<html>
<head>
<title>How to efficiently use Stencil Web Components in React (with typings)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中有效地使用模板Web组件(带类型)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-stencil-web-components-in-react-within-a-nx-monorepo-d6644f6ee858?source=collection_archive---------2-----------------------#2020-05-31">https://javascript.plainenglish.io/how-to-use-stencil-web-components-in-react-within-a-nx-monorepo-d6644f6ee858?source=collection_archive---------2-----------------------#2020-05-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="afd0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章描述了如何通过生成的React包装器和类型在React <strong class="jp ir">中有效地使用你的<a class="ae kl" href="https://stenciljs.com/" rel="noopener ugc nofollow" target="_blank">模板Web组件</a>。</strong>这给了你对TypeScript和JSX的完全支持。此外，这种方法还克服了React和定制元素之间通信的弱点。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/8ac2d85248c7c275d04ba21c26b68d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qPO_UlEgb_1sQ2xLF1uYQA.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Stencil Web Components in React with generated React wrappers and bindings for TypeScript</figcaption></figure></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="222c" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">为什么是模板</h2><p id="8501" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">首先，使用Stencil构建组件库的动机是Stencil向下编译符合标准的Web组件/自定义元素，同时它为Angular、Vue或React等流行的库提供了<a class="ae kl" href="https://stenciljs.com/docs/overview" rel="noopener ugc nofollow" target="_blank">框架集成</a>。这使得它与框架无关，经得起未来考验，并使前端架构能够拥有多个应用程序，这些应用程序使用不同的技术堆栈。在本文中，我们将探讨如何在React中有效地使用模板组件库:</p><h2 id="b3ba" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">考虑</h2><p id="f1c6" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">GitHub上的<a class="ae kl" href="https://github.com/ionic-team/stencil-ds-react-template" rel="noopener ugc nofollow" target="_blank">Stencil-ds-react-template</a>文档建议您在生成React绑定之前先将模板组件发布到npm。这不适合我的工作流程，因为我喜欢避免发布包和处理版本管理。相反，我更喜欢有一个monorepo，其中包含我所有的库和应用程序。这就是为什么我大量使用TypeScript的<a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/module-resolution.html" rel="noopener ugc nofollow" target="_blank">路径映射</a>特性，它允许我的库导入到应用程序中，而不需要发布它们。对于React绑定来说，路径映射也是一个很好的特性，正如您将看到的，这使得路径映射成为一个简单的任务。</p><h2 id="c926" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">工具作业🚀</h2><p id="4a98" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">我想为我的模板组件生成React包装器的原因不仅仅是因为<a class="ae kl" href="https://custom-elements-everywhere.com/" rel="noopener ugc nofollow" target="_blank">简化了React和定制元素</a>之间的交互(例如，你不能优雅地传递复杂的数据)，还因为开发速度和生产率，因为我不想自己编写和更新粘合代码。这就是Nx 的用武之地。</p><h2 id="fb0e" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">Nx monorepo，带React和Stencil ️</h2><p id="2cb3" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">Nx是一个用于monorepo开发的开源工具包，可以帮助您搭建项目、生成应用程序或库，并且在许多其他事情中，它还可以智能地构建monorepo中受影响的更改。</p><p id="3ce1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您还没有使用Nx，您可以通过运行以下命令来尝试一下，该命令将引导您完成使用React应用程序创建monorepo工作区的过程:</p><pre class="kn ko kp kq gt mh mi mj mk aw ml bi"><span id="06bb" class="lj lk iq mi b gy mm mn l mo mp">npx create-nx-workspace@latest<br/><br/>? Workspace name (e.g., org name)     yourcompany<br/>? What to create in the new workspace react<br/>? Application name                    frontend1<br/>? Default stylesheet format           SASS(.scss)<!-- --> </span></pre><p id="376c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这为我们提供了一个非常清晰的文件夹结构，其中包含了测试和运行React应用程序的所有内容。除了Jest单元测试，Nx还使用Cypress搭建了一个完整的端到端测试项目(E2E)。</p><p id="6096" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当您安装一个名为Nx Console 的<a class="ae kl" href="https://marketplace.visualstudio.com/items?itemName=nrwl.angular-console" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码扩展时，Nx的威力会变得更加明显，它为您提供了一个GUI，其中包含一些有用的命令来服务/构建/测试/生成/输出您的代码:</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/fe982d8f3bfdf05aa61916bd03eb5f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:712/format:webp/1*W3fShfASbcawXaP_mnWpgg.png"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Nx Console Visual Studio Code</figcaption></figure><p id="4e44" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些，让我们在Nx和一个<a class="ae kl" href="https://github.com/DominikPieper/nx-extensions" rel="noopener ugc nofollow" target="_blank">优秀的模板插件</a>的帮助下生成我们的模板库(感谢张秀坤·派珀):</p><ol class=""><li id="56fa" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk mw mx my mz bi translated"><code class="fe na nb nc mi b">yarn add @nxext/stencil -D</code></li><li id="605e" class="mr ms iq jp b jq nd ju ne jy nf kc ng kg nh kk mw mx my mz bi translated">使用Nx控制台为您生成模板库(见下图)。我将模板库命名为<code class="fe na nb nc mi b">ui-components</code>，我们稍后会用到它。如果你想不用Nx控制台，执行下面的命令:<code class="fe na nb nc mi b">nx generate @nxext/stencil:library --name=ui-components --style=scss</code></li></ol><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ni"><img src="../Images/ccfb5c8c65fc6adc142f4047ab2a8a8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7DvWLNFC18mqBPuycJBlpw.gif"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Generate a Stencil library using the Nx Console</figcaption></figure><p id="262f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Nx刚刚生成了一个libs文件夹，其中包含一个名为ui-components的模板项目，其中包含一个组件<code class="fe na nb nc mi b">my-component</code>。我们已经可以构建项目来获得一个dist文件夹，其中包含我们可以在任何现代浏览器中使用的已编译的定制元素，而无需加载框架。但是我们现在真正感兴趣的是为我们的Web组件生成一个React包装器，所以让我们开始吧。</p><h2 id="36ef" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">生成React绑定</h2><p id="d3ee" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">模板项目就绪后，我们要生成React绑定所要做的就是以下步骤:</p><ul class=""><li id="1944" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk nj mx my mz bi translated">决定一个(虚拟)包名，您希望在该包名下公开您的模具组件库。你可能已经想到了你刚刚输入的用于创建模板项目的库名，所以在我的例子中，我将使用<strong class="jp ir"> ui-components </strong>。如果您在没有Nx搭建的情况下使用了模板CLI(NPM init模板组件),这也很好，尽管下面提到的路径可能会因项目搭建的不同而略有不同。在任何情况下，最重要的一点是决定一个包名，我们稍后将使用该包名进行TypeScript的路径映射，以使我们的库无需发布即可访问。</li><li id="a6c2" class="mr ms iq jp b jq nd ju ne jy nf kc ng kg nh kk nj mx my mz bi translated">安装@stencil/react-output-target作为开发依赖:<code class="fe na nb nc mi b">yarn add @stencil/react-output-target -D</code></li><li id="152c" class="mr ms iq jp b jq nd ju ne jy nf kc ng kg nh kk nj mx my mz bi translated">更新<code class="fe na nb nc mi b">stencil.config.ts</code>并添加<code class="fe na nb nc mi b">reactOutputTarget</code>。这个目标需要以下信息:在哪个包名下你的模板组件是可访问的(使用我们刚刚决定的名字)以及你想把生成的React包装器，别名proxiesFile放在哪里。这是我的模板配置的结果:</li></ul><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Stencil component library with React bindings</figcaption></figure><ul class=""><li id="83bb" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk nj mx my mz bi translated">注意，在我的monorepo中，为了清晰起见，我喜欢将React包装器输出到名为generated的顶级文件夹中。这是一个仅包含生成的源代码的文件夹，因此不应提交。所以让我们用<strong class="jp ir">更新我们的</strong> <code class="fe na nb nc mi b"><strong class="jp ir">.gitignore</strong></code> <strong class="jp ir">来忽略</strong> <code class="fe na nb nc mi b"><strong class="jp ir">/generated</strong></code>内的所有内容。此外，Stencil支持与多个框架集成，这就是为什么我将生成的代码放在另一个名为<code class="fe na nb nc mi b">ui-components-react</code>的文件夹中，只是为了给它一个明确的范围和清晰的隔离。</li><li id="93fd" class="mr ms iq jp b jq nd ju ne jy nf kc ng kg nh kk nj mx my mz bi translated">我还添加了esmLoaderPath选项，该选项将生成另一个名为<code class="fe na nb nc mi b">loader</code>的文件夹，React组件需要该文件夹来加载自定义元素的定义并引导它们。因此，这个加载器是创建我们的包装React组件的关键构建块。为了保持整洁，我将这个加载器放在dist文件夹中，就像编译后的Web组件一样。</li></ul><h2 id="30c9" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">路径映射</h2><p id="5086" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">生成绑定后，我们最终得到三个包:</p><ul class=""><li id="df71" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk nj mx my mz bi translated"><code class="fe na nb nc mi b">ui-components</code>我们的核心模板组件</li><li id="bfd1" class="mr ms iq jp b jq nd ju ne jy nf kc ng kg nh kk nj mx my mz bi translated"><code class="fe na nb nc mi b">ui-components-react</code>生成的反应组分</li><li id="2b95" class="mr ms iq jp b jq nd ju ne jy nf kc ng kg nh kk nj mx my mz bi translated"><code class="fe na nb nc mi b">ui-components/loader</code>生成的加载器充当我们的定制元素和React包装器之间的桥梁</li></ul><p id="1d85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在不发布这些包，而是简单地将正确的路径映射添加到monorepo 中最外层的<code class="fe na nb nc mi b"><a class="ae kl" href="https://github.com/Mobiletainment/Nx-Stencil-React/blob/master/tsconfig.json" rel="noopener ugc nofollow" target="_blank">tsconfig.json</a></code> <a class="ae kl" href="https://github.com/Mobiletainment/Nx-Stencil-React/blob/master/tsconfig.json" rel="noopener ugc nofollow" target="_blank">。这允许从monorepo中的任何库或应用程序中按名称导入这些包，因为它只是将导入映射到给定的源代码位置:</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi nm"><img src="../Images/44cfd20f0c9eb9662bdfdca545f6f8ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Bb8ms-yZzNFyEV685QcGg.png"/></div></div></figure><p id="558f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经可以在react应用程序中使用ui-components-react包:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="nk nl l"/></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">React app that uses Stencil components with type safe bindings and full framework integration</figcaption></figure><p id="2534" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，我们没有使用my-component定制元素，而是使用它生成的React derivative<code class="fe na nb nc mi b">MyComponent</code>。TypeScript将自动选择为MyComponent生成的接口，以便我们能够以类型安全的方式设置props和事件处理程序。最重要的是，Stencil的粘合代码允许我们将复杂的数据，如对象和数组传递给定制元素，从而减轻了我们在React 中处理<a class="ae kl" href="https://custom-elements-everywhere.com/libraries/react/results/results.html" rel="noopener ugc nofollow" target="_blank">定制元素时通常会遇到的问题。</a></p><h2 id="5364" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">额外提示:模板自定义元素和笑话</h2><p id="563e" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">模板的当前分发包依赖于<code class="fe na nb nc mi b">CSSStyleSheet</code>的替换方法在组件初始化期间注册样式。虽然这在现代浏览器环境中可能没问题，但目前在用Jest执行测试时会导致错误。幸运的是，有一个多填充物可以拯救我们:</p><ul class=""><li id="4f99" class="mr ms iq jp b jq jr ju jv jy mt kc mu kg mv kk nj mx my mz bi translated"><code class="fe na nb nc mi b">yarn add construct-style-sheets-polyfill -D</code></li><li id="66d5" class="mr ms iq jp b jq nd ju ne jy nf kc ng kg nh kk nj mx my mz bi translated">将polyfill添加到jest.config.js中的setup文件:</li></ul><pre class="kn ko kp kq gt mh mi mj mk aw ml bi"><span id="5a4f" class="lj lk iq mi b gy mm mn l mo mp">module.exports = {<br/>  setupFiles: ['construct-style-sheets-polyfill'],<br/>  ...</span></pre></div><div class="ab cl lc ld hu le" role="separator"><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh li"/><span class="lf bw bk lg lh"/></div><div class="ij ik il im in"><h2 id="78d9" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated">源代码</h2><p id="7a3f" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">你可以在GitHub上查看完整的工作示例:<a class="ae kl" href="https://github.com/Mobiletainment/Nx-Stencil-React" rel="noopener ugc nofollow" target="_blank">https://github.com/Mobiletainment/Nx-Stencil-React</a></p><p id="049c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，所描述的过程可能会随着未来的软件包更新而改变。撰写本文时使用的软件包版本是:</p><pre class="kn ko kp kq gt mh mi mj mk aw ml bi"><span id="0b5d" class="lj lk iq mi b gy mm mn l mo mp">"@nrwl/react": "9.3.0",<br/>"@nrwl/workspace": "9.3.0",<br/>"@nxext/stencil": "0.0.13",<br/>"@stencil/core": "1.14.0",<br/>"@stencil/react-output-target": "0.0.6",<br/>"construct-style-sheets-polyfill": "2.3.5",<br/>"document-register-element": "1.14.3",<br/>"react": "16.13.1",<br/>"react-dom": "16.13.1",<br/>"typescript": "~3.9.3"</span></pre><h2 id="f01d" class="lj lk iq bd ll lm ln dn lo lp lq dp lr jy ls lt lu kc lv lw lx kg ly lz ma mb bi translated"><strong class="ak">用简单英语写的便条</strong></h2><p id="3bcd" class="pw-post-body-paragraph jn jo iq jp b jq mc js jt ju md jw jx jy me ka kb kc mf ke kf kg mg ki kj kk ij bi translated">你知道我们推出了一个YouTube频道吗？我们制作的每个视频都旨在教给你一些新的东西。点击此处 查看我们，并确保订阅该频道😎</p></div></div>    
</body>
</html>