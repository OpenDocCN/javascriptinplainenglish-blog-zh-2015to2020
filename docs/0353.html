<html>
<head>
<title>Algorithms 101: Convert Roman Numerals to Integers in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:在JavaScript中将罗马数字转换成整数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-101-convert-roman-numerals-to-integers-in-javascript-d3aba86a43d4?source=collection_archive---------5-----------------------#2019-09-23">https://javascript.plainenglish.io/algorithms-101-convert-roman-numerals-to-integers-in-javascript-d3aba86a43d4?source=collection_archive---------5-----------------------#2019-09-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="728d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Noob诉LeetCode第6集</h2></div><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi gj"><img src="../Images/7022dac6cdd1352e3be1ce12a395bf14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6a7K9ETG5DlQr_PE.jpg"/></div></div></figure><p id="6687" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在我不断寻求解决LeetCode中“简单”算法问题的过程中，我遇到了将罗马数字转换成整数的挑战<a class="ae lm" href="https://leetcode.com/problems/roman-to-integer/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="b5e2" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">LeetCode示例:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi ln"><img src="../Images/1a92176d80e788e3ef9cce0598674055.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Uc_r1p9agsJrQUUXkf7lw.png"/></div></div></figure><p id="d599" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">幸运的是，我正和我的丈夫开车长途回家，他是一名软件工程师，已经习惯了这类难题。我们讨论的第一件事是如何知道何时从后面的数字中减去一个罗马数字。</p><p id="dd5f" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我在想，如果是一个“I”后面跟着一个“V ”,我们就要减去。哦，对了，如果是“X”前面的“I ”,我们也要减去。等等，等等，天啊，这将会是一个很长的列表，关于什么时候要减去。</p><p id="630e" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我的犯罪搭档有一个更好、更抽象的方法:如果我们看到的罗马数字与下一个相同或相等，我们可以把它加到总数中。如果它小于下一个，我们将从下一个中减去它，然后将结果加到总数中。</p><p id="d34a" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你已经看到了捷径，对你有好处。如果没有，请容忍我！</p><p id="3af3" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lo">注意:根据你的反馈，我从最初的帖子开始重构了这段代码，使代码和帖子更容易阅读。</em></p><h1 id="33e7" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">分解它</h1><p id="0ff2" class="pw-post-body-paragraph kq kr iq ks b kt mh jr kv kw mi ju ky kz mj lb lc ld mk lf lg lh ml lj lk ll ij bi translated">我们一到家，我就拿出电脑，把问题分解成更小的问题。我必须想出如何:</p><ol class=""><li id="4900" class="mm mn iq ks b kt ku kw kx kz mo ld mp lh mq ll mr ms mt mu bi translated">将单个罗马数字转换为相应的数值</li><li id="5ee8" class="mm mn iq ks b kt mv kw mw kz mx ld my lh mz ll mr ms mt mu bi translated">设定何时加减的规则</li><li id="0d68" class="mm mn iq ks b kt mv kw mw kz mx ld my lh mz ll mr ms mt mu bi translated">返回总计</li></ol><h1 id="12ea" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">第一步。将单个罗马数字转换为数值</h1><p id="5016" class="pw-post-body-paragraph kq kr iq ks b kt mh jr kv kw mi ju ky kz mj lb lc ld mk lf lg lh ml lj lk ll ij bi translated">我知道我希望“I”等于1，“V”等于5，等等。</p><p id="7b68" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所以我试了一长串常量:</p><pre class="kf kg kh ki gt na nb nc nd aw ne bi"><span id="edc5" class="nf lq iq nb b gy ng nh l ni nj">const “I” = 1<br/>const “V” = 5<br/>etc.</span></pre><p id="582e" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">问题是，“I”是字符串，不是变量。如果你想把它转换成一个变量，有很多关于如何做的相互矛盾的建议。我想让事情尽可能简单。经过许多死胡同，我决定在哈希。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi nk"><img src="../Images/079df26c32acac9c64b01194f1d75e30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5I5zdv3l005Z7F8q_LJThw.png"/></div></div></figure><p id="c101" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个谜题的测试用例输入是“III”。我知道我要单独查看这些“I”中的每一个，所以我把字符串分成一个数组:</p><p id="0169" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe nl nm nn nb b">let array = s.split('')</code></p><p id="c034" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这给了我:<code class="fe nl nm nn nb b">["I", "I", "I"]</code></p><p id="68bb" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在，我必须检查每个元素，找到它的换算值，然后将该值加或减到一个名为total的计数器中。</p><h1 id="a760" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">修订步骤2:说明如何将每个数值相加得到一个总数。</h1><p id="055c" class="pw-post-body-paragraph kq kr iq ks b kt mh jr kv kw mi ju ky kz mj lb lc ld mk lf lg lh ml lj lk ll ij bi translated">我决定先写一个程序，简单地将每个字符的值加到一个总数中，而不是为何时加减设定规则。</p><p id="1e74" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我从这个开始:</p><pre class="kf kg kh ki gt na nb nc nd aw ne bi"><span id="1321" class="nf lq iq nb b gy ng nh l ni nj">//test value:<br/>s = "III"</span><span id="0a76" class="nf lq iq nb b gy no nh l ni nj">array = s.split('')</span><span id="4844" class="nf lq iq nb b gy no nh l ni nj">//set a counter called 'total' with an initial value of zero:<br/>let total = 0<br/>       <br/>for(let i = 0; i &lt; array.length; i++){<br/>   total += conversion[array[i]]  <br/> }<br/>       <br/>return total</span><span id="835d" class="nf lq iq nb b gy no nh l ni nj">// =&gt; 3</span></pre><p id="0a34" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">好啊，我的测试用例成功了！至少我走了这么远…</p><h1 id="2720" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">修订步骤3。弄清楚什么时候做加法，什么时候做减法以及如何做减法</h1><p id="0a62" class="pw-post-body-paragraph kq kr iq ks b kt mh jr kv kw mi ju ky kz mj lb lc ld mk lf lg lh ml lj lk ll ij bi translated">早些时候，我已经决定如果一个值大于下一个值，就给我的总数加一个值；否则我会从下一个值中减去它，然后把结果加到我的总数中。</p><p id="a784" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所以我写了一个比较当前值和下一个值的方法。</p><p id="02bb" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果我的数组中的当前元素是<code class="fe nl nm nn nb b">array[i]</code>，那么下一个值就是<code class="fe nl nm nn nb b">array[i+1].</code></p><p id="d9bc" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果<code class="fe nl nm nn nb b">array[i]</code>的数值为<code class="fe nl nm nn nb b">conversion[array[i]]</code></p><p id="fa6d" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">则<code class="fe nl nm nn nb b">array[i+1]</code>的数值为<code class="fe nl nm nn nb b">conversion[array[i+1]]</code></p><p id="bc79" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所以如果我们想看看当前的值是否大于或等于下一个值，我们可以这样写:</p><pre class="kf kg kh ki gt na nb nc nd aw ne bi"><span id="b357" class="nf lq iq nb b gy ng nh l ni nj">if(<!-- -->conversion[array[i] &gt;= conversion[array[i+1]] ...</span><span id="9992" class="nf lq iq nb b gy no nh l ni nj">//feeling dizzy??</span></pre><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi np"><img src="../Images/80f7319dcf460e3072f55f0c3d61dc21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_WH4_G-u5-VSaRQI.jpg"/></div></div></figure><p id="51d0" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这种代码感觉就像一个镜子房子！为了让我更容易理解，我添加了几个变量:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi nq"><img src="../Images/62110e720d1f48dfd39baa3910e72bb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bpGmLREfaeZPZfVMhoMYlQ.png"/></div></div></figure><p id="b19a" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这样就更容易写下一部分:</p><pre class="kf kg kh ki gt na nb nc nd aw ne bi"><span id="75f3" class="nf lq iq nb b gy ng nh l ni nj">if (currentValue &gt;= nextValue ){<br/>       // add current value to total</span><span id="58c0" class="nf lq iq nb b gy no nh l ni nj">       } else if (currentValue &lt; nextValue) {<br/>       //subtract current value from next value and add result to total ?<br/></span><span id="74f8" class="nf lq iq nb b gy no nh l ni nj">        }</span></pre><h1 id="efaa" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">IX的问题在于……</h1><p id="6d49" class="pw-post-body-paragraph kq kr iq ks b kt mh jr kv kw mi ju ky kz mj lb lc ld mk lf lg lh ml lj lk ll ij bi translated">我们的<em class="lo"> for loop </em>设置为一次处理一个元素，决定如何使用它来更改总计，然后继续处理下一个元素。但在代码的“else if”部分，我们跳过了这一步，一次处理两个值，数组[i]和数组[i+1]。</p><p id="42b4" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">举个例子。如果我们把“I”跟在“X”后面，我们就把“I”翻译成1，把“X”翻译成10。遵循我们的规则，由于1小于10，我们从10中减去1，得到9的结果；然后我们将总数加9。</p><p id="b223" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但在下一个循环中，我们当前的元素是前一个“next”元素，即值为10的“X”。但在最后一个循环中，我们已经将这10个因素考虑在内了。如果我们再考虑同样的10，我们将扔掉我们的总数！</p><h1 id="9626" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">掉进兔子洞</h1><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="d704" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这提供了一个绝佳的机会，深入了解兔子洞。我在考虑将else语句中的<em class="lo"> i </em>增加2，这时我意识到……</p><p id="18e4" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我不必同时处理两种价值观。如果“I”在“X”之前，(或“C”在“D”之前等)。)我可以简单地从总数中减去它的数值，然后在下一个循环中将该数值与“后面的罗马数字”相加。</p><p id="59ac" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lo">当初我为什么要反过来做呢？</em>因为我的思维太过依赖字面意义:罗马数字中的“IX”是9，所以我觉得必须将这些字符作为一对进行分析，而不是简单地减去1，再加上10。</p><h1 id="a3d6" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">修订步骤4:返回总计</h1><p id="ac72" class="pw-post-body-paragraph kq kr iq ks b kt mh jr kv kw mi ju ky kz mj lb lc ld mk lf lg lh ml lj lk ll ij bi translated">在我的for循环之后，我返回了总数。以下是这一点的全部功能:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi nt"><img src="../Images/d654d53a7614bb7566217e337c3e7811.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3bgR90WVHLQ71fo7OdklKA.png"/></div></div></figure><h1 id="d61f" class="lp lq iq bd lr ls lt lu lv lw lx ly lz jw ma jx mb jz mc ka md kc me kd mf mg bi translated">重构</h1><p id="8636" class="pw-post-body-paragraph kq kr iq ks b kt mh jr kv kw mi ju ky kz mj lb lc ld mk lf lg lh ml lj lk ll ij bi translated">最大的改进来自清理解决方案的这一部分:</p><pre class="kf kg kh ki gt na nb nc nd aw ne bi"><span id="2949" class="nf lq iq nb b gy ng nh l ni nj">if (currentValue &gt;= nextValue ){<br/>            total += (currentValue);<br/>        } else if (currentValue &lt; nextValue) {<br/>            total -= (currentValue);  <br/>        } else if (currentValue &amp;&amp; !nextValue) {<br/>            total += currentValue<br/>        }</span></pre><p id="d082" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我原来是这样写的:</p><pre class="kf kg kh ki gt na nb nc nd aw ne bi"><span id="017b" class="nf lq iq nb b gy ng nh l ni nj">if (currentValue &gt;= nextValue ){<br/>            total += (currentValue);<br/>        } else if (currentValue &lt; nextValue) {<br/>            total -= (currentValue);  <br/>        } </span></pre><p id="21a9" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但这种方法并不奏效，因为出现了“边缘”情况，即<em class="lo"> currentValue </em>是数组中的最后一个值。出现这种情况时，没有<em class="lo"> nextValue </em>可比较，因此代码跳过了对最后一个值的评估。这就是为什么我补充说:</p><pre class="kf kg kh ki gt na nb nc nd aw ne bi"><span id="5014" class="nf lq iq nb b gy ng nh l ni nj">else if (currentValue &amp;&amp; !nextValue) {<br/>            total += currentValue<br/>        }</span></pre><p id="da74" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">即，如果没有下一个值，则前进并将当前值加到总数中。</p><p id="cdbe" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但是……这大大降低了代码的速度。浏览LeetCode上的其他解决方案时，我注意到<a class="ae lm" href="https://leetcode.com/problems/roman-to-integer/discuss/373357/Simple-javascript-solution" rel="noopener ugc nofollow" target="_blank">来自hadleyac </a> <em class="lo">的这个解决方案(老实说，直到我自己编写代码时我才看到它！字面意思是几分钟前弹出来的…) </em>，它采用了同样的方法，但以更干净的方式处理了if语句。所以我重构了:</p><pre class="kf kg kh ki gt na nb nc nd aw ne bi"><span id="432d" class="nf lq iq nb b gy ng nh l ni nj">if (currentValue &lt; nextValue ){<br/>            total -= (currentValue);<br/>        } else {<br/>            total += (currentValue);  <br/>        }</span></pre><p id="0bd3" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这涵盖了<em class="lo">当前值</em>也是最后一个值的情况。</p><p id="60b7" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在一起:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi nu"><img src="../Images/9742aef85c36c5408f4e323a12c447a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z08hli-05MWtm8gcKDLgWQ.png"/></div></div></figure><p id="0805" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="lo">注:</em>作为一个noob，我的本能是把所有和函数有关的东西都放在函数里面；感谢克里斯多佛·马戴尔<a class="ae lm" href="https://medium.com/@truffula" rel="noopener">https://medium.com/@truffula</a>的评论，他说散列可以放在函数之外，这样就不会在每次函数运行时被调用！</p><p id="90c1" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">不算太寒酸:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="kk kl di km bf kn"><div class="gh gi nv"><img src="../Images/7d7737dc60955616d90dc9a32f942b73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILIJUGQHV97J_QeJZNFKSQ.png"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk">ps, wait a few seconds and run it again and you might beat 95% …..</figcaption></figure><p id="366c" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">版权所有琼·印第安纳·琳斯2019</p><p id="d6e3" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://medium.com/@joanrigdon/algorithms-101-house-robber-in-javascript-da3e6ee36241" rel="noopener"> <em class="lo">接下来:算法101，第七集:JavaScript中的入室抢劫犯</em> </a></p><p id="4ac6" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://medium.com/@joanrigdon/algorithms-101-goat-latin-in-javascript-d388cc29dc73" rel="noopener"> <em class="lo">以防你错过:算法101，第5集:JavaScript中的山羊拉丁语</em> </a></p></div></div>    
</body>
</html>