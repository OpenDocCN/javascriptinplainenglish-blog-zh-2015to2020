<html>
<head>
<title>Unit Testing Angular — Component Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">单元测试角度-组件测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/unit-testing-angular-component-testing-f0c478de3dd8?source=collection_archive---------6-----------------------#2020-02-15">https://javascript.plainenglish.io/unit-testing-angular-component-testing-f0c478de3dd8?source=collection_archive---------6-----------------------#2020-02-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0fe45665a0b3fda6b43c9711f3d19b2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Vl1m3j6meyZSleK3.jpg"/></div></div></figure><p id="9299" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们每天都看到向我们的应用程序添加自动化测试的更大推动力。无论这些是单元测试、集成测试还是e2e测试。</p><p id="0779" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将是基于为Angular和它的一些核心概念编写单元测试的一系列文章:组件、服务、管道和防护。</p><p id="a950" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些文章并不打算包罗万象，而是对单元测试的一个软介绍。对于更详细的组件测试文档，Angular有一个很棒的文档页面:<a class="ae kw" href="https://angular.io/guide/testing" rel="noopener ugc nofollow" target="_blank">https://angular.io/guide/testing</a></p><p id="001b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的是，我的一些固执己见的测试方法将会在本文中出现。测试已经是一个非常热门的话题了。我的建议是浏览所有的测试策略，然后决定你认为什么是最好的方法。</p><p id="13ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将探索测试组件，从简单到更复杂的组件，我们将涵盖以下内容:</p><ul class=""><li id="a5e9" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">什么是单元测试？💡</li><li id="9b64" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">为什么要编写单元测试？🤔</li><li id="3124" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">好了，现在我们如何编写单元测试呢？😄</li></ul><p id="208d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用标准的Jasmine和Karma测试设置，这是Angular在使用Angular CLI生成的应用程序上提供的现成设置。</p><h1 id="af32" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">💡什么是单元测试？</h1><p id="49bb" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">单元测试是一种软件测试，它验证代码的一个独立部分(单元)的正确性。</p><p id="4128" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设你有一个简单的加法函数:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f762" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个完整的函数可以被认为是一个单元，因此您的测试将验证这个单元是正确的。对该单元的快速测试可以是:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="f876" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里介绍几个概念。<br/><code class="fe mv mw mx my b">it(...args)</code>是建立我们的单元测试的函数。这是测试跑步者中非常常见的测试术语。</p><p id="b711" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还介绍了AAA测试模式。这是一种将你的测试分成3个部分的模式。</p><p id="10ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一部分是<strong class="ka ir">安排</strong>:在这里你执行你的测试所需的任何设置。</p><p id="289a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二部分是<strong class="ka ir"> Act </strong>:在这里，您将让您的代码执行您想要测试的动作。</p><p id="855e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第三个也是最后一个选项是<strong class="ka ir">断言</strong>:这里您将验证单元是否按预期执行。</p><p id="c742" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的测试中，我们设置了函数正确执行时的预期值，并且设置了将用于测试函数的数据。</p><p id="dadf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们对之前安排的测试数据调用<code class="fe mv mw mx my b">sum()</code>函数，并将结果存储在<code class="fe mv mw mx my b">total</code>变量中。</p><p id="a819" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们检查<code class="fe mv mw mx my b">total</code>是否与我们期望的值相同。</p><p id="6207" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果是的话，测试就会通过，这要感谢我们使用了<code class="fe mv mw mx my b">expect()</code>方法。</p><p id="d834" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">注:</em> <code class="fe mv mw mx my b"><em class="kx">.toBe()</em></code> <em class="kx">是matcher函数。匹配器函数检查传递到</em> <code class="fe mv mw mx my b"><em class="kx">expect()</em></code> <em class="kx">函数的值是否与期望的结果匹配。Jasmine附带了很多匹配器函数，可以在这里查看:</em><a class="ae kw" href="https://jasmine.github.io/api/3.5/matchers.html" rel="noopener ugc nofollow" target="_blank"><em class="kx">Jasmine Matchers</em></a></p><h1 id="c376" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">🤔但是为什么呢？</h1><p id="b90a" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">轻松点。对变化的信心。</p><p id="6fc2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一名开发人员，您一直在对代码库进行修改。但是，如果没有测试，你怎么知道你没有在你的应用程序的不同区域做出破坏功能的改变呢？</p><p id="2fef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以尝试手动测试应用程序中每个可能的区域和场景。但是这会消耗你的开发时间，最终影响你的生产力。</p><p id="fbfa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您可以简单地运行一个命令来检查您应用程序的所有区域，以确保一切仍按预期运行，那么效率会高得多。对吗？</p><p id="07aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这正是自动化单元测试的目标，尽管在编写测试时，您会花费更多的时间来开发特性或修复bug，但如果您将来不得不更改功能或重构代码，您会将这些时间争取回来。</p><p id="8bc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个好处是，任何跟在你后面的开发人员都可以使用你写的测试套件作为你写的代码的文档。如果他们不明白如何在代码中使用一个类或一个方法，测试会告诉他们如何使用！</p><p id="825d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">需要注意的是，这些好处来自于</em> <strong class="ka ir"> <em class="kx">写得好的</em> </strong> <em class="kx">测试。稍后我们将探讨好的和坏的测试之间的区别。</em></p><h1 id="37ba" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">😄让我们写一个角度分量测试</h1><p id="f087" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我们将把它分成一系列步骤，涵盖以下测试场景:</p><ul class=""><li id="c955" class="ky kz iq ka b kb kc kf kg kj la kn lb kr lc kv ld le lf lg bi translated">只有输入和输出的简单组件</li><li id="f12e" class="ky kz iq ka b kb lh kf li kj lj kn lk kr ll kv ld le lf lg bi translated">具有DI提供者的复杂组件</li></ul><p id="ee17" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从一个只有输入和输出的简单组件开始。纯粹的表象成分。</p><h1 id="37b6" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">🖼️表象成分测试</h1><p id="1c26" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我们将从一个非常简单的组件<code class="fe mv mw mx my b">user-speak.component.ts</code>开始，它有一个输入和一个输出。它将显示用户的名字，并有两个按钮允许用户回话:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="cc35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您使用Angular CLI <em class="kx">(强烈推荐！)</em>为了生成你的组件，你将得到一个现成的测试文件。如果没有，创建一个<code class="fe mv mw mx my b">user-speak.component.spec.ts</code>。</p><p id="71e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">注意:</em> <code class="fe mv mw mx my b"><em class="kx">.spec.ts</em></code> <em class="kx">很重要。这就是测试运行人员知道如何找到您的测试的方法！</em></p><p id="b932" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后在内部，确保它最初看起来像这样:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="8101" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们解释一下这里发生了什么。</p><p id="28d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mv mw mx my b">describe('UserSpeakComponent', () =&gt; ...)</code>调用为我们的User Speak组件建立了一个测试套件。它将包含我们希望为我们的组件执行的所有测试。</p><p id="0612" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mv mw mx my b">beforeEach()</code>调用指定了在每次测试运行之前应该执行的代码。使用Angular，我们必须告诉编译器如何正确地解释和编译我们的组件。这就是<code class="fe mv mw mx my b">TestBed.configureTestingModule</code>的用武之地。对于这个特定的组件测试，我们不会涉及太多的细节，但是，在本文的后面，我们将描述当我们的组件中有DI提供者时，如何改变它。</p><p id="1956" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">关于这方面的更多信息，请查看</em> <a class="ae kw" href="https://angular.io/guide/testing" rel="noopener ugc nofollow" target="_blank"> <em class="kx">角度测试文档</em> </a></p><p id="08ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个<code class="fe mv mw mx my b">it()</code>调用都会为测试运行人员创建一个新的测试来执行。</p><p id="cfd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们目前只有一个测试。这个测试检查我们的组件是否创建成功。这几乎就像一个健全性检查，以确保我们已经为我们的组件正确地设置了<code class="fe mv mw mx my b">TestBed</code>。</p><p id="2b62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们知道我们的组件类有一个<code class="fe mv mw mx my b">constructor</code>和两个方法<code class="fe mv mw mx my b">sayHello</code>和<code class="fe mv mw mx my b">sayGoodbye</code>。由于构造函数是空的，我们不需要测试它。但是，另外两个方法确实包含逻辑。</p><p id="c5c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以认为这些方法中的每一个都是需要测试的单元。因此，我们将为它们编写两个单元测试。</p><p id="f22b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">应该记住，当我们编写单元测试时，我们希望它们是独立的。本质上，这意味着它应该是完全独立的。如果我们仔细观察我们的方法，可以看到它们在组件的<code class="fe mv mw mx my b">speak</code> EventEmitter上调用<code class="fe mv mw mx my b">emit</code>方法。</p><p id="985d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的单元测试对<code class="fe mv mw mx my b">emit</code>功能是否正常工作不感兴趣，相反，我们只想确保我们的方法恰当地调用了<code class="fe mv mw mx my b">emit</code>方法:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="aa53" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们遇到了<code class="fe mv mw mx my b">spyOn</code>函数，它允许我们模拟出<code class="fe mv mw mx my b">emit</code>调用的实际实现，并创建一个<a class="ae kw" href="https://jasmine.github.io/api/3.5/global.html#spyOn" rel="noopener ugc nofollow" target="_blank"> Jasmine Spy </a>，然后我们可以用它来检查是否进行了<code class="fe mv mw mx my b">emit</code>调用，以及向它传递了什么参数，从而允许我们单独检查我们的单元是否正确执行。</p><p id="e0a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们从命令行运行<code class="fe mv mw mx my b">ng test</code>，我们将看到测试正确通过。太棒了。</p><h1 id="cd52" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">🔧重构</h1><p id="c04d" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">停下来。拥有两个本质上做同样事情的方法会复制大量代码。让我们重构我们的代码，让它变得更加枯燥:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="20fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太棒了，这样好多了。让我们再次运行测试:<code class="fe mv mw mx my b">ng test</code>。</p><p id="b450" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">啊哦！😱</p><p id="4c04" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试失败了！</p><p id="da7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的单元测试能够正确地捕捉到我们改变了功能，并且潜在地破坏了一些先前工作的功能。💪</p><p id="d5ff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们更新我们的测试，以确保它们继续为我们的新逻辑工作:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="7979" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经删除了之前的两个测试，并用一个新的测试更新了它。这个测试确保传递给<code class="fe mv mw mx my b">saySomething</code>方法的任何字符串都将被传递给<code class="fe mv mw mx my b">emit</code>调用，允许我们测试Say Hello按钮和Say Goodbye。</p><p id="e5eb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">厉害！🚀</p><p id="7c64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">注意:围绕在单元测试中测试JSDOM有一个争论。我个人反对这种方法，因为我觉得它更像是一个集成测试，而不是单元测试，应该与你的单元测试套件分开。</em></p><p id="8fa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们继续:</p><h1 id="30bd" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">🤯复杂组件测试</h1><p id="0b5a" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">现在我们已经看到了如何测试一个纯粹的表示性组件，让我们来看看测试一个注入了阿迪提供者的组件。</p><p id="de5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对此有几种方法，所以我将展示我倾向于采用的方法。</p><p id="792d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个注入了<code class="fe mv mw mx my b">UserService</code>的<code class="fe mv mw mx my b">UserComponent</code>:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4177" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相当简单，除了我们已经将<code class="fe mv mw mx my b">UserService</code>注入到我们的组件中。</p><p id="20ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，让我们建立我们的初始测试文件<code class="fe mv mw mx my b">user.component.spec.ts</code>:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="9732" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们现在运行<code class="fe mv mw mx my b">ng test</code>，它会失败，因为我们缺少<code class="fe mv mw mx my b">UserService</code>的提供者，因此<code class="fe mv mw mx my b">TestBed</code>不能正确地注入它来成功地创建组件。</p><p id="a082" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们必须编辑设置的<code class="fe mv mw mx my b">TestBed</code>,以允许我们正确创建组件。请记住，我们正在编写单元测试，因此只想孤立地运行这些测试，并不关心<code class="fe mv mw mx my b">UserService</code>方法是否正常工作。</p><p id="4c08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mv mw mx my b">TestBed</code>也不理解我们的HTML中的<code class="fe mv mw mx my b">app-user-speak</code>组件。这是因为我们没有将它添加到我们的声明模块中。然而，现在是争论的时候了。我对此的看法是，我们的测试不需要知道这个组件的组成，而是我们只测试我们的组件中的类型脚本，而不是HTML，因此我们将使用一种称为浅层呈现的技术，这将告诉Angular编译器忽略HTML中的问题。</p><p id="2d31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为此，我们必须编辑我们的<code class="fe mv mw mx my b">TestBed.configureTestingModule</code>,如下所示:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="60de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将解决我们的<code class="fe mv mw mx my b">app-user-speak</code>未声明的问题。但是我们仍然需要为<code class="fe mv mw mx my b">UserService</code>错误修复我们丢失的提供者。我们将在单元测试中使用一种称为模仿的技术，来创建一个模仿对象，它将被注入到组件中，而不是真正的用户服务中。</p><p id="56c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有许多方法可以创建模拟/间谍对象。Jasmine有一些内置选项，你可以在这里阅读<a class="ae kw" href="https://jasmine.github.io/api/3.5/jasmine.html#.createSpy" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="5bc0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将采用稍微不同的方法:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="aa11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在感兴趣的部分是我们的<code class="fe mv mw mx my b">providers</code>数组。这里我们告诉编译器提供这里定义为UserService的值。我们设置了一个新的对象，并定义了我们想要模仿的方法，在本例中是<code class="fe mv mw mx my b">getUser</code>，我们将告诉它返回一个特定的对象，而不是让真正的用户服务执行逻辑从数据库或类似的地方获取用户。</p><p id="3ece" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我对此的想法是，您与之交互的每个公共API都应该已经过测试，因此您的单元测试不需要确保API正确工作，但是，您希望确保您的代码能够正确处理API返回的内容。</p><p id="9755" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们编写测试来检查我们是否在我们的<code class="fe mv mw mx my b">ngOnInit</code>方法中获取了用户。</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b3b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们简单地创建一个spy来确保在<code class="fe mv mw mx my b">ngOnInit</code>方法中进行<code class="fe mv mw mx my b">getUser</code>调用。完美。</p><p id="a87e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还利用<code class="fe mv mw mx my b">.and.returnValue()</code>语法来告诉Jasmine，当调用API时，它应该向<code class="fe mv mw mx my b">ngOnInit()</code>方法返回什么。这可以让我们通过强制返回错误或不完整的对象来检查边缘情况和错误情况。</p><p id="a089" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们修改我们的<code class="fe mv mw mx my b">ngOnInit()</code>方法如下，以允许它处理错误:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d0ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们编写一个新的测试，告诉Jasmine抛出一个错误，允许我们检查我们的代码是否正确地处理了错误:</p><figure class="mp mq mr ms gt jr"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4de3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完美！🔥🔥我们现在也能够确保我们的代码能够正确处理错误！</p><p id="13af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是对Jasmine和Karma的Angular单元测试组件的一个简短而不全面的介绍。我将发表更多关于单元测试角度的文章，涵盖测试服务、数据服务、管道和防护。</p><p id="253f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如有任何问题，欢迎在下方提问或在Twitter上联系我:<a class="ae kw" href="https://twitter.com/FerryColum" rel="noopener ugc nofollow" target="_blank"> @FerryColum </a>。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="b7ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">原载于2020年2月15日</em><a class="ae kw" href="https://dev.to/coly010/unit-testing-angular-component-testing-2g47" rel="noopener ugc nofollow" target="_blank"><em class="kx">https://dev . to</em></a><em class="kx">。</em></p></div></div>    
</body>
</html>