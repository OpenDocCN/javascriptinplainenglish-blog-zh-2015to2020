<html>
<head>
<title>Understanding Types in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解TypeScript中的类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-types-in-typescript-b8d2297126bf?source=collection_archive---------1-----------------------#2019-08-10">https://javascript.plainenglish.io/understanding-types-in-typescript-b8d2297126bf?source=collection_archive---------1-----------------------#2019-08-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2216" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为您的代码构建坚实的基础</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c74c4f71785113ad686ab415c1db893b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E9Trm_4HblQX4xKMu-7LsA.jpeg"/></div></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="a6a4" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在是2019年，大多数库都支持TypeScript，所以你很有可能想在下一个项目中使用TypeScript。在<strong class="la ir"> <em class="lu">写代码。ts </em> </strong>文件是不够的，因为TypeScript编译器非常宽松，许多web开发人员倾向于编写没有任何类型注释的JavaScript代码，这使得使用TypeScript的整个目的变得徒劳。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lv"><img src="../Images/bdccf8dc0568309741076c06899be53d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JNpGomi-CLWCulRVzaJISg.jpeg"/></div></div><figcaption class="lw lx gj gh gi ly lz bd b be z dk">TypeScript’s autocomplete suggestion and compile time error checking</figcaption></figure><p id="fe41" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">此处将涵盖的内容列表:</p><ol class=""><li id="0299" class="ma mb iq la b lb lc le lf lh mc ll md lp me lt mf mg mh mi bi translated">基本类型(数字、字符串等。)</li><li id="7b66" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">功能类型</li><li id="d56f" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">元组</li><li id="114a" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">可空类型</li><li id="eefd" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">枚举</li><li id="4b8f" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">接口</li></ol><h1 id="567e" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated"><strong class="ak">基本类型</strong></h1><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="046b" class="nl mp iq nh b gy nm nn l no np">const name: string = 'Frudo';</span></pre><p id="d119" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下面是在TypeScript中以下列形式使用类型的简单示例</p><blockquote class="nq nr ns"><p id="2943" class="ky kz lu la b lb lc jr ld le lf ju lg nt li lj lk nu lm ln lo nv lq lr ls lt ij bi translated">设变量名称:数据类型=值</p></blockquote><p id="66dd" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">对于简单类型<em class="lu">,如果变量赋值在声明的同一行完成，data_type </em>可以避免。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="48cc" class="nl mp iq nh b gy nm nn l no np">const name = 'Frudo';</span></pre><p id="1532" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">TypeScript编译器将推断变量的类型，这被称为<em class="lu">类型推断</em>，我们可以避免编写不必要的代码。</p><p id="d1d9" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">以下是TypeScript中的基本类型:</p><ol class=""><li id="b387" class="ma mb iq la b lb lc le lf lh mc ll md lp me lt mf mg mh mi bi translated">布尔型(真或假)</li><li id="8782" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">数字(整数和小数)</li><li id="d523" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">线</li><li id="bfa4" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">排列</li><li id="295a" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">任何(它可以保存任何数据类型)</li></ol><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="b16f" class="nl mp iq nh b gy nm nn l no np">const flag: boolean = true;            // boolean<br/>const count: number = 10;             // number<br/>const name: string = 'Fred';         // string</span><span id="590c" class="nl mp iq nh b gy nw nn l no np">const names: string[] = ['Fred', 'Alice'];    // Array of string<br/>const temp: Array&lt;number&gt; = [1, 4, 2.5, 100] // Array of number</span><span id="a4df" class="nl mp iq nh b gy nw nn l no np">const a: any = 'hello'    // any type<br/>const b: any = 5         // any type</span></pre><p id="98b3" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">指定数据类型非常有用，因为它有助于发现常见的赋值错误。</p><blockquote class="nq nr ns"><p id="43cf" class="ky kz lu la b lb lc jr ld le lf ju lg nt li lj lk nu lm ln lo nv lq lr ls lt ij bi translated">谨慎:避免使用<strong class="la ir"> <em class="iq">任何</em> </strong>类型，因为这与编写普通javascript代码是一样的</p></blockquote><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="b290" class="nl mp iq nh b gy nm nn l no np">let count;           // any type by default<br/>count = 7;          // no error<br/>count = 'wow'      // no error</span></pre><p id="59c9" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在上面的例子中，count的类型是“any ”,这是当我们声明变量时由TypeScript指定的默认类型。</p><p id="c21e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这个错误可以很容易地用类型来修复:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="d2be" class="nl mp iq nh b gy nm nn l no np">let count: number;   // number type<br/>count = 7;          // no error<br/>count = 'wow'      // compile time error</span></pre></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="d9c6" class="mo mp iq bd mq mr nx mt mu mv ny mx my jw nz jx na jz oa ka nc kc ob kd ne nf bi translated"><strong class="ak">功能类型</strong></h1><p id="239d" class="pw-post-body-paragraph ky kz iq la b lb oc jr ld le od ju lg lh oe lj lk ll of ln lo lp og lr ls lt ij bi translated">在TypeScript中，我们也可以为函数定义类型。它对于定义回调函数非常有用，这是JavaScript中的一种常见模式。首先，让我们定义一个函数，并对它进行类型注释:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="16f5" class="nl mp iq nh b gy nm nn l no np">function sum(num1: number, num2: number): number {<br/>    return num1 + num2;<br/>}</span></pre><p id="ff5a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这里我们给了变量<code class="fe oh oi oj nh b">num1</code>和<code class="fe oh oi oj nh b">num2</code>一个类型号，函数的返回类型也是冒号后的数字。对于箭头函数，语法是不同的。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="cfc2" class="nl mp iq nh b gy nm nn l no np">const sum: (num1: number, num2: number) =&gt; number = (num1, num2) =&gt; num1 + num2;</span></pre><p id="7c25" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在这有点令人困惑，所以让我们把它分成两部分，把变量设为<strong class="la ir"> <em class="lu">让</em> </strong> <em class="lu"> </em>而不是<em class="lu"/><em class="lu">const</em><em class="lu">。</em></p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="afd7" class="nl mp iq nh b gy nm nn l no np">let sum: (num1: number, num2: number) =&gt; number;</span></pre><p id="9451" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这里我们定义了一个变量<code class="fe oh oi oj nh b">sum</code> <strong class="la ir"> <em class="lu"> </em> </strong>，并给了它一个函数类型，它有两个参数，类型为<em class="lu">数字</em>和返回类型为<em class="lu">数字。</em>在这之后我们将赋予它箭头功能的实现。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="b6bb" class="nl mp iq nh b gy nm nn l no np">sum = (num1, num2) =&gt; num1 + num2;</span></pre><p id="49bf" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这里我们用arrow函数实现给变量<code class="fe oh oi oj nh b">sum</code>赋值。</p><p id="6ff8" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">还有一件事，如果函数不返回值，它的返回类型将是<code class="fe oh oi oj nh b">void</code>，这意味着<em class="lu">没有返回类型。</em></p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="ef2a" class="nl mp iq nh b gy nm nn l no np">function print(value: string): void {<br/>  console.log(value);<br/>}</span></pre><p id="9b49" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最后，让我们用一些用例来总结函数类型:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="e061" class="mo mp iq bd mq mr nx mt mu mv ny mx my jw nz jx na jz oa ka nc kc ob kd ne nf bi translated">元组</h1><p id="c7b2" class="pw-post-body-paragraph ky kz iq la b lb oc jr ld le od ju lg lh oe lj lk ll of ln lo lp og lr ls lt ij bi translated">想知道如何在函数中返回多个值吗？元组来拯救，它让您可以轻松地返回多个不同数据类型的值。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="95e7" class="nl mp iq nh b gy nm nn l no np">const example: [int, string] = [10, 'Hi'];</span></pre><p id="16be" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">元组只是幕后的数组，但TypeScript用独特的类型检查增强功能包装了它。元组可以保存不同的数据类型，可以像数组一样使用索引来访问，但它与数组相比有一些不同。元组中的每个索引只能保存声明期间定义的数据类型。与其他编程语言不同，TypeScript中的元组是可变的，我们还可以推送或弹出元组中的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="d3bd" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您还可以自动完成特定于索引数据类型，这在数组中是不可能的。即使元组是可变的，也应该尽可能避免。元组用例的一个真实例子是在React中，其中<code class="fe oh oi oj nh b">useState()</code>挂钩返回元组。</p></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="8a72" class="mo mp iq bd mq mr nx mt mu mv ny mx my jw nz jx na jz oa ka nc kc ob kd ne nf bi translated">可空类型</h1><p id="33eb" class="pw-post-body-paragraph ky kz iq la b lb oc jr ld le od ju lg lh oe lj lk ll of ln lo lp og lr ls lt ij bi translated">javaScript有两种类型<code class="fe oh oi oj nh b">undefined</code>和<code class="fe oh oi oj nh b">null</code>，它们代表空值或null值，就像在Java和c#中一样。这也是用javascript编程时人们面临的最常见的运行时错误之一。TypeScript也有这两种类型，它可以被赋给任何数据类型。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="dad5" class="nl mp iq nh b gy nm nn l no np">let str: string;</span></pre><p id="7a37" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这里<code class="fe oh oi oj nh b">str</code>有值<code class="fe oh oi oj nh b">undefined</code>,因为我们从未给它赋值，尽管它的数据类型是字符串。对<code class="fe oh oi oj nh b">str</code>的任何操作都会导致运行时错误，因此我们需要使用if语句检查它是否包含某个值，然后执行所需的操作。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="823d" class="nl mp iq nh b gy nm nn l no np">if(str) {<br/> str.length;<br/>}</span></pre><p id="85e7" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">默认情况下，TypeScript不会在编译时考虑<code class="fe oh oi oj nh b">undefined</code>和<code class="fe oh oi oj nh b">null</code>运行时错误。在名为<strong class="la ir"><em class="lu">strictNullChecks</em></strong>的<strong class="la ir"><em class="lu">ts config . JSON</em></strong>文件中有一个标志可以设置为true，这会导致TypeScript对代码进行流分析，以检查带有<code class="fe oh oi oj nh b">undefined</code>和<code class="fe oh oi oj nh b">null</code>的不安全代码，并在编译时给出错误。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="3afb" class="nl mp iq nh b gy nm nn l no np">{<br/>  "include": ["src/**/*"],<br/>  "exclude": ["node_modules", "**/*.spec.ts"],<br/>  "compileOnSave": false,<br/>  "compilerOptions": {<br/>    ...<br/>    "strict": true,             // All strict flags are turned on<br/>    "strictNullChecks": true,   // Null checks for nullable types<br/>    ...<br/>  }<br/>}</span></pre><p id="ceef" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">当<strong class="la ir"><em class="lu">strictNullChecks</em></strong>为真时，那么<code class="fe oh oi oj nh b">let str: string;</code>将给出错误，因为我们不能将<code class="fe oh oi oj nh b">undefined</code>赋值给类型字符串。为了允许undefined赋值给<code class="fe oh oi oj nh b">str</code>,我们需要这样声明:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="2206" class="nl mp iq nh b gy nm nn l no np">let str: string | undefined;</span></pre><p id="a7be" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这就是所谓的可空类型。TypeScript不允许我们直接访问可空类型，相反我们需要对它进行检查。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="3705" class="nl mp iq nh b gy nm nn l no np">let str: string | undefined = 'Hello';</span><span id="86b3" class="nl mp iq nh b gy nw nn l no np">str.length; // error</span><span id="b386" class="nl mp iq nh b gy nw nn l no np">// Access like below<br/>if(str) {<br/> str.length;<br/>}</span></pre><p id="72be" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这使得代码库更加健壮，并防止了一整类运行时异常。这种空检查如此强大，以至于当TypeScript团队在制作编译器时启用了这一功能，他们在代码库中发现了未被发现的错误。</p><p id="db4e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><strong class="la ir">注意:</strong> <code class="fe oh oi oj nh b">null</code>不能赋给<code class="fe oh oi oj nh b">let str: string|undefined</code>，因为<code class="fe oh oi oj nh b">null</code>和<code class="fe oh oi oj nh b">undefined</code>在类型脚本中被认为是不同类型。</p><p id="4744" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了给<code class="fe oh oi oj nh b">null</code>赋值，我们需要将变量定义为</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="ce19" class="nl mp iq nh b gy nm nn l no np">let str: string | null | undefined</span></pre><p id="10ac" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这将允许<code class="fe oh oi oj nh b">undefined</code>和<code class="fe oh oi oj nh b">null</code>都可以分配给<code class="fe oh oi oj nh b">str</code>。</p><p id="747f" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有时当你知道一个给定的变量不包含<code class="fe oh oi oj nh b">null</code>或<code class="fe oh oi oj nh b">undefined</code>时，你可以使用<strong class="la ir">类型断言</strong>来强制删除null。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="90d4" class="nl mp iq nh b gy nm nn l no np">let str: string | undefined = 'Hello';<br/>str!.length; // it will work</span></pre><p id="1e1b" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这里的<code class="fe oh oi oj nh b">!</code>用于从<code class="fe oh oi oj nh b">str</code>中移除可空类型，并用它调用<code class="fe oh oi oj nh b">length</code>。只有当你确信给定的变量不会为空时，才应该小心使用类型断言。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="3ef2" class="mo mp iq bd mq mr nx mt mu mv ny mx my jw nz jx na jz oa ka nc kc ob kd ne nf bi translated">枚举</h1><p id="42a4" class="pw-post-body-paragraph ky kz iq la b lb oc jr ld le od ju lg lh oe lj lk ll of ln lo lp og lr ls lt ij bi translated">枚举就像逻辑上组合在一起的常量，有助于提高常量的可读性，并且可以有有趣的用例。枚举在其他语言中也是可用的，如java、c#等，它们也类似于TypeScript中的枚举。</p><p id="9738" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">枚举的定义如下:</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="c812" class="nl mp iq nh b gy nm nn l no np">enum Direction {<br/> North, South, East, West<br/>}</span></pre><p id="57bc" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">枚举类型的任何变量只能有由该枚举定义的那些值，例如</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="4d4c" class="nl mp iq nh b gy nm nn l no np">let d: Direction = Direction.North<br/>d = Direction.South</span><span id="c7cc" class="nl mp iq nh b gy nw nn l no np">d = "East"    // error</span><span id="b763" class="nl mp iq nh b gy nw nn l no np">// Checking for value<br/>d == Direction.South    // true or false<br/>d == "South"           // error</span></pre><p id="661b" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">正如你所看到的，枚举允许我们施加额外的约束，并且比使用<code class="fe oh oi oj nh b">const</code>更加易读。</p><p id="29e9" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">默认情况下，枚举从0开始取数值，但是我们可以手动给它们赋值。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="4d5b" class="nl mp iq nh b gy nm nn l no np">enum Direction {<br/> North=1, South=6, East=5, West=2<br/>}</span></pre><p id="9d40" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">您也可以将字符串值赋给枚举。只能将数字和字符串值赋予枚举。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="4fb1" class="nl mp iq nh b gy nm nn l no np">enum Direction {<br/> North='north', South='south', East='east', West='west'<br/>}</span></pre></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="fedd" class="mo mp iq bd mq mr nx mt mu mv ny mx my jw nz jx na jz oa ka nc kc ob kd ne nf bi translated">接口</h1><p id="dd05" class="pw-post-body-paragraph ky kz iq la b lb oc jr ld le od ju lg lh oe lj lk ll of ln lo lp og lr ls lt ij bi translated">在javascript中，我们经常动态地创建许多对象，将它们存储在变量中，然后传递给函数。接口允许我们定义这些对象的结构，这样我们就可以放心地编写代码，确信该对象中存在特定的属性。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="9be2" class="nl mp iq nh b gy nm nn l no np">interface IProduct {<br/>name: string;<br/>description: string;<br/>price: number;<br/>}</span></pre><p id="8a82" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">通常，我以'<strong class="la ir"> I </strong>'开始接口名称，以便区分类和接口，但这不是必须的。接口一旦定义，就可以像任何其他类型一样使用</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="2e3f" class="nl mp iq nh b gy nm nn l no np">let book: IProduct = {<br/>name: 'Typescript guide',<br/>description: 'Guide for beginners',<br/>price: 100<br/>};</span><span id="ab9c" class="nl mp iq nh b gy nw nn l no np">book = {name: 'Typescript'}; //error, all properties are not defined</span><span id="daa9" class="nl mp iq nh b gy nw nn l no np">function displayPrice(product: IProduct) {<br/>console.log(product.price);<br/>}</span></pre><p id="7287" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">TypeScript编译器检查接口的结构相等性，这意味着接口定义的所有属性都应该存在于该对象中，否则将引发编译时错误。</p><p id="9caa" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们也可以定义匿名接口(没有名字)</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="c1a4" class="nl mp iq nh b gy nm nn l no np">let custom: { id: number, name: string }; // anonymous interface</span><span id="0b04" class="nl mp iq nh b gy nw nn l no np">custom = {id: 45, name: 'Frudo'};</span><span id="e436" class="nl mp iq nh b gy nw nn l no np">custom = {id: '45', name: 'Frudo'}; // error, id is number</span></pre><p id="07a2" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">接口可以是非常强大的，因为它有助于属性的逻辑分组，这些属性也可以是函数类型、枚举、可空值甚至是另一个接口。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ok ol l"/></div></figure><p id="a412" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">接口通常用作模型，例如json响应的api模型。创建接口模型有助于通过IDE自动完成、错误检查和作为自我文档。</p><p id="8042" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">这里的是一个有用的链接，可以轻松地将JSON响应转换为TypeScript。</p><div class="on oo gp gr op oq"><a href="https://www.jsonutils.com/" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ir gy z fp ov fr fs ow fu fw ip bi translated">JSON Utils:从JSON生成C#、VB.Net、SQL表、Java和PHP</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">JSON Utils是一个从JSON生成C#、VB.Net、Javascript、Java和PHP类的网站。它还会清理你的…</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">www.jsonutils.com</p></div></div></div></a></div></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="8b8c" class="mo mp iq bd mq mr nx mt mu mv ny mx my jw nz jx na jz oa ka nc kc ob kd ne nf bi translated">结论</h1><p id="c4ea" class="pw-post-body-paragraph ky kz iq la b lb oc jr ld le od ju lg lh oe lj lk ll of ln lo lp og lr ls lt ij bi translated">因此，我们学习了很多关于typescript中最常用的类型以及如何使用它的知识。项目越大，它就变得越有用，真正的项目通常会变得更大。这些额外的工作将为项目的后期铺平道路。快乐编码😃👍。</p></div></div>    
</body>
</html>