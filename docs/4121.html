<html>
<head>
<title>How to Check for an Array in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中检查数组</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-check-for-an-array-in-javascript-6ad20f7a0e21?source=collection_archive---------3-----------------------#2020-11-18">https://javascript.plainenglish.io/how-to-check-for-an-array-in-javascript-6ad20f7a0e21?source=collection_archive---------3-----------------------#2020-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="3d7c" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph"><code class="fe iy iz ja jb b">Array.isArray([])</code>对<code class="fe iy iz ja jb b">Object.prototype.toString.call([])</code></h2><div class=""/><div class=""><h2 id="ff6d" class="pw-subtitle-paragraph ka jd iq bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">JavaScript数组是一种对象类型，所以<code class="fe iy iz ja jb b">typeof []</code>返回<code class="fe iy iz ja jb b">"object"</code>——对于查看您是否有数组没有太大帮助。这里有5种方法来检查JavaScript对象是否是数组。</h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/b95ee7c79738bf82cb2e3f3f1834a3bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fO99mJxflsimdcc7"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Photo by <a class="ae li" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JJ Ying</a> on <a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bd07" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">JavaScript数据验证中的一个常见问题是检查给定变量是否包含数组。</p><blockquote class="mf"><p id="66d4" class="mg mh iq bd mi mj mk ml mm mn mo me dk translated">"数组是类似列表的对象，其原型具有执行遍历和变异操作的方法."— <a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank"> MDN文档</a></p></blockquote><p id="d89d" class="pw-post-body-paragraph lj lk iq ll b lm mp ke lo lp mq kh lr ls mr lu lv lw ms ly lz ma mt mc md me ij bi translated">对于原始类型，<a class="ae li" href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener"/><code class="fe iy iz ja jb b"><a class="ae li" href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener">typeof</a></code><a class="ae li" href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener">关键字</a>通常工作得很好，但是<code class="fe iy iz ja jb b">typeof</code>数组是<code class="fe iy iz ja jb b">"object"</code> : <code class="fe iy iz ja jb b">typeof [] === object // true</code>。</p><p id="38f9" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">虽然这很有意义(毕竟数组是JavaScript对象的内置类型)，但它对于区分数组和其他对象并没有什么用处。</p><p id="2a2f" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">另外，从<code class="fe iy iz ja jb b">typeof</code> <a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">得到<code class="fe iy iz ja jb b">"object"</code>可以表示一个</a> <code class="fe iy iz ja jb b"><a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">null</a></code> <a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">值</a>。</p><p id="3943" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">幸运的是，有许多方法可以检查JavaScript数组:</p><ul class=""><li id="d9a8" class="mu mv iq ll b lm ln lp lq ls mw lw mx ma my me mz na nb nc bi translated">方法1) <code class="fe iy iz ja jb b">Array.isArray([])</code></li><li id="4023" class="mu mv iq ll b lm nd lp ne ls nf lw ng ma nh me mz na nb nc bi translated">方法2) <code class="fe iy iz ja jb b">Object.prototype.toString.call([])</code></li><li id="aa50" class="mu mv iq ll b lm nd lp ne ls nf lw ng ma nh me mz na nb nc bi translated">方法3) <code class="fe iy iz ja jb b">[] instanceof Array</code></li><li id="8aab" class="mu mv iq ll b lm nd lp ne ls nf lw ng ma nh me mz na nb nc bi translated">方法4) <code class="fe iy iz ja jb b">[].constructor</code></li><li id="f112" class="mu mv iq ll b lm nd lp ne ls nf lw ng ma nh me mz na nb nc bi translated">方法5) <code class="fe iy iz ja jb b">&amp;&amp;</code>同<code class="fe iy iz ja jb b">[].constructor</code></li></ul><p id="2cf3" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在本文中，我将解释每种方法的优缺点。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="15f9" class="np nq iq bd nr ns nt nu nv nw nx ny nz kj oa kk ob km oc kn od kp oe kq of og bi translated">方法1: <code class="fe iy iz ja jb b">Array.isArray([])</code></h1><p id="dde8" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">ECMAScript 5 (ES5)引入了<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" rel="noopener ugc nofollow" target="_blank">Array.isArray()</a></code>方法来<a class="ae li" href="http://web.mit.edu/jwalden/www/isArray.html" rel="noopener ugc nofollow" target="_blank">检查数组</a>，因为<code class="fe iy iz ja jb b">typeof</code>将无法区分数组与其他对象，例如内置对象<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" rel="noopener ugc nofollow" target="_blank">Date</a></code>和<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp" rel="noopener ugc nofollow" target="_blank">RegExp</a></code>。</p><p id="f68b" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">使用<code class="fe iy iz ja jb b">Array.isArray()</code>也有助于确保我们的对象不是<code class="fe iy iz ja jb b">null</code>，因为<code class="fe iy iz ja jb b"><a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">null</a></code> <a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">由于一个长期存在的错误而具有</a> <code class="fe iy iz ja jb b"><a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">typeof "object"</a></code>。</p><p id="c2ae" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">下面是一个使用<code class="fe iy iz ja jb b">Array.isArray([])</code>检查数组的例子:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div class="gh gi om"><img src="../Images/d4eaef14ad05109d2040da846eca3299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*aJ_-wS6Ez2iws8y4BKbHRg.png"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk"><a class="ae li" href="https://gist.github.com/DoctorDerek/a22a533367bf883b7f1ceb9602397a47" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="6ab5" class="np nq iq bd nr ns nt nu nv nw nx ny nz kj oa kk ob km oc kn od kp oe kq of og bi translated">方法2: <code class="fe iy iz ja jb b">Object.prototype.toString.call([])</code></h1><p id="c816" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">详细的JavaScript语句<code class="fe iy iz ja jb b"><a class="ae li" href="https://medium.com/better-programming/what-is-object-object-in-javascript-object-prototype-tostring-1db888c695a4" rel="noopener">Object.prototype.toString.call()</a></code>可以区分数组和其他类型的对象，因为它返回的<a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-check-for-a-string-in-javascript-a16b196915ff" rel="noopener">字符串</a>比<code class="fe iy iz ja jb b">typeof</code>更详细地指定了对象类型。</p><p id="75f3" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">因为这个方法适用于任何对象，所以我称它为JavaScript中类型检查的最佳方式<a class="ae li" href="https://medium.com/javascript-in-plain-english/the-best-way-to-type-check-in-vanilla-js-55197b4f45ec" rel="noopener"/>。下面是一个例子:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi on"><img src="../Images/048caba5fb22d8cfdd97bc0c6a0c81f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KyTGgltGp_Fm0CGv96KGEg.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk"><a class="ae li" href="https://gist.github.com/DoctorDerek/eae44673b8e8a4a5250d6fece904591c" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="db30" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">虽然冗长，但这个方法适用于任何基本类型和任何对象。它总是返回变量的构造函数的名称。</p><p id="f2d9" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">换句话说，<code class="fe iy iz ja jb b">Object.prototype.toString.call()</code>有点像反过来的<code class="fe iy iz ja jb b">instanceof</code>，尽管它在<code class="fe iy iz ja jb b">iframes</code>内部工作得很好。</p><p id="a38f" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">上述<code class="fe iy iz ja jb b">isArray()</code>函数的行为应该与内置的<code class="fe iy iz ja jb b">Array.isArray()</code>函数相同。</p><p id="f6de" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这里需要注意的一点是，<code class="fe iy iz ja jb b">typeof {}</code>返回<code class="fe iy iz ja jb b">"object"</code>(小写)，但是<code class="fe iy iz ja jb b">Object.prototype.toString.call({}).slice(8,-1)</code>对于一个对象<code class="fe iy iz ja jb b">{}</code>返回<code class="fe iy iz ja jb b">"Object"</code>(大写)，对于一个数组<code class="fe iy iz ja jb b">[]</code>返回<code class="fe iy iz ja jb b">"Array"</code>(大写)。</p><p id="7a66" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">与所有这些方法一样，如果变量尚未声明，该方法将不起作用。稍后我将解决未声明变量的检查问题。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="b198" class="np nq iq bd nr ns nt nu nv nw nx ny nz kj oa kk ob km oc kn od kp oe kq of og bi translated">方法三:<code class="fe iy iz ja jb b">[] instanceof Array</code></h1><p id="85f2" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">使用关键字<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" rel="noopener ugc nofollow" target="_blank">instanceof</a></code>可以用来检查数组或任何类型的JavaScript对象。</p><blockquote class="oo op oq"><p id="5d7a" class="lj lk or ll b lm ln ke lo lp lq kh lr os lt lu lv ot lx ly lz ou mb mc md me ij bi translated">"<code class="fe iy iz ja jb b"><strong class="ll je">instanceof</strong></code> <strong class="ll je">操作符</strong>测试一个构造函数的<code class="fe iy iz ja jb b">prototype</code>属性是否出现在一个对象的原型链中。"— <a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" rel="noopener ugc nofollow" target="_blank"> MDN文档</a></p></blockquote><p id="d8b3" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">语法很简单，如以下代码示例所示:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ov"><img src="../Images/480695296ea34d6a2d6e0ec79125ac3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I4zA-Zz40Ed_9tEYfTmmfA.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk"><a class="ae li" href="https://gist.github.com/DoctorDerek/3110d41754b2413600f3a2798c2738fc" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="4d54" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">不过要小心，<code class="fe iy iz ja jb b"><a class="ae li" href="https://medium.com/@bluepnume/iframes-are-just-terrible-heres-how-they-could-be-better-974b731f0fb4" rel="noopener">iframes</a></code>可能会破坏这种行为，正如Mozilla Developer Network <a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" rel="noopener ugc nofollow" target="_blank">文档中对</a> <code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" rel="noopener ugc nofollow" target="_blank">Array.isArray</a></code>的解释:</p><blockquote class="oo op oq"><p id="a5ef" class="lj lk or ll b lm ln ke lo lp lq kh lr os lt lu lv ot lx ly lz ou mb mc md me ij bi translated"><code class="fe iy iz ja jb b">instanceof</code> vs <code class="fe iy iz ja jb b">isArray</code></p><p id="8e59" class="lj lk or ll b lm ln ke lo lp lq kh lr os lt lu lv ot lx ly lz ou mb mc md me ij bi translated">在检查[an] <code class="fe iy iz ja jb b">Array</code>实例时，<code class="fe iy iz ja jb b">Array.isArray</code>优先于<code class="fe iy iz ja jb b">instanceof</code>，因为它通过<code class="fe iy iz ja jb b">iframes</code>工作。— <a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" rel="noopener ugc nofollow" target="_blank"> MDN文档</a></p></blockquote><p id="2807" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这意味着我们可能根本不想使用<code class="fe iy iz ja jb b">instanceof</code>来检查数组，以防我们的JavaScript代码最终在<code class="fe iy iz ja jb b">iframe</code>中运行。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="e9e3" class="np nq iq bd nr ns nt nu nv nw nx ny nz kj oa kk ob km oc kn od kp oe kq of og bi translated">方法四:<code class="fe iy iz ja jb b">[].constructor</code></h1><p id="a575" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">为了完整起见，我想提一个类似于<code class="fe iy iz ja jb b">instanceof </code>的方法——调用JavaScript对象的<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" rel="noopener ugc nofollow" target="_blank">.constructor</a></code> <a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" rel="noopener ugc nofollow" target="_blank">属性</a>。</p><p id="8b8d" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><code class="fe iy iz ja jb b">.constructor </code>属性将返回构造函数，对于数组来说将是<code class="fe iy iz ja jb b">function Array()</code>(即<a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">JavaScript类</a> <code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">Array</a></code>)。</p><p id="e0f3" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">访问该函数的<code class="fe iy iz ja jb b">.name</code>属性将得到字符串<code class="fe iy iz ja jb b">"Array"</code>，该字符串可用于对数组的存在进行简单的检查。</p><p id="09f4" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">由于<code class="fe iy iz ja jb b">.constructor </code>属性返回<code class="fe iy iz ja jb b">function Array()</code>(即<a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">JavaScript类</a> <code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">Array</a></code>)，所以也可以直接将其与<a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener ugc nofollow" target="_blank">全局数组对象</a>(也就是返回的<code class="fe iy iz ja jb b">function Array()</code>所引用的)进行比较。</p><p id="d138" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">换句话说，您实际上不必使用<code class="fe iy iz ja jb b">.name</code>属性；<code class="fe iy iz ja jb b">[].constructor===Array</code>相当于<code class="fe iy iz ja jb b">[].constructor.name==="Array"</code>。</p><p id="601c" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">下面是一个代码示例:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ow"><img src="../Images/4364cf35b45cc49a0426a6c27590e253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vDv4TkJ4FG0fS6HosDiakA.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk"><a class="ae li" href="https://gist.github.com/DoctorDerek/3be6f651b52395ff62ff52cd8edd7423" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="8d64" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">类似于<code class="fe iy iz ja jb b">Object.prototype.toString.call()</code>，访问<code class="fe iy iz ja jb b">.constructor</code>属性将适用于任何类型的JavaScript值，包括原语——尽管您不能访问<code class="fe iy iz ja jb b"><a class="ae li" href="https://medium.com/coding-at-dawn/how-to-check-for-undefined-in-javascript-bcedd62c8ad" rel="noopener">undefined</a></code>或<code class="fe iy iz ja jb b">null</code>值的<code class="fe iy iz ja jb b">.constructor</code>。</p><p id="7149" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">(注意，<code class="fe iy iz ja jb b">instanceof</code>关键字适用于对象，但不适用于原语。当然还有<code class="fe iy iz ja jb b">instanceof</code>在<code class="fe iy iz ja jb b">iframes</code>被窃听。)</p><p id="bc18" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">正如我们在上面看到的，使用没有<code class="fe iy iz ja jb b">null</code>检查的<code class="fe iy iz ja jb b">.constructor</code>会导致<code class="fe iy iz ja jb b">null</code>和<code class="fe iy iz ja jb b">undefined</code>都有一个<code class="fe iy iz ja jb b">TypeError</code>——与<code class="fe iy iz ja jb b">Array.isArray()</code>相比，这是一个缺点，它只会为这两个值返回<code class="fe iy iz ja jb b">false</code>。</p><p id="dc87" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">而且，就像到目前为止介绍的任何方法一样，如果您试图访问未声明的变量，它们将抛出一个<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError" rel="noopener ugc nofollow" target="_blank">ReferenceError</a></code>。</p><h2 id="f079" class="ox nq iq bd nr oy oz dn nv pa pb dp nz ls pc pd ob lw pe pf od ma pg ph of iw bi translated">一个警告:<code class="fe iy iz ja jb b">.constructor</code>是可变的</h2><p id="3f00" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">在继续之前，值得注意的是<code class="fe iy iz ja jb b">.constructor</code>并不健壮，因为它是一个可以在以后被覆盖的对象属性。</p><blockquote class="oo op oq"><p id="e7f2" class="lj lk or ll b lm ln ke lo lp lq kh lr os lt lu lv ot lx ly lz ou mb mc md me ij bi translated">“请记住，如果你以任何理由通过原型重写了你构造函数，那么<code class="fe iy iz ja jb b">arr.constructor === Array</code>测试将返回false。尽管如此，仍然返回true。–<a class="ae li" href="https://stackoverflow.com/users/1415032/ghaschel" rel="noopener ugc nofollow" target="_blank">ghaschel</a>他的栈中溢出<a class="ae li" href="https://stackoverflow.com/questions/4775722/how-to-check-if-an-object-is-an-array#comment84913691_4775722" rel="noopener ugc nofollow" target="_blank">答案</a></p></blockquote><p id="5ddb" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">所以只要记住一个对象的<code class="fe iy iz ja jb b">.constructor</code>属性是“<a class="ae li" href="https://en.wikipedia.org/wiki/Immutable_object" rel="noopener ugc nofollow" target="_blank">可变的</a>”——它可能已经在代码中的某个地方从它的初始值改变了。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="a3f4" class="np nq iq bd nr ns nt nu nv nw nx ny nz kj oa kk ob km oc kn od kp oe kq of og bi translated">方法五:&amp;&amp;和<code class="fe iy iz ja jb b">[].constructor</code> ( <code class="fe iy iz ja jb b">null</code>检查！😄)</h1><p id="65e4" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">下面是一个简洁的一行程序，它将在检查数组<code class="fe iy iz ja jb b">[] &amp;&amp; [].constructor === Array</code>的同时检查非<code class="fe iy iz ja jb b">null</code>值。</p><p id="2108" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><code class="fe iy iz ja jb b">null</code>和<code class="fe iy iz ja jb b">undefined</code>都是<a class="ae li" href="https://medium.com/coding-at-dawn/what-are-falsy-values-in-javascript-ca0faa34feb4" rel="noopener"> falsy </a>值，这意味着它们在条件语句中计算为false，但是所有对象都是真的，包括空数组。检查<code class="fe iy iz ja jb b">[] &amp;&amp; [].constructor === Array</code>将为<code class="fe iy iz ja jb b">null</code>或<code class="fe iy iz ja jb b">undefined</code>值返回false，而<code class="fe iy iz ja jb b">.constructor</code>将单独抛出一个错误。</p><p id="c119" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">包含<a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND#Short-circuit_evaluatoin" rel="noopener ugc nofollow" target="_blank">逻辑AND ( </a> <code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND#Short-circuit_evaluatoin" rel="noopener ugc nofollow" target="_blank">&amp;&amp;</a></code> <a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND#Short-circuit_evaluatoin" rel="noopener ugc nofollow" target="_blank">)运算符</a>的好处是避免了因为<code class="fe iy iz ja jb b">null</code>和<code class="fe iy iz ja jb b">undefined</code>没有属性而发生的<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError" rel="noopener ugc nofollow" target="_blank">TypeError</a></code>。这是因为<code class="fe iy iz ja jb b">&amp;&amp;</code>是一个<a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND#Short-circuit_evaluatoin" rel="noopener ugc nofollow" target="_blank">短路操作器</a>通过使用逻辑AND ( <code class="fe iy iz ja jb b">&amp;&amp;</code>)，我们在尝试访问<code class="fe iy iz ja jb b">.constructor</code>属性之前检查值是否为<a class="ae li" href="https://medium.com/coding-in-simple-english/what-are-truthy-values-in-javascript-e037bdfa76f8" rel="noopener">真值</a>。下面是一个代码示例:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pi"><img src="../Images/c2b4eb8a48d99a89af09b22c8df9472b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9We0Pt4lUNUETDClQJt1RA.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk"><a class="ae li" href="https://gist.github.com/DoctorDerek/f30f3e65a06c487a14db55a6d33f78e4" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="edfa" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">为了提高代码的可读性，你可以考虑使用<a class="ae li" href="https://medium.com/better-programming/making-sense-of-vs-in-javascript-f9dbbc6352e3" rel="noopener">松散等式</a> : <code class="fe iy iz ja jb b">[] != null &amp;&amp; [].constructor</code>使<a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">的空检查</a>显式化。使用<code class="fe iy iz ja jb b">!=</code>(宽松相等运算符)意味着<code class="fe iy iz ja jb b">null</code>和<code class="fe iy iz ja jb b">undefined</code>彼此相等。</p><p id="3c2f" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">一个更加明确的检查将使用<a class="ae li" href="https://medium.com/better-programming/making-sense-of-vs-in-javascript-f9dbbc6352e3" rel="noopener">严格等式</a> : <code class="fe iy iz ja jb b">[] !== null &amp;&amp; [] !== undefined &amp;&amp; [].constructor === Array</code>。许多JavaScript程序员不喜欢使用松散的等式，因为<code class="fe iy iz ja jb b">==</code>的规则令人困惑。</p><p id="464e" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">将<code class="fe iy iz ja jb b">&amp;&amp;</code>与<code class="fe iy iz ja jb b">.constructor</code>一起使用，对于<code class="fe iy iz ja jb b">null</code>和<code class="fe iy iz ja jb b">undefined</code>来说，效果与<code class="fe iy iz ja jb b">Array.isArray()</code>一样:如你所愿，它返回false。</p><p id="ef76" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">然而，当试图访问<code class="fe iy iz ja jb b">.constructor</code>属性时，未声明的变量仍然会抛出<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError" rel="noopener ugc nofollow" target="_blank">ReferenceError</a></code>。您可以在数组检查之前使用<code class="fe iy iz ja jb b">typeof</code>来检查值是否不是<code class="fe iy iz ja jb b">"undefined"</code>来解决这个问题。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="bf83" class="np nq iq bd nr ns nt nu nv nw nx ny nz kj oa kk ob km oc kn od kp oe kq of og bi translated">如果数组变量实际上是未声明的呢？</h1><p id="4e9f" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">你可能不确定可能是数组的变量是否已经被声明了。让我简单谈谈检查未声明的数组。</p><p id="fdbc" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">提醒一下，访问一个没有声明的变量会抛出一个<code class="fe iy iz ja jb b"><a class="ae li" href="https://www.google.com/search?client=firefox-b-d&amp;q=ReferenceError+mdn" rel="noopener ugc nofollow" target="_blank">ReferenceError</a></code>，而一个已经声明但没有赋值的变量会有<code class="fe iy iz ja jb b"><a class="ae li" href="https://medium.com/coding-at-dawn/how-to-check-for-undefined-in-javascript-bcedd62c8ad" rel="noopener">undefined</a></code>的值。</p><p id="3f3f" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">值得庆幸的是，<a class="ae li" href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener"/><code class="fe iy iz ja jb b"><a class="ae li" href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener">typeof</a></code><a class="ae li" href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener">关键字</a>将为尚未声明的变量返回<code class="fe iy iz ja jb b">"undefined"</code>，对于值<code class="fe iy iz ja jb b">undefined</code>也是如此，但不会抛出<code class="fe iy iz ja jb b">ReferenceError</code>，因为变量尚未声明。</p><p id="fdab" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这意味着我们可以将<code class="fe iy iz ja jb b">Array.isArray()</code>包装在<code class="fe iy iz ja jb b">typeof</code>调用中，以使其对未声明的变量具有健壮性。这里有一个例子:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pj"><img src="../Images/2ab69da7f92157a437113338c0249991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cmUsM6Yn0LtMsnRN8xrhQg.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk"><a class="ae li" href="https://gist.github.com/DoctorDerek/63c32245dd4b21fc1b3c8cf47357df2d" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="4d8e" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">或者，我们可以使用一个<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" rel="noopener ugc nofollow" target="_blank">try...catch</a></code>块，捕捉潜在的<code class="fe iy iz ja jb b">ReferenceError</code>，但是<code class="fe iy iz ja jb b">typeof</code>对未声明的变量也同样有效。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="5394" class="np nq iq bd nr ns nt nu nv nw nx ny nz kj oa kk ob km oc kn od kp oe kq of og bi translated">如何在JavaScript中检查空数组？</h1><p id="1d16" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">相反，如果我们想检查一个数组是否为空，我们可以检查它的<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length" rel="noopener ugc nofollow" target="_blank">.length</a></code>属性——一个空数组有<code class="fe iy iz ja jb b">.length</code>的<code class="fe iy iz ja jb b">0</code>。</p><p id="6730" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">同样，我们需要确保我们使用的是一个已经被赋值的声明变量，这个值肯定是一个数组。</p><p id="05c2" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">但是，假设我们从<code class="fe iy iz ja jb b">Array.isArray([])</code>得到了<code class="fe iy iz ja jb b">true</code>，那么<code class="fe iy iz ja jb b">[].length &gt; 0</code>会确认我们的数组不是空的。下面是一段代码:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pk"><img src="../Images/84c7399f82aca6e4dd87c3883d38ea5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d5RFqukZIn0vT74xOl9F9w.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk"><a class="ae li" href="https://gist.github.com/DoctorDerek/513c7ccb117ecef1a946f58fa6a297dc" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="3a78" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">同样，我们正在利用<code class="fe iy iz ja jb b">&amp;&amp;</code>作为短路操作器的优势。因为它“短路”了错误的语句，所以我们永远不会到达上面例子中的<code class="fe iy iz ja jb b">.length</code>调用。这正是我们想要的，因为<code class="fe iy iz ja jb b">.length</code>不能处理大多数原语，比如<a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-check-for-a-number-in-javascript-8d9024708153" rel="noopener">数字</a>或其他类型的对象。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="b948" class="np nq iq bd nr ns nt nu nv nw nx ny nz kj oa kk ob km oc kn od kp oe kq of og bi translated">性能测试:在JavaScript中检查数组最快的方法是什么？</h1><p id="4154" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">开发者<a class="pl pm ep" href="https://medium.com/u/e36902b76a9a?source=post_page-----6ad20f7a0e21--------------------------------" rel="noopener" target="_blank">Mark Penner</a>(<a class="ae li" href="https://stackoverflow.com/users/65387/mpen" rel="noopener ugc nofollow" target="_blank">mpen</a>)使用<a class="ae li" href="https://jsperf.com/js-isarray-comparison/16" rel="noopener ugc nofollow" target="_blank"> jsPerf </a>来比较JavaScript中检查数组的各种方法。</p><p id="128e" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">他的结果显示，一种流行的方法比其他方法慢20%——尽管这种差异可以忽略不计，因为结果是如此之快。</p><p id="4557" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">以下是我几个月前运行<a class="ae li" href="https://jsperf.com/js-isarray-comparison/16" rel="noopener ugc nofollow" target="_blank">的jsPerf测试套件</a>时得到的结果:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pn"><img src="../Images/6332ccb9ac1a8993a5e7f958e5a827aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n9r4tjvV_m5RdLfBxQ0RnQ.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">These jsPerf test results show that Object.prototype.toString.call([]) is about 20% slower than other methods, such as Array.isArray().</figcaption></figure><p id="fcac" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">(<em class="or">作者注</em> : jsPerf目前关闭<a class="ae li" href="https://github.com/jsperf/jsperf.com/pull/535" rel="noopener ugc nofollow" target="_blank">，等待一些配置</a>来重新启动它。我希望作者们能尽快让它重新工作起来。🙏)</p><p id="6974" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">总结就是<code class="fe iy iz ja jb b">Array.isArray()</code>和<code class="fe iy iz ja jb b">.constructor</code>或者<code class="fe iy iz ja jb b">instanceof</code>一样快，但是<code class="fe iy iz ja jb b">Object.prototype.toString.call([])</code>要慢一些。</p><p id="307e" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">默认情况下，结果支持使用<code class="fe iy iz ja jb b">Array.isArray()</code>，尽管您的个人偏好可能是使用带有<code class="fe iy iz ja jb b">null</code>检查的<code class="fe iy iz ja jb b">.constructor</code>。</p><p id="2ce3" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">但是如果你是<code class="fe iy iz ja jb b">Object.prototype.toString.call([])</code>的粉丝——不要担心！不同之处在于，这种稍慢的方法仍然非常快:在我的家用电脑上，每秒钟超过700，000，000次运算。</p><p id="7729" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">因此，除非您正在进行数万亿次数组检查，否则将任何一种方法换成另一种方法都不会显著提高代码的速度。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="703a" class="np nq iq bd nr ns nt nu nv nw nx ny nz kj oa kk ob km oc kn od kp oe kq of og bi translated">结论:如何检查JavaScript数组</h1><p id="845b" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">因为关键字<code class="fe iy iz ja jb b">typeof</code>返回<code class="fe iy iz ja jb b">null</code>和所有对象的<code class="fe iy iz ja jb b">"object"</code>——包括数组——检查数组需要另一个工具。</p><h2 id="32e6" class="ox nq iq bd nr oy oz dn nv pa pb dp nz ls pc pd ob lw pe pf od ma pg ph of iw bi translated">数组特定的方法</h2><p id="2b1d" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">ES5帮助器方法<code class="fe iy iz ja jb b">Array.isArray()</code>会快速简单地告诉你任何JavaScript变量是否是数组:<code class="fe iy iz ja jb b">Array.isArray([]) // true</code>，它对<code class="fe iy iz ja jb b">null</code>和<code class="fe iy iz ja jb b">undefined</code>有效(但对未声明的变量无效)。</p><p id="75d8" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">从Internet Explorer 9开始，<code class="fe iy iz ja jb b">Array.isArray()</code>方法<a class="ae li" href="http://kangax.github.io/compat-table/es5/#test-Array.isArray" rel="noopener ugc nofollow" target="_blank">在所有浏览器</a>中得到广泛支持，因为它是ECMAScript 5规范的一部分。</p><p id="c245" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">你可能会看到使用过的<code class="fe iy iz ja jb b">instanceof</code>:<code class="fe iy iz ja jb b">[] instanceof Array // true</code>，但是不推荐使用<code class="fe iy iz ja jb b">instanceof</code>，因为它在<code class="fe iy iz ja jb b">iframes</code>中不起作用。</p><h2 id="1c78" class="ox nq iq bd nr oy oz dn nv pa pb dp nz ls pc pd ob lw pe pf od ma pg ph of iw bi translated">适用于任何对象的方法</h2><p id="43b9" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">有几种方法对检查数组很有用，因为它们可以用来确定任何JavaScript对象的类型。</p><p id="ce9b" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">更通用的方法<code class="fe iy iz ja jb b">Object.prototype.toString.call([]) // "[object Array]"</code>会告诉你任何值是什么类型的对象，包括原语。</p><p id="6edd" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">为了捕获类型，可以用<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank">.slice()</a></code> : <code class="fe iy iz ja jb b">Object.prototype.toString.call([]).slice(8,-1) // Array</code>处理该字符串</p><p id="42cd" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">类似地，<code class="fe iy iz ja jb b">.constructor</code>属性将返回JavaScript值的构造函数。对于数组，这是内置的全局<code class="fe iy iz ja jb b">function Array()</code>。</p><p id="3ecb" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">该函数可以与全局对象(即<code class="fe iy iz ja jb b">Array</code>)进行比较，或者构造函数的<code class="fe iy iz ja jb b">.name</code>属性可以作为字符串:<code class="fe iy iz ja jb b">[].constructor.name // "Array"</code>进行访问。</p><p id="f9f5" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">然而，<code class="fe iy iz ja jb b">.constructor</code>有一个缺点，你可以给它赋一个新的值，从而否定你的数组检查:<code class="fe iy iz ja jb b">[].constructor = 3 // valid</code></p><h2 id="2d32" class="ox nq iq bd nr oy oz dn nv pa pb dp nz ls pc pd ob lw pe pf od ma pg ph of iw bi translated">检查未声明的数组</h2><p id="31cb" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">关键字<code class="fe iy iz ja jb b"><a class="ae li" href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener">typeof</a></code>不会将数组与其他对象区分开来，尽管<code class="fe iy iz ja jb b">typeof</code>对于筛选出未声明的变量仍然有用。</p><p id="4400" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">当<code class="fe iy iz ja jb b">typeof</code>关键字返回<code class="fe iy iz ja jb b">"object"</code>时，我们知道变量已经被声明并被赋值<a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">或者是一个对象或者是一个</a> <code class="fe iy iz ja jb b"><a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">null</a></code> <a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">值</a>。</p><p id="a92a" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">同时，<code class="fe iy iz ja jb b">typeof</code>将为未声明的变量返回<code class="fe iy iz ja jb b">"<a class="ae li" href="https://medium.com/coding-at-dawn/how-to-check-for-undefined-in-javascript-bcedd62c8ad" rel="noopener">undefined</a>"</code>,而不是抛出一个<code class="fe iy iz ja jb b">ReferenceError</code>,如果你认为你可能正在处理一个未声明的变量，那么首先检查<code class="fe iy iz ja jb b">typeof</code>是很有用的。</p><p id="01f3" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">一旦我们知道变量是使用<code class="fe iy iz ja jb b">typeof</code>声明的(无论是<code class="fe iy iz ja jb b">=== "object"</code>还是<code class="fe iy iz ja jb b">!== "undefined"</code>，我们就可以确定地使用<code class="fe iy iz ja jb b">Array.isArray()</code>。</p><h2 id="ae53" class="ox nq iq bd nr oy oz dn nv pa pb dp nz ls pc pd ob lw pe pf od ma pg ph of iw bi translated">检查空数组</h2><p id="1135" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">最后，当我们确定我们有一个数组时(即当<code class="fe iy iz ja jb b">Array.isArray()</code>返回<code class="fe iy iz ja jb b">true</code>时)，我们可以使用<code class="fe iy iz ja jb b">.length</code>检查数组是否为空。</p><p id="779e" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><code class="fe iy iz ja jb b">0</code>的一个<code class="fe iy iz ja jb b">.length</code>表示一个空的JavaScript数组<code class="fe iy iz ja jb b">[]</code>，而一个带<code class="fe iy iz ja jb b">.length &gt; 0</code>的数组表示一个非空数组。</p><p id="1633" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">注意，空数组<code class="fe iy iz ja jb b">[]</code>是真的，这意味着当作为布尔值计算时，它返回真。(<code class="fe iy iz ja jb b">[]</code>是真的，因为<a class="ae li" href="https://medium.com/coding-in-simple-english/what-are-truthy-values-in-javascript-e037bdfa76f8" rel="noopener">所有对象都是真的</a>。)</p><h2 id="0202" class="ox nq iq bd nr oy oz dn nv pa pb dp nz ls pc pd ob lw pe pf od ma pg ph of iw bi translated">检查数组的最佳方法</h2><p id="e68e" class="pw-post-body-paragraph lj lk iq ll b lm oh ke lo lp oi kh lr ls oj lu lv lw ok ly lz ma ol mc md me ij bi translated">我介绍了检查JavaScript数组的5种不同方法。出于几个原因，我通常在编码时使用<code class="fe iy iz ja jb b">Array.isArray()</code>:</p><ul class=""><li id="7c34" class="mu mv iq ll b lm ln lp lq ls mw lw mx ma my me mz na nb nc bi translated"><code class="fe iy iz ja jb b">Array.isArray()</code>速度快，支持面广。</li><li id="24e6" class="mu mv iq ll b lm nd lp ne ls nf lw ng ma nh me mz na nb nc bi translated"><code class="fe iy iz ja jb b">Array.isArray()</code>是显式的，使你的代码更具可读性。</li><li id="b7cd" class="mu mv iq ll b lm nd lp ne ls nf lw ng ma nh me mz na nb nc bi translated"><code class="fe iy iz ja jb b">Array.isArray()</code>为<code class="fe iy iz ja jb b">null</code>和<code class="fe iy iz ja jb b">undefined</code>返回<code class="fe iy iz ja jb b">false</code>。</li></ul><p id="50b3" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">有时，我会将数组检查封装在一个<code class="fe iy iz ja jb b">if(typeof !== "undefined") </code>语句中，这是我担心未声明变量的罕见情况。</p><p id="6bf0" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">但除此之外，我将使用<code class="fe iy iz ja jb b">Array.isArray()</code>——它只是工作。</p><p id="8f30" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">现在，开始自信地检查数组吧！</p><p id="f5a4" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><strong class="ll je">快乐编码！</strong>💻🎶👓💯🤩</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="16e7" class="np nq iq bd nr ns nt nu nv nw nx ny nz kj oa kk ob km oc kn od kp oe kq of og bi translated">进一步阅读</h1><ul class=""><li id="f689" class="mu mv iq ll b lm oh lp oi ls po lw pp ma pq me mz na nb nc bi translated"><a class="ae li" href="https://codewithhugo.com/detecting-object-vs-array-in-javascript-by-example/" rel="noopener ugc nofollow" target="_blank">Hugo</a>代码覆盖<code class="fe iy iz ja jb b">Array.isArray()</code>所有可能的数据类型:</li></ul><div class="pr ps gp gr pt pu"><a href="https://codewithhugo.com/detecting-object-vs-array-in-javascript-by-example/" rel="noopener  ugc nofollow" target="_blank"><div class="pv ab fo"><div class="pw ab px cl cj py"><h2 class="bd je gy z fp pz fr fs qa fu fw jd bi translated">JavaScript数组类型检查-“is array”vs .使用Hugo的对象深度代码</h2><div class="qb l"><h3 class="bd b gy z fp pz fr fs qa fu fw dk translated">本节示例在observablehq . com/@ Hugo df/JavaScript-array-detection-using-array-is array，可以玩…</h3></div><div class="qc l"><p class="bd b dl z fp pz fr fs qa fu fw dk translated">codewithhugo.com</p></div></div><div class="qd l"><div class="qe l qf qg qh qd qi lc pu"/></div></div></a></div><ul class=""><li id="b2c4" class="mu mv iq ll b lm ln lp lq ls mw lw mx ma my me mz na nb nc bi translated">才华横溢的作者<a class="pl pm ep" href="https://medium.com/u/829a804ea5da?source=post_page-----6ad20f7a0e21--------------------------------" rel="noopener" target="_blank"> Samantha Ming </a>讨论为什么不使用<code class="fe iy iz ja jb b">instanceof</code>:</li></ul><div class="pr ps gp gr pt pu"><a href="https://medium.com/dailyjs/better-array-check-with-array-isarray-dae0283263be" rel="noopener follow" target="_blank"><div class="pv ab fo"><div class="pw ab px cl cj py"><h2 class="bd je gy z fp pz fr fs qa fu fw jd bi translated">使用Array.isArray进行更好的数组检查</h2><div class="qb l"><h3 class="bd b gy z fp pz fr fs qa fu fw dk translated">因为数组在JavaScript中不是真正的数组，所以没有简单类型的检查。没问题！使用方法…</h3></div><div class="qc l"><p class="bd b dl z fp pz fr fs qa fu fw dk translated">medium.com</p></div></div><div class="qd l"><div class="qj l qf qg qh qd qi lc pu"/></div></div></a></div><ul class=""><li id="4f1c" class="mu mv iq ll b lm ln lp lq ls mw lw mx ma my me mz na nb nc bi translated">作者<a class="pl pm ep" href="https://medium.com/u/994dcd5bc2e8?source=post_page-----6ad20f7a0e21--------------------------------" rel="noopener" target="_blank"> Moon </a>在更好的编程中更详细地描述了<code class="fe iy iz ja jb b">Object.prototype.toString.call([])</code>方法<a class="ae li" href="https://medium.com/better-programming/what-is-object-object-in-javascript-object-prototype-tostring-1db888c695a4" rel="noopener">:</a></li></ul><div class="pr ps gp gr pt pu"><a href="https://medium.com/better-programming/what-is-object-object-in-javascript-object-prototype-tostring-1db888c695a4" rel="noopener follow" target="_blank"><div class="pv ab fo"><div class="pw ab px cl cj py"><h2 class="bd je gy z fp pz fr fs qa fu fw jd bi translated">JavaScript:Object . prototype . tostring中的[object Object]是什么</h2><div class="qb l"><h3 class="bd b gy z fp pz fr fs qa fu fw dk translated">[object Object]的更深一层的解释</h3></div><div class="qc l"><p class="bd b dl z fp pz fr fs qa fu fw dk translated">medium.com</p></div></div><div class="qd l"><div class="qk l qf qg qh qd qi lc pu"/></div></div></a></div><ul class=""><li id="9eb6" class="mu mv iq ll b lm ln lp lq ls mw lw mx ma my me mz na nb nc bi translated">我之前在更好的编程中写过<code class="fe iy iz ja jb b">typeof</code> <a class="ae li" href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener">的陷阱:</a></li></ul><div class="pr ps gp gr pt pu"><a href="https://medium.com/better-programming/how-to-check-data-types-in-javascript-using-typeof-424d0520a329" rel="noopener follow" target="_blank"><div class="pv ab fo"><div class="pw ab px cl cj py"><h2 class="bd je gy z fp pz fr fs qa fu fw jd bi translated">如何使用typeof检查JavaScript中的数据类型</h2><div class="qb l"><h3 class="bd b gy z fp pz fr fs qa fu fw dk translated">检查九个字符串之一:undefined、object (null)、boolean、number、bigint、string、symbol、function或object…</h3></div><div class="qc l"><p class="bd b dl z fp pz fr fs qa fu fw dk translated">medium.com</p></div></div><div class="qd l"><div class="ql l qf qg qh qd qi lc pu"/></div></div></a></div><ul class=""><li id="4f57" class="mu mv iq ll b lm ln lp lq ls mw lw mx ma my me mz na nb nc bi translated">我还在一篇文章<a class="ae li" href="https://medium.com/javascript-in-plain-english/the-best-way-to-type-check-in-vanilla-js-55197b4f45ec" rel="noopener">中用简单英语写了关于类型检查的<code class="fe iy iz ja jb b">Object.prototype.toString.call([])</code>方法的文章</a>:</li></ul><div class="pr ps gp gr pt pu"><a href="https://medium.com/javascript-in-plain-english/the-best-way-to-type-check-in-vanilla-js-55197b4f45ec" rel="noopener follow" target="_blank"><div class="pv ab fo"><div class="pw ab px cl cj py"><h2 class="bd je gy z fp pz fr fs qa fu fw jd bi translated">在普通JS中键入Check的最佳方式</h2><div class="qb l"><h3 class="bd b gy z fp pz fr fs qa fu fw dk translated">在JavaScript中检查变量类型的最好方法不是type of。以下是使用的原因…</h3></div><div class="qc l"><p class="bd b dl z fp pz fr fs qa fu fw dk translated">medium.com</p></div></div><div class="qd l"><div class="qm l qf qg qh qd qi lc pu"/></div></div></a></div><ul class=""><li id="186a" class="mu mv iq ll b lm ln lp lq ls mw lw mx ma my me mz na nb nc bi translated"><a class="pl pm ep" href="https://medium.com/u/e9031892baf5?source=post_page-----6ad20f7a0e21--------------------------------" rel="noopener" target="_blank">布兰登·莫雷利</a>在代码突发中解释短路算子井<a class="ae li" href="https://codeburst.io/javascript-what-is-short-circuit-evaluation-ff22b2f5608c" rel="noopener" target="_blank">:</a></li></ul><div class="pr ps gp gr pt pu"><a href="https://codeburst.io/javascript-what-is-short-circuit-evaluation-ff22b2f5608c" rel="noopener follow" target="_blank"><div class="pv ab fo"><div class="pw ab px cl cj py"><h2 class="bd je gy z fp pz fr fs qa fu fw jd bi translated">JavaScript:什么是短路评估？</h2><div class="qb l"><h3 class="bd b gy z fp pz fr fs qa fu fw dk translated">学习如何使用逻辑OR ( ||)来分配变量。</h3></div><div class="qc l"><p class="bd b dl z fp pz fr fs qa fu fw dk translated">codeburst.io</p></div></div><div class="qd l"><div class="qn l qf qg qh qd qi lc pu"/></div></div></a></div></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="fabe" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><a class="ae li" href="https://www.linkedin.com/in/derek-austin/" rel="noopener ugc nofollow" target="_blank">Derek Austin</a>博士是《职业编程:如何在6个月内成为一名成功的6位数程序员 》一书的作者，该书现已在亚马逊上架。</p></div></div>    
</body>
</html>