<html>
<head>
<title>Data Structures: Heaps in Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构:代码中的堆</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/heaps-of-data-structures-creating-heaps-in-code-80d215dcf53d?source=collection_archive---------3-----------------------#2019-10-10">https://javascript.plainenglish.io/heaps-of-data-structures-creating-heaps-in-code-80d215dcf53d?source=collection_archive---------3-----------------------#2019-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/54e2c4b4e5d518bf0cf6fd27b8c1f169.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NFKFjJG7FDMTirA4vGT2LQ.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@olianayda?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Olia Nayda</a> on <a class="ae jd" href="https://unsplash.com/s/photos/mound?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="025c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天我们将讨论数据结构堆，了解它们是什么，以及如何使用JavaScript构建它们。在软件工程之外，堆的定义是</p><blockquote class="lb lc ld"><p id="e161" class="kd ke le kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">一堆乱七八糟地堆在一起的东西。</p></blockquote><p id="746d" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很讽刺，因为堆数据结构非常有序。如果你还记得我写的关于<a class="ae jd" href="https://medium.com/javascript-in-plain-english/binary-search-trees-how-they-work-9c64029eedb7" rel="noopener">二分搜索法树</a>的文章，二分搜索法树是这样的树，其中根节点右边的所有节点都大于根节点，而左边的所有节点都小于根节点。堆的排序也有类似的目的，但是我们不是从左到右排序，而是上下排序。</p><p id="d041" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两种类型的堆，最大堆和最小堆。一个<strong class="kf jh">最大堆</strong>将从一个根号开始，该根号是整个树中的最大值。它的孩子会比它小，他们的每个孩子会比那个孩子小，如此等等。</p><p id="185c" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如你的直觉可能已经告诉你的，最小堆恰恰相反。在最小堆中，从一个根节点开始，它将是整个树中最低的值。它的每个孩子都会比它大，孩子的每个孩子都会比孩子大。</p><figure class="lj lk ll lm gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi li"><img src="../Images/3f532f5560a884f57e4af5e0714d997f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2XhoV0IYgNlRxQ8jCW1Guw.png"/></div></div></figure><p id="8498" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些堆的例子具体是二进制堆，尽管<strong class="kf jh">堆不一定是二进制的</strong>，只要它们符合最小堆或最大堆的规则。</p><h1 id="62b1" class="ln lo jg bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">JavaScript中的堆</h1><p id="0cc7" class="pw-post-body-paragraph kd ke jg kf b kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw mp ky kz la ij bi translated">这与用代码构建其他类型的树没有什么不同，我们在前面的文章中已经详细讨论过了。但是让我们使用JavaScript构建上面的这两棵树，这样我们就可以看到它是如何工作的。</p><p id="1525" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将从上面的最小堆结构开始。我们有节点集:</p><pre class="lj lk ll lm gt mq mr ms mt aw mu bi"><span id="20a3" class="mv lo jg mr b gy mw mx l my mz">let nodes = [3, 5, 8, 6, 11, 15];</span></pre><p id="bda4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个节点可以表示为一个JavaScript对象，包含根节点、右边的子节点和左边的子节点。从根节点开始，我们有:</p><pre class="lj lk ll lm gt mq mr ms mt aw mu bi"><span id="ceec" class="mv lo jg mr b gy mw mx l my mz">let rootNode = {element: 3, rightChild: null, leftChild null};</span></pre><p id="97e8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望为集合中的每个节点创建相同的数据结构，并让左右子节点指向其他节点。</p><pre class="lj lk ll lm gt mq mr ms mt aw mu bi"><span id="6c68" class="mv lo jg mr b gy mw mx l my mz">let fifteen = {element: 15, rightChild: null, leftChild: null};<br/>let eleven = {element: 11, rightChild: null, leftChild: null};<br/>let six = {element: 6, rightChild: null, leftChild: null};<br/>let eight = {element: 8, rightChild: null, leftChild: fifteen};<br/>let five = {element: 5, rightChild: eleven, leftChild: six}<br/>let rootNode = {element: 3, rightChild: eight, leftChild: five};</span></pre><p id="9210" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构建上面的max-heap，我们将有类似的对象，但它们将指向本质上相反的顺序。我们将从一个15的根节点开始，一直到3。</p><pre class="lj lk ll lm gt mq mr ms mt aw mu bi"><span id="091a" class="mv lo jg mr b gy mw mx l my mz">let three= {element: 3, rightChild: null, leftChild: null};<br/>let five= {element: 5, rightChild: null, leftChild: null};<br/>let six = {element: 6, rightChild: null, leftChild: null};<br/>let eight = {element: 8, rightChild: null, leftChild: three};<br/>let eleven = {element: 11, rightChild: five, leftChild: six}<br/>let rootNode = {element: 15, rightChild: eight, leftChild: eleven};</span></pre><p id="0abb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要认识到的一件大事是，在构建堆之前需要进行排序，这比构建二叉查找树要多得多。这些节点集从一开始就或多或少地进行了排序，这使得我们可以整齐地构建我们的堆，而不必进行搜索。但是如果我们没有一个有序的节点集呢？如果节点集看起来像这样会怎么样:</p><pre class="lj lk ll lm gt mq mr ms mt aw mu bi"><span id="f8fe" class="mv lo jg mr b gy mw mx l my mz">let nodes = [6, 5, 11, 3, 8, 15];</span></pre><p id="1d6f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了创建一个最小堆，我们还需要从根节点3 开始。在二叉查找树中，我们可以从6开始，让5成为左孩子，11成为右孩子，然后让3成为5的左孩子。在一堆我们没有这种灵活性。3必须是最小堆的根节点，15必须是最大堆的根节点。</p><p id="a100" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些细微差别就是为什么我们对数据结构有这么多不同的选择。每一种都有其最佳选择的情况，而每一种在其他情况下都是无法大规模维持的。了解细节对于根据不同需求选择合适的选项至关重要。</p></div></div>    
</body>
</html>