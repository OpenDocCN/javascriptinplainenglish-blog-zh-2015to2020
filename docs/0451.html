<html>
<head>
<title>React Hooks to optimize performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应挂钩以优化性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-hooks-to-optimize-performance-2bb876b25d67?source=collection_archive---------5-----------------------#2019-10-17">https://javascript.plainenglish.io/react-hooks-to-optimize-performance-2bb876b25d67?source=collection_archive---------5-----------------------#2019-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="503c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">useMemo和useCallback hooks使用指南来提高我们的应用程序的性能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/92b6a3ec576b7f3666b69283724e9f0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I2GE6Lu5ycNWuk4K"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@christianem?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christian Englmeier</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fe64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们用<strong class="ky ir"> React </strong>开发应用程序时，我们会担心它的性能(越快越好😛).一般来说，一旦我们开始开发中型应用程序，优化和性能通常是最头疼的问题之一。</p><p id="3e23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，利用对<strong class="ky ir"> React挂钩</strong>的整合，我想提出一些解决方案，帮助避免导致应用程序性能低下的两个典型问题:</p><ul class=""><li id="fd29" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">不必要的重新渲染。</li><li id="e715" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在组件中重复繁重的计算运算。</li></ul><p id="1722" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi mj b"><strong class="ky ir">useCallback</strong></code>和<code class="fe mg mh mi mj b"><strong class="ky ir">useMemo</strong></code>钩子是两个简单的工具，使用它们我们可以防止一些导致这种问题的情况。</p><p id="530c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看他们！</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="8a4a" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">不必要的重新渲染</h1><p id="ae96" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">众所周知，当<code class="fe mg mh mi mj b">props</code>或React组件的状态发生变化时，它会自动重新渲染该组件。</p><p id="1c86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这通常是一件好事，事实上这就是React的工作方式。然而，有时我们可以“帮助”在决定何时强制重新渲染的任务中做出反应，以节省多余的周期，因为正如您所知，如何在屏幕上绘画是应用程序必须面对的最昂贵的操作之一。</p><p id="d8ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注</strong>。如果你对React的虚拟Dom是如何工作的感到好奇，我留下一篇我不久前写的文章。</p><p id="96b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/@ger86/y-eso-del-virtual-dom-de-react-qu%C3%A9-es-3feed6366925" rel="noopener">https://medium . com/@ ger 86/y-ESO-del-virtual-DOM-de-react-qué-es-3 feed 6366925</a></p><p id="4c71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些重新呈现的一个常见原因是每次组件更改时都要向子组件传递一个新函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/9fa4a8f541e8ad42b9da572c3fbb1018.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dM0vobE39S48DhZP3kMfRA.png"/></div></div></figure><p id="7968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们在每次呈现<code class="fe mg mh mi mj b">ComponentContainer</code>时都创建一个匿名函数，这迫使在<code class="fe mg mh mi mj b">Component</code>组件中呈现，因为属性(即使函数也是这样)已经改变了(我们传递给它一个新的“对象”)。</p><p id="acf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果底层数据没有改变，这种重新呈现可能变得不必要。</p><p id="ff89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了避免这种情况，我们可以使用<code class="fe mg mh mi mj b"><strong class="ky ir">useCallback</strong></code> <strong class="ky ir">钩子</strong>，它“记忆”该函数，并且只在其中一个指定的依赖关系改变时才返回“重建”:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/59b5c87e2dfbfd59261f1d3d4c0880d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZcWn734z1JdlgQ2E3Vy1_w.png"/></div></div></figure><p id="74da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这种方式，<code class="fe mg mh mi mj b">Component</code>组件将总是收到对<code class="fe mg mh mi mj b">handleItemClick</code>的相同回调，直到<code class="fe mg mh mi mj b">item</code>或<code class="fe mg mh mi mj b">onClick</code>元素发生变化。这将<strong class="ky ir">防止我们不必要的渲染。</strong></p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="0a0a" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">昂贵的计算</h1><p id="bdbb" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">导致<strong class="ky ir"> React </strong>性能不佳的另一个原因可能是组件内计算的复杂性。</p><p id="2196" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此时，<code class="fe mg mh mi mj b"><strong class="ky ir">useMemo</strong></code> <code class="fe mg mh mi mj b"><strong class="ky ir">useMemo</strong></code>特别有用，因为它允许“记忆”一个值，以便在需要时随时获取，而无需重新计算，直到计算的依赖关系改变。</p><p id="3862" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi no"><img src="../Images/3074a5343a5732088d0ee8acd200be91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FX4albt6RzgrxMDeuWTlZQ.png"/></div></div></figure><p id="2c30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们将在每次更新<code class="fe mg mh mi mj b">ListContainer</code>组件时保存重新计算的过滤列表，直到依赖项(在本例中是<code class="fe mg mh mi mj b">items</code>属性)改变。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="0aef" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">最后的想法</h1><p id="d52d" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">尽管这是一篇相当短的文章，但我相信这些类型的出版物有助于您熟悉诸如<strong class="ky ir"> hooks </strong>之类的工具，并找到帮助我们解决使用React开发应用程序时可能会遇到的问题的用例。</p><p id="b8d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望你喜欢这篇文章！</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="99a0" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">你想看更多这样的文章吗？</h1><p id="7367" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">如果你喜欢这篇文章，我鼓励你订阅我每周日发送的时事通讯，里面有类似的出版物和更多的推荐内容:👇👇👇</p><div class="np nq gp gr nr ns"><a href="https://eepurl.us20.list-manage.com/subscribe?u=c14cad2102bcf33bf216cc69e&amp;id=2790da9378" rel="noopener  ugc nofollow" target="_blank"><div class="nt ab fo"><div class="nu ab nv cl cj nw"><h2 class="bd ir gy z fp nx fr fs ny fu fw ip bi translated">拿铁和代码</h2><div class="nz l"><h3 class="bd b gy z fp nx fr fs ny fu fw dk translated">这是一份最新的时事通讯，代码是recibirás cada domingo。——洛斯多斯乌尔蒂莫斯艺术博物馆……</h3></div><div class="oa l"><p class="bd b dl z fp nx fr fs ny fu fw dk translated">eepurl.us20.list-manage.com</p></div></div><div class="ob l"><div class="oc l od oe of ob og kp ns"/></div></div></a></div></div></div>    
</body>
</html>