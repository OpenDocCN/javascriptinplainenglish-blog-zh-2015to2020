<html>
<head>
<title>React Context: Why am I getting unnecessary re-renders?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应上下文:为什么我得到了不必要的重新渲染？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-context-why-am-i-getting-unnecessary-re-renders-b61836d224a7?source=collection_archive---------0-----------------------#2020-01-13">https://javascript.plainenglish.io/react-context-why-am-i-getting-unnecessary-re-renders-b61836d224a7?source=collection_archive---------0-----------------------#2020-01-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7f27570abfcd0911b4d848a143572b60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h0_JpU3miAKOybLm"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@tim_denn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tim Dennert</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d87b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嘿，大家好，在过去的一周里，我一直在努力理解React Context的一些内幕。我想知道的是——为什么每次上下文变量更新时，我的组件都会重新呈现？</p><p id="dec1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本文包括我的研究结果，以及避免这一问题的建议方法。</p><p id="ffac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了更好地理解这个问题，我们将使用下面的例子:</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">someContext.js</figcaption></figure><p id="ad87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，我们创建了一些东西:</p><ul class=""><li id="eec9" class="lh li iq kf b kg kh kk kl ko lj ks lk kw ll la lm ln lo lp bi translated"><code class="fe lq lr ls lt b">randomContext</code></li><li id="507d" class="lh li iq kf b kg lu kk lv ko lw ks lx kw ly la lm ln lo lp bi translated">一个<code class="fe lq lr ls lt b">useRandomContext</code>定制挂钩</li><li id="d8f5" class="lh li iq kf b kg lu kk lv ko lw ks lx kw ly la lm ln lo lp bi translated">一个<code class="fe lq lr ls lt b">randomStore</code>，我们创建了两个状态变量和一个效果，当<code class="fe lq lr ls lt b">something</code>变量内容改变时，更新<code class="fe lq lr ls lt b">otherThing</code>变量。</li><li id="0e90" class="lh li iq kf b kg lu kk lv ko lw ks lx kw ly la lm ln lo lp bi translated">一个<code class="fe lq lr ls lt b">randomContextProvider</code>用于包装将使用上下文的组件。</li></ul><p id="fe78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们创建一个组件。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">someComponent.js</figcaption></figure><p id="0f5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个组件上，我们使用<code class="fe lq lr ls lt b">useRandomContext</code>钩子来订阅我们的上下文并添加一个按钮，当点击这个按钮时会更新<code class="fe lq lr ls lt b">something</code>状态变量。</p><p id="04da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们已经具备了找到手头“问题”的条件。通过将console.log(“我刚刚渲染了”)添加到组件的根，我们将能够看到所有的渲染和重新渲染。</p><p id="7809" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们按下那个按钮。现在我们期望在控制台上只看到一个<code class="fe lq lr ls lt b">I just rendered</code>，因为我们只做了一个<code class="fe lq lr ls lt b">setSomething</code>并更新了<code class="fe lq lr ls lt b">something</code>变量。我们忘记的是，当<code class="fe lq lr ls lt b">something</code>改变时，效果将更新<code class="fe lq lr ls lt b">otherThing</code>，并因此更新我们的上下文，并导致第二次重新渲染和第二次日志。</p><h1 id="f283" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">为什么会这样？</h1><p id="12b7" class="pw-post-body-paragraph kd ke iq kf b kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">每当<em class="nc"> React </em>检测到其上下文中的某个变化时，它会触发对所有<em class="nc">上下文</em>订阅者的重新呈现，以便它们可以接收新的变化。</p><h1 id="1935" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">我能做些什么来避免这种情况？</h1><h2 id="3f18" class="nd ma iq bd mb ne nf dn mf ng nh dp mj ko ni nj mn ks nk nl mr kw nm nn mv no bi translated">拆分上下文</h2><p id="6df2" class="pw-post-body-paragraph kd ke iq kf b kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">这是<strong class="kf ir"> <em class="nc">首选的</em> </strong>方法，包括将经常变化的变量传递给另一个上下文。在这种情况下，我们将创建第二个上下文，在其中添加<code class="fe lq lr ls lt b">otherThing</code>变量，并将其从另一个上下文中移除。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">splitContexts.js</figcaption></figure><h2 id="53b1" class="nd ma iq bd mb ne nf dn mf ng nh dp mj ko ni nj mn ks nk nl mr kw nm nn mv no bi translated">将组件一分为二，然后使用memo</h2><p id="6654" class="pw-post-body-paragraph kd ke iq kf b kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">这种方法包括将第一个组件的返回转移到第二个组件。第二个组件将被用备忘录<em class="nc">包装，并接收所需的上下文变量作为道具。</em></p><p id="d654" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这种情况下，第一个组件仍然会重新渲染，但它不会很昂贵，因为它不会做任何事情。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">appWithMemo.js</figcaption></figure><h2 id="bf91" class="nd ma iq bd mb ne nf dn mf ng nh dp mj ko ni nj mn ks nk nl mr kw nm nn mv no bi translated">在你的退货单上附上使用备忘录</h2><p id="bd9d" class="pw-post-body-paragraph kd ke iq kf b kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">如果我们不想分割我们的组件，我们可以用<em class="nc"> useMemo </em>钩子来包装我们的返回。我们的组件仍然会重新呈现，但只有当<em class="nc"> useMemo </em>观察到的变量发生变化时，才会返回新的变化。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="lf lg l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">appWithUseMemo.js</figcaption></figure></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="bf82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在写这篇文章的时候，有一个<a class="ae kc" href="https://github.com/reactjs/rfcs/pull/119" rel="noopener ugc nofollow" target="_blank"> RFC </a>提议创建一个<code class="fe lq lr ls lt b">useContextSelector</code>。在这个钩子中，我们观察选择器的变化，而不是整个上下文。</p><h1 id="d10c" class="lz ma iq bd mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw bi translated">结论</h1><p id="5c11" class="pw-post-body-paragraph kd ke iq kf b kg mx ki kj kk my km kn ko mz kq kr ks na ku kv kw nb ky kz la ij bi translated">尽管<em class="nc">上下文API </em>非常有用，但是如果使用不当，它也会造成一些混乱。如今，开发人员倾向于更早地考虑优化性能，而不是建立适当的准则并遵循建议。性能优化通常伴随着牺牲代码可读性的缺点，因此必须小心进行，因为它可能成为一把双刃剑。</p><p id="1401" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当应用这里描述的方法时，开发人员必须总是尝试使用第一种方法，因为它不需要任何类型的救助或记忆。</p><p id="5164" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为TLDR的一名成员，你可以查看twitter上促使我写这篇文章的帖子。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nw lg l"/></div></figure><p id="b22b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还添加了一个沙箱，里面有解决“问题”的方法。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nx lg l"/></div></figure><p id="a3fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这篇文章，并继续关注未来的文章。</p></div></div>    
</body>
</html>