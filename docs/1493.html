<html>
<head>
<title>How to read files with Buffer &amp; Stream in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Node.js中用Buffer &amp; Stream读取文件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-read-files-with-buffer-stream-in-node-js-d77de6ae6b49?source=collection_archive---------0-----------------------#2020-03-24">https://javascript.plainenglish.io/how-to-read-files-with-buffer-stream-in-node-js-d77de6ae6b49?source=collection_archive---------0-----------------------#2020-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/974757bfd1d280fab547670c3e326d73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qz_QQwwUSc2if5WVBihAtA.png"/></div></div></figure><blockquote class="jy"><p id="1a7b" class="jz ka iq bd kb kc kd ke kf kg kh ki dk translated">有两种方法可以读写文件；1)缓冲区2)流</p></blockquote><h1 id="3e4b" class="kj kk iq bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">缓冲和流的一般概念</h1><ul class=""><li id="49fd" class="lh li iq lj b lk ll lm ln lo lp lq lr ls lt ki lu lv lw lx bi translated">缓冲或缓冲和流通常用于互联网上的视频播放器，如Youtube</li><li id="22a4" class="lh li iq lj b lk ly lm lz lo ma lq mb ls mc ki lu lv lw lx bi translated">缓冲是收集数据以播放视频的操作</li><li id="d471" class="lh li iq lj b lk ly lm lz lo ma lq mb ls mc ki lu lv lw lx bi translated">流式传输是将数据从服务器传输到观众的电脑</li></ul></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="0cbf" class="kj kk iq bd kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc mo le lf lg bi translated">Node.js中缓冲区和流的概念</h1><p id="5bd7" class="pw-post-body-paragraph mp mq iq lj b lk ll mr ms lm ln mt mu lo mv mw mx lq my mz na ls nb nc nd ki ij bi translated"><em class="ne">node . js中的Buffer和Stream其实和一般概念</em>差不多</p><ul class=""><li id="b435" class="lh li iq lj b lk nf lm ng lo nh lq ni ls nj ki lu lv lw lx bi translated">当读取文件时，Node.js分配与文件大小一样多的内存，并将文件数据保存到内存中</li><li id="00ee" class="lh li iq lj b lk ly lm lz lo ma lq mb ls mc ki lu lv lw lx bi translated">Buffer表示文件数据驻留的内存</li></ul></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="7473" class="kj kk iq bd kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc mo le lf lg bi translated">缓冲器</h1><figure class="nl nm nn no gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/a9a89acf0000c816abe657fb5b615ddf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*d42XK3FY-6TXI43N.png"/></div></div></figure><p id="2747" class="pw-post-body-paragraph mp mq iq lj b lk nf mr ms lm ng mt mu lo np mw mx lq nq mz na ls nr nc nd ki ij bi translated">Node.js有一个名为<strong class="lj ir"> Buffer </strong>的内部缓冲对象</p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk">buffer.js</figcaption></figure><h2 id="299b" class="ny kk iq bd kl nz oa dn kp ob oc dp kt lo od oe kx lq of og lb ls oh oi lf oj bi translated"><strong class="ak"> Buffer </strong>对象有很多可用的方法</h2><ul class=""><li id="8280" class="lh li iq lj b lk ll lm ln lo lp lq lr ls lt ki lu lv lw lx bi translated"><strong class="lj ir"> from( &lt; string &gt; ) </strong>:将字符串转换为缓冲区</li><li id="16b5" class="lh li iq lj b lk ly lm lz lo ma lq mb ls mc ki lu lv lw lx bi translated"><strong class="lj ir">toString(&lt;String&gt;)</strong>:将缓冲区转换为字符串</li><li id="8a65" class="lh li iq lj b lk ly lm lz lo ma lq mb ls mc ki lu lv lw lx bi translated"><strong class="lj ir"> concat( &lt; List &gt; ) </strong>:在一个数组中连接缓冲区</li><li id="3547" class="lh li iq lj b lk ly lm lz lo ma lq mb ls mc ki lu lv lw lx bi translated"><strong class="lj ir"> alloc( &lt;字节&gt; ) </strong>:在给定的字节长度内创建空缓冲区</li></ul></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="0f34" class="kj kk iq bd kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc mo le lf lg bi translated">缓冲问题</h1><ul class=""><li id="27af" class="lh li iq lj b lk ll lm ln lo lp lq lr ls lt ki lu lv lw lx bi translated">缓冲区方法很方便，但是有一个问题，你需要在内存中创建100MB的缓冲区来读取100MB的文件</li><li id="9dea" class="lh li iq lj b lk ly lm lz lo ma lq mb ls mc ki lu lv lw lx bi translated">如果您读取10个100MB的文件，那么您只需分配1GB的内存来读取10个文件</li><li id="01b2" class="lh li iq lj b lk ly lm lz lo ma lq mb ls mc ki lu lv lw lx bi translated">特别是，对于服务器来说，这是一个大问题，因为你不知道有多少人会同时使用(读取文件)</li></ul></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="7571" class="kj kk iq bd kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc mo le lf lg bi translated">溪流</h1><figure class="nl nm nn no gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/0399ecf1b0ab3d08ec7628401893e61e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6zUJv40cAaZtR3eu.jpg"/></div></div></figure><p id="fe4d" class="pw-post-body-paragraph mp mq iq lj b lk nf mr ms lm ng mt mu lo np mw mx lq nq mz na ls nr nc nd ki ij bi translated">Node.js有一个名为<strong class="lj ir"> createReadStream </strong>的内部流方法</p><p id="088d" class="pw-post-body-paragraph mp mq iq lj b lk nf mr ms lm ng mt mu lo np mw mx lq nq mz na ls nr nc nd ki ij bi translated"><em class="ne"> readme3.txt </em></p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d912" class="pw-post-body-paragraph mp mq iq lj b lk nf mr ms lm ng mt mu lo np mw mx lq nq mz na ls nr nc nd ki ij bi translated"><em class="ne"> createReadStream.js </em></p><figure class="nl nm nn no gt jr"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk">createReadStream</figcaption></figure><ul class=""><li id="45bf" class="lh li iq lj b lk nf lm ng lo nh lq ni ls nj ki lu lv lw lx bi translated"><strong class="lj ir"> createReadStream() </strong>方法需要2个参数</li><li id="0b06" class="lh li iq lj b lk ly lm lz lo ma lq mb ls mc ki lu lv lw lx bi translated">在第一个参数中，我们指定了文件路径</li><li id="040c" class="lh li iq lj b lk ly lm lz lo ma lq mb ls mc ki lu lv lw lx bi translated">第二个参数是可选的，而<strong class="lj ir"> highWaterMark </strong>选项有助于确定缓冲区的大小(默认为64KB，但在本例中为16字节)</li><li id="c345" class="lh li iq lj b lk ly lm lz lo ma lq mb ls mc ki lu lv lw lx bi translated">readStream使用事件监听器，如<strong class="lj ir">数据、结束、错误</strong>事件</li></ul><figure class="nl nm nn no gt jr gh gi paragraph-image"><div class="gh gi op"><img src="../Images/1a97d49bf7c2ef650b505f82e49bb3af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/1*O5fUXeR2_6bZuvbm-4X7bw.png"/></div></figure><ul class=""><li id="2fce" class="lh li iq lj b lk nf lm ng lo nh lq ni ls nj ki lu lv lw lx bi translated">由于文件大小为48字节，我们将数据传输容量设置为16字节(<strong class="lj ir"> highWaterMark </strong>选项)，我们可以看到它分3次完成数据传输</li></ul></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><h1 id="1a5d" class="kj kk iq bd kl km mk ko kp kq ml ks kt ku mm kw kx ky mn la lb lc mo le lf lg bi translated">结论</h1><h2 id="6395" class="ny kk iq bd kl nz oa dn kp ob oc dp kt lo od oe kx lq of og lb ls oh oi lf oj bi translated">与缓冲区相比，流有以下优点</h2><ul class=""><li id="e2ff" class="lh li iq lj b lk ll lm ln lo lp lq lr ls lt ki lu lv lw lx bi translated">连续的数据分块(它可以在无限的时间内传输任意数量的大文件),而<strong class="lj ir">缓冲区</strong>在传输大数据方面有局限性</li><li id="7b0f" class="lh li iq lj b lk ly lm lz lo ma lq mb ls mc ki lu lv lw lx bi translated">无需等待整个资源加载，而<strong class="lj ir">缓冲</strong>需要做<em class="ne">缓冲</em> <strong class="lj ir"> <em class="ne">(等待)</em> </strong></li></ul></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><blockquote class="jy"><p id="a1b7" class="jz ka iq bd kb kc oq or os ot ou ki dk translated">谢谢你</p></blockquote><figure class="ow ox oy oz pa jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ov"><img src="../Images/aa93e3a43ee5c4d82938ee05e311fa58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9uQQJ28M4TfXOKj7"/></div></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk">Photo by <a class="ae pb" href="https://unsplash.com/@charlesdeluvio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Charles Deluvio</a> on <a class="ae pb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div></div>    
</body>
</html>