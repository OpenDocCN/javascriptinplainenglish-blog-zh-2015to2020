<html>
<head>
<title>React Tips — super, Call Child Methods, Debounce, and Inline Styles</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React提示—超级、调用子方法、反跳和内联样式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-tips-super-call-child-methods-debounce-and-inlint-styles-55a98466152e?source=collection_archive---------4-----------------------#2020-07-20">https://javascript.plainenglish.io/react-tips-super-call-child-methods-debounce-and-inlint-styles-55a98466152e?source=collection_archive---------4-----------------------#2020-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d13f9ba69a18b8a4325b50ca2b62df9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*UqHaSTQkvFw6A6Wq"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sherihoo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sheri Hooley</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cc1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些编写更好的React应用程序的技巧。</p><h1 id="91fd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用ES6类时React中“super()”和“super(props)”的区别？</h1><p id="3a3c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">两者之间唯一的区别是当我们需要在构造函数中访问属性时。</p><p id="a265" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们需要在构造函数中获取它们，那么我们必须从参数中获取道具，并将其传递给<code class="fe me mf mg mh b">super</code>。</p><p id="17fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5010" class="mq lc iq mh b gy mr ms l mt mu">class MyComponent extends React.Component {<br/>  constructor(props) {<br/>    super(props)<br/>    console.log(this.props);<br/>  }<br/>  <br/>  render(){<br/>    //...<br/>  }<br/>}</span></pre><p id="816e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有，我们可以跳过它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1bd0" class="mq lc iq mh b gy mr ms l mt mu">class MyComponent extends React.Component {<br/>  constructor(props) {<br/>    super()<br/>  }<br/>  <br/>  render(){<br/>    //...<br/>  }<br/>}</span></pre><h1 id="5a08" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">内联风格最佳实践</h1><p id="d5b6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过传入带有<code class="fe me mf mg mh b">styles</code>或<code class="fe me mf mg mh b">className</code>属性的对象来放置内联样式。</p><p id="ccc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3869" class="mq lc iq mh b gy mr ms l mt mu">&lt;li <br/> className={classnames({ 'list-item': true, 'is-complete': item.complete })} /&gt;</span></pre><p id="a989" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用了<code class="fe me mf mg mh b">classnames</code>包来动态设置<code class="fe me mf mg mh b">li</code>元素的类名。</p><p id="d2a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="75e0" class="mq lc iq mh b gy mr ms l mt mu">&lt;li style={Object.assign({}, fooStyles, barStyles)}&gt;</span></pre><p id="52c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是通过传入一个具有所有样式属性的对象来设置样式。</p><p id="5d33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">键有属性，值就是值。</p><h1 id="2c74" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">任何时候调用setState都会调用render吗？</h1><p id="5fcd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">每次调用<code class="fe me mf mg mh b">render</code>时都会调用<code class="fe me mf mg mh b">setState</code>。</p><p id="5ff3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是为什么我们不能在<code class="fe me mf mg mh b">render</code>方法中使用<code class="fe me mf mg mh b">setState</code>的原因。</p><p id="2b9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们将得到一个无限的渲染循环。</p><p id="f4dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们不想在每次调用<code class="fe me mf mg mh b">setState</code>时都调用它，我们应该使用<code class="fe me mf mg mh b">shouldComponentUpdate</code>钩子。</p><p id="aec9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以比较状态和属性，并返回一个布尔表达式，其中包含通知React组件何时应该呈现的条件。</p><p id="d0ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">showComponentUpdate</code>瓦斯如下签名:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fa72" class="mq lc iq mh b gy mr ms l mt mu">shouldComponentUpdate(nextProps, nextState)</span></pre><h1 id="b1a8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在React中执行去抖</h1><p id="9370" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用令人敬畏的去抖承诺包来谴责React，</p><p id="0f1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8eec" class="mq lc iq mh b gy mr ms l mt mu">const searchAPI = text =&gt; fetch(`/search?text=${encodeURIComponent(text)}`);</span><span id="e489" class="mq lc iq mh b gy mv ms l mt mu">const searchAPIDebounced = AwesomeDebouncePromise(searchAPI, 500);</span><span id="0ea6" class="mq lc iq mh b gy mv ms l mt mu">class SearchInputAndResults extends React.Component {<br/>  state = {<br/>    text: '',<br/>    results: null,<br/>  };</span><span id="8f25" class="mq lc iq mh b gy mv ms l mt mu">  search = async text =&gt; {<br/>    this.setState({ text, results: null });<br/>    const result = await searchAPIDebounced(text);<br/>    this.setState({ result });<br/>  };<br/>  //...<br/>}</span></pre><p id="30d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">AwesomeDebouncePromise</code>功能将<code class="fe me mf mg mh b">searchAPI</code>功能延迟500毫秒。</p><p id="f3c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">sesrch</code>方法中，我们用包返回的承诺，用<code class="fe me mf mg mh b">setState</code>来设置数据。</p><p id="b821" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以将它与函数组件一起使用。</p><p id="4241" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fc07" class="mq lc iq mh b gy mr ms l mt mu">const searchAPI = text =&gt; fetch(`/search?text=${encodeURIComponent(text)}`);</span><span id="6353" class="mq lc iq mh b gy mv ms l mt mu">const searchAPIDebounced = AwesomeDebouncePromise(searchAPI, 500);<br/><br/>const App = () =&gt; {<br/>  const [results, setResults] = useState([]);<br/>  const [text, setText] = useState(['');</span><span id="589d" class="mq lc iq mh b gy mv ms l mt mu">  search = async text =&gt; {<br/>    const result = await searchAPIDebounced(text);<br/>    <!-- -->setResults<!-- -->(result);<br/>  };</span><span id="15dd" class="mq lc iq mh b gy mv ms l mt mu">  return (<br/>    &lt;div&gt;<br/>      &lt;input value={setText} onChange={e =&gt; setText(e.target.value)} /&gt;<br/>      &lt;div&gt;<br/>        {results &amp;&amp; (<br/>          &lt;div&gt;<br/>            &lt;ul&gt;<br/>              {results.map(r =&gt; (<br/>                &lt;li key={r.name}&gt;{r.name}&lt;/li&gt;<br/>              ))}<br/>            &lt;/ul&gt;<br/>          &lt;/div&gt;<br/>        )}<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="c4e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用相同的函数和<code class="fe me mf mg mh b">useState</code>钩子来设置完成后的状态。</p><p id="dbe5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些都在<code class="fe me mf mg mh b">search</code>功能中完成。</p><h1 id="15f2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从父方法调用子方法</h1><p id="e056" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过将引用转发给子方法来调用父方法的子方法。</p><p id="aefc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们就可以从ref中得到子方法了。</p><p id="e70f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a28c" class="mq lc iq mh b gy mr ms l mt mu">const Child = forwardRef((props, ref) =&gt; {<br/>  useImperativeHandle(ref, () =&gt; ({<br/>    hello() {<br/>      console.log("hello Child");<br/>    }<br/>  }));</span><span id="aee6" class="mq lc iq mh b gy mv ms l mt mu">  return &lt;h1&gt;Hi&lt;/h1&gt;;<br/>});</span><span id="fdfc" class="mq lc iq mh b gy mv ms l mt mu">const Parent = () =&gt; {<br/>  const childRef = useRef();</span><span id="07cb" class="mq lc iq mh b gy mv ms l mt mu">  return (<br/>    &lt;div&gt;<br/>      &lt;Child ref={childRef} /&gt;<br/>      &lt;button onClick={() =&gt; childRef.current.hello()}&gt;Click&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="5b5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一个返回组件的回调函数在孩子上调用<code class="fe me mf mg mh b">forwardRef</code>。</p><p id="c84b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">钩子获取ref并返回一个包含我们想要调用的方法的对象。</p><p id="7570" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在父节点中，我们将引用传递给<code class="fe me mf mg mh b">ref</code>属性。</p><p id="cc30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">current.hello</code>来调用子中的方法。</p><p id="9a6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用类组件，那么就更简单了。</p><p id="062b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="de2d" class="mq lc iq mh b gy mr ms l mt mu">const { Component } = React;</span><span id="333a" class="mq lc iq mh b gy mv ms l mt mu">class Parent extends Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.child = React.createRef();<br/>  }</span><span id="b5f8" class="mq lc iq mh b gy mv ms l mt mu">  onClick = () =&gt; {<br/>    this.child.current.hello();<br/>  };</span><span id="2024" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;Child ref={this.child} /&gt;<br/>        &lt;button onClick={this.onClick}&gt;Click&lt;/button&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span><span id="68cc" class="mq lc iq mh b gy mv ms l mt mu">class Child extends Component {<br/>  hello() {<br/>    conole.log('hello child');<br/>  }</span><span id="bb22" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return &lt;h1&gt;Hello&lt;/h1&gt;;<br/>  }<br/>}</span></pre><p id="d756" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用从<code class="fe me mf mg mh b">Parent</code>调用的<code class="fe me mf mg mh b">hello</code>方法创建了一个<code class="fe me mf mg mh b">Child</code>。</p><p id="e874" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们只要给它分配一个ref，用<code class="fe me mf mg mh b">current.hello</code>调用它。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/b872eebba5610a81ba8f080182110cc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*O9Gr6TTpMNoaj3NM"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@qbuffing?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Quinn Buffing</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5738" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="83c7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以从父组件调用子组件功能。</p><p id="a53e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们需要访问构造函数中的props，那么我们需要将它们传递给<code class="fe me mf mg mh b">super</code>。</p><p id="3369" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以谴责第三方库的事件处理程序。</p><h1 id="4f57" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单英语的JavaScript</h1><p id="f149" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>