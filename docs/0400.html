<html>
<head>
<title>Async &amp; Await in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的异步等待</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/async-await-e949a0d06d63?source=collection_archive---------2-----------------------#2019-10-06">https://javascript.plainenglish.io/async-await-e949a0d06d63?source=collection_archive---------2-----------------------#2019-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/31c453e51feeff4a7878b6b932c73b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*G2t_YhD_QzQZXrdxI8LPFg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kc" href="https://unsplash.com/s/photos/bubbles?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9416" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">TL；博士:</strong></p><ul class=""><li id="1ad8" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">await关键字接受一个返回承诺的函数，并返回该承诺的<em class="lk"> resolved </em>值。</li><li id="eeb9" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">您只能在用<code class="fe lq lr ls lt b">async</code>关键字声明的函数中使用<code class="fe lq lr ls lt b">await</code>关键字。</li><li id="eecc" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated"><code class="fe lq lr ls lt b">async</code>功能是如何工作的？</li><li id="1cc1" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">返回承诺时，不需要在<code class="fe lq lr ls lt b">async</code>函数的<code class="fe lq lr ls lt b">return</code>语句中使用<code class="fe lq lr ls lt b">await</code>。</li><li id="73f8" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">你可以使用<code class="fe lq lr ls lt b">Promise.all([…])</code>和<code class="fe lq lr ls lt b">await</code>一次执行多个承诺。</li><li id="4a31" class="lb lc iq kf b kg ll kk lm ko ln ks lo kw lp la lg lh li lj bi translated">您可以使用<code class="fe lq lr ls lt b">for/await</code>循环异步遍历承诺。</li></ul></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="cc93" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">介绍</h1><p id="f3b1" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">ES2017引入了两个关键字，为JavaScript中的异步编程引入了一个全新的范式。<code class="fe lq lr ls lt b">async</code>和<code class="fe lq lr ls lt b">await</code>极大地简化了我们使用承诺的方式，并允许我们以同步的方式编写基于承诺的异步代码。尽管<code class="fe lq lr ls lt b">async</code>和<code class="fe lq lr ls lt b">await</code>隐藏了裸承诺所需的所有代码，但了解承诺如何工作以及它们提供的API以充分利用<code class="fe lq lr ls lt b">async/await</code>仍然非常重要。</p><p id="128f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不知道承诺是如何工作的，我鼓励你阅读我之前的两篇文章，关于你需要知道的关于承诺的要点。<a class="ae kc" href="https://medium.com/javascript-in-plain-english/javascript-promises-part-1-70cbc4d188e5?source=friends_link&amp;sk=cd5a4af398827a420386c3a66dce3e91" rel="noopener">第1部分</a>介绍了承诺何时在事件循环中执行，而<a class="ae kc" href="https://medium.com/javascript-in-plain-english/javascript-promises-part-2-f13184b46bd7?source=friends_link&amp;sk=be21028491f764ad9c3ba8c45b1c41b7" rel="noopener">第2部分</a>介绍了承诺如何工作，它们提供的API以及一些常用的模式。</p><p id="28af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">说完这些，让我们来看看<code class="fe lq lr ls lt b">async/await</code>是如何工作的！</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="0573" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">等待表达式</h1><p id="efc0" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">关键字<code class="fe lq lr ls lt b">await</code>采用一个返回承诺的函数，并返回该承诺的<em class="lk">解析</em>值。如果实现了承诺的解析，则返回实现的值，否则它<em class="lk">抛出</em>拒绝原因。让我们看一个例子:</p><pre class="ne nf ng nh gt ni lt nj nk aw nl bi"><span id="a290" class="nm mc iq lt b gy nn no l np nq">const users = await fetch('/users');</span></pre><p id="84e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设<code class="fe lq lr ls lt b">fetch(…)</code>返回一个承诺，表达式<code class="fe lq lr ls lt b">await fetch(…)</code>会等待<code class="fe lq lr ls lt b">fetch(…)</code>被<em class="lk">摆平</em>。如果<code class="fe lq lr ls lt b">fetch(…)</code>的解决方案是实现，那么<code class="fe lq lr ls lt b">users</code>被分配返回值。然而，如果<code class="fe lq lr ls lt b">fetch(…) </code>因为某种原因遇到错误并被拒绝，那么<code class="fe lq lr ls lt b">await fetch(…)</code>表达式将<em class="lk">抛出</em>拒绝原因。</p><p id="b847" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">重要的是要注意到,<code class="fe lq lr ls lt b">await</code>表达式不会导致你的程序停止，直到指定的承诺完成。你可以认为<code class="fe lq lr ls lt b">await</code>只是隐藏了用于处理承诺解析的<code class="fe lq lr ls lt b">.then(…, …)</code>调用。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="0fc3" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">异步函数</h1><p id="01b6" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">因为任何使用<code class="fe lq lr ls lt b">await</code>的代码都是异步的，所以有一条规则你必须绝对遵守:<em class="lk">你只能在已经用</em> <code class="fe lq lr ls lt b"><em class="lk">async</em></code> <em class="lk">关键字</em>声明的函数中使用 <code class="fe lq lr ls lt b"><em class="lk">await</em></code> <em class="lk">关键字。这里有一个例子:</em></p><pre class="ne nf ng nh gt ni lt nj nk aw nl bi"><span id="d2f4" class="nm mc iq lt b gy nn no l np nq">async getFoo() {<br/>  const foo = await fetch('/api/v1/getFoo');<br/>}</span></pre><p id="1369" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您应该注意，当您将函数声明为<code class="fe lq lr ls lt b">async</code>时，这意味着该函数将返回一个承诺，即使函数体中没有出现与承诺相关的代码。请考虑以下情况:</p><pre class="ne nf ng nh gt ni lt nj nk aw nl bi"><span id="bd2b" class="nm mc iq lt b gy nn no l np nq">async addFiftyTwo(number) {<br/>  const plusFiftyTwo = number + 52;<br/>  return plusFiftyTwo;<br/>}</span></pre><h2 id="2a9f" class="nm mc iq bd md nr ns dn mh nt nu dp ml ko nv nw mp ks nx ny mt kw nz oa mx ob bi translated">在后台</h2><p id="1b8e" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">当你观察<code class="fe lq lr ls lt b">async</code>函数如何在幕后工作时，你会发现它们只是返回承诺的函数，正如本文中描述的<a class="ae kc" href="https://medium.com/javascript-in-plain-english/javascript-promises-part-2-f13184b46bd7?source=friends_link&amp;sk=be21028491f764ad9c3ba8c45b1c41b7" rel="noopener">。让我们看一个例子:</a></p><pre class="ne nf ng nh gt ni lt nj nk aw nl bi"><span id="6d90" class="nm mc iq lt b gy nn no l np nq">async function get52() {<br/>  return 52;<br/>}</span><span id="cac0" class="nm mc iq lt b gy oc no l np nq">// The following works exactly the same<br/>function get52() {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    resolve(52);<br/>  });<br/>}</span><span id="e89d" class="nm mc iq lt b gy oc no l np nq">// Which can also be written as <br/>function get52() {<br/>  return Promise.resolve(52);<br/>}</span></pre><p id="1872" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是为什么理解承诺的概念对于有效使用<code class="fe lq lr ls lt b">async/await</code>仍然非常重要。<code class="fe lq lr ls lt b">async/await</code>只是围绕承诺的<em class="lk">句法糖</em>，所以如果你不知道如何有效地使用承诺，你很可能也不会有效地使用<code class="fe lq lr ls lt b">async/await</code>。接下来让我们看看一些与<code class="fe lq lr ls lt b">async/await</code>一起使用的常见模式。</p></div><div class="ab cl lu lv hu lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="ij ik il im in"><h1 id="8477" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">常见模式</h1><h2 id="97e1" class="nm mc iq bd md nr ns dn mh nt nu dp ml ko nv nw mp ks nx ny mt kw nz oa mx ob bi translated">回报承诺</h2><p id="59d5" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">新开发人员在开始使用<code class="fe lq lr ls lt b">async/await</code>时会犯的一个常见错误是什么时候使用<code class="fe lq lr ls lt b">await</code>以及什么时候不使用。请考虑以下情况:</p><pre class="ne nf ng nh gt ni lt nj nk aw nl bi"><span id="0153" class="nm mc iq lt b gy nn no l np nq">async someFunc() {<br/>  return await fetch('/api/v1/getFoo');<br/>}</span><span id="3863" class="nm mc iq lt b gy oc no l np nq">async someOtherFunc() {<br/>  const foo = await someFunc();<br/>}</span></pre><p id="0ea3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，<code class="fe lq lr ls lt b">async</code>函数返回一个承诺，该承诺解析为从函数返回的的值<em class="lk">并且<code class="fe lq lr ls lt b">await</code>在继续执行<code class="fe lq lr ls lt b">async</code>函数之前等待承诺被解析。如果一个<code class="fe lq lr ls lt b">async</code>函数返回一个承诺作为<code class="fe lq lr ls lt b">return</code>值，那么你不需要在<code class="fe lq lr ls lt b">return</code>关键字后使用<code class="fe lq lr ls lt b">await</code>。让我们看看那会是什么样子</em></p><pre class="ne nf ng nh gt ni lt nj nk aw nl bi"><span id="e6e6" class="nm mc iq lt b gy nn no l np nq">async someFunc() {<br/>  return fetch('/api/v1/getFoo');<br/>}</span><span id="af44" class="nm mc iq lt b gy oc no l np nq">async someOtherFunc() {<br/>  const foo = await someFunc();<br/>}</span></pre><p id="4b6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会怎么读这个？<code class="fe lq lr ls lt b">someFunc()</code>返回一个承诺，该承诺解析为另一个承诺，该承诺解析为来自API调用的响应。因此，<code class="fe lq lr ls lt b">someOtherFucn()</code>中的<code class="fe lq lr ls lt b">await</code>将等待内部最大承诺被解析，并将最后一个值赋给变量foo。</p><h2 id="3383" class="nm mc iq bd md nr ns dn mh nt nu dp ml ko nv nw mp ks nx ny mt kw nz oa mx ob bi translated">等待多重承诺</h2><p id="71cd" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">假设您已经编写了一个类似如下的<code class="fe lq lr ls lt b">getJSON</code>函数</p><pre class="ne nf ng nh gt ni lt nj nk aw nl bi"><span id="09d0" class="nm mc iq lt b gy nn no l np nq">async<!-- --> <!-- -->function<!-- --> <!-- -->getJSON(url)<!-- --> <!-- -->{<br/>    <!-- -->const response<!-- --> <!-- -->=<!-- --> <!-- -->await<!-- --> <!-- -->fetch(url);<br/>    <!-- -->const body<!-- --> <!-- -->=<!-- --> <!-- -->await<!-- --> <!-- -->response.json();<br/>    <!-- -->return<!-- --> <!-- -->body;<br/>}</span></pre><p id="5245" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在您想从外部API获取一些JSON数据，所以您这样做</p><pre class="ne nf ng nh gt ni lt nj nk aw nl bi"><span id="28ee" class="nm mc iq lt b gy nn no l np nq">async function doSomething() {<br/>  const users = await getJSON('/api/v1/users');<br/>  const themes = await getJSON('/api/v1/themes');<br/>}</span></pre><p id="3f1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">执行该函数所需的时间完全取决于两个<code class="fe lq lr ls lt b">getJSON</code>调用何时解决。这意味着如果第一次调用花了5秒，第二次调用直到那时才开始，如果第二次调用也花了5秒，那么该功能总共需要10秒才能完成。如果两个调用互不依赖，这可能是不必要的。这是新开发人员在使用<code class="fe lq lr ls lt b">async/await</code>时经常犯的错误。那么怎么修呢？Promise API提供了一个我们可以使用的名为<code class="fe lq lr ls lt b">all([…])</code>的静态方法。让我们看看这是如何工作的。</p><p id="d481" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注:</strong> <em class="lk">我在这里</em>  <em class="lk">的帖子里讨论了</em> <code class="fe lq lr ls lt b"><em class="lk">Promise.all([…])</em></code> <em class="lk">和其他Promise API提供</em> <a class="ae kc" href="https://medium.com/javascript-in-plain-english/javascript-promises-part-2-f13184b46bd7?source=friends_link&amp;sk=be21028491f764ad9c3ba8c45b1c41b7" rel="noopener"> <em class="lk">的方法。</em></a></p><pre class="ne nf ng nh gt ni lt nj nk aw nl bi"><span id="6100" class="nm mc iq lt b gy nn no l np nq">async function doSomething() {<br/>  const [users, themes] = await Promise.all([<br/>    getJSON('/api/v1/users'),<br/>    getJSON('/api/v1/themes')<br/>  ]);<br/>}</span></pre><p id="31f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将同时执行两个<code class="fe lq lr ls lt b">getJSON()</code>调用，从而减少<code class="fe lq lr ls lt b">doSomething()</code>的执行时间。现在你可能会想，为什么把<code class="fe lq lr ls lt b">await</code>放在<code class="fe lq lr ls lt b">Promise.all()</code>前面，而不是<code class="fe lq lr ls lt b">getJSON</code>呼叫前面。这是因为<code class="fe lq lr ls lt b">Promise.all([…])</code>它自己返回一个承诺，这个承诺的实现会产生一个数组，该数组由传入的承诺列表中的值组成。我之前提到的帖子对此有更详细的描述。</p><h2 id="eb20" class="nm mc iq bd md nr ns dn mh nt nu dp ml ko nv nw mp ks nx ny mt kw nz oa mx ob bi translated">异步迭代</h2><p id="ba85" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">迭代器和异步迭代器超出了本文的范围，所以我们将只讨论如何将<code class="fe lq lr ls lt b">async/await</code>用于异步迭代。异步迭代器就像常规迭代器一样，但基于承诺，可以用于新形式的<code class="fe lq lr ls lt b">for/of</code>循环、<code class="fe lq lr ls lt b">for/await</code>。</p><p id="c0a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像常规的<code class="fe lq lr ls lt b">await</code>表达式一样，<code class="fe lq lr ls lt b">for/await</code>循环是基于承诺的。异步迭代器上的<code class="fe lq lr ls lt b">next()</code>方法产生一个承诺，<code class="fe lq lr ls lt b">for/await</code>循环等待该承诺解析，将实现值赋给循环变量，并运行循环体。然后它重新开始，从迭代器获得另一个承诺，并等待新的承诺被解析。让我们看一个如何使用它的例子，在下面的例子中，我们将使用一个普通迭代器<em class="lk">(不是异步迭代器)</em>，但是同样的概念也适用。</p><p id="36d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您有一个URL数组，您希望对其进行循环并得到一个承诺数组:</p><pre class="ne nf ng nh gt ni lt nj nk aw nl bi"><span id="ff06" class="nm mc iq lt b gy nn no l np nq">const urls = [url1, url2, url3];<br/>const promises = urls.map((url) =&gt; fetch(url));</span></pre><p id="c884" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以在这里使用Promise.all([…])并等待所有的承诺被解决，但是如果我们需要它们一回来就得到结果呢？然后呢？我们可以这样做:</p><pre class="ne nf ng nh gt ni lt nj nk aw nl bi"><span id="aeb2" class="nm mc iq lt b gy nn no l np nq">for(const promise of promises) {<br/>  const response = await promise;<br/>  // do something with response here...<br/>}</span></pre><p id="e5ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这完全可以接受，没有错。由于迭代器返回承诺，我们也可以利用如下所示的<code class="fe lq lr ls lt b">for/await</code>循环:</p><pre class="ne nf ng nh gt ni lt nj nk aw nl bi"><span id="ad8b" class="nm mc iq lt b gy nn no l np nq">for await (const response of promises) {<br/>  //do something with response here...<br/>}</span></pre><p id="ed9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lq lr ls lt b">for/await</code>循环在循环中使用了<code class="fe lq lr ls lt b">await</code>调用，使我们的代码更加紧凑，但是这两个例子做了完全相同的事情。需要注意的一点是，这两个例子只有在声明为<code class="fe lq lr ls lt b">async</code>的函数中才会起作用:<code class="fe lq lr ls lt b">for/await</code>循环在这方面与常规的<code class="fe lq lr ls lt b">await</code>表达式是一样的。</p><h1 id="6e4f" class="mb mc iq bd md me od mg mh mi oe mk ml mm of mo mp mq og ms mt mu oh mw mx my bi translated">结论</h1><p id="ea26" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">现在，你应该对<code class="fe lq lr ls lt b">async/await</code>及其工作原理有了很好的理解。我们分别讨论了关键词，并简要介绍了<code class="fe lq lr ls lt b">async</code>函数是如何工作的。之后是使用<code class="fe lq lr ls lt b">async/await</code>的一些常见模式，以及新开发人员在开始使用<code class="fe lq lr ls lt b">async/await</code>时会犯的一些常见错误。</p><p id="84db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像往常一样，让我知道你对async/await的体验。你在使用它时遇到了什么问题，以及你可能有什么问题。</p><p id="21ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下次见，干杯！</p></div></div>    
</body>
</html>