<html>
<head>
<title>Use Fragments to Group React Components Together</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用片段将React组件分组在一起</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-fragments-to-group-react-components-f30bfd515665?source=collection_archive---------3-----------------------#2020-03-21">https://javascript.plainenglish.io/using-fragments-to-group-react-components-f30bfd515665?source=collection_archive---------3-----------------------#2020-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1664162ad18a47e8a4b6e5aa38612059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CdmhyYgK8J9BrElB"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@struvictoryart?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Victoria Strukovskaya</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9e77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建前端视图的库。它有一个庞大的图书馆生态系统与之合作。此外，我们可以用它来增强现有的应用程序。</p><p id="e4a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用片段将组件分组在一起，而不使用HTML元素。</p><h1 id="28c2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">碎片</h1><p id="9d69" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们需要片段将组件组合在一起，而不需要在DOM中添加额外的包装元素。</p><p id="5fc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不要写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2782" class="mn lc iq mj b gy mo mp l mq mr">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;foo&lt;/p&gt;<br/>        &lt;p&gt;bar&lt;/p&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="ba13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以改为写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="93fb" class="mn lc iq mj b gy mo mp l mq mr">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        &lt;p&gt;foo&lt;/p&gt;<br/>        &lt;p&gt;bar&lt;/p&gt;<br/>      &lt;/React.Fragment&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="b534" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个和第二个示例的区别在于，第一个示例将呈现:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="02eb" class="mn lc iq mj b gy mo mp l mq mr">&lt;div&gt;<br/>  &lt;p&gt;foo&lt;/p&gt;<br/>  &lt;p&gt;bar&lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="21e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而第二个示例将呈现:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ec89" class="mn lc iq mj b gy mo mp l mq mr">&lt;p&gt;foo&lt;/p&gt;<br/>&lt;p&gt;bar&lt;/p&gt;</span></pre><p id="12aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于呈现包含多组元素(如表格)的元素也很有帮助。表格具有必须成组添加的<code class="fe ms mt mu mj b">td</code>和<code class="fe ms mt mu mj b">th</code>元素。</p><p id="ea0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以将<code class="fe ms mt mu mj b">th</code>元素移动到一个组件中，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9faf" class="mn lc iq mj b gy mo mp l mq mr">class Heading extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        {["foo", "bar"].map((th, index) =&gt; (<br/>          &lt;th key={index}&gt;{th}&lt;/th&gt;<br/>        ))}<br/>      &lt;/React.Fragment&gt;<br/>    );<br/>  }<br/>}</span><span id="d162" class="mn lc iq mj b gy mv mp l mq mr">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;table&gt;<br/>        &lt;thead&gt;<br/>          &lt;tr&gt;<br/>            &lt;Heading /&gt;<br/>          &lt;/tr&gt;<br/>        &lt;/thead&gt;<br/>      &lt;/table&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="a84d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将只呈现<code class="fe ms mt mu mj b">tr</code>中的<code class="fe ms mt mu mj b">th</code>元素，所以它将是有效的HTML。如果我们将<code class="fe ms mt mu mj b">th</code>元素与其他元素组合在一起，它将成为无效的HTML，因为它们不应该被任何额外的东西包裹。</p><h1 id="bcb2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">短语法</h1><p id="0ee4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">还有一个片段的简写。我们可以写<code class="fe ms mt mu mj b">&lt;&gt;</code>和<code class="fe ms mt mu mj b">&lt;/&gt;</code>而不是写<code class="fe ms mt mu mj b">&lt;React.Fragment&gt;</code>和<code class="fe ms mt mu mj b">&lt;/React.Fragment&gt;</code>。</p><p id="d070" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们也可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1d21" class="mn lc iq mj b gy mo mp l mq mr">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        &lt;p&gt;foo&lt;/p&gt;<br/>        &lt;p&gt;bar&lt;/p&gt;<br/>      &lt;/&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="a781" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在任何其他元素上使用短语法，除了它不支持键或属性。</p><p id="b873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该语法不支持键或任何其他属性。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/23c7e474aaae5f024b91895b8729b8bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2K3ndUFlgaSLmXPH"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@bergerteam?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Florian Berger</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="b469" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">键控片段</h1><p id="2538" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">用<code class="fe ms mt mu mj b">&lt;React.Fragment&gt;</code>语法声明的片段可能有键。这对于将集合映射到片段数组非常有用。</p><p id="c896" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6044" class="mn lc iq mj b gy mo mp l mq mr">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      glossary: [<br/>        { id: 1, word: "coffee", meaning: "black drink" },<br/>        { id: 2, word: "milk", meaning: "white drink" }<br/>      ]<br/>    };<br/>  }</span><span id="8f3d" class="mn lc iq mj b gy mv mp l mq mr">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        {this.state.glossary.map(g =&gt; (<br/>          &lt;React.Fragment key={g.id.toString()}&gt;<br/>            &lt;dt&gt;{g.word}&lt;/dt&gt;<br/>            &lt;dd&gt;{g.meaning}&lt;/dd&gt;<br/>          &lt;/React.Fragment&gt;<br/>        ))}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="388c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们在<code class="fe ms mt mu mj b">React.Fragment</code>组件中使用了<code class="fe ms mt mu mj b">key</code>属性，这样React就可以从一组片段中识别出唯一的元素。</p><p id="8533" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到一个内部只有dt和dd元素的div。</p><p id="ae66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">key</code>属性是唯一可以传递给<code class="fe ms mt mu mj b">Fragment</code>的属性。将来可能会支持其他道具。</p><h1 id="04a8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4a87" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用片段将元素分组在一起，而无需在DOM中呈现额外的包装元素。</p><p id="ac54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以使用<code class="fe ms mt mu mj b">React.Fragment</code>组件或简写的<code class="fe ms mt mu mj b">&lt;&gt;&lt;/&gt;</code>语法。</p><p id="bbe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将数组映射到片段，那么我们必须将一个<code class="fe ms mt mu mj b">key</code>属性放到<code class="fe ms mt mu mj b">React.Fragment</code>组件中，这样React就可以唯一地标识映射的元素。</p></div></div>    
</body>
</html>