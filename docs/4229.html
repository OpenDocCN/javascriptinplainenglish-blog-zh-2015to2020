<html>
<head>
<title>Features And Breaking Changes In TypeScript 4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4中的功能和重大更改</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/features-and-breaking-changes-in-typescript-4-111e6551cd7?source=collection_archive---------7-----------------------#2020-11-26">https://javascript.plainenglish.io/features-and-breaking-changes-in-typescript-4-111e6551cd7?source=collection_archive---------7-----------------------#2020-11-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/549fc5e86886d47b9b10273cc31486ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nkpNOMI76YvPdjgk"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1b29" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">8月26日发布的新版TypeScript，typescript 4。在本文中，我们将讨论最新Typescript版本中发布的所有新特性、改进和重大变化。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="5982" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">谁应该阅读这篇文章？</h1><ol class=""><li id="5df8" class="md me in kc b kd mf kh mg kl mh kp mi kt mj kx mk ml mm mn bi translated"><strong class="kc io">任何具备JavaScript或打字基础知识的人</strong></li><li id="208a" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><strong class="kc io">前端开发者(Angular/React): </strong> Typescript是Angular的基础。我们已经在angular版本11和12即将到来，作为angular/前端开发人员，我们有责任让自己与typescript保持同步，这样我们就可以编写不会真正过时的代码，并且我们可以利用微软和typescript团队每天都在开发的所有新功能来改善我们的生活。</li><li id="26b6" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><strong class="kc io">与时俱进的程序员</strong></li></ol></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="a448" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><a class="ae jz" href="https://medium.com/javascript-in-plain-english/typescript-101-understanding-the-basics-in-3-minutes-e2113a9c4c5f" rel="noopener">什么是TypeScript？</a></h1><ol class=""><li id="248a" class="md me in kc b kd mf kh mg kl mh kp mi kt mj kx mk ml mm mn bi translated">这是一种建立在JavaScript之上的语言。</li><li id="685c" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">它基本上为我们的静态类型增加了语法。</li><li id="4a43" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">其思想是使用typescript对代码进行基本的类型检查，并在运行代码之前告诉您错误。</li></ol><p id="4539" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如，在javascript环境中，您可以编写:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="d451" class="nc lg in my b gy nd ne l nf ng">let a = "cat";</span></pre><p id="8c91" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下一行，你可以写:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="7710" class="nc lg in my b gy nd ne l nf ng">a = 24; // and this is a problem!</span></pre><p id="37ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没有人会阻止你，你的编译器不会，你的IDE也不会，你自己也不会知道，除非代码崩溃了，因为你期待的是一个字符串，而你得到的是一个整数，你只能在后期制作时才知道。</p><blockquote class="nh"><p id="d3ea" class="ni nj in bd nk nl nm nn no np nq kx dk translated">因此，基本上typescript的目标是避免那些错误，避免那些明显的错误，使我们的代码更干净，更可读。</p></blockquote></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="4848" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">TypeScript 4.0新增功能摘要</h1><ol class=""><li id="321a" class="md me in kc b kd mf kh mg kl mh kp mi kt mj kx mk ml mm mn bi translated">标记元组元素</li><li id="eb4c" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">从构造函数推断类属性</li><li id="240d" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">短路赋值运算符</li><li id="6336" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">更好的catch子句绑定</li><li id="560f" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated">VS代码改进</li></ol></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="d31b" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">标记元组元素</h1><p id="1f7d" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl ns kn ko kp nt kr ks kt nu kv kw kx ig bi translated">我最感兴趣的第一个变化是标签元组元素。不熟悉编程的人都知道，我们可以将元组作为可变数量的参数传递给任何函数，这样函数就可以真正动态化。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="78d3" class="nc lg in my b gy nd ne l nf ng">// Javascript =&gt;</span><span id="e913" class="nc lg in my b gy nv ne l nf ng">function addressJs(...args) {<br/>    // ...<br/>}</span><span id="8701" class="nc lg in my b gy nv ne l nf ng">addressJs(2505, 'Sherbrooke East');</span><span id="4c8b" class="nc lg in my b gy nv ne l nf ng">addressJs('Sherbrooke East', 2505, 10); // oops!</span></pre><p id="5010" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">尽管TypeScript从一开始就支持它:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="b4f3" class="nc lg in my b gy nd ne l nf ng">// TypeScript &lt; 4.0 =&gt;  </span><span id="0dd8" class="nc lg in my b gy nv ne l nf ng">function addressTs(...args: [number, string]): void {<br/>    // ...<br/>}</span><span id="d1d1" class="nc lg in my b gy nv ne l nf ng">addressTs(2505, 'Sherbrooke East'); // works</span><span id="74d8" class="nc lg in my b gy nv ne l nf ng">addressTs(2505, 'Sherbrooke East', true); // error<br/>addressTs(2505); // error</span></pre><p id="d53d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个函数中，我们有两个参数，第一个是数字，第二个是字符串。</p><p id="1aeb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，它看起来与下面的函数没有什么不同:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="04b8" class="nc lg in my b gy nd ne l nf ng">function addressTs2(arg0: number, arg1: string): void {<br/>    // ...<br/>}</span><span id="e413" class="nc lg in my b gy nv ne l nf ng">addressTs2(2505, 'Sherbrooke East'); // works</span></pre><p id="d100" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它基本上意味着参数0是一个数字，参数1是一个字符串。</p><blockquote class="nz oa ob"><p id="6739" class="ka kb oc kc b kd ke kf kg kh ki kj kk od km kn ko oe kq kr ks of ku kv kw kx ig bi translated">这已经比javascript好得多了，因为在javascript中你不知道我们是否必须先传递一个字符串，再传递一个数字。</p></blockquote><p id="71c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">问题:</strong>在这个例子中，对于程序员来说，他/她是应该将公寓号作为第一个参数，将城市作为第二个参数，还是将街道号或街道名作为第二个参数，这一点并不明显！</p><p id="dfc9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可能会有各种各样的场景，可能会有很多困惑。</p><h2 id="d4d8" class="nc lg in bd lh og oh dn ll oi oj dp lp kl ok ol lt kp om on lx kt oo op mb oq bi translated">TypeScript 4有什么变化？</h2><p id="dc02" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl ns kn ko kp nt kr ks kt nu kv kw kx ig bi translated">现在更好的是我们可以命名元组。例如，我们必须定义范围，我们实际上可以说第一个变量被标记为<code class="fe nw nx ny my b">start</code>，第二个变量被标记为<code class="fe nw nx ny my b">end</code>，这大大增加了代码的可读性。</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="975e" class="nc lg in my b gy nd ne l nf ng">// In TypeScript 4.0, tuples types can now provide labels =&gt;</span><span id="f63e" class="nc lg in my b gy nv ne l nf ng">type StreetAddress = [streetNumber: number,streetName: string] <br/>| [streetNumber: number, streetName: string, city: string];</span><span id="9cc1" class="nc lg in my b gy nv ne l nf ng">function addressWithLabels(...address: StreetAddress): void {<br/>    //...<br/>}</span><span id="2d5f" class="nc lg in my b gy nv ne l nf ng">addressWithLabels(2525, 'Sherbrooke East'); //works<br/>addressWithLabels(2525, 'Sherbrooke East', 'Montreal'); //works</span></pre><p id="b4ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以定义或标记我们的论点。我们可以说第一个应该是<code class="fe nw nx ny my b">streetNumber</code>，第二个应该是<code class="fe nw nx ny my b">streetName.</code></p><p id="c982" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此方法接受街道地址。现在，街道地址可以包含街道编号和街道名称，也可以包含街道编号、街道名称和城市。因此，现在很清楚了。</p><p id="9cdc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们有一个大的代码库时，这将有所帮助！在大公司里，我们有成千上万行代码，如果这些东西能让程序员的生活变得更容易、更好，那么为什么不实现它们呢？</p><blockquote class="nh"><p id="c44e" class="ni nj in bd nk nl nm nn no np nq kx dk translated">此外，我们不必依赖文档或注释。这种代码可读性很好，我们需要传递什么样的参数也很明显。</p></blockquote><p id="5d85" class="pw-post-body-paragraph ka kb in kc b kd or kf kg kh os kj kk kl ot kn ko kp ou kr ks kt ov kv kw kx ig bi translated">如果您真的想利用可变数量的参数:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="8758" class="nc lg in my b gy nd ne l nf ng">type StreetAddressComplete = [<br/>    streetNumber: number,<br/>    streetName?: string,<br/>    ...rest: any[]<br/>];</span></pre><p id="2cea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个例子中，我们可以说第一个必须是一个<strong class="kc io"> streetNumber </strong>，这将是一个<strong class="kc io"> number </strong>类型，第二个必须是一个<strong class="kc io">字符串</strong>，第三个可以有我们想要的任何类型的参数。所以我们仍然可以利用可变数量的参数。</p><h1 id="0c0d" class="lf lg in bd lh li ow lk ll lm ox lo lp lq oy ls lt lu oz lw lx ly pa ma mb mc bi translated">从构造函数推断类属性</h1><p id="c459" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl ns kn ko kp nt kr ks kt nu kv kw kx ig bi translated">现在，typescript可以使用控制流来分析这些变量的类型，在这种情况下，您定义了一个类<strong class="kc io"> Square </strong>，具有<strong class="kc io"> area </strong>和<strong class="kc io"> sideLength </strong>，但是您没有给出类型:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="4137" class="nc lg in my b gy nd ne l nf ng">class Square {<br/>    // Previously: implicit any!<br/>    // Now: inferred to `number`!<br/>    area;<br/>    sideLength;</span><span id="2785" class="nc lg in my b gy nv ne l nf ng">    constructor(sideLength: number) {<br/>        this.sideLength = sideLength;<br/>        this.area = sideLength ** 2;<br/>    }<br/>}</span></pre><p id="8ed8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它分析说，在构造函数中，你传递了一个数字，然后你分配了这个数字，对它做了一些操作，并把它分配给了这个区域。但是typescript足够聪明，知道它仍然是一个数字，它会假设你的变量是数字。</p><p id="d8d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，它有一个限制，例如:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="9f30" class="nc lg in my b gy nd ne l nf ng">class Square {<br/>    sideLength;</span><span id="e944" class="nc lg in my b gy nv ne l nf ng">    constructor(sideLength: number) {<br/>        if (Math.random()) {<br/>            this.sideLength = sideLength;<br/>        }<br/>    }</span><span id="54d1" class="nc lg in my b gy nv ne l nf ng">    get area() {<br/>        return this.sideLength ** 2;<br/>        //     ~~~~~~~~~~~~~~~<br/>        // error! Object is possibly 'undefined'.<br/>    }<br/>}</span></pre><p id="7eaf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，它在一个<strong class="kc io"> if </strong>条件中被赋值。所以在这种情况下，typescript的编译器不能确定这个变量的类型是不是数字，因为它有可能是未定义的。</p><h1 id="800f" class="lf lg in bd lh li ow lk ll lm ox lo lp lq oy ls lt lu oz lw lx ly pa ma mb mc bi translated">短路赋值运算符</h1><p id="ab0f" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl ns kn ko kp nt kr ks kt nu kv kw kx ig bi translated">在TypeScript 4中，他们宣布现在我们有三个新的赋值操作符:</p><ol class=""><li id="c97e" class="md me in kc b kd ke kh ki kl pb kp pc kt pd kx mk ml mm mn bi translated"><code class="fe nw nx ny my b">&amp;&amp;=</code></li><li id="c65d" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><code class="fe nw nx ny my b">||=</code></li><li id="43e8" class="md me in kc b kd mo kh mp kl mq kp mr kt ms kx mk ml mm mn bi translated"><code class="fe nw nx ny my b">??=</code></li></ol><p id="1654" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以基本上我们可以替换这些作业</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="9f25" class="nc lg in my b gy nd ne l nf ng">a = a &amp;&amp; b; <br/>a = a || b; <br/>a = a ?? b;</span></pre><p id="2561" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了新的。</p><blockquote class="nh"><p id="62e4" class="ni nj in bd nk nl nm nn no np nq kx dk translated">每个程序员都喜欢更短的代码。</p></blockquote><h1 id="4ac7" class="lf lg in bd lh li ow lk ll lm ox lo lp lq pe ls lt lu pf lw lx ly pg ma mb mc bi translated">更好的catch子句绑定</h1><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="0a93" class="nc lg in my b gy nd ne l nf ng">try {<br/>    // ...<br/>}<br/>catch (x) {<br/>    // x has type 'any' - have fun!<br/>    console.log(x.toUpperCase());<br/>    x++;<br/>}</span></pre><p id="f9c9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这基本上意味着，如果我们之前尝试了一个catch block，我们不知道<code class="fe nw nx ny my b">type x</code>是什么，它可以是<code class="fe nw nx ny my b">any</code>类型，我们可以做一个应该只针对整数的操作，并且它不会在代码实际执行之前抛出错误。</p><p id="ca9c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们有了一个类型<code class="fe nw nx ny my b">unknown</code>，我们可以定义它，并将其分配给异常:</p><pre class="mt mu mv mw gt mx my mz na aw nb bi"><span id="eae5" class="nc lg in my b gy nd ne l nf ng">try {<br/>    // ...<br/>}<br/>catch (e: unknown) {<br/>    console.log(e.toUpperCase()); // compile error<br/>    if (typeof e === "string") {<br/>       console.log(x.toUpperCase()); <br/>    }<br/>}</span></pre><p id="2a9c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在如果我们试着说<code class="fe nw nx ny my b">e.toUpperCase() </code>编译器会抛出一个错误，因为它不认为<code class="fe nw nx ny my b">type unknown</code>有这个方法。所以我们不得不缩小范围。如果异常(e)的类型是字符串，那么我们可以调用它。</p><blockquote class="nh"><p id="c956" class="ni nj in bd nk nl nm nn no np nq kx dk translated"><em class="nr">这非常方便，因为您不希望捕获代码中出现错误或异常！</em></p></blockquote><h1 id="32d9" class="lf lg in bd lh li ow lk ll lm ox lo lp lq pe ls lt lu pf lw lx ly pg ma mb mc bi translated">打破变化</h1><p id="68fd" class="pw-post-body-paragraph ka kb in kc b kd mf kf kg kh mg kj kk kl ns kn ko kp nt kr ks kt nu kv kw kx ig bi translated">最后，我只想提一下，这个版本没有重大的突破性变化，所以您可以简单地更新代码库中的typescript版本，您就可以开始了！</p><p id="205c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望本文能帮助您理解最新的TypeScript版本。</p><p id="8453" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">谢谢你的阅读。如果您有任何问题，请随时留言回应。</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="ph pi l"/></div></figure><h1 id="7228" class="lf lg in bd lh li ow lk ll lm ox lo lp lq oy ls lt lu oz lw lx ly pa ma mb mc bi translated">资源</h1><ol class=""><li id="679b" class="md me in kc b kd mf kh mg kl mh kp mi kt mj kx mk ml mm mn bi translated"><a class="ae jz" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/" rel="noopener ugc nofollow" target="_blank">https://dev blogs . Microsoft . com/type script/notify-type script-4-0/</a></li></ol></div></div>    
</body>
</html>