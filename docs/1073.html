<html>
<head>
<title>Writing your own webpack plugin</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写自己的webpack插件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/exploring-webpacks-templateplugin-writing-webpack-plugin-8bb283fc82c0?source=collection_archive---------5-----------------------#2020-01-25">https://javascript.plainenglish.io/exploring-webpacks-templateplugin-writing-webpack-plugin-8bb283fc82c0?source=collection_archive---------5-----------------------#2020-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/460c243e5c74a76574879527a67ac958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MztcXroPHZ5nkHOS.png"/></div></div></figure><p id="1b77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您使用webpack来捆绑您的库，您很可能会在您的条目文件中导出一些内容:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="bf99" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你像那样用webpack构建它，开箱即用，你可能会惊讶，如果你尝试<code class="fe lc ld le lf b">require()</code>构建的文件，你会发现构建的文件没有导出任何东西。</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="2fb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你读过我以前写的一篇关于编写模块捆绑器的文章，你可以想象输出包看起来像这样:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div><figcaption class="lh li gj gh gi lj lk bd b be z dk"><em class="ll">Everything should be familiar, except the fact that instead of calling </em><strong class="ak"><em class="ll">webpackStart</em></strong><em class="ll"> in a separate statement, I made it into a IIFE (Immediately Invoked Function Expression) for reasons that will be apparent later</em></figcaption></figure><p id="59ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了构建一个库，即:为了暴露条目文件导出的任何内容，webpack提供了3个选项供您使用:</p><h1 id="c5ed" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Webpack的output.library*选项</h1><p id="13d4" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">要了解它们各自的工作原理，我们先从<code class="fe lc ld le lf b">output.libraryTarget</code>说起。</p><p id="8fcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lc ld le lf b">output.libraryTarget</code>接受<code class="fe lc ld le lf b">string</code>作为值，您可以向<code class="fe lc ld le lf b">output.libraryTarget</code>选项提供2组主要值:</p><h2 id="e6d0" class="mp ln iq bd lo mq mr dn ls ms mt dp lw kj mu mv ma kn mw mx me kr my mz mi na bi translated">1.模块系统名称:<code class="fe lc ld le lf b">"commonjs"</code>、<code class="fe lc ld le lf b">"commonjs2"</code>、<code class="fe lc ld le lf b">"amd"</code>、<code class="fe lc ld le lf b">"umd"</code>，...</h2><p id="225e" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">Webpack允许您指定想要用来公开条目文件的导出值的模块系统的名称。</p><p id="c3d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以指定一个不同于您在库中使用的模块系统。</p><p id="4245" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们试着以<code class="fe lc ld le lf b">commonjs2</code>为例:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="ec1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lc ld le lf b">commonjs2</code>使用<code class="fe lc ld le lf b">module.exports</code>从模块中导出值。在这个例子中，webpack将IIFE的返回值分配给<code class="fe lc ld le lf b">module.exports</code>。</p><p id="10d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果看捆绑的代码，和没有指定<code class="fe lc ld le lf b">output.libraryTarget</code>的没有太大区别。唯一不同的是捆绑代码的前缀是<code class="fe lc ld le lf b">module.exports =</code>；</p><blockquote class="nb nc nd"><p id="dd76" class="jy jz ne ka b kb kc kd ke kf kg kh ki nf kk kl km ng ko kp kq nh ks kt ku kv ij bi translated"><em class="iq">对了，如果你好奇commonjs和commonjs2的区别，可以跟帖</em> <a class="ae lg" href="https://github.com/webpack/webpack/issues/1114" rel="noopener ugc nofollow" target="_blank"> <em class="iq">本期</em> </a> <em class="iq">。</em></p></blockquote><p id="8820" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，您可以指定导出对象所分配到的变量名，而不是通过模块系统公开库内容。</p><p id="41a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们以<code class="fe lc ld le lf b">self</code>为例:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="c62c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有导出的值被分配给<code class="fe lc ld le lf b">self</code>。</p><p id="5e73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">再次观察捆绑代码，这一次我们在捆绑代码前面加上<code class="fe lc ld le lf b">Object.assign(self,</code>，后面加上<code class="fe lc ld le lf b">);</code>。</p><p id="5ddd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，将<code class="fe lc ld le lf b">output.libraryTarget</code>指定为<code class="fe lc ld le lf b">var</code>，允许您将它赋给一个变量名，这可以在<code class="fe lc ld le lf b">output.library</code>选项中提供:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="0991" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您不想让<code class="fe lc ld le lf b">myApp</code>包含条目文件的所有导出值，您可以只在<code class="fe lc ld le lf b">output.libraryExport</code>选项中提供您想要导出的键:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="c530" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，您可以观察到，通过播放不同的选项值<code class="fe lc ld le lf b">output.library</code>、<code class="fe lc ld le lf b">output.libraryTarget</code>、<code class="fe lc ld le lf b">output.libraryExport</code>，webpack为捆绑代码添加了不同的前缀和后缀:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="ecaf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，如果我们想支持类似下面这样的自定义库目标，我们应该怎么做，而不是使用webpack内置库目标呢？</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="51cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在<a class="ae lg" href="https://webpack.js.org/configuration/output/" rel="noopener ugc nofollow" target="_blank"> webpack官方文档</a>中搜索，没有找到允许这样做的选项。所以目前唯一的解决办法就是写一个webpack插件。</p><h1 id="afb8" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">编写webpack插件</h1><p id="942b" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在挖掘了<a class="ae lg" href="https://github.com/webpack/webpack" rel="noopener ugc nofollow" target="_blank"> webpack源代码</a>之后，我发现<a class="ae lg" href="https://github.com/webpack/webpack/blob/master/lib/LibraryTemplatePlugin.js" rel="noopener ugc nofollow" target="_blank"> LibraryTemplatePlugin </a>基于<code class="fe lc ld le lf b">output.libraryTarget</code>选项的值实例化了不同的模板插件:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="d892" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我去查看了其中一个模板插件，SetVarTemplatePlugin :</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="270a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不了解文件中发生的每一行，但我知道上面突出显示的行是webpack连接<code class="fe lc ld le lf b">varExpression =</code>(在<code class="fe lc ld le lf b">commonjs</code>的情况下，<code class="fe lc ld le lf b">varExpression</code>是<code class="fe lc ld le lf b">module.exports</code>，因此是<code class="fe lc ld le lf b">module.exports =</code>)和源代码(在本例中是捆绑代码)的地方。</p><p id="7431" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，要有以下几点:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="087b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="bf13" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我做了以下事情:</p><ol class=""><li id="09a0" class="ni nj iq ka b kb kc kf kg kj nk kn nl kr nm kv nn no np nq bi translated">创建一个新文件并粘贴来自<a class="ae lg" href="https://github.com/webpack/webpack/blob/master/lib/SetVarTemplatePlugin.js" rel="noopener ugc nofollow" target="_blank">setvartemplateplugin . js</a>的整个源代码</li><li id="f4d5" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">Searched + replaced将插件名称重命名为更合适的名称，(SetModuleTemplatePlugin)</li><li id="4bd5" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">替换了相对导入，<code class="fe lc ld le lf b">require("./RuntimeGlobals")</code>以要求来自webpack，<code class="fe lc ld le lf b">require("webpack/lib/RuntimeGlobals")</code></li><li id="7968" class="ni nj iq ka b kb nr kf ns kj nt kn nu kr nv kv nn no np nq bi translated">将<code class="fe lc ld le lf b">return new ConcatSource(prefix, source);</code>一行替换为以下内容:</li></ol><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="4577" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">5.从网络包配置中删除了<code class="fe lc ld le lf b">output.library</code>、<code class="fe lc ld le lf b">output.libraryTarget</code></p><p id="a81a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">6.添加了我的新插件:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="4efe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">令我惊讶的是，它成功了！差不多了。</p><p id="5e3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我运行捆绑代码时，customRegistry注册了一个空对象，没有从捆绑代码中导出任何内容。</p><p id="bb8f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我进入<a class="ae lg" href="https://github.com/webpack/webpack/blob/master/lib/LibraryTemplatePlugin.js" rel="noopener ugc nofollow" target="_blank"> LibraryTemplatePlugin.js </a>进行查找，因为这是最明显的开始查找的地方，因为我已经从<a class="ae lg" href="https://github.com/webpack/webpack/blob/master/lib/SetVarTemplatePlugin.js" rel="noopener ugc nofollow" target="_blank">setvartemplateplugin . js</a>开始逐行复制。</p><p id="5230" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我发现了一句很明显的话:</p><figure class="kw kx ky kz gt jr"><div class="bz fp l di"><div class="la lb l"/></div></figure><p id="5cd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果要我猜的话，我认为这一行的作用是将条目文件的导出标记为已用，这样webpack就不会<em class="ne"> treeshake掉它们</em>。</p><blockquote class="nb nc nd"><p id="f6cf" class="jy jz ne ka b kb kc kd ke kf kg kh ki nf kk kl km ng ko kp kq nh ks kt ku kv ij bi translated"><em class="iq">其中，</em><strong class="ka ir"><em class="iq">treeshake</em></strong><em class="iq">是一个很酷的词，意思是把它们去掉。</em></p><p id="8de2" class="jy jz ne ka b kb kc kd ke kf kg kh ki nf kk kl km ng ko kp kq nh ks kt ku kv ij bi translated"><em class="iq">你可能会争辩说</em><strong class="ka ir"><em class="iq">treeshake</em></strong><em class="iq">确实方式更多，只是去掉了入口出口，它去掉的东西只被入口出口使用，递归。</em></p></blockquote><p id="49df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我把这2行加到我的<code class="fe lc ld le lf b">SetModuleTemplatePlugin</code>里，成功了！这次很完美。🎉</p><p id="8049" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你懒的话，我为完整的代码创建了一个要点。</p><p id="78d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，如果您注意到了，这个例子是基于最新的主webpack源代码(在撰写本文时)，即<code class="fe lc ld le lf b">webpack@5.0.0-beta.12</code>。</p><p id="1460" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想要一个类似的<code class="fe lc ld le lf b">webpack^4</code>插件，你可以相信我，这篇文章是你自己编写插件的一个很好的切入点。</p><p id="14d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我相信你能做到。😎</p><h1 id="755b" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结束语</h1><p id="5c30" class="pw-post-body-paragraph jy jz iq ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">编写一个webpack插件不是不可能的。如果你很好地理解了webpack作为一个捆绑器是如何工作的，这将会变得特别容易。</p><p id="7a58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ne">(插:想了解更多可以看我的</em> <a class="ae lg" href="https://lihautan.com/what-is-module-bundler-and-how-does-it-work/" rel="noopener ugc nofollow" target="_blank"> <em class="ne">“什么是模块捆绑器，它是怎么工作的？”</em></a><em class="ne"/></p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="24a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ne">原贴于</em><a class="ae lg" href="https://lihautan.com/webpack-plugin-main-template/" rel="noopener ugc nofollow" target="_blank"><em class="ne">lihautan.com</em></a><em class="ne">。</em></p><p id="ba39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lg" href="https://twitter.com/lihautan" rel="noopener ugc nofollow" target="_blank">在twitter上关注我</a>，我会在那里发布更多与前端相关的内容。</p></div></div>    
</body>
</html>