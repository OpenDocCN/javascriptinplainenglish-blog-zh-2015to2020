<html>
<head>
<title>Learning ReScript — Converting a React App to ReScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习重写—将React应用程序转换为重写</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/learning-rescript-a-safer-way-to-write-javascript-part-2-5a4df5ecc09?source=collection_archive---------5-----------------------#2020-12-21">https://javascript.plainenglish.io/learning-rescript-a-safer-way-to-write-javascript-part-2-5a4df5ecc09?source=collection_archive---------5-----------------------#2020-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e5d6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第2部分:通过转换应用程序跳入深水区</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/04a6bf914bcc18ce2ebe8e9185da07cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PbhBSZUJf_jBNtvM"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@altumcode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">AltumCode</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="kw kx ky"><p id="5235" class="kz la lb lc b ld le jr lf lg lh ju li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ir">注意:</strong>这是两部分教程的第二部分。这涵盖了一吨的材料。建议阅读第一部分，尤其是如果你打算继续下去。<a class="ae kv" href="https://medium.com/swlh/learn-rescript-a-safer-way-to-write-javascript-part-1-e0b56d447c44" rel="noopener">你可以在这里看！</a></p></blockquote><p id="76c0" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><a class="ae kv" href="https://jaysonalzate.medium.com/learn-rescript-a-safer-way-to-write-javascript-part-1-e0b56d447c44" rel="noopener">在教程</a>的第一部分，我们介绍了什么是ReScript，它的好处，将编译器添加到应用程序中，并了解了该语言及其生态系统的一些细微差别。在本教程中，我们将基于这些知识用ReScript完全重写一个应用程序。</p><p id="aa09" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">为了帮助你容易地回顾本教程中的概念，我们将列出每一节涉及的概念。</p><p id="3b00" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这里还有一个链接，链接到本教程第1部分的最终代码，如果你想了解的话。</p><p id="87aa" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">首先，让我们简单地看一下我们的项目。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="cf67" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">是什么项目？</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/f51903d3dc9a6875265de35a1217700c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*U-Nf8hQzgQGnZGqx"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@korolevalkv?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Veronika Koroleva</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4dc5" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">对于本教程，我们将采用一个基本的购物车应用程序，并慢慢地将类型安全添加到回购中。该示例应用程序有些做作，架构不佳，有明显的错误。这些将有助于我们学习和应用这些概念。</p><h2 id="6620" class="mz mh iq bd mi na nb dn mm nc nd dp mq lw ne nf ms lx ng nh mu ly ni nj mw nk bi translated">探索应用程序</h2><p id="1aa8" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">拉动回购后，安装依赖项，启动app。在看到应用程序时，您应该会看到一个基本的表，允许您添加购物车中每个产品的数量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/1b467ece7d7b644c5c1052f456004b40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7pJBs6q4vzGZx7vPgz3k9Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The shopping app that we will be working on</figcaption></figure><p id="ac68" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">正如您所看到的，其中一些购物车值有不正确的值，如<code class="fe nr ns nt nu b">'x'</code>。下面是具有默认值的代码块:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Invalid (non-numeric) quantities are seen above</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/500f115d5141c63aa932aabeafb5321c.png" data-original-src="https://miro.medium.com/v2/resize:fit:984/format:webp/1*_GLiT-xP1UQtCa2unU9HdQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Pictured above: Not a valid price</figcaption></figure><p id="6bd9" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">当您尝试计算总价时，结果会收到一个非常奇怪的字符串。这是因为Javascript对这些类型进行数学运算的方式中有许多非数值和怪癖。通过类型检查(和一些常识)，我们可以避免这样的错误。</p><p id="bc36" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在转换我们的应用程序时，我们将利用在第1部分中学到的一些脚本基础知识。我建议在继续之前简要回顾一下基本的脚本概念部分。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="cc9d" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">关于在脚本中开发的一个注记</h1><p id="a01f" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">当我们开始转换到ReScript的过程时，由于编译器的速度和有用的反馈，我们不会使用Webpack直接捆绑我们的ReScript文件。因此，我们将使用编写一个JavaScript文件并将编译后的JavaScript导入到现有项目中的模式。然后，我们的捆绑器将执行输出的JavaScript。</p><p id="057e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">采用这种方法的结果是，我们需要打开两个独立的终端:一个用于Webpack开发服务器，另一个用于我们的BuckleScript编译器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The scripts we need to run before we can begin to develop</figcaption></figure></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="da11" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">将我们的入口点转换为JavaScript</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/eb309c1a556d94ded7ad6fc7f14f7d61.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KIdEgnwsU1cJo2pG"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@wanderlabs?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">WanderLabs</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="204c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们的第一个任务是将我们的入口点转换为使用ReScript。在本节中，我们将讨论:</p><ul class=""><li id="5be5" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv oe of og oh bi translated">将JavaScript代码导入到ReScript中</li><li id="3c2a" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">手动创建模块</li><li id="1d46" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">将JavaScript反应组件转换为JavaScript反应组件</li><li id="3db3" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">使用ReactDom将ReactDom元素呈现给dom</li></ul><p id="6d88" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">首先，我将向大家展示我们的成品<code class="fe nr ns nt nu b">Index.res</code>，并讲解一些概念。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Our Index.res file</figcaption></figure><p id="dc51" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这个文件中发生了很多事情，但让我们深入了解更多细节。这个文件主要做两件事:</p><ol class=""><li id="e7ee" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv on of og oh bi translated">导入一个Javascript React组件，并将其转换为使用Javascript和ReasonReact约定。这包括将其包含在模块中，并将其导出到名为<code class="fe nr ns nt nu b">make</code>的变量中。</li><li id="bb03" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated">使用ReasonReact提供的<code class="fe nr ns nt nu b">ReactDomRe</code>模块将组件呈现到我们的根。可以看到，在转换为JavaScript约定之后，我们可以使用<code class="fe nr ns nt nu b">&lt;App/&gt;</code>的JSX语法。编译人员发现这相当于在JavaScript中的<code class="fe nr ns nt nu b">App.make</code>。</li></ol><h2 id="842a" class="mz mh iq bd mi na nb dn mm nc nd dp mq lw ne nf ms lx ng nh mu ly ni nj mw nk bi translated">快速了解导入JSX组件—可选</h2><p id="062e" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">要将JavaScript React组件导入到JavaScript中，我们必须执行一些步骤，以允许编译器正确地对其进行解密(并为我们提供所有令人敬畏的类型安全覆盖)。<a class="ae kv" href="https://reasonml.github.io/reason-react/docs/en/components#import-from-js" rel="noopener ugc nofollow" target="_blank">以下是一些古老的推论，请查阅有关</a>主题的文档。</p><p id="0168" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们需要做的第一件事是定义一个模块来包含我们的组件定义。以下是有关<a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/module#sidebar" rel="noopener ugc nofollow" target="_blank">模块</a>的更多信息。</p><p id="b1f1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">接下来，我们需要在模块中导入我们的JavaScript React组件，并将其转换为ReasonReact约定。我们将使用一些装饰者，比如:</p><ol class=""><li id="9e9e" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv on of og oh bi translated"><code class="fe nr ns nt nu b">@bsmodule</code>修饰词和<code class="fe nr ns nt nu b">external</code>关键字。这允许我们从JavaScript导入代码，并将其分配给一个变量。<a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/import-from-export-to-js#import-from-javascript" rel="noopener ugc nofollow" target="_blank">以下是这些功能的更多细节。</a>在我们的代码中，我们通过指定“default”来获取<code class="fe nr ns nt nu b">App.jsx</code>文件的默认导出，但我们可以引用JS文件中的任何命名导出。</li><li id="d684" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated">我们还将使用<code class="fe nr ns nt nu b">@react.component</code>装饰器让编译器知道我们正在制作一个React组件。<a class="ae kv" href="https://reasonml.github.io/reason-react/docs/en/components#reactcomponent" rel="noopener ugc nofollow" target="_blank">这里有一些关于装修工的信息。</a>按照惯例，每个ReasonReact组件都有一个命名的导出<code class="fe nr ns nt nu b">make</code>,其中组件被导出，而不是使用默认导出。</li><li id="3ac5" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated">上面的信息意味着我们必须使用我们的<code class="fe nr ns nt nu b">external</code>操作将我们的React组件绑定到一个<code class="fe nr ns nt nu b">make</code>变量，以确保编译器正确地选择它。</li></ol><p id="05f4" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">一旦我们完成了这些步骤，编译器会将<code class="fe nr ns nt nu b">App</code>识别为ReasonReact组件，并正确地呈现它。</p><p id="646a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们现在可以通过修改<code class="fe nr ns nt nu b">webpack.config.js</code>中的<code class="fe nr ns nt nu b">entry</code>属性来引用我们的生成文件<code class="fe nr ns nt nu b">Index.bs.js</code>来使用它作为我们的入口点。</p><p id="1d9a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在我们已经更新了我们的入口点，我们将在下一节中处理转换我们最简单的React组件。但是要注意的是，我们在这样做的时候会涉及很多材料。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="66ad" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">转换我们的ProductActions组件</h1><p id="4448" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated"><code class="fe nr ns nt nu b">ProductActions</code>组件非常简单。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/14beb839ff90b0ca0a8acfc38af36e10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BGYF2geCro4ZZ68WufLevw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The ProductActions section is highlighted in blue.</figcaption></figure><p id="277d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">其核心是由两个MaterialUI图标组成，这两个图标都有调用函数的点击处理程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Our original ProductActions React Component.</figcaption></figure><p id="888b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">虽然这是一个简单的组件，但是本节将向我们介绍一些有用的特性和模式。这包括:</p><ul class=""><li id="31c9" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv oe of og oh bi translated">配置bsconfig在我们的应用程序中使用第三方包。在这种情况下，材质用户界面和材质用户界面图标</li><li id="7529" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">学习如何打开模块使我们的代码更具可读性</li><li id="3cae" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">查看文档和代码以理解预期的输入值</li><li id="96cf" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">创建助手模块</li><li id="0df8" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">在我们的组件中使用第三方包</li><li id="2986" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">逐步切换我们的应用程序以使用我们的脚本代码</li></ul><p id="04cd" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这将帮助我们走得更远，走得更远。我们开始吧！</p><h2 id="8899" class="mz mh iq bd mi na nb dn mm nc nd dp mq lw ne nf ms lx ng nh mu ly ni nj mw nk bi translated">将第三方库导入我们的项目</h2><p id="27ca" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">在这个文件中，我们需要使用两个库:<a class="ae kv" href="https://jsiebern.github.io/bs-material-ui/" rel="noopener ugc nofollow" target="_blank">材质UI </a>和<a class="ae kv" href="https://github.com/mscharley/bs-material-ui-icons" rel="noopener ugc nofollow" target="_blank">材质UI图标。</a>谢天谢地，社区中有人为这两个包编写了原因绑定。</p><p id="6abb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们需要更新我们的<code class="fe nr ns nt nu b">bsconfig</code>文件并更新我们的bs-dependencies来添加这些包。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">We add the packages to our dependencies like in a package.json. This allows us to utilize their modules in our project.</figcaption></figure><h2 id="1df7" class="mz mh iq bd mi na nb dn mm nc nd dp mq lw ne nf ms lx ng nh mu ly ni nj mw nk bi translated">打开模块以提高代码可读性</h2><p id="0ab4" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">打开一个模块允许我们访问模块的所有内容，而不必总是在内容前面加上模块名。以下是打开模块如何提高可读性的示例:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">An example of how opening modules improves readability</figcaption></figure><p id="668b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">打开模块的一个警告是，如果你可能会遇到变量名冲突。如果您使用的变量出现在多个打开的模块中，就会出现这种情况。例如，<code class="fe nr ns nt nu b">OpenModuleA</code>和<code class="fe nr ns nt nu b">OpenModuleB</code>中存在同名变量时引用<code class="fe nr ns nt nu b">myVar</code>。如果发生这种情况，编译器会让你知道！</p><p id="f072" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在我们知道了如何打开一个模块，我们将看看MaterialUI图标文档，看看如何添加它们。</p><h2 id="e37f" class="mz mh iq bd mi na nb dn mm nc nd dp mq lw ne nf ms lx ng nh mu ly ni nj mw nk bi translated">分析来自第三方库的文档和代码</h2><p id="da33" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">所以看一下我们的代码，我们需要给我们的回购协议添加两个图标:一个<code class="fe nr ns nt nu b">DeleteIcon</code>和一个<code class="fe nr ns nt nu b">AddShoppingCartIcon</code>。<a class="ae kv" href="https://github.com/mscharley/bs-material-ui-icons" rel="noopener ugc nofollow" target="_blank">让我们花点时间看看材质UI图标文档</a>。通过分析，我们了解到一些事情:</p><ol class=""><li id="f43a" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv on of og oh bi translated">我们将看到如何在组件中使用材质UI图标</li><li id="1660" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated">我们看到像<code class="fe nr ns nt nu b">Filled</code>和<code class="fe nr ns nt nu b">Outlined.</code>这样的图标有各种变体，这反映了<a class="ae kv" href="https://material.io/resources/icons/?style=baseline" rel="noopener ugc nofollow" target="_blank">材质UI图标</a>的实现。我们将使用<code class="fe nr ns nt nu b">Filled</code>变体，因为它是基线，并且与我们当前的应用程序相匹配。</li><li id="6f3b" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated">我们学习如何将我们的图标别名到模块中以提高可读性</li><li id="48e8" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated">我们注意到它确实告诉了我们一个图标的名字。<code class="fe nr ns nt nu b">DeleteIcon</code>在其中一个例子中被称为<code class="fe nr ns nt nu b">Delete</code>，但它没有告诉我们<code class="fe nr ns nt nu b">AddShoppingCartIcon</code>的名称。</li></ol><p id="11e2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们已经了解了这个库及其工作原理。我们现在必须找出一些关于我们的<code class="fe nr ns nt nu b">AddShoppingCartIcon</code>的缺失信息。这包括:</p><ol class=""><li id="ef74" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv on of og oh bi translated"><code class="fe nr ns nt nu b">AddShoppingCartIcon</code>模块的名称是什么？</li><li id="de16" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated">我们如何让图标坚持“原色”配色？</li></ol><p id="3b2c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">为此，我们将打开我们的节点模块并进行一些研究。我们可以看到这里列出了一个<code class="fe nr ns nt nu b">AddShoppingCart.bs.js</code>文件，以及一个原因文件中的原因绑定。</p><h2 id="3a86" class="mz mh iq bd mi na nb dn mm nc nd dp mq lw ne nf ms lx ng nh mu ly ni nj mw nk bi translated"><strong class="ak">什么是原因绑定？</strong></h2><p id="b613" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">原因绑定是一个文件，它设置了一些Javascript代码和编译器之间的契约。这包括类型信息和可接受的值。我们可以利用原因绑定，因为它与ReScript共享编译器来使用第三方库。</p><p id="1ded" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">打开文件，我们可以看到每个道具的类型和值。对于我们的用例，我们注意到我们将值作为“主要”传递给了<code class="fe nr ns nt nu b">~color</code> props。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/4c4507558f936dc5057c50f826f969a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-cnqDinRZeEfjoAg6DS3Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Reading Reason bindings is a great way to find out how to pass props</figcaption></figure><p id="199e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">有了这些信息，我们现在可以开始创建我们的助手文件，并开始编写我们的组件。</p><h2 id="839d" class="mz mh iq bd mi na nb dn mm nc nd dp mq lw ne nf ms lx ng nh mu ly ni nj mw nk bi translated">编写我们的助手文件</h2><p id="0b08" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">请记住，材料用户界面图标文档中有关于如何为我们的图标取别名的信息。</p><p id="fbe3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们将首先在一个助手目录中创建一个名为<code class="fe nr ns nt nu b">Icons.res</code>的新文件，并放入下面的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">This aliasing will make our components more readable.</figcaption></figure><h2 id="3eb7" class="mz mh iq bd mi na nb dn mm nc nd dp mq lw ne nf ms lx ng nh mu ly ni nj mw nk bi translated">编写我们的ProductActions组件</h2><p id="ca9b" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">我们现在将使用我们所学的知识编写我们的组件。在使用的概念中:</p><ul class=""><li id="bb49" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv oe of og oh bi translated">@react-component decorator</li><li id="374c" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">打开模块</li><li id="f95d" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">为我们的道具命名的论点</li></ul><p id="be0b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这是我们第一次尝试写文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Here is the first try at rewriting ProductAction to ReScript</figcaption></figure><p id="39de" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们现在将看到这个有用的编译器错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/bbca7424bd796f3833f0e0f4b734e252.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Tv022MgrJCF4PPHDttUsOw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">ReScripts amazing compiler lets us know exactly what inputs are acceptable!</figcaption></figure><p id="7c81" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们现在将“主要”值更新为<code class="fe nr ns nt nu b">#Primary</code>。</p><p id="6f24" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir">注:</strong> <em class="lb">出现差异的原因是我们可以使用原因文件，但是Script </em>中的语法略有变化。这甚至可以应用于道具/关键词。因此，原因绑定是一个很好的指南，但是编译器和一些额外的研究可能需要。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">This now compiles and works!</figcaption></figure><p id="547b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们的代码现在可以工作了。我建议你看看输出。我们现在可以逐步切换我们的应用程序来使用这个输出的JS文件。在下一节中，我们将展示如何进行增量切换。</p><h2 id="9a98" class="mz mh iq bd mi na nb dn mm nc nd dp mq lw ne nf ms lx ng nh mu ly ni nj mw nk bi translated">用我们的产品动作替换脚本组件</h2><p id="2316" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">我们的应用程序使用一种模式，即<code class="fe nr ns nt nu b">index.js</code>文件作为我们的反应组件的出口。当导入组件时，这给了我们一些可读性上的改进。此外，这种模式允许我们很容易地用现有的组件替换我们的脚本组件。下面是开关。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Swapping our components is very easy</figcaption></figure><p id="74ee" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">就这样！这个简单的组件涵盖了很多领域，但是这些知识应该能让我们在未来走得更快。在下一部分，我们将处理应用程序中最复杂的类型:记录。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="9a42" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">将我们的产品定义为记录类型</h1><p id="536f" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">在我们的应用程序中，我们的大多数类型都是基本的基本类型。我们的应用确实有一个对正确建模很重要的数据结构:我们的<code class="fe nr ns nt nu b">product</code>记录。因此，接下来应对<code class="fe nr ns nt nu b">product</code>类型是有意义的。这将使我们能够开始重写应用程序的其余部分。</p><p id="93e2" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">有三个步骤:</p><ol class=""><li id="fe76" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv on of og oh bi translated">定义描述我们产品的<a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/record" rel="noopener ugc nofollow" target="_blank">记录</a>类型。<strong class="lc ir">注意:</strong> <a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/object" rel="noopener ugc nofollow" target="_blank">物体</a>也存在，但不建议使用</li><li id="a876" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated">定义一个maker函数，该函数接受命名参数并基于输入创建记录</li><li id="32fc" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated">转换我们的产品数组，使用这个新的maker函数来填充数组。</li></ol><p id="8aca" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">以下是它的外观。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Our updated product constants with our new type!</figcaption></figure><p id="c5f1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们在这里学到了一些新概念。我想谈两点:</p><ul class=""><li id="38cc" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv oe of og oh bi translated"><a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/null-undefined-optionhttps://rescript-lang.org/docs/manual/latest/null-undefined-option" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">选项类型</strong></a>—ReScript没有未定义或空的类型，而是有一个选项类型。这有助于我们完全避免由这些类型引起的错误！</li><li id="efce" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated"><strong class="lc ir">访问我们的新记录类型— </strong>既然我们已经定义了产品类型，我们的应用程序可能需要引用它。重要的是要知道编译器访问我们的类型声明的方式和访问任何模块内容的方式是一样的。要使用<strong class="lc ir">，</strong>你可以使用<code class="fe nr ns nt nu b">Product.product</code>注释该类型，或者只打开<code class="fe nr ns nt nu b">Product</code>模块，让整个模块访问该类型。</li><li id="8187" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">当使用我们的maker函数时，我们传递的最后一个参数总是<code class="fe nr ns nt nu b">()</code>，称为<code class="fe nr ns nt nu b">unit</code>。这让编译器知道我们已经完成了参数传递。</li></ul><p id="dbc1" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">既然我们已经设置了<code class="fe nr ns nt nu b">product</code>类型，现在我们可以轻松地完成应用程序的其余部分。</p><p id="bf7b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在下一节中，我们将键入我们的utils文件。在这个过程中，我们将开始使用我们的新类型，利用ReScript的内置库，并使用出色的管道操作符(<code class="fe nr ns nt nu b">-&gt;</code>)。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="6238" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">内置库+管道操作符=太棒了！</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/d7bf228a17a3352e8ae63f6c51aba4aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qp_Grz7jGv8F2waf"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@drewsal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Drew Sal</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="227f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在我们已经定义了我们的<code class="fe nr ns nt nu b">product</code>类型，我们可以查看我们的cart utils并开始转换它们。下面是我们的原始文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Our original cart utils</figcaption></figure><p id="3522" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">您可能会注意到，我们在这个文件中使用了lodash，但是我们没有为ReScript安装一个等效的库。我们不需要它！有了标准的脚本库，我们将能够涵盖所有这些用例。</p><p id="6d25" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们将放大第一个函数<code class="fe nr ns nt nu b">calculateProductPrice</code>来看看几个概念:</p><ul class=""><li id="8cde" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv oe of og oh bi translated">如何在ReScript中构建函数</li><li id="c208" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">看公共图书馆</li><li id="21aa" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">在代码中使用类型定义</li><li id="36bb" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">使用管道运算符提高可读性</li></ul><h2 id="6a89" class="mz mh iq bd mi na nb dn mm nc nd dp mq lw ne nf ms lx ng nh mu ly ni nj mw nk bi translated">函数快速备忘单</h2><p id="ce8c" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">关于函数，需要记住以下几点:</p><ul class=""><li id="2a5c" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv oe of og oh bi translated">它们被分配给带有<code class="fe nr ns nt nu b">let</code>关键字的变量</li><li id="47d0" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">函数的最后一行是隐式返回</li><li id="98e0" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">默认情况下，函数为curry</li></ul><p id="d27b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如果你想了解更多关于函数的知识，这里有一些文档。</p><h2 id="7898" class="mz mh iq bd mi na nb dn mm nc nd dp mq lw ne nf ms lx ng nh mu ly ni nj mw nk bi translated">使用我们的第一个图书馆</h2><p id="8cb8" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">对于我们的第一个函数，我们需要重新创建与lodash中的<code class="fe nr ns nt nu b">get</code>相同的功能。幸运的是，标准库为我们提供了这样的工具。让我们先来看看<a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/api" rel="noopener ugc nofollow" target="_blank"> API文档</a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/2ef89fabdeb14739372464c621227157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iwQogourTYyiMpC5Ggq4kQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The impressive built-in libraries have awesome API docs!</figcaption></figure><p id="0697" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir">注意:</strong>由于我们之前输入了我们的<code class="fe nr ns nt nu b">product</code>记录，我们不需要使用<code class="fe nr ns nt nu b">get</code>方法。这是因为我们永远不会看到一个空洞的“价格”或“数量”。尽管如此，我们还是要重新创建这个功能来学习。</p><p id="3c03" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如您所见，库是按数据类型组织的。浏览文档或使用搜索功能，<a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/api/belt/option#getwithdefault" rel="noopener ugc nofollow" target="_blank">我们在</a> <code class="fe nr ns nt nu b"><a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/api/belt/option#getwithdefault" rel="noopener ugc nofollow" target="_blank">Belt.Option</a></code> <a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/api/belt/option#getwithdefault" rel="noopener ugc nofollow" target="_blank">库中发现了一个</a> <code class="fe nr ns nt nu b"><a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/api/belt/option#getwithdefault" rel="noopener ugc nofollow" target="_blank">getWithDefault</a></code> <a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/api/belt/option#getwithdefault" rel="noopener ugc nofollow" target="_blank">方法。查看文档，我们注意到传递的第一个值是我们的值的一个</a><a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/null-undefined-option" rel="noopener ugc nofollow" target="_blank">选项</a>。要将我们的值转换成选项，我们只需要将它们包装在一个<code class="fe nr ns nt nu b">Some</code>函数中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Here is our first try at recreating the function</figcaption></figure><p id="56d3" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir">附注:Some|None选项类型非常强大。</strong> <a class="ae kv" href="https://mostly-adequate.gitbooks.io/mostly-adequate-guide/content/ch08.html#schr%C3%B6dingers-maybe" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">要了解更多，你可以读一读弗里斯比教授的《函数式编程基本充足指南》的这一节！</strong> </a></p><p id="c670" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在编写这些内容时，我们将得到以下有用的错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/5bf12d06ea36f5368da5e1c9f12a7e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NvlvF_IitiMd3qbpUcO1VQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">While we have defined our product type, we forgot to import it into our CartUtils file!</figcaption></figure><p id="e70b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们忘记了导入我们的类型定义。我们可以通过打开<code class="fe nr ns nt nu b">CartUtils</code>模块顶部的<code class="fe nr ns nt nu b">Product</code>模块来解决这个问题。这允许我们的<code class="fe nr ns nt nu b">CartUtils</code>文件中的所有函数都可以访问我们的<code class="fe nr ns nt nu b">product</code>类型。将<code class="fe nr ns nt nu b">open Product</code>添加到文件的顶部后，我们将得到以下错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/fcc58a55cf79aa42f9f748f5bff4aeda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SRnX3oc96Ycmwj_0QhZmWA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Our compiler reminds us that we need to convert quantity to a float type.</figcaption></figure><p id="bfbb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">编译器很有帮助地提醒我们，我们需要将quantity转换为float类型，以便将它乘以价格。编译器甚至会告诉我们使用什么库函数来做这件事！我们现在将更新我们的文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Here is our working version of the calculateProductPrice.</figcaption></figure><p id="21d4" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们现在有一个工作的util函数，但是很难读懂这个函数。</p><p id="9821" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在我们继续之前，我们将通过使用管道函数和利用自动匹配来清理我们的文件。</p><h2 id="4310" class="mz mh iq bd mi na nb dn mm nc nd dp mq lw ne nf ms lx ng nh mu ly ni nj mw nk bi translated">使用管道函数和curry来清理我们的函数</h2><p id="2310" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">我们写了一个工作函数，但是很难读懂。我们将利用这样一个事实，即每个函数在默认情况下都是curries，以便于阅读。</p><p id="9b5e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">管道让我们将一个函数的结果作为参数传递给另一个函数。我们将利用这一点并重写我们的函数。下面是我们更新的文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Using a combination of pipes, currying, and opening Belt, we greatly improve the readability of our file.</figcaption></figure><p id="2d33" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">正如你所看到的，这是非常可读的。我们现在将继续应用这些工具，并继续重写文件的其余部分。这是最后一个文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Our finalized CartUtils with comments</figcaption></figure><p id="a39a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">需要指出一些事情:</p><ol class=""><li id="f48f" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv on of og oh bi translated">ReScript支持三元运算。</li><li id="b6a1" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated">我们将函数分成更小的部分，以提高可读性。</li><li id="41e8" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated">我们在这个文件中利用了<code class="fe nr ns nt nu b"><a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/api/belt/array" rel="noopener ugc nofollow" target="_blank">Belt.Arra</a>y</code>库，但是也存在一个<code class="fe nr ns nt nu b"><a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/api/js/array" rel="noopener ugc nofollow" target="_blank">Js.Array</a></code>库。它们可能有一些相似的功能，但并不总是如此。总是先检查<code class="fe nr ns nt nu b">Belt</code>库，因为默认情况下它提供了不变性，然后再检查<code class="fe nr ns nt nu b">Js</code>库。</li></ol><p id="a9fe" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在我们已经完成了，我们将重写我们的<code class="fe nr ns nt nu b">App.jsx</code>文件。这个组件有一些我们需要处理的人为问题。在下一节中，我们将解决这些问题并学习一些新的功能，但是首先，我们将研究部分应用程序和类型系统之间的关系。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="3b58" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">当心局部应用和类型系统</h1><p id="3a25" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">部分应用程序是一个强大的工具，ReScript让我们可以通过默认设置所有函数来轻松使用它。<strong class="lc ir">当心！使用局部应用</strong>时，我们必须考虑类型系统。好吧，不是真的小心，编译器不会让我们做任何不安全的事情。让我们首先看一个通过currying在普通JavaScriptfile文件中使用partial application的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">An example of currying and partial application in practice.</figcaption></figure><p id="83a6" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">上面的代码是有效的JavaScript用法。</p><p id="cede" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在，让我们试着重新写一遍。<strong class="lc ir">注意:这不是有效的说明，而是用于说明目的。</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">This file shows how partial application and types work together in ReScript.</figcaption></figure><p id="db09" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">从上面的例子可以看出，<strong class="lc ir">部分应用的函数只能有一种类型的返回。如果你忘记这么做，编译器会抱怨的。这就是强式系统的力量！</strong></p><p id="dc8b" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们也可以使用<code class="fe nr ns nt nu b">_</code>将参数部分应用到我们的函数中，提高可重用性！</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="1606" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">在ReasonReact中编写我们的第一个React钩子</h1><p id="a5c9" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">我们的<code class="fe nr ns nt nu b">App</code>组件是我们要解决的下一个问题。下面是它的样子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Our App.jsx file, commented to highlight contrived errors</figcaption></figure><p id="1943" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们需要解决一些显而易见的问题，才能让这种方法发挥作用。这包括:</p><ul class=""><li id="1c58" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv oe of og oh bi translated">将我们的初始购物车值从字符串改为数字<code class="fe nr ns nt nu b">0</code></li><li id="bb11" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv oe of og oh bi translated">用位于我们的<code class="fe nr ns nt nu b">Product</code>模块中的正确的<code class="fe nr ns nt nu b">productDetails</code>列表切换出我们的无效<code class="fe nr ns nt nu b">initialProductListWithTypeErrors</code></li></ul><p id="fa3c" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">当我们重写我们的<code class="fe nr ns nt nu b">App</code>时，我们必须记住这一点。还有一点需要注意的是，它使用了<code class="fe nr ns nt nu b">ProductTable</code>。我们还没有重写它，所以我们将不得不导入它。</p><p id="8c08" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们也将使用<code class="fe nr ns nt nu b">useState</code>挂钩。React网站上有一些ReasonML的例子可以帮助你。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">our App.res file with comments</figcaption></figure><p id="1d6a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">只是一些需要注意的事情:</p><ol class=""><li id="600b" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv on of og oh bi translated">我们可以在React渲染方法中使用管道操作符，如<code class="fe nr ns nt nu b">React.string</code>、<code class="fe nr ns nt nu b">React.float</code>、<code class="fe nr ns nt nu b">React.array</code>等。</li><li id="3e78" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated">我们的<code class="fe nr ns nt nu b">useState</code>不取值<strong class="lc ir">，而是取一个返回值的函数。</strong></li><li id="9323" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated">MaterialUI将类似<code class="fe nr ns nt nu b">#Right</code>的变体用于align等道具。记得查看他们的文档或检查你的节点模块中的文件。</li><li id="5854" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated"><code class="fe nr ns nt nu b"><strong class="lc ir">_</strong></code>操作符让编译器知道您不会使用传递的参数。否则，您将会看到如下所示的编译器错误:</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/d756213421104c53190417aac5a81ce0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-T_nMbBgUBBfzrUJH_5Tzw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The compiler reads a unit type if you pass “()”</figcaption></figure><p id="496f" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">现在，我们已经确保了我们的主要数据(我们的购物车和价格)是正确的，并正确输入，我们现在可以快速浏览并完成输入我们的应用程序。我们还需要一些概念。</p><p id="5e1d" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在此之前，我们应该记得从我们的<code class="fe nr ns nt nu b">Index.res</code>文件中删除我们的<code class="fe nr ns nt nu b">App.jsx</code>导入。</p><p id="6249" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">接下来，我们将进入简单的<code class="fe nr ns nt nu b">ProductTable</code>组件。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="1d51" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">给孩子们传递道具的速成课</h1><p id="3f41" class="pw-post-body-paragraph kz la iq lc b ld nl jr lf lg nm ju li lw nn ll lm lx no lp lq ly np lt lu lv ij bi translated">转换我们的<code class="fe nr ns nt nu b">ProductTable</code>文件非常简单。这是原始文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="55ca" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这是我们转换后的文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Our ProductTable component written in ReScript</figcaption></figure><p id="a7b7" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">唯一需要注意的独特之处是:</p><ol class=""><li id="5fac" class="nz oa iq lc b ld le lg lh lw ob lx oc ly od lv on of og oh bi translated">我们必须显式地将道具传递给我们的子组件<strong class="lc ir"/>。我们不能传播道具。</li><li id="64f9" class="nz oa iq lc b ld oi lg oj lw ok lx ol ly om lv on of og oh bi translated">当映射组件数组时，我们仍然需要使用React render方法，<code class="fe nr ns nt nu b">React.array</code>。</li></ol><p id="94ae" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">快好了。我们现在来看看最后一个组件<code class="fe nr ns nt nu b">ProductRow</code>。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="ff7b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">学习模式匹配</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/badd87894ba4cc4d47ab65e180e6e125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Y-rKSKWvtGI_qqiz"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@crischv87?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cristian Cristian</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="efc8" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">在大多数情况下，<code class="fe nr ns nt nu b">ProductRow</code>非常容易转换。关于如何呈现可选属性<code class="fe nr ns nt nu b">description</code>，我们确实有些复杂。有几种方法可以解决这个问题。这是我们的原始文件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Here is the original ProductRow file.</figcaption></figure><p id="7934" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">处理可选的<code class="fe nr ns nt nu b">description</code>属性的一种方法是使用<code class="fe nr ns nt nu b">Option.getWithDefault</code>方法返回一个值，我们可以将这个值传递给另一个函数。这个函数将帮助我们决定返回什么元素。这增加了很多复杂性。下面是该实现的样子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Handling optional param with helper function and ternary</figcaption></figure><p id="27cb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">不过有一种更好的方法:<a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/pattern-matching-destructuring" rel="noopener ugc nofollow" target="_blank">模式匹配！</a></p><p id="b02a" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们的描述是一个<a class="ae kv" href="https://rescript-lang.org/docs/manual/latest/null-undefined-option" rel="noopener ugc nofollow" target="_blank">选项</a>，所以它只有两个可能的值:一些(值)或者没有。使用模式匹配，我们可以很容易地考虑这两种情况。如果我们错过了一个边缘情况，编译器也会给出有用的警告。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/41d27038999f41c2be4c0fabce7605ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*crVyNpMs6c-s-XT71AWo9A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The compiler lets us know if we failed to account for a potential state!</figcaption></figure><p id="fe45" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">下面是我们如何实现这一点。你会发现它读起来更容易，启动起来更安全！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Handling optional param with pattern matching</figcaption></figure><p id="2321" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">就是这样。我们完了！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/6abccd2cb08262b8b51bfc420282afa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3bfFtQQmEp-o_cMv"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@mioitophotography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">MIO ITO</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2306" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">我们现在可以清理我们的项目了。这包括移除<code class="fe nr ns nt nu b">App.res</code>中的<code class="fe nr ns nt nu b">ProductTable</code>导入。完成这一步后，我们的应用程序应该100%运行我们编译的脚本代码！</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="33fe" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/34efaf4246efe1e1590af012b6ab6ae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WRamH-ZeVAcOjMlU"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Priscilla Du Preez</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2719" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">如您所见，关于ReScript还有很多要学的，但它是一种非常强大的语言。我们已经介绍了大量内容，但是希望您现在对如何开始有了更好的理解。</p><p id="2f5e" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">这里是我们最终代码的链接！</p><p id="6acb" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated">感谢您阅读我的第一篇文章！请不要客气。</p><p id="9ead" class="pw-post-body-paragraph kz la iq lc b ld le jr lf lg lh ju li lw lk ll lm lx lo lp lq ly ls lt lu lv ij bi translated"><strong class="lc ir">注意:由于所涉及的内容太广，我们在本教程中没有使用Gentype功能。如果感兴趣，请联系我，我也许可以写一篇关于垫片和其他需要知道的事情的短文。</strong></p></div></div>    
</body>
</html>