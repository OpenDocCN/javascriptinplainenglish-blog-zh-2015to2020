<html>
<head>
<title>The Power of Higher-Order Array Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高阶数组函数的威力</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-power-of-array-function-93d5428286c3?source=collection_archive---------4-----------------------#2019-11-24">https://javascript.plainenglish.io/the-power-of-array-function-93d5428286c3?source=collection_archive---------4-----------------------#2019-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="923d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">查找，一些，映射，减少，每个，过滤器</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f005722ff6cf74e48b49ca124d5ec972.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R9QJNmT0Ykvn3H751OQSMw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@tjump?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nik Shuliahin</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://www.webtips.dev/the-power-of-higher-order-array-functions"><div class="gh gi kw"><img src="../Images/c19cb3069af1beba3c93258d9fcfe139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*-PVzecNs3s4ZbJsdsgIsGA.png"/></div></a></figure><p id="907f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">数组无处不在。从简单的矩阵到复杂的对象列表，在页面上保存每个产品的每个细节。我们每天都要处理它们，当我们对它们进行操作时，我们会本能地写出相同的代码行，而不会太注意它们可能采取的形式。您编写它们的方式决定了其他人阅读和理解您的实现的难易程度。</p><p id="4138" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">幸运的是，在JavaScript中，我们有一些很好的处理数组的内置函数，可以简化您的代码，使其更容易阅读，最终，在出现问题时更容易调试。</p><p id="edf9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">与数组相关联的函数是函数式编程范式的核心部分，它只不过是</p><blockquote class="lt"><p id="5003" class="lu lv iq bd lw lx ly lz ma mb mc ls dk translated">“构建计算机程序的结构和元素的一种风格”——<a class="ae kv" href="https://en.wikipedia.org/wiki/Functional_programming" rel="noopener ugc nofollow" target="_blank">维基百科</a></p></blockquote><p id="eb1f" class="pw-post-body-paragraph kx ky iq kz b la md jr lc ld me ju lf lg mf li lj lk mg lm ln lo mh lq lr ls ij bi translated">人们常说，在函数式编程中，你声明你的意思。当你使用命令式方法时，你的代码更关注于<em class="mi">“它是如何做的”</em>事情。采用声明式方法，它更关注于<em class="mi">“它正在做什么”</em>。如果您想看一些代码示例来演示这两者之间的区别，请继续阅读，当我们看到<code class="fe mj mk ml mm b">map</code>函数时，我会这样做。</p><p id="5a4b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在，为了演示我们拥有的每一个函数，我们需要一些数据来处理。让我们假设你正在开发一个电子商务，你有一系列的产品。每个商品都包含一个对象，该对象具有各种属性，例如名称、价格、id，如果商品正在销售，还会有一个可选的标志:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="e2b1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果商品不打折，则整个标志被省略。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="73e2" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">数组.原型.查找</h1><p id="aab4" class="pw-post-body-paragraph kx ky iq kz b la no jr lc ld np ju lf lg nq li lj lk nr lm ln lo ns lq lr ls ij bi translated"><code class="fe mj mk ml mm b">find</code>，顾名思义是用来查找数组中的特定元素。它返回一个首先通过回调函数测试的项目:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="fcd1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于第一个例子，我们返回一个对象，因为每个id都是唯一的。够清楚了。但是在第二个例子中，我们有两个正在销售的产品，但是我们仍然只能得到第一个通过测试的产品。如果没有匹配，它简单地返回<code class="fe mj mk ml mm b">undefined</code>。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="3938" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">数组.原型.过滤器</h1><p id="8ffd" class="pw-post-body-paragraph kx ky iq kz b la no jr lc ld np ju lf lg nq li lj lk nr lm ln lo ns lq lr ls ij bi translated">现在，如果我们想找到所有正在销售的产品，而不仅仅是第一个产品，该怎么办呢？这就是<code class="fe mj mk ml mm b">filter</code>可以帮助我们的地方:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="2a4e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe mj mk ml mm b">filter</code>返回每个通过测试的元素，不像<code class="fe mj mk ml mm b">find</code>只返回第一个。如果没有匹配，我们得到的不是<code class="fe mj mk ml mm b">undefined</code>，而是<code class="fe mj mk ml mm b">[]</code>。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="f833" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">数组.原型.每</h1><p id="5c01" class="pw-post-body-paragraph kx ky iq kz b la no jr lc ld np ju lf lg nq li lj lk nr lm ln lo ns lq lr ls ij bi translated">不像<code class="fe mj mk ml mm b">find</code>或<code class="fe mj mk ml mm b">filter</code>我们期望从数组中返回一个项目，<code class="fe mj mk ml mm b">every</code>返回一个<code class="fe mj mk ml mm b">true</code>或<code class="fe mj mk ml mm b">false</code>值。如果数组中的每一项都通过了测试，我们就得到<code class="fe mj mk ml mm b">true</code>，否则就剩下<code class="fe mj mk ml mm b">false</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="e8ec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">很明显，对于一个给定的电子商务网站，并不是每个产品都在销售，所以我们回到第一个例子的<code class="fe mj mk ml mm b">false</code>。但是，我们可以检查是否每个产品都有名称。因为在这个例子中他们有，我们得到一个<code class="fe mj mk ml mm b">true</code>值。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="1130" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">数组.原型.一些</h1><p id="61d7" class="pw-post-body-paragraph kx ky iq kz b la no jr lc ld np ju lf lg nq li lj lk nr lm ln lo ns lq lr ls ij bi translated"><code class="fe mj mk ml mm b">some</code>在返回值方面与<code class="fe mj mk ml mm b">every</code>非常相似:要么返回一个<code class="fe mj mk ml mm b">true</code>要么返回<code class="fe mj mk ml mm b">false</code>。但是，不是检查每一个项目是否符合标准，如果至少有一个产品符合标准，它将立即返回<code class="fe mj mk ml mm b">true</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="33e0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这一次，我们返回<code class="fe mj mk ml mm b">true</code>,因为我们没有检查是否每件商品都在打折。我们只对是否至少有一件商品打折感兴趣。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="7357" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">数组.原型.地图</h1><p id="7187" class="pw-post-body-paragraph kx ky iq kz b la no jr lc ld np ju lf lg nq li lj lk nr lm ln lo ns lq lr ls ij bi translated">到目前为止，我们只研究了如何过滤数组中的值。每个函数的主要目的都是根据给定的标准匹配一个项目。<code class="fe mj mk ml mm b">map</code>另一方面，用于变换一个数组。我们给它一个回调函数，每个条目都会被调用。在函数内部，我们通常会做一些转换。假设您想要对每种产品的价格进行舍入:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="91fd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在第一个例子中，如果我们只返回价格，我们只得到一个与原始长度相同的数组，但是只有价格。为了获得预期的行为，我们需要在最后返回<code class="fe mj mk ml mm b">product</code>本身。请注意，与for循环相比，使用<code class="fe mj mk ml mm b">map</code>可以简化您的代码—<em class="mi">—并使其更具可读性。</em></p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="7873" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">array . protocol . reduce</h1><p id="6984" class="pw-post-body-paragraph kx ky iq kz b la no jr lc ld np ju lf lg nq li lj lk nr lm ln lo ns lq lr ls ij bi translated">我们漏掉了reduce，最吓人的。至少对我来说是这样，比其他人都多。<code class="fe mj mk ml mm b">reduce</code>用于从数组中产生单个值。它对每个项目都进行操作，并且还需要一个累加器。</p><p id="4095" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">假设这次我们想得到所有产品的价格总和。借助<code class="fe mj mk ml mm b">reduce</code>。这可以简单地用一行代码来完成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="cc95" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><code class="fe mj mk ml mm b">reduce</code>需要两个参数，一个用于回调函数，一个用于初始值。我们从<code class="fe mj mk ml mm b">0</code>开始，这是我们的初始值。回调函数接受两个参数，一个是累积值，一个是项目本身。在每次迭代中，<code class="fe mj mk ml mm b">accumulated</code>参数获取前一次迭代产生的值。</p><ul class=""><li id="dc60" class="nt nu iq kz b la lb ld le lg nv lk nw lo nx ls ny nz oa ob bi translated">开始的时候，它的值会是<code class="fe mj mk ml mm b">0</code>。</li><li id="fd4a" class="nt nu iq kz b la oc ld od lg oe lk of lo og ls ny nz oa ob bi translated">然后我们将第一个产品的价格加到它上面，这样它的值就是<code class="fe mj mk ml mm b">73</code>。</li><li id="7f69" class="nt nu iq kz b la oc ld od lg oe lk of lo og ls ny nz oa ob bi translated">在下一次迭代中，当函数被调用时，<code class="fe mj mk ml mm b">accumulated</code>的值将会是<code class="fe mj mk ml mm b">73</code>,我们将为其添加下一个价格标签，以此类推。</li></ul></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="af14" class="mw mx iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">摘要</h1><p id="a4df" class="pw-post-body-paragraph kx ky iq kz b la no jr lc ld np ju lf lg nq li lj lk nr lm ln lo ns lq lr ls ij bi translated">有了工具箱中的每一个重要的数组函数，你就能使你的代码更容易推理，更干净，最后但同样重要的是，更容易测试。</p><p id="97be" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你现在还没有在你的代码库中使用它们，那就去尝试一下吧，你可能永远都不想回头了。感谢您花时间阅读本文，编码快乐！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://medium.com/@ferencalmasi/membership"><div class="gh gi oh"><img src="../Images/e66c4cd6d9849ac0bd245f3fc39b65c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZ9xuLqLkbqUG65sgVB3gg.png"/></div></a></figure></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://www.webtips.dev/why-you-should-know-about-functional-programming"><div class="gh gi kw"><img src="../Images/1ddbbe20fa1890d8bd41d28ff10820b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*mzPhJEkhs8oy0zAidTKQHQ.png"/></div></a></figure></div></div>    
</body>
</html>