<html>
<head>
<title>Using JavaScript’s Object Constructor — Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript的对象构造函数—第1部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-javascripts-object-constructor-part-1-b93e15b75fe2?source=collection_archive---------3-----------------------#2019-12-12">https://javascript.plainenglish.io/using-javascripts-object-constructor-part-1-b93e15b75fe2?source=collection_archive---------3-----------------------#2019-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f275e733ba1077865fdcf1018dfc8074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XS8Bl2Q8PxYr-EN-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@imandrewpons?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrew Pons</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9005" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，<code class="fe lb lc ld le b">Object</code>构造函数让我们用给定的值创建对象包装器。如果将<code class="fe lb lc ld le b">null</code>或<code class="fe lb lc ld le b">undefined</code>传递给对象构造函数，它将创建一个空对象。如果传入构造函数的值已经是一个对象，那么它将返回该对象。</p><p id="fa95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Object</code>构造函数有两个属性。它有一个始终为1的<code class="fe lb lc ld le b">length</code>属性，像所有其他对象一样，<code class="fe lb lc ld le b">Object</code>构造函数有一个原型来获取类型对象的所有附加属性。</p><p id="fc89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Object</code>构造函数有许多有用的方法，不用构造一个新对象就可以使用。该列表的第1部分如下:</p><h2 id="b9b2" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated"><code class="fe lb lc ld le b">Object.assign()</code></h2><p id="c47d" class="pw-post-body-paragraph kd ke iq kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">方法制作一个对象的浅层拷贝。第一个参数是要将对象复制到的目标对象，第二个参数接受要复制的对象。请注意，如果源对象和目标对象具有相同的属性，源对象的属性值将覆盖目标对象中的属性值。例如，我们可以写:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="261a" class="lf lg iq le b gy ml mm l mn mo">const target = { a: 1, b: 2 };<br/>const source = { b: 3, c: 4};</span><span id="ff43" class="lf lg iq le b gy mp mm l mn mo">const newObj = Object.assign(target, source);<br/>console.log(newObj)</span></pre><p id="e9ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行代码，我们将得到<code class="fe lb lc ld le b">{ a: 1, b: 3, c: 4}</code>。我们也可以复制数组。例如，我们可以写:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="1dbb" class="lf lg iq le b gy ml mm l mn mo">const targetArr = [1,2];<br/>const sourceArr = [2,3];</span><span id="7837" class="lf lg iq le b gy mp mm l mn mo">const newArr = Object.assign(targetArr, sourceArr);<br/>console.log(newArr)</span></pre><p id="3af3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们运行上面的代码时，我们记录了<code class="fe lb lc ld le b">[2,3]</code>。对于数组，它将使用源数组覆盖整个目标数组。</p><h2 id="3a37" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated"><code class="fe lb lc ld le b">Object.create()</code></h2><p id="1968" class="pw-post-body-paragraph kd ke iq kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated"><code class="fe lb lc ld le b">Object.create()</code>方法创建一个新对象，将您传入的对象作为新对象的原型。例如，我们可以写:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="0b7e" class="lf lg iq le b gy ml mm l mn mo">const obj = { a: 1, b: 2, c: 3 };<br/>const newObj = Object.create(obj);<br/>console.log(newObj);</span></pre><p id="886a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，当我们记录<code class="fe lb lc ld le b">newObj</code>时，它没有自己的不是从<code class="fe lb lc ld le b">obj</code>继承的属性。这是因为我们只向构造函数传递了第一个参数，它是返回的对象的原型。如果我们想添加只在返回的对象中可用的属性，我们传入一个对象，将属性名作为键，将属性<code class="fe lb lc ld le b">writable</code>、<code class="fe lb lc ld le b">configurable</code>、<code class="fe lb lc ld le b">enumerable</code>和<code class="fe lb lc ld le b">value</code>作为属性名键的属性，这称为属性描述符。例如，我们可以写:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="9e13" class="lf lg iq le b gy ml mm l mn mo">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>};</span><span id="a988" class="lf lg iq le b gy mp mm l mn mo">const childObj = {<br/>  a: {<br/>    writable: true,<br/>    configurable: true,<br/>    value: 'hello'<br/>  },<br/>  d: {<br/>    writable: true,<br/>    configurable: true,<br/>    value: 'hello'<br/>  }<br/>}<br/>const newObj = Object.create(obj, childObj);<br/>console.log(newObj);</span></pre><p id="3c7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，<code class="fe lb lc ld le b">writable</code>意味着属性的值可以更改。<code class="fe lb lc ld le b">configurable</code>表示属性描述符可以被改变，并且属性是否可以从对象中删除。<code class="fe lb lc ld le b">enumerable</code>属性是指用<code class="fe lb lc ld le b">for...in</code>循环枚举属性时出现的属性，<code class="fe lb lc ld le b">value</code>是该属性的值。</p><p id="8c9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想要创建一个属性不可更改的对象，那么我们将<code class="fe lb lc ld le b">writable</code>设置为<code class="fe lb lc ld le b">false</code>，如下面的代码所示:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="c5b6" class="lf lg iq le b gy ml mm l mn mo">const obj = {<br/>  a: 1,<br/>  b: 2,<br/>  c: 3<br/>};</span><span id="8b16" class="lf lg iq le b gy mp mm l mn mo">const childObj = {<br/>  a: {<br/>    writable: false,<br/>    configurable: true,<br/>    value: 'hello'<br/>  },<br/>  d: {<br/>    writable: true,<br/>    configurable: true,<br/>    value: 'hello'<br/>  }<br/>}<br/>const newObj = Object.create(obj, childObj);<br/>newObj.a = 1;<br/>newObj.d = 1;<br/>console.log(newObj);</span></pre><p id="e673" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，赋值运算符不起作用。如果我们启用了严格模式，那么就会抛出一个<code class="fe lb lc ld le b">TyepError</code>。我们已经在<code class="fe lb lc ld le b">console.log</code>中登录了<code class="fe lb lc ld le b">{a: “hello”, d: 1}</code>。这意味着设置为<code class="fe lb lc ld le b">false</code>的<code class="fe lb lc ld le b">writable</code>为属性<code class="fe lb lc ld le b">a</code>工作，设置为<code class="fe lb lc ld le b">true</code>的<code class="fe lb lc ld le b">writable</code>值为属性<code class="fe lb lc ld le b">d</code>工作。</p><p id="1034" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将<code class="fe lb lc ld le b">null</code>传递给构造函数，我们会得到一个空对象:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="1d0d" class="lf lg iq le b gy ml mm l mn mo">const nullObj = Object.create(null)<br/>console.log(nullObj)</span></pre><p id="1f67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将得到一个错误“对象原型可能只是一个对象或null: undefined”是我们在<code class="fe lb lc ld le b">undefined</code>中传递的一个对象的原型，如下面的代码所示:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="85b1" class="lf lg iq le b gy ml mm l mn mo">const undefinedObj = Object.create(undefined);<br/>console.log(undefinedObj)</span></pre><figure class="md me mf mg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mq"><img src="../Images/470b6ef349dfef19ca154b5a677f9327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yRhJiin18AWi3jm6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@tierramallorca?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tierra Mallorca</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="147a" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated"><code class="fe lb lc ld le b">Object.defineProperty()</code></h2><p id="35c5" class="pw-post-body-paragraph kd ke iq kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">方法定义了一个对象的新属性。第一个参数是要向其添加属性的对象。第二个参数是您希望添加的属性的名称，作为字符串传递，最后一个参数是当我们试图向返回的对象添加属性时包含在<code class="fe lb lc ld le b">Object.create()</code>方法中的属性描述符。属性描述符应该将属性<code class="fe lb lc ld le b">writable</code>、<code class="fe lb lc ld le b">configurable</code>、<code class="fe lb lc ld le b">enumerable</code>和<code class="fe lb lc ld le b">value</code>作为属性名称键的属性。<code class="fe lb lc ld le b">writable</code>意味着属性的值可以改变。<code class="fe lb lc ld le b">configurable</code>表示属性描述符可以被改变，并且属性是否可以从对象中删除。<code class="fe lb lc ld le b">enumerable</code>属性是指用<code class="fe lb lc ld le b">for...in</code>循环枚举属性时出现的属性，<code class="fe lb lc ld le b">value</code>是该属性的值。例如，我们可以写:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="2cff" class="lf lg iq le b gy ml mm l mn mo">let obj = {};</span><span id="8de7" class="lf lg iq le b gy mp mm l mn mo">Object.defineProperty(obj, 'a', {<br/>  writable: false,<br/>  configurable: true,<br/>  value: 'hello'<br/>})</span><span id="ea0c" class="lf lg iq le b gy mp mm l mn mo">console.log(obj.a)<br/>obj.a  = 1;<br/>console.log(obj.a)</span></pre><p id="fc17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所见，属性描述符的行为与<code class="fe lb lc ld le b">Object.create()</code>中的行为相同。当<code class="fe lb lc ld le b">writable</code>为<code class="fe lb lc ld le b">false</code>时，对该属性的赋值无效。如果我们启用了严格模式，那么将抛出一个<code class="fe lb lc ld le b">TyepError</code>。</p><p id="6809" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以为属性定义getter和setter函数，分别称为属性的<code class="fe lb lc ld le b">get</code>和<code class="fe lb lc ld le b">set</code>:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="d28a" class="lf lg iq le b gy ml mm l mn mo">let obj = {};<br/>let value;</span><span id="acc9" class="lf lg iq le b gy mp mm l mn mo">Object.defineProperty(obj, 'a', {<br/>  get() {<br/>    return value;<br/>  },<br/>  set(a) {<br/>    value = a;<br/>  }<br/>});</span><span id="eac8" class="lf lg iq le b gy mp mm l mn mo">console.log(obj.a)<br/>obj.a = 1;<br/>console.log(obj.a)</span></pre><p id="b67b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，在上面的代码中，我们用<code class="fe lb lc ld le b">get</code>和<code class="fe lb lc ld le b">set</code>函数为对象<code class="fe lb lc ld le b">obj</code>定义了属性<code class="fe lb lc ld le b">a</code>，以分别获取属性的值和设置值。</p><p id="b9e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在原型上定义了访问器属性，那么它是在原型上设置的，但是值属性是在当前对象上设置的。如果一个对象继承了不可写的属性，它在当前对象上仍然是不可写的。例如，如果我们有:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="424b" class="lf lg iq le b gy ml mm l mn mo">let ObjClass = function() {};<br/>ObjClass.prototype.a = 1;</span><span id="055c" class="lf lg iq le b gy mp mm l mn mo">Object.defineProperty(ObjClass.prototype, "b", {<br/>  writable: false,<br/>  value: 1<br/>});</span><span id="3160" class="lf lg iq le b gy mp mm l mn mo">const obj = new ObjClass();<br/>ObjClass.prototype.a = 3<br/>obj.a = 2<br/>ObjClass.prototype.b = 3<br/>obj.b = 2<br/>console.log(obj);</span></pre><p id="6ed3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么分配给财产<code class="fe lb lc ld le b">b</code>是没有效果的。如果我们启用了严格模式，那么将抛出一个<code class="fe lb lc ld le b">TyepError</code>。</p><h2 id="9a3a" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated"><code class="fe lb lc ld le b">Object.defineProperties()</code></h2><p id="ea24" class="pw-post-body-paragraph kd ke iq kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">方法让我们在一个对象上定义多个属性。该方法的第一个参数是要定义属性的对象，第二个对象包含作为键的属性名和作为值的相应属性描述符。属性描述符应该有属性<code class="fe lb lc ld le b">writable</code>、<code class="fe lb lc ld le b">configurable</code>、<code class="fe lb lc ld le b">enumerable</code>和<code class="fe lb lc ld le b">value</code>作为属性名称键的属性。<code class="fe lb lc ld le b">writable</code>表示属性值可以更改。<code class="fe lb lc ld le b">configurable</code>表示属性描述符可以被改变，并且属性是否可以从对象中删除。<code class="fe lb lc ld le b">enumerable</code>属性是指在用<code class="fe lb lc ld le b">for...in</code>循环枚举属性的过程中出现的属性，<code class="fe lb lc ld le b">value</code>是属性的值。例如，我们可以写:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="44b1" class="lf lg iq le b gy ml mm l mn mo">let obj = {}<br/>Object.defineProperties(obj, {<br/>  a: {<br/>    writable: true,<br/>    configurable: true,<br/>    value: 'hello'<br/>  },<br/>  d: {<br/>    writable: false,<br/>    configurable: true,<br/>    value: 'hello'<br/>  }<br/>})<br/>obj.a = 1;<br/>obj.d = 1;<br/>console.log(obj);</span></pre><p id="81f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">添加<code class="fe lb lc ld le b">a</code>和<code class="fe lb lc ld le b">d</code>属性，其中<code class="fe lb lc ld le b">a</code>的值可以更改，而<code class="fe lb lc ld le b">d</code>的值不能更改。由于属性<code class="fe lb lc ld le b">d</code>的描述符的<code class="fe lb lc ld le b">writable</code>属性被设置为<code class="fe lb lc ld le b">false</code>，所以<code class="fe lb lc ld le b">console.log</code>将显示<code class="fe lb lc ld le b">{a: 1, d: “hello”}</code>。我们还可以将<code class="fe lb lc ld le b">configurable</code>设置为<code class="fe lb lc ld le b">false</code>，以防止它被删除或其属性描述符被更改。例如，我们可以写:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="bbd5" class="lf lg iq le b gy ml mm l mn mo">let obj = {}<br/>Object.defineProperties(obj, {<br/>  a: {<br/>    writable: true,<br/>    configurable: true,<br/>    value: 'hello'<br/>  },<br/>  d: {<br/>    writable: false,<br/>    configurable: false,<br/>    value: 'hello'<br/>  }<br/>})<br/>obj.a = 1;<br/>delete obj.d;<br/>console.log(obj);</span></pre><p id="9142" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行上面的代码，那么我们可以看到<code class="fe lb lc ld le b">delete</code>操作符对<code class="fe lb lc ld le b">obj</code>的属性<code class="fe lb lc ld le b">d</code>没有影响。</p><h2 id="1c65" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated"><code class="fe lb lc ld le b">Object.entries()</code></h2><p id="11a5" class="pw-post-body-paragraph kd ke iq kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated"><code class="fe lb lc ld le b">Object.entries()</code>方法返回一个对象的键值对数组，可由<code class="fe lb lc ld le b">for...in</code>循环枚举。如果使用<code class="fe lb lc ld le b">for...in</code>循环进行迭代，它们将按照相同的顺序返回。数组的每个条目将把关键字作为第一个元素，把相应关键字的值作为第二个元素。例如，我们可以在下面的代码中使用它来遍历对象的属性:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="1e9c" class="lf lg iq le b gy ml mm l mn mo">const obj = {<br/>  a: 1,<br/>  b: 2<br/>};</span><span id="0d71" class="lf lg iq le b gy mp mm l mn mo">for (let [key, value] of Object.entries(obj)) {<br/>  console.log(key, value);<br/>}</span></pre><p id="d7d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们运行上面的代码时，我们得到了<code class="fe lb lc ld le b">a 1</code>和<code class="fe lb lc ld le b">b 2</code>。这些是这个对象的键值对。</p><h2 id="af8d" class="lf lg iq bd lh li lj dn lk ll lm dp ln ko lo lp lq ks lr ls lt kw lu lv lw lx bi translated"><code class="fe lb lc ld le b">Object.freeze()</code></h2><p id="3af0" class="pw-post-body-paragraph kd ke iq kf b kg ly ki kj kk lz km kn ko ma kq kr ks mb ku kv kw mc ky kz la ij bi translated">方法冻结一个对象。这意味着对象中的所有属性值都不能更改。此外，不能向其添加新属性，也不能更改冻结对象的现有属性描述符。物体被冻结在原地。该方法不返回新的冻结对象。相反，它返回冻结前的原始对象。冻结对象的原型也不能改变。例如，如果我们运行以下命令来冻结一个对象:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="b5f8" class="lf lg iq le b gy ml mm l mn mo">const obj = {<br/>  a: 1<br/>};</span><span id="7f2c" class="lf lg iq le b gy mp mm l mn mo">Object.freeze(obj);</span><span id="57f7" class="lf lg iq le b gy mp mm l mn mo">obj.a = 2;</span><span id="514c" class="lf lg iq le b gy mp mm l mn mo">console.log(obj.a);</span></pre><p id="f416" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe lb lc ld le b">obj.a</code>仍然是1。这是因为对象的属性值不能更改。如果我们启用了严格模式，将会产生一个<code class="fe lb lc ld le b">TypeError</code>。值得注意的是，作为对象的值仍然可以被修改。例如，如果我们有以下代码:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="c857" class="lf lg iq le b gy ml mm l mn mo">const obj = {<br/>  a: 1,<br/>  b: {<br/>    c: 2<br/>  }<br/>};</span><span id="2767" class="lf lg iq le b gy mp mm l mn mo">Object.freeze(obj);</span><span id="b033" class="lf lg iq le b gy mp mm l mn mo">obj.b.c = 3;</span><span id="8469" class="lf lg iq le b gy mp mm l mn mo">console.log(obj.b.c);</span></pre><p id="1ef1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe lb lc ld le b">obj.b.c</code>就是3，因为<code class="fe lb lc ld le b">Object.freeze</code>不会冻结嵌套对象内部的属性，除非它们被显式冻结。所以如果我们有:</p><pre class="md me mf mg gt mh le mi mj aw mk bi"><span id="82b2" class="lf lg iq le b gy ml mm l mn mo">const obj = {<br/>  a: 1,<br/>  b: {<br/>    c: 2<br/>  }<br/>};</span><span id="1fbe" class="lf lg iq le b gy mp mm l mn mo">Object.freeze(obj);<br/>Object.freeze(obj.b);</span><span id="e838" class="lf lg iq le b gy mp mm l mn mo">obj.b.c = 3;</span><span id="b889" class="lf lg iq le b gy mp mm l mn mo">console.log(obj.b.c);</span></pre><p id="375f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe lb lc ld le b">obj.b.c</code>就是2，因为我们冻结了<code class="fe lb lc ld le b">obj.b</code>，所以我们不能修改<code class="fe lb lc ld le b">obj.b</code>的值。</p><p id="3756" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Object</code>构造函数有更多的方法来从一个数组构造对象，该数组具有属性的键和值，还有从对象、属性名、属性符号中获取属性描述符的方法，获取对象的键，防止属性被添加或删除或修改它们的属性描述符。</p></div></div>    
</body>
</html>