<html>
<head>
<title>Building a game with TypeScript. Drawing Grid 2/5</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用TypeScript构建游戏。绘制网格2/5</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-game-with-typescript-drawing-grid-2-5-206555719490?source=collection_archive---------2-----------------------#2020-08-22">https://javascript.plainenglish.io/building-a-game-with-typescript-drawing-grid-2-5-206555719490?source=collection_archive---------2-----------------------#2020-08-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a747" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">教程<a class="ae ki" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">系列</a>中的第三章讲述了如何用TypeScript和本地浏览器API从头开始构建游戏</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/11071dbab5771bf388f253c425416bd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rB8Mbjhzm-VZ1mPaWbJc9A.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae ki" href="https://www.freepik.com/free-photos-vectors/background" rel="noopener ugc nofollow" target="_blank">Background photo created by freepik</a></figcaption></figure><p id="305f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你好，欢迎回来！这是我们讨论如何用TypeScript和本地浏览器API构建一个简单的回合制游戏的系列文章！第三章致力于为这个游戏建立一个网格，其他章节可以在这里找到:</p><ul class=""><li id="4eb1" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated"><a class="ae ki" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="39f5" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated"><a class="ae ki" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">第一章实体组件系统</a></li><li id="bd45" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第二章。游戏循环(<a class="ae ki" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">第一部分</a>，<a class="ae ki" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener">第二部分</a>)</li><li id="2942" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第三章。绘制网格(<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">第1部分</a>，第2部分<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">，第3部分</a>，<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第4部分</a>，<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第5部分</a>)</li><li id="dde6" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第四章。舰船(<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae ki" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="ffab" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第五章输入系统(<a class="ae ki" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae ki" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae ki" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="39cc" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第六章。寻路和移动(<a class="ae ki" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">第一部分</a>、<a class="ae ki" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">第二部分</a>、<a class="ae ki" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">第三部分</a>、<a class="ae ki" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">第四部分</a>、<a class="ae ki" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">第五部分</a>、<a class="ae ki" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">第六部分</a>、<a class="ae ki" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">第七部分</a>)</li><li id="dd68" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第七章。玛奇纳州</li><li id="0682" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第八章。攻击系统:生命和伤害</li><li id="6aa5" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第九章。比赛的输赢</li><li id="11c1" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第十章敌人AI</li></ul></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><p id="3d4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本章的<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">第一部分</a>中，我们成功地<em class="lu">绘制了</em>网格。Canvas API当时对我们帮助很大。然而，这个解决方案相当脏而且不灵活。我们简单地把所有的代码放到一个地方:<code class="fe lv lw lx ly b">Game</code>实体。如果我们继续走这条路，很快，我们的游戏脚本会变得非常大，很难维护。而且，我们上次没有写测试，让自己没有任何保险。在这篇文章中，我们将改进我们的代码，使其更易于维护和扩展。</p><p id="1111" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">除了代码质量之外，我们还必须考虑其他一些事情。在这一点上，我们所做的就是<em class="lu">画了一个网格的静态图像</em>。它没有任何功能。事实上，现在网格唯一动态的部分是它的大小和颜色。但是正如我们将在以后的章节中看到的，网格不仅仅是一个图像。这是游戏中至关重要的一部分，我们需要它来满足我们日益增长的需求。网格应该成为一个实体。</p><blockquote class="lz ma mb"><p id="d52f" class="jk jl lu jm b jn jo jp jq jr js jt ju mc jw jx jy md ka kb kc me ke kf kg kh ig bi translated">随意切换到<a class="ae ki" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe lv lw lx ly b">drawing-grid-1</code>分支。它包含了前几篇文章的工作成果，是这篇文章的一个很好的起点。</p></blockquote></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h1 id="acc4" class="mf mg in bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">目录</h1><ol class=""><li id="2538" class="kz la in jm b jn nd jr ne jv nf jz ng kd nh kh ni lf lg lh bi translated">网格实体</li><li id="980c" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ni lf lg lh bi translated">用网格测试游戏实体</li><li id="0806" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ni lf lg lh bi translated">引入节点实体</li><li id="fe05" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ni lf lg lh bi translated">编写我们的第一个组件</li><li id="8ed8" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ni lf lg lh bi translated">测试节点实体</li><li id="a903" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh ni lf lg lh bi translated">结论</li></ol></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h1 id="1f0b" class="mf mg in bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">网格实体</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nj"><img src="../Images/33d3936d015f07e26e5c3b41d0563d86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4b6nKNzFjGdt-n0TQprXjA.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae ki" href="https://www.freepik.com/free-photos-vectors/background'" rel="noopener ugc nofollow" target="_blank">Background vector created by pikisuperstar</a></figcaption></figure><p id="27fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将网格代码与游戏实体结合起来。虽然网格对游戏来说确实很重要，但这并不意味着它们必须生活在一起。是时候定义我们的第一个子实体了:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="fb40" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并为其添加一个桶文件:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c51f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在可以将这个新实体作为孩子添加到游戏中。同样，让我们通过使用一个公共getter使<code class="fe lv lw lx ly b">entities</code>成为私有字段来确保只有game拥有对其子节点的写访问权:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="37b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是我们要做的！游戏将唤醒并更新网格，就像我们在之前的帖子中设置的那样。</p></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h1 id="353c" class="mf mg in bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">用网格测试游戏</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nm"><img src="../Images/4bf4f45fe5ea20f5d1fdc2cf70031b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mTw5H6uOJMd7fiM_Ozpz-w.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae ki" href="https://www.freepik.com/free-photos-vectors/background" rel="noopener ugc nofollow" target="_blank">Background vector created by freepik</a></figcaption></figure><p id="5640" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们继续之前，让我们更新一下游戏的测试。当我们建立<code class="fe lv lw lx ly b">game.spec.ts</code>的时候，我们也创造了一堆虚假的实体:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="98f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">他们为我们提供了很好的服务，但现在我们可以更进一步。我们确切地知道<code class="fe lv lw lx ly b">Game</code>的子实体是什么:它是<code class="fe lv lw lx ly b">Grid</code>。我们不再需要一个<em class="lu">假</em>孩子了。这种方法允许我们验证两者:</p><ul class=""><li id="605f" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated">游戏和它的实体一起正常工作</li><li id="9e1d" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">它很适合<em class="lu">特别是</em>电网</li></ul><p id="6d36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我首先从规范中删除所有虚假的实体:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="55e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，我添加了一个新的测试来检查所有的孩子都被唤醒和更新。即使现在我们只有一个孩子，网格，将来我们可以在引入更多孩子时更新测试:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="c973" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该测试的工作方式与<em class="lu">假实体</em>测试的工作方式相似。首先，我窥探一下<code class="fe lv lw lx ly b">Grid</code>的<code class="fe lv lw lx ly b">Awake</code>和<code class="fe lv lw lx ly b">Update</code>方法。然后，我确保只有在分别执行了<code class="fe lv lw lx ly b">game.Awake</code>和<code class="fe lv lw lx ly b">game.Update</code>之后才调用它们:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><blockquote class="lz ma mb"><p id="c2a9" class="jk jl lu jm b jn jo jp jq jr js jt ju mc jw jx jy md ka kb kc me ke kf kg kh ig bi translated">注意，我没有访问网格实例的权限，因为它是由游戏创建和封装的。但是我可以依靠<code class="fe lv lw lx ly b">Grid.prototype</code>来访问<code class="fe lv lw lx ly b">Grid</code>方法，而不需要实际的实例。</p></blockquote><p id="9e03" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您运行<code class="fe lv lw lx ly b">npm start</code>，代码现在应该编译无误。如果运行<code class="fe lv lw lx ly b">npm t</code>，所有测试都应通过</p></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h1 id="38fb" class="mf mg in bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">引入节点</h1><p id="1d7a" class="pw-post-body-paragraph jk jl in jm b jn nd jp jq jr ne jt ju jv nn jx jy jz no kb kc kd np kf kg kh ig bi translated">我们为网格创建了一个专用实体。</p><p id="98bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将整个网格呈现为一个整体是一件简单的事情。不幸的是，这对我们来说还不够。出于不同的目的，我们必须跟踪网格中的各个矩形:突出显示它们并指示玩家可以将他们的船移动到哪里，存储附近节点的信息以使寻路成为可能，等等。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nq"><img src="../Images/cf3f497a7f9ec41ee96ef86add80a09d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sAlQrdMAwqW0BaM0U_AcUQ.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae ki" href="https://www.freepik.com/free-photos-vectors/business" rel="noopener ugc nofollow" target="_blank">Business vector created by fullvector</a></figcaption></figure><p id="0df8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了使这种跟踪成为可能，我们迈出了第一步:我们为网格创建了一个实体。现在我们应该为每个<code class="fe lv lw lx ly b">Grid</code>的<code class="fe lv lw lx ly b">Node</code>创建一个实体:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7d71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们不要忘记桶文件:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="b419" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像任何其他实体一样，它应该在游戏对象的层次结构中占据自己的位置。让它成为<code class="fe lv lw lx ly b">Grid</code>的孩子感觉很自然。然后，我们可以在<code class="fe lv lw lx ly b">Grid</code>中的所有节点上执行批量操作。</p><p id="d14f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将孩子添加到<code class="fe lv lw lx ly b">Grid</code>的过程与我们添加到<code class="fe lv lw lx ly b">Game</code>的过程相同。我定义了私有字段和公共getter:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0a64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">网格应该唤醒并更新所有节点:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><blockquote class="lz ma mb"><p id="c0a5" class="jk jl lu jm b jn jo jp jq jr js jt ju mc jw jx jy md ka kb kc me ke kf kg kh ig bi translated">注意，我们应该叫超级。清醒()和超级。Update()允许抽象实体完成其默认工作，并唤醒和更新组件。我们还没有，但我们将在未来的章节中添加一些。</p></blockquote><p id="e3ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太好了，但是我们如何<em class="lu">画出</em>节点呢？我们应该在<code class="fe lv lw lx ly b">Node</code>实体的Awake方法中添加绘图功能吗？我们<em class="lu">可以</em>，但这不是一个灵活的解决方案。</p><p id="02ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果有几种方法可以画出一个<code class="fe lv lw lx ly b">Node</code>呢？比方说，有些节点是圆形而不是矩形。或者也许我们根本不想画出一些节点，让它们看不见？为了实现这种灵活性，我们可以使用条件:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="3d38" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样，我们在<code class="fe lv lw lx ly b">Node</code> : <code class="fe lv lw lx ly b">drawRectNode</code>，<code class="fe lv lw lx ly b">drawCircleNode</code>中有了所有的绘图逻辑。</p><p id="fbaf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我们有一个更强大的工具:组件。我们可以定义不同的组件:<code class="fe lv lw lx ly b">RectangleDraw</code>、<code class="fe lv lw lx ly b">CircleDraw</code>，只附加必要的组件。或者，如果我们想跳过绘图，甚至不分配任何值。此外，我们可以实时地做到这一点！按照这种方法，我们将绘图逻辑从<code class="fe lv lw lx ly b">Node</code>的核心逻辑中分离出来。</p></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h1 id="70bc" class="mf mg in bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">编写我们的第一个组件</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nr"><img src="../Images/70e401b84b6907c645f8191a6b35b402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nU5xjQIpqv4hw2fabi-v-w.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae ki" href="https://www.freepik.com/free-photos-vectors/business" rel="noopener ugc nofollow" target="_blank">Business photo created by d3images</a></figcaption></figure><p id="6d47" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将从小处着手，向为我们处理绘图逻辑的节点添加一个<code class="fe lv lw lx ly b">Draw Component</code>。然而，我们保留选择的余地。如果我们需要不同的绘图组件，我们可以在不影响现有代码的情况下快速创建它们。</p><blockquote class="lz ma mb"><p id="c95b" class="jk jl lu jm b jn jo jp jq jr js jt ju mc jw jx jy md ka kb kc me ke kf kg kh ig bi translated">请注意，这种方法与可靠的“打开-关闭”原则配合得多么好:我们保持代码开放以供扩展。</p></blockquote><p id="ef84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">组件是符合<code class="fe lv lw lx ly b">IComponent</code>的任何类:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f23f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我定义了一个实现<code class="fe lv lw lx ly b">IComponent</code>的类。接口要求指定组件可以附加到哪个实体。在这种情况下，它是<code class="fe lv lw lx ly b">Node</code>实体。我们还必须按照<code class="fe lv lw lx ly b">IComponent</code>要求实施<code class="fe lv lw lx ly b">Awake</code>和<code class="fe lv lw lx ly b">Update</code>。</p><p id="e189" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要忘记添加和更新必要的桶文件:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><blockquote class="lz ma mb"><p id="b5b7" class="jk jl lu jm b jn jo jp jq jr js jt ju mc jw jx jy md ka kb kc me ke kf kg kh ig bi translated">注意，我为<em class="in">组件</em>定义了一个专用文件夹，甚至为<strong class="jm io">绘制</strong>组件定义了一个单独的文件夹。这个文件夹结构将贯穿整个系列。</p></blockquote><p id="bd27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">留给我们的就是将<code class="fe lv lw lx ly b">NodeDrawComponent</code>加到<code class="fe lv lw lx ly b">Node</code>上:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h1 id="2918" class="mf mg in bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">测试节点</h1><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ns"><img src="../Images/8d947ca4fc92f3738d0489b81abe3244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yIRxHa-POAu1NyeScCZpAQ.jpeg"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae ki" href="https://www.freepik.com/free-photos-vectors/watercolor" rel="noopener ugc nofollow" target="_blank">The watercolor vector created by milano83</a></figcaption></figure><p id="c6d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们结束这篇文章之前，让我添加一些测试。<code class="fe lv lw lx ly b">NodeDrawComponent</code>现在是空的，所以还没有什么可测试的。但是我们可以测试<code class="fe lv lw lx ly b">Node</code>。</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7648" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lv lw lx ly b">Node</code>现在的功能已经相当一般了。它所做的就是添加<code class="fe lv lw lx ly b">NodeDrawComponent</code>。请允许我更一般化一点，为所有组件创建一个测试套件，尽管我们现在只有一个:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a58c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用<code class="fe lv lw lx ly b">NodeDrawComponent</code>测试通信听起来应该很熟悉。我们不能访问组件的实例，但是我们可以窥探它的原型。然后，当实体被唤醒和更新时，我们使用spy来验证组件确实被唤醒和更新:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1e7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你用<code class="fe lv lw lx ly b">npm start</code>开始你的代码，它应该编译没有错误。如果您用<code class="fe lv lw lx ly b">npm t</code>运行测试，它们应该也能通过。</p><blockquote class="lz ma mb"><p id="5ff8" class="jk jl lu jm b jn jo jp jq jr js jt ju mc jw jx jy md ka kb kc me ke kf kg kh ig bi translated">你可以在<a class="ae ki" href="https://github.com/soloschenko-grigoriy/gamedev-patterns-ts" rel="noopener ugc nofollow" target="_blank">库</a>的<code class="fe lv lw lx ly b">drawing-grid-2</code>分支中找到这篇文章的完整源代码。</p></blockquote></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><h1 id="d1dd" class="mf mg in bd mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb nc bi translated">结论</h1><p id="473c" class="pw-post-body-paragraph jk jl in jm b jn nd jp jq jr ne jt ju jv nn jx jy jz no kb kc kd np kf kg kh ig bi translated">厉害！我们做了很多，但在屏幕上什么也没有改变:我们仍然只能看到网格的旧“脏”图。但是我们完成了很多:我们学习了如何在不创建实例的情况下测试类的功能，我们引入了两个新的实体:<code class="fe lv lw lx ly b">Grid</code>和<code class="fe lv lw lx ly b">Node</code>，将它们从<code class="fe lv lw lx ly b">Game</code>中分离出来，甚至建立了我们的第一个组件！</p><p id="8e4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">第三部</a>中，我们将与<code class="fe lv lw lx ly b">NodeDrawComponent</code>紧密合作，一劳永逸地摆脱<em class="lu">肮脏的</em>抽签。我们还会遇到一个新朋友，他会在这方面帮助我们(并且在未来继续帮助我们！):<code class="fe lv lw lx ly b">Vector2D</code>。</p><p id="24fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您有任何意见、建议、问题或任何其他反馈，请不要犹豫，给我发私信或在下面留下评论！感谢您的阅读，我们下次再见！</p></div><div class="ab cl ln lo hr lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ig ih ii ij ik"><p id="6756" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lu">这是系列教程“</em> <strong class="jm io"> <em class="lu">用TypeScript </em> </strong> <em class="lu">”中的第三章。其他章节可点击此处:</em></p><ul class=""><li id="fb9c" class="kz la in jm b jn jo jr js jv lb jz lc kd ld kh le lf lg lh bi translated"><a class="ae ki" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-d29b913858e" rel="noopener">简介</a></li><li id="c389" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated"><a class="ae ki" href="https://medium.com/@gregsolo/entity-component-system-in-action-with-typescript-f498ca82a08e" rel="noopener">第一章实体组件系统</a></li><li id="a7f7" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第二章。游戏循环(<a class="ae ki" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-with-typescript-game-loop-part-1-2-699919bb9b71" rel="noopener">第一部</a>，<a class="ae ki" href="https://medium.com/@gregsolo/gamedev-patterns-and-algorithms-in-action-with-typescript-game-loop-2-2-c0d57a8e5ec2" rel="noopener">第二部</a>)</li><li id="8710" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第三章。绘制网格(<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-1-5-aaf68797a0bb" rel="noopener">第1部分</a>，第2部分<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-3-5-1fb94211c4aa" rel="noopener">，第3部分</a>，<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-iii-drawing-grid-4-5-398af1dd638d" rel="noopener">第4部分</a>，<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-grid-5-5-49454917b3af" rel="noopener">第5部分</a>)</li><li id="b861" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第四章。舰船(<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-colors-and-layers-337b0e4d71f" rel="noopener">第一部分</a>、<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-team-and-fleet-f223d39e9248" rel="noopener">第二部分</a>、<a class="ae ki" href="https://medium.com/@gregsolo/building-a-game-with-typescript-drawing-ship-14e6c19caa38" rel="noopener">第三部分</a>、<a class="ae ki" href="https://gregsolo.medium.com/building-a-game-with-typescript-ship-and-locomotion-4f5969675993" rel="noopener">第四部分</a>)</li><li id="5ccc" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第五章输入系统(<a class="ae ki" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-1-3-46d0b3dd7662" rel="noopener">第一部分</a>、<a class="ae ki" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-2-3-cd419e36027c" rel="noopener">第二部分</a>、<a class="ae ki" href="https://gregsolo.medium.com/building-a-game-with-typescript-input-system-3-3-8492552579f1" rel="noopener">第三部分</a>)</li><li id="db43" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第六章。寻路和移动(<a class="ae ki" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-17-introduction" rel="noopener ugc nofollow" target="_blank">部分1 </a>、<a class="ae ki" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-27-highlighting-locomotion-range" rel="noopener ugc nofollow" target="_blank">部分2 </a>、<a class="ae ki" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-37-graph-and-priority-queue" rel="noopener ugc nofollow" target="_blank">部分3 </a>、<a class="ae ki" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-47-pathfinder" rel="noopener ugc nofollow" target="_blank">部分4 </a>、<a class="ae ki" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-57-finding-the-path" rel="noopener ugc nofollow" target="_blank">部分5 </a>、<a class="ae ki" href="https://blog.gregsolo.me/articles/building-a-game-with-typescript-pathfinding-and-movement-6-instant-locomotion" rel="noopener ugc nofollow" target="_blank">部分6 </a>、<a class="ae ki" href="https://blog.gregsolo.me/articles/pathfinding-and-movement-7-animated-locomotion" rel="noopener ugc nofollow" target="_blank">部分7 </a>)</li><li id="0a63" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第七章。玛奇纳州</li><li id="533d" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第八章。攻击系统:生命和伤害</li><li id="1317" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第九章。比赛的输赢</li><li id="e03c" class="kz la in jm b jn li jr lj jv lk jz ll kd lm kh le lf lg lh bi translated">第十章敌人AI</li></ul></div></div>    
</body>
</html>