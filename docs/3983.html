<html>
<head>
<title>Best of Modern JavaScript — Generator Best Practices and Regex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华——生成器最佳实践和正则表达式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-generator-best-practices-5cac2494ec1f?source=collection_archive---------8-----------------------#2020-11-07">https://javascript.plainenglish.io/best-of-modern-javascript-generator-best-practices-5cac2494ec1f?source=collection_archive---------8-----------------------#2020-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5279dd38e5395e2fa90efbc040f8a8b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dL5nW6s_PWxxdbpU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@gardiept?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gardie Design &amp; Social Media Marketing</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9e84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript生成器和新的regex特性。</p><h1 id="cc32" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">星号</h1><p id="d4c9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">用于生成器函数的星号有一个星号。</p><p id="c51b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">If必须在<code class="fe me mf mg mh b">function</code>关键字和函数名之间。</p><p id="3c00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它可以有任何间距。</p><p id="e64c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是通常，它有这样的格式:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="42c9" class="mq lc iq mh b gy mr ms l mt mu">function* gen() {<br/>  //..<br/>}</span></pre><h1 id="1ed1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">生成器函数声明和表达式</h1><p id="e492" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">生成器函数声明和表达式都是有效的。</p><p id="c7a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下代码来编写生成器函数声明:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9f24" class="mq lc iq mh b gy mr ms l mt mu">function* gen() {<br/>  //..<br/>}</span></pre><p id="29a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过将函数声明赋给变量来创建生成器表达式:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="35a0" class="mq lc iq mh b gy mr ms l mt mu">const gen = function* () {<br/>  //..<br/>}</span></pre><h1 id="8141" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">生成器方法定义</h1><p id="7a6b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过编写以下代码来添加生成器方法定义:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="833b" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  * gen(x, y) {<br/>    //...<br/>  }<br/>};</span></pre><p id="60a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在方法名前加了星号。</p><p id="ece1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是以下内容的简写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9a2b" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  gen: function*(x, y) {<br/>    //...<br/>  }<br/>};</span></pre><p id="05e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">生成器方法定义类似于getters和setters。</p><p id="775a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5310" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  get foo() {<br/>    //...<br/>  },<br/>  set foo(value) {<br/>    //...<br/>  }<br/>};</span></pre><p id="81f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像星号一样，<code class="fe me mf mg mh b">get</code>和<code class="fe me mf mg mh b">set</code>是<code class="fe me mf mg mh b">foo</code>方法的修饰符。</p><h1 id="4879" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">递归<code class="fe me mf mg mh b">yield</code></h1><p id="0cbe" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以给<code class="fe me mf mg mh b">yield</code>加一个星号，从一个生成器函数调用另一个生成器函数。</p><p id="1994" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="038a" class="mq lc iq mh b gy mr ms l mt mu">function* foo(x) {<br/>  //...<br/>  yield* foo(x - 1);<br/>  //..<br/>}</span></pre><p id="5d96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用关键字<code class="fe me mf mg mh b">yield*</code>递归调用<code class="fe me mf mg mh b">foo</code>。</p><h1 id="e891" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">Why Use the function*</code>发生器功能的关键字？</h1><p id="9b71" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">选择关键字<code class="fe me mf mg mh b">function*</code>用于生成器函数，因为关键字<code class="fe me mf mg mh b">generator</code>可能会被其他东西使用。</p><h1 id="d1f9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">yield</code></h1><p id="d036" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">yield</code>是严格模式下的保留字。</p><p id="9b3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以不能戴着用。</p><p id="84d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果ES6代码处于松散模式，那么关键字就变成了上下文关键字，只在生成器内部可用。</p><h1 id="9fd7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">新的正则表达式功能</h1><p id="a3f0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">新的regex特性包括<code class="fe me mf mg mh b">/y</code>标志，让我们将搜索的起点锚定到regex对象的<code class="fe me mf mg mh b">lastIndex</code>属性。</p><p id="698e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这类似于<code class="fe me mf mg mh b">^</code>锚，但是<code class="fe me mf mg mh b">^</code>的匹配总是从0开始。</p><p id="72e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着匹配对于使用<code class="fe me mf mg mh b">g</code>标志是有用的。</p><p id="4406" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用它多次匹配一个模式。</p><p id="8641" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">紧跟在它的前一个之后查找匹配也很有用。</p><p id="2dfe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以使用<code class="fe me mf mg mh b">regex.prototype.exec</code>方法从一个字符串中找到所有匹配。</p><p id="7ef9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ac77" class="mq lc iq mh b gy mr ms l mt mu">const REGEX = /foo/;</span><span id="0e8e" class="mq lc iq mh b gy mv ms l mt mu">REGEX.lastIndex = 8;<br/>const match = REGEX.exec('barfoobarfoo');<br/>console.log(match.index); <br/>console.log(REGEX.lastIndex);</span></pre><p id="65b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">index</code>将忽略正则表达式的<code class="fe me mf mg mh b">lastIndex</code>属性，但是如果我们添加<code class="fe me mf mg mh b">g</code>标志:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="842f" class="mq lc iq mh b gy mr ms l mt mu">const REGEX = /foo/g;</span><span id="4ac4" class="mq lc iq mh b gy mv ms l mt mu">REGEX.lastIndex = 8;<br/>const match = REGEX.exec('barfoobarfoo');<br/>console.log(match.index); <br/>console.log(REGEX.lastIndex);</span></pre><p id="f53f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模式搜索从<code class="fe me mf mg mh b">lastIndex</code>索引值开始。</p><p id="eef7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">y</code>被设置:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5305" class="mq lc iq mh b gy mr ms l mt mu">const REGEX = /foo/y;</span><span id="d097" class="mq lc iq mh b gy mv ms l mt mu">REGEX.lastIndex = 9;<br/>const match = REGEX.exec('barfoobarfoo');<br/>console.log(match.index);<br/>console.log(REGEX.lastIndex);</span></pre><p id="c6b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将<code class="fe me mf mg mh b">lastIndex</code>设置为9，那么我们将得到与该索引匹配的<code class="fe me mf mg mh b">'foo'</code>。</p><p id="855b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">索引必须精确到比赛的起点，以便<code class="fe me mf mg mh b">y</code>旗拾取比赛。</p><p id="9b65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">lastIndex</code>找到匹配后会更新到12。</p><p id="cd6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一起设置<code class="fe me mf mg mh b">/g</code>和<code class="fe me mf mg mh b">/y</code>与设置<code class="fe me mf mg mh b">y</code>相同。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/f399e3fa84a4d70e5ebead63b9ad353e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H1FYjmv6DPfBdloU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@candice_picard?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Candice Picard</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8e84" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="98df" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">生成器代码风格可能会有所不同。</p><p id="fd22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，JavaScript regex对象现在可以使用<code class="fe me mf mg mh b">y</code>标志来查找标志后的精确匹配。</p><p id="6297" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>