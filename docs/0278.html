<html>
<head>
<title>Angular: Observables, async/await, and Promises, oh my!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular: Observables，async/await，and Promises，oh my！</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-observables-async-await-and-promises-oh-my-c6220c074878?source=collection_archive---------1-----------------------#2019-09-11">https://javascript.plainenglish.io/angular-observables-async-await-and-promises-oh-my-c6220c074878?source=collection_archive---------1-----------------------#2019-09-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/218fb0bb83b9344f3940d8d8264b7407.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*guZN1o0QmlfFOI8Y9QNiQw.jpeg"/></div></div></figure><p id="a91f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Angular来自Angular2之前的Angular.js世界，Angular(在撰写本文时已经是第5版)坚持使用<a class="ae kt" href="https://en.wikipedia.org/wiki/Observer_pattern" rel="noopener ugc nofollow" target="_blank">观察者/可观察设计模式</a>，看起来令人生畏。无论你往哪里看，事物似乎都返回一个<a class="ae kt" href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html" rel="noopener ugc nofollow" target="_blank"> RxJS可观察</a>而不是我们都知道的美好熟悉的承诺(甚至可能是爱？).当尝试学习Angular时，这非常令人沮丧，我的本能反应是使用Observables提供的非常方便的toPromise()方法，并采取简单的方法，但我说服自己学习它，因为我确信这一切都是有原因的。现在我想我终于明白了，我想分享我的发现。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="d5d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以让我们从基础开始——为什么要使用可观察的，而不是完全依赖承诺？嗯，这个很简单——你可以在stackoverflow 上阅读<a class="ae kt" href="https://stackoverflow.com/questions/37364973/angular-promise-vs-observable" rel="noopener ugc nofollow" target="_blank">这个更详细的答案，但是它的要点是，Observables允许你取消一个正在进行的任务，它们允许你返回多个东西，并且允许你有多个订阅者订阅一个单独的Observable实例。它还简化了重试。</a></p><p id="e10c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设您有以下基于承诺的代码:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="5ce2" class="lk ll in lg b gy lm ln l lo lp">doAsyncPromiseThing()<br/>  .then(() =&gt; console.log("I'm done!"))<br/>  .catch(() =&gt; console.log("Error'd out"));</span></pre><p id="5b4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在“可观察的土地”中，这实际上并不复杂:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="956d" class="lk ll in lg b gy lm ln l lo lp">doAsyncObservableThing()<br/>  .subscribe(<br/>     () =&gt; console.log("I'm done!"),<br/>     () =&gt; console.log("Error'd out")<br/>  )</span></pre><h1 id="6904" class="lq ll in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">你自己的第一次观察</h1><p id="4be0" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">我读过的很多指南都是直接用observables进行HTTP请求，因为这实际上是你最常使用它们的地方，但是我想在这篇文章中做一些不同的事情，了解Observables的本质，而不是试图马上使它变得实用。那么，我们如何使用Observable以异步方式简单地返回值呢？有两种方法——我们可以使用它的构造函数，或者使用create方法，这两种方法做同样的事情(它们是彼此的别名)。</p><p id="e1b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">顺便说一下，本文的其余部分将基于这里的一些helper方法，因此对于第一个示例，我将发布完整的组件源代码，以便您可以更容易地理解Plnkr之类的内容。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="63eb" class="lk ll in lg b gy lm ln l lo lp">//our root app component<br/>import {Component, NgModule} from '@angular/core'<br/>import {BrowserModule} from '@angular/platform-browser'<br/>import {Observable} from 'rxjs/Observable';</span><span id="16a7" class="lk ll in lg b gy ms ln l lo lp">@Component({<br/>  selector: 'my-app',<br/>  template: `<br/>    &lt;div&gt;<br/>      &lt;h2&gt;Observable Example&lt;/h2&gt;<br/>      &lt;ul&gt;<br/>        &lt;li *ngFor="let message of messages"&gt;{{message}}&lt;/li&gt;<br/>      &lt;/ul&gt;<br/>    &lt;/div&gt;<br/>  `,<br/>})<br/>export class App {<br/>  constructor() {<br/>    this.initialTime = Date.now();<br/>    this.messages = [];<br/>    this.log = (m) =&gt; {<br/>      const dateDifference = Date.now() - this.initialTime;<br/>      this.messages.push(`${dateDifference}: ${m}`);<br/>    };<br/>    this.doAsyncObservableThing = new Observable(observer =&gt; {<br/>      observer.next('Hello, observable world!');<br/>      observer.complete();<br/>    });<br/>    <br/>    this.doAsyncObservableThing.subscribe(<br/>      this.log<br/>    );<br/>  }<br/>}</span><span id="9fa1" class="lk ll in lg b gy ms ln l lo lp">@NgModule({<br/>  imports: [ BrowserModule ],<br/>  declarations: [ App ],<br/>  bootstrap: [ App ]<br/>})<br/>export class AppModule {}</span></pre><p id="707d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以当你运行这个程序时，你应该会看到“你好，可观测的世界！”因为可观察的事物会立即完成。请注意，我的助手“log”方法将应用程序加载后的微秒数添加到每条消息中，这样我们就可以对下一个例子更感兴趣:需要一些时间才能完成的事情。在我们到达那里之前，请注意我们的观察者有一个下一个完整的方法，我们在上面的例子中使用。虽然很诱人的看法”。subscribe()"类似于"。然后()”的一个承诺，这是远离真理的。事实上，next()可以被多次调用，因为一个可观察对象可以返回多个结果。其实有<strong class="jx io"> <em class="mt">无限和有限的</em> </strong>。顾名思义，有限的可观测量返回固定数量的结果，而无限的可观测量可以永远继续下去。</p><p id="cd74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我还想在这里补充一点，对于这些常见任务中的许多，有非常简单的简化方法，就像我们刚刚在上面所做的那样——例如，不用像我在那里所做的那样定义可观察对象，人们可以简单地做:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0589" class="lk ll in lg b gy lm ln l lo lp">this.doAsyncObservableThing = Observable.of('Hello, observable world!');</span></pre><p id="4ebe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它做的事情和上面完全一样，而且简单得多。这类似于Angular.js世界中的$q.when('Hello ')。请注意，您需要将以下导入添加到文件的顶部，以便在Angular中访问这些帮助器:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="83ff" class="lk ll in lg b gy lm ln l lo lp">import 'rxjs/add/observable/of';</span></pre><p id="e04d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里要注意的另一个有趣的事情是<a class="ae kt" href="https://stackoverflow.com/questions/38008334/angular-rxjs-when-should-i-unsubscribe-from-subscription" rel="noopener ugc nofollow" target="_blank">你不需要退订有限的可观测量</a>——RxJS会帮你处理好的。如果您尝试以下操作，看看会发生什么:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7d7f" class="lk ll in lg b gy lm ln l lo lp">this.doAsyncObservableThing = new Observable(observer =&gt; {<br/>  observer.next('Started');<br/>  setTimeout(() =&gt; {<br/>    observer.next('Hello, observable world!');<br/>  }, 1000);<br/>  setTimeout(() =&gt; {<br/>    observer.next('Done');<br/>    observer.complete();<br/>  }, 2000);<br/>});</span></pre><p id="132d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您将看到以下内容:</p><ul class=""><li id="5097" class="mu mv in jx b jy jz kc kd kg mw kk mx ko my ks mz na nb nc bi translated">0:已开始</li><li id="8fd7" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">1001:你好，可观测的世界！</li><li id="33d1" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">2001年:完成</li></ul><p id="ebe8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，根据具体情况，您可能会更好地使用类似于<a class="ae kt" href="https://www.learnrxjs.io/operators/utility/delay.html" rel="noopener ugc nofollow" target="_blank"> delay() </a>的东西，而不是setTimeout来为您的可观测量计时；我只是在这里使用setTimeout来说明一个观点。</p><p id="d44f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，因为我们仍然使用subscribe方法，所以我们将保持订阅状态，并在每次我们期望的时候调用我们的log函数，但是我们没有办法知道可观察对象何时完全完成，即使这是一个有限的可观察对象，我们在这里调用“observer.complete()”方法。因此，为了纠正这一点，让我们稍微修改一下我们的订阅:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f98d" class="lk ll in lg b gy lm ln l lo lp">this.doAsyncObservableThing = new Observable(observer =&gt; {<br/>  observer.next('Started');<br/>  setTimeout(() =&gt; {<br/>    observer.next('Hello, observable world!');<br/>  }, 1000);<br/>  setTimeout(() =&gt; {<br/>    observer.complete();<br/>  }, 2000);<br/>});<br/>    <br/>this.doAsyncObservableThing.forEach(<br/>  this.log<br/>).then(() =&gt; {<br/>  this.log('Done');<br/>});</span></pre><p id="c6b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，我将subscribe()方法更改为forEach()。forEach()方法返回…一个承诺！因此，我们可以简单地对forEach()的结果执行一个. then()，当可观察对象完全完成时，就会调用forEach()。经验法则是，当你期望某件事情发生一次并完成时，你可能应该使用subscribe()，如果你期望多个结果，你可能应该使用forEach()。</p><h1 id="fa0a" class="lq ll in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">链接可观测量</h1><p id="5a7d" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">当我开始使用Observable时，最让我头疼的事情之一是如何将它们链接在一起——具体来说，我有一个场景，其中我有两个需要顺序发生的HTTP请求，中间有一些结果处理。</p><p id="67fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">简单的解决方法是在订阅中简单地订阅:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="bf89" class="lk ll in lg b gy lm ln l lo lp">this.doAsyncObservableThing = new Observable(observer =&gt; {<br/>  setTimeout(() =&gt; {<br/>    observer.next('Hello, observable world!');<br/>    observer.complete();<br/>  }, 1000);<br/>});<br/>  <br/>this.doAsyncObservableThing.subscribe((val) =&gt; {<br/>  this.log(val);<br/>  this.doAsyncObservableThing.subscribe((val) =&gt; {<br/>    this.log(val);<br/>  });<br/>});</span></pre><p id="11fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，上述内容将会起作用，您将会看到以下内容:</p><ul class=""><li id="4d31" class="mu mv in jx b jy jz kc kd kg mw kk mx ko my ks mz na nb nc bi translated">1001:你好，可观测的世界！</li><li id="4247" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">2001年:你好，可观测的世界！</li></ul><p id="b5af" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，代码非常难看，任何稍微复杂一点的东西都会很快变得不可维护。那么我们能做什么呢？另一个简单的解决方案是对可观测量使用toPromise()方法，并以这种方式将它们链接在一起，但这也是一种简单的方法，并没有真正考虑可观测量。那怎么办呢？你可以做几件事，但在此之前，重要的是要明白<strong class="jx io">与承诺不同，你不能像链接then()的</strong>那样一直链接subscribes()。相反，有一些解决方案取决于你在寻找什么。</p><h1 id="26db" class="lq ll in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">立即开始所有任务，逐个获得结果(合并)</h1><p id="1956" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">首先，我们尝试使用import 'rxjs/add/operator/merge '导入merge；</p><p id="db35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来让我们试试</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="fcd3" class="lk ll in lg b gy lm ln l lo lp">this.doAsyncObservableThing('First')<br/>.merge(this.doAsyncObservableThing('Second'))<br/>.subscribe((v) =&gt; {<br/>  this.log(v);<br/>});</span></pre><p id="bed8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的结果看起来像这样:</p><ul class=""><li id="7914" class="mu mv in jx b jy jz kc kd kg mw kk mx ko my ks mz na nb nc bi translated">1002:第一</li><li id="8128" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">1002:第二</li></ul><p id="0f33" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本实验的关键是subscribe()中的回调被调用两次，一次用于“第一次”,一次用于“第二次”,但是时间间隔是从同一时间开始的——计时确认两次都在一秒钟后完成。</p><h1 id="3eba" class="lq ll in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">序列中的可观察值，使用异步/等待</h1><p id="915c" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">现在，下一个将使用toPromise()，因为我还没有找到更好的方法来解决这个问题，但是它使用得很少，并且仍然是我所发现的最干净的方法来完成我们对嵌套的subscribe()所做的事情，而不实际嵌套它们，那就是使用async和await关键字。首先，我们必须将我们的代码移到NgOnInit方法中，因为构造函数不能是异步的，这就是我们到目前为止的代码；接下来，让我们简单谈谈async和await关键字。</p><p id="950e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Async是一个关键字，表示允许一个方法使用await关键字，并且它返回一个承诺(您必须确保指定一个与承诺兼容的返回值，例如承诺<yourresult>)。await关键字挂起异步函数的执行，直到承诺被解析或拒绝—它必须始终跟有一个计算结果为承诺的表达式。让我们来看看实际情况:</yourresult></p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8d62" class="lk ll in lg b gy lm ln l lo lp">this.log(await this.doAsyncObservableThing('First').toPromise());<br/>this.log(await this.doAsyncObservableThing('Second').toPromise());</span></pre><p id="b848" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，对this.log()的调用将被挂起，直到可以对涉及await的表达式求值，这只是在承诺解析之后。这意味着我们的结果看起来像这样:</p><ul class=""><li id="0466" class="mu mv in jx b jy jz kc kd kg mw kk mx ko my ks mz na nb nc bi translated">1005:第一</li><li id="0c3e" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">2009:第二</li></ul><p id="08f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们预期的时间内，第二个可观察到的现象直到第一个结束才开始。</p><h1 id="616f" class="lq ll in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">怪癖</h1><h1 id="5b2a" class="lq ll in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">route.queryParams不能与await一起使用</h1><p id="89f6" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">当您回读当前路线中的查询参数时，必须使用observable:route . query params；这里是官方文件。然而，对该可观察对象的toPromise()执行await不起作用——您的执行将在该点停止，并且不会继续。我花了比我愿意承认的更长的时间才弄明白这一点，但事实证明queryParams是一个无限可观察的例子——订阅它将导致您的订阅在每次查询参数改变时被调用，而不是只在那一刻获得当前的查询参数。这意味着observer.complete()永远不会被其中的内部机制调用，这意味着对它的await操作永远不会完成。如果您只想获得一次查询参数，这里的技巧是导入take或first运算符，以便只获得第一个结果(执行时的结果)，如下所示:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2658" class="lk ll in lg b gy lm ln l lo lp">import 'rxjs/add/operator/take';<br/>// ...<br/>const queryParams = await this.route.queryParamMap.take(1).toPromise();<br/>// access queryParams as needed</span></pre><p id="9cdb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读，希望这篇文章对你有所帮助！如果你想看上面的代码运行，看看<a class="ae kt" href="http://embed.plnkr.co/FpBcaV/?show=preview,src%2Fapp.ts" rel="noopener ugc nofollow" target="_blank">这个plnkr </a>。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><h1 id="3092" class="lq ll in bd lr ls ni lu lv lw nj ly lz ma nk mc md me nl mg mh mi nm mk ml mm bi translated">进一步阅读</h1><p id="d69d" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">以下是学习观察的一些其他主题，并推荐进一步阅读:</p><ul class=""><li id="17ec" class="mu mv in jx b jy jz kc kd kg mw kk mx ko my ks mz na nb nc bi translated">取消可观测量</li><li id="6a22" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">取消订阅观察</li><li id="499c" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">处理错误和捕捉异常</li><li id="81ca" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">编写包含可观察性的单元测试</li><li id="8f4f" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated">使用<a class="ae kt" href="https://blog.hackages.io/rxjs-5-5-piping-all-the-things-9d469d1b3f44" rel="noopener ugc nofollow" target="_blank">管道()对可观察的结果应用map()、reduce()和filter() </a></li><li id="9c2f" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated"><a class="ae kt" href="https://blog.thoughtram.io/angular/2016/06/16/cold-vs-hot-observables.html" rel="noopener ugc nofollow" target="_blank">“冷”和“热”可观测量的概念</a>(例如，只有在有订户时才开始做事情的可观测量与有订户或没有订户都立即做事情的可观测量)</li><li id="ae83" class="mu mv in jx b jy nd kc ne kg nf kk ng ko nh ks mz na nb nc bi translated"><a class="ae kt" href="https://www.learnrxjs.io/operators/filtering/distinctuntilchanged.html" rel="noopener ugc nofollow" target="_blank"> distinctUntilChanged() </a>和<a class="ae kt" href="https://www.learnrxjs.io/operators/filtering/debouncetime.html" rel="noopener ugc nofollow" target="_blank">去抖时间()</a></li></ul><p id="50ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mt">注:本文原载于我的旧博客2018/01/09，移至此处。</em></p></div></div>    
</body>
</html>