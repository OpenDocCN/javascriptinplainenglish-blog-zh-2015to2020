<html>
<head>
<title>How To RxJS — Creational Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何RxJS创作基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-rxjs-creational-basics-70318c5eca38?source=collection_archive---------7-----------------------#2020-04-04">https://javascript.plainenglish.io/how-to-rxjs-creational-basics-70318c5eca38?source=collection_archive---------7-----------------------#2020-04-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="d1c3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">RxJS可观察的创作，像一个专业</p><p id="cbce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我关于RxJS系列的第3部分，你可以在下面的链接中找到我的其他文章:</p><ul class=""><li id="bd1a" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated"><a class="ae kr" href="https://medium.com/javascript-in-plain-english/how-to-rxjs-the-basics-d5a5905497e0" rel="noopener">如何学习RxJS —基础知识</a></li><li id="167f" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><a class="ae kr" href="https://medium.com/javascript-in-plain-english/how-to-rxjs-hot-vs-cold-3b430c4b7690" rel="noopener"> How to RxJS — How vs冷</a></li><li id="7d72" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><strong class="jm io">如何RxJS —创作基础</strong></li></ul><p id="2f37" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本系列的前一部分，我写了热可观测量和冷可观测量的区别。RxJS的一个至关重要的部分，如果你不知道它们是什么，我强烈建议你在前进之前阅读一下。我在帮助Rx时发现了很多错误，因为他们不知道基本知识。</p><p id="d43b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我们将介绍常用的创建操作符。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div class="gh gi kx"><img src="../Images/4a26c45abe0b7aec249ce4d1522c40bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*Q_UQsvqaX4XRxYmkeS7ztA.jpeg"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Photo by <a class="ae kr" href="https://unsplash.com/@nikhilmitra?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Nikhil Mitra</a> on <a class="ae kr" href="https://unsplash.com/s/photos/create?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b977" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将展示其中一些运算符的大理石图，然后举例说明用法。</p><h1 id="7b63" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">“从”运算符</h1><p id="1e66" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">第一个被广泛使用的操作符是<code class="fe mm mn mo mp b">from</code>。让我们参考RxJS文档中对该操作符的描述:</p><blockquote class="mq mr ms"><p id="1767" class="jk jl mt jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">几乎可以将任何东西转化为可观察的。</p></blockquote><p id="8f04" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">说实话，就是这么简单。这个操作符可以从数组、类数组对象、可迭代对象、承诺或类可观察对象中创建一个可观察对象。</p><p id="a479" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，值得一提的是，在数组、类数组和可迭代对象的情况下，<strong class="jm io">它将一个接一个地发出该对象内部的项目</strong>。参见文档中的大理石图。</p><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/967148a8a86e16dd3e463ed038d12735.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gM3bcl6zlEPvnTBC3rBUxg.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Image from <a class="ae kr" href="https://rxjs-dev.firebaseapp.com/api/index/function/from" rel="noopener ugc nofollow" target="_blank">RxJS’s documentation</a></figcaption></figure><p id="a2b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在Angular应用程序中，该操作符最常见的用法是从承诺中创建可观察值。npm内部有几个依赖于承诺的库，因为承诺是ES2015规范的一部分，而可观察的不是。然而，一个有角度的应用程序严重依赖于可观测量，没有它们你也可以生活，但是那就像一只手被束缚着编码一样。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Example to create an Observable with the ‘from’ operator</figcaption></figure><p id="047b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我写了两个例子，第一个是更简单的例子，你有一个库，里面有类型定义。在第二个例子中，您可以看到如何告诉“from”操作符由库返回的承诺的类型。当然，你可以只返回一个<code class="fe mm mn mo mp b">any</code>类型，但是你应该避免在任何情况下使用<code class="fe mm mn mo mp b">any</code>。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><h1 id="13d5" class="lj lk in bd ll lm nl lo lp lq nm ls lt lu nn lw lx ly no ma mb mc np me mf mg bi translated">“of”运算符</h1><p id="aa95" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">这是一个简单的创建操作符，非常类似于from。我们再来看看描述。</p><blockquote class="mq mr ms"><p id="d781" class="jk jl mt jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">每个参数都成为下一个通知。</p></blockquote><figure class="ky kz la lb gt lc gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/93f722589f93d61af419ddf9781e626b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fK6PW-7y2vo9pkOcwBgp9w.png"/></div></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Image from <a class="ae kr" href="https://rxjs-dev.firebaseapp.com/api/index/function/of" rel="noopener ugc nofollow" target="_blank">RxJS’s documentation</a></figcaption></figure><p id="8a75" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这么简单。你给这个操作符的每个参数都将成为下一个通知。与“from”运算符的基本区别在于，“of”不会展平它的任何参数。如果你给它一个数组作为输入，那么它将发出数组本身，而不是数组内部的元素。</p><p id="b901" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在角度应用程序和任何应用程序中，该运算符用于创建默认可观察值或后备可观察值。例如，您可以在一个简单的错误处理程序中使用它来返回一个包含默认值或回退值的回退可观察值，这样其他管道操作符就不会失败。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><h1 id="2eb1" class="lj lk in bd ll lm nl lo lp lq nm ls lt lu nn lw lx ly no ma mb mc np me mf mg bi translated">“fromEvent”和“fromEventPattern”运算符</h1><p id="bda8" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">我们列表中的下两个操作符是<code class="fe mm mn mo mp b">fromEvent</code>和<code class="fe mm mn mo mp b">fromEventPattern</code>操作符。我将它们放在一起讨论，因为它们用于相同的事情，并且<em class="mt"> fromEvent </em>可以被看作是<em class="mt"> fromEventPattern </em>操作符的简写。</p><p id="2ad2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事不宜迟，我们来看看这些操作符的描述。</p><p id="276b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">‘来自事件’</strong></p><blockquote class="mq mr ms"><p id="0722" class="jk jl mt jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">从DOM事件或Node.js EventEmitter事件或其他事件中创建一个可观察对象。</p></blockquote><p id="c973" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">顾名思义，这些操作符正在从目标对象上发生的一系列事件中创建一个可观察的流。</p><p id="a9e3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mm mn mo mp b">fromEvent</code>可以监听以下事件目标:</p><ul class=""><li id="2da7" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated"><strong class="jm io"> DOM EventTarget </strong> <br/>这是一个带有<em class="mt"> addEventListener </em>和<em class="mt"> removeEventListener </em>方法的对象。这些方法的可选第三个参数也可以作为来自事件的<em class="mt">的第三个参数</em></li><li id="956a" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><strong class="jm io">Node . js Event emitter<br/></strong>这是Node的事件目标对象。它是一个具有<em class="mt"> addListener </em>和<em class="mt"> removeListener </em>方法的对象。</li><li id="3837" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><strong class="jm io"> JQuery风格的事件目标<br/> </strong>一个带有<em class="mt"> on </em>和<em class="mt"> off </em>方法的对象</li><li id="9d63" class="ki kj in jm b jn ks jr kt jv ku jz kv kd kw kh kn ko kp kq bi translated"><strong class="jm io"> DOM NodeList或DOM HtmlCollection <br/> </strong>在这种情况下，尽管它们不是直接的EventTargets，但RxJS通过遍历其所有元素并订阅每个元素上的给定事件来处理它们。</li></ul><p id="6a55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们来看看对来自事件模式操作符<em class="mt">的描述。</em></p><blockquote class="mq mr ms"><p id="c9fb" class="jk jl mt jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">从任意API创建一个用于注册事件处理程序的可观察对象。</p></blockquote><p id="7a72" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如您所见，如果您遇到一个不能由<em class="mt"> fromEvent </em>操作符处理的事件目标对象，您可以使用它。它有两个重要的参数，即<em class="mt"> addHandler </em>和<em class="mt"> removeHandler </em>函数。在这些步骤中，您应该将<em class="mt">事件处理程序</em>添加到<em class="mt">事件目标</em>中，并将其移除。如果你得到某种令牌，当添加一个句柄时，你可以在<em class="mt"> addHandler </em>函数中返回它，这个返回值将作为第二个参数给<em class="mt"> removeHandler </em>。</p><p id="f31e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在Angular应用程序中，我很少使用这些操作符，因为您更愿意通过事件绑定来监听元素上的事件。但是，在创建低级的自定义组件或指令时，这些操作符可能会有一些有用的含义。我在一个处理拖放事件的组件中使用了它，我必须将这些事件与其他流结合起来。</p><h1 id="0735" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">“空”常数</h1><p id="e8d8" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">这不是一个创造性的操作符，但在它被废弃之前是这样的。虽然它现在不是一个操作符，但是值得一提，因为这个常量有一些基本的用例。</p><blockquote class="mq mr ms"><p id="1c38" class="jk jl mt jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">只是发出“完成”，没有别的。</p></blockquote><p id="f331" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如描述和它的名字所暗示的，这是一个空的可观察对象，它将在订阅后立即完成。</p><p id="b9f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当您必须返回基于表达式的默认可观察值时，空常量通常用作后备。</p><p id="1c9b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在Angular应用程序中，这可以用来将条件副作用包装在一个可观察对象中。让我们假设你正在写一个旧货在线商店，你有一个功能，如果有人正在购买一件物品，你需要通知卖家，如果他/她配置了广告这样做。</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Example of using the EMPTY constant</figcaption></figure><p id="e3b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，如果有人在调用BuyerService的buy方法，这个通知副作用就会得到处理，调用者根本不需要知道这件事。当整个过程完成后，将会有下一个，紧接着是一个关于可观测的完整通知。我们是否必须通知卖方并不重要。</p><h1 id="0800" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">“延迟”运算符</h1><p id="4e9c" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">本文中我想提到的最后一个操作符是<code class="fe mm mn mo mp b">defer</code>。我们再看看文件。</p><blockquote class="mq mr ms"><p id="b50b" class="jk jl mt jm b jn jo jp jq jr js jt ju mu jw jx jy mv ka kb kc mw ke kf kg kh ig bi translated">延迟创建可观察对象，即仅当它被订阅时创建。</p></blockquote><p id="316c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如描述所说，我们可以使用这个运算符来创建一个可观察的懒懒。例如，当你在做承诺的时候，它会很有用。正如我们在上一篇文章中所说的，承诺不是懒惰的，无论何时你创建一个承诺，它都会运行，即使没有任何<code class="fe mm mn mo mp b">then</code>调用它。“延期”操作人员前来救援:</p><figure class="ky kz la lb gt lc"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="lf lg gj gh gi lh li bd b be z dk">Using the defer operator</figcaption></figure><p id="152c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，你正在调用“callPromise”方法，那么“from”中的承诺将总是被创建，因此将总是运行。然而，在“lazilyCallPromise”方法中，只有当您订阅了defer的输出可观察值时，才会创建承诺。</p><p id="e498" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就好像我们在订阅时作为生产者创造了承诺一样:</p><pre class="ky kz la lb gt nq mp nr ns aw nt bi"><span id="de0d" class="nu lk in mp b gy nv nw l nx ny"><em class="mt">new Observable(</em>observer<em class="mt"> =&gt; {</em></span><span id="a39e" class="nu lk in mp b gy nz nw l nx ny"><em class="mt">someLibrary.callPromise().then(</em>result<em class="mt"> =&gt; observer.next(result));</em></span><span id="ae68" class="nu lk in mp b gy nz nw l nx ny"><em class="mt">});</em></span></pre><h1 id="832b" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">摘要</h1><p id="07ee" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">在本文中，我们讨论了基本的创建操作符。我还试图给出关于它们用法的简明例子。希望对你们有些人有帮助。</p><p id="f1de" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请随时留下关于我的故事的任何建议或评论。我也乐于接受新的事物来改进或学习。此外，我欢迎任何关于我的未来故事的建议，任何与web开发、JavaScript或Angular相关的主题。</p><h2 id="9c13" class="nu lk in bd ll oa ob dn lp oc od dp lt jv oe of lx jz og oh mb kd oi oj mf ok bi translated"><strong class="ak">用简单英语写的JavaScript的一个注释:</strong></h2><p id="31f2" class="pw-post-body-paragraph jk jl in jm b jn mh jp jq jr mi jt ju jv mj jx jy jz mk kb kc kd ml kf kg kh ig bi translated">我们总是有兴趣帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，请用你的Medium用户名发邮件到<a class="ae kr" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">submissions@javascriptinplainenglish.com</a>给我们，我们会把你添加为作者。</p></div></div>    
</body>
</html>