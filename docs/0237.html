<html>
<head>
<title>Build your own Minesweeper game with Vue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Vue构建你自己的扫雷游戏</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/minesweeper-rebuild-with-vue-vuex-and-vuetify-ab1921e5258e?source=collection_archive---------2-----------------------#2019-09-02">https://javascript.plainenglish.io/minesweeper-rebuild-with-vue-vuex-and-vuetify-ab1921e5258e?source=collection_archive---------2-----------------------#2019-09-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6702" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用Vue、Vuex和Vuetify构建经典游戏的克隆版！</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b49c8be4befa1590788b7bf2004cb1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w7PgHxpS02-ilb6RsvpGvA.png"/></div></div></figure><p id="c6e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">编程的世界，尤其是前端工程今天似乎被框架的使用激活了。当然，目标是提高工作效率和时间效率。在过去的几个月里，我一直在做的一个框架是<a class="ae lk" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue </a>。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="2f38" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated"><strong class="ak">简介</strong></h1><p id="be36" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">为了提高我的编程知识，我决定在<a class="ae lk" href="https://vuejsexamples.com/" rel="noopener ugc nofollow" target="_blank">这里</a>搜索一些Vue项目的例子。然后，我发现了一个吸引人的项目要克隆，它就是扫雷。</p><p id="49f9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，在这篇文章中，我将尝试显示和建立由Vue CLI，Vuex和Vuetify支持的扫雷应用程序。不是游戏的每一个细节，但我希望这一个能启发你。</p></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="11bb" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">内容</h1><ol class=""><li id="b139" class="mp mq in kq b kr mk ku ml kx mr lb ms lf mt lj mu mv mw mx bi translated">扫雷怎么玩？</li><li id="9314" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">为什么是Vuex？</li><li id="8884" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">为什么要Vuetify？</li><li id="7472" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">设置应用程序</li><li id="c90c" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">添加Vuex</li><li id="70eb" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">添加Vuetify</li><li id="bfd1" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">应用程序的结构</li><li id="9de1" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">设置主网格组件</li><li id="7581" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">设置主网格存储模块</li><li id="c3f5" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">主网格:setPattern</li><li id="601f" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">主网格:getPattern</li><li id="83ec" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">主网格:隐藏和显示单元格的数据</li><li id="d32f" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">主网格:洪水填充算法</li><li id="6a1e" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">主网格:标记单元格</li><li id="b022" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">设置定时器组件和存储模块</li><li id="dd47" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">定时器:设置定时器</li><li id="13af" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">计时器:getTimer</li></ol></div><div class="ab cl ll lm hr ln" role="separator"><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq lr"/><span class="lo bw bk lp lq"/></div><div class="ig ih ii ij ik"><h1 id="a454" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">1.扫雷怎么玩？</h1><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nd ne l"/></div><figcaption class="nf ng gj gh gi nh ni bd b be z dk">Oct 3, 2006 — Uploaded by Llamallover</figcaption></figure><p id="d05a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">用户将能够点击单元格，选择网格的大小，或重新开始游戏。如果用户点击了被炸的单元格，游戏就结束了。或者，用户可以通过右键单击单元格来标记它，如果他们认为这是一个被轰炸的单元格。如果玩家可以打开所有未被炸毁的房间，他们就赢得了游戏。</p><h1 id="595b" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">2.为什么是Vuex？</h1><p id="da4a" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">因为我想建立一个有一些组件的应用程序，(为了可伸缩性和效率)，维护每个组件的状态是相当困难的。Vuex之所以如此强大，是因为组件从Vuex存储中获取它们的状态，并可以在存储状态发生变化时快速有效地进行更新。</p><h1 id="3bf9" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">3.为什么要Vuetify？</h1><p id="be61" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Vuetify是一个基于Vue环境的材质设计框架。它有体面和微妙的用户界面组件，并在Vue上随时可用。</p><h1 id="9345" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">4.设置应用程序</h1><p id="5695" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Vue提供了名为Vue CLI的标准开发工具。它可以通过一个简单的命令轻松设置应用程序。</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="080d" class="nt lt in np b gy nu nv l nw nx">vue create minesweeper-vue</span></pre><p id="c5d0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您的电脑中没有安装Vue CLI，请将其作为全局软件包安装。</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="d641" class="nt lt in np b gy nu nv l nw nx">npm install -g @vue/cli<br/># OR<br/>yarn global add @vue/cli</span></pre><h1 id="b0b8" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">5.添加Vuex</h1><p id="361c" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">正如已经讨论过的，我使用Vuex作为我们应用程序的商店管理模式。简单键入</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="06e9" class="nt lt in np b gy nu nv l nw nx">yarn add vuex<br/># OR<br/>npm install vuex</span></pre><h1 id="427f" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">6.添加Vuetify</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/cd7112fda463a5fa059eef2857033d1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*Zl0rIIZUAMTIn70WFU6WAQ.png"/></div></figure><p id="eda7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它与Vuex略有不同，因为我是通过Vue CLI设置Vuetify的。我可以通过键入以下内容将Vuetify添加到应用程序中</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="dbe5" class="nt lt in np b gy nu nv l nw nx">vue add vuetify</span></pre><p id="0141" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">安装后，我们的根应用程序结构将如左图所示。</p><h1 id="f4b2" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">7.应用程序的结构</h1><p id="32f7" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">我用两个组件构建了这个应用程序:</p><ul class=""><li id="284f" class="mp mq in kq b kr ks ku kv kx nz lb oa lf ob lj oc mv mw mx bi translated">主网格组件</li><li id="8426" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj oc mv mw mx bi translated">计时器组件</li></ul><p id="7b4a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">由内部含有<code class="fe od oe of np b">v-card</code>的硫化材料<code class="fe od oe of np b">v-hover</code>制成的主要栅格部件。然后把<code class="fe od oe of np b">v-hover</code>裹在里面<code class="fe od oe of np b">v-row.</code></p><p id="d339" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">计时器组件包含关于用户玩游戏花费的时间的信息。当玩家第一次点击单元格时，它会被实时更新。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/68d6c41bd3411cbe4c9f01c6a3df7f1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BuoQLK4WvuRYl-fX9Q0QQQ.png"/></div></div></figure><h1 id="0747" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">8.设置主网格组件</h1><p id="d637" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">首先，您可以从<code class="fe od oe of np b">components</code>文件夹中删除<code class="fe od oe of np b">HelloWorld.vue</code>，因为它不会被使用。然后，你必须创建新的组件，例如<code class="fe od oe of np b">MainGrid.vue</code>。</p><blockquote class="oh oi oj"><p id="1a3f" class="ko kp ok kq b kr ks jo kt ku kv jr kw ol ky kz la om lc ld le on lg lh li lj ig bi translated">温馨提示:<br/>使用VSCode IntelliSense加载Vue模板更快</p></blockquote><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oo"><img src="../Images/beb1b2ade7d69cd48c5f74244a9596be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xsHddpF72nxyJw_p16DAhg.png"/></div></div></figure><p id="7a1c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我想建立主网格，有“多维数组”一样，其中有相同的行和列数。在这个例子中，应用程序使用8作为行和列。为此，我可以使用来自Vuetify的<code class="fe od oe of np b">v-row</code>和<code class="fe od oe of np b">v-col</code>。为了增加悬停效果，我用了<code class="fe od oe of np b">v-hover</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="9e5d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将<code class="fe od oe of np b">MainGrid.vue</code>注册到<code class="fe od oe of np b">App.vue</code>上的组件</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="8f03" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要查看网格的结果，您可以运行命令</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="2449" class="nt lt in np b gy nu nv l nw nx">yarn run serve</span></pre><p id="4648" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们的应用程序看起来像这样:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/d05d9fadb245c49fe7f9668317cff2e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCMufwLyRfB10PIfQ0OSug.png"/></div></div></figure><h1 id="d0c3" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">9.设置主网格存储模块</h1><p id="8bd1" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">我使用Vuex作为我们应用程序的状态管理。首先，我为主网格设置了状态管理。</p><ol class=""><li id="f8da" class="mp mq in kq b kr ks ku kv kx nz lb oa lf ob lj mu mv mw mx bi translated"><em class="ok">创建</em>文件夹<code class="fe od oe of np b"><em class="ok">store</em></code>文件夹<em class="ok">内</em>文件夹<code class="fe od oe of np b"><em class="ok">src</em></code>文件夹<em class="ok">文件夹</em></li><li id="f486" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">在这个应用程序中，我使用模块系统。因此，我创建了名为 <code class="fe od oe of np b"><em class="ok">vuex.js</em></code> <em class="ok">的文件，该文件将Vuex注册到应用程序中，并导出Vuex存储本身中的模块。</em></li><li id="ea78" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated"><em class="ok">创建文件夹</em> <code class="fe od oe of np b"><em class="ok">modules</em></code></li><li id="9030" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated"><em class="ok">创建文件</em> <code class="fe od oe of np b"><em class="ok">mainGrid.js</em></code> <em class="ok">来配置它自己的</em> <code class="fe od oe of np b"><em class="ok">getters</em></code> <em class="ok">、</em> <code class="fe od oe of np b"><em class="ok">state</em></code> <em class="ok">、</em> <code class="fe od oe of np b"><em class="ok">actions</em></code> <em class="ok">和</em> <code class="fe od oe of np b"><em class="ok">mutations.</em></code></li><li id="1fca" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated"><em class="ok">包括我们的</em> <code class="fe od oe of np b"><em class="ok">vuex.js</em></code> <em class="ok">到我们的入口点文件，通常是</em> <code class="fe od oe of np b"><em class="ok">main.js</em></code></li></ol><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><h1 id="bf16" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">10.主网格:setPattern</h1><p id="7080" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">主网格组件依赖于一些状态。首先，我需要为我们的主网格设置网格模式。所以，我知道如何在每个单元格内随机放置数字和炸弹。</p><p id="e2b8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了创建模式，声明<strong class="kq io">状态，动作，</strong>和<strong class="kq io">突变</strong>用于在存储中设置模式。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="0e4c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那么，如何初始化组件来设置模式呢？我用的是Vuex的<code class="fe od oe of np b">map</code>。<code class="fe od oe of np b">map</code>将商店连接到组件，然后异步启动set模式。</p><p id="0c9a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一步是使用析构赋值从Vuex导入<code class="fe od oe of np b">mapActions</code>。并将<code class="fe od oe of np b">setPattern</code>动作分配给组件的方法。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="061b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如你所见，当组件进入<em class="ok">创建的</em>生命周期钩子时，我执行<code class="fe od oe of np b">setPattern</code>。在<em class="ok">创建的</em>钩子中，你将能够访问反应性的<em class="ok">数据</em>和<em class="ok">事件</em>是活动的，但是模板和虚拟DOM还没有被挂载或者渲染。</p><p id="2c51" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要检查模式，您可以在Vue devtools上轻松检查。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/a4256da645786d10190fd691ca0641e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wykvP_a5Xf_9k-UeRD7WWg.png"/></div></div></figure><h1 id="0ce9" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">11.主网格:getPattern</h1><p id="5cf6" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">在创建了模式之后，模板必须与商店进行通信。因此，模板可以呈现从存储区传来的模式。可以使用Vuex的<code class="fe od oe of np b">mapGetters</code>来完成。</p><p id="f451" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，将<code class="fe od oe of np b">getters</code>和名为<code class="fe od oe of np b">getPattern</code>的创建方法添加到我们的主网格存储中，并将其包含在导出对象中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="b15b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">像以前一样，使用析构赋值从Vuex导入<code class="fe od oe of np b">mapGetters</code>，并将<code class="fe od oe of np b">getPattern</code>动作分配给组件的计算属性。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="6fb5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">映射后，使用<em class="ok">上的<code class="fe od oe of np b"><em class="ok">getPattern</em></code> <em class="ok"> </em>计算出的</em>属性作为组件的数据源。您可以通过将每次迭代放入<code class="fe od oe of np b">v-card</code>文本来显示每个单元格数据。</p><p id="641d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们的应用程序看起来像这样</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/5e96afe047529b0b73c11cb35e9d23ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCdm71h6XcbFi7PdsE0-Cg.png"/></div></div></figure><h1 id="2ee2" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">12.主网格:隐藏和显示单元格的数据</h1><p id="acb8" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">我们需要考虑如何打开一个通过左键点击关闭的单元格。首先要做是在每个单元格中设置一个表示为“关闭”状态的状态，并在我们左键单击单元格时更改该状态。</p><p id="6fc6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将<code class="fe od oe of np b">show</code>键添加到之前创建的单元格中，并修改一些代码以保持单元格的数据被定义。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="86ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来，用Vue条件渲染“隐藏”单元格的数据<code class="fe od oe of np b">v-if</code>。为了显示单元格的数据，分配名为<code class="fe od oe of np b">openCell</code>的方法并传递单元格的<code class="fe od oe of np b">row_idx</code>和<code class="fe od oe of np b">col_idx</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="48cc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在存储中添加<code class="fe od oe of np b">openCell</code>方法处理程序。将其放入<em class="ok">动作</em>属性，然后将单元格目标传递给<em class="ok">突变</em>属性。我必须传递给<em class="ok">突变</em>，因为我想改变<code class="fe od oe of np b">pattern</code>状态。只有<em class="ok">突变</em>属性才允许这样做。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="bcd4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">试试看。</p><p id="a5e2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们再次感谢Vue的反应。你已经恋爱了吗？</p><h1 id="b8bf" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">13.主网格:洪水填充算法</h1><p id="4417" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">Flood fill是一种算法，主要用于确定连接到多维数组中给定节点的有界区域。它与绘画程序中的桶工具非常相似。</p><p id="6356" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这种情况下，我使用洪水填充算法来寻找连接的细胞有" 0 "值，并显示它。当指定的单元格被点击时，这种递归开始。为此，需要注意以下几点:</p><ol class=""><li id="3280" class="mp mq in kq b kr ks ku kv kx nz lb oa lf ob lj mu mv mw mx bi translated">仅在覆盖的单元上操作</li><li id="3f80" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">仅在电网范围内运行</li><li id="ab5c" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">查找相邻单元格的数量</li><li id="4d03" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">如果有，显示编号的单元格(大于0)</li><li id="4a62" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">如果不是，显示一个空白单元格(0)并继续递归</li><li id="63cc" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">如果单元格已经显示，则跳过显示过程</li><li id="2240" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">如果单元格已编号或者单元格位于数组末尾，则停止递归</li></ol><p id="f303" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我在<code class="fe od oe of np b">openCell</code>方法中添加了一些条件语句来处理递归。首先，如果递归到达数组末尾，就停止递归。第二个是处理单元的数据是否等于“0”或已被泄露。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="f017" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">接下来是在<em class="ok">动作</em>属性中定义<code class="fe od oe of np b">floodFill</code>方法。在方法内部，我显示单元格的数据并再次调用<code class="fe od oe of np b">openCell</code>方法，但是传递不同的行和列索引。我用四个方向打电话，北，西，东，南。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><h1 id="c63f" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">14.标记单元格</h1><p id="cb41" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">在扫雷游戏中，如果我们通过右键点击它来假设它是一个炸弹，那么这个单元可以被标记。有一些事情需要注意:</p><ol class=""><li id="1e36" class="mp mq in kq b kr ks ku kv kx nz lb oa lf ob lj mu mv mw mx bi translated">如果已经显示，则不能标记该单元格</li><li id="4a9e" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">在单元格中放置标志图标</li><li id="361d" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">如果标记了单元格，则无法打开该单元格，除非再次右键单击该单元格取消标记</li></ol><p id="2d94" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在组件文件中，插入用于处理单元格属性的右键单击的方法。我使用了阻止处理程序来阻止右击对话框的显示。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="e9dd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，通过从存储映射右键单击处理程序，将其注册到组件的方法。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="fc71" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在主网格存储模块中，我做了三个部分:</p><ol class=""><li id="0d38" class="mp mq in kq b kr ks ku kv kx nz lb oa lf ob lj mu mv mw mx bi translated"><code class="fe od oe of np b">flag</code>在state属性上按键，将旗帜图标注册到网络上。</li><li id="c42f" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated"><em class="ok">上的<code class="fe od oe of np b">flag</code>属性获取</em>以获取标志图标并与组件交流状态。</li><li id="61d2" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated"><code class="fe od oe of np b">flagged</code>在图案中的每个单元格属性上按键。我这样做是因为这个类似于<code class="fe od oe of np b">show</code>键，它使用布尔值来由组件进行反应渲染。</li><li id="1ebb" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">如果单元格被标记，则<code class="fe od oe of np b">openCell</code>方法中要跳过的条件语句。</li></ol><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="cd13" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，将组件配置为当用户右键单击单元格时显示标志。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><h1 id="52bc" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">15.设置定时器组件和存储模块</h1><p id="4854" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">这就像通常的计时器，计时是基于秒的。当用户点击单元格时，计时器将开始计时。步骤与主网格几乎相同:</p><ol class=""><li id="5ed5" class="mp mq in kq b kr ks ku kv kx nz lb oa lf ob lj mu mv mw mx bi translated">创建文件组件，例如<em class="ok"> Timer.vue </em></li><li id="c9c1" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">导入组件，添加到<em class="ok"> App.vue </em>注册的组件中，并在<code class="fe od oe of np b">&lt;main-grid&gt;</code>标签下记下自定义标签</li><li id="51ad" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">创建定时器存储模块文件，例如<em class="ok"> timer.js </em></li><li id="f14a" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">导入模块并添加到Vuex store的模块中的<em class="ok"> vuex.js </em>文件中</li></ol><h1 id="36a9" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">16.定时器:设置定时器</h1><p id="6f74" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">如果所有的要素都已设置好，下一步就是制作一个触发器来启动计时器。时间以秒为单位计时，每当用户单击单元格时，时间就会开始计时。这可以通过设置一个状态作为计时器的“主控件”来告诉何时开始计时来实现。它可以作为新的状态属性放在主网格存储中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="70bf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了能够改变状态，我还在<em class="ok">突变</em>属性上添加了一个突变。从这段代码中，我们知道当用户第一次点击时,<code class="fe od oe of np b">timerInit</code>状态属性将以毫秒为单位变成当前时间。我设置初始时间，因为我想计算初始时间和实际时间之间的差异。</p><p id="7bb5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">计时器值实际上是在我之前创建的计时器存储中处理的。让我们在计时器存储中创建<em class="ok">状态</em>属性，以接受小时、分钟和秒的值；还创建基于毫秒的时间划分。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="f2fc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在<em class="ok">动作</em>属性上，我添加了<code class="fe od oe of np b">setInterval</code>方法来处理定时器初始化。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="3cd3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于<code class="fe od oe of np b">setTimer</code>动作，只要主网格存储上的<code class="fe od oe of np b">timerInit</code>状态被设置为当前时间值，它就会工作。我在之前的解释中设置了如果用户点击单元格<code class="fe od oe of np b">timerInit</code>会发生变异。</p><p id="7936" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了在商店之间进行连接，我使用了Vuex的<em class="ok"> rootState </em>属性。它为所有在app initiation中注册的Vuex模块提供服务。那么可以简单地使用点符号或括号符号来访问主网格存储。</p><p id="5389" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下一步是每当计时器计时时处理小时、分钟和秒钟；然后通过<em class="ok">突变</em>在<em class="ok">状态</em>属性中设置这些值。因此，我们的<em class="ok"> timer.js </em>存储文件将如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="0fd4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以在Vue devtools上的<em class="ok"> Vuex </em>条菜单中检查定时器状态的变化。</p><p id="3b59" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后通过将<code class="fe od oe of np b">setTimer</code>动作添加到定时器组件中，将其连接到应用程序，并放置在<em class="ok">创建的</em>钩子中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><h1 id="ec80" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">17.计时器:getTimer</h1><p id="0656" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">为了获得时间值，我使用了<em class="ok"> getters </em>属性。时间由小时、分钟和秒状态组成。首先，我们通过使用getter分别获得每个小时、分钟和秒的值。我还添加了秒和分钟的条件返回值，如果这些值低于10，则返回两位数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><p id="ae68" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后使用<code class="fe od oe of np b">mapGetters</code>将时间获取器映射到定时器组件上</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="op ne l"/></div></figure><h1 id="c3d5" class="ls lt in bd lu lv nj lx ly lz nk mb mc jt nl ju me jw nm jx mg jz nn ka mi mj bi translated">就在那里！</h1><p id="f147" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">我希望你喜欢跟随。如果你喜欢这个内容，并想进一步讨论，请留下你的掌声和评论！</p><p id="223e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可以在游戏中加入一些额外的功能:</p><ol class=""><li id="658f" class="mp mq in kq b kr ks ku kv kx nz lb oa lf ob lj mu mv mw mx bi translated">每当用户点击炸弹时，停止计时器并弹出通知</li><li id="f42d" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">给数字和炸弹一些风格</li><li id="e941" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">重启按钮</li><li id="c0ac" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">网格大小选择</li><li id="15dd" class="mp mq in kq b kr my ku mz kx na lb nb lf nc lj mu mv mw mx bi translated">关于地雷的信息留下了。当用户在单元格上放置一个标志时，它可以减少，反之亦然</li></ol><p id="5faa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我也做了一些有特色的扫雷舰。你可以看看，我非常欢迎反馈！</p><p id="0e4d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">GitHub:<a class="ae lk" href="https://github.com/naufaliqbal/minesweeper-vue" rel="noopener ugc nofollow" target="_blank">https://github.com/naufaliqbal/minesweeper-vue</a></p><p id="ec07" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">领英:<a class="ae lk" href="https://www.linkedin.com/in/muhamad-iqbal-naufal/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/muhamad-iqbal-naufal/</a></p></div></div>    
</body>
</html>