<html>
<head>
<title>Class, Factory, and Object Prototypes in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的类、工厂和对象原型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/class-factory-and-object-prototypes-b4a7fff7dba8?source=collection_archive---------4-----------------------#2020-06-21">https://javascript.plainenglish.io/class-factory-and-object-prototypes-b4a7fff7dba8?source=collection_archive---------4-----------------------#2020-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9e9f3cdd1fb7ea374e4e5823054f674b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-5lmI1scPhjVYlC2r3rj5w.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://www.pexels.com/@padrinan?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Miguel Á. Padriñán</a> from <a class="ae kc" href="https://www.pexels.com/photo/photo-of-golden-cogwheel-on-black-background-3785927/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="ef75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象原型继承是JavaScript的核心。基于我们在<a class="ae kc" href="https://medium.com/javascript-in-plain-english/whats-function-got-to-do-with-this-7ab2633fb4a5" rel="noopener">上一篇关于函数</a>的文章中所学到的，这篇文章更深入地探讨了函数和原型继承。具体来说，我们就来看看<strong class="kf ir">类函数和工厂函数。</strong></p><div class="lb lc gp gr ld le"><a href="https://medium.com/javascript-in-plain-english/whats-function-got-to-do-with-this-7ab2633fb4a5" rel="noopener follow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">“this”关键字在不同的上下文中如何变化</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">并不是所有的JavaScript函数都是一样的。</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">medium.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls jw le"/></div></div></a></div><h2 id="40d2" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated"><strong class="ak">关于JavaScript中的</strong><code class="fe mm mn mo mp b"><strong class="ak">Class</strong></code><strong class="ak"/></h2><p id="fada" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">JavaScript是基于原型的语言，而不是基于类的语言。由于ES6在语言中添加了一个<code class="fe mm mn mo mp b">class</code>声明，JavaScript开发人员可以更容易地创建类。然而，这种添加只是JavaScript原型继承的语法上的糖衣。</p><p id="3a9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，在基于类的语言中，JavaScript类不会像您所期望的那样运行。一个<code class="fe mm mn mo mp b">new()</code>类不会创建一个要实例化的副本。它创建另一个对象，并链接到另一个对象的原型。</p><p id="f132" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">理解ES6类掩盖了引擎盖下的原型机制是至关重要的。需要记住的两个关键区别是:</p><p id="a4cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1) JavaScript类属性继承遵循原型链，而不是类链</p><p id="5ba9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2) JavaScript类属性<em class="mv">可以在运行时动态添加或删除</em></p><p id="bbc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">有关这方面的更多阅读，请查看“</strong> <a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Details_of_the_Object_Model" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">对象模型的详细信息。</strong></a><strong class="kf ir"/></p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="15d8" class="nd lu iq bd lv ne nf ng ly nh ni nj mb nk nl nm me nn no np mh nq nr ns mk nt bi translated"><strong class="ak">类功能</strong></h1><p id="9d9b" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">在ES6之前，我们将结合显式委托原型使用<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor" rel="noopener ugc nofollow" target="_blank">构造函数</a>。</p><p id="a14c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于ES6，我们可以简单地使用<code class="fe mm mn mo mp b">class</code>关键字。我们可以用两种不同的方式创建一个类，作为一个声明或者作为一个表达式。比如<code class="fe mm mn mo mp b">class MyClass{}</code>和<code class="fe mm mn mo mp b">const MyClass = class{}</code>是等价的。无论哪种方式，类函数都不会被提升，这意味着我们不能在它声明之前引用它。</p><p id="a4dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，一个类函数，关于<code class="fe mm mn mo mp b">this</code>关键字上下文，表现得像一个常规函数。所以我们在<a class="ae kc" href="https://medium.com/javascript-in-plain-english/whats-function-got-to-do-with-this-7ab2633fb4a5" rel="noopener">上一篇文章</a>中探索的警告仍然适用于一个类实例。</p><h2 id="0797" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated"><strong class="ak">基本用法</strong></h2><p id="3048" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">我们创建一个类函数，然后在其中定义一个<code class="fe mm mn mo mp b">constructor</code>:</p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="5cf2" class="lt lu iq mp b gy oc od l oe of">class Employee {<br/>  constructor(name, hoursWorked) {<br/>    this.wagePerHour = 15;<br/>    this.hours = hoursWorked;<br/>    this.employeeName = name;<br/>  }</span><span id="e915" class="lt lu iq mp b gy og od l oe of">// class method<br/>  getWageReport() {<br/>   const totalWage = this.hours * this.wagePerHour;<br/>   return `${this.employeeName} total wages: ${totalWage}`<br/>  }</span><span id="b9f4" class="lt lu iq mp b gy og od l oe of">// getter<br/> get totalWage() {<br/>  return this.getWageReport();<br/> }<br/>}</span></pre><p id="8852" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还在类中使用了getter和setter。使用<code class="fe mm mn mo mp b">new</code>关键字创建该类的一个实例。</p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="446e" class="lt lu iq mp b gy oc od l oe of">var employeeOne = new Employee(“Amy”, 20);<br/>employeeOne.totalWage; // output: “Amy total wages: 300”</span></pre><h2 id="9575" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated"><strong class="ak">扩展创建子类</strong></h2><p id="34b4" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">我们可以用关键字<code class="fe mm mn mo mp b">extend</code>创建一个子类:</p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="9fb5" class="lt lu iq mp b gy oc od l oe of">class Contractor extends Employee {<br/>  constructor(name, hours) {<br/>   super(name, hours);<br/>   this.wagePerHour = 8;<br/>  }<br/>}</span><span id="b516" class="lt lu iq mp b gy og od l oe of">var employeeTwo = new Contractor(“Tom”, 20);<br/>employeeTwo.totalWage; // output: “Tom total wages: 160”</span></pre><p id="8cc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在子构造函数中，我们用<code class="fe mm mn mo mp b">super()</code>调用父类。然后将<code class="fe mm mn mo mp b">wagePerHour</code>赋值为新值。</p><p id="f85e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在子类中，我们必须在访问关键字<code class="fe mm mn mo mp b">this</code>之前调用<code class="fe mm mn mo mp b">super()</code>。</p><h2 id="bc7f" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated"><strong class="ak">静态方法</strong></h2><p id="68bf" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">类也可以有静态方法，这些方法只能在类本身上调用，而不能在类实例上调用。静态方法作为实用方法很有用。</p><p id="e227" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想添加一个实用程序类，通过传入任意工资和工时来计算工资总额:</p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="ec83" class="lt lu iq mp b gy oc od l oe of">class Employee {<br/>  ...omitted...<br/>  static calculateWage(wage, hours) {<br/>    return wage * hours<br/>  }<br/>}</span></pre><p id="23de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只能通过直接引用类而不是实例来调用它:</p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="32ba" class="lt lu iq mp b gy oc od l oe of">Employee.calculateWage(100, 5); // output: 500</span><span id="f980" class="lt lu iq mp b gy og od l oe of">employeeOne.calculateWage(100, 5); // TypeError: employeeOne.calculateWage is not a function</span></pre><p id="5ce4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而如果我们想从一个类内部引用静态方法，就必须通过类名(<em class="mv">显式引用</em>)或者调用它的构造函数(<em class="mv">动态引用</em>)。</p><p id="8e77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们重写<code class="fe mm mn mo mp b">getWageReport</code>类方法以使用静态<code class="fe mm mn mo mp b">calculateWage</code>方法:</p><p id="b9f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mv">明确引用- </em></p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="2626" class="lt lu iq mp b gy oc od l oe of">getWageReport() {<br/>  const totalWage = <br/>   <strong class="mp ir">Employee.calculateWage</strong>(this.wagePerHour, this.hours)<br/>  <br/>  return `${this.employeeName} total wages: ${totalWage}`<br/>}</span></pre><p id="fc40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="mv">动态参考- </em></p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="fe93" class="lt lu iq mp b gy oc od l oe of">getWageReport() {</span><span id="141b" class="lt lu iq mp b gy og od l oe of">const totalWage = <br/>   <strong class="mp ir">this.constructor.calculateWage</strong>(this.wagePerHour, this.hours)</span><span id="9a53" class="lt lu iq mp b gy og od l oe of">return `${this.employeeName} total wages: ${totalWage}`<br/>}</span></pre><p id="e099" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你不想改变静态方法，那么使用显式引用。</p><p id="3ddb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">静态方法的<code class="fe mm mn mo mp b">this</code>关键字不会自动绑定到执行上下文或词法范围(自动装箱)。我们需要明确地定义或传递<code class="fe mm mn mo mp b">this</code>上下文给这个方法。</p><p id="0ad9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是为什么我认为与其在父类中动态引用一个静态方法，不如使用一个简单的类方法要干净得多。那么该方法的可用性是显而易见的。我们也没有丢失<code class="fe mm mn mo mp b">this</code>上下文的问题。</p><h2 id="41bb" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated"><strong class="ak">私有字段和方法(ES2019) </strong></h2><p id="d5c8" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">默认情况下，类字段和方法是公共的。ES2019增加了通过在私有成员前面加上#来定义私有成员的功能。</p><p id="a354" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">对私有字段的支持还不是100%。私有方法处于</strong> <a class="ae kc" href="https://github.com/tc39/proposal-private-methods" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">提议阶段</strong> </a> <strong class="kf ir">并且只能用于Babel和其他一些框架。</strong></p><p id="b1ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设您已经添加了支持，使用<strong class="kf ir">雇员</strong>示例，让我们添加一个私有字段和方法:</p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="130f" class="lt lu iq mp b gy oc od l oe of">class Employee {</span><span id="5ff9" class="lt lu iq mp b gy og od l oe of">#minimumWage;</span><span id="75f6" class="lt lu iq mp b gy og od l oe of">constructor(name, hoursWorked) {<br/>    this.#minimumWage = 7;    <br/>    this.wagePerHour = this.#calculateBaseWage();<br/>    this.hours = hoursWorked;<br/>    this.employeeName = name;<br/>  }</span><span id="ba85" class="lt lu iq mp b gy og od l oe of">// class method<br/>  getWageReport() {<br/>    const totalWage = this.hours * this.wagePerHour;<br/>    return `${this.employeeName} total wages: ${totalWage}`<br/>  }</span><span id="ea1e" class="lt lu iq mp b gy og od l oe of">// getter<br/> get totalWage() {<br/>   return this.getWageReport();<br/> }</span><span id="e9da" class="lt lu iq mp b gy og od l oe of">//private static method<br/> static #assignBaseWage(min) {<br/>   return min * 2;<br/> }<br/> <br/> // private method<br/> #calculateBaseWage() {<br/>   return Employee.#assignBaseWage(this.#minimumWage);<br/> }<br/> <br/>}</span><span id="39ea" class="lt lu iq mp b gy og od l oe of">const employeeThree = new Employee("Bobby", 25);<br/>employeeThree.#minimumWage; // error: Syntax error<br/>employeeThree.totalWage; // output: "Bobby total wages: 350"</span></pre><p id="b120" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的例子有点做作，在根据最低工资计算基本工资时多了一层。</p><p id="8862" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只是为了说明静态私有方法与上一节中解释的常规静态方法具有相同的非实例访问限制。</p><h2 id="ecf4" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated"><strong class="ak">类捕获:可变性</strong></h2><p id="26ce" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">由类创建的对象不是不可变的。因为类对象只是另一个JavaScript对象。考虑:</p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="9d5f" class="lt lu iq mp b gy oc od l oe of">employeeTwo.employeeName = ‘Bob’;</span><span id="a097" class="lt lu iq mp b gy og od l oe of">employeeTwo.totalWage; // output: “Bob total wages: 160”</span></pre><p id="941b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会使用一个不可变的库或者在类函数中使用<code class="fe mm mn mo mp b">Object.freeze</code>,但是一旦我们开始创建子类/子类，就会有很多警告。</p><p id="5738" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">要深入了解不变性和类，请查看Everything Frontend上JavaScript </strong>  <strong class="kf ir">中的</strong> <a class="ae kc" href="https://www.everythingfrontend.com/posts/immutable-classes-in-javascript.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">不可变类。值得一读！</strong></a></p><h2 id="6b35" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated"><strong class="ak">类问题:实践中的对象原型链</strong></h2><p id="d9d1" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">为了说明原型继承或委托的含义，请使用上面的代码示例来考虑这些场景。</p><p id="a8a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些情况不太可能通过设计发生。因为它们不是好的编码实践，可以被认为是反模式，所以不要这样做！</p><p id="a8d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，随着代码库变得越来越复杂，不变性没有得到很好的实施，意外的操作可能会发生。</p><h2 id="6ece" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated">类的方法或属性可以在声明后修改吗？是</h2><p id="d10a" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">继续上面的静态方法示例，如果我在类声明之后重新定义了<code class="fe mm mn mo mp b">calculateWage</code>方法，并且我们使用了显式引用<code class="fe mm mn mo mp b">Employee.calculateWage</code>:</p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="a6a4" class="lt lu iq mp b gy oc od l oe of">// redefine the method in parent class<br/>Employee.calculateWage = function() { return ‘what?’ }</span><span id="0457" class="lt lu iq mp b gy og od l oe of">// redefine the method in child class<br/>Contractor.calculateWage = function() { return ‘what now?’ }</span><span id="ea3a" class="lt lu iq mp b gy og od l oe of">// get totalWage again, parent class used explicit reference<br/>employeeOne.totalWage; //output: “Amy total wages: what?”<br/>employeeTwo.totalWage; //output: “Tom total wages: what?”</span></pre><p id="b672" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">父类和子类的实例现在都从父类Employee中新定义的<code class="fe mm mn mo mp b">calculateWage</code>方法返回值——“什么？”。我们不应该期望子类的实例返回“现在怎么办？”因为声明的引用对<em class="mv">雇员</em>是显式的。</p><p id="f4b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们已经声明使用动态引用，<code class="fe mm mn mo mp b">this.constructor.calculateWage</code>，我们应该看到每个类的实例尊重它的边界:</p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="c5b1" class="lt lu iq mp b gy oc od l oe of">// get totalWage again, parent class used dynamic reference</span><span id="3f46" class="lt lu iq mp b gy og od l oe of">employeeOne.totalWage; //output: “Amy total wages: what?”<br/>employeeTwo.totalWage; //output: “Tom total wages: what now?”</span></pre><h2 id="0df2" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated"><strong class="ak">我可以在声明后添加新的父方法吗？是</strong></h2><p id="4b57" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">如果我通过添加一个新的<code class="fe mm mn mo mp b">getShift</code>方法来修改父<strong class="kf ir"> <em class="mv">雇员</em> </strong>类aka对象原型:</p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="d0b5" class="lt lu iq mp b gy oc od l oe of">// randomly generate and return a shift number with employee name</span><span id="c0b4" class="lt lu iq mp b gy og od l oe of">Employee.prototype.getShift = function () {<br/>  const shift = lastShiftNumber + 1;<br/>  return `${this.employeeName} is on shift number ${shift}.`;<br/>};</span></pre><p id="3bba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们对之前创建的两个对象调用这个方法:</p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="ee55" class="lt lu iq mp b gy oc od l oe of">employeeOne.getShift(1); //output: “Amy is on shift number 2.”<br/>employeeTwo.getShift(2); //output: “Tom is on shift number 3.”</span></pre><p id="7ee8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将得到相应的结果，打印出员工姓名和正确的班次编号。</p><p id="8053" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为原型委托的缘故。</p><p id="8f44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe mm mn mo mp b">employeeTwo</code>在原型中找不到方法时，它会沿着委托链向上遍历到父原型，并从那里执行<code class="fe mm mn mo mp b">getShift</code>方法。</p><h2 id="4811" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated"><strong class="ak">关于类的结论</strong></h2><p id="f3a9" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">原型委托是JavaScript中的一个强大特性。类语法使得创建具有继承行为的对象更加容易。</p><p id="5212" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，将面向类的范例应用到基于原型的语言中会导致混乱。我们需要在原型继承的上下文中理解类，以便在设计OOP系统时充分利用对象原型。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="e4c7" class="nd lu iq bd lv ne nf ng ly nh ni nj mb nk nl nm me nn no np mh nq nr ns mk nt bi translated"><strong class="ak">工厂功能</strong></h1><p id="c486" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">ES6类或构造函数不是在JavaScript中创建可重用或可组合对象的唯一方法。另一种广泛使用的方法是工厂函数。</p><p id="1137" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类和工厂函数的心理模型并不相似。一种是从面向对象的模式开始，而另一种更接近于函数式编程。</p><p id="b097" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">工厂函数是返回对象的(非构造函数)函数。对象可以是对象文字或对象原型。</strong></p><p id="8b31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上一节的<code class="fe mm mn mo mp b"><strong class="kf ir">Employee</strong></code>为例，说明使用<strong class="kf ir">工厂函数创建一个对象文字(无继承)</strong>:</p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="4609" class="lt lu iq mp b gy oc od l oe of">const RegularEmployeeModel = { wagePerHour: 15 };<br/>const ContractorModel = { wagePerHour: 8 };</span><span id="c252" class="lt lu iq mp b gy og od l oe of">// utility function<br/>const calculateWage = (wage, hours) =&gt; wage * hours;</span><span id="1125" class="lt lu iq mp b gy og od l oe of">// factory function</span><span id="c79b" class="lt lu iq mp b gy og od l oe of">const CreateEmployee = (name, hoursWorked, model) =&gt; {<br/>  const hours = hoursWorked;<br/>  const employeeName = name;<br/>  const wagePerHour = model.wagePerHour;<br/>  <br/>  const getWageReport = () =&gt; {<br/>    const totalWage = calculateWage(wagePerHour, hours);<br/>    return `${employeeName} total wages: ${totalWage}`;<br/>  };</span><span id="e3c5" class="lt lu iq mp b gy og od l oe of">return Object.freeze({<br/>     totalWage: getWageReport(),<br/>     name: employeeName,<br/>     hours<br/>  });<br/>}</span></pre><p id="df8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用常规或箭头函数。这里我们使用一个箭头函数<code class="fe mm mn mo mp b">CreateEmployee</code>，它接受<code class="fe mm mn mo mp b">name</code>和<code class="fe mm mn mo mp b">hoursWorked</code>参数(就像类的例子一样)。最后，它接受<code class="fe mm mn mo mp b">model</code>作为参数，它定义了我们想要创建的对象的结构。</p><p id="f05d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在那里，我们调用函数为雇员创建一个对象:</p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="8e2b" class="lt lu iq mp b gy oc od l oe of">const employeeOne = CreateEmployee(“Amy”, 20, RegularEmployeeModel);<br/>const employeeTwo = CreateEmployee(“Tom”, 20, ContractorModel);</span><span id="b8d6" class="lt lu iq mp b gy og od l oe of">employeeOne.totalWage; // output: “Amy total wages: 300”</span><span id="3db7" class="lt lu iq mp b gy og od l oe of">employeeTwo.totalWage; // output: “Tom total wages: 160”</span></pre><p id="38bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很简单——给定输入，我们有一个预期的输出。这种模式提供了很大的灵活性。</p><p id="9992" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">美妙的是，我们可以轻松地将return语句包装在一个<code class="fe mm mn mo mp b">Object.freeze</code>或其他不可变的实用程序中，以确保创建的任何对象都是不可变的。</p><p id="56ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于该函数每次都返回一个新对象，因此没有委托或继承。</p><p id="3b18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以有一个<strong class="kf ir">工厂函数来创建一个具有原型继承的对象。为此，我们将在函数中使用<code class="fe mm mn mo mp b">Object.create</code>:</strong></p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="169d" class="lt lu iq mp b gy oc od l oe of">const RegularEmployee = {<br/>  wagePerHour: 15,<br/>  getWageReport: function () {<br/>    const totalWage = calculateWage(this.wagePerHour, this.hours);<br/>    return `${this.name} total wages: ${totalWage}`;<br/>  }<br/>};</span><span id="7ce5" class="lt lu iq mp b gy og od l oe of">const Employee = (name, hoursWorked, model) =&gt; {<br/>   let newEmployee = Object.create(model);<br/>   newEmployee.name = name;<br/>   newEmployee.hours = hoursWorked;<br/>   newEmployee.totalWage = newEmployee.getWageReport();</span><span id="7aaa" class="lt lu iq mp b gy og od l oe of">   return Object.freeze(newEmployee);<br/>}</span><span id="fb5e" class="lt lu iq mp b gy og od l oe of">const employeeThree = Employee("Amy", 20, RegularEmployeeModel);</span><span id="48e4" class="lt lu iq mp b gy og od l oe of">employeeThree.totalWage; // output: "Amy total wages: 300"</span></pre><p id="efef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以检查原型委托:</p><pre class="nu nv nw nx gt ny mp nz oa aw ob bi"><span id="33f6" class="lt lu iq mp b gy oc od l oe of">Object.getPrototypeOf(employeeThree) === RegularEmployeeModel;<br/>// output: true</span><span id="4aff" class="lt lu iq mp b gy og od l oe of">// don't really do this mutation, anti-pattern!<br/>RegularEmployeeModel.say = 'hello';<br/>employeeThree.say; // output: 'hello';</span></pre><p id="c8c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们看到当我们用一个新方法修改委托原型<code class="fe mm mn mo mp b">RegularEmployeeModel</code>时，一个冻结的/不可变的<code class="fe mm mn mo mp b">employeeThree</code>的行为发生了变化。不变性仅限于通过调用工厂函数创建的对象属性。</p><h2 id="444c" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated"><strong class="ak">私有数据和封装</strong></h2><p id="bab6" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">从前面两个例子可以看出，除非一个变量或方法被故意暴露(返回)，那么它就不能在函数之外被访问。因此，默认情况下，工厂函数中的所有变量和方法都是私有的。当然，这不适用于对象原型上的方法。</p><h2 id="9076" class="lt lu iq bd lv lw lx dn ly lz ma dp mb ko mc md me ks mf mg mh kw mi mj mk ml bi translated"><strong class="ak">关于工厂的结论</strong></h2><p id="2fd7" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated"><strong class="kf ir">工厂功能灵活。它们很容易理解，执行上下文总是很清楚。你没有模糊不清的</strong> <code class="fe mm mn mo mp b"><strong class="kf ir"><em class="mv">this</em></strong></code> <strong class="kf ir">关键词问题。</strong></p><p id="cf48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">我们可以修改它以包含不同的实现模式，特别是使用</strong> <code class="fe mm mn mo mp b"><strong class="kf ir"><em class="mv">Object.create</em></strong></code> <strong class="kf ir">的OOLO(对象链接到其他对象)模式。</strong></p><p id="1ef1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">它可以支持创建简单的对象文字。如果我们将工厂功能分解成小的功能块，它们可以成为组合模式的基础。</strong></p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h1 id="6d9b" class="nd lu iq bd lv ne nf ng ly nh ni nj mb nk nl nm me nn no np mh nq nr ns mk nt bi translated"><strong class="ak">类/构造函数与对象.用工厂创建</strong></h1><p id="746c" class="pw-post-body-paragraph kd ke iq kf b kg mq ki kj kk mr km kn ko ms kq kr ks mt ku kv kw mu ky kz la ij bi translated">我们看到工厂函数和类/构造函数都可以通过继承创建对象原型。工厂函数并不局限于此，它在生成对象文字或简单数据对象时非常有用。</p><p id="ea88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Class的ES6语法使得使用构造函数创建新对象更容易编写。与Object.create相比，类/构造函数的一个优势在于性能。</p><p id="acdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript引擎通过使用<code class="fe mm mn mo mp b">new</code>关键字和类在<code class="fe mm mn mo mp b">Object.create</code>上创建新的对象原型来优化性能。</p><p id="e631" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，性能差异主要在于系统是如何构建的。是这样吗，还是需要用面向对象的方法来设计？代码的清晰性和可维护性也不容忽视。</p><p id="a6b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，在使用<strong class="kf ir">类/构造函数</strong>和使用<strong class="kf ir">对象的工厂之间的选择。创造归结于个人喜好以及它如何适应你的大格局。</strong></p></div></div>    
</body>
</html>