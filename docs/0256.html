<html>
<head>
<title>Loading images with JWT Authorization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JWT授权加载图像</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/loading-images-with-authorization-8aab33663ba6?source=collection_archive---------0-----------------------#2019-09-07">https://javascript.plainenglish.io/loading-images-with-authorization-8aab33663ba6?source=collection_archive---------0-----------------------#2019-09-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f89e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">或者如何增强原生HTML</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c3dfc727200d6aca3255f1734dea8f63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9pWUdYPAwCQoWdEnvZli4A.jpeg"/></div></div></figure><p id="4887" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你做JS + HTML已经有几天了，那么你可能对<code class="fe lk ll lm ln b">img</code>标签很熟悉。这个概念很简单——在你的标记中放一个<code class="fe lk ll lm ln b">img</code>标签，提供一个带有图片URL的<code class="fe lk ll lm ln b">src</code>属性，然后砰——你的页面上就有一张图片了。例如，如果我们在<code class="fe lk ll lm ln b">https://somewhere.com/image.png</code>有一张图片，我们可以这样做:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="3c2c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">到目前为止还没有什么新奇的东西，但是如果我们不想让任何人访问这张图片呢？当然，从API的角度来看，实现一些基本的认证并不难。据说，JWT授权现在很流行。但是另一个问题来了——对于JWT，我们需要一个特殊的字符串——一个令牌，与请求一起传递给服务器，以帮助服务器识别发出请求的用户。当然，如果我们使用一个<code class="fe lk ll lm ln b">HttpClient</code>实例来获取图像，这没什么大不了的——我们只需在请求中添加带有<code class="fe lk ll lm ln b">options</code>参数的头。但是我们如何迫使<code class="fe lk ll lm ln b">img</code>标签通过<code class="fe lk ll lm ln b">HttpClient</code>实例请求图像呢？</p><p id="2d23" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">答案是管道。</p><p id="2a45" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们要做的是:</p><ol class=""><li id="04be" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated">编写一个接受图像url的管道，并在放置授权头的同时执行HTTP请求，</li><li id="f17a" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">将<code class="fe lk ll lm ln b">blob</code>响应转换成一个<code class="fe lk ll lm ln b">base64</code>字符串，这样它就可以被传递给<code class="fe lk ll lm ln b">src</code>属性，</li><li id="ef10" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">将<code class="fe lk ll lm ln b">base64</code>管柱放入<code class="fe lk ll lm ln b">Promise</code>中，使其依次通过<code class="fe lk ll lm ln b">async</code>管，</li><li id="8a29" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">调用一个<code class="fe lk ll lm ln b">src</code>属性中的管道，</li><li id="e880" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">如果出现问题，可以选择指定一个后备映像，</li><li id="c831" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">可以选择创建一个组件来处理所有这些逻辑</li></ol><p id="63f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们从基本管道开始:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="e550" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以我们在这里:</p><ol class=""><li id="e3d7" class="ls lt in kq b kr ks ku kv kx lu lb lv lf lw lj lx ly lz ma bi translated">从我们的本地服务获取令牌，</li><li id="bdfc" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">放在<code class="fe lk ll lm ln b">headers</code>里面，</li><li id="2325" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">使用这些标题调用图像，</li><li id="9e84" class="ls lt in kq b kr mb ku mc kx md lb me lf mf lj lx ly lz ma bi translated">指定<code class="fe lk ll lm ln b">responseType: 'blob'</code>告诉Angular我们正在这里加载一个二进制文件</li></ol><p id="a4be" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意<code class="fe lk ll lm ln b">toPromise</code>和<code class="fe lk ll lm ln b">async</code> / <code class="fe lk ll lm ln b">await</code>的用法。</p><p id="11ac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当然，这只是工作的一半——我们仍然需要将二进制转换成一个<code class="fe lk ll lm ln b">base64</code>字符串。<code class="fe lk ll lm ln b">FileReader</code>来了。(我将只提供<code class="fe lk ll lm ln b">transform</code>方法的实现)</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="e504" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们只是将文件读取过程包装在一个Promise中，所以我们可以将它与<code class="fe lk ll lm ln b">async</code>管道结合使用:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="d1cb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们在Chrome中打开<code class="fe lk ll lm ln b">Network</code>标签，我们会看到对图片的请求，并找到我们要找的标题:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/bb40c1a4684fe1dbaabd6ea25b36d871.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*oAPcYOEOKt1Ixp-PdotZZA.png"/></div></figure><p id="2a93" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你仔细观察，你会注意到在我们的<code class="fe lk ll lm ln b">transform</code>方法中我们没有做任何错误处理。如果图像不存在呢？如果出现服务器错误怎么办？不管错误的性质如何，我们都可以提供一个回退图像:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="706c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们只是将HTTP请求包装在一个<code class="fe lk ll lm ln b">try</code> / <code class="fe lk ll lm ln b">catch</code>块中，并在出错时返回一个回退图像url。请注意，我们没有承诺包装回退图像url字符串，因为该方法已经是<code class="fe lk ll lm ln b">async</code>，它是自动完成的。</p><blockquote class="mh mi mj"><p id="0a19" class="ko kp lq kq b kr ks jo kt ku kv jr kw mk ky kz la ml lc ld le mm lg lh li lj ig bi translated">可选地，我们也可以用一个<code class="fe lk ll lm ln b">switch</code>语句为不同的错误场景返回不同的回退图像(一个用于<code class="fe lk ll lm ln b">404</code>，一个用于<code class="fe lk ll lm ln b">Server Error</code>，等等)，但这超出了本文的范围。</p></blockquote><p id="5749" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，我们可以编写一个组件，用它的<code class="fe lk ll lm ln b">Authorized</code>版本替换整个应用程序中的所有<code class="fe lk ll lm ln b">img</code>标签:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="d1a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后像这样使用它:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lo lp l"/></div></figure><blockquote class="mh mi mj"><p id="6766" class="ko kp lq kq b kr ks jo kt ku kv jr kw mk ky kz la ml lc ld le mm lg lh li lj ig bi translated"><strong class="kq io">警告</strong>:你需要记住的一件事是CORS:你的图像服务服务器应该以这样一种方式配置，它接受来自你的Angular应用程序正在运行的域的图像的XHR调用，否则你会遇到CORS错误。此外，您必须提供自定义管道的绝对URL，否则它将向Angular应用程序的域本身发出请求。</p></blockquote><h2 id="2f9f" class="mn mo in bd mp mq mr dn ms mt mu dp mv kx mw mx my lb mz na nb lf nc nd ne nf bi translated">结论</h2><p id="2f78" class="pw-post-body-paragraph ko kp in kq b kr ng jo kt ku nh jr kw kx ni kz la lb nj ld le lf nk lh li lj ig bi translated">正如我们所看到的，完全可以用包装器替换原生HTML元素来执行定制逻辑。管道在这个过程中也派上了用场。</p><p id="17d9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="lq">跟我上</em> <a class="ae lr" href="https://medium.com/@Armandotrue" rel="noopener"> <em class="lq">中</em> </a> <em class="lq">和</em><a class="ae lr" href="https://twitter.com/Armandotrue" rel="noopener ugc nofollow" target="_blank"><em class="lq">Twitter</em></a><em class="lq">了解更多关于Angular、Rxjs、React和Javascript的一般信息</em>。</p></div></div>    
</body>
</html>