<html>
<head>
<title>How to add authentication to your universal Nuxt app using the nuxt/auth module</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用nuxt/auth模块向您的通用Nuxt应用程序添加身份验证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-add-authentication-to-your-universal-nuxt-app-using-nuxt-auth-module-61dbc9aea2c2?source=collection_archive---------1-----------------------#2019-09-29">https://javascript.plainenglish.io/how-to-add-authentication-to-your-universal-nuxt-app-using-nuxt-auth-module-61dbc9aea2c2?source=collection_archive---------1-----------------------#2019-09-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/328bc87c82730c94b1c801616833d171.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SkqGJ5uTQdD-y6FZ.png"/></div></div></figure><p id="1d2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最近，我在开发一个Nuxt.js应用程序，不得不为它添加认证。我想到的第一件事是使用vuex在一个州中存储两个字段:</p><ul class=""><li id="39a5" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><strong class="jx io"> isLoggedIn </strong>:表示用户是否登录的布尔值</li><li id="6f68" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io"> loggedInUser </strong>:一个对象，包含我们从服务器获取的会话的用户详细信息</li></ul><p id="d6ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我在页面上添加了一个中间件，我想将访问权限仅限于登录用户。这种方法的思路是正确的，但问题是当你刷新页面时，vuex的状态会丢失。为了处理这个问题，你需要使用<strong class="jx io"> localStorage </strong>，但是只有当你的应用程序运行在<strong class="jx io"> spa </strong>模式下，也就是说，只在客户端运行。如果你在<strong class="jx io">通用</strong>模式(服务器端渲染)下运行你的应用，那么你还需要使用<strong class="jx io"> cookies </strong>并编写一个自定义中间件来检查它是运行在客户端还是服务器端，然后相应地使用<strong class="jx io"> localStorage </strong>或<strong class="jx io"> cookies </strong>。做所有这些将是一个很好的练习来学习一切是如何工作的，但是在我看来，将它添加到一个多人工作的项目中可能不是一个好主意。Nuxt有一个官方支持的模块就是为了这个目的。是<a class="ae lh" href="https://auth.nuxtjs.org/" rel="noopener ugc nofollow" target="_blank">认证模块</a>。在这篇文章中，我将讨论如何将<strong class="jx io">认证模块</strong>集成到你的nuxt应用中，以支持使用<strong class="jx io">电子邮件</strong>和<strong class="jx io">密码</strong>的认证。</p><h1 id="0776" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">服务器API的假设</h1><p id="ea85" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">我们假设API服务器:</p><ul class=""><li id="320e" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">正在<a class="ae lh" href="http://localhost:8080/v1" rel="noopener ugc nofollow" target="_blank">上运行<strong class="jx io">http://localhost:8080/v1</strong>上运行</a></li><li id="ffae" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">使用基于cookie的会话</li><li id="6c97" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">有一个基于JSON的API</li><li id="a533" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">具有以下API端点:</li><li id="0498" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io"> POST /v1/auth/login </strong>:在请求体中接受<strong class="jx io">电子邮件</strong>和<strong class="jx io">密码</strong>并认证用户</li><li id="66e2" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io"> POST /v1/auth/logout </strong>:不需要请求体，从服务器中删除用户会话</li><li id="0b3f" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io"> GET /v1/auth/profile </strong>:返回登录用户的对象</li></ul><h1 id="ba35" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">所涉及步骤的概述</h1><p id="3fba" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">我们将这篇文章分为以下几个步骤:</p><ul class=""><li id="3a16" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">安装<strong class="jx io">轴</strong>和<strong class="jx io">授权</strong>模块</li><li id="a9be" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">在<strong class="jx io"> nuxt.config.js </strong>中需要配置</li><li id="16ae" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">使用来自身份验证模块的状态来检查用户是否登录，并在我们的应用程序组件中访问登录的用户</li><li id="150b" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">使用认证模块通过基于电子邮件和密码的认证来认证用户</li><li id="a6f1" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">使用auth模块提供的中间件将对页面的访问仅限于登录用户</li></ul><h1 id="8d2b" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">步骤1:安装axios和auth模块</h1><p id="baf0" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">打开终端，导航到项目的根目录，然后运行以下命令:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="1feb" class="mu lj in mq b gy mv mw l mx my">npm install @nuxtjs/auth @nuxtjs/axios</span></pre><h1 id="e628" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">步骤2:配置axios和认证模块</h1><p id="6dea" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">打开您的<strong class="jx io"> nuxt.config.js </strong>文件，找到<strong class="jx io"> modules </strong>部分并包含<strong class="jx io"> axios </strong>和<strong class="jx io"> auth </strong>模块并添加它们的配置:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="af69" class="mu lj in mq b gy mv mw l mx my">  modules: [<br/>    '@nuxtjs/axios',<br/>    '@nuxtjs/auth'<br/>  ],<br/><br/>  auth: {<br/>    strategies: {<br/>      local: {<br/>        endpoints: {<br/>          login: {<br/>            url: '/auth/login',<br/>            method: 'post',<br/>            propertyName: false<br/>          },<br/>          logout: { <br/>            url: '/auth/logout', <br/>            method: 'post' <br/>          },<br/>          user: { <br/>            url: '/auth/profile', <br/>            method: 'get', <br/>            propertyName: false <br/>          }<br/>        },<br/>        tokenRequired: false,<br/>        tokenType: false<br/>      }<br/>    }<br/>  },<br/><br/>  axios: {<br/>    baseURL: 'http://localhost:8080/v1',<br/>    credentials: true<br/>  },</span></pre><p id="b12e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的<strong class="jx io"> auth </strong>对象包括配置。<strong class="jx io"> auth </strong>模块支持<strong class="jx io">本地</strong>策略以及<strong class="jx io"> OAuth2 </strong>。因为在我们的例子中我们只有基于电子邮件和密码的认证，所以我们只需要为<strong class="jx io">本地</strong>策略提供配置。</p><p id="4237" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<strong class="jx io">端点</strong>部分，我们为登录、注销和已登录用户配置文件指定了API服务器端点的详细信息，每个配置如下所示:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="bdf5" class="mu lj in mq b gy mv mw l mx my">  user: { <br/>    url: '/auth/profile', <br/>    method: 'get', <br/>    propertyName: false <br/>  }</span></pre><p id="4085" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> url </strong>和<strong class="jx io">方法</strong>应该和你的服务器API一致。这里的<strong class="jx io"> url </strong>需要相对于<strong class="jx io"> baseUrl </strong>配置。<strong class="jx io"> propertyName </strong>告诉auth模块在响应对象中寻找哪个属性。例如，如果您的API服务器对<code class="fe mz na nb mq b">GET /auth/profile</code>的响应如下:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="5eca" class="mu lj in mq b gy mv mw l mx my">{<br/>  "user": {<br/>    "id: 1,<br/>    "name": "Jon Snow",<br/>    "email": "jon.snow@asoiaf.com"<br/>  }<br/>}</span></pre><p id="ebed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，您可以将<strong class="jx io"> propertyName </strong>设置为<code class="fe mz na nb mq b">user</code>，以便在API响应中只查找<code class="fe mz na nb mq b">user</code>键。如果要使用整个API响应，需要将<strong class="jx io"> propertyName </strong>设置为<code class="fe mz na nb mq b">false</code>。</p><p id="da0a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我们的API服务器有基于cookie的会话，所以我们将<strong class="jx io">令牌要求</strong>和<strong class="jx io">令牌类型</strong>设置为<code class="fe mz na nb mq b">false</code>。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="96c6" class="mu lj in mq b gy mv mw l mx my">tokenRequired: false,<br/>tokenType: false</span></pre><p id="4c84" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关于auth模块支持的选项的完整列表，你可以访问他们的官方文档<a class="ae lh" href="https://auth.nuxtjs.org/api/options.html#redirect" rel="noopener ugc nofollow" target="_blank">这里</a></p><p id="79d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上述配置中的<strong class="jx io"> axios </strong>对象用于提供axios配置。这里，我们设置以下属性:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c13f" class="mu lj in mq b gy mv mw l mx my">  axios: {<br/>    baseURL: 'http://localhost:8080/v1',<br/>    credentials: true<br/>  },</span></pre><p id="8c65" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> baseUrl </strong>这是我们API的根Url，我们在应用中使用axios点击的任何相对url都将与此url相关。将<strong class="jx io">凭证</strong>设置为<code class="fe mz na nb mq b">true</code>可以确保我们在所有请求中将认证头发送到API服务器。</p><h1 id="603a" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">第三步:在你的应用中激活vuex商店</h1><p id="cf34" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">为了使用认证模块，我们需要激活应用程序中的<strong class="jx io"> vuex </strong>存储，因为会话相关信息将存储在那里。这可以通过添加任何<strong class="jx io">来完成。js </strong>文件在你的应用程序的<strong class="jx io">存储</strong>目录中，nuxt会用这个文件的名字注册一个命名空间的vuex模块。让我们继续将一个名为<strong class="jx io"> index.js </strong>的空白文件添加到我们应用程序的<strong class="jx io"> store </strong>目录中。不强制添加<strong class="jx io"> index.js </strong>文件。您可以在<strong class="jx io"> store </strong>目录中添加任何文件，例如<strong class="jx io"> xyz.js </strong>，这将在您的应用程序中激活vuex store。</p><p id="ff40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们包含在项目中的auth模块将自动向vuex商店注册一个名为<strong class="jx io"> auth </strong>的命名空间模块。它在状态中有以下字段:</p><ul class=""><li id="f608" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><strong class="jx io">登录</strong>:表示用户是否登录的布尔值</li><li id="a567" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io">用户</strong>:从我们的<strong class="jx io"> nuxt.config.js </strong>文件中配置的<strong class="jx io">auth . strategies . local . user</strong>端点接收的用户对象。</li><li id="3a58" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io">策略</strong>:在我们的例子中，这将是<code class="fe mz na nb mq b">local</code></li></ul><p id="a2b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它还为设置状态添加了必要的突变。所以，即使我们还没有在我们应用程序的<strong class="jx io">存储</strong>目录中创建任何<strong class="jx io"> auth.js </strong>文件，auth模块已经自动处理了这一切。如果有助于理解的话，想象一下，一个名为<strong class="jx io"> auth.js </strong>的文件是由应用程序的<strong class="jx io"> store </strong>目录中的auth模块自动创建的，尽管这个文件实际上并不存在。这意味着在vuex商店的<strong class="jx io"> auth </strong>模块上使用<strong class="jx io"> mapState </strong>将会有效。例如，您可以在任何组件或页面中使用它:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="dbb1" class="mu lj in mq b gy mv mw l mx my">  computed: {<br/>    ...mapState('auth', ['loggedIn', 'user'])<br/>  },</span></pre><p id="8d47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是使用这些属性的组件的完整示例:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="3b81" class="mu lj in mq b gy mv mw l mx my">&lt;template&gt;<br/>  &lt;b-navbar type="dark" variant="dark"&gt;<br/>    &lt;b-navbar-brand to="/"&gt;NavBar&lt;/b-navbar-brand&gt;<br/>    &lt;b-navbar-nav class="ml-auto"&gt;<br/>      &lt;b-nav-item v-if="!loggedIn" to="/login"&gt;Login&lt;/b-nav-item&gt;<br/>      &lt;b-nav-item v-if="!loggedIn" to="/register"&gt;Register&lt;/b-nav-item&gt;<br/>      &lt;b-nav-item v-if="loggedIn" @click="logout"&gt;<br/>        &lt;em&gt;Hello {{ user.name }}&lt;/em&gt;<br/>      &lt;/b-nav-item&gt;<br/>      &lt;b-nav-item v-if="loggedIn" @click="logout"&gt;Logout&lt;/b-nav-item&gt;<br/>    &lt;/b-navbar-nav&gt;<br/>  &lt;/b-navbar&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>import { mapState } from 'vuex'<br/>export default {<br/>  name: 'NavBar',<br/>  computed: {<br/>    ...mapState('auth', ['loggedIn', 'user'])<br/>  },<br/>  methods: {<br/>    async logout() {<br/>      await this.$auth.logout()<br/>      this.$router.push('/login')<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;<br/><br/>&lt;style&gt;&lt;/style&gt;</span></pre><h2 id="36e1" class="mu lj in bd lk nc nd dn lo ne nf dp ls kg ng nh lw kk ni nj ma ko nk nl me nm bi translated">替代方法</h2><p id="a5cd" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">除了使用<strong class="jx io">映射状态</strong>，你也可以通过<strong class="jx io">引用<strong class="jx io">登录</strong>和<strong class="jx io">用户</strong>。$auth.loggedIn </strong>和<strong class="jx io"> this。$auth.user </strong>。因此，在上面的示例中，您可以按如下所述重写计算的属性，它仍然可以正常工作:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="0c76" class="mu lj in mq b gy mv mw l mx my">  computed: {<br/>    loggedIn() {<br/>      return this.$auth.loggedIn<br/>    },<br/>    user() {<br/>      return this.$auth.user<br/>    }<br/>  },</span></pre><h1 id="9507" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">步骤4:使用认证模块认证用户</h1><p id="d80b" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">我们知道如何使用auth模块的API来检查用户是否登录，或者访问登录用户的详细信息。但是我们还没有涉及如何认证用户的部分。这是通过使用<strong class="jx io">这个。$auth.loginWith </strong>方法由您的任何组件或页面中的<strong class="jx io"> auth </strong>模块提供。该函数的第一个参数是策略的名称。在我们的例子中，这将是<code class="fe mz na nb mq b">local</code>。这是一个异步函数，它返回一个承诺。以下是如何使用它的示例:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="b736" class="mu lj in mq b gy mv mw l mx my">  try {<br/>    await this.$auth.loginWith('local', {<br/>      data: {<br/>        email: 'email@xyz.com'<br/>        password: 'password',<br/>      }<br/>    })<br/>    // do something on success<br/>  } catch (e) {    <br/>    // do something on failure <br/>  }</span></pre><p id="edd2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，通常你会有一个带有表单的登录页面，表单中的<strong class="jx io">电子邮件</strong>和<strong class="jx io">密码</strong>字段映射到使用<strong class="jx io"> v-model </strong>的组件的<strong class="jx io">数据</strong>。一旦您提交了表单，您就可以使用<strong class="jx io"> auth </strong>模块运行这个函数来进行身份验证。以下是登录页面的示例:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="14a0" class="mu lj in mq b gy mv mw l mx my">&lt;template&gt;<br/>  &lt;div class="row"&gt;<br/>    &lt;div class="mx-auto col-md-4 mt-5"&gt;<br/>      &lt;b-card&gt;<br/>        &lt;b-form @submit="submitForm"&gt;<br/>          &lt;b-form-group<br/>            id="input-group-1"<br/>            label="Email address:"<br/>            label-for="email"<br/>          &gt;<br/>            &lt;b-form-input<br/>              id="email"<br/>              v-model="email"<br/>              type="email"<br/>              required<br/>              placeholder="Enter email"<br/>            &gt;&lt;/b-form-input&gt;<br/>          &lt;/b-form-group&gt;<br/><br/>          &lt;b-form-group<br/>            id="input-group-2"<br/>            label="Password:"<br/>            label-for="password"<br/>          &gt;<br/>            &lt;b-form-input<br/>              id="password"<br/>              v-model="password"<br/>              type="password"<br/>              required<br/>              placeholder="Enter password"<br/>            &gt;&lt;/b-form-input&gt;<br/>          &lt;/b-form-group&gt;<br/><br/>          &lt;b-button type="submit" variant="primary"&gt;Login&lt;/b-button&gt;<br/>        &lt;/b-form&gt;<br/>      &lt;/b-card&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>export default {<br/>  name: 'LoginPage',<br/>  data() {<br/>    return {<br/>      email: '',<br/>      password: ''<br/>    }<br/>  },<br/>  methods: {<br/>    async submitForm(evt) {<br/>      evt.preventDefault()<br/>      const credentials = {<br/>        email: this.email,<br/>        password: this.password<br/>      }<br/>      try {<br/>        await this.$auth.loginWith('local', {<br/>          data: credentials<br/>        })<br/>        this.$router.push('/')<br/>      } catch (e) {<br/>        this.$router.push('/login')<br/>      }<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;<br/><br/>&lt;style&gt;&lt;/style&gt;</span></pre><p id="2c59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了注销一个已登录的用户，可以使用<strong class="jx io">这个。由<strong class="jx io"> auth </strong>模块提供的$auth.logout </strong>方法。这个不需要任何论证。这里有一个例子:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="96e5" class="mu lj in mq b gy mv mw l mx my">  methods: {<br/>    async logout() {<br/>      await this.$auth.logout()<br/>      this.$router.push('/login')<br/>    }<br/>  }</span></pre><h1 id="0811" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">步骤5:使用认证中间件来限制对某些页面的访问</h1><p id="364f" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">auth 模块还提供中间件来限制登录用户的访问。因此，例如，如果您想将应用程序的<strong class="jx io"> /profile </strong>路由限制为仅允许登录的用户使用，您可以将身份验证中间件添加到<strong class="jx io"> profile.vue </strong>页面，如下所示:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="6b80" class="mu lj in mq b gy mv mw l mx my">export default {<br/>  name: 'ProfilePage',<br/>  middleware: ['auth']<br/>}</span></pre><p id="e503" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关于如何配置您的组件和页面以使用<code class="fe mz na nb mq b">auth</code>中间件的更多细节，您可以在这里查看官方文档<a class="ae lh" href="https://auth.nuxtjs.org/guide/middleware.html" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="590d" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论和参考文献</h1><p id="6f08" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">这是一篇关于带有<strong class="jx io"> NuxtJS </strong>的<strong class="jx io"> axios </strong>和<strong class="jx io"> auth </strong>模块的入门文章。我们只讨论了本地策略，但auth模块也支持<strong class="jx io"> OAuth2 </strong>，并可用于支持使用<strong class="jx io"> Auth0 </strong>、<strong class="jx io">脸书</strong>、<strong class="jx io"> Github </strong>和<strong class="jx io"> Google </strong>的登录。我强烈建议查看认证模块的<strong class="jx io">指南</strong>和<strong class="jx io"> API </strong>部分:</p><p id="b641" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae lh" href="https://auth.nuxtjs.org/" rel="noopener ugc nofollow" target="_blank">https://auth.nuxtjs.org/</a></p><p id="556b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">axios 模块也为我们提供了许多配置选项。虽然我们在这篇文章中没有涉及太多，但是我也强烈建议查看一下官方文档:</p><p id="abc8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae lh" href="https://axios.nuxtjs.org/" rel="noopener ugc nofollow" target="_blank">https://axios.nuxtjs.org/</a></p><p id="bab4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这篇文章有助于理解Nuxt中auth模块的基础知识，并让你更容易自己浏览其余的官方文档。</p><p id="12e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">快乐编码:-)</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><p id="9ca6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="nu">原载于2019年9月29日</em><a class="ae lh" href="http://codingfundas.com/how-to-add-auth-to-your-nuxt-app/index.html" rel="noopener ugc nofollow" target="_blank"><em class="nu">【http://codingfundas.com】</em></a><em class="nu">。</em></p></div></div>    
</body>
</html>