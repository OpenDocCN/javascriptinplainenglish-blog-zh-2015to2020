<html>
<head>
<title>How to Use HTML Canvas to Edit Image Uploads with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用HTML画布通过React编辑图片上传</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-html-canvas-to-edit-image-uploads-with-react-ba1d377ea3ff?source=collection_archive---------0-----------------------#2020-01-25">https://javascript.plainenglish.io/using-html-canvas-to-edit-image-uploads-with-react-ba1d377ea3ff?source=collection_archive---------0-----------------------#2020-01-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0e33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有几个使用canvas来优化、更改、调整大小或仅仅显示用户上传的用例。既然React是我们选择的库，那么让我们深入研究如何创建一个简单而强大的钩子来实现预期的应用程序行为。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dc23fe7ab6d2588889cb9ebc0dd8aa2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pKCEnfBq3J_lXhV4"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk"><a class="ae ky" href="https://i1.wp.com/onaircode.com/wp-content/uploads/2018/03/HTML5-Canvas.jpg?resize=1280%2C640&amp;ssl=1" rel="noopener ugc nofollow" target="_blank">https://i1.wp.com/onaircode.com/wp-content/uploads/2018/03/HTML5-Canvas.jpg?resize=1280%2C640&amp;ssl=1</a></figcaption></figure><p id="6f2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们想象一下，我们正在用React构建某种web应用程序，碰巧我们的应用程序有一个用户资料部分，用户可以在那里添加封面/资料照片，以便个性化他们的资料。</p><p id="3079" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，用户有能力导入他们的个人资料，在这种情况下，我们需要能够复制他们的照片并上传到我们的系统。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="ca98" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们将我们的钩子命名为<strong class="jm io"> useCanvasImage.js </strong></p><p id="6b4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我们需要考虑从某个URL创建一个实际的图像元素，可以是本地的，也可以是外部的。</p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="27df" class="ll lm in lh b gy ln lo l lp lq"><em class="lr">const </em>createImage = (<em class="lr">url</em>) =&gt;<br/>  <em class="lr">new </em>Promise((<em class="lr">resolve</em>, <em class="lr">reject</em>) =&gt; {<br/>    <em class="lr">const </em>image = <em class="lr">new </em>Image();<br/>    image.addEventListener('load', () =&gt; <em class="lr">resolve</em>(image));<br/>    image.addEventListener('error', <em class="lr">error </em>=&gt; <em class="lr">reject</em>(<em class="lr">error</em>));<br/>    image.setAttribute('crossOrigin', 'anonymous');<br/>    image.src = <em class="lr">url</em>;<br/>  });</span></pre><p id="862e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">好了，现在我们有了这个漂亮的工具，我们可以开始构建钩子了。</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="d671" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们在开始时谈到的，我们希望能够降低图像大小和质量。因此，让我们创建几个常数作为默认校正因子。</p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="6fe7" class="ll lm in lh b gy ln lo l lp lq"><em class="lr">const </em>SIZE_REDUCTION_FACTOR = 0.125;<br/><em class="lr">const </em>QUALITY_REDUCTION_FACTOR = 0.4;</span></pre><p id="3f24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还将使用户能够裁剪图像，所以我们将引入带有关于裁剪区域的位置和大小的数据的<strong class="jm io"> pixelCrop </strong>参数。</p><p id="dba6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们准备写钩子了。</p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="5889" class="ll lm in lh b gy ln lo l lp lq"><em class="lr">const </em>createImage = (<em class="lr">url</em>): <em class="lr">any </em>=&gt;<br/>  <em class="lr">new </em>Promise((<em class="lr">resolve</em>, <em class="lr">reject</em>) =&gt; {<br/>    <em class="lr">const </em>image = <em class="lr">new </em>Image();<br/>    image.addEventListener('load', () =&gt; <em class="lr">resolve</em>(image));<br/>    image.addEventListener('error', <em class="lr">error </em>=&gt; <em class="lr">reject</em>(<em class="lr">error</em>));<br/>    image.setAttribute('crossOrigin', 'anonymous');<br/>    image.src = <em class="lr">url</em>;<br/>  });<br/><br/><em class="lr">const </em>getRadianAngle = <em class="lr">degreeValue </em>=&gt; {<br/>  <em class="lr">return </em>(<em class="lr">degreeValue </em>* Math.PI) / 180;<br/>};<br/><br/><em class="lr">const </em>exportFromCanvas = <em class="lr">async </em>(<br/>  <em class="lr">canvas</em>,<br/>  <em class="lr">qualityReductionFactor</em>,<br/>  <em class="lr">exportAsBlob<br/></em>) =&gt; {<br/>  <em class="lr">return exportAsBlob<br/>    </em>? <em class="lr">new </em>Promise(<em class="lr">resolve </em>=&gt; {<br/>        <em class="lr">canvas</em>.toBlob(<br/>          <em class="lr">file </em>=&gt; {<br/>            <em class="lr">resolve</em>(URL.createObjectURL(<em class="lr">file</em>));<br/>          },<br/>          'image/jpeg',<br/>          <em class="lr">qualityReductionFactor<br/>        </em>);<br/>      })<br/>    : <em class="lr">canvas</em>.toDataURL('image/jpeg');<br/>};<br/><br/><em class="lr">const </em>SIZE_REDUCTION_FACTOR = 0.125;<br/><em class="lr">const </em>QUALITY_REDUCTION_FACTOR = 0.4;<br/><br/><em class="lr">export const </em>useCanvasImage = (<br/>  <em class="lr">reductionFactor </em>= SIZE_REDUCTION_FACTOR,<br/>  <em class="lr">qualityReductionFactor </em>= QUALITY_REDUCTION_FACTOR,<br/>  <em class="lr">exportAsBlob </em>= <em class="lr">true<br/></em>) =&gt; {<br/>  <em class="lr">const </em>getImage = <em class="lr">async </em>(<br/>    <em class="lr">imageSrc</em>, <br/>    <em class="lr">pixelCrop </em>= null, <br/>    <em class="lr">rotation </em>= 0<br/>) =&gt; {<br/>    <em class="lr">const </em>image = <em class="lr">await </em>createImage(<em class="lr">imageSrc</em>);<br/>    <em class="lr">const </em>canvas = document.createElement('canvas');<br/>    <em class="lr">const </em>ctx = canvas.getContext('2d') <em class="lr">as any</em>;<br/><br/>    <em class="lr">if </em>(!<em class="lr">pixelCrop</em>) {<br/>      <em class="lr">pixelCrop </em>= {<br/>        width: image.width,<br/>        height: image.height,<br/>        x: 0,<br/>        y: 0,<br/>      };<br/>    }<br/>    <em class="lr">const </em>safeArea = Math.max(image.width, image.height);<br/><br/>    canvas.width = safeArea;<br/>    canvas.height = safeArea;<br/><br/>    ctx.translate(<br/>      safeArea * <em class="lr">reductionFactor</em>,<br/>      safeArea * <em class="lr">reductionFactor<br/>    </em>);<br/>    ctx.rotate(getRadianAngle(<em class="lr">rotation</em>));<br/>    ctx.translate(<br/>      -safeArea * <em class="lr">reductionFactor</em>,<br/>      -safeArea * <em class="lr">reductionFactor<br/>    </em>);<br/>    ctx.drawImage(<br/>      image,<br/>      safeArea * <em class="lr">reductionFactor </em>- image.width * <em class="lr">reductionFactor</em>,<br/>      safeArea * <em class="lr">reductionFactor </em>- image.height * <em class="lr">reductionFactor<br/>    </em>);<br/><br/>    <em class="lr">const </em>data = <em class="lr">ctx</em>.getImageData(0, 0, <em class="lr">safeArea</em>, <em class="lr">safeArea</em>);<br/><br/>    canvas.width = <em class="lr">pixelCrop</em>.width;<br/>    canvas.height = <em class="lr">pixelCrop</em>.height;<br/><br/>    ctx.putImageData(<br/>      data,<br/>      0 -<br/>        safeArea * <em class="lr">reductionFactor </em>+<br/>        image.width * <em class="lr">reductionFactor </em>-<br/>        <em class="lr">pixelCrop</em>.x,<br/>      0 -<br/>        safeArea * <em class="lr">reductionFactor </em>+<br/>        image.height * <em class="lr">reductionFactor </em>-<br/>        <em class="lr">pixelCrop</em>.y<br/>    );<br/><br/>    <em class="lr">return </em>exportFromCanvas(<br/>      canvas,<br/>      <em class="lr">qualityReductionFactor</em>,<br/>      <em class="lr">exportAsBlob<br/>    </em>);<br/>  };<br/><br/>  <em class="lr">return </em>{ getImage };<br/>};</span></pre><p id="7080" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样。我们现在可以在React应用程序中使用钩子了。</p><p id="df0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们首先来看看这样一种情况，我们从其他地方导入一个图像，我们想把它转换成画布，这样我们就可以存储我们自己的副本。要做到这一点，我们需要做的就是为我们的钩子提供外部URL。</p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="caff" class="ll lm in lh b gy ln lo l lp lq">const { getImage } = useCanvasImage()</span><span id="2661" class="ll lm in lh b gy ls lo l lp lq"><em class="lr">const </em>getUserExternalAccount = <em class="lr">async </em>(<em class="lr">url</em>) =&gt; {<br/>  <em class="lr">const </em>{ data } = <em class="lr">await </em>axios.get(url); <br/>  ...<br/>  const imageFromCanvas = <em class="lr">await </em>getImage(data.avatar_url)<br/>  ...<br/>};</span><span id="a39c" class="ll lm in lh b gy ls lo l lp lq">  data.avatar_url = <em class="lr">await </em>getImage(data.avatar_url)<br/><br/>};</span></pre><p id="31ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，就是这么简单！</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="07c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然我们已经解决了这个问题，现在让我们来处理来自本地磁盘的用户上传。为了减少代码，我将使用Ant Design的上传组件。</p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="20cc" class="ll lm in lh b gy ln lo l lp lq"><em class="lr">import </em>React<em class="lr">from </em>'react';<br/><em class="lr">import </em>{ Upload } <em class="lr">from </em>'antd';<br/><br/><em class="lr">import </em>{ useCanvasImage } <em class="lr">from </em>'...';<br/><br/><em class="lr">export const </em>FormUploadField = ({ <em class="lr">onChange </em>}) =&gt; {<br/>  <em class="lr">const </em>{ getImage } = useCanvasImage();</span><span id="d95a" class="ll lm in lh b gy ls lo l lp lq">  const handleBeforeUpload = <em class="lr">file </em>=&gt; {<br/>    <em class="lr">const </em>reader = <em class="lr">new </em>FileReader();<br/>    reader.onload = <em class="lr">async e </em>=&gt; {<br/>      <em class="lr">if </em>(<em class="lr">e</em>.target) {<br/>        <em class="lr">onChange</em>(<em class="lr">await </em>getImage(<em class="lr">e</em>.target.result));<br/>      }<br/>    };<br/>    reader.readAsDataURL(<em class="lr">file</em>);<br/><br/>    <em class="lr">// Prevent upload<br/>    return false</em>;<br/>  }</span><span id="49cf" class="ll lm in lh b gy ls lo l lp lq"><em class="lr">  return </em>(<br/>      &lt;Upload<br/>        <em class="lr">accept</em>={'.png,.jpeg,.jpg'}<br/>        <em class="lr">beforeUpload</em>={handleBeforeUpload}<br/>        <em class="lr">onChange</em>={() =&gt; {}}<br/>      &gt;<br/>      &lt;/Upload&gt;<br/>  );<br/>};</span></pre><p id="7fed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，就是这么简单！</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="4aa9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">自从我们添加了裁剪和旋转功能，现在我们的库实际上可以即插即用地使用令人敬畏的React裁剪库<strong class="jm io"> react-easy-crop。</strong>让我们添加一个图像模型，这样用户可以使用react-easy-crop与画布图像进行交互，然后使用我们强大的钩子创建一个实际的图像。</p><pre class="kj kk kl km gt lg lh li lj aw lk bi"><span id="1be0" class="ll lm in lh b gy ln lo l lp lq"><em class="lr">import </em>React, { useCallback, useState} <em class="lr">from </em>'react';<br/><em class="lr">import </em>Cropper <em class="lr">from </em>'react-easy-crop';<br/><em class="lr">import </em>{ Button, Icon } <em class="lr">from </em>'antd';</span><span id="f00e" class="ll lm in lh b gy ls lo l lp lq"><em class="lr">import </em>{ useCanvasImage } <em class="lr">from </em>'...';<br/><br/><br/><em class="lr">export const </em>ImageModal = ({<br/>  <em class="lr">visible</em>,<br/>  <em class="lr">img</em>,<br/>  <em class="lr">onCrop</em>,<br/>  <em class="lr">onClose</em>,<br/>  <em class="lr">aspectRatio<br/></em>}) =&gt; {<br/>  <em class="lr">const </em>[crop, setCrop] = useState({ x: 0, y: 0 });<br/>  <em class="lr">const </em>[rotation, setRotation] = useState(0);<br/>  <em class="lr">const </em>[zoom, setZoom] = useState(1);<br/>  <em class="lr">const </em>[croppedAreaPixels, setCroppedAreaPixels] = useState(<em class="lr">null</em>);<br/><br/>  <em class="lr">const </em>{ getImage} = useCanvasImage();<br/><em class="lr"><br/>  const </em>onCropComplete = useCallback((<em class="lr">_</em>, <em class="lr">croppedAreaPixels</em>) =&gt; {<br/>    setCroppedAreaPixels(<em class="lr">croppedAreaPixels</em>);<br/>  }, []);<br/><br/>  <em class="lr">const </em>showCroppedImage = useCallback(<em class="lr">async </em>() =&gt; {<br/>    <em class="lr">const </em>croppedImage = <em class="lr">await </em>getImage(<br/>      <em class="lr">img</em>,<br/>      croppedAreaPixels,<br/>      rotation<br/>    );<br/>    <em class="lr">onCrop</em>(croppedImage);<br/>    <em class="lr">onClose</em>();<br/>  }, [croppedAreaPixels, rotation]);<em class="lr"><br/><br/>  if </em>(!<em class="lr">visible </em>|| !<em class="lr">img</em>) {<br/>    <em class="lr">return </em>&lt;&gt;&lt;/&gt;;<br/>  }<br/><br/>  <em class="lr">return </em>(<br/>    &lt;div <em class="lr">className</em>={'modal-wrapper translucent'}&gt;<br/>      &lt;div <em class="lr">className</em>={'image-modal'}&gt;<br/>        &lt;span <em class="lr">className</em>={'modal__close'} <em class="lr">onClick</em>={<em class="lr">onClose</em>}&gt;<br/>          Close &lt;Icon <em class="lr">type</em>="close" /&gt;<br/>        &lt;/span&gt;<br/>        &lt;div <em class="lr">className</em>={'image-modal__cropper'}&gt;<br/>          &lt;Cropper<br/>            <em class="lr">image</em>={<em class="lr">img</em>}<br/>            <em class="lr">crop</em>={crop}<br/>            <em class="lr">rotation</em>={rotation}<br/>            <em class="lr">zoom</em>={zoom}<br/>            <em class="lr">aspect</em>={<em class="lr">aspectRatio</em>}<br/>            <em class="lr">onCropChange</em>={setCrop}<br/>            <em class="lr">onRotationChange</em>={setRotation}<br/>            <em class="lr">onCropComplete</em>={onCropComplete}<br/>            <em class="lr">onZoomChange</em>={setZoom}<br/>          /&gt;<br/>        &lt;/div&gt;<br/>        &lt;div <em class="lr">className</em>={'image-modal__actions'}&gt;<br/>          &lt;Button <em class="lr">onClick</em>={showCroppedImage}&gt;<br/>            Done<br/>          &lt;/Button&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="613d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">是的，就是这么简单！</p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="fa91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lr">希望这篇帖子有所帮助，</em> <strong class="jm io"> <em class="lr">编码快乐！</em>T11】</strong></p><p id="71e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lr">更多内容请看</em><a class="ae ky" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="lr">plain English . io</em></a></p></div></div>    
</body>
</html>