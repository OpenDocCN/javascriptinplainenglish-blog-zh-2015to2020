<html>
<head>
<title>How to create authentication system with Passport</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Passport创建认证系统</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-passport-js-local-authentication-7617a2ef93e8?source=collection_archive---------3-----------------------#2020-08-17">https://javascript.plainenglish.io/how-to-implement-passport-js-local-authentication-7617a2ef93e8?source=collection_archive---------3-----------------------#2020-08-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/deeb9759f0490755ce996a1d198b45b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*157bkozJZjlyY4yjBAtnuw.png"/></div></div></figure><p id="5296" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个分步指南，帮助您使用passport.js创建电子邮件/密码验证。</p><h2 id="9116" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak">先决条件</strong></h2><p id="5b8d" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">为了理解这篇文章，您需要对Node.js、Express.js和MongoDB有一个基本的了解。</p><h2 id="857c" class="kt ku in bd kv kw kx dn ky kz la dp lb kg lc ld le kk lf lg lh ko li lj lk ll bi translated"><strong class="ak">passport . js简介</strong></h2><p id="3d18" class="pw-post-body-paragraph jv jw in jx b jy lm ka kb kc ln ke kf kg lo ki kj kk lp km kn ko lq kq kr ks ig bi translated">根据passport的网站，Passport的定义如下:</p><p id="c5e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lr">“Passport是</em><a class="ae ls" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"><em class="lr">node . js</em></a><em class="lr">的认证中间件。极其灵活和模块化，Passport可以不引人注目地放入任何基于</em><a class="ae ls" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"><em class="lr">Express</em></a><em class="lr">的web应用程序中。一套全面的策略支持使用一个</em> <a class="ae ls" href="http://www.passportjs.org/docs/username-password/" rel="noopener ugc nofollow" target="_blank"> <em class="lr">用户名和密码</em></a><em class="lr"/><a class="ae ls" href="http://www.passportjs.org/docs/facebook/" rel="noopener ugc nofollow" target="_blank"><em class="lr">脸书</em></a><em class="lr"/><a class="ae ls" href="http://www.passportjs.org/docs/twitter/" rel="noopener ugc nofollow" target="_blank"><em class="lr">Twitter</em></a><em class="lr">，以及</em> <a class="ae ls" href="http://www.passportjs.org/packages/" rel="noopener ugc nofollow" target="_blank"> <em class="lr">更多</em> </a> <em class="lr">进行身份验证。”</em></p><p id="fd25" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">是的，passport是一个中间件。从某种意义上说，它是灵活和模块化的，我们可以安装不同的策略来帮助我们完成不同的任务。策略是帮助我们使用用户名和密码或其他OAuth选项执行用户身份验证的工具。如果你不知道策略是做什么的，不要着急，过一会儿我们实施策略之后你就能明白它是做什么的了。</p><p id="81c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经理解了passport.js的功能，让我们开始实现它。为此，让我们在主工作目录中打开终端，并编写以下命令:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5dd1" class="kt ku in ly b gy mc md l me mf">npm init -y</span></pre><p id="6677" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的<code class="fe mg mh mi ly b">-y</code>标志将每个值设置为默认值。</p><p id="5ded" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们安装一些我们需要的包。</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="c93f" class="kt ku in ly b gy mc md l me mf">npm i bcrypt connect-mongo express express-session express-validator</span><span id="f3ba" class="kt ku in ly b gy mj md l me mf">     mongoose passport passport-local</span></pre><p id="8223" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们在主项目目录中创建一个名为<strong class="jx io"> index.js </strong>的文件，并编写以下代码行:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="d6a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">前几行是导入。从第1行到第4行，我们导入了<code class="fe mg mh mi ly b">express</code>、<code class="fe mg mh mi ly b">mongoose</code>、<code class="fe mg mh mi ly b">express-session</code>和<code class="fe mg mh mi ly b">connect-mongo</code>。这里，<code class="fe mg mh mi ly b">express-session</code>的任务将是创建会话；<code class="fe mg mh mi ly b">connect-mongo</code>的任务是帮助我们将会话存储在mongoDB数据库中。注意，在第4行<code class="fe mg mh mi ly b">connect-mongo</code>接受<code class="fe mg mh mi ly b">session</code>作为参数。</p><p id="d530" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们看看第6行，我们从<em class="lr">导入了<code class="fe mg mh mi ly b">MONGO_URI</code>和<code class="fe mg mh mi ly b">SECRET</code>。/config </em>。<code class="fe mg mh mi ly b">MONGO_URI</code>是MongoDB数据库URI，而<code class="fe mg mh mi ly b">SECRET</code>是我们解析cookies时需要的秘密值。我们将在<em class="lr">上工作。/config </em>很快。</p><p id="7516" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们分别在第8行和第9行导入了<code class="fe mg mh mi ly b">passport</code>和<code class="fe mg mh mi ly b">AuthRoute</code>。一会儿我们将讨论<code class="fe mg mh mi ly b">passport</code>和<code class="fe mg mh mi ly b">AuthRoute</code>。</p><p id="5e9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第11行，我们初始化了express应用程序。</p><p id="b041" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，在第13行，我们在<code class="fe mg mh mi ly b">app.use(express.json())</code>的帮助下使用了<code class="fe mg mh mi ly b">express.json()</code>中间件。</p><p id="e82e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，从第14行到第24行，我们编写了在我们的<code class="fe mg mh mi ly b">app</code>中使用<code class="fe mg mh mi ly b">session</code>中间件的代码。该会话接受采用多个选项的键值对。让我们讨论一下这些选择。在第16行，我们有一个<code class="fe mg mh mi ly b">secret</code>选项。这是不言自明的，对不对？在第17行，我们有接受布尔值的<code class="fe mg mh mi ly b">resave</code>选项。我们不想保存该会话。所以，我们把它设置为<code class="fe mg mh mi ly b">false</code>。在第18行，我们有<code class="fe mg mh mi ly b">saveUninitialized</code>选项，它也接受布尔值。我们不想保存未初始化的会话。所以，我们将其设置为<code class="fe mg mh mi ly b">false</code>。然后，在第19行，我们有了<code class="fe mg mh mi ly b">cookie</code>选项，它接受了<code class="fe mg mh mi ly b">secure</code>选项。<code class="fe mg mh mi ly b">secure</code>选项接受布尔值。在我们的例子中，我们将<code class="fe mg mh mi ly b">secure</code>设置为<code class="fe mg mh mi ly b">false</code>。因为我们将在<code class="fe mg mh mi ly b">localhost</code>上工作，所以<code class="fe mg mh mi ly b">secure</code>选项被设置为<code class="fe mg mh mi ly b">false</code>，如果我们将<code class="fe mg mh mi ly b">secure</code>选项设置为<code class="fe mg mh mi ly b">true</code>，我们需要有<a class="ae ls" href="https://." rel="noopener ugc nofollow" target="_blank"><em class="lr">https://</em></a><em class="lr">。</em>记住，当我们在产品中发布我们的应用程序时，我们需要将<code class="fe mg mh mi ly b">secure</code>设置为<code class="fe mg mh mi ly b">true</code>。现在，让我们看看第20行。这里，我们有一个名为<code class="fe mg mh mi ly b">store</code>的选项。<code class="fe mg mh mi ly b">store</code>接收关于数据库的信息，或者仅仅是存储会话的内存地址。在我们的例子中，我们将会话存储在MongoDB中。为此，我们使用了<code class="fe mg mh mi ly b">MongoStore</code>。我们用一个名为<code class="fe mg mh mi ly b">mongooseConnection</code>的选项创建了一个新的<code class="fe mg mh mi ly b">MongoStore</code>实例。<code class="fe mg mh mi ly b">mongooseConnection</code>收进<code class="fe mg mh mi ly b">mongoose.connection</code>。</p><p id="799a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第26行，我们使用<code class="fe mg mh mi ly b">passport.initialize()</code>初始化了在第8行导入的<code class="fe mg mh mi ly b">passport</code>。然后，在第27行，我们编写了代码，告诉passport它必须使用session进行身份验证过程。</p><p id="6195" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第29行，我们在<code class="fe mg mh mi ly b">AuthRoute</code>的帮助下创建了一个端点<em class="lr"> /api/auth </em>。</p><p id="3e78" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第31行，我们编写了存储端口值的代码，我们的服务器将在该端口中运行。我们检查端口是否存在于环境变量中。如果存在，我们存储环境变量的值，否则我们使用默认值5000。</p><p id="92e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从第33行到第36行，我们编写了连接MongoDB数据库的代码。很简单吧？</p><p id="74d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，在第38行，我们编写了在给定的<code class="fe mg mh mi ly b">PORT</code>启动服务器的代码。</p><p id="d203" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然我们已经理解了在<strong class="jx io"> index.js </strong>文件中发生了什么，现在让我们开始处理<em class="lr">。/config。</em>让我们在主项目目录中创建一个名为<em class="lr"> config </em>的目录。之后，让我们在<em class="lr"> config </em>目录下创建三个名为<strong class="jx io"> index.js </strong>、<strong class="jx io"> prod.js </strong>和<strong class="jx io"> dev.js </strong>的文件。</p><p id="c371" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们打开<em class="lr"> config </em>目录下的文件<strong class="jx io"> index.js </strong>，并编写以下代码行:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="0f01" class="kt ku in ly b gy mc md l me mf">if (process.env.NODE_ENV === "production") {</span><span id="4445" class="kt ku in ly b gy mj md l me mf">     module.exports = require("./prod");</span><span id="9103" class="kt ku in ly b gy mj md l me mf">} else {</span><span id="4575" class="kt ku in ly b gy mj md l me mf">     module.exports = require("./dev");</span><span id="cd69" class="kt ku in ly b gy mj md l me mf">} </span></pre><p id="ce95" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的代码或者从<strong class="jx io"> prod.js </strong>或者<strong class="jx io"> dev.js </strong>文件中导出模块。如果<code class="fe mg mh mi ly b">process.env.NODE_ENV</code>等于<code class="fe mg mh mi ly b">"production"</code>，我们将从<strong class="jx io"> prod.js </strong>中导出模块，否则我们将从<strong class="jx io"> dev.js </strong>中导出模块。</p><p id="df20" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们打开<strong class="jx io"> dev.js </strong>文件，并编写以下代码行:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="e23e" class="kt ku in ly b gy mc md l me mf">module.exports = {</span><span id="034d" class="kt ku in ly b gy mj md l me mf">MONGO_URI:    ,// add mongoDB URI here</span><span id="085a" class="kt ku in ly b gy mj md l me mf">SECRET:      ,// add Secret here</span><span id="aadd" class="kt ku in ly b gy mj md l me mf">};</span></pre><p id="a7f0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个文件中，我们导出了<code class="fe mg mh mi ly b">MONGO_URI</code>和<code class="fe mg mh mi ly b">SECRET</code>。我们需要输入它们各自的值，如上面的评论中所提到的。<code class="fe mg mh mi ly b">MONGO_URI</code>接收mongoDB数据库URL，而<code class="fe mg mh mi ly b">SECRET</code>接收一些秘密值。我们可以在<code class="fe mg mh mi ly b">SECRET</code>中输入任何随机的字符串。记住，只有当<code class="fe mg mh mi ly b">NODE_ENV</code>不是<code class="fe mg mh mi ly b">"production"</code>时，这个文件才会被导出。</p><p id="b219" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">既然我们已经处理了<strong class="jx io"> dev.js </strong>文件，现在让我们处理<strong class="jx io"> prod.js </strong>文件。让我们在<strong class="jx io"> prod.js </strong>文件中编写下面几行代码:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="6693" class="kt ku in ly b gy mc md l me mf">module.exports = {</span><span id="5105" class="kt ku in ly b gy mj md l me mf">MONGO_URI: process.env.MONGO_URI,</span><span id="2252" class="kt ku in ly b gy mj md l me mf">SECRET: process.env.SECRET,</span><span id="04d8" class="kt ku in ly b gy mj md l me mf">};</span></pre><p id="5f06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<strong class="jx io"> prod.js </strong>文件内部，我们已经编写了代码来导出<code class="fe mg mh mi ly b">MONGO_URI</code>和<code class="fe mg mh mi ly b">SECRET</code>。<code class="fe mg mh mi ly b">MONGO_URI</code>从我们的环境变量中获取<code class="fe mg mh mi ly b">process.env.MONGO_URI</code>作为值。类似地，<code class="fe mg mh mi ly b">SECRET</code>接受<code class="fe mg mh mi ly b">process.env.SECRET</code>作为值。记住，只有当<code class="fe mg mh mi ly b">NODE_ENV</code>为<code class="fe mg mh mi ly b">"production"</code>时，这些模块才会被导出。所以，在本文中，我们不会花时间在创建环境变量上，好吗？</p><p id="371e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们现在开始研究我们的路线。为此，让我们在主项目目录<strong class="jx io"> <em class="lr">中创建一个名为<em class="lr"> routes </em>的目录。</em> </strong>然后，在<em class="lr"> routes </em>目录下创建一个名为<strong class="jx io"> Auth.js </strong>的文件。现在让我们在文件<strong class="jx io"> Auth.js </strong>中编写以下代码行:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="ae39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">前几行只是导入。在第1行，我们导入了<code class="fe mg mh mi ly b">express</code>。在第2行，我们导入了<code class="fe mg mh mi ly b">passport</code>。在第3行，我们从<code class="fe mg mh mi ly b">express-validator</code>导入了<code class="fe mg mh mi ly b">check</code>和<code class="fe mg mh mi ly b">validationResult </code>。在第5行，我们导入了我们的控制器，即<code class="fe mg mh mi ly b">login</code>、<code class="fe mg mh mi ly b">logout</code>、<code class="fe mg mh mi ly b">me</code>和<code class="fe mg mh mi ly b">signup</code>。</p><p id="a2cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第7行，我们在<code class="fe mg mh mi ly b">express.Router()</code>的帮助下创建了<code class="fe mg mh mi ly b">router</code>。</p><p id="a0fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从第10行到第50行，我们已经为我们的<code class="fe mg mh mi ly b"><em class="lr">api/auth/signup</em></code> <em class="lr"> </em>路线编写了代码。从第12行到第37行，我们已经编写了使用<code class="fe mg mh mi ly b">express-validator</code>验证数据的代码。如果你不知道<code class="fe mg mh mi ly b">express-validator</code>的基本知识，你可能想看看我写的这篇文章。</p><div class="mm mn gp gr mo mp"><a href="https://medium.com/javascript-in-plain-english/getting-started-with-express-validator-fae0bbeeb0f9" rel="noopener follow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd io gy z fp mu fr fs mv fu fw im bi translated">快速验证器入门</h2><div class="mw l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">medium.com</p></div></div><div class="mx l"><div class="my l mz na nb mx nc jt mp"/></div></div></a></div><p id="fd17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们快速浏览一下第12行到第37行。从第13行到第16行，我们编写了代码来指定<code class="fe mg mh mi ly b">name</code>字段的最小长度应该是3。如果最小长度不是3，我们生成一个带有<code class="fe mg mh mi ly b">.withMessage</code>的验证错误消息。从第18行到第21行，我们编写了代码来检查<code class="fe mg mh mi ly b">email</code>字段是否有实际的电子邮件地址。类似地，从第23行到第29行，我们编写了验证密码字段的代码。</p><p id="bd2b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们指定密码的最小长度为8，最大长度为15。我们还指定密码字段应该至少有一个数字和一个特殊字符。从第31行到第36行，我们编写了代码来检查<code class="fe mg mh mi ly b">confirmPassword</code>和<code class="fe mg mh mi ly b">password</code>字段是否有相同的值。在第39行，我们提取并格式化了错误。然后我们检查错误是否存在。如果错误存在，我们向用户发送一组错误消息，在第44行显示状态代码422。如果错误不存在，我们在第46行运行<code class="fe mg mh mi ly b">next()</code>。</p><p id="3629" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后在第49行，我们指定<code class="fe mg mh mi ly b"><em class="lr">/api/auth/signup</em></code> <em class="lr"> </em>路线的控制器应该是<code class="fe mg mh mi ly b">signup</code> <em class="lr">。</em></p><p id="fba2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从第53行到第59行，我们为<code class="fe mg mh mi ly b">/<em class="lr">api/auth/login</em></code> <em class="lr"> </em>端点<em class="lr">创建了一条路线。我们已经使用了<code class="fe mg mh mi ly b">passport.authenticate</code>作为这个端点的中间件。<code class="fe mg mh mi ly b">authenticate</code>接受两个参数。第一个参数接受策略名。在我们的例子中是<code class="fe mg mh mi ly b">local</code>。第二个参数接受一个对象。我们可以看到，我们在第二个论点中使用了一个名为<code class="fe mg mh mi ly b">failureMessage</code>的选项。这个选项的目的是不言自明的，对吗？在第58行，我们指定了<code class="fe mg mh mi ly b">/<em class="lr">api/auth/login</em></code>的控制器是<code class="fe mg mh mi ly b">login</code>。</em></p><p id="7276" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，在第62行，我们为<code class="fe mg mh mi ly b">/api/auth/logout</code>创建了一个端点。我们还指定该路线应该使用<code class="fe mg mh mi ly b">logout</code>作为控制器。</p><p id="3f0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后在第65行，我们为<code class="fe mg mh mi ly b">/api/auth/me</code>路线创建了一个端点。我们也指定了，这条路线应该有<code class="fe mg mh mi ly b">me</code>作为控制器。<code class="fe mg mh mi ly b">me</code>控制器的目的是获取登录用户的信息。</p><p id="a391" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们现在研究模型。为此，让我们在主项目目录中创建一个名为<em class="lr"> models </em>的目录。现在让我们在<em class="lr"> models </em>目录下创建一个名为<strong class="jx io"> User.js </strong>的文件。现在，让我们在文件中编写以下代码行:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="33ec" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第1行，我们导入了<code class="fe mg mh mi ly b">mongoose</code>。然后，在第2行，我们导入了<code class="fe mg mh mi ly b">bcrypt</code>。然后我们从第12行到第25行创建了一个<code class="fe mg mh mi ly b">UserSchema</code>。用户模式有<code class="fe mg mh mi ly b">name</code>、<code class="fe mg mh mi ly b">email</code>、<code class="fe mg mh mi ly b">password</code>字段。这些字段都是<code class="fe mg mh mi ly b">String</code>。</p><p id="3eae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，在第12行，我们使用了<code class="fe mg mh mi ly b">pre("save",...)</code>方法。在第13行，我们将<code class="fe mg mh mi ly b">this</code>存储在<code class="fe mg mh mi ly b">user</code>常量中。之后，在第16行，我们检查了<code class="fe mg mh mi ly b">user</code>的<code class="fe mg mh mi ly b">password</code>字段是否被修改。如果<code class="fe mg mh mi ly b">password</code>字段没有被修改，我们使用<code class="fe mg mh mi ly b">next()</code>否则，我们继续散列<code class="fe mg mh mi ly b">password</code>。我们已经编写了代码来散列密码，并将其存储在第18行的变量<code class="fe mg mh mi ly b">hash</code>中。这里，我们使用了<code class="fe mg mh mi ly b">bcrypt.hash</code>来散列密码。<code class="fe mg mh mi ly b">bcrypt.hash</code>接受纯文本密码作为第一个参数，散列轮作为第二个参数。我们已经指定13为散列回合。然后，我们将散列保存在第19行的<code class="fe mg mh mi ly b">user.password</code>中。之后，我们在第20行使用了<code class="fe mg mh mi ly b">next()</code>。如果在散列密码时出现任何错误，我们已经编写了代码在第22行记录该错误。然后，我们在第23行使用<code class="fe mg mh mi ly b">next(error)</code>。</p><p id="eebe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在第27行，我们使用<code class="fe mg mh mi ly b">UserSchema.methods.comparePassword</code>创建了<code class="fe mg mh mi ly b">comparePassword</code>方法。这种方法将帮助我们比较哈希密码和纯文本密码。在第29行，我们编写了代码来比较纯文本密码(<code class="fe mg mh mi ly b">password</code>)和散列密码(<code class="fe mg mh mi ly b">this.password</code>)，并将其存储在<code class="fe mg mh mi ly b">result</code>变量中。如果密码匹配，则<code class="fe mg mh mi ly b">result</code>为真。然后我们在第31行返回<code class="fe mg mh mi ly b">result</code>。如果在执行这个方法时出现任何错误，我们在第33行记录这个错误。然后，我们在第34行返回<code class="fe mg mh mi ly b">false</code>。我们将在开发passport中间件时使用这种方法。</p><p id="de36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第38行，我们导出了用户模型。</p><p id="bd13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们来研究我们的控制器。为此，让我们在主项目目录中创建一个名为<em class="lr">控制器</em>的目录。之后，让我们在<em class="lr">控制器</em>目录中创建一个名为<strong class="jx io"> AuthController.js </strong>的文件。</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="b417" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第1行，我们已经导入了<code class="fe mg mh mi ly b">User</code>模型。</p><p id="a54d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第3行，您可以看到我们有一个名为<code class="fe mg mh mi ly b">login</code>的函数。在第4行，我们编写了代码，向用户发送用户已经成功登录的消息和状态代码200。记住，登录过程是由<code class="fe mg mh mi ly b">passort.authenticate</code>中间件执行的，这个控制器只有在认证成功时才会被调用。</p><p id="c5ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们来看看第7行到第24行的<code class="fe mg mh mi ly b">signup</code>函数。在第8行，我们存储了来自<code class="fe mg mh mi ly b">req.body</code>的<code class="fe mg mh mi ly b">email</code>、<code class="fe mg mh mi ly b">name</code>、<code class="fe mg mh mi ly b">password</code>的值。在第10行，我们编写了用<code class="fe mg mh mi ly b">email</code>查询<code class="fe mg mh mi ly b">User</code>模型的代码。如果已经存在具有相同<code class="fe mg mh mi ly b">email</code>的用户，我们向该用户发送一条错误消息，表明该用户已经存在(从第16行到第18行)。如果提供的用户<code class="fe mg mh mi ly b">email</code>不存在，我们已经编写了代码在第12行创建一个新用户。之后，我们在第13行使用<code class="fe mg mh mi ly b">user.save()</code>保存用户数据。然后，我们编写代码在第14行向用户发送成功消息。如果在此过程中出现任何错误，我们将向用户发送状态代码500和错误消息(在第22行)。</p><p id="db13" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们看看第26行。在那里，我们有一个函数叫做<code class="fe mg mh mi ly b">logout</code>。记住，当用户请求路由<code class="fe mg mh mi ly b">/api/auth/logout</code>时，它会被调用。在第27行，我们使用<code class="fe mg mh mi ly b">req.logout()</code>将用户注销。注销用户后，我们已经编写了代码，在第28行向用户发送成功消息。</p><p id="0184" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们看看第31行的<code class="fe mg mh mi ly b">me</code>函数。这里，我们检查用户是否在<code class="fe mg mh mi ly b">req.user</code>的帮助下登录。如果<code class="fe mg mh mi ly b">req.user</code>不存在，我们已经编写了代码，在第32行和第33行向用户发送错误消息和状态403。如果<code class="fe mg mh mi ly b">req.user</code>存在，我们发送用户信息(在第35行)。</p><p id="cdfb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从38线到43线，我们已经出口了<code class="fe mg mh mi ly b">login</code>、<code class="fe mg mh mi ly b">signup</code>、<code class="fe mg mh mi ly b">logout</code>和<code class="fe mg mh mi ly b">me</code>。</p><p id="8097" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们来研究一下passport中间件。为此，让我们在主项目目录<em class="lr">中创建一个名为<em class="lr"> services </em>的目录。</em>然后，在<em class="lr">服务</em>目录中创建一个名为<strong class="jx io"> passport.js </strong>的文件，并编写以下代码行:</p><figure class="lt lu lv lw gt jo"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="7a51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，前几行只是导入。在第1行，我们导入了<code class="fe mg mh mi ly b">passport</code>。在第2行，我们导入了<code class="fe mg mh mi ly b">LocalStrategy</code>。在第5行，我们导入了<code class="fe mg mh mi ly b">User</code>模型。</p><p id="01cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第7行，我们使用了<code class="fe mg mh mi ly b">passport.serializeUser</code>。<code class="fe mg mh mi ly b">serializeUser</code>的功能是告诉passport用户的哪些数据应该存储在会话中。该指定数据稍后将被<code class="fe mg mh mi ly b">deserializeUser</code>用于获取用户信息。在第8行，我们使用<code class="fe mg mh mi ly b">done(null, user._id)</code>指定了应该在会话中存储什么值。使用这个命令，我们告诉passport会话应该存储用户的id。</p><p id="bab2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们看看第11行的<code class="fe mg mh mi ly b">deserializeUser</code>。<code class="fe mg mh mi ly b">deserializeUser</code>的功能是从会话中存储的给定用户的信息中接收关于该用户的信息。让我们仔细看看。这里，<code class="fe mg mh mi ly b">deserializUser</code>为我们提供了<code class="fe mg mh mi ly b">id</code>和<code class="fe mg mh mi ly b">done</code>。在第13行，我们通过<code class="fe mg mh mi ly b">id</code>查询了用户模型，并将其存储在<code class="fe mg mh mi ly b">user</code>变量中。如果<code class="fe mg mh mi ly b">user</code>不存在，我们在第15行抛出新的错误。如果用户存在，我们在第17行运行<code class="fe mg mh mi ly b">done(null,user)</code>。</p><p id="f27c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从第22行到第41行，我们设置了本地策略。让我们仔细看看。通过代码，我们告诉<code class="fe mg mh mi ly b">passport</code>通过创建<code class="fe mg mh mi ly b">LocalStrategy</code>的新实例来使用本地策略。在第26行，我们有一个名为<code class="fe mg mh mi ly b">usernameField</code>的字段，它接受<code class="fe mg mh mi ly b">"email"</code>作为值。这用来定义用户名字段应该是<code class="fe mg mh mi ly b">"email"</code>。默认情况下，其值为<code class="fe mg mh mi ly b">"username"</code>。</p><p id="c252" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看第27行的函数。它有<code class="fe mg mh mi ly b">email</code>、<code class="fe mg mh mi ly b">password</code>、<code class="fe mg mh mi ly b">done</code>作为自变量。在第29行，我们通过<code class="fe mg mh mi ly b">email</code>查询了<code class="fe mg mh mi ly b">User</code>模型，并将其存储在<code class="fe mg mh mi ly b">user</code>变量中。如果用户不存在，我们在第31行运行<code class="fe mg mh mi ly b">done(null, false)</code>。之后，在第33行，我们在<code class="fe mg mh mi ly b">comparePassword</code>方法的帮助下比较了<code class="fe mg mh mi ly b">password</code>，这个方法是我们在<code class="fe mg mh mi ly b">User</code>模型中创建的，并存储在<code class="fe mg mh mi ly b">passwordMatch</code>常量中。如果<code class="fe mg mh mi ly b">passwordMatch</code>是<code class="fe mg mh mi ly b">false</code>，我们在第35行运行<code class="fe mg mh mi ly b">done(null, false)</code>。如果密码匹配，我们在第37行运行<code class="fe mg mh mi ly b">done(null,user)</code>。通过使用<code class="fe mg mh mi ly b">done(null,user)</code>,我们告诉passport为这个特定用户创建一个会话。如果在过程中出现任何错误，我们运行第39行的<code class="fe mg mh mi ly b">done(err)</code>。然后我们在第45行输出护照。</p><p id="e2d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你还在纠结<code class="fe mg mh mi ly b">serializeUser</code>或<code class="fe mg mh mi ly b">deserializeUser</code>的问题，你可以在<a class="ae ls" href="https://stackoverflow.com/questions/27637609/understanding-passport-serialize-deserialize" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>上看到这个答案，它可能会给你一个更清晰的画面。</p><p id="729b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这意味着我们现在可以验证我们的用户。</p></div></div>    
</body>
</html>