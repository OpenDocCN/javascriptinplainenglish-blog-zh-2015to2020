<html>
<head>
<title>Everything You Need To Know About Hoisting in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于在JavaScript中提升你需要知道的一切</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/everything-you-need-to-know-about-hoisting-in-javascript-2b6808e92eaa?source=collection_archive---------23-----------------------#2020-12-21">https://javascript.plainenglish.io/everything-you-need-to-know-about-hoisting-in-javascript-2b6808e92eaa?source=collection_archive---------23-----------------------#2020-12-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b3cb" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">了解JavaScript中的变量提升、函数提升和类提升</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3c7744623589cb1d6075db1a025996e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f_Cx_m85y8Bzi87I"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@fr3nks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daniel Frank</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bf90" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了充分了解JavaScript的工作原理，任何开发人员都应该知道其中的一个关键概念。对提升的良好理解肯定有助于减少代码中的运行时异常和意外行为。因此，让我们深入了解一下起重是如何工作的。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="9504" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">什么是吊装？</h1><p id="b721" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">举个例子更容易理解什么是吊装。让我们看看下面的代码片段。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="0b9b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里可以看到<code class="fe mv mw mx my b">printVariable</code>函数在定义之前就被调用了，传递给函数的变量也在定义之前就被使用了。但是，如果您运行代码，您会注意到程序没有抛出任何错误。它只是在控制台中打印出<code class="fe mv mw mx my b">undefined</code>。似乎程序在某种程度上意识到了代码中这些尚未定义的元素。这背后的魔力是提升。</p><p id="fba2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">提升是通过在编译时为代码中的变量声明、类声明和函数声明分配内存位置来实现的。因此，感觉上这些元素被提升到了它们作用域的顶端，这样程序就可以提前知道它们。</p><p id="ae3c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面的代码片段显示了编译器读取上面代码中的元素的顺序，给人一种被举起来的感觉。重要的是要记住，提升与编译器如何通读程序有关，它并不真的改变代码。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="6672" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">可变提升</h1><p id="6746" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">JavaScript中的变量可以用<code class="fe mv mw mx my b">let</code>、<code class="fe mv mw mx my b">const</code>或<code class="fe mv mw mx my b">var</code>来声明，所有的变量声明(不是它们的赋值)都会被提升。然而，提升声明的初始化方式有所不同。对于用<code class="fe mv mw mx my b">var</code>声明的变量，被提升的变量声明用<code class="fe mv mw mx my b">undefined</code>初始化，直到变量后来被赋予它的实际值。因此，当我们试图在实际定义之前访问用<code class="fe mv mw mx my b">var</code>声明的变量时，它会返回<code class="fe mv mw mx my b">undefined</code>。</p><p id="450e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于用<code class="fe mv mw mx my b">let</code>和<code class="fe mv mw mx my b">const</code>声明的变量，提升的声明不会用undefined或任何其他值初始化。因此，当这些变量在定义之前被访问时，程序抛出<code class="fe mv mw mx my b">ReferenceError</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="b8ff" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">功能提升</h1><h2 id="6234" class="mz lx in bd ly na nb dn mc nc nd dp mg lc ne nf mi lg ng nh mk lk ni nj mm nk bi translated">命名函数</h2><p id="92ee" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">在JavaScript中，命名函数的函数声明被挂起。函数声明包括关键字<code class="fe mv mw mx my b">function</code>、分配给函数的名称、输入参数和函数体。它基本上提升了一个功能为了达到它的目的所需要的所有部分。因此，我们可以在实际定义命名函数之前调用它们，并期望它们按照预期的方式运行。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="d5fe" class="mz lx in bd ly na nb dn mc nc nd dp mg lc ne nf mi lg ng nh mk lk ni nj mm nk bi translated">匿名函数/函数表达式</h2><p id="2a44" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">匿名函数可以是箭头函数，也可以是常规函数，通常会赋给变量。因为它们被赋给变量，不像命名函数，只有变量声明被提升。提升变量声明的行为类似于我们之前讨论的变量提升，它们是不可调用的。因此，我们不能在定义匿名函数之前使用它们。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="a000" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">注意，当我们试图调用未用任何东西初始化的被提升的<code class="fe mv mw mx my b">let</code>声明时，程序抛出了一个<code class="fe mv mw mx my b">ReferenceError</code>，当我们调用用<code class="fe mv mw mx my b">undefined</code>初始化的被提升的<code class="fe mv mw mx my b">var</code>声明时，程序抛出了一个<code class="fe mv mw mx my b">TypeError</code>。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="bf50" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">分级提升</h1><h2 id="f71d" class="mz lx in bd ly na nb dn mc nc nd dp mg lc ne nf mi lg ng nh mk lk ni nj mm nk bi translated">类声明</h2><p id="3704" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">JavaScript类声明在编译时被抛出，但是它们没有用任何值初始化。这些声明的行为类似于我们观察到的提升的<code class="fe mv mw mx my b">const</code>和<code class="fe mv mw mx my b">let</code>变量声明。即使JavaScript设法为我们创建的类找到了一个引用，我们也不能在代码中实际定义它之前使用它。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><h2 id="7ae7" class="mz lx in bd ly na nb dn mc nc nd dp mg lc ne nf mi lg ng nh mk lk ni nj mm nk bi translated">类别表达式</h2><p id="d6ae" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">类表达式，类似于函数表达式，赋给变量；因此只有变量声明被提升。因此，我们不能在定义类表达式之前使用它们。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div></figure></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="e314" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">结论</h1><p id="18b5" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated">提升是一个隐喻概念，与JavaScript编译器在编译时如何读取代码有关。为了理解JavaScript如何真正工作并避免意外行为，必须清楚地了解变量声明、函数声明和类声明是如何被提升的。</p><p id="1f0a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢阅读！</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="b347" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">资源</h1><p id="4824" class="pw-post-body-paragraph kt ku in kv b kw mo jo ky kz mp jr lb lc mq le lf lg mr li lj lk ms lm ln lo ig bi translated"><a class="ae ks" href="https://medium.com/javascript-in-plain-english/https-medium-com-javascript-in-plain-english-what-is-hoisting-in-javascript-a63c1b2267a1" rel="noopener">JavaScript中的提升是什么？</a>由<a class="nl nm ep" href="https://medium.com/u/a7b125868703?source=post_page-----2b6808e92eaa--------------------------------" rel="noopener" target="_blank">苏尼尔·桑德胡</a></p><p id="087d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://stackabuse.com/hoisting-in-javascript/" rel="noopener ugc nofollow" target="_blank">在JavaScript中提升</a></p><p id="3bc0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting" rel="noopener ugc nofollow" target="_blank">吊装</a></p><p id="e107" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://www.digitalocean.com/community/tutorials/understanding-hoisting-in-javascript" rel="noopener ugc nofollow" target="_blank">用JavaScript理解吊装</a></p><p id="9c66" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><a class="ae ks" href="https://youtu.be/j-9_15QBW2s" rel="noopener ugc nofollow" target="_blank"> WTF是JavaScript变量提升</a></p></div></div>    
</body>
</html>