<html>
<head>
<title>Better JavaScript — State, and Array vs Array-Like Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的JavaScript——状态、数组和类数组对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/better-javascript-state-and-array-vs-array-like-objects-7396a21c28c0?source=collection_archive---------12-----------------------#2020-11-01">https://javascript.plainenglish.io/better-javascript-state-and-array-vs-array-like-objects-7396a21c28c0?source=collection_archive---------12-----------------------#2020-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/91b290e4d267437da3f29fe8f4c4c38c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oqgYp5_UDtmVNyfK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@vidarnm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Vidar Nordli-Mathisen</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5b18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究改进JavaScript代码的方法。</p><h1 id="d632" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有不必要的状态</h1><p id="3e65" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">API可以分为有状态的和无状态的。</p><p id="4460" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无状态API提供其行为依赖于输入的函数或方法。</p><p id="e6dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们不会改变程序的状态。</p><p id="bd44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们改变了程序的状态，那么代码就更难追踪。</p><p id="380d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">改变状态的程序的一部分是有状态API。</p><p id="32f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无状态API更容易学习和使用，更容易自我记录，更不容易出错。</p><p id="01e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们也更容易测试。</p><p id="8af3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为当我们传入一些输入时，会得到一些输出。</p><p id="b7d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不会因为外在状态而改变。</p><p id="88d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建具有纯函数的无状态API。</p><p id="b93e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当给定一些输入时，纯函数返回一些输出。</p><p id="0dc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当两个不同调用中的输入相同时，我们每次都得到相同的输出。</p><p id="c2ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="77fc" class="mn lc iq mj b gy mo mp l mq mr">c.font = "14px";<br/>c.textAlign = "center";<br/>c.fillText("hello, world!", 75, 25);</span></pre><p id="e6f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c33f" class="mn lc iq mj b gy mo mp l mq mr">c.fillText("14px", "center", "hello, world!", 75, 25);</span></pre><p id="025f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二种情况是一个接受输入的函数，它不像上一个例子那样依赖于<code class="fe ms mt mu mj b">font</code>和<code class="fe ms mt mu mj b">textAlign</code>属性。</p><p id="e6f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无状态API也更加简洁。</p><p id="b423" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有状态API导致了设置对象内部状态的附加语句的激增。</p><h1 id="3d56" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为灵活的接口使用结构化类型</h1><p id="226c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript对象是灵活的，所以我们可以只创建对象文字来创建接口，其中包含我们想要向公众公开的项目。</p><p id="9cdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="debd" class="mn lc iq mj b gy mo mp l mq mr">const book = {<br/>  getTitle() {<br/>    /* ... */<br/>  },<br/>  getAuthor() {<br/>    /* ... */<br/>  },<br/>  toHTML() {<br/>    /* ... */<br/>  }<br/>}</span></pre><p id="a5bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一些方法想公之于众。</p><p id="0cdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是提供这个对象作为任何使用我们库的接口。</p><p id="67fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是创建外部世界可以使用的API的最简单的方法。</p><h1 id="afd3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">区分数组和类似数组的对象</h1><p id="bef0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript有数组和类似数组的对象。</p><p id="584b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们不一样。</p><p id="76f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组有自己的方法，可以按顺序存储数据。</p><p id="3802" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们也是<code class="fe ms mt mu mj b">Array</code>构造函数的一个实例。</p><p id="46ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似数组的对象没有数组方法。</p><p id="e86a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检查某个东西是否是一个数组，我们调用<code class="fe ms mt mu mj b">Array.isArray</code>方法来检查。</p><p id="807f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它返回<code class="fe ms mt mu mj b">false</code>，那么它不是一个数组。</p><p id="6e6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似数组的对象可以是可迭代的，也可以不是。</p><p id="c4a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它们是可迭代的，那么我们可以用spread操作符把它们转换成一个数组。</p><p id="7351" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以将节点列表和<code class="fe ms mt mu mj b">arguments</code>对象转换成一个数组:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e417" class="mn lc iq mj b gy mo mp l mq mr">[...document.querySelectorAll('div')]<br/>[...arguments]</span></pre><p id="7ade" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将NodeList和<code class="fe ms mt mu mj b">arguments</code>对象转换成一个数组。</p><p id="508a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它是一个不可迭代的类似数组的对象，即一个具有非负整数键和一个<code class="fe ms mt mu mj b">length</code>属性的对象，我们可以使用<code class="fe ms mt mu mj b">Array.from</code>方法来进行转换。</p><p id="cbd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1b6d" class="mn lc iq mj b gy mo mp l mq mr">const arr = Array.from({<br/>  0: 'foo',<br/>  1: 'bar',<br/>  length: 2<br/>})</span></pre><p id="357e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">arr</code>就是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1f1f" class="mn lc iq mj b gy mo mp l mq mr">["foo", "bar"]</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/77b598f0ca28c5304d027b16457bcf1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AobOsiJjoy4qOxxR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@michael75?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Michael</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="dfe3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="db8a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们的程序中不应该有不必要的状态。</p><p id="c98e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有，鸭式分型有利于识别类型。</p><p id="026a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该区分数组和类似数组的对象。</p><p id="efc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>