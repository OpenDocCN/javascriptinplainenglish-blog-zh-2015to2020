<html>
<head>
<title>Improving CI Performance (aka How To Save Your Money)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高CI绩效(也称为如何省钱)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/improving-ci-performance-aka-how-to-save-your-money-31ff691360e4?source=collection_archive---------5-----------------------#2020-12-16">https://javascript.plainenglish.io/improving-ci-performance-aka-how-to-save-your-money-31ff691360e4?source=collection_archive---------5-----------------------#2020-12-16</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="43b3" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">如何使用缓存和Docker映像提高CI/CD管道速度</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/01d407e239f9077aa6bdcf1341c8735f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8znrY8Ucn3mKwI_RRap18g.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Reducing the pipeline duration will save your money</figcaption></figure><p id="ad83" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">如今，在一个项目中使用CI是必须的。在大多数情况下，我们必须为依赖项安装、项目构建、测试、部署所需的时间付费。如果你觉得这是你的情况，我会分享我的经验，如何显著提高Angular app(不仅是)CI的性能，并及时降低计费成本。</p><h1 id="3dec" class="ls lt ir bd lu lv lw lx ly lz ma mb mc jx md jy me ka mf kb mg kd mh ke mi mj bi translated">管道改进</h1><h2 id="9a88" class="mk lt ir bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">依赖项安装</h2><p id="fa08" class="pw-post-body-paragraph kw kx ir ky b kz mw js lb lc mx jv le lf my lh li lj mz ll lm ln na lp lq lr ik bi translated">几乎每个管道都是从依赖项安装开始的。为了处理它，通常，我们使用简单的命令<strong class="ky is"> npm install </strong>或<strong class="ky is"> yarn </strong>。在我们的情况下，当我们将它作为CI的一部分运行时，我们检查包锁。如果它与package.json有相同的版本，它将安装锁文件中的所有内容。但是如果package.json有更新的版本，它将重新生成包锁文件。</p><h2 id="0c54" class="mk lt ir bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">npm ci而不是npm安装</h2><p id="2f35" class="pw-post-body-paragraph kw kx ir ky b kz mw js lb lc mx jv le lf my lh li lj mz ll lm ln na lp lq lr ik bi translated">这个命令:<code class="fe nb nc nd ne b">npm ci</code>类似于<code class="fe nb nc nd ne b">npm install</code>，除了它更适合在自动化环境中使用，比如持续集成。通过跳过某些面向用户的功能，它可以比常规的<code class="fe nb nc nd ne b">npm install</code>快得多。此外，它有一个超级酷的特性，如果package.json在没有package-lock的情况下更新，它会报错。所以你可以确定，在不同的构建之间，你总是会有相同版本的依赖关系。普通的npm安装在这种情况下可以安装一个更新的版本并生成新的包——lock . JSON</p><h2 id="e45c" class="mk lt ir bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">带缓存的npm ci</h2><p id="d827" class="pw-post-body-paragraph kw kx ir ky b kz mw js lb lc mx jv le lf my lh li lj mz ll lm ln na lp lq lr ik bi translated">Npm缓存位于<code class="fe nb nc nd ne b">~/.npm</code>中，但是在大多数配置项中，您只能缓存工作目录中的内容。</p><p id="bbdc" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">为了避免这种情况，我们可以使用<strong class="ky is"> npm set cache将缓存目录更改为项目中的本地文件夹。npm </strong>。NPM缓存现在在<code class="fe nb nc nd ne b">./.npm</code>中，所以现在它在CI作业之间缓存。</p><p id="87eb" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">例如，我们使用Gitlab CI，其中我们需要在。gitlab-ci.yml。</p><pre class="kh ki kj kk gu nf ne ng nh aw ni bi"><span id="a5e0" class="mk lt ir ne b gz nj nk l nl nm">cache:</span><span id="9fcf" class="mk lt ir ne b gz nn nk l nl nm">key: ${CI_COMMIT_REF_SLUG}</span><span id="87d4" class="mk lt ir ne b gz nn nk l nl nm">paths:</span><span id="2218" class="mk lt ir ne b gz nn nk l nl nm">- node_modules/</span><span id="219d" class="mk lt ir ne b gz nn nk l nl nm">- .npm/</span></pre><p id="742b" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">之后，我们可以使用下一个命令安装依赖项:</p><pre class="kh ki kj kk gu nf ne ng nh aw ni bi"><span id="bff9" class="mk lt ir ne b gz nj nk l nl nm">npm ci — cache .npm — prefer-offline</span></pre><p id="e202" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">现在，我们的CI使用缓存，并与我们的下一次管道运行共享它。</p><h2 id="4575" class="mk lt ir bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">角度测试速度可以快3倍(直到角度错误存在，该问题在2020年12月14日有效)</h2><p id="1b14" class="pw-post-body-paragraph kw kx ir ky b kz mw js lb lc mx jv le lf my lh li lj mz ll lm ln na lp lq lr ik bi translated">几周前，我发现了一篇关于角度测试的<a class="ae no" href="https://bit.ly/3lTxfD9" rel="noopener ugc nofollow" target="_blank">文章</a>。总的来说，这个问题是关于在每次测试后清理损坏的共享样式。框架在每次测试后添加一个带有共享样式的样式标签。在测试结束时，您可以在测试页面上拥有数千个共享样式的样式标签。</p><p id="1914" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">作者提供了一个临时的解决办法，如何解决这个问题，直到正式修复。</p><p id="0e46" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">您只需在项目中添加几行代码:</p><p id="f987" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">在CLI项目中，打开test.ts并添加以下行:</p><pre class="kh ki kj kk gu nf ne ng nh aw ni bi"><span id="9415" class="mk lt ir ne b gz nj nk l nl nm">import { ɵDomSharedStylesHost } from ‘@angular/platform-browser’;</span><span id="77fc" class="mk lt ir ne b gz nn nk l nl nm">afterEach(() =&gt; {</span><span id="c34a" class="mk lt ir ne b gz nn nk l nl nm">   getTestBed().inject(ɵDomSharedStylesHost).ngOnDestroy();</span><span id="5d08" class="mk lt ir ne b gz nn nk l nl nm">});</span></pre><p id="1a11" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">令人惊讶的是，它确实有效！分享评论对你有帮助吗？</p><h1 id="67ed" class="ls lt ir bd lu lv lw lx ly lz ma mb mc jx md jy me ka mf kb mg kd mh ke mi mj bi translated">Docker改进</h1><p id="cc9c" class="pw-post-body-paragraph kw kx ir ky b kz mw js lb lc mx jv le lf my lh li lj mz ll lm ln na lp lq lr ik bi translated">根据<a class="ae no" href="https://www.jetbrains.com/lp/devecosystem-2020/" rel="noopener ugc nofollow" target="_blank"> 2020 Jetbrains开发者调查</a>，44%的开发者现在使用Docker容器的某种形式的CI和CD。所以我想分享一些常见的最佳实践。它们中的每一个都将提高任何NodeJS应用程序的性能，不管你使用Angular、React、Vue还是vanilla js。</p><h2 id="d86b" class="mk lt ir bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">使用较小的Docker基本图像</h2><p id="6f42" class="pw-post-body-paragraph kw kx ir ky b kz mw js lb lc mx jv le lf my lh li lj mz ll lm ln na lp lq lr ik bi translated">四构建Angular app或简单SSR使用较小的Docker镜像就足够了，比如Slim和Alpine Linux修改。这将减少建设的持续时间，推动和拉动你的CI形象。</p><pre class="kh ki kj kk gu nf ne ng nh aw ni bi"><span id="fb1b" class="mk lt ir ne b gz nj nk l nl nm"><em class="np"># base node image<br/></em>FROM node:12-slim</span></pre><h2 id="1801" class="mk lt ir bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">使用缓存来重建图像和重新运行管道</h2><p id="8c1e" class="pw-post-body-paragraph kw kx ir ky b kz mw js lb lc mx jv le lf my lh li lj mz ll lm ln na lp lq lr ik bi translated">有了配置良好的缓存策略，您几乎可以立即重建您的映像。规则很简单:</p><ol class=""><li id="9efb" class="nq nr ir ky b kz la lc ld lf ns lj nt ln nu lr nv nw nx ny bi translated">在复制源文件之前安装模块</li><li id="fdc0" class="nq nr ir ky b kz nz lc oa lf ob lj oc ln od lr nv nw nx ny bi translated">不要使用标签<code class="fe nb nc nd ne b">LABEL build_number=”123"</code></li></ol><pre class="kh ki kj kk gu nf ne ng nh aw ni bi"><span id="1a93" class="mk lt ir ne b gz nj nk l nl nm"><em class="np"># base node image</em></span><span id="efcf" class="mk lt ir ne b gz nn nk l nl nm">FROM node:12.20.0-slim</span><span id="df83" class="mk lt ir ne b gz nn nk l nl nm">WORKDIR /usr/src/app</span><span id="58d6" class="mk lt ir ne b gz nn nk l nl nm">COPY package*.json ./</span><span id="0381" class="mk lt ir ne b gz nn nk l nl nm">RUN npm ci</span></pre><h2 id="325c" class="mk lt ir bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">使用明确的映像版本，而不是最新版本。</h2><p id="b13b" class="pw-post-body-paragraph kw kx ir ky b kz mw js lb lc mx jv le lf my lh li lj mz ll lm ln na lp lq lr ik bi translated">当您使用最新/稳定的引用作为基础映像时，您不能确切地确定哪个版本将是最新/稳定的。因此，最好使用基础映像的精确版本。</p><pre class="kh ki kj kk gu nf ne ng nh aw ni bi"><span id="a15c" class="mk lt ir ne b gz nj nk l nl nm">FROM node:12.20.0-alpine3.10 as builder</span></pre><h2 id="6908" class="mk lt ir bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated">主持您自己的CI/CD runner</h2><p id="c658" class="pw-post-body-paragraph kw kx ir ky b kz mw js lb lc mx jv le lf my lh li lj mz ll lm ln na lp lq lr ik bi translated">自己的runner，首先能带来更好的网速。GCP/AWS/Digital Ocean的网络带宽比内置的运行器好得多，所以你可以节省安装依赖项的时间。<br/>其次，如果你需要，你可以使用CPU/RAM更好的机器，它会更快，但不确定它能节省你的钱😉。</p><h2 id="e26b" class="mk lt ir bd lu ml mm dn ly mn mo dp mc lf mp mq me lj mr ms mg ln mt mu mi mv bi translated"><strong class="ak">不要在每次运行时安装所有依赖项</strong></h2><p id="7503" class="pw-post-body-paragraph kw kx ir ky b kz mw js lb lc mx jv le lf my lh li lj mz ll lm ln na lp lq lr ik bi translated">如果使用带有预安装依赖项的Docker，可以节省大量时间。至少你可以在Docker镜像中预装CLI之类的全局依赖。但是如果你在一个项目中工作，依赖项很少收到更新。这可能是一个好的选择，预安装所有的依赖项，并将您的源代码复制到正确的文件夹中。之后，您可以运行任何命令，而无需安装依赖项。</p><p id="7fad" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated">就是这样。有了这些简单的建议，你可以大大节省时间和金钱。</p><p id="c361" class="pw-post-body-paragraph kw kx ir ky b kz la js lb lc ld jv le lf lg lh li lj lk ll lm ln lo lp lq lr ik bi translated"><strong class="ky is">感谢阅读！</strong>如果你对构建SEO友好的Angular应用感兴趣，阅读<a class="ae no" href="https://medium.com/javascript-in-plain-english/how-to-make-a-fast-angular-seo-friendly-app-a6d769bfd8d2" rel="noopener">我以前的文章</a>可能会有用。</p></div></div>    
</body>
</html>