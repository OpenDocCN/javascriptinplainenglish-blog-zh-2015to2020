<html>
<head>
<title>How to write a simple React App using Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用钩子编写一个简单的React应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/writing-a-simple-react-app-using-hooks-59fbeb56a40b?source=collection_archive---------14-----------------------#2020-04-17">https://javascript.plainenglish.io/writing-a-simple-react-app-using-hooks-59fbeb56a40b?source=collection_archive---------14-----------------------#2020-04-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e110654e99dde0bc77c59dfeae9e5037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*88EnBSN-5Reht5Yc.jpg"/></div></div></figure><p id="3e7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">自从我开始用React工作以来，我有点困惑，或者更好的说法是，不太适应<strong class="jx io"> React </strong>处理组件的<strong class="jx io"><em class="kt"/></strong>生命周期的方式，直到我发现了<strong class="jx io">钩子！！</strong></p><p id="63fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> React </strong>发布了新的<strong class="jx io">特性</strong>，更好的说法是一个n<strong class="jx io"><em class="kt">ew</em></strong><em class="kt"/><strong class="jx io"><em class="kt">方式</em> </strong>利用<a class="ae ku" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">钩子</strong> </a> <strong class="jx io"> </strong>创建函数组件自<strong class="jx io">版本16.8 </strong>以来，其故事完全不同，更好的一个我相信如此，而且我知道，还有<strong class="jx io">的优点</strong></p><p id="aaa0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们在这里写一些代码，好吗？</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="fb54" class="le lf in la b gy lg lh l li lj">import React from 'react';</span><span id="b757" class="le lf in la b gy lk lh l li lj">const MyApp = () =&gt; {<br/>  <br/>  return (<br/>    &lt;div&gt;<br/>      &lt;p&gt;Welcome to your First component using Hooks!!&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="54e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我知道你在想什么，<strong class="jx io">“就这样？”是的，就像这样简单，还没有钩子，但是仍然有一个更好的方法将类声明为函数组件。</strong></p><p id="cafa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另外，你可能会想，其他的东西呢？像<strong class="jx io"> <em class="kt">道具，状态，</em> </strong> <strong class="jx io"> <em class="kt">组件DidMount </em>，<em class="kt">组件WillUnmount </em> </strong>之类的，我们来深入一下，首先有大量新的<strong class="jx io">钩子</strong>，比如<strong class="jx io">使用状态</strong>，<strong class="jx io">使用效果</strong>，<strong class="jx io">使用上下文</strong>，那些都是基础<strong class="jx io">钩子</strong>，还有</p><h1 id="d95d" class="ll lf in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">使用状态</h1><p id="f2d0" class="pw-post-body-paragraph jv jw in jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">使用<strong class="jx io">使用状态</strong>钩子创建一些状态。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="5ad9" class="le lf in la b gy lg lh l li lj">import React, { <strong class="la io">useState</strong> } from 'react';</span><span id="f15b" class="le lf in la b gy lk lh l li lj">const MyApp = () =&gt; {<br/>  const [count, setCount] = useState(0);<br/>  const [title, setTitle] = useState(<strong class="la io">'Welcome to React hooks!!'</strong>);<br/>  <br/>  return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;{title}&lt;/p&gt;<br/>        &lt;button onClick<strong class="la io">=</strong>{() =&gt; setCount(prevState =&gt; prevState+1)}&gt;<br/>          Count on me!!<br/>        &lt;/button&gt;<br/>        &lt;p&gt;Count: {count}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>  );<br/>};</span></pre><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/cfc42da041fb9b6c974ded0acc6f3e14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/1*znm1p6SwrgQ55kZXrSWjnA.gif"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">As you can see, it’s very straight forward.</figcaption></figure><p id="7501" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在某些情况下，您希望获得以前的状态，例如使用数组。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="6563" class="le lf in la b gy lg lh l li lj">const [listTask, setListTask] = useState([])</span><span id="196b" class="le lf in la b gy lk lh l li lj">setListTask(prevState =&gt; prevState.filter(t =&gt; t !== task))</span></pre><p id="e7e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关于<strong class="jx io"> useState </strong>有一点非常重要，你可能会问，“<strong class="jx io">为什么不使用析构变量？</strong>“相反。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="894b" class="le lf in la b gy lg lh l li lj">setListTask(listTask.filter(t =&gt; t !== task))</span></pre><p id="8bb6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嗯，你可以，但是根据我以前的经验，通过使用<strong class="jx io"> prevState </strong>，它看起来更安全，除了它避免了可变异对象的问题之外，更新从已经处于<strong class="jx io">状态</strong>的东西派生的状态是非常危险的。</p><h1 id="cd7d" class="ll lf in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">使用效果</h1><p id="7180" class="pw-post-body-paragraph jv jw in jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">现在，谈论的是<strong class="jx io"><em class="kt"/></strong><em class="kt"/><strong class="jx io"><em class="kt">周期</em> </strong> <em class="kt">的一个组件</em> <strong class="jx io"> <em class="kt">，</em> <em class="kt"> componentDidMount，componentWillUnmount等。</em> </strong> <em class="kt">对于这个我们有</em><strong class="jx io"><em class="kt">use effect</em></strong>，顾名思义，这是一个副作用，让我们写一些代码来更清楚一些。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="dad2" class="le lf in la b gy lg lh l li lj">import React, { useState, useEffect } from 'react';</span><span id="4cd1" class="le lf in la b gy lk lh l li lj">const MyApp = () =&gt; {<br/>  const [count, setCount] = useState(0);<br/>  const [title, setTitle] = useState('Welcome !!');<br/>  <br/>  <strong class="la io">useEffect(() =&gt; console.log('mounted or updated'));</strong><br/>  <br/>  return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;{title}&lt;/p&gt;<br/>        &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>          Count on me!!<br/>        &lt;/button&gt;<br/>        &lt;p&gt;Count: {count}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>  );<br/>};</span></pre><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/272bad4472562eb896a86e7484b99c28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/1*HvuBnim1UHHnSOdALpcRMQ.gif"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">As you can see, once the component is <strong class="bd ms">mounted</strong> or <strong class="bd ms">update</strong> the <strong class="bd ms">effect</strong> will be triggered.</figcaption></figure><p id="9870" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果你只是想在挂载之后做一些事情呢？</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="01fe" class="le lf in la b gy lg lh l li lj">useEffect(() =&gt; console.log('mounted'), [])</span></pre><p id="901b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者一旦组件被移除？</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="560e" class="le lf in la b gy lg lh l li lj">useEffect(() =&gt; {<br/>  return () =&gt; {<br/>    console.log('will unmount');<br/>  }<br/>}, []);</span></pre><p id="ca74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">太棒了，对吧？但是一旦变量发生变化，我也想做些什么。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="6535" class="le lf in la b gy lg lh l li lj">import React, { useState, useEffect } from 'react';</span><span id="bae4" class="le lf in la b gy lk lh l li lj">const MyApp = () =&gt; {<br/>  const [count, setCount] = useState(0);<br/>  const [title, setTitle] = useState('Welcome to React Hooks!');</span><span id="45d1" class="le lf in la b gy lk lh l li lj">useEffect(() =&gt; {<br/>    console.log(`Count is updated: ${count} `);<br/>  }, [count]);</span><span id="1e5d" class="le lf in la b gy lk lh l li lj">return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;{title}&lt;/p&gt;<br/>        &lt;button <br/>            onClick={() =&gt; setCount(prevState =&gt; prevState + 1)}&gt;<br/>          Count on me!!<br/>        &lt;/button&gt;<br/>        &lt;p&gt;Count: {count}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>  );<br/>};</span></pre><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/8ba4f37a5d0e47cda75d4cd48921c113.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/1*tSaeSNwuQIW2TTDDr14gaQ.gif"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk"><strong class="bd ms">useEffect</strong> will be triggered once <strong class="bd ms">setCount</strong> is called via <strong class="bd ms">onClick.</strong></figcaption></figure><p id="8f30" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您还可以在同一个<strong class="jx io"> useEffect </strong>中放置另一个变量，用于exp。[ <strong class="jx io">算一个，另一个变量</strong> ]，但我并不极力推荐，如果可以避免，那就好了，我建议在单独的<strong class="jx io"> useEffect </strong>中做。</p><p id="9c7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而不是这个:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="da2b" class="le lf in la b gy lg lh l li lj">useEffect(() =&gt; {<br/>    console.log(<strong class="la io">`Count is updated: `</strong>${count});<br/>    console.log(<strong class="la io">`anotherVarivable is updated: `</strong>${<strong class="la io">anotherVarivable</strong>});<br/>}, [<strong class="la io">count, anotherVarivable</strong>]);</span></pre><p id="02f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我宁愿这样做:</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="90a4" class="le lf in la b gy lg lh l li lj">useEffect(() =&gt; {<br/>    console.log(<strong class="la io">`Count is updated: `</strong>${count});<br/>}, [<strong class="la io">count</strong>]);</span><span id="73ed" class="le lf in la b gy lk lh l li lj">useEffect(() =&gt; {<br/>    console.log(<strong class="la io">`anotherVarivable is updated: `</strong>${<strong class="la io">anotherVarivable</strong>});<br/>}, [<strong class="la io">anotherVarivable</strong>]);</span></pre><p id="c343" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不要混淆不同的状态，这会导致非常糟糕和奇怪的事情。 </p><p id="d2e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，一切都很好，甚至更多，总的来说你可以用<strong class="jx io"> useState </strong>处理大多数场景，但是让我们继续。</p><h1 id="5e58" class="ll lf in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">使用上下文</h1><p id="eb0c" class="pw-post-body-paragraph jv jw in jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">如你所知，当你想将<strong class="jx io">数据</strong>从<strong class="jx io">父</strong>传递到<strong class="jx io">子</strong>组件时，会用到上下文，但不是通过props，把它想象成你想申请所有组件，比如<strong class="jx io">主题</strong>、<strong class="jx io">区域设置</strong>、<strong class="jx io">用户ID、</strong>等等。即使它看起来像是全局变量，但其思想是通过使用一些上下文来共享React组件树的公共数据。</p><p id="7cbd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="kt"> P.S </em> </strong> <em class="kt">使用</em><strong class="jx io"><em class="kt">props</em></strong><em class="kt">向子组件传递数据没有错，但是在某些场景中，上下文只是一种更好的方法，你也应该很好地使用它，否则，你可能会遇到麻烦，要注意这一点，还有其他方法可以在没有上下文的情况下工作，比如Redux。</em></p><p id="748c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">幸运的是，我们可以使用<strong class="jx io">用户上下文钩子</strong>来实现这个目的。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="258c" class="le lf in la b gy lg lh l li lj">import React, { createContext, useContext } from 'react';</span><span id="68f1" class="le lf in la b gy lk lh l li lj">// creating my own context.<br/>const MyContext = createContext();</span><span id="f340" class="le lf in la b gy lk lh l li lj">// mock user data, it could come from API, etc.<br/>const user = { userID : 12, userName: 'Test'};</span><span id="95b8" class="le lf in la b gy lk lh l li lj">const MyApp = () =&gt; {<br/>  return (<br/>      &lt;MyContext.Provider value<strong class="la io">=</strong>{user}&gt;<br/>        &lt;Header /&gt;<br/>      &lt;/MyContext.Provider&gt;<br/>  );<br/>}</span><span id="66c2" class="le lf in la b gy lk lh l li lj">const Header = () =&gt; {<br/>  const myContext = useContext(MyContext);<br/>  return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;Welcome to your First component using Hooks!!&lt;/p&gt;<br/>        &lt;p&gt;User: {myContext.userName}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>  );<br/>};</span></pre><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/f53ee1c1562499f71a00f9bbf5d54802.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/1*Zie1zZpehJD_HoMuhv_0xA.gif"/></div></figure><p id="ef90" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面这部分非常重要，用户<strong class="jx io">被设置到一个上下文中，它可以在组件树的任何地方被读取。</strong></p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="5b85" class="le lf in la b gy lg lh l li lj">&lt;MyContext.Provider value<strong class="la io">=</strong>{user}&gt;<br/>  &lt;Header /&gt;<br/>&lt;/MyContext.Provider&gt;</span></pre><p id="356a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以通过在子组件中使用<strong class="jx io"> useContext钩子来访问数据。</strong></p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="2518" class="le lf in la b gy lg lh l li lj">const Header = () =&gt; {<br/>  const myContext = useContext(MyContext);<br/>  return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;Welcome to your First component using Hooks!!&lt;/p&gt;<br/>        &lt;p&gt;User: {myContext.userName}&lt;/p&gt;<br/>      &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="9084" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">同样，没有<strong class="jx io">上下文</strong>也有其他的方法，你可以使用<strong class="jx io"> Redux </strong>来代替，但是你仍然会发现是否使用它。</p><h1 id="262c" class="ll lf in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">好的，一切都好吗？但是让我们把这些碎片放在一起，让它更像一个应用程序。</h1><p id="9523" class="pw-post-body-paragraph jv jw in jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">首先，让我们在这里设置基础知识，然后我们可以前进，顺便说一下，这将是一个<strong class="jx io"> TODO </strong> <strong class="jx io"> task </strong> app。</p><p id="6ee5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个<strong class="jx io"> package.json </strong>文件。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="dc38" class="le lf in la b gy lg lh l li lj">{<br/>  "name": "react-hooks",<br/>  "version": "1.0.0",<br/>  "private": true,<br/>  "dependencies": {<br/>    "react": "^16.13.1",<br/>    "react-dom": "16.12.0"<br/>  },<br/>  "scripts": {<br/>    "start": "react-scripts start",<br/>    "build": "react-scripts build",<br/>    "test": "react-scripts test --env=jsdom",<br/>    "eject": "react-scripts eject"<br/>  },<br/>  "devDependencies": {<br/>    "react-scripts": "latest"<br/>  }<br/>}</span></pre><p id="8609" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个<strong class="jx io"> index.js </strong>文件<strong class="jx io">，</strong>注意这一点，整个app都在一个文件之内，很快就会整理出来，不用麻烦！</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="ada4" class="le lf in la b gy lg lh l li lj">import React, { useEffect, useState } from 'react';<br/>import { render } from 'react-dom';</span><span id="6151" class="le lf in la b gy lk lh l li lj">const MyApp = () =&gt; {<br/>  // create the states<br/>  const [task, setTask] = useState('');<br/>  const [error, setError] = useState('');<br/>  const [listTask, setListTask] = useState([]);</span><span id="3364" class="le lf in la b gy lk lh l li lj">// once listTask changes, clean the task.<br/>  useEffect(() =&gt; setTask(''), [listTask]);</span><span id="675c" class="le lf in la b gy lk lh l li lj">// add a task also verify duplicate task and display an error.<br/>  const addTask = () =&gt; {<br/>    let errorMsg = '';</span><span id="0959" class="le lf in la b gy lk lh l li lj">const taskFound = listTask.find(t =&gt; t === task);</span><span id="b122" class="le lf in la b gy lk lh l li lj">!taskFound<br/>        ? setListTask(listTask.concat(task))<br/>        : errorMsg = 'Task already added!!';</span><span id="d8fa" class="le lf in la b gy lk lh l li lj">setError(errorMsg);<br/>  };</span><span id="5d6e" class="le lf in la b gy lk lh l li lj">// remove task given one.<br/>  const removeTask = task =&gt; {<br/>    setListTask(listTask.filter(t =&gt; t !== task));<br/>  };</span><span id="681e" class="le lf in la b gy lk lh l li lj">// basic CSS.<br/>  const errorStyle = {color: 'red'};<br/>  const taskStyle = {<br/>    width: '12em',<br/>    display: 'flex',<br/>    justifyContent: 'space-between',<br/>    marginBottom: '0.5em'<br/>  };</span><span id="78db" class="le lf in la b gy lk lh l li lj">return (<br/>      &lt;div&gt;<br/>        &lt;label htmlFor="task"&gt;Task:&amp;nbsp;&lt;/label&gt;<br/>        &lt;input id="task" maxLength="15"<br/>               value={task}<br/>               onChange={(e) =&gt; setTask(e.target.value)}/&gt;<br/>        &amp;nbsp;<br/>        &lt;button onClick={() =&gt; addTask()}&gt;Add&lt;/button&gt;</span><span id="f264" class="le lf in la b gy lk lh l li lj">{/* if error is valid than display it */}<br/>        {error &amp;&amp; &lt;p style={errorStyle}&gt;{error}&lt;/p&gt;}</span><span id="f7ba" class="le lf in la b gy lk lh l li lj">&lt;p&gt;Tasks to do:&lt;/p&gt;</span><span id="82fc" class="le lf in la b gy lk lh l li lj">{/* if listTask is valid n has tasks than display them */}<br/>        {<br/>          listTask &amp;&amp; listTask.map((t) =&gt; {<br/>            return (<br/>                &lt;div style={taskStyle} key={t}&gt;<br/>                  &lt;label&gt;{t}&lt;/label&gt;&amp;nbsp;<br/>                  &lt;button onClick={() =&gt; removeTask(t)}&gt;<br/>                    Remove<br/>                  &lt;/button&gt;<br/>                &lt;/div&gt;<br/>            );<br/>          })<br/>        }<br/>      &lt;/div&gt;<br/>  );<br/>};</span><span id="ff0e" class="le lf in la b gy lk lh l li lj">render(&lt;MyApp/&gt;, document.getElementById('root'));</span></pre><p id="c140" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后但同样重要的是<strong class="jx io">index.html</strong></p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="6549" class="le lf in la b gy lg lh l li lj">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>    &lt;meta charset="utf-8"/&gt;<br/>    &lt;meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/&gt;<br/>    &lt;meta name="description" content="React HOOKs!!"/&gt;<br/>    &lt;title&gt;React Hooks App&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;<br/>&lt;div id="root"&gt;&lt;/div&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/2e25391c1146aa448f6156f4c3cc20d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/1*Zt3pM2MR_SrkVNgtW-FsjQ.gif"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Then, we have it!!</figcaption></figure><p id="8bed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，一切看起来都很好，但正如我之前提到的，整个应用程序都放在文件中，这并不好，我们需要重组项目，这意味着，是时候创建<strong class="jx io">自定义挂钩了！！</strong></p><p id="4257" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">把<strong class="jx io">定制钩子</strong>想象成应用程序的<strong class="jx io">引擎</strong>，或者它的soma部分，这个<strong class="jx io">组件</strong>本身<strong class="jx io">应该</strong> <strong class="jx io">而不是</strong>过多的担心数据、处理、一些逻辑等等。让我们把它清理干净。</p><p id="9d27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个名为<strong class="jx io"> useTask.js </strong>的自定义<strong class="jx io">钩子</strong></p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="330a" class="le lf in la b gy lg lh l li lj">import React, { useState, useEffect } from <strong class="la io">'react'</strong>;</span><span id="2d76" class="le lf in la b gy lk lh l li lj">export const useTask = () =&gt; {</span><span id="a817" class="le lf in la b gy lk lh l li lj">  // create the states<br/>  const [task, setTask] = useState(<strong class="la io">''</strong>);<br/>  const [error, setError] = useState(<strong class="la io">''</strong>);<br/>  const [listTask, setListTask] = useState([]);</span><span id="6c46" class="le lf in la b gy lk lh l li lj">  // once listTask changes, clean the task.<br/>  useEffect(() =&gt; setTask(<strong class="la io">''</strong>), [listTask]);</span><span id="b009" class="le lf in la b gy lk lh l li lj">  // add a task also verify duplicate task and display an error.<br/>  const addTask = () =&gt; {<br/>    let errorMsg = <strong class="la io">''</strong>;</span><span id="4069" class="le lf in la b gy lk lh l li lj">    const taskFound = listTask.find(t =&gt; t === task);</span><span id="bf1d" class="le lf in la b gy lk lh l li lj">    !taskFound<br/>        ? setListTask(listTask.concat(task))<br/>        : errorMsg = <strong class="la io">'Task already added!!'</strong>;</span><span id="f287" class="le lf in la b gy lk lh l li lj">    setError(errorMsg);<br/>  };</span><span id="a6a6" class="le lf in la b gy lk lh l li lj">  // remove task given one.<br/>  const removeTask = task =&gt; {<br/>    setListTask(prevState =&gt; prevState.filter(t =&gt; t !== task));<br/>    setError(<strong class="la io">''</strong>);<br/>  };</span><span id="a730" class="le lf in la b gy lk lh l li lj">  return {<br/>    task,<br/>    setTask,<br/>    listTask,<br/>    error,<br/>    addTask,<br/>    removeTask,<br/>  };<br/>};</span></pre><p id="3275" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过这样做，组件会更干净，可读性更好，而且所有涉及任务机制的逻辑现在都是定制钩子的一部分，可以被任何其他组件重用。</p><p id="98aa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，看看MyApp 组件是什么样子的。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="e119" class="le lf in la b gy lg lh l li lj">import React from 'react';<br/>import { render } from 'react-dom';</span><span id="d14e" class="le lf in la b gy lk lh l li lj">import { useTask } from './hooks/useTask';</span><span id="58de" class="le lf in la b gy lk lh l li lj">const MyApp = () =&gt; {<br/>  const {<br/>    task,<br/>    setTask,<br/>    listTask,<br/>    error,<br/>    addTask,<br/>    removeTask<br/>  } = useTask();</span><span id="d027" class="le lf in la b gy lk lh l li lj">// basic CSS.<br/>  const errorStyle = {color: 'red'};<br/>  const taskStyle = {<br/>    width: '12em',<br/>    display: 'flex',<br/>    justifyContent: 'space-between',<br/>    marginBottom: '0.5em'<br/>  };</span><span id="1ebe" class="le lf in la b gy lk lh l li lj">return (<br/>      &lt;div&gt;<br/>        &lt;label htmlFor="task"&gt;Task:&amp;nbsp;&lt;/label&gt;<br/>        &lt;input id="task" maxLength="15"<br/>               value={task}<br/>               onChange={(e) =&gt; setTask(e.target.value)}/&gt;<br/>        &amp;nbsp;<br/>        &lt;button onClick={() =&gt; addTask()}&gt;Add&lt;/button&gt;</span><span id="4676" class="le lf in la b gy lk lh l li lj">{/* if error is valid than display it */}<br/>        {error &amp;&amp; &lt;p style={errorStyle}&gt;{error}&lt;/p&gt;}</span><span id="631c" class="le lf in la b gy lk lh l li lj">&lt;p&gt;Tasks to do:&lt;/p&gt;</span><span id="ced3" class="le lf in la b gy lk lh l li lj">{/* if listTask is valid n has tasks than display them */}<br/>        {<br/>          listTask &amp;&amp; listTask.map((t) =&gt; {<br/>            return (<br/>                &lt;div style={taskStyle} key={t}&gt;<br/>                  &lt;label&gt;{t}&lt;/label&gt;&amp;nbsp;<br/>                  &lt;button onClick={() =&gt; removeTask(t)}&gt;<br/>                    Remove<br/>                  &lt;/button&gt;<br/>                &lt;/div&gt;<br/>            );<br/>          })<br/>        }<br/>      &lt;/div&gt;<br/>  );<br/>};</span><span id="bc9d" class="le lf in la b gy lk lh l li lj">render(&lt;MyApp/&gt;, document.getElementById('root'));</span></pre><p id="f5b7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但仍然有一些重构的空间，所以，首先让我们创建一个名为<strong class="jx io"> AddTask.js </strong>的组件，并移动<strong class="jx io">标签</strong>、<strong class="jx io">输入</strong>和添加<strong class="jx io">按钮</strong>。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="d2eb" class="le lf in la b gy lg lh l li lj">import React from <strong class="la io">'react'</strong>;</span><span id="e50b" class="le lf in la b gy lk lh l li lj">export const AddTask = props =&gt; {<br/>  const {task, setTask, addTask} = props;</span><span id="eb3d" class="le lf in la b gy lk lh l li lj">  return (<br/>      &lt;div&gt;<br/>        &lt;label htmlFor<strong class="la io">="task"</strong>&gt;Task:&amp;nbsp;&lt;/label&gt;<br/>        &lt;input id<strong class="la io">="task" </strong>maxLength<strong class="la io">="15"<br/>               </strong>value<strong class="la io">=</strong>{task}<br/>               onChange<strong class="la io">=</strong>{(e) =&gt; setTask(e.target.value)}/&gt;<br/>        &amp;nbsp;<br/>        &lt;button onClick<strong class="la io">=</strong>{() =&gt; addTask()}&gt;Add&lt;/button&gt;<br/>      &lt;/div&gt;<br/>  );</span><span id="0540" class="le lf in la b gy lk lh l li lj">};</span></pre><p id="a55f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们需要创建另一个名为<strong class="jx io"> ListTask.js </strong>的组件，并从列表任务中移除所有部分。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="141b" class="le lf in la b gy lg lh l li lj">import React from <strong class="la io">'react'</strong>;</span><span id="2d45" class="le lf in la b gy lk lh l li lj">export const ListTask = props =&gt; {<br/>  const {listTask, removeTask} = props;</span><span id="399c" class="le lf in la b gy lk lh l li lj">  // task list css.<br/>  const taskStyle = {<br/>    width: <strong class="la io">'12em'</strong>,<br/>    display: <strong class="la io">'flex'</strong>,<br/>    justifyContent: <strong class="la io">'space-between'</strong>,<br/>    marginBottom: <strong class="la io">'0.5em'<br/>  </strong>};</span><span id="bb34" class="le lf in la b gy lk lh l li lj">  return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;Tasks to do:&lt;/p&gt;</span><span id="3ca5" class="le lf in la b gy lk lh l li lj">        {<br/>          listTask &amp;&amp; listTask.map(task =&gt; {<br/>            return (<br/>                &lt;div style<strong class="la io">=</strong>{taskStyle} key<strong class="la io">=</strong>{task}&gt;<br/>                  &lt;label&gt;{task}&lt;/label&gt;&amp;nbsp;<br/>                  &lt;button onClick<strong class="la io">=</strong>{() =&gt; removeTask(task)}&gt;<br/>                    Remove<br/>                  &lt;/button&gt;<br/>                &lt;/div&gt;<br/>            );<br/>          })<br/>        }<br/>      &lt;/div&gt;<br/>  );</span><span id="7088" class="le lf in la b gy lk lh l li lj">};</span></pre><p id="b0be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很酷不是吗？，现在好多了，所以，让我们再看看<strong class="jx io">的MyApp </strong>，看看变化后的样子。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="17cc" class="le lf in la b gy lg lh l li lj">import React from 'react';<br/>import { render } from 'react-dom';</span><span id="464e" class="le lf in la b gy lk lh l li lj">import { useTask } from './hooks';<br/>import { AddTask, ListTask } from './component';</span><span id="3a6b" class="le lf in la b gy lk lh l li lj">const MyApp = () =&gt; {<br/>  const {<br/>    task,<br/>    setTask,<br/>    listTask,<br/>    error,<br/>    addTask,<br/>    removeTask<br/>  } = useTask();</span><span id="7553" class="le lf in la b gy lk lh l li lj">  // error css<br/>  const errorStyle = {color: 'red'};</span><span id="f370" class="le lf in la b gy lk lh l li lj">  return (<br/>      &lt;div&gt;</span><span id="c608" class="le lf in la b gy lk lh l li lj">        &lt;AddTask<br/>            task={task}<br/>            setTask={setTask}<br/>            addTask={addTask}<br/>        /&gt;</span><span id="1328" class="le lf in la b gy lk lh l li lj">        {/* if error is valid than display it */}<br/>        {error &amp;&amp; &lt;p style={errorStyle}&gt;{error}&lt;/p&gt;}</span><span id="00e5" class="le lf in la b gy lk lh l li lj">        &lt;ListTask<br/>            listTask={listTask}<br/>            removeTask={removeTask}<br/>        /&gt;</span><span id="6b66" class="le lf in la b gy lk lh l li lj">      &lt;/div&gt;<br/>  );<br/>};</span><span id="997b" class="le lf in la b gy lk lh l li lj">render(&lt;MyApp/&gt;, document.getElementById('root'));</span></pre><p id="0ce1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">确实非常好，但仍然有一些事情留下来，通常<strong class="jx io"> index.js </strong>是应用程序的入口点，并不做那么多，所以让我们创建一个名为<strong class="jx io"> TaskApp.js、</strong>的主要组件，这样MyApp就不会再被使用了。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="d06e" class="le lf in la b gy lg lh l li lj">import React from <strong class="la io">'react'</strong>;<br/>import { render } from <strong class="la io">'react-dom'</strong>;</span><span id="861f" class="le lf in la b gy lk lh l li lj">import { useTask } from <strong class="la io">'./hooks'</strong>;<br/>import { AddTask, ListTask } from <strong class="la io">'./component'</strong>;</span><span id="6bc9" class="le lf in la b gy lk lh l li lj">export const TaskApp = () =&gt; {<br/>  const {<br/>    task,<br/>    setTask,<br/>    listTask,<br/>    error,<br/>    addTask,<br/>    removeTask<br/>  } = useTask();</span><span id="2afa" class="le lf in la b gy lk lh l li lj">  // error css<br/>  const errorStyle = {color: <strong class="la io">'red'</strong>};</span><span id="7913" class="le lf in la b gy lk lh l li lj">  return (<br/>      &lt;div&gt;</span><span id="b29b" class="le lf in la b gy lk lh l li lj">        &lt;AddTask<br/>            task<strong class="la io">=</strong>{task}<br/>            setTask<strong class="la io">=</strong>{setTask}<br/>            addTask<strong class="la io">=</strong>{addTask}<br/>        /&gt;</span><span id="894a" class="le lf in la b gy lk lh l li lj">        {/* if error is valid than display it */}<br/>        {error &amp;&amp; &lt;p style<strong class="la io">=</strong>{errorStyle}&gt;{error}&lt;/p&gt;}</span><span id="2c5f" class="le lf in la b gy lk lh l li lj">        &lt;ListTask<br/>            listTask<strong class="la io">=</strong>{listTask}<br/>            removeTask<strong class="la io">=</strong>{removeTask}<br/>        /&gt;</span><span id="cf3f" class="le lf in la b gy lk lh l li lj">      &lt;/div&gt;<br/>  );<br/>};</span></pre><p id="5319" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，<strong class="jx io"> index.js </strong>将仅在此处恢复。</p><pre class="kv kw kx ky gt kz la lb lc aw ld bi"><span id="72ad" class="le lf in la b gy lg lh l li lj">import React from <strong class="la io">'react'</strong>;<br/>import { render } from <strong class="la io">'react-dom'</strong>;</span><span id="023c" class="le lf in la b gy lk lh l li lj">import { TaskApp } from <strong class="la io">'./TaskApp'</strong>;</span><span id="a3a4" class="le lf in la b gy lk lh l li lj">render(&lt;TaskApp/&gt;, document.getElementById(<strong class="la io">'root'</strong>));</span></pre><p id="1298" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就这样，还在工作，但是更干净，更容易维护。</p><figure class="kv kw kx ky gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/a43aea18c7a95d47304f32608d1bbdb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2w_iUXcX_yMuSzYce_qcfw.png"/></div></div></figure><p id="0bd6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你有任何问题或疑问，让我知道，我很想知道其他方式与挂钩。</p><p id="c004" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里查看运行<a class="ae ku" href="https://gbrivate.github.io/react-hooks/" rel="noopener ugc nofollow" target="_blank">的应用</a>以及Github <a class="ae ku" href="https://github.com/gbrivate/react-hooks" rel="noopener ugc nofollow" target="_blank">库</a></p><h2 id="3271" class="le lf in bd lm mv mw dn lq mx my dp lu kg mz na ly kk nb nc mc ko nd ne mg nf bi translated"><strong class="ak">用简单英语写的JavaScript的注释</strong></h2><p id="2470" class="pw-post-body-paragraph jv jw in jx b jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko mm kq kr ks ig bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae ku" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="jx io">AI in Plain English</strong></a><a class="ae ku" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="jx io">UX in Plain English</strong></a><a class="ae ku" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="jx io">Python in Plain English</strong></a><strong class="jx io"/>——谢谢，继续学习！</p><p id="777e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae ku" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">submissions @ plain English . io</strong></a><strong class="jx io"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>