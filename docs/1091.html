<html>
<head>
<title>A simple Node.js Docker workflow</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">简单的Node.js Docker工作流</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-simple-node-js-docker-workflow-2ee5db1960a7?source=collection_archive---------4-----------------------#2020-01-28">https://javascript.plainenglish.io/a-simple-node-js-docker-workflow-2ee5db1960a7?source=collection_archive---------4-----------------------#2020-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e9564a2849b5b5ffd187e3fa42cd6188.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pYW82GmmN1DauP5kWkXttA.png"/></div></div></figure><p id="d126" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Docker是一个很棒的工具，可以帮助开发人员以标准化的方式更有效地构建、部署和运行应用程序。我们可以在与生产中运行的应用程序相同的环境中进行开发。通过在本地进行相同的设置，可以加快调试速度，甚至防止即将出现的错误。在<a class="ae kw" href="https://dev.to/blacksonic/frontend-development-with-docker-simplified-254i" rel="noopener ugc nofollow" target="_blank">之前的文章</a>中，我已经写了一个使用Docker进行前端开发的简化方法，现在我将展示同样的方法用于Node.js项目。</p><h1 id="7c29" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">应用程序</h1><p id="572c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">作为一个例子，我组装了一个基本的应用程序，并试图让它尽可能简单。如果你喜欢自己试验，你可以<a class="ae kw" href="https://github.com/blacksonic/node-docker-workflow" rel="noopener ugc nofollow" target="_blank">克隆库</a>并开始修改，看看效果如何。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="d0d0" class="mj ky iq mf b gy mk ml l mm mn">// src/index.js<br/>'use strict';<br/>const express = require('express');<br/>const port = process.env.PORT || 3000;<br/>const app = express();<br/><br/>app.get('/', (req, res) =&gt; res.send('Hello World!'));<br/><br/>app.listen(port, () =&gt; console.log(`App listening on port ${port}!`));</span></pre><p id="bc3e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该应用程序由一个文件组成，它启动一个web服务器并响应请求。我使用了众所周知的<a class="ae kw" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express web框架</a>来响应请求，并通过环境变量来配置端口。我们需要它是可配置的，因为这个端口可以从开发中使用的端口改变。</p><h1 id="155d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">发展</h1><p id="fe65" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">为了发展，我们希望</p><ul class=""><li id="c90d" class="mo mp iq ka b kb kc kf kg kj mq kn mr kr ms kv mt mu mv mw bi translated">与生产环境相同的环境</li><li id="43d4" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">轻松设置环境</li><li id="cf07" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">在浏览器中查看文件自动更改</li><li id="8584" class="mo mp iq ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated">在编辑器中使用代码完成</li></ul><p id="dd9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了完成所有需求，我们将使用Docker和Docker Compose为开发和生产创建一个相同的容器，并使用<a class="ae kw" href="https://nodemon.io/" rel="noopener ugc nofollow" target="_blank"> Nodemon包</a>在文件更改时重启应用程序。</p><p id="ca58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过将启动脚本从<code class="fe nc nd ne mf b">node src/index.js</code>更改为<code class="fe nc nd ne mf b">nodemon --watch src src/index.js</code>来重启文件更改。它的功能和以前一样，只是在<code class="fe nc nd ne mf b">src</code>文件夹中的文件发生变化时会重新启动。</p><p id="103c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们进入更令人兴奋的部分，我们在本地旋转容器。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f344" class="mj ky iq mf b gy mk ml l mm mn"># docker-compose.yml<br/>version: "3"<br/><br/>services:<br/>  server:<br/>    image: node:12<br/>    working_dir: /app<br/>    volumes:<br/>      - ./:/app<br/>    ports:<br/>      - 3000:3000<br/>    environment:<br/>      - PORT=3000<br/>    command: sh -c "npm install &amp;&amp; npm run dev"</span></pre><p id="bad0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能注意到的第一件事是Docker合成配置文件不包含定制的Docker图像。大多数情况下，我们不需要它，但是如果有必要，我们总是可以用<code class="fe nc nd ne mf b">build</code>属性来添加它。在我们的设置中，我们将使用节点基础映像。</p><p id="75a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我选择用<code class="fe nc nd ne mf b">volumes</code>双向同步文件，而不是复制Dockerfile文件中的文件。这比复制文件更耗费资源，但是安装的NPM软件包出现在提供代码完成功能的主机上，这一事实使它成为一个显而易见的方法。</p><p id="e1d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不应该想当然:我们设置可配置的环境变量。在我们的例子中，端口是可配置的，服务器在这里监听传入的呼叫。在配置中设置它使它更具可读性，因为它紧挨着<code class="fe nc nd ne mf b">ports</code>定义:在这里我们声明我们希望在主机上公开哪些内部容器端口。</p><p id="888d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一步是用<code class="fe nc nd ne mf b">command</code>属性启动应用程序。我们总是运行<code class="fe nc nd ne mf b">npm install</code>命令，这可能会对启动性能产生一点影响，但也确保了容器运行时依赖项仍然是最新的。您可以从<code class="fe nc nd ne mf b">command</code>中删除它，但是这样，您必须在启动容器之前或者当<code class="fe nc nd ne mf b">package.json</code>文件的内容改变时手动运行它。</p><h1 id="cc80" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">生产</h1><p id="064b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们可以愉快地使用前面的设置来开发应用程序，但是我们还必须创建一个可部署到生产环境的容器。此时，不可能进一步推迟自定义docker映像的创建。让我们看看它如何成为最优的。</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7810" class="mj ky iq mf b gy mk ml l mm mn"># Dockerfile<br/>FROM node:12 AS base<br/>WORKDIR /app<br/>COPY package*.json ./<br/>RUN npm ci --only=production<br/><br/>FROM node:12-alpine<br/>WORKDIR /app<br/>COPY --from=base /app .<br/>COPY . .<br/><br/>EXPOSE 3000<br/><br/>CMD npm start</span></pre><p id="1b61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该文件从声明起始图像开始，该图像称为“base”。命名它是不必要的，但是在使用Dockers <a class="ae kw" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank">多阶段构建</a>时可以澄清很多。</p><p id="9877" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们必须只复制包文件，因为它们是安装用于开发的相同版本所必需的。命令<code class="fe nc nd ne mf b">npm install</code>变为<code class="fe nc nd ne mf b">npm ci --only=production</code>。它有两个主要区别。<code class="fe nc nd ne mf b">npm ci</code>安装锁文件中定义的相同版本，并且不像<code class="fe nc nd ne mf b">npm install</code>那样尝试更新它们。第二个是跳过安装<code class="fe nc nd ne mf b">devDependencies</code>的<code class="fe nc nd ne mf b">--only=production</code>标志，我们在生产中不需要。</p><p id="2411" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过跳过<code class="fe nc nd ne mf b">devDependencies</code>从图像中节省了很多宝贵的空间，但是图像仍然很重要(大约500 MB)。Node有一个小得多的映像叫做alpine，它只包含必要的包:更少的包意味着更少的磁盘空间、内存、更好的速度和安全性。包安装有时需要标准映像，但是使用Docker多阶段构建，我们可以在包安装后切换到较小的映像，并复制上一步中的包。这样，我们得到了两个世界的好处:小的映像大小和安装任何东西的能力。</p><p id="977e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们用<code class="fe nc nd ne mf b">docker images</code>来看图像的大小，可以看到它缩小到了100 MB以下。图像准备好了；我们可以将其部署到生产中。</p><h1 id="ba4c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">摘要</h1><p id="dd43" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">起初，我并不觉得我为什么要用另一种开发所必需的技术来复杂化我的日常生活。其他人不得不向我展示，使用带有<code class="fe nc nd ne mf b">volumes</code>的同步文件夹，我将无法区分在我的本地机器上开发。之后，我可以在我的本地计算机上测试相同的基础设施，他们说服我每天使用Docker。我希望上面的工作流程能帮助其他人也了解爱Docker的好处。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="f4fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nm">原载于2020年1月28日</em><a class="ae kw" href="https://dev.to/blacksonic/a-simple-node-js-docker-workflow-18dh" rel="noopener ugc nofollow" target="_blank"><em class="nm">https://dev . to</em></a><em class="nm">。</em></p></div></div>    
</body>
</html>