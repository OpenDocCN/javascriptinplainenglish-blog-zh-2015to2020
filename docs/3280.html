<html>
<head>
<title>Cycle Detection of A Linked List in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中链表的循环检测</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/cycle-detection-in-javascrip-5173792a1ded?source=collection_archive---------8-----------------------#2020-09-15">https://javascript.plainenglish.io/cycle-detection-in-javascrip-5173792a1ded?source=collection_archive---------8-----------------------#2020-09-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8f94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">循环检测是在迭代函数值序列中寻找循环的算法问题，例如，经典的链表循环检测问题。有不同解决办法。对于下面的<a class="ae ki" href="https://leetcode.com/problems/linked-list-cycle/" rel="noopener ugc nofollow" target="_blank"> <em class="kj"> Leetcode </em> </a>例子，我来解释真解。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi kk"><img src="../Images/13f9ce4d2b019b4728897415d9ee5713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*Vweo8HbrWvrDapXTNvXQIg.png"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Example of Floyd’s algorithm</figcaption></figure></div><div class="ab cl kw kx hr ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ig ih ii ij ik"><p id="5ac1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">给定一个链表的头<code class="fe ld le lf lg b">head</code>，判断该链表中是否有循环。</p><p id="bb90" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果链表中有某个节点可以通过继续跟随<code class="fe ld le lf lg b">next</code>指针再次到达，那么链表中就存在循环。在内部，<code class="fe ld le lf lg b">pos</code>用来表示tail的<code class="fe ld le lf lg b">next</code>指针所连接的节点的索引。<strong class="jm io">注意</strong> <code class="fe ld le lf lg b"><strong class="jm io">pos</strong></code> <strong class="jm io">没有作为参数</strong>传递。</p><p id="4ded" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果链表中有循环，则返回<code class="fe ld le lf lg b">true</code> <em class="kj">。否则，返回<code class="fe ld le lf lg b">false</code>。</em></p><pre class="kl km kn ko gt lh lg li lj aw lk bi"><span id="16d2" class="ll lm in lg b gy ln lo l lp lq"><strong class="lg io">Example 1: </strong></span><span id="f2e5" class="ll lm in lg b gy lr lo l lp lq"><strong class="lg io">Input:</strong> head = [3,2,0,-4], pos = 1<br/><strong class="lg io">Output:</strong> true<br/><strong class="lg io">Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/220d96c77811c2d879cb6415abb8e69b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1062/format:webp/1*CsHDdNpzUEBm1ZkNx-p8uw.png"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Example 1</figcaption></figure><pre class="kl km kn ko gt lh lg li lj aw lk bi"><span id="993d" class="ll lm in lg b gy ln lo l lp lq"><strong class="lg io">Example 2:</strong></span><span id="2921" class="ll lm in lg b gy lr lo l lp lq"><strong class="lg io">Input:</strong> head = [1,2], pos = 0<br/><strong class="lg io">Output:</strong> true<br/><strong class="lg io">Explanation:</strong> There is a cycle in the linked list, where the tail connects to the 0th node.</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/bf4b26603a4f95ee787056a96ac61642.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*gAcCdLdT-2AXNivFtbsRlQ.png"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Example 2</figcaption></figure><pre class="kl km kn ko gt lh lg li lj aw lk bi"><span id="504f" class="ll lm in lg b gy ln lo l lp lq"><strong class="lg io">Example 3:</strong></span><span id="2720" class="ll lm in lg b gy lr lo l lp lq"><strong class="lg io">Input:</strong> head = [1], pos = -1<br/><strong class="lg io">Output:</strong> false<br/><strong class="lg io">Explanation:</strong> There is no cycle in the linked list.</span></pre><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/42e3c93f08cd4a8fcbe681d55397e7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:130/format:webp/1*-u65AxoHkEtfuVnv0o7gMQ.png"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Example 3</figcaption></figure><p id="43c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">约束:</em></p><ul class=""><li id="aac2" class="lv lw in jm b jn jo jr js jv lx jz ly kd lz kh ma mb mc md bi translated">列表中的节点数量在范围<code class="fe ld le lf lg b">[0, 104]</code>内。</li><li id="2fed" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated"><code class="fe ld le lf lg b">-105 &lt;= Node.val &lt;= 105</code></li><li id="434b" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh ma mb mc md bi translated"><code class="fe ld le lf lg b">pos</code>是链表中的<code class="fe ld le lf lg b">-1</code>或<strong class="jm io">有效索引</strong>。</li></ul><p id="53d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kj">方案一:哈希</em> </strong></p><ol class=""><li id="7c07" class="lv lw in jm b jn jo jr js jv lx jz ly kd lz kh mj mb mc md bi translated">遍历给定的链表并将节点存储在Set()对象中以避免重复值</li><li id="01bf" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh mj mb mc md bi translated">如果出现重复，链表就是一个循环，函数返回<code class="fe ld le lf lg b">true</code></li><li id="1f55" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh mj mb mc md bi translated">遍历后，如果没有找到重复的节点，函数返回<code class="fe ld le lf lg b">false</code></li></ol><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk"><a class="ae ki" href="https://gist.github.com/GAierken/226126a8998ed219de9921aa5cf0c195" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/GAierken/226126a8998ed219de9921aa5cf0c195</a></figcaption></figure><p id="80d2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">时间复杂度:<strong class="jm io"> O(n)。</strong>只需要遍历一次链表。</p><p id="d32c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">空间复杂度:<strong class="jm io"> O(n)。n </strong>是集合()中存储节点所需的空间。</p><p id="288c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kj">解法二:弗洛伊德龟兔赛跑算法</em> </strong></p><ol class=""><li id="6690" class="lv lw in jm b jn jo jr js jv lx jz ly kd lz kh mj mb mc md bi translated">用两个指针遍历给定的列表</li><li id="f1c6" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh mj mb mc md bi translated">慢速指针移动一位，快速指针移动两位</li><li id="d4e5" class="lv lw in jm b jn me jr mf jv mg jz mh kd mi kh mj mb mc md bi translated">如果两个指针相遇，返回<code class="fe ld le lf lg b">true</code>，否则返回<code class="fe ld le lf lg b">false</code></li></ol><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk"><a class="ae ki" href="https://gist.github.com/GAierken/5e66d1fbf3e4c5b7adf367520e46004f" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/GAierken/5e66d1fbf3e4c5b7adf367520e46004f</a></figcaption></figure><p id="7851" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">时间复杂度:<strong class="jm io"> O(n)。</strong>只需要遍历一次链表。</p><p id="3221" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">空间复杂度:<strong class="jm io"> O(1)。不需要空格，它是常数。</strong></p></div><div class="ab cl kw kx hr ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ig ih ii ij ik"><p id="61aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kj">资源:</em> </strong></p><div class="mm mn gp gr mo mp"><a href="https://leetcode.com/problems/linked-list-cycle/" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd io gy z fp mu fr fs mv fu fw im bi translated">链表循环- LeetCode</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">给定一个链表，确定其中是否有循环。为了在给定的链表中表示一个循环，我们使用一个…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">leetcode.com</p></div></div><div class="my l"><div class="mz l na nb nc my nd kq mp"/></div></div></a></div><div class="mm mn gp gr mo mp"><a href="https://en.wikipedia.org/wiki/Cycle_detection" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd io gy z fp mu fr fs mv fu fw im bi translated">循环检测</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">在计算机科学中，循环检测或循环寻找是在一系列循环中寻找循环的算法问题</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">en.wikipedia.org</p></div></div><div class="my l"><div class="ne l na nb nc my nd kq mp"/></div></div></a></div><div class="mm mn gp gr mo mp"><a href="https://www.geeksforgeeks.org/detect-loop-in-a-linked-list/" rel="noopener  ugc nofollow" target="_blank"><div class="mq ab fo"><div class="mr ab ms cl cj mt"><h2 class="bd io gy z fp mu fr fs mv fu fw im bi translated">检测链表中的循环</h2><div class="mw l"><h3 class="bd b gy z fp mu fr fs mv fu fw dk translated">给定一个链表，检查该链表是否有循环。下图显示了一个带有循环的链表。跟随…</h3></div><div class="mx l"><p class="bd b dl z fp mu fr fs mv fu fw dk translated">www.geeksforgeeks.org</p></div></div><div class="my l"><div class="nf l na nb nc my nd kq mp"/></div></div></a></div></div></div>    
</body>
</html>