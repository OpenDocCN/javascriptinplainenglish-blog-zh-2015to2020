<html>
<head>
<title>Angular Security Best Practices</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度安全最佳实践</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-security-best-practices-54fadf8974a1?source=collection_archive---------3-----------------------#2020-04-28">https://javascript.plainenglish.io/angular-security-best-practices-54fadf8974a1?source=collection_archive---------3-----------------------#2020-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/06132901ba901cf28a3780d48bc023eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*trsKIkuh65w-eAyZ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@bernardhermant?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bernard Hermant</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9b1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular是谷歌制作的一个流行的前端框架。像其他流行的前端框架一样，它使用基于组件的架构来构建应用程序。</p><p id="9791" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究编写Angular应用程序时要遵循的一些安全最佳实践。</p><h1 id="b1c6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">防止跨站点脚本编写(XSS)</h1><p id="7e81" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">跨站点脚本使攻击者能够将恶意代码注入网页。</p><p id="6706" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了防止这种情况，角度会清理插入到模板中的变量。</p><p id="651e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">角度模板是可执行代码，所以任何潜在的恶意代码片段都必须被清除。</p><p id="9d33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">插值已清除，但<code class="fe me mf mg mh b">innerHtml</code>未清除。例如:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8f33" class="mq lc iq mh b gy mr ms l mt mu">&lt;p&gt;{{htmlSnippet}}&lt;/p&gt;</span></pre><p id="ff58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">已消毒，但:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d280" class="mq lc iq mh b gy mr ms l mt mu">&lt;p [innerHTML]="htmlSnippet"&gt;&lt;/p&gt;</span></pre><p id="dedc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不是。</p><p id="5244" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，使用<code class="fe me mf mg mh b">innerHTML</code>时要小心，防止带有<code class="fe me mf mg mh b">script</code>标记的字符串执行。</p><h1 id="f4cc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">直接使用DOM APIs和显式清理调用</h1><p id="86ec" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">内置的DOM APIs不能自动保护我们免受安全漏洞的攻击。</p><p id="826a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">document</code>、<code class="fe me mf mg mh b">ElementRef</code>都有不安全的方法。如果我们使用它们，我们应该运行<code class="fe me mf mg mh b">DomSanitizer.sanitize</code>方法和适当的<code class="fe me mf mg mh b">SecurityContext</code>。</p><h1 id="f38c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用离线模板编译器</h1><p id="bb46" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在生产环境中使用离线模板编译器来防止模板注射。</p><h1 id="e4c4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">信任安全价值观</h1><p id="7575" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">DomSanitizer</code>来信任安全值，并调用以下方法之一:</p><ul class=""><li id="60ef" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><code class="fe me mf mg mh b">bypassSecurityTrustHtml</code></li><li id="5709" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">bypassSecurityTrustScript</code></li><li id="7e1f" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">bypassSecurityTrustStyle</code></li><li id="e02a" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">bypassSecurityTrustUrl</code></li><li id="5ef1" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">bypassSecurityTrustResourceUrl</code></li></ul><p id="f024" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">信任动态设置的代码。</p><p id="b545" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码，让我们在<code class="fe me mf mg mh b">href</code>属性中运行JavaScript代码:</p><p id="0594" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">app.component.ts</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a94b" class="mq lc iq mh b gy mr ms l mt mu">import { Component } from "@angular/core";<br/>import { DomSanitizer } from "@angular/platform-browser";</span><span id="4390" class="mq lc iq mh b gy nj ms l mt mu">@Component({<br/>  selector: "app-root",<br/>  templateUrl: "./app.component.html",<br/>  styleUrls: ["./app.component.css"]<br/>})<br/>export class AppComponent {<br/>  dangerousUrl;<br/>  trustedUrl;<br/>  constructor(private sanitizer: DomSanitizer) {<br/>    this.dangerousUrl = 'javascript:alert("Hi")';<br/>    this.trustedUrl = sanitizer.bypassSecurityTrustUrl(this.dangerousUrl);<br/>  }<br/>}</span></pre><p id="9fc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">app.component.html</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="396f" class="mq lc iq mh b gy mr ms l mt mu">&lt;p&gt;&lt;a class="e2e-trusted-url" [href]="trustedUrl"&gt;Click me&lt;/a&gt;&lt;/p&gt;</span></pre><p id="ba7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当将<code class="fe me mf mg mh b">this.dangerousUrl</code>传递到<code class="fe me mf mg mh b">sanitizer.bypassSecurityTrustUrl</code>时，我们相信代码是安全的。</p><p id="2643" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当我们单击“单击我”时，我们会看到弹出的警告框，因为JavaScript代码没有经过杀毒。</p><h1 id="240b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">HTTP级漏洞</h1><p id="3284" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Angular内置了支持功能，有助于防止2个常见的HTTP漏洞。跨站点请求伪造(CSRF或XSRF)和跨站点脚本编写(XSS)。</p><p id="1dc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">跨站点请求伪造是一种攻击者假装是合法用户并代表该用户发出请求的攻击。</p><p id="72af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">常见的反CSRF技术是在cookie中发送随机生成的身份验证令牌。客户端读取cookie，并在所有后续请求中添加带有令牌的自定义请求头。</p><p id="d2b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">服务器将接收到的cookie值与请求标头值进行比较，如果值缺失或不匹配，则拒绝请求。</p><p id="2229" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有浏览器都执行同源策略。只有来自设置了cookie的网站的代码才能读取cookie并在网站上设置自定义标题。</p><p id="d28a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular的HTTP客户端可以从服务器接收cookie，并在所有后续请求中添加自定义请求头。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/10fb5ba1140e13a472489267392409f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X0gYL20ABtYMdEPG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rayner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rayner Simpson</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="9558" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">跨站点脚本包含(XSSI)</h1><p id="ff32" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这是旧浏览器上的一个漏洞，通过覆盖本机JavaScript对象构造函数并使用<code class="fe me mf mg mh b">script</code>标签包含API URL。</p><p id="da1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有当JSON有可执行的JavaScript代码时，它才是成功的。</p><p id="7c94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular的<code class="fe me mf mg mh b">HttpClient</code>自动从JSON中串出括号和圆括号来防止这种攻击。</p><h1 id="a619" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ccbb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">跨站点脚本攻击是指恶意脚本被注入到应用程序的代码中并运行。</p><p id="ddc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是通过消毒字符串来防止的。Angular还提供了绕过净化的选项。</p><p id="16a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DOM方法并不安全，所以我们在直接使用它们时应该意识到这一点。</p><p id="5952" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">交叉请求伪造是指攻击者通过伪装成合法用户来发出请求。</p><p id="149c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular的<code class="fe me mf mg mh b">HttpClient</code>可以从服务器读取定制的cookies，并发送一个带有唯一标识的请求头，该标识由服务器验证，以防止这种攻击。</p><p id="ac1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过净化JSON来防止可执行JSON字符串的执行，从而防止跨站点脚本包含攻击。</p><h2 id="b8bb" class="mq lc iq bd ld nl nm dn lh nn no dp ll ko np nq lp ks nr ns lt kw nt nu lx nv bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="f504" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"> <strong class="kf ir"> AI in Plain English </strong> </a>，<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="b10d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>