<html>
<head>
<title>Understanding Prototypal Inheritance in JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JS中的原型继承</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-prototypical-inheritance-in-js-3c24e8bd74ce?source=collection_archive---------5-----------------------#2018-09-30">https://javascript.plainenglish.io/understanding-prototypical-inheritance-in-js-3c24e8bd74ce?source=collection_archive---------5-----------------------#2018-09-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e282" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">理解JavaScript中的原型、原型继承和原型链所需的一切</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/6ee6558e22eca0d51fccd0e0c9ca8cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/0*nOibcBOerk2lyL7r"/></div></figure><p id="4a4e" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我使用JavaScript已经快两年了，用React替换了基于jQuery的UI，这是我们在小说家公司的一个产品。我喜欢了解我正在使用的工具的不足之处，这样我就可以更有效地使用它。很明显，从我开始JS之旅的时候起，理解JavaScript中的原型对于理解这种语言是如何工作的至关重要。所以我开始了这次冒险，去了解原型到底是什么，以及我们如何利用它。为了理解什么是原型或原型继承，我们必须首先理解函数在JS中是如何工作的。</p><h2 id="05d8" class="lg lh in bd li lj lk dn ll lm ln dp lo kt lp lq lr kx ls lt lu lb lv lw lx ly bi translated">JavaScript中的函数</h2><p id="135d" class="pw-post-body-paragraph kk kl in km b kn lz jo kp kq ma jr ks kt mb kv kw kx mc kz la lb md ld le lf ig bi translated">JavaScript中的函数由两个内部方法[[Call]]和[[Construct]]驱动。任何带有[[Call]]方法的对象都称为函数，任何<em class="me">另外</em>带有[[Construct]]方法的函数都称为<strong class="km io">构造函数。</strong>[[Call]]方法决定当你调用一个对象作为函数时会发生什么，例如<em class="me"> foo(args) </em>，而[[Construct]]决定当你调用它作为一个新的表达式时会发生什么，例如new foo(args)。每个构造函数也有一个内部的[[Call]]方法。</p><blockquote class="mf"><p id="eeca" class="mg mh in bd mi mj mk ml mm mn mo lf dk translated">类实际上是使用构造函数创建的对象。</p></blockquote><p id="9b8e" class="pw-post-body-paragraph kk kl in km b kn mp jo kp kq mq jr ks kt mr kv kw kx ms kz la lb mt ld le lf ig bi translated">需要意识到的一件重要事情是，特别是对于习惯于Java/C#/C++的人来说，JavaScript中没有类。类实际上是使用构造函数创建的对象。您可以使用构造函数创建对象的实例。在这方面，它们的工作方式与您的Java或C#对象创建方式相同。构造函数及其实例化的示例:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="0f25" class="lg lh in mv b gy mz na l nb nc">function Student(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>    this.getName = () =&gt; `${this.firstName} ${this.lastName}`;<br/> }</span><span id="0076" class="lg lh in mv b gy nd na l nb nc">let student1 = new Student("Albert","Einstein");<br/>let student2 = new Student("Isaac", "Newton");</span></pre><h2 id="db91" class="lg lh in bd li lj lk dn ll lm ln dp lo kt lp lq lr kx ls lt lu lb lv lw lx ly bi translated">原型</h2><p id="fd52" class="pw-post-body-paragraph kk kl in km b kn lz jo kp kq ma jr ks kt mb kv kw kx mc kz la lb md ld le lf ig bi translated">现在到了精彩的部分。每个构造函数都有一个名为<strong class="km io">‘Prototype’</strong>的<strong class="km io">属性</strong>，它指向一个在声明函数时创建的原型对象。我仍然没有弄清楚原型对象是如何创建的，但是现在让我们把它放在一个黑盒里。</p><blockquote class="mf"><p id="7fdc" class="mg mh in bd mi mj mk ml mm mn mo lf dk translated">每个构造函数都有一个名为<strong class="ak">‘Prototype’</strong>的<strong class="ak">属性</strong>，它指向一个在声明函数时创建的原型对象。</p></blockquote><p id="e314" class="pw-post-body-paragraph kk kl in km b kn mp jo kp kq mq jr ks kt mr kv kw kx ms kz la lb mt ld le lf ig bi translated">既然JavaScript中没有类，那么如何创建可以在实例间共享的方法和属性呢？你可以通过原型属性来实现，也就是说，你可以把它附加到原型对象上。这叫做<strong class="km io">原型继承</strong>。在上面的示例中，firstName、lastName和getName是唯一创建的，并存储在Student对象的每个实例中。当我们创建Student对象的实例时，每个实例都有自己的firstName、lastName和getName属性。现在让我们添加一个将由所有实例共享的方法:</p><p id="c6f4" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><code class="fe ne nf ng mv b">Student.prototype.printName = () =&gt; console.log(this.getName());</code></p><p id="0ee1" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在，student1和student2都将共享printName()函数，因为它已附加到student.prototype，而且它们是由Student()构造函数创建的。由Student()创建的每个实例都将共享printName()。但如何实现呢？问得好。</p><p id="94cc" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">构造函数创建的每个实例都有一个指向其构造函数“prototype”属性的内部<strong class="km io">‘prototo _ _’</strong>属性。这很令人困惑，我知道。我花了一些时间才明白‘prototype’和‘proto _ property’是不一样的。是的，它们通常会指向同一个Prototype对象，但<em class="me">并不总是</em>。我们稍后将看到这一点，但首先让我们设想一下这种关系:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/0c709a7df4207f69eb24db45b2f2f8c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1048/0*yKx0PykVJdrPIahj"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Relationship between prototype and __proto__</figcaption></figure><p id="85b8" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在查找属性时，JavaScript首先查看对象实例是否具有该属性，如果不具有，则通过“__proto_”属性转到Prototype对象。这就是所谓的<strong class="km io">原型链</strong>。JavaScript将一直向上，直到Object.prototype，如果在那里找不到它，将返回undefined。</p><h2 id="f0a3" class="lg lh in bd li lj lk dn ll lm ln dp lo kt lp lq lr kx ls lt lu lb lv lw lx ly bi translated">__proto__ vs原型</h2><p id="6994" class="pw-post-body-paragraph kk kl in km b kn lz jo kp kq ma jr ks kt mb kv kw kx mc kz la lb md ld le lf ig bi translated">我答应过要谈谈‘prototype’和‘proto _ property’的区别。正如我所说，“prototype”属性在构造函数中找到，指向该函数的Prototype对象，而“__proto_”属性在构造函数及其实例中找到，并指向创建它们的函数的Prototype对象。听起来它们应该总是一样的，对吧？让我们看一个例子，其中情况并非如此。我发现下图非常有用:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/47229dc2fdfcec859179fd6bef2d05f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/0*DCIckoFOeWCrWysA"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Image from <a class="ae nn" href="http://dmitrysoshnikov.com/ecmascript/javascript-the-core/" rel="noopener ugc nofollow" target="_blank">http://dmitrysoshnikov.com/ecmascript/javascript-the-core/</a></figcaption></figure><p id="9ab9" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如图所示，Foo的“__proto_”和“prototype”属性指向不同的东西。Foo是一个函数，因此由“function”构造函数(JavaScript内部)创建。所以“__proto_”属性指向函数的Prototype对象。但Foo的“prototype”属性指向Foo的Prototype对象。</p><h2 id="6405" class="lg lh in bd li lj lk dn ll lm ln dp lo kt lp lq lr kx ls lt lu lb lv lw lx ly bi translated">ES6类语法如何与原型相关？</h2><p id="fdf7" class="pw-post-body-paragraph kk kl in km b kn lz jo kp kq ma jr ks kt mb kv kw kx mc kz la lb md ld le lf ig bi translated">和前面一样，ES6中的每个类都由一个构造函数和一个原型对象组成，它们通过prototype属性相互引用。然而，两者的定义顺序相反。使用旧的样式类，定义构造函数，并为您创建原型对象。使用新样式类时，类定义的主体将成为原型对象的内容(静态方法除外)，在这些内容中，您定义了一个构造函数。无论哪种方式，最终结果都是一样的。</p><h2 id="f8f8" class="lg lh in bd li lj lk dn ll lm ln dp lo kt lp lq lr kx ls lt lu lb lv lw lx ly bi translated">结论</h2><p id="8ef2" class="pw-post-body-paragraph kk kl in km b kn lz jo kp kq ma jr ks kt mb kv kw kx mc kz la lb md ld le lf ig bi translated">我希望这能帮助你理解JavaScript中的原型(我说的原型够了吗？)老实说，过几个月我可能会读这篇文章，以重温旧梦。但我真的很喜欢做这样的研究！</p></div></div>    
</body>
</html>