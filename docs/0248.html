<html>
<head>
<title>Algorithms 101: TwoSum in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:JavaScript中的二和</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-101-twosum-in-javascript-b493c8d64014?source=collection_archive---------3-----------------------#2019-09-05">https://javascript.plainenglish.io/algorithms-101-twosum-in-javascript-b493c8d64014?source=collection_archive---------3-----------------------#2019-09-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1a19" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><em class="kc"> Noob诉LeetCode，第一集</em></h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi kd"><img src="../Images/ec826c4cf3758cf7465d9e0554060291.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*v9l0LJWG6Ja2jKeMxmSdWw.png"/></div><figcaption class="kl km gj gh gi kn ko bd b be z dk">not a bad thing</figcaption></figure><p id="90f6" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">寻找编码工作的很大一部分是能够通过技术面试，这通常包括解决像LeetCode.com上的算法。</p><p id="e44c" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">有什么地方比起点更好呢？LeetCode的第一个算法挑战叫做<a class="ae ll" href="https://leetcode.com/problems/two-sum/" rel="noopener ugc nofollow" target="_blank">二和</a>。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lm"><img src="../Images/ab4509d4b55187a2fc371de324e6c1f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7KEjv6vVHvqL_KAZZgCPg.png"/></div></div><figcaption class="kl km gj gh gi kn ko bd b be z dk">sounds simple, right?</figcaption></figure><h1 id="aa34" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">蛮力/天真</h1><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/a3409d56c8b395225a0ec30675b8d8c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/0*peSMDCYq-vyUZnH4"/></div></figure><p id="c8af" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">像我这样的菜鸟通常会先找到“蛮力”或幼稚的解决方案。这些是可行的解决方案，但是会占用大量的处理时间和/或内存。有点像用火箭筒拍苍蝇。它工作，但是…</p><p id="9a80" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">但是，你必须从某个地方开始。一旦你得到一个强力解决方案，你总是可以重构。</p><p id="48a0" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">进入，火箭筒:</p><p id="d82a" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">如果将数组中的每个元素与数组中的其他每个<em class="mk">元素进行比较，可以检查任意两个元素的和是否等于目标值。然后你可以找到这两个元素的索引，把它们放在一个数组中并返回这个数组。</em></p><p id="8fae" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">换句话说，你可以用一个嵌套循环来做这件事。</p><pre class="ke kf kg kh gt ml mm mn mo aw mp bi"><span id="1763" class="mq ls in mm b gy mr ms l mt mu">const twoSum = function(nums, target) {<br/>  for (let i = 0; i &lt; nums.length; i++){<br/>     for (let j = 0; j &lt; nums.length; j++ ) {<br/>        if (nums[i] + nums[j] === target &amp;&amp; i !== j){<br/>           return [i,j]<br/>        }<br/>     }<br/>   }<br/>}</span></pre><p id="6524" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">让我们打开它。</p><p id="f5f2" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">如果你知道<code class="fe mv mw mx mm b">(let i = 0; i &lt; nums.length; i++)</code>是什么意思，跳过下面几段！</p><p id="1cc2" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">“I”代表索引。通过将‘I’设置为零，我们说从第一个元素开始(index = 0)；让我们一直走，直到到达数组的末尾(当i =到数组的长度)；在此之前，每次迭代后，让我们将“I”加1。</p><p id="9c50" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">同时，让我们再做一次同样的事情，但是这次我们将查看“j”索引处的元素。</p><p id="1406" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">如果我们在索引“I”处找到一个元素，在索引“j”处找到一个元素，这两个元素加起来就是目标——<em class="mk">和</em>。如果我们在索引“I”处找到的元素与在索引“j”处找到的元素不同，那么我们知道我们找到了两个满足要求的独立元素。让我们把它们的索引‘I’和‘j’放入一个数组中。</p><p id="3b97" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">它起作用了，但是很慢:</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi my"><img src="../Images/d235268f7693794203562483073ee12e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CPyxMXsptEAuIbdQECOtCg.png"/></div></div></figure><p id="71c9" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在这个例子中，我们的代码看起来并不慢，因为我们的数组只有四个元素。为了在一个有四个元素的数组中检查每一项和其他项，我们需要做16次，或者4次比较。</p><p id="054d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">但是如果我们的数组有4000个元素呢？那我们就得做4000次比较。换句话说，对于数组中的n个元素，我们需要进行n次比较。从数学上来说，这是n的大O符号，被认为非常非常慢。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="1250" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">一个更好的解决方案应该是n的大O符号——这意味着我们只需要迭代一次数组。</p><h1 id="4894" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">更好、更聪明、更快</h1><p id="61a8" class="pw-post-body-paragraph kp kq in kr b ks nb jo ku kv nc jr kx ky nd la lb lc ne le lf lg nf li lj lk ig bi translated">让我们重新想象一下这个问题。</p><p id="bcdb" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">假设你有一个很大的篮子，里面有不同重量的球。你想知道它们中的任何两个加起来是否等于x。在第一个解决方案中，我们尝试了所有可能的组合，直到找到正确的组合。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/06872a15813079ff33e6a16d80934d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/0*kFqpk4Cofgm-66YD.jpg"/></div><figcaption class="kl km gj gh gi kn ko bd b be z dk">kinda like this … but we’ll only use two baskets of balls</figcaption></figure><p id="da8e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在下一个解决方案中，我们将从同一个球篮(篮子#1)加上一个空篮子(篮子#2)开始。对于篮子#1中的每个球，我们将遵循以下步骤:</p><ol class=""><li id="3364" class="nh ni in kr b ks kt kv kw ky nj lc nk lg nl lk nm nn no np bi translated">称一下球。(姑且称之为‘当前球’)。</li><li id="a660" class="nh ni in kr b ks nq kv nr ky ns lc nt lg nu lk nm nn no np bi translated">从目标中减去当前球的重量，得到所需的重量——我们需要另一个球来称量当前球的重量，这另一个球就是我们的解。所以如果当前的球重2克，我们的目标重量是10克，那么需要的重量是8克。</li><li id="155b" class="nh ni in kr b ks nq kv nr ky ns lc nt lg nu lk nm nn no np bi translated">在2号篮子上挥动魔杖，说:“喂，8克重的球！”如果它在那里，它会跳出来！(当然，我们第一次这样做时，篮子#2将是空的；没关系)。</li><li id="6f54" class="nh ni in kr b ks nq kv nr ky ns lc nt lg nu lk nm nn no np bi translated">如果我们在篮子#2中没有找到我们要找的东西，在当前球上写下当前球的重量。然后把它放进2号篮子里。</li></ol><p id="3860" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我们这样做了几次，没有找到匹配，然后…最后…</p><ol class=""><li id="6a17" class="nh ni in kr b ks kt kv kw ky nj lc nk lg nl lk nm nn no np bi translated">当前球重8克</li><li id="1888" class="nh ni in kr b ks nq kv nr ky ns lc nt lg nu lk nm nn no np bi translated">从目标重量中减去得到所需重量:2克)</li><li id="6049" class="nh ni in kr b ks nq kv nr ky ns lc nt lg nu lk nm nn no np bi translated">在2号篮子上挥动魔杖，大声喊“喂，2克重的球！”—嘿，在那儿！</li></ol><p id="abce" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">4.我们找到我们的那一对了！</p><h1 id="a172" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">代码看起来是这样的:</h1><pre class="ke kf kg kh gt ml mm mn mo aw mp bi"><span id="387b" class="mq ls in mm b gy mr ms l mt mu">var twoSum = function(nums, target) {<br/>    const previousValues = {};<br/>    for (let i = 0; i &lt; nums.length; i++) {        <br/>        const currentNumber = nums[i];<br/>        const neededValue = target - currentNumber;<br/>        const index2 = previousValues[neededValue];<br/>        if (index2 != null){<br/>            return [index2, i];<br/>        } else {<br/>            previousValues[currentNumber] = i;<br/>            // hash[key] = value</span><span id="86f6" class="mq ls in mm b gy nv ms l mt mu">        }        <br/>    }<br/>}</span></pre><p id="cbc4" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">让我们再次打开包装。</p><p id="df77" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">空散列值<em class="mk"> previousValues </em>是篮# 2；这是我们检查完球后扔球的地方。</p><ul class=""><li id="0811" class="nh ni in kr b ks kt kv kw ky nj lc nk lg nl lk nw nn no np bi translated"><em class="mk">当前号码</em>是当前球(在我们的nums数组的索引‘I’处的那个)</li><li id="7d0c" class="nh ni in kr b ks nq kv nr ky ns lc nt lg nu lk nw nn no np bi translated"><em class="mk">所需值是</em>所需重量</li></ul><pre class="ke kf kg kh gt ml mm mn mo aw mp bi"><span id="0974" class="mq ls in mm b gy mr ms l mt mu">const index2 = previousValues[neededValue];</span></pre><p id="1dae" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><em class="mk"> index2 </em>是我们在原始数组中找到所需重量的球的位置(如果该球存在，则为<em class="mk">)。</em></p><pre class="ke kf kg kh gt ml mm mn mo aw mp bi"><span id="a00b" class="mq ls in mm b gy mr ms l mt mu">if (index2 != null){<br/>            return [index2, i];</span></pre><p id="477b" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">如果<em class="mk"> index2 </em>确实存在，则所需重量的匹配球存在，所以我们返回匹配球的位置和当前球的位置…</p><pre class="ke kf kg kh gt ml mm mn mo aw mp bi"><span id="acb1" class="mq ls in mm b gy mr ms l mt mu">} else {<br/>            previousValues[currentNumber] = i;<br/>            // hash[key] = value</span><span id="47fc" class="mq ls in mm b gy nv ms l mt mu">}</span></pre><p id="df1e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">如果<em class="mk"> index2 </em>不存在，那么我们给<em class="mk"> previousValues </em>添加一个键值对，其中key为<em class="mk"> currentNumber </em>，value为currentNumber在原数组中的索引。</p><p id="7288" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">注意:由于previousValues是一个散列，当我们在其中查找neededValue时，我们不需要迭代。我们只需要看看它是否有某个值，只有当它有某个键等于变量<em class="mk"> neededValue </em>时才会有。从散列中获取值要快得多(有点像调用‘Accio！’用魔棒)要比遍历数组好得多。与嵌套循环的n相比，它有一个很大的O符号值n)</p><p id="f76e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">果然，我们的方法更快:</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi nx"><img src="../Images/6d3a709370daf5e932add3b608cebb0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BBxqa_Mx7hfm7ACGbFfQXg.png"/></div></div></figure><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="ny na l"/></div></figure><h1 id="e244" class="lr ls in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">非常感谢…</h1><p id="cf88" class="pw-post-body-paragraph kp kq in kr b ks nb jo ku kv nc jr kx ky nd la lb lc ne le lf lg nf li lj lk ig bi translated">所以，诺布，不要绝望。起初，我对如何解决这个问题毫无头绪。我做了很多谷歌搜索，玩了很多我找到的解决方案，最终偶然发现了这个视频<a class="ae ll" href="https://www.youtube.com/watch?v=Ivyh3V4QolA&amp;t=316s" rel="noopener ugc nofollow" target="_blank"/>，由WebDev Simplified制作，它帮助我理解了这些概念！</p><p id="34dc" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><a class="ae ll" href="https://medium.com/javascript-in-plain-english/algorithms-101-reverse-a-string-in-javascript-de453d5ce77e" rel="noopener"> <em class="mk">接下来:算法101:在JavaScript中反转一个字符串</em> </a></p><p id="8cc4" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">版权所有琼·印第安纳·琳斯2019</p></div></div>    
</body>
</html>