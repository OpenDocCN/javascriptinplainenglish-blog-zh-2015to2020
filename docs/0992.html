<html>
<head>
<title>The most confusing thing in JavaScript: The ‘this’ keyword</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中最令人困惑的事情:“this”关键字</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-most-confusing-thing-in-javascript-the-this-keyword-3436f451fca?source=collection_archive---------0-----------------------#2020-01-11">https://javascript.plainenglish.io/the-most-confusing-thing-in-javascript-the-this-keyword-3436f451fca?source=collection_archive---------0-----------------------#2020-01-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f196b7162aa43a6776d1152e0cba378a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HtGxydi5D2z0IFZpdAK99A.png"/></div></div></figure><p id="da75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你知道那些你一遍又一遍学习的概念，然而不管你记了多少笔记，它们似乎都从你的记忆中消失了？</p><p id="d3d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript中的关键字<code class="fe kw kx ky kz b">this</code>对我来说就是这些概念中的一个，直到我最终花了一个下午来理解代码的内部工作，而不是绝望地试图记住影响<code class="fe kw kx ky kz b">this</code>值的4种类型的“绑定”(默认、隐式、显式和“新”)。</p><p id="28e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">喝杯咖啡，带上你的聚焦帽，和我一起度过接下来的15分钟，你也会最终明白<code class="fe kw kx ky kz b">this</code>这个关键词是什么。</p><h1 id="8145" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">编译时间与运行时间</h1><p id="8228" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">编写代码不需要对编译器和运行时有深刻的理解，如果你在21世纪学会了编码，可能就不会有人向你强行灌输操作系统理论了(特别是如果你受过非正式的培训)。</p><p id="71bd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是要理解JavaScript中的<code class="fe kw kx ky kz b">this</code>关键字，我们至少需要对编译时和运行时的区别有一个基本的了解。</p><p id="8a03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有语言在编译和执行代码的方式上都略有不同，但是JavaScript在这方面有点独特。由于JavaScript在浏览器中运行，所以需要一次性编译并执行；而且要快！与C语言不同，在C语言中，我们必须先编译代码，然后运行代码，这种“一体化”的魔力让JavaScript引擎(通常是Chrome这样的浏览器)看起来好像是一个完成所有事情的实体。</p><h1 id="6666" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">但是打住，我不确定我知道什么是“编译”？</h1><p id="f629" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">你可能已经读过这个词一千遍了，但是它到底是什么意思呢？</p><p id="7bea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编译可以从两个方面来理解:</p><ol class=""><li id="274f" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated">作为一个<em class="mm">过程</em></li><li id="ad00" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">作为<em class="mm">时间点</em></li></ol><p id="0a0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们在屏幕上显示一些代码来更好地理解这一点。</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="df81" class="na lb iq kz b gy nb nc l nd ne">function simpleFunction() {<br/>    console.log("I am a useless function");<br/>}</span><span id="aa74" class="na lb iq kz b gy nf nc l nd ne">simpleFunction();</span></pre><p id="6059" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">定义为一个<em class="mm">过程</em>，这段代码的编译是从你现在在屏幕上看到的内容到计算机可以执行的1和0(二进制代码)的<em class="mm">过程</em>。</p><p id="4ff8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">具体如何发生是由编译器自己定义的，但可能是这样的:</p><ol class=""><li id="3729" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated">嗯……我先看到“功能”这个词。这是JavaScript语言语法的一部分吗？没错。好吧，我们继续。</li><li id="a467" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">刚刚看到“函数”这个关键词，那么下一个词“simpleFunction”一定是它的名字。这个名字符合我的标准吗？它没有任何奇怪的字符或空格，所以没错！下一个！</li><li id="d295" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">我看到一个“{”，这是我看到“function”和“simpleFunction”后可能会想到的。这里一切都好。</li><li id="2086" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">这个叫“控制台”的东西是什么？不太确定，但肯定是个物件。让我们看看一个“.”接下来。</li><li id="d870" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">啊，在那里！的“.”意味着某种方法即将到来。</li><li id="da29" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">是的，“日志”是在“控制台”上调用的方法。不知道它是否真的存在，但那不是我的工作！向前移动！</li><li id="13a2" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">我看到一个“(”字符。我希望如此，因为在此之前我刚刚看到了一个名为“log”的方法。我们现在必须定义这个方法的参数。</li><li id="2fe8" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">我看到一串“我是无用函数”。嗯，不知道这有什么意义，但这是有效的字符串语法，所以我接受它。</li><li id="6cdb" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">这里是右括号“)”，后面是“；”。这个方法做好了，有效！</li><li id="a397" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">而现在，我看到一个“}”。这意味着我的函数定义现在完成了！</li><li id="b081" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">我又看到“simpleFunction”带“()”。这是调用之前声明的函数的有效方法。</li><li id="fcb3" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">就是这样！没有更多的令牌可以解析。这个程序是编译的。</li></ol><p id="0825" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在通读了这段想象中的与编译器的对话后，你可以看到编译器的工作是遍历一个程序，看符号(也叫“记号”)，根据语言规范确定它们是否有意义。如果编译器看到下面的代码，它会发疯并抛出一个错误，而不把代码编译成1和0:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="cfb3" class="na lb iq kz b gy nb nc l nd ne">variable myvariable = 1;</span></pre><p id="d0d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对话是这样进行的:</p><ol class=""><li id="92a7" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated">我看到一个词“变量”。这一行的开头没有“const”、“let”或“var”，所以这必须是一个隐式声明的变量。我不爱它，但技术上它是有效的！</li><li id="9397" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">哇哦哇哦哇哦等等。我对之前的行很满意，但是现在我看到了“我的变量”。这不是有效的JavaScript语法。我抛出一个SyntaxError！</li></ol><p id="ea60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从上面的例子中你可以发现，当我们在一个<em class="mm">过程</em>的环境中看编译时，它都是关于读取代码，验证代码，并将其转换成计算机可以执行的东西。</p><p id="4b9c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是许多有经验的开发人员会谈论这个叫做“编译时间”的东西，这是在一个<em class="mm">时间点</em>的上下文中查看编译。</p><p id="8981" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很难理解，因为正如你所看到的，编译更多的是一个过程，而不是一个时间点。</p><p id="b459" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您听到“编译时间”时，这实际上指的是在您点击compile之前的时刻，或者在我们使用JavaScript的情况下，运行程序。</p><p id="333f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以实际上，“编译时”是“在编译器转换代码之前，我们的代码是什么样子”的另一种说法。</p><h1 id="7f36" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">运行时间</h1><p id="6574" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">编译器在确保你的代码具有正确的语法结构方面做得很好，但是它并不真正检查以确保代码工作。</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="9d5d" class="na lb iq kz b gy nb nc l nd ne">invalidFunction();</span></pre><p id="ac93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您在JavaScript控制台中运行它，您将得到<code class="fe kw kx ky kz b">ReferenceError</code>，因为编译器编译了代码，但是当JavaScript引擎试图运行它时，它在任何地方都找不到声明<code class="fe kw kx ky kz b">invalidFunction</code>。</p><p id="9796" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以运行时就是程序被执行的时候，它包括调用栈、内存位置等。</p><h1 id="bdf2" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">“运行时”与“运行时”</h1><p id="e6c6" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">我认为事情变得混乱的地方是在网上缺乏对短语“运行时”和单词“运行时”的区分。</p><p id="7756" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们知道“运行时间”是程序开始执行的时间，但是我们还没有问<em class="mm">它在哪里执行。</em></p><p id="6dfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可以打开谷歌浏览器，在开发者工具中，进入控制台。一旦到了那里，我就可以编写和执行JavaScript代码了。</p><p id="075c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我也可以在我的电脑上打开终端，键入<code class="fe kw kx ky kz b">node</code>，我将进入NodeJS控制台，在那里我可以编写和执行代码。</p><p id="8113" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我在两个不同的运行时编写了相同的代码。</p><p id="19db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是为什么我们需要不同的运行时呢？</p><p id="a257" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为Windows电脑不同于Mac电脑，Mac电脑不同于浏览器。具体来说，它们的硬件组件以及高级代码(如JavaScript)需要编译成的汇编语言是不同的！</p><p id="090e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当JavaScript被编译成计算机可以运行的1和0时，它需要记住它所处的运行时环境。如果不这样做，可能会导致Mac上发生Windows低级系统调用，这显然是行不通的！</p><h1 id="1420" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">回到“这个”关键词</h1><p id="8d94" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">因此，我们讨论了在不同的上下文中，编译和运行时意味着不同的东西。作为一个过程，编译指的是将代码从开发人员编写的内容转换为计算机读取的内容。计算机读取的内容发生在运行时的过程中，并且根据“运行时环境”而不同。</p><p id="b769" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是为了理解JavaScript中的<code class="fe kw kx ky kz b">this</code>关键字，我们必须从<em class="mm">时间点</em>的上下文来考虑运行时和编译时。</p><h1 id="fc4d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">静态(词法)与动态范围</h1><p id="87fe" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated"><em class="mm">原因</em>我们必须从<em class="mm">时间点</em>的上下文来看待编译时和运行时，因为变量和函数的<em class="mm">值</em>完全取决于它们是在运行时定义的还是在编译时定义的！</p><p id="d797" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理解静态(词法)和动态范围是在<code class="fe kw kx ky kz b">this</code>关键字开始有意义之前你必须理解的最后一项！</p><h2 id="2ba4" class="na lb iq bd lc ng nh dn lg ni nj dp lk kj nk nl lo kn nm nn ls kr no np lw nq bi translated">什么是“范围”？</h2><p id="4f62" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">如果你还在读这篇文章，你可能已经知道什么是作用域了。看一下下面的代码:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="6d1d" class="na lb iq kz b gy nb nc l nd ne">let a = 1;</span><span id="c47e" class="na lb iq kz b gy nf nc l nd ne">function printA() {<br/>    a = 2;<br/>    console.log(a)<br/>}</span><span id="0dbe" class="na lb iq kz b gy nf nc l nd ne">printA(); // 2<br/>console.log(a) // 1</span></pre><p id="4ca6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们调用<code class="fe kw kx ky kz b">printA()</code>时，它将首先在<code class="fe kw kx ky kz b">printA</code>函数的范围内寻找<code class="fe kw kx ky kz b">a</code>的值，由于该值存在，它将打印该值。</p><p id="4cb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于<code class="fe kw kx ky kz b">console.log</code>语句不能访问<code class="fe kw kx ky kz b">printA</code>的作用域，它必须在全局作用域中查找，这是它唯一可以访问的作用域。</p><p id="cfbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说，JavaScript引擎将在当前范围内查找变量，如果找不到，它将查找一个范围。如果它到达了<code class="fe kw kx ky kz b">global</code>范围，但仍然找不到变量，那么将抛出一个<code class="fe kw kx ky kz b">ReferenceError</code>，因为该变量不存在。</p><p id="324c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是这个过程的一个人为例子:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="11fb" class="na lb iq kz b gy nb nc l nd ne">let globalVariable = 2;</span><span id="c020" class="na lb iq kz b gy nf nc l nd ne">function outer() {<br/>    middle();<br/>    function middle() {<br/>        inner();<br/>        function inner() {<br/>            console.log(globalVariable);<br/>        }<br/>    }<br/>}</span><span id="6309" class="na lb iq kz b gy nf nc l nd ne">outer(); // 2<br/>inner(); // ReferenceError: inner is not defined</span></pre><p id="8075" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们调用<code class="fe kw kx ky kz b">outer</code>函数时，该函数调用调用内部函数的中间函数。当调用内部函数时，它首先在自己的范围内寻找<code class="fe kw kx ky kz b">globalVariable</code>的值。它找不到它，所以它看起来在<code class="fe kw kx ky kz b">middle</code>的范围内。它又找不到它，所以它看起来在<code class="fe kw kx ky kz b">outer</code>的范围内。它找不到它，所以它最终在全球范围内寻找。它会在那里找到它并打印一个值2。</p><p id="30f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一方面，当我们从全局范围调用<code class="fe kw kx ky kz b">inner</code>函数时，会抛出一个<code class="fe kw kx ky kz b">ReferenceError</code>！</p><p id="014e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是因为JavaScript(以及几乎任何语言)中的作用域只有一种工作方式。在这种情况下，<code class="fe kw kx ky kz b">inner</code>的作用域被“封装”了，因此全局作用域甚至不知道<code class="fe kw kx ky kz b">inner()</code>函数的存在。</p><h2 id="64b2" class="na lb iq bd lc ng nh dn lg ni nj dp lk kj nk nl lo kn nm nn ls kr no np lw nq bi translated">有道理，但为什么？</h2><p id="1959" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">您可能没有意识到这一点，但很可能，您使用的所有编程语言都实现了静态或“词汇”范围——包括JavaScript。我刚才解释的是<em class="mm">静态范围规则</em>。</p><p id="ff36" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是还有另一种类型的作用域叫做动态作用域，它在运行时<em class="mm"/>分配变量的值！让我们看看另一个计划，记住我们刚刚学到的东西。</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="ef42" class="na lb iq kz b gy nb nc l nd ne">let x;<br/>x = 1;</span><span id="7b1b" class="na lb iq kz b gy nf nc l nd ne">function a() {<br/>    x = 2;<br/>}</span><span id="e0c9" class="na lb iq kz b gy nf nc l nd ne">function b() {<br/>    let x;<br/>    a();<br/>}</span><span id="4301" class="na lb iq kz b gy nf nc l nd ne">b();</span><span id="1fea" class="na lb iq kz b gy nf nc l nd ne">// With Lexical scope, this will print 2<br/>// With dynamic scope, this will print 1<br/>console.log(x);</span><span id="ddc1" class="na lb iq kz b gy nf nc l nd ne">a();</span><span id="10fb" class="na lb iq kz b gy nf nc l nd ne">// With Lexical scope, this will print 2<br/>// With dynamic scope, this will print 2<br/>console.log(x);</span></pre><p id="9984" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们实际上用词汇(“静态”)范围的JavaScript语言运行，无论我们调用哪个函数，我们都会为x打印一个值2。这是因为函数<code class="fe kw kx ky kz b">a</code>会始终将变量x重新分配为值2。</p><p id="ae9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是对于动态范围，我们必须从调用堆栈的角度来考虑。我知道这很令人困惑(因此，为什么大多数语言不是动态类型的，为什么大多数人不理解JavaScript <code class="fe kw kx ky kz b">this</code>关键字)，但是让我们来浏览一下。</p><p id="b273" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个程序中，调用堆栈首先用全局作用域<code class="fe kw kx ky kz b">x</code>变量填充，该变量被设置为1。然后我们调用<code class="fe kw kx ky kz b">b()</code>，将变量<code class="fe kw kx ky kz b">x</code>从<code class="fe kw kx ky kz b">function b()</code>的范围推送到调用栈。我们的调用堆栈如下所示:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="ac03" class="na lb iq kz b gy nb nc l nd ne">x (function b scope)<br/>x (global scope)</span></pre><p id="a2c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，虽然它们被命名为同一个变量，但两个<code class="fe kw kx ky kz b">x</code>变量都占据了它们自己的内存段，并被赋予了它们自己的值。</p><p id="1e27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此在这一点上，我们称之为<code class="fe kw kx ky kz b">a()</code>，它设定了<code class="fe kw kx ky kz b">x=2</code>。</p><p id="a5b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是<em class="mm">它设定了哪个</em> x？？</p><p id="e921" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在词汇作用域语言中，我们到达函数<code class="fe kw kx ky kz b">a</code>，我们看不到变量声明。由于没有变量声明，编译器查找一个作用域，找到在全局作用域中声明的x。然后，它将这个全局<code class="fe kw kx ky kz b">x</code>变量赋值为2。</p><p id="eb7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于动态范围，值2被赋给位于调用堆栈顶部<em class="mm">的变量<code class="fe kw kx ky kz b">x</code>。如果您还记得的话，在<code class="fe kw kx ky kz b">function b</code>作用域中的<code class="fe kw kx ky kz b">x</code>位于堆栈的顶部，这意味着值2将被赋给它。</em></p><p id="0e43" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，当我们从全局范围打印x的值时，它仍然是值1！</p><p id="76d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是当我们从全局范围调用<code class="fe kw kx ky kz b">a()</code>时，事情发生了一些变化。这一次，我们的调用堆栈如下所示:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="74c0" class="na lb iq kz b gy nb nc l nd ne">x (global scope)</span></pre><p id="82d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，值2将被赋给全局范围内的变量<code class="fe kw kx ky kz b">x</code>，我们将打印出值2！</p><h1 id="4278" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">重绕</h1><p id="04c0" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">太多了。</p><p id="c639" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们为什么会在这里？嗯，为了理解JavaScript <code class="fe kw kx ky kz b">this</code>关键字，您必须了解动态范围变量的思维模式。为了理解动态范围的变量，你必须理解什么是静态范围的变量。要理解静态范围的变量，你需要知道编译器做什么。</p><p id="cacb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对我来说，这听起来像是一大堆知识！</p><p id="0f56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不管怎样，回顾一下:</p><ul class=""><li id="8c3c" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv nr mj mk ml bi translated">JavaScript是一种静态作用域语言，这意味着变量值基于它们的“编译时”条件进行计算。变量可以“向上作用域”求值，但不能“向下作用域”(即嵌套函数可以使用全局变量，但全局函数不能使用封装变量)</li><li id="9ad4" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv nr mj mk ml bi translated">JavaScript <code class="fe kw kx ky kz b">this</code>关键字的行为方式类似于动态范围，但并不完全相同。尽管如此，理解动态范围将有助于您理解<code class="fe kw kx ky kz b">this</code>关键字。</li><li id="cdbb" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv nr mj mk ml bi translated">如果你完全迷失了，可能是因为你还没有准备好这种类型的讨论。我花了很多年才理解了这些概念，并且需要大量的编程和实践。如果是这种情况，您可以在将来重新阅读这篇文章。</li></ul><h1 id="ca9d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">最后。<code class="fe kw kx ky kz b">this</code>关键字解释</h1><p id="3e8c" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">就像动态范围依赖于运行时调用栈的顺序一样，<code class="fe kw kx ky kz b">this</code>关键字依赖于调用栈来确定<code class="fe kw kx ky kz b">this</code>是哪个“上下文”的一部分。</p><p id="bb51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">this</code>有4种“绑定”方式。我们将从最容易的开始，然后努力做到最难的。</p><h1 id="eb3d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><code class="fe kw kx ky kz b">new</code>关键字</h1><p id="b49a" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">这个很简单。当使用<code class="fe kw kx ky kz b">new</code>关键字声明一个函数的新实例时，<code class="fe kw kx ky kz b">this</code>将总是引用声明的函数。</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="dd7b" class="na lb iq kz b gy nb nc l nd ne">function myFunction() {<br/>    var a = 2;<br/>    <br/>    this.a = a;<br/>}</span><span id="610f" class="na lb iq kz b gy nf nc l nd ne">var a = 4;</span><span id="2780" class="na lb iq kz b gy nf nc l nd ne">var functionInstance = new myFunction();</span><span id="a159" class="na lb iq kz b gy nf nc l nd ne">console.log(functionInstance.a) // 2</span></pre><p id="7a86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的<code class="fe kw kx ky kz b">this</code>关键字指的是<code class="fe kw kx ky kz b">myFunction</code>对象，它分配了一个等于2的<code class="fe kw kx ky kz b">a</code>属性。尽管<code class="fe kw kx ky kz b">functionInstance</code>的调用点在全局范围内，但是<code class="fe kw kx ky kz b">new</code>关键字会覆盖任何关于<code class="fe kw kx ky kz b">this</code>的规则，并且显式绑定到新的函数实例。</p><p id="ed2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为这是识别<code class="fe kw kx ky kz b">this</code>代表什么的最简单的情况，因为它是如此明确。</p><h1 id="2ee8" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">显式绑定</h1><p id="b691" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">这种类型的<code class="fe kw kx ky kz b">this</code>绑定非常类似于<code class="fe kw kx ky kz b">new</code>关键字，但是在您试图同时使用这种方法和<code class="fe kw kx ky kz b">new</code>关键字的情况下，<code class="fe kw kx ky kz b">new</code>关键字将优先。</p><p id="78d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">实际上有多种方法可以显式绑定<code class="fe kw kx ky kz b">this</code>的值，但有些方法比其他方法更过时。为简单起见，我们只看其中一种方式，这是最常见的。</p><p id="8e37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用存在于所有JavaScript函数中的<code class="fe kw kx ky kz b">bind()</code>原型函数，您可以显式地分配一个对象来表示<code class="fe kw kx ky kz b">this</code>的值。</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="878c" class="na lb iq kz b gy nb nc l nd ne">function myFunction() {<br/>    console.log(this.a);<br/>}</span><span id="6c44" class="na lb iq kz b gy nf nc l nd ne">var explicitlyBoundObject = {<br/>    a: 2<br/>};</span><span id="7b1e" class="na lb iq kz b gy nf nc l nd ne">var a = 4;</span><span id="e0c6" class="na lb iq kz b gy nf nc l nd ne">var functionInstance = myFunction.bind(explicitlyBoundObject);</span><span id="5cdb" class="na lb iq kz b gy nf nc l nd ne">functionInstance(); // 2</span></pre><p id="319f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与关键字<code class="fe kw kx ky kz b">new</code>一样，显式绑定允许您完全消除动态范围的概念，并从您的头脑中调用堆栈，并确切地知道<code class="fe kw kx ky kz b">this</code>代表什么。</p><p id="d647" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">稍后，我们将看到这里有一些例外，但是为了简单起见，从表面上看，就拿上面的例子来说吧。</p><h1 id="6c12" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">默认绑定</h1><p id="b3cf" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">默认绑定比<code class="fe kw kx ky kz b">new</code>和显式绑定稍微复杂一点，因为有一些您可能没有预料到的细微差别。</p><p id="af1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个很好的经验法则是:<strong class="ka ir">如果一个函数以“正常”的方式被调用，那么它有默认绑定</strong> <code class="fe kw kx ky kz b"><strong class="ka ir">this</strong></code> <strong class="ka ir">引用全局作用域</strong>。</p><p id="2c9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我说“正常”时，我指的是如下所示的函数调用:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="1363" class="na lb iq kz b gy nb nc l nd ne">function myFunction() {<br/>    console.log("does something");<br/>}</span><span id="97cb" class="na lb iq kz b gy nf nc l nd ne">// Call function "normally"<br/>myFunction();</span></pre><p id="4bf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">只有三种方法可以调用这个函数，如下所示:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="1a7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以如果你看到一个被称为“正常”的函数，你可以合理地假设<code class="fe kw kx ky kz b">this</code>指的是全局对象。如果使用NodeJS控制台，全局对象将是<code class="fe kw kx ky kz b">global</code>，如果使用浏览器控制台，全局对象将是<code class="fe kw kx ky kz b">window</code>。</p><p id="2b07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我看来，当考虑默认绑定时，有两件事会让程序员迷惑。</p><ol class=""><li id="9b6f" class="md me iq ka b kb kc kf kg kj mf kn mg kr mh kv mi mj mk ml bi translated">“严格”模式</li><li id="c9f5" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated"><code class="fe kw kx ky kz b">const</code>关键字</li><li id="249f" class="md me iq ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">嵌套函数</li></ol><p id="e9ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从“严格”模式开始:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="a7e9" class="na lb iq kz b gy nb nc l nd ne">function myFunction() {<br/>    'use strict'   <br/>    console.log(this.a)<br/>}</span><span id="2c08" class="na lb iq kz b gy nf nc l nd ne">var a = 2;<br/>myFunction(); // undefined</span></pre><p id="74c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">this</code>未定义，因为在JavaScript中使用严格模式会使全局范围不可用。严格模式的目的是迫使开发人员注意范围、安全性和其他最佳编码实践，实现这一点的方法之一是限制全局对象的使用。</p><p id="63f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，对于<code class="fe kw kx ky kz b">const</code>这个关键词:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="669d" class="na lb iq kz b gy nb nc l nd ne">function myFunction() {<br/>    console.log(this.a);<br/>}</span><span id="0ef9" class="na lb iq kz b gy nf nc l nd ne">const a = 2;<br/>myFunction(); // undefined</span></pre><p id="18d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe kw kx ky kz b">const</code>关键字不会使变量在全局对象上可用。要看到这一点，打开谷歌浏览器，进入控制台。键入以下内容:</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="d8ec" class="na lb iq kz b gy nb nc l nd ne">var a1 = 2;<br/>const a2 = 2;</span><span id="b702" class="na lb iq kz b gy nf nc l nd ne">// In a browser, window is the global object<br/>// In a NodeJS console, you would replace "window" with "global"<br/>window.a1 // 2<br/>window.a2 // undefined</span></pre><p id="54f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，嵌套函数:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="291d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谈了这么多关于调用栈和调用点的内容，您可能会看一下上面的代码，并推断出<code class="fe kw kx ky kz b">this</code>代表的不是全局对象。打印<code class="fe kw kx ky kz b">this.a</code>时，调用栈顶部有f3()，表示<code class="fe kw kx ky kz b">f1()</code>的“调用地点”在<code class="fe kw kx ky kz b">f2()</code>。换句话说，即使<code class="fe kw kx ky kz b">f1()</code>在全局范围内执行，也不意味着它的调用地点在全局范围内。调用地点在<code class="fe kw kx ky kz b">f2()</code>范围内。</p><p id="6021" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">知道了这一点，你可能会猜测<code class="fe kw kx ky kz b">this.a</code>的值应该是6，因为这是打印<code class="fe kw kx ky kz b">this.a</code>时<code class="fe kw kx ky kz b">f1()</code>的调用位置处<code class="fe kw kx ky kz b">a</code>的值。</p><p id="d9d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但事实并非如此。由于<code class="fe kw kx ky kz b">f1()</code>是作为一个“普通”函数调用被调用的，所以它的作用域总是全局的，因此在上面的代码中<code class="fe kw kx ky kz b">this.a</code>等于2。</p><h1 id="309e" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">隐式结合</h1><p id="53b5" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">最后，是<code class="fe kw kx ky kz b">this</code>变得有点混乱的部分。如果我们调用一个函数作为一个对象的属性，<code class="fe kw kx ky kz b">this</code>的值完全基于函数的调用位置。</p><pre class="ms mt mu mv gt mw kz mx my aw mz bi"><span id="32ad" class="na lb iq kz b gy nb nc l nd ne">var obj1 = {<br/>    color: 'green',<br/>    func: () =&gt; {<br/>        console.log(this.color); // undefined<br/>    }<br/>}</span><span id="5a9a" class="na lb iq kz b gy nf nc l nd ne">var obj2 = {<br/>    color: 'green',<br/>    func: function () {<br/>        console.log(this.color); // green<br/>    }<br/>}</span><span id="878e" class="na lb iq kz b gy nf nc l nd ne">obj1.func(); // undefined<br/>obj2.func(); // green</span></pre><p id="1991" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我展示了两个概念，对于<code class="fe kw kx ky kz b">this</code>的隐式绑定，您必须理解这两个概念。显然，这两个函数都是从全局范围调用的，但是如果您确定了真正的调用位置，它就在每个对象的上下文中，因此，<code class="fe kw kx ky kz b">this</code>的值就是上下文对象。</p><p id="5a4d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第二个函数调用<code class="fe kw kx ky kz b">obj2.func()</code>中，结果并不令人惊讶。我们已经确定这个函数的调用点是<code class="fe kw kx ky kz b">obj2</code>对象，它的属性<code class="fe kw kx ky kz b">color</code>等于绿色。</p><p id="9396" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个函数调用有点令人困惑，它与函数属性的语法有关。ES6中引入了胖箭头功能。与普通的函数声明不同，胖箭头函数中的<code class="fe kw kx ky kz b">this</code>关键字遵循词法(与“静态”同义)作用域规则，而不是动态作用域规则，在动态作用域规则中，我们必须查看调用堆栈并确定调用位置以确定<code class="fe kw kx ky kz b">this</code>的值。</p><p id="1fe8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以胖箭头函数中的<code class="fe kw kx ky kz b">this</code>的值是全局对象，不具备<code class="fe kw kx ky kz b">color</code>的属性。</p><p id="f15c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">胖箭头函数对<code class="fe kw kx ky kz b">this</code>的处理为开发人员解决了一个问题，最好用例子来说明。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="3eb1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于前面的例子，你可能会猜测<code class="fe kw kx ky kz b">this.color</code>等于绿色。但是如果你还记得关于<a class="ae nu" href="https://dillinger.io/#default-binding" rel="noopener ugc nofollow" target="_blank">默认绑定</a>的章节，如果我们“正常地”调用一个函数(即<code class="fe kw kx ky kz b">myAsyncFunction</code>已经被正常地调用了)，<code class="fe kw kx ky kz b">this</code>将代表全局对象。为了解决这个问题，JavaScript开发人员使用了如下方法:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Assigning `this` to `self`</figcaption></figure><p id="675d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过将<code class="fe kw kx ky kz b">this</code>的值赋给一个变量，同时我们可以访问它，我们可以将它传递给回调函数并使用它。</p><p id="307c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然，这是一种人为的使用<code class="fe kw kx ky kz b">this</code>的方式。还有一个更好的方法，它涉及到ES6的胖箭头功能:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="3477" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这种模式需要对关键字<code class="fe kw kx ky kz b">this</code>有相当深刻的理解，并且让你想知道为什么有人会首先去找麻烦？</p><h1 id="97ca" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">为什么首先使用<code class="fe kw kx ky kz b">this</code>？</h1><p id="b80b" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">在所有这些解释之后，你可能想知道为什么有人会不厌其烦地在他们的代码中使用<code class="fe kw kx ky kz b">this</code>？</p><p id="e324" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管这完全是个人观点，但我看不出有什么过分令人信服的理由来为我写的JavaScript使用<code class="fe kw kx ky kz b">this</code>关键字。就我个人而言，我写了很多与应用相关的JavaScript，在很多情况下，很多人可能会看到，也可能不知道<code class="fe kw kx ky kz b">this</code>是如何工作的。为了让每个人都处于一个公平的竞争环境中，我发现尽可能在我的代码中去掉<code class="fe kw kx ky kz b">this</code>是更好的选择。也就是说，如果我正在为一个库/框架编写更健壮的JavaScript代码，我可能会有不同的看法。</p><p id="8deb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">也就是说，有一个令人信服的理由来彻底了解<code class="fe kw kx ky kz b">this</code>是如何工作的。无论你发起多大规模的反对在代码库中使用<code class="fe kw kx ky kz b">this</code>的运动，总会有代码库利用它。因此，不管您是否选择在您的代码库中实现<code class="fe kw kx ky kz b">this</code>，您肯定需要知道它是如何工作的。</p><p id="3007" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">至此，我希望这个对关键字<code class="fe kw kx ky kz b">this</code>的深入探究能帮助你理解，就像它帮助我一样。另外，我很想听听你对<code class="fe kw kx ky kz b">this</code>关键词的看法。我们应该使用它吗？为什么？</p></div></div>    
</body>
</html>