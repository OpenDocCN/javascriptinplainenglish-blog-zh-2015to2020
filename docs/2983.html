<html>
<head>
<title>What people don’t know about immutable objects in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于JavaScript中的不可变对象，人们不知道的是</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-people-dont-know-about-immutable-objects-in-javascript-74f737bcdcb6?source=collection_archive---------2-----------------------#2020-08-14">https://javascript.plainenglish.io/what-people-dont-know-about-immutable-objects-in-javascript-74f737bcdcb6?source=collection_archive---------2-----------------------#2020-08-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1844" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi kl translated"><span class="l km kn ko bm kp kq kr ks kt di"> J </span> avaScript (JS)也是函数式编程(FP)语言。FP的核心概念之一是不可变对象，这对其他编程范例，例如面向对象编程(OOP)也有很多好处。</p><p id="ca9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将向您解释不同类型的不可变对象，以及如何用JavaScript实现不可变对象。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div role="button" tabindex="0" class="la lb di lc bf ld"><div class="gh gi ku"><img src="../Images/da492225266f5f6a9e960154daabf690.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tnOQw9JgBI52TGIO"/></div></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">Photo by <a class="ae lk" href="https://unsplash.com/@jacklikethings?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jack O'Rourke</a> on <a class="ae lk" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="eb00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们先从可变对象开始:可变对象是在声明后可以修改的对象。例如，foo是一个可变对象:</p><pre class="kv kw kx ky gt ll lm ln lo aw lp bi"><span id="2554" class="lq lr iq lm b gy ls lt l lu lv">let foo = {<br/>    a: "b"<br/>};<br/>let bar = foo;<br/>bar.a = "c";</span><span id="1805" class="lq lr iq lm b gy lw lt l lu lv">console.log(foo.a); // c</span></pre><p id="2bd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">默认情况下，JS中的自定义对象是可变的。可变对象的问题是改变对象的值会传播到它的所有引用。这被称为副作用，会导致难以调试的错误。</p><p id="88fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，不可变对象是一个在声明之后不能被改变的对象。默认情况下，数学、日期、数字和字符串在JS中是不可变的，这意味着您不能删除、添加或覆盖它们的属性。例如，您想将字符串<code class="fe lx ly lz lm b">Hello</code>与<code class="fe lx ly lz lm b">world</code>连接起来，如下所示:</p><pre class="kv kw kx ky gt ll lm ln lo aw lp bi"><span id="7c5a" class="lq lr iq lm b gy ls lt l lu lv">let foo = "Hello" + "world";<br/>console.log(foo); // Hello world</span></pre><p id="41b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">字符串<code class="fe lx ly lz lm b">Hello</code>未被修改。相反，创建了一个新字符串。原来的<code class="fe lx ly lz lm b">Hello</code>保持不变。</p><p id="277d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有些人认为用关键字<code class="fe lx ly lz lm b">const</code>创建的常量是不可变的对象:</p><pre class="kv kw kx ky gt ll lm ln lo aw lp bi"><span id="df4f" class="lq lr iq lm b gy ls lt l lu lv">const foo = {<br/>  a: "x"<br/>};</span><span id="0b7c" class="lq lr iq lm b gy lw lt l lu lv">foo = {<br/>  a: "y"<br/>}; // error</span></pre><p id="11dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您试图重新分配它，上面的代码会抛出一个错误。有些人认为这就是不变性含义。但事实并非如此，如下例所示:</p><pre class="kv kw kx ky gt ll lm ln lo aw lp bi"><span id="59b7" class="lq lr iq lm b gy ls lt l lu lv">const foo = {<br/>  a: "x"<br/>};</span><span id="af36" class="lq lr iq lm b gy lw lt l lu lv">foo.a = "y";<br/>console.log(foo.a); // y</span></pre><p id="8a95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lx ly lz lm b">const</code>在JS里只表示不能重新分配。所以，<code class="fe lx ly lz lm b">const</code>中的“常量”部分只指指针——你不能改变指针。但是，正如您在上面看到的，您仍然可以更改对象的属性。这不仅适用于自定义对象，也适用于内置对象，如数组。</p><p id="6473" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在JavaScript中，创建不可变对象有不同的方法。</p><h2 id="0a1b" class="lq lr iq bd ma mb mc dn md me mf dp mg jy mh mi mj kc mk ml mm kg mn mo mp mq bi translated">定义属性</h2><p id="3c97" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">在JS中，对象具有(隐藏的)属性<code class="fe lx ly lz lm b">writeable</code>和<code class="fe lx ly lz lm b">configurable</code>，您可以手动将其设置为<code class="fe lx ly lz lm b">false</code>，从而防止改变或删除值:</p><pre class="kv kw kx ky gt ll lm ln lo aw lp bi"><span id="4baa" class="lq lr iq lm b gy ls lt l lu lv">const immutableFoo = {};<br/>Object.defineProperty(immutableFoo, "a", {<br/>  value: "d",<br/>  writable: false,<br/>  configurable: false<br/>});</span><span id="99bd" class="lq lr iq lm b gy lw lt l lu lv">console.log(immutableFoo.a); // d<br/>immutableFoo.a = "z";<br/>delete immutableFoo.a;<br/>console.log(immutableFoo.a); // d</span></pre><p id="b3c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，您仍然可以向对象添加新属性</p><h2 id="26fb" class="lq lr iq bd ma mb mc dn md me mf dp mg jy mh mi mj kc mk ml mm kg mn mo mp mq bi translated">预防高血压</h2><p id="477a" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">如果您想防止向对象添加新属性，并保持对象的其余属性不变，您可以这样做:</p><pre class="kv kw kx ky gt ll lm ln lo aw lp bi"><span id="f36d" class="lq lr iq lm b gy ls lt l lu lv">const immutableFoo = {<br/>  a: "e"<br/>};<br/>Object.preventExtensions(immutableFoo);</span><span id="f797" class="lq lr iq lm b gy lw lt l lu lv">immutableFoo.b = "z";<br/>console.log(immutableFoo.b); // undefined</span></pre><p id="e369" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是<code class="fe lx ly lz lm b">preventExtensions</code>并不能阻止你的属性被覆盖或者被删除。</p><h2 id="525f" class="lq lr iq bd ma mb mc dn md me mf dp mg jy mh mi mj kc mk ml mm kg mn mo mp mq bi translated">海豹</h2><p id="64db" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated"><code class="fe lx ly lz lm b">Object.seal()</code>创建一个“密封”的对象，这意味着它接受一个对象并调用<code class="fe lx ly lz lm b">Object.preventExtension()</code>。除此之外，它设置所有对象的属性为<code class="fe lx ly lz lm b">configurable: false</code>。通过这样做，您既不能添加也不能删除属性。</p><pre class="kv kw kx ky gt ll lm ln lo aw lp bi"><span id="b657" class="lq lr iq lm b gy ls lt l lu lv">const immutableFoo = {<br/>  a: "e"<br/>};<br/>Object.seal(immutableFoo);<br/>immutableFoo.b = "z";<br/>console.log(immutableFoo.b); // undefined</span><span id="50f5" class="lq lr iq lm b gy lw lt l lu lv">immutableFoo.a = "999";<br/>delete immutableFoo.a;<br/>console.log(immutableFoo.a); // 999</span></pre><p id="a041" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是您仍然可以更改属性值。</p><h2 id="8c6b" class="lq lr iq bd ma mb mc dn md me mf dp mg jy mh mi mj kc mk ml mm kg mn mo mp mq bi translated">冻结</h2><p id="02a7" class="pw-post-body-paragraph jn jo iq jp b jq mr js jt ju ms jw jx jy mt ka kb kc mu ke kf kg mv ki kj kk ij bi translated">使用freeze，您可以在JS中创建真正不可变的对象，这意味着您不能删除、添加或覆盖对象的属性。</p><pre class="kv kw kx ky gt ll lm ln lo aw lp bi"><span id="b9ac" class="lq lr iq lm b gy ls lt l lu lv">const immutableFoo = {<br/>  a: "e"<br/>};<br/>Object.freeze(immutableFoo);<br/>immutableFoo.b = "z";<br/>console.log(immutableFoo.b); // undefined</span><span id="0279" class="lq lr iq lm b gy lw lt l lu lv">immutableFoo.a = "999";<br/>delete immutableFoo.a;<br/>console.log(immutableFoo.a); // e</span></pre></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="22f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，在JS中，有一些方法可以模拟不可变对象的各个方面。但是只有一种方法能够在JS中创建完全不可变的对象。下面是这些方法的总结，以及它们覆盖了不可变属性的哪一部分。只有<code class="fe lx ly lz lm b">Object.freeze()</code>能够阻止所有形式的变异。所以，如果你想在JS中创建不可变的对象，只能选择<code class="fe lx ly lz lm b">Object.freeze()</code>。</p><figure class="kv kw kx ky gt kz gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/6f3f0108a2438f55fd4d6fc6dd591833.png" data-original-src="https://miro.medium.com/v2/resize:fit:874/format:webp/1*_jHALo3mPMg9vMlItGJI6w.png"/></div></figure><p id="faba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你有任何问题，请在下面评论并告诉我。</p></div></div>    
</body>
</html>