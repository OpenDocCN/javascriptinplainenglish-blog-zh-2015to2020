<html>
<head>
<title>JavaScript Best Practices —Names, jQuery, and Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—名称、jQuery和对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-names-jquery-and-objects-450904d2c191?source=collection_archive---------5-----------------------#2020-06-07">https://javascript.plainenglish.io/javascript-best-practices-names-jquery-and-objects-450904d2c191?source=collection_archive---------5-----------------------#2020-06-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/baa48dad36e46db6a0449762d8abec7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OfirkfepXtkK0pQq"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@danieljerez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daniel Jerez</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0d3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="1b5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究命名事物以及处理对象、名称和jQuery代码的最佳方式。</p><h1 id="1938" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用PascalCase导出构造函数、类、单例或库</h1><p id="7275" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们坚持使用PascalCase，因为我们没有导出构造函数、类、单例对象和库。</p><p id="cfd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6ab9" class="mn lc iq mj b gy mo mp l mq mr">const StudentUser = {<br/>  //...<br/>};<br/><br/>export default StudentUser;</span></pre><p id="c2ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也适用于构造函数和构造函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="453d" class="mn lc iq mj b gy mo mp l mq mr">class StudentUser {<br/>  //...<br/>}</span><span id="13f0" class="mn lc iq mj b gy ms mp l mq mr">function StudentUser {<br/>  //...<br/>}</span></pre><h1 id="8998" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">首字母缩写词应该全部大写或小写</h1><p id="56bd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">首字母缩略词都用同一个字母会使它们更易读。</p><p id="0610" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="089a" class="mn lc iq mj b gy mo mp l mq mr">const HTTPResponses = [<br/>  // ...<br/>];</span></pre><p id="485d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4d04" class="mn lc iq mj b gy mo mp l mq mr">const httpResponses = [<br/>  // ...<br/>];</span></pre><h1 id="b0c8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么时候我们应该让常量名大写？</h1><p id="488a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当常数不变时，我们可以用常数命名特例。</p><p id="ba60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让它们大写意味着我们可以相信不会改变。</p><p id="926f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果常量名称被导出，我们也应该让它们大写。</p><p id="d5a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，这应该只适用于最高级别。</p><p id="01c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="691b" class="mn lc iq mj b gy mo mp l mq mr">export const API_KEY = 'foo';</span></pre><p id="f992" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a939" class="mn lc iq mj b gy mo mp l mq mr">export const FOO = {<br/>  key: 'value'<br/>};</span></pre><h1 id="7ecc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">访问者</h1><p id="846a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不需要属性的访问函数。</p><p id="712d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不应该使用JavaScript getters或setters，因为它们有意想不到的副作用。</p><p id="58f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们也使我们的代码更难理解。</p><p id="68a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们创建函数来获取和设置我们的值。</p><p id="66b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6944" class="mn lc iq mj b gy mo mp l mq mr">class Person {<br/>  get age() {<br/>    // ...<br/>  }</span><span id="8f78" class="mn lc iq mj b gy ms mp l mq mr">  set age(value) {<br/>    // ...<br/>  }<br/>}</span></pre><p id="2756" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f569" class="mn lc iq mj b gy mo mp l mq mr">class Person {<br/>  getAge() {<br/>    // ...<br/>  }</span><span id="ab4e" class="mn lc iq mj b gy ms mp l mq mr">  setAge(value) {<br/>    // ...<br/>  }<br/>}</span></pre><p id="8001" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正常的方法更容易理解。</p><h1 id="3395" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如果一个属性或方法返回一个布尔值，那么我们给它加上前缀<code class="fe mt mu mv mj b">is</code>或<code class="fe mt mu mv mj b">has</code></h1><p id="29d9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">例如，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4d3d" class="mn lc iq mj b gy mo mp l mq mr">person.hasAge()</span></pre><p id="545c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3fd4" class="mn lc iq mj b gy mo mp l mq mr">person.age()</span></pre><p id="0b12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们知道这个函数是做什么的了。</p><h1 id="c310" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建获取和设置函数</h1><p id="83d0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建<code class="fe mt mu mv mj b">get</code>和<code class="fe mt mu mv mj b">set</code>函数来获取和设置值。</p><p id="d918" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f724" class="mn lc iq mj b gy mo mp l mq mr">class Person {<br/>  constructor() {<br/>    //...<br/>  }</span><span id="cd3f" class="mn lc iq mj b gy ms mp l mq mr">  set(key, val) {<br/>    this[key] = val;<br/>  }</span><span id="74eb" class="mn lc iq mj b gy ms mp l mq mr">  get(key) {<br/>    return this[key];<br/>  }<br/>}</span></pre><p id="1a1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以通过它们的键和值动态地获取和设置值。</p><h1 id="43c3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">触发事件</h1><p id="3226" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们触发事件，我们应该传入一个对象而不是一个原始值。</p><p id="9eff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8e9b" class="mn lc iq mj b gy mo mp l mq mr">const event = new CustomEvent("eventName", {<br/>  "detail": "event"<br/>});<br/>document.dispatchEvent(event);</span><span id="8363" class="mn lc iq mj b gy ms mp l mq mr">document.addEventListener("eventName", (e) =&gt; {<br/>  console.log(e.detail);<br/>});</span></pre><p id="36d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有一个对象作为<code class="fe mt mu mv mj b">detail</code>的值而不是一个原始值。</p><p id="2436" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们总是用一个事件发送一个对象，那么我们就不必检查发送的对象是一个原始值还是一个对象。</p><h1 id="9ee3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">jQuery</h1><p id="a31d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们使用<code class="fe mt mu mv mj b">jQuery</code>，我们应该添加一个<code class="fe mt mu mv mj b">$</code>前缀，这样我们就知道它是由jQuery返回的。</p><p id="64e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="28b8" class="mn lc iq mj b gy mo mp l mq mr">const $main = $('.main');</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e7b285f68026b17ca18c86937b8b3c24.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xLi-Kj3bvPY4iKMU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jakubkriz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jakub Kriz</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a6fc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">缓存jQuery查找</h1><p id="adb7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们用jQuery查找一些东西，我们应该缓存它们，这样我们就不必重复查找相同的东西。</p><p id="3de8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d331" class="mn lc iq mj b gy mo mp l mq mr">const main = $('.main');<br/>main.hide();<br/>// ...</span><span id="bfd6" class="mn lc iq mj b gy ms mp l mq mr">main.css({<br/>  'background-color': 'green',<br/>});</span></pre><h1 id="35db" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对作用域jQuery对象查询使用<code class="fe mt mu mv mj b">find</code></h1><p id="7e7f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用<code class="fe mt mu mv mj b">find</code>进行限定范围的查询。</p><p id="6b41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们只对一个查询使用一个CSS选择器:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4b04" class="mn lc iq mj b gy mo mp l mq mr">$('.main ul').hide();</span></pre><p id="1c02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们只需要查找一次，而不是两次。</p><h1 id="1aa8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">箭头功能</h1><p id="5e6f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于回调，我们应该尽可能多地使用箭头函数。</p><p id="5bc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d345" class="mn lc iq mj b gy mo mp l mq mr">[1, 2, 3].map((x) =&gt; x + 1);</span></pre><p id="0a08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比用传统函数要短很多。</p><p id="75b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">this</code>的值在里面也不变。</p><h1 id="dc1e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">跳过括号</h1><p id="59a2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果函数只有一条语句，我们可以跳过括号，使用隐式返回。</p><p id="b306" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的例子告诉我们，我们可以跳过括号，返回一些东西。</p><p id="b965" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3ab1" class="mn lc iq mj b gy mo mp l mq mr">(x) =&gt; x + 1</span></pre><p id="b78b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回<code class="fe mt mu mv mj b">x</code>加1。</p><h1 id="0c6c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="8ffa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了在使用jQuery时加快速度，我们应该缓存查询。</p><p id="30cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不应该使用<code class="fe mt mu mv mj b">find</code>进行限定范围的查询。相反，使用一个CSS选择器。</p><p id="31d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该坚持标准的JavaScript命名约定。</p><p id="f879" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该对访问器使用<code class="fe mt mu mv mj b">get</code>和<code class="fe mt mu mv mj b">set</code>关键字。</p><h2 id="ed8a" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">简单英语的JavaScript</h2><p id="c40a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>