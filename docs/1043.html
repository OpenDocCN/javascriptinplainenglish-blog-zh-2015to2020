<html>
<head>
<title>ReactJS Training: Creating your first game with React and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ReactJS培训:使用React和TypeScript创建您的第一个游戏</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reactjs-training-creating-your-first-game-with-react-and-typescript-162f56b75e78?source=collection_archive---------2-----------------------#2020-01-20">https://javascript.plainenglish.io/reactjs-training-creating-your-first-game-with-react-and-typescript-162f56b75e78?source=collection_archive---------2-----------------------#2020-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/10845cfda170d88e83b80b0346f67455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QaEF8m8VFeJrNZKifZVhSg.png"/></div></div></figure><blockquote class="jy jz ka"><p id="bd6a" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想知道西班牙艺术的版本，请点击<a class="ae la" href="https://medium.com/@nanovazquez/reactjs-training-creando-tu-primer-juego-con-react-y-typescript-43232b988d87" rel="noopener">进入</a>。</p></blockquote><p id="f14e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">既然我们已经介绍了基础知识，是时候让事情变得真实了。在本练习中，我们将从头开始建立一个React应用程序，然后我们将在它的基础上实现<a class="ae la" href="https://en.wikipedia.org/wiki/Connect_Four" rel="noopener ugc nofollow" target="_blank"> Connect Four </a>游戏。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi le"><img src="../Images/95c7ca48e01bfff5bfa8ccace2d761f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jIWs2uKam0Ybln9r-TE-vw.gif"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">This is the game we are going to build in this post: Connect four</figcaption></figure><p id="8679" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">通过遵循本逐步演练，您将在编写实际应用程序时了解React和TypeScript。你准备好了吗？👾</p><h1 id="017d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">初始设置</h1><blockquote class="jy jz ka"><p id="19f3" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>如果你想马上开始游戏逻辑，你可以跳过这一节，然后<a class="ae la" href="https://github.com/nanovazquez/reactjs-training/tree/master/exercise-2/begin/connect-four" rel="noopener ugc nofollow" target="_blank">打开本练习的<strong class="ke ir"> begin </strong>应用，位于本次培训的GitHub资源库</a>。记得在用<code class="fe ml mm mn mo b"><em class="iq">npm start</em></code>运行之前先用<code class="fe ml mm mn mo b"><em class="iq">npm install</em></code>。</p></blockquote><p id="e468" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">正如我们在上一篇文章中解释的那样，TypeScript和JSX都不能在浏览器中运行。因为我们要用这些语言编写代码，所以在执行我们的应用程序之前，我们需要<em class="kd">转换它。为此，我们有两种选择:</em></p><ol class=""><li id="1557" class="mp mq iq ke b kf kg kj kk lb mr lc ms ld mt kz mu mv mw mx bi translated">自己呈现、解释、分析和配置多个工具(Webpack/Rollup、Babel/tsconfig、CSS模块等。)</li><li id="d524" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz mu mv mw mx bi translated">利用“架子工”(也称为<em class="kd">集成工具链</em>)，这是已经预先配置好的烘焙应用，不需要任何额外的设置就可以开始，让我们<strong class="ke ir">只关注我们的代码</strong>。</li></ol><p id="ec12" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在这篇文章中，我们将采用后一种选择，利用脸书的<a class="ae la" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React app </a>，这是当今构建React应用程序的事实上的工具。</p><p id="f903" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">设置起来非常简单:</p><p id="dcd0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在你的终端中，运行<code class="fe ml mm mn mo b">npx create-react-app connect-four --typescript</code>。该命令将在文件夹<strong class="ke ir"> connect-four </strong>中创建一个TypeScript应用程序。等待该过程完成。您应该会看到类似以下内容的消息:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/5e370885547cec56ef062d22d3ba803c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EOYOj0aHiD2YRejG8GhUng.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Create React app installation completed successfully message</figcaption></figure><blockquote class="jy jz ka"><p id="558c" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>如果<code class="fe ml mm mn mo b"><em class="iq">npx</em></code>不起作用，先用<code class="fe ml mm mn mo b"><em class="iq">npm i -g create-react-app</em></code>再用<code class="fe ml mm mn mo b"><em class="iq">create-react-app connect-four --typescript</em></code>试试。</p></blockquote><p id="3134" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">浏览到您刚刚创建的<strong class="ke ir"> connect-four </strong>文件夹，花一两分钟时间分析文件夹结构。您正在查看一个全功能的应用程序，其业务逻辑位于<strong class="ke ir"> src </strong>文件夹中:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="f23d" class="ni lo iq mo b gy nj nk l nl nm"><strong class="mo ir">connect-four<br/></strong>├── node_modules<br/>│   ├── ...<br/>├── public<br/>│   ├── favicon.ico<br/>│   ├── index.html<br/>│   └── manifest.json<br/>│   └── ...<br/><strong class="mo ir">├── src<br/></strong>│   ├── App.css<br/>│   ├── <strong class="mo ir">App.tsx<br/></strong>│   ├── index.css<br/>│   ├── index.tsx<br/>│   └── ...<br/>├── package.json<br/>├── tsconfig.json<br/>└── ...</span></pre><p id="cb59" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在，运行<code class="fe ml mm mn mo b">npm start</code>。该命令在<em class="kd">“开发模式”</em>下执行应用程序，这提供了许多额外的好处，如当您对代码进行更改时自动重新加载(也称为<a class="ae la" href="https://webpack.js.org/concepts/hot-module-replacement/" rel="noopener ugc nofollow" target="_blank">热模块替换</a>)。</p><p id="f068" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">打开<a class="ae la" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>在浏览器中可视化您的应用程序:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/77c2af17e108a4231d123f8819a6b890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hya1iogUfrxJlh83AJWw2A.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Create React app initial Home screen</figcaption></figure><p id="d4a3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">恭喜你！你已经用React和TypeScript创建了你的第一个应用程序👏 💃 🕺 👏</p><p id="8e8f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">让我们兜一圈。使用VSCode或您偏好的IDE打开应用程序，并导航到<strong class="ke ir"> src/App.tsx </strong>文件夹。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/7340afe7503c370405558efc2e0f04d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2nPm8SyIS2_fqU4x_SUYdA.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">App.tsx file autogenerated by Create React app</figcaption></figure><blockquote class="jy jz ka"><p id="5f86" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注:</strong>亲提示！您可以通过运行<code class="fe ml mm mn mo b"><em class="iq">code .</em></code>打开指向您终端所在文件夹的VSCode。类似地，您可以用<code class="fe ml mm mn mo b"><em class="iq">atom .</em></code>对Atom做同样的事情。而对于Sublime，可以运行<code class="fe ml mm mn mo b"><em class="iq">subl .</em></code>。</p></blockquote><p id="0714" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">花几分钟时间来分析这个文件中的代码:</p><ul class=""><li id="970d" class="mp mq iq ke b kf kg kj kk lb mr lc ms ld mt kz np mv mw mx bi translated">在顶部，有<code class="fe ml mm mn mo b">import</code>语句。这是JavaScript (ES6)将模块导入文件的方式。导入的值存储在变量中供以后使用。<em class="kd">你可以在这里</em>  <em class="kd">了解更多ES6进口</em> <a class="ae la" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank"> <em class="kd">。</em></a></li><li id="baf8" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated"><em class="kd">第5行</em>定义了一个名为<code class="fe ml mm mn mo b">App</code>的<a class="ae la" href="https://reactjs.org/docs/components-and-props.html#function-and-class-components" rel="noopener ugc nofollow" target="_blank">反应函数组件</a>。它返回JSX代码，稍后将由浏览器呈现(在翻译之后)。<em class="kd"> React组件帮助我们将代码分割成小块，遵循单一责任原则(或者</em><a class="ae la" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank"><em class="kd">SRP</em></a><em class="kd">)。</em></li><li id="ad54" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">在第7行和第22行之间有JSX代码，代表我们在浏览器中看到的渲染。注意，除了第9行使用JavaScript变量引用(<code class="fe ml mm mn mo b">&lt;img src={logo} .. /&gt;</code>)设置了<em class="kd"> src </em>属性之外，它几乎与HTML相同。</li><li id="d5a5" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">最后，<em class="kd">第26行</em> <em class="kd">导出</em>我们的<code class="fe ml mm mn mo b">&lt;App /&gt;</code>函数，使其可以被<em class="kd">导入到其他文件中</em>。</li></ul><p id="6ffa" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在本地运行应用程序(如果您已经停止了它，在您的终端中运行<code class="fe ml mm mn mo b">npm start</code>，通过删除第<em class="kd">行第22、</em>行中的<code class="fe ml mm mn mo b">&lt;/div&gt;</code>结束标签来修改代码，并保存您的更改。</p><p id="8897" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">请注意，VSCode(或您的IDE)现在会显示一个错误:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/d2a5d6a5afd6fdaf7ee9462d4164e9d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TPimvghyamhjyno1Sd8xXw.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Error message displayed in VSCode</figcaption></figure><p id="da05" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">浏览器显示一个编译错误:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/aa8861189d117ddf093b988e7fbc5628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1328/format:webp/1*wdjNPwdDrW7CUvZfS_Mavg.png"/></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Compilation error in the browser</figcaption></figure><p id="da8c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">通过撤销您所做的来修复错误(我们移除了<code class="fe ml mm mn mo b">&lt;/div&gt;</code>结束标签)，保存您的更改并等待浏览器刷新您的应用。</p><p id="37dd" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在，打开<strong class="ke ir"> src/index.tsx </strong>文件。这是应用程序的主要入口点:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="03a4" class="ni lo iq mo b gy nj nk l nl nm">import React from “react”;<br/>import ReactDOM from “react-dom”;<br/>import App from “./App”;</span><span id="ed49" class="ni lo iq mo b gy ns nk l nl nm">ReactDOM.render(&lt;App /&gt;, document.getElementById(“root”));</span></pre><p id="b039" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">你现在需要学习的最重要的事情是:</p><ul class=""><li id="99ce" class="mp mq iq ke b kf kg kj kk lb mr lc ms ld mt kz np mv mw mx bi translated">这个文件<em class="kd">导入</em>组件<code class="fe ml mm mn mo b">&lt;App /&gt;</code>，以及React和ReactDOM库。</li><li id="69aa" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">它执行<code class="fe ml mm mn mo b">ReactDOM.render()</code>方法，将<code class="fe ml mm mn mo b">&lt;App /&gt;</code>组件和一个以“root”为ID的文档(HTML)元素的引用作为参数传递。</li><li id="a5d1" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">你可以在<strong class="ke ir"> public/index.html </strong>文件中找到你的应用启动时浏览器呈现的HTML。在<em class="kd">第31行，</em>有一个空的<code class="fe ml mm mn mo b">&lt;div id="root"&gt;</code>元素。这是您的应用程序将被“装载”的地方，这意味着这是应用程序在<code class="fe ml mm mn mo b">render()</code>方法中的代码将被注入的地方(作为HTML)。</li></ul><p id="9c25" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这个文件的内容与我们在之前的帖子中看到的之前的基本示例<a class="ae la" href="https://medium.com/@nanovazquez/reactjs-training-understanding-react-and-typescript-d01deb2dd127" rel="noopener">完全相同。<strong class="ke ir">这就是React的强大之处:</strong>不管你的应用程序有多复杂，呈现它的代码都是一样的。</a></p><h2 id="5250" class="ni lo iq bd lp nt nu dn lt nv nw dp lx lb nx ny mb lc nz oa mf ld ob oc mj od bi translated">包扎</h2><p id="e330" class="pw-post-body-paragraph kb kc iq ke b kf oe kh ki kj of kl km lb og kp kq lc oh kt ku ld oi kx ky kz ij bi translated">在初始设置的快速演练中，我们执行了以下操作:</p><ol class=""><li id="32a3" class="mp mq iq ke b kf kg kj kk lb mr lc ms ld mt kz mu mv mw mx bi translated">我们用终端中的一个(npm)命令创建了一个全功能的web应用程序。</li><li id="2c24" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz mu mv mw mx bi translated">我们在本地执行web应用程序，并在浏览器中显示它。</li><li id="31ff" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz mu mv mw mx bi translated">我们分析了应用程序的<em class="kd"> React + TypeScript </em>代码，包括主要组件和主要入口代码，以及它的HTML代码。</li></ol><p id="1718" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">最后，不要忘记<strong class="ke ir">浏览器只理解HTML、JS和CSS </strong>，不理解TS或JSX。这个<em class="kd">搭建的应用</em>有一个<strong class="ke ir">构建</strong> <em class="kd">进程</em>，它将生成JS和CSS文件，并将它放在一个<strong class="ke ir"> dist </strong>文件夹中，并在<strong class="ke ir">index.html</strong>文件中引用，也生成。这些自动生成的文件将被发送到浏览器进行解析、读取、解释和执行。</p><blockquote class="jy jz ka"><p id="c567" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>如果你有兴趣阅读transpilation过程的深入解释，以及如何为此配置工具，请在这篇文章中添加评论，我会写的！</p></blockquote><h1 id="d835" class="ln lo iq bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">将游戏逻辑添加到应用中</h1><p id="7633" class="pw-post-body-paragraph kb kc iq ke b kf oe kh ki kj of kl km lb og kp kq lc oh kt ku ld oi kx ky kz ij bi translated">既然我们已经了解了React应用程序的基础，是时候添加游戏逻辑了。正如我们在上一篇文章中解释的那样，React应用程序将业务逻辑分成不同的组件。但是我们必须处理不同的责任:决定谁赢(以及是否有人赢)的逻辑，选择绘制元素(以及如何绘制)的逻辑，决定谁的玩家可以移动的逻辑，等等。我们如何以一致的可重复的方式划分这些职责？</p><p id="a537" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们将使用一个广为人知的模式，<a class="ae la" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">表示和容器组件</a>，以一个简单但强大的结构组织我们的组件:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/beabafba37727dfb9600f574ad840f6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vh7YSAHFshY6pk0fQYKfTQ.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">React data flows from “top to bottom”, while events bubble up information “from the bottom to the top”</figcaption></figure><p id="4901" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">该技术提出将所有业务逻辑和状态封装在父组件中(<em class="kd">容器</em>或<em class="kd">智能)</em>)。并使用它们的子组件，通常是树叶，来呈现UI和管理用户交互(<em class="kd">表示性</em>或<em class="kd">哑</em>组件)。</p><p id="1f4e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><em class="kd">容器</em>组件通过<strong class="ke ir">道具</strong>向其子组件发送数据和功能。<em class="kd">表示性</em>组件使用数据来决定画什么以及如何画。并在用户与这些函数交互时执行它们，通常以参数的形式发送信息。</p><blockquote class="jy jz ka"><p id="d752" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>由于你的应用程序将从上到下层叠信息，这种方法最适合中小型应用程序。由深度嵌套的层次结构组成的大型应用程序需要不同的方法。我们将在下一篇文章中讨论它。</p></blockquote><p id="d76b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">通过使用这种技术，我们可以识别以下实体:</p><ul class=""><li id="8f72" class="mp mq iq ke b kf kg kj kk lb mr lc ms ld mt kz np mv mw mx bi translated">一个<strong class="ke ir"> App </strong>组件，负责存储应用的状态。并计算出谁是赢家。就是<em class="kd">“父”/“容器”/“智能”</em>组件。</li><li id="5082" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">一个<strong class="ke ir">棋盘</strong>组件，负责绘制游戏的元素。该板由多个<strong class="ke ir">列</strong>组成，这些列由不同的<strong class="ke ir">块</strong>组成，这些块可能有也可能没有芯片。它们是“子元素”/“表象元素”/“哑元素”。</li><li id="26e5" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">当点击<strong class="ke ir">栏</strong>时，一个新的<strong class="ke ir">芯片</strong>被添加到底部一个空的<strong class="ke ir">瓷砖</strong>中。这是app业务逻辑的一部分。</li></ul><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/99fe87693c59020cd8ddfda27a8aa50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BrYV8jWlNeNyUA_2IjMggw.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Split the application’s logic into small components</figcaption></figure><blockquote class="ol"><p id="fba9" class="om on iq bd oo op oq or os ot ou kz dk translated">当然，您使用的组件可以根据您的偏好而有所不同。你能想出一种不同的方式来组织你的代码吗？</p></blockquote><h2 id="fcd7" class="ni lo iq bd lp nt ov dn lt nv ow dp lx lb ox ny mb lc oy oa mf ld oz oc mj od bi translated">创建单幅图块组件</h2><p id="940b" class="pw-post-body-paragraph kb kc iq ke b kf oe kh ki kj of kl km lb og kp kq lc oh kt ku ld oi kx ky kz ij bi translated">在<strong class="ke ir"> src </strong>文件夹内创建一个名为<strong class="ke ir"> components </strong>的新文件夹。</p><p id="458c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在该文件夹中，创建另一个名为<strong class="ke ir"> Tile </strong>的文件夹，并在其中添加以下(目前为空)文件:</p><ul class=""><li id="4129" class="mp mq iq ke b kf kg kj kk lb mr lc ms ld mt kz np mv mw mx bi translated">存储css代码的<strong class="ke ir"> Tile.module.css </strong>文件</li><li id="bdbf" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">React组件逻辑的<strong class="ke ir"> Tile.tsx </strong>文件</li><li id="6de1" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">以及用于组件的类型脚本类型的<strong class="ke ir"> types.ts </strong>文件。</li></ul><p id="3789" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">打开<strong class="ke ir">src/components/Tile/types . ts</strong>文件，粘贴以下代码:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="e840" class="ni lo iq mo b gy nj nk l nl nm">export interface Props {<br/>  id: string;<br/>  chipType?: string;<br/>  onClick: (id: string) =&gt; any;<br/>}</span></pre><p id="54a0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">通过键入<strong class="ke ir">瓦片</strong>组件的<strong class="ke ir">道具</strong>，我们定义了它的接口，或者契约。它告诉组件使用者:</p><ol class=""><li id="8088" class="mp mq iq ke b kf kg kj kk lb mr lc ms ld mt kz mu mv mw mx bi translated">它必须通过组件的<strong class="ke ir">道具</strong>提供一个<code class="fe ml mm mn mo b">id</code>。</li><li id="e8a5" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz mu mv mw mx bi translated">它可以向组件发送一个<code class="fe ml mm mn mo b">chipType</code>。如上所述，<strong class="ke ir">瓷砖</strong>可以有<strong class="ke ir">芯片</strong>也可以没有。</li><li id="f27a" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz mu mv mw mx bi translated">它必须附加一个功能到<code class="fe ml mm mn mo b">onClick</code>道具，当用户点击<strong class="ke ir">瓷砖</strong>时将被触发。</li></ol><p id="48de" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">然后，打开<strong class="ke ir">src/components/tile . tsx</strong>文件，粘贴以下代码:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="68f6" class="ni lo iq mo b gy nj nk l nl nm">import React from "react";<br/>import classNames from "classnames";<br/>import styles from "./Tile.module.css";<br/>import { Props } from "./types";</span><span id="f0e8" class="ni lo iq mo b gy ns nk l nl nm">export default class Tile extends React.PureComponent&lt;Props&gt; {</span><span id="b8b6" class="ni lo iq mo b gy ns nk l nl nm">render() {<br/>    const { id, chipType, onClick = () =&gt; {} } = this.props;<br/>    const chipCssClass = classNames(styles.chip, chipType === "red" ? styles.red : styles.yellow);<br/>    <br/>    return (<br/>      &lt;div className={styles.tile} onClick={() =&gt; onClick(id)}&gt;<br/>        {chipType &amp;&amp; &lt;div className={chipCssClass} /&gt;}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="e70b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">通过查看这段代码，你会注意到<strong class="ke ir"> Tile </strong>组件是一个<em class="kd"> presentational </em>组件，负责在你的板上绘制图块。它通过检查<code class="fe ml mm mn mo b">chipType</code>属性的值来决定<strong class="ke ir">芯片</strong>是否存在，并根据其值设置CSS类。最后，当点击时，它触发设置为<code class="fe ml mm mn mo b">onClick</code>道具的函数，发送<strong class="ke ir">图块</strong>的<code class="fe ml mm mn mo b">id</code>作为参数。</p><blockquote class="jy jz ka"><p id="4999" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>有没有注意到我们把<strong class="ke ir">道具</strong>接口附加到了<code class="fe ml mm mn mo b"><em class="iq">React.PureComponent</em></code>定义上？这就是你输入React class的方式。IDE将理解这一点，并告诉您组件中每个道具的类型。您可以通过将鼠标悬停在<code class="fe ml mm mn mo b">render()</code>方法的第一行中的<code class="fe ml mm mn mo b"><em class="iq">this.props</em></code>值上来查看这一点。试试看！</p></blockquote><p id="9eb9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">最后，打开<strong class="ke ir">src/components/tile . module . css</strong>文件，粘贴以下CSS代码:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="9469" class="ni lo iq mo b gy nj nk l nl nm">.tile {<br/>  width: 75px;<br/>  height: 75px;<br/>  border: solid 10px #3355ff;<br/>  border-radius: 100%;<br/>  background-color: white;<br/>}</span><span id="fcb4" class="ni lo iq mo b gy ns nk l nl nm">.chip {<br/>  width: 75px;<br/>  height: 75px;<br/>  border-radius: 100%;<br/>  background-color: gray;<br/>}</span><span id="fb25" class="ni lo iq mo b gy ns nk l nl nm">.yellow {<br/>  background-color: #ffff33;<br/>}</span><span id="c889" class="ni lo iq mo b gy ns nk l nl nm">.red {<br/>  background-color: #ff010b;<br/>}</span></pre><blockquote class="jy jz ka"><p id="6a85" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong> Create React app使用<code class="fe ml mm mn mo b"><em class="iq">[name].module.css</em></code>处理CSS文件的方式不同于普通的CSS文件，它使用<a class="ae la" href="https://github.com/css-modules/css-modules" rel="noopener ugc nofollow" target="_blank"> CSS模块</a>库来传输它们。这样做的主要好处是，您不需要担心CSS类名冲突，因为每个文件都可以被视为一个独立的模块。这是可以实现的，因为当传输文件时，所有CSS类名都被替换为格式<code class="fe ml mm mn mo b"><em class="iq">[filename]_[classname]__[hash]</em></code>的“唯一”值。</p><p id="0e81" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">有关该库的更多信息，请单击<a class="ae la" href="https://create-react-app.dev/docs/adding-a-css-modules-stylesheet" rel="noopener ugc nofollow" target="_blank">此处</a>。</p></blockquote><h2 id="c364" class="ni lo iq bd lp nt nu dn lt nv nw dp lx lb nx ny mb lc nz oa mf ld ob oc mj od bi translated">创建柱构件</h2><p id="5274" class="pw-post-body-paragraph kb kc iq ke b kf oe kh ki kj of kl km lb og kp kq lc oh kt ku ld oi kx ky kz ij bi translated">现在导航到<strong class="ke ir">组件</strong>文件夹，并在其中创建一个名为<strong class="ke ir">列</strong>的新文件夹。</p><p id="da2d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在这个文件夹中，创建以下文件:一个用于存储css代码的<strong class="ke ir"> Column.module.css </strong>文件，一个用于React组件逻辑的<strong class="ke ir"> Column.tsx </strong>文件和一个用于组件类型脚本类型的<strong class="ke ir"> types.ts </strong>文件。</p><p id="d198" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">打开<strong class="ke ir">src/components/Column/types . ts</strong>文件，粘贴下面定义<strong class="ke ir">列</strong>组件的props (contract)的代码:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="ca12" class="ni lo iq mo b gy nj nk l nl nm">import { ChipsPositions } from "../App/types";</span><span id="a145" class="ni lo iq mo b gy ns nk l nl nm">export interface Props {<br/>  column: number;<br/>  rows: number;<br/>  chipsPositions: ChipsPositions;<br/>  onTileClick: (id: string) =&gt; any;<br/>}</span></pre><p id="fcee" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这段代码告诉组件的使用者:</p><ul class=""><li id="15f6" class="mp mq iq ke b kf kg kj kk lb mr lc ms ld mt kz np mv mw mx bi translated">它需要提供一个<code class="fe ml mm mn mo b">column</code>号。该值充当元素的ID。</li><li id="f6a1" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">它需要定义<strong class="ke ir">列</strong>组件将有多少个<code class="fe ml mm mn mo b">rows</code>。</li><li id="9dd0" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated"><code class="fe ml mm mn mo b">chipsPositions</code>道具是知道每个筹码位置的对象。我们将在后面看到这个对象是如何构建的。现在，你只需要知道它能告诉我们<strong class="ke ir">瓷砖</strong>里面是否有芯片。</li><li id="93ac" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">最后，<code class="fe ml mm mn mo b">onTileClick</code>函数用于让父节点知道用户何时点击了特定的磁贴。</li></ul><p id="19a9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">打开<strong class="ke ir">src/components/column . tsx</strong>文件，粘贴以下代码:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="5495" class="ni lo iq mo b gy nj nk l nl nm">import React from "react";<br/>import Tile from "../Tile/Tile";<br/>import styles from "./Column.module.css";<br/>import { Props } from "./types";</span><span id="f10f" class="ni lo iq mo b gy ns nk l nl nm">export default class Column extends React.PureComponent&lt;Props&gt; {</span><span id="63f7" class="ni lo iq mo b gy ns nk l nl nm">  render() {<br/>    const { column, rows, chipsPositions, onTileClick } = this.props;<br/>    const tiles = [];<br/>    <br/>    for (let row = 0; row &lt; rows; row++) {<br/>      const tileId = `${row}:${column}`;<br/>      const chipType = chipsPositions[tileId];<br/>      tiles.push(<br/>        &lt;Tile<br/>          key={tileId}<br/>          id={tileId}<br/>          chipType={chipType}<br/>          onClick={onTileClick}<br/>        /&gt;<br/>      );<br/>    }</span><span id="62c8" class="ni lo iq mo b gy ns nk l nl nm">    return &lt;div className={styles.column}&gt;{tiles}&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="74d4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这段(也是<em class="kd">表示性</em>)代码呈现一个<code class="fe ml mm mn mo b">&lt;div&gt;</code>元素，该元素包含与<code class="fe ml mm mn mo b">rows</code>值所指示的<strong class="ke ir">平铺</strong>组件一样多的<code class="fe ml mm mn mo b">&lt;div&gt;</code>组件(通过<em class="kd">道具</em>发送)。每个区块将接收一个<code class="fe ml mm mn mo b">chipType</code>和<code class="fe ml mm mn mo b">onTileClick()</code>功能。注意，这里唯一的<code class="fe ml mm mn mo b">tileId</code>是通过组合<code class="fe ml mm mn mo b">row</code>和<code class="fe ml mm mn mo b">column</code>的值来定义的。</p><p id="a30f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">最后，打开<strong class="ke ir">src/components/Column/Column . module . css</strong>文件，粘贴以下CSS代码:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="3346" class="ni lo iq mo b gy nj nk l nl nm">.column {<br/>  display: flex;<br/>  flex-direction: column;<br/>  cursor: pointer;<br/>}</span></pre><p id="050b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们快到了！🙌</p><h2 id="a8f6" class="ni lo iq bd lp nt nu dn lt nv nw dp lx lb nx ny mb lc nz oa mf ld ob oc mj od bi translated">创建电路板组件</h2><p id="acae" class="pw-post-body-paragraph kb kc iq ke b kf oe kh ki kj of kl km lb og kp kq lc oh kt ku ld oi kx ky kz ij bi translated">类似地，导航到<strong class="ke ir">组件</strong>文件夹，并在其中创建一个名为<strong class="ke ir">板</strong>的新文件夹。</p><p id="eec5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在这个文件夹中，创建以下文件:一个用于存储css代码的<strong class="ke ir"> Board.module.css </strong>文件，一个用于React组件逻辑的<strong class="ke ir"> Board.tsx </strong>文件和一个用于组件类型脚本的<strong class="ke ir"> types.ts </strong>文件。</p><blockquote class="jy jz ka"><p id="461f" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注:</strong>你在创建组件时看到的是一个通用的模式吗？</p></blockquote><p id="7c82" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">打开<strong class="ke ir">src/components/Board/types . ts</strong>文件，粘贴以下定义<strong class="ke ir">板</strong>组件道具(合同)的代码:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="3ffa" class="ni lo iq mo b gy nj nk l nl nm">import { ChipsPositions } from “../App/types”;</span><span id="fc3b" class="ni lo iq mo b gy ns nk l nl nm">export interface Props {<br/>  columns: number;<br/>  rows: number;<br/>  chipsPositions: ChipsPositions;<br/>  onTileClick: (id: string) =&gt; any;<br/>}</span></pre><p id="100b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这段代码告诉组件的使用者:</p><ul class=""><li id="d4c8" class="mp mq iq ke b kf kg kj kk lb mr lc ms ld mt kz np mv mw mx bi translated">它必须提供电路板上的<code class="fe ml mm mn mo b">columns</code>和<code class="fe ml mm mn mo b">rows</code>的数量。</li><li id="7971" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">它必须发送<code class="fe ml mm mn mo b">chipsPositions</code>对象。<em class="kd">但是这个信息是由</em> <strong class="ke ir"> <em class="kd">栏的</em> </strong> <em class="kd">组件使用的，而不是</em> <strong class="ke ir"> <em class="kd">板的</em> </strong> <em class="kd">。</em></li><li id="4f45" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">它必须提供一个<code class="fe ml mm mn mo b">onTileClick</code>函数，该函数将由<strong class="ke ir"> Tile </strong>组件在被点击时发出信号。</li></ul><p id="3214" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">然后，打开<strong class="ke ir">src/components/board . tsx</strong>文件，粘贴以下演示代码:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="d6de" class="ni lo iq mo b gy nj nk l nl nm">import React from "react";<br/>import Column from "../Column/Column";<br/>import styles from "./Board.module.css";<br/>import { Props } from "./types";</span><span id="fae0" class="ni lo iq mo b gy ns nk l nl nm">export default class Board extends React.PureComponent&lt;Props&gt; {<br/>  <br/>  renderColumns() {<br/>    const { columns, rows, chipsPositions, onTileClick } = this.props;<br/>    const columnsComponents = [];</span><span id="b237" class="ni lo iq mo b gy ns nk l nl nm">  for (let column = 0; column &lt; columns; column++) {<br/>      columnsComponents.push(<br/>        &lt;Column<br/>          key={column}<br/>          column={column}<br/>          rows={rows}<br/>          chipsPositions={chipsPositions}<br/>          onTileClick={onTileClick}<br/>        /&gt;<br/>      );<br/>    }</span><span id="007a" class="ni lo iq mo b gy ns nk l nl nm">  return &lt;&gt;{columnsComponents}&lt;/&gt;;<br/>  }</span><span id="7433" class="ni lo iq mo b gy ns nk l nl nm">  render() {<br/>    return &lt;div className={styles.board}&gt;{this.renderColumns()}&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="d5b5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这段代码类似于<strong class="ke ir">列</strong>组件的代码，但是我们没有创建<strong class="ke ir">块</strong>，而是创建了多个列，将所需的信息传递给它们，然后呈现结果。<code class="fe ml mm mn mo b">this.renderColumns()</code>方法封装了这个逻辑。</p><blockquote class="ol"><p id="af3e" class="om on iq bd oo op pa pb pc pd pe kz dk translated">你有没有注意到我们也用React。这里有碎片吗？大概不是因为我们使用了简写的“<code class="fe ml mm mn mo b">&lt;&gt;&lt;/&gt;”, which is</code>相当于“&lt;的React。片段&gt;&lt;/反应过来。片段&gt;”。</p></blockquote><p id="2fed" class="pw-post-body-paragraph kb kc iq ke b kf pf kh ki kj pg kl km lb ph kp kq lc pi kt ku ld pj kx ky kz ij bi translated">最后，打开<strong class="ke ir">src/components/Board/Board . module . css</strong>文件，粘贴以下CSS代码:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="6a2c" class="ni lo iq mo b gy nj nk l nl nm">.board {<br/>  display: flex;<br/>  flex-direction: row;<br/>  border: solid 5px #002bff;<br/>  border-radius: 5px;<br/>  background-color: #3355ff;<br/>}</span><span id="242d" class="ni lo iq mo b gy ns nk l nl nm">.columns {<br/>  display: flex;<br/>  flex-direction: row;<br/>}</span></pre><h2 id="0fab" class="ni lo iq bd lp nt nu dn lt nv nw dp lx lb nx ny mb lc nz oa mf ld ob oc mj od bi translated">创建应用程序组件</h2><p id="6fa1" class="pw-post-body-paragraph kb kc iq ke b kf oe kh ki kj of kl km lb og kp kq lc oh kt ku ld oi kx ky kz ij bi translated">我们现在要为我们的游戏开发主要的逻辑。特别注意这一节</p><p id="6925" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在<strong class="ke ir"> src/components </strong>文件夹中创建一个名为<strong class="ke ir"> App </strong>的文件夹。在这个文件夹中，创建<strong class="ke ir"> App.module.css </strong>文件、<strong class="ke ir"> App.tsx </strong>文件和<strong class="ke ir"> types.ts </strong>文件。</p><p id="bbdf" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">打开<strong class="ke ir">src/components/App/types . ts</strong>文件，粘贴以下类型:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="0663" class="ni lo iq mo b gy nj nk l nl nm">export interface ChipsPositions {<br/>  [key: string]: Player;<br/>}</span><span id="f0c3" class="ni lo iq mo b gy ns nk l nl nm">export type Player = "red" | "yellow" | "";</span><span id="e3ec" class="ni lo iq mo b gy ns nk l nl nm">export interface Props {<br/>  columns: number;<br/>  rows: number;<br/>}</span><span id="c783" class="ni lo iq mo b gy ns nk l nl nm">export interface State {<br/>  chipsPositions: ChipsPositions;<br/>  gameStatus: string;<br/>  playerTurn: Player;<br/>}</span></pre><p id="e352" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这里的定义是:</p><ul class=""><li id="d89d" class="mp mq iq ke b kf kg kj kk lb mr lc ms ld mt kz np mv mw mx bi translated"><code class="fe ml mm mn mo b">ChipsPositions</code>对象的形状:一个字典，在每个位置包含这些<code class="fe ml mm mn mo b">Player</code>类型的值之一:<code class="fe ml mm mn mo b">"red"</code>、<code class="fe ml mm mn mo b">"yellow"</code>或<code class="fe ml mm mn mo b">"" </code>(代表一个空值)。</li><li id="fca7" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">App的<code class="fe ml mm mn mo b">Props</code>和<code class="fe ml mm mn mo b">State</code>的形状。前者告诉我们需要为<strong class="ke ir"> App </strong>组件提供<code class="fe ml mm mn mo b">columns</code>和<code class="fe ml mm mn mo b">rows</code>的编号进行初始化，后者告诉我们组件将存储的所有信息。</li></ul><p id="1b84" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在，打开<strong class="ke ir">src/components/App/App . tsx</strong>并粘贴以下代码:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="f1c9" class="ni lo iq mo b gy nj nk l nl nm">import React from "react";<br/>import Board from "../Board/Board";<br/>import { Props, State, ChipsPositions } from "./types";<br/>import styles from "./App.module.css";</span><span id="31af" class="ni lo iq mo b gy ns nk l nl nm">export default class App extends React.PureComponent&lt;Props, State&gt; {<br/>  state: State = {<br/>    chipsPositions: {},<br/>    playerTurn: "red",<br/>    gameStatus: "It's red's turn"<br/>  };</span><span id="af89" class="ni lo iq mo b gy ns nk l nl nm">  calculateGameStatus = (playerTurn: string, chipsPositions: ChipsPositions): string =&gt; {<br/>    // TODO<br/>  };</span><span id="a41d" class="ni lo iq mo b gy ns nk l nl nm">  handleTileClick = (tileId: string) =&gt; {<br/>    // TODO<br/>  };</span><span id="583c" class="ni lo iq mo b gy ns nk l nl nm">  renderBoard() {<br/>    const { columns, rows } = this.props;<br/>    const { chipsPositions } = this.state;<br/>    return (<br/>      &lt;Board<br/>        columns={columns}<br/>        rows={rows}<br/>        chipsPositions={chipsPositions}<br/>        onTileClick={this.handleTileClick}<br/>      /&gt;<br/>    );<br/>  }</span><span id="549f" class="ni lo iq mo b gy ns nk l nl nm">  renderStatusMessage() {<br/>    const { gameStatus } = this.state;<br/>    return &lt;div className={styles.statusMessage}&gt;{gameStatus}&lt;/div&gt;;<br/>  }</span><span id="9430" class="ni lo iq mo b gy ns nk l nl nm">  render() {<br/>    return (<br/>      &lt;div className={styles.app}&gt;<br/>        {this.renderBoard()}<br/>        {this.renderStatusMessage()}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="12f5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这是组件的基本结构:绘制/呈现<strong class="ke ir">板</strong>和<strong class="ke ir">状态</strong>消息的表示逻辑，以及默认的<strong class="ke ir">应用</strong>的状态。这段代码完全是功能性的，但是如果用户与游戏进行交互，应用程序仍然不会做出反应。<em class="kd">我们将在接下来的几行</em>中编写这个逻辑。</p><p id="226b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">实现<code class="fe ml mm mn mo b">handleTileClick()</code>方法以在用户点击<strong class="ke ir">图块</strong>时做出反应。</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="8724" class="ni lo iq mo b gy nj nk l nl nm">handleTileClick = (tileId: string) =&gt; {<br/>  const { chipsPositions, playerTurn } = this.state;</span><span id="a907" class="ni lo iq mo b gy ns nk l nl nm">  // Get the last empty tile of the column<br/>  const column = parseInt(tileId.split(":")[1]);<br/>  let lastEmptyTileId = this.getLastEmptyTile(column);</span><span id="9df1" class="ni lo iq mo b gy ns nk l nl nm">  // If there is no empty tile in the column, do nothing<br/>  if (!lastEmptyTileId) {<br/>    return;<br/>  }</span><span id="1ede" class="ni lo iq mo b gy ns nk l nl nm">  // Add chip to empty tile<br/>  const newChipsPositions = {<br/>    ...chipsPositions,<br/>    [lastEmptyTileId]: playerTurn<br/>  };</span><span id="790a" class="ni lo iq mo b gy ns nk l nl nm">  // Change player turn<br/>  const newPlayerTurn = playerTurn === "red" ? "yellow" : "red";</span><span id="1398" class="ni lo iq mo b gy ns nk l nl nm">  // Calculate game status<br/>  const gameStatus = this.calculateGameStatus(newPlayerTurn, newChipsPositions);</span><span id="209b" class="ni lo iq mo b gy ns nk l nl nm">  // Save new state<br/>  this.setState({ chipsPositions: newChipsPositions, playerTurn: newPlayerTurn, gameStatus });<br/>  };</span><span id="dfcf" class="ni lo iq mo b gy ns nk l nl nm">getLastEmptyTile(column: number) {<br/>  const { rows } = this.props;<br/>  const { chipsPositions } = this.state;</span><span id="cc20" class="ni lo iq mo b gy ns nk l nl nm">  for (let row = rows - 1; row &gt;= 0; row--) {<br/>    const tileId = `${row}:${column}`;<br/>    <br/>    if (!chipsPositions[tileId]) {<br/>      return tileId;<br/>    }<br/>  }<br/>}</span></pre><p id="ef50" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">花几分钟时间理解代码的作用:</p><ul class=""><li id="9b78" class="mp mq iq ke b kf kg kj kk lb mr lc ms ld mt kz np mv mw mx bi translated">首先，它需要被点击的列的最后一个空的<strong class="ke ir">磁贴</strong>。它通过解析<code class="fe ml mm mn mo b">tileId</code>获得列号。</li><li id="126b" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">然后，它根据玩家的回合向选定的牌添加一个筹码，这仅由<strong class="ke ir"> App </strong>组件知道。它会重新计算游戏状态。</li><li id="9d51" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">最后，它将所有新信息存储在组件的状态中，如果有变化，就重新呈现整个应用程序。<em class="kd"> React会为我们决定这个</em>。</li></ul><p id="9d25" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">最后，通过将下面的代码粘贴到<strong class="ke ir"> App </strong>组件中来实现<code class="fe ml mm mn mo b">calculateGameStatus()</code>方法。代码包含决定谁是赢家，或者谁是下一个玩家的逻辑:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="3f32" class="ni lo iq mo b gy nj nk l nl nm">calculateGameStatus = (playerTurn: string, chipsPositions: ChipsPositions): string =&gt; {<br/>  const { columns, rows } = this.props;</span><span id="a7db" class="ni lo iq mo b gy ns nk l nl nm">  // Check four in a row horizontally<br/>  for (let row = 0; row &lt; rows; row++) {<br/>    let repetitionCountStatus = { playerChip: "", count: 0 };</span><span id="8d74" class="ni lo iq mo b gy ns nk l nl nm">    for (let column = 0; column &lt; columns; column++) {<br/>      const chip = chipsPositions[`${row}:${column}`];<br/>      <br/>      // If there is a chip in that position, and belongs<br/>      // to a player, count that chip for that player <br/>      // (either increase the count or start over)<br/>      if (chip &amp;&amp; chip === repetitionCountStatus.playerChip) {<br/>        repetitionCountStatus.count++;<br/>      } else {<br/>        repetitionCountStatus = { playerChip: chip, count: 1 };<br/>      }</span><span id="7dd0" class="ni lo iq mo b gy ns nk l nl nm">      // If the count for a player is 4, that player won<br/>      if (repetitionCountStatus.count === 4) {<br/>         return `Player ${repetitionCountStatus.playerChip} won!`;<br/>      }<br/>    }<br/>  }</span><span id="73bb" class="ni lo iq mo b gy ns nk l nl nm">  // Check four in a row vertically<br/>  for (let column = 0; column &lt; columns; column++) {<br/>    let repetitionCountStatus = { playerChip: "", count: 0 };<br/>    <br/>    for (let row = 0; row &lt; rows; row++) {<br/>      const chip = chipsPositions[`${row}:${column}`];</span><span id="3d57" class="ni lo iq mo b gy ns nk l nl nm">      // If there is a chip in that position, and belongs <br/>      // to a player, count that chip for that player<br/>      // (either increase the count or start over)<br/>      if (chip &amp;&amp; chip === repetitionCountStatus.playerChip) {<br/>        repetitionCountStatus.count++;<br/>      } else {<br/>        repetitionCountStatus = { playerChip: chip, count: 1 };<br/>      }</span><span id="4bd4" class="ni lo iq mo b gy ns nk l nl nm">      // If the count for a player is 4, that player won<br/>      if (repetitionCountStatus.count === 4) {<br/>        return `Player ${repetitionCountStatus.playerChip} won!`;<br/>      }<br/>    }<br/>  }</span><span id="d890" class="ni lo iq mo b gy ns nk l nl nm">  // TODO: Check four in a row diagonally<br/>  <br/>  return `It's ${playerTurn}'s turn`;<br/>};</span></pre><blockquote class="ol"><p id="1576" class="om on iq bd oo op oq or os ot ou kz dk translated">你有没有注意到这个代码没有检查对角线上四个连续的相同值的芯片？你能为此提出一个实现吗？如果有，作为拉取请求发送给我<a class="ae la" href="https://help.github.com/en/articles/creating-a-pull-request" rel="noopener ugc nofollow" target="_blank">！</a></p></blockquote><h2 id="48ed" class="ni lo iq bd lp nt ov dn lt nv ow dp lx lb ox ny mb lc oy oa mf ld oz oc mj od bi translated">正在初始化应用程序</h2><p id="1ea4" class="pw-post-body-paragraph kb kc iq ke b kf oe kh ki kj of kl km lb og kp kq lc oh kt ku ld oi kx ky kz ij bi translated">打开<strong class="ke ir"> src/index.tsx </strong>文件，用以下代码替换其内容:</p><pre class="lf lg lh li gt ne mo nf ng aw nh bi"><span id="b072" class="ni lo iq mo b gy nj nk l nl nm">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import App from "./components/App";<br/>import "./index.css";</span><span id="e4f2" class="ni lo iq mo b gy ns nk l nl nm">// Initialize the app with 7 columns and 6 rows<br/>ReactDOM.render(<br/>  &lt;App columns={7} rows={6} /&gt;, <br/>  document.getElementById("root")<br/>);</span></pre><p id="9957" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">通过在终端运行<code class="fe ml mm mn mo b">npm start</code>来启动应用程序。</p><p id="75d0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在新打开的浏览器窗口中，打开<strong class="ke ir">开发者控制台</strong>，然后点击<strong class="ke ir">组件</strong>标签。您将看到React应用程序的层次树，由您刚刚创建的组件组成:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pk"><img src="../Images/03e935413c40e7e8ad74e9345d78652b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d8Vefg7moHU7XO8p0wQ9ig.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">Connect Four app hierarchy tree in the Developer Console</figcaption></figure><p id="d2d0" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">一点点玩游戏，往棋盘里加几个筹码，然后在开发者控制台里查看棋盘不同的<strong class="ke ir">平铺</strong>。请注意，收到的属性在您与它们交互后发生了变化。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pl"><img src="../Images/f2c0d92ac0f7c882d9b9cb6cba06a097.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8M_I1vNN9ZtoQVFnEcDykQ.png"/></div></div><figcaption class="lj lk gj gh gi ll lm bd b be z dk">When you click on an empty tile, its chipType changes</figcaption></figure><blockquote class="jy jz ka"><p id="e511" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>你也可以直接在右边面板修改道具的值来改变道具。通过将<strong class="ke ir">牌</strong>的筹码类型从<code class="fe ml mm mn mo b"><em class="iq">"red"</em></code>或<code class="fe ml mm mn mo b"><em class="iq">undefined</em></code>转到<code class="fe ml mm mn mo b"><em class="iq">"yellow"</em></code>来亲自尝试。</p></blockquote><p id="02e2" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">恭喜你！您刚刚用React和TypeScript创建了您的第一个游戏💪💪💪</p><h2 id="c58f" class="ni lo iq bd lp nt nu dn lt nv nw dp lx lb nx ny mb lc nz oa mf ld ob oc mj od bi translated">包扎</h2><p id="d43c" class="pw-post-body-paragraph kb kc iq ke b kf oe kh ki kj of kl km lb og kp kq lc oh kt ku ld oi kx ky kz ij bi translated">在本练习中，我们学到了以下内容:</p><ul class=""><li id="4ccf" class="mp mq iq ke b kf kg kj kk lb mr lc ms ld mt kz np mv mw mx bi translated">如何使用React和TypeScript从头开始创建应用程序。</li><li id="4e0e" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">如何把你的app的业务逻辑拆分成小组件？</li><li id="dc91" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">如何通过道具发送信息和通知用户事件？</li><li id="8c5b" class="mp mq iq ke b kf my kj mz lb na lc nb ld nc kz np mv mw mx bi translated">如何使用React开发人员工具来可视化您的应用程序的组件树及其状态。</li></ul><p id="b3d7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi">🎉🎉</p></div><div class="ab cl pm pn hu po" role="separator"><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr ps"/><span class="pp bw bk pq pr"/></div><div class="ij ik il im in"><blockquote class="jy jz ka"><p id="df09" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">记住你可以在<a class="ae la" href="https://github.com/nanovazquez/reactjs-training" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">这个GitHub资源库</strong> </a>找到完整的培训。</p></blockquote></div></div>    
</body>
</html>