<html>
<head>
<title>JavaScript Design Patterns — The Decorator Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript设计模式——装饰模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-design-patterns-the-decorator-pattern-eaf6adc77cb7?source=collection_archive---------1-----------------------#2020-05-21">https://javascript.plainenglish.io/javascript-design-patterns-the-decorator-pattern-eaf6adc77cb7?source=collection_archive---------1-----------------------#2020-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d74b098bd316c7314cbdbffc9eb427fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FICcNn58hm1pyw8re43BpA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@vincentromain" rel="noopener ugc nofollow" target="_blank">Vincent ROMAIN</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0314" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">快速介绍</h1><p id="a080" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这是<strong class="ld ir"> JavaScript设计模式</strong>系列的第三篇文章，我用简单的文字解释设计模式。网上的信息量大得不可思议，真的是让人摸不着头脑，枯燥无味。我的目标是用简单而愉快的方式解释复杂的事情。</p><p id="a488" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们已经在JavaScript中经历了以下设计模式:</p><ul class=""><li id="71fc" class="me mf iq ld b le lz li ma lm mg lq mh lu mi ly mj mk ml mm bi translated"><a class="ae kc" href="https://medium.com/javascript-in-plain-english/javascript-design-patterns-the-factory-pattern-6b399656d710" rel="noopener"> <strong class="ld ir">工厂</strong> </a></li><li id="5050" class="me mf iq ld b le mn li mo lm mp lq mq lu mr ly mj mk ml mm bi translated"><a class="ae kc" href="https://medium.com/javascript-in-plain-english/javascript-design-patterns-adapter-explained-cbcffbb4b8bc" rel="noopener"> <strong class="ld ir">适配器</strong> </a></li></ul><p id="f226" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这次我们将讨论<strong class="ld ir">装饰模式</strong>以及如何在<strong class="ld ir"> JavaScript </strong>中使用它。</p><h1 id="8c35" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">装饰师的真实例子</h1><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/559e74e4b170ddc671909df31b57ccab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p0QumUP_34gOCWD6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@thenigmatic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">The Nigmatic</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b7bc" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">假设你买了一辆车。这是一辆好车，总的来说你会喜欢它的。但是你突然意识到——“<em class="mx">伙计，靴子不够大！</em>“还有一两个特别的地方，你需要额外的空间来放置额外的行李。</p><p id="e8bb" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">你可以考虑买或租一辆拖车来扩大你的车的容量。一般来说，它会是一模一样的车，如果你需要，你可以不用拖车。但是，当你需要额外的启动空间，你可以使用拖车。</p><blockquote class="my"><p id="66ac" class="mz na iq bd nb nc nd ne nf ng nh ly dk translated">在用小行李箱比喻的汽车中，拖车扮演着装饰者的角色——它改变了我们汽车的能力，而没有改变汽车本身</p></blockquote></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="23a8" class="kd ke iq bd kf kg np ki kj kk nq km kn ko nr kq kr ks ns ku kv kw nt ky kz la bi translated">要解决的问题</h1><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/bf0fd69df34ac3eba5387feacc18e8e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cGonH3szD5O-Cd2j"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@momentsbygabriel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gabriel Crismariu</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7df6" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在编程中，我们可能会面临类似的挑战，就像我们在上面的故事中遇到的汽车一样。想象一下，你有一个用户对象。它设计精良，可用于应用的多个领域。</p><p id="a2ca" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在其上添加任何额外的逻辑，都会影响整个应用程序和所有用例。如果你只需要对一个或两个独特的场景进行一些调整，那就更烦人了。</p><p id="e49b" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们在这里讨论的是JavaScript，所以另一个很好的例子是UI组件。假设您有一个按钮组件。它的风格非常好，它有基本的逻辑来处理事件等。但是突然之间，在数百种情况中，只有一两种情况下，你需要一个带有一点额外风格和额外逻辑的按钮。</p><blockquote class="my"><p id="9bbe" class="mz na iq bd nb nc nd ne nf ng nh ly dk translated">为了保持您的初始对象或组件不变，您可以实现装饰模式概念来扩展它们的功能</p></blockquote></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="3585" class="kd ke iq bd kf kg np ki kj kk nq km kn ko nr kq kr ks ns ku kv kw nt ky kz la bi translated">JavaScript中的装饰模式</h1><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/b63e469ef70c8ff4bca67be713d5a078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*poEm3ifmSIn5vmTx"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@steve_j?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Steve Johnson</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="97b3" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">装饰图案被归类为结构性的。这意味着它的核心概念在于将对象组装成更大的结构，同时保持这些结构的灵活性和高效性，并且不影响原始定义。</p><p id="33b5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">总的来说，如果你去掉了所有的枯燥部分，Decorator Pattern会为你提供一种干净的方式来扩展你的原始对象或组件的能力，而不会影响它的初始状态或结构。</p><h2 id="ff00" class="nw ke iq bd kf nx ny dn kj nz oa dp kn lm ob oc kr lq od oe kv lu of og kz oh bi translated">装饰模式—简单的图表</h2><p id="bdf8" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">第一张图是一个没有使用装饰器的代码库的例子，当一个特定的用例需要额外的特性时。</p><p id="b8e8" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们用彩色的形状来代表物体或组件。浅灰色代表这些实例的用例。用深灰色的形状，我们显示了额外的功能/逻辑，这是已经添加的。最后，我们用深灰色分支代表这些特殊功能的几个用例。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/3a73e538b91bbf051386b8ca8ebb8131.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eHuBAB_ofNPjQmj6fy0SLQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Diagram without Decorator by Arthur Frank</figcaption></figure><p id="3335" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">第二张图显示了当我们实现装饰设计模式时，情况变化有多快。我们已经很好地将额外功能的实现从主结构中分离出来。这给了我们更干净的代码库，在那里我们保留了最初设计的原始对象或组件。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/038c46618b74f06dcd0338650373cb32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4qFNUuHfmrT1SNJTLQ7GZg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Diagram with Decorator by Arthur Frank</figcaption></figure><h2 id="cccc" class="nw ke iq bd kf nx ny dn kj nz oa dp kn lm ob oc kr lq od oe kv lu of og kz oh bi translated">装饰模式—代码示例</h2><p id="c8f6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">假设我们有以下用户对象。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oj"><img src="../Images/6cec5d9bfc5ed0b87acc63e6988f19a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tHTb3cokVyLGEicz198dYg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Code Snippet by Arthur Frank</figcaption></figure><p id="25b9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">请记住，这是一个极其简化的示例，旨在让您了解一般概念。</p><p id="6594" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在考虑以下场景。你需要在姓名前加上头衔。您可能会想——“<em class="mx">好吧，在这个简单的例子中，我可以用来自</em> <code class="fe ok ol om on b"><em class="mx">title</em></code> <em class="mx">属性</em>的值作为我的 <code class="fe ok ol om on b"><em class="mx">getFullName()</em></code> <em class="mx">输出的前缀。”</em></p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oo"><img src="../Images/598bee1bab344d92287716dec1d4aa17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8RCU41LcG7Ag-Nk3ObpbNg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Code Snippet by Arthur Frank</figcaption></figure><p id="b804" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这种方法很容易实现——看起来很有吸引力。不过，这种解决方案也有一些缺点。首先，你永远不知道，<code class="fe ok ol om on b">title</code>的财产是否可能会发生变化，例如去<code class="fe ok ol om on b">salutation</code>和<code class="fe ok ol om on b">title</code>的财产可能会被用于其他用途或被移走。</p><p id="2812" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">从干净代码的角度来看，这种方法也很脏。每次你需要全名与标题，你会把这个hacky解决方案。</p><p id="5f49" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">另一个可能出现在你脑海中的想法是——“<em class="mx">好的，我将为我的用户对象添加额外的方法，该方法返回带有标题前缀</em>的全名”。想象一下这个大型项目的场景。在那里你可以处理已经设计好的大物件和组件。</p><p id="2481" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果每次需要满足新的需求时都要向每个实现添加额外的功能，那么您将会把原来的结构扩大到一个巨大的规模。而且很有可能你会打破第一条<strong class="ld ir">坚实的</strong>规则——<strong class="ld ir">单一责任</strong>。</p><p id="9b6d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">没错，是时候引入Decorator模式了。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi op"><img src="../Images/71840bed21ea8ffc56a8278358c801cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nI8jE3lV1dC66OL8nVbxxw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Code Snippet by Arthur Frank</figcaption></figure><p id="a2b1" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">上面的代码样本代表了用户装饰者的入口点。你可以把它想象成一个<code class="fe ok ol om on b">index</code>装饰工。背后的原因是我们可能有多个装饰者，做不同的事情。为了给原始用户对象注入正确的方法和属性，我们需要一个入口装饰器来扩展更多具体的装饰器。</p><blockquote class="my"><p id="9805" class="mz na iq bd nb nc nd ne nf ng nh ly dk translated">必须有一个前端装饰器(又名index ),它遵循原始对象接口，充当具体装饰器的父级</p></blockquote><p id="8691" class="pw-post-body-paragraph lb lc iq ld b le oq lg lh li or lk ll lm os lo lp lq ot ls lt lu ou lw lx ly ij bi translated">就像我们这个简单的例子——在全名前面加上标题。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ov"><img src="../Images/5c26b3092b7c3e78c869c35a35e16f29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gjU-oC2kQQapviLOgYP8TA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Code Snippet by Arthur Frank</figcaption></figure><p id="3567" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在这个Concrete Decorator中，我们用我们需要的额外逻辑覆盖了原始的<code class="fe ok ol om on b">getFullName()</code>方法，但是我们没有影响原始的结构。</p><p id="8012" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在让我们看看如何使用这些美丽的东西。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ow"><img src="../Images/a43524bb01f157ee14e8a89a78bf1d4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-YElYpqvXPrD_AEYaCstg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Code Snippet by Arthur Frank</figcaption></figure><p id="15f9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我希望你已经明白了。装饰者的概念相当简单。在实际项目中，一开始就很难确定何时实现它。我希望这篇文章能让你对如何以及何时使用<strong class="ld ir">装饰设计模式</strong>有所了解。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="75a3" class="kd ke iq bd kf kg np ki kj kk nq km kn ko nr kq kr ks ns ku kv kw nt ky kz la bi translated"><strong class="ak">一句话总结</strong></h1><blockquote class="my"><p id="97ed" class="mz na iq bd nb nc nd ne nf ng nh ly dk translated"><em class="ox">装饰器是一个为原始结构添加</em>额外功能<em class="ox">的概念，然而，保持其解耦和干净</em></p></blockquote><h1 id="b7ac" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko oy kq kr ks oz ku kv kw pa ky kz la bi translated">接下来阅读</h1><ul class=""><li id="7ee5" class="me mf iq ld b le lf li lj lm pb lq pc lu pd ly mj mk ml mm bi translated"><a class="ae kc" href="https://medium.com/javascript-in-plain-english/javascript-design-patterns-the-factory-pattern-6b399656d710" rel="noopener"> <strong class="ld ir">工厂模式</strong>中的<strong class="ld ir"> </strong> JavaScript </a></li><li id="4f25" class="me mf iq ld b le mn li mo lm mp lq mq lu mr ly mj mk ml mm bi translated"><a class="ae kc" href="https://medium.com/javascript-in-plain-english/javascript-design-patterns-adapter-explained-cbcffbb4b8bc" rel="noopener"> <strong class="ld ir">适配器模式<strong class="ld ir"> </strong>中的</strong>JavaScript</a></li></ul></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="6554" class="kd ke iq bd kf kg np ki kj kk nq km kn ko nr kq kr ks ns ku kv kw nt ky kz la bi translated">总结</h1><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/af2c8ed8bdf6e89804a1886659a0b56e.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*lBeJcp-c3uA2jQ9HAKIRFw.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5657" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">感谢您抽出时间阅读这篇文章。我真的希望，你已经获得了一些好的见解，并成为更好的工程师。祝你玩得开心，做你喜欢的事情，下一篇文章再见。🔥</p><h2 id="4b64" class="nw ke iq bd kf nx ny dn kj nz oa dp kn lm ob oc kr lq od oe kv lu of og kz oh bi translated"><strong class="ak">简明英语团队的笔记</strong></h2><p id="eb2a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ld ir">plain English . io</strong></a>上找到所有这些信息——关注我们的出版物并<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ir">订阅我们的YouTube频道</strong> </a> <strong class="ld ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>