<html>
<head>
<title>JavaScript Best Practices — Type Conversions and Casing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—类型转换和大小写</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-type-conversions-and-casing-d1233f6515d4?source=collection_archive---------7-----------------------#2020-06-06">https://javascript.plainenglish.io/javascript-best-practices-type-conversions-and-casing-d1233f6515d4?source=collection_archive---------7-----------------------#2020-06-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/7550119848aa0b434de160a52c329cb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xfoLNmhBGIN6cQM6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David Clode</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="12e9" class="kk kl iq bd km kn ko dn kp kq kr dp ks kt ku kv kw kx ky kz la lb lc ld le lf bi translated"><strong class="ak">简单明了的JavaScript</strong></h2><p id="da11" class="pw-post-body-paragraph lg lh iq li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma ij bi translated"><em class="mb">通过</em> <a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="li ir"> <em class="mb">订阅我们的YouTube频道</em> </strong> </a> <strong class="li ir"> <em class="mb">来表达爱意吧！</em> </strong></p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="91e1" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">JavaScript是一种容易学习的编程语言。编写运行并做某事的程序很容易。然而，很难解释所有的用例并编写健壮的JavaScript代码。</p><p id="1b5f" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">在本文中，我们将研究在JavaScript程序中转换类型的最佳方法。此外，我们还会查看标识符的大小写。</p><h1 id="cdd5" class="mh kl iq bd km mi mj mk kp ml mm mn ks mo mp mq kw mr ms mt la mu mv mw le mx bi translated">类型铸造&amp;强制</h1><p id="937c" class="pw-post-body-paragraph lg lh iq li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma ij bi translated">在铸造类型时，我们应该遵守一些规则。</p><h1 id="1566" class="mh kl iq bd km mi mj mk kp ml mm mn ks mo mp mq kw mr ms mt la mu mv mw le mx bi translated">执行类型强制的最佳位置</h1><p id="c7a1" class="pw-post-body-paragraph lg lh iq li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma ij bi translated">我们应该在声明的开头做类型强制。</p><p id="6525" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">这样，我们就知道我们正在转换类型。</p><h1 id="6828" class="mh kl iq bd km mi mj mk kp ml mm mn ks mo mp mq kw mr ms mt la mu mv mw le mx bi translated">没有包装纸</h1><p id="d931" class="pw-post-body-paragraph lg lh iq li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma ij bi translated">我们永远不应该使用包装对象来转换类型。</p><p id="b920" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">相反，我们应该使用工厂函数。</p><p id="b223" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">例如，不写:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="b111" class="kk kl iq nd b gy nh ni l nj nk">const totalScore = new String(score);</span></pre><p id="fd6d" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">我们写道:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="cf95" class="kk kl iq nd b gy nh ni l nj nk">const totalScore = String(score);</span></pre><p id="ad68" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">这是因为包装对象返回的是一个对象，而不是一个原语。</p><p id="8a10" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">这对我们没有好处。</p><p id="901b" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">JavaScript使用包装对象将它们转换成对象，这样我们就可以调用它的方法。</p><h1 id="07be" class="mh kl iq bd km mi mj mk kp ml mm mn ks mo mp mq kw mr ms mt la mu mv mw le mx bi translated">使用<code class="fe nl nm nn nd b">Number</code>进行数字铸造</h1><p id="d652" class="pw-post-body-paragraph lg lh iq li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma ij bi translated"><code class="fe nl nm nn nd b">Number</code>用于将任何事物转化为数字。</p><p id="7c92" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">例如，我们写道:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="975c" class="kk kl iq nd b gy nh ni l nj nk">const val = Number(inputValue);</span></pre><p id="3490" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">这样，我们得到一个返回的数字基元值。</p><p id="13c4" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">这比使用构造函数或其他函数要好。</p><p id="caef" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">例如，写作:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="d02a" class="kk kl iq nd b gy nh ni l nj nk">const val = new Number(inputValue);</span></pre><p id="b10b" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">是坏的，因为它返回的是一个对象而不是一个数字。</p><p id="fb3c" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">使用<code class="fe nl nm nn nd b">+</code>如下:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="9716" class="kk kl iq nd b gy nh ni l nj nk">const val = +inputValue;</span></pre><p id="6de1" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">可能会使不熟悉<code class="fe nl nm nn nd b">+</code>操作人员的人感到困惑。</p><p id="73f0" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">如果我们使用<code class="fe nl nm nn nd b">parseInt</code>的话，我们应该传入我们想要转换的基数。</p><p id="9c6b" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">例如，我们写道:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="36e5" class="kk kl iq nd b gy nh ni l nj nk">const val = parseInt(inputValue, 10);</span></pre><p id="8e5b" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">我们将10作为第二个参数，将<code class="fe nl nm nn nd b">inputValue</code>转换为十进制数/</p><h1 id="b861" class="mh kl iq bd km mi mj mk kp ml mm mn ks mo mp mq kw mr ms mt la mu mv mw le mx bi translated">不要使用布尔构造函数</h1><p id="64e7" class="pw-post-body-paragraph lg lh iq li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma ij bi translated">像数字和字符串一样，我们永远不应该使用<code class="fe nl nm nn nd b">Boolean</code>构造函数。</p><p id="98d4" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">使用它没有好处。</p><p id="aa52" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">相反，我们使用<code class="fe nl nm nn nd b">Boolean</code>工厂功能。</p><p id="a677" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">例如，我们写道:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="7801" class="kk kl iq nd b gy nh ni l nj nk">const hasAge = Boolean(3);</span></pre><p id="9602" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">代替写作:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="9318" class="kk kl iq nd b gy nh ni l nj nk">const hasAge = new Boolean(3);</span></pre><h1 id="ee1b" class="mh kl iq bd km mi mj mk kp ml mm mn ks mo mp mq kw mr ms mt la mu mv mw le mx bi translated">命名规格</h1><p id="8171" class="pw-post-body-paragraph lg lh iq li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma ij bi translated">我们不应该使用单个字母的名字。它们从来没有那么具有描述性。</p><p id="047f" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">所以与其写作:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="4f8c" class="kk kl iq nd b gy nh ni l nj nk">const q = () =&gt; {<br/>  //...<br/>}</span></pre><p id="a85f" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">我们写道:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="2f28" class="kk kl iq nd b gy nh ni l nj nk">const question = () =&gt; {<br/>  //...<br/>}</span></pre><h1 id="82a1" class="mh kl iq bd km mi mj mk kp ml mm mn ks mo mp mq kw mr ms mt la mu mv mw le mx bi translated">将camelCase用于标识符</h1><p id="c20a" class="pw-post-body-paragraph lg lh iq li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma ij bi translated">我们应该使用camelCase来命名对象、属性和构造器实例。</p><p id="e5dc" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">例如，我们写道:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="a17c" class="kk kl iq nd b gy nh ni l nj nk">const bigObject = {};</span></pre><h1 id="5472" class="mh kl iq bd km mi mj mk kp ml mm mn ks mo mp mq kw mr ms mt la mu mv mw le mx bi translated">将PascalCase用于构造函数</h1><p id="1c21" class="pw-post-body-paragraph lg lh iq li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma ij bi translated">PascalCase用于命名构造函数或类。</p><p id="4172" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">例如，我们写道:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="4957" class="kk kl iq nd b gy nh ni l nj nk">class StudentUser {<br/>  //...<br/>}</span></pre><p id="0a1e" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">或:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="aa2f" class="kk kl iq nd b gy nh ni l nj nk">function StudentUser(name) {<br/>  //...<br/>}</span></pre><h1 id="35dc" class="mh kl iq bd km mi mj mk kp ml mm mn ks mo mp mq kw mr ms mt la mu mv mw le mx bi translated">无前导或尾随下划线</h1><p id="99f3" class="pw-post-body-paragraph lg lh iq li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma ij bi translated">JavaScript构造函数或类中没有私有变量，所以我们不应该用下划线来表示它们是私有的。</p><p id="0b00" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">所以我们不应该写:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="a318" class="kk kl iq nd b gy nh ni l nj nk">class StudentUser {<br/>  constructor(name) {<br/>    this._name = name;<br/>  }<br/>  //...<br/>}</span></pre><p id="4501" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">当它不是隐私的时候，用下划线来表示隐私是一种误导。</p><h1 id="e391" class="mh kl iq bd km mi mj mk kp ml mm mn ks mo mp mq kw mr ms mt la mu mv mw le mx bi translated">不要保存对此的引用</h1><p id="4bfa" class="pw-post-body-paragraph lg lh iq li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma ij bi translated">我们不需要保存对<code class="fe nl nm nn nd b">this</code>的引用，因为我们可以使用箭头函数来避免这样做。</p><p id="6f46" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">例如，我们可以写:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="16bb" class="kk kl iq nd b gy nh ni l nj nk">function bar() {<br/>  return () =&gt; {<br/>    console.log(this);<br/>  };<br/>}</span></pre><p id="9275" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">而不是:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="3268" class="kk kl iq nd b gy nh ni l nj nk">function bar() {<br/>  const self = this;<br/>  return function () {<br/>    console.log(self);<br/>  };<br/>}</span></pre><p id="9a37" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">作为额外的好处，它也更短。</p><figure class="my mz na nb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/5d9150138c7607fa90416aca047b4937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*982i_UujtBCgwAl5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@honeyfangs?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Honey Fangs</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3d9e" class="mh kl iq bd km mi mj mk kp ml mm mn ks mo mp mq kw mr ms mt la mu mv mw le mx bi translated">基本文件名应该与其默认导出的名称相匹配</h1><p id="28c3" class="pw-post-body-paragraph lg lh iq li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma ij bi translated">默认导出应该与导出文件的名称相匹配，以避免混淆。</p><p id="124f" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">例如，我们写道:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="e5d8" class="kk kl iq nd b gy nh ni l nj nk">import Foo from './Foo';</span></pre><p id="916a" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">或者:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="478c" class="kk kl iq nd b gy nh ni l nj nk">import bar from './bar';</span></pre><p id="be4f" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">这样，我们就不会混淆。</p><p id="b627" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">同样，对于出口，我们写道:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="330e" class="kk kl iq nd b gy nh ni l nj nk">class Foo{<br/>  // ...<br/>}<br/>export default Foo;</span></pre><p id="9547" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">我们使案例保持一致，以便于阅读。</p><h1 id="86d3" class="mh kl iq bd km mi mj mk kp ml mm mn ks mo mp mq kw mr ms mt la mu mv mw le mx bi translated">对用作默认导出的函数使用camelCase</h1><p id="3e92" class="pw-post-body-paragraph lg lh iq li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma ij bi translated">因为函数应该是camelCase，所以我们应该以同样的方式使用name默认导出。</p><p id="9026" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">所以我们写道:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="fa76" class="kk kl iq nd b gy nh ni l nj nk">function eatLunch() {<br/>  // ...<br/>}<br/><br/>export default eatLunch;</span></pre><h1 id="7494" class="mh kl iq bd km mi mj mk kp ml mm mn ks mo mp mq kw mr ms mt la mu mv mw le mx bi translated">结论</h1><p id="9451" class="pw-post-body-paragraph lg lh iq li b lj lk ll lm ln lo lp lq kt lr ls lt kx lu lv lw lb lx ly lz ma ij bi translated">对于函数、类和其他标识符，我们应该坚持使用标准的JavaScript大小写。</p><p id="7016" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">这也应该适用于模块中的导入和导出。</p><p id="73a9" class="pw-post-body-paragraph lg lh iq li b lj mc ll lm ln md lp lq kt me ls lt kx mf lv lw lb mg ly lz ma ij bi translated">要对类型进行强制转换，我们应该使用工厂函数，如果我们试图转换为原始值，就让它返回原始值。</p></div></div>    
</body>
</html>