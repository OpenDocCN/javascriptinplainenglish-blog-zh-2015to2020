<html>
<head>
<title>How to Create Registration &amp; Authentication with Express &amp; PassportJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Express &amp; PassportJS创建注册和认证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-registration-authentication-with-express-passportjs-eb9450a9fa3b?source=collection_archive---------22-----------------------#2020-12-21">https://javascript.plainenglish.io/how-to-create-registration-authentication-with-express-passportjs-eb9450a9fa3b?source=collection_archive---------22-----------------------#2020-12-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f31943303d0b1408eb74b980d8b52c4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OTFFSeGNUQDYjlsX.jpg"/></div></div></figure><p id="dffc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我将演示如何在ExpressJS中构建一个用户注册和认证系统。在上一篇文章中，我们<a class="ae kt" href="https://kelvinmwinuka.com/how-to-set-up-mongoose-with-expressjs/" rel="noopener ugc nofollow" target="_blank">使用mongose</a>建立了一个MongoDB连接。在这里，我们将使用该连接来保存用户数据并使用它进行身份验证。</p><p id="6b2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个项目在<a class="ae kt" href="https://github.com/kelvinmwinuka/express-tutorial" rel="noopener ugc nofollow" target="_blank"> Github </a>上有。如果你愿意的话，可以随意复制它。</p><h1 id="c818" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">设置</h1><p id="3237" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">让我们首先为项目的这一部分设置必要的包和库。</p><p id="38c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行以下命令安装必要的软件包:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1cec" class="mg kv in mc b gy mh mi l mj mk">npm install passport passport-local express-session bcrypt connect-mongo express-flash joi</span></pre><p id="fc55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我们刚刚安装的软件包的明细:</p><ol class=""><li id="e8d6" class="ml mm in jx b jy jz kc kd kg mn kk mo ko mp ks mq mr ms mt bi translated"><a class="ae kt" href="http://www.passportjs.org/" rel="noopener ugc nofollow" target="_blank">护照</a>和<a class="ae kt" href="http://www.passportjs.org/packages/passport-local/" rel="noopener ugc nofollow" target="_blank">护照-本地</a>-用户认证。</li><li id="840c" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated"><a class="ae kt" href="https://www.npmjs.com/package/express-session" rel="noopener ugc nofollow" target="_blank">快速会话</a>—express js中的会话。</li><li id="be4d" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated"><a class="ae kt" href="https://www.npmjs.com/package/bcrypt" rel="noopener ugc nofollow" target="_blank"> bcrypt </a> —密码加密和认证比较。</li><li id="2d2c" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated"><a class="ae kt" href="https://www.npmjs.com/package/connect-mongo" rel="noopener ugc nofollow" target="_blank"> connect-mongo </a> —用于快速会话的mongo商店。</li><li id="fff7" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated"><a class="ae kt" href="https://www.npmjs.com/package/express-flash" rel="noopener ugc nofollow" target="_blank">快速闪烁</a> —在前端显示闪烁信息。</li><li id="ab07" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated"><a class="ae kt" href="https://joi.dev/api/?v=17.3.0" rel="noopener ugc nofollow" target="_blank"> joi </a> —用户输入验证。</li></ol><p id="3228" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">包含bootstrap(可选，只要表单可以向服务器发送post数据，就可以)。</p><p id="26b6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在<strong class="jx io"><em class="mz">base.html</em></strong>文件中，添加引导导入的链接和脚本标签。它们被导入一次，然后包含在扩展基本模板的每个模板中。</p><p id="b218" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个阶段，base.html的文件应该是这样的:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2d12" class="mg kv in mc b gy mh mi l mj mk">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;meta charset="utf-8"&gt;<br/>    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;<br/>    &lt;title&gt;{{ title }}&lt;/title&gt;<br/>    &lt;meta name="description" content=""&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;<br/>    &lt;!-- Bootstrap CSS --&gt;<br/>    &lt;link <br/>      href="<a class="ae kt" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css</a>" <br/>      rel="stylesheet" <br/>      integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" <br/>      crossorigin="anonymous"&gt;<br/>    {% block styles %}<br/>      {# This block will be replaced by child templates when importing styles #}<br/>    {% endblock %}<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    {% block content %}<br/>      {# This block will be replaced by child templates when adding content to the  #}<br/>    {% endblock %}</span><span id="0184" class="mg kv in mc b gy na mi l mj mk">&lt;!-- Bootstrap JavaScript Bundle with Popper --&gt;<br/>    &lt;script <br/>      src="<a class="ae kt" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/js/bootstrap.bundle.min.js</a>" <br/>      integrity="sha384-ygbV9kiqUc6oa4msXn9868pTtWMgiQaeYH7/t7LECLbyPA2x65Kgf80OJFdroafW" <br/>      crossorigin="anonymous"&gt;<br/>    &lt;/script&gt;<br/>    {% block scripts %}<br/>      {# This block will be replaced by child templates when importing scripts #}<br/>    {% endblock %}<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><h1 id="736d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">履行</h1><p id="62ce" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">进入入口点文件并需要以下包:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="fb32" class="mg kv in mc b gy mh mi l mj mk">const session = require('express-session') <br/>const MongoStore = require('connect-mongo')(session) <br/>const passport = require('passport')</span></pre><p id="430c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在应用程序声明之后，添加内置的express中间件来解析带有url编码数据的传入请求，以处理将从表单接收的数据。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="efb3" class="mg kv in mc b gy mh mi l mj mk">var app = express() <br/>app.use(express.urlencoded({extended: true}))</span></pre><p id="fc5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，设置会话中间件。确保将这段代码放在mongose连接之后，因为我们将使用现有的mongose连接来存储会话数据。否则，您必须为此创建一个新连接。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0972" class="mg kv in mc b gy mh mi l mj mk">app.use(session({<br/>  secret: process.env.SESSION_SECRET,<br/>  resave: false,<br/>  saveUninitialized: true,<br/>  store: new MongoStore({<br/>    mongooseConnection: mongoose.connection,<br/>    collection: 'sessions'<br/>  }),<br/>  cookie: {<br/>    secure: false<br/>  }<br/>}))</span></pre><p id="cbe1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们浏览一下上面的代码:</p><ol class=""><li id="99c2" class="ml mm in jx b jy jz kc kd kg mn kk mo ko mp ks mq mr ms mt bi translated">我们正在将会话中间件添加到应用中。</li><li id="8531" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">secret —用于加密会话的字符串。在。env文件或系统环境变量。</li><li id="dfe2" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">重新保存—确定是否将会话对象重新保存到会话存储中，即使该对象未被请求修改。</li><li id="5b5f" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">save initialized—确定是否应该将新会话保存到存储中，甚至在修改之前。</li><li id="8ebc" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">存储—用于保存会话数据的存储。</li></ol><h1 id="560b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">更新模型</h1><p id="bfed" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在这一节中，我指的是我们在上一篇文章中创建的用户模型。<a class="ae kt" href="https://kelvinmwinuka.com/how-to-set-up-mongoose-with-expressjs/" rel="noopener ugc nofollow" target="_blank">看这里</a>。</p><p id="bcfd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们需要更新用户模型，以便在保存时启用身份验证和密码散列。我们在模型中这样做是为了避免在需要时在多个地方编写认证登录。</p><p id="8ad8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个逻辑是这个模型所独有的，所以在这里使用它是有意义的。导航到我们之前创建的User.js模型文件，并在第一个require语句后添加以下代码:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8db2" class="mg kv in mc b gy mh mi l mj mk">const bcrypt = require('bcrypt') <br/>const saltRounds = 10</span></pre><p id="dac0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在模式定义之后，添加以下代码:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2407" class="mg kv in mc b gy mh mi l mj mk">userSchema.pre('save', async function(next){<br/>  if (this.isNew) this.password = await bcrypt.hash(this.password, saltRounds)<br/>  next()<br/>})</span><span id="d589" class="mg kv in mc b gy na mi l mj mk">userSchema.static('userExists', async function({username, email}){<br/>  let user = await this.findOne({ username })<br/>  if (user) return { username: 'This username is already in use' }<br/>  user = await this.findOne({ email })<br/>  if (user) return { email: 'This email address is already in use' }<br/>  return false<br/>})</span><span id="14ff" class="mg kv in mc b gy na mi l mj mk">userSchema.static('authenticate', async function(username, plainTextPassword){<br/>  const user = await this.findOne({ $or: [ {email: username}, {username} ] })<br/>  if (user &amp;&amp; await bcrypt.compare(plainTextPassword, user.password)) return user<br/>  return false<br/>})</span></pre><p id="0f72" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里发生了一些事情:</p><ol class=""><li id="2829" class="ml mm in jx b jy jz kc kd kg mn kk mo ko mp ks mq mr ms mt bi translated">第一个是预保存挂钩。这将在每次保存文档之前运行。我们用它来确定当前文档是否是新的(不是更新调用)。如果文档是新的，散列密码。始终保存哈希密码，而不是纯文本。</li><li id="d319" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">第二个块是一个静态方法，它检查用户是否存在。我们将通过用户名查询数据库，然后发送电子邮件。如果找到用户，则返回一个对象，指定哪个用户已经在使用。否则，返回false。</li><li id="5a7b" class="ml mm in jx b jy mu kc mv kg mw kk mx ko my ks mq mr ms mt bi translated">第三种方法是添加到模式中的静态方法。我们用这个来验证用户。如果用户存在，并且明文密码和散列用户密码之间的密码比较通过，则返回用户对象。否则，为返回false。认证失败。</li></ol><h1 id="4ec6" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">登记</h1><p id="8e1d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">创建注册表；一个简单的表格，收集用户的姓名，用户名，电子邮件地址和密码。</p><p id="51ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将此代码放在views文件夹的“register.html”中。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="3a1d" class="mg kv in mc b gy mh mi l mj mk">{% extends 'base.html' %}</span><span id="42d8" class="mg kv in mc b gy na mi l mj mk">{% set title = 'Register' %}</span><span id="9285" class="mg kv in mc b gy na mi l mj mk">{% block styles %}<br/>  &lt;style&gt;<br/>    form {<br/>      margin-top: 20px;<br/>      margin-left: 20px;<br/>      margin-right: 20px;<br/>    }<br/>  &lt;/style&gt;<br/>{% endblock %}</span><span id="49a0" class="mg kv in mc b gy na mi l mj mk">{% block content %}<br/>  &lt;form action="/register" method="POST"&gt;<br/>    &lt;div class="mb-3"&gt;<br/>      &lt;label for="name" class="form-label"&gt;Name&lt;/label&gt;<br/>      &lt;input <br/>        type="text" <br/>        class="form-control {% if messages.name_error %}is-invalid{% endif %}" <br/>        id="name" <br/>        name="name"<br/>        value="{{ messages.name or '' }}"<br/>        placeholder="Full Name"&gt;<br/>      &lt;div class="invalid-feedback"&gt;{{ messages.name_error }}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="mb-3"&gt;<br/>      &lt;label for="username" class="form-label"&gt;Username&lt;/label&gt;<br/>      &lt;input <br/>        type="text" <br/>        class="form-control {% if messages.username_error %}is-invalid{% endif %}" <br/>        id="username" <br/>        name="username"<br/>        value="{{ messages.username or '' }}"<br/>        placeholder="Username"&gt;<br/>      &lt;div class="invalid-feedback"&gt;{{ messages.username_error }}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="mb-3"&gt;<br/>      &lt;label for="email" class="form-label"&gt;Email address&lt;/label&gt;<br/>      &lt;input <br/>        type="email" <br/>        class="form-control {% if messages.email_error %}is-invalid{% endif %}" <br/>        id="email"<br/>        name="email"<br/>        value="{{ messages.email or '' }}"<br/>        placeholder="Email Address"&gt;<br/>      &lt;div class="invalid-feedback"&gt;{{ messages.email_error }}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="mb-3"&gt;<br/>      &lt;label for="password" class="form-label"&gt;Password&lt;/label&gt;<br/>      &lt;input <br/>        type="password" <br/>        class="form-control {% if messages.password_error %}is-invalid{% endif %}" <br/>        id="password" <br/>        name="password" <br/>        value="{{ messages.password or '' }}"<br/>        placeholder="Password"&gt;<br/>      &lt;div class="invalid-feedback"&gt;{{ messages.password_error }}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div&gt;<br/>      &lt;button type="submit" class="btn btn-primary"&gt;Sign me up!&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  &lt;/form&gt;<br/>{% endblock %}</span><span id="51ce" class="mg kv in mc b gy na mi l mj mk">{% block scripts %}<br/>{% endblock %}</span></pre><p id="ddb6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用nunjucks来实现一些动态行为。</p><p id="e1e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个是使用来自服务器的flash消息将is-invalid类添加到表单控件中。这将添加一条附加到表单控件的错误信息。</p><p id="061b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二个是设置用户输入的前一个值(对于本教程来说，这是一个可选的UX特性)。</p><p id="9594" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建注册模板后，创建与模板相关联的路由。</p><p id="c1dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在项目的根目录下创建一个名为“routes”的文件夹。这个文件夹将保存我们所有的路线。在该文件夹中创建一个文件“register.js”。该文件的内容应该如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="96c6" class="mg kv in mc b gy mh mi l mj mk">var router = require('express').Router()<br/>const Joi = require('joi')<br/>const { User } = require('../models')</span><span id="dd98" class="mg kv in mc b gy na mi l mj mk">const validateRegistrationInfo = async (req, res, next) =&gt; {<br/>  for(let [key, value] of Object.entries(req.body)) {<br/>    req.flash(`${key}`, value)<br/>  }<br/>  /* Validate the request parameters.<br/>  If they are valid, continue with the request.<br/>  Otherwise, flash the error and redirect to registration form. */<br/>  const schema = Joi.object({<br/>    name: Joi.string().required(),<br/>    username: Joi.string().alphanum().min(6).max(12).required(),<br/>    email: Joi.string()<br/>        .email({ minDomainSegments: 2, tlds: { allow: ['com', 'net'] } }).required(),<br/>    password: Joi.string().min(8).required()<br/>  })</span><span id="27bd" class="mg kv in mc b gy na mi l mj mk">const error = schema.validate(req.body, { abortEarly: false }).error<br/>  if (error) {<br/>    error.details.forEach(currentError =&gt; {<br/>      req.flash(`${currentError.context.label}_error`, currentError.message)<br/>    })<br/>    return res.redirect('/register')<br/>  }</span><span id="94f8" class="mg kv in mc b gy na mi l mj mk">/** Check if user exists */<br/>  const userExists = await User.userExists(req.body)<br/>  if (userExists) {<br/>    for(let [key, message] of Object.entries(userExists)) {<br/>      req.flash(`${key}`, message)<br/>    }<br/>    return res.redirect('/register')<br/>  }</span><span id="9831" class="mg kv in mc b gy na mi l mj mk">next()  <br/>}</span><span id="0895" class="mg kv in mc b gy na mi l mj mk">router.get('/register', (req, res) =&gt; res.render('register.html'))</span><span id="70b0" class="mg kv in mc b gy na mi l mj mk">router.post('/register', validateRegistrationInfo, async (req, res) =&gt; {<br/>  let savedUser = await (new User(req.body)).save()<br/>  res.redirect('/')<br/>})</span><span id="1235" class="mg kv in mc b gy na mi l mj mk">module.exports = router</span></pre><p id="c1f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个重要的代码块是一个名为<strong class="jx io"><em class="mz">validateRegistrationInfo</em></strong>的函数。这是用于验证用户注册信息的中间件。</p><p id="f3bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在验证的第一阶段，我们会立即刷新预填充的当前信息，以防我们重定向回注册页面。</p><p id="9ce7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">阶段2是根据验证模式验证每个条目。<a class="ae kt" href="https://joi.dev/" rel="noopener ugc nofollow" target="_blank"> Joi </a>包让这个过程变得简单。</p><p id="b0b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果验证有任何错误，在重定向到注册页面之前，刷新该特定条目的每个错误消息。在模板中显示此错误消息。</p><p id="2840" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">验证的最后阶段是检查所提供的用户名/电子邮件是否已经被使用。如果是，则在重定向到注册路由之前闪烁错误消息。</p><p id="36a8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个简单呈现“register.html”的GET路由。这是验证失败时我们重定向到的路由。</p><p id="434d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个post路由，接收用户在请求正文中输入的数据，并将验证中间件传递给它。</p><p id="0c7f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在路由处理程序本身中，我们不必担心无效数据，因为如果处理程序正在执行，它会通过所有的验证检查。</p><p id="aea2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用提供的数据创建一个新用户，保存它，并重定向到主页。</p><p id="6159" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">导出此路由器对象，并将其导入条目文件，如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ebe2" class="mg kv in mc b gy mh mi l mj mk">// Import rotues <br/>app.use('/', require('./routes/register'))</span></pre><h1 id="11b1" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">证明</h1><p id="e161" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">既然我们已经完成了注册，那么是时候实现应用程序的认证逻辑了。</p><p id="de0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先创建一个登录表单。该表单有一个用户名/电子邮件字段和一个密码字段。我们还将包含一个条件，用于检查警报中显示的错误消息。闪烁一条消息后，当我们重定向到登录页面时，就会显示这条消息。</p><p id="fcd2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将此表单放在注册模板旁边的视图文件夹中的“login.html”模板文件中。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ebf8" class="mg kv in mc b gy mh mi l mj mk">{% extends 'base.html' %}</span><span id="c897" class="mg kv in mc b gy na mi l mj mk">{% set title = 'Login' %}</span><span id="4cef" class="mg kv in mc b gy na mi l mj mk">{% block styles %}<br/>  &lt;style&gt;<br/>    form {<br/>      margin-top: 20px;<br/>      margin-left: 20px;<br/>      margin-right: 20px;<br/>    }<br/>  &lt;/style&gt;<br/>{% endblock %}</span><span id="66c3" class="mg kv in mc b gy na mi l mj mk">{% block content %}<br/>  &lt;form action="/login" method="POST"&gt;<br/>    {% if messages.error %}<br/>      &lt;div class="alert alert-danger" role="alert"&gt;{{ messages.error }}&lt;/div&gt;<br/>    {% endif %}<br/>    &lt;div class="mb-3"&gt;<br/>      &lt;label for="name" class="form-label"&gt;Username or Email&lt;/label&gt;<br/>      &lt;input <br/>        type="text" <br/>        class="form-control {% if messages.name_error %}is-invalid{% endif %}" <br/>        id="username" <br/>        name="username"<br/>        value="{{ messages.name or '' }}"&gt;<br/>      &lt;div class="invalid-feedback"&gt;{{ messages.name_error }}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div class="mb-3"&gt;<br/>      &lt;label for="name" class="form-label"&gt;Password&lt;/label&gt;<br/>      &lt;input <br/>        type="password" <br/>        class="form-control {% if messages.name_error %}is-invalid{% endif %}" <br/>        id="password" <br/>        name="password"<br/>        value="{{ messages.name or '' }}"&gt;<br/>      &lt;div class="invalid-feedback"&gt;{{ messages.name_error }}&lt;/div&gt;<br/>    &lt;/div&gt;<br/>    &lt;div&gt;<br/>      &lt;button type="submit" class="btn btn-primary"&gt;Login&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  &lt;/form&gt;<br/>{% endblock %}</span><span id="3bdd" class="mg kv in mc b gy na mi l mj mk">{% block scripts %}<br/>{% endblock %}</span></pre><p id="2227" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一个任务是定义用于认证用户的passport策略。我们使用passport-local的策略，因为我们根据自己存储的用户凭据进行身份验证。</p><p id="655d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在项目的根目录下创建一个名为“passport-helper.js”的新文件，内容如下:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1e53" class="mg kv in mc b gy mh mi l mj mk">const LocalStrategy = require('passport-local').Strategy<br/>const { User } = require('./models')</span><span id="97bf" class="mg kv in mc b gy na mi l mj mk">module.exports = (app, passport) =&gt; {</span><span id="e94b" class="mg kv in mc b gy na mi l mj mk">passport.use(new LocalStrategy((username, password, done) =&gt; {<br/>    User.authenticate(username, password)<br/>    .then( user =&gt; {<br/>      done(null, user)<br/>    })<br/>    .catch( error =&gt; {<br/>      done(error)<br/>    })<br/>  }))</span><span id="18de" class="mg kv in mc b gy na mi l mj mk">passport.serializeUser((user, done) =&gt; {<br/>    done(null, user._id)<br/>  })</span><span id="de7c" class="mg kv in mc b gy na mi l mj mk">passport.deserializeUser((id, done) =&gt; {<br/>    User.findById(id, (error, user) =&gt; {<br/>      if (error) return done(error)<br/>      done(null, user)<br/>    })<br/>  })</span><span id="7fb1" class="mg kv in mc b gy na mi l mj mk">app.use(passport.initialize())<br/>  app.use(passport.session())<br/>}</span></pre><p id="d9ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一步是导入策略和用户模型。</p><p id="cea7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二步是配置策略。我们创建一个新的策略实例，向它传递一个接受用户名、密码的函数和一个验证回调(done)函数，该函数在身份验证过程完成后执行。</p><p id="9052" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">身份验证逻辑放在这个函数中。为了保持简洁，我们将简单地使用我们在用户模型中创建的“authenticate”静态方法。</p><p id="68a6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在passport中进行身份验证时，如果身份验证成功，用户对象将被传递给verify回调函数，否则将返回false(如果在这种情况下没有抛出错误，则传递错误)。</p><p id="4b18" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果找到用户，我们的authenticate方法返回一个用户对象，否则返回false，因此它的输出非常适合这个场景。</p><p id="8c39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦我们配置了策略，我们必须指定用户序列化和反序列化逻辑。</p><p id="c61b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您不使用会话，这一步是可选的，但是我们试图创建一个带有会话的登录系统，所以在我们的例子中，这是必要的。</p><p id="a443" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">serializeUser方法将带有用户对象和回调的函数作为参数，该函数确定将存储在会话本身中的数据。</p><p id="f374" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了保持会话中存储的数据量较小，我们只在会话中存储用户ID。这个序列化过程发生在初次登录时。</p><p id="4ae7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">deserializeUser方法采用一个接收用户ID和回调的函数。该方法在登录/序列化后的所有后续请求上运行。</p><p id="3db5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从会话中获取用户ID，从数据库中检索用户。一旦检索到用户，它们就存储在req.user中。</p><p id="07c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在序列化/反序列化之后，确保将passport initialize和会话中间件添加到应用程序中。我们将把所有这些打包到一个函数中，该函数将我们的app和passport对象作为参数。</p><p id="73ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的passport配置现在已经完成。下一步是初始化passport。</p><p id="34b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在应用程序入口文件中，导入我们在上一步中创建的函数，然后执行它，传递app和passport对象。</p><p id="168e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">确保在passport require语句之后有require语句。在定义会话中间件之后，必须调用初始化函数，因为passport会话中间件使用它。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="fd74" class="mg kv in mc b gy mh mi l mj mk">const initializePassport = require('./passport-helper') </span><span id="3de9" class="mg kv in mc b gy na mi l mj mk">... </span><span id="d071" class="mg kv in mc b gy na mi l mj mk">initializePassport(app, passport)</span></pre><p id="3414" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们创建登录路由。在routes文件夹中，创建一个名为“login.js”的文件，并添加以下代码:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="125a" class="mg kv in mc b gy mh mi l mj mk">const createLoginRoutes = passport =&gt; {<br/>  const router = require('express').Router()</span><span id="7cff" class="mg kv in mc b gy na mi l mj mk">router.get('/login', (req, res) =&gt; {<br/>    if (req.isAuthenticated()) return res.redirect('/')<br/>    res.render('login.html')<br/>  })<br/>  <br/>  router.post(<br/>    '/login',<br/>    passport.authenticate('local', {<br/>      failureRedirect: '/login', <br/>      successRedirect: '/',<br/>      failureFlash: 'User not found', <br/>    }),<br/>    (error, req, res, next) =&gt; {<br/>      if (error) next(error)<br/>    }<br/>  )</span><span id="96ea" class="mg kv in mc b gy na mi l mj mk">router.get('/logout', (req, res) =&gt; {<br/>    req.logout()<br/>    res.redirect('/login')<br/>  })<br/>  <br/>  return router<br/>}</span><span id="3415" class="mg kv in mc b gy na mi l mj mk">module.exports = createLoginRoutes</span></pre><p id="5ce9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与我们在注册路由文件中创建路由的方式不同，我们在这里做的有点不同。</p><p id="5c6b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我们需要passport对象，所以我们将导出一个接受passport对象作为参数的函数，定义路由并返回router对象。</p><p id="35b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一个路由是“/login”的GET路由。这将在没有活动会话时呈现表单。使用passport在请求对象中提供的“isAuthenticated”方法来确定当前是否有活动会话。</p><p id="69f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第二个路由是来自“/login”的POST路由。这个路径接受来自用户的表单输入。</p><p id="2aaa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将passport.authenticate中间件传递给此路由以处理身份验证。这个中间件接受策略类型和选项对象。</p><p id="a567" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在选项对象中，指定失败和成功时的重定向路径。failureFlash属性指定身份验证失败时要闪烁的消息。这是您应该检查并显示在登录页面上的消息。</p><p id="f0d1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，创建一个注销路由，调用req.logout来结束当前用户的会话。passport也提供了这种注销方法。</p><p id="f5f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在条目文件中导入登录路由创建者，并将passport对象传递给它:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="703e" class="mg kv in mc b gy mh mi l mj mk">app.use('/', require('./routes/auth')(passport))</span></pre><p id="1a36" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将主页路径更新为:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8090" class="mg kv in mc b gy mh mi l mj mk">app.get('/', async (req, res) =&gt; {<br/>  if (!req.isAuthenticated()) return res.redirect('/login')<br/>  res.render('home.html')<br/>})</span></pre><p id="63df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">主页路由现在是受保护的路由。这意味着只有经过身份验证的用户才能访问它。</p><p id="22b4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们通过使用req.isAuthenticated方法来确保用户已经过身份验证，从而实现了这一点。如果没有，重定向到登录页面。</p><p id="9e51" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">回到注册路由文件并更新获取路由。致以下内容:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4182" class="mg kv in mc b gy mh mi l mj mk">router.get('/register', (req, res) =&gt; {<br/>  if (req.isAuthenticated()) return res.redirect('/')<br/>  res.render('register.html')<br/>})</span></pre><p id="4b47" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果用户没有通过身份验证，我们只需要呈现注册表单，否则，重定向到主页。</p><h1 id="0f04" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="04eb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在本文中，我演示了如何使用PassportJS在ExpressJS中创建一个简单的注册/认证系统。然而，如果没有密码重置功能，认证系统是不完整的。</p><p id="91ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一篇文章将是关于使用mongoose和NodeMailer创建密码重置特性的教程。</p><p id="4b1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如果你喜欢这篇文章，可以考虑关注我的</strong> <a class="ae kt" href="https://kelvinmwinuka.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">个人网站</strong> </a> <strong class="jx io">，以便在我的内容在媒体上发布之前提前获得(别担心，它仍然是免费的，没有烦人的弹出广告！).另外，请随意评论这篇文章。我很想听听你们的想法！</strong></p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="c9b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mz">原载于2020年12月21日https://kelvinmwinuka.com</em><a class="ae kt" href="https://kelvinmwinuka.com/how-to-create-registration-authentication-with-express-passportjs/" rel="noopener ugc nofollow" target="_blank"><em class="mz"/></a><em class="mz">。</em></p></div></div>    
</body>
</html>