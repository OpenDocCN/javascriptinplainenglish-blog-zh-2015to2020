<html>
<head>
<title>Object-Oriented JavaScript — Objects and Constructors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的JavaScript —对象和构造函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-oriented-javascript-objects-and-constructors-e50d01eed8dd?source=collection_archive---------8-----------------------#2020-10-02">https://javascript.plainenglish.io/object-oriented-javascript-objects-and-constructors-e50d01eed8dd?source=collection_archive---------8-----------------------#2020-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b977eb9c86762e910c9cdc09a4273c42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_kvdeMk_8ioZ3pjJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8ac3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究对象和构造函数。</p><h1 id="be40" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">访问对象的属性</h1><p id="cad7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用方括号符号或点符号来访问对象的属性。</p><p id="c57f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用方括号符号，我们可以这样写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5e1f" class="mn lc iq mj b gy mo mp l mq mr">dog['name']</span></pre><p id="d75d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这适用于所有属性名，不管它们是否是有效的标识符。</p><p id="79fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用它们来访问属性，方法是用字符串或符号动态地传递属性名。</p><p id="1b85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以通过书写来使用点符号:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9829" class="mn lc iq mj b gy mo mp l mq mr">dog.name</span></pre><p id="7838" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这更短，但只适用于有效的标识符。</p><p id="b154" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个对象可以包含另一个对象。</p><p id="558e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="771c" class="mn lc iq mj b gy mo mp l mq mr">const book = {<br/>  name: 'javascript basics',<br/>  published: 2020,<br/>  author: {<br/>    firstName: 'jane',<br/>    lastName: 'smith'<br/>  }<br/>};</span></pre><p id="aa9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">author</code>属性具有<code class="fe ms mt mu mj b">firstName</code>和<code class="fe ms mt mu mj b">lastName</code>属性。</p><p id="8a31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下内容来获得嵌套属性:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="137f" class="mn lc iq mj b gy mo mp l mq mr">book['author']['firstName']</span></pre><p id="4847" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="25b4" class="mn lc iq mj b gy mo mp l mq mr">book.author.firstName</span></pre><p id="df63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以混合方括号和点符号。</p><p id="1901" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5be9" class="mn lc iq mj b gy mo mp l mq mr">book['author'].firstName</span></pre><h1 id="bf75" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">调用对象的方法</h1><p id="1bc6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以像调用其他函数一样调用一个方法。</p><p id="5666" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下对象:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1ccd" class="mn lc iq mj b gy mo mp l mq mr">const dog = {<br/>  name: 'james',<br/>  gender: 'male',<br/>  speak() {<br/>    console.log('woof');<br/>  }<br/>};</span></pre><p id="2407" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过编写调用<code class="fe ms mt mu mj b">speak</code>方法:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="477e" class="mn lc iq mj b gy mo mp l mq mr">dog.speak()</span></pre><h1 id="7fd5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">改变属性/方法</h1><p id="8c8e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过赋值来改变属性。</p><p id="09a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="da5f" class="mn lc iq mj b gy mo mp l mq mr">dog.name = 'jane';<br/>dog.gender = 'female';<br/>dog.speak = function() {<br/>  console.log('she barked');<br/>}</span></pre><p id="71ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe ms mt mu mj b">delete</code>操作符从对象中删除一个属性:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8d73" class="mn lc iq mj b gy mo mp l mq mr">delete dog.name</span></pre><p id="84d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当我们试图得到<code class="fe ms mt mu mj b">dog.name</code>时，我们得到<code class="fe ms mt mu mj b">undefined</code>。</p><h1 id="1fbd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用这个值</h1><p id="ea55" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个对象有自己的<code class="fe ms mt mu mj b">this</code>值。</p><p id="65eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在对象的方法中使用它。</p><p id="d14c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c07a" class="mn lc iq mj b gy mo mp l mq mr">const dog = {<br/>  name: 'james',<br/>  sayName() {<br/>    return this.name;<br/>  }<br/>};</span></pre><p id="520f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回<code class="fe ms mt mu mj b">this.name</code>，应该是<code class="fe ms mt mu mj b">'james'</code>。</p><p id="bf7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe ms mt mu mj b">this</code>是<code class="fe ms mt mu mj b">sayName</code>方法内的<code class="fe ms mt mu mj b">dog</code>对象。</p><h1 id="8b2b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构造函数</h1><p id="c056" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建构造函数来创建具有固定结构的对象。</p><p id="4bab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4d24" class="mn lc iq mj b gy mo mp l mq mr">function Person(name, occupation) {<br/>  this.name = name;<br/>  this.occupation = occupation;<br/>  this.whoAreYou = function() {<br/>    return `${this.name} ${this.occupation}`<br/>  };<br/>}</span></pre><p id="9126" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有实例属性<code class="fe ms mt mu mj b">name</code>、<code class="fe ms mt mu mj b">occupation</code>和<code class="fe ms mt mu mj b">this.whoAreYou</code>实例方法。</p><p id="cfeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们用构造函数创建一个新对象时，它们都被返回。</p><p id="7977" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe ms mt mu mj b">new</code>操作符来创建一个新的<code class="fe ms mt mu mj b">Person</code>实例:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6806" class="mn lc iq mj b gy mo mp l mq mr">const jane = new Person('jane', 'writer');</span></pre><p id="5aca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设置为返回的<code class="fe ms mt mu mj b">Person</code>实例的<code class="fe ms mt mu mj b">this</code> os的值。</p><p id="4c7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该将构造函数的第一个字母大写，这样我们就可以将它们与其他函数区分开来。</p><p id="3c51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该在没有操作符的情况下调用构造函数。</p><p id="e29d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ad49" class="mn lc iq mj b gy mo mp l mq mr">const jane = Person('jane', 'writer');</span></pre><p id="6387" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样,<code class="fe ms mt mu mj b">this</code>的值不会被设置为返回的<code class="fe ms mt mu mj b">Person</code>实例。</p><h1 id="ac5b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">全局对象</h1><p id="bff4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">浏览器中的全局对象是<code class="fe ms mt mu mj b">window</code>对象。</p><p id="1244" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用顶层的<code class="fe ms mt mu mj b">var</code>向它添加属性:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="78ff" class="mn lc iq mj b gy mo mp l mq mr">var a = 1;</span></pre><p id="d686" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">window.a</code>就是1。</p><p id="3de8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用不带<code class="fe ms mt mu mj b">new</code>的构造函数会返回<code class="fe ms mt mu mj b">undefined</code>。</p><p id="13c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a4fe" class="mn lc iq mj b gy mo mp l mq mr">const jane = Person('jane', 'writer');</span></pre><p id="257d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">jane</code>就是<code class="fe ms mt mu mj b">undefined</code>。</p><p id="f84b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">内置全局函数是全局对象的属性。</p><p id="9a62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe ms mt mu mj b">parseInt</code>和<code class="fe ms mt mu mj b">window.parseInt</code>一样。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/b53b11d224a43feaa239e00fe736c554.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vjKduz3OqHZUVk_5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rush_nishar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rushabh Nishar</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="1a93" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="a5f1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过两种方式访问对象属性。</p><p id="ce20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以创建构造函数来创建具有固定结构的对象。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/787be6c671be8d345dc786dad8729ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-sOyyG8NoRbKpCG_y4Cmw@2x.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank">Subscribe to Decoded, our official YouTube channel!</a></figcaption></figure></div></div>    
</body>
</html>