<html>
<head>
<title>Some of the JavaScript Interview Questions I have experienced</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我经历过的一些JavaScript面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/some-of-the-javascript-interview-questions-i-have-experienced-ce802e4e107d?source=collection_archive---------7-----------------------#2020-06-29">https://javascript.plainenglish.io/some-of-the-javascript-interview-questions-i-have-experienced-ce802e4e107d?source=collection_archive---------7-----------------------#2020-06-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4212" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我的一些个人经历</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f28495b85fa0fa9090c91030c0e5692f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*V2mRGyrbBm73Gp5C"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@headwayio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Headway</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f9ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近参加了一些JS面试，在面试中我被要求实现一些常用JS函数的定制实现。我们在日常的JS任务中使用它们。所以我想和大家分享这些。</p><p id="e522" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然你可能从来不需要提出自己的东西，但理解和思考它们是很好的。</p><p id="efc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你没有为面试做准备，只是想从总体上了解JavaScript，我邀请你一起来通读，因为你可能会从这篇文章中有所收获。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e613" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">平的</h1><p id="2bd2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">将嵌套数组展平到所需级别。</p><p id="8cd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="9ef5" class="nb ma iq mx b gy nc nd l ne nf">const arr = [[1,2,3], 2,5,4,56, [4,5,[45,6,7]]];<br/>const flatArr = arr.flat(1);<br/>flatArr; // [1,2,3,2,5,4,56,4,5,[45,6,7]]</span></pre><p id="9047" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是自定义实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="ba77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">customFlat接受三个参数:<code class="fe ni nj nk mx b">array</code>、<code class="fe ni nj nk mx b">level</code>、<code class="fe ni nj nk mx b">result array</code>(可选)。</p><p id="7f5c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们简单地遍历数组并检查当前项是否是一个数组；如果是，我们把它分布在结果数组中，否则我们直接把它推入数组。此后，我们递归调用平面函数，直到级别为0。我们最终返回结果数组。</p><p id="8ebb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是用法:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="0bd2" class="nb ma iq mx b gy nc nd l ne nf">const arr = [[1,2,3], 2,5,4,56, [4,5,[45,6,7]]];<br/>const flatArr = customFlat(arr, 2);<br/>flatArr; // [1,2,3,2,5,4,56,4,5,[45,6,7]]</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ace3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">去抖</h1><p id="0ef2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">去抖可以用在像搜索这样的场景中，你不想每次击键都触发请求；相反，您希望在发送请求之前有一个冷却期。</p><p id="e62e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面的示例记录了每次按钮点击:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Logs on every button click</figcaption></figure><p id="b438" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们先看看去抖的实现，然后应用到例子中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="78a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分解一下:</p><ol class=""><li id="3f35" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">我们的去抖函数有两个参数:<code class="fe ni nj nk mx b">delay</code>和<code class="fe ni nj nk mx b">function</code>来执行这个延迟。</li><li id="3ebf" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">我们在去抖函数中定义了一个<code class="fe ni nj nk mx b">timeoutID</code>，借助闭包的魔力，我们能够在从它返回的函数内部访问它。</li><li id="4b97" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">在内部函数中，我们清除timeoutID(如果有的话),否则我们通过调用setTimeout来分配一个新的ID。</li><li id="77ce" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated"><strong class="ky ir">清零</strong> <code class="fe ni nj nk mx b"><strong class="ky ir">timeoutID</strong></code> <strong class="ky ir">可确保setTimeout内的函数不会执行，直到延迟时间过去。</strong></li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Logs after 2s has passed</figcaption></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ab71" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">喉咙</h1><p id="54b2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">虽然反跳确保传递给它的函数在一定的延迟后被调用，但throttle每次都至少在延迟过去后调用该函数。</p><p id="bc36" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是自定义节流的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="cb15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分解一下:</p><ol class=""><li id="6e42" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">这个函数还接受两个参数:<code class="fe ni nj nk mx b">delay</code>和<code class="fe ni nj nk mx b">function</code>来执行。</li><li id="ed82" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">它有一个<code class="fe ni nj nk mx b">last</code>变量，该变量被设置为功能注册时的当前时间。</li><li id="2556" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">内部功能检查<code class="fe ni nj nk mx b">current</code>时间和<code class="fe ni nj nk mx b">last</code>时间的差值是否小于<code class="fe ni nj nk mx b">delay</code>。如果是，我们返回，因为我们不想调用该函数，否则我们执行该函数，并将最后一次作为当前时间。</li></ol><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nl nh l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">logs after atleast 2s</figcaption></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="524b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">约束</h1><p id="1be9" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe ni nj nk mx b">bind()</code>方法返回一个新的函数，当被调用时，它的<code class="fe ni nj nk mx b">this</code>被设置为一个特定的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="4c95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，Person函数显式绑定到传递给它的对象，即p1。</p><p id="fb9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们现在编写bind的自定义版本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="1184" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数的作用如下:</p><ol class=""><li id="6ae0" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">我们正在<code class="fe ni nj nk mx b">Function prototype</code>上定义一个功能<code class="fe ni nj nk mx b">myBind</code></li><li id="dac0" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">它接受的参数为<code class="fe ni nj nk mx b">args</code></li><li id="d63c" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">有<code class="fe ni nj nk mx b">obj</code>设置为我们正在调用的功能<code class="fe ni nj nk mx b">myBind</code>。在我们的案例中，它是人。</li><li id="7498" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">有<code class="fe ni nj nk mx b">rest</code>取除第一个参数以外的所有参数。<code class="fe ni nj nk mx b">args[0]</code>是我们绑定函数的地方，其余的参数是我们称之为<code class="fe ni nj nk mx b">myBind</code>函数的地方。在我们的例子中，<code class="fe ni nj nk mx b">args[0]</code>是p1对象，其余的参数是<code class="fe ni nj nk mx b">cricket</code></li><li id="a176" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">最后，我们返回一个函数，它接受自己要调用的参数。我们在传递相关参数时，简单地将从外部范围获得的<code class="fe ni nj nk mx b">obj</code>称为<code class="fe ni nj nk mx b">apply</code>。</li></ol><p id="75c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在前面的示例中使用它:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="5db6" class="nb ma iq mx b gy nc nd l ne nf">const bindMe = Person.myBind(p1, 'cricket');<br/>console.log(bindMe('Sachin'));// Ravi 65 [ 'cricket', 'Sachin' ]<br/>console.log(bindMe('Sehwag'));// Ravi 65 [ 'cricket', 'Sehwag' ]</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4530" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">深度冻结对象</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/9556f123eadfb4b9ecf473c8b8519fcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NQVRALVgVtVF389t"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@barkosulin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Barbara Kosulin</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f677" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经在javascript对象上使用了freeze方法，它可以防止新属性被添加到其中，现有属性被移除，防止现有属性的可枚举性、可配置性或可写性发生变化，并防止现有属性的值发生变化。</p><p id="6021" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但它只在第一层起作用。因此，作为一个挑战，我被要求实现一个在嵌套层冻结对象的自定义实现。</p><p id="e781" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我提出的递归实现:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="cc48" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是上述函数的作用:</p><ol class=""><li id="52e0" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">检查<code class="fe ni nj nk mx b">typeof</code>对象的值本身是否是一个对象。如果没有，我们就回来。</li><li id="cfce" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">然后，我们循环对象值，用传入的值递归调用deepFreeze。</li><li id="73e6" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">最后，我们只需调用我们的<code class="fe ni nj nk mx b">obj</code>上的<code class="fe ni nj nk mx b">Object.freeze</code></li></ol><p id="9f87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">测试以上内容:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="5ed3" class="nb ma iq mx b gy nc nd l ne nf">const obj = {<br/>    a:123,<br/>    b:{<br/>       c:4334534534<br/>    }<br/>}<br/>deepFreeze(obj);</span><span id="5605" class="nb ma iq mx b gy ob nd l ne nf">obj.b.c = 234;</span><span id="07de" class="nb ma iq mx b gy ob nd l ne nf">console.log(obj); // {a:123, b:{c: 4334534534}}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2019" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="004e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">这些都是被问到的问题。很明显，我无法解决所有问题，但后来我明白了如何在本地解决。我希望这能对某人未来的努力有所帮助。</p><div class="oc od gp gr oe of"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">Array.prototype.flat()</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">flat()方法创建一个新数组，所有子数组元素递归地连接到该数组中，直到指定的…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">developer.mozilla.org</p></div></div><div class="oo l"><div class="op l oq or os oo ot kp of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://css-tricks.com/debouncing-throttling-explained-examples/" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">通过示例解释去抖动和节流| CSS技巧</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">以下是伦敦前端工程师David Corbacho的客座博文。我们以前讨论过这个话题，但是…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">css-tricks.com</p></div></div><div class="oo l"><div class="ou l oq or os oo ot kp of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">函数.原型.绑定()</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">bind()方法创建了一个新函数，当调用该函数时，它的this关键字被设置为提供的值，并带有一个…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">developer.mozilla.org</p></div></div><div class="oo l"><div class="ov l oq or os oo ot kp of"/></div></div></a></div><div class="oc od gp gr oe of"><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze#:~:text=A%20frozen%20object%20can%20no,existing%20properties%20from%20being%20changed." rel="noopener  ugc nofollow" target="_blank"><div class="og ab fo"><div class="oh ab oi cl cj oj"><h2 class="bd ir gy z fp ok fr fs ol fu fw ip bi translated">Object.freeze()</h2><div class="om l"><h3 class="bd b gy z fp ok fr fs ol fu fw dk translated">方法的作用是:冻结一个对象。冻结的对象不能再被改变；冻结对象会阻止新的…</h3></div><div class="on l"><p class="bd b dl z fp ok fr fs ol fu fw dk translated">developer.mozilla.org</p></div></div><div class="oo l"><div class="ow l oq or os oo ot kp of"/></div></div></a></div><h2 id="ee45" class="nb ma iq bd mb ox oy dn mf oz pa dp mj lf pb pc ml lj pd pe mn ln pf pg mp ph bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="f6a5" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？在<a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> plainenglish.io </strong> </a>和<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">找到它们订阅我们的YouTube频道</strong> </a> <strong class="ky ir">！</strong></p></div></div>    
</body>
</html>