# 用 Vue 和组合 API 构建数据层

> 原文：<https://javascript.plainenglish.io/building-a-data-layer-with-vue-and-composition-api-547cc9761b4c?source=collection_archive---------3----------------------->

当你学习一个新的前端库时，比如 Vue 或 React，你可以阅读很多关于某些最佳实践的资料。在有效的组件组合、如何防止性能瓶颈以及状态管理的基础(如 Redux、VueX 等)上寻找资源应该没有问题。

但是，有一个领域很难找到任何信息，那就是如何构建一个好的数据层。人们通常会花很多心思来优化和组织视图层，但数据层可能会被忽略，并成为常见的错误来源。

什么是数据层？

在前端应用程序的上下文中，数据层实际上指的是三层:

1.  获取层—使用 XHR、获取或 Websockets 联系服务器的代码。通常是一组服务(类)或纯功能。
2.  规范化/序列化层—处理传入和传出数据的代码。
3.  存储层—处理将数据保存和访问到客户端存储的代码。

令人惊讶的是，网上关于如何做好这些的信息很少。可能是因为这个逻辑高度依赖于你的 API 的设计，很难通用化。尽管如此，我还是会试着提供一些指导。

# 你需要数据层吗？

如果一个组件直接执行 ajax 调用，并使用原始响应来呈现数据，而不将其存储在任何类型的客户端存储中，这实质上意味着不涉及数据层。

在某些情况下，这是好的，但在很多情况下，根本不是。

使用这种方法，在以下情况下可能会出现问题…

1.  同一种请求在多个地方被执行，提取逻辑需要被重用
2.  来自服务器的数据需要被处理。
3.  部分或全部数据可能需要在其他地方重用
4.  数据需要被再次使用，例如当用户回到先前的路线时，再次触发相同的请求不是最佳的。
5.  这里涉及到 SSR，服务器状态需要传递给客户端

随着越来越多的内容需要被覆盖，复杂性会呈指数级增长。在一个组件中直接处理这些问题很容易失控，因此您必须开始将逻辑移到其他地方，并开始将其一般化——这就是数据层如何慢慢开始形成的。

如果您的后端支持 GraphQL 之类的传统解决方案，或者符合 JSON:API 之类的标准，那么您可以通过使用现有的数据层客户端(如 Apollo 或 vuex-orm)来节省大部分或全部工作。Apollo 需要一个 GraphQL 后端，使用 vuex-orm 是有意义的，尤其是如果你的 API 是 Restful 的话。

如果不是，并且你的后台是非传统的，那么工作就在你身上。这就是我要报道的案子。

# 提取图层

让我们从一个组件开始，它使用 Axios 执行 ajax 请求，并将数据传递给模板。

该组件获取并处理结果:

这是在组件中直接联系 API 的一种非常低级的方法。我们看到一堆引用被使用，如`data` `error` `isLoading`。我们将它们和`fetchUsers`函数本身一起传递给模板——以便在需要时可以再次触发(例如让用户重试)。

尽管如此，只是为了获得一些用户还是有很多代码，而且像这样的逻辑肯定会在代码的很多地方出现。

在这一点上，我们可以引入第三方解决方案，如 vue-use、vue-composition-toolkit、vue-concurrency 中的 util 函数来改进它。或者我们可以开始使用悬念，而不是设置裁判，在`setup`中直接使用`async/await`并返回一个承诺。

但是出于演示的目的，让我们将前面的代码重构为一个通用的解决方案:

通用的 ref 设置逻辑被移动到一个名为`useAsync`的定制钩子中，只有特定于案例的逻辑通过回调传递给它。回调预计会触发一些 ajax 并返回数据。

现在，我也创建了一个小的`normalizeUser`函数，但是以后还会有更多的工作。

还要注意`processError`。在来自服务器的所有响应上使用这个函数允许我们向一致和统一的错误处理前进。

如果这个`useAsync`函数在整个应用程序中使用，我们就有效地创建了一个基本的获取层。由于序列化和存储层的需要，它可能需要一些补丁，但基础是存在的。

# 序列化层

序列化层的目的是处理传入和传出的数据，并至少执行以下一些操作:

1.  验证响应是否具有正确的格式(可能通过像 [io-ts](https://github.com/gcanti/io-ts) 这样的工具)
2.  改变结构以适应用户界面的需要(也许是为了让数据更容易迭代)
3.  将日期字符串序列化为日期对象
4.  调整命名，也许将 snake_case 改为 camelCase
5.  如果需要，提高不同端点之间的命名一致性
6.  删除我们不需要的数据。这就清楚了 FE 实际使用的是哪种数据。较小的对象更容易处理，也可能对性能产生影响(潜在的反应跟踪更少)

API 响应中发送的模型往往很大，并且由于历史原因或因为其他客户端(移动应用程序、机器人、第三方脚本)需要而具有额外的属性。

基本规范化函数可能如下所示:

它的输出是一个小而简单的对象，也提供了一些回退值。

序列化函数会做相反的事情。将“正常化”的用户变回原来的格式。当您将用户发送回您的 API 时，可能是在编辑个人数据时，您会用到它。

这里这个函数更简单，可能只返回服务器希望客户机改变的内容的子集。图像被排除在外，因为它们可能由特定的端点处理。在严格的 REST-API 的情况下，这对于一个`PATCH`请求`PATCH /users/1`来说是可以的。对于一个合适的`PUT`请求来说，整个模型被发送出去，而不仅仅是一组变更，这是不可行的。定制 API 通常也期望一组变化，否则，它们将是 RESTful 的:)。

# 商店层

如果正在获取数据并将其规范化为最简单的格式，它们就可以存储了。

在这一点上，有一些问题需要解决。如何存储数据？窝多深？将实体存储在 Map(Dict)结构中还是作为数组？

让我们回到我们之前的`useAsync` + `fetchUsers`的解决方案。我们在`useAsync`内部传递了一个回调函数，它调用 Axios 并触发规范化函数。这个函数现在应该再做一件事:除了返回数据之外，还要将它们传递给商店。在 VueX 中，这意味着让它们发生某种变异。

这将是最直接的方法:

这里发生了什么事？我们使用 store 中的两个 getter—`hasUsers`和`users`。`hasUsers`是一个简单的布尔值返回函数，它检查有效的`users`是否在存储中。开始时，它可以只在存储、非空数组或对象中寻找真值。稍后，它可能会变得更加复杂，甚至检查最后一次获取的时间(如果用户在很久以前被加载，它们就不再有效)。

但是在这一点上，我们陷入了和以前相似的困境。随着我们开始在新组件中处理更多的端点，我们可能不得不一遍又一遍地做这样的事情:

1.  检查存储中的有效值，如果存在，立即通过存储 getters 返回
2.  成功后，将数据提交给存储

看起来相似的代码会一遍又一遍地重复，每次我们都必须考虑如何命名 getters 和 mutations。

这难道不能被抽象化吗？

是的，如果我们幸运地拥有一个 GraphQL 后端和一个 Apollo 客户端，或者如果我们有一个 RESTful，甚至可能是 JSON:API 后端并使用 vuex-orm，我们就不必处理这个问题。在 GraphQL 领域，我们只执行查询，在 REST 领域，我们以 CRUD 方式处理一致的资源，并通过 orm 进行抽象。

如果我们的 API 是定制的，我们至少可以优化每个端点发生的逻辑。在每次端点调用时，我们将检查现有值，并可能保存一个新值，或者两者都保存(以防后台重载)。

我们的钩子能搞定吗？

在某种程度上，是的，在这一点上，我们可能应该把它重新命名为类似于`useApi`的东西，因为它变得更加固执己见。或者更好的办法是，在`useAsync`的顶部加上`useApi`。

有两种方法可以解决这个问题:约定或配置。

**配置**:调用`useApi`
**约定:**从一个端点名或者从一个函数名派生出 getter 和 mutation 名。

我通常更喜欢传统而不是配置，所以我选择后者。

在这种情况下，`useApi`在`useAsync`之上构成。它需要传递一个命名函数，并从中派生出存储 getter 和 setter 名称。因此它检查`hasUsers`，如果返回 true，它返回`Users` getter。成功后，它调用`setUsers`突变。点击一个新的端点就变成了创建一个函数`X`并在`hasX` `X`和`setX`的存储中创建 getters 和 setters 的例程。这种方法的一种替代方法是将 getter 和 setter 名称传递到`useApi`中，但是根据我的经验，这种约定可以减少开销。

# 文件夹结构？

随着这种方法的发展，很明显需要一些额外的代码来获取、序列化和存储数据。它可以并排存储在一个组件中，但是通常更好的方法是创建某种类型的`data`文件夹。

在该文件夹中，可以有一个文件列表，每个端点处理程序一个文件。

```
data
  createUser.js
  findUser.js
  createPost.js
  findPost.js
  login.js 
```

这些函数中的每一个都有一个`normalizeReponse`函数、`fetch`函数和几个将被传递给存储的突变函数和 getter 函数。

如果逻辑进一步膨胀，就有可能进一步分割:

```
data
  createUser
    fetch.js
    serialize.js
    store.js
```

但是根据我的经验，几乎不需要这么深！

# 包扎

我希望这个小小的见解有用。实际上，一个定制的`useApi`函数可能会膨胀，但是创建一些灵活、有用且易于维护的东西是可能的——一个定制的高质量数据层。

## 在 herohero 上订阅每周编码示例、技巧和提示

嘿👋如果你觉得这些内容有帮助，请在 herohero 上订阅我，我经常在这里分享我日常使用 JavaScript 和 Vue 的经验中的简洁而有用的编码技巧。

[![](img/19339e390e1513a8a73f83e1ec1036a2.png)](https://herohero.co/martin)