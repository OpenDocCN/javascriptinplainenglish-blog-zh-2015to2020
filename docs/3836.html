<html>
<head>
<title>Simulate Browser Interactions with Testing Library’s UserEvent</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用测试库的用户事件模拟浏览器交互</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/simulate-browser-interactions-with-testing-librarys-userevent-cf8480d2606?source=collection_archive---------4-----------------------#2020-10-28">https://javascript.plainenglish.io/simulate-browser-interactions-with-testing-librarys-userevent-cf8480d2606?source=collection_archive---------4-----------------------#2020-10-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b87c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">图书馆用户事件API测试指南</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/6324f77ae741f5adaeb262779d02b509.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*oxTbKerG0NwOvj7q"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="600f" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">我的旅程</h1><p id="05a2" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">像大多数人一样，当我第一次开始使用<a class="ae ks" href="https://testing-library.com/docs/intro" rel="noopener ugc nofollow" target="_blank">测试库</a>，<a class="ae ks" href="https://medium.com/javascript-in-plain-english/interaction-testing-with-react-testing-library-d824f74ce48a" rel="noopener">时，我使用Fire Event来测试组件交互</a>。毕竟，这个API是库本身附带的，并且用于文档中的测试示例。但我很快发现，火灾事件有严重的局限性。我会尝试单击某个东西，但没有出现预期的效果。为什么？</p><h1 id="6e45" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">浏览器事件</h1><p id="f98b" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">为了理解这个问题，我们需要更好地理解浏览器事件。当用户点击浏览器中的某个东西时，会触发多个事件— <code class="fe mh mi mj mk b">mouseDown</code>、<code class="fe mh mi mj mk b">mouseUp</code>、<code class="fe mh mi mj mk b">click</code>和<code class="fe mh mi mj mk b">focus</code>。类似地，当输入内容时，<code class="fe mh mi mj mk b">keyDown</code>、<code class="fe mh mi mj mk b">keyUp</code>和<code class="fe mh mi mj mk b">keyPress</code>事件都会触发！因为单个用户交互可以触发多个事件，所以开发人员有多种实现选择。这就是我遇到问题的地方。</p><h1 id="0be0" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">火灾事件</h1><p id="b679" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">不幸的是，Fire事件要求您使用相应事件处理程序的方法来触发。如果一个元素有<code class="fe mh mi mj mk b">onClick</code>事件处理程序，我就得用<code class="fe mh mi mj mk b">fireEvent.click</code>；如果一个元素有一个<code class="fe mh mi mj mk b">onMouseDown</code>事件处理器，我必须使用<code class="fe mh mi mj mk b">fireEvent.mouseDown</code>。换句话说，我需要知道事件处理程序的确切实现才能成功使用<code class="fe mh mi mj mk b">fireEvent</code>。</p><h1 id="38b4" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">用户事件</h1><p id="a0b2" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><a class="ae ks" href="https://www.npmjs.com/package/@testing-library/user-event" rel="noopener ugc nofollow" target="_blank">用户事件</a>是Fire事件的更高级实现，更好地模拟了浏览器事件。它基于Fire事件来触发通常会在浏览器上发生的一系列事件。这允许您更像用户一样进行交互，而不关心内部实现，最终确保您的测试环境交互更加真实。</p><h1 id="f743" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">用户事件与火灾事件</h1><p id="1471" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><a class="ae ks" href="https://www.npmjs.com/package/react-select" rel="noopener ugc nofollow" target="_blank"> React Select </a>是Fire事件的局限性和用户事件的价值的最好例子。它会呈现一个输入，当您单击它时会打开一个选项菜单。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/b0ffeb72d6679751501851e7607c67a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*lvhVZOauQ1oifYh1gRxnvA.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">React Select</figcaption></figure><p id="c8a2" class="pw-post-body-paragraph ll lm in ln b lo mm jo lq lr mn jr lt lu mo lw lx ly mp ma mb mc mq me mf mg ig bi translated">使用Fire Event，您可以在单击下拉指示器时看到选择选项。</p><pre class="kd ke kf kg gt mr mk ms mt aw mu bi"><span id="8639" class="mv ku in mk b gy mw mx l my mz">import { fireEvent, render, screen } from '<a class="ae ks" href="http://twitter.com/testing" rel="noopener ugc nofollow" target="_blank">@testing</a>-library/react';<br/>import ReactSelect from 'react-select';</span><span id="e3d6" class="mv ku in mk b gy na mx l my mz">// test fails<br/>test('should open select menu with fireEvent click', () =&gt; {<br/>  const { container, queryByText } = render(<br/>    &lt;ReactSelect classNamePrefix="select" options={options} /&gt;<br/>  );<br/>  const control = container.querySelector('.select__dropdown-indicator');<br/>  fireEvent.click(control);<br/>  expect(getByText('React')).toBeTruthy();<br/>  expect(getByText('Vue')).toBeTruthy();<br/>  expect(getByText('Angular')).toBeTruthy();<br/>});</span></pre><p id="c4f1" class="pw-post-body-paragraph ll lm in ln b lo mm jo lq lr mn jr lt lu mo lw lx ly mp ma mb mc mq me mf mg ig bi translated">但这并没有发生！遇到这个的时候，好迷茫。在磕磕绊绊地通过React Select代码库中的<a class="ae ks" href="https://github.com/JedWatson/react-select/blob/master/packages/react-select/src/__tests__/Select.test.js#L798" rel="noopener ugc nofollow" target="_blank">测试后，我发现我需要使用<code class="fe mh mi mj mk b">fireEvent.mouseDown</code>来获得打开菜单的预期效果。</a></p><p id="f33f" class="pw-post-body-paragraph ll lm in ln b lo mm jo lq lr mn jr lt lu mo lw lx ly mp ma mb mc mq me mf mg ig bi translated">但是对于用户事件，我不需要担心这个实现细节！</p><pre class="kd ke kf kg gt mr mk ms mt aw mu bi"><span id="7895" class="mv ku in mk b gy mw mx l my mz">import userEvent from '<a class="ae ks" href="http://twitter.com/testing" rel="noopener ugc nofollow" target="_blank">@testing</a>-library/user-event';</span><span id="9f6e" class="mv ku in mk b gy na mx l my mz">// test succeeds<br/>test('should open select menu with userEvent click', () =&gt; {<br/>  const { container, getByText } = render(<br/>    &lt;ReactSelect classNamePrefix="select" options={options} /&gt;<br/>  );<br/>  const control = container.querySelector('.select__dropdown-indicator');<br/>  userEvent.click(control);<br/>  expect(getByText('React')).toBeTruthy();<br/>  expect(getByText('Vue')).toBeTruthy();<br/>  expect(getByText('Angular')).toBeTruthy();<br/>});</span></pre><p id="c5eb" class="pw-post-body-paragraph ll lm in ln b lo mm jo lq lr mn jr lt lu mo lw lx ly mp ma mb mc mq me mf mg ig bi translated">由于<code class="fe mh mi mj mk b">userEvent.click</code>触发了多个事件，其中包括通常会在浏览器中发生的<code class="fe mh mi mj mk b">mouseDown</code>事件，因此正确的事件处理程序被触发，菜单打开。</p><h1 id="34cd" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">蜜蜂</h1><p id="4d80" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">用户事件提供的不仅仅是上面的click方法。它提供了以下API，这些API将使您的测试工作变得更加容易。</p><ul class=""><li id="66dc" class="nb nc in ln b lo mm lr mn lu nd ly ne mc nf mg ng nh ni nj bi translated"><strong class="ln io">悬停</strong>将触发目标元素的<code class="fe mh mi mj mk b">pointerOver</code>、<code class="fe mh mi mj mk b">mouseOver</code>、<code class="fe mh mi mj mk b">pointerMove</code>、<code class="fe mh mi mj mk b">mouseMove</code>事件处理程序，并触发所有父元素的<code class="fe mh mi mj mk b">pointerEnter</code>和<code class="fe mh mi mj mk b">mouseEnter</code>事件处理程序。</li><li id="a384" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated"><strong class="ln io"> unhover </strong>会做与上面<em class="np"> hover </em> API相同的事情，但是顺序相反。</li><li id="97d5" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated"><strong class="ln io">点击</strong>将触发上述<em class="np">悬停</em> API，然后触发<code class="fe mh mi mj mk b">pointerDown</code>、<code class="fe mh mi mj mk b">mouseDown</code>、<code class="fe mh mi mj mk b">focus</code>、<code class="fe mh mi mj mk b">pointerUp</code>、<code class="fe mh mi mj mk b">mouseUp</code>和<code class="fe mh mi mj mk b">click</code>事件处理程序。如果有一个先前聚焦的元素，它也会触发模糊。</li><li id="65b9" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated"><strong class="ln io"> dblClick </strong>将触发上述<em class="np"> click </em>方法两次，但只触发上述<em class="np"> hover </em>一次。</li><li id="6c57" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated"><strong class="ln io"> type </strong>将首先触发元素上的上述<em class="np"> click </em> API，然后触发<code class="fe mh mi mj mk b">keyDown</code>、<code class="fe mh mi mj mk b">keyUp</code>、<code class="fe mh mi mj mk b">keyPress</code>，改变事件处理程序。通过该API添加的文本将在现有文本之上完成。因此，如果您执行<code class="fe mh mi mj mk b">userEvent.type(input, ' World')</code>并且输入已经有了值<code class="fe mh mi mj mk b">Hello</code>，那么结果文本将是<code class="fe mh mi mj mk b">Hello World</code>。此外，文字将遵守任何选定的文本行为，并在添加新文本时删除它。</li><li id="23c4" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated"><strong class="ln io">上传</strong>将触发上面的<em class="np">点击</em> API，然后是<code class="fe mh mi mj mk b">blur</code>(当文件选择器弹出时)、<code class="fe mh mi mj mk b">focus</code>(从弹出的文件中选择一个文件后)，以及输入元素上的<code class="fe mh mi mj mk b">change</code>事件处理程序。</li><li id="9988" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated"><strong class="ln io">清除</strong>将触发上述<em class="np">类型</em>方法，用全选和删除清除输入文本。</li><li id="513b" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated"><strong class="ln io"> selectOptions </strong>将触发上述<em class="np">悬停</em>、<em class="np">点击</em>、<em class="np">取消悬停</em>选择元素选项上的API。</li><li id="ffac" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated">如果选择元素启用了多个值，则<strong class="ln io">取消选择选项</strong>将执行与上述<em class="np">选择选项</em> API相同的操作。</li><li id="30a0" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated"><strong class="ln io"> tab </strong>将触发下一个tabbable元素上的<code class="fe mh mi mj mk b">focus</code>事件处理程序，并触发当前聚焦元素上的<code class="fe mh mi mj mk b">blur</code>事件处理程序。</li><li id="0ca3" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated"><strong class="ln io">粘贴</strong>将触发一个粘贴剪贴板事件，该事件将在现有文本的顶部插入文本。</li></ul></div><div class="ab cl nq nr hr ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ig ih ii ij ik"><h1 id="2be4" class="kt ku in bd kv kw nx ky kz la ny lc ld jt nz ju lf jw oa jx lh jz ob ka lj lk bi translated">最后的想法</h1><p id="43eb" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">用户事件旨在解决使用和实现之间的脱节，使您的测试更加准确和可靠。它消除了理解实现的需要，并努力模拟用户如何与组件交互，这是测试库本身的核心指导原则。用户不关心你是否使用<code class="fe mh mi mj mk b">mouseDown</code> vs <code class="fe mh mi mj mk b">mouseUp</code> vs <code class="fe mh mi mj mk b">click</code>实现了事件处理程序！你的测试也不应该！但前提是您开始使用用户事件。</p></div><div class="ab cl nq nr hr ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ig ih ii ij ik"><h1 id="b8fb" class="kt ku in bd kv kw nx ky kz la ny lc ld jt nz ju lf jw oa jx lh jz ob ka lj lk bi translated">资源</h1><ul class=""><li id="b124" class="nb nc in ln b lo lp lr ls lu oc ly od mc oe mg ng nh ni nj bi translated"><a class="ae ks" href="https://www.npmjs.com/package/@testing-library/user-event" rel="noopener ugc nofollow" target="_blank">官方用户活动文档</a></li><li id="87df" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated"><a class="ae ks" href="https://testing-library.com/docs/intro" rel="noopener ugc nofollow" target="_blank">官方测试库文档</a></li><li id="e2fc" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated"><a class="ae ks" href="https://medium.com/@changmander/interaction-testing-with-react-testing-library-d824f74ce48a" rel="noopener">交互测试指南</a></li><li id="9030" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated"><a class="ae ks" href="https://github.com/mjchang/medium/tree/master/user-event" rel="noopener ugc nofollow" target="_blank">本文Github回购</a></li><li id="f2bb" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated"><a class="ae ks" href="https://codesandbox.io/s/github/mjchang/medium/tree/master/user-event?file=/src/Select.test.js" rel="noopener ugc nofollow" target="_blank">本文的code sandbox</a></li></ul></div><div class="ab cl nq nr hr ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ig ih ii ij ik"><h1 id="4a33" class="kt ku in bd kv kw nx ky kz la ny lc ld jt nz ju lf jw oa jx lh jz ob ka lj lk bi translated">放弃</h1><p id="4ad6" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在写这篇文章的时候，我注意到<a class="ae ks" href="https://testing-library.com/docs/dom-testing-library/api-events" rel="noopener ugc nofollow" target="_blank"> Fire事件文档</a>现在包含了一个关于使用用户事件的简介。这是在【2020年8月新增的。</p></div></div>    
</body>
</html>