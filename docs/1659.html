<html>
<head>
<title>JavaScript Algorithm: Wherefore Art Thou</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法:你为什么存在</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-algorithm-wherefore-art-thou-1e6eb6c10ba2?source=collection_archive---------7-----------------------#2020-04-11">https://javascript.plainenglish.io/javascript-algorithm-wherefore-art-thou-1e6eb6c10ba2?source=collection_archive---------7-----------------------#2020-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bc3c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我们编写了一个函数，该函数返回一个数组中的所有对象，该数组包含来自源对象的所有名称/值对。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/dd604d051acf6fa639f0e6a557f80b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A5XCI9ssbWCohomdS6vBQA@2x.png"/></div></div></figure><p id="3908" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将编写一个名为<code class="fe ln lo lp lq b">whatIsInAName</code>的函数，它接受一个数组(<code class="fe ln lo lp lq b">collection</code>)和一个对象(<code class="fe ln lo lp lq b">source</code>)。</p><p id="0d5c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你会得到一个对象数组。该函数的目标是查看对象的<code class="fe ln lo lp lq b">collection</code>数组，并返回具有匹配名称和值对的所有对象的数组作为<code class="fe ln lo lp lq b">source</code>对象。</p><p id="6f92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">从<code class="fe ln lo lp lq b">collection</code>开始，对象中必须存在<code class="fe ln lo lp lq b">source</code>对象的每个</strong>名称和值对。</p><p id="bc46" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">示例:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="ecfa" class="lv lw iq lq b gy lx ly l lz ma">let collection = [<br/>{ "apple": 1, "bat": 2 }, <br/>{ "bat": 2 }, <br/>{ "apple": 1, "bat": 2, "cookie": 2 }<br/>];</span><span id="1011" class="lv lw iq lq b gy mb ly l lz ma">let source = { "apple": 1, "bat": 2 };</span></pre><p id="a8d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们看看我们的例子，唯一包含来自<code class="fe ln lo lp lq b">source</code>的所有名称和值对的对象是第一个和第三个对象。该函数将这两个对象放入一个数组并返回:</p><p id="051e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">[{ “apple”: 1, “bat”: 2 }, { “apple”: 1, “bat”: 2, “cookie”: 2 }]</code></p><p id="89b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们编写函数。</p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="5a81" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们创建三个变量:</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="3b58" class="lv lw iq lq b gy lx ly l lz ma">let arr = [];<br/>let hasAllEntries = 0;<br/>const sourceObject = Object.entries(source);</span></pre><p id="571e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">arr</code>变量是用于保存<code class="fe ln lo lp lq b">collection</code>数组中所有对象的变量，该数组中所有匹配的名称-值对都作为<code class="fe ln lo lp lq b">source</code>。</p><p id="5e7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于下一个变量，我费了好大劲才找到方法来确保<code class="fe ln lo lp lq b">collection</code>对象中的每个对象都有<strong class="kt ir">匹配<code class="fe ln lo lp lq b">source</code>对象中的每个名称-值对。《财富》美国500强排名第14位的公司将继续关注此事。</strong></p><p id="fe9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">sourceObject</code>变量使用<code class="fe ln lo lp lq b">Object</code>对象将对象转换为数组。<a class="ae mj" href="https://zellwk.com/blog/looping-through-js-objects/" rel="noopener ugc nofollow" target="_blank">这使得迭代变得容易。</a></p><p id="1358" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">Object.entries</code>创建数组的数组。每个子阵列有两个项目。第一个是属性，第二个是值。此变量构成了<code class="fe ln lo lp lq b">source</code>对象参数的数组。</p><p id="d0a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，我们循环通过<code class="fe ln lo lp lq b">collection</code>数组。然后我们添加一个额外的嵌套for循环，以循环通过<code class="fe ln lo lp lq b">sourceObject</code>数组。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="545a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于我们在<code class="fe ln lo lp lq b">collection</code>数组中循环通过的每个对象，我们也循环通过<code class="fe ln lo lp lq b">sourceObject</code>数组中的每个键值对。</p><p id="caff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当遍历<code class="fe ln lo lp lq b">sourceObject</code>时，由于我们处理的是一个二维数组，我们将数组析构为它的键(<code class="fe ln lo lp lq b">sourceKey</code>)和值(<code class="fe ln lo lp lq b">sourceValue</code>)。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="3d3f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的条件中，如果<code class="fe ln lo lp lq b">collection</code>数组中的对象包含与<code class="fe ln lo lp lq b">sourceKey</code>匹配的属性，并且如果该对象属性的值与<code class="fe ln lo lp lq b">sourceValue</code>匹配，我们就增加<code class="fe ln lo lp lq b">hasAllEntries</code>。</p><p id="aeeb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您阅读过前面的内容，那么为我们从<code class="fe ln lo lp lq b">collection</code>中的每个对象获得的每个名称-值对计数<code class="fe ln lo lp lq b">hasAllEntries</code>变量是跟踪和查看该对象是否拥有来自<code class="fe ln lo lp lq b">source</code>对象的所有名称-值对的唯一方法。</p><p id="be95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">许多其他解决方案中，我只在<code class="fe ln lo lp lq b">arr</code>数组中填充了只有<em class="mm">一个</em>名称-值对匹配的对象。该函数应该返回匹配每一对的对象。</p><p id="98ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了回到函数，我们写了一个条件。根据<code class="fe ln lo lp lq b">sourceObject</code>的长度，如果<code class="fe ln lo lp lq b">hasAllEntries</code>等于<code class="fe ln lo lp lq b">sourceObject</code>数组的长度，这意味着来自<code class="fe ln lo lp lq b">collection</code>的特定对象拥有来自<code class="fe ln lo lp lq b">source</code>的每个名称-值对。如果是这种情况，我们将该对象推入<code class="fe ln lo lp lq b">arr</code>数组。</p><p id="e1cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们进入下一个对象之前，我们将<code class="fe ln lo lp lq b">hasAllEntries</code>重置回0。</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="31e3" class="lv lw iq lq b gy lx ly l lz ma">if (hasAllEntries === sourceObject.length) {<br/>    arr.push(object);<br/>}</span><span id="8e35" class="lv lw iq lq b gy mb ly l lz ma">hasAllEntries = 0;</span></pre><p id="6ac5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">循环完成后，我们返回<code class="fe ln lo lp lq b">arr</code>数组。</p><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="3287" class="lv lw iq lq b gy lx ly l lz ma">return arr;</span></pre><p id="7798" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的代码到此结束。它并不完美，但下面是函数的其余部分:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><p id="05a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你觉得这个算法有帮助，看看我的其他JavaScript算法解决方案:</p><div class="mn mo gp gr mp mq"><a href="https://codeburst.io/javascript-algorithm-return-largest-numbers-in-arrays-476914b717a7" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">JavaScript算法:返回数组中最大的数字</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">我们编写了一个函数，从数组参数中返回一个数组，该数组包含每个子数组中最大的数字</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">codeburst.io</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne kp mq"/></div></div></a></div><div class="mn mo gp gr mp mq"><a href="https://levelup.gitconnected.com/javascript-algorithm-remove-the-time-de34cfb909cd" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">JavaScript算法:去掉时间</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">我们将编写一个函数，输出以某种格式编写的时间戳。</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="mz l"><div class="nf l nb nc nd mz ne kp mq"/></div></div></a></div><div class="mn mo gp gr mp mq"><a href="https://medium.com/javascript-in-plain-english/javascript-algorithm-minimum-distances-65dfde1ca83f" rel="noopener follow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd ir gy z fp mv fr fs mw fu fw ip bi translated">JavaScript算法:最小距离</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">对于今天的算法，我们要写一个名为minimumDistances的函数，它将接受一个数组a作为…</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">medium.com</p></div></div><div class="mz l"><div class="ng l nb nc nd mz ne kp mq"/></div></div></a></div><pre class="kg kh ki kj gt lr lq ls lt aw lu bi"><span id="2d12" class="lv lw iq lq b gy lx ly l lz ma">hasAllEntries = 0;<br/>}</span></pre><h2 id="402c" class="lv lw iq bd nh ni nj dn nk nl nm dp nn la no np nq le nr ns nt li nu nv nw nx bi translated"><strong class="ak">用简单的英语写的JavaScript的注释:</strong></h2><p id="0427" class="pw-post-body-paragraph kr ks iq kt b ku ny jr kw kx nz ju kz la oa lc ld le ob lg lh li oc lk ll lm ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae mj" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kt ir">AI in Plain English</strong></a><a class="ae mj" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kt ir">UX in Plain English</strong></a><a class="ae mj" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kt ir">Python in Plain English</strong></a><strong class="kt ir"/>——谢谢，继续学习！</p></div></div>    
</body>
</html>