<html>
<head>
<title>JavaScript Mistakes — Useless Promise Code and Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript错误——无用的承诺代码和操作</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-mistakes-useless-promise-code-and-operations-d4a22debed04?source=collection_archive---------7-----------------------#2020-04-16">https://javascript.plainenglish.io/javascript-mistakes-useless-promise-code-and-operations-d4a22debed04?source=collection_archive---------7-----------------------#2020-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ecdb2ed98b71a3cd166bb96283ac35a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e0xW73whUwy-W8sj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@krishnadigitalcolorphotostudio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Shivam Kumar</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="eb53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="6ace" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将会看到一些多余的代码，我们应该把它们从我们的代码中删除，放在我们的异步函数和其他地方。</p><h1 id="2dc4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有不必要的<code class="fe lz ma mb mc b">return await</code></h1><p id="f6d2" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在JavaScript中，异步函数总是返回承诺。如果我们在那里返回一些东西，我们返回一个承诺，它的解析值就是我们在承诺中返回的值。</p><p id="e687" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">return await</code>在承诺解决或拒绝之前，除了增加额外时间之外，不做任何事情。</p><p id="8cbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以直接退回承诺。</p><p id="76c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">return await</code>唯一有效的用法是在<code class="fe lz ma mb mc b">try...catch</code>语句中捕捉另一个返回承诺的函数的错误。</p><p id="d97b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，下面的代码是不好的:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="127b" class="mq lc iq mc b gy mr ms l mt mu">const foo = async () =&gt; {<br/>  return await Promise.resolve(1);<br/>}</span></pre><p id="311b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们不需要<code class="fe lz ma mb mc b">await</code>来回报承诺一样。</p><p id="6a7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以直接写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c28e" class="mq lc iq mc b gy mr ms l mt mu">const foo = async () =&gt; {<br/>  return Promise.resolve(1);<br/>}</span></pre><p id="ad18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不过下面使用<code class="fe lz ma mb mc b">return await</code>还是不错的:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="b4d7" class="mq lc iq mc b gy mr ms l mt mu">const foo = async () =&gt; {<br/>  try {<br/>    return await Promise.resolve(1);<br/>  } catch (ex) {<br/>    console.log(ex);<br/>  }<br/>}</span></pre><h1 id="1e4c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有脚本URL</h1><p id="43ba" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">拥有<code class="fe lz ma mb mc b">javascript:</code> URL是一种不好的做法，因为它让我们面临与<code class="fe lz ma mb mc b">eval</code>相同的性能和安全问题。</p><p id="7672" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们都允许我们从字符串中运行任意代码，所以攻击者也可以这样做。</p><p id="679b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，从字符串运行代码的性能较慢，因为JavaScript解释器不能优化字符串中的代码。</p><p id="5923" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该编写如下代码:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="f5c9" class="mq lc iq mc b gy mr ms l mt mu">location.href = "javascript:alert('foo')";</span></pre><p id="1d22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，只需将它放入JavaScript代码中，如下所示:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5202" class="mq lc iq mc b gy mr ms l mt mu">alert('foo');</span></pre><h1 id="27b7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有自我分配</h1><p id="9fa7" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">自我分配是没有用的。因此，它不应该出现在我们的代码中。</p><p id="7140" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能是我们在修改代码时没有发现的错误。</p><p id="71af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，以下内容是无用的:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="26b8" class="mq lc iq mc b gy mr ms l mt mu">a = a;<br/>[a, b] = [a, b];</span></pre><p id="685b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该这样写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3ebc" class="mq lc iq mc b gy mr ms l mt mu">a = b;<br/>[a, b] = [b, a];</span></pre><h1 id="d438" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有自我比较</h1><p id="bdec" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">将变量与其自身进行比较总是会返回<code class="fe lz ma mb mc b">true</code>。因此，在我们的代码中使用这些类型的表达式是没有用的。</p><p id="43f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这通常是键入或重构代码时出现的错误。这可能会在我们的代码中引入运行时错误。</p><p id="54fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一适合将一个值与其自身进行比较的时候是在比较<code class="fe lz ma mb mc b">NaN</code>的时候，因为<code class="fe lz ma mb mc b">NaN</code>与<code class="fe lz ma mb mc b">===</code>运算符比较时不等于自身。</p><p id="3999" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是最好使用<code class="fe lz ma mb mc b">isNaN</code>或<code class="fe lz ma mb mc b">Number.isNaN</code>功能来检查<code class="fe lz ma mb mc b">NaN</code>是否存在。</p><p id="7147" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在检查<code class="fe lz ma mb mc b">NaN</code>之前，<code class="fe lz ma mb mc b">isNaN</code>试图将它的参数转换成一个数字，而<code class="fe lz ma mb mc b">Number.isNaN</code>只是检查值而不做任何数据类型转换。</p><p id="6f1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该有如下代码:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ccbf" class="mq lc iq mc b gy mr ms l mt mu">const a = 1;<br/>if (a === a) {<br/>    x = 2;<br/>}</span></pre><h1 id="be2b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用逗号运算符</h1><p id="ba74" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">逗号运算符总是返回由运算符分隔的项目列表中的最后一个元素，从左到右计算它们。</p><p id="6b9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在我们的代码中使用它不是一个非常有用的操作符。</p><p id="247f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可能应该从代码中删除对它的任何使用。大概是这样的:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="52b3" class="mq lc iq mc b gy mr ms l mt mu">const a = (1, 2, 3);</span></pre><p id="a904" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将始终将<code class="fe lz ma mb mc b">a</code>设置为3。</p><p id="5f8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在正常程序中，这个操作符没有任何有效的用例。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/5f4ba94d517330d666daab0f4a20671a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o6xzwQGoGfP4kdAU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@daijiumemoto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daiji Umemoto</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="b53f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在抛出表达式中只抛出错误对象</h1><p id="f04b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在JavaScript中，当我们试图抛出错误时，我们可以在<code class="fe lz ma mb mc b">throw</code>后放置任何值。</p><p id="4c69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，抛出除了<code class="fe lz ma mb mc b">Error</code>对象或从它派生的子构造函数之外的任何东西都不是好的做法。</p><p id="2bc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Error</code>对象自动跟踪<code class="fe lz ma mb mc b">Error</code>对象的构建和起源。</p><p id="1a69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该有这样的<code class="fe lz ma mb mc b">throw</code>表达式:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8f88" class="mq lc iq mc b gy mr ms l mt mu">throw "fail";</span></pre><p id="b949" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="6290" class="mq lc iq mc b gy mr ms l mt mu">throw new Error("fail");</span></pre><h1 id="6b1f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="12f6" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">return await</code>除了<code class="fe lz ma mb mc b">try...catch</code>块，大部分都没用。将变量或值与其自身进行比较是没有用的，就像将变量赋值给自身一样。</p><p id="b5aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，逗号操作符也是无用的，因为它总是返回列表中的最后一个值。</p><p id="11a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">抛出异常的错误应该总是抛出一个<code class="fe lz ma mb mc b">Error</code>对象或者它的子构造函数的一个实例。</p><p id="c94d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中编写URL也是一种不好的做法，因为我们在一个字符串中运行代码，这阻止了任何优化的完成，并且可能让攻击者任意运行我们的代码。</p><h2 id="80d8" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="a272" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们已经推出了三种新的出版物！为我们的新出版物献上一点爱心吧，请跟随他们:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="8c22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>