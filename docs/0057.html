<html>
<head>
<title>How to write event handlers in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中编写事件处理程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/declaring-event-handlers-d63b17e170d9?source=collection_archive---------2-----------------------#2018-12-06">https://javascript.plainenglish.io/declaring-event-handlers-d63b17e170d9?source=collection_archive---------2-----------------------#2018-12-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ba8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在Adam Boduch的这篇文章中学习如何声明事件处理程序，他是一位经验丰富的web应用程序开发人员，拥有从jQuery到React的丰富经验。</p><p id="e4ef" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React有一种独特的处理事件的方法:在JSX中声明事件处理程序。React组件中事件处理的区别在于它是声明性的。与jQuery相比，在jQuery中，您必须编写命令式代码来选择相关的DOM元素并将事件处理函数附加到这些元素上。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/9ba269864675df3c4263363f1774598c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ivjksIhvAs7TUXbQCxAU0A.jpeg"/></div></div></figure><p id="252b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JSX标记中事件处理程序的声明性方法的优点是它们是UI结构的一部分。不必追踪分配事件处理程序的代码是一种精神解放。在本文中，您将编写一个基本的事件处理程序，这样您就可以感受一下React应用程序中的声明性事件处理语法。然后，您将学习如何使用通用事件处理函数。</p><h2 id="e96b" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">声明处理函数</h2><p id="0999" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">下面是一个为元素的click事件声明事件处理程序的基本组件:</p><pre class="kk kl km kn gt lt lu lv lw aw lx bi"><span id="d834" class="kv kw in lu b gy ly lz l ma mb">import React, { Component } from 'react';</span><span id="04f2" class="kv kw in lu b gy mc lz l ma mb"><br/>export default class MyButton extends Component {</span><span id="2237" class="kv kw in lu b gy mc lz l ma mb">// The click event handler, there's nothing much happening here other than a log of the event.<br/></span><span id="b723" class="kv kw in lu b gy mc lz l ma mb">onClick() {</span><span id="d1be" class="kv kw in lu b gy mc lz l ma mb">    console.log('clicked');</span><span id="7373" class="kv kw in lu b gy mc lz l ma mb">}<br/></span><span id="190a" class="kv kw in lu b gy mc lz l ma mb">// Renders a "<!-- -->&lt;button&gt;<!-- -->" element with the "onClick" event handler set to the "onClick()" method of this component.</span><span id="ffd3" class="kv kw in lu b gy mc lz l ma mb">  render() {</span><span id="c46c" class="kv kw in lu b gy mc lz l ma mb">    return (</span><span id="d0db" class="kv kw in lu b gy mc lz l ma mb">      &lt;button onClick={this.onClick}&gt;<!-- -->{this.props.children}<!-- -->/&gt;</span><span id="8ea8" class="kv kw in lu b gy mc lz l ma mb">    );</span><span id="e8b6" class="kv kw in lu b gy mc lz l ma mb">  }</span><span id="29ba" class="kv kw in lu b gy mc lz l ma mb">}</span></pre><p id="92d7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事件处理函数<code class="fe md me mf lu b">this.onClick()</code>被传递给<code class="fe md me mf lu b">&lt;button&gt;</code>元素的<code class="fe md me mf lu b">onClick</code>属性。通过查看这些标记，可以清楚地看到当按钮被单击时会运行什么代码。</p><h2 id="8234" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">多个事件处理程序</h2><p id="6519" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">当一个元素有多个处理程序时，声明性事件处理程序的语法很容易理解。例如，有时一个元素有两三个处理程序。命令式代码很难处理单个事件处理程序，更不用说几个事件处理程序了。当一个元素需要更多的处理程序时，它只是另一个JSX属性。从代码可维护性的角度来看，这一点很好:</p><pre class="kk kl km kn gt lt lu lv lw aw lx bi"><span id="7b4a" class="kv kw in lu b gy ly lz l ma mb">import React, { Component } from 'react';<br/></span><span id="5eda" class="kv kw in lu b gy mc lz l ma mb">export default class MyInput extends Component {</span><span id="faa0" class="kv kw in lu b gy mc lz l ma mb">// Triggered when the value of the text input changes...</span><span id="d275" class="kv kw in lu b gy mc lz l ma mb">onChange() {</span><span id="0eee" class="kv kw in lu b gy mc lz l ma mb">  console.log('changed');</span><span id="72b5" class="kv kw in lu b gy mc lz l ma mb">}</span><span id="b948" class="kv kw in lu b gy mc lz l ma mb">// Triggered when the text input loses focus...</span><span id="a307" class="kv kw in lu b gy mc lz l ma mb">onBlur() {</span><span id="88a4" class="kv kw in lu b gy mc lz l ma mb">  console.log('blurred');</span><span id="44ff" class="kv kw in lu b gy mc lz l ma mb">}</span><span id="7850" class="kv kw in lu b gy mc lz l ma mb">// JSX elements can have as many event handler properties as necessary.</span><span id="77ce" class="kv kw in lu b gy mc lz l ma mb">  render() {</span><span id="ec81" class="kv kw in lu b gy mc lz l ma mb">    return <!-- -->&lt;input onChange={this.onChange} onBlur={this.onBlur} /&gt;<!-- -->;</span><span id="47c6" class="kv kw in lu b gy mc lz l ma mb">  }</span><span id="9252" class="kv kw in lu b gy mc lz l ma mb">}</span></pre><p id="21e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个<code class="fe md me mf lu b">&lt;input&gt;</code>元素可以有更多的事件处理程序，代码也同样可读。</p><p id="1af5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着您不断向组件添加更多的事件处理程序，您会注意到许多事件处理程序都在做同样的事情。接下来，您将学习如何跨组件共享通用处理程序函数。</p><h2 id="7952" class="kv kw in bd kx ky kz dn la lb lc dp ld jv le lf lg jz lh li lj kd lk ll lm ln bi translated">导入通用处理程序</h2><p id="41a4" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">任何React应用程序都可能为不同的组件共享相同的事件处理逻辑。例如，在响应按钮点击时，组件应该对项目列表进行排序。正是这些类型的通用行为属于它们自己的模块，以便几个组件可以共享它们。实现一个使用通用事件处理函数的组件:</p><pre class="kk kl km kn gt lt lu lv lw aw lx bi"><span id="2f90" class="kv kw in lu b gy ly lz l ma mb">import React, { Component } from 'react';</span><span id="49a7" class="kv kw in lu b gy mc lz l ma mb">// Import the generic event handler that manipulates the state of a component.</span><span id="2ae0" class="kv kw in lu b gy mc lz l ma mb">import reverse from './reverse';</span><span id="a3b8" class="kv kw in lu b gy mc lz l ma mb">export default class MyList extends Component {</span><span id="c309" class="kv kw in lu b gy mc lz l ma mb">  state = {</span><span id="563d" class="kv kw in lu b gy mc lz l ma mb">    items: ['Angular', 'Ember', 'React']</span><span id="f603" class="kv kw in lu b gy mc lz l ma mb">  };<br/></span><span id="b73f" class="kv kw in lu b gy mc lz l ma mb">// Makes the generic function specific to this component by calling "bind(this)".</span><span id="e633" class="kv kw in lu b gy mc lz l ma mb">onReverseClick = reverse.bind(this);</span><span id="939a" class="kv kw in lu b gy mc lz l ma mb">render() {</span><span id="c43e" class="kv kw in lu b gy mc lz l ma mb">  const { state: { items }, onReverseClick } = this;</span><span id="0922" class="kv kw in lu b gy mc lz l ma mb">  return (</span><span id="790f" class="kv kw in lu b gy mc lz l ma mb">    &lt;section&gt;</span><span id="1f9f" class="kv kw in lu b gy mc lz l ma mb">{/* Now we can attach the "onReverseClick" handler to the button, and the generic function will work with this component's state. */}</span><span id="b6f4" class="kv kw in lu b gy mc lz l ma mb">      &lt;button onClick={onReverseClick}&gt;<!-- -->Reverse<!-- -->&lt;/button&gt;</span><span id="8797" class="kv kw in lu b gy mc lz l ma mb">      &lt;ul&gt;<!-- -->{items.map((v, i) =&gt; <!-- -->&lt;li key={i}&gt;<!-- -->{v}<!-- -->&lt;/li&gt;<!-- -->)}<!-- -->&lt;/ul&gt;</span><span id="fe53" class="kv kw in lu b gy mc lz l ma mb">    &lt;/section&gt;</span><span id="a343" class="kv kw in lu b gy mc lz l ma mb">  );</span><span id="4bfa" class="kv kw in lu b gy mc lz l ma mb">}</span><span id="506c" class="kv kw in lu b gy mc lz l ma mb">}</span></pre><p id="d7fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您正在导入一个名为<code class="fe md me mf lu b">reverse()</code>的函数。这是您对<code class="fe md me mf lu b">&lt;button&gt;</code>元素使用的通用事件处理函数。当它被点击时，列表应该颠倒它的顺序。</p><p id="a192" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe md me mf lu b">onReverseClick</code>方法实际上调用了通用的<code class="fe md me mf lu b">reverse()</code>函数。它是使用<code class="fe md me mf lu b">bind()</code>将通用函数的上下文绑定到这个组件实例上而创建的。</p><p id="eabc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，查看JSX标记，可以看到<code class="fe md me mf lu b">onReverseClick()</code>函数被用作按钮点击的处理程序。</p><p id="ffdc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这到底是怎么回事？你有没有一个通用函数，因为你绑定了上下文而改变了这个组件的状态？嗯，差不多，是的，就是这样。现在让我们来看看通用函数的实现:</p><pre class="kk kl km kn gt lt lu lv lw aw lx bi"><span id="623b" class="kv kw in lu b gy ly lz l ma mb">// Exports a generic function that changes the state of a component, causing it to re-render itself.</span><span id="5807" class="kv kw in lu b gy mc lz l ma mb">export default function reverse() {</span><span id="394f" class="kv kw in lu b gy mc lz l ma mb">  this.setState(this.state.items.reverse());</span><span id="3499" class="kv kw in lu b gy mc lz l ma mb">}</span></pre><p id="f400" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个函数依赖于状态中的一个<code class="fe md me mf lu b">this.state</code>属性和一个<code class="fe md me mf lu b">items</code>数组。关键是状态是通用的；一个应用程序可能有许多状态中带有一个<code class="fe md me mf lu b">items</code>数组的组件。</p><p id="50dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是您的渲染列表的样子:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/d0c9aa8a7c20f10d874b1afab1ab9147.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*z6QUu1Yygjab_hbh10ejfg.png"/></div></figure><p id="ee7d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不出所料，点击按钮会导致列表排序，使用通用的<code class="fe md me mf lu b">reverse()</code>事件处理程序:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/97227464c14bb5ec17f67d959f65e7c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*JxjywgzmSXh1JqUfwVgtBw.png"/></div></figure><p id="1b14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">如果你觉得这篇文章很有趣，你可以探索一下</em> <a class="ae mi" href="https://www.amazon.com/React-Native-Complete-native-development-ebook/dp/B07GVMNQCB" rel="noopener ugc nofollow" target="_blank"> <em class="ki"> React和React Native——第二版</em> </a> <em class="ki">用React、JSX、Redux和GraphQL为web和原生移动平台构建应用。</em> <a class="ae mi" href="https://india.packtpub.com/in/application-development/react-and-react-native-second-edition" rel="noopener ugc nofollow" target="_blank"> <em class="ki"> React和React Native —第二版</em> </a> <em class="ki">带您了解如何使用React 16和React Native 0.5为所有平台创建强大而迷人的桌面移动和本机应用程序。</em></p></div></div>    
</body>
</html>