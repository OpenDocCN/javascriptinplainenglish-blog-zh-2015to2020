<html>
<head>
<title>Node.js: 4 of the most popular and useful libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js: 4个最流行和最有用的库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-4-of-the-most-popular-and-useful-libraries-cbf9fa758432?source=collection_archive---------1-----------------------#2020-04-23">https://javascript.plainenglish.io/node-js-4-of-the-most-popular-and-useful-libraries-cbf9fa758432?source=collection_archive---------1-----------------------#2020-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="00f3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们看看Node.js下载量最大的4个包，分别是Chalk、Chokirdar、CORS和mkdirp</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/9f4bf76dd790698251a2a6d18622cc4d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*DY7TZYQtJRzSv6bpjUYdYg.png"/></div></figure><p id="85d4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">根据下载量，我查看了NPM最受欢迎的Node.js软件包。我找到了一些我觉得非常方便的。他们在这里，玩得开心:)</p><h1 id="b070" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">1.粉笔——使终端输出的着色和样式化变得简单</h1><p id="c0f2" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">在输出出现的错误时，系统数据或者函数的输出— <strong class="kp ir"> console.log </strong>对于每一个开发者来说都有着不可或缺的价值。</p><p id="30ab" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">唯一的问题是它会很快变得混乱，因为默认情况下终端输出是单调的。</p><p id="9cc9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">粉笔改变了这一点，你保留了概览。</p><p id="b50f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">只要像往常一样用<strong class="kp ir"> npm安装粉笔</strong>安装它，你就可以开始了。</p><p id="afa6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是一个代码示例，下面是它在我的终端中的真实样子。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="049c" class="ml lk iq mh b gy mm mn l mo mp">const chalk = require(‘chalk’)</span><span id="0fb5" class="ml lk iq mh b gy mq mn l mo mp"><em class="mr">// simply blue font<br/></em>console.log(chalk.blue(‘this is is blue text’))</span><span id="27a8" class="ml lk iq mh b gy mq mn l mo mp"><em class="mr">// blue &amp; bold font, red background (bg = background)<br/></em>console.log(chalk.blue.bgRed.bold(‘Blue &amp; Bold on Red’))</span><span id="6e19" class="ml lk iq mh b gy mq mn l mo mp"><em class="mr">// blue font, red background<br/></em>console.log(chalk.blue.bgRed(‘Regular Blue on Red Background’))</span><span id="e3bc" class="ml lk iq mh b gy mq mn l mo mp"><em class="mr">// combining multiple font colors<br/></em>console.log(chalk.blue(‘Blue’) + ‘ Default’ + chalk.red(‘Red’))</span><span id="9761" class="ml lk iq mh b gy mq mn l mo mp"><em class="mr">// Underlining text<br/></em>console.log(chalk.red(‘There is an ‘, chalk.underline(‘Error’)))</span><span id="1dfa" class="ml lk iq mh b gy mq mn l mo mp"><em class="mr">// Using RGB-colors<br/></em>console.log(chalk.rgb(127, 255, 0).bold(‘Custom green’))</span></pre><p id="0f25" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">它认为这段代码没什么好解释的。如果有，就留言评论:)</p><p id="0a9e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">上面代码的输出:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi ms"><img src="../Images/9d639a7f6aecf4738e08d041b87e00fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s5-9quHBTbD3ICci8ZFZVg.png"/></div></div></figure><h1 id="9e89" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">2.乔基达尔</h1><p id="a7cd" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">每个使用过<strong class="kp ir">文件系统</strong> (fs)的人可能都知道<strong class="kp ir"> fs.watchFile / fs.watch </strong>函数。<br/>顾名思义，它用于检测文件系统中的变化，例如文件的创建、删除或修改。在一些Node.js应用程序中，这是必要的，例如处理用户文件的CMS。但是有一个问题:内置模块<strong class="kp ir"> fs </strong>中的<strong class="kp ir"> fs.watch / fs.watchFile </strong>函数并不能很好地工作。<br/> Z. E.g. fs.watch简单的把大部分事件叫做“<strong class="kp ir">rename</strong>”&amp;也不是100%确定能检测到某些编辑的所有改动。<br/>(两个标准功能的其他弱点可以直接在Chokidar的NPM页面上找到)</p><p id="89c1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一个补救方法是Chokidar，这是NPM的官方网站</p><p id="992d" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">Chokidar的工作是以<strong class="kp ir"> fs.watch </strong>和<strong class="kp ir"> fs.watchFile </strong>为基础，但它自己还是会做一些研究。因此，Chokidar甚至用于Visual Studio代码和Node.js的PM2中。这足以让我们看一看。</p><p id="ff02" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们开始监视当前文件夹中的所有结果。：</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="e16a" class="ml lk iq mh b gy mm mn l mo mp"><br/>const chokidar = require(‘chokidar’)</span><span id="8f43" class="ml lk iq mh b gy mq mn l mo mp">chokidar.watch(‘.’).on(‘all’, (event, path) =&gt; {<br/>  console.log(event, path)<br/>})</span></pre><p id="c2ca" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">事件</strong>输出是哪种变化，<strong class="kp ir">路径</strong>，发生的位置。</p><p id="83ab" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因为chokidar也很擅长目录，这里有几个例子:</p><ul class=""><li id="37d0" class="my mz iq kp b kq kr kt ku kw na la nb le nc li nd ne nf ng bi translated">我们创建一个新目录“newFolder”。我们的代码将打印如下内容:</li></ul><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="a43c" class="ml lk iq mh b gy mm mn l mo mp">addDir newFolder</span></pre><ul class=""><li id="8e2b" class="my mz iq kp b kq kr kt ku kw na la nb le nc li nd ne nf ng bi translated">在这个新的目录中，我们创建了一个文件“FileInFolder.txt”:</li></ul><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="e7af" class="ml lk iq mh b gy mm mn l mo mp">add newFolder/FileInFolder.txt</span></pre><ul class=""><li id="42c5" class="my mz iq kp b kq kr kt ku kw na la nb le nc li nd ne nf ng bi translated">在新目录中，我们创建另一个新目录“folderInFolder”:</li></ul><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="0815" class="ml lk iq mh b gy mm mn l mo mp">addDir newFolder/folderInFolder</span></pre><ul class=""><li id="c5a8" class="my mz iq kp b kq kr kt ku kw na la nb le nc li nd ne nf ng bi translated">让我们更改单个文件中的一些内容，并保存更改:</li></ul><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="80e6" class="ml lk iq mh b gy mm mn l mo mp">change newFolder/FileInFolder.txt</span></pre><ul class=""><li id="513a" class="my mz iq kp b kq kr kt ku kw na la nb le nc li nd ne nf ng bi translated">因为我们现在在包装目录“newFolder”中有一个不同的目录和一个文件，所以让我们删除它:</li></ul><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="3891" class="ml lk iq mh b gy mm mn l mo mp">unlink newFolder/FileInFolder.txt<br/>unlinkDir newFolder/folderInFolder<br/>unlinkDir newFolder</span></pre><p id="9049" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">正如您所看到的，chokidar完美地注册了我们在文件系统上完成的所有操作——正如我们所期望的那样。</p><h1 id="809c" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">3.CORS —支持跨原产地申请</h1><p id="0dab" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">那么什么是CORS呢？CORS主张跨产地资源共享。<br/>这意味着我们允许我们的客户，通常是用户使用我们网站的网络浏览器，提出<strong class="kp ir">跨来源请求。</strong> <br/>但这样的要求是什么？<br/>跨源请求是从服务器A上的网站到可能位于另一个域中的第二个服务器B的直接内部访问。</p><p id="034b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">让我们用一个例子来实践这一点:我们让我们的Express服务器运行在端口<strong class="kp ir"> 8080 </strong>上，它提供一个向我们的API发送请求的网页，API是一个运行在端口3000上的Express服务器。</p><p id="a240" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这是我们的主服务器，为网站服务:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8bb1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">这是我们的API服务器，对每个API调用都返回一个响应:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="92a3" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因此，如果我们在localhost:8080打开我们的网站，它在后台向我们在localhost:3000的API发送请求，我们会在控制台中得到一条错误消息。无法执行该请求，因为它是一个COR，默认情况下被阻止:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mt mu di mv bf mw"><div class="gh gi nj"><img src="../Images/907b158b2f2637d57159f5dec7d7a1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YLXzI0_OdAPBeHAyyfK7EQ.png"/></div></div></figure><p id="7b96" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是有一个简单的CORS中间件解决方案，我们可以在NPM找到。</p><p id="3bfa" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我们的API服务器中，我们只需集成中间件并对其进行设置，一切都应该按预期运行:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="5c29" class="ml lk iq mh b gy mm mn l mo mp">const cors = require(‘cors’)</span><span id="732b" class="ml lk iq mh b gy mq mn l mo mp">let user = { name: ‘Max’, age: 21 }</span><span id="6f07" class="ml lk iq mh b gy mq mn l mo mp">app.use(cors())  // just use it as middleware </span><span id="0594" class="ml lk iq mh b gy mq mn l mo mp">app.get(‘/’, (req, res) =&gt; {<br/>  res.json(user)<br/>})</span></pre><p id="1683" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果您现在再次运行API服务器并重新加载页面，这次请求应该会通过。</p><h1 id="744e" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">4.mkdirp——与mkdir -p一样，但用于Node.js</h1><p id="0c98" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">稍微偏离一下终端命令。如果我们想创建一个新的文件夹，我们可以简单地通过<strong class="kp ir">mkdir</strong><strong class="kp ir">&lt;directory-name&gt;</strong>来完成。</p><p id="0135" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">但是，如果我们想一次创建两个或更多的文件夹，它们也是一个在另一个下面，该怎么办呢？<br/>不幸的是，这与<strong class="kp ir">mkdir enclosing_directory/inner _ directoy</strong>不兼容，所以我们会有目录“enclosing _ directory”，并且在这个目录中有“inner_directory”。我们需要首先创建顶级目录，然后我们可以在其中创建另一个目录。</p><p id="5ce7" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">当然，这对于多重嵌套来说尤其令人讨厌。但是当然有补救的办法。使用mkdir -p，我们可以同时创建任意多的目录，按照我们想要的结构。所有尚不存在的目录都是自动创建的。</p><p id="80a8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在Node.js中，现在有两种主要的方法来使用这个命令以这种方式创建目录<br/>或者我们直接通过Node.js执行一个终端命令，正如你在这里可以找到的:</p><div class="nk nl gp gr nm nn"><a href="https://medium.com/javascript-in-plain-english/3-pretty-cool-built-in-node-js-modules-c2c3283276e6" rel="noopener follow" target="_blank"><div class="no ab fo"><div class="np ab nq cl cj nr"><h2 class="bd ir gy z fp ns fr fs nt fu fw ip bi translated">3个非常酷的内置Node.js模块</h2><div class="nu l"><h3 class="bd b gy z fp ns fr fs nt fu fw dk translated">让我们使用Node.js读取用户输入，执行终端命令并运行一个JS虚拟机！</h3></div><div class="nv l"><p class="bd b dl z fp ns fr fs nt fu fw dk translated">medium.com</p></div></div><div class="nw l"><div class="nx l ny nz oa nw ob kl nn"/></div></div></a></div><p id="d949" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">或者我们可以使用专门为此目的而创建的库。在我们的例子中，可能是更优雅的解决方案:NPM上的mkdirp</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="7b6d" class="ml lk iq mh b gy mm mn l mo mp">const mkdirp = require(‘mkdirp’)</span><span id="c01a" class="ml lk iq mh b gy mq mn l mo mp">mkdirp(‘./assets/pictures’).then((made) =&gt; {<br/>  <em class="mr">if</em> (made == undefined) {<br/>    console.log(‘already exists’)<br/>  } <em class="mr">else</em> {<br/>    console.log(`made directories, starting with ${made}`)<br/>  }<br/>})</span></pre><p id="f4df" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">整个事情相对简单:在这个例子中，我们在与节点应用程序相同的目录中创建了两个新文件夹。<br/>在“资产”目录里面的“图片”目录。<br/>如果<strong class="kp ir">造</strong>是<strong class="kp ir">未定义</strong>，则它们已经存在。</p><h2 id="c1e6" class="ml lk iq bd ll oc od dn lp oe of dp lt kw og oh lv la oi oj lx le ok ol lz om bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="f5ba" class="pw-post-body-paragraph kn ko iq kp b kq mb jr ks kt mc ju kv kw md ky kz la me lc ld le mf lg lh li ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物，表达对它们的爱:<a class="ae mx" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kp ir"/></a><a class="ae mx" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kp ir">UX</strong></a><a class="ae mx" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kp ir">Python</strong></a><strong class="kp ir"/>——谢谢，继续学习！</p><p id="56e6" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae mx" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kp ir">submissions @ plain English . io</strong></a><strong class="kp ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>