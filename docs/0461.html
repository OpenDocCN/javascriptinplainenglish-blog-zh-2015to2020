<html>
<head>
<title>Your basic guide to finally understand TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最终理解TypeScript的基本指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/your-basic-guide-to-finally-understand-typescript-f81ab85d2a33?source=collection_archive---------6-----------------------#2019-10-18">https://javascript.plainenglish.io/your-basic-guide-to-finally-understand-typescript-f81ab85d2a33?source=collection_archive---------6-----------------------#2019-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/66ab3f93a407fc9ddc73fb0223969558.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uKtQylWvq_e5jDEN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@shotbycerqueira?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Shot by Cerqueira</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="aba8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着TypeScript的力量在过去几年中不断增强，成千上万的开发人员决定开始使用这个<a class="ae kc" href="https://thecoderswag.com/you-absolutely-have-to-learn-typescript-in-2019/" rel="noopener ugc nofollow" target="_blank"> Javascript超集</a>来增强他们代码的能力。本指南旨在成为所有想学习如何使用TypeScript并在他们的下一个项目中使用它的开发人员的快速入门。</p><h1 id="01fa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#1单词Types的意思是:使用它们！</h1><p id="1b96" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript最大的特性之一是<strong class="kf ir">编译时类型检查</strong>，以防止变量类型中的任何<strong class="kf ir">不匹配</strong>，是的，你实际上可以在TypeScript中使用类型，下面是一些关于你如何使用它们的例子:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/64ea549c6189cdbfd0e086296cdcf0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GswevYjR2hVeD0eu.png"/></div></div></figure><h1 id="2672" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#1.1我可以对我的变量使用多种类型吗？</h1><p id="f9d5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当然你可以，通过简单地使用<strong class="kf ir"> any </strong>类型作为你的一个变量，你将能够<strong class="kf ir">分配不同的值类型</strong>，比如:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/b77caf0fd0b5f2b4ea8be11d04460c18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*LTy6apUJJAWVRadM.png"/></div></div></figure><p id="97b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想要<strong class="kf ir">限制你可以分配</strong>给你的变量的类型，你最终可以像这样使用管道操作符:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/7ad38930fa4a218eb7b51760def40e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iwJ0xzW0keNghVjm.png"/></div></div></figure><h1 id="4546" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#1.2如果不想指定变量的类型怎么办？</h1><p id="8fd8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">没问题！TypeScript支持隐式和显式类型化。在第一种情况下，您将精确地指定变量的类型，就像我们到目前为止所看到的那样，在第二种情况下，<strong class="kf ir">每当您第一次初始化变量</strong> a值时，类型将自动分配给变量，这种机制更好地被称为<strong class="kf ir">类型推断</strong>。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/922adbbb6938685f0ed81924e6cf1a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*A1XtzAKVD1TVwuCl.png"/></div></div></figure><p id="5173" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意类型推断在其他有用的情况下是如何变得方便的，比如函数返回值:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/395afcbbb68b3929b8b665adbf5eea01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1b9-7D-xmuxSihiZ.png"/></div></div></figure><h1 id="a31f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#1.3我可以检查变量的类型吗？</h1><p id="86ae" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">想确定你用的是正确的类型吗？合适的班级？您可以像这样使用操作符的<strong class="kf ir">实例来使用它:</strong></p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/a75886ff5244098f7087afc95296046c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/0*hh-ls2oCRqoGPbBW"/></div></figure><p id="fda0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于<strong class="kf ir">用户定义的类型</strong>特别有用，当你从另一个对象继承属性时也同样有效。</p><h1 id="1b57" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#1.4我可以转换变量的类型吗？</h1><p id="55d5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这种类型的操作通常被称为<strong class="kf ir">强制转换</strong>，它可以在特殊情况下在TypeScript中执行，我们可能需要使用特定类型处理变量。让我们假设你定义了一个类型为<strong class="kf ir"> any </strong>的变量，但是你现在想在这个变量<strong class="kf ir">上使用一些普通的<strong class="kf ir"> string </strong>函数，你现在不能访问这个函数</strong>因为这个类型不是string，你可以告诉TypeScript这样处理这个变量:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/278c9a6fc9be68c4289f19f304d39462.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wqiOtTJhkLSNm2LO.png"/></div></div></figure><h1 id="f1da" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#2使用阵列</h1><p id="befb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当涉及到在TypeScript中使用数组时，上面提到的所有内容都非常适用:</p><h1 id="350b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#2.1使用元组</h1><p id="82d3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">元组类型是一个全新的概念，它允许您表达一个数组，其中固定数量的元素的类型是已知的，但不需要相同。考虑一下，如果您想将一个值表示为一对布尔值和一个数字:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/d10ea1e741dd81d4699294d0dcaac622.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ReRrvf2hJUpl4Gzi.png"/></div></div></figure><h1 id="787b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#2.2我真正错过的东西:Enums！</h1><p id="b459" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这个对Javascript的伟大补充是我过去用Java编码时真正缺少的东西，枚举基本上是一组命名的常量。枚举有三种类型:</p><ul class=""><li id="6a7b" class="mk ml iq kf b kg kh kk kl ko mm ks mn kw mo la mp mq mr ms bi translated">数字枚举</li><li id="f99e" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">字符串枚举</li><li id="e8f0" class="mk ml iq kf b kg mt kk mu ko mv ks mw kw mx la mp mq mr ms bi translated">异构枚举</li></ul><p id="15d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了不使这篇文章太长，我不会对枚举进行太多的描述，只要记住，如果您想更好地记录您的意图或者创建一组不同的情况，比如:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/446a49db9322970d6b04fbae08aa6771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wQt7JRBm3TR4-OM7.png"/></div></div></figure><h1 id="6775" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#3物件呢？</h1><p id="1be7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对象是Typescript的另一个重要部分，让我们通过一个例子来更详细地分析它们:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/5629c4e27000d44cc7f4f8233ee514b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WLJgM0RUDjH3nebY.png"/></div></div></figure><p id="8ba0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们拥有的对象的两个属性被推断为string类型，这意味着任何向它们分配不同类型的值的尝试都是无效的:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi my"><img src="../Images/ca4605efcd4a721a912d99d3217b2ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-shO3bUsE5u8l5VB.png"/></div></div></figure><h1 id="a32e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#3.1对象类型</h1><p id="1c78" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对象是不属于原始类型类别的类型，如:布尔型、字符串型、数字型、符号型、空型、未定义型，它遵循以下语法:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/53d2fbff0bc05d5198ac2b0dd2fa2851.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tFFaENvinMJR4Iro.png"/></div></div></figure><h1 id="c1ff" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#4功能</h1><p id="fb31" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当谈到函数时，Typescript引入了在处理函数时使用类型的可能性，例如，我们首先希望将它们用于函数参数:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/fbe1d7e9fe192af35994fa27d369fa88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*C3YNBe9mfQYGXSjB.png"/></div></div></figure><p id="2456" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个可能需要指定类型的地方是从函数返回值的时候。注意，在上面的函数中，返回类型被自动推断为string类型。让我们看看如何使用以下方法显式定义函数的返回类型:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/230efab9832148158df94ee23c2f1ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GC27ncyUYnEKwBvb.png"/></div></div></figure><h1 id="a86d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">#5面向对象部分</h1><p id="dd8a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">自从ECMAScript 6发布以来，Javascript程序员已经能够使用面向对象的方法构建他们的程序。Typescript也支持这种方法，所以让我们通过一些例子来分析我们将如何使用它:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/7d4fcb36def5129dbbedc7ef40aa4e55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*mLcbFQRCUr3PA2RK.png"/></div></div></figure><p id="4bf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于大多数使用过C#或Java等语言的人来说，这看起来非常熟悉，我们有一个名为Point的类，它有两个成员x和y，我们可以自由地访问它们(稍后会详细介绍)，我们还调用了一个名为getPoints()的类方法。然后，我们可以使用new关键字创建Point类型对象的实例。</p><h1 id="97a4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用访问修饰符</h1><p id="d253" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">因为这是一个完全不同的主题，所以不要对此进行太多的详细描述，但是请记住，在Typescript中，您还可以像这样为您的类变量定义访问修饰符:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/ac9280b8d098c532234e4b43f2003b94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8uIU2A1n143x2x1n.png"/></div></div></figure><p id="5af9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如同基本上所有面向对象的编程语言一样，我们可以使用访问修饰符来确定谁能够访问我们的类数据。默认情况下，public被设置为成员默认修饰符，当您希望成员在其类(private)之外不可访问时，以及当您希望成员仅在其类或派生类之内可访问时，分别使用private和protected。</p><h1 id="a7a8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">遗产</h1><p id="7e3f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如前所述，Typescript支持最常用的面向对象模式，包括继承。因此，使用Typescript，您将能够定义一个类，然后定义它的子类，该子类将继承超类的基本方法和成员:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi me"><img src="../Images/e92e3d3da5b8f5c95d65058ddead8723.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*04xhcXTbJ5rMiKg8.png"/></div></div></figure><h1 id="4b27" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">接口</h1><p id="524a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">另一种常见的面向对象技术，你可以用它来创建一个接口。这在Typescript中是可能的，在那里主要的焦点是类型检查，我们可以使用接口给这些类型命名。所以基本上在使用它们的时候，我们会创建一组相关的方法和成员来描述一个特定的对象:</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/4eb8ff22296a0510fa9604486b0da366.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*OEefWIvZqGqnbVeU.png"/></div></div></figure><h1 id="01cf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="654f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这篇文章背后的想法只是为了能够给你一个快速入门，告诉你可以用Typescript做什么，它如何帮助我们解决常见的问题，以及它与Javascript的不同方法。希望它能让你对一些有用的东西有新的认识！</p></div></div>    
</body>
</html>