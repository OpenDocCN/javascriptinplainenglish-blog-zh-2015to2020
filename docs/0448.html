<html>
<head>
<title>Build a movie search app using the Vue Composition API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Vue合成API构建电影搜索应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-movie-search-app-using-the-vue-composition-api-f2e104ca9c79?source=collection_archive---------2-----------------------#2019-10-17">https://javascript.plainenglish.io/build-a-movie-search-app-using-the-vue-composition-api-f2e104ca9c79?source=collection_archive---------2-----------------------#2019-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d71a8e0457e7e2c41f60789b457c5ad6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sIJ_Fuss5wZoMDJH_WStWg.jpeg"/></div></div></figure><p id="0b31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Vue 3 的第一个<a class="ae kw" href="https://github.com/vuejs/vue-next" rel="noopener ugc nofollow" target="_blank"> alpha版本发布了！版本3有很多令人兴奋的特性:Vue在新的组合API后面公开了它的反应系统。如果你没有听说过它，我推荐阅读描述它的</a><a class="ae kw" href="https://vue-composition-api-rfc.netlify.com/" rel="noopener ugc nofollow" target="_blank">RFC</a>。起初，我有点怀疑，但看着React的Hooks API，这有点类似，我决定尝试一下。</p><p id="a10e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将使用Composition API构建一个电影搜索应用程序。我们不会使用基于对象的组件。我将解释新的API如何工作，以及我们如何构建应用程序。</p><p id="5bc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们完成时，我们会看到类似这样的内容:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kx"><img src="../Images/b3a7d2384bdc0b93638e136cf3cd122b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-O5bt5EoQLrndJZl.png"/></div></div></figure><p id="2aab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该应用程序将能够通过<a class="ae kw" href="http://www.omdbapi.com/apikey.aspx" rel="noopener ugc nofollow" target="_blank">开放电影数据库API </a>搜索电影，并呈现结果。构建这个应用程序的原因是，它足够简单，不会分散学习新API的注意力，但又足够复杂，足以展示它的工作原理。</p><p id="0dcd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你对解释不感兴趣，你可以直接进入<a class="ae kw" href="https://github.com/blacksonic/movie-search-vue" rel="noopener ugc nofollow" target="_blank">源代码</a>和<a class="ae kw" href="https://codesandbox.io/s/github/blacksonic/movie-search-vue" rel="noopener ugc nofollow" target="_blank">最终应用</a>。</p><h1 id="ea8e" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">设置项目</h1><p id="ed33" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">对于本教程，我们将使用Vue CLI，它可以快速生成必要的环境。</p><pre class="ky kz la lb gt mf mg mh mi aw mj bi"><span id="e84d" class="mk ld iq mg b gy ml mm l mn mo">npm install -g @vue/cli <br/>vue create movie-search-vue <br/>cd movie-search-vue <br/>npm run serve</span></pre><p id="7c5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的应用程序现在运行在<a class="ae kw" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>上，如下所示:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/c787cdb3100b49e443b0d326df41dbf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/0*sq_Sjohf56bJAVJq.png"/></div></figure><p id="bed2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，您可以看到默认的文件夹结构:</p><figure class="ky kz la lb gt jr gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/ba4a556fad6172fde54bdd66f93955e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:852/format:webp/0*JAYmkKIyafv0tJXV.png"/></div></figure><p id="21b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不想在本地计算机上安装所有的依赖项，你也可以在<a class="ae kw" href="https://codesandbox.io/" rel="noopener ugc nofollow" target="_blank"> Codesandbox </a>上启动项目。Codesandbox为最重要的框架提供了完美的入门项目，<a class="ae kw" href="https://codesandbox.io/s/vue" rel="noopener ugc nofollow" target="_blank">包括Vue </a>。</p><h1 id="b8aa" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">启用新的API</h1><p id="df6b" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">生成的源代码使用Vue 2和旧API。要在Vue 2中使用新的API，我们必须安装<a class="ae kw" href="https://github.com/vuejs/composition-api" rel="noopener ugc nofollow" target="_blank">合成插件</a>。</p><pre class="ky kz la lb gt mf mg mh mi aw mj bi"><span id="02af" class="mk ld iq mg b gy ml mm l mn mo">npm install @vue/composition-api</span></pre><p id="f405" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装后，我们必须将其添加为插件:</p><pre class="ky kz la lb gt mf mg mh mi aw mj bi"><span id="a320" class="mk ld iq mg b gy ml mm l mn mo">import Vue from 'vue';<br/>import VueCompositionApi from '@vue/composition-api';<br/><br/>Vue.use(VueCompositionApi);</span></pre><p id="fe4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">组合插件是附加的:你仍然可以用老方法创建和使用组件，并开始使用新的组合API。</p><p id="3015" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将有四个组成部分:</p><ul class=""><li id="4aaa" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated">App.vue:父组件。它将处理API调用并与其他组件通信。</li><li id="57a2" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">Header.vue:接收和显示页面标题的基本组件</li><li id="5436" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">它渲染每部电影。电影对象作为属性传递。</li><li id="7294" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">它包含一个带有输入元素和搜索按钮的表单。当您提交表单时，它向应用程序组件提供搜索词。</li></ul><h1 id="0e73" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">创建组件</h1><p id="bb9d" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">让我们编写我们的第一个组件，头:</p><pre class="ky kz la lb gt mf mg mh mi aw mj bi"><span id="3bd9" class="mk ld iq mg b gy ml mm l mn mo">&lt;template&gt;<br/>  &lt;header class="App-header"&gt;<br/>    &lt;h2&gt;{{ title }}&lt;/h2&gt;<br/>  &lt;/header&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>  export default {<br/>    name: 'Header',<br/>    props: ['title'],<br/>    setup() {}<br/>  }<br/>&lt;/script&gt;</span></pre><p id="cde1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">组件<code class="fe nf ng nh mg b">props</code>以同样的方式声明。您将期望从父组件获得的变量命名为数组或对象。这些变量将在模板(<code class="fe nf ng nh mg b">{{ title }}</code>)和<code class="fe nf ng nh mg b">setup</code>方法中可用。</p><p id="51c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的新东西是<code class="fe nf ng nh mg b">setup</code>方法。它在最初的<code class="fe nf ng nh mg b">props</code>决议之后运行。<code class="fe nf ng nh mg b">setup</code>方法可以返回一个对象，该对象的属性将被合并到模板上下文中:这意味着它们将在模板中可用。这个返回的对象也是放置生命周期回调的地方。我们将在搜索组件中看到这样的例子。</p><p id="30a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看看搜索组件:</p><pre class="ky kz la lb gt mf mg mh mi aw mj bi"><span id="740b" class="mk ld iq mg b gy ml mm l mn mo">&lt;template&gt;<br/>  &lt;form class="search"&gt;<br/>    &lt;input<br/>       type="text"<br/>       :value="movieTitle"<br/>       @keyup="handleChange"<br/>    /&gt;<br/>    &lt;input @click="handleSubmit" type="submit" value="SEARCH" /&gt;<br/>  &lt;/form&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>  import { ref } from '@vue/composition-api';<br/><br/>  export default {<br/>    name: 'Search',<br/>    props: ['search'],<br/>    setup({ search }, { emit }) {<br/>      const movieTitle = ref(search);<br/><br/>      return {<br/>        movieTitle,<br/>        handleSubmit(event) {<br/>          event.preventDefault();<br/>          emit('search', movieTitle.value);<br/>        },<br/>        handleChange(event) {<br/>          movieTitle.value = event.target.value<br/>        }<br/>      }<br/>    }<br/>  };<br/>&lt;/script&gt;</span></pre><p id="5bc8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">搜索组件跟踪击键并将输入值存储在变量中。当我们完成并按下submit按钮时，它发出当前的搜索词直到父组件。</p><p id="5512" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nf ng nh mg b">setup</code>方法有两个参数。</p><p id="7f26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个参数是作为命名对象解析的<code class="fe nf ng nh mg b">props</code>。您可以使用对象析构来访问其属性。该参数是反应性的，这意味着当输入属性改变时，<code class="fe nf ng nh mg b">setup</code>功能将再次运行。</p><p id="4385" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个参数是上下文对象。在这里，您可以找到2.x API中的<code class="fe nf ng nh mg b">this</code>上可用的属性的选择性列表(<code class="fe nf ng nh mg b">attrs</code>、<code class="fe nf ng nh mg b">slots</code>、<code class="fe nf ng nh mg b">parent</code>、<code class="fe nf ng nh mg b">root</code>、<code class="fe nf ng nh mg b">emit</code>)。</p><p id="3315" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的下一个新元素是<code class="fe nf ng nh mg b">ref</code>函数。<code class="fe nf ng nh mg b">ref</code>功能暴露Vue的反应系统。当被调用时，它创建一个具有单一属性<code class="fe nf ng nh mg b">value</code>的反应性可变变量。属性将把参数的值传递给函数。它是围绕原始值的反应式包装器。在模板内部，我们不需要引用<code class="fe nf ng nh mg b">value</code>属性，Vue会为我们解开它。如果我们传入一个对象，它将是深度反应的。</p><p id="52f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Reactive意味着当我们修改对象的值(在我们的例子中是<code class="fe nf ng nh mg b">value</code>属性)时，Vue将知道值已经改变，它需要重新呈现连接的模板并重新运行被监视的函数。</p><p id="478c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它的行为类似于从<code class="fe nf ng nh mg b">data</code>方法返回的对象属性。</p><pre class="ky kz la lb gt mf mg mh mi aw mj bi"><span id="f589" class="mk ld iq mg b gy ml mm l mn mo">data: function() {<br/>  return { movieTitle: 'Joker' };<br/>}</span></pre><h1 id="e8fd" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">粘合在一起</h1><p id="a018" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">下一步是引入标题和搜索组件的父组件，即App组件。它监听来自搜索组件的搜索事件，在搜索词发生变化时运行API，并将找到的电影传递给电影组件列表。</p><pre class="ky kz la lb gt mf mg mh mi aw mj bi"><span id="365d" class="mk ld iq mg b gy ml mm l mn mo">&lt;template&gt;<br/>  &lt;div class="App"&gt;<br/>    &lt;Header :title="'Composition API'" /&gt;<br/>    &lt;Search :search="state.search" @search="handleSearch" /&gt;<br/>    &lt;p class="App-intro"&gt;Sharing a few of our favourite movies&lt;/p&gt;<br/>    &lt;div class="movies"&gt;<br/>      &lt;Movie v-for="movie in state.movies" :movie="movie" :key="movie.imdbID" /&gt;<br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>  import { reactive, watch } from '@vue/composition-api';<br/>  import Header from './Header.vue';<br/>  import Search from './Search.vue';<br/>  import Movie from './Movie.vue';<br/><br/>  const API_KEY = 'a5549d08';<br/><br/>  export default {<br/>    name: 'app',<br/>    components: {<br/>      Header, Search, Movie<br/>    },<br/>    setup() {<br/>      const state = reactive({<br/>        search: 'Joker',<br/>        loading: true,<br/>        movies: [],<br/>        errorMessage: null<br/>      });<br/><br/>      watch(() =&gt; {<br/>        const MOVIE_API_URL = `https://www.omdbapi.com/?s=${state.search}&amp;apikey=${API_KEY}`;<br/><br/>        fetch(MOVIE_API_URL)<br/>          .then(response =&gt; response.json())<br/>          .then(jsonResponse =&gt; {<br/>            state.movies = jsonResponse.Search;<br/>            state.loading = false;<br/>          });<br/>      });<br/><br/>      return {<br/>        state,<br/>        handleSearch(searchTerm) {<br/>          state.loading = true;<br/>          state.search = searchTerm;<br/>        }<br/>      };<br/>    }<br/>  }<br/>&lt;/script&gt;</span></pre><p id="6ff9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里引入两个新元素:<code class="fe nf ng nh mg b">reactive</code>和<code class="fe nf ng nh mg b">watch</code>。</p><p id="3d2d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nf ng nh mg b">reactive</code>功能相当于Vue 2的<code class="fe nf ng nh mg b">Vue.observable()</code>。<br/>它使传递的对象深度反应:获取原始对象并用代理包装它(ES2015基于代理的实现)。在从<code class="fe nf ng nh mg b">reactive</code>返回的对象上，我们可以直接访问属性，而不是从<code class="fe nf ng nh mg b">ref</code>函数返回的值，我们需要使用<code class="fe nf ng nh mg b">value</code>属性。如果您想在Vue 2.x API中搜索对等物，那么<code class="fe nf ng nh mg b">data</code>方法将是完全匹配的。</p><p id="79c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nf ng nh mg b">reactive</code>对象的一个缺点是我们不能将它扩展到从<code class="fe nf ng nh mg b">setup</code>方法返回的对象中。</p><p id="3ae6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nf ng nh mg b">watch</code>函数需要一个函数。它跟踪内部的反应变量，就像组件跟踪模板一样。当我们修改传递的函数中使用的反应变量时，给定的函数再次运行。在我们的例子中，每当搜索词改变时，它获取匹配搜索词的电影。</p><p id="bc38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">剩下一个组件，显示每个电影记录:</p><pre class="ky kz la lb gt mf mg mh mi aw mj bi"><span id="e2ab" class="mk ld iq mg b gy ml mm l mn mo">&lt;template&gt;<br/>  &lt;div class="movie"&gt;<br/>    &lt;h2&gt;{{ movie.Title }}&lt;/h2&gt;<br/>    &lt;div&gt;<br/>      &lt;img width="200" :alt="altText" :src="movie.Poster" /&gt;<br/>    &lt;/div&gt;<br/>    &lt;p&gt;{{ movie.Year }}&lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>  import { computed } from '@vue/composition-api';<br/><br/>  export default {<br/>    name: "Movie",<br/>    props: ['movie'],<br/>    setup({ movie }) {<br/>      const altText = computed(() =&gt; `The movie titled: ${movie.Title}`);<br/><br/>      return { altText };<br/>    }<br/>  };<br/>&lt;/script&gt;</span></pre><p id="23c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">电影组件接收要显示的电影，并将其名称与其图像一起打印出来。令人兴奋的是，对于图像的<code class="fe nf ng nh mg b">alt</code>字段，我们使用了基于其标题的计算文本。</p><p id="50fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe nf ng nh mg b">computed</code>函数获取一个getter函数，并将返回的变量包装成一个反应变量。返回的变量与从<code class="fe nf ng nh mg b">ref</code>函数返回的变量具有相同的接口。区别在于它是只读的。当getter函数中的一个反应变量改变时，getter函数将再次运行。如果<code class="fe nf ng nh mg b">computed</code>函数返回一个非包装的原始值，模板将无法跟踪依赖关系的变化。</p><h1 id="4728" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">清理组件</h1><p id="00c4" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">此时，我们在App组件内部有很多业务逻辑。它做两件事:处理API调用及其子组件。目标是每个对象有一个责任:应用程序组件应该只管理组件，不应该为API调用而烦恼。为此，我们必须提取API调用。</p><pre class="ky kz la lb gt mf mg mh mi aw mj bi"><span id="90f4" class="mk ld iq mg b gy ml mm l mn mo">import { reactive, watch } from '@vue/composition-api';<br/>const API_KEY = 'a5549d08';<br/><br/>export const useMovieApi = () =&gt; {<br/>  const state = reactive({<br/>    search: 'Joker',<br/>    loading: true,<br/>    movies: []<br/>  });<br/><br/>  watch(() =&gt; {<br/>    const MOVIE_API_URL = `https://www.omdbapi.com/?s=${state.search}&amp;apikey=${API_KEY}`;<br/><br/>    fetch(MOVIE_API_URL)<br/>      .then(response =&gt; response.json())<br/>      .then(jsonResponse =&gt; {<br/>        state.movies = jsonResponse.Search;<br/>        state.loading = false;<br/>      });<br/>  });<br/><br/>  return state;<br/>};</span></pre><p id="0e49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，App组件收缩到只处理与视图相关的操作:</p><pre class="ky kz la lb gt mf mg mh mi aw mj bi"><span id="12bf" class="mk ld iq mg b gy ml mm l mn mo">import Header from './Header.vue';<br/>import Search from './Search.vue';<br/>import Movie from './Movie.vue';<br/>import { useMovieApi } from '../hooks/movie-api';<br/><br/>export default {<br/>  name: 'app',<br/>  components: { Header, Search, Movie },<br/>  setup() {<br/>    const state = useMovieApi();<br/><br/>    return {<br/>      state,<br/>      handleSearch(searchTerm) {<br/>        state.loading = true;<br/>        state.search = searchTerm;<br/>      }<br/>    };<br/>  }<br/>}</span></pre><p id="6d02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">仅此而已；我们用新的组合API实现了一个小应用程序。</p><h1 id="bb07" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">包装它</h1><p id="0da0" class="pw-post-body-paragraph jy jz iq ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">自从使用Vue CLI生成项目以来，我们已经走过了漫长的道路。让我们总结一下我们所学的。</p><p id="a040" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在当前稳定的Vue 2版本中使用新的组合API。为了实现这一点，我们必须使用<code class="fe nf ng nh mg b">@vue/composition-api</code>插件。API是可扩展的:我们可以用新的API和旧的一起创建新的组件，现有的组件将继续像以前一样工作。</p><p id="588b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Vue 3将引入许多不同的功能:</p><ul class=""><li id="4a5b" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated"><code class="fe nf ng nh mg b">setup</code>:驻留在组件上，将编排组件的逻辑，在初始<code class="fe nf ng nh mg b">props</code>解析后运行，接收<code class="fe nf ng nh mg b">props</code>和上下文作为参数</li><li id="91e9" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><code class="fe nf ng nh mg b">ref</code>:返回一个反应变量，在模板改变时触发重新渲染，我们可以通过<code class="fe nf ng nh mg b">value</code>属性操纵它的值。</li><li id="1135" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><code class="fe nf ng nh mg b">reactive</code>:返回一个反应对象(基于代理)，在反应变量改变时触发模板的重新渲染，我们可以在没有<code class="fe nf ng nh mg b">value</code>属性的情况下修改其值</li><li id="8847" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><code class="fe nf ng nh mg b">computed</code>:根据getter函数参数返回一个反应变量，跟踪反应变量的变化，并在变化时重新计算</li><li id="a5bd" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated"><code class="fe nf ng nh mg b">watch</code>:根据提供的功能处理副作用，跟踪反应变量变化，并根据变化重新运行</li></ul><p id="e039" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这个例子已经让您熟悉了新的API，并消除了您的疑虑，就像我一样。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="81bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="np">原发布于2019年10月17日</em><a class="ae kw" href="https://dev.to/blacksonic/build-a-movie-search-app-using-the-vue-composition-api-5218" rel="noopener ugc nofollow" target="_blank"><em class="np">https://dev . to</em></a><em class="np">。</em></p></div></div>    
</body>
</html>