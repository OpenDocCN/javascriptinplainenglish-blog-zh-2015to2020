<html>
<head>
<title>Why Is setState() Asynchronous In React?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么在React中setState()是异步的？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-is-setstate-asynchronous-in-react-63827033ff45?source=collection_archive---------2-----------------------#2020-11-20">https://javascript.plainenglish.io/why-is-setstate-asynchronous-in-react-63827033ff45?source=collection_archive---------2-----------------------#2020-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d833" class="pw-subtitle-paragraph jr ip iq bd b js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki dk translated">还是同步的？</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/91484f343bd92fc3f883898652236cda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e_oJFkjO93ZbHWd0"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@brucemars?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">bruce mars</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d706" class="la lb iq bd lc ld le lf lg lh li lj lk ka ll kb lm kd ln ke lo kg lp kh lq lr bi translated">问题是</h1><p id="90ed" class="pw-post-body-paragraph ls lt iq lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">在React中，我们使用<code class="fe jn jo jp jq b">setState()</code>来更新任何组件的状态。现在<code class="fe jn jo jp jq b">setState()</code>不会立即改变这个状态，而是创建一个挂起的状态转换。调用<code class="fe jn jo jp jq b">setState()</code>后立即访问状态会返回现有值，而不是更新后的值。作为React的初学者，我相信我们大多数人都会经常面临这个问题。</p><p id="0155" class="pw-post-body-paragraph ls lt iq lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">不能保证<code class="fe jn jo jp jq b">setState()</code>上的同步操作，为了提高性能，可能会批量调用。人们很容易忘记<code class="fe jn jo jp jq b">setState()</code>是异步的，这使得我们很难调试代码中的问题。<code class="fe jn jo jp jq b">setState()</code>也不回承诺。使用<code class="fe jn jo jp jq b">async</code> / <code class="fe jn jo jp jq b">await</code>或任何类似的方法都不起作用。还有另一种情况，我们倾向于在同一个块中使用多个<code class="fe jn jo jp jq b">setState()</code>函数，有时状态没有正确更新。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="a889" class="la lb iq bd lc ld na lf lg lh nb lj lk ka nc kb lm kd nd ke lo kg ne kh lq lr bi translated">可能的解决方案</h1><p id="ee9f" class="pw-post-body-paragraph ls lt iq lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我们经常用一个参数调用<code class="fe jn jo jp jq b">setState()</code>，但实际上，该方法支持两个参数。您可以传递的第二个参数是一个回调函数，它总是在状态更新后执行。</p><p id="66bd" class="pw-post-body-paragraph ls lt iq lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">让我们来看一个问题的例子:</p><pre class="kk kl km kn gt nf jq ng nh aw ni bi"><span id="d10c" class="nj lb iq jq b gy nk nl l nm nn">...<br/>state = {value: 5}<br/>...<br/>...</span><span id="0611" class="nj lb iq jq b gy no nl l nm nn">// --WRONG WAY-- //</span><span id="d354" class="nj lb iq jq b gy no nl l nm nn">this.setState({value: this.state.value + 1})<br/>console.log(this.state.value) // Prints 5 and not 6</span></pre><p id="ee7c" class="pw-post-body-paragraph ls lt iq lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">编写更好的<code class="fe jn jo jp jq b">setState</code>函数的解决方案是:</p><pre class="kk kl km kn gt nf jq ng nh aw ni bi"><span id="0f31" class="nj lb iq jq b gy nk nl l nm nn">// --RIGHT WAY-- //</span><span id="9765" class="nj lb iq jq b gy no nl l nm nn">this.setState((prevState) =&gt; ({<br/>   value: prevState.value +1}), () =&gt; {<br/>   console.log(this.state.value)});<br/>// Provide a callback to setState as second argument</span></pre><p id="2a0b" class="pw-post-body-paragraph ls lt iq lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">上面给出了更新状态和访问更新值的正确方法。我们将一个回调函数作为第二个参数传递给在状态更新后被调用的<code class="fe jn jo jp jq b">setState()</code>函数。还应该注意，使用函数作为第一个参数来返回对象是编写React代码的一种非常好的方式，因为您可以访问状态的当前值(<code class="fe jn jo jp jq b">prevState</code>)。在一个块中使用一个<code class="fe jn jo jp jq b">setState()</code>函数来避免状态更新时出现问题也是一个很好的做法。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="2fe0" class="la lb iq bd lc ld na lf lg lh nb lj lk ka nc kb lm kd nd ke lo kg ne kh lq lr bi translated">为什么会这样？</h1><p id="1ef1" class="pw-post-body-paragraph ls lt iq lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">如果你看一下React的代码库中<code class="fe jn jo jp jq b">setState()</code>函数内部的代码，你会发现<code class="fe jn jo jp jq b">setState()</code>根本不是一个异步函数，它总是同步的。只是它在后台更新时调用了<strong class="lu ir"> enqueueState </strong>或<strong class="lu ir"> enqueueCallback </strong>，因此它的执行感觉像是异步的。</p><p id="dcab" class="pw-post-body-paragraph ls lt iq lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">因此，真正的同步或异步是React中调用<code class="fe jn jo jp jq b">setState()</code>的效果——<a class="ae kz" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank"><strong class="lu ir">协调</strong> </a>算法进行虚拟DOM比较，并调用render来更新真实DOM。</p><p id="cb6f" class="pw-post-body-paragraph ls lt iq lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">出于性能原因，React批量更新并每帧刷新一次。然而，在某些情况下，React无法控制批处理，因此更新是同步可用的，例如在AJAX、<code class="fe jn jo jp jq b">setTimeOut()</code>等中。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><h1 id="4baa" class="la lb iq bd lc ld na lf lg lh nb lj lk ka nc kb lm kd nd ke lo kg ne kh lq lr bi translated">结论</h1><p id="6802" class="pw-post-body-paragraph ls lt iq lu b lv lw jv lx ly lz jy ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">通常，更新状态发生在下一次渲染时，但有时为了提高性能，可以进行批处理。这种批处理可能不受React控制，因此<code class="fe jn jo jp jq b">setState()</code>可能不总是连续的。因此，如果您想要对状态进行顺序更新，请使用第二个参数。</p><p id="59ae" class="pw-post-body-paragraph ls lt iq lu b lv mo jv lx ly mp jy ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我希望你能从中学到一些新的东西！感谢阅读！</p></div></div>    
</body>
</html>