<html>
<head>
<title>JavaScript Type Checking with Flow — Union Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用流联合类型进行JavaScript类型检查</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-type-checking-with-flow-union-types-3c8aa5d1dc05?source=collection_archive---------3-----------------------#2020-02-14">https://javascript.plainenglish.io/javascript-type-checking-with-flow-union-types-3c8aa5d1dc05?source=collection_archive---------3-----------------------#2020-02-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e00e80f6ddaf2d6cddbfc3c422250c2f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XmTePWN2V3RgVhPj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@dre0316?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andre Hunter</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="52a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Flow是一个由脸书开发的类型检查器，用于检查JavaScript数据类型。它有许多内置的数据类型，我们可以用它们来注释变量和函数参数的类型。</p><p id="c0e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何使用联合类型来创建接受几种不同类型的变量。</p><h1 id="cd03" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">联合类型语法</h1><p id="dcd1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">定义联合类型的一般语法如下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fc13" class="mn lc iq mj b gy mo mp l mq mr">Type1 | Type2 | ... | TypeN</span></pre><p id="0ea4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用竖线<code class="fe ms mt mu mj b">|</code>将每种类型分开。</p><p id="17b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以通过使用前导<code class="fe ms mt mu mj b">|</code>将它们分成多行:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b832" class="mn lc iq mj b gy mo mp l mq mr">type Bar =<br/>  | Type1<br/>  | Type2<br/>  | ...<br/>  | TypeN</span></pre><p id="b8f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以从其他联合类型中创建联合类型:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="61a2" class="mn lc iq mj b gy mo mp l mq mr">type Numbers = 1 | 2;<br/>type Fruit = 'apple' | 'orange';</span><span id="a349" class="mn lc iq mj b gy mv mp l mq mr">type Foo = Numbers | Fruit;</span></pre><h1 id="45f9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">功能</h1><p id="1af4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们在函数中使用联合类型，我们必须处理参数的联合类型的每一种可能类型。例如，我们必须写出这样的内容:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="38ff" class="mn lc iq mj b gy mo mp l mq mr">function foo(value: number | boolean | string):  number { <br/>  if (typeof value === 'number') {<br/>    return 1;<br/>  } else if (typeof value === 'boolean') {<br/>    return 2;<br/>  }<br/>  return Number(value);<br/>}</span></pre><p id="ba82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们像下面的代码一样跳过对参数的联合类型中任何类型的处理:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="18bb" class="mn lc iq mj b gy mo mp l mq mr">function foo(value: number | boolean | string):  number { <br/>  if (typeof value === 'number') {<br/>    return 1;<br/>  } else if (typeof value === 'boolean') {<br/>    return 2;<br/>  }  <br/>}</span></pre><p id="1fa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会得到一个错误。</p><h1 id="bb1c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">联合和细化</h1><p id="c999" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于联合类型参数，单独处理每种类型是很有用的。我们可以使用<code class="fe ms mt mu mj b">typeof</code>操作符来检查类型，并按如下方式处理每种类型:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bb53" class="mn lc iq mj b gy mo mp l mq mr">function foo(value: number | boolean | string): number { <br/>  if (typeof value === 'number') {<br/>    return 1;<br/>  } <br/>  else if (typeof value === 'boolean') {<br/>    return 2;<br/>  } <br/>  else if (typeof value === 'string') {<br/>    return Number(value);<br/>  }<br/>  return Number(value);<br/>}</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/1e14edc5c31f7506edd04555bb12461d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zoDEak8mIrB25yuR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@domi_blig?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dominic Blignaut</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0302" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不相交并集</h1><p id="0522" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用不同的对象类型创建一个联合类型。例如，如果我们有以下对象:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="370a" class="mn lc iq mj b gy mo mp l mq mr">{ foo: true, bar: 'bar' }<br/>{ foo: false, bar: 'baz' }</span></pre><p id="82e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过为这两个对象分别创建一个类型别名来创建一个联合类型，然后将它们联合起来。所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="95f3" class="mn lc iq mj b gy mo mp l mq mr">type Foo1 = { foo: true, bar: 'bar' };<br/>type Foo2 = { foo: false, bar: 'baz' };</span><span id="0edd" class="mn lc iq mj b gy mv mp l mq mr">type Foo = Foo1 | Foo2;</span></pre><p id="283e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以创建类型为<code class="fe ms mt mu mj b">Foo</code>的变量，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="01ea" class="mn lc iq mj b gy mo mp l mq mr">let foo1: Foo = { foo: true, bar: 'bar' };<br/>let foo2: Foo = { foo: false, bar: 'baz' };</span></pre><p id="e6b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具有固定值的两个对象类型的联合将允许我们的变量采用联合中的两个类型中的任何一个。</p><p id="2daf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具有不精确属性的对象类型的联合将为属性创建两种类型的联合。</p><p id="7b3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e32f" class="mn lc iq mj b gy mo mp l mq mr">type Foo1 = { foo: true, bar: string };<br/>type Foo2 = { foo: true, bar: number };<br/>type Foo = Foo1 | Foo2;</span></pre><p id="793d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">Foo</code>将允许<code class="fe ms mt mu mj b">bar</code>为字符串或数字，而<code class="fe ms mt mu mj b">foo</code>将始终为<code class="fe ms mt mu mj b">true</code>。所以我们可以创建如下的变量:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4e4f" class="mn lc iq mj b gy mo mp l mq mr">let foo1: Foo = { foo: true, bar: 'bar' };<br/>let foo2: Foo = { foo: true, bar: 2 };</span></pre><p id="ef87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有两个不同属性的类型，那么两个类型的并集让我们包含对象的所有属性，如果我们有一个两个类型并集的变量。</p><p id="0b95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3b61" class="mn lc iq mj b gy mo mp l mq mr">type Foo1 = { foo: true, bar: string };<br/>type Foo2 = { baz: false, a: number };</span><span id="ae29" class="mn lc iq mj b gy mv mp l mq mr">type Foo = Foo1 | Foo2;</span></pre><p id="81aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以定义一个具有所有属性的变量，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0adc" class="mn lc iq mj b gy mo mp l mq mr">let foo: Foo = { foo: true, bar: 'bar', baz: false, a: 1 };</span></pre><p id="abba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于联合类型，我们还可以传入组成联合的类型中不包含的额外属性。所以考虑到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a1d2" class="mn lc iq mj b gy mo mp l mq mr">type Foo1 = { foo: true, bar: string };<br/>type Foo2 = { baz: false, a: number };</span><span id="02ec" class="mn lc iq mj b gy mv mp l mq mr">type Foo = Foo1 | Foo2;</span></pre><p id="0a43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="214f" class="mn lc iq mj b gy mo mp l mq mr">let foo: Foo = { foo: true, bar: 'bar', baz: false, a: 1, b: 2 };</span></pre><h1 id="f229" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">精确类型的不相交并集</h1><p id="22cf" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过创建精确类型的联合来限制新属性的添加，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3f0b" class="mn lc iq mj b gy mo mp l mq mr">type Foo1 = {| foo: true, bar: string |};<br/>type Foo2 = {| baz: false, a: number |};</span><span id="aec9" class="mn lc iq mj b gy mv mp l mq mr">type Foo = Foo1 | Foo2;</span></pre><p id="1c6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6e29" class="mn lc iq mj b gy mo mp l mq mr">let foo: Foo = { foo: true, bar: 'bar', baz: false, a: 1, b: 2 };</span></pre><p id="57c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">会给我们一个错误。</p><p id="5253" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了精确类型的联合，我们可以从其中一个获得属性。给定这些类型:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="62a2" class="mn lc iq mj b gy mo mp l mq mr">type Foo1 = {| foo: true, bar: string |};<br/>type Foo2 = {| baz: false, a: number |};</span><span id="05ab" class="mn lc iq mj b gy mv mp l mq mr">type Foo = Foo1 | Foo2;</span></pre><p id="c16e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以选择:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2a5f" class="mn lc iq mj b gy mo mp l mq mr">let foo: Foo = { foo: true, bar: 'bar' };</span></pre><p id="1f1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e4fb" class="mn lc iq mj b gy mo mp l mq mr">let foo: Foo = {  baz: false, a: 1 };</span></pre><p id="b921" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用联合类型，我们可以创建可以采用几种类型的值的变量。形成联合的类型可以是基元或对象类型。</p><p id="01bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以形成精确类型的联合，以防止添加未在类型中列出的附加属性或包含所有类型的属性。</p></div></div>    
</body>
</html>