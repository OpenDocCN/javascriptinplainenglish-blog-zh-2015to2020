<html>
<head>
<title>JavaScript Algorithms: Verifying an Alien Dictionary (LeetCode)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法:验证外来字典(LeetCode)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-algorithms-verifying-an-alien-dictionary-leetcode-4769a7605a2a?source=collection_archive---------6-----------------------#2020-12-15">https://javascript.plainenglish.io/javascript-algorithms-verifying-an-alien-dictionary-leetcode-4769a7605a2a?source=collection_archive---------6-----------------------#2020-12-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9c827612660f7b09b3fbaf8a69e512b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MsAVWe6788HEoSL6"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@pisitheng?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pisit Heng</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e079" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">描述</h1><p id="00c8" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在外星语言中，令人惊讶的是他们也使用英文小写字母，但可能是不同的<code class="fe lw lx ly lz b">order</code>。字母表中的<code class="fe lw lx ly lz b">order</code>是一些小写字母的排列。</p><p id="886f" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">给定一个用外星语言写的<code class="fe lw lx ly lz b">words</code>序列和字母表的<code class="fe lw lx ly lz b">order</code>，当且仅当给定的<code class="fe lw lx ly lz b">words</code>按外星语言的字典顺序排序时，返回<code class="fe lw lx ly lz b">true</code>。</p><p id="c519" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated"><strong class="la io">例1: </strong></p><pre class="mf mg mh mi gt mj lz mk ml aw mm bi"><span id="0b5c" class="mn kb in lz b gy mo mp l mq mr"><strong class="lz io">Input:</strong> words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"<br/><strong class="lz io">Output:</strong> true<br/><strong class="lz io">Explanation: </strong>As 'h' comes before 'l' in this language, then the sequence is sorted.</span></pre><p id="d958" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated"><strong class="la io">例2: </strong></p><pre class="mf mg mh mi gt mj lz mk ml aw mm bi"><span id="2ea8" class="mn kb in lz b gy mo mp l mq mr"><strong class="lz io">Input:</strong> words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"<br/><strong class="lz io">Output:</strong> false<br/><strong class="lz io">Explanation: </strong>As 'd' comes after 'l' in this language, then words[0] &gt; words[1], hence the sequence is unsorted.</span></pre><p id="e44e" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated"><strong class="la io">例3: </strong></p><pre class="mf mg mh mi gt mj lz mk ml aw mm bi"><span id="4334" class="mn kb in lz b gy mo mp l mq mr"><strong class="lz io">Input:</strong> words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"<br/><strong class="lz io">Output:</strong> false<br/><strong class="lz io">Explanation: </strong>The first three characters "app" match, and the second string is shorter (in size.) According to lexicographical rules "apple" &gt; "app", because 'l' &gt; '∅', where '∅' is defined as the blank character which is less than any other character (<a class="ae jz" href="https://en.wikipedia.org/wiki/Lexicographical_order" rel="noopener ugc nofollow" target="_blank">More info</a>).</span></pre><p id="4e05" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated"><strong class="la io">约束:</strong></p><ul class=""><li id="c5ff" class="ms mt in la b lb ma lf mb lj mu ln mv lr mw lv mx my mz na bi translated"><code class="fe lw lx ly lz b">1 &lt;= words.length &lt;= 100</code></li><li id="a244" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated"><code class="fe lw lx ly lz b">1 &lt;= words[i].length &lt;= 20</code></li><li id="8c59" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated"><code class="fe lw lx ly lz b">order.length == 26</code></li><li id="9a80" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated"><code class="fe lw lx ly lz b">words[i]</code>和<code class="fe lw lx ly lz b">order</code>中的所有字符都是英文小写字母。</li></ul><h1 id="c483" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">解决办法</h1><p id="885c" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">首先，我们来搞清楚字典序是什么— <a class="ae jz" href="https://en.wikipedia.org/wiki/Lexicographic_order" rel="noopener ugc nofollow" target="_blank"> wiki </a>。为了解决这个问题，我们真正需要知道的是字典顺序:</p><ul class=""><li id="30ad" class="ms mt in la b lb ma lf mb lj mu ln mv lr mw lv mx my mz na bi translated">如果两个单词有相同的第一个字母，我们比较第二个。如果第二个字母相同，我们就比较第三个，以此类推。最后，如果第一个不同的字母在对应的字母之前，则一个单词在另一个单词之前。</li><li id="b5dd" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated">如果两个单词在较短的单词长度上完全相同，则较短的单词先出现。</li></ul><p id="8610" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">换句话说——JavaScript . info:</p><ol class=""><li id="4483" class="ms mt in la b lb ma lf mb lj mu ln mv lr mw lv ng my mz na bi translated">比较两个字符串的第一个字符。</li><li id="afaa" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv ng my mz na bi translated">如果第一个字符串的第一个字符大于(或小于)另一个字符串的第一个字符，则第一个字符串大于(或小于)第二个字符串。我们完了。</li><li id="422c" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv ng my mz na bi translated">否则，如果两个字符串的第一个字符相同，以同样的方式比较第二个字符。</li><li id="adc7" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv ng my mz na bi translated">重复直到任一字符串结束。</li><li id="590f" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv ng my mz na bi translated">如果两个字符串以相同的长度结束，那么它们相等。否则，字符串越长越大。</li></ol><p id="485c" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">在JavaScript中比较两个字母意味着比较它们在<a class="ae jz" href="https://en.wikipedia.org/wiki/Unicode" rel="noopener ugc nofollow" target="_blank"> Unicode </a> (16位Unicode转换格式)中的代码。因此，使用Unicode我们知道<code class="fe lw lx ly lz b">a</code>有<code class="fe lw lx ly lz b">feff0061</code>的字符代码，<code class="fe lw lx ly lz b">b</code>有<code class="fe lw lx ly lz b">feff0062</code>的字符代码，以此类推。</p><pre class="mf mg mh mi gt mj lz mk ml aw mm bi"><span id="2a36" class="mn kb in lz b gy mo mp l mq mr">'a'.charCodeAt().toString(16) -&gt; 61<br/>'b'.charCodeAt().toString(16) -&gt; 62<br/>...<br/>'z'.charCodeAt().toString(16) -&gt; 7a</span></pre><p id="b03e" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">在这个问题中，我们有一个新的字母表<code class="fe lw lx ly lz b">order</code>,我们需要找出如何有效地比较两个字母。在这种情况下，最好的数据结构是HashMap。键将是一个字母，值将是索引，因为我们需要比较两个字母，较大的字母将具有较高的索引。</p></div><div class="ab cl nh ni hr nj" role="separator"><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm nn"/><span class="nk bw bk nl nm"/></div><div class="ig ih ii ij ik"><p id="7ff2" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">所以，在我们理解了所有这些之后，我们可以切换到一个算法。我们可以遍历所有单词，并在每次迭代中逐个字母地比较两个单词(<code class="fe lw lx ly lz b">current</code>和<code class="fe lw lx ly lz b">next</code>)。比较算法非常简单:</p><ul class=""><li id="6474" class="ms mt in la b lb ma lf mb lj mu ln mv lr mw lv mx my mz na bi translated">如果<code class="fe lw lx ly lz b">current[i] === next[i]</code>我们需要更进一步。</li><li id="142f" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated">如果<code class="fe lw lx ly lz b">map[current[i]] &lt; map[next[i]]</code>我们需要返回<code class="fe lw lx ly lz b">false</code>，因为我们不再需要比较其他字符。</li><li id="afcd" class="ms mt in la b lb nb lf nc lj nd ln ne lr nf lv mx my mz na bi translated">如果下一个单词对存在，我们需要转到它。</li></ul><p id="ece6" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">让我们看一下实现:</p><figure class="mf mg mh mi gt jo"><div class="bz fp l di"><div class="no np l"/></div></figure><figure class="mf mg mh mi gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/66bbdd8b8b578d8d25923e975ae4a7e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MSeKZ2G0iqaNLKZy9eeAIQ.png"/></div></div></figure><p id="4a38" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">时间复杂度为<code class="fe lw lx ly lz b">O(mn)</code>，其中<code class="fe lw lx ly lz b">m</code>为字数，<code class="fe lw lx ly lz b">n</code>为这些字的平均长度。根据约束条件，我们可以说时间复杂度是线性的，因为我们在一个单词中最多可以有20个字符。空间复杂度是恒定的，因为我们在<code class="fe lw lx ly lz b">order</code>中最多有26个字母。</p><p id="934a" class="pw-post-body-paragraph ky kz in la b lb ma ld le lf mb lh li lj mc ll lm ln md lp lq lr me lt lu lv ig bi translated">我希望，它对你有用。感谢阅读！期待您的反馈。回头见，✌️</p></div></div>    
</body>
</html>