<html>
<head>
<title>JavaScript Anti Patterns — Wrappers and Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript反模式——包装器和函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-antipatterns-wrappers-and-functions-b8580c92dec8?source=collection_archive---------4-----------------------#2020-05-30">https://javascript.plainenglish.io/javascript-antipatterns-wrappers-and-functions-b8580c92dec8?source=collection_archive---------4-----------------------#2020-05-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f3908e9305e24b8c3b2f9834700fe08d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i1H5bSs9EVS3U8vN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@scottwebb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Scott Webb</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5ba5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript让我们可以做很多事情。它的语法有时过于宽容。</p><p id="9766" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些在定义和使用包装器和函数时应该避免的反模式。</p><h1 id="d338" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">原始包装</h1><p id="af86" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript附带了一组原始包装器。</p><p id="0d43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们包括<code class="fe me mf mg mh b">Number()</code>、<code class="fe me mf mg mh b">String()</code>、<code class="fe me mf mg mh b">Boolean()</code>构造者。</p><p id="7997" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用它们创建原始值不同于使用文字。</p><p id="7bad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用文字，我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f2d1" class="mq lc iq mh b gy mr ms l mt mu">console.log(typeof 100);</span></pre><p id="92a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们看到<code class="fe me mf mg mh b">'number'</code>登录到控制台。</p><p id="11c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果我们使用<code class="fe me mf mg mh b">Number</code>构造函数，我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f2ce" class="mq lc iq mh b gy mr ms l mt mu">console.log(typeof new Number(100));</span></pre><p id="b9a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe me mf mg mh b">'object'</code>日志。</p><p id="2e03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript解释器内部使用时最需要包装器。</p><p id="082f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原始文字在调用类似数字上的<code class="fe me mf mg mh b">toFixed()</code>的方法之前被转换成对象。</p><p id="88a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">字符串在包装器上也有一些可用的方法，如<code class="fe me mf mg mh b">toLowerCase()</code>。</p><p id="c6c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="286b" class="mq lc iq mh b gy mr ms l mt mu">(1 / 7).toPrecision(3);</span></pre><p id="437e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe me mf mg mh b">1 / 7</code>转换成包装器对象，就可以调用<code class="fe me mf mg mh b">toPrecision</code>了。</p><p id="239c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们不应该用它们来创建对象。</p><p id="4f86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为它们对我们毫无用处。</p><p id="5733" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8e85" class="mq lc iq mh b gy mr ms l mt mu">const s = new String("string");</span></pre><p id="545d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d011" class="mq lc iq mh b gy mr ms l mt mu">const s = "string";</span></pre><p id="aa18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们应该仅隐式用于调用方法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1a90" class="mq lc iq mh b gy mr ms l mt mu">'hello world'.split(' ')[0]</span></pre><p id="fff0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不想显式地调用构造函数。</p><h1 id="2d7a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">错误对象</h1><p id="6e01" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">错误构造函数是JavaScript标准库的一部分。</p><p id="f161" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有<code class="fe me mf mg mh b">Error()</code>、<code class="fe me mf mg mh b">SyntaxError()</code>、<code class="fe me mf mg mh b">TypeError()</code>等构造函数。</p><p id="72a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们具有以下属性:</p><ul class=""><li id="a53f" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><code class="fe me mf mg mh b">name</code> —错误的名称</li><li id="4082" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">message</code> —创建对象时传递给构造函数的字符串。</li></ul><p id="8e5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还有其他属性，比如行号和发生错误的文件名。</p><p id="676e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">throw</code>适用于任何对象。只要对象有<code class="fe me mf mg mh b">name</code>和<code class="fe me mf mg mh b">message</code>属性，就可以用<code class="fe me mf mg mh b">catch</code>语句捕获。</p><p id="3408" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="45fc" class="mq lc iq mh b gy mr ms l mt mu">try {<br/>  throw {<br/>    name: 'error',<br/>    message: 'error occurred'<br/>  }<br/>} catch (ex) {<br/> console.log(ex)<br/>}</span></pre><p id="fc91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2f59" class="mq lc iq mh b gy mr ms l mt mu">{name: "error", message: "error occurred"}</span></pre><p id="b80a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从控制台日志输出。</p><h1 id="d506" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">功能</h1><p id="c4e3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript函数是对象。</p><p id="cb2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们是头等物品。这意味着它们可以动态创建。</p><p id="38a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，还可以将它们赋给变量，复制它们，并向它们添加属性。可以删除它们的属性。</p><p id="6d39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数也可以作为参数传递给其他函数，这些参数可以由其他函数返回。</p><p id="0289" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们也可以有自己的方法。</p><p id="c5b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过<code class="fe me mf mg mh b">Function</code>构造函数的存在，我们可以看出它们是对象。</p><p id="3297" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该用它来创建函数，但我们知道它在那里，所以我们可以看到函数是对象。</p><p id="df2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数有自己的作用域。块创建它们自己的变量范围，常量用<code class="fe me mf mg mh b">let</code>或<code class="fe me mf mg mh b">const</code>声明。</p><p id="4d22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们声明一个函数，那么我们应该使用<code class="fe me mf mg mh b">let</code>或<code class="fe me mf mg mh b">const</code>来声明块范围的数据。</p><p id="ebba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将为我们省去许多使用示波器的麻烦。</p><p id="bdd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1c45" class="mq lc iq mh b gy mr ms l mt mu">const foo = () =&gt; {<br/>  let x = 1;<br/>  const y = 2;<br/>  //...<br/>}</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/88c940dbbb7a61c0a0a439ffb4a91d53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mu6BfxG4WKqfsSS_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@britishlibrary?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">British Library</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="89e0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">功能类型</h1><p id="47c3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript中有两种函数。</p><p id="db41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们是函数表达式和函数声明。</p><p id="f9ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们把函数赋给一个变量或常数时，我们就创建了一个函数表达式。</p><p id="ac5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b9a7" class="mq lc iq mh b gy mr ms l mt mu">const foo = () =&gt; {<br/>  let x = 1;<br/>  const y = 2;<br/>  //...<br/>};</span></pre><p id="8151" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3ec3" class="mq lc iq mh b gy mr ms l mt mu">const foo = function() {<br/>  let x = 1;<br/>  const y = 2;<br/>  //...<br/>};</span></pre><p id="51e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数表达式也可以命名为:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f1a6" class="mq lc iq mh b gy mr ms l mt mu">const foo = function bar() {<br/>  let x = 1;<br/>  const y = 2;<br/>  //...<br/>};</span></pre><p id="a343" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但我们还是用<code class="fe me mf mg mh b">foo</code>来称呼它。</p><p id="41e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，如果我们不需要引用<code class="fe me mf mg mh b">this</code>，箭头函数是首选，如果我们不创建构造函数，我们很可能不需要引用。</p><p id="8386" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数声明是通过定义传统函数而创建的，无需将其赋给变量或常数。</p><p id="5dae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="05de" class="mq lc iq mh b gy mr ms l mt mu">function foo() {<br/>  // function body<br/>}</span></pre><p id="31d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们被提升起来，以便可以在脚本中的任何地方引用它们。</p><p id="1ece" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数声明不需要分号。</p><h1 id="3f7d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9c63" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用原始包装器来定义原始值。</p><p id="d361" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们应该只在JavaScript解释器内部使用，这样我们就可以用原始值调用方法。</p><p id="8d49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数可以用几种方法创建。如果我们使用函数表达式，我们应该在末尾加上分号。</p><p id="2820" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该在函数中使用块范围的变量和常量，以避免与范围混淆。</p><h1 id="2622" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">用简单英语写的便条</strong></h1><p id="7c86" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">plain English . io</strong></a>找到所有这些内容——关注我们的出版物并<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>