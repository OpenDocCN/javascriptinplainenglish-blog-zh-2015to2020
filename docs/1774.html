<html>
<head>
<title>How the ‘this’ keyword changes when used in different contexts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“this”关键字在不同的上下文中如何变化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/whats-function-got-to-do-with-this-7ab2633fb4a5?source=collection_archive---------2-----------------------#2020-04-21">https://javascript.plainenglish.io/whats-function-got-to-do-with-this-7ab2633fb4a5?source=collection_archive---------2-----------------------#2020-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f9b5c6093e3a1f306e17e5950ffece68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8OqmE4YlAtAtmYSzrRcEog.png"/></div></div></figure><p id="dd16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并非所有的功能都是平等的。我们如何使用函数会影响它的上下文和范围。学习更多关于函数的知识是了解JavaScript如何评估<code class="fe kw kx ky kz b">this</code>的一个很好的方法，这确实值得单独的系列。</p><p id="ab26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，一些基础术语。或者，如果您已经知道它们，那么可以跳过一半直接跳到常规的vs arrow和DOM事件。</p><h1 id="c4ee" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">宣言vs表情</strong></h1><p id="3eed" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated"><strong class="ka ir">声明:</strong></p><p id="7be7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<strong class="ka ir">函数声明</strong>(或函数语句)。当它执行时，它<strong class="ka ir">被提升</strong>到封闭函数的顶部。因此您可以在声明函数之前调用它。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="0466" class="ml lb iq kz b gy mm mn l mo mp">function myfunc() {}</span></pre><p id="4fff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">表达式:</strong></p><p id="102a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个带有匿名函数的<strong class="ka ir">函数表达式。函数表达式是赋给变量的函数。更重要的是，<strong class="ka ir"> <em class="mq">它没有被吊起</em> </strong>。只有当解释器读到这一行时，它才会被调用。因此在声明之前，您将无法引用它。</strong></p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="5ea8" class="ml lb iq kz b gy mm mn l mo mp">var myfunc = function() {}</span></pre><p id="fa3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个更紧凑的版本是一个箭头函数(稍后在<a class="ae mr" href="#245a" rel="noopener ugc nofollow"/>中会有更多)。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="1873" class="ml lb iq kz b gy mm mn l mo mp">var myfunc = () =&gt; {}</span></pre><p id="94ec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以创建一个带有命名函数的<strong class="ka ir">函数表达式，这样您就可以在函数体中调用该命名函数。这对于编写递归函数很有用。</strong></p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="c7c9" class="ml lb iq kz b gy mm mn l mo mp">var myfunc = function named() {}</span></pre><p id="6bf4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">表情:生活版</strong></p><p id="893b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<strong class="ka ir">生命函数</strong>是一个函数表达式，一旦被定义就运行。它是一个由一组<code class="fe kw kx ky kz b">()</code>包装的<code class="fe kw kx ky kz b">function()</code>，向解释器发出信号，表示它应该被视为一个函数表达式，最后一组<code class="fe kw kx ky kz b">()</code>调用函数。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="7aed" class="ml lb iq kz b gy mm mn l mo mp">(function() {<br/>  // code here<br/>})()</span></pre><p id="ff93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="e6e7" class="ml lb iq kz b gy mm mn l mo mp">(() =&gt; {<br/>  // code here<br/>})()</span></pre><p id="c34f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以给生命传递参数</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="4b25" class="ml lb iq kz b gy mm mn l mo mp">(function(name) {<br/>  console.log(‘hello’, name);<br/>  // hello Tom<br/>})(“Tom”);</span></pre><h1 id="d48a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">匿名vs具名</strong></h1><p id="0bc2" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated"><strong class="ka ir">匿名:</strong></p><p id="6cee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">堆栈跟踪中的<strong class="ka ir">匿名函数</strong>将隐式使用定义上下文的名称作为函数名。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="66a2" class="ml lb iq kz b gy mm mn l mo mp">var myfunc = function() {}</span></pre><p id="b7aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">命名为:</strong></p><p id="d5fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">堆栈跟踪中一个名为<strong class="ka ir">的函数</strong>将使用函数名作为上下文，这使得调试更加可靠。当您有一个命名的函数表达式时，它的上下文并不局限于封闭环境。但是它可以访问封闭上下文的全局声明和变量。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="5661" class="ml lb iq kz b gy mm mn l mo mp">var greeting = function(name) {<br/>   var sayHello = function phrase() { return ‘hello ‘ + name };<br/>   console.log(sayHello())<br/>}</span><span id="2bb6" class="ml lb iq kz b gy ms mn l mo mp">greeting('Jaime')<br/>//output: hello Jaime</span></pre></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="5606" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们来看看函数的两种基本类型。理解这种差异对于实现对象方法、回调和组合等模式非常重要。</p><h1 id="245a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">常规vs箭头</strong></h1><blockquote class="na nb nc"><p id="9208" class="jy jz mq ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated"><strong class="ka ir">☕tl；dr: </strong>两者的主要区别在于<strong class="ka ir">箭头函数</strong>是一个没有自己绑定到<code class="fe kw kx ky kz b">this</code>、<code class="fe kw kx ky kz b">arguments</code>或<code class="fe kw kx ky kz b">super </code>的函数表达式，也没有<code class="fe kw kx ky kz b">new.target</code>。Arrow函数不能使用内置方法<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" rel="noopener ugc nofollow" target="_blank"> bind() </a>、<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" rel="noopener ugc nofollow" target="_blank"> apply() </a>和<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call" rel="noopener ugc nofollow" target="_blank"> call() </a>来改变其上下文。Arrow函数也没有“property”关键字。</p><p id="212e" class="jy jz mq ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated">那么为什么要使用arrow函数而不是它简洁的语法呢？回调等用例特别适合依赖于词法范围而不是执行上下文的函数。</p></blockquote><p id="6ef2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们深入了解一下<strong class="ka ir"> tl之外的内容；dr </strong>来看看<code class="fe kw kx ky kz b">this</code>是如何详细改变上下文的，以及为什么。</p><p id="f756" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">常规:</strong></p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="32df" class="ml lb iq kz b gy mm mn l mo mp">function regular() {}</span></pre><p id="4ce5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<strong class="ka ir">常规函数</strong>可以是命名的也可以是匿名的(见上文)。</p><p id="adb7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它是<em class="mq">可构造的</em>，因为你可以使用<code class="fe kw kx ky kz b">new()</code>关键字创建一个新对象。它还带有一个局部变量<code class="fe kw kx ky kz b">arguments</code>。这两者都不能用箭头函数来实现。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="97b6" class="ml lb iq kz b gy mm mn l mo mp">function myFunction() {<br/>  if(arguments) {<br/>    console.log(argument[0]);<br/>  }<br/>}</span><span id="26f1" class="ml lb iq kz b gy ms mn l mo mp">const newObject = new myFunction(1); //returns 1</span></pre><p id="9fac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在常规函数中，<code class="fe kw kx ky kz b">this</code>被绑定到它的执行上下文或者调用函数的对象。这使得它特别适合作为对象方法。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="0295" class="ml lb iq kz b gy mm mn l mo mp">const myMethod = {<br/>  username: “Tommy”,<br/>  callName: function() {<br/>    console.log(“hello :”, this.username);<br/>  }<br/>};</span><span id="fc15" class="ml lb iq kz b gy ms mn l mo mp">myMethod.callName();<br/>//output: “hello Tommy”</span></pre><p id="f520" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">箭头:</strong></p><p id="40d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<strong class="ka ir">箭头功能</strong>写成<code class="fe kw kx ky kz b">()=&gt;{}</code>。</p><p id="79a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Arrow函数不是可构造的，而是可调用的。这意味着您不能使用<code class="fe kw kx ky kz b">new</code>关键字。它也没有一个<code class="fe kw kx ky kz b">prototype</code>属性。</p><p id="04bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一般来说，它比常规函数更适合于函数式编程。一个关键原因是它没有自己与<code class="fe kw kx ky kz b">this</code>的绑定。正因为如此，内置的原型方法<em class="mq"> bind/call/apply </em>不能用于重新设置上下文。Arrow函数可以使用<code class="fe kw kx ky kz b">call()</code>和<code class="fe kw kx ky kz b">apply()</code>简单地调用函数并传递参数。并且<code class="fe kw kx ky kz b">bind()</code>对箭头功能没有影响。</p><p id="7929" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与常规函数不同，Arrow函数的<code class="fe kw kx ky kz b">this</code>绑定到词法范围或定义它的地方。词法范围的限制使得arrow函数不适合对象方法。</p><p id="3ea4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用前面的<code class="fe kw kx ky kz b">myMethod</code>示例作为箭头功能来说明:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="7446" class="ml lb iq kz b gy mm mn l mo mp">const myMethod = {<br/>  username: “Tommy”,<br/>  callName: () =&gt; {<br/>    console.log(this);<br/>    console.log(this.username);<br/>  }<br/>};</span><span id="0dd7" class="ml lb iq kz b gy ms mn l mo mp">myMethod.callName();</span><span id="87dc" class="ml lb iq kz b gy ms mn l mo mp">//output: Window or global object<br/>//output: undefined</span></pre><p id="3a6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，没有自己的<code class="fe kw kx ky kz b">this</code>绑定的arrow函数实际上非常适合回调函数。</p><p id="b197" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，假设我们修改<code class="fe kw kx ky kz b">myMethod.callName</code>以具有回调超时功能:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="ebd6" class="ml lb iq kz b gy mm mn l mo mp">const myMethod = {<br/>  username: “Tommy”,<br/>  callName: function() {<br/>   console.log(“hello :”, this.username);<br/>   <br/>   setTimeout(function() {<br/>     console.log(“call again: “, this.username);<br/>   }, 1000);<br/>  }<br/>};</span><span id="5ea4" class="ml lb iq kz b gy ms mn l mo mp">myMethod.callName();</span><span id="6771" class="ml lb iq kz b gy ms mn l mo mp">//output: “hello Tommy”<br/>//output: “call again: “ undefined</span></pre><p id="8ff4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在超时中，我们得到一个<code class="fe kw kx ky kz b">undefined</code>，因为<code class="fe kw kx ky kz b">this.username</code>在执行上下文中不存在。</p><blockquote class="na nb nc"><p id="cef6" class="jy jz mq ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated"><strong class="ka ir">⏳超时提示:</strong>如果我们在<code class="fe kw kx ky kz b">setTimeout</code>函数中<code class="fe kw kx ky kz b">console.log(this)</code>，我们将得到窗口或者全局对象(或者如果在严格模式下是未定义的)。为什么？因为<strong class="ka ir">规则默认绑定</strong>和<strong class="ka ir">隐式绑定</strong>。如果使用对象上下文调用函数，即<code class="fe kw kx ky kz b">myMethod.callName()</code>，则隐式绑定适用。但是超时函数是一个未经修饰的普通函数调用，这意味着默认绑定是有效的。在这种情况下，<code class="fe kw kx ky kz b">this</code>是全局对象。</p></blockquote><p id="de52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在使用arrow函数之前，我们将通过将<code class="fe kw kx ky kz b">this</code>重新分配给一个局部变量来修复超时函数:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="d778" class="ml lb iq kz b gy mm mn l mo mp">const myMethod = {<br/>  username: “Tommy”,<br/>  callName: function() {<br/>    var that = this;<br/>    <br/>    console.log(“hello :”, that.username);<br/>    setTimeout(function() {<br/>      console.log(“call again: “, that.username);<br/>    }, 1000);<br/>  }<br/>};</span></pre><p id="3949" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者对这个简单示例之外的内容同时使用重新分配和重新绑定:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="23a7" class="ml lb iq kz b gy mm mn l mo mp">...</span><span id="d29f" class="ml lb iq kz b gy ms mn l mo mp">callName: function () {<br/>  var self = this;</span><span id="c67a" class="ml lb iq kz b gy ms mn l mo mp">  function logDelayed() {<br/>    console.log(“delayed: “, this.username);<br/>  }<br/>  <br/>  setTimeout(logDelayed.bind(self), 1000);</span><span id="8e81" class="ml lb iq kz b gy ms mn l mo mp">}<br/>...</span></pre><p id="0a27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在任一解决方案中，正确的结果将被记录:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="f2e4" class="ml lb iq kz b gy mm mn l mo mp">myMethod.callName();</span><span id="db1e" class="ml lb iq kz b gy ms mn l mo mp">//output: “hello Tommy”<br/>//output: “call again: Tommy”</span></pre><p id="1446" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以解决，但是有太多的障碍，容易出问题。😓</p><p id="c184" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从ES6开始，我们只需要把传递给<code class="fe kw kx ky kz b">setTimeOut</code>的回调函数转换成箭头函数。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="fc5c" class="ml lb iq kz b gy mm mn l mo mp">const myMethod = {<br/>  username: “Tommy”,<br/>  callName: function() {<br/>    console.log(this.username);<br/>    <br/>    setTimeout(() =&gt; {<br/>       console.log(“call again: “, this.username);<br/>    }, 1000);<br/>  }<br/>};</span><span id="601b" class="ml lb iq kz b gy ms mn l mo mp">myMethod.callName();</span><span id="d2d7" class="ml lb iq kz b gy ms mn l mo mp">//output: “hello Tommy”<br/>//output: “call again: Tommy”</span></pre><p id="bf67" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于回调是一个箭头函数，<code class="fe kw kx ky kz b">this</code>现在来自词法范围，这意味着回调是在这里定义的。开发者对箭头功能如此兴奋的原因之一！🤩</p><h1 id="c9bb" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">更多关于常规的，箭头函数&amp;这个跟DOM事件</strong></h1><p id="cdc0" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">到目前为止，我们已经深入了解了arrow函数和常规函数之间的区别。关键在于理解JavaScript中的<code class="fe kw kx ky kz b">this</code>是如何计算的。</p><p id="d82a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了进一步探究这个主题中的细微差别，我认为我们可以使用一个非常常见的回调应用程序— DOM event。</p><p id="4dbd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在前端开发中，这是我们需要用回调来构建的最基本的特性。</p><p id="87da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于示例，我们将使用普通的JavaScript实现。</p><p id="e536" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1。绑定到DOM元素的事件回调:</strong></p><p id="1633" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望绑定在DOM对象本身上。它被称为<strong class="ka ir">动态上下文</strong>，其中<code class="fe kw kx ky kz b">this</code>在每次调用函数时都会发生变化。<strong class="ka ir">不适合箭头功能。</strong></p><p id="0cf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们详细过一遍。</p><p id="d8ae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在DOM中有两个按钮:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="099a" class="ml lb iq kz b gy mm mn l mo mp">&lt;button class=”button buttonA”&gt;Button&lt;/button&gt;<br/>&lt;button class=”button buttonB”&gt;Button&lt;/button&gt;</span></pre><p id="e4a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当按钮被单击时，我们希望将单词“Button”改为“Button Clicked ”:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="f5f7" class="ml lb iq kz b gy mm mn l mo mp">const buttonActions = {<br/>   changeText: () =&gt; this.innerHTML = “Button Clicked”;<br/>};</span></pre><p id="426a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们用一个<em class="mq">引用</em>到<code class="fe kw kx ky kz b">changeText</code>的方法将事件监听器附加到:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="3cfb" class="ml lb iq kz b gy mm mn l mo mp">document<br/>  .querySelector(“.buttonA”)<br/>  .addEventListener(‘click’, buttonActions.changeText);</span><span id="603e" class="ml lb iq kz b gy ms mn l mo mp">document<br/>  .querySelector(“.buttonB”)<br/>  .addEventListener(‘click’, buttonActions.changeText);</span></pre><p id="d061" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有用吗？号码🙅当我们点击任何按钮时，什么也没有发生。</p><p id="4825" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为在这里使用箭头函数将<code class="fe kw kx ky kz b">this</code>绑定到全局窗口对象，即引用对象的词法范围。</p><p id="6d8e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要通过执行上下文绑定到按钮DOM对象，解决方案是简单地将<code class="fe kw kx ky kz b">changeText</code>绑定到一个常规函数。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="4ec5" class="ml lb iq kz b gy mm mn l mo mp">changeText: function() {<br/>  this.innerHTML = “Button Clicked”;<br/>}</span></pre><p id="012e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">存储的引用调用现在将button DOM对象作为上下文。</p><blockquote class="na nb nc"><p id="7b87" class="jy jz mq ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated"><strong class="ka ir">⏳超时侧注:</strong>为什么使用对函数<code class="fe kw kx ky kz b">buttonActions.changeText</code>的引用而不是直接调用<code class="fe kw kx ky kz b">buttonActions.changeText()</code>？因为我们希望只有当它被点击时才调用函数。否则，当DOM呈现时，<code class="fe kw kx ky kz b">buttonActions.changeText()</code>将被调用。</p></blockquote><p id="c779" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 2。绑定到对象方法的事件回调:</strong></p><p id="980d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个相反的用例是，我们希望执行上下文总是在回调方法上，而不是在DOM对象上。</p><p id="8d62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，常规函数似乎也是这里的选择？是的，但不完全是。</p><p id="8314" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们又有了两个按钮和一个div元素来充当简单的计数器:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="42b4" class="ml lb iq kz b gy mm mn l mo mp">&lt;button class=”button buttonA”&gt;Increase Count&lt;/button&gt;<br/>&lt;button class=”button buttonB”&gt;Decrease Count&lt;/button&gt;</span><span id="63ee" class="ml lb iq kz b gy ms mn l mo mp">&lt;div class=”counter”&gt;&lt;/div&gt;</span></pre><p id="876a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们定义了增加和减少计数器的方法:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="bba5" class="ml lb iq kz b gy mm mn l mo mp">const buttonActions = {<br/>  count: 0,<br/>  increment: function () {<br/>    let n = ++this.count;<br/>    console.log(“counter: “, n);<br/>    document.querySelector(“.counter”).innerHTML = n;<br/>  },</span><span id="0cf6" class="ml lb iq kz b gy ms mn l mo mp">  decrement: function () {<br/>   if(this.count &gt; 0) {<br/>     let n = — this.count;<br/>     console.log(“counter: “, n);<br/>     document.querySelector(“.counter”).innerHTML = n;<br/>   }<br/> }<br/>};</span></pre><p id="e6aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们对这两种方法都使用常规函数，因为我们希望它们共享对<code class="fe kw kx ky kz b">count</code>值的访问。</p><p id="e3d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们附上点击事件作为参考:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="bf5b" class="ml lb iq kz b gy mm mn l mo mp">document<br/>  .querySelector(“.buttonA”)<br/>  .addEventListener(“click”, buttonActions.increment);</span><span id="5990" class="ml lb iq kz b gy ms mn l mo mp">document<br/>  .querySelector(“.buttonB”)<br/>  .addEventListener(“click”, buttonActions.decrement);</span></pre><p id="1919" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">光看这个，我们就知道有问题。🤨</p><p id="d7a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">执行上下文现在是按钮DOM对象本身。如果我们现在运行它，在点击时，我们会看到一个不需要的输出，因为<code class="fe kw kx ky kz b">this.count</code>未定义:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="479a" class="ml lb iq kz b gy mm mn l mo mp">//output: “counter: “ NaN</span></pre><p id="0354" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了解决这个问题，我们有几种解决方案。</p><p id="133d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">解决方案1 </strong> —我们使用<strong class="ka ir"> <em class="mq">显式绑定</em> </strong>来设置回调的上下文。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="240b" class="ml lb iq kz b gy mm mn l mo mp">//Increase button</span><span id="86a7" class="ml lb iq kz b gy ms mn l mo mp">document<br/>  .querySelector(“.buttonA”)<br/>  .addEventListener(“click”, buttonActions.increment.bind(buttonActions));</span></pre><p id="3e5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，通过使用<code class="fe kw kx ky kz b">bind()</code>，我们已经明确地将上下文设置为<code class="fe kw kx ky kz b">buttonActions</code>对象。当我们单击“增加”按钮时，应该会看到所需的变化。这是一种确定而清晰的设置上下文的方式。</p><blockquote class="na nb nc"><p id="76ba" class="jy jz mq ka b kb kc kd ke kf kg kh ki nd kk kl km ne ko kp kq nf ks kt ku kv ij bi translated"><strong class="ka ir">⏳超时提示:</strong>通常对于事件和异步回调，我们使用<code class="fe kw kx ky kz b">bind()</code>，因为它意味着返回一个函数供以后执行。<code class="fe kw kx ky kz b">call()</code>和<code class="fe kw kx ky kz b">apply()</code>用于立即调用一个函数。</p></blockquote><p id="af4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">解决方案2 </strong> —我们实际上可以使用<strong class="ka ir">箭头函数</strong>回退到<strong class="ka ir"> <em class="mq">隐式绑定</em> </strong>并包含buttonActions对象的执行上下文。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="307c" class="ml lb iq kz b gy mm mn l mo mp">//Decrease Button</span><span id="8565" class="ml lb iq kz b gy ms mn l mo mp">document<br/>  .querySelector(“.buttonB”)<br/>  .addEventListener(“click”, () =&gt; buttonActions.decrement());</span></pre><p id="f777" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">减少计数按钮现在也可以正常工作了。因为箭头函数回调没有<code class="fe kw kx ky kz b">this</code>上下文，所以JavaScript将隐含地推断执行上下文是<code class="fe kw kx ky kz b">decrement</code>所属的对象(buttonActions)。</p><p id="ab58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这同样清晰简洁。</p><p id="5246" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">解决方案3 </strong> —在按钮元素上使用<strong class="ka ir">内联事件处理程序</strong>。🙃</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="eaa4" class="ml lb iq kz b gy mm mn l mo mp">&lt;button onclick=”buttonActions.increment()”&gt;Increase Count&lt;/button&gt;&lt;button onclick=”buttonActions.decrement()”&gt;Decrease Count&lt;/button&gt;</span></pre><p id="7439" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，这是一个解决方案，但如果我们的HTML元素不能使用任何事件处理程序属性，那么不推荐使用它，也不太可能有用。</p><p id="af23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尽管如此，我想我会把这个扔进去玩玩！并指出另一个潜在的困惑。</p><p id="d3b4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你阅读关于<a class="ae mr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#In_an_inline_event_handler" rel="noopener ugc nofollow" target="_blank">内联事件处理器</a>的API参考文档，它说:</p><p id="7867" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mq"> &gt;当代码被内联事件处理程序调用时，它的this被设置为放置监听器的DOM元素。</em></p><p id="b449" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们怎么能指望<code class="fe kw kx ky kz b">onclick=”buttonActions.increment()”</code>像当时那样工作呢？</p><p id="d608" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为内联事件处理程序作为匿名常规函数执行，并返回提供的回调函数。</p><p id="777d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它相当于这样的东西:</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="bd00" class="ml lb iq kz b gy mm mn l mo mp">var inlineEventHandler = function() {<br/>  return buttonActions.increment()<br/>}</span><span id="d6e0" class="ml lb iq kz b gy ms mn l mo mp">// when user invoke the event on the button</span><span id="6ff8" class="ml lb iq kz b gy ms mn l mo mp">inlineEventHandler();</span></pre><p id="a2b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，如果我们将<code class="fe kw kx ky kz b">this</code>作为参数传递给<code class="fe kw kx ky kz b">buttonActions.increment(this)</code>来注销它，我们会看到参数的值确实是DOM对象按钮。因为来自匿名函数的<code class="fe kw kx ky kz b">this</code>确实属于它的执行上下文，按钮。</p><p id="51a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，<code class="fe kw kx ky kz b">increment</code>方法内部引用的<code class="fe kw kx ky kz b">this</code>本身是<em class="mq">隐式</em>绑定到其执行上下文<code class="fe kw kx ky kz b">buttonActions</code>对象。</p><p id="8950" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，正则函数的执行上下文可以在分配给对象后隐式设置。</p><p id="7a50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好玩吧。当然了。</p><p id="15c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一个有趣的问题——</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="3199" class="ml lb iq kz b gy mm mn l mo mp">var logName = {<br/>  name: 'Jon',<br/>  say: function() {<br/>   console.log(this.name)<br/> }<br/>};</span><span id="404d" class="ml lb iq kz b gy ms mn l mo mp">var setLogName = {<br/>  name: 'Dany',<br/>  say: logName.say<br/>}</span><span id="5bec" class="ml lb iq kz b gy ms mn l mo mp">&lt;button onclick=”setLogName.say()”&gt;Say Name&lt;/button&gt;</span></pre><p id="8f88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">控制台中的输出是什么？</p><p id="bbb9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是<code class="fe kw kx ky kz b">Dany</code>。</p></div><div class="ab cl mt mu hu mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ij ik il im in"><p id="3dde" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经大致了解了函数。不仅探究了<em class="mq"/><strong class="ka ir">常规</strong>和<strong class="ka ir">箭头</strong>功能的不同，还探究了<em class="mq">为什么</em>重要的是掌握它们对改变上下文和范围的影响。</p><p id="50c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里涉及的主题将在下一篇关于<strong class="ka ir">类函数</strong>和<strong class="ka ir">工厂函数</strong>的优缺点的<a class="ae mr" href="https://medium.com/javascript-in-plain-english/class-factory-and-object-prototypes-b4a7fff7dba8" rel="noopener">文章中直接有用。</a></p><div class="ng nh gp gr ni nj"><a href="https://medium.com/javascript-in-plain-english/class-factory-and-object-prototypes-b4a7fff7dba8" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">JavaScript中的类、工厂和对象原型</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">类和工厂函数中的对象原型继承。</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jw nj"/></div></div></a></div><h2 id="b085" class="ml lb iq bd lc ny nz dn lg oa ob dp lk kj oc od lo kn oe of ls kr og oh lw oi bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="4241" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae mr" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ka ir">AI in Plain English</strong></a>，<a class="ae mr" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ka ir">UX in Plain English</strong></a>，<a class="ae mr" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ka ir">Python in Plain English</strong></a><strong class="ka ir"/>——谢谢，继续学习！</p><p id="dda9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae mr" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">submissions @ plain English . io</strong></a><strong class="ka ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>