<html>
<head>
<title>How to Write Better and Secure JavaScript Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何写出更好更安全的JavaScript代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/error-handling-simplified-javascript-8c4c96c8377f?source=collection_archive---------2-----------------------#2020-09-19">https://javascript.plainenglish.io/error-handling-simplified-javascript-8c4c96c8377f?source=collection_archive---------2-----------------------#2020-09-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/5b3889529c13f6e1428dc109f5f1e06e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xe7Z_KiUCiwSNKDg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Photo by <a class="ae ja" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="f803" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript是一种动态语言。这使得JavaScript一开始就是一种非常酷的语言。然而，很难写出更好更安全的代码。一个小错误会导致更大的问题。错误处理在减少错误数量方面起着至关重要的作用。如果你以优雅的方式处理错误，将来会节省很多时间。所以更大的问题是你应该如何处理这个错误。</p><p id="d384" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们举一个例子。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="1d1d" class="lh li jd ld b gy lj lk l ll lm">const express = require("express")<br/>const app = express()<br/>app.get("/", (_, res) =&gt; res.end("OK"))</span><span id="6ea8" class="lh li jd ld b gy ln lk l ll lm">app.listen(80)</span></pre><p id="1fa7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码是在一个<a class="ae ja" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> express </a>框架上用nodejs编写的示例代码。在这段代码中，我试图在端口80运行一个服务器。</p><p id="2dfb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">问题:</strong></p><ol class=""><li id="64cf" class="lo lp jd kc b kd ke kh ki kl lq kp lr kt ls kx lt lu lv lw bi translated">如果我们知道端口80已经被其他应用程序占用，并且我们试图运行上面的代码，那该怎么办？</li><li id="51a9" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">我们怎么知道会发生什么？</li><li id="c8f7" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">它会运行还是会出错而中断？</li></ol><p id="148d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看到这段代码时，输出非常不清楚。即使您想处理一个错误，您可能也必须阅读文档。但是不用担心，就像任何自然语言一样。编程语言有一些语法。</p><p id="1108" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mc"> ECMA，没有特别提到的规格/标准。然而，JavaScript社区遵循一定的编码准则。</em></p><h2 id="d9c9" class="lh li jd bd md me mf dn mg mh mi dp mj kl mk ml mm kp mn mo mp kt mq mr ms mt bi translated"><strong class="ak"> 1。错误类型</strong></h2><p id="35e2" class="pw-post-body-paragraph ka kb jd kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">因为JavaScript具有不同的编译器风格，并且大多数由不同的组织编写和维护。除了<a class="ae ja" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError" rel="noopener ugc nofollow" target="_blank"> SyntaxError </a>之外，错误类型之间没有非常明确或一致的分布。甚至消息也因编译器而异。然而，你可以在这里找到语法错误<a class="ae ja" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError" rel="noopener ugc nofollow" target="_blank">的列表。</a></p><p id="5857" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">注意:</strong> JavaScript是一种动态语言，大部分错误都是运行时错误。</p><p id="e653" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">例如:</strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a099" class="lh li jd ld b gy lj lk l ll lm">console.log(Number(10).toPrecision(200))</span></pre><p id="fec5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们运行上面的代码，它将抛出<strong class="kc je"> RangeError </strong>。</p><p id="f1c8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mz na nb ld b">RangeError: toPrecision() argument must be between 1 and 100</code></p><h2 id="304a" class="lh li jd bd md me mf dn mg mh mi dp mj kl mk ml mm kp mn mo mp kt mq mr ms mt bi translated">2.如何处理错误</h2><p id="26c8" class="pw-post-body-paragraph ka kb jd kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">基于API(方法)调用同步/异步的性质，错误可以被不同地处理。</p><h2 id="f5a9" class="lh li jd bd md me mf dn mg mh mi dp mj kl mk ml mm kp mn mo mp kt mq mr ms mt bi translated">2.1 <strong class="ak">同步</strong></h2><p id="23b5" class="pw-post-body-paragraph ka kb jd kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated"><strong class="kc je">试捕:</strong>你可以用一个<a class="ae ja" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch" rel="noopener ugc nofollow" target="_blank">试捕</a>块来处理<strong class="kc je">同步</strong>错误。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="4880" class="lh li jd ld b gy lj lk l ll lm">try {<br/>  console.log(Number(10).toPrecision(200));<br/>} catch (error) {<br/>  <strong class="ld je">// RangeError: toPrecision() argument must be between 1 and 100</strong><br/>  console.log(error <strong class="ld je">instanceof</strong> RangeError); // <strong class="ld je">true</strong><br/>}</span></pre><p id="7076" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mc">如果不想捕捉错误并执行任何操作。在较新版本的JavaScript编译器中，您可以这样做。</em></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0581" class="lh li jd ld b gy lj lk l ll lm">try {<br/>  console.log(Number(10).toPrecision(200));<br/>} catch {}</span></pre><p id="b2a4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果想对error执行一些默认操作，可以在catch块后使用<strong class="kc je"> finally </strong> <strong class="kc je">块</strong>。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="fe76" class="lh li jd ld b gy lj lk l ll lm">let average;<br/>try {<br/>  average = getAverage(); // Sum function does not exits.<br/>} catch {<br/>} <strong class="ld je">finally {<br/>  average = 0;<br/>}</strong><br/>console.log(`Average is ${average}`);<br/>// Average is 0</span></pre><p id="1baf" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后块主要用来清理资源像一些<strong class="kc je">打开文件</strong>，<strong class="kc je">打开</strong> <strong class="kc je">连接</strong>。</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nc"><img src="../Images/b10d323f60d4585f54e928cc54744e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VB_fvm1LnN39nOcg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Photo by <a class="ae ja" href="https://unsplash.com/@nordwood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">NordWood Themes</a> on <a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="95da" class="lh li jd bd md me mf dn mg mh mi dp mj kl mk ml mm kp mn mo mp kt mq mr ms mt bi translated"><strong class="ak"> 2.2异步</strong></h2><p id="b61c" class="pw-post-body-paragraph ka kb jd kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">当结果出现在EventLoop的下一个事件周期时，API在本质上被称为异步的。通常，所有网络调用和IO操作本质上都是异步的。</p><p id="e337" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了收集异步调用的结果，我们或者使用一个<strong class="kc je">回调</strong>或者<strong class="kc je">承诺</strong>对象。</p><p id="933c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">异步回调API(callback-error-data)中错误处理:</strong>基于核心浏览器的JavaScript具有非常有限的异步API。你可以使用定时器API创建一个异步函数，比如<strong class="kc je"> setTimeout </strong>和<strong class="kc je"> setInterval。</strong>您还可以使用AJAX调用请求服务器(使用<strong class="kc je"> fetch) </strong>。<strong class="kc je"> setTimeout </strong>和<strong class="kc je"> setInterval </strong>不抛出任何可以处理的错误。并且<strong class="kc je"> fetch </strong>是一个基于承诺的异步调用<em class="mc">(我们将在后面学习如何处理基于承诺的错误)</em>。然而，nodejs有很多标准和第三方API，这会引发一个错误。就像我们的第一个<strong class="kc je"> express.js </strong>例子一样。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="69db" class="lh li jd ld b gy lj lk l ll lm">const express = require("express");<br/>const app = express();<br/>app.get("/", (_, res) =&gt; res.end("OK"));</span><span id="72d0" class="lh li jd ld b gy ln lk l ll lm">const server = app.listen(80);<br/>server.on("error", function handleListen(error) {<br/>  console.log(error);<br/>});</span></pre><p id="6c2e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，Express没有试图为您处理错误。相反，它返回nodejs的核心<a class="ae ja" href="https://nodejs.org/api/http.html#http_event_clienterror" rel="noopener ugc nofollow" target="_blank">服务器</a>实例。您可以在错误<strong class="kc je">处理程序回调函数</strong>上捕获错误。</p><p id="ca22" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Nodejs遵循一定的规则。作为<a class="ae ja" href="https://nodejs.org/api/errors.html" rel="noopener ugc nofollow" target="_blank">编码标准</a>，所有的异步API都接受回调。在回调中，第一个参数是API生成的错误，第二个参数是成功的数据。这个标准也被整个社区所遵循。</p><p id="d370" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看到这种模式，我们可以如下处理错误</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="3317" class="lh li jd ld b gy lj lk l ll lm">fs.readFile('a file that does not exist', (err, data) =&gt; {<br/>  if (err) {<br/>    console.error('There was an error reading the file!', err);<br/>    return;<br/>  }<br/>  // Otherwise handle the data<br/>});</span></pre><p id="43dd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">注意:</strong>你不能在<strong class="kc je"> try-catch </strong>块中处理异步回调错误。然而，有一个例外。ECMA脚本的最新版本，使用异步等待现在我们可以处理try-catch中的错误。我们稍后会了解这一点。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="739f" class="lh li jd ld b gy lj lk l ll lm">// This will not work</span><span id="8030" class="lh li jd ld b gy ln lk l ll lm">try {<br/>  app.listen(80);<br/>} catch (error) {<br/>  // never called<br/>  console.error(error)<br/>}</span></pre><p id="3f7a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">基于承诺API中的错误处理(promise-then-catch): </strong>在ES5之后，JavaScript引入了一种新的设计模式来处理异步API的回调。那是一个<a class="ae ja" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺的设计图案</a>。这就解决了前一期的<a class="ae ja" href="https://www.bmc.com/blogs/callback-hell/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc je">回调地狱</strong> </a>。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5de2" class="lh li jd ld b gy lj lk l ll lm">const promise = new Promise((response, reject) =&gt; {<br/>  // some async code here<br/>});</span><span id="c84c" class="lh li jd ld b gy ln lk l ll lm">promise<br/>  .then(function onSuccess(data) {<br/>    console.log("SUCCESS");<br/>  })<br/>  .catch(function onError(err) {<br/>    console.error(err);<br/>  });</span></pre><p id="c23a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了捕捉来自promise对象的错误，您必须使用<strong class="kc je"> catch </strong>方法并传递一个回调函数。要了解<a class="ae ja" href="https://www.tothenew.com/blog/angularjs-deferred-promises-basic-understanding/" rel="noopener ugc nofollow" target="_blank">承诺/延期模式</a>，可以在这里阅读我的博客<a class="ae ja" href="https://www.tothenew.com/blog/angularjs-deferred-promises-basic-understanding/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="d9c2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">在使用async-await(try-catch-await)基于承诺的API中的错误处理:</strong>承诺比回调干净得多。然而，理解一个大代码库中的流程是非常困难的。ECMA脚本的最新版本引入了<a class="ae ja" href="https://javascript.info/async-await" rel="noopener ugc nofollow" target="_blank">异步等待</a>。使用async-await，我们可以同步编写异步代码。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f37d" class="lh li jd ld b gy lj lk l ll lm">async function main() {<br/>  try {<br/>    await promise1;<br/>    const data = await promise2;<br/>  } catch (error) {<br/>    console.log(error); // SOME ERROR<br/>  }<br/>}<br/>main();</span></pre><p id="3a58" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<strong class="kc je"> try-catch-await </strong>，您可以在一个块中处理多个错误，这在<strong class="kc je"> promise-then-catch </strong>模式中是不可能/复杂的。</p><p id="1847" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们知道如何处理错误了。然而，在编写代码时，我们不必只处理错误。我们可能想要创建一个自定义错误。这将有助于编写干净和可维护的代码。这是一个很好的实践，您应该为业务逻辑创建自定义错误</p><figure class="ky kz la lb gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nd"><img src="../Images/873d10e7c9ca73fdebfe6fb38a45a63d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xETNVRQX05UU0UZM"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Photo by <a class="ae ja" href="https://unsplash.com/@isisfra?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Isis França</a> on <a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="66b7" class="lh li jd bd md me mf dn mg mh mi dp mj kl mk ml mm kp mn mo mp kt mq mr ms mt bi translated">3.创建自定义错误</h2><p id="fde8" class="pw-post-body-paragraph ka kb jd kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">创建自定义错误非常简单。您可以使用任何自定义类，并将其作为错误抛出。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="84b4" class="lh li jd ld b gy lj lk l ll lm">class SomeNetworkError {<br/>  constructor(status) {<br/>    this.status = status;<br/>  }<br/>}<br/>try {<br/>  throw new SomeNetworkError(4000);<br/>} catch (error) {</span><span id="2f71" class="lh li jd ld b gy ln lk l ll lm">  console.log(error instanceof SomeNetworkError); // true</span><span id="b072" class="lh li jd ld b gy ln lk l ll lm">  console.log(`SomeNetworkError Status: ${error.status}`); // SomeNetworkError Status: 4000</span><span id="eb4a" class="lh li jd ld b gy ln lk l ll lm">}</span></pre><p id="779b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面我们有一个类，我们使用这个类的一个实例来抛出一个错误。这是一个有效的代码。然而，作为编码实践，我们应该扩展默认(标准)错误类。所有错误类的基础是<a class="ae ja" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Constructor" rel="noopener ugc nofollow" target="_blank">错误</a>并使用消息调用一个超级方法。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7610" class="lh li jd ld b gy lj lk l ll lm">class SomeNetworkError extends Error {<br/>  constructor(message, status) {<br/>    super(message);<br/>    this.status = status;<br/>  }<br/>}<br/>try {<br/>  throw new SomeNetworkError("Network Error", 4000);<br/>} catch (error) {</span><span id="e2ac" class="lh li jd ld b gy ln lk l ll lm">  console.error(error instanceof Error); // true<br/>  console.log(`&gt; ${error}`); // &gt; Error: Network Error<br/>  console.error(error); // SomeNetworkError: Network Error<br/>  console.error(error.stack); <em class="mc">// stacktrace here</em></span><span id="39c9" class="lh li jd ld b gy ln lk l ll lm">}</span></pre><p id="702d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您注意到，扩展Error类并调用super会自动获得。SomeNetworkError类的toString方法。它打印了一个很好的信息。类似地，您也可以扩展其他标准错误类。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="c483" class="lh li jd ld b gy lj lk l ll lm">class ArithmeticRangeError extends RangeError {<br/>  constructor(message) {<br/>    super(message);<br/>  }<br/>}<br/>try {<br/>  const zero = 0;<br/>  if (zero === 0) {<br/>    throw new ArithmeticRangeError("zero cant be 0");<br/>  }<br/>} catch (error) {<br/>  console.log(error instanceof RangeError); // true<br/>  console.error(error.toString()); // RangeError: zero cant be 0<br/>}</span></pre><h2 id="5dd9" class="lh li jd bd md me mf dn mg mh mi dp mj kl mk ml mm kp mn mo mp kt mq mr ms mt bi translated">4.高级错误处理</h2><p id="b338" class="pw-post-body-paragraph ka kb jd kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">使用循环处理错误:如果您想在错误时中断循环，请将try-catch排除在循环之外。否则将try-catch放入循环中继续</p><p id="ce3e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mc">出错时中断:</em></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="18f5" class="lh li jd ld b gy lj lk l ll lm">try { <br/>  const numbers = [10, 2, 0, 5];<br/>  numbers.forEach((num) =&gt; {<br/>    if (num === 0) {<br/>      throw new ArithmeticRangeError("zero cant be 0");<br/>    }<br/>    console.log(num);<br/>  });<br/>} catch (error) {} <br/></span></pre><p id="3f6d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mc">出错时继续或跳过:</em></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="5658" class="lh li jd ld b gy lj lk l ll lm">const numbers = [10, 2, 0, 5];<br/>numbers.forEach((num) =&gt; {<br/>  try {<br/>    if (num === 0) {<br/>      throw new ArithmeticRangeError("zero cant be 0");<br/>    }<br/>  } catch (error) {}<br/>  console.log(num);<br/>});</span></pre><p id="2538" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mc">无试抓，逻辑处理:</em></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="0fe6" class="lh li jd ld b gy lj lk l ll lm">// filter zero, no need handle zero</span><span id="0d6f" class="lh li jd ld b gy ln lk l ll lm">const numbers = [10, 2, 0, 5].filter((num) =&gt; num !== 0);<br/>numbers.forEach((num) =&gt; {<br/>  console.log(num);<br/>});</span><span id="b149" class="lh li jd ld b gy ln lk l ll lm">// Use some to break loop</span><span id="7594" class="lh li jd ld b gy ln lk l ll lm">const numbers = [10, 2, 0, 5];</span><span id="2c7d" class="lh li jd ld b gy ln lk l ll lm">numbers.some((num) =&gt; {<br/>  const isZero = num === 0;<br/>  if (isZero) return true;<br/>  // logic here<br/>  console.log(num);<br/>});</span></pre><p id="647b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，根据您的需要，您可能不需要总是抛出错误。逻辑上可以处理。</p><p id="7334" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">try-catch中的多个错误:</strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="26ce" class="lh li jd ld b gy lj lk l ll lm">try {<br/>  let name ;<br/>  /// some operation<br/>  if (name === "") throw new RangeError("Cant be blank");<br/>  if (name.match(/\W/)) throw new TypeError("name cant be non alph-numric");<br/>  throw new Error("Some other error");<br/>} catch (error) {<br/>  if (<strong class="ld je">error instanceof RangeError</strong>) console.log("RangeError");<br/>  else if (<strong class="ld je">error instanceof TypeError</strong>) console.log("TypeError");<br/>  else console.log("Other Error");<br/>}</span></pre><p id="e8cd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">先承诺后兑现中的多个错误:</strong></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="7f4b" class="lh li jd ld b gy lj lk l ll lm">new Promise((resolve) =&gt; {<br/>  let name;<br/>  // some logic<br/>  resolve(name);<br/>})<br/>  .then((name) =&gt; {<br/>    if (name === "") throw new RangeError("Cant be blank");<br/>    else return name;<br/>  })<br/>  .then((name) =&gt; {<br/>    if (name.match(/\W/)) throw new TypeError("name cant be non alph-numric");<br/>    else return name;<br/>  })<br/>  .catch((error) =&gt; {<br/>    if (error instanceof RangeError) console.log("RangeError");<br/>    else if (error instanceof TypeError) console.log("TypeError");<br/>    else console.log("Other Error");<br/>  });</span></pre><h2 id="bb8e" class="lh li jd bd md me mf dn mg mh mi dp mj kl mk ml mm kp mn mo mp kt mq mr ms mt bi translated"><strong class="ak"> 5。错误处理编码实践</strong></h2><p id="4015" class="pw-post-body-paragraph ka kb jd kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">以上所有代码都是非常标准和简单的错误处理用例。然而，当你在项目中工作时。代码可能没有这里给出的那么简单。所以我们需要写一些样板代码。下面，我列出了我在项目中遵循的一些模式。</p><ol class=""><li id="f26c" class="lo lp jd kc b kd ke kh ki kl lq kp lr kt ls kx lt lu lv lw bi translated">创建<strong class="kc je">枚举</strong>类或错误<strong class="kc je">常量</strong></li><li id="0731" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">从头开始使用<strong class="kc je">定位</strong></li><li id="0b61" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">通用<strong class="kc je"> util模块或文件</strong>处理逻辑并产生错误</li><li id="287b" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">尽量减少的尝试性使用，而不是编写更多的单元测试用例</li><li id="052e" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">在API调用中捕获并抛出一个定制错误<strong class="kc je"/></li><li id="3984" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">使用<strong class="kc je">类型脚本</strong>减少错误</li><li id="686a" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">尽量减少使用幻数/字符串</li><li id="97dc" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">避免更高层次的<strong class="kc je">嵌套对象</strong></li><li id="81c0" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">避免全球<strong class="kc je">物体污染</strong></li><li id="4ddb" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">尽可能多地使用<strong class="kc je"> E </strong> <a class="ae ja" href="https://reactjs.org/docs/error-boundaries.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kc je">错误界限</strong> </a>(反应)</li><li id="4830" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">正确记录，使用<strong class="kc je">控制台。错误</strong>进行错误记录。</li><li id="f7b5" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated"><strong class="kc je">日志级别</strong>最小化日志消息</li><li id="441c" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">不要在日志中打印<strong class="kc je">凭证</strong></li><li id="e654" class="lo lp jd kc b kd lx kh ly kl lz kp ma kt mb kx lt lu lv lw bi translated">在网络应用中，使用<strong class="kc je">比控制台更多的视觉效果</strong>。</li></ol><h2 id="b193" class="lh li jd bd md me mf dn mg mh mi dp mj kl mk ml mm kp mn mo mp kt mq mr ms mt bi translated"><strong class="ak"> 6。结论</strong></h2><p id="84b9" class="pw-post-body-paragraph ka kb jd kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">如您所见，有许多模式和实践可以遵循来改进您的代码库。这将减少代码中的错误。和应用程序的整体性能。</p><p id="4aa9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望你喜欢这篇文章。让我们写一个干净安全的代码。</p></div></div>    
</body>
</html>