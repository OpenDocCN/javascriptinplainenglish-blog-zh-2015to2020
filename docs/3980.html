<html>
<head>
<title>Creating a YouTube ‘Latest Video Viewer’ with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React创建YouTube的“最新视频浏览器”</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-a-youtube-latest-video-viewer-with-react-9d04161c51b3?source=collection_archive---------5-----------------------#2020-11-07">https://javascript.plainenglish.io/creating-a-youtube-latest-video-viewer-with-react-9d04161c51b3?source=collection_archive---------5-----------------------#2020-11-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9da2d30ab8bd9935694af59c693ef616.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y25NKhKSdJnqHNNEEM7hhQ.jpeg"/></div></div></figure><p id="259f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本教程中，我们将使用React的一些基础知识，包括React挂钩来构建一个简单的应用程序，列出特定频道的最新YouTube视频。</p><p id="c24f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="kt">本文基于一段视频教程来自</em> <a class="ae ku" href="https://youtube.com/juniordevelopercentral" rel="noopener ugc nofollow" target="_blank"> <em class="kt">我自己的YouTube频道</em> </a> <em class="kt">其中你</em> <a class="ae ku" href="https://youtu.be/X6GpRxu4q_s" rel="noopener ugc nofollow" target="_blank"> <em class="kt">可以在这里查看</em> </a> <em class="kt">。这里可以看到</em> <a class="ae ku" href="https://upbeat-hopper-d3563b.netlify.app/" rel="noopener ugc nofollow" target="_blank"> <em class="kt">项目的一个demo</em></a><em class="kt">。</em></p><figure class="kw kx ky kz gt jo gh gi paragraph-image"><div class="gh gi kv"><img src="../Images/7ba4cb4f5608f43d266a482847385e15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/1*X4-Ssg1JmI4sCukTmQ4doA.gif"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Example of the completed APP</figcaption></figure><p id="bd6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该应用程序的工作原理是利用YouTube的RSS源，提取视频信息，包括缩略图和标题等。</p><h1 id="a888" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">入门</strong></h1><p id="1375" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">因此，我们需要一个能够理解和编译React和JSX代码的开发环境。如果你熟悉的话，你可以用<strong class="jx io"> create-react-app </strong>创建一个新的应用，或者你可以从<a class="ae ku" href="https://github.com/codebubb/react-starter" rel="noopener ugc nofollow" target="_blank">这里</a>克隆我的React starter，这是我在视频教程中使用的。</p><p id="220b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的应用程序需要一些组件，所以在您的<code class="fe mh mi mj mk b">src</code>文件夹中，让我们为我们的主应用程序创建<code class="fe mh mi mj mk b">App.js</code>，为我们的表单字段创建<code class="fe mh mi mj mk b">Search.js</code>来查找特定的YouTube频道，创建<code class="fe mh mi mj mk b">Video.js</code>来显示来自RSS提要的单个条目。</p><p id="81fc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们也为我们的Sass <code class="fe mh mi mj mk b">App.scss</code>创建一个SCSS文件和一个<code class="fe mh mi mj mk b">index.js</code>文件来引导应用程序。</p><h1 id="6ccf" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">运行正常的</h1><p id="ff75" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">让我们通过在<code class="fe mh mi mj mk b">index.js</code>文件中设置我们的React应用程序来为我们的项目做些准备和运行:</p><figure class="kw kx ky kz gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><ul class=""><li id="ff53" class="mn mo in jx b jy jz kc kd kg mp kk mq ko mr ks ms mt mu mv bi translated">第1行:这是Webpack在最终版本中包含我们的<code class="fe mh mi mj mk b">index.html</code>文件的额外一行。</li><li id="2fb8" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第3–4行:导入React库。</li><li id="392f" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第5行:这里我们正在导入我们的<code class="fe mh mi mj mk b">App</code>组件(这会很可能导致不稳定，因为这个文件中什么都没有)。</li><li id="f1c8" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第8行:这里我们获得了对HTML页面中一个元素的引用，该元素将用于安装React应用程序。</li><li id="157e" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第10行:将我们的<code class="fe mh mi mj mk b">App</code>组件呈现给上面的HTML元素。</li></ul><p id="053d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们需要在我们的<code class="fe mh mi mj mk b">App.js</code>文件中放一些东西来创建我们的<code class="fe mh mi mj mk b">App</code>组件。</p><figure class="kw kx ky kz gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><ul class=""><li id="8817" class="mn mo in jx b jy jz kc kd kg mp kk mq ko mr ks ms mt mu mv bi translated">第1行:我们正在导入React以及<code class="fe mh mi mj mk b">useState</code>和<code class="fe mh mi mj mk b">useEffect</code>钩子，我们很快就会用到它们。</li><li id="91ab" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第3行:导出App组件，这样它就可以被导入到我们的<code class="fe mh mi mj mk b">index.js</code>文件中。</li><li id="6ceb" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第4–9行:使用函数式React组件，我们可以只返回一些JSX。</li></ul><p id="77e7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从终端，我们可以通过服务应用程序来测试一切是否正常:</p><pre class="kw kx ky kz gt nb mk nc nd aw ne bi"><span id="3a13" class="nf lf in mk b gy ng nh l ni nj">npm run serve</span></pre><figure class="kw kx ky kz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/5b1d71f51ef02c0babcc0e972f595712.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFp4SKwCJM8Zg6Y2pfsqjA.png"/></div></div></figure><p id="fecc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦开发服务器运行，当导航到<code class="fe mh mi mj mk b"><a class="ae ku" href="http://localhost:3020" rel="noopener ugc nofollow" target="_blank">http://localhost:3020</a></code>时，您应该会看到上面的页面</p><p id="20bc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您使用另一个设置，而不是我前面提到的React starter repo，请确保运行相关的serve命令并导航到您的配置使用的地址。</p><h1 id="b7a4" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设置搜索组件</h1><p id="f3fc" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">我们的搜索组件将有一个输入文本字段和一个按钮，基本上负责接受用户试图查看的频道ID，然后将其传递回<code class="fe mh mi mj mk b">App</code>组件，该组件将发出获取数据的请求。</p><figure class="kw kx ky kz gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><ul class=""><li id="8962" class="mn mo in jx b jy jz kc kd kg mp kk mq ko mr ks ms mt mu mv bi translated">第3行:我们将<code class="fe mh mi mj mk b">Search</code>创建为传递了<code class="fe mh mi mj mk b">props</code>对象的功能组件。</li><li id="89ce" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第4行:这里我们使用<code class="fe mh mi mj mk b">useState</code> React钩子创建一个名为<code class="fe mh mi mj mk b">channelId</code>的新状态项。当使用<code class="fe mh mi mj mk b">useState()</code>时，我们可以析构实际的状态值以及相应的setter(在本例中是<code class="fe mh mi mj mk b">setChannelId</code>)来管理状态值</li><li id="2b04" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第8行:当创建输入字段时，我们将一个函数传递给<code class="fe mh mi mj mk b">onChange</code>事件，当用户在输入中键入内容时，该事件将被触发。该功能实际上使用<code class="fe mh mi mj mk b">setChannelId.</code>更新<code class="fe mh mi mj mk b">channelId</code>状态值</li><li id="46a1" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第9行:如果用户没有输入任何东西，我们可以利用<code class="fe mh mi mj mk b">channelId</code>状态值来禁用按钮，当用户点击按钮时，我们将调用<code class="fe mh mi mj mk b">props</code>对象上传入的另一个函数，<code class="fe mh mi mj mk b">setCurrentChannelId</code>将存储在<code class="fe mh mi mj mk b">channelId</code>中的值从<code class="fe mh mi mj mk b">Search</code>组件传递回<code class="fe mh mi mj mk b">App</code>组件。</li></ul><p id="d99e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们将<code class="fe mh mi mj mk b">Search</code>组件添加到我们的<code class="fe mh mi mj mk b">App</code>模板中，并在props上传递该函数，以处理当用户单击搜索按钮时返回的数据。</p><figure class="kw kx ky kz gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><ul class=""><li id="eeaa" class="mn mo in jx b jy jz kc kd kg mp kk mq ko mr ks ms mt mu mv bi translated">第2行:导入我们刚刚更新的<code class="fe mh mi mj mk b">Search</code>组件。</li><li id="0c7a" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第5行:为<code class="fe mh mi mj mk b">App</code>组件设置一点状态，它将保存用户查找的当前频道</li><li id="6ee6" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第10行:将<code class="fe mh mi mj mk b">Search</code>组件添加到我们的JSX模板中，并传入一个<code class="fe mh mi mj mk b">setCurrentChannelId</code>属性，该属性接受一个函数(当用户按下<code class="fe mh mi mj mk b">Search</code>组件中的按钮时将被调用)并用从<code class="fe mh mi mj mk b">Search</code>组件传回的值更新<code class="fe mh mi mj mk b">currentChannelId</code>状态。</li></ul><figure class="kw kx ky kz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/9f3fdb5af346df214f9910663f0fb189.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JceIB8aU4zVbAI8zk8bokA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">The App with the Search Component added</figcaption></figure><h1 id="0132" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">视频组件</h1><p id="4c6c" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">在我们获取一些数据并将其显示给用户之前，让我们设置一个组件，该组件将显示每个视频的缩略图和标题，以及YouTube上该视频的链接。</p><figure class="kw kx ky kz gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><ul class=""><li id="769c" class="mn mo in jx b jy jz kc kd kg mp kk mq ko mr ks ms mt mu mv bi translated">第7行:我们以这种方式手动构建缩略图，这样我们可以得到“中等质量”的缩略图，这样我们的图像可以快速加载</li></ul><p id="9bd5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">组件<code class="fe mh mi mj mk b">Video</code>只是一个模板，我们将通过组件的<code class="fe mh mi mj mk b">props</code>向其传递一个视频对象。从YouTube RSS提要返回的数据将具有像<code class="fe mh mi mj mk b">link</code>、<code class="fe mh mi mj mk b">guid</code>和<code class="fe mh mi mj mk b">title</code>这样的属性，我们可以用它们来构造模板。当我们在下一步中检索数据时，您将看到所有这些属性。</p><h1 id="e5d8" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">检索YouTube视频数据</h1><p id="a9d8" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">因此，YouTube提供了一个频道的RSS提要，但数据是XML格式的。例如，我的频道是<a class="ae ku" href="https://www.youtube.com/feeds/videos.xml?channel_id=UCuvTObpdx__W966kbdIZ4_Q" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/feeds/videos.xml?channel _ id = UCuvTObpdx _ _ w 966 kbdiz 4 _ Q</a></p><p id="486b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是XML数据在前端并不方便(我们已经习惯了所有的东西都是JSON ),所以我们可以自己解析XML或者使用服务来完成这项工作。为了简洁起见，在教程中，我使用了一个服务(<a class="ae ku" href="https://rss2json.com" rel="noopener ugc nofollow" target="_blank"> rss2json </a>)。com)来做到这一点。</p><figure class="kw kx ky kz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/21a526b1011c073d2192dfb72937c642.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W0dVgZRh7HgHB_HRWKqgmA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Converting the XML feed to JSON with rss2json.com</figcaption></figure><p id="34e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，该服务允许您粘贴一个RSS URL，并返回XML的JSON等价物。</p><p id="8a6b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，在我们的<code class="fe mh mi mj mk b">App</code>组件中，让我们调用这个端点并将数据保存到我们应用程序的状态中。然后我们可以创建一个<code class="fe mh mi mj mk b">Video</code>组件列表来显示数据。</p><figure class="kw kx ky kz gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><ul class=""><li id="40bd" class="mn mo in jx b jy jz kc kd kg mp kk mq ko mr ks ms mt mu mv bi translated">第3行:不要忘记导入<code class="fe mh mi mj mk b">Video</code>组件</li><li id="cbcc" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第7行:这里我们创建了更多的状态来保存从RSS提要返回的数据</li><li id="797d" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第9行:这是我们将使用用户在<code class="fe mh mi mj mk b">Search</code>组件中输入的<code class="fe mh mi mj mk b">channelId</code>进行调用的基本URL</li><li id="ad63" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第11行:这里我们调用了<code class="fe mh mi mj mk b">useEffect</code> React钩子，如果在<code class="fe mh mi mj mk b">currentChannelId</code>状态中有值，它将调用API端点并将<code class="fe mh mi mj mk b">videos</code>状态设置为响应的<code class="fe mh mi mj mk b">items</code>属性。</li><li id="8cd8" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第22行:我们将<code class="fe mh mi mj mk b">currentChannelId</code>作为第二个参数传递给<code class="fe mh mi mj mk b">useEffect</code>钩子，以便在<code class="fe mh mi mj mk b">currentChannelId</code>的值改变时重新触发它。这样，每当用户输入新的通道ID时，都会再次向API发出请求。</li><li id="38b3" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第29行:最后，为了显示视频列表，我们简单地使用<code class="fe mh mi mj mk b">map</code>遍历所有返回的视频项，并返回一个<code class="fe mh mi mj mk b">Video</code>组件，将整个视频对象作为道具传入，并将视频的<code class="fe mh mi mj mk b">key</code>设置为每个视频特有的<code class="fe mh mi mj mk b">guid</code>属性。</li></ul><p id="9a8c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果我们输入YouTube频道的ID并点击“获取视频”按钮，我们会看到一些结果显示在我们的应用程序中。</p><figure class="kw kx ky kz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nn"><img src="../Images/48b00bd752d5e150eac44dd0fc6c9b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JBeY94m1o3PsK2Gd_gxlFA.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Results from parsed YouTube RSS feed.</figcaption></figure><p id="1bca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们的应用程序现在能够加载YouTube频道最近视频的缩略图和标题，但它的外观可能需要一些工作，所以让我们添加一些样式。</p><h1 id="32ff" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">设计应用程序</h1><p id="a7cb" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">以下是我为应用程序创建的样式。</p><figure class="kw kx ky kz gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="7173" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我保持了非常简单的样式，并且都在一个文件中，所以你可以在一个地方看到它，但是它可以被分解成单独的文件来匹配每个组件。</p><p id="b902" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我导入了<a class="ae ku" href="https://fonts.google.com/specimen/Commissioner" rel="noopener ugc nofollow" target="_blank">专员</a>谷歌字体，但是你可以把它换成别的字体。</p><p id="d5fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">应用样式后，我们的应用程序如下所示:</p><figure class="kw kx ky kz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/192804f2c7599c4456904226ca89ffe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7IbbEA9jxxAydYZoMzkSrw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">The app with styling applied</figcaption></figure><p id="8f60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以把我们的应用程序留在那里，但在从RSS提要中检索数据时，在处理错误方面可以做一些改进。</p><h1 id="cbf4" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">错误处理</h1><p id="2a63" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">最后，让我们创建一个状态来保存从RSS提要请求视频时发生的任何错误。我们将把它放在我们的<code class="fe mh mi mj mk b">App.js</code>组件中。</p><figure class="kw kx ky kz gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><ul class=""><li id="5091" class="mn mo in jx b jy jz kc kd kg mp kk mq ko mr ks ms mt mu mv bi translated">第9行:使用<code class="fe mh mi mj mk b">useState</code>钩子，我们创建新的错误状态</li><li id="abdd" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第24行:如果接收到一个成功的请求，我们将清除之前设置的任何错误消息</li><li id="c347" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第28行:但是如果确实发生了错误，我们将设置一个适当的消息</li><li id="a9ce" class="mn mo in jx b jy mw kc mx kg my kk mz ko na ks ms mt mu mv bi translated">第39行:在JSX中，我们将显示错误</li></ul><p id="07f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，如果我们键入一个无效的频道id，或者向RSS提要发出请求时出现问题，我们会看到错误显示。</p><figure class="kw kx ky kz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi no"><img src="../Images/d864a70eda61ca016db98da9cd2d306f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LUdT2Iw3-HiMEJSqGV4VQg.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Error handling in the app</figcaption></figure><h1 id="b38e" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">结论</h1><p id="61c1" class="pw-post-body-paragraph jv jw in jx b jy mc ka kb kc md ke kf kg me ki kj kk mf km kn ko mg kq kr ks ig bi translated">在本教程中，我们看到了如何使用YouTube RSS提要从频道ID中获取特定YouTube频道的最新视频。</p><p id="901b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用rss2json.com的<a class="ae ku" href="https://rss2json.com" rel="noopener ugc nofollow" target="_blank">服务，我们能够将RSS提要转换成JSON响应。</a></p><p id="0e4c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们创建的应用程序使用了几个React挂钩；用于在组件中设置状态的<code class="fe mh mi mj mk b">useState</code>钩子和用于触发调用的<code class="fe mh mi mj mk b">useEffect</code>钩子，以检索要在应用程序中使用的数据。</p><p id="82ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">考虑您的应用程序将如何处理错误是很重要的，在这个项目中，我们通过捕捉在请求获取特定通道id的JSON数据时发生的错误来做到这一点。</p><p id="485e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读，如果你觉得这个教程有用，请在Twitter( <a class="ae ku" href="https://twitter.com/codebubb" rel="noopener ugc nofollow" target="_blank"> @codebubb </a>)上给我留言。</p></div></div>    
</body>
</html>