<html>
<head>
<title>All you need is mobx-react-lite</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你所需要的就是mobx-react-lite</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/all-you-need-is-mobx-react-lite-47ba0e95e9c8?source=collection_archive---------2-----------------------#2020-09-23">https://javascript.plainenglish.io/all-you-need-is-mobx-react-lite-47ba0e95e9c8?source=collection_archive---------2-----------------------#2020-09-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a569ee13bae043c7596872aab0545edb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ichOrSUWV1J1Lk3r"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@devintavery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Devin Avery</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="c4f6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">MobX的知名度越来越高。减小束尺寸的需求也增加了。不仅如此，我们还寻求在我们的项目中编写更干净和可维护的代码。那么如何才能做到这一点呢？</p><p id="8a0a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自从React团队从v16.8.0发布了hooks我们被引入了一种以函数方式编写组件的好方法。在我个人看来——在悬挂物上使用挂钩看起来干净多了。用钩子从商店中访问数据似乎也更干净。我们倾向于用功能组件编写更少的代码，而不是用类组件编写大块的代码。这是增加代码可维护性的方法之一。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h2 id="4973" class="li lj jg bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">捆绑包大小呢？</h2><p id="846a" class="pw-post-body-paragraph kd ke jg kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">使用轻量级包是减少最终包大小的一个好方法。我们可以通过许多包来实现这一点。还记得用Moment.js吗？我不记得使用它有一段时间了，因为它有一个更大的包大小的替代日期-fns包。即使如此，现在仍然有两倍多的下载量和明星。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mg"><img src="../Images/8cd42db8e2fe2a2a7ebd6b54147d84f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jJz7cpXSTNHAV93hkrSnCA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk"><a class="ae jd" href="https://www.npmtrends.com/moment-vs-date-fns" rel="noopener ugc nofollow" target="_blank">https://www.npmtrends.com/moment-vs-date-fns</a></figcaption></figure><p id="4c98" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Mobx-react-lite是一个轻量级绑定，用于粘合Mobx存储和功能性react组件。它的尺寸更小，但可能没有你想象的那么大。然而，这就是我们所需要的。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/399827cd9679cbc8b6126e2e79f87e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8zNqgTL7YTByQqBOA6eRdg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk"><a class="ae jd" href="https://www.npmtrends.com/mobx-react-vs-mobx-react-lite" rel="noopener ugc nofollow" target="_blank">https://www.npmtrends.com/mobx-react-vs-mobx-react-lite</a></figcaption></figure><h1 id="3a58" class="mm lj jg bd lk mn mo mp ln mq mr ms lq mt mu mv lt mw mx my lw mz na nb lz nc bi translated">我们开始吧</h1><p id="ed5e" class="pw-post-body-paragraph kd ke jg kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">我们需要一个React项目设置和两个依赖项来开始:</p><pre class="mh mi mj mk gt nd ne nf ng aw nh bi"><span id="094c" class="li lj jg ne b gy ni nj l nk nl">yarn add mobx mobx-react-lite</span><span id="adee" class="li lj jg ne b gy nm nj l nk nl">OR</span><span id="c372" class="li lj jg ne b gy nm nj l nk nl">npm install mobx mobx-react-lite</span></pre><p id="25b8" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">举个简单的例子，我们可以用一些动作和值创建一个计数器存储。我使用的Typescript具有支持decorator语法的特性，但是对于我们的例子，使用decorator还是函数并不重要。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="7cc7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了从组件访问商店，我们需要创建商店的实例，当然，以某种方式与组件共享它。React Context非常适合这项任务，我们可以根据需要利用它。让我们用商店实例和上下文包装器创建一个<code class="fe np nq nr ne b">stores.ts</code>文件。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4165" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好。现在我们有了一个<code class="fe np nq nr ne b">stores</code>变量，可以保存Mobx商店的实例。我们冻结这个物体是为了避免它发生任何意想不到的变化。但是，当然，这是一个可选步骤。</p><p id="905f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个基于商店变量的React上下文，还创建了一个商店提供者组件，我们很快就会用到它。</p><p id="3ef4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们用上下文提供者包装器更新根<code class="fe np nq nr ne b">index.tsx</code>文件。遵循以下代码片段。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="c774" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好。在这一点上，我们有一个地方，我们保存我们的商店。我们也有办法与组件共享存储，但不是完全共享。要访问该上下文，我们必须创建两个定制且非常方便的钩子。一个将返回所有商店，另一个返回特定的首选商店。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="e858" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好了，现在我们有了。看到<code class="fe np nq nr ne b">useStore</code>钩子奇怪的类型定义了吗？它将为传递的存储键提供正确的类型。</p><pre class="mh mi mj mk gt nd ne nf ng aw nh bi"><span id="9519" class="li lj jg ne b gy ni nj l nk nl">&lt;T extends keyof typeof stores&gt;<br/>(store: T): typeof stores[T]</span></pre><p id="e472" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有当<code class="fe np nq nr ne b">store</code>变量类型是<code class="fe np nq nr ne b">stores</code>对象的键之一时，我们才会接受它。因此，在我们的例子中，它将只接受一个<code class="fe np nq nr ne b">counterStore</code>字符串，并返回给定商店的相应类型。很好，不是吗？</p><p id="88fe" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，让我们最终从实际的组件中访问存储、它的方法和属性。为此，我们必须用自定义钩子和Mobx Observer包装来修改<code class="fe np nq nr ne b">App.tsx</code>文件。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><p id="4dc2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用它的钥匙进入柜台商店，并得到商店的回报。此外，我们必须将组件包装到<code class="fe np nq nr ne b">observer</code>函数中，以允许组件监听商店的变化。但我们仍然不会破坏商店。</p><pre class="mh mi mj mk gt nd ne nf ng aw nh bi"><span id="d48e" class="li lj jg ne b gy ni nj l nk nl">const counterStore = useStore("counterStore");</span></pre><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/135c682e1269d5d23bc8d13859a31a5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1252/1*oCG-0bVsdzJ3T4oBUrSCSw.gif"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Counter App demo</figcaption></figure><p id="4354" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该应用程序工作正常，酷！让我们看看我们从这个设置中得到的TypeScript提示，以及它将如何保护我们不做错事。</p><p id="5ebf" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先要提到的是代码完成特性。当我们添加<code class="fe np nq nr ne b">useStore</code>钩子并开始传递一个字符串作为参数时——将会显示一个关键提示。我们也将无法传递不存在的商店密钥。不错。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nt"><img src="../Images/ac5c6e94ef6bae287a19bbc4ef7224f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yw30LAHOERjtDaseh6vAhA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">TypeScript hint</figcaption></figure><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nu"><img src="../Images/197bfc89d393ab37167aa5f20dcf8812.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qti2eT24jgD4FhvjMgIZLw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">TypeScript warning</figcaption></figure><p id="3b42" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们有多个商店时，这也适用。我们可以用单独的<code class="fe np nq nr ne b">useStore</code>挂钩或<code class="fe np nq nr ne b">useStores</code>挂钩来接近它们。看看这个。</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nv"><img src="../Images/6bdcfbd25dbacbb76d1c371f7c2fccef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Hho5gPqJZU6COiWUcmFUew.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">TypeScript hint for multiple options</figcaption></figure><h1 id="14ae" class="mm lj jg bd lk mn mo mp ln mq mr ms lq mt mu mv lt mw mx my lw mz na nb lz nc bi translated">测试</h1><p id="2e79" class="pw-post-body-paragraph kd ke jg kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">当然，我们需要测试一下。在本文中，我们不会对商店本身进行测试，因为这是一个性质不同的话题。</p><p id="b744" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我发现使用Jest和反应测试库很容易。所以，让我们添加必要的依赖项。</p><pre class="mh mi mj mk gt nd ne nf ng aw nh bi"><span id="878d" class="li lj jg ne b gy ni nj l nk nl">yarn add @testing-library/react-hooks react-test-renderer -D</span><span id="a993" class="li lj jg ne b gy nm nj l nk nl">OR</span><span id="2f5a" class="li lj jg ne b gy nm nj l nk nl">npm install @testing-library/react-hooks react-test-renderer --save-dev</span></pre><p id="d2e4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">酷！现在我们可以开始测试钩子文件了。这里没什么特别的，但还是必要的。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nw"><img src="../Images/2cb9938e559cd46b888b90841ffe73cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mBAz8CsZBBExQhX9S4UUlw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Hooks file tests results</figcaption></figure><h2 id="2743" class="li lj jg bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">组件测试怎么样？</h2><p id="619b" class="pw-post-body-paragraph kd ke jg kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">为此，我们将需要更多的依赖。测试组件并执行用户事件。</p><pre class="mh mi mj mk gt nd ne nf ng aw nh bi"><span id="04a1" class="li lj jg ne b gy ni nj l nk nl">yarn add @testing-library/react @testing-library/user-event -D</span><span id="baee" class="li lj jg ne b gy nm nj l nk nl">OR</span><span id="66c3" class="li lj jg ne b gy nm nj l nk nl">npm install <a class="ae jd" href="http://twitter.com/testing" rel="noopener ugc nofollow" target="_blank">@testing</a>-library/react @testing-library/user-event --save-dev</span></pre><p id="c240" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很好。让我们现在测试组件。我们可以使用Jest来模拟<code class="fe np nq nr ne b">useStore</code>钩子，让它总是返回一个特定的商店。而且，我们可以通过几行额外的代码来实现类型安全。对于每个测试，我们都希望钩子返回一个新的存储。但是，对于其中一个测试，我们将稍微改变一下，并替换计数器的初始值。请检查此代码段。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="nn no l"/></div></figure><figure class="mh mi mj mk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/8065a822dda5afab2d682c6e29fb1627.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ndoxk9US9O1yf8wuVs9qBQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">App file tests results</figcaption></figure><p id="6b84" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很简单，不是吗？没错。我们也被开了绿灯！</p><h1 id="8dda" class="mm lj jg bd lk mn mo mp ln mq mr ms lq mt mu mv lt mw mx my lw mz na nb lz nc bi translated">摘要</h1><p id="abff" class="pw-post-body-paragraph kd ke jg kf b kg mb ki kj kk mc km kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">Mobx-react-lite实际上是我个人项目中所需要的一切。这也是你喜欢的选择吗？请在下面的评论中告诉我😉。</p><p id="c73a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整个项目可在<a class="ae jd" href="https://github.com/bohdanbirdie/mobx-react-lite-example" rel="noopener ugc nofollow" target="_blank"> GitHub链接</a>上找到。</p><h2 id="73b3" class="li lj jg bd lk ll lm dn ln lo lp dp lq ko lr ls lt ks lu lv lw kw lx ly lz ma bi translated">谢谢你阅读这个话题！</h2></div></div>    
</body>
</html>