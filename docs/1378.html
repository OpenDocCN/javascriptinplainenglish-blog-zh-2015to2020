<html>
<head>
<title>Compile Svelte in your head</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在你的头脑中编译苗条</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/compile-svelte-in-your-head-e12c87808255?source=collection_archive---------7-----------------------#2020-03-08">https://javascript.plainenglish.io/compile-svelte-in-your-head-e12c87808255?source=collection_archive---------7-----------------------#2020-03-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="919d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分:Svelte如何查看您的代码并将其编译成普通的JavaScript</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4eac6b465cf50393db8178ba6ae26e5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4dXdAVzhnaPjMmME"/></div></div></figure><h1 id="b883" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">背景</h1><p id="f39e" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">前阵子，<a class="ae mf" href="https://twitter.com/swyx" rel="noopener ugc nofollow" target="_blank"> @swyx </a>回到新加坡，在<a class="ae mf" href="https://careers.shopee.sg/about/" rel="noopener ugc nofollow" target="_blank"> Shopee Singapore </a> ( <a class="ae mf" href="https://grnh.se/32e5b3532" rel="noopener ugc nofollow" target="_blank">我们正在招人！</a>)。</p><p id="1811" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">他在<a class="ae mf" href="https://reactknowledgeable.org/" rel="noopener ugc nofollow" target="_blank">可识别的原创</a>中对<a class="ae mf" href="https://www.swyx.io/speaking/svelte-compile-lightning/" rel="noopener ugc nofollow" target="_blank">编译你脑中的苗条</a> ( <a class="ae mf" href="https://www.youtube.com/watch?v=FNmvcswdjV8" rel="noopener ugc nofollow" target="_blank">视频</a>)进行了惊人的分享。</p><p id="4c7c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我喜欢他的演示，标题很吸引人，所以我恳求他用这个吸引人的标题作为这一系列关于苗条编译器的文章。这将是关于如何Svelte看到你的代码，并将其编译成普通的JavaScript。</p><h1 id="c8ab" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="cb28" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">让我们回顾一下如何在没有任何框架的情况下编写web应用程序:</p><p id="ebde" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">创建元素</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="0407" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">更新元素</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="d640" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">移除一个元素</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="77bc" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">给一个元素添加样式</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8727" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">监听元素上的点击事件</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="12d0" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这些是你必须编写的代码，不需要使用任何框架或库。</p><p id="69e4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这篇文章的主要思想是展示svelite编译器如何将svelite语法编译成我上面展示的代码语句。</p><h1 id="2985" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated"><strong class="ak">纤细的语法</strong></h1><p id="f572" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这里我将向你展示一些简单语法的基础。</p><blockquote class="mn mo mp"><p id="adc4" class="lj lk mq ll b lm mg jr lo lp mh ju lr mr mi lu lv ms mj ly lz mt mk mc md me ij bi translated"><em class="iq">如果你希望了解更多，我强烈推荐尝试一下</em> <a class="ae mf" href="https://svelte.dev/tutorial/basics" rel="noopener ugc nofollow" target="_blank"> <em class="iq"> Svelte的互动教程</em> </a> <em class="iq">。</em></p></blockquote><p id="3553" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这是一个基本的苗条元素:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8bff" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><a class="ae mf" href="https://svelte.dev/repl/99aeea705b1e48fe8610b3ccee948280" rel="noopener ugc nofollow" target="_blank">苗条的REPL </a></p><p id="b0c8" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">要添加样式，您需要添加一个<code class="fe mu mv mw mx b">&lt;style&gt;</code>标签:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="7105" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">苗条的REPL</p><p id="e35e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在这一点上，编写苗条的组件感觉就像编写HTML，这是因为苗条的语法是HTML语法的超级集合。</p><p id="6268" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">让我们看看如何将数据添加到组件中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="aed5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">苗条的REPL</p><p id="029f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们把JavaScript放在花括号里。</p><p id="1593" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">为了添加一个点击处理程序，我们使用了<code class="fe mu mv mw mx b">on:</code>指令</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="4962" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><a class="ae mf" href="https://svelte.dev/repl/1da1dcaf51814ed09d2341ea7915f0a1" rel="noopener ugc nofollow" target="_blank">苗条的REPL </a></p><p id="fff1" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">为了改变数据，我们使用<a class="ae mf" href="https://www.w3schools.com/js/js_assignment.asp" rel="noopener ugc nofollow" target="_blank">赋值操作符</a></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="df94" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><a class="ae mf" href="https://svelte.dev/repl/7bff4b7746df4007a51155d2006ce724" rel="noopener ugc nofollow" target="_blank">苗条的REPL </a></p><p id="cdc3" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">让我们继续来看看如何将简单的语法编译成我们之前看到的JavaScript</p><h1 id="c9c7" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated"><strong class="ak">在你的头脑中编译苗条的身材</strong></h1><p id="36b3" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Svelte编译器分析您编写的代码，并生成优化的JavaScript输出。</p><p id="2614" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">为了研究Svelte如何编译代码，让我们从尽可能小的例子开始，慢慢地构建代码。通过这个过程，您将看到Svelte根据您的更改逐渐增加输出代码。</p><p id="3cdf" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们要看的第一个例子是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b5b7" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">苗条的REPL</p><p id="eb72" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">输出代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="18d5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">您可以将输出代码分成两部分:</p><ul class=""><li id="b802" class="my mz iq ll b lm mg lp mh ls na lw nb ma nc me nd ne nf ng bi translated"><code class="fe mu mv mw mx b">create_fragment</code></li><li id="61af" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated"><code class="fe mu mv mw mx b">class App extends SvelteComponent</code></li></ul><p id="2715" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">创建_片段</strong></p><p id="4762" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">苗条的组件是苗条的应用程序的构建块。每个纤细的组件都专注于构建最终DOM的片段。</p><p id="6589" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe mu mv mw mx b">create_fragment</code>函数为这个苗条的组件提供了如何构建DOM片段的指导手册。</p><p id="ad95" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">再看<code class="fe mu mv mw mx b">create_fragment</code>函数的返回对象。它有一些方法，例如:</p><p id="ec0c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir"> - c() </strong></p><p id="572a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">的简称创建</strong>。</p><p id="ff0d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">包含创建片段中所有元素的指令。</p><p id="233d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在这个例子中，它包含了创建<code class="fe mu mv mw mx b">h1</code>元素的指令</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f303" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir"> - m(目标，锚)</strong></p><p id="4550" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">座</strong>的简称。</p><p id="34a3" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">包含将元素装入目标的说明。</p><p id="8c0f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在本例中，它包含将<code class="fe mu mv mw mx b">h1</code>元素插入到<code class="fe mu mv mw mx b">target</code>中的指令。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="74e8" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir"> - d(分离)</strong></p><p id="68e1" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">销毁</strong>的简称。</p><p id="4d3b" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">包含从目标中移除元素的指令。</p><p id="3337" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在这个例子中，我们将<code class="fe mu mv mw mx b">h1</code>元素从DOM中分离出来</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><blockquote class="mn mo mp"><p id="c6f5" class="lj lk mq ll b lm mg jr lo lp mh ju lr mr mi lu lv ms mj ly lz mt mk mc md me ij bi translated"><em class="iq">为了更好地缩小，方法名称是简短的。</em> <a class="ae mf" href="https://alistapart.com/article/javascript-minification-part-ii/#section3" rel="noopener ugc nofollow" target="_blank"> <em class="iq">见此处有什么不能缩小的</em> </a> <em class="iq">。</em></p></blockquote><p id="bddf" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">每个组件都是一个类，你可以通过<a class="ae mf" href="https://svelte.dev/docs#Client-side_component_API" rel="noopener ugc nofollow" target="_blank">这个API </a>导入和实例化。</p><p id="5935" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在构造函数中，我们用组成组件的信息初始化组件，比如<code class="fe mu mv mw mx b">create_fragment</code>。Svelte只会传递需要的信息，并在不需要的时候删除它们。</p><p id="efec" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">尝试移除<code class="fe mu mv mw mx b">&lt;h1&gt;</code>标签，看看输出会发生什么:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="d9e7" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">苗条的REPL</p><p id="9f09" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><a class="ae mf" href="https://gist.github.com/efc401d42d1161c8cbb83ae722a4eab1" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/efc401d42d1161c8cbb83ae722a4eab1</a></p><p id="4f82" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">苗条将通过<code class="fe mu mv mw mx b">null</code>而不是<code class="fe mu mv mw mx b">create_fragment</code>！</p><p id="4725" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe mu mv mw mx b">init</code>函数是Svelte设置大部分内部组件的地方，比如:</p><ul class=""><li id="0172" class="my mz iq ll b lm mg lp mh ls na lw nb ma nc me nd ne nf ng bi translated">组件道具、<code class="fe mu mv mw mx b">ctx</code>(后面会解释什么是<code class="fe mu mv mw mx b">ctx</code>)和上下文</li><li id="e596" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">组件生命周期事件</li><li id="429e" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">组件更新机制</li></ul><p id="32c6" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">最后，Svelte调用<code class="fe mu mv mw mx b">create_fragment</code>来创建元素并将其安装到DOM中。</p><p id="1aa5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果你注意到了，所有的内部状态和方法都被附加到了<code class="fe mu mv mw mx b">this.$$</code>。</p><p id="fb70" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">因此，如果您曾经访问过组件的<code class="fe mu mv mw mx b">$$</code>属性，那么您就是在接触内部。你已经被警告了！🙈🚨</p><h1 id="64d6" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated"><strong class="ak">添加数据</strong></h1><p id="aaff" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">既然我们已经看到了一个瘦组件的最少部分，让我们看看添加一个数据会如何改变编译后的输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="78f7" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><a class="ae mf" href="https://svelte.dev/repl/c149ca960b0444948dc0c00a9175bcb3?version=3.19.1" rel="noopener ugc nofollow" target="_blank">苗条的REPL </a></p><p id="cade" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">请注意输出中的变化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="5d27" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">一些观察结果:</p><ul class=""><li id="dbdb" class="my mz iq ll b lm mg lp mh ls na lw nb ma nc me nd ne nf ng bi translated">您在<code class="fe mu mv mw mx b">&lt;script&gt;</code>标签中写的内容被移到代码的顶层</li><li id="e963" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated"><code class="fe mu mv mw mx b">h1</code>元素的文本内容现在是一个模板文本</li></ul><p id="27e7" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在有许多令人惊奇的事情正在发生，但是让我们先不要着急，因为这在与下一次代码更改进行比较时会得到最好的解释。</p><h1 id="1b06" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated"><strong class="ak">更新数据</strong></h1><p id="76d7" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">让我们添加一个函数来更新<code class="fe mu mv mw mx b">name</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="46d8" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">苗条的REPL</p><p id="f951" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">…并观察编译输出的变化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b426" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">一些观察结果:</p><ul class=""><li id="ebab" class="my mz iq ll b lm mg lp mh ls na lw nb ma nc me nd ne nf ng bi translated"><code class="fe mu mv mw mx b">&lt;h1&gt;</code>元素的文本内容现在被分成两个文本节点，由<code class="fe mu mv mw mx b">text(...)</code>函数创建</li><li id="2aab" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated"><code class="fe mu mv mw mx b">create_fragment</code>的返回对象有一个新方法，<code class="fe mu mv mw mx b">p(ctx, dirty)</code></li><li id="79d7" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">一个新的功能<code class="fe mu mv mw mx b">instance</code>被创建</li><li id="b952" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">您在<code class="fe mu mv mw mx b">&lt;script&gt;</code>标签中写的内容现在被移到了<code class="fe mu mv mw mx b">instance</code>函数中</li><li id="3f2b" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">对于眼尖的人来说，在<code class="fe mu mv mw mx b">create_fragment</code>中使用的变量<code class="fe mu mv mw mx b">name</code>现在被<code class="fe mu mv mw mx b">ctx[0]</code>代替了</li></ul><p id="ee98" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">那么，为什么要改变呢？</p><p id="4425" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">苗条编译器跟踪所有在<code class="fe mu mv mw mx b">&lt;script&gt;</code>标签中声明的变量。</p><p id="aae6" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">它跟踪变量是否:</p><ul class=""><li id="3218" class="my mz iq ll b lm mg lp mh ls na lw nb ma nc me nd ne nf ng bi translated">可以变异？<code class="fe mu mv mw mx b">count++</code>例:</li><li id="d4cb" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">可以重新分配？<code class="fe mu mv mw mx b">name = 'Svelte'</code>例:</li><li id="921b" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">模板中引用了。例:<code class="fe mu mv mw mx b">&lt;h1&gt;Hello {name}&lt;/h1&gt;</code></li><li id="711e" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">是可写的？例:<code class="fe mu mv mw mx b">const i = 1;</code>对<code class="fe mu mv mw mx b">let i = 1;</code></li><li id="57c9" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">…以及更多</li></ul><p id="bea3" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">当瘦编译器意识到变量<code class="fe mu mv mw mx b">name</code>可以被重新分配时，(由于<code class="fe mu mv mw mx b">update</code>中的<code class="fe mu mv mw mx b">name = 'Svelte';</code>，它将<code class="fe mu mv mw mx b">h1</code>的文本内容分解成几个部分，这样它就可以动态更新部分文本。</p><p id="31a7" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">事实上，您可以看到有一个新的方法，<code class="fe mu mv mw mx b">p</code>，用于更新文本节点。</p><p id="f55b" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir"> - p(ctx，dirty) </strong></p><p id="185b" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir"> u <em class="mq"> p </em>日期</strong>的简称。</p><p id="1e50" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir"> p(ctx，dirty) </strong>包含根据组件的状态(<code class="fe mu mv mw mx b">dirty</code>)和状态(<code class="fe mu mv mw mx b">ctx</code>)的变化来更新元素的指令。</p><p id="311d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">实例变量</strong></p><p id="1e6f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">编译器意识到变量<code class="fe mu mv mw mx b">name</code>不能在<code class="fe mu mv mw mx b">App</code>组件的不同实例之间共享。这就是为什么它将变量<code class="fe mu mv mw mx b">name</code>的声明移到一个名为<code class="fe mu mv mw mx b">instance</code>的函数中。</p><p id="5ba6" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在前面的示例中，无论有多少个<code class="fe mu mv mw mx b">App</code>组件实例，变量<code class="fe mu mv mw mx b">name</code>的值都是相同的，并且在所有实例中保持不变:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6b3e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">实例($$self，$$props，$$invalidate) </strong></p><p id="1b7f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">但是，在这个例子中，变量<code class="fe mu mv mw mx b">name</code>可以在组件的一个实例中被改变，所以变量<code class="fe mu mv mw mx b">name</code>的声明现在被移到了<code class="fe mu mv mw mx b">instance</code>函数中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="133a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe mu mv mw mx b">instance</code>函数返回一列<em class="mq">实例</em>变量，这些变量是:</p><ul class=""><li id="1b4b" class="my mz iq ll b lm mg lp mh ls na lw nb ma nc me nd ne nf ng bi translated">模板中引用的</li><li id="f2ce" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">变异或重新分配(可以在组件的一个实例内更改)</li></ul><p id="86d0" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在Svelte中，我们称这个实例变量列表为<strong class="ll ir"> ctx </strong>。</p><p id="b8c3" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在<code class="fe mu mv mw mx b">init</code>函数中，Svelte调用<code class="fe mu mv mw mx b">instance</code>函数来创建<strong class="ll ir"> ctx </strong>，并使用它来创建组件的片段:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="9110" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在，我们引用通过<strong class="ll ir"> ctx </strong>传递的变量<code class="fe mu mv mw mx b">name</code>，而不是访问组件外部的变量<code class="fe mu mv mw mx b">name</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="e3d8" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">ctx是一个数组而不是地图或对象的原因是因为与位掩码相关的优化，你可以在这里看到关于它的讨论</p><p id="6915" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">$ $无效</strong></p><p id="477d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">苗条身材反应系统背后的秘密是<code class="fe mu mv mw mx b">$$invalidate</code>功能。</p><p id="4c0f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">每一个变量</p><ul class=""><li id="13fb" class="my mz iq ll b lm mg lp mh ls na lw nb ma nc me nd ne nf ng bi translated">重新分配或变异</li><li id="626a" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">模板中引用的</li></ul><p id="e16a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">将在赋值或变异后插入<code class="fe mu mv mw mx b">$$invalidate</code>函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="862c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe mu mv mw mx b">$$invalidate</code>函数将变量标记为脏，并为组件安排一次更新:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="dd58" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">添加事件监听器</strong></p><p id="d6c2" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在让我们添加一个事件监听器</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a56e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><a class="ae mf" href="https://svelte.dev/repl/5b12ff52c2874f4dbb6405d9133b34da?version=3.19.1" rel="noopener ugc nofollow" target="_blank">苗条的REPL </a></p><p id="422f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">观察不同之处:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="a02a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">一些观察结果:</p><ul class=""><li id="c5f5" class="my mz iq ll b lm mg lp mh ls na lw nb ma nc me nd ne nf ng bi translated"><code class="fe mu mv mw mx b">instance</code>函数现在返回2个变量而不是1个</li><li id="0405" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">在<strong class="ll ir">挂载</strong>期间监听点击事件，并在<strong class="ll ir">销毁</strong>中处理</li></ul><p id="48da" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">正如我前面提到的，<code class="fe mu mv mw mx b">instance</code>函数返回模板中引用的<strong class="ll ir">变量以及<strong class="ll ir">变异或重新分配的</strong>变量。</strong></p><p id="6277" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">由于我们刚刚在模板中引用了<code class="fe mu mv mw mx b">update</code>函数，它现在作为<strong class="ll ir"> ctx </strong>的一部分返回到<code class="fe mu mv mw mx b">instance</code>函数中。</p><p id="993c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">Svelte试图生成尽可能紧凑的JavaScript输出，如果不必要，不返回额外的变量。</p><p id="75dd" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">倾听和处置</strong></p><p id="3fdd" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">每当你在Svelte中添加<a class="ae mf" href="https://svelte.dev/tutorial/dom-events" rel="noopener ugc nofollow" target="_blank">一个事件监听器</a>时，Svelte会注入代码来添加一个<a class="ae mf" href="https://developer.mozilla.org/en-US/docs/Web/API/EventListener" rel="noopener ugc nofollow" target="_blank">事件监听器</a>并在从DOM中移除DOM片段时移除它。</p><p id="0fef" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">尝试添加更多事件侦听器，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="0498" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><a class="ae mf" href="https://svelte.dev/repl/efde6f2aaf624e708767f1bd3e94e479?version=3.19.1" rel="noopener ugc nofollow" target="_blank">苗条的REPL </a></p><p id="b196" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">并观察编译后的输出:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6b73" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">Svelte没有声明和创建一个新变量来删除每个事件侦听器，而是将它们全部分配给一个数组:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b194" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">缩小可以压缩变量名，但是不能去掉括号。</p><p id="89c5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">同样，这是Svelte试图生成紧凑JavaScript输出的另一个很好的例子。当只有一个事件监听器时，Svelte不会创建<code class="fe mu mv mw mx b">dispose</code>数组。</p><h1 id="d9d5" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated"><strong class="ak">总结</strong></h1><p id="857c" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">简单语法是HTML的超集。</p><p id="6fab" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">当你编写一个简单的组件时，简单的编译器会分析你的代码并生成优化的JavaScript代码输出。</p><p id="9de3" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">输出可分为3个部分:</p><p id="201c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir"> 1。创建_片段</strong></p><ul class=""><li id="e843" class="my mz iq ll b lm mg lp mh ls na lw nb ma nc me nd ne nf ng bi translated">返回一个片段，这是关于如何为组件构建DOM片段的说明手册</li></ul><p id="2348" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir"> 2。实例</strong></p><ul class=""><li id="57cd" class="my mz iq ll b lm mg lp mh ls na lw nb ma nc me nd ne nf ng bi translated">写在<code class="fe mu mv mw mx b">&lt;script&gt;</code>标签中的大部分代码都在这里。</li><li id="bec8" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">返回模板中引用的实例变量列表</li><li id="13a7" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">在实例变量的每次赋值和变异后插入<code class="fe mu mv mw mx b">$$invalidate</code></li></ul><p id="d9a8" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir"> 3。class App扩展了svelet component</strong></p><ul class=""><li id="f452" class="my mz iq ll b lm mg lp mh ls na lw nb ma nc me nd ne nf ng bi translated">用<code class="fe mu mv mw mx b">create_fragment</code>和<code class="fe mu mv mw mx b">instance</code>功能初始化组件</li><li id="3fcc" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">设置组件内部</li><li id="d70f" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">提供<a class="ae mf" href="https://svelte.dev/docs#Client-side_component_API" rel="noopener ugc nofollow" target="_blank">组件API </a></li></ul><p id="1cc2" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">Svelte努力生成尽可能紧凑的JavaScript，例如:</p><ul class=""><li id="d9f0" class="my mz iq ll b lm mg lp mh ls na lw nb ma nc me nd ne nf ng bi translated">仅当部分文本可以更新时，将<code class="fe mu mv mw mx b">h1</code>的文本内容分解成单独的文本节点</li><li id="788a" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">不需要时不定义<code class="fe mu mv mw mx b">create_fragment</code>或<code class="fe mu mv mw mx b">instance</code>功能</li><li id="5e22" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi translated">根据事件侦听器的数量，将<code class="fe mu mv mw mx b">dispose</code>生成为数组或函数。</li><li id="3e18" class="my mz iq ll b lm nh lp ni ls nj lw nk ma nl me nd ne nf ng bi">…</li></ul><h1 id="4843" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated"><strong class="ak">结束语</strong></h1><p id="7c0d" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们已经介绍了Svelte编译输出的基本结构，这仅仅是开始。</p><p id="f46f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果你想了解更多，请在Twitter上关注我。</p><p id="0575" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">当下一部分准备好的时候，我会把它发布在Twitter上，在那里我会涵盖<a class="ae mf" href="https://svelte.dev/tutorial/if-blocks" rel="noopener ugc nofollow" target="_blank">逻辑块</a>、<a class="ae mf" href="https://svelte.dev/tutorial/slots" rel="noopener ugc nofollow" target="_blank">插槽</a>、<a class="ae mf" href="https://svelte.dev/tutorial/context-api" rel="noopener ugc nofollow" target="_blank">上下文</a>以及许多其他内容。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><p id="7048" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><em class="mq">原载于</em><a class="ae mf" href="https://lihautan.com/compile-svelte-in-your-head-part-1/" rel="noopener ugc nofollow" target="_blank"><em class="mq">https://lihautan.com</em></a><em class="mq">。</em></p></div></div>    
</body>
</html>