<html>
<head>
<title>React Tips — Sharing Data</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应提示—共享数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-tips-sharing-data-623f60925446?source=collection_archive---------11-----------------------#2020-07-31">https://javascript.plainenglish.io/react-tips-sharing-data-623f60925446?source=collection_archive---------11-----------------------#2020-07-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/42d525221c04fbbb9984e17523848d3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u4Pv3Ip_wpFprGps"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nicn10?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nicate Lee</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6892" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将探讨一些编写更好的React应用程序的技巧。</p><h1 id="5040" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从子组件内部更新反应上下文</h1><p id="4fb0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过首先创建一个上下文，并在上下文消费者中包装子组件来更新React上下文。</p><p id="d322" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以使用子组件中的<code class="fe me mf mg mh b">useContext</code>挂钩返回的函数来进行更新。</p><p id="0e0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f182" class="mq lc iq mh b gy mr ms l mt mu">const NameContext = React.createContext({<br/>  name: "",<br/>  setName: () =&gt; {}<br/>});</span><span id="0361" class="mq lc iq mh b gy mv ms l mt mu">const NameSwitcher = () =&gt; {<br/>  const { name, setName } = useContext(NameContext);<br/>  return (<br/>    &lt;button onClick={() =&gt; setName("mary")}&gt;<br/>      change name<br/>    &lt;/button&gt;<br/>  );<br/>};</span><span id="70a6" class="mq lc iq mh b gy mv ms l mt mu">const App = () =&gt; {<br/>  const [name, setName] = useState("");</span><span id="f00d" class="mq lc iq mh b gy mv ms l mt mu">  return (<br/>    &lt;NameContext.Provider value={{ name, setName }}&gt;<br/>      &lt;h2&gt;Name: {name}&lt;/h2&gt;<br/>      &lt;div&gt;<br/>        &lt;NameSwitcher /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/NameContext.Provider&gt;<br/>  );<br/>};</span></pre><p id="bcd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们用<code class="fe me mf mg mh b">React.createContext</code>方法创建<code class="fe me mf mg mh b">NameContext</code>。</p><p id="efa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们有<code class="fe me mf mg mh b">App</code>组件，它有<code class="fe me mf mg mh b">name</code>状态和<code class="fe me mf mg mh b">setName</code>来更新<code class="fe me mf mg mh b">name</code>状态。</p><p id="2c70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe me mf mg mh b">NameContext.Provider</code>包裹在我们想要访问<code class="fe me mf mg mh b">NameContext</code>的所有组件周围。</p><p id="1a39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嵌套可以处于任何级别。</p><p id="a04e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们使用<code class="fe me mf mg mh b">value</code>道具时，它里面的所有东西都会被<code class="fe me mf mg mh b">useContext</code>退回。</p><p id="19c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，在<code class="fe me mf mg mh b">NameSwitcher</code>中，我们可以使用<code class="fe me mf mg mh b">setName</code>功能来设置<code class="fe me mf mg mh b">name</code>状态，该状态也由<code class="fe me mf mg mh b">useContext</code>返回。</p><p id="0c70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在类组件中，我们可以做同样的事情。</p><p id="0d3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fcf2" class="mq lc iq mh b gy mr ms l mt mu">const NameContext = React.createContext({<br/>  name: "",<br/>  setName: () =&gt; {}<br/>});</span><span id="319d" class="mq lc iq mh b gy mv ms l mt mu">class NameSwitcher extends Component {<br/>  render() {<br/>    return (<br/>      &lt;NameContext.Consumer&gt;<br/>        {({ name, setName }) =&gt; (<br/>          &lt;button onClick={() =&gt; setName("mary")}&gt;<br/>            change name<br/>          &lt;/button&gt;<br/>        )}<br/>      &lt;/NameContext.Consumer&gt;<br/>    );<br/>  }<br/>}</span><span id="d0a6" class="mq lc iq mh b gy mv ms l mt mu">class App extends Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      language: "en",<br/>      setLanguage: this.setLanguage<br/>    };<br/>    this.setName = this.setName.bind(this);<br/>  }</span><span id="3547" class="mq lc iq mh b gy mv ms l mt mu">  setName(name) {<br/>    this.setState({ name });<br/>  };</span><span id="53df" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;NameContext.Provider value={{ <br/>        name: this.state.name, <br/>        setName: this.setName <br/>      }}&gt;<br/>        &lt;h2&gt;Name: {name}&lt;/h2&gt;<br/>        &lt;div&gt;<br/>          &lt;NameSwitcher /&gt;<br/>        &lt;/div&gt;<br/>      &lt;/NameContext.Provider&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="95d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有相同的上下文对象，但状态改变函数，并且状态在不同的地方。</p><p id="2e94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们把它们传到<code class="fe me mf mg mh b">value</code>道具中放到对象上。</p><p id="f486" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们将它们传递到了<code class="fe me mf mg mh b">value</code>道具的对象中，因此我们可以在<code class="fe me mf mg mh b">NameSwitcher</code>中访问它们。</p><p id="d68e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的区别在于，我们需要在其中添加一个<code class="fe me mf mg mh b">NameContext.Consumer</code>和一个回调来访问这些属性。</p><p id="59b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们在回调的参数中。</p><h1 id="335c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">useCallback和useMemo之间的区别</h1><p id="5049" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">useMemo</code>来记住函数调用和呈现的计算结果。</p><p id="2c2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">useCallback</code>用于在渲染之间记住回调本身。</p><p id="78f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">参考已快取。</p><p id="7ac7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">useRef</code>是保持数据之间呈现。</p><p id="62f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">useState</code>同样如此。</p><p id="e523" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以使用<code class="fe me mf mg mh b">useMemo</code>来避免繁重的计算。</p><p id="b0bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">useCallback</code>修复了内联处理程序导致<code class="fe me mf mg mh b">PureComponent</code>的子代再次呈现的性能问题。</p><p id="c23e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">出现这种情况是因为函数表达式每次呈现时引用的内容不同。</p><h1 id="ed61" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Redux中发出Ajax请求</h1><p id="a3b8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果使用Redux Thunk中间件，我们可以用Redux发出Ajax请求。</p><p id="ef73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要安装它，我们运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="826f" class="mq lc iq mh b gy mr ms l mt mu">npm install redux-thunk</span></pre><p id="dc4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使用它，我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f7bf" class="mq lc iq mh b gy mr ms l mt mu">import { createStore, applyMiddleware } from 'redux';<br/>import thunk from 'redux-thunk';<br/>import rootReducer from './reducers/index';</span><span id="cb7c" class="mq lc iq mh b gy mv ms l mt mu">const store = createStore(rootReducer, applyMiddleware(thunk));</span></pre><p id="56d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入了<code class="fe me mf mg mh b">rootReducer</code>和<code class="fe me mf mg mh b">thunk</code>中间件。</p><p id="4eee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">applyMiddleware</code>来应用<code class="fe me mf mg mh b">thunk</code>中间件。</p><p id="301b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以通过编写以下代码来创建自己的thunk:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bc20" class="mq lc iq mh b gy mr ms l mt mu">const fetchUsers = () =&gt; {<br/>  return dispatch =&gt; {<br/>     fetch(`https://randomuser.me/api/`)<br/>       .then(res =&gt; res.json())<br/>       .then(res =&gt; {<br/>          dispatch(saveUserData(res))<br/>       }) <br/>   }<br/>}</span><span id="f210" class="mq lc iq mh b gy mv ms l mt mu">store<br/>  .dispatch(fetchUsers())<br/>  .then(() =&gt; {<br/>    //...<br/>  })</span></pre><p id="29c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将一个带有<code class="fe me mf mg mh b">dispatch</code>参数的函数，也就是Redux <code class="fe me mf mg mh b">dispatch</code>函数，传递给<code class="fe me mf mg mh b">store.dispatch</code>方法。</p><p id="9484" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">调用<code class="fe me mf mg mh b">dispatch</code>参数将数据放入Redux存储中。</p><p id="54cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，为了将该函数映射到组件的道具，我们可以编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="01d3" class="mq lc iq mh b gy mr ms l mt mu">function mapDispatchToProps(dispatch) {<br/>  return {<br/>    fetchUsers: () =&gt; dispatch(fetchUsers()),<br/>  };<br/>}</span></pre><p id="752b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以调用<code class="fe me mf mg mh b">this.prop.fetchUsers</code>来调用调度我们的异步动作。</p><p id="5f01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">fetchUsers</code>是一个动作创建函数，但它是异步的。</p><p id="6623" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这要感谢Redux Thunk插件。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/167ec1a5c6a0d0ebe7495fbd7a9b2534.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xKokRhvHUrGFgFiU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@fouldsmatt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Matthew Foulds</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="03cd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="8764" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用上下文API与类和函数组件共享数据。</p><p id="4410" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想要一种更灵活的方式来共享数据，我们可以使用Redux with Redux Thunk。</p><p id="29de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们能够以异步方式设置数据。</p><h2 id="93ab" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="e7ee" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>