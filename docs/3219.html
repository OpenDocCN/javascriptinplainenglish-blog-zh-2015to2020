<html>
<head>
<title>Best of Modern JavaScript — Variables and Destructuring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript精华——变量和析构</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-variables-and-destructuring-1b714820641d?source=collection_archive---------4-----------------------#2020-09-10">https://javascript.plainenglish.io/best-of-modern-javascript-variables-and-destructuring-1b714820641d?source=collection_archive---------4-----------------------#2020-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ec513ee9fed441ef3a9eab5635fc4ea8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6hoM9h36PetxJBXp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ramche?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ramiz Dedaković</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a15c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript变量和析构。</p><h1 id="571a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">全局对象</h1><p id="af58" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">全局对象在Node.js中，浏览器端JavaScript更多的是一个bug而不是一个特性。</p><p id="b927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它的性能很差。</p><p id="cb73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">全局对象是全局变量。</p><p id="25ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在全局作用域中，<code class="fe me mf mg mh b">var</code>声明声明全局对象属性。</p><p id="fbdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数声明也声明全局对象属性。</p><p id="e089" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们在全局作用域中创建属性时，<code class="fe me mf mg mh b">let</code>、<code class="fe me mf mg mh b">const</code>和类声明不会给全局对象添加属性。</p><h1 id="63a8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函数声明和类声明</h1><p id="8a90" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">像<code class="fe me mf mg mh b">let</code>一样，函数声明是块范围。</p><p id="fa43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们像<code class="fe me mf mg mh b">var</code>一样在全局范围内创建全局对象的属性。</p><p id="e072" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们也是托管的，所以就可用性而言，它们独立于它们在代码中的位置。</p><p id="b4fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3df6" class="mq lc iq mh b gy mr ms l mt mu">{ <br/>  console.log(foo()); <br/>  function foo() {<br/>    return 'hello';<br/>  }<br/>}</span></pre><p id="3073" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以调用<code class="fe me mf mg mh b">foo</code>而不出错，因为<code class="fe me mf mg mh b">foo</code>被提升了。</p><p id="e1f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类声明是块范围的，不会在全局对象上创建属性，也不会被提升。</p><p id="adb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们在引擎盖下创造功能，但他们仍然没有被提升。</p><p id="b783" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bcb8" class="mq lc iq mh b gy mr ms l mt mu">{<br/>  const identity = x =&gt; x;<br/>  const inst = new Foo();<br/>  class Foo extends identity(Object) {}<br/>}</span></pre><p id="0d8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会得到一个<code class="fe me mf mg mh b">ReferenceError</code>，因为<code class="fe me mf mg mh b">Foo</code>在被调用之前没有被定义。</p><h1 id="7e05" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">const</code>对<code class="fe me mf mg mh b">let</code>对<code class="fe me mf mg mh b">var</code></h1><p id="1f61" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">声明变量的最好方法是先用<code class="fe me mf mg mh b">const</code>。</p><p id="274e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们不能通过重新分配来改变，所以用它们更难出错。</p><p id="4d98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们仍然可以改变分配给它的内容。</p><p id="0c5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="206e" class="mq lc iq mh b gy mr ms l mt mu">const<!-- --> <!-- -->foo<!-- --> <!-- -->=<!-- --> <!-- -->{};<br/>foo.prop<!-- --> <!-- -->=<!-- --> <!-- -->123;</span></pre><p id="660d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在循环中使用<code class="fe me mf mg mh b">const</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="81bf" class="mq lc iq mh b gy mr ms l mt mu">for (const x of ['a', 'b']) {<br/>   console.log(x);<br/> }</span></pre><p id="5277" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe me mf mg mh b">x</code>是为循环的每次迭代创建的，所以我们可以在循环中使用<code class="fe me mf mg mh b">const</code>。</p><p id="af80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们可以在以后需要更改变量时使用<code class="fe me mf mg mh b">let</code>。</p><p id="67f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="caa8" class="mq lc iq mh b gy mr ms l mt mu">let counter = 0;<br/>counter++; </span><span id="29fa" class="mq lc iq mh b gy mv ms l mt mu">let obj = {}; <br/>obj = { foo: 'bar' };</span></pre><p id="706b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该使用<code class="fe me mf mg mh b">var</code>，它们应该只出现在遗留代码中。</p><h1 id="34f9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解构</h1><p id="e7b2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">析构是从数组和对象中提取多个值的一种便捷方式。</p><p id="dca0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组和对象可以嵌套。</p><h1 id="101f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象析构</h1><p id="161a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过书写来破坏对象:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cf5f" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  firstName: 'james',<br/>  lastName: 'smith'<br/>};<br/>const {<br/>  firstName: f,<br/>  lastName: l<br/>} = obj;</span></pre><p id="4567" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个对象<code class="fe me mf mg mh b">obj</code>，然后将它赋给第二条语句的表达式。</p><p id="e3c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将获得<code class="fe me mf mg mh b">firstName</code>属性并将其分配给<code class="fe me mf mg mh b">f</code>。</p><p id="217d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将对<code class="fe me mf mg mh b">lastName</code>做同样的事情，并将其分配给<code class="fe me mf mg mh b">l</code>。</p><p id="8466" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">析构也有助于处理返回值。</p><p id="e76b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7d41" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  foo: 'bar'<br/>};</span><span id="3276" class="mq lc iq mh b gy mv ms l mt mu">const {<br/>  writable,<br/>  configurable<br/>} =<br/>Object.getOwnPropertyDescriptor(obj, 'foo');</span><span id="7e30" class="mq lc iq mh b gy mv ms l mt mu">console.log(writable, configurable);</span></pre><p id="530d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称之为<code class="fe me mf mg mh b">Object.getOwnPropertyDescriptor</code>方法，它接受一个对象和一个属性键。</p><p id="9f27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回一个具有<code class="fe me mf mg mh b">writable</code>和<code class="fe me mf mg mh b">configurable</code>属性的对象。</p><p id="313c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以使用析构来获取属性并将它们赋给变量。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/11091217bb8ef2ac9129dc8b5bb9e7f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mi4f292V4OYCY2te"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@alain_pham?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alain Pham</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0979" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="682b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以遵循一些声明变量的最佳实践。</p><p id="ab29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，析构对于从对象和数组中获取变量也很方便。</p><h2 id="2911" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="7164" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>