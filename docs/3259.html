<html>
<head>
<title>How to create an Offline-First PWA with Nuxt.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Nuxt.js创建离线优先PWA</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nuxt-offline-first-pwa-tutorial-782df70b535?source=collection_archive---------4-----------------------#2020-09-14">https://javascript.plainenglish.io/nuxt-offline-first-pwa-tutorial-782df70b535?source=collection_archive---------4-----------------------#2020-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f7af" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Nuxt在Vue.js中设置支持离线的应用程序的快速教程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6c7bafe8d65e6543cd70c740008a5f37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XZqn-U_RlG5Mlwdh.jpg"/></div></div></figure><h1 id="30d2" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">我爱Vue</h1><p id="2a73" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我喜欢Vue.js。这是一个奇妙的JavaScript框架——在我看来很容易超越其他产品——这说明了一些问题，因为我认为它们也很酷。是的，他们比Vue做得更好。他们中的一些人在Vue和Vue后来采用它之前就已经做了一些事情。但即便如此，还是有充分的理由支持Vue。</p><p id="f851" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">快速浏览一遍:</p><ol class=""><li id="23b2" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">Vue有很好的学习曲线。</li><li id="bbf9" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">它鼓励在遗留项目中逐步采用。</li><li id="c7e4" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">发展是由社区需求驱动的。</li><li id="d03e" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">Vue维护者与其他框架维护者有着友好的关系，允许思想和概念的自由交流。</li></ol><h1 id="9d20" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">也许有些事情可以更好</h1><p id="4a29" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这里还有更多的观点，但是，让我继续对Vue.js进行批评——根据您打算构建的应用程序的类型或应用程序的大小，搭建Vue.js应用程序，即使是使用CLI也可能是一件苦差事。</p><p id="5aed" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">此外，关于创建Vue应用程序有一些必须注意的细节——这并不困难，但如果你打算使用Vuex或Vue路由器，那么在你可以启动商店或期望你的路线工作之前，需要少量的配置。</p><p id="db95" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在保存文件的地方，是否有一个组件文件夹，或者如何进行布局，可能会有相当多的变化。当然，Vue CLI在搭建新项目时会有所帮助，但是，例如对于Vue路由器，您需要继续修改router index.js，以便准确记录路由。</p><p id="f045" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这是很小的变化，但随着应用程序的不断发展和变化，很容易被遗忘。虽然任何应用程序，不管是什么语言或框架，最终都会有一个需要维护的项目清单，但我们应该尽可能保持清单较小，并在有意义的时候实现自动化。</p><h1 id="d9c2" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">输入Nuxt.js。</h1><p id="962a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果我正在创建一个新的Vue项目，除非它非常小，否则我很少会使用Vue CLI而不是Nuxt。Nuxt让一切变得简单。路由已经预先配置好，并根据目录结构动态确定。它很容易理解用于确定布局、中间件和组件的选项。</p><p id="d3b0" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">事实上，你可以把这个博客的结构看作一个例子。这里是<a class="ae mz" href="https://github.com/RobotOptimist/macivor" rel="noopener ugc nofollow" target="_blank"> GitHub </a>。</p><p id="d13a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">Nuxt可以扮演很多角色。在这个博客中，它是一个基于git的CMS和静态站点生成器。但是我也用它创建了一个单页面应用程序，为浏览器提供了丰富的体验。它可以是一个通用的应用程序，非常容易地提供预渲染甚至服务器端渲染的页面。事实上，要创建服务器端呈现的应用程序而不是单页面应用程序，下面是nuxt.config.js中的配置行:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="c45b" class="nf ks iq nb b gy ng nh l ni nj">ssr: true, // will be a spa if set to false</span></pre><p id="2269" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果不提供示例，很难描述如何使用Nuxt——所以让我们一起创建一个Nuxt应用程序。</p><h1 id="27cc" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">应用要求示例</h1><p id="dc0f" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">首先，让我们得到一些要求。</p><p id="21db" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">让我们把它变成一个调查应用程序。是给需要定期检查消防栓的消防栓检查员用的(很确定这是个假工作)。所以它有这些要求:</p><ol class=""><li id="8c3a" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">需要用户登录。</li><li id="3b0e" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">以表单形式收集消防栓的相关数据。(消防栓序列号和状况)</li><li id="798e" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">必须离线工作(消防栓并不总是在手机信号塔或无线网络附近)。</li><li id="7ceb" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">连接(或重新连接)时必须传输消防栓数据。</li><li id="ad19" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">适合在手机或平板电脑上工作。</li></ol><p id="49b6" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">好极了。让我们对应用程序的架构做出一些决定。</p><p id="e2b9" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">它需要一个登录，所以我们将使用Auth0。Auth0将允许我们与其他认证系统集成，因此我们可以支持各种消防栓检查员公司。</p><p id="842c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">它需要一个表单，所以我们将使用bootstrap来满足这个需求。还有更新更好的(？)，CSS框架可用，但bootstrap将通过很少的工作为我们提供所需的一切(以及许多我们没有的东西)。</p><p id="ace2" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">嗯，需求3、4、5确实指向PWA ( <a class="ae mz" href="https://web.dev/what-are-pwas/" rel="noopener ugc nofollow" target="_blank">渐进式Web应用</a>)。因此，我们也将使这个应用程序成为PWA。</p><p id="14c0" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">好的。现在怎么办？所有这些都可以通过Nuxt来完成。</p><h1 id="deab" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">用Nuxt做</h1><p id="5979" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">对于认证，我们可以使用<a class="ae mz" href="https://auth.nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> @nuxtjs/auth </a>。这很完美，因为它内置了与Auth0的集成。但是如果我不想使用Auth0，它内置了对一些其他身份验证提供者的支持，或者我们可以扩展它以使用我们需要的任何身份验证提供者。</p><p id="0022" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">Nuxtjs/auth有一个对ajax库<a class="ae mz" href="https://axios.nuxtjs.org/" rel="noopener ugc nofollow" target="_blank"> @nuxtjs/axios </a>的依赖——这很完美，因为我们无论如何都需要它来传输表单数据。</p><p id="3f53" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们还需要创建这个表单。我们选择了bootstrap，所以我们将使用<a class="ae mz" href="https://bootstrap-vue.org/docs#getting-started-with-nuxtjs" rel="noopener ugc nofollow" target="_blank"> bootstrap-vue </a>，它有一个方便的Nuxt.js模块来简化这一切。此外，bootstrap-vue有一种方法来指定我们正在使用哪些bootstrap特性，因此我们可以使用webpack(内置于Nuxt中)来清除其余的特性。太好了！对于bootstrap的缺点来说，这并不是一个完美的解决方案，但也是有意义的。</p><p id="c0c9" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">最后，我们有这个PWA要求。这也有一个模块。<a class="ae mz" href="https://pwa.nuxtjs.org/setup" rel="noopener ugc nofollow" target="_blank"> @nuxtjs/pwa </a>看起来拥有我们需要的一切。它将处理所有的图标和清单，并允许我们轻松地注册一个服务人员，并确定当用户离线时应该使用什么路线和行为。</p><p id="e5c4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在，注意所有我不需要指定的东西。我不需要调用Vue路由器，因为它已经在混合中。Vuex也在里面，它是nuxt/auth的依赖项，但是我们自己可能不需要它。</p><p id="512d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们通过运行以下命令来创建项目:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="77ba" class="nf ks iq nb b gy ng nh l ni nj">npx create-nuxt-app &lt;project-name&gt;</span></pre><p id="e628" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在运行时，它将允许我们使用一些选项来引入一些依赖项。PWA是一个选项，但是仍然需要额外的npm安装。我们也将使用Axios，所以现在使用它更有意义。我们也可以选择bootstrap，或者其他CSS框架。</p><p id="cbde" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">让我们继续并引入身份验证模块:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="0bfa" class="nf ks iq nb b gy ng nh l ni nj">npm install @nuxtjs/auth</span></pre><p id="0333" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果您还没有安装，请确保安装Axios:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="1fd5" class="nf ks iq nb b gy ng nh l ni nj">npm install @nuxtjs/axios</span></pre><p id="65f9" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">然后我们修改nuxt.config.js以添加到modules属性:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="dab2" class="nf ks iq nb b gy ng nh l ni nj">modules: [<br/>  '@nuxtjs/axios',<br/>  '@nuxtjs/auth'<br/>],<br/>auth: {<br/>  // Options<br/>}</span></pre><p id="d40d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">脚手架工具也帮助我们选择了一个测试工具。我选择了Jest。</p><p id="1030" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">谢谢提醒Nuxt！测试很重要。但是我不会在本教程中讨论测试，抱歉。</p><p id="1806" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">最后，@nuxtjs/auth提醒我们需要通过在存储目录中添加index.js文件来初始化Vuex存储。Nuxt将自动导入Vuex，并在添加index.js文件时对其进行配置。(这可以防止Vuex被添加到不需要它的项目中。)</p><p id="e0fb" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">接下来，让我们引入PWA模块:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="5cb9" class="nf ks iq nb b gy ng nh l ni nj">npm install @nuxtjs/pwa</span></pre><p id="2328" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">别忘了建立我们的清单！</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="44ae" class="nf ks iq nb b gy ng nh l ni nj">pwa: {<br/>  manifest: {<br/>    name: 'Fire hydrant surveyor',<br/>    short_name: 'Hydrant Surveyor',<br/>    lang: 'en',<br/>    display: 'standalone',<br/>  },<br/>}</span></pre><p id="7fa8" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">Nuxt PWA实际上是一个5个不同的模块，其中只有一个将需要我们的一些自定义代码。</p><ul class=""><li id="15aa" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me nk mr ms mt bi translated">图标模块——它将为PWA图标配置图标并使其可用。</li><li id="2656" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me nk mr ms mt bi translated">元模块——它将为移动应用程序设置一些通用选项。</li><li id="29ca" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me nk mr ms mt bi translated">清单模块—使用配置的值创建清单文件。</li><li id="359a" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me nk mr ms mt bi translated">工作箱模块——允许设置服务工作者和可缓存资源——这是我们为离线行为做大量工作的地方。</li><li id="61b6" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me nk mr ms mt bi translated">一个信号模块——注入一个API，允许在移动设备上创建推送通知。</li></ul><p id="7453" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">让我们来看看这一切是什么样子的:</p><p id="2dda" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><a class="ae mz" href="https://github.com/RobotOptimist/demo_survey_app/tree/initial-setup" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="b6ad" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">就这样，我们有了一个具有PWA功能的功能应用程序，一个CSS框架和内置的身份验证。</p><p id="e18f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">此时，我们应该考虑我们剩余的任务:</p><ol class=""><li id="f070" class="ml mm iq ll b lm mg lp mh ls mn lw mo ma mp me mq mr ms mt bi translated">创建一个Auth0帐户，并将适当的信息添加到nuxt配置中。</li><li id="4785" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">使用auth0登录和消防栓调查表构建适当的页面。</li><li id="1463" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">将可缓存资产添加到workbox(包含在PWA模块中)。</li><li id="6033" class="ml mm iq ll b lm mu lp mv ls mw lw mx ma my me mq mr ms mt bi translated">配置和自定义服务人员来处理离线工作流。</li></ol><p id="abec" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">让我们去争取吧。从#1开始。</p><p id="c656" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">创建一个Auth0 账户非常简单。可以使用GitHub登录。Auth0会自动为您设置一个应用程序。然后，您可以获取nuxtjs/auth模块所需的所有信息。你需要在Auth0应用程序设置中设置一些东西，比如允许的来源，允许的回调URIs等等。你可以参考<a class="ae mz" href="https://auth0.com/docs/get-started/dashboard/application-settings" rel="noopener ugc nofollow" target="_blank"> Auth0文档</a>来了解如何操作。</p><p id="eeff" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在nuxt.config.js中，您需要定义重定向和策略对象。请注意，回调和登录不能是相同的值。该模块需要路由到不同的页面，以便完成对从登录事件返回的用户数据的处理。</p><p id="b378" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在nuxt.config.js中:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="085a" class="nf ks iq nb b gy ng nh l ni nj">auth: {<br/>  redirect: {<br/>    login: '/',<br/>    callback: options.redirectUri<br/>  },<br/>  strategies: {<br/>    local: false,<br/>    auth0: {<br/>      domain: options.domain,<br/>      client_id: options.client_id,<br/>    }<br/>  }<br/>},</span></pre><p id="2bdf" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">options对象在一个单独的文件中定义:auth_config.js。为了方便起见，我为我的项目这样做了，但是对于一个真实的项目，我将使用一个. env文件，这样我就可以通过CI/CD管道为每个环境注入正确的值。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="aaef" class="nf ks iq nb b gy ng nh l ni nj">export const options = {<br/>  domain: '...',<br/>  client_id: '...',<br/>  redirectUri: '/signed-in' //or whatever you configure in Auth0 Application Settings<br/>}</span></pre><p id="aa8d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">虽然其中包含的值不是机密的，但还是建议不要将该文件签入源代码管理。您可以稍后修改此文件，使其具有受众属性，并根据构建环境更改这些值。</p><p id="a415" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">接下来，我们将修改主路由以包含一个登录按钮。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="f177" class="nf ks iq nb b gy ng nh l ni nj">&lt;div class="links"&gt;<br/>  &lt;button<br/>    class="button--green"<br/>    @click="login"<br/>  &gt;<br/>    Login<br/>  &lt;/button&gt;<br/>&lt;/div&gt;</span></pre><p id="95a5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们将在Vue实例中定义一个登录方法。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="0926" class="nf ks iq nb b gy ng nh l ni nj">export default {<br/>  methods: {<br/>    login() {<br/>      this.$auth.loginWith('auth0')<br/>    }<br/>  }<br/>}</span></pre><p id="307e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><em class="mf">注意:在撰写本文时，有一个</em> <a class="ae mz" href="https://github.com/nuxt-community/auth-module/issues/750" rel="noopener ugc nofollow" target="_blank"> <em class="mf">问题</em> </a> <em class="mf">需要安装一个额外的npm包。</em></p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="6adf" class="nf ks iq nb b gy ng nh l ni nj">npm install nanoid@2.1.11</span></pre><p id="13f5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在，当您对此进行测试时，您应该被重定向到Auth0登录页面。成功注册或登录后，您将被重定向回redirect_uri，在这个示例项目中，我将其设置为<a class="ae mz" href="http://localhost:3000." rel="noopener ugc nofollow" target="_blank"> http://localhost:3000。</a></p><p id="3af7" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在，让我们进一步修改组件模板，以便在登录后显示不同的内容。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="aafd" class="nf ks iq nb b gy ng nh l ni nj">&lt;div class="links"&gt;<br/>  &lt;b-button<br/>    v-if="!$auth.loggedIn"<br/>    variant="primary"<br/>    size="lg"<br/>    @click="login"<br/>  &gt;<br/>    Login<br/>  &lt;/b-button&gt;<br/>  &lt;b-button<br/>    v-else<br/>    variant="warning"<br/>    @click="logout"<br/>    size="lg"<br/>  &gt;<br/>    Logout<br/>  &lt;/b-button&gt;<br/>&lt;/div&gt;</span></pre><p id="4978" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">注意，我们开始为按钮使用bootstrap-vue组件。b-button组件接受一个变量和一个大小属性。</p><p id="be38" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在，让我们确保页面的脚本部分是正确的:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="bbce" class="nf ks iq nb b gy ng nh l ni nj">import { mapGetters } from 'vuex'<br/>export default {<br/>  methods: {<br/>    login() {<br/>      this.$auth.loginWith('auth0')<br/>    },<br/>    logout() {<br/>      this.$auth.logout();<br/>    }<br/>  },<br/>  computed: mapGetters(['isAuthenticated']),<br/>}</span></pre><p id="ca5d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">太好了！现在，通过这些简单的更改，我们有了一个带身份验证的应用程序。所以我们现在已经完成了第一点和第二点的一部分。</p><p id="2c0d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><a class="ae mz" href="https://github.com/RobotOptimist/demo_survey_app/tree/configured-nuxt-auth" rel="noopener ugc nofollow" target="_blank">下面是GitHub中的结果。</a></p><p id="612f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">#2的剩余部分是构建调查表。作为一个组件，让我们快速地完成它。</p><p id="8fa6" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">Bootstrap-vue让这一切变得非常简单。它包含了作为组件的引导类。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="f8fb" class="nf ks iq nb b gy ng nh l ni nj">&lt;template&gt;<br/>  &lt;b-container fluid&gt;<br/>    &lt;b-form-row&gt;<br/>      &lt;b-col sm="3"&gt;<br/>        &lt;label for="serial-number"&gt;Hydrant Serial Number&lt;/label&gt;<br/>      &lt;/b-col&gt;<br/>      &lt;b-col sm="9"&gt;<br/>        &lt;b-form-input<br/>          type="text"<br/>          v-model="serialNumber"<br/>          id="serial-number"<br/>          placeholder="Enter the hydrant serial number"&gt;<br/>        &lt;/b-form-input&gt;<br/>      &lt;/b-col&gt;<br/>    &lt;/b-form-row&gt;<br/>    &lt;b-form-row&gt;<br/>      &lt;b-col sm="3"&gt;<br/>        &lt;label for="condition"&gt;Hydrant Condition&lt;/label&gt;<br/>      &lt;/b-col&gt;<br/>      &lt;b-col sm="9"&gt;<br/>        &lt;b-form-select <br/>          v-model="condition" <br/>          :options="options" <br/>          id="condition"&gt;<br/>        &lt;/b-form-select&gt;<br/>      &lt;/b-col&gt;<br/>    &lt;/b-form-row&gt;<br/>    &lt;b-form-row align-h="end"&gt;<br/>      &lt;b-col cols="*"&gt;<br/>        &lt;b-button @click="submit"&gt;Submit&lt;/b-button&gt;<br/>      &lt;/b-col&gt;<br/>    &lt;/b-form-row&gt;<br/>  &lt;/b-container&gt;<br/>&lt;/template&gt;</span></pre><p id="b769" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">Bootstrap-vue走的是把网格系统做成组件的路线。我有时会对这个决定提出异议，但它很容易使用。在这个模板中，容器(b-container)有一个行集合(b-row或b-form-row)。每行最多可以有12列。其他列换行到下一行。b-col组件可以表示1到12之间的任意列数。然后，您可以决定对于每个视口大小，它应该占用多少列。</p><p id="c070" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">例如，您可能希望bootstrap b-col在mobile上占据12列(全角),因此您可以指定cols="12 "作为b-col组件的属性。但是您可能会决定它应该在tablet上占据6列(半宽)，因此您会指定sm="6 "，这也是一个属性。这允许你在html中声明一个元素应该如何在每个视窗中以宽度显示。非常方便！</p><p id="da17" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">除了bootstrap-vue为我们抽象出的相当不错的网格系统之外，还有许多我们可以使用的实用组件。在这个表单中，我只需要一个输入、一个选择和一个按钮——所以我使用bootstrap-vue版本。Bootstrap为表单上的良好可访问性提供了开箱即用的支持，组件上的选项可以提醒您一些事情，例如设置占位符。</p><p id="7d0a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这是一个非常简单的表格——我们只需要几样东西。我们将通过发出结果把完成的结果发送回父节点。以下是组件的脚本部分:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="38d7" class="nf ks iq nb b gy ng nh l ni nj">export default {<br/>  data() {<br/>    return {<br/>      serialNumber: "",<br/>      condition: null,<br/>      options: [<br/>       { value: null, text: "Please choose a hydrant condition." },<br/>       { value: "poor", text: "Poor" },<br/>       { value: "fair", text: "Fair" },<br/>       { value: "good", text: "Good" },<br/>       { value: "excellent", text: "Excellent" },<br/>     ],<br/>    };<br/>  },<br/>  methods: {<br/>    submit() {<br/>      this.$emit("submit-form", { serialNumber, condition });<br/>    },<br/>  },<br/>};</span></pre><p id="70e3" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在，父组件可以根据需要处理结果。让我们来看看父母。你猜怎么着让我们继续进行重构，以使用bootstrap-vue。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="82fc" class="nf ks iq nb b gy ng nh l ni nj">&lt;template&gt;<br/>  &lt;b-container class="pt-5"&gt;<br/>    &lt;b-row align-h="center" class="mt-5"&gt;<br/>      &lt;b-col cols="*"&gt;<br/>        &lt;h1 class="title"&gt;Fire Hydrant Surveyor&lt;/h1&gt;<br/>      &lt;/b-col&gt;<br/>    &lt;/b-row&gt;<br/>    &lt;b-row align-h="center" v-if="$auth.loggedIn"&gt;<br/>      &lt;b-col sm="9" class="my-4"&gt;<br/>        &lt;survey-form @submitForm="handleFormResult"&gt;&lt;/survey-form&gt;<br/>      &lt;/b-col&gt;<br/>    &lt;/b-row&gt;<br/>    &lt;b-row align-h="center" class="mt-3"&gt;<br/>      &lt;b-col cols="*"&gt;<br/>        &lt;b-button <br/>          v-if="!$auth.loggedIn" <br/>          variant="primary" <br/>          size="lg" <br/>          @click="login"&gt;<br/>            Login<br/>        &lt;/b-button&gt;<br/>        &lt;b-button <br/>          v-else <br/>          variant="warning" <br/>          @click="logout" <br/>          size="lg"&gt;<br/>            Logout<br/>        &lt;/b-button&gt;<br/>      &lt;/b-col&gt;<br/>    &lt;/b-row&gt;<br/>  &lt;/b-container&gt;<br/>&lt;/template&gt;</span></pre><p id="3db4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在父组件中，我们还需要导入组件并定义处理程序:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="ee63" class="nf ks iq nb b gy ng nh l ni nj">import surveyForm from '../components/survey-form'<br/>export default {<br/>  components: [<br/>   surveyForm<br/>  ],<br/>...<br/>  methods: {<br/>...<br/>    async handleFormResult(formObj) {<br/>      //do stuff<br/>    }<br/>  }<br/>...<br/>}</span></pre><p id="40d5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><a class="ae mz" href="https://github.com/RobotOptimist/demo_survey_app/tree/bootstrap-form" rel="noopener ugc nofollow" target="_blank">这里是我们这一段冒险的GitHub</a></p><p id="6bf4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在我们需要弄清楚如何处理这些表单数据。我们将把数据发送到我们的服务器，但是我们想怎么做呢？我们还需要创建服务工作者来处理离线行为。</p><p id="26a3" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我发现有人创建了一个很好的测试API，所以我可以发送表单数据，而不必部署整个其他项目，我只需要稍微修改一下数据就可以工作了。</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="f3d0" class="nf ks iq nb b gy ng nh l ni nj">async handleFormResult(formObj) {<br/>  //https://jsonplaceholder.typicode.com/posts is a test API I'm borrowing<br/>  //I'm making the data fit because I'm too lazy to make my own test API<br/>  const post = {<br/>    title: formObj.serialNumber,<br/>    body: formObj.condition,<br/>    userId: 1<br/>   }<br/>  try {<br/>    const result = await   this.$axios.$post('https://jsonplaceholder.typicode.com/posts', post);<br/>    console.log(result);<br/>  } catch(e) {<br/>    console.log(e);<br/>  }<br/>}</span></pre><p id="17c3" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">好了，现在当我发送请求时，我得到了一个发送到控制台的结果。只要我在线，一切看起来都很好。</p><p id="c18d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">但是我离线的时候呢？</p><p id="d228" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">事实证明，我们所需要的是nuxt/pwa模块，在这个模块中，workbox将为我们处理所有的事情。</p><p id="b8e7" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">为了实现我们想要的行为——当应用程序离线时重新发送失败的请求——我们需要为workbox创建一个特殊的插件。</p><p id="a6a9" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">在插件文件夹中，我创建了一个名为<code class="fe nl nm nn nb b">workbox-sync.js</code>的文件，并添加了以下代码:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="8bc7" class="nf ks iq nb b gy ng nh l ni nj">const bgSyncPlugin = new workbox.backgroundSync.BackgroundSyncPlugin('formQueue', {<br/>  maxRetentionTime: 24 * 60 // Retry for max of 24 Hours (specified in minutes)<br/>});</span><span id="11fc" class="nf ks iq nb b gy no nh l ni nj">workbox.routing.registerRoute(<br/>  /https:\/\/jsonplaceholder\.typicode\.com\/posts/,<br/>  new workbox.strategies.NetworkOnly({<br/>    plugins: [bgSyncPlugin]<br/>  }),<br/>  'POST'<br/>);</span></pre><p id="5c75" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们正在创建一个新的后台同步插件，然后我们在一条路线上注册这个插件。workbox register route方法有3个参数，一个用于路由的正则表达式(因此您可以使用正则表达式为一系列相似的路由定义相同的行为)、一个策略和http谓词。</p><p id="9ee8" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">接下来，您需要通过<code class="fe nl nm nn nb b">nuxt.config.js</code>中的这些配置行将这个插件添加到工具箱中:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="b213" class="nf ks iq nb b gy ng nh l ni nj">pwa: {<br/>  ...<br/>  workbox: {<br/>    cachingExtensions: '@/plugins/workbox-sync.js',<br/>    enabled: true //should be off actually per workbox docs due to complications when used in prod<br/>  }<br/>}</span></pre><p id="604f" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">请注意，您不能在<code class="fe nl nm nn nb b">workbox-sync.js</code>文件中进行导入。原因是插件被注入到了workbox模块为我们创建的sw.js脚本的中间。无法在脚本中间执行导入。</p><p id="201d" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">另外，你会注意到我有<code class="fe nl nm nn nb b">enabled: true</code>,但是根据@nuxtjs/pwa workbox文档，你通常不应该这样做，因为当你在开发和生产环境之间切换时，这会导致问题。我在这里做是因为太方便了。</p><p id="a676" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在，当我运行<code class="fe nl nm nn nb b">npm run dev</code>时，workbox将创建服务工人。如果我通过浏览器devtools将应用程序切换到离线状态，那么向服务器的发送将会失败，但是一旦我切换回在线状态，服务人员就会重新发送请求。</p><p id="9574" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">让我们来看看实际情况。</p><p id="3c32" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这里我们发送一个成功的请求。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/e522b2c5836f3574ba6a31d3a700c9d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yKqFDGTvSW_5vstrwkU0Ww.png"/></div></div></figure><p id="b392" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">但是让我们从开发工具中将我们的状态改为离线，并观察一个请求失败。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/c3ff52de8d72bc58bc5705634c12e154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0yE8Jsz4ZQzoatdDgg0pAQ.png"/></div></div></figure><p id="29cd" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在服务人员负责重新发送请求。它将使用与最初发送的信息相同的信息，所以如果您使用任何类型的过期身份验证数据，请小心。但是，如果我们有理由确信身份验证令牌将保持有效，直到我们的用户可以重新上线，那么这个解决方案将会非常有效。</p><p id="cb2c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果您不能指望这一点，那么您可能需要使用一个替代的解决方案，在请求失败时，使用<a class="ae mz" href="https://github.com/nuxt-community/localforage-module" rel="noopener ugc nofollow" target="_blank">local feed</a>将数据保存在indexdb中。然后，您需要创建一个定制服务工作器，该工作器需要确定您是否重新联机，并使用最新的可用身份验证凭据重新发送数据。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/465510c9b68a122091effcf95ac7cb9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1CQrOrmv3Ms4JBNhDyxStQ.png"/></div></div></figure><p id="be82" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">对于我们代码的最终结果，让我们在这里看一下<a class="ae mz" href="https://github.com/RobotOptimist/demo_survey_app/tree/pwa-config" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="d4fd" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我们用很少的定制代码满足了所有的需求。</p><p id="a15b" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在进行部署，Auth0需要配置为接受我的生产域名。</p><p id="d6ed" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">此外，我们需要继续重构出<strong class="ll ir"> auth.config.js </strong>并用<strong class="ll ir">替换它。env </strong>。</p><p id="4266" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">我照做了，首先安装了跨环境</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="c205" class="nf ks iq nb b gy ng nh l ni nj">npm install cross-env</span></pre><p id="dce4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">然后我创造了。env文件，并像这样填充它:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="dd35" class="nf ks iq nb b gy ng nh l ni nj">DOMAIN='...auth0.com' <br/>CLIENTID='aHashFromAuth0' <br/>REDIRECTURI='/signed-in'</span></pre><p id="7a52" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">然后，我从nuxt.config中删除了auth.config的导入，并用以下内容替换了这些选项:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="7328" class="nf ks iq nb b gy ng nh l ni nj">auth: {<br/>  redirect: {<br/>    login: '/',<br/>    callback: process.env.REDIRECTURI<br/>  },<br/>  strategies: {<br/>    local: false,<br/>    auth0: {<br/>      domain: process.env.DOMAIN,<br/>      client_id: process.env.CLIENTID,<br/>    }<br/>  }<br/>},</span></pre><p id="3437" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在我可以通过CI/CD管道注入变量。</p><p id="a4a7" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">这是最终的结果。</p><p id="9ec5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">Nuxt有各种各样的库和插件，可以帮助你实现你想做的事情。快速启动项目是非常好的，这样你就可以专注于业务需求。</p><p id="faef" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">希望这对任何做离线第一应用的人都有帮助！</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="e101" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><em class="mf">最初发表于</em><a class="ae mz" href="https://www.macivortech.com/blog/nuxt-offline-first-tutorial" rel="noopener ugc nofollow" target="_blank">T5【https://www.macivortech.com】</a><em class="mf">。</em></p></div></div>    
</body>
</html>