<html>
<head>
<title>JavaScript Refactoring — Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript重构—类</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-refactoring-classes-2fd5338a37b0?source=collection_archive---------5-----------------------#2020-05-15">https://javascript.plainenglish.io/javascript-refactoring-classes-2fd5338a37b0?source=collection_archive---------5-----------------------#2020-05-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/06b62853fd5e729e3a58c4cb977fc916.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8ROeAsfeet6zzwY5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sbk202?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sam Balye</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5bf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以清理我们的JavaScript代码，这样我们可以更容易地使用它们。</p><p id="8fa5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些与清理JavaScript类相关的重构思想。</p><h1 id="3eb4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">内嵌类</h1><p id="021b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们从两个类开始，然后把它们合并成一个。这和之前的重构正好相反。</p><p id="56ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ece0" class="mn lc iq mj b gy mo mp l mq mr">class PhoneNumber {<br/>  constructor(phoneNumber) {<br/>    this.phoneNumber = phoneNumber;<br/>  }<br/>}</span><span id="eed0" class="mn lc iq mj b gy ms mp l mq mr">class Person {<br/>  constructor(name, phoneNumber) {<br/>    this.name = name;<br/>    this.phoneNumber = new PhoneNumber(phoneNumber);<br/>  }<br/>}</span></pre><p id="fe42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe mt mu mv mj b">PhoneNumber</code>类的代码回滚到<code class="fe mt mu mv mj b">Person</code>类，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0706" class="mn lc iq mj b gy mo mp l mq mr">class Person {<br/>  constructor(name, phoneNumber) {<br/>    this.name = name;<br/>    this.phoneNumber = phoneNumber;<br/>  }<br/>}</span></pre><p id="9802" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们分离出来的类不是很复杂，我们可能会这么做。</p><p id="64d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有没有方法的<code class="fe mt mu mv mj b">PhoneNumber</code>类，所以我们可以把它放到<code class="fe mt mu mv mj b">Person</code>类中，因为<code class="fe mt mu mv mj b">phoneNumber</code>是一个<code class="fe mt mu mv mj b">Person</code>实例可以拥有的属性。</p><h1 id="13ec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">隐藏代理</h1><p id="7ebd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在客户端类上创建方法，通过用直接获得我们想要的值的代码填充方法类来隐藏代码的底层实现。</p><p id="bcc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这降低了我们获取想要的项目的代码的耦合性。</p><p id="c917" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不要写以下内容:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4ae5" class="mn lc iq mj b gy mo mp l mq mr">class Department {<br/>  constructor(name, deptHead) {<br/>    this.name = name;<br/>    this.deptHead = deptHead;<br/>  }</span><span id="b46f" class="mn lc iq mj b gy ms mp l mq mr">  getDeptHead() {<br/>    return deptHead;<br/>  }<br/>}</span><span id="b9d5" class="mn lc iq mj b gy ms mp l mq mr">class Person {<br/>  constructor(name, dept) {<br/>    this.name = name;<br/>    this.dept = dept;<br/>  }</span><span id="98b0" class="mn lc iq mj b gy ms mp l mq mr">  getDept() {<br/>    return this.dept;<br/>  }<br/>}</span><span id="3435" class="mn lc iq mj b gy ms mp l mq mr">const deptHead = new Person('jane');<br/>const dept = new Department('customer service', deptHead);<br/>const employee = new Person('joe', dept);<br/>const manager = employee.getDept().getDeptHead();</span></pre><p id="eab5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就要求我们在找到部门主管之前先找到部门，就像我们在最后一行所做的那样。</p><p id="a30f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="94d1" class="mn lc iq mj b gy mo mp l mq mr">class Department {<br/>  constructor(name, deptHead) {<br/>    this.name = name;<br/>    this.deptHead = deptHead;<br/>  }<br/>}</span><span id="6765" class="mn lc iq mj b gy ms mp l mq mr">class Person {<br/>  constructor(name, dept) {<br/>    this.name = name;<br/>    this.dept = dept;<br/>  }</span><span id="8989" class="mn lc iq mj b gy ms mp l mq mr">  getDept() {<br/>    return this.dept;<br/>  }</span><span id="93d3" class="mn lc iq mj b gy ms mp l mq mr">  getDeptHead() {<br/>    return this.dept.deptHead;<br/>  }<br/>}</span><span id="bda6" class="mn lc iq mj b gy ms mp l mq mr">const deptHead = new Person('jane');<br/>const dept = new Department('customer service', deptHead);<br/>const employee = new Person('joe', dept);<br/>const manager = employee.getDeptHead();</span></pre><p id="ec87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们所做的只是将<code class="fe mt mu mv mj b">getDeptHead</code>方法添加到<code class="fe mt mu mv mj b">person</code>中，以直接从部门获得部门主管。</p><p id="e543" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们不必先得到部门再得到部门负责人，这减少了<code class="fe mt mu mv mj b">Person</code>和<code class="fe mt mu mv mj b">Department</code>类之间的耦合。</p><h1 id="8389" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">引进外国方法</h1><p id="07ef" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过用<code class="fe mt mu mv mj b">Object.assign</code>给一个不能直接修改的类添加方法来给它添加一个外来方法。</p><p id="9142" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下内容:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="df44" class="mn lc iq mj b gy mo mp l mq mr">class Foo {<br/>  //...<br/>}</span><span id="8a3e" class="mn lc iq mj b gy ms mp l mq mr">const mixin = {<br/>  bar() {<br/>    //...<br/>  }<br/>}</span><span id="a3b6" class="mn lc iq mj b gy ms mp l mq mr">Object.assign(Foo.prototype, mixin)</span></pre><p id="53e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们通过调用<code class="fe mt mu mv mj b">Object.assign</code>向<code class="fe mt mu mv mj b">Foo</code>添加了<code class="fe mt mu mv mj b">bar</code>实例方法，因为<code class="fe mt mu mv mj b">Foo</code>是一个我们不能修改的类。</p><h1 id="450b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">引入本地扩展</h1><p id="d763" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">除了直接向类中添加新方法之外，我们还可以通过将包含方法的类作为不能直接修改的类的子类，来创建包含我们想要调用的额外方法的新类。</p><p id="9329" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下内容:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c4b9" class="mn lc iq mj b gy mo mp l mq mr">class Foo {<br/>  //...<br/>}</span><span id="3edb" class="mn lc iq mj b gy ms mp l mq mr">class Bar extends Foo {<br/>  bar() {<br/>    //...<br/>  }<br/>}</span></pre><p id="a0b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们创建了一个包含我们想要调用的方法的<code class="fe mt mu mv mj b">Foo</code>的子类，其中<code class="fe mt mu mv mj b">Foo</code>是一个我们不能更改的类。</p><p id="636c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们不必通过向它的原型添加东西来修改<code class="fe mt mu mv mj b">Foo</code>。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/f60d1ec5db0a150c945f3f2241cb5060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Qi_d64pz4OCGoxDV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kimberlyfarmer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kimberly Farmer</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c43f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">自封装字段</h1><p id="343a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在直接访问的字段中添加getters和setters方法，这样我们就可以封装它。</p><p id="3dc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不要编写以下内容:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="30e0" class="mn lc iq mj b gy mo mp l mq mr">class Counter {<br/>  inRange(arg) {<br/>    return arg &gt;= this._low &amp;&amp; arg &lt;= this._high;<br/>  }<br/>}</span></pre><p id="8511" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8418" class="mn lc iq mj b gy mo mp l mq mr">class Counter {<br/>  inRange(arg) {<br/>    return arg &gt;= low() &amp;&amp; arg &lt;= high();<br/>  }</span><span id="d60e" class="mn lc iq mj b gy ms mp l mq mr">  get low() {<br/>    return this._low;<br/>  }</span><span id="f500" class="mn lc iq mj b gy ms mp l mq mr">  get high() {<br/>    return this._high;<br/>  }<br/>}</span></pre><p id="f273" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们可以封装字段，我们也可以对其应用其他操作，而不需要访问<code class="fe mt mu mv mj b">high</code>和<code class="fe mt mu mv mj b">low</code>字段，直接对它们应用操作。</p><h1 id="abf4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="dddb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将一个类中不做很多事情的成员移到另一个类中，这样我们就可以删除不做很多事情的类。</p><p id="f49f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了减少类之间的耦合，我们可以用方法直接得到我们想要的，而不是用迂回的方式。</p><p id="a521" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以封装字段，这样我们就可以获得一个值，并在我们返回的值之前做一些事情。</p><h2 id="dfd3" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">来自简明英语团队的说明</h2><p id="3ce2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">简明英语刚刚推出了一个YouTube频道！我们希望你现在就订阅<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">来支持我们！</strong> </a></p></div></div>    
</body>
</html>