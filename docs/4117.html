<html>
<head>
<title>Object-Oriented JavaScript — Inheritance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的JavaScript —继承</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-oriented-javascript-inheritance-346817fa7f02?source=collection_archive---------9-----------------------#2020-11-17">https://javascript.plainenglish.io/object-oriented-javascript-inheritance-346817fa7f02?source=collection_archive---------9-----------------------#2020-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5d3b0a0ad939b7e00c06cd557a981c9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*z5vxedX0WMZCnn7F"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jjying?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JJ Ying</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="62a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看继承。</p><h1 id="e531" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">原型链接</h1><p id="4f8d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">一个对象有一个原型链。</p><p id="97ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从它们继承属性。</p><p id="6f86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下代码来创建构造函数链:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7605" class="mn lc iq mj b gy mo mp l mq mr">function Shape() {}<br/>Shape.prototype.name = 'Shape';<br/>Shape.prototype.toString = function() {<br/>  return this.name;<br/>};</span><span id="89d6" class="mn lc iq mj b gy ms mp l mq mr">function Square() {}<br/>Square.prototype = new Shape();<br/>Square.prototype.constructor = Square;<br/>Square.prototype.name = 'Square';</span></pre><p id="c565" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有带有一些原型属性的<code class="fe mt mu mv mj b">Shape</code>构造函数。</p><p id="46c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建了一个<code class="fe mt mu mv mj b">Square</code>构造函数，将<code class="fe mt mu mv mj b">prototype</code>设置为<code class="fe mt mu mv mj b">Shape</code>构造函数。</p><p id="1c70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe mt mu mv mj b">constructor</code>设置为<code class="fe mt mu mv mj b">Square</code>，如果我们将<code class="fe mt mu mv mj b">instanceof</code>与<code class="fe mt mu mv mj b">Square</code>实例一起使用，那么<code class="fe mt mu mv mj b">instanceof sqaure</code>将返回<code class="fe mt mu mv mj b">true</code>。</p><p id="e20f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想在子构造函数中调用父构造函数来填充它的属性，我们可以修改代码。</p><p id="8f3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b5d6" class="mn lc iq mj b gy mo mp l mq mr">function Shape(name) {<br/>  this.name = name;<br/>}<br/>Shape.prototype.toString = function() {<br/>  return this.name;<br/>};</span><span id="a414" class="mn lc iq mj b gy ms mp l mq mr">function Square(name, length) {<br/>  Shape.call(this, name);<br/>  this.length = length<br/>}<br/>Square.prototype = Object.create(Shape.prototype);<br/>Square.prototype.constructor = Square;</span></pre><p id="fb0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe mt mu mv mj b">name</code>属性创建<code class="fe mt mu mv mj b">Shape</code>构造函数。</p><p id="40ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们有了带有<code class="fe mt mu mv mj b">name</code>和<code class="fe mt mu mv mj b">length</code>参数的<code class="fe mt mu mv mj b">Square</code>属性。</p><p id="7147" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">call</code>调用<code class="fe mt mu mv mj b">Shape</code>构造函数，我们将第一个参数设置为<code class="fe mt mu mv mj b">this</code>，所以用<code class="fe mt mu mv mj b">Square</code>构造函数作为<code class="fe mt mu mv mj b">this</code>调用它。</p><p id="1f8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">name</code>是我们传递给<code class="fe mt mu mv mj b">Shape</code>构造函数的内容。</p><p id="71eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了创建原型，我们调用<code class="fe mt mu mv mj b">Object.create</code>来继承<code class="fe mt mu mv mj b">Shape.prototype</code>的属性。</p><p id="6ac4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们以同样的方式设置<code class="fe mt mu mv mj b">constructor</code>，以便<code class="fe mt mu mv mj b">instanceof</code>仍然能够正确报告。</p><h1 id="32af" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类别语法</h1><p id="0a42" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用类语法来简化这个过程。</p><p id="a61d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了它，我们可以重写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e72c" class="mn lc iq mj b gy mo mp l mq mr">function Shape(name) {<br/>  this.name = name;<br/>}<br/>Shape.prototype.toString = function() {<br/>  return this.name;<br/>};</span><span id="ced5" class="mn lc iq mj b gy ms mp l mq mr">function Square(name, length) {<br/>  Shape.call(this, name);<br/>  this.length = length<br/>}<br/>Square.prototype = Object.create(Shape.prototype);<br/>Square.prototype.constructor = Square;</span></pre><p id="dd9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">收件人:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3c85" class="mn lc iq mj b gy mo mp l mq mr">class Shape {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="0754" class="mn lc iq mj b gy ms mp l mq mr">  toString() {<br/>    return this.name;<br/>  };<br/>}</span><span id="fd73" class="mn lc iq mj b gy ms mp l mq mr">class Square extends Shape {<br/>  constructor(name, length) {<br/>    super(name);<br/>    this.length = length<br/>  }<br/>}</span></pre><p id="c8e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe mt mu mv mj b">extends</code>关键字从<code class="fe mt mu mv mj b">Square</code>类中的<code class="fe mt mu mv mj b">Shape</code>属性继承属性。</p><p id="0540" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">super(name)</code>同<code class="fe mt mu mv mj b">Shape.call(this, name);</code>。</p><h1 id="3771" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">原型</h1><p id="de1c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe mt mu mv mj b">__proto__</code>属性得到链中的原型。</p><p id="8b0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="69a9" class="mn lc iq mj b gy mo mp l mq mr">console.log(square.__proto__);</span></pre><p id="4c98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到了<code class="fe mt mu mv mj b">Shape</code>构造函数。</p><p id="0824" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以得到<code class="fe mt mu mv mj b">__proto__</code>属性的<code class="fe mt mu mv mj b">__proto__</code>，所以我们可以得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="64c0" class="mn lc iq mj b gy mo mp l mq mr">console.log(square.__proto__.__proto__);</span></pre><p id="1cc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到了<code class="fe mt mu mv mj b">Shape.prototype</code>对象。</p><p id="367b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们再次调用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ca94" class="mn lc iq mj b gy mo mp l mq mr">console.log(square.__proto__.__proto__.__proto___);</span></pre><p id="d544" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了<code class="fe mt mu mv mj b">Object.prototype</code>对象。</p><p id="169f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过写信来证实这一点:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="31fb" class="mn lc iq mj b gy mo mp l mq mr">console.log(square.__proto__ === Square.prototype);<br/>console.log(square.__proto__.__proto__ === Shape.prototype);<br/>console.log(square.__proto__.__proto__.__proto__  === Object.prototype);</span></pre><p id="d2ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后他们都登录<code class="fe mt mu mv mj b">true</code>。</p><h1 id="a495" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象从对象继承</h1><p id="bbc3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对象可以直接从其他对象继承。</p><p id="afbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们使用<code class="fe mt mu mv mj b">Object.create</code>方法返回一个对象，该对象返回一个具有给定原型对象的对象。</p><p id="2065" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3692" class="mn lc iq mj b gy mo mp l mq mr">const proto = {<br/>  foo: 1<br/>};<br/>const obj = Object.create(proto);</span></pre><p id="40c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe mt mu mv mj b">__proto__</code>属性检查<code class="fe mt mu mv mj b">obj</code>的原型:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fcd2" class="mn lc iq mj b gy mo mp l mq mr">console.log(obj.__proto__ === proto);</span></pre><p id="0ee1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后那个日志<code class="fe mt mu mv mj b">true</code>。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/752d7d1d663d942e68ec631eae64a111.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DKySz8FJHA4Fc0ic"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@hush52?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hush Naidoo</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3d58" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4b15" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建从其他对象继承的对象。</p><p id="0a0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以检查对象的原型链，看看从。</p><p id="81dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，类语法使构造函数的继承变得更加容易。</p><p id="03b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>