<html>
<head>
<title>Intersection Observer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">交叉观测器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/intersection-observer-928a0ce309?source=collection_archive---------6-----------------------#2020-07-29">https://javascript.plainenglish.io/intersection-observer-928a0ce309?source=collection_archive---------6-----------------------#2020-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/1e8aa9c5835adae31c76061e465cf8ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2iK7DHLZphv9SN7z"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@dnevozhai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Denys Nevozhai</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="4a41" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">导航风格和惰性加载变得很容易</h2></div><p id="0ad2" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这篇文章旨在用例子解释交集观察者API，这样你就可以了解如何在生产现场使用它们。我最近开始研究这个惊人的API，并发现了一些非常好的资源。其中之一是凯文·鲍威尔(Kevin Powell)的《T2》，这篇文章很大程度上是受他的视频启发。</p><p id="58de" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们将基本上从概念的介绍开始，并以一些例子结束。</p><h2 id="51f8" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">那么什么是交叉点观察者呢</h2><p id="09ca" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">交集观察者API提供了一种简单的方法来观察和注册回调，以便在页面上的元素进入视图时触发。</p><p id="d2be" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们只需创建一个交叉点观察器对象，如下所示:</p><p id="073a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mp mq mr ms b">let observer = new IntersectionObserver(callback, options);</code></p><p id="e69f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mp mq mr ms b">IntersectionObserver</code>对象的构造函数采用<strong class="kx jh">两个参数</strong>。第一个是一个<strong class="kx jh">回调</strong>函数，一旦观察者注意到一个交集就执行这个函数，并且异步传递了关于该交集的一些数据。</p><p id="48bf" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第二个(可选)参数是<strong class="kx jh">选项</strong>，一个有信息来定义什么是“交叉点”的对象。我们可能不想知道某个元素什么时候会出现，但是只有当它<em class="mt">完全</em>可见的时候。类似的东西是通过options参数定义的。</p><p id="6296" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">选项</strong>有三个属性:</p><ul class=""><li id="3f1a" class="mu mv jg kx b ky kz lb lc le mw li mx lm my lq mz na nb nc bi translated"><strong class="kx jh">根</strong>-被观察元素将相交的祖先元素/视口。</li><li id="1e76" class="mu mv jg kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated"><strong class="kx jh">根边距</strong>-值的格式与CSS边距或填充值相同的字符串。例如:“3rem 2rem”。这将在根元素周围创建一个指定大小的边距，以有效地为交叉点创建一个插图或开始。默认为“0px”。</li><li id="f504" class="mu mv jg kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated"><strong class="kx jh">阈值</strong> —一个值数组(0到1.0之间)，每个值代表一个元素在根中相交或交叉的距离，回调将在该距离处被触发。如果回调为0.5，则在元素处于或超过其半可见阈值时触发回调。</li></ul></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="b980" class="np ls jg bd lt nq nr ns lw nt nu nv lz km nw kn mc kp nx kq mf ks ny kt mi nz bi translated">Navbar背景更改</h1><p id="3fe9" class="pw-post-body-paragraph kv kw jg kx b ky mk kh la lb ml kk ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在网站上工作时，我们经常会有导航栏，一开始是透明的，但是当我们滚动到一定高度时，我们希望它们有一个合适的背景和根据页面的对比。您可以在下面的演示中注意到这个问题。一旦我们到达<strong class="kx jh">随机栏</strong>部分，背景似乎与该部分融合在一起，使得阅读其内容变得困难。</p><figure class="ob oc od oe gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oa"><img src="../Images/fc825279b208627a386feaeec5b6c1ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Udz48oIlmpu2-CIeFhsvrg.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Observe the header here</figcaption></figure><p id="d863" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以在这里使用交叉点观察器，使导航条的背景更加直观。</p><p id="9c8c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们先抓住标题和顶部容器元素:</p><pre class="ob oc od oe gt of ms og oh aw oi bi"><span id="0b45" class="lr ls jg ms b gy oj ok l ol om">const header = document.querySelector(“header”);<br/>const topContainer = document.querySelector(“.top-container”);</span></pre><p id="177b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">这里顶层容器是交集将触发</strong>的父元素或祖先元素。我们还将在<strong class="kx jh">选项</strong>中定义一个阈值，以允许标题在离开父元素之前获得背景样式。</p><p id="7de8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mp mq mr ms b">const topContainerOptions = { threshold: 0.1 };</code></p><p id="2046" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建交叉点观察点:</p><pre class="ob oc od oe gt of ms og oh aw oi bi"><span id="0b5a" class="lr ls jg ms b gy oj ok l ol om">const topContainerObserver = new IntersectionObserver(function(entries) {<br/>    entries.forEach(entry =&gt; {<br/>        // code to add/remove background from header<br/>    });<br/>  },<br/>topContainerOptions);</span></pre><p id="5a3e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">观察者接受回退中的条目，我们简单地遍历它们。回调接收到的条目列表包括每个目标的一个条目，这些条目报告了其交集状态的变化。</p><p id="4407" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在循环内部，通过检查entry对象上的<strong class="kx jh">is intersection</strong>属性，我们可以完成所需的行为。</p><pre class="ob oc od oe gt of ms og oh aw oi bi"><span id="045a" class="lr ls jg ms b gy oj ok l ol om">const topContainerObserver = new IntersectionObserver(function(entries) {<br/>    entries.forEach(entry =&gt; {<br/>         if (!entry.isIntersecting) {<br/>             header.classList.add("nav-scrolled");<br/>         } else {<br/>             header.classList.remove("nav-scrolled");<br/>         }<br/>    });<br/>  },<br/>topContainerOptions);</span></pre><p id="ebf5" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果找到的条目不相交，只需添加<code class="fe mp mq mr ms b">nav-scrolled</code>类，否则删除它。这个类只是给标题添加了背景样式。</p><pre class="ob oc od oe gt of ms og oh aw oi bi"><span id="adfc" class="lr ls jg ms b gy oj ok l ol om">.nav-scrolled {<br/>    background: #999;<br/>    z-index: 2;<br/>}</span></pre><p id="4974" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后观察目标元素:</p><p id="d329" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><code class="fe mp mq mr ms b">topContainerObserver.observe(topContainer);</code></p><p id="ea15" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是最终输出:</p><figure class="ob oc od oe gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi on"><img src="../Images/a89f122d5ed464fc6e3878617248bd96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*g_EMGK39U4xtKd_aVtV_7w.gif"/></div></div></figure><p id="9aeb" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以根据希望何时应用样式或何时触发交叉点来调整阈值。</p><figure class="ob oc od oe gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/4b557738ab056aa9cdc3288daa1d1ac1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*he-W9pgNRFuZBZL_2fKjyw.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">threshold set to 0.5 here</figcaption></figure><p id="cb5a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">代码沙箱:</p><figure class="ob oc od oe gt is"><div class="bz fp l di"><div class="op oq l"/></div></figure></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="f03c" class="np ls jg bd lt nq nr ns lw nt nu nv lz km nw kn mc kp nx kq mf ks ny kt mi nz bi translated">延迟加载图像</h1><figure class="ob oc od oe gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi or"><img src="../Images/3133a21b125805bfe492fd45473ba7e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Bhx81UHUZ_XlfniF"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@photoholgic?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Holger Link</a> on <a class="ae jd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="220e" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这仅仅意味着在页面加载时不加载图像，而是按需加载。我们将在交叉点观察器的帮助下在卷轴上使用它。</p><p id="67c9" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最初，HTML将在所有img标签上使用data属性作为data-src，而不是src，因为我们不想一开始就加载它们。</p><figure class="ob oc od oe gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi os"><img src="../Images/71169b6926ab75416d42def99a1c42ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_LcQq0aRk46MI3aPuf8gfw.png"/></div></div></figure><p id="3e29" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是该脚本的样子:</p><pre class="ob oc od oe gt of ms og oh aw oi bi"><span id="e852" class="lr ls jg ms b gy oj ok l ol om">const images = document.querySelectorAll(“.gallery img”);</span><span id="09dd" class="lr ls jg ms b gy ot ok l ol om">const imagesObeserver = new IntersectionObserver(function(entries) {<br/>    entries.forEach(entry =&gt; {<br/>        if (entry.isIntersecting) {<br/>            showImages(entry.target);<br/>            imagesObeserver.unobserve(entry.target);<br/>        }<br/>    });<br/>  },<br/>{});</span></pre><p id="e814" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果entry object <code class="fe mp mq mr ms b">isIntersecting</code>为真，我们只需在下面定义的showImages函数中加载图像，然后不观察目标，因为加载后我们不需要观察它。</p><p id="be27" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">输入图像标签的数据-src到src属性:</p><pre class="ob oc od oe gt of ms og oh aw oi bi"><span id="e8cc" class="lr ls jg ms b gy oj ok l ol om">function showImages(el) {<br/>    el.src = el.dataset.src;<br/>}</span></pre><p id="dd31" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于要观察多个图像，我们需要遍历它们:</p><pre class="ob oc od oe gt of ms og oh aw oi bi"><span id="7f02" class="lr ls jg ms b gy oj ok l ol om">for (let image of images) {<br/>    imagesObserver.observe(image);<br/>}</span></pre><p id="d5e1" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是惰性负载的运行情况:</p><figure class="ob oc od oe gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ou"><img src="../Images/91d246dbb25a481e96b064e55d9e3231.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*n2sBeURPilW1G1jyqWfNhg.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Images being lazy loaded. See the network tab to see the loading of resources</figcaption></figure><p id="2dd8" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是代码沙箱:</p><figure class="ob oc od oe gt is"><div class="bz fp l di"><div class="op oq l"/></div></figure></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h2 id="5d75" class="lr ls jg bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">交叉点观察器API的一些其他用例</h2><ul class=""><li id="9589" class="mu mv jg kx b ky mk lb ml le ov li ow lm ox lq mz na nb nc bi translated">实现“无限滚动”网站，当你滚动的时候，越来越多的内容被加载和呈现，这样用户就不需要翻页了。</li><li id="46b4" class="mu mv jg kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated">报告广告的可见性，以便计算广告收入。</li><li id="f15e" class="mu mv jg kx b ky nd lb ne le nf li ng lm nh lq mz na nb nc bi translated">根据用户是否会看到结果来决定是否执行任务或动画过程。</li></ul></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="4cf5" class="np ls jg bd lt nq nr ns lw nt nu nv lz km nw kn mc kp nx kq mf ks ny kt mi nz bi translated">资源</h1><div class="ip iq gp gr ir oy"><a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd jh gy z fp pd fr fs pe fu fw jf bi translated">交叉点观察器API</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">交叉点观察器API提供了一种异步观察目标元素交叉点变化的方法…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">developer.mozilla.org</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm ix oy"/></div></div></a></div><div class="ip iq gp gr ir oy"><a href="https://alligator.io/js/intersection-observer/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd jh gy z fp pd fr fs pe fu fw jf bi translated">使用交叉点观察器API触发动画和转换</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">随着浏览器支持的迅速增加，交叉点观察器API引起了人们的极大兴趣，它…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">鳄鱼. io</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm ix oy"/></div></div></a></div></div></div>    
</body>
</html>