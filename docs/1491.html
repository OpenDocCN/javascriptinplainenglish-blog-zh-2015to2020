<html>
<head>
<title>How to Send Messages with the Broadcast Channel API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用广播通道API发送消息</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/sending-messages-with-the-broadcast-channel-api-214435dba4ff?source=collection_archive---------5-----------------------#2020-03-23">https://javascript.plainenglish.io/sending-messages-with-the-broadcast-channel-api-214435dba4ff?source=collection_archive---------5-----------------------#2020-03-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d31b62f3f62bd00cefb32eaabc27002e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IYi2h9bYnNxhiTz5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ripato?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ricardo Gomez Angel</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e0eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在相同来源的浏览上下文(如窗口、选项卡、框架或iframe)之间发送消息，我们可以使用广播通道API。</p><p id="78ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何使用它来发送和接收消息。</p><h1 id="afae" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">广播频道API</h1><p id="7660" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了使用这个API，我们必须创建一个<code class="fe me mf mg mh b">BroadcastChannel</code>对象来监听底层通道。</p><p id="a724" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们就可以接收任何发布到它上面的消息。我们不需要维护iframes的引用或者我们想要与之交流的工人。</p><p id="c81f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相同来源的任何东西都可以通过创建一个<code class="fe me mf mg mh b">BroadcasChannel</code>来订阅一个特定的频道，然后它们之间将进行全双工通信。</p><p id="0aa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6a85" class="mq lc iq mh b gy mr ms l mt mu">const bc = new BroadcastChannel("test_channel");<br/>bc.postMessage("test");<br/>bc.onmessage = ev =&gt; {<br/>  console.log(ev.data);<br/>};<br/>bc.close();</span></pre><p id="a82f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们创建了一个<code class="fe me mf mg mh b">BroadcastChannel</code>实例，然后调用<code class="fe me mf mg mh b">postMessage</code>并设置<code class="fe me mf mg mh b">onmessage</code>属性来监听发送的消息。</p><p id="e01c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">data</code>属性访问数据。</p><p id="83cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，我们可以调用<code class="fe me mf mg mh b">close</code>来关闭通道。</p><p id="85a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以发送任何类型的对象，而不仅仅是字符串。</p><h1 id="a829" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">消息事件</h1><p id="2ed9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">onmessage</code>处理程序中的<code class="fe me mf mg mh b">ev</code>参数是<code class="fe me mf mg mh b">MessageEvent</code>对象。</p><p id="89d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有几个我们可以访问的只读属性:</p><ul class=""><li id="6c84" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><code class="fe me mf mg mh b">data</code> —消息发送方发送的数据。这将是我们传递到<code class="fe me mf mg mh b">postMessage</code>中的内容</li><li id="ca53" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">origin</code> —表示发出的消息来源的字符串</li><li id="bd93" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">lastEventId</code> —表示事件的唯一ID的字符串</li><li id="f582" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">source</code>—<code class="fe me mf mg mh b">MessageEventSource</code>对象，(可以是<code class="fe me mf mg mh b">WindowProxy</code>、<code class="fe me mf mg mh b">MessagePort</code>或<code class="fe me mf mg mh b">ServiceWorker</code>对象)，代表消息发送者</li><li id="efe1" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe me mf mg mh b">ports</code>—<code class="fe me mf mg mh b">MessagePort</code>对象的数组，表示与发送消息的通道相关联的端口。</li></ul><h1 id="42f7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">处理错误</h1><p id="f5e1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了处理发送消息的错误，我们可以为广播频道对象的<code class="fe me mf mg mh b">onmessageerror</code>属性设置一个事件处理程序。</p><p id="cd71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="091d" class="mq lc iq mh b gy mr ms l mt mu">bc.onmessageerror = e =&gt; console.log(e);</span></pre><p id="9672" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以记录出现的任何错误。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/ca72171436a9d0c6fb1d7e1758611b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lK0WIo_eK8fn_iYF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@pawelkadysz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pawel Kadysz</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="64db" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">名字</h1><p id="4abc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">name</code>属性得到频道的名称。</p><p id="9e30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="12fe" class="mq lc iq mh b gy mr ms l mt mu">const bc = new BroadcastChannel("test_channel");<br/>console.log(bc.name);</span></pre><p id="bbd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以从<code class="fe me mf mg mh b">console.log</code>中看到我们的广播频道名称是<code class="fe me mf mg mh b">test_channel</code>。</p><h1 id="9a12" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="746f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">广播通道API是一个非常简单的API，它让我们可以进行跨上下文通信。</p><p id="2e36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它可用于检测同一站点原始环境中其他选项卡中的用户操作，如用户登录帐户时。</p><p id="2e4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有消息协议，不同上下文中的不同文档需要自己实现它。</p><p id="93cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，也没有协商，这也不是规范所要求的。</p></div></div>    
</body>
</html>