<html>
<head>
<title>Microfrontends — bringing JavaScript frameworks together (React, Angular, Vue etc)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">微前端——整合JavaScript框架(React、Angular、Vue等)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/microfrontends-bringing-javascript-frameworks-together-react-angular-vue-etc-5d401cb0072b?source=collection_archive---------0-----------------------#2019-06-22">https://javascript.plainenglish.io/microfrontends-bringing-javascript-frameworks-together-react-angular-vue-etc-5d401cb0072b?source=collection_archive---------0-----------------------#2019-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="712b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf">反应，角，Vue，余烬，骨干，模板，预反应… </em>。事实上，现在可能又有一部正在上映！</h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/2f6dc87cc678a9a954a16b7b93165444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jtNFdGC9rgsb8Q8mjWeGxA.png"/></div></div></figure><p id="d619" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">像生活中的大多数事情一样，各种选择传达了一种有毒的文化<em class="lo">我的比你的好</em>和<em class="lo">你错了，我是对的</em>。</p><p id="731f" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">既然技术进步让我们陷入了这种困境，那么它有没有可能让我们摆脱困境呢？</p><p id="ab6e" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><em class="lo">输入微前端… </em></p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="b2b9" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">微前端简介</h1><p id="690a" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">不管你的框架如何，现代的UI开发已经变成了关于<strong class="ku ir">组件组合</strong>的事情:你适应框架的<em class="lo">做事方式</em>通过遵循它们的模式和惯例来创建组件，这些组件通常由某种数据模型支撑，通常以服务或状态对象的形式。</p><p id="6bca" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><em class="lo">例如:</em> Angular对如何在前端构建一切有强烈的看法。尽管React只处理组件，但它有一个由以React为中心的开发人员社区驱动的庞大生态系统。</p><p id="5566" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">微前端最近聚集了巨大的动力，因为它允许多个团队使用多个框架在单个UI上工作，但是它真的能改变UI开发的前景吗？</p><p id="6f80" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">在本文中，我将花一些时间研究SDLC(软件开发生命周期)以及采用这种架构的优势。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="5704" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">问题出在哪里？</h1><p id="e4ba" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">UI开发的当前趋势是使用选定的框架构建功能丰富且强大的浏览器应用程序(单页面应用程序)。</p><p id="00ed" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">开发导致构建许多小组件，然后在某种构建过程中使用webpack或rollup之类的东西将这些组件捆绑在一起。</p><p id="0c87" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">随着时间的推移，通常由单独或多个团队开发的UI层不断增长，变得越来越难以维护，从而创建了一个巨大的单片前端。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mt"><img src="../Images/686cbf24a11036a8ca7699f5cb6bdc10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mzAyRJcbQN0AY98dr9bhfg.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Monolithic frontend SDLC</figcaption></figure><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mt"><img src="../Images/ef1798e05c35300906684c8f68a0cb1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cQ11KhfHiwu5CObs9Pz7Pg.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Monolithic frontends deployment architecture</figcaption></figure></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="ec63" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">逆转微服务反模式:</h1><p id="d333" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">Microfrontends着眼于消除整体构建步骤，并产生可以独立构建和部署的完全解耦的服务:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mt"><img src="../Images/4f68a90fd0f20fb07af93de4fb790c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OR8YBdtDFDBfXW697l0VFQ.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Microfrontend SDLC</figcaption></figure><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mt"><img src="../Images/2c6a85ec5b48df06b2af4dc8d36de201.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_KnCktAkrZfvPyogr5Uuqw.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Microfrontend deployment architecture</figcaption></figure><p id="f3a0" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">现在我们的UI架构具备了传统微服务的所有品质:</p><ul class=""><li id="e88e" class="my mz iq ku b kv kw ky kz lb na lf nb lj nc ln nd ne nf ng bi translated">高度可维护和可测试</li><li id="b639" class="my mz iq ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">松散耦合</li><li id="8509" class="my mz iq ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">可独立部署</li><li id="e5f8" class="my mz iq ku b kv nh ky ni lb nj lf nk lj nl ln nd ne nf ng bi translated">围绕业务能力组织</li></ul></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><h1 id="be85" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">这怎么能把大框架结合在一起呢？</h1><p id="1b8e" class="pw-post-body-paragraph ks kt iq ku b kv mo jr kx ky mp ju la lb mq ld le lf mr lh li lj ms ll lm ln ij bi translated">由于我们已经将UI组件解耦到许多微前端中，我们不再需要指定每个组件使用哪个框架。</p><p id="7fce" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">下图显示了我们如何<em class="lo">能够</em>潜在地让不同的应用团队使用不同的技术来创建他们独立构建和发布的微前端:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mt"><img src="../Images/ca89f2bef1be5edbdc7534d325954593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*64pi9rV0JelzrJj71P013g.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">SDLC using multiple frameworks</figcaption></figure><p id="32a9" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">有几种方法利用技术解决这个问题，但让我举一个例子:</p><ol class=""><li id="a8cd" class="my mz iq ku b kv kw ky kz lb na lf nb lj nc ln nm ne nf ng bi translated"><strong class="ku ir">开发:</strong>三个团队为每个微前端使用不同的JavaScript框架</li><li id="9b59" class="my mz iq ku b kv nh ky ni lb nj lf nk lj nl ln nm ne nf ng bi translated"><strong class="ku ir">构建:</strong>将他们的微前端组件包装成<strong class="ku ir"> <em class="lo"> web组件</em> </strong>并将他们的项目构建成一个JavaScript文件</li><li id="545b" class="my mz iq ku b kv nh ky ni lb nj lf nk lj nl ln nm ne nf ng bi translated"><strong class="ku ir"> Release: </strong>在使用Ngnix的docker容器中发布一个JavaScript文件</li></ol><p id="bc7d" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">一旦我们发布了我们的微前端，我们应该将它们组合在一个UI层中。微前端之间的通信应该由复合层来处理，复合层应该有一个明确定义的契约。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="f1dc" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated"><strong class="ku ir"> <em class="lo">免责声明:</em></strong><em class="lo"/><strong class="ku ir"><em class="lo">Web组件</em> </strong> <em class="lo">并不是解决这个问题的唯一方法，但是如果你想进一步探索这个问题，请查看本文:</em></p><div class="nn no gp gr np nq"><a href="https://medium.com/javascript-in-plain-english/create-micro-frontends-using-web-components-with-support-for-angular-and-react-2d6db18f557a" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">使用Web组件创建微前端(支持Angular和React)</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">如果你是React或Angular，Ember或Vue，让我们创建一个地方，让他们都可以生活在一起，在完美的和谐使用…</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kq nq"/></div></div></a></div></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mt"><img src="../Images/14d85aba219780e27dfb21857cc4b8f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tZRDma3Wr2BPrqIrkXa-BQ.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">Deployment architecture using multiple frameworks</figcaption></figure><p id="4fed" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">从用户的角度来看，他们访问单个应用程序，但是开发人员解决问题的能力不再受应用程序使用的单个框架的限制。</p><p id="57aa" class="pw-post-body-paragraph ks kt iq ku b kv kw jr kx ky kz ju la lb lc ld le lf lg lh li lj lk ll lm ln ij bi translated">这可能是Angular v React v Vue的宗教辩论的结束吗？<br/>我全部选择！</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><blockquote class="of og oh"><p id="b445" class="ks kt lo ku b kv kw jr kx ky kz ju la oi lc ld le oj lg lh li ok lk ll lm ln ij bi translated">感谢您花时间阅读我的文章。</p></blockquote></div></div>    
</body>
</html>