<html>
<head>
<title>4 Practical Use Cases for IIFEs in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中生命的4个实际用例</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/4-practical-use-cases-for-iifes-in-javascript-6481dcb0ba7d?source=collection_archive---------2-----------------------#2020-11-11">https://javascript.plainenglish.io/4-practical-use-cases-for-iifes-in-javascript-6481dcb0ba7d?source=collection_archive---------2-----------------------#2020-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8e8d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们用生命编写更安全的代码</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ce8de6f5864736e903aa49f076e60999.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0IcrVukF5vHtruNF"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7452" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你知道生命的概念，对吗？</p><p id="0b0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">简单地说，从它的全名，立即调用函数表达式来看，它是一个一旦定义就运行的函数。</p><p id="2887" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">IIEFs以保护变量作用域而闻名。但这实际上意味着什么呢？IIEFs的实际使用案例是什么？</p><p id="fcde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你会在这篇文章中知道答案。让我们深入研究一下。</p><h1 id="4d2b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">关闭</h1><p id="56c3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在生命中定义的变量不能从外部访问。或者当你使用<code class="fe mp mq mr ms b">let</code>或<code class="fe mp mq mr ms b">const</code>声明一个变量时，它只能在封闭块中被访问。</p><p id="9f77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，有时您可能需要修改这些变量的值。可能吗？是的，它是。</p><p id="7be4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">方法如下:</p><p id="151e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你知道闭包，对吧？闭包使您能够从内部函数访问外部函数的作用域。创建闭包只不过是在另一个函数中定义一个函数并公开它。</p><p id="f77c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当把结束和生活结合起来时，你会得到两个好处。</p><p id="99d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个是保护变量的范围以防止意外行为。</p><p id="6f7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二，你可以从外部修改函数内部的变量。听起来我们正在打破第一个好处。但是我们没有。因为您不能直接修改变量值，只能通过公开的函数来修改。而且很安全。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="fcdf" class="mx lt iq ms b gy my mz l na nb">const user = (function() {<br/>  let name = ‘anonymous’;</span><span id="7efb" class="mx lt iq ms b gy nc mz l na nb">  return {<br/>    getName: _ =&gt; name,<br/>    setName: newName =&gt; name = newName<br/>  };<br/>})();</span><span id="5da9" class="mx lt iq ms b gy nc mz l na nb">console.log(user.getName()) // anonymous<br/>user.setName(‘Amy’);<br/>console.log(user.getName()); // Amy</span></pre><p id="d79b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mp mq mr ms b">name</code>变量是私有的，这意味着我们只能在<code class="fe mp mq mr ms b">user</code>生命中访问它。然而，由于我们在这里使用了闭包，我们可以通过暴露<code class="fe mp mq mr ms b">setName()</code>方法从外部修改它。</p><h1 id="1409" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">别名全局变量</h1><p id="f946" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">使用许多JavaScript库可能会导致冲突，因为其中一些库可能会导出同名的对象。</p><p id="209b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您正在使用jQuery。我们都知道它把出口<code class="fe mp mq mr ms b">$</code>作为它的主要对象。因此，如果您的依赖项中有任何库也使用<code class="fe mp mq mr ms b">$</code>作为它的导出对象，就会发生冲突。</p><p id="7a67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，您可以通过应用别名技术来使用IIFEs解决这个问题:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="7a86" class="mx lt iq ms b gy my mz l na nb">(function ($) {<br/>  // You’re safe to use jQuery here<br/>})(jQuery);</span></pre><p id="d38b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过将您的代码包装在一个以<code class="fe mp mq mr ms b">jQuery</code>作为参数的IIFE中，我们将确保<code class="fe mp mq mr ms b">$</code>符号现在引用的是<code class="fe mp mq mr ms b">jQuery</code>，而不是其他库。</p><h1 id="b3b5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">安全变量范围</h1><p id="1bad" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/9-es6-features-every-javascript-developer-should-know-b1f2915e7add" rel="noopener"> ES6 </a>引入了<code class="fe mp mq mr ms b">let</code>和<code class="fe mp mq mr ms b">const</code>来更安全地定义变量。使用<code class="fe mp mq mr ms b">var</code>可能会导致意外的结果，因为它的作用域很脆弱。</p><p id="9797" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果生产环境还不支持ES6呢？还是不知何故不能利用<code class="fe mp mq mr ms b">let</code>和<code class="fe mp mq mr ms b">const</code>？</p><p id="6c3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">别担心。你还有生命，<em class="nd">立即调用函数表达式</em>，达到同样的目的。</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="6794" class="mx lt iq ms b gy my mz l na nb">(function () {<br/>  var greeting = ‘Good morning! How are you today?’;<br/>  console.log(greeting); // Good morning! How are you today?<br/>})();</span><span id="bea0" class="mx lt iq ms b gy nc mz l na nb">console.log(greeting); // error: Uncaught ReferenceError: greeting is not defined</span></pre><p id="edc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你在上面的例子中所看到的，在生命范围内发生的事情，都留在生命范围内。你不能从外部使用生命内部定义的变量。</p><h1 id="db8b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">循环索引</h1><p id="5dc7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在循环中执行异步任务可能会导致意外的结果。</p><p id="6bd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以使用<code class="fe mp mq mr ms b">setTimeout()</code>为例:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="57eb" class="mx lt iq ms b gy my mz l na nb">for (var i = 0; i &lt; 3; i++) {<br/>  setTimeout(_ =&gt; console.log(`We’re at ${i}`), 100);<br/>}</span></pre><p id="8f2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您期望的结果应该是:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="9b6a" class="mx lt iq ms b gy my mz l na nb">We’re at 0<br/>We’re at 1<br/>We’re at 2</span></pre><p id="fb9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但它实际上是:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="37fa" class="mx lt iq ms b gy my mz l na nb">We’re at 3<br/>We’re at 3<br/>We’re at 3</span></pre><p id="27d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么？因为示例中的<code class="fe mp mq mr ms b">console.log()</code>调用只会在每个<code class="fe mp mq mr ms b">100ms</code>之后运行。循环可能在该时间之前结束，这意味着<code class="fe mp mq mr ms b">i</code>索引实际上已经到达<code class="fe mp mq mr ms b">3</code>。结果，所有的<code class="fe mp mq mr ms b">console.log()</code>都会打印出<code class="fe mp mq mr ms b">i</code>、<code class="fe mp mq mr ms b">3</code>的最终结果。</p><p id="c7fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过将<code class="fe mp mq mr ms b">setTimeout()</code>电话融入生活来解决这个问题:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="0c99" class="mx lt iq ms b gy my mz l na nb">for (var i = 0; i &lt; 3; i++) {<br/>  (function(index) {<br/>    setTimeout(_ =&gt; console.log(`We’re at ${index}`), 100);<br/>  })(i);<br/>}</span></pre><p id="db8f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在结果是正确的:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="d523" class="mx lt iq ms b gy my mz l na nb">We’re at 0<br/>We’re at 1<br/>We’re at 2</span></pre><p id="8e37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不过，这是ES6的时代，我们可以使用<code class="fe mp mq mr ms b">let</code>关键字来简化代码:</p><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="eefe" class="mx lt iq ms b gy my mz l na nb">for (let i = 0; i &lt; 3; i++) {<br/>  setTimeout(_ =&gt; console.log(`We’re at ${i}`), 100);<br/>}</span></pre><h1 id="a935" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">最终想法</h1><p id="cfeb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">生命是保护瞄准镜的好方法。您可以使用IIFEs来防止全局变量的定义问题、别名变量、保护私有数据，以及避免使用导出相同对象名的许多库的冲突。</p><p id="af6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">虽然您可以用ES6特性替换一些life用法，但是您仍然应该学习life，以便清楚地理解JavaScript中的作用域是如何工作的。此外，您不能立即将遗留项目应用到ES6。所以，生活仍然扮演着重要的角色。</p><p id="dee6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">希望你喜欢这篇文章。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="de2f" class="ls lt iq bd lu lv nl lx ly lz nm mb mc jw nn jx me jz no ka mg kc np kd mi mj bi translated">进一步阅读</h1><div class="nq nr gp gr ns nt"><a href="https://medium.com/javascript-in-plain-english/9-tips-for-writing-scalable-javascript-code-e6bcfc791882" rel="noopener follow" target="_blank"><div class="nu ab fo"><div class="nv ab nw cl cj nx"><h2 class="bd ir gy z fp ny fr fs nz fu fw ip bi translated">编写可伸缩JavaScript代码的9个技巧</h2><div class="oa l"><h3 class="bd b gy z fp ny fr fs nz fu fw dk translated">您应该从一开始就准备好扩展您的项目</h3></div><div class="ob l"><p class="bd b dl z fp ny fr fs nz fu fw dk translated">medium.com</p></div></div><div class="oc l"><div class="od l oe of og oc oh kp nt"/></div></div></a></div></div></div>    
</body>
</html>