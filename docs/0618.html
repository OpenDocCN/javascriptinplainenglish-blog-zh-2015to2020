<html>
<head>
<title>Check JavaScript Variable Data Types with the Typeof Operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Typeof运算符检查JavaScript变量数据类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/check-javascript-variable-data-types-with-the-typeof-operator-79a66e22f23f?source=collection_archive---------1-----------------------#2019-11-17">https://javascript.plainenglish.io/check-javascript-variable-data-types-with-the-typeof-operator-79a66e22f23f?source=collection_archive---------1-----------------------#2019-11-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/10a312e15883466d4da7c037cc4ed315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GlgbD6wawGHaWQ12"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@stanleydai?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Stanley Dai</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1fca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种松散类型或动态类型的语言。这意味着用一种类型声明的变量可以转换成另一种类型，而不用显式地将数据转换成另一种类型。变量也可以在任何时候包含任何类型，这取决于赋值的内容。JavaScript有多种数据类型。有7种原始数据类型和一种对象类型。这7种基本类型是布尔、空、未定义、数字、BigInt、字符串和符号。因为有不同的数据类型，并且它们一个变量或一个对象的属性类型可以改变任何东西，我们需要一种方法来检查一个变量或一个对象的属性的数据类型。</p><p id="fa30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检查对象属性或变量的类型，我们使用对象的<code class="fe lb lc ld le b">typeof</code>操作符。它让我们以字符串的形式获取对象的类型名或其属性。我们可以在允许的情况下使用它:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="b08c" class="ln lo iq le b gy lp lq l lr ls">typeof x</span></pre><p id="56d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe lb lc ld le b">x</code>是变量的名称。这是<code class="fe lb lc ld le b">typeof</code>运算符的唯一操作数。在检查一个对象的属性的类型时，我们可以写:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="1a4f" class="ln lo iq le b gy lp lq l lr ls">typeof x.prop</span></pre><p id="f43d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过上面的代码，我们可以方便地得到<code class="fe lb lc ld le b">x</code>的<code class="fe lb lc ld le b">prop</code>属性的类型。<code class="fe lb lc ld le b">typeof</code>操作符返回一个包含操作数类型名称的字符串。它可以将以下类型名称作为字符串返回:</p><ul class=""><li id="114d" class="lt lu iq kf b kg kh kk kl ko lv ks lw kw lx la ly lz ma mb bi translated">未定义类型的对象将返回<code class="fe lb lc ld le b">'undefined'</code></li><li id="1b63" class="lt lu iq kf b kg mc kk md ko me ks mf kw mg la ly lz ma mb bi translated">null类型的对象将返回<code class="fe lb lc ld le b">'object'</code></li><li id="4b13" class="lt lu iq kf b kg mc kk md ko me ks mf kw mg la ly lz ma mb bi translated">布尔类型的对象将返回<code class="fe lb lc ld le b">'boolean'</code></li><li id="cac4" class="lt lu iq kf b kg mc kk md ko me ks mf kw mg la ly lz ma mb bi translated">数字类型的对象将返回<code class="fe lb lc ld le b">'number'</code></li><li id="b074" class="lt lu iq kf b kg mc kk md ko me ks mf kw mg la ly lz ma mb bi translated">BigInt类型的对象将返回<code class="fe lb lc ld le b">'bigint'</code></li><li id="3a24" class="lt lu iq kf b kg mc kk md ko me ks mf kw mg la ly lz ma mb bi translated">字符串类型的对象将返回<code class="fe lb lc ld le b">'string'</code></li><li id="528b" class="lt lu iq kf b kg mc kk md ko me ks mf kw mg la ly lz ma mb bi translated">符号类型的对象将返回<code class="fe lb lc ld le b">'symbol'</code></li><li id="8095" class="lt lu iq kf b kg mc kk md ko me ks mf kw mg la ly lz ma mb bi translated">函数类型的对象将返回<code class="fe lb lc ld le b">'function'</code></li><li id="6eec" class="lt lu iq kf b kg mc kk md ko me ks mf kw mg la ly lz ma mb bi translated">任何其他类型的对象都将返回<code class="fe lb lc ld le b">'object'</code></li></ul><p id="88f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以像下面的例子一样使用<code class="fe lb lc ld le b">typeof</code>运算符:</p><h2 id="47e0" class="ln lo iq bd mh mi mj dn mk ml mm dp mn ko mo mp mq ks mr ms mt kw mu mv mw mx bi translated">数字</h2><p id="b9d6" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">如果对以下操作数应用了<code class="fe lb lc ld le b">typeof</code>运算符，则该操作数将返回<code class="fe lb lc ld le b">'number'</code>。因此，所有被记录的表达式都将输出<code class="fe lb lc ld le b">true</code>。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="c8d9" class="ln lo iq le b gy lp lq l lr ls">typeof 1 === 'number';<br/>typeof 3.1 === 'number';<br/>typeof(2) === 'number';<br/>typeof Math.LN10 === 'number';<br/>typeof Infinity === 'number';<br/>typeof NaN === 'number'; <br/>typeof Number('2') === 'number'; <br/>typeof Number('shoe') === 'number';</span></pre><p id="430e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数字类型是双精度64位数字，其值可以在-2的53次方减1到2的53次方减1之间。整数没有特定的类型。所有数字都是浮点数。还有3个符号值:<code class="fe lb lc ld le b">Infinity</code>、<code class="fe lb lc ld le b">-Infinity</code>和<code class="fe lb lc ld le b">NaN</code>。这些都在范围内或者是<code class="fe lb lc ld le b">Infinity</code>、<code class="fe lb lc ld le b">-Infinity</code>或<code class="fe lb lc ld le b">NaN</code>所以都有<code class="fe lb lc ld le b">'number'</code>的类型。<code class="fe lb lc ld le b">Number(‘shoe’)</code>返回<code class="fe lb lc ld le b">NaN</code>，因为<code class="fe lb lc ld le b">NaN</code>是数字类型，<code class="fe lb lc ld le b">typeof Number(‘shoe’)</code>是数字类型。</p><h2 id="3a82" class="ln lo iq bd mh mi mj dn mk ml mm dp mn ko mo mp mq ks mr ms mt kw mu mv mw mx bi translated">用线串</h2><p id="a9e5" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">如果对以下操作数应用了<code class="fe lb lc ld le b">typeof</code>运算符，它们将返回<code class="fe lb lc ld le b">'string'</code>。因此，所有被记录的表达式都将输出<code class="fe lb lc ld le b">true</code>。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="0417" class="ln lo iq le b gy lp lq l lr ls">typeof '' === 'string';<br/>typeof 'abc' === 'string';<br/>typeof `template string` === 'string';<br/>typeof '2' === 'string';<br/>typeof (typeof 2) === 'string';<br/>typeof String(1) === 'string';</span></pre><p id="f1c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">字符串用于表示文本数据。字符串中的每个元素在字符串中都有自己的位置。它的索引是零，所以字符串第一个字符的位置是0。字符串的<code class="fe lb lc ld le b">length </code>属性有字符串的总字符数。</p><p id="ac85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript字符串是不可变的。我们不能修改已经创建的字符串，但是我们仍然可以创建一个包含最初定义的字符串的新字符串。我们可以用<code class="fe lb lc ld le b">substr()</code>函数从一个字符串中提取子字符串，并用<code class="fe lb lc ld le b">concat()</code>函数连接两个字符串。</p><p id="eb86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，任何被单引号、双引号或反勾号包围的东西都是字符串。普通字符串用单引号和双引号括起来，模板字符串用反引号括起来。<code class="fe lb lc ld le b">String</code>函数将任何东西转换成字符串，所以<code class="fe lb lc ld le b">String(1)</code>返回<code class="fe lb lc ld le b">'1'</code>，所以它的类型是string。<code class="fe lb lc ld le b">typeof</code>操作符返回一个字符串，所以如果我们对<code class="fe lb lc ld le b">typeof</code>返回的结果应用<code class="fe lb lc ld le b">typeof</code>操作符，那么它应该是一个字符串。</p><h2 id="6524" class="ln lo iq bd mh mi mj dn mk ml mm dp mn ko mo mp mq ks mr ms mt kw mu mv mw mx bi translated">布尔运算</h2><p id="97c4" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">如果对以下操作数应用了<code class="fe lb lc ld le b">typeof</code>运算符，它们将返回<code class="fe lb lc ld le b">'boolean'</code>。因此，所有被记录的表达式都将输出<code class="fe lb lc ld le b">true</code>。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="4296" class="ln lo iq le b gy lp lq l lr ls">typeof true === 'boolean';<br/>typeof false === 'boolean';<br/>typeof Boolean(2) === 'boolean';<br/>typeof !!(2) === 'boolean';</span></pre><p id="c8bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Boolean</code>函数和双非运算符(<code class="fe lb lc ld le b">!!</code>)都会将真值转换为<code class="fe lb lc ld le b">true</code>，将假值转换为<code class="fe lb lc ld le b">false</code>。JavaScript中的Falsy值包括0、空字符串、<code class="fe lb lc ld le b">null</code>、<code class="fe lb lc ld le b">undefined</code>和<code class="fe lb lc ld le b">false</code>。因此，如果它们作为参数传递给<code class="fe lb lc ld le b">Boolean</code>函数，那么它们将被转换为<code class="fe lb lc ld le b">false</code>。其他的都是真的，所以用<code class="fe lb lc ld le b">Boolean </code>函数或双not运算符将它们转换成<code class="fe lb lc ld le b">true</code>。</p><h2 id="73e6" class="ln lo iq bd mh mi mj dn mk ml mm dp mn ko mo mp mq ks mr ms mt kw mu mv mw mx bi translated">标志</h2><p id="7ff4" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">如果对以下操作数应用了<code class="fe lb lc ld le b">typeof</code>运算符，它们将返回<code class="fe lb lc ld le b">'symbol'</code>。因此，所有被记录的表达式都将输出<code class="fe lb lc ld le b">true</code>。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="4dc4" class="ln lo iq le b gy lp lq l lr ls">typeof Symbol() === 'symbol'<br/>typeof Symbol('foo') === 'symbol'<br/>typeof Symbol.iterator === 'symbol'</span></pre><p id="0710" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">符号是ES2015的新功能。它是唯一且不可变的标识符。一旦创建，就无法复制。每次你创造一个新的符号，它都是独一无二的。它主要用于对象中的唯一标识符。这是一个符号的唯一目的。</p><p id="3da5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Symbol</code>函数创建一个新的符号，所以它返回的任何东西都是符号类型的。<code class="fe lb lc ld le b">Symbol.iterator</code>是特殊符号，所以也是类型符号。</p><h2 id="c8cf" class="ln lo iq bd mh mi mj dn mk ml mm dp mn ko mo mp mq ks mr ms mt kw mu mv mw mx bi translated">不明确的</h2><p id="925f" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">如果对以下操作数应用了<code class="fe lb lc ld le b">typeof</code>运算符，则该操作数将返回<code class="fe lb lc ld le b">'undefined'</code>。因此，所有被记录的表达式都将输出<code class="fe lb lc ld le b">true</code>。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="a37d" class="ln lo iq le b gy lp lq l lr ls">typeof undefined === 'undefined';<br/>typeof declaredVariableWithoutValueAssigned === 'undefined';<br/>typeof undeclaredVariable === 'undefined';</span></pre><p id="91ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有赋值的变量具有未定义的类型。如果你没有给一个已声明的变量赋值或者试图引用一个未声明的变量，那么如果你对它们应用<code class="fe lb lc ld le b">typeof</code>操作符，你会得到未定义的类型。同样，如果你从未声明过一个对象的属性，或者声明了属性但没有赋值，那么这些属性也将具有未定义的类型。</p><h2 id="fa8a" class="ln lo iq bd mh mi mj dn mk ml mm dp mn ko mo mp mq ks mr ms mt kw mu mv mw mx bi translated">目标</h2><p id="f97d" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">如果对以下操作数应用了<code class="fe lb lc ld le b">typeof</code>运算符，它们将返回<code class="fe lb lc ld le b">'object'</code>。因此，所有被记录的表达式都将输出<code class="fe lb lc ld le b">true</code>。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="f0b8" class="ln lo iq le b gy lp lq l lr ls">typeof {a: 1} === 'object';<br/>typeof [1, 2, 4] === 'object';<br/>typeof null === 'object';<br/>typeof new Date() === 'object';<br/>typeof /regex/ === 'object';</span></pre><p id="f754" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象是一种引用数据类型，这意味着它可以被指向内存中对象位置的标识符引用。在内存中，对象的值被存储，通过标识符，我们可以访问该值。对象有属性，这些属性是键值对，其值可以包含原始类型的数据或其他对象，这意味着我们可以使用对象来构建复杂的数据结构。</p><p id="5c40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了具有object类型的键值对的数据之外，当对<code class="fe lb lc ld le b">typeof</code>操作符进行操作时，<code class="fe lb lc ld le b">null</code>类型也返回object。当我们对数组和其他可迭代对象应用操作符来获取类型时，它们也将object作为类型返回，因为这些类型的数据在JavaScript中也是对象。为了检查一个对象是否是一个数组，我们可以使用<code class="fe lb lc ld le b">Array.isArray</code>函数来确定一个对象是否是一个数组。</p><h2 id="8a2b" class="ln lo iq bd mh mi mj dn mk ml mm dp mn ko mo mp mq ks mr ms mt kw mu mv mw mx bi translated">功能</h2><p id="fe4b" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">如果对以下操作数应用了<code class="fe lb lc ld le b">typeof</code>运算符，它们将返回<code class="fe lb lc ld le b">'function'</code>。因此，所有被记录的表达式都将输出<code class="fe lb lc ld le b">true</code>。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="8fac" class="ln lo iq le b gy lp lq l lr ls">typeof function() {} === 'function';<br/>typeof class C {} === 'function';<br/>typeof Math.sin === 'function';</span></pre><p id="be1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数是JavaScript中的对象。任何种类的函数，像箭头函数，函数都用关键字<code class="fe lb lc ld le b">function</code>声明，类是function类型的。注意，JavaScript中的类只是函数的语法糖，我们可以用它来创建新的对象。因此，类仍然是函数类型。</p><h2 id="a9ff" class="ln lo iq bd mh mi mj dn mk ml mm dp mn ko mo mp mq ks mr ms mt kw mu mv mw mx bi translated">比金茨</h2><p id="bb4e" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">如果对以下操作数应用了<code class="fe lb lc ld le b">typeof</code>运算符，它们将返回<code class="fe lb lc ld le b">'bigint'</code>。因此，所有被记录的表达式都将输出<code class="fe lb lc ld le b">true</code>。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="3528" class="ln lo iq le b gy lp lq l lr ls">typeof 42n === 'bigint';</span></pre><p id="0a3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，BigInt类型存储超出安全整数范围的数字。可以通过在数字末尾添加一个<code class="fe lb lc ld le b">n</code>字符来创建一个BigInt数字。使用BigInt，我们可以计算出超出正常数字安全范围的结果。所以任何以<code class="fe lb lc ld le b">n</code>结尾的数字都是<code class="fe lb lc ld le b">bigint</code>类型。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/6ce51dab860a0dabf592c2f841d29ff8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Dqjpt8RjDnVWuM0x"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@eagleeyevisuals?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alistair Smith</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f6bf" class="ne lo iq bd mh nf ng nh mk ni nj nk mn nl nm nn mq no np nq mt nr ns nt mw nu bi translated">新操作员</h1><p id="be2b" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated"><code class="fe lb lc ld le b">new</code>操作符总是将一个对象返回给它所应用的对象，所以下面的操作符总是有object类型。如果对以下操作数应用了<code class="fe lb lc ld le b">typeof</code>运算符，它们将返回<code class="fe lb lc ld le b">'object'</code>。因此，所有被记录的表达式都将输出<code class="fe lb lc ld le b">true</code>。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="d583" class="ln lo iq le b gy lp lq l lr ls">typeof new Boolean(true) === 'object'; <br/>typeof new Number(1) === 'object'; <br/>typeof new String('abc') === 'object';<br/>typeof new String(null) <!-- -->=== 'object';<br/>typeof new Number(undefined) <!-- -->=== 'object';</span></pre><p id="b96d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，无论我们拥有什么，如果使用关键字<code class="fe lb lc ld le b">new</code>创建对象，我们都会得到类型<code class="fe lb lc ld le b">object</code>。不管它是布尔型、数字型、字符串型还是你传入的任何类型，因此，当我们不需要使用<code class="fe lb lc ld le b">new</code>关键字来创建对象时，就不要这样做。要将事物转换成布尔型，我们使用<code class="fe lb lc ld le b">Boolean</code>函数，要将事物转换成数字，我们使用<code class="fe lb lc ld le b">Number</code>函数，要将事物转换成字符串，我们使用<code class="fe lb lc ld le b">String</code>函数。</p><h1 id="19dc" class="ne lo iq bd mh nf ng nh mk ni nj nk mn nl nm nn mq no np nq mt nr ns nt mw nu bi translated">空类型</h1><p id="f4b8" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated"><code class="fe lb lc ld le b">null</code>对象属于object类型，因为它们由类型标签0表示。与大多数平台一样，JavaScript的空指针是0x00。因此，<code class="fe lb lc ld le b">null</code>有类型标签0，所以object有object作为<code class="fe lb lc ld le b">typeof</code>返回的类型。</p><h1 id="33cc" class="ne lo iq bd mh nf ng nh mk ni nj nk mn nl nm nn mq no np nq mt nr ns nt mw nu bi translated">确定表达式的类型</h1><p id="abda" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">我们可以使用<code class="fe lb lc ld le b">typeof</code>操作符来确定表达式返回的实体的类型。我们用括号来确定表达式中组合在一起的结果的类型。例如，如果我们想得到<code class="fe lb lc ld le b">1 + ‘1’</code>的类型，那么我们需要写:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="e144" class="ln lo iq le b gy lp lq l lr ls">typeof (1 + '1');</span></pre><p id="57e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们写上面的代码，我们得到string作为类型，这是表达式结果的正确类型。如果我们不在表达式两边加上括号，那么我们只能得到表达式第一部分的类型，即与<code class="fe lb lc ld le b">'1'</code>连接的数字。</p><h1 id="a135" class="ne lo iq bd mh nf ng nh mk ni nj nk mn nl nm nn mq no np nq mt nr ns nt mw nu bi translated">错误</h1><p id="effc" class="pw-post-body-paragraph kd ke iq kf b kg my ki kj kk mz km kn ko na kq kr ks nb ku kv kw nc ky kz la ij bi translated">在用<code class="fe lb lc ld le b">let</code>或<code class="fe lb lc ld le b">const</code>声明的变量之前使用<code class="fe lb lc ld le b">typeof</code>操作符将导致抛出ReferenceError，因为它引用了一个尚未声明的变量。之前在未声明的变量上使用<code class="fe lb lc ld le b">typeof</code>操作符将返回类型<code class="fe lb lc ld le b">'undefined’</code>。在ES2015之前，<code class="fe lb lc ld le b">typeof</code>操作符从未产生错误。</p><p id="0814" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="e1cb" class="ln lo iq le b gy lp lq l lr ls">typeof letVariable; <br/>typeof constant; <br/>typeof c;<br/><br/>let letVariable;<br/>const constant = 'constant';<br/>class c{};</span></pre><p id="80fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前3行将在运行时抛出一个ReferenceError。</p><p id="3df8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">typeof</code>操作符对于检查基本类型和对象的类型很有用。对于基本类型，它将返回对象的类型，除了<code class="fe lb lc ld le b">null</code> type，它将object作为类型返回。对象，包括数组和其他可迭代对象，将总是返回object作为类型。对于用<code class="fe lb lc ld le b">let</code>或<code class="fe lb lc ld le b">const</code>关键字和类声明的变量，我们必须在对它们使用<code class="fe lb lc ld le b">typeof</code>操作符之前声明它们。</p></div></div>    
</body>
</html>