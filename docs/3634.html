<html>
<head>
<title>‘Dumb’ Angular — Input Setter/Getter vs NgOnChanges</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">“哑”角度—输入设置器/获取器与NgOnChanges</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dumb-angular-input-setter-getter-vs-ngonchanges-f30e61937926?source=collection_archive---------1-----------------------#2020-10-14">https://javascript.plainenglish.io/dumb-angular-input-setter-getter-vs-ngonchanges-f30e61937926?source=collection_archive---------1-----------------------#2020-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="7625" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">有角度的尖端</h2><div class=""/><div class=""><h2 id="9d38" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">了解通过NgOnChanges和输入绑定向非智能角度组件传递数据的正确方法。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/ca2230c6f7f3b0f9a093b9a12fcaed8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_RM5qZRn3Sthj3Zx3revrA.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Dumb</figcaption></figure><h1 id="0955" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">组件如何在角度上相互作用</h1><p id="709e" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">角度组件有多种方式与应用程序的其他部分共享信息。开发一个复杂的Angular应用程序将涉及大量的数据，以及随后组件之间的大量交互。</p><p id="8d70" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">一旦你学会了在组件中处理数据的方法，就很容易为不同的用例进行复制。</p><p id="e305" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">然而，有三种主要的方法来拦截数据变更，并且很容易假设所有的方法都是相同的。在简单的情况下，比如当您只需要监听更新的值时，它们可以表现得非常相似。</p><p id="f2c8" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">但是在某些情况下，每种方法都比其他方法更适合手头的任务。</p><p id="d5fd" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">使用的方法有:</p><ul class=""><li id="4600" class="mx my iq ly b lz ms mc mt mf mz mj na mn nb mr nc nd ne nf bi translated"><strong class="ly ja">@输入设置器和获取器</strong></li><li id="2f96" class="mx my iq ly b lz ng mc nh mf ni mj nj mn nk mr nc nd ne nf bi translated"><strong class="ly ja">恩贡奇斯</strong></li><li id="79b3" class="mx my iq ly b lz ng mc nh mf ni mj nj mn nk mr nc nd ne nf bi translated">一项服务</li></ul><p id="dc68" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">如题所示，我们将集中讨论<strong class="ly ja">前两个，</strong>我们将讨论它们在Angular中不同情况下的各自适用性。</p><h1 id="488d" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">角度中的哑分量</h1><blockquote class="nl"><p id="eadc" class="nm nn iq bd no np nq nr ns nt nu mr dk translated">如果你没有听说过Angular中的哑组件…你可能会认为我在侮辱Angular或它的组件。我不是…</p></blockquote><p id="1501" class="pw-post-body-paragraph lw lx iq ly b lz nv ka mb mc nw kd me mf nx mh mi mj ny ml mm mn nz mp mq mr ij bi translated">Angular中哑组件的想法是创建像纯函数一样工作的<strong class="ly ja">组件。也就是说，它们的内部状态和行为只受输入和输出的控制。没有副作用和外部数据源，如服务、API或本地存储。</strong></p><p id="6b7c" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">哑组件通常是我们的应用程序的极简UI/表示容器，其中考虑了大小和复杂性，并尽可能地减少。</p><blockquote class="nl"><p id="371c" class="nm nn iq bd no np nq nr ns nt nu mr dk translated">因此,“智能”组件应该是在构造函数中注入了服务依赖的组件，或者是连接到API或本地存储的组件。他们倾向于控制而不是仅仅在场。</p></blockquote><p id="8b7d" class="pw-post-body-paragraph lw lx iq ly b lz nv ka mb mc nw kd me mf nx mh mi mj ny ml mm mn nz mp mq mr ij bi translated"><strong class="ly ja">依赖性通过增加的业务逻辑和数据处理增加了膨胀和复杂性</strong>。这些依赖关系会影响性能，因此最好组织和设计应用程序，让更多的组件被认为是愚蠢的，而不是“聪明的”。</p><blockquote class="oa ob oc"><p id="3a5b" class="lw lx od ly b lz ms ka mb mc mt kd me oe mu mh mi of mv ml mm og mw mp mq mr ij bi translated">哑组件旨在轻量级和相对简单，与“智能”组件相反，后者更像是控制器，处理更复杂的逻辑，倾向于与应用程序的核心进行更多的交互。</p></blockquote><h2 id="7655" class="oh lf iq bd lg oi oj dn lk ok ol dp lo mf om on lq mj oo op ls mn oq or lu iw bi translated">哑组件是可重用的</h2><p id="1c9b" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">没有依赖关系的组件是Angular中你可以创建的最可重用的东西。组件是组织和分组DOM中相互接近的相关功能的好方法。</p><p id="530d" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">当你考虑将组件转换成可重用的哑组件时，想想<strong class="ly ja">布局组件</strong>，比如列表、导航条和演示卡。</p><p id="7b42" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">这些是您可以在应用程序中重用的组件，提供了定制每个实例的美学和行为的能力，以适应特定的用例/主题。</p><blockquote class="oa ob oc"><p id="7afa" class="lw lx od ly b lz ms ka mb mc mt kd me oe mu mh mi of mv ml mm og mw mp mq mr ij bi translated"><a class="ae os" href="https://material.angular.io/" rel="noopener ugc nofollow" target="_blank">Angular素材库</a>充满了开源的哑组件，在这里你可以提供自己的数据来定制它们的默认行为。</p></blockquote><h2 id="357b" class="oh lf iq bd lg oi oj dn lk ok ol dp lo mf om on lq mj oo op ls mn oq or lu iw bi translated">哑vs智能决定组件交互</h2><p id="0728" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">向哑组件提供数据是通过使用@Input绑定，而不是注入服务。</p><p id="b22c" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">试图重用一个有服务依赖的组件将意味着你也必须注入那些服务，并在父组件中与它们交互，这在项目中不起作用。</p><p id="8efd" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">这就是为什么<strong class="ly ja">哑组件只通过输入和输出进行交互。</strong></p><h1 id="edc8" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">1) NgOnChanges</h1><p id="7ff6" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">NgOnChanges是Angular提供的一个生命周期钩子，可以由Angular组件通过<code class="fe ot ou ov ow b">OnChanges</code>接口实现。</p><p id="b7eb" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">这将公开一种方法来侦听父组件提供的对子组件的数据绑定输入属性的更改。</p><h2 id="3664" class="oh lf iq bd lg oi oj dn lk ok ol dp lo mf om on lq mj oo op ls mn oq or lu iw bi translated">何时使用OnChanges</h2><ul class=""><li id="4b7b" class="mx my iq ly b lz ma mc md mf ox mj oy mn oz mr nc nd ne nf bi translated">当你想把逻辑组织在一起时</li><li id="045d" class="mx my iq ly b lz ng mc nh mf ni mj nj mn nk mr nc nd ne nf bi translated">当数据改变逻辑和功能依赖于来自任何其它输入的改变时。</li><li id="5ece" class="mx my iq ly b lz ng mc nh mf ni mj nj mn nk mr nc nd ne nf bi translated">您需要知道以前和当前的值(更改后)，和/或它是否是第一次更改。</li></ul><p id="a120" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">我个人喜欢在一个函数中处理输入的所有变化，当我有很多输入需要考虑的时候。</p><blockquote class="oa ob oc"><p id="9beb" class="lw lx od ly b lz ms ka mb mc mt kd me oe mu mh mi of mv ml mm og mw mp mq mr ij bi translated">NgOnChanges让您更全面地了解组件中的数据是如何变化的</p></blockquote><p id="7d50" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">带有<code class="fe ot ou ov ow b">SimpleChanges</code>参数的NgOnChanges实现提供了一个参数，使您不必编写和跟踪中间值。</p><h2 id="b6a6" class="oh lf iq bd lg oi oj dn lk ok ol dp lo mf om on lq mj oo op ls mn oq or lu iw bi translated">NgOnChanges对可读性更好</h2><p id="aed1" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">如果我有一个开始变得复杂或庞大的组件，甚至在考虑处理输入更改之前，我可能会使用NgOnChanges来处理数据更改。</p><p id="482e" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">使用NgOnChanges而不是输入Setter/getter避免了由于输入Setter/getter的冗长而对可读性造成的额外影响。</p><p id="3e9a" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">考虑到中间值和更改逻辑，您实际上为每个输入设置器/获取器添加了大约6行。</p><h2 id="da59" class="oh lf iq bd lg oi oj dn lk ok ol dp lo mf om on lq mj oo op ls mn oq or lu iw bi translated">使用NgOnChanges的示例</h2><p id="70bd" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">本例要求NgOnChanges根据<code class="fe ot ou ov ow b">likeState</code>值触发角度动画<code class="fe ot ou ov ow b">likeState()</code>。因此，我们需要截取<code class="fe ot ou ov ow b">likes</code>和<code class="fe ot ou ov ow b">liked</code>值，使用最新的<code class="fe ot ou ov ow b">uid</code>来确定父组件上的喜好状态。</p><blockquote class="oa ob oc"><p id="a41e" class="lw lx od ly b lz ms ka mb mc mt kd me oe mu mh mi of mv ml mm og mw mp mq mr ij bi translated">这里使用NgOnChanges的原因是<strong class="ly ja">如果它是第一个变化</strong>，我们希望跳过“喜欢”动画，这意味着用户实际上没有喜欢任何东西，组件正在初始化，默认状态是基于初始数据设置的。</p></blockquote><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="pa pb l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Like button with NgOnChanges</figcaption></figure><h2 id="63f6" class="oh lf iq bd lg oi oj dn lk ok ol dp lo mf om on lq mj oo op ls mn oq or lu iw bi translated">与NgOnChanges无关的事情</h2><p id="2e7a" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">不要忽略<code class="fe ot ou ov ow b">SimpleChanges</code>。如果您忽略Angular在NgOnChanges接口中提供的这个参数，您就忽略了确定发生了什么变化的最简单的方法，包括它的“前后”值。</p><p id="48d1" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">您选择实现NgOnChanges的主要原因是为了倾听和响应这些变化，所以忽略它们意味着您不需要NgOnChanges。</p><p id="1235" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">如果不使用SimpleChanges参数，您将不得不自己跟踪组件中以前的值，这看起来会很混乱，另外，当您要努力战胜Angular实现时，重新发明那个特殊的轮子是没有意义的。</p><h1 id="454e" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">2)输入设置器和获取器</h1><p id="2fc7" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在子组件中提供了一个输入decorated，让Angular知道它可以从父组件接收一个值。因此，父节点负责使用语法<code class="fe ot ou ov ow b">&lt;ngx-child-component [user]="userObj"&gt;&lt;/ngx-child-component&gt;</code>向子节点提供一个值，输入为<code class="fe ot ou ov ow b">user</code>。</p><h2 id="a669" class="oh lf iq bd lg oi oj dn lk ok ol dp lo mf om on lq mj oo op ls mn oq or lu iw bi translated">何时使用</h2><ul class=""><li id="cd79" class="mx my iq ly b lz ma mc md mf ox mj oy mn oz mr nc nd ne nf bi translated">你有少量的输入</li></ul><p id="dc39" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated"><strong class="ly ja">加… </strong></p><ul class=""><li id="9845" class="mx my iq ly b lz ms mc mt mf mz mj na mn nb mr nc nd ne nf bi translated">当你只想孤立地聆听变化时</li><li id="ad6a" class="mx my iq ly b lz ng mc nh mf ni mj nj mn nk mr nc nd ne nf bi translated">对组件的更改不依赖于其他输入的值</li><li id="09cb" class="mx my iq ly b lz ng mc nh mf ni mj nj mn nk mr nc nd ne nf bi translated">你不需要<code class="fe ot ou ov ow b">SimpleChanges</code>提供的信息。</li></ul><h2 id="bc95" class="oh lf iq bd lg oi oj dn lk ok ol dp lo mf om on lq mj oo op ls mn oq or lu iw bi translated">正交输入数据的获取器和设置器</h2><p id="84b9" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">将getters和setters与@Input绑定结合使用是处理少量互不依赖的输入的最简单、最直观的方式。</p><p id="4294" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">使用getters和setters，您仍然可以通过截取来控制更改。</p><p id="9587" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">然而，当您有这么多输入时，为您的输入数据编写getters &amp; setters会变得重复和冗长。此外，您无法全面了解组件数据的所有更改，只能了解特定输入的新旧值(来自中间值)。</p><h2 id="93c5" class="oh lf iq bd lg oi oj dn lk ok ol dp lo mf om on lq mj oo op ls mn oq or lu iw bi translated">我们之前的例子…但是使用输入设置器/获取器</h2><p id="a115" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">要了解使用输入Setter/Getter和NgOnChanges之间的真正区别，让我们看看我们在前面的例子中遇到的问题，使用Setter/Getter方法重新实现…</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="pa pb l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Like button with Input Getters/Setters</figcaption></figure><p id="98ad" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">正如你所看到的，这个版本更加冗长，而且当我们试图确定这是他们对<code class="fe ot ou ov ow b">uid</code>还是<code class="fe ot ou ov ow b">likes</code>的第一次变更时，我们会陷入困境，如果是这样的话，我们可以跳过动画。</p><p id="5bc3" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">当然，您可以编写一些代码来保存一个值，该值表示每个输入经历的变化次数，但是我们应该为此使用NgOnChanges。</p><h1 id="c072" class="le lf iq bd lg lh li lj lk ll lm ln lo kf lp kg lq ki lr kj ls kl lt km lu lv bi translated">使用@Input和NgOnChanges时要记住什么</h1><h2 id="4d97" class="oh lf iq bd lg oi oj dn lk ok ol dp lo mf om on lq mj oo op ls mn oq or lu iw bi translated">了解角度变化检测的工作原理</h2><p id="69eb" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">请记住，在某些情况下，无论使用何种方法，Angular都不会检测到输入数据的变化。</p><p id="99c1" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">一种情况是当您将<strong class="ly ja">更改检测策略</strong>设置为<code class="fe ot ou ov ow b">OnPush</code>时。</p><pre class="kp kq kr ks gt pc ow pd pe aw pf bi"><span id="41db" class="oh lf iq ow b gy pg ph l pi pj">@Component({<br/>   selector: 'ngx-app-component',<br/>   templateUrl: './app.component.html',<br/>   styleUrls: ['./app.component.scss'],<br/>   changeDetection: ChangeDetectionStrategy.<em class="od">OnPush</em><br/>})</span></pre><p id="3346" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">用OnPush配置组件意味着在某些情况下，数据绑定输入不会触发更改检测。</p><p id="1ef9" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">这些情况是当您正在处理一个对象，并且只有一个嵌套属性发生了更改。这里，<strong class="ly ja">输入绑定和NgOnChanges都不会被触发，因为没有对底层对象引用</strong>进行修改。</p><p id="a519" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">如果您将一个非基本对象向下传递给一个子组件，并对嵌套属性进行更改，通常会出现这种情况。这将保留对象的引用。</p><p id="2311" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">对于硬编码的值，您经常会遇到这种情况，硬编码的值是指那些不是来自异步流的值，比如可观察值或承诺值。</p><h2 id="2c86" class="oh lf iq bd lg oi oj dn lk ok ol dp lo mf om on lq mj oo op ls mn oq or lu iw bi translated">那么我应该使用默认的变化检测吗？</h2><p id="369f" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">嗯，不一定。</p><p id="b122" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">如果你要使用Angular的默认变化检测机制，<strong class="ly ja">直接对象突变将被允许</strong>，因此没有提供新引用的对象变化将被检测到。</p><p id="cff2" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">但是，您可能熟悉OnPush行为的好处及其相关的性能提升。</p><p id="b7cf" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">因此，对于某些应用程序来说，这不仅仅是说“我将只使用默认的变化检测”那么简单。从长远来看，理解OnPush的复杂性是值得的。这意味着可以使用OnPush而不会遇到缺点。</p><h2 id="6ad4" class="oh lf iq bd lg oi oj dn lk ok ol dp lo mf om on lq mj oo op ls mn oq or lu iw bi translated">如何确保变更检测按预期工作</h2><p id="beb2" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">在整个应用程序中端到端地使用Observables使您的应用程序真正具有反应性。</p><p id="2164" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">这也是确保Angular检测数据变化的一种方法。使用Observable，您可以访问异步管道，该管道可用于将数据传递给子组件。<strong class="ly ja">当异步管道发出对数据的更改时，它自动标记组件以检测更改</strong>。</p><p id="eca6" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated">因此，就变更检测而言，主要是硬编码对象需要格外小心。</p><h2 id="acbb" class="oh lf iq bd lg oi oj dn lk ok ol dp lo mf om on lq mj oo op ls mn oq or lu iw bi translated">小费</h2><p id="2d79" class="pw-post-body-paragraph lw lx iq ly b lz ma ka mb mc md kd me mf mg mh mi mj mk ml mm mn mo mp mq mr ij bi translated">为了让你的应用到处都是可反应的，你总是可以用<strong class="ly ja">将值包装在一个行为主体</strong> <strong class="ly ja">中，就像</strong> <code class="fe ot ou ov ow b">new BehaviorSubject({firstName: ‘John', lastName: 'Doe'});</code>，<strong class="ly ja">用</strong> <code class="fe ot ou ov ow b">.next({firstName: 'Jane', lastName: 'Doe'});</code>控制变化，并且用<code class="fe ot ou ov ow b">.asObservable();</code>将值作为可观察的提供给你的组件<strong class="ly ja">。</strong></p><p id="841d" class="pw-post-body-paragraph lw lx iq ly b lz ms ka mb mc mt kd me mf mu mh mi mj mv ml mm mn mw mp mq mr ij bi translated"><strong class="ly ja">感谢阅读！有任何问题，请在评论中告诉我。</strong></p></div></div>    
</body>
</html>