<html>
<head>
<title>Maintainable JavaScript — IIFEs and Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可维护的JavaScript —生命和事件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/maintainable-javascript-iifes-and-events-965f09f2359b?source=collection_archive---------10-----------------------#2020-09-23">https://javascript.plainenglish.io/maintainable-javascript-iifes-and-events-965f09f2359b?source=collection_archive---------10-----------------------#2020-09-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0c97294e1e92d6f6c752fa808291aa46.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BDKxWQiaC9Ajmc0D"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@photos_by_lanty?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Photos by Lanty</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9178" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果想继续使用代码，创建可维护的JavaScript代码很重要。</p><p id="9221" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将通过在UI中避免全局变量和松散耦合来了解创建可维护JavaScript代码的基础。</p><h1 id="3b33" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有全球性的方法</h1><p id="9335" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建没有全局变量的私有变量。</p><p id="8d22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们把我们需要的全局对象传递到生活中，我们不用改变它就可以使用它。</p><p id="fac9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b2f3" class="mn lc iq mj b gy mo mp l mq mr">(function(win) {<br/>  const doc = win.document;<br/>  // ...<br/>}(window));</span></pre><p id="9864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建自己的生命，然后用<code class="fe ms mt mu mj b">window</code>对象调用，这样我们就可以访问<code class="fe ms mt mu mj b">window.document</code>并将其赋给一个变量。</p><p id="048d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那我们就可以随心所欲了。</p><p id="742c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数包装器可以用于我们不想创建任何全局对象的脚本。</p><p id="98fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种模式用途有限。</p><p id="4e68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">页面上其他脚本使用的任何脚本都不能使用这种方法。</p><p id="d794" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有不与任何其他脚本交互的小脚本，那么可以使用这种方法。</p><h1 id="e0ea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">事件处理</h1><p id="992c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">事件处理一直在客户端JavaScript中进行。</p><p id="c0cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的应用程序必须处理来自输入，鼠标点击，滚动等事件。</p><p id="f56b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们不小心的话，也有可能产生紧密耦合的代码。</p><p id="d23b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">event</code>对象在事件处理函数中作为一个参数可用。</p><p id="63f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以很容易地用它来创建紧密耦合的代码。</p><p id="96d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了确保我们不会创建紧密耦合的代码，我们应该记住一些事情。</p><h1 id="e76d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">独立的应用程序逻辑</h1><p id="72f4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们需要分离应用程序逻辑，这样我们就不会创建耦合到UI的应用程序逻辑代码。</p><p id="f0e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">事件处理程序中的应用程序逻辑代码很难跟踪和测试。</p><p id="f52a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，当我们可以重用逻辑代码时，我们可能会重复它们。</p><p id="40a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试更加困难，因为我们要创建与事件处理代码相耦合的逻辑代码。</p><p id="d1f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须触发事件来测试我们的应用程序逻辑代码，即使我们只是想测试逻辑。</p><p id="9edd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们要把app逻辑代码和事件处理代码分开。</p><p id="0d36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下代码将应用程序逻辑代码与事件句柄分开:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3271" class="mn lc iq mj b gy mo mp l mq mr">function onClick(event) {<br/>  showPopup(event);<br/>}</span><span id="84c4" class="mn lc iq mj b gy mv mp l mq mr">function showPopup(event) {<br/>  const popup = document.getElementById("popup");<br/>  popup.style.left = `${event.clientX}px`;<br/>  popup.style.top = `${event.clientY}px`;<br/>  popup.className = "popup";<br/>}</span><span id="0645" class="mn lc iq mj b gy mv mp l mq mr">const button = document.querySelector('button');<br/>button.addEventListener('click', onClick);</span></pre><p id="ba83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe ms mt mu mj b">showPopup</code>函数显示弹出窗口，用<code class="fe ms mt mu mj b">onClick</code>方法监听按钮上的点击。</p><p id="22db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe ms mt mu mj b">onClick</code>运行时<code class="fe ms mt mu mj b">showPopup</code>运行，这样我们就不会在事件处理函数中包含所有的逻辑。</p><h1 id="c5ab" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要传递事件对象</h1><p id="446c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该传递事件对象，因为它依赖于调用事件处理函数的元素。</p><p id="be99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望将应用程序逻辑从DOM元素中分离出来，所以我们不应该将<code class="fe ms mt mu mj b">event</code>对象作为应用程序逻辑函数中的参数。</p><p id="9086" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该取<code class="fe ms mt mu mj b">showPopup</code>中的<code class="fe ms mt mu mj b">event</code>对象，而应该只取x和y坐标。</p><p id="694b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c6bb" class="mn lc iq mj b gy mo mp l mq mr">function onclick(event) {<br/>  const {<br/>    clientX,<br/>    clienty<br/>  } = event;<br/>  showPopup(clientX, clienty);<br/>}</span><span id="a3f7" class="mn lc iq mj b gy mv mp l mq mr">function showPopup(x, y) {<br/>  const popup = document.getElementById("popup");<br/>  popup.style.left = `${x}px`;<br/>  popup.style.top = `${y}px`;<br/>  popup.className = "popup";<br/>}</span><span id="3ff5" class="mn lc iq mj b gy mv mp l mq mr">const button = document.querySelector('button');<br/>button.addEventListener('click', onClick);</span></pre><p id="eea2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们更改了<code class="fe ms mt mu mj b">showPopup</code>函数来获取弹出窗口的x和y坐标，这样我们就不必将<code class="fe ms mt mu mj b">event</code>对象传递给我们的应用程序逻辑。</p><p id="3bb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使我们的事件处理代码与应用程序逻辑代码保持松散耦合。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/16293af87a415d0f92e3d3cfe5173f52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*89c4rbwGcoUkDQop"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@alelmes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alasdair Elmes</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3cad" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="e471" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该将应用程序逻辑代码从事件处理代码中分离出来。</p><p id="ed99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以创建函数来获取全局变量，并在函数内部使用它们。</p><h2 id="e711" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="46d8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>