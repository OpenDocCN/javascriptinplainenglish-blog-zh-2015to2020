<html>
<head>
<title>How TypeScript 3.7 Improves Code Quality</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 3.7如何提高代码质量</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-typescript-3-7-helps-quality-bb2b143f7425?source=collection_archive---------5-----------------------#2019-11-07">https://javascript.plainenglish.io/how-typescript-3-7-helps-quality-bb2b143f7425?source=collection_archive---------5-----------------------#2019-11-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a9d19cd831d176f4e74d14c123d5dd7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g-FF-BGH_GUXAC4Q"/></div></div></figure><p id="24bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我将回顾最近发布的TypeScript 3.7中的一些重要亮点。我将从它们如何影响软件和代码质量的角度来看待这些事情，因为让我们面对它吧— <a class="ae kt" href="https://www.killalldefects.com" rel="noopener ugc nofollow" target="_blank">这是我的难题</a>。</p><p id="9988" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我关注TypeScript发布已经有一段时间了。我已经看到过去的几个来来去去，没有任何重大影响我的日常生活。像3.7这样的小版本听起来不是很大或很重要，但是这个版本在提高代码质量方面是巨大的。</p><p id="6b39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然TypeScript 3.7中有许多令人惊讶的东西，但我将专门写以下变化:</p><ul class=""><li id="ab98" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">可选链接</li><li id="a07d" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">无效合并</li><li id="b9c6" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">断言函数</li><li id="d0c3" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">Declare关键字</li><li id="ae99" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">未调用的函数检查</li></ul><p id="84ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们开始吧。</p><h1 id="2108" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">可选链接</h1><p id="a9c9" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">可选链接是一种语法形式，用于在某些内容为空或未定义的情况下缩短计算时间。</p><p id="95ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TypeScript引入了<code class="fe ml mm mn mo b">?.</code>操作符，以便在对象存在的情况下有选择地调用某些东西。</p><p id="e869" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看看下面新旧做事方式的对比:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="60dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在C#中我们已经有了可选的链接。网络世界有一段时间了，我是它的超级粉丝。</p><p id="763b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我喜欢的是:</p><ul class=""><li id="744a" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">它使得语法非常简洁，但是可读性非常好</li><li id="8061" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">这使得检查空值变得很容易</li></ul><p id="5c55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这两件事对代码和软件质量都有很大帮助。如果我正在审查代码，并且没有被If块的额外语法分散注意力，我就能够专注于真正重要的代码。</p><p id="a53f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">类似地，如果我是一个开发人员，正在开发一个比它应该的更长的方法，我可能会变得懒惰，并假设一个变量已经被检查为空。这听起来很傻，但是我自己也感觉到了不想脱离这个流程而去添加一个空检查的诱惑。</p><p id="d94d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">能够快速且有条件地检查null对质量的帮助比您最初想象的要大。</p><h1 id="c323" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">无效合并</h1><p id="a097" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">Nullish合并是指在评估可能为空或未定义的事物时使用<code class="fe ml mm mn mo b">??</code>操作符。</p><p id="3122" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先,“nullish”这个术语让我发笑，因为它非常适合JavaScript概念。</p><p id="5d11" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript需要这种区别，因为它有“T2”的概念，这个概念与“T3”是分开的，但又是相关的。当然，区别在于<code class="fe ml mm mn mo b">null</code>明确地<em class="mv">什么都不是</em>但是<code class="fe ml mm mn mo b">undefined</code>没有被定义为有任何价值。我想，动态语言的危险。</p><p id="a038" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于nullish合并的示例，请查看以下代码片段前后的内容:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="4a06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如您所见，与使用赋值的等价if检查的三元(<code class="fe ml mm mn mo b">?</code>)操作符相比，使用nullish合并非常简洁。</p><p id="d02b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我喜欢的这一点与我喜欢的可选链接类似——它帮助您关注真正重要的代码。</p><p id="fb7c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们作为工程师能够消除代码和语法中的额外干扰，我们将更容易、更早地发现缺陷。</p><h1 id="0ffc" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">断言函数</h1><p id="c564" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">我更倾向于断言函数。从本质上说，它们是一些函数，如果被正确调用，它们会向TypeScript的内部类型解释代码断言一些东西。这反过来允许编译器基于现在被证明是真实的事实来捕捉更具体的问题。</p><p id="eb3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看一个例子:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="ee4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们有一个<code class="fe ml mm mn mo b">getStandardFixedNumberString</code>函数，它接受一个已知为<code class="fe ml mm mn mo b">string</code>或<code class="fe ml mm mn mo b">number</code>的值。由于<code class="fe ml mm mn mo b">toFixed</code>在<code class="fe ml mm mn mo b">string</code>型上不可用，该代码通常是不允许的。</p><p id="41e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ml mm mn mo b">assertIsNumber</code>函数定义了一个断言子句，本质上是说“如果这没有出错，那么函数断言的是真的，并且可以被你的方法的其余部分理解”。</p><p id="4430" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我们断言输入是一个数字，在这种情况下，对数字可用的函数也变得可用，所以TypeScript对我们的<code class="fe ml mm mn mo b">toFixed</code>调用没有问题。</p><p id="9bf0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以，这里是我在这个问题上的立场:如果你的方法足够长，你需要断言函数，你可能应该把它们分成更小的方法。</p><p id="03c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可能会认为断言函数是让TypeScript进行一些运行时类型检查的一种方式，而不是它只在编译时进行的标准静态检查。</p><p id="d10c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，我不认为TypeScript是通过在运行时强制执行规则而繁荣起来的。在我看来，我们应该在编译时加强我们的打字，然后在边缘验证系统的外部输入。像API调用和用户输入这样的东西应该被断言和强制转换，而不是你的主应用程序代码。</p><p id="5b09" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">尽管如此，断言函数仍然是值得考虑和关注的，因为它们有可能在将来为其他用途服务。</p><h1 id="9367" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Declare关键字</h1><p id="8184" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">Declare让我们将动态类型系统与继承结合起来，从本质上重新声明继承的属性。</p><p id="95c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看看下面这个简单的层次结构:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="817f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们有一个继承自<code class="fe ml mm mn mo b">Theme</code>的<code class="fe ml mm mn mo b">DarkTheme</code>。<code class="fe ml mm mn mo b">Theme</code>声明了一个<code class="fe ml mm mn mo b">Person</code>实体的集合，它本身就是一个抽象。</p><p id="6a6a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我们知道所有使用黑色主题的人都很棒，我们知道<code class="fe ml mm mn mo b">users</code>属性也将只有<code class="fe ml mm mn mo b">AwesomePerson</code>实体。</p><p id="cd96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了TypeScript 3.7，TypeScript也能理解这一点。</p><p id="a023" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们使用<code class="fe ml mm mn mo b">declare</code>关键字来告诉TypeScript对某些事情做出假设，而不为这个假设发出任何特别的东西。以前我使用过<code class="fe ml mm mn mo b">declare</code>来引用共享网页上加载的外部库。</p><p id="01bf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们使用<code class="fe ml mm mn mo b">declare</code>来指定一个属性在上下文中具有不同于先前定义的类型。</p><p id="1bf3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我真的很喜欢这个功能。虽然不像其他语言特性那样常用，但这有助于具有复杂层次结构的团队理解它们的属性，并且不需要进行类型断言。</p><h1 id="f339" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">未调用的函数检查</h1><p id="6b66" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">最后，TypeScript现在将捕获我们在函数中经常犯的一个常见错误。看一下下面的代码:</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="b082" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们打算在第10行调用<code class="fe ml mm mn mo b">person.onlyDoesBoringThings</code>，但是忘记了<code class="fe ml mm mn mo b">()</code>，取而代之的是针对null / undefined评估函数。该函数已定义，因此条件的计算结果为<code class="fe ml mm mn mo b">true</code>，即使调用它会返回<code class="fe ml mm mn mo b">fasle</code>。</p><p id="9536" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TypeScript 3.7会立即捕捉到此错误:</p><p id="15e5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe ml mm mn mo b">This condition will always return true since the function is always defined. Did you mean to call it instead?</code></p><p id="daa9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个简单的内置检查应该可以提高你的质量，不需要额外的步骤，所以我完全支持。</p><h1 id="c031" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">TypeScript 3.7的后续步骤</h1><p id="eb65" class="pw-post-body-paragraph jv jw in jx b jy mg ka kb kc mh ke kf kg mi ki kj kk mj km kn ko mk kq kr ks ig bi translated">如果你想了解更多关于TypeScript的这些特性或其他改进，请看一下<a class="ae kt" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html" rel="noopener ugc nofollow" target="_blank">完整的发行说明</a>。</p><p id="1ee3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以通过运行<code class="fe ml mm mn mo b">npm update -g typescript</code>经由npm更新到TypeScript 3.7。</p><p id="f50b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您还没有开始使用TypeScript，请查看我的文章<a class="ae kt" href="https://killalldefects.com/2019/10/27/migrating-javascript-to-typescript/" rel="noopener ugc nofollow" target="_blank">将现有的JavaScript代码迁移到TypeScript </a>。</p><p id="5f19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你对这些变化有什么看法？你最兴奋的是什么？你有令人信服的理由使用我没有想到的断言函数吗？</p></div><div class="ab cl mw mx hr my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ig ih ii ij ik"><p id="b664" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="mv">原载于2019年11月7日</em><a class="ae kt" href="https://killalldefects.com/2019/11/06/how-typescript-3-7-helps-quality/" rel="noopener ugc nofollow" target="_blank"><em class="mv">https://killalldefects.com</em></a><em class="mv">。</em></p></div></div>    
</body>
</html>