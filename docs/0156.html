<html>
<head>
<title>Linked Lists In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的链表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/linked-list-in-javascript-d0224a6f15f7?source=collection_archive---------1-----------------------#2019-05-26">https://javascript.plainenglish.io/linked-list-in-javascript-d0224a6f15f7?source=collection_archive---------1-----------------------#2019-05-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f04d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这篇文章解释了如何用JavaScript实现一个链表</h2></div><p id="a4fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为JavaScript不像C语言那样有指针，所以我们将引用来链接JavaScript中的节点。如果你不熟悉对象引用的概念，可以看看我之前的文章<a class="ae lb" href="https://medium.com/@anupam1996/object-referencing-in-javascript-9ecb6ba29e22" rel="noopener">https://medium . com/@ anu PAM 1996/object-referencing-in-JavaScript-9 ECB 6 ba 29 e 22</a></p><p id="bb74" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">让我们来复习一下链表中的核心概念和操作。</strong></p><p id="72db" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">链表由不同的节点组成，这些节点通过指针或引用链接在一起。每个节点存储一些值和一个指针，该指针指向或存储下一个节点的地址。链表中的最后一个节点指向空。</p><p id="7349" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">追加<br/> </strong>链表中的插入操作必须是O(1)。<br/> <strong class="kh ir">前置</strong> <br/>链表中的前置操作必须再次为O(1)。<br/> <strong class="kh ir">插入<br/> </strong>链表中的插入操作为O(n)。<strong class="kh ir"> <br/>打印<br/> </strong>链表中的打印操作也用O(n)表示。<strong class="kh ir"> <br/>删除<br/> </strong>删除操作也是O(n)。</p><p id="7b9c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们先做一个类链表。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/e171ded4842660c9a147493151aa8227.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Bu-oRqM44mA6Yx0st39Uhw.png"/></div></div></figure><p id="0663" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类<strong class="kh ir"> LinkedList </strong>由三个属性<br/> 1组成。<strong class="kh ir"> head </strong> - &gt; head是我们链表的起始节点。<br/> 2。<strong class="kh ir">尾</strong> - &gt;尾是指向头部的指针。<br/> 3。<strong class="kh ir"> length </strong> - &gt; length表示链表的长度。</p><p id="88ab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们从操作Append开始。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lo"><img src="../Images/c5c2c321a8c229e4822c285cd9d9f3e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5pb2s-uJB6-svwOLgvMuQ.png"/></div></div></figure><p id="0308" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Append中，我们创建了一个存储新值的新节点。现在，由于尾节点引用的第一个节点是我们的头节点，所以现在<strong class="kh ir"> this.tail.next = newNode </strong>即意味着头节点next指针现在指向newNode。由于尾节点是我们的指针，<strong class="kh ir"> this.tail = newNode </strong>即tail现在指向新节点。</p><p id="7daa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看操作<strong class="kh ir"> Prepend。</strong></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lp"><img src="../Images/da102b9aca6099c1b7d79f8f4e2a7717.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rUgHqnhBtEuA_dHkexUlEg.png"/></div></div></figure><p id="c7eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Prepend中，我们只需在链表的开头添加一个新节点。因此，我们创建一个新节点，并将其指向头部，即第一个节点。现在，由于newNode应该是第一个节点，<strong class="kh ir"> this.head = newNode </strong>使newNode成为头节点。</p><p id="40f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们来看看<strong class="kh ir">插入的操作。</strong></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lq"><img src="../Images/1d9eec95ab7d670a2274169addf6a4d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vfrGbG6R3AqMKbDrMRseuA.png"/></div></div></figure><p id="df73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Insert中，我们在给定的索引后添加一个新的节点。首先我们需要检查索引是否等于或大于链表的长度，这就变成了一个追加操作。如果不是这样，我们创建一个包含值和下一个指针的newNode。为了找到需要插入新节点的节点的位置，我们创建了一个函数<strong class="kh ir"> traverseToIndex </strong>，它返回指向需要插入新节点的节点的指针。变量<strong class="kh ir"> holdingPointer </strong>存储我们需要插入新节点的节点的下一个节点。然后我们将首节点next指针改为newNode，newNode next指针改为<strong class="kh ir"> holdingPointer </strong>。</p><p id="b95a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们看看<strong class="kh ir">移除</strong>操作在链表中是如何工作的。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lr"><img src="../Images/8e4697989601b804dc12eb22dedb726c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hXPIAsgE1l1rX0WVB-EKQA.png"/></div></div></figure><p id="70c5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">删除操作类似于插入操作。给定要删除的节点的索引，使用<strong class="kh ir"> traverseToIndex </strong>函数，我们找到要删除的节点的前一个节点地址，即leader。现在我们找到要删除的节点的下一个节点。指向上一个节点下一个指针指向要删除的节点的下一个节点。</p><p id="8b85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在让我们<strong class="kh ir">打印</strong>我们的链表。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ls"><img src="../Images/b3c29b5127f9f0029d3beab22ce869df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RlAWyOk7Ez9MUcJvHLoRrg.png"/></div></div></figure><p id="463b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">打印一个链表非常简单。只需从头节点开始，使用下一个指针遍历，直到最后一个节点。</p><p id="e38e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，但是对于你们中的一些人来说，可能会有一个困惑，我们删除的所有对象去了哪里？它们仍然存储在内存中还是被永久删除。因此，在JavaScript中，我们不需要担心这些事情，因为所有这些事情都是由JavaScript的垃圾收集在内部管理的。</p></div></div>    
</body>
</html>