<html>
<head>
<title>Understanding TypeScript Configuration Options</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解TypeScript配置选项</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-configuration-options-tsconfig-json-561d4a2ad4b?source=collection_archive---------0-----------------------#2020-02-23">https://javascript.plainenglish.io/typescript-configuration-options-tsconfig-json-561d4a2ad4b?source=collection_archive---------0-----------------------#2020-02-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fcbc" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">介绍TypeScript配置选项如何工作。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/464dfe3814bb31dcc167e583ae9da974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/0*bwH0ay1wWQ3T4oU4.png"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">TypeScript</figcaption></figure><p id="0417" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章将通过一些例子向你展示<code class="fe ln lo lp lq b">tsconfig.json</code>在你的应用程序中是如何工作的。</p><h1 id="85fd" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">回购示例</h1><p id="ebb8" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">这里有一个完整的示例代码库链接供参考。您可以用一个非常简单的例子来测试这些选项。</p><div class="mo mp gp gr mq mr"><a href="https://github.com/manakuro/typescript-compiler-options-example" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">manakuro/typescript-编译器-选项-示例</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">测试TypeScript编译器选项。为manakuro/typescript-compiler-options-example开发做出贡献，创建一个…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">github.com</p></div></div><div class="na l"><div class="nb l nc nd ne na nf kl mr"/></div></div></a></div><h1 id="2d52" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">配置选项</h1><p id="e7c0" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">我们将在<a class="ae ng" href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html" rel="noopener ugc nofollow" target="_blank">文档</a>中介绍以下配置选项:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="11ee" class="nl ls iq lq b gy nm nn l no np"><strong class="lq ir">File Inclusion</strong><br/> - files<br/> - include<br/> - exclude<br/> - extends<br/> - typeAcquisition<br/> - references</span><span id="c926" class="nl ls iq lq b gy nq nn l no np"><strong class="lq ir">Project Options<br/></strong> - incremental<br/> - target<br/> - module<br/> - lib<br/> - allowJs<br/> - checkJs<br/> - jsx<br/> - declaration<br/> - declarationMap<br/> - sourceMap<br/> - outFile<br/> - outDir<br/> - rootDir<br/> - composite<br/> - tsBuildInfoFile<br/> - removeComments<br/> - noEmit<br/> - importHelpers<br/> - downlevelIteration<br/> - isolatedModules</span><span id="4159" class="nl ls iq lq b gy nq nn l no np"><strong class="lq ir">Strict Checks</strong><br/> - strict<br/> - noImplicitAny<br/> - strictNullChecks<br/> - strictFunctionTypes<br/> - strictBindCallApply<br/> - strictPropertyInitialization<br/> - noImplicitThis<br/> - alwaysStrict</span><span id="90a4" class="nl ls iq lq b gy nq nn l no np"><strong class="lq ir">Module Resolution</strong><br/>- moduleResolution<br/>- baseUrl<br/>- paths<br/>- rootDirs<br/>- typeRoots<br/>- types<br/>- allowSyntheticDefaultImports<br/>- esModuleInterop<br/>- preserveSymlinks<br/>- allowUmdGlobalAccess</span><span id="bc24" class="nl ls iq lq b gy nq nn l no np"><strong class="lq ir">Linter Checks</strong><br/>- noUnusedLocals<br/>- noUnusedParameters<br/>- noImplicitReturns<br/>- noFallthroughCasesInSwitch</span><span id="85c4" class="nl ls iq lq b gy nq nn l no np"><strong class="lq ir">Experimental</strong><br/>- experimentalDecorators<br/>- emitDecoratorMetadata</span></pre><h1 id="f87b" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">先决条件</h1><p id="3b7b" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">安装<code class="fe ln lo lp lq b">typescript</code>并生成<code class="fe ln lo lp lq b">tsconfig.json</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="00b5" class="nl ls iq lq b gy nm nn l no np">$ npm init<br/>$ npm i -D typescript@3.7.5<br/>$ npx tsc --init</span></pre><h1 id="2c6a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">文件包含</h1><h2 id="518b" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">文件</h2><p id="d434" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">您可以在程序中直接指定要编译的文件。如果<code class="fe ln lo lp lq b">.ts</code>被排除，默认自动搜索<code class="fe ln lo lp lq b">.ts</code>和<code class="fe ln lo lp lq b">.tsx</code>文件。</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="ad1f" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {},<br/><strong class="lq ir">  "files": [<br/>    "index.ts",<br/>    "hello"<br/>  ]</strong><br/>}</span></pre><h2 id="8d6d" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">包括</h2><p id="857d" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">您可以使用文件名数组或glob模式指定要在程序中编译的文件。</p><blockquote class="oc od oe"><p id="dc0b" class="kr ks of kt b ku kv jr kw kx ky ju kz og lb lc ld oh lf lg lh oi lj lk ll lm ij bi translated">*匹配零个或多个字符(不包括目录分隔符)<br/>？匹配任何一个字符(不包括目录分隔符)<br/> **/递归匹配任何子目录</p></blockquote><p id="8a1f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">默认情况下，TypeScript搜索带有<code class="fe ln lo lp lq b">.ts</code>、<code class="fe ln lo lp lq b">.tsx</code>和<code class="fe ln lo lp lq b">.d.ts</code>的文件，如果<code class="fe ln lo lp lq b">allowJs</code>设置为true，<code class="fe ln lo lp lq b">.js</code>和<code class="fe ln lo lp lq b">.jsx</code>将被编译。</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="549c" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {},<br/><strong class="lq ir">  "include": [<br/>    "src/**/*"<br/>  ]</strong><br/>}</span></pre><p id="00c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果不提供<code class="fe ln lo lp lq b">files</code>和<code class="fe ln lo lp lq b">include</code>，TypeScript将自动编译目录中除<code class="fe ln lo lp lq b">excludes</code>选项指定的文件以外的所有文件(<code class="fe ln lo lp lq b">.ts, .tsx</code>)。</p><p id="7304" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你也可以像这样同时使用<code class="fe ln lo lp lq b">files</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="687f" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {},<br/>  "include": [<br/>    "src/**/*"<br/>  ],<br/>  <strong class="lq ir">"files": ["hello"]</strong><br/>}</span></pre><h2 id="071b" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">排除</h2><p id="32d1" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">您可以使用文件名数组或glob模式指定程序中不编译的文件。通常用作<code class="fe ln lo lp lq b">include</code>选项的过滤。</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="536a" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {},<br/>  "include": [<br/>    "src/**/*"<br/>  ],<br/><strong class="lq ir">  "exclude": [<br/>    "node_modules",<br/>    "src/exclude.ts"<br/>  ]</strong><br/>}</span></pre><p id="e1bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上例中，<code class="fe ln lo lp lq b">node_modules</code>和<code class="fe ln lo lp lq b">src/exclude.ts</code>将被排除。但是如果使用<code class="fe ln lo lp lq b">files</code>选项:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="6dd3" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {},<br/>  "include": [<br/>    "src/**/*"<br/>  ],<br/>  "exclude": [<br/>    "node_modules",<br/>    "src/exclude.ts"<br/>  ],<br/>  <strong class="lq ir">"files": ["src/exclude.ts"]</strong><br/>}</span></pre><p id="9547" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">exclude</code>将被忽略，TypeScript将编译<code class="fe ln lo lp lq b">src/exclude.ts</code>。</p><p id="311e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在另一种情况下，如果<code class="fe ln lo lp lq b">src/exclude.ts</code>引用<code class="fe ln lo lp lq b">src/utils/index.ts</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="0b0b" class="nl ls iq lq b gy nm nn l no np">// src/exclude.ts</span><span id="f76a" class="nl ls iq lq b gy nq nn l no np"><strong class="lq ir">import util from './utils';</strong></span><span id="6fd3" class="nl ls iq lq b gy nq nn l no np">const excluded = "Hey excluded"</span><span id="201a" class="nl ls iq lq b gy nq nn l no np">console.log(util)<br/>console.log(excluded)</span></pre><p id="4253" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">src/utils/index.ts</code>不排除会被编译。您需要显式包含这些文件。</p><p id="a52c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果<code class="fe ln lo lp lq b">exclude</code>被禁用，TypeScript将默认包含这些目录:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="9127" class="nl ls iq lq b gy nm nn l no np">- node_modules<br/>- bower_components<br/>- jspm_packages<br/>- the files &lt;outDir&gt; option specifies</span></pre><h2 id="d692" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">延伸</h2><p id="1e29" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">您可以通过继承来扩展另一个配置。</p><p id="6ba9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们有<code class="fe ln lo lp lq b">tsconfig.base.json</code>和<code class="fe ln lo lp lq b">tsconfig.json</code>。</p><p id="0334" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">tsconfig.base.json</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="fab5" class="nl ls iq lq b gy nm nn l no np">// <!-- -->tsconfig.base.json</span><span id="35fb" class="nl ls iq lq b gy nq nn l no np">{<br/>  "compilerOptions": {},<br/>  "include": ["src/**/*"]<br/>}</span></pre><p id="d9e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">tsconfig.json</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="26dc" class="nl ls iq lq b gy nm nn l no np">{<br/>  "extends": "./tsconfig.base.json"<br/>}</span></pre><p id="6e94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将编译<code class="fe ln lo lp lq b">src/</code>目录下的所有文件，但是如果您想特别包含<code class="fe ln lo lp lq b">hello.ts</code>，请添加:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3854" class="nl ls iq lq b gy nm nn l no np">{<br/>  "extends": "./tsconfig.base.json",<br/><strong class="lq ir">  "files": ["hello"]</strong><br/>}</span></pre><p id="5f6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它从基本配置文件扩展了<code class="fe ln lo lp lq b">files</code>。</p><h2 id="02a9" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">类型获取</h2><p id="1594" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">如果您的编辑器中有一个JavaScript项目，默认情况下，TypeScript使用<code class="fe ln lo lp lq b">@types</code>声明为您的<code class="fe ln lo lp lq b">node_moduels</code>提供类型。您可以使用此选项自定义行为。</p><p id="3636" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您想禁用此功能，只需将其关闭:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="4986" class="nl ls iq lq b gy nm nn l no np">{<br/>  "typeAcquisition": {<br/>    "enable": false<br/>  }<br/>}</span></pre><p id="c476" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您想指定应该包含但不在<code class="fe ln lo lp lq b">node_modules</code>中的模块:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="974f" class="nl ls iq lq b gy nm nn l no np">{<br/>  "typeAcquisition": {<br/>    "include": ["react"]<br/>  }<br/>}</span></pre><p id="d1d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您想从<code class="fe ln lo lp lq b">node_modules</code>中明确排除模块:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="a56b" class="nl ls iq lq b gy nm nn l no np">{<br/>  "typeAcquisition": {<br/>    "exclude": ["jquery"]<br/>  }<br/>}</span></pre><p id="f699" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常它会在JavaScript项目中用作类型检查。</p><h2 id="95ce" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">参考</h2><p id="d58f" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当您使用<a class="ae ng" href="https://www.typescriptlang.org/v2/docs/handbook/project-references.html" rel="noopener ugc nofollow" target="_blank">项目引用</a>时，您可以启用此选项。项目引用是TypeScript 3.0+中的新功能。通过使用它，您可以将TypeScript项目组织成更小的部分。通过分成多个项目，可以提高类型检查和编译过程的速度。</p><p id="b3cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看看这个特性。以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="c66e" class="nl ls iq lq b gy nm nn l no np">├── app<br/>│   └── src<br/>│       └── index.ts<br/>├── test<br/>│   └── index.test.ts<br/>└── tsconfig.json</span></pre><p id="cfd4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">假设我们有<code class="fe ln lo lp lq b">app</code>模块、<code class="fe ln lo lp lq b">test</code>和一个<code class="fe ln lo lp lq b">tsconfig</code>文件。</p><p id="a904" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">tsconfig.json</code>只是简单的一个:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="4502" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "outDir": "./dist"<br/>  }<br/>}</span></pre><p id="635d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">构建完成后，您将在<code class="fe ln lo lp lq b">dist</code>中看到结果:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="58cc" class="nl ls iq lq b gy nm nn l no np">├── app<br/>│   └── src<br/>│       └── index.ts<strong class="lq ir"><br/>├── dist<br/>│   ├── app<br/>│   │   └── src<br/>│   └── test<br/>│       └── index.test.js</strong><br/>├── test<br/>│   └── index.test.ts<br/>└── tsconfig.json</span></pre><p id="65ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript已经在<code class="fe ln lo lp lq b">dist</code>文件夹中构建了<code class="fe ln lo lp lq b">app</code>和<code class="fe ln lo lp lq b">test</code>，但是您可能不想将<code class="fe ln lo lp lq b">test</code>作为输出，所以您可以使用<code class="fe ln lo lp lq b">include</code>选项:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="9656" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "outDir": "./dist"<br/>  },<br/>  <strong class="lq ir">"include": ["./app/**/*"]</strong><br/>}</span></pre><p id="a6fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这解决了问题，但也意味着编译器和类型检查会忽略所有的测试文件，这是一些人可能没有预料到的。</p><p id="992e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，TypeScript还有另外一个选择。</p><p id="385c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们改变文件结构:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="ab42" class="nl ls iq lq b gy nm nn l no np">├── app<br/>│   ├── src<br/>│   │   └── index.ts<br/>│   └── <strong class="lq ir">tsconfig.json</strong><br/>├── test<br/>│   ├── index.test.ts<br/>│   └── <strong class="lq ir">tsconfig.json</strong><br/>└── <strong class="lq ir">tsconfig-base.json</strong></span></pre><p id="c20f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">tsconfig-base.json</code>是<code class="fe ln lo lp lq b">/tsconfig.json</code>和<code class="fe ln lo lp lq b">test/tsconfig.json</code>可以扩展到的共享选项。</p><p id="fbaf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ln lo lp lq b">test/tsconfig.json</code>中增加<code class="fe ln lo lp lq b">references</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="8ac5" class="nl ls iq lq b gy nm nn l no np">{<br/>  "extends": "../tsconfig-base.json",<br/>  "compilerOptions": {},<br/><strong class="lq ir">  "references": [{<br/>    "path": "../app"<br/>  }]</strong><br/>}</span></pre><p id="c821" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并在<code class="fe ln lo lp lq b">app/tsconfig.json</code>开启<code class="fe ln lo lp lq b">composite</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="001c" class="nl ls iq lq b gy nm nn l no np">{<br/>  "extends": "../tsconfig-base.json",<br/>  "compilerOptions": {<br/>    "outDir": "../dist",<br/><strong class="lq ir">    "composite": true</strong><br/>  }<br/>}</span></pre><p id="38fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，构建它:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="012e" class="nl ls iq lq b gy nm nn l no np">tsc -b app test</span></pre><p id="45ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出将是:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="d75b" class="nl ls iq lq b gy nm nn l no np">├── app<br/>│   ├── src<br/>│   │   └── index.ts<br/>│   └── tsconfig.json<br/><strong class="lq ir">├── dist<br/>│   ├── src<br/>│   │   ├── index.d.ts<br/>│   │   └── index.js<br/>│   └── tsconfig.tsbuildinfo</strong><br/>├── test<br/>│   ├── index.test.ts<br/>│   └── tsconfig.json<br/>└── tsconfig-base.json</span></pre><p id="98e9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，你不再需要使用<code class="fe ln lo lp lq b">include</code>选项，输出已经内置在<code class="fe ln lo lp lq b">dist</code>中，不包括<code class="fe ln lo lp lq b">test</code>，也不忽略任何编译错误。</p><p id="e2c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果运行<code class="fe ln lo lp lq b">tsc</code>进行测试，TypeScript将总是首先构建<code class="fe ln lo lp lq b">app</code>作为被引用的模块，即使不考虑顺序。</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="9a06" class="nl ls iq lq b gy nm nn l no np">tsc -b test app</span></pre><p id="299b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">更多描述，可以看<a class="ae ng" href="https://www.typescriptlang.org/docs/handbook/project-references.html" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><h1 id="7878" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">项目选项</h1><h2 id="10a7" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">增加的</h2><p id="682b" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">incremental</code>为真时，TypeScript将保存最新编译的项目图的信息。它比较前一个文件和当前文件之间的差异，并编译您更改过的文件。第一次构建的时间通常会更长，但之后会节省时间。</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="380f" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"incremental": true</strong><br/>  },<br/>  "include": [<br/>    "src/**/*"<br/>  ]<br/>}</span></pre><p id="9251" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行<code class="fe ln lo lp lq b">tsc</code>后，TypeScript将生成<code class="fe ln lo lp lq b">tsconfig.tsbuildinfo</code>，用于检测类型检查和发出更改的最低成本方式。</p><p id="5dc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想把文件建立到特定的文件夹，你可以使用<code class="fe ln lo lp lq b">tsBuildInfoFile</code>选项:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="cda3" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "incremental": true,<br/>    <strong class="lq ir">"tsBuildInfoFile": "./path/my.tsbuildinfo"</strong><br/>  },<br/>  "include": [<br/>    "src/**/*"<br/>  ]<br/>}</span></pre><h2 id="fb5e" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">目标</h2><p id="2485" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">构建时可以选择生成JavaScript文件的版本。所以如果你选择<code class="fe ln lo lp lq b">es2015</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="1467" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"target": "es2015"</strong><br/>  }<br/>}</span></pre><p id="1de3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="f956" class="nl ls iq lq b gy nm nn l no np">const hi = () =&gt; new Promise(resolve =&gt; resolve('hi'))<br/>const hey = async () =&gt; await hi()<br/>console.log(hey())</span></pre><p id="f008" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出将具有<code class="fe ln lo lp lq b">ES2015</code>功能:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="13cf" class="nl ls iq lq b gy nm nn l no np">var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {<br/>    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }<br/>    return new (P || (P = Promise))(function (resolve, reject) {<br/>        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }<br/>        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }<br/>        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }<br/>        step((generator = generator.apply(thisArg, _arguments || [])).next());<br/>    });<br/>};<br/>const hi = () =&gt; new Promise(resolve =&gt; resolve('hi'));<br/>const hey = () =&gt; __awaiter(this, void 0, void 0, function* () { return yield hi(); });<br/>console.log(hey());</span></pre><p id="7883" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果选择<code class="fe ln lo lp lq b">es2020</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="e8cb" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "target": "es2020"<br/>  }<br/>}</span></pre><p id="25a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">代码将生成为<code class="fe ln lo lp lq b">ES2020</code>特征:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="588f" class="nl ls iq lq b gy nm nn l no np">const hi = () =&gt; new Promise(resolve =&gt; resolve('hi'));<br/>const hey = async () =&gt; await hi();<br/>console.log(hey());</span></pre><h2 id="242c" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">组件</h2><p id="cfb6" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">您可以选择JavaScript文件的模块系统，如下所示:</p><ul class=""><li id="85d0" class="oj ok iq kt b ku kv kx ky la ol le om li on lm oo op oq or bi translated"><code class="fe ln lo lp lq b">CommonJS</code></li><li id="bdb8" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><code class="fe ln lo lp lq b">UMD</code></li><li id="2f85" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><code class="fe ln lo lp lq b">AMD</code></li><li id="7ba7" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><code class="fe ln lo lp lq b">System</code></li><li id="55ae" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><code class="fe ln lo lp lq b">ESNext</code></li><li id="995e" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><code class="fe ln lo lp lq b">ES2015</code></li><li id="fee2" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><code class="fe ln lo lp lq b">NONE</code></li></ul><p id="45d3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3d4f" class="nl ls iq lq b gy nm nn l no np">// hello.ts</span><span id="eb2b" class="nl ls iq lq b gy nq nn l no np">export const hello = 'Hey hello'<br/>console.log(hello)</span></pre><p id="329c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">CommonJS</code>出现时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="d587" class="nl ls iq lq b gy nm nn l no np">"use strict";<br/>exports.__esModule = true;<br/>exports.hello = 'Hey hello';<br/>console.log(exports.hello);</span></pre><p id="1bc8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">UMD</code>出现时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="a67f" class="nl ls iq lq b gy nm nn l no np">(function (factory) {<br/>    if (typeof module === "object" &amp;&amp; typeof module.exports === "object") {<br/>        var v = factory(require, exports);<br/>        if (v !== undefined) module.exports = v;<br/>    }<br/>    else if (typeof define === "function" &amp;&amp; define.amd) {<br/>        define(["require", "exports"], factory);<br/>    }<br/>})(function (require, exports) {<br/>    "use strict";<br/>    exports.__esModule = true;<br/>    exports.hello = 'Hey hello';<br/>    console.log(exports.hello);<br/>});</span></pre><p id="53ac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">AMD</code>出现时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="c449" class="nl ls iq lq b gy nm nn l no np">define(["require", "exports"], function (require, exports) {<br/>    "use strict";<br/>    exports.__esModule = true;<br/>    exports.hello = 'Hey hello';<br/>    console.log(exports.hello);<br/>});</span></pre><p id="9968" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">ESNEXT</code>出现时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="445a" class="nl ls iq lq b gy nm nn l no np">export var hello = 'Hey hello';<br/>console.log(hello);</span></pre><h2 id="9324" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">解放运动</h2><p id="afa5" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">TypeScript自动包含一组内置JavaScript APIs的类型定义和与您指定的<code class="fe ln lo lp lq b">target</code>相匹配的特性。例如，如果<code class="fe ln lo lp lq b">target</code>是<code class="fe ln lo lp lq b">ES3</code>，而你想使用<code class="fe ln lo lp lq b">Promise</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="d09a" class="nl ls iq lq b gy nm nn l no np">// hello.ts</span><span id="3144" class="nl ls iq lq b gy nq nn l no np">export const hello = new Promise(resolve =&gt; resolve('Hey hello'))</span></pre><p id="f44f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将发出一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="fd93" class="nl ls iq lq b gy nm nn l no np">hello.ts:1:26 - error TS2585: 'Promise' only refers to a type, but is being used as a value here. Do you need to change your target library? Try changing the `lib` compiler option to es2015 or later.</span><span id="6e23" class="nl ls iq lq b gy nq nn l no np">export const hello = new Promise(resolve =&gt; resolve('Hey hello'))</span></pre><p id="dda8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为<code class="fe ln lo lp lq b">ES3</code>没有Promise API，所以为了使用它，你需要显式包含<code class="fe ln lo lp lq b">ES2015</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3ba4" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "target": "ES3",<br/>    <strong class="lq ir">"lib": ["ES2015"]</strong><br/>  }<br/>}</span></pre><p id="411b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将生成如下JavaScript文件:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="b111" class="nl ls iq lq b gy nm nn l no np">"use strict";<br/>exports.__esModule = true;<br/>exports.hello = new Promise(function (resolve) { return resolve('Hey hello'); });</span></pre><p id="2c9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果想使用特定的JavaScript特性，可以查看<a class="ae ng" href="https://github.com/microsoft/TypeScript/tree/master/lib" rel="noopener ugc nofollow" target="_blank">源代码</a>中的库组件。</p><h2 id="5bc2" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">允许</h2><p id="0286" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">allowJs</code>为<code class="fe ln lo lp lq b">true</code>时，TypeScript将允许编译JavaScript文件，但不会进行类型检查。</p><p id="0f7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="b887" class="nl ls iq lq b gy nm nn l no np">├── hello.ts<br/>├── helloJavaScript.js<br/>└── tsconfig.json</span></pre><p id="6ff9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">allowJs</code>禁用时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="6ee4" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "outDir": "./dist",<br/>    <strong class="lq ir">"allowJs": false</strong><br/>  }<br/>}</span></pre><p id="9fd2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行<code class="fe ln lo lp lq b">tsc</code>后，<code class="fe ln lo lp lq b">dist</code>将不包括<code class="fe ln lo lp lq b">helloJavaScript.js</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="b14e" class="nl ls iq lq b gy nm nn l no np">dist<br/>└── hello.js</span></pre><p id="33f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">allowJs</code>启用时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="ce2a" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "outDir": "./dist",<br/>    <strong class="lq ir">"allowJs": true</strong><br/>  }<br/>}</span></pre><p id="dbb8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">helloJavaScript.js</code>将在<code class="fe ln lo lp lq b">dist</code>中:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="12c8" class="nl ls iq lq b gy nm nn l no np">dist<br/>├── hello.js<br/>└── <strong class="lq ir">helloJavaScript.js</strong></span></pre><h2 id="e0a0" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">checkJs</h2><p id="4bad" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">您可以将<code class="fe ln lo lp lq b">checkJs</code>与<code class="fe ln lo lp lq b">allowJs</code>选项一起使用。当<code class="fe ln lo lp lq b">checkJs</code>被启用时，TypeScript将为JavaScript文件引发错误。</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="13c3" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "outDir": "./dist",<br/>    "allowJs": true,<br/>    "<strong class="lq ir">checkJs</strong>": <strong class="lq ir">true</strong><br/>  }<br/>}</span></pre><p id="bd80" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些JavaScript代码示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="4f61" class="nl ls iq lq b gy nm nn l no np">const helloJavaScript = parseInt(10)</span><span id="65e2" class="nl ls iq lq b gy nq nn l no np">export default helloJavaScript</span></pre><p id="2aa1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将报告一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="8d55" class="nl ls iq lq b gy nm nn l no np">helloJavaScript.js:1:34 - error TS2345: Argument of type '10' is not assignable to parameter of type 'string'.</span><span id="69e6" class="nl ls iq lq b gy nq nn l no np">1 const helloJavaScript = parseInt(10)<br/>                                   ~~<br/>Found 1 error.</span></pre><h2 id="c318" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">jsx</h2><p id="f793" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">您可以选择如何在JavaScript文件中发出TypeScript控件JSX构造。该选项仅在以<code class="fe ln lo lp lq b">.tsx</code>开始的文件中受影响。</p><blockquote class="oc od oe"><p id="c701" class="kr ks of kt b ku kv jr kw kx ky ju kz og lb lc ld oh lf lg lh oi lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b"><em class="iq">preserve</em></code>:发出<code class="fe ln lo lp lq b"><em class="iq">.jsx</em></code>文件，JSX不变</p><p id="6a91" class="kr ks of kt b ku kv jr kw kx ky ju kz og lb lc ld oh lf lg lh oi lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b"><em class="iq">react</em></code>:将<code class="fe ln lo lp lq b"><em class="iq">.js</em></code>文件与JSX发出的<code class="fe ln lo lp lq b"><em class="iq">React.createElement</em></code>调用进行等效转换</p><p id="89e8" class="kr ks of kt b ku kv jr kw kx ky ju kz og lb lc ld oh lf lg lh oi lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b"><em class="iq">react-native</em></code>:发出<code class="fe ln lo lp lq b"><em class="iq">.js</em></code>文件，JSX不变</p></blockquote><p id="b23e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些React代码示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="e527" class="nl ls iq lq b gy nm nn l no np">// <!-- -->hello.tsx</span><span id="a3eb" class="nl ls iq lq b gy nq nn l no np">import React from 'react'</span><span id="bf44" class="nl ls iq lq b gy nq nn l no np">type Props = {<br/>  foo: string;<br/>  bar: string;<br/>}</span><span id="90b8" class="nl ls iq lq b gy nq nn l no np">const Hi: React.FC = () =&gt; &lt;p&gt;hi&lt;/p&gt;</span><span id="4501" class="nl ls iq lq b gy nq nn l no np">export const Hello: React.FC&lt;Props&gt; = ({foo, bar}) =&gt;<br/>  &lt;Hi&gt;{foo} {bar}&lt;/Hi&gt;;</span></pre><p id="5ce4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">preserve</code>出现时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="0b53" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"jsx": "</strong><strong class="lq ir">preserve</strong><strong class="lq ir">"</strong><br/>  }<br/>}</span></pre><p id="07c3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出将是<code class="fe ln lo lp lq b">hello.jsx</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="c9ba" class="nl ls iq lq b gy nm nn l no np">"use strict";<br/>exports.__esModule = true;<br/>var react_1 = require("react");</span><span id="e310" class="nl ls iq lq b gy nq nn l no np">var Hi = function () { return &lt;p&gt;hi&lt;/p&gt;; };<br/>exports.Hello = function (_a) {<br/>    var foo = _a.foo, bar = _a.bar;<br/>    return &lt;Hi&gt;{foo} {bar}&lt;/Hi&gt;;<br/>};</span></pre><p id="247c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">preserve</code>保持JSX语法不变。使用Babel作为编译器时，可以启用这个选项。</p><p id="01b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想把它编译成React，就改成<code class="fe ln lo lp lq b">react</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="fe0a" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"jsx": "react"</strong><br/>  }<br/>}</span></pre><p id="3bb1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">编译后的文件将是<code class="fe ln lo lp lq b">hello.js</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="0a34" class="nl ls iq lq b gy nm nn l no np">"use strict";<br/>exports.__esModule = true;<br/>var react_1 = require("react");<br/>var Hi = function () { return react_1["default"].createElement("p", null, "hi"); };<br/>exports.Hello = function (_a) {<br/>    var foo = _a.foo, bar = _a.bar;<br/>    return react_1["default"].createElement(Hi, null,<br/>        foo,<br/>        " ",<br/>        bar);<br/>};</span></pre><p id="0cf8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">react-native</code>发生时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="361d" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"jsx": "</strong><strong class="lq ir">react-native</strong><strong class="lq ir">"</strong><br/>  }<br/>}</span></pre><p id="35f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出将是<code class="fe ln lo lp lq b">hello.js</code>,但JSX的语法仍然是这样:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="7969" class="nl ls iq lq b gy nm nn l no np">"use strict";<br/>exports.__esModule = true;<br/>var react_1 = require("react");<br/>var Hi = function () { return &lt;p&gt;hi&lt;/p&gt;; };<br/>exports.Hello = function (_a) {<br/>    var foo = _a.foo, bar = _a.bar;<br/>    return &lt;Hi&gt;{foo} {bar}&lt;/Hi&gt;;<br/>};</span></pre><h2 id="89f7" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">申报</h2><p id="927f" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">TypeScript为项目中的所有TypeScript和JavaScript文件生成<code class="fe ln lo lp lq b">.d.ts</code>文件。</p><p id="a99e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="e949" class="nl ls iq lq b gy nm nn l no np">.<br/>├── hello.ts<br/>└── tsconfig.json</span></pre><p id="3faa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">declaration</code>启用时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="b885" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "outDir": "./dist",<br/>    <strong class="lq ir">"declaration": true</strong><br/>  }<br/>}</span></pre><p id="3f7e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出将是:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="ba74" class="nl ls iq lq b gy nm nn l no np">├── dist<br/>│   ├── <strong class="lq ir">hello.d.ts</strong><br/>│   └── hello.js<br/>├── hello.ts<br/>└── tsconfig.json</span></pre><p id="a0cb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以看到生成的<code class="fe ln lo lp lq b">hello.d.ts</code>文件。</p><p id="5c13" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您想要包含JavaScript文件:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="09a6" class="nl ls iq lq b gy nm nn l no np">├── hello.ts<br/>├── <strong class="lq ir">helloJs.js</strong><br/>└── tsconfig.json</span></pre><p id="97be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">打开<code class="fe ln lo lp lq b">allowJs</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="8bdf" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "outDir": "./dist",<br/>    "declaration": true,<br/>    <strong class="lq ir">"allowJs": true</strong><br/>  }<br/>}</span></pre><p id="e453" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出将是:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="91d7" class="nl ls iq lq b gy nm nn l no np">├── dist<br/>│   ├── hello.d.ts<br/>│   ├── hello.js<br/><strong class="lq ir">│   ├── helloJs.d.ts<br/>│   └── helloJs.js</strong><br/>├── hello.ts<br/>├── helloJs.js<br/>└── tsconfig.json</span></pre><p id="bb58" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">可以看到，<code class="fe ln lo lp lq b">helloJs.d.ts</code>和<code class="fe ln lo lp lq b">helloJs.js</code>是在<code class="fe ln lo lp lq b">dist</code>中生成的。</p><p id="2668" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想包括唯一的声明文件，使用<code class="fe ln lo lp lq b">emitDeclarationOnly</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="6498" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "outDir": "./dist",<br/>    "declaration": true,<br/>    "allowJs": true,<br/>    <strong class="lq ir">"emitDeclarationOnly": true</strong><br/>  }<br/>}</span></pre><p id="a6af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出将是唯一的声明文件:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="9caf" class="nl ls iq lq b gy nm nn l no np">├── dist<br/><strong class="lq ir">│   ├── hello.d.ts<br/>│   └── helloJs.d.ts</strong><br/>├── hello.ts<br/>├── helloJs.js<br/>└── tsconfig.json</span></pre><h2 id="b7c2" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">声明地图</h2><p id="53b6" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">TypeScript为声明文件生成一个源映射，它映射到原始的<code class="fe ln lo lp lq b">.ts</code>源文件。这对于像VS Code或IntelliJ这样的编辑器在使用<code class="fe ln lo lp lq b">Go to Definition</code>功能时查找<code class="fe ln lo lp lq b">.ts</code>文件很有用。</p><p id="4d94" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="5c26" class="nl ls iq lq b gy nm nn l no np">├── hello.ts<br/>└── tsconfig.json</span></pre><p id="1a7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">declarationMap</code> <strong class="kt ir"> </strong>启用时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="f7fc" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "outDir": "./dist",<br/>    "declaration": true,<br/><strong class="lq ir">    "declarationMap": true</strong><br/>  }<br/>}</span></pre><p id="b44a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出将是:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="74af" class="nl ls iq lq b gy nm nn l no np">├── dist<br/>│   ├── hello.d.ts<br/><strong class="lq ir">│   ├── hello.d.ts.map</strong><br/>│   └── hello.js<br/>├── hello.ts<br/>└── tsconfig.json</span></pre><p id="4d5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">hello.d.ts.map</code>在dist文件夹中生成。</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="2a9b" class="nl ls iq lq b gy nm nn l no np">// <!-- -->hello.d.ts.map</span><span id="5c45" class="nl ls iq lq b gy nq nn l no np">{<br/> "version":3,<br/> "file":"hello.d.ts",<br/> "sourceRoot":"",<br/> "sources":["../hello.ts"],"names":[],<br/> "mappings":"AAAA,eAAO,MAAM,KAAK,cAAc,CAAA"<br/>}</span></pre><h2 id="ac0b" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">源地图</h2><p id="6871" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当它为true时，TypeScript生成一个源映射文件。</p><p id="4965" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="1b9c" class="nl ls iq lq b gy nm nn l no np">├── hello.ts<br/>└── tsconfig.json</span></pre><p id="d39f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">sourceMap</code> <strong class="kt ir"> </strong>启用时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="d939" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "outDir": "./dist",<br/>    <strong class="lq ir">"sourceMap": true</strong><br/>  }<br/>}</span></pre><p id="d369" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出将是:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="30ca" class="nl ls iq lq b gy nm nn l no np">├── dist<br/>│   ├── hello.js<br/><strong class="lq ir">│   └── hello.js.map</strong><br/>├── hello.ts<br/>└── tsconfig.json</span></pre><p id="bc32" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">hello.js.map</code>是在<code class="fe ln lo lp lq b">dist</code>中生成的:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3565" class="nl ls iq lq b gy nm nn l no np">// hello.js.map</span><span id="8991" class="nl ls iq lq b gy nq nn l no np">{<br/> "version":3,<br/> "file":"hello.js",<br/> "sourceRoot":"",<br/> "sources":["../hello.ts"],<br/> "names":[],<br/> "mappings":";;AAAa,QAAA,KAAK,GAAG,WAAW,CAAA"<br/>}</span></pre><p id="1adc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">dist/hello.js</code>也有一个源映射路径:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="373b" class="nl ls iq lq b gy nm nn l no np">"use strict";<br/>exports.__esModule = true;<br/>exports.hello = "Hey hello";<br/>//# sourceMappingURL=hello.js.map</span></pre><h2 id="3b85" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">输出文件</h2><p id="b995" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">outFile</code>被启用时，TypeScript将连接输出到一个文件。</p><p id="cb00" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果要使用这个，需要<code class="fe ln lo lp lq b">module</code>选项为<code class="fe ln lo lp lq b">amd</code>或<code class="fe ln lo lp lq b">system</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="7581" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "outFile": "./dist/bundle.js",<br/>    <strong class="lq ir">"module": "amd"</strong><br/>  }<br/>}</span></pre><p id="b116" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="db76" class="nl ls iq lq b gy nm nn l no np">├── hello.ts<br/>├── hello2.ts<br/>└── tsconfig.json</span></pre><p id="1a5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行<code class="fe ln lo lp lq b">tsc</code>后，输出将为:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="b658" class="nl ls iq lq b gy nm nn l no np">├── dist<br/><strong class="lq ir">│   └── bundle.js</strong><br/>├── hello.ts<br/>├── hello2.ts<br/>└── tsconfig.json</span></pre><p id="e8fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">hello.ts</code>和<code class="fe ln lo lp lq b">hello2.ts</code>捆绑成<code class="fe ln lo lp lq b">dist/bundle.js</code>。</p><h2 id="7c8b" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">户外</h2><p id="2496" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">TypeScript将输出结构重定向到特定目录。</p><p id="53d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="31ad" class="nl ls iq lq b gy nm nn l no np">├── hello.ts<br/>├── hello2.ts<br/>└── tsconfig.json</span></pre><p id="b805" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">指定<code class="fe ln lo lp lq b">outDir</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="ca10" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"outDir": "./dist"</strong><br/>  }<br/>}</span></pre><p id="bdec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出文件将在<code class="fe ln lo lp lq b">./dist</code>中:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3654" class="nl ls iq lq b gy nm nn l no np">├── dist<br/><strong class="lq ir">│   ├── hello.js<br/>│   └── hello2.js</strong><br/>├── hello.ts<br/>├── hello2.ts<br/>└── tsconfig.json</span></pre><p id="959c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">原始源文件的目录结构被保留。</p><h2 id="5d76" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">rootDir</h2><p id="7d44" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">您可以指定输入文件的根目录。但是，<code class="fe ln lo lp lq b">rootDir</code>不影响哪些文件成为编译的一部分，并且与<code class="fe ln lo lp lq b">include</code>、<code class="fe ln lo lp lq b">exclude</code>或<code class="fe ln lo lp lq b">files</code>选项没有交互。</p><p id="0875" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="40ca" class="nl ls iq lq b gy nm nn l no np">├── src<br/>│   └── index.ts<br/>├── hello.ts<br/>└── tsconfig.json</span></pre><p id="8fb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">指定<code class="fe ln lo lp lq b">outDir</code>和<code class="fe ln lo lp lq b">rootDir</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="1b26" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"outDir": "./dist",</strong><br/>    <strong class="lq ir">"rootDir": "./src"</strong><br/>  }<br/>}</span></pre><p id="bbf2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您希望它已经在<code class="fe ln lo lp lq b">dist</code>中编译了，但是TypeScript将报告一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="8c19" class="nl ls iq lq b gy nm nn l no np">hello.ts' is not under 'rootDir' ...</span><span id="3f86" class="nl ls iq lq b gy nq nn l no np">'rootDir' is expected to contain all source files.</span></pre><p id="c4ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为TypeScript在输出目录中保持与输入目录中相同的目录结构，并且当提供了<code class="fe ln lo lp lq b">outDir</code>时，TypeScript将永远不会将输出文件写入到<code class="fe ln lo lp lq b">outDir</code>之外的目录中。</p><p id="dc20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，TypeScript试图编译<code class="fe ln lo lp lq b">src/index.ts</code>和<code class="fe ln lo lp lq b">hello.ts</code>并将它们输出到<code class="fe ln lo lp lq b">dist</code>文件夹，但是由于设置了<code class="fe ln lo lp lq b">rootDir</code>，它期望<code class="fe ln lo lp lq b">src</code>文件夹中有所有要编译的源文件。</p><p id="96a1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要实现此功能，您可以使用<code class="fe ln lo lp lq b">include</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="7440" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "outDir": "./dist",<br/>    "rootDir": "./src"<br/>  },<br/><strong class="lq ir">  "include": [<br/>    "src/**/*"<br/>  ]</strong><br/>}</span></pre><p id="ba17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出将是:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="ce91" class="nl ls iq lq b gy nm nn l no np"><strong class="lq ir">├── dist<br/>│   └── index.js</strong><br/>├── src<br/>│   └── index.ts<br/>├── hello.ts<br/>└── tsconfig.json</span></pre><p id="2808" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">只有在<code class="fe ln lo lp lq b">src</code>下面是编译目标和输入文件的根。</p><p id="dd3c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您想像<code class="fe ln lo lp lq b">hello.ts</code>一样包含<code class="fe ln lo lp lq b">src</code>之外的内容，请将<code class="fe ln lo lp lq b">rootDir</code>改为:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="988a" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "outDir": "./dist",<br/>    "rootDir": "."<br/>  }<br/>}</span></pre><p id="c3d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出将是:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="8da6" class="nl ls iq lq b gy nm nn l no np">├── dist<br/><strong class="lq ir">│   ├── hello.js<br/></strong>│   └── src<br/>│       └── index.js<br/>├── src<br/>│   └── index.ts<br/>├── hello.ts<br/>└── tsconfig.json</span></pre><h2 id="086f" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">复合材料</h2><p id="457c" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">使用项目引用时，可以启用此选项。启用复合标志会改变一些事情:</p><blockquote class="oc od oe"><p id="e84b" class="kr ks of kt b ku kv jr kw kx ky ju kz og lb lc ld oh lf lg lh oi lj lk ll lm ij bi translated">如果没有明确设置，<code class="fe ln lo lp lq b"><em class="iq">rootDir</em></code>设置默认为包含<code class="fe ln lo lp lq b"><em class="iq">tsconfig</em></code>文件的目录</p><p id="f679" class="kr ks of kt b ku kv jr kw kx ky ju kz og lb lc ld oh lf lg lh oi lj lk ll lm ij bi translated">所有的实现文件必须与一个<code class="fe ln lo lp lq b"><em class="iq">include</em></code>模式匹配，或者列在<code class="fe ln lo lp lq b"><em class="iq">files</em></code>数组中。如果违反了这个约束，<code class="fe ln lo lp lq b"><em class="iq">tsc</em></code>会通知您哪些文件没有被指定</p><p id="815c" class="kr ks of kt b ku kv jr kw kx ky ju kz og lb lc ld oh lf lg lh oi lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b"><em class="iq">declaration</em></code>必须打开</p></blockquote><p id="6e78" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用方法见上面的<code class="fe ln lo lp lq b">reference</code>选项。</p><h2 id="c03f" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">tsBuildInfoFile</h2><p id="e9ae" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">您可以指定用于存储增量编译信息的文件的路径，在该路径中，TypeScript可以跟踪它存储在dist上的文件，以指示项目的生成状态。</p><p id="8f17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="f033" class="nl ls iq lq b gy nm nn l no np">├── hello.ts<br/>└── tsconfig.json</span></pre><p id="b1e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">increment</code>为真时，默认情况下它们与发出的JavaScript在同一个文件夹中。</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="74aa" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"incremental": true</strong><br/>  }<br/>}</span></pre><p id="732d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行之后，输出将是:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="72ac" class="nl ls iq lq b gy nm nn l no np">├── hello.js<br/>├── hello.ts<br/>├── tsconfig.json<br/>└── <strong class="lq ir">tsconfig.tsbuildinfo</strong></span></pre><p id="4fd4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">指定<code class="fe ln lo lp lq b">tsBuildInfoFile</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="a196" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "incremental": true,<br/>    <strong class="lq ir">"tsBuildInfoFile": "./store/tsBuildInfoFile"</strong><br/>  }<br/>}</span></pre><p id="e35a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出将是:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="16f6" class="nl ls iq lq b gy nm nn l no np">├── hello.js<br/>├── hello.ts<br/><strong class="lq ir">├── store<br/>│   └── tsBuildInfoFile</strong><br/>├── tsconfig.json</span></pre><h2 id="99dc" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">删除评论</h2><p id="a5ae" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">编译时可以从TypeScript文件中去掉所有注释。</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="ce99" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "removeComments": true<br/>  }<br/>}</span></pre><h2 id="7114" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">诺埃米特</h2><p id="a87e" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">noEmit</code>为<code class="fe ln lo lp lq b">true</code>时，TypeScript不会发出输出。当您希望TypeScript只进行类型检查而不进行编译时，可以使用它。通常<code class="fe ln lo lp lq b">Babel</code>或<code class="fe ln lo lp lq b">swc</code>可以处理打字稿文件的转换。</p><p id="91d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="9c05" class="nl ls iq lq b gy nm nn l no np">├── hello.ts<br/>└── tsconfig.json</span></pre><p id="bdd9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当设置<code class="fe ln lo lp lq b">noEmit</code>为真时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="a2a9" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "outDir": "./dist",<br/>    <strong class="lq ir">"noEmit": true</strong><br/>  }<br/>}</span></pre><p id="90a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">构建完成后，输出将是:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="6056" class="nl ls iq lq b gy nm nn l no np">├── hello.ts<br/>└── tsconfig.json</span></pre><h2 id="6843" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">重要助手</h2><p id="84fe" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">默认情况下，如果需要，TypeScript会将助手函数插入到发出的JavaScript文件中。当<code class="fe ln lo lp lq b">importHelpers</code>为<code class="fe ln lo lp lq b">true</code>时，这些辅助函数从<code class="fe ln lo lp lq b"><a class="ae ng" href="https://github.com/microsoft/tslib" rel="noopener ugc nofollow" target="_blank">tslib</a></code>模块导入。</p><p id="09a3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="2146" class="nl ls iq lq b gy nm nn l no np">export const hello = () =&gt; new Promise(resolve =&gt; resolve('hello'))<br/>export const say = async () =&gt; await hello()</span></pre><p id="f66f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">target</code>为<code class="fe ln lo lp lq b">es2015</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="1b75" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "target": "ES2015"<br/>  }<br/>}</span></pre><p id="922b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出文件将是:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="69d8" class="nl ls iq lq b gy nm nn l no np"><strong class="lq ir">var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {<br/>    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }<br/>    return new (P || (P = Promise))(function (resolve, reject) {<br/>        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }<br/>        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }<br/>        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }<br/>        step((generator = generator.apply(thisArg, _arguments || [])).next());<br/>    });<br/>};</strong></span><span id="83dd" class="nl ls iq lq b gy nq nn l no np">export const hello = () =&gt; new Promise(resolve =&gt; resolve('hello'));<br/>export const say = () =&gt; __awaiter(void 0, void 0, void 0, function* () { return yield hello(); });</span></pre><p id="2f15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如你所见，<code class="fe ln lo lp lq b">var __awaiter = ...</code>是一个插入的辅助函数。</p><p id="8b06" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">importHelpers</code>为<code class="fe ln lo lp lq b">true</code>且<code class="fe ln lo lp lq b">moduleResolution</code> <strong class="kt ir"> </strong>设定为<code class="fe ln lo lp lq b">node</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="bd13" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "target": "ES2015",<br/>    <strong class="lq ir">"moduleResolution": "node",</strong><br/>    <strong class="lq ir">"importHelpers": true</strong><br/>  }<br/>}</span></pre><p id="6bd3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">运行<code class="fe ln lo lp lq b">tsc</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="f442" class="nl ls iq lq b gy nm nn l no np">This syntax requires an imported helper but module 'tslib' cannot be found.</span></pre><p id="8196" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它将尝试在发出的JavaScript中导入<code class="fe ln lo lp lq b">tslib</code>,因此您需要在项目中安装<code class="fe ln lo lp lq b">tslib</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="90d1" class="nl ls iq lq b gy nm nn l no np">npm i tslib</span></pre><p id="7d2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">构建完成后，您将看到输出:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="0e51" class="nl ls iq lq b gy nm nn l no np"><strong class="lq ir">import { __awaiter } from "tslib";</strong><br/>export const hello = () =&gt; new Promise(resolve =&gt; resolve('hello'));<br/>export const say = () =&gt; __awaiter(void 0, void 0, void 0, function* () { return yield hello(); });</span></pre><p id="330d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">tslib</code>是导入而不是插入代码，这样可以避免在很多不同的模块中重复相同的代码。</p><h2 id="b6d1" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">下行迭代</h2><p id="487e" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">downlevelIteration</code>启用时，当使用<code class="fe ln lo lp lq b">ES5</code>或<code class="fe ln lo lp lq b">ES3</code>时，TypeScript将完全支持<code class="fe ln lo lp lq b">for-of</code>、<code class="fe ln lo lp lq b">spread</code>和<code class="fe ln lo lp lq b">destructuring</code>中的可重复项。</p><p id="c8a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">瞄准<code class="fe ln lo lp lq b">ES5</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3447" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"target": "ES5",</strong><br/>    "lib": ["es2015"]<br/>  }<br/>}</span></pre><p id="b29b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您尝试遍历可迭代的数组:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="6c55" class="nl ls iq lq b gy nm nn l no np">const array = ['a', 'b', 'c']<br/>for (let value of array) {<br/>  console.log(value)<br/>}</span></pre><p id="93eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将成功编译它。</p><p id="fc61" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如果你试图使用<code class="fe ln lo lp lq b">Set</code>遍历对象:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="f340" class="nl ls iq lq b gy nm nn l no np">const map = new Set(['a', 'b', 'c'])<br/>const array = []<br/>for (let value of map) {<br/>  array.push(value)<br/>}</span></pre><p id="55f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将报告一个错误，因为除了Array或String之外，TypeScript不允许使用这些新的迭代基元(添加了ES6):</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3132" class="nl ls iq lq b gy nm nn l no np">- error TS2569: Type 'Set&lt;string&gt;' is not an array type or a string type. Use compiler option '--downlevelIteration' to allow iterating of iterators.</span></pre><p id="490e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">downlevelIteration</code>启用时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="5949" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "target": "ES5",<br/>    "lib": ["es2015"],<br/>    <strong class="lq ir">"downlevelIteration": true</strong><br/>  }<br/>}</span></pre><p id="a293" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">编译会通过的。</p><h2 id="7d94" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">孤立模块</h2><p id="832f" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当将<code class="fe ln lo lp lq b">isolatedModules</code>设置为<code class="fe ln lo lp lq b">true</code>时，如果您编写如下代码，TypeScript将会警告您:</p><ul class=""><li id="e03c" class="oj ok iq kt b ku kv kx ky la ol le om li on lm oo op oq or bi translated">再出口类型</li><li id="9896" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><code class="fe ln lo lp lq b">declare const enum</code>成员</li><li id="bad2" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated">非模块文件</li></ul><p id="62e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">再导出类型时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3a1d" class="nl ls iq lq b gy nm nn l no np">import { MyModuleType, myFunc } from './myModule';</span><span id="35c8" class="nl ls iq lq b gy nq nn l no np">myFunc();</span><span id="1f27" class="nl ls iq lq b gy nq nn l no np">export { MyModuleType, myFunc }</span></pre><p id="e2c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将报告一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="e700" class="nl ls iq lq b gy nm nn l no np">error TS1205: Cannot re-export a type when the '--isolatedModules' flag is provided.</span><span id="6bcd" class="nl ls iq lq b gy nq nn l no np">5 export { MyModuleType, myFunc }<br/>           ~~~~~~~~~~~~</span></pre><p id="3435" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript不会尝试在发出的文件中导出<code class="fe ln lo lp lq b">MyModuleType</code>，因为TypeScript知道它没有值，但对于其他transpilers(如Babel)不知道哪个是值和类型，因此如果Babel尝试导出<code class="fe ln lo lp lq b">MyModuleType</code>，将导致运行时错误。</p><p id="598a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了避免这种情况，您可以通过<code class="fe ln lo lp lq b">*</code>导出模块:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="8546" class="nl ls iq lq b gy nm nn l no np">import { myFunc } from './myModule';</span><span id="8b68" class="nl ls iq lq b gy nq nn l no np">myFunc();</span><span id="5349" class="nl ls iq lq b gy nq nn l no np">export * from "./myModule"</span></pre><p id="8d92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">declare const enum</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="c249" class="nl ls iq lq b gy nm nn l no np">declare const enum MyEnum {<br/>  <em class="of">Foo </em>= "foo",<br/>  <em class="of">Bar </em>= "bar"<br/>}</span></pre><p id="45d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当非模块文件:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3bda" class="nl ls iq lq b gy nm nn l no np">const hoge = 'hoge'</span></pre><p id="14dd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript也会报告一个错误。要解决这个问题，你需要<code class="fe ln lo lp lq b">export</code>它们来避免警告。</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="1a4d" class="nl ls iq lq b gy nm nn l no np">export const hoge = 'hoge'</span></pre><h1 id="92c0" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">严格的检查</h1><h2 id="0300" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">严格的</h2><p id="269d" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">您可以启用所有严格的类型检查选项，如下所示。</p><ul class=""><li id="ea39" class="oj ok iq kt b ku kv kx ky la ol le om li on lm oo op oq or bi translated"><code class="fe ln lo lp lq b">--noImplicitAny</code></li><li id="a9f9" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><code class="fe ln lo lp lq b">--noImplicitThis</code></li><li id="208b" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><code class="fe ln lo lp lq b">--alwaysStrict</code></li><li id="939b" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><code class="fe ln lo lp lq b">--strictBindCallApply</code></li><li id="0ed9" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><code class="fe ln lo lp lq b">--strictNullChecks</code></li><li id="d21d" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><code class="fe ln lo lp lq b">--strictFunctionTypes</code></li><li id="cf97" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated"><code class="fe ln lo lp lq b">--strictPropertyInitialization</code></li></ul><h2 id="e46e" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">无ImplicitAny</h2><p id="c8d4" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">如果启用了<code class="fe ln lo lp lq b">noImplicitAny</code>，TypeScript将在推断出任何错误时报告错误。</p><p id="4072" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="58fe" class="nl ls iq lq b gy nm nn l no np">// hello.ts</span><span id="6c18" class="nl ls iq lq b gy nq nn l no np">const hello = (name) =&gt; `Hello, ${name}`</span></pre><p id="952a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe ln lo lp lq b">noImplicitAny</code>设置为<code class="fe ln lo lp lq b">true</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="2752" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"</strong><strong class="lq ir">noImplicitAny</strong><strong class="lq ir">": true</strong><br/>  }<br/>}</span></pre><p id="0725" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将发出一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="eaf4" class="nl ls iq lq b gy nm nn l no np">error TS7006: Parameter 'name' implicitly has an 'any' type.</span><span id="2ce7" class="nl ls iq lq b gy nq nn l no np">1 const hello = (name) =&gt; `Hello, ${name}`</span></pre><p id="9074" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要避免这种情况，请显式应用类型:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="006b" class="nl ls iq lq b gy nm nn l no np">const hello = (name: <strong class="lq ir">string</strong>) =&gt; `Hello, ${name}`</span></pre><h2 id="1efd" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">strictNullChecks</h2><p id="eb9d" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">strictNullChecks</code>为<code class="fe ln lo lp lq b">true</code>时，TypeScript将检查该值是否为null和undefined，如果是这样，则在尝试使用该值之前，会引发一个错误，提示您无法保证该值存在。</p><p id="27da" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3922" class="nl ls iq lq b gy nm nn l no np">// hello.ts</span><span id="259e" class="nl ls iq lq b gy nq nn l no np">type Hello = {<br/>  greet?: () =&gt; string<br/>}</span><span id="2ecc" class="nl ls iq lq b gy nq nn l no np">const hello: Hello = {}</span><span id="8c86" class="nl ls iq lq b gy nq nn l no np">hello.greet()</span></pre><p id="44cd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe ln lo lp lq b">noImplicitAny</code>设定为<code class="fe ln lo lp lq b">true</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="ed0d" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"strictNullChecks": true</strong><br/>  }<br/>}</span></pre><p id="a3d4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将引发一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="2502" class="nl ls iq lq b gy nm nn l no np">- error TS2722: Cannot invoke an object which is possibly 'undefined'.</span><span id="6b99" class="nl ls iq lq b gy nq nn l no np">7 hello.greet()<br/>  ~~~~~~~~~~~</span></pre><p id="7546" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了避免这种情况，可以使用条件语句:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="20c0" class="nl ls iq lq b gy nm nn l no np">type Hello = {<br/>  greet?: () =&gt; string<br/>}</span><span id="3993" class="nl ls iq lq b gy nq nn l no np">const hello: Hello = {}</span><span id="ceda" class="nl ls iq lq b gy nq nn l no np">if (hello.greet) {<br/>  hello.greet()<br/>}</span></pre><p id="a495" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">或者就像这样:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="ec0c" class="nl ls iq lq b gy nm nn l no np">hello.greet &amp;&amp; hello.greet()</span></pre><h2 id="109c" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">strictFunctionTypes</h2><p id="88b7" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">strictFunctionTypes</code>启用时，TypeScript将更正确地检查函数参数。</p><p id="ccdc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="8006" class="nl ls iq lq b gy nm nn l no np">// hello.ts</span><span id="228c" class="nl ls iq lq b gy nq nn l no np">type Hello = (age: string | number) =&gt; string</span><span id="2494" class="nl ls iq lq b gy nq nn l no np">const hello: Hello = (age: string) =&gt; `Hello, my age is ${age}`</span></pre><p id="7a55" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常情况下，TypeScript会编译这段代码，但是当将<code class="fe ln lo lp lq b">noImplicitAny</code>设置为<code class="fe ln lo lp lq b">true</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="44cf" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"strictFunctionTypes": true</strong><br/>  }<br/>}</span></pre><p id="b6e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将检测不安全的赋值:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="5063" class="nl ls iq lq b gy nm nn l no np">error TS2322: Type '(age: string) =&gt; string' is not assignable to type 'Hello'.<br/>  Types of parameters 'age' and 'age' are incompatible.<br/>    Type 'string | number' is not assignable to type 'string'.<br/>      Type 'number' is not assignable to type 'string'.</span><span id="ce55" class="nl ls iq lq b gy nq nn l no np">3 const hello: Hello = (age: string) =&gt; `Hello, my age is ${age}`<br/>        ~~~~~</span></pre><h2 id="8b28" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">strictBindCallApply</h2><p id="4cec" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">strictBindCallApply</code>启用时，TypeScript将检查<code class="fe ln lo lp lq b">call</code>、<code class="fe ln lo lp lq b">bind</code>和<code class="fe ln lo lp lq b">apply</code>是否以正确的参数被调用。</p><p id="6d02" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="1115" class="nl ls iq lq b gy nm nn l no np">// hello.ts</span><span id="9a1c" class="nl ls iq lq b gy nq nn l no np">const hello = (name: string) =&gt; `Hello, my name is ${name}`</span><span id="06b4" class="nl ls iq lq b gy nq nn l no np">hello.call(undefined, 100)</span></pre><p id="0b18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe ln lo lp lq b">strictBindCallApply</code>设置为<code class="fe ln lo lp lq b">true</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="5d04" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"</strong><strong class="lq ir">strictBindCallApply</strong><strong class="lq ir">": true</strong><br/>  }<br/>}</span></pre><p id="2378" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将引发一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="7328" class="nl ls iq lq b gy nm nn l no np">- error TS2345: Argument of type '100' is not assignable to parameter of type 'string'.</span><span id="dc3a" class="nl ls iq lq b gy nq nn l no np">hello.call(undefined, 100)<br/>                      ~~~</span></pre><p id="11f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">hello</code>应该采用<code class="fe ln lo lp lq b">string</code>参数，但在这种情况下是<code class="fe ln lo lp lq b">number</code>。</p><h2 id="1ab0" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">strictPropertyInitialization</h2><p id="8633" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">strictPropertyInitialization</code>被启用时，当声明了一个类属性但没有在构造函数中设置时，TypeScript会发出一个错误。</p><p id="6a1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="5a44" class="nl ls iq lq b gy nm nn l no np">// hello.ts</span><span id="9d76" class="nl ls iq lq b gy nq nn l no np">class Hello {<br/>  name: string<br/>  age: string</span><span id="0e9d" class="nl ls iq lq b gy nq nn l no np">constructor(name: string, age: string) {<br/>    this.name = name<br/>  }<br/>}</span></pre><p id="eca1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe ln lo lp lq b">strictPropertyInitialization</code>和<code class="fe ln lo lp lq b">strictNullChecks</code>设置为<code class="fe ln lo lp lq b">true</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="0934" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/><strong class="lq ir">    "strictPropertyInitialization": true,<br/>    "strictNullChecks": true</strong><br/>  }<br/>}</span></pre><p id="8598" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将引发一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="168e" class="nl ls iq lq b gy nm nn l no np">error TS2564: Property 'age' has no initializer and is not definitely assigned in the constructor.</span><span id="b526" class="nl ls iq lq b gy nq nn l no np">age: string<br/>~~~</span></pre><p id="63db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">this.age</code>没有在构造函数中初始化，所以需要设置:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="626a" class="nl ls iq lq b gy nm nn l no np">class Hello {<br/>  name: string<br/>  age: string</span><span id="c22e" class="nl ls iq lq b gy nq nn l no np">constructor(name: string, age: string) {<br/>    this.name = name<br/><strong class="lq ir">    this.age = age</strong><br/>  }<br/>}</span></pre><h2 id="6b42" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">不影响这个</h2><p id="ecbf" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">noImplicitThis</code>启用时，当<code class="fe ln lo lp lq b">this</code>表达式带有隐含的<code class="fe ln lo lp lq b">any</code>类型时，TypeScript将引发错误。</p><p id="1a29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="9567" class="nl ls iq lq b gy nm nn l no np">// hello.ts</span><span id="632d" class="nl ls iq lq b gy nq nn l no np">const hello<strong class="lq ir"><em class="of"> </em></strong>= {<br/>  name: 'Tom',<br/>  say: function () {<br/>    return function() {<br/>      return this.name<br/>    }<br/>  }<br/>}</span></pre><p id="0bbd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe ln lo lp lq b">noImplicitThis</code>设置为<code class="fe ln lo lp lq b">true</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="f53b" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"noImplicitThis": true</strong><br/>  }<br/>}</span></pre><p id="5a6f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将引发一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="4234" class="nl ls iq lq b gy nm nn l no np">- error TS2683: 'this' implicitly has type 'any' because it does not have a type annotation.</span><span id="3f5d" class="nl ls iq lq b gy nq nn l no np">return this.name<br/>            ~~~~</span></pre><p id="0139" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建<code class="fe ln lo lp lq b">function</code>时，<code class="fe ln lo lp lq b">this</code>未定义，因此将其隐式应用于任何类型。</p><p id="4df4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要避免这种情况，您可以使用箭头函数:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="9b5c" class="nl ls iq lq b gy nm nn l no np">const hello<strong class="lq ir"><em class="of"> </em></strong>= {<br/>  name: 'Tom',<br/>  say: function () {<br/>    return <strong class="lq ir">() =&gt; {<br/>      return this.name<br/>    }</strong><br/>  }<br/>}</span></pre><p id="d6c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">创建arrow函数时，<code class="fe ln lo lp lq b">this</code>被定义为hello对象的上下文，因此不会有错误。</p><h2 id="1e2c" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">总是严格</h2><p id="6f64" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">alwaysStrict</code>被启用时，TypeScript将总是以严格模式解析，并为每个源文件发出<code class="fe ln lo lp lq b">use strict</code>。</p><h1 id="3587" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">模块分辨率</h1><h2 id="9055" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">模块化解决方案</h2><p id="0f67" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">您可以通过以下选项指定如何解析模块:</p><ul class=""><li id="44a5" class="oj ok iq kt b ku kv kx ky la ol le om li on lm oo op oq or bi translated">结节</li><li id="a179" class="oj ok iq kt b ku os kx ot la ou le ov li ow lm oo op oq or bi translated">经典(默认)</li></ul><p id="d4bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">Classic</code>出现时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="40a6" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"moduleResolution": "classic"</strong><br/>  }<br/>}</span></pre><p id="9cff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">Classic</code>时，如果你在源文件<code class="fe ln lo lp lq b">/src/myFolder/app.ts</code>中写<code class="fe ln lo lp lq b">import myModule from “./myModule”</code>，TypeScript将解析一个相对路径如下查找:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="cce6" class="nl ls iq lq b gy nm nn l no np">1. /src/<!-- -->myFolder/<!-- -->myModule.ts<br/>2. /src/<!-- -->myFolder/<!-- -->myModule.d.ts</span></pre><p id="0341" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于非相对路径，如果在源文件<code class="fe ln lo lp lq b">/src/myFolder/app.ts</code>中写入<code class="fe ln lo lp lq b">import myModule from “myModule”</code>，TypeScript将按照以下查找方式解析非相对路径:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="82e6" class="nl ls iq lq b gy nm nn l no np">1. /src/<!-- -->myFolder/<!-- -->myModule.ts<br/>2. /src/<!-- -->myFolder/<!-- -->myModule.d.ts<br/>3. /<!-- -->myFolder/<!-- -->myModule.ts<br/>4. /<!-- -->myFolder/<!-- -->myModule.d.ts<br/>5. /src/myModule.ts<br/>6. /src/myModule.d.ts<br/>7. /myModule.ts<br/>8. /myModule.d.ts</span></pre><p id="a001" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">Node</code>出现时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="cf65" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"moduleResolution": "node"</strong><br/>  }<br/>}</span></pre><p id="4ebb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">Node</code>时，如果在源文件<code class="fe ln lo lp lq b">/src/myFolder/app.ts</code>中写入<code class="fe ln lo lp lq b">import myModule from “./myModule”</code>，TypeScript将解析一个相对路径，如下查找:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="b224" class="nl ls iq lq b gy nm nn l no np">1. /src/<!-- -->myFolder/<!-- -->myModule.ts<br/>2. /src/<!-- -->myFolder/<!-- -->myModule.tsx<br/>3. /src/<!-- -->myFolder/<!-- -->myModule.d.ts<br/>4. /src/<!-- -->myFolder/<!-- -->myModule/package.json (use "types" property if provided)<br/>5. /src/<!-- -->myFolder/<!-- -->myModule/index.ts<br/>5. /src/<!-- -->myFolder/<!-- -->myModule/index.tsx<br/>5. /src/<!-- -->myFolder/<!-- -->myModule/index.d.ts</span></pre><p id="f39e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript总是寻找以扩展名、<code class="fe ln lo lp lq b">.ts</code>、<code class="fe ln lo lp lq b">.tsx</code>和<code class="fe ln lo lp lq b">.d.ts</code>开头的文件。</p><p id="944f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">Node</code>时，如果在源文件<code class="fe ln lo lp lq b">/src/myFolder/app.ts</code>中写入<code class="fe ln lo lp lq b">import myModule from “myModule”</code>，TypeScript将解析不解析相对路径，如下查找:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="d9ea" class="nl ls iq lq b gy nm nn l no np">1. /src/myFolder/node_modules/myModule.ts<br/>2. /src/myFolder/node_modules/myModule.tsx<br/>3. /src/myFolder/node_modules/myModule.d.ts<br/>4. /src/myFolder/node_modules/myModule/package.json (use "types" if provided)<br/>5. /src/myFolder/node_modules/@types/myModule.d.ts<br/>6. /src/myFolder/node_modules/myModule/index.ts<br/>7. /src/myFolder/node_modules/myModule/index.tsx<br/>8. /src/myFolder/node_modules/myModule/index.d.ts</span><span id="2540" class="nl ls iq lq b gy nq nn l no np">9.  /src/node_modules/myModule.ts<br/>10. /src/node_modules/myModule.tsx<br/>11. /src/node_modules/myModule.d.ts<br/>12. /src/node_modules/myModule/package.json (use "types" if provided)<br/>13. /src/node_modules/@types/myModule.d.ts<br/>14. /src/node_modules/myModule/index.ts<br/>15. /src/node_modules/myModule/index.tsx<br/>16. /src/node_modules/myModule/index.d.ts</span><span id="caae" class="nl ls iq lq b gy nq nn l no np">17. /node_modules/myModule.ts<br/>18. /node_modules/myModule.tsx<br/>19. /node_modules/myModule.d.ts<br/>20. /node_modules/myModule/package.json (use "types" if provided)<br/>21. /node_modules/@types/myModule.d.ts<br/>22. /node_modules/myModule/index.ts<br/>23. /node_modules/myModule/index.tsx<br/>24. /node_modules/myModule/index.d.ts</span></pre><p id="74c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:在Vue.js项目中，您可能会在您的TypeScript文件中发现那个<code class="fe ln lo lp lq b">error TS2307: Cannot find module</code>错误。这是上面的解析策略造成的。</p><p id="0a2a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果您在源文件<code class="fe ln lo lp lq b">/src/app.vue</code>中编写<code class="fe ln lo lp lq b">import Card from “./Card.vue”</code>，TypeScript将按照以下查找方式解析相对路径:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="88d3" class="nl ls iq lq b gy nm nn l no np">1. /src/Card.vue.ts<br/>2. /src/Card.vue.tsx<br/>3. /src/Card.vue.d.ts<br/>4. /src/Card/package.json (use "types" property if provided)<br/>5. /src/Card/index.vue.ts<br/>5. /src/Card/index.vue.tsx<br/>5. /src/Card/index.vue.d.ts</span></pre><p id="0e37" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后您需要在<code class="fe ln lo lp lq b">src</code>目录中创建上述文件之一，否则您将得到<code class="fe ln lo lp lq b">Cannot find module</code>错误。</p><p id="4b8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这已在Vue社区发布。</p><div class="mo mp gp gr mq mr"><a href="https://github.com/vuejs/vue/issues/5298" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">无法从一个typescript Vue组件导入到另一个typescript Vue组件问题#5298 …</h2><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">github.com</p></div></div><div class="na l"><div class="ox l nc nd ne na nf kl mr"/></div></div></a></div><p id="29ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要解决这个问题，您可以创建如下声明文件:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="15c0" class="nl ls iq lq b gy nm nn l no np">declare module "*.vue" {<br/>    import Vue from "vue";<br/>    export default Vue;<br/>}</span></pre><p id="2366" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript会将任何以<code class="fe ln lo lp lq b">.vue</code>结尾的文件解析为Vue文件。</p><p id="4205" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是如果你想为每个<code class="fe ln lo lp lq b">.vue</code>文件创建一个声明，你可以使用一些库。</p><div class="mo mp gp gr mq mr"><a href="https://github.com/ktsn/vuetype" rel="noopener  ugc nofollow" target="_blank"><div class="ms ab fo"><div class="mt ab mu cl cj mv"><h2 class="bd ir gy z fp mw fr fs mx fu fw ip bi translated">ktsn/vuetype</h2><div class="my l"><h3 class="bd b gy z fp mw fr fs mx fu fw dk translated">为生成TypeScript声明文件。vue文件您可以在执行以下命令之一后使用vuetype命令…</h3></div><div class="mz l"><p class="bd b dl z fp mw fr fs mx fu fw dk translated">github.com</p></div></div><div class="na l"><div class="oy l nc nd ne na nf kl mr"/></div></div></a></div><h2 id="6146" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">baseUrl</h2><p id="22bc" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">您可以指定一个基目录来解析非绝对模块名。</p><p id="dfa1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="a3a9" class="nl ls iq lq b gy nm nn l no np">├── shared<br/>│   └── index.ts<br/>├── src<br/>│   └── index.ts<br/>└── tsconfig.json</span></pre><p id="5d24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">src/index.ts</code>用相对路径引用<code class="fe ln lo lp lq b">shared/index.ts</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="e23f" class="nl ls iq lq b gy nm nn l no np">// <!-- -->src/index.ts</span><span id="8aa6" class="nl ls iq lq b gy nq nn l no np">import { hello } from '../shared';</span><span id="8cc3" class="nl ls iq lq b gy nq nn l no np">console.log(hello)</span></pre><p id="c978" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">baseUrl</code>指定时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="8153" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"baseUrl": "."</strong><br/>  }<br/>}</span></pre><p id="5de4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将从与<code class="fe ln lo lp lq b">tsconfig.json</code>相同的文件夹开始查找文件，因此您更改了<code class="fe ln lo lp lq b">src/index.ts</code>中的路径:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="1ad0" class="nl ls iq lq b gy nm nn l no np"><strong class="lq ir">import { hello } from 'shared';</strong> // same as "./shared"</span><span id="1255" class="nl ls iq lq b gy nq nn l no np">console.log(hello)</span></pre><h2 id="1812" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">小路</h2><p id="e389" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">您可以将导入映射到相对于<code class="fe ln lo lp lq b">baseUrl</code>的查找。</p><p id="f735" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="fbbb" class="nl ls iq lq b gy nm nn l no np">├── shared<br/>│   └── myModule<br/>│       └── index.ts<br/>├── src<br/>│   └── index.ts<br/>└── tsconfig.json</span></pre><p id="5da3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">src/index.ts</code>用相对路径引用<code class="fe ln lo lp lq b">shared/myModule/index.ts</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="7ead" class="nl ls iq lq b gy nm nn l no np">// <!-- -->src/index.ts</span><span id="c511" class="nl ls iq lq b gy nq nn l no np">import { hello } from '../shared/myModule';</span><span id="1050" class="nl ls iq lq b gy nq nn l no np">console.log(hello)</span></pre><p id="2575" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">paths</code>允许您声明TypeScript如何解析文件中的导入。</p><p id="f7c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当告诉打字稿<code class="fe ln lo lp lq b">myModule</code>为<code class="fe ln lo lp lq b">../shared/myModule</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="bfdc" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "baseUrl": ".",<br/>    "paths": {<br/>      <strong class="lq ir">"myModule": ["./shared/myModule"]</strong><br/>    }<br/>  }<br/>}</span></pre><p id="fb96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并在<code class="fe ln lo lp lq b">src/index.ts</code>中更改导入:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="edc2" class="nl ls iq lq b gy nm nn l no np">import { hello } from 'myModule';</span><span id="a092" class="nl ls iq lq b gy nq nn l no np">console.log(hello)</span></pre><p id="7839" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您想包括<code class="fe ln lo lp lq b">shared</code>中的所有填充，您可以使用<code class="fe ln lo lp lq b">*</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="753a" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "baseUrl": ".",<br/>    "paths": {<br/>      <strong class="lq ir">"shared/*": ["./shared/*"]</strong><br/>    }<br/>  }<br/>}</span></pre><p id="27e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">*</code>将任何文件映射到<code class="fe ln lo lp lq b">shared</code>下面。</p><p id="27c1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以这样在<code class="fe ln lo lp lq b">src/index.ts</code>写进口:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="2c2f" class="nl ls iq lq b gy nm nn l no np">import { hello } <strong class="lq ir">from 'shared/myModule'</strong>;</span><span id="c7b6" class="nl ls iq lq b gy nq nn l no np">console.log(hello)</span></pre><p id="aa4e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在<a class="ae ng" href="https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping" rel="noopener ugc nofollow" target="_blank">手册</a>中看到更多细节。</p><h2 id="fe40" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">根蒂尔斯</h2><p id="1543" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated"><code class="fe ln lo lp lq b">rootDirs</code>允许您将相对模块导入解析为单个根。</p><p id="d996" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="7a2e" class="nl ls iq lq b gy nm nn l no np">├── root1<br/>│   └── root1.ts<br/>├── root2<br/>│   └── root2.ts<br/>└── tsconfig.json</span></pre><p id="ca63" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常如果你想在<code class="fe ln lo lp lq b">root1/root1.ts</code>中使用<code class="fe ln lo lp lq b">root2/root2.ts</code>，你必须像这样导入它:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="5e5e" class="nl ls iq lq b gy nm nn l no np">import { root2 } from '../root2/root2'</span><span id="ec13" class="nl ls iq lq b gy nq nn l no np">console.log(root2)</span></pre><p id="f8bf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您使用<code class="fe ln lo lp lq b">rootDirs</code>时，您可以创建一个虚拟目录:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="eff7" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"rootDirs": ["./root1", "./root2"]</strong><br/>  }<br/>}</span></pre><p id="1edd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可以在<code class="fe ln lo lp lq b">root1/root1.ts</code>中更改相对路径:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3eba" class="nl ls iq lq b gy nm nn l no np">// <!-- -->root1/root1.ts</span><span id="32ec" class="nl ls iq lq b gy nq nn l no np"><strong class="lq ir">import { root2 } from './root2'</strong></span><span id="e7cc" class="nl ls iq lq b gy nq nn l no np">console.log(root2)</span></pre><p id="7448" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它的作用就好像它们被合并到一个目录中。</p><h2 id="460e" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">字根</h2><p id="b589" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当指定了<code class="fe ln lo lp lq b">typeRoots</code>时，TypeScript将只包含<code class="fe ln lo lp lq b">typeRoots</code>路径下的包。</p><p id="cdd8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">默认情况下，TypeScript在<code class="fe ln lo lp lq b">node_modules</code>中查找所有可见的<code class="fe ln lo lp lq b">@types</code>包:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3175" class="nl ls iq lq b gy nm nn l no np">./src/node_modules/@types<br/>../node_modules/@types<br/>../../node_modules/@types</span><span id="4b44" class="nl ls iq lq b gy nq nn l no np">and so on..</span></pre><p id="4640" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="0700" class="nl ls iq lq b gy nm nn l no np">├── src<br/>│   └── index.ts<br/>└── tsconfig.json</span></pre><p id="9908" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你在<code class="fe ln lo lp lq b">src/index.ts</code>中写代码，你会遇到一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="0514" class="nl ls iq lq b gy nm nn l no np">export const hello = window.hello</span><span id="3d03" class="nl ls iq lq b gy nq nn l no np">// error occured</span><span id="86fe" class="nl ls iq lq b gy nq nn l no np">Property 'hello' does not exist on type 'Window &amp; typeof globalThis'.</span><span id="af2c" class="nl ls iq lq b gy nq nn l no np">1 export const hello = window.hello<br/>                              ~~~~~</span></pre><p id="6031" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要解决这个问题，你需要添加<code class="fe ln lo lp lq b">hello</code>到窗口对象。您可以在<code class="fe ln lo lp lq b">src/myTypes/index.d.ts</code>中创建声明文件:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="470a" class="nl ls iq lq b gy nm nn l no np">// <!-- -->src/myTypes/index.d.ts</span><span id="0249" class="nl ls iq lq b gy nq nn l no np">declare global {<br/>  interface Window {<br/>    hello: string,<br/>  }<br/>}</span></pre><p id="f06f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意:如果您遇到错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="e878" class="nl ls iq lq b gy nm nn l no np">error TS2669: Augmentations for the global scope can only be directly nested in external modules or ambient module declarations.</span><span id="ea6e" class="nl ls iq lq b gy nq nn l no np">1 declare global {<br/>          ~~~~~~</span></pre><p id="b376" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">向其添加导出:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="5e51" class="nl ls iq lq b gy nm nn l no np"><strong class="lq ir">export {}</strong></span><span id="2e8e" class="nl ls iq lq b gy nq nn l no np">declare global {<br/>  interface Window {<br/>    hello: string,<br/>  }<br/>}</span></pre><p id="097a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">指定<code class="fe ln lo lp lq b">typeRoots</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="300e" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "typeRoots": [<br/>      "./node_modules/@types",<br/>      <strong class="lq ir">"./myTypes"</strong><br/>    ]<br/>  },<br/>  "include": ["src/**/*"]<br/>}</span></pre><p id="24e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不要忘记添加<code class="fe ln lo lp lq b">“./node_modules/@types”</code>，因为TypeScript将在<code class="fe ln lo lp lq b">typeRoots</code>中搜索唯一的目录。</p><h2 id="d94f" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">类型</h2><p id="8d16" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当指定了<code class="fe ln lo lp lq b">types</code>时，TypeScript将只包含<code class="fe ln lo lp lq b">types</code>中列出的包。</p><p id="1d54" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">默认情况下，TypeScript会在<code class="fe ln lo lp lq b">node_modules</code>中查找所有可见的<code class="fe ln lo lp lq b">@types</code>包:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="6886" class="nl ls iq lq b gy nm nn l no np">./src/node_modules/@types<br/>../node_modules/@types<br/>../../node_modules/@types</span><span id="6f19" class="nl ls iq lq b gy nq nn l no np">and so on..</span></pre><p id="52a7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ln lo lp lq b">types</code>中指定<code class="fe ln lo lp lq b">node</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="f28a" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "types": [<br/>      "<strong class="lq ir">node</strong>"<br/>    ]<br/>  }<br/>}</span></pre><p id="f260" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将只包含<code class="fe ln lo lp lq b">node_modules/@types</code>中的<code class="fe ln lo lp lq b">node</code>包。</p><p id="5a9c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您想像这样指定自己的声明文件:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="fd07" class="nl ls iq lq b gy nm nn l no np">├── myTypes<br/>│   └── global<br/>│       └── <strong class="lq ir">index.d.ts</strong><br/>└── tsconfig.json</span></pre><p id="0194" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe ln lo lp lq b">./myTypes/global</code>添加到<code class="fe ln lo lp lq b">types</code>列表中:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="9760" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "types": [<br/>      "node",<br/>      <strong class="lq ir">"./myTypes/global"</strong><br/>    ]<br/>  }<br/>}</span></pre><h2 id="02a8" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">allowSyntheticDefaultImports</h2><p id="3a62" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">allowSyntheticDefaultImports</code>被启用时，TypeScript将允许您在没有<code class="fe ln lo lp lq b">*</code>的情况下编写导入:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="f640" class="nl ls iq lq b gy nm nn l no np">import jquery from "jquery";</span><span id="dccb" class="nl ls iq lq b gy nq nn l no np">// instead of import * as jquery from "jquery";</span></pre><h2 id="ceac" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">esModuleInterop</h2><p id="9bee" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">esModuleInterop</code>被启用时，TypeScript将允许您像这样使用导入:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="e456" class="nl ls iq lq b gy nm nn l no np">import myModule from '../myModule'</span></pre><p id="b2e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">而不是:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="99b1" class="nl ls iq lq b gy nm nn l no np">import myModule = require('../myModule')</span></pre><p id="87c6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你试图导入<code class="fe ln lo lp lq b">CommonJS</code>模块时。</p><p id="40d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您有一个用<code class="fe ln lo lp lq b">CommonJS</code>导出的JavaScript文件:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="8436" class="nl ls iq lq b gy nm nn l no np">// src/myModule1.js</span><span id="a328" class="nl ls iq lq b gy nq nn l no np">const myModule1 = () =&gt; 'myModule1'</span><span id="fc8f" class="nl ls iq lq b gy nq nn l no np">module.exports = {<br/>  myModule1<br/>}</span></pre><p id="5270" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并使用<code class="fe ln lo lp lq b">src/index.ts</code>中的<code class="fe ln lo lp lq b">ES Module</code>将其导入:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="84df" class="nl ls iq lq b gy nm nn l no np">import myModule from '../myModule'<br/>myModule.myModule1()</span></pre><p id="9118" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将报告一个错误，因为没有可以导入的默认对象。</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="a860" class="nl ls iq lq b gy nm nn l no np">- error TS1259: Module /myModule can only be default-imported using the 'esModuleInterop' flag</span></pre><p id="d7f5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要解决这个问题，您可以像这样编写一个导入:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3c9f" class="nl ls iq lq b gy nm nn l no np"><strong class="lq ir">import myModule = require('../myModule')</strong><br/>myModule.myModule1()</span></pre><p id="40de" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是当<code class="fe ln lo lp lq b">esModuleInterop</code>被启用时，TypeScript会插入一个导入助手来解决默认的导入问题。</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="47fc" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"esModuleInterop": true</strong>,<br/>    "allowJs": true<br/>  }<br/>}</span></pre><p id="5f53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在发出的JavaScript中，有一个<code class="fe ln lo lp lq b">__importDefault</code> helper函数，它创建一个默认的导入对象。</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="9b86" class="nl ls iq lq b gy nm nn l no np">"use strict";<br/><strong class="lq ir">var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {<br/>    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };<br/>};</strong></span><span id="c465" class="nl ls iq lq b gy nq nn l no np">exports.__esModule = true;<br/>var myModule_1 = __importDefault(require("../myModule"));<br/>myModule_1["default"].myModule1();</span></pre><h2 id="943b" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">保留符号链接</h2><p id="975e" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">preserveSymlinks</code>被启用时，TypeScript将解析相对于符号链接文件位置的所有模块和包。</p><h2 id="7f9b" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">allowUmdGlobalAccess</h2><p id="4851" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当将<code class="fe ln lo lp lq b">allowUmdGlobalAccess</code>设置为<code class="fe ln lo lp lq b">true</code>时，TypeScript将允许您在没有<code class="fe ln lo lp lq b">require</code>或<code class="fe ln lo lp lq b">import</code>的情况下从模块文件内部以全局方式访问UMD导出。</p><p id="3c09" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，如果您在项目中使用<code class="fe ln lo lp lq b">Foo</code>，它作为全局变量加载:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="38b5" class="nl ls iq lq b gy nm nn l no np">export const x<strong class="lq ir"><em class="of"> </em></strong>= Foo</span></pre><p id="da69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">声明文件是这样的:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="a1bb" class="nl ls iq lq b gy nm nn l no np">declare class Thing {<br/>  foo(): number;<br/>}<br/>export = Thing;<br/>export as namespace Foo;</span></pre><p id="1388" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">export as namespace Foo;</code>表示将<code class="fe ln lo lp lq b">Thing</code>导出为<code class="fe ln lo lp lq b">Foo</code>。</p><p id="e833" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将报告一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="cd64" class="nl ls iq lq b gy nm nn l no np">error TS2686: 'Foo' refers to a UMD global, but the current file is a module. Consider adding an import instead.</span><span id="8505" class="nl ls iq lq b gy nq nn l no np">1 export const x = Foo<br/>                   ~~~</span></pre><p id="fcd5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你必须导入<code class="fe ln lo lp lq b">Foo</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="5123" class="nl ls iq lq b gy nm nn l no np"><strong class="lq ir">import Foo = require("../@types");</strong></span><span id="e0b0" class="nl ls iq lq b gy nq nn l no np">export const x = Foo</span></pre><p id="9ea7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是当设置<code class="fe ln lo lp lq b">allowUmdGlobalAccess</code>为<code class="fe ln lo lp lq b">true</code>时，不需要写导入:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="78ad" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"allowUmdGlobalAccess": true</strong><br/>  }<br/>}</span></pre><h1 id="5772" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">源地图</h1><h2 id="b788" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">sourceRoot</h2><p id="2856" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">如果您将源地图移动到某个地方，您可以告诉调试器在哪里可以找到它。</p><p id="8b6c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">指定<code class="fe ln lo lp lq b">sourceRoot</code>时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="222c" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "sourceMap": true,<br/>    <strong class="lq ir">"sourceRoot": "https://your-website.com/source/"</strong><br/>  }<br/>}</span></pre><p id="b9b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您将看到地图文件:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="647f" class="nl ls iq lq b gy nm nn l no np">{<br/>  "version":3,<br/>  "file":"index.js",<br/>  <strong class="lq ir">"sourceRoot":"https://your-website.com/source/",</strong><br/>  "sources":["index.ts"],<br/>  "names":[],<br/>  "mappings":";;AAAa,QAAA,KAAK,GAAG,OAAO,CAAA"<br/>}</span></pre><h2 id="8083" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">mapRoot</h2><p id="7e88" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">您可以指定生成的映射文件的位置，而不是相对源位置。</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="715a" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "sourceMap": true,<br/>    "mapRoot": "https://your-website.com/sourcemap/"<br/>  }<br/>}</span></pre><h2 id="ad35" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">inlineSourceMap</h2><p id="8d08" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">inlineSourceMap</code>开启时，TypeScript将在<code class="fe ln lo lp lq b">.js</code>文件中生成地图内容，而不是在<code class="fe ln lo lp lq b">.js.map</code>文件中。</p><p id="2c5d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="cbbc" class="nl ls iq lq b gy nm nn l no np">// src/index.ts</span><span id="0d92" class="nl ls iq lq b gy nq nn l no np">export const hello<strong class="lq ir"><em class="of"> </em></strong>= 'Hello'</span></pre><p id="ab6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">inlineSourceMap</code>被激活时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="59a4" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"inlineSourceMap": true</strong><br/>  }<br/>}</span></pre><p id="d2d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出文件，<code class="fe ln lo lp lq b">src/index.js</code>将包含源地图信息:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="7736" class="nl ls iq lq b gy nm nn l no np">"use strict";<br/>exports.__esModule = true;<br/>exports.hello = 'Hello';<br/><strong class="lq ir">//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFhLFFBQUEsS0FBSyxHQUFHLE9BQU8sQ0FBQSJ9</strong></span></pre><h2 id="1f21" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">内嵌资源</h2><p id="3407" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">inlineSources</code>启用时，TypeScript会将<code class="fe ln lo lp lq b">.ts</code>文件的内容包含在生成的<code class="fe ln lo lp lq b">.js</code>文件中。</p><p id="e8b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">以下是一些文件结构示例:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="c51d" class="nl ls iq lq b gy nm nn l no np">// src/index.ts</span><span id="cf29" class="nl ls iq lq b gy nq nn l no np">export const hello<strong class="lq ir"><em class="of"> </em></strong>= 'Hello' as const</span></pre><p id="d7fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">inlineSources</code>和<code class="fe ln lo lp lq b">sourceMap</code>被使能时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="472a" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "sourceMap": true,<br/>    <strong class="lq ir">"inlineSources": true</strong><br/>  }<br/>}</span></pre><p id="9bdc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出文件，<code class="fe ln lo lp lq b">src/index.js.map</code>将包含<code class="fe ln lo lp lq b">.ts</code>文件的原始内容:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="f647" class="nl ls iq lq b gy nm nn l no np">{<br/>  "version":3,"file":"index.js",<br/>  "sourceRoot":"",<br/>  "sources":["index.ts"],<br/>  "names":[],<br/>  "mappings":";;AAAa,QAAA,KAAK,GAAG,OAAgB,CAAA",<br/>  <strong class="lq ir">"sourcesContent":["export const hello = 'Hello' as const\n"]</strong><br/>}</span></pre><h1 id="c2dc" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">棉绒格子</h1><h2 id="8b88" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">noUnusedLocals</h2><p id="97ff" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">noUnusedLocals</code>被启用时，TypeScript将报告一个关于未使用的局部变量的错误。</p><p id="7378" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="868a" class="nl ls iq lq b gy nm nn l no np">// src/index.ts</span><span id="ee64" class="nl ls iq lq b gy nq nn l no np">const hello = () =&gt; {<br/>  const name = 'Tom'<br/>  return 'Hello'<br/>}</span></pre><p id="465c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">noUnusedLocals</code>启用时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="5944" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"noUnusedLocals": true</strong><br/>  }<br/>}</span></pre><p id="0636" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将引发一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="2043" class="nl ls iq lq b gy nm nn l no np">error TS6133: 'name' is declared but its value is never read.</span><span id="1175" class="nl ls iq lq b gy nq nn l no np">const name = 'Tom'<br/>      ~~~~</span></pre><h2 id="d027" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">nounused参数</h2><p id="0959" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">noUnusedParameters</code>被启用时，TypeScript将报告函数中未使用参数的错误。</p><p id="0fe4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="0036" class="nl ls iq lq b gy nm nn l no np">// src/index.ts</span><span id="4818" class="nl ls iq lq b gy nq nn l no np">const hello = (name: string) =&gt; {<br/>  return 'Hello'<br/>}</span></pre><p id="0b1e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">noUnusedParameters</code>启用时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="2eba" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"noUnusedParameters": true</strong><br/>  }<br/>}</span></pre><p id="3113" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将引发一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="4457" class="nl ls iq lq b gy nm nn l no np">error TS6133: 'name' is declared but its value is never read.</span><span id="93ce" class="nl ls iq lq b gy nq nn l no np">const hello = (name: string) =&gt; {<br/>               ~~~~</span></pre><h2 id="cfdf" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">noImplicitReturns</h2><p id="fc63" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">noImplicitReturns</code>启用时，TypeScript将检查函数是否在任何代码路径返回值。</p><p id="724e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="e5a4" class="nl ls iq lq b gy nm nn l no np">// src/index.ts</span><span id="99fa" class="nl ls iq lq b gy nq nn l no np">const hello = (name: string) =&gt; {<br/>  if (name) {<br/>    return `Hello, ${name}`<br/>  }<br/>}</span></pre><p id="48f2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">noImplicitReturns</code>启用时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="6fad" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"noImplicitReturns": true</strong><br/>  }<br/>}</span></pre><p id="291b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将引发一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3ff3" class="nl ls iq lq b gy nm nn l no np">error TS7030: Not all code paths return a value.</span><span id="a223" class="nl ls iq lq b gy nq nn l no np">const hello = (name: string) =&gt; {<br/>              ~~~~~~~~~~~~~~~~~~~</span></pre><p id="3a15" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您需要在所有代码路径中返回一些值:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="73c8" class="nl ls iq lq b gy nm nn l no np">// src/index.ts</span><span id="d1b8" class="nl ls iq lq b gy nq nn l no np">const hello = (name: string) =&gt; {<br/>  if (name) {<br/>    return `Hello, ${name}`<br/>  }<br/>  <br/>  <strong class="lq ir">return 'Hello, somebody'</strong><br/>}</span></pre><h2 id="d8d2" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">noFallthroughCasesInSwitch</h2><p id="854a" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">noFallthroughCasesInSwitch</code>被启用时，TypeScript将在switch语句中报告有关失败情况的错误。</p><p id="d83d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="32b7" class="nl ls iq lq b gy nm nn l no np">// src/index.ts</span><span id="47db" class="nl ls iq lq b gy nq nn l no np">const hello = () =&gt; {<br/>  const age: number = 10</span><span id="6f0c" class="nl ls iq lq b gy nq nn l no np">switch (age) {<br/>    case 1:<br/>      return "Hello, age 1"<br/>    case 2:<br/>      return "Hello, age 2"<br/>    case 3:<br/>      console.log('case 3')<br/>    default:<br/>      return 'Hello'<br/>  }<br/>}</span></pre><p id="f6b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">noFallthroughCasesInSwitch</code>启用时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="aa6e" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"noFallthroughCasesInSwitch": true</strong><br/>  }<br/>}</span></pre><p id="a3e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">TypeScript将引发一个错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="8218" class="nl ls iq lq b gy nm nn l no np">error TS7029: Fallthrough case in switch.</span><span id="3e7b" class="nl ls iq lq b gy nq nn l no np">case 3:<br/>~~~~~~</span></pre><p id="7209" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您需要在<code class="fe ln lo lp lq b">case 3</code>语句中写入<code class="fe ln lo lp lq b">return</code>或<code class="fe ln lo lp lq b">break</code>:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="e53e" class="nl ls iq lq b gy nm nn l no np">// src/index.ts</span><span id="bd05" class="nl ls iq lq b gy nq nn l no np">const hello = () =&gt; {<br/>  const age: number = 10</span><span id="8564" class="nl ls iq lq b gy nq nn l no np">switch (age) {<br/>    case 1:<br/>      return "Hello, age 1"<br/>    case 2:<br/>      return "Hello, age 2"<br/>    case 3:<br/>      console.log('case 3')<br/>      <strong class="lq ir">return "Hello, age 3"</strong><br/>    default:<br/>      return 'Hello'<br/>  }<br/>}</span></pre><h1 id="daf9" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">实验的</h1><h2 id="354e" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">实验解码器</h2><p id="86c1" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">experimentalDecorators</code>启用时，TypeScript将支持decorators，这是<a class="ae ng" href="https://github.com/tc39/proposal-decorators" rel="noopener ugc nofollow" target="_blank">TC39</a>第二阶段的特性。</p><p id="455b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="da76" class="nl ls iq lq b gy nm nn l no np">// src/index.ts</span><span id="afb0" class="nl ls iq lq b gy nq nn l no np">const classDecorator = (constructor: Function) =&gt; {<br/>  console.log('decorator function invoked');<br/>}<br/><br/>@classDecorator<br/>class MyClass {<br/>  method() {}<br/>}</span></pre><p id="0c4d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">experimentalDecorators</code>被禁用时，您将看到以下错误:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="f478" class="nl ls iq lq b gy nm nn l no np">- error TS1219: Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option in your 'tsconfig' or 'jsconfig' to remove this warning.</span><span id="ca4b" class="nl ls iq lq b gy nq nn l no np">6 class MyClass {<br/>        ~~~~~~~</span></pre><p id="cffb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">experimentalDecorators</code>启用且<code class="fe ln lo lp lq b">target</code>应高于<code class="fe ln lo lp lq b">ES5</code>时，编写代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="3efb" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    <strong class="lq ir">"target": "ES5",</strong><br/>    <strong class="lq ir">"experimentalDecorators": true</strong><br/>  }<br/>}</span></pre><p id="1468" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以在<a class="ae ng" href="https://codeburst.io/decorate-your-code-with-typescript-decorators-5be4a4ffecb4" rel="noopener" target="_blank">用TypeScript装饰器装饰你的代码中看到TypeScript装饰器是如何工作的。</a></p><h2 id="c263" class="nl ls iq bd lt nr ns dn lx nt nu dp mb la nv nw md le nx ny mf li nz oa mh ob bi translated">emitDecoratorMetadata</h2><p id="ca13" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">emitDecoratorMetadata</code>被启用时，TypeScript将在发出的JavaScript文件中为decorators发出元数据。元数据与模块<a class="ae ng" href="https://www.npmjs.com/package/reflect-metadata" rel="noopener ugc nofollow" target="_blank">反射-元数据</a>一起工作。</p><p id="7efe" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下面是一些示例代码:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="0c18" class="nl ls iq lq b gy nm nn l no np">// src/index.ts</span><span id="5268" class="nl ls iq lq b gy nq nn l no np">const myLogger = (target: any, propertyKey: string | symbol, descriptor: PropertyDescriptor) =&gt; {<br/>  console.log('log invoked');<br/>}<br/><br/>class MyClass {<br/>  @myLogger<br/>  method() {}<br/>}<br/><br/>new MyClass()</span></pre><p id="cd5f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当emitDecoratorMetadata被禁用时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="e521" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "target": "ES5",<br/>    "experimentalDecorators": true<br/>  }<br/>}</span></pre><p id="6828" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出将没有元数据:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="09bf" class="nl ls iq lq b gy nm nn l no np">var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) {<br/>    var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;<br/>    if (typeof Reflect === "object" &amp;&amp; typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);<br/>    else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r;<br/>    return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r;<br/>};<br/>var myLogger = function (target, propertyKey, descriptor) {<br/>    console.log('log invoked');<br/>};<br/>var MyClass = /** @class */ (function () {<br/>    function MyClass() {<br/>    }<br/>    MyClass.prototype.method = function () { };<br/>    __decorate([<br/>        myLogger<br/>    ], MyClass.prototype, "method", null);<br/>    return MyClass;<br/>}());<br/>new MyClass();</span></pre><p id="d8c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当<code class="fe ln lo lp lq b">emitDecoratorMetadata</code>被启用时:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="58e9" class="nl ls iq lq b gy nm nn l no np">{<br/>  "compilerOptions": {<br/>    "target": "ES5",<br/>    "experimentalDecorators": true,<br/>    <strong class="lq ir">"emitDecoratorMetadata": true</strong><br/>  }<br/>}</span></pre><p id="4c2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输出将包含元数据:</p><pre class="kg kh ki kj gt nh lq ni nj aw nk bi"><span id="d1c0" class="nl ls iq lq b gy nm nn l no np">var __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) {<br/>    var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;<br/>    if (typeof Reflect === "object" &amp;&amp; typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);<br/>    else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r;<br/>    return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r;<br/>};<br/><strong class="lq ir">var __metadata = (this &amp;&amp; this.__metadata) || function (k, v) {<br/>    if (typeof Reflect === "object" &amp;&amp; typeof Reflect.metadata === "function") return Reflect.metadata(k, v);<br/>};</strong><br/>var myLogger = function (target, propertyKey, descriptor) {<br/>    console.log('log invoked');<br/>};<br/>var MyClass = <em class="of">/** </em><strong class="lq ir"><em class="of">@</em></strong>class<strong class="lq ir"><em class="of"> </em></strong><em class="of">*/ </em>(function () {<br/>    function MyClass() {<br/>    }<br/>    MyClass.prototype.method = function () { };<br/>    __decorate([<br/>        myLogger,<br/><strong class="lq ir">        __metadata("design:type", Function),<br/>        __metadata("design:paramtypes", []),<br/>        __metadata("design:returntype", void 0)</strong><br/>    ], MyClass.prototype, "method", null);<br/>    return MyClass;<br/>}());<br/>new MyClass();</span></pre><h1 id="97aa" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">结论</h1><p id="d757" class="pw-post-body-paragraph kr ks iq kt b ku mj jr kw kx mk ju kz la ml lc ld le mm lg lh li mn lk ll lm ij bi translated">这仍在进行中。如果你有任何建议，请告诉我。</p></div></div>    
</body>
</html>