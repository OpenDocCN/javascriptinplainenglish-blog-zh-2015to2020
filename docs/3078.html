<html>
<head>
<title>Benchmarking JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基准测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/benchmarking-javascript-e57d34b5dcc3?source=collection_archive---------7-----------------------#2020-08-26">https://javascript.plainenglish.io/benchmarking-javascript-e57d34b5dcc3?source=collection_archive---------7-----------------------#2020-08-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0dd3f99eb992649a0b3348ac7913b62d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Z9ZlrLf7YRl_Hya0"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@cadop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mathew Schwartz</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dfa6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用JavaScript，时间分辨率的最精细粒度是毫秒。</p><p id="b059" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，了解在一行代码中花费了多少时间需要一种提供足够可测量时间的方法。</p><p id="d125" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">比如，我们计算一个<code class="fe ky kz la lb b">Math.log10()</code>运算能有多快？</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="dde4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简单地在这个操作周围放置计时器将返回0毫秒——没有可测量的时间。实际上，我要调用这个操作10万次，才能得到一个有意义的2到3毫秒的时间。</p><p id="696c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一些浏览器具有高分辨率的时间戳，如Google Chrome，其中可以报告毫秒级的分数。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="3e29" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是为了达到精度，需要累积多个样本。</p><h2 id="73c9" class="li lj in bd lk ll lm dn ln lo lp dp lq kl lr ls lt kp lu lv lw kt lx ly lz ma bi translated">设置计时器</h2><p id="917d" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">首先，我们需要构建如何测量时间。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="e847" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一个参数，<code class="fe ky kz la lb b">iterations</code>定义循环将执行多少次要测量的操作。操作时间的计算方法是用总时间除以迭代次数。</p><h2 id="2ed3" class="li lj in bd lk ll lm dn ln lo lp dp lq kl lr ls lt kp lu lv lw kt lx ly lz ma bi translated">优化执行时间</h2><p id="73de" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">接下来，我们需要调整执行时间以获得可靠的样本。在上面100k次迭代的例子中，我的测试每次总时间在2到3毫秒之间波动。这实际上是相当大的差异:</p><ul class=""><li id="1db4" class="mg mh in kc b kd ke kh ki kl mi kp mj kt mk kx ml mm mn mo bi translated">在总执行时间为2毫秒的情况下，这个函数需要0.00002毫秒(20纳秒)，每秒钟可以调用50，000，000次</li><li id="3a4c" class="mg mh in kc b kd mp kh mq kl mr kp ms kt mt kx ml mm mn mo bi translated">在总执行时间为3毫秒的情况下，这个函数需要0.00003毫秒(30纳秒)，每秒可以调用33，333，333次</li></ul><p id="2fa3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这相当于每秒钟超过1660万次运算。</p><p id="c61a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于代码的优先级，我们永远不会达到完美的运行时一致性。通过计算运行平均样本的标准偏差，可以自动调整迭代次数；然而，为了简化这个例子，我将迭代次数增加了10次，直到达到大约50毫秒的时间。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="b23e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运行以上程序现在提供了一个连续的样品组:</p><pre class="lc ld le lf gt mu lb mv mw aw mx bi"><span id="d8d3" class="li lj in lb b gy my mz l na nb">total: 60, time: 0.0000006000, op/sec: 1666666666<br/>total: 53, time: 0.0000005300, op/sec: 1886792452<br/>total: 59, time: 0.0000005900, op/sec: 1694915254<br/>total: 56, time: 0.0000005600, op/sec: 1785714285<br/>total: 52, time: 0.0000005200, op/sec: 1923076923</span></pre><p id="f5ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从上面的样本集来看，迭代1亿次平均需要56毫秒，这意味着<code class="fe ky kz la lb b">Math.log10</code>函数的时间大约是0.00000056毫秒(0.56纳秒)，每秒能够执行大约1，791，433，116次。</p><h2 id="106d" class="li lj in bd lk ll lm dn ln lo lp dp lq kl lr ls lt kp lu lv lw kt lx ly lz ma bi translated">异步执行</h2><p id="387d" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">启动应用程序后，性能可能会立即下降，或者受到垃圾收集的影响。为了获得更真实的执行样本，请避免在测试之间运行到完成。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="5dd8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们在测试之间休眠50毫秒，以提供一个短暂的冷却时间。</p><h2 id="4b8a" class="li lj in bd lk ll lm dn ln lo lp dp lq kl lr ls lt kp lu lv lw kt lx ly lz ma bi translated">测试中的覆盖率</h2><p id="628a" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">这个<code class="fe ky kz la lb b">Math.log10()</code>例子很简单，但是到目前为止，我们已经反复测试了只将<code class="fe ky kz la lb b">0</code>的一个值传递给返回<code class="fe ky kz la lb b">-Infinity</code>的函数。</p><p id="248e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一定要考虑输入参数如何改变执行时间。</p><p id="f903" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个循环中，我们可以方便地将<code class="fe ky kz la lb b">for</code>循环的索引值作为<code class="fe ky kz la lb b">Math.log10(i)</code>传递给函数。</p><h2 id="6b46" class="li lj in bd lk ll lm dn ln lo lp dp lq kl lr ls lt kp lu lv lw kt lx ly lz ma bi translated">基线时间</h2><p id="464d" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">利用循环来获得足够的可测量时间意味着计算开销在这个测试中没有考虑。不仅我们的测试函数在执行，而且<code class="fe ky kz la lb b">for</code>循环本身也在增加索引值。</p><p id="f2d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">重要的是要准确地分离出我们要计时的内容。</p><p id="ba60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们需要测量循环本身花费了多少时间，并从总时间中减去基线时间。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="434c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们的测试时间考虑了循环，只显示了花费在log函数上的时间。</p><pre class="lc ld le lf gt mu lb mv mw aw mx bi"><span id="af04" class="li lj in lb b gy my mz l na nb">total: 11, time: 0.0000001100, op/sec:  9090909090<br/>total:  6, time: 0.0000000600, op/sec: 16666666666<br/>total:  8, time: 0.0000000800, op/sec: 12500000000<br/>total:  8, time: 0.0000000800, op/sec: 12500000000</span></pre><p id="1e85" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一定要积累足够多的样本，因为当测量小段代码时，测试的执行速度可能会比基线更快。这导致了负时间:</p><pre class="lc ld le lf gt mu lb mv mw aw mx bi"><span id="bd22" class="li lj in lb b gy my mz l na nb">total: -1, time: -0.0000000100, op/sec: -100000000000</span></pre><p id="5405" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些离群值应该被扔掉。</p><h2 id="b31e" class="li lj in bd lk ll lm dn ln lo lp dp lq kl lr ls lt kp lu lv lw kt lx ly lz ma bi translated">编译器优化</h2><p id="aaf5" class="pw-post-body-paragraph ka kb in kc b kd mb kf kg kh mc kj kk kl md kn ko kp me kr ks kt mf kv kw kx ig bi translated">最后，考虑编译器或JavaScript运行时本身应用的任何优化也很重要。</p><p id="f820" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">像Babel这样的代码转换器可以重写代码，或者像提升循环不变代码运动这样的优化可以自动应用。如果代码被提升到循环之外，实际上不会测试任何东西。</p></div></div>    
</body>
</html>