<html>
<head>
<title>How to implement User Authentication in Next.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Next.js中实现用户认证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-user-authentication-in-next-js-2929ea94493a?source=collection_archive---------0-----------------------#2020-09-06">https://javascript.plainenglish.io/how-to-implement-user-authentication-in-next-js-2929ea94493a?source=collection_archive---------0-----------------------#2020-09-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/01078058fbf008e47612344946d864cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ua0mkVh3JEL2-I8MJD2IRw.png"/></div></div></figure><div class=""/><div class=""><h2 id="3e5e" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated">这是在Next.js中实现用户认证的逐步指南</h2></div><p id="39f8" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">为了实现这一点，我们将使用一个名为SWR的数据获取工具。如果你不知道如何使用SWR，你可能想先看看这篇文章。</p><div class="im in gp gr io lj"><a href="https://medium.com/javascript-in-plain-english/getting-started-with-data-fetching-in-react-with-swr-bfb37ec0c65d" rel="noopener follow" target="_blank"><div class="lk ab fo"><div class="ll ab lm cl cj ln"><h2 class="bd iz gy z fp lo fr fs lp fu fw ix bi translated">与SWR互动中的数据获取入门</h2><div class="lq l"><p class="bd b dl z fp lo fr fs lp fu fw dk translated">medium.com</p></div></div><div class="lr l"><div class="ls l lt lu lv lr lw iu lj"/></div></div></a></div><p id="0c17" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在这里，我们不会花时间为我们的应用程序创建后端。我已经写了后端代码，我们将使用它，好吗？</p><p id="9b69" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">因此，让我们启动我们的终端并编写以下命令:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="e525" class="mg mh iy mc b gy mi mj l mk ml">git clone <a class="ae mm" href="https://github.com/aa1aac/next-auth.git" rel="noopener ugc nofollow" target="_blank">https://github.com/aa1aac/next-auth.git</a> </span></pre><p id="0b36" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这将克隆git repo，我在其中发布了用于我们的身份验证的后端代码。克隆了repo之后，让我们安装我们需要的包。为此，编写以下命令:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ced8" class="mg mh iy mc b gy mi mj l mk ml"> npm install </span></pre><p id="74eb" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在我们已经安装了这些包，让我们来讨论这些包的用例。我们不会讨论后端使用的包。使用上面的安装命令，我们已经为我们的前端安装了Axios、bootstrap、SWR、react-bootstrap、react、next、react-dom。我们将使用bootstrap和react-bootstrap来设计我们的应用程序。我们安装了Axios用于向后端发出请求，安装了SWR用于缓存数据。</p><p id="c2ca" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们的后端为我们提供了以下路线:</p><ul class=""><li id="f4e9" class="mn mo iy kp b kq kr kt ku kw mp la mq le mr li ms mt mu mv bi translated"><em class="mw">/API/auth/登录</em></li><li id="6c6e" class="mn mo iy kp b kq mx kt my kw mz la na le nb li ms mt mu mv bi translated"><em class="mw">/API/auth/注册</em></li><li id="b616" class="mn mo iy kp b kq mx kt my kw mz la na le nb li ms mt mu mv bi translated"><em class="mw"> /api/auth/me </em></li><li id="cb14" class="mn mo iy kp b kq mx kt my kw mz la na le nb li ms mt mu mv bi translated"><em class="mw">/API/auth/注销</em></li></ul><p id="4db7" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我认为，这些路线的目的是自我描述的。</p><p id="d7bf" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">接下来，让我们在主项目目录中创建一个名为<em class="mw"> pages </em>的目录。这应该使我们的文件夹结构看起来像这样:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/1b7526e9fa74e75d7da84a3fe66bf04a.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*4_Xjoh2okhVLhGV9D3ZsqA.png"/></div></figure><p id="ef65" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在让我们在<em class="mw">页面</em>目录中创建名为<strong class="kp iz"> _app.js </strong>、<strong class="kp iz"> index.js </strong>、<strong class="kp iz"> login.js </strong>的文件。这应该使我们的文件夹结构看起来像这样:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/5c6552691b7e3cf582fc213e196db0f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:484/format:webp/1*VreyG_f9cDr6u1k1EXEAnA.png"/></div></figure><p id="948c" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">让我们现在开始工作在<em class="mw">页</em>目录。在此之前，我们需要向我们的<em class="mw"> config </em>目录添加一些东西。让我们在<em class="mw"> config </em>目录下创建一个名为<strong class="kp iz"> dev.js </strong>的文件，并在文件中写入以下代码行:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="34b7" class="mg mh iy mc b gy mi mj l mk ml">module.exports = {<br/>    MONGO_URI: "",      // MongoDB's URI goes here<br/>    SECRET: "",         // SECRET key goes here<br/>};</span></pre><p id="cbc6" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">正如上面评论中提到的，你需要写<code class="fe ne nf ng mc b">MONGO_URI</code>和<code class="fe ne nf ng mc b">SECRET</code>。<code class="fe ne nf ng mc b">MONGO_URI</code>必须包含MongoDB数据库的URL，而<code class="fe ne nf ng mc b">SECRET</code>应该包含一个秘密字符串。秘密字符串可以是任何随机字符串。</p><p id="e99e" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在，让我们在<em class="mw">页面</em>目录中打开文件<strong class="kp iz"> _app.js </strong>，并添加以下代码行:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a0e4" class="mg mh iy mc b gy mi mj l mk ml">import "bootstrap/dist/css/bootstrap.min.css";<br/></span><span id="c0a7" class="mg mh iy mc b gy nh mj l mk ml">export default function App({ Component, pageProps }) {</span><span id="a81c" class="mg mh iy mc b gy nh mj l mk ml">     return &lt;Component {...pageProps} /&gt;;</span><span id="d049" class="mg mh iy mc b gy nh mj l mk ml">}</span></pre><p id="b9c4" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">您可以看到，我们已经在第一行导入了引导程序的CSS文件。然后，我们导出了<code class="fe ne nf ng mc b">App</code>函数。</p><p id="3315" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">到目前为止，我们已经处理了<strong class="kp iz"> _app.js </strong>文件，现在让我们处理文件<strong class="kp iz"> index.js </strong>。让我们打开文件并编写以下代码行:</p><figure class="lx ly lz ma gt ip"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="2ef9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">让我们仔细看看上面的代码。前几行是导入。在第1行，我们导入了<code class="fe ne nf ng mc b">Layout</code>；在第3行，我们导入了<code class="fe ne nf ng mc b">useUser</code>。</p><p id="5e90" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第5行，我们定义了一个箭头函数<code class="fe ne nf ng mc b">IndexPage</code>，并在第28行将其导出。</p><p id="02aa" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第6行，我们使用了<code class="fe ne nf ng mc b">useUser()</code>——一会儿我们将讨论<code class="fe ne nf ng mc b">useUser()</code>。现在，请记住，<code class="fe ne nf ng mc b">useUser()</code>函数为我们提供了<code class="fe ne nf ng mc b">user</code>、<code class="fe ne nf ng mc b">loading</code>、<code class="fe ne nf ng mc b">loggedIn</code>、<code class="fe ne nf ng mc b">mutate</code>。注意，在我们的例子中，我们使用了对象析构来从<code class="fe ne nf ng mc b">useUser()</code>接收<code class="fe ne nf ng mc b">user</code>、<code class="fe ne nf ng mc b">loading</code>和<code class="fe ne nf ng mc b">loggedIn</code>。<code class="fe ne nf ng mc b">loading</code>提供一个布尔值，表示数据是否正在加载。<code class="fe ne nf ng mc b">loggedIn</code>提供布尔值，表示用户是否登录。<code class="fe ne nf ng mc b">user</code>包含关于用户的信息，如果存在的话。<code class="fe ne nf ng mc b">mutate</code>是一个帮助重新运行请求的函数，这样缓存的信息就会发生变化。换句话说，<code class="fe ne nf ng mc b">mutate</code>重新验证数据。</p><p id="75ce" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">从第21行到第25行，我们返回了将它包装在<code class="fe ne nf ng mc b">Layout</code>中的<code class="fe ne nf ng mc b">DisplayInfo</code>组件。注意，我们已经将<code class="fe ne nf ng mc b">title</code>道具传递给了<code class="fe ne nf ng mc b">Layout</code>组件。这个<code class="fe ne nf ng mc b">title</code>道具设置页面的标题；在我们的例子中，我们将它设置为“index”。</p><p id="3ee4" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在让我们看看第8行的组件<code class="fe ne nf ng mc b">DisplayInfo</code>。在第9行，我们检查数据是否正在加载。如果数据正在加载，我们向用户呈现“正在加载…”。然后，在第10行，我们检查用户是否登录并且<code class="fe ne nf ng mc b">user._id</code>是否存在。如果两者都存在，我们从第12行到第16行呈现用户的id和电子邮件地址。</p><p id="4073" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第19行，我们返回了一条消息，用户应该登录来获取信息。记住，这个get只有在用户没有登录的时候才会被渲染。</p><p id="0601" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在让我们来处理<strong class="kp iz"> login.js </strong>文件。打开文件并编写以下代码行:</p><figure class="lx ly lz ma gt ip"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ad29" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><strong class="kp iz"> login.js </strong>文件的前几行是导入。在第1行，我们从<code class="fe ne nf ng mc b">’react’</code>导入了<code class="fe ne nf ng mc b">useState</code>和<code class="fe ne nf ng mc b">useEffect</code>。第2行，导入<code class="fe ne nf ng mc b">Router</code>；在第4行，我们导入了<code class="fe ne nf ng mc b">Layout</code>组件。在第6行，我们导入了<code class="fe ne nf ng mc b">login</code>函数，它将帮助我们发出登录请求。在第7行，我们导入了<code class="fe ne nf ng mc b">useUser</code>函数。</p><p id="490d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第9行，我们创建了一个名为<code class="fe ne nf ng mc b">Login</code>的箭头函数。我们已经在第66行导出了这个函数。在函数内部，我们在<code class="fe ne nf ng mc b">useState()</code>的帮助下初始化了<code class="fe ne nf ng mc b">email</code>和<code class="fe ne nf ng mc b">password</code>状态，并将它们的默认值设置为一个空字符串(第10行和第11行)。</p><p id="47e4" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第13行，我们使用object destructure从<code class="fe ne nf ng mc b">useUser()</code>接收<code class="fe ne nf ng mc b">mutate</code>和<code class="fe ne nf ng mc b">loggedIn</code>。</p><p id="13e5" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">从第15行到第17行，我们使用了<code class="fe ne nf ng mc b">useEffect</code>。我们检查了用户是否在<code class="fe ne nf ng mc b">useEffect</code>中登录。如果用户登录，我们将用户重定向到索引页面，在第16行。</p><p id="e9ea" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第19行，我们再次检查用户是否登录。如果用户登录，我们将重定向消息返回给用户。这样，我们可以防止登录用户访问登录页面。</p><p id="766c" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">从第29行到第63行，我们呈现了一个登录表单。我们将表单包装在<code class="fe ne nf ng mc b">Layout</code>组件中。在<code class="fe ne nf ng mc b">Layout</code>标题属性的帮助下，我们将页面的标题设置为“登录”。从第34行到第60行，我们看到了登录表单。我们已经从第35行到第45行为<code class="fe ne nf ng mc b">email</code>字段设置了输入和标签。从第46行到第55行，我们已经为<code class="fe ne nf ng mc b">email</code>设置了输入和标签。</p><p id="05d5" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">然后，从第57行到第59行，我们创建了提交按钮。注意，我们已经在第34行为表单设置了<code class="fe ne nf ng mc b">onSubmit</code>事件处理程序。当用户点击提交按钮时，函数<code class="fe ne nf ng mc b">onLoginSubmit</code>被调用。</p><p id="1239" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们来看看函数<code class="fe ne nf ng mc b">onLoginSubmit</code>(从第21行到第27行)。这个函数接受<code class="fe ne nf ng mc b">e</code>(事件)作为第一个参数。我们已经运行了代码来阻止默认事件在第22行执行。然后，我们在第23行检查<code class="fe ne nf ng mc b">email</code>和<code class="fe ne nf ng mc b">password</code>是否存在。如果<code class="fe ne nf ng mc b">email</code>和<code class="fe ne nf ng mc b">password</code>存在，我们运行第24行的<code class="fe ne nf ng mc b">login</code>函数。登录函数向后端发出请求，让用户登录。然后，在第25行，我们运行<code class="fe ne nf ng mc b">mutate()</code>。这个<code class="fe ne nf ng mc b">mutate</code>重新验证用户数据。</p><p id="dafc" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">到目前为止，我们已经处理了我们的<em class="mw">页面</em>，现在让我们处理组件。为此，让我们在主项目目录中创建一个名为<em class="mw">组件</em>的目录。在目录内部，创建名为<strong class="kp iz"> Layout.js </strong>和<strong class="kp iz"> Navbar.js </strong>的文件。这应该使我们的文件夹结构看起来像这样:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/5cee69a8b4d2b8fce66efa8736269a08.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/1*2yKQempdvNoKoVP1ASJLiQ.png"/></div></figure><p id="4157" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在让我们打开文件<strong class="kp iz"> Layout.js </strong>并编写以下代码行:</p><figure class="lx ly lz ma gt ip"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="7bde" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">前几行是文件中的导入内容。第1行，我们导入了<code class="fe ne nf ng mc b">Head</code>；在第3行，我们导入了<code class="fe ne nf ng mc b">Nav</code>。</p><p id="629d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第5行，我们创建了一个名为<code class="fe ne nf ng mc b">Layout</code>的箭头函数。然后，我们使用对象析构来接收<code class="fe ne nf ng mc b">title</code>和<code class="fe ne nf ng mc b">children</code>道具。</p><p id="6107" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第9行，我们在<code class="fe ne nf ng mc b">Head</code>中使用<code class="fe ne nf ng mc b">title</code>属性定义了页面的标题。</p><p id="495d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">然后在第14行，我们使用<code class="fe ne nf ng mc b">children</code>道具渲染子组件。</p><p id="79c8" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在我们已经处理了我们的<strong class="kp iz"> Layout.js </strong>文件，让我们现在处理<strong class="kp iz"> Navbar.js </strong>文件。打开文件并编写以下代码行:</p><figure class="lx ly lz ma gt ip"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="0f6f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">让我们仔细看看这个文件。在第1行，我们导入了<code class="fe ne nf ng mc b">Link</code>；在第2行，我们从<code class="fe ne nf ng mc b">’react-bootstrap’</code>导入了<code class="fe ne nf ng mc b">Navbar</code>。在第4行，我们导入了<code class="fe ne nf ng mc b">useUser</code>。然后在第5行，我们导入了<code class="fe ne nf ng mc b">logout</code>。</p><p id="39a5" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第7行，我们创建了一个名为<code class="fe ne nf ng mc b">Nav</code>的箭头函数，并在第53行将其导出。</p><p id="0d84" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第8行，我们收到了来自<code class="fe ne nf ng mc b">useUser()</code>的<code class="fe ne nf ng mc b">loading</code>、<code class="fe ne nf ng mc b">loggedIn</code>、<code class="fe ne nf ng mc b">user</code>和<code class="fe ne nf ng mc b">mutate</code>。</p><p id="455e" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">从第39行到第50行，我们呈现了导航栏。从第41行到第43行，我们提供了“navbar-brand”的链接。然后，在第47行，我们渲染了<code class="fe ne nf ng mc b">LoginOrInfo</code>组件。根据登录状态,<code class="fe ne nf ng mc b">LoginOrInfo</code>组件将显示一个登录按钮或一个带有用户信息的注销按钮。</p><p id="e9d3" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">让我们仔细看看第10行的<code class="fe ne nf ng mc b">LoginOrInfo</code>组件。在第11行，我们检查数据是否被加载。如果数据正在加载，我们返回null。如果用户登录，我们在第15行返回用户名。然后，我们从第16行到第25行呈现一个注销按钮。我们在注销按钮的第18行添加了<code class="fe ne nf ng mc b">onClick</code>事件监听器。当用户点击按钮时，我们运行<code class="fe ne nf ng mc b">logout</code>功能，在第19行。这个<code class="fe ne nf ng mc b">logout</code>函数向后端发送请求，让用户注销。然后，我们在第20行运行<code class="fe ne nf ng mc b">mutate()</code>来改变用户的数据。如果用户没有登录，我们会呈现一个登录链接，从第29行到第37行。该登录链接仅在用户未登录时呈现。</p><p id="c290" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">至此，我们已经完成了<code class="fe ne nf ng mc b">Navb</code>的工作。让我们开始研究<code class="fe ne nf ng mc b">useUser</code>函数。为此，让我们在主项目目录中创建一个名为<em class="mw"> data </em>的目录。在<em class="mw">数据</em>目录中，创建一个名为<strong class="kp iz"> useUser.js </strong>的文件。这应该使我们的文件夹结构看起来像这样:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/94f40f73983f0c962e8ce0ba3f24c4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*YvYo5kJW86nLaTNhG32_jA.png"/></div></figure><p id="9647" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">之后，让我们在<strong class="kp iz"> useUser.js </strong>文件中编写以下代码行:</p><figure class="lx ly lz ma gt ip"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="11e9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第1行，我们导入了<code class="fe ne nf ng mc b">useSWR</code>。然后，在第3行，我们导入了<code class="fe ne nf ng mc b">getUser</code>函数。</p><p id="27e6" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第5行，我们创建了<code class="fe ne nf ng mc b">useUser</code>函数并将其导出。在第6行，我们使用了<code class="fe ne nf ng mc b">useSWR</code>。<code class="fe ne nf ng mc b">useSWR</code>接受两个参数。第一个参数应该是唯一的，因为SWR使用它作为特定数据的标识符。记住第一个参数不一定是URL。因此，在我们的例子中，我们提供第一个参数为<code class="fe ne nf ng mc b">”api_user”</code>。然后，我们提供fetcher函数作为第二个参数。在我们的例子中，获取函数是<code class="fe ne nf ng mc b">getUser</code>。</p><p id="640d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们使用对象析构在第6行从<code class="fe ne nf ng mc b">useSWR</code>接收<code class="fe ne nf ng mc b">data</code>、<code class="fe ne nf ng mc b">mutate</code>和<code class="fe ne nf ng mc b">error</code>。<code class="fe ne nf ng mc b">data</code>包含从请求中收到的数据。<code class="fe ne nf ng mc b">error</code>包含发出请求时收到的任何错误。我们有另一个函数叫做<code class="fe ne nf ng mc b">mutate</code>。如您所知，这个<code class="fe ne nf ng mc b">mutate</code>函数帮助我们重新验证数据。</p><p id="1585" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第8行，我们创建了一个布尔值<code class="fe ne nf ng mc b">loading</code>。在第9行，我们为<code class="fe ne nf ng mc b">loggedIn</code>创建了一个布尔值。最后，我们从第11行到第16行返回了<code class="fe ne nf ng mc b">loading</code>、<code class="fe ne nf ng mc b">loggedIn</code>、<code class="fe ne nf ng mc b">mutate</code>和<code class="fe ne nf ng mc b">user</code>。</p><p id="f892" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">既然我们已经处理了我们的<strong class="kp iz"> useUser.js </strong>文件，现在让我们在我们的主项目目录中创建一个名为<em class="mw"> requests </em>的目录。之后，让我们在<em class="mw">请求</em>目录中创建一个名为<strong class="kp iz"> userApi.js </strong>的文件。这应该使我们的文件夹结构看起来像这样:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/c8e8447061ab09d9a5abf29a6fc5a8c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*0lIQfO2Y9JtNwv2FraGNMA.png"/></div></figure><p id="4d20" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在让我们打开文件<strong class="kp iz"> userApi.js </strong>并编写以下代码行:</p><figure class="lx ly lz ma gt ip"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c23e" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第1行，我们导入了axios。</p><p id="9f82" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第3行，我们创建了一个名为<code class="fe ne nf ng mc b">login</code>的箭头函数并将其导出。<code class="fe ne nf ng mc b">login</code>函数接受一个带有<code class="fe ne nf ng mc b">email</code>和<code class="fe ne nf ng mc b">password</code>的对象。在第5行，我们向路由<em class="mw"> /api/auth/login </em>发出post请求，字段为<code class="fe ne nf ng mc b">email</code>和<code class="fe ne nf ng mc b">password</code>。在第9行，我们记录了数据。如果在这个过程中发生了任何错误，我们记录这个错误(在第11行)。</p><p id="7250" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第15行，我们创建并导出了一个名为<code class="fe ne nf ng mc b">getUser</code>的箭头函数。这个函数的目的是获取用户信息。在第17行，我们向路由<em class="mw"> /api/auth/me </em>发出了一个get请求。如果用户已登录，此路由将提供用户的数据。然后，在第19行，我们从<code class="fe ne nf ng mc b">res.data.user</code>返回用户的数据。如果在这个过程中出现任何错误，我们在第21行记录<code class="fe ne nf ng mc b">error</code>。然后，我们在第22行抛出<code class="fe ne nf ng mc b">error</code>。注意，我们没有在其他请求函数中返回任何数据，但是我们为<code class="fe ne nf ng mc b">getUser</code>函数返回了数据。这是因为我们使用了<code class="fe ne nf ng mc b">getUser</code>函数作为<strong class="kp iz"> useUser.js </strong>文件中SWR的提取函数。<code class="fe ne nf ng mc b">getUser</code>返回的数据被SWR缓存。我们应用程序中的许多组件都可以使用这些缓存数据。</p><p id="8032" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在第26行，我们已经创建并导出了<code class="fe ne nf ng mc b">logout</code>函数。该功能的目的是注销用户。在第28行，我们向路由<em class="mw"> api/auth/logout </em>发出get请求。这将注销用户。如果过程中出现任何错误，我们在第30行记录<code class="fe ne nf ng mc b">error</code>。</p><p id="8bb0" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">至此，我们已经完成了认证工作。现在让我们来试试这个。在试用这个应用程序之前，让我们先快速挑选一下我们的用户。我们本来可以花时间来创建注册页面，但是这篇博文变得很长。要注册我们的用户，打开Postman并向端点<em class="mw">localhost:5000/API/auth/sign up</em>发出POST请求。在提出请求时，我们应该提供以下字段:<code class="fe ne nf ng mc b">name</code>、<code class="fe ne nf ng mc b">email</code>、<code class="fe ne nf ng mc b">password</code>、<code class="fe ne nf ng mc b">confirmPassword</code>。你需要记住的是，<code class="fe ne nf ng mc b">name</code>字段的最小长度应该是3。<code class="fe ne nf ng mc b">password</code>字段的最小长度应为8，最大长度应为15。<code class="fe ne nf ng mc b">password</code>字段还应包括至少一个数字和一个特殊字符。</p><p id="d0bf" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">注册成功后，您可以试用该应用程序。</p><p id="1082" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">当用户没有登录时，我们的索引页面应该是这样的:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nn"><img src="../Images/a305c7eeab3dee0e7cf6536e2d9ac994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yf7ufqx-8Lnp_JWPv6mzeg.png"/></div></div></figure><p id="e1ae" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我们的登录页面应该如下所示:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nn"><img src="../Images/9aee327228c0d2229ebd6feecbb6d394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X3TXCULfuTzy3wzBujiTfw.png"/></div></div></figure><p id="4598" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">当用户登录时，我们的索引页面应该如下所示:</p><figure class="lx ly lz ma gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nn"><img src="../Images/14b37e7e80fe03211b37872aa1ec58be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LM-fuPwssKpqddgT9D_MXQ.png"/></div></div></figure><p id="5b8f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">如果您想看看最终的代码，您可以将git的分支改为final-project。为此，您可以在终端中使用以下命令:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ec5e" class="mg mh iy mc b gy mi mj l mk ml">git checkout final-project</span></pre><h2 id="b07e" class="mg mh iy bd no np nq dn nr ns nt dp nu kw nv nw nx la ny nz oa le ob oc od oe bi translated">简单英语的JavaScript</h2><p id="56f4" class="pw-post-body-paragraph kn ko iy kp b kq of jz ks kt og kc kv kw oh ky kz la oi lc ld le oj lg lh li ig bi translated">你知道我们有三份出版物和一个YouTube频道吗？在<a class="ae mm" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kp iz">寻找一切的链接plainenglish.io </strong> </a>！</p></div></div>    
</body>
</html>