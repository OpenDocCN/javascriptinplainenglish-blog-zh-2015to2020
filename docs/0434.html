<html>
<head>
<title>Jest — How to Use Extend with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jest —如何在TypeScript中使用Extend</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/jest-how-to-use-extend-with-typescript-4011582a2217?source=collection_archive---------1-----------------------#2019-10-14">https://javascript.plainenglish.io/jest-how-to-use-extend-with-typescript-4011582a2217?source=collection_archive---------1-----------------------#2019-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/55c3b66cc27f089cf48691060521709f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SruahLTSYt6Oo8MKhTMI6w.png"/></div></div></figure><p id="5f01" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Jest是目前最流行的JavaScript测试库。编写测试代码以确保稳定性和可信性变得越来越重要。</p><figure class="kx ky kz la gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi kw"><img src="../Images/2999cabbadbc0c4d9bbbec2891706379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h2gfLEgs1X7fW7_5ZJhstg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><a class="ae lf" href="https://www.npmtrends.com/jest-vs-karma-vs-mocha-vs-jasmine-core-vs-testdouble" rel="noopener ugc nofollow" target="_blank">NPM download counts of Jest with other testing libraries</a></figcaption></figure><p id="8fcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基本上，<code class="fe lg lh li lj b">jest</code>允许您测试各种条件，包括异步调用。但是如果你想根据你的条件来检查代码呢？在我的例子中，问题是“我如何确定来自服务器API调用的响应是否总是与JSON模式相同？”。任何时候都可能不同，这取决于您需要什么类型的数据，尤其是当您调用机票API或住宿搜索API时。</p><p id="4fa8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我意识到有一个很有用的特性，叫做<code class="fe lg lh li lj b">extend</code>。</p><h1 id="2629" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">设置您的项目</h1><p id="08ce" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">好了，现在言归正传！:)</p><p id="4153" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，创建包含所有相关文件的项目文件夹。</p><pre class="kx ky kz la gt mn lj mo mp aw mq bi"><span id="d01a" class="mr ll iq lj b gy ms mt l mu mv">npm init -y</span></pre><p id="7100" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装我们需要的所有软件包。</p><pre class="kx ky kz la gt mn lj mo mp aw mq bi"><span id="9da8" class="mr ll iq lj b gy ms mt l mu mv">npm i -D jest ts-jest typescript @types/jest</span><span id="6ca7" class="mr ll iq lj b gy mw mt l mu mv">// package.json<br/>"scripts": {<br/>  "test": "jest"<br/>}</span></pre><blockquote class="mx my mz"><p id="43f1" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated"><code class="fe lg lh li lj b"><a class="ae lf" href="https://www.npmjs.com/package/ts-jest" rel="noopener ugc nofollow" target="_blank"><em class="iq">ts-jest</em></a></code>是一个TypeScript预处理器，支持Jest的源代码映射，允许你使用Jest来测试用TypeScript编写的项目。</p></blockquote><p id="b5c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，制作文件夹。</p><pre class="kx ky kz la gt mn lj mo mp aw mq bi"><span id="f23b" class="mr ll iq lj b gy ms mt l mu mv">mkdir src &amp;&amp; cd src<br/>mkdir __tests__<br/>mkdir typings<br/>mkdir example</span></pre><p id="0141" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您的项目的层次结构应该如下所示。如果到目前为止您已经很好地遵循了这些步骤，那么现在您已经准备好了！</p><pre class="kx ky kz la gt mn lj mo mp aw mq bi"><span id="c8fd" class="mr ll iq lj b gy ms mt l mu mv">node_modules<br/>src<br/>|--- __tests__<br/>|--- example<br/>|--- typings<br/>package-lock.json<br/>package.json</span></pre><h1 id="2b43" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">编写配置文件</h1><p id="b9f1" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">现在，我们应该让TypeScript明白，您将在您的测试代码中使用定制的函数。为此，有一些小事要做。</p><p id="6b4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在你的根文件夹中创建<code class="fe lg lh li lj b">jest.config.js</code>和<code class="fe lg lh li lj b">tsconfig.json</code>。它将在测试运行时被<code class="fe lg lh li lj b">jest</code>和<code class="fe lg lh li lj b">typescript</code>自动抓取并使用。您可以将这些配置放入您的<code class="fe lg lh li lj b">package.json</code>中。更多信息，请点击<a class="ae lf" href="https://jestjs.io/docs/en/configuration#docsNav" rel="noopener ugc nofollow" target="_blank"> <em class="na">配置Jest </em> </a>。</p><pre class="kx ky kz la gt mn lj mo mp aw mq bi"><span id="1e15" class="mr ll iq lj b gy ms mt l mu mv">touch jest.config.js<br/>cd src &amp;&amp; touch tsconfig.json</span></pre><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="8642" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">简单测试代码</h1><p id="dfed" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">现在让我们从我们更熟悉的基本简单测试代码开始。</p><pre class="kx ky kz la gt mn lj mo mp aw mq bi"><span id="1aa5" class="mr ll iq lj b gy ms mt l mu mv">cd src &amp;&amp; cd example<br/>touch math.ts</span></pre><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="026a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并创建测试文件，我们将测试我们刚刚创建的<code class="fe lg lh li lj b">math.ts</code>文件。确保文件名中包含<code class="fe lg lh li lj b">spec</code>。</p><pre class="kx ky kz la gt mn lj mo mp aw mq bi"><span id="5997" class="mr ll iq lj b gy ms mt l mu mv">cd __tests__<br/>touch math.spec.ts</span></pre><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3fd8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lg lh li lj b">mockedAdd</code>是一个spy函数，我们可以使用它来跟踪其初始函数实现的使用情况，这就是<code class="fe lg lh li lj b">math.add</code>。关于Jest中间谍功能的更多信息，<a class="ae lf" href="https://jestjs.io/docs/en/jest-object#jestspyonobject-methodname" rel="noopener ugc nofollow" target="_blank"> <em class="na">点击此处Jest Doc </em> </a>。</p><p id="8140" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意检查<em class="na"> expect() </em>中的值有不同的方式。您可以使用spy函数和从原始实现返回的值，或者使用模拟对象，该模拟对象具有跟踪初始实现的<em class="na">调用</em>和<em class="na">结果</em>对象。</p><p id="2ba0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果您只希望测试代码在值为奇数时成功，该怎么办呢？应该这样写吗？</p><pre class="kx ky kz la gt mn lj mo mp aw mq bi"><span id="f44c" class="mr ll iq lj b gy ms mt l mu mv">if (num % 2 === 1) {<br/>  expect(num).toBe(yourOdd);<br/>} else {<br/>  expect(num).not.toBe(yourOdd);<br/>}</span></pre><p id="b0fa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不建议将<code class="fe lg lh li lj b">expect</code>放在<em class="na"> if-else </em>中，这是假设。</p><p id="4630" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，有一个对你有用的功能。</p><h1 id="d326" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">expect.extend()</h1><p id="0819" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated"><code class="fe lg lh li lj b">jest</code>允许您添加额外定制的<em class="na">匹配器</em>。为了让<code class="fe lg lh li lj b">jest</code>知道你的自定义<em class="na">匹配器</em>在哪里，以及应该如何处理它们，我们需要创建一个类型化文件。</p><p id="35de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要做一个函数来检查<em class="na"> expect() </em>中的值是否是奇数。</p><pre class="kx ky kz la gt mn lj mo mp aw mq bi"><span id="b660" class="mr ll iq lj b gy ms mt l mu mv">cd src &amp;&amp; cd typings<br/>touch index.d.ts</span></pre><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="1ebe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以目录层次应该是这样的。</p><pre class="kx ky kz la gt mn lj mo mp aw mq bi"><span id="cc23" class="mr ll iq lj b gy ms mt l mu mv">node_modules<br/>src<br/>|--- __tests__<br/>|    |<br/>|    |--- math.spec.ts<br/>|--- example<br/>|    |<br/>|    |--- math.ts<br/>|--- typings<br/>|    |<br/>|    |--- index.d.ts<br/>|<br/>|--- tsconfig.json<br/>jest.config.js<br/>package-lock.json<br/>package.json</span></pre><p id="d898" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">即使我们在<em class="na"> typings </em>文件夹中创建了类型化文件，类型化文件也不会影响您的测试代码。它只是让<code class="fe lg lh li lj b">typescript</code>知道在<code class="fe lg lh li lj b">jest</code>的<em class="na">匹配器</em>中会有一个名为<code class="fe lg lh li lj b">toBeOdd</code>的功能。</p><p id="04f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们应该把这个脚本添加到<code class="fe lg lh li lj b">math.spec.ts</code>中。</p><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3a89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们新的扩展匹配器<code class="fe lg lh li lj b">toBeOdd</code>没有参数，但是<em class="na">收到了</em>。收到的参数<em class="na"/>指的是你放入<em class="na"> expect() </em>中的值。在这种情况下，每次都是2和3。</p><p id="28c1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果要把一些参数折腾给<code class="fe lg lh li lj b">toBeOdd</code>，那么配置应该是这样的。</p><pre class="kx ky kz la gt mn lj mo mp aw mq bi"><span id="9b7b" class="mr ll iq lj b gy ms mt l mu mv">// index.d.ts<br/>declare global {<br/>  ...<br/>  interface matchers&lt;R&gt; { <br/>    toBeOdd(a: number): R;<br/>  }<br/>}</span><span id="c4eb" class="mr ll iq lj b gy mw mt l mu mv">// math.spec.ts<br/>expect.extend({<br/>  toBeOdd(received, a) {<br/>    .. do something<br/>  }<br/>});</span><span id="c4d5" class="mr ll iq lj b gy mw mt l mu mv">it('..', () =&gt; {<br/>  /* <em class="na">received will be 3, and a will be 2 </em>*/<br/>  expect(3).toBeOdd(2);<br/>})</span></pre><p id="ec7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="na">匹配器</em>、<em class="na">消息</em>和<em class="na">通过</em>返回两个值。</p><blockquote class="mx my mz"><p id="ec5e" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">消息—一个不带任何参数的函数。当测试失败时，它会显示一条消息。</p><p id="e1d1" class="jy jz na ka b kb kc kd ke kf kg kh ki nb kk kl km nc ko kp kq nd ks kt ku kv ij bi translated">pass决定何时在消息函数中显示错误消息的布尔类型值。</p></blockquote><p id="491b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果<em class="na">通过</em>为真，那么<em class="na">匹配器</em>在<code class="fe lg lh li lj b">expect(value).not.toBeOdd()</code>失败时将调用<em class="na">消息</em>功能，反之，如果<em class="na">通过</em>为假，则<code class="fe lg lh li lj b">expect(value).toBeOdd()</code>失败时将调用消息功能。</p><pre class="kx ky kz la gt mn lj mo mp aw mq bi"><span id="b64e" class="mr ll iq lj b gy ms mt l mu mv">/*<br/>* pass: false<br/>* Since 2 isn't an odd number, it fails and the error from message <br/>* function will be <br/>* expected 2 not to be an odd number<br/>*/<br/>expect(2).toBeOdd();</span><span id="8774" class="mr ll iq lj b gy mw mt l mu mv">/*<br/>* pass: true<br/>* Since 1 is an odd number, it fails and the error from message <br/>* function will be <br/>* expected 1 to be an odd number<br/>*/<br/>expect(1).not.toBeOdd();</span></pre><h1 id="17dd" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">完整测试代码</h1><pre class="kx ky kz la gt mn lj mo mp aw mq bi"><span id="dcae" class="mr ll iq lj b gy ms mt l mu mv">npm run test math</span></pre><figure class="kx ky kz la gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="520f" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">结论</h1><p id="7914" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">JavaScript测试库可以在项目发布之前确保您的代码。但是有时候，在你使用的测试库中，不会有适合你的情况的完美匹配器。所以，这个特性将使你的测试代码更加灵活。</p></div></div>    
</body>
</html>