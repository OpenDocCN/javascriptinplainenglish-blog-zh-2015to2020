<html>
<head>
<title>FizzBuzz Kata: An Exploration With Functors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">FizzBuzz Kata:对函子的探索</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/fizzbuzz-kata-an-exploration-with-functors-41d5217464fc?source=collection_archive---------7-----------------------#2020-06-27">https://javascript.plainenglish.io/fizzbuzz-kata-an-exploration-with-functors-41d5217464fc?source=collection_archive---------7-----------------------#2020-06-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="efaa" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">今天，当我们重温著名的FizzBuzz形时，我们将看到如何利用函子进行函数合成。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ea7dcf3375e2abe6d699c0ad18f163f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FsqTQjVEZgWzBHcqBpKdsw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@corey_lyfe?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Corey Agopian</a> on <a class="ae ks" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d66b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">本文是TypeScript中著名的kata上演示的函数式编程概念系列文章的一部分。没有理论，只有实践！</em></p><p id="b993" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过加强不变性和支持函数组合，函数式编程是一种强大而简单的方法，可以减少程序员的认知负荷、简化可测试性和减少错误(无共享状态)。</p><p id="9bb5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当然，有些语言比其他语言更适合函数式编程，但是在<a class="ae ks" href="https://www.arolla.fr/" rel="noopener ugc nofollow" target="_blank"> Arolla </a>我们相信，人们总是可以在他们的日常语言中使用这种编程风格的一些成分，无论是Java、C#、JavaScript还是Python。因此这个系列的名字:<strong class="kv io">休闲FP </strong>。</p><p id="cddb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以今天，当我们重温著名的FizzBuzz形时，我们将看到如何利用函子来对任何类型的对象进行函数合成。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="c5c4" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">嘶嘶作响</h1><p id="115a" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">FizzBuzz是手工艺社区中众所周知的一种形式，因为它非常适合学习<a class="ae ks" href="https://www.arolla.fr/training/tdd-test-driven-development/" rel="noopener ugc nofollow" target="_blank">测试驱动开发</a> (TDD)，因为它简单且渐进，同时允许不止一次的重构。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1113" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里的目的不是学习TDD，因此我们将直接跳到一个足够好的<em class="lp">实现。测试和源代码可以在<a class="ae ks" href="https://github.com/mathieueveillard/fizzbuzz-js" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上获得。</em></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="dc46" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在现实生活中，我会就此打住:它有效，简单，易读。</p><p id="f341" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是…我还不太满意。直觉告诉我们，实现依赖于一个<strong class="kv io">管道</strong>:</p><ul class=""><li id="4f4a" class="mw mx in kv b kw kx kz la lc my lg mz lk na lo nb nc nd ne bi translated">用空字符串初始化结果</li><li id="c7e7" class="mw mx in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">如果数字是3的倍数，则追加“Fizz”</li><li id="9f61" class="mw mx in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">如果数字是5的倍数，则附加“Buzz”</li><li id="e8b3" class="mw mx in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">最后，如果该数字不是3或5的倍数，则将其作为字符串追加</li></ul><p id="558b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不过，我在代码中看不到它:人们不能用简单的英语把它当成一个句子来读，可能是因为可变状态(<code class="fe nk nl nm nn b">let result</code>)。</p><p id="4de7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我希望我可以通过组合纯函数来构建一个管道，并用一个初始的空字符串来填充管道。也就是说，在伪代码中:</p><pre class="kd ke kf kg gt no nn np nq aw nr bi"><span id="eebe" class="ns ly in nn b gy nt nu l nv nw">"".map(appendFizzIfNIsMultipleOf3)<br/>  .map(appendBuzzIfNIsMultipleOf5)<br/>  .map(returnNOtherwise)</span></pre><p id="b7c8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不幸的是，<code class="fe nk nl nm nn b">String</code>原型没有公开一个<code class="fe nk nl nm nn b">map</code>方法。这就是函子发挥作用的地方。</p><blockquote class="nx"><p id="3649" class="ny nz in bd oa ob oc od oe of og lo dk translated">不幸的是，String原型没有公开map方法。这就是函子发挥作用的地方。</p></blockquote><h1 id="0e72" class="lx ly in bd lz ma oh mc md me oi mg mh jt oj ju mj jw ok jx ml jz ol ka mn mo bi translated">函子</h1><p id="068f" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">关于函子的精彩介绍，你可能想参考Eric Elliott的<a class="ae ks" href="https://medium.com/javascript-scene/composing-software-the-book-f31c77fc3ddc" rel="noopener">作曲软件</a>一书(<a class="ae ks" href="https://medium.com/javascript-scene/functors-categories-61e031bac53f" rel="noopener">函子&amp;类别</a>章节)。但是我建议你在看完这个用例之后再看<em class="lp">。关键的一点是<strong class="kv io">仿函数是一个可映射类型</strong>，这是一个公开<code class="fe nk nl nm nn b">map</code>方法的类型。</em></p><blockquote class="nx"><p id="ea1c" class="ny nz in bd oa ob oc od oe of og lo dk translated"><strong class="ak">函子是一种可映射类型。</strong></p></blockquote><p id="41e4" class="pw-post-body-paragraph kt ku in kv b kw om jo ky kz on jr lb lc oo le lf lg op li lj lk oq lm ln lo ig bi translated">所以基本上，我们将把空字符串包装在一个函子中，进行映射，然后解开函子，返回它携带的修改后的字符串。</p><p id="e57e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于单元测试帮助我们构建了第一个实现，我们可以安全地进行重构。所以事不宜迟，让我们直接开始吧！</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="fa97" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">哇…这么小的功能却有这么多代码！这可能是过度设计，但我们将继续下去，因为它只是为了演示的目的。</p><p id="28fc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看看这里会发生什么:</p><ul class=""><li id="aff7" class="mw mx in kv b kw kx kz la lc my lg mz lk na lo nb nc nd ne bi translated">首先我们定义函子，通过它的构造函数<code class="fe nk nl nm nn b">IdentityFunctor</code>。它封装了一个给定类型的<code class="fe nk nl nm nn b">value</code>(例如一个字符串)，并且可以映射到一个<code class="fe nk nl nm nn b">IdentityFunctor</code>，其类型由映射函数<code class="fe nk nl nm nn b">fn</code>决定。然而在这里，我们将只从一个字符串映射到另一个字符串。</li><li id="4f98" class="mw mx in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">然后我们定义纯映射函数，<code class="fe nk nl nm nn b">appendIfMultipleOf</code>和<code class="fe nk nl nm nn b">returnNOtherwise</code>，它们封装了大部分业务逻辑(有引号，但是嘿，你明白我的意思)。</li><li id="573e" class="mw mx in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated">最后，当我们可以使用这些基础时:在5行代码中，现在非常清楚，我们通过在<em class="lp">特定条件</em>下连接<em class="lp">事物</em>来构建一个空字符串，并返回结果。这几乎是简单的英语。</li></ul></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="a357" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">大局</h1><p id="5819" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">当然，这是一个人为的例子:对于这么少的附加值来说，代码太多了。但是希望您已经直观地了解了函子是什么以及何时使用它:函子允许映射不可映射的对象。</p><blockquote class="nx"><p id="caeb" class="ny nz in bd oa ob oc od oe of og lo dk translated">仿函数允许映射不可映射的对象。</p></blockquote><p id="2e92" class="pw-post-body-paragraph kt ku in kv b kw om jo ky kz on jr lb lc oo le lf lg op li lj lk oq lm ln lo ig bi translated"><code class="fe nk nl nm nn b">IdentityFunctor</code>可能是人们可以想象的最简单的函子。还有其他类型的函子，从数组开始，以及类似函子的类型(如承诺)。</p><p id="22b4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，函子主要用于处理管道中条件类型的映射，这对于不破坏管道非常方便。同样，<a class="ae ks" href="https://medium.com/javascript-scene/functors-categories-61e031bac53f" rel="noopener">埃里克·埃利奥特</a>做了很好的详细解释。</p><p id="f3a8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">欢迎评论。感谢您的阅读！</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h1 id="a923" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">资源</h1><ul class=""><li id="b95d" class="mw mx in kv b kw mp kz mq lc or lg os lk ot lo nb nc nd ne bi translated"><a class="ae ks" href="https://github.com/mathieueveillard/fizzbuzz" rel="noopener ugc nofollow" target="_blank">https://github.com/mathieueveillard/fizzbuzz</a></li><li id="9c2b" class="mw mx in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated"><a class="ae ks" href="https://medium.com/javascript-scene/composing-software-the-book-f31c77fc3ddc" rel="noopener">作曲软件:书</a>，作者埃里克·艾略特</li><li id="52f8" class="mw mx in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated"><a class="ae ks" href="https://github.com/getify/Functional-Light-JS" rel="noopener ugc nofollow" target="_blank">Kyle Simpson编写的功能轻量级JavaScript </a></li><li id="7730" class="mw mx in kv b kw nf kz ng lc nh lg ni lk nj lo nb nc nd ne bi translated"><a class="ae ks" href="https://github.com/MostlyAdequate/mostly-adequate-guide" rel="noopener ugc nofollow" target="_blank">功能编程的基本指南</a></li></ul></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><h2 id="cfed" class="ns ly in bd lz ou ov dn md ow ox dp mh lc oy oz mj lg pa pb ml lk pc pd mn pe bi translated">简单英语的JavaScript</h2><p id="578f" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">你知道我们有四份出版物和一个YouTube频道吗？在<a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">plain English . io</strong></a>和<a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">找到它们订阅我们的YouTube频道</strong> </a> <strong class="kv io">！</strong></p></div></div>    
</body>
</html>