<html>
<head>
<title>Node.js Tips — Express Requests and Responses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—快速请求和响应</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-express-requests-and-responsd-d0b934e681af?source=collection_archive---------3-----------------------#2020-07-15">https://javascript.plainenglish.io/node-js-tips-express-requests-and-responsd-d0b934e681af?source=collection_archive---------3-----------------------#2020-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/52ee52311e9438595332c93ac042edc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N7xOAo4XBP8sdVhA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nxn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nikolay Tchaouchev</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="be8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="30f3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Node或Express返回JSON</h1><p id="d6f6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过设置<code class="fe me mf mg mh b">Content-Type</code>头和<code class="fe me mf mg mh b">res.end</code>方法来呈现带有<code class="fe me mf mg mh b">http</code>包的JSON响应。</p><p id="3d46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="470b" class="mq lc iq mh b gy mr ms l mt mu">const http = require('http');</span><span id="e306" class="mq lc iq mh b gy mv ms l mt mu">const app = http.createServer((req, res) =&gt; {<br/>  res.setHeader('Content-Type', 'application/json');<br/>  res.end(JSON.stringify({<br/>    a: 1<br/>  }));<br/>});</span><span id="15f0" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000);</span></pre><p id="e4a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">createServer</code>来创建一个HTTP服务器。</p><p id="ba16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在回调中，我们将<code class="fe me mf mg mh b">Content-Type</code>响应头设置为<code class="fe me mf mg mh b">application/json</code>，以将响应数据设置为JSON。</p><p id="501c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用字符串化的JSON调用<code class="fe me mf mg mh b">res.end</code>来呈现响应。</p><p id="cd5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Express，我们只需编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="79b3" class="mq lc iq mh b gy mr ms l mt mu">res.json({<br/>  foo: "bar"<br/>});</span></pre><p id="b707" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的中间件中。</p><p id="5a90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">res.json</code>设置头并呈现JSON。</p><h1 id="d31d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过快速启用HTTPS</h1><p id="f705" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过读取证书数据来启用HTTPS和Express，并使用<code class="fe me mf mg mh b">http.createServer</code>来创建服务器。</p><p id="258b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f80c" class="mq lc iq mh b gy mr ms l mt mu">const fs = require('fs');<br/>const http = require('http');<br/>const https = require('https');<br/>const privateKey = fs.readFileSync('sslcert/server.key', 'utf8');<br/>const certificate = fs.readFileSync('sslcert/server.crt', 'utf8');<br/>const credentials = {<br/>  key: privateKey,<br/>  cert: certificate<br/>};<br/>const express = require('express');<br/>const app = express();<br/><br/>const httpServer = http.createServer(app);<br/>const httpsServer = https.createServer(credentials, app);<br/>httpServer.listen(3000);<br/>httpsServer.listen(3443);</span></pre><p id="14e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从服务器读取私钥和证书文件。</p><p id="14ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在一个对象中传递它们，这个对象被传递给<code class="fe me mf mg mh b">https.createServer</code>来创建服务器。</p><p id="0463" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">httpsServer</code>上的<code class="fe me mf mg mh b">listen</code>来创建服务器。</p><p id="36e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们仍然需要创建HTTP服务器来监听不安全的HTTP请求。</p><h1 id="031c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">修复Express中的“错误:请求实体太大”错误</h1><p id="938c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过增加允许的请求大小来修复“请求实体太大”的错误。</p><p id="1df6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5f5d" class="mq lc iq mh b gy mr ms l mt mu">const bodyParser = require('body-parser');<br/>app.use(bodyParser.json({<br/>  limit: '50mb'<br/>}));<br/>app.use(bodyParser.urlencoded({<br/>  limit: '50mb',<br/>  extended: true<br/>}));</span></pre><p id="7776" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在作为参数传入的对象中设置了<code class="fe me mf mg mh b">limit</code>,以设置请求负载的最大大小。</p><p id="04de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">'50mb'</code>是50兆。</p><h1 id="a13c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Express从节点服务器下载文件</h1><p id="ac6d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">res.download</code>向客户端发送文件下载响应。</p><p id="851f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fd4a" class="mq lc iq mh b gy mr ms l mt mu">app.get('/download', (req, res) =&gt; {<br/>  const file =  path.join(__dirname, '/upload-folder/movie.mp4');<br/>  res.download(file);<br/>});</span></pre><p id="9190" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">res.download</code>需要文件的绝对路径，所以我们需要将<code class="fe me mf mg mh b">__dirname</code>和路径的其余部分结合起来。</p><p id="8455" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">res.download</code>会自动设置<code class="fe me mf mg mh b">Content-Disposition</code>等头，并将文件发送给客户端。</p><h1 id="c3a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Express的服务器静态文件</h1><p id="2334" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">express.static</code>中间件通过Express提供静态文件。</p><p id="c9ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c859" class="mq lc iq mh b gy mr ms l mt mu">app.use(express.static(path.join(__dirname, '/public')));</span></pre><p id="764a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将我们想要用作静态文件夹的文件夹作为绝对路径。</p><p id="6f11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">express.static</code>将文件夹暴露给客户端。</p><h1 id="930f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Express应用程序中获取JSON POST数据</h1><p id="2266" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">req.body</code>属性从POST请求中获取JSON数据。</p><p id="3dae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2ea0" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express.createServer();</span><span id="5e36" class="mq lc iq mh b gy mv ms l mt mu">app.use(<!-- -->bodyParser<!-- -->.<!-- -->json<!-- -->());</span><span id="0b60" class="mq lc iq mh b gy mv ms l mt mu">app.post('/', (req, res) =&gt; {<br/>  console.log(req.body); <br/>  response.send(req.body);<br/>});</span><span id="e215" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000);</span></pre><p id="ce34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">req.body</code>拥有JSON请求有效载荷。</p><p id="fa01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行了<code class="fe me mf mg mh b">bodyParser.json()</code>中间件，那么<code class="fe me mf mg mh b">req.body</code>属性是可用的。</p><p id="553b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们是这样做的:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="888d" class="mq lc iq mh b gy mr ms l mt mu">app.use(bodyParser.json());</span></pre><h1 id="271f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Node.js Mongoose删除文档</h1><p id="d900" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过在模型类上使用<code class="fe me mf mg mh b">remove</code>方法来删除带有Mongoose的文档。</p><p id="2f89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1e54" class="mq lc iq mh b gy mr ms l mt mu">Model.remove({<br/>  _id: id<br/>}, (err) =&gt; {<br/>  if (err) {<br/>    console.log(err);<br/>  }<br/>});</span></pre><h1 id="0005" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Express获取上传的文件</h1><p id="1d6c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要使用Express获取上传的文件，我们可以使用<code class="fe me mf mg mh b">express-fileupload</code>包。</p><p id="9b1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="df0e" class="mq lc iq mh b gy mr ms l mt mu">const fileupload = require("express-fileupload");<br/>app.use(fileupload());</span><span id="c773" class="mq lc iq mh b gy mv ms l mt mu">app.post("/upload", (req, res) =&gt; {<br/>  if (!req.files) {<br/>    res.send("File not found");<br/>    return;<br/>  }<br/>  const file = req.files.photo;<br/>  res.send("File Uploaded");<br/>});</span></pre><p id="3f55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用了来自<code class="fe me mf mg mh b">express-fileupload</code>包的<code class="fe me mf mg mh b">fileupload</code>中间件。</p><p id="6f64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使用它，我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9226" class="mq lc iq mh b gy mr ms l mt mu">app.use(fileupload());</span></pre><p id="464b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们上传一个或多个文件时,<code class="fe me mf mg mh b">req.files</code>应该是可用的。</p><p id="f60c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">req.files</code>对象来获取文件。</p><p id="9d55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">photo</code>是输入文件的字段名。</p><p id="a258" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用正确的名字来代替。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/6241d04dd2819ac6c9a6a4adf841b45b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K2OAx2fvN2aKLDeb"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@viktortalashuk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Viktor Talashuk</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0c46" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="2987" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有几种方法可以将JSON响应呈现给客户端。</p><p id="11c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用一个中间件包来上传文件。</p><p id="2bde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以用<code class="fe me mf mg mh b">res.download</code>返回一个文件下载响应。</p><p id="f174" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须使用body-parser来解析JSON请求负载。</p><h2 id="6c77" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="9f3c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>