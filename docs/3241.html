<html>
<head>
<title>Understand Angular’s forRoot and forChild</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解根和孩子角度</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understand-angulars-forroot-and-forchild-f27fbc41cb7b?source=collection_archive---------1-----------------------#2020-09-13">https://javascript.plainenglish.io/understand-angulars-forroot-and-forchild-f27fbc41cb7b?source=collection_archive---------1-----------------------#2020-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/84fd9e46ed376c406830d291cdbbc2bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AjMBMcRa-LqLkmU34aG9lg.jpeg"/></div></div></figure><p id="b2b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">forRoot</code> / <code class="fe kw kx ky kz b">forChild</code>是一种我们大多数人从路由中知道的单体服务模式。路由实际上是它的主要用例，由于它在it之外并不常用，如果大多数Angular开发人员没有重新考虑它，我不会感到惊讶。然而，正如官方Angular文档所说:</p><p id="2812" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="la">“理解</em> <code class="fe kw kx ky kz b"><em class="la">forRoot()</em></code> <em class="la">如何工作以确保一个服务是单例的，将在更深的层次上通知您的开发。”</em></p><p id="f6f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以我们走吧。</p><h1 id="8628" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">供应商和注射器</h1><p id="55b6" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">Angular带有依赖注入(DI)机制。当一个组件依赖于一个服务时，您不需要手动创建服务的实例。您<em class="la">注入</em>服务，依赖注入系统负责提供实例。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="bb41" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">依赖注入并不局限于服务。你可以用它来注入(几乎)任何你喜欢的东西，例如像<code class="fe kw kx ky kz b">RouterModule</code>中的<code class="fe kw kx ky kz b">Routes</code>这样的物体。</p><p id="f938" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注入器负责创建要注入的对象，并将它们注入到请求它们的组件中。您告诉注入器<strong class="ka ir">如何通过声明<em class="la">提供者</em>来创建这些对象。例如，在提供者中，你可以告诉注入器使用一个给定值或者使用一个类来实例化。</strong></p><p id="7a9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注入的对象在一个注入器中总是单一的，但是在您的项目中可以有多个注入器。它们由Angular创建:在引导过程中创建一个<code class="fe kw kx ky kz b">root</code>注入器，为组件、管道或指令创建注入器。每个惰性加载的模块也有自己的。</p><p id="165a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能需要给定服务在不同模块或组件中的不同实例。对于其他一些应用程序来说，如果在给定时间应用程序中存在多个实例，这可能真的无关紧要，除了对性能而言。然而，对于某些服务，你需要确保它们是真正的单例，这意味着在整个应用程序中只有一个实例。</p><p id="888a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务的提供者通常是服务类本身，您通常会使用<code class="fe kw kx ky kz b">providedIn </code>快捷方式在<code class="fe kw kx ky kz b">root</code>注入器中提供服务。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="fd32" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当提供其他类型的对象时，您可能会遇到必须在模块中声明提供者的情况，例如:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="4052" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这种情况下，当处理懒惰加载的模块时，保持<code class="fe kw kx ky kz b">SOME_OBJECT</code>单例变得棘手。</p><h1 id="6e7b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">惰性加载模块</h1><p id="eaa6" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">当您在相互导入的预先加载的模块中提供值时，模块的提供者将被合并。我们可以从服务中看到这一点，因为我们可以记录实例的数量:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b3bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您在两个模块中的一个<code class="fe kw kx ky kz b">providers</code>数组中提供该服务，并在另一个模块中导入其中一个模块，那么注入器将被合并，您将仍然只有该服务的一个实例。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="2515" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您现在可以检查控制台，您会看到两次消息“有1个服务实例”。</p><p id="2f91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于延迟加载的模块，这变得更加复杂。每个延迟加载的模块都有自己的注入器。在前面的例子中，如果您延迟加载moduleA而不是简单地导入它，它的注入器将创建一个新的<code class="fe kw kx ky kz b">SingletonService</code>实例。您将在控制台中看到“有2个服务实例”。</p><h1 id="f2b8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为根/为孩子</h1><p id="0455" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">Angular支持用提供者导入模块的另一种方式。你可以传递一个实现<code class="fe kw kx ky kz b">ModuleWithProviders</code>接口的对象，而不是传递模块类引用。</p><pre class="me mf mg mh gt mk kz ml mm aw mn bi"><span id="8c5c" class="mo lc iq kz b gy mp mq l mr ms">interface ModuleWithProviders {<br/>  ngModule: Type&lt;any&gt;;<br/>  providers?: Provider[];<br/>}</span></pre><p id="6d44" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，您可以决定在<code class="fe kw kx ky kz b">AppModule</code>和子模块中使用不同的提供者来导入模块:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="a9a4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个更优雅的解决方案是在<code class="fe kw kx ky kz b">ModuleA</code>上定义静态方法:</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b33c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并在导入模块时使用这些方法。我们将它们命名为<code class="fe kw kx ky kz b">forRoot</code>和<code class="fe kw kx ky kz b">forChild</code>，但从技术上讲，我们可以自由选择任何名称。</p><figure class="me mf mg mh gt jr"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="ed00" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">按指定路线发送</h1><p id="4476" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">在路由的情况下，<code class="fe kw kx ky kz b">RouterModule</code>提供<code class="fe kw kx ky kz b">Router</code>服务。如果没有<code class="fe kw kx ky kz b">forRoot</code> / <code class="fe kw kx ky kz b">forChild</code>，每个特征模块将创建一个新的<code class="fe kw kx ky kz b">Router</code>实例，但只能有一个<code class="fe kw kx ky kz b">Router</code>。通过使用<code class="fe kw kx ky kz b">forRoot</code>方法，根应用模块得到一个<code class="fe kw kx ky kz b">Router</code>，所有的功能模块都使用<code class="fe kw kx ky kz b">forChild</code>并且不实例化另一个<code class="fe kw kx ky kz b">Router</code>。</p><p id="fcd5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为<code class="fe kw kx ky kz b">forRoot</code>和<code class="fe kw kx ky kz b">forChild</code>只是方法，所以你可以在调用它们时传递参数。对于<code class="fe kw kx ky kz b">RouterModule</code>,您传递一个附加提供者的值、路由和一些选项:</p><pre class="me mf mg mh gt mk kz ml mm aw mn bi"><span id="0fe9" class="mo lc iq kz b gy mp mq l mr ms">static forRoot(routes: Routes, config?: ExtraOptions) {<br/>  return {<br/>    ngModule: RouterModule,<br/>    providers: [<br/>     {provide: ROUTES, multi: true, useValue: routes},<br/>     ...,<br/>    ],<br/>  ...<br/>}</span><span id="11ad" class="mo lc iq kz b gy mt mq l mr ms">static forChild(routes: Routes) {<br/>  return {<br/>    ngModule: RouterModule,<br/>    providers: [<br/>     {provide: ROUTES, multi: true, useValue: routes},<br/>     ...,<br/>    ],<br/>  ...<br/>}</span></pre></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="843d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">综上所述，<code class="fe kw kx ky kz b">forRoot</code> / <code class="fe kw kx ky kz b">forChild</code>解决了一个在真正特殊的情况下可能发生的问题。</p><p id="5b69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">惰性加载的模块有自己的注入器，当试图保持一些提供的服务为单例时，这会导致问题。</p><p id="7bd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过使用<code class="fe kw kx ky kz b">ModuleWithProviders</code>接口导入模块来解决这个问题。<code class="fe kw kx ky kz b">forRoot</code> / <code class="fe kw kx ky kz b">forChild</code>只是一个方便的图案，以一种干净的方式来包装这个。从技术上来说，它不是Angular的一部分，但它是Angular团队为<code class="fe kw kx ky kz b">RouterModule</code>选择的解决方案，并且使用相同的模式解决类似的问题是一个很好的实践。</p><h2 id="895d" class="mo lc iq bd ld nb nc dn lh nd ne dp ll kj nf ng lp kn nh ni lt kr nj nk lx nl bi translated">简单英语的JavaScript</h2><p id="726d" class="pw-post-body-paragraph jy jz iq ka b kb lz kd ke kf ma kh ki kj mb kl km kn mc kp kq kr md kt ku kv ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae nm" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="ka ir">！</strong></p></div></div>    
</body>
</html>