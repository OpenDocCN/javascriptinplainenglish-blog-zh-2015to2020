<html>
<head>
<title>Building The Same Application With and Without React Hooks, Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用和不使用React挂钩构建相同的应用程序，第1部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-the-same-application-with-and-without-react-hooks-part-1-4bdcf02c9ab5?source=collection_archive---------4-----------------------#2019-12-08">https://javascript.plainenglish.io/building-the-same-application-with-and-without-react-hooks-part-1-4bdcf02c9ab5?source=collection_archive---------4-----------------------#2019-12-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/28d54d9c6074fbebe545f1118854e973.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QDdxXiX5PhYUt2P5"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4e34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">随着React钩子的发布，很多人可能会想，钩子到底有什么好处，甚至什么是钩子？</p><h1 id="63d1" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是钩子</h1><p id="3660" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">钩子是允许您从函数组件中“挂钩”React状态和生命周期方法的函数。一个“钩子”的例子是<code class="fe mb mc md me b">useState</code>。<code class="fe mb mc md me b">useState</code>是一个钩子，它允许我们在一个功能组件中利用有状态行为。我们将在下一节介绍这个内置钩子的一个使用示例。</p><h1 id="484f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么是钩子</h1><p id="8781" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">钩子允许我们把所有的组件做成功能组件。这并不意味着类组件不再工作，它们可以与函数组件和钩子共存。</p><p id="60e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为钩子允许函数组件中的有状态逻辑，所以我们不再需要跨组件管理和绑定<code class="fe mb mc md me b">this</code>的值。这不仅使组件代码更容易阅读，也更容易编写。</p><h2 id="340d" class="mf kz in bd la mg mh dn le mi mj dp li kl mk ml lm kp mm mn lq kt mo mp lu mq bi translated">让我们来看一个以基于标准类的方式编写的简单组件:</h2><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="d77d" class="mf kz in bd la mg mh dn le mi mj dp li kl mk ml lm kp mm mn lq kt mo mp lu mq bi translated">现在让我们将它与用两个简单的内置钩子编写的相同组件进行比较:</h2><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="dc21" class="mf kz in bd la mg mh dn le mi mj dp li kl mk ml lm kp mm mn lq kt mo mp lu mq bi translated">让我们比较一下</h2><p id="99a6" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">第二个组件仍然设法使用有状态逻辑，它仍然在组件挂载时获取，但是也设法不在任何地方使用单个<code class="fe mb mc md me b">this</code>。钩子的这种实现是最基本的，没有定制的钩子或reducers，但是代码已经很容易理解和编写了。</p><p id="8d2e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以更进一步，使用<code class="fe mb mc md me b">useReducer</code>将我们的有状态逻辑放在一个reducer钩子中。</p><h1 id="df08" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">用户教育</h1><p id="68f4" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们可以为我们的有状态逻辑定义一个定制的缩减器，并配置以使逻辑可重用。</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="bd8d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后我们可以使用react中的<code class="fe mb mc md me b">useReducer</code>钩子导入这个定制的reducer函数。</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="2ce0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过从我们创建的这个reducer函数中导入我们的有状态逻辑，如果需要的话，我们可以在其他组件中重用我们的逻辑。一旦我们将其他钩子如<code class="fe mb mc md me b">useContext</code>合并到我们的应用程序中，这将会派上用场。</p><h1 id="74c6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">定制挂钩</h1><p id="b763" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们可以更进一步，通过创建一个定制的钩子来使我们的代码更加可重用。我们就叫它<code class="fe mb mc md me b">useSushi</code>。</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="cd3b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在不仅重定位了我们的调度，还重定位了所有将我们的调度调用到我们的定制钩子中的有状态方法。现在，我们的slim应用程序组件看起来像:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="c571" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以从上面的片段中看到，我们的应用程序组件已经变得非常小，并且更容易阅读。在我们的代码中找不到任何<code class="fe mb mc md me b">this</code>的实例，我们的逻辑现在是可重用的。然而，仍有一些我们可以改进的地方。</p><p id="c739" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个例子中，我们仍然使用我们的分派作为我们获取的一部分。如果我们想创建一个同步获取函数，我们可以绕过这个问题。与此同时，我们仍然将有状态逻辑作为道具传递给子组件。有一个内置的钩子来帮助我们解决这个问题，叫做<code class="fe mb mc md me b">useContext</code>。</p><p id="b604" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个应用程序的这些改进将是这篇博客文章下一部分的重点，敬请关注！</p><h2 id="952b" class="mf kz in bd la mg mh dn le mi mj dp li kl mk ml lm kp mm mn lq kt mo mp lu mq bi translated">额外资源</h2><h1 id="47ca" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">额外资源</h1><ul class=""><li id="f051" class="mx my in kc b kd lw kh lx kl mz kp na kt nb kx nc nd ne nf bi translated"><a class="ae jz" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> React Docs简介钩子</a></li><li id="e380" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated"><a class="ae jz" href="https://www.youtube.com/watch?v=dpw9EHDh2bM" rel="noopener ugc nofollow" target="_blank">今明两天做出反应，90%的清洁工人用钩子做出反应</a></li><li id="b425" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated"><a class="ae jz" href="https://www.youtube.com/watch?v=zWsZcBiwgVE&amp;feature=youtu.be&amp;list=PLV5CVI1eNcJgNqzNwcs4UKrlJdhfDjshf" rel="noopener ugc nofollow" target="_blank"> Kent C. Dodds GDG盐湖DevFest 2018:为什么React Hooks </a></li></ul></div></div>    
</body>
</html>