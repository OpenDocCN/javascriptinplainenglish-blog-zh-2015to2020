<html>
<head>
<title>Understanding JavaScript Parsers in 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解2020年的JavaScript解析器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-javascript-parsers-in-2020-a2f00830d5fe?source=collection_archive---------6-----------------------#2020-01-02">https://javascript.plainenglish.io/understanding-javascript-parsers-in-2020-a2f00830d5fe?source=collection_archive---------6-----------------------#2020-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/54e82520deb3b3572499b36c9d51b807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_mNxqyKjzUd3PiRodThVw.jpeg"/></div></div></figure><p id="ed75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从理解javaScript如何在幕后解析我们的代码的核心概念开始新的一年。我认为，在编写业务逻辑时，了解javaScript如何工作是很重要的，这样可以更好地理解为什么要编写一行特定的代码，可以是实例化一个变量，也可以是调用一个函数。</p><h1 id="1c4a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">JavaScript解析器概念:</h1><p id="705c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">每当我们编写任何一段像var myName = "John "这样的javaScript代码时，它都会被转换成令牌。标记只不过是代码字符串表示，因此您的代码将被转换为“var”、“my name”“=”、“John”。因此，如果这个语法与javaScript语法相匹配，javaScript语法是javaScript引擎的一个定义范例，那么javaScript会将其编译为有效的javaScript语法。</p><p id="d110" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而如果你写整数m = 10这样的东西，最终会是' Integer '，' m '，' = '，' 10 '，那么javaScript会告诉我们语法是无效的，因为javaScript字典中不存在像' Integer '这样的定义。</p><h2 id="0b33" class="lz kx iq bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">AST(抽象语法树):</h2><p id="924e" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当我们谈论javaScript中的标记时，标记是javaScript表达式的糖语法，所以现在当我们编写javaScript表达式时，解析器开始解析语法并创建一个<strong class="ka ir"> AST，它只是一个表示源代码的数据结构。</strong></p><p id="5802" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们以我们之前定义的为例。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="e045" class="lz kx iq mq b gy mu mv l mw mx">var myName = “John”</span></pre><p id="ba42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，如果我们将这段代码粘贴到https://astexplorer.net/的浏览器<a class="ae my" href="https://astexplorer.net/" rel="noopener ugc nofollow" target="_blank">中，我们将会得到这样的结果:</a></p><figure class="ml mm mn mo gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/e4ff13aa51461f86768625d3e2f06686.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qjkixModlNzw2xuEilnTYA.png"/></div></div><figcaption class="na nb gj gh gi nc nd bd b be z dk">JSON code structure of the JS syntax</figcaption></figure><p id="6977" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们试着理解树结构，以便清楚地了解解析器如何解析javaScript语法。从上面的图中我们可以看到，解析器返回给我们一个大对象，它有类似<strong class="ka ir">‘开始’，‘结束’，‘主体’，‘源类型’的属性。<em class="ne"> Start </em> ' </strong>和'<strong class="ka ir"> <em class="ne"> End </em> ' </strong>属性什么都不是，但它表示第一个字符开始和结束的索引是语法的长度。这里从0开始，到19结束。“Body”是一个对象数组，它表示声明的类型和标识符，在本例中是“myName ”,它还告诉我们“value”中包含的值。种类是可变，可以是任何数据类型。</p><h2 id="9876" class="lz kx iq bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">JavaScript解析器的作用域:</h2><p id="0d9a" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">当JavaScript解析器开始解析时，它也会对变量进行作用域分析。至于上面的例子。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="449e" class="lz kx iq mq b gy mu mv l mw mx">let globalVariable = 10;<br/>function abc(){<br/>  let localVariable = 5;<br/>  console.log("Variable is " + localVariable);<br/>}</span></pre><p id="1198" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们运行上面的函数，解析器将确定变量“globalVariable”和“localVariable”的范围。该函数将打印5，因为变量localVariable将首先尝试找到它的声明，并且它将找到5，因为它的阻止范围。</p><p id="579a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而如果我们举下面的例子。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="0c53" class="lz kx iq mq b gy mu mv l mw mx">let globalVariable = 20;<br/>function foo(){<br/>  let localVariable = 15;<br/>  console.log("variable is " + localVariable);<br/>  console.log("variable is " + globalVariable);<br/>}<br/>console.log("variable is " + localVariable);<br/>console.log("variable is " + globalVariable);</span></pre><p id="439a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，当函数foo执行时，它将打印15，因为它将首先在链上找到它的声明，并且“globalVariable”是全局定义的，所以一旦它向上移动，它将找到它的声明。</p><p id="7810" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是console.log("变量是"+local variable)；将打印未定义的<strong class="ka ir">,因为它不会在其上下文中找到局部变量的声明。</strong></p><h2 id="b9c3" class="lz kx iq bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">优化性能的预解析技术:</h2><p id="1e08" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">JavaScript V8引擎有一种特殊类型的解析算法，称为预解析器，速度是完全解析的两倍，因为它只解析运行时或启动时需要解析的代码，并且只定义语句的范围。JavaScript解析器解析代码、构建AST、确定变量范围并发现错误。当我们在执行上下文中定义函数时，它会占用一些内存并等待函数调用。但是在某些情况下，我们会定义一些函数，我们不会立即调用它们，我们可能会在以后调用它们，但是解析它们会占用我们的内存。</p><p id="d4f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="ne">解决方案:</em></p><p id="2a3d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过调用预解析器来解决这个问题，预解析器只解析需要进入执行上下文的那部分代码，并且只定义其他代码的范围，而不解析它们。这将释放内存，因为在内存中查找作用域是一项开销很大的操作。让我们看一个例子来理解这个概念。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ba46" class="lz kx iq mq b gy mu mv l mw mx">function avenger1() {<br/>  console.log("I am avenger 1")<br/>}</span><span id="aa8d" class="lz kx iq mq b gy nf mv l mw mx">function avenger2() {<br/>  console.log("I am avenger 2")<br/>}</span><span id="b260" class="lz kx iq mq b gy nf mv l mw mx">avenger1();</span></pre><p id="8697" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们调用了复仇者1，而复仇者2被定义了，但现在没有调用，可以在以后的某个时间点调用。因此，javaScript将在加载时完全解析函数，并将其保存在内存中，即使尚未调用复仇者2。这造成了冗余的内存分配，如果您正在构建一个项目，其中声明了20-30个这样的方法，而您并没有立即调用它们，那么如果您的应用程序扩展，它将在您的浏览器中调用严重的延迟，并且您可以通过告诉javaScript解析器不要在此时解析该函数来提高性能。</p><p id="6307" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们再举一个例子，看看当我们将两个函数链接在一起时，如何解决这个问题。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="674d" class="lz kx iq mq b gy mu mv l mw mx">(function abc(){<br/> console.log("I am fully parsed or eagerly parsed");<br/>  function xyz() {<br/>    console.log("I am lazily parsed");<br/>  }<br/>})();</span></pre><p id="ae07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们调用上面的函数时，当解析器到达第一个括号时，它知道必须立即调用，所以它完全解析abc函数，构建它的AST，当到达没有被调用的xyz时，它缓慢地解析xyz函数，只创建它的作用域。</p><h2 id="3499" class="lz kx iq bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">解析嵌套函数时出现问题:</h2><p id="59ca" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">嵌套函数或闭包是可以访问其外部函数的变量的函数，其嵌套函数的返回值存储在内存中，直到调用该函数，以便外部函数可以访问其内部函数返回的值。</p><p id="edd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">举下面的例子来加深理解。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="1920" class="lz kx iq mq b gy mu mv l mw mx">(function abc(){<br/>  let x = 1;<br/>  let y = 2;<br/>  function xyz(){<br/>    return x;<br/>  }<br/>return xyz;<br/>})</span></pre><p id="2cdb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，函数abc被完全解析了，因为它被放在括号中，而内部函数xyz被部分解析了，因为它已经被定义但还没有被调用。</p><p id="bd0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">函数“xyz”返回x的值1，因为它可以访问其父函数的变量。因此，当解析“xyz”函数时，它会在其作用域中查找变量x，因为它没有找到变量x，所以它会查找其父作用域。这里，变量x存储在abc的函数上下文中，并一直保留到调用“xyz”函数。</p><p id="4254" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们调用内部函数“xyz”时，它在上下文中找不到x，所以它查找它的父函数，在函数上下文中查找上下文比在调用栈中查找开销更大。</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="9f90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读！如果您有任何问题，请随时联系rajrock38@gmail.com，通过<a class="ae my" href="https://www.linkedin.com/in/rajdeepcoder/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>与我联系，或者通过<a class="ae my" href="https://medium.com/@rajrock38" rel="noopener"> Medium </a>和<a class="ae my" href="https://twitter.com/rajrock38" rel="noopener ugc nofollow" target="_blank"> Twitter </a>关注我。</p><p id="8596" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你觉得这篇文章很有帮助，给它一些掌声会很有意义👏并分享出来帮别人找！并欢迎在下方发表评论。</p></div></div>    
</body>
</html>