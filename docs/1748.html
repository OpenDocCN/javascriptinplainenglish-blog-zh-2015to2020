<html>
<head>
<title>Establishing a Broadcasting Channel in Component-Driven Architecture 📡</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在组件驱动架构中建立广播通道📡</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/establishing-broadcasting-channel-in-components-driven-architecture-d3d56c20fdbe?source=collection_archive---------11-----------------------#2020-04-18">https://javascript.plainenglish.io/establishing-broadcasting-channel-in-components-driven-architecture-d3d56c20fdbe?source=collection_archive---------11-----------------------#2020-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="06d8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">介绍BroadcastChannel API和使用BroadcastChannel的跨组件/模块通信</h2></div><p id="7e8f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">广播仅仅意味着向观众或听众传递信息。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/9508ea3ccb8fd508b9ea4d19dce20e69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKHzETIBAsl3sKvWZ3dV8w.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">A broadcasting node dispatching information to multiple listeners.</figcaption></figure><p id="795e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">软件工程世界中几乎所有的概念都是从现实世界中抄袭来的。同样的，<em class="lr">广播频道</em>就像它听起来的那样，它向听众广播信息。</p><p id="9bd8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">深入到WebAPI本身，一个<em class="lr">广播频道</em>也是一个消息频道，就像<em class="lr"> postMessage </em>频道一样，除了一些我们将讨论的差异。</p><p id="d5ba" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi ls translated"><span class="l lt lu lv bm lw lx ly lz ma di">W</span>T8】ait！在继续阅读之前，如果你不知道MessageChannel或postMessage，请先阅读我关于<a class="ae mb" href="https://medium.com/@itssaadabbasi/message-channels-f94de3488b1a" rel="noopener"><strong class="kh ir"><em class="lr">message channel</em></strong></a><strong class="kh ir"><em class="lr"/></strong><em class="lr">的文章，然后再继续</em></p><p id="84d2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，我们在谈论<em class="lr">广播频道</em>是一种差异很小的沟通渠道:</p><ul class=""><li id="3e05" class="mc md iq kh b ki kj kl km ko me ks mf kw mg la mh mi mj mk bi translated">它有一个频道名，听众或其他消费者可以通过它订阅。</li><li id="6de1" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la mh mi mj mk bi translated">与<em class="lr"> MessageChannel不同，</em>你可以拥有任意多的听众。</li></ul><p id="5f27" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看我写代码是什么意思。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mq"><img src="../Images/d5aea797faf6f9449257e55b4b1c3b93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CJp4ES1CKPebvAyqg2oTmg.png"/></div></div></figure><p id="559d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，看到了吗？这与<em class="lr"> postMessage </em>通道具有相同的接口，除了它具有名为<strong class="kh ir"> name </strong>的附加属性。因此，这里的问题是“它在功能上与<em class="lr">邮件后</em>频道有何不同”</p><p id="da1c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，<em class="lr"> postMessage </em>渠道建立在两个消费者之间，其中一个发布消息，另一个监听，这种沟通在消费者之间来回进行。但是在广播频道，你可以注册任意多的听众，但是他们必须有相同的名字。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mr"><img src="../Images/d8aa1986a675a4c1bfa7300a3a0ed7f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Vi05XHzURn05wXqo83G8A.png"/></div></div></figure><p id="5811" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，这里需要注意一些事情:</p><ul class=""><li id="b5cb" class="mc md iq kh b ki kj kl km ko me ks mf kw mg la mh mi mj mk bi translated">我们将我们的通道命名为“examply”，您可以用string或string complaint来命名它，但这里要注意的一点是，您想要注册到特定通道的所有侦听器必须具有相同的名称。在上面的例子中<em class="lr"> listenerOne </em>和<em class="lr"> listenerTwo </em>具有完全相同的名称‘示例’,但是<em class="lr"> listenerThree </em>具有名称‘示例，不是示例’,它也有一个监听器，但是它没有被触发；其他两个有。</li><li id="5443" class="mc md iq kh b ki ml kl mm ko mn ks mo kw mp la mh mi mj mk bi translated">我们在注册了所有的听众之后发布了消息，不像<em class="lr"> postMessage </em>频道；<em class="lr"> broadcastChannel </em>不缓冲注册监听器之前发布或广播的事件或消息。</li></ul><p id="9a37" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们读过关于<a class="ae mb" href="https://medium.com/@itssaadabbasi/message-channels-f94de3488b1a" rel="noopener"> <em class="lr">消息通道</em> </a>的文章，因为这个WebAPI的工作方式有些类似；我不会浪费太多时间来重复我们已经学到的东西。<br/>让我们直接进入在我们的应用程序中我们可以在哪里以及如何使用它。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi ms"><img src="../Images/d6781d58ea27ce34580ace853460032d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_SsI1DipZEUV1EhWa_1FmQ.png"/></div></div></figure><p id="5c17" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们试图通过钻柱或任何其他手工编写的设计模式来实现这一点，请考虑这个场景。这实际上会给你带来大量的代码需要维护，但代价是严重的性能损失(如果处理不当)。有了BroadcastChannel，一切都变得简单而直截了当:没有道具训练，没有观察者/可观察的模式，没有发射者/消费者，只是简单而美好。</p><p id="9788" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个很好的例子是下表</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mt"><img src="../Images/123591819a7cb2fcf651baca90c6b50f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mNOH6ddMGjgakMqh4nIVkA.png"/></div></div></figure><p id="66df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个具有多种功能的表，如搜索、排序、下载配置、日期范围选择器和切换列可见性选择器、分页和页面大小选择。嗯，配置很多，对吧？如果我要求你实现一个功能“重置”，点击重置每个功能为默认！那将是低音的痛苦，不是吗？</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mu"><img src="../Images/c5a9ce3d27a5d53c91d480770140c012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3IoiH2uyoW613dsyFYyKXA.png"/></div></div></figure><p id="6b51" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以通过在不同组件之间建立一个名为“reset-table”的广播通道来实现这一点，并使<em class="lr"> ResetComponent </em>能够向所有其他侦听器组件发布消息，以便它们能够做出相应的反应。</p><p id="62f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更好的一点是，如果一个侦听器组件不活动(在视图中是呈现的)或者稍后可能被延迟加载，这也没有问题。一旦它将延迟加载，如果它具有正确频道名称，它将只是挂钩到广播频道。</p><p id="945f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是也有不好的一面，如果你不注意取消订阅，它可能会引入一些内存泄漏。让我们看看如何通过引入内存泄漏☢️</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mv"><img src="../Images/0a2deb16bc4328fc80099d49ca716796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7ZXQ-t5CDFZy4P4CBEum4Q.png"/></div></div></figure><p id="0579" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次执行这段代码时，侦听器的数量都会不断增加。为了防止内存泄漏，只需在您完成监听或卸载模块或组件后关闭通道，方法是在您想要关闭的通道上调用<em class="lr"> close </em>方法。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi mw"><img src="../Images/aa4d21c5ef26a6bfacb4e0f2daddece0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l8eSRoT0WS8llht1yGdSFQ.png"/></div></div></figure><p id="1cc1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们刚刚修好了，但是，请注意！一旦通道被关闭，你就不能通过它发送或接收信息，这应该是显而易见的，但无论如何还是要提到它。</p><p id="64b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嗯，是的，redux也可以做到这一点，忽略样板文件，所有的复杂性，所有你必须改变的文件，以及随之而来的额外代码；这个问题是基于事件的问题，redux是一个状态容器，仅仅因为我们可以适应它，并不意味着我们应该适应它。我发现<em class="lr">广播频道</em>更加干净和直接。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="025a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这应该足以让你产生好奇心，在你的应用程序中尝试一次，但遗憾的是，目前在浏览器上还没有太多的支持——只有Chrome和Firefox🙁<br/>嗯，<em class="lr">广播频道</em>能做的远不止这些。当涉及到跨上下文交流时，它基本上还有一点要探索，但是保持这篇文章的简洁并专注于本文的主题，<strong class="kh ir">我们可以到此为止。</strong></p><p id="4eec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你能从这篇文章中学到一些东西。<strong class="kh ir">干杯🍻</strong></p><h2 id="9fda" class="ne nf iq bd ng nh ni dn nj nk nl dp nm ko nn no np ks nq nr ns kw nt nu nv nw bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="5910" class="pw-post-body-paragraph kf kg iq kh b ki nx jr kk kl ny ju kn ko nz kq kr ks oa ku kv kw ob ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物，表达对它们的喜爱:<a class="ae mb" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kh ir">AI in Plain English</strong></a>，<a class="ae mb" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kh ir">UX in Plain English</strong></a>，<a class="ae mb" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kh ir">Python in Plain English</strong></a><strong class="kh ir"/>——谢谢，继续学习！</p><p id="029b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae mb" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir">submissions @ plain English . io</strong></a><strong class="kh ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>