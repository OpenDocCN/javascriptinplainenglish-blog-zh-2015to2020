<html>
<head>
<title>Best of Modern JavaScript — Prototypes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华——原型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-prototypes-31c56f9743f3?source=collection_archive---------8-----------------------#2020-10-09">https://javascript.plainenglish.io/best-of-modern-javascript-prototypes-31c56f9743f3?source=collection_archive---------8-----------------------#2020-10-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4bc516c46577b9da90ca7a29ad0f14bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*14l9BUMHcdAbtQue"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@lavievagabonde?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jasmin Schreiber</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2414" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript中新的OOP特性。</p><h1 id="8425" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">重写继承的只读属性</h1><p id="0f26" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">Object.defineProperty</code>方法覆盖继承的只读属性。</p><p id="3251" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不能直接给只读属性赋值。</p><p id="6d58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ddd2" class="mq lc iq mh b gy mr ms l mt mu">const proto = Object.defineProperty({}, 'prop', {<br/>  writable: false,<br/>  configurable: true,<br/>  value: 'foo',<br/>});</span><span id="63c4" class="mq lc iq mh b gy mv ms l mt mu">const obj = Object.create(proto);<br/>obj.prop = 'bar';</span></pre><p id="df14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们<code class="fe me mf mg mh b">obj.prop</code>保持<code class="fe me mf mg mh b">'foo'</code>在松散模式下，我们在严格模式下得到一个错误。</p><p id="c0b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以调用<code class="fe me mf mg mh b">Object.defineProperty</code>来覆盖<code class="fe me mf mg mh b">obj.prop</code>的属性值。</p><p id="7e83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9b2a" class="mq lc iq mh b gy mr ms l mt mu">const proto = Object.defineProperty({}, 'prop', {<br/>  writable: false,<br/>  configurable: true,<br/>  value: 'foo',<br/>});</span><span id="6c35" class="mq lc iq mh b gy mv ms l mt mu">const obj = Object.create(proto);<br/>Object.defineProperty(obj, 'prop', {<br/>  value: 'bar'<br/>});</span></pre><p id="08b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe me mf mg mh b">obj</code>对象上定义了<code class="fe me mf mg mh b">prop</code>属性，以将值添加到<code class="fe me mf mg mh b">obj</code>对象中。</p><p id="8e2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这覆盖了<code class="fe me mf mg mh b">prop</code>属性，从<code class="fe me mf mg mh b">obj</code>的原型到<code class="fe me mf mg mh b">obj</code>对象本身。</p><h1 id="ff4b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">__proto__</code>在ES6中</h1><p id="9adc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">__proto__</code>是ES6中的官方隐藏属性。</p><p id="ad73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在ES5中，我们可以使用<code class="fe me mf mg mh b">Object.getPrototypeOf</code>方法来获得对象的原型。</p><p id="341b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0059" class="mq lc iq mh b gy mr ms l mt mu">var obj = {};<br/>var p = Object.getPrototypeOf(obj);</span></pre><p id="d2af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用这种方法可以得到<code class="fe me mf mg mh b">obj</code>的原型。</p><p id="35fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要用给定的原型创建一个对象，我们可以使用<code class="fe me mf mg mh b">Object.create</code>方法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a8d8" class="mq lc iq mh b gy mr ms l mt mu">var<!-- --> <!-- -->obj<!-- --> <!-- -->=<!-- --> <!-- -->Object.create(p);</span></pre><p id="db22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">p</code>为原型。</p><p id="2987" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Firefox是第一个让曾经非标准的<code class="fe me mf mg mh b">__proto__</code>属性允许我们用Firefox获取和设置对象原型的浏览器。</p><p id="7372" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ac0f" class="mq lc iq mh b gy mr ms l mt mu">var<!-- --> <!-- -->obj<!-- --> <!-- -->=<!-- --> <!-- -->{};<br/>var<!-- --> <!-- -->p<!-- --> <!-- -->=<!-- --> <!-- -->{};<br/>obj.__proto__<!-- --> <!-- -->=<!-- --> <!-- -->p;</span></pre><p id="1da6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dfca" class="mq lc iq mh b gy mr ms l mt mu">console.log(obj.__proto__<!-- --> <!-- -->===<!-- --> <!-- -->p);</span></pre><p id="5846" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">日志<code class="fe me mf mg mh b">true</code>。</p><p id="28d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是当我们试图用以下方法检查该属性是否是<code class="fe me mf mg mh b">obj</code>的实际属性时:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6db2" class="mq lc iq mh b gy mr ms l mt mu">'__proto__' in obj</span></pre><p id="0166" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将返回<code class="fe me mf mg mh b">false</code>。</p><p id="464b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">__proto__</code>属性对于创建数组的子类很有用。</p><p id="c54c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b65c" class="mq lc iq mh b gy mr ms l mt mu">function FancyArray() {<br/>  var instance = new Array();<br/>  instance.__proto__ = FancyArray.prototype;<br/>  return instance;<br/>}</span><span id="55b0" class="mq lc iq mh b gy mv ms l mt mu">FancyArray.prototype = Object.create(Array.prototype);<br/>FancyArray.prototype.customMethod = function() {<br/>  //...<br/>};</span></pre><p id="1ab0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过创建<code class="fe me mf mg mh b">Array</code>构造函数的实例来创建<code class="fe me mf mg mh b">FancyArray</code>构造函数，</p><p id="7c54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将实例的原型设置为我们的<code class="fe me mf mg mh b">FancyArray</code>构造器的<code class="fe me mf mg mh b">prototype</code>。</p><p id="de24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回数组的实例。</p><p id="b640" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">Object.create</code>创建<code class="fe me mf mg mh b">FanctArray</code>的原型，这样我们就可以从<code class="fe me mf mg mh b">Array</code>的原型继承方法。</p><p id="6589" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在原型中创建一个自定义方法。</p><p id="7f65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性很容易与对象的常规属性混淆。</p><p id="221d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，使用<code class="fe me mf mg mh b">__proto__</code>属性来获取和设置对象的属性并不是一个好主意。</p><p id="07a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Object.getPrototypeOf()</code>是获得原型的最好方法。</p><p id="6f8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ES6标准化了<code class="fe me mf mg mh b">__proto__</code>属性，使其广泛可用。</p><p id="5615" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个getter和setter属性。</p><p id="dfe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ES6让我们获取并设置<code class="fe me mf mg mh b">__proto__</code>属性。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/9dcfe01dd4fc0865ec27ec37c2e322a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QdbxlgF1wn2fZ12a"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@markkoenig?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mark König</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ad8a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d21d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过各种方式获得和设置原型。</p><p id="3c8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">__proto__</code>属性是ES6的标配。</p><p id="a8c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>