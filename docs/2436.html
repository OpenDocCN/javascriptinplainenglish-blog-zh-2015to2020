<html>
<head>
<title>React Best Practices — Components and States</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应最佳实践—组件和状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-best-practices-components-and-states-551709d7df6f?source=collection_archive---------7-----------------------#2020-06-23">https://javascript.plainenglish.io/react-best-practices-components-and-states-551709d7df6f?source=collection_archive---------7-----------------------#2020-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/62e888beed4954cd61722768f7b9affe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zDSc0qZeJRJUpYe2"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@heytowner?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JOHN TOWNER</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="690f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，React应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="d58a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写React应用程序时的一些最佳实践。</p><h1 id="297d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用带挂钩的ES6类或功能组件</h1><p id="78cc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该为我们的React组件采用现代JavaScript语法。</p><p id="e0ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用类或者功能组件。</p><p id="8c44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们在不久的将来都会得到支持。</p><p id="4bf6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7036" class="mn lc iq mj b gy mo mp l mq mr">class Hello extends React.Component {<br/>  render() {<br/>    return &lt;div&gt;Hello {this.props.name}&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="3ab1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f4cc" class="mn lc iq mj b gy mo mp l mq mr">function Hello({ name }) {<br/>  render() {<br/>    return &lt;div&gt;Hello {name}&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="2a71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们都很好。</p><p id="25da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们正在构建现代应用程序，就不应该再使用它了。</p><h1 id="21a9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">强制只读属性</h1><p id="017a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果有只读道具，那么就要强制执行。</p><p id="d294" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:“</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9a27" class="mn lc iq mj b gy mo mp l mq mr">function Hello(props: { -name: string }) {<br/>  return &lt;div&gt;Hello {props.name}&lt;/div&gt;;<br/>}</span></pre><p id="ffbc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="14fa" class="mn lc iq mj b gy mo mp l mq mr">const Hello = (props: {|name: string|}) =&gt; (<br/>  &lt;div&gt;Hello {props.name}&lt;/div&gt;<br/>);</span></pre><p id="356b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们都用Flow使我们的道具只读。</p><p id="371c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有办法用普通的JavaScript将属性设为只读。</p><h1 id="76d4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将无状态React组件编写为纯函数</h1><p id="e013" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用无状态组件的全部意义在于没有自己的状态。</p><p id="e80d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以他们应该只拿道具渲染。</p><p id="7e40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8ee3" class="mn lc iq mj b gy mo mp l mq mr">const Foo = function(props) {<br/>  return &lt;div&gt;{props.foo}&lt;/div&gt;;<br/>};</span></pre><p id="2fb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们所做的就是获取<code class="fe ms mt mu mj b">props</code>并渲染它们。</p><p id="3ca0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们不应该做别的。</p><h1 id="de04" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">添加属性验证</h1><p id="238e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">适当验证将省去我们许多麻烦。</p><p id="9af9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们只有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0ccb" class="mn lc iq mj b gy mo mp l mq mr">function Hello({ name }) {<br/>  return &lt;div&gt;Hello {name}&lt;/div&gt;;<br/>}</span></pre><p id="3437" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以为<code class="fe ms mt mu mj b">name</code>传递任何东西。</p><p id="98c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该为<code class="fe ms mt mu mj b">prop-types</code>包添加如下验证:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="77a2" class="mn lc iq mj b gy mo mp l mq mr">import PropTypes from 'prop-types';</span><span id="58c0" class="mn lc iq mj b gy mv mp l mq mr">function Hello({ name }) {<br/>  return &lt;div&gt;Hello {name}&lt;/div&gt;;<br/>}</span><span id="1515" class="mn lc iq mj b gy mv mp l mq mr">Hello.propTypes = {<br/>  name: PropTypes.string.isRequired,<br/>};</span></pre><p id="a534" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们确保<code class="fe ms mt mu mj b">name</code>被传入并且是一个字符串。</p><h1 id="30a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">当有JSX时，添加反应进口</h1><p id="c4b3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当有JSX时，我们应该加上反动派。</p><p id="6b73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有它我们会得到一个错误。</p><p id="fe3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="17e1" class="mn lc iq mj b gy mo mp l mq mr">import React from 'react';<br/><br/>const Hello = ({ name }) =&gt; &lt;div&gt;Hello {name}&lt;/div&gt;;</span></pre><h1 id="f450" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为每个不是必需道具的道具添加默认道具</h1><p id="c7d0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果它不是一个必需的属性，那么我们应该添加一个默认值，这样即使没有传入任何东西，我们也可以为这个属性赋值。</p><p id="aad8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f81b" class="mn lc iq mj b gy mo mp l mq mr">const HelloWorld = ({ first, last }) =&gt; (<br/>  &lt;h1&gt;Hello, {first} {last}!&lt;/h1&gt;<br/>);<br/><br/>HelloWorld.propTypes = {<br/>  first: PropTypes.string.isrequired,<br/>  last: PropTypes.string,<br/>};</span><span id="3022" class="mn lc iq mj b gy mv mp l mq mr">HelloWorld.defaultProps = {<br/>  last: 'smith'<br/>};</span></pre><p id="eacb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe ms mt mu mj b">first</code>属性设置为required，因此我们需要为它传入一个值。</p><p id="8eda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是<code class="fe ms mt mu mj b">last</code>不是必需的。</p><p id="10e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该为它设置一个默认值，这样无论我们有什么，我们都可以为<code class="fe ms mt mu mj b">last</code>渲染一些东西。</p><h1 id="6d47" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">添加一个shouldComponentUpdate以减少渲染</h1><p id="16b4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该添加一个<code class="fe ms mt mu mj b">shouldComponentUpdate</code>方法，这样我们就可以比较道具或状态来决定我们是否应该重新渲染组件。</p><p id="b094" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="20b7" class="mn lc iq mj b gy mo mp l mq mr">class Component extends React.Component {<br/>  shouldComponentUpdate () {<br/>    return false;<br/>  }<br/>}</span></pre><p id="00d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将防止组件发生任何重新渲染。</p><h1 id="5eed" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对组件使用ES6类或函数</h1><p id="6e60" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有React组件的ES6类函数，我们使用<code class="fe ms mt mu mj b">render</code>方法来呈现我们想要的项目。</p><p id="085c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是函数组件，我们直接返回项目。</p><p id="fc9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6089" class="mn lc iq mj b gy mo mp l mq mr">class Hello extends React.Component {<br/>  render() {<br/>    &lt;div&gt;Hello&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="aa20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e154" class="mn lc iq mj b gy mo mp l mq mr">function Hello {<br/>  &lt;div&gt;Hello&lt;/div&gt;;  <br/>}</span></pre><h1 id="ef1b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">向没有子级的组件或元素添加结束标记</h1><p id="b8ec" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JSX遵循类似XML的语法，所以我们应该为没有子组件的组件设置结束标记。</p><p id="7fb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2042" class="mn lc iq mj b gy mo mp l mq mr">const Hello = &lt;Hello name="james" /&gt;;</span></pre><p id="7d85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="46cd" class="mn lc iq mj b gy mo mp l mq mr">const Image = &lt;img src="picture.png" /&gt;</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/518559b642528110c9ed3e4872d4397d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*n6TyjJORV7fzz2Ss"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@barncreative?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fábio Alves</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5235" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="50e9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该用现代语法创建组件。</p><p id="fa8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用新的语法编写更容易。</p><p id="b304" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以调用<code class="fe ms mt mu mj b">shouldComponentUpdate</code>来确定我们的组件是否需要重新渲染，这样我们就可以减少更新的频率。</p><h2 id="b8e9" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">说白了</strong></h2><p id="86d0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四种出版物吗？通过<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> plainenglish.io </strong> </a>找到他们——通过关注我们的出版物和<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>