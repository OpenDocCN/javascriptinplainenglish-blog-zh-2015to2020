<html>
<head>
<title>An Introduction to Fiber, an Alternative to Express.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">光纤简介，Express.js的替代方案</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/golang-fiber-426f52185fc4?source=collection_archive---------4-----------------------#2020-12-20">https://javascript.plainenglish.io/golang-fiber-426f52185fc4?source=collection_archive---------4-----------------------#2020-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b4d3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Golang的performant Express.js替代比较</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4a751e3715f8994fb9ec89d07fd5657c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vlBMNVKk_oDrB6KO8sT_WQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: The author</figcaption></figure><p id="6548" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Golang是趋势。随着编程语言的兴起，用于编程语言的库和框架不断涌现。对于谷歌的Golang，甚至有一个web框架，它非常类似于express . js——但它声称是一个性能更好的替代方案。</p><p id="50ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将了解Fiber的基础知识，以及它与Express.js有多相似。我们还将进行性能比较，看看哪个框架更快。</p><p id="1251" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于这篇文章，你不需要太多关于Golang的知识——如果你还想上一点Golang速成班，这里有一个。</p><h1 id="12a1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">我们走吧</h1><p id="7463" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">首先，你需要安装Golang你可以在这里做<a class="ae lr" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank">https://golang.org/</a>。</p><p id="9bad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在您的终端中，您可以简单地输入<code class="fe mp mq mr ms b">go version</code>来测试安装是否有效。现在我们已经可以开始安装光纤了。</p><p id="78fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，首先使用Go-CLI创建一个新项目。这有点像我们从npm init开始的节点世界。所以我们为我们的项目创建了一个<em class="mt"> package.json </em>。在Go中，这个文件就是<em class="mt"> go.mod </em>。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="575e" class="my lt iq ms b gy mz na l nb nc">go mod init</span></pre><p id="60e4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">之后，我们可以为我们的项目安装光纤框架。我们使用下面的命令来实现这一点，它的工作方式类似于npm install。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="3140" class="my lt iq ms b gy mz na l nb nc">go get -u github.com/gofiber/fiber/v2</span></pre><p id="2acd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们可以用光纤实现一个hello world。为此，我们在与我们的<em class="mt"> go.mod </em>相同的文件夹中创建一个<em class="mt"> main.go </em>。我们在这里编写所有的代码。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="cd69" class="my lt iq ms b gy mz na l nb nc">package main</span><span id="4962" class="my lt iq ms b gy nd na l nb nc">import "github.com/gofiber/fiber/v2"</span><span id="4bfc" class="my lt iq ms b gy nd na l nb nc">func main() {<br/>  app := fiber.New()</span><span id="99cd" class="my lt iq ms b gy nd na l nb nc">  app.Get("/", func(c *fiber.Ctx) error {<br/>    <em class="mt">return</em> c.SendString("Hello, World :)")<br/>  })</span><span id="cd8c" class="my lt iq ms b gy nd na l nb nc">  app.Listen(":8080")<br/>}</span></pre><p id="f487" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe mp mq mr ms b">go run main.go</code>我们可以运行main . go。<br/>如果您现在在浏览器中打开localhost:8080，您应该会看到我们的第一页。</p><p id="63f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里已经可以看出和Express.js. <br/>是多么的相似，在Golang中，我们总是要定义一个包；在它下面，我们用Express导入纤维框架。</p><p id="8e4e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与JavaScript不同，Go依赖于一个自动执行的<strong class="kx ir">主函数</strong>——这就是我们在这里定义代码的原因。和在Express中一样，我们首先必须创建一个实例，为我们的web服务器奠定基础。</p><p id="6c13" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mt"> app.get </em>函数我们应该也很熟悉。第一个参数是路线；第二个是处理请求的函数。<em class="mt"> Ctx </em>代表上下文，包含所有重要信息。我们可以用变量<strong class="kx ir"> <em class="mt"> c </em> </strong>来访问上下文。类似于Express.js中的<strong class="kx ir"> <em class="mt"> res </em> </strong>。</p><p id="17df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="mt"> c.SendString() </em>因此可以理解为类似于<em class="mt"> res.send()。</em></p><p id="b4a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，我们可以使用上下文变量输出基本URL如下:<code class="fe mp mq mr ms b">fmt.Println(c.BaseURL())</code>。</p><p id="d5d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是另一个例子，它展示了上下文变量像Express中的res一样工作。所以我们可以为我们的响应设置一个HTTP状态:</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="fa88" class="my lt iq ms b gy mz na l nb nc">app.Get("/", func(c *fiber.Ctx) error {<br/>  <em class="mt">return</em> c.SendStatus(404)<br/>  <em class="mt">// "Status for Not Found"<br/></em>})</span></pre><p id="a869" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们的web服务器启动并运行，我们就可以使用nodemon进行实时重载。不，我没有打错——<strong class="kx ir">nodemon</strong>；我们也可以用它来下围棋。<br/>它是这样工作的:</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="60d6" class="my lt iq ms b gy mz na l nb nc">nodemon — exec go run main.go — signal SIGTERM</span></pre><p id="a2a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很实用，不是吗？如果我们修改了代码，服务器会自动重启。</p><h1 id="008d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">URL参数</h1><p id="c7ad" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们不能回避这个原则——URL参数非常方便，允许我们的服务器动态响应请求。在Express.js中，我们只需要在GET route中使用一个特殊的语法来表示我们需要一个参数。这是它在Express中的样子:</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="01be" class="my lt iq ms b gy mz na l nb nc">app.get("/user/:name", (req, res) =&gt; {<br/>  res.send("Hi user " + req.params.name)<br/>})</span></pre><p id="b581" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">令人惊讶的是，这就是它在纤维中的样子:</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="c2cb" class="my lt iq ms b gy mz na l nb nc">app.Get("/user/:name", func(c *fiber.Ctx) error {<br/>  <em class="mt">return</em> c.SendString("Hi User "+ c.Params("name"))<br/>})</span></pre><p id="11ef" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们调用localhost:8080/user/max，我们会看到以下输出:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/351f52f14a5c711c58b4373ff9eaf4b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:868/format:webp/1*1G8NDVZrwZwAeTq-VxkvZA.png"/></div></figure><p id="11bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我们通过URL传递参数有多容易——几乎与Express.js中的一模一样。</p><h1 id="f7dc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">提供静态文件</h1><p id="0bcd" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">静态文件是服务器不再修改的文件——我们交付给用户的CSS或JavaScript文件就是很好的例子。<br/>为了在Express.js中交付静态文件，我们使用了中间件函数<em class="mt"> express.static </em>。在使用中，它看起来像这样:</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="d146" class="my lt iq ms b gy mz na l nb nc">app.use('/app', express.static('public'));</span></pre><p id="2ae3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，当用户调用路由“app”时，我们将传递文件夹“public”的内容。<br/>在Golang的纤维里，这个看起来也很像。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="dc6a" class="my lt iq ms b gy mz na l nb nc">app.Static("/app", "./public")</span></pre><p id="e2cf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这同样适用于这里。当有人调用/app时，直接在我们目录中的文件夹“public”的内容就会发送给他。例如，典型的结构如下。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/550f5c65a4719ad24abf0c7ff5a76bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/format:webp/1*G1SvpTeQj4BWg4xm5KpeUQ.png"/></div></figure><p id="ca31" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到目前为止，一切顺利。我们看到Fiber Express.js极其相似。但它也提供了真正的优势吗？是的，尤其是性能是纤维的强项。</p><p id="82fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了证明这一点，我实现了一个基准。利用这两种技术，我实现了同一个应用程序。公平地说，我还将两种情况下的响应头调整为相同的大小。</p><p id="6768" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">以下是光纤应用程序的代码:</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="93bb" class="my lt iq ms b gy mz na l nb nc">app.Get("/user/:name", func(c *fiber.Ctx) error {<br/>  c.Set("Connection", "keep-alive")<br/>  c.Set("Content-Type", "text/html; charset=utf-8")<br/>  <em class="mt">return</em> c.SendString("Hi User "+ c.Params("name"))<br/>})</span></pre><p id="8c9e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是Express中同一应用程序的代码:</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="0c79" class="my lt iq ms b gy mz na l nb nc">app.disable("etag");<br/>  app.disable("x-powered-by");<br/>  app.get("/user/:name", (req, res) =&gt; {<br/>  res.send("Hi user "+ req.params.name)<br/>})</span></pre><p id="77b1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Express应用程序简单地用<code class="fe mp mq mr ms b">node server.js</code>Fiber应用程序执行，因为Go是一种编译语言，用<code class="fe mp mq mr ms b">go build main.go</code>编译，用<code class="fe mp mq mr ms b">./main</code>执行。</p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="4de9" class="my lt iq ms b gy mz na l nb nc">wrk -t12 -c400 -d10s http://localhost:8080/user/max</span></pre><p id="13bf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">基准的工具叫做<strong class="kx ir"> <em class="mt"> wrk </em> </strong>。12是我们将使用的线程数，400是并发连接数。负载运行10秒钟。</p><p id="f1b5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果是惊人的。当然，我已经运行了几次，但这里是平均结果。</p><p id="38e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">纤维:</strong></p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="b738" class="my lt iq ms b gy mz na l nb nc">Thread Stats Avg Stdev Max +/- Stdev<br/> Latency 2.57ms 698.98us 50.72ms 90.95%<br/> Req/Sec 12.70k 2.10k 38.18k 96.43%<br/> 1521782 requests in 10.10s, 219.14MB read<br/> Socket errors: connect 0, read 364, write 0, timeout 0<br/>Requests/sec: 150603.89<br/>Transfer/sec: 21.69MB</span></pre><p id="8ad6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> Express.js: </strong></p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="deb9" class="my lt iq ms b gy mz na l nb nc">Running 10s test @ <a class="ae lr" href="http://localhost:8080/user/max" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/user/max</a><br/> 12 threads and 400 connections<br/> Thread Stats Avg Stdev Max +/- Stdev<br/> Latency 38.54ms 8.55ms 171.39ms 93.07%<br/> Req/Sec 0.85k 151.82 1.00k 89.32%<br/> 102078 requests in 10.02s, 16.94MB read<br/> Socket errors: connect 0, read 610, write 0, timeout 0<br/>Requests/sec: 10189.99<br/>Transfer/sec: 1.69MB</span></pre><p id="af3c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> Express.js与PM2: </strong></p><pre class="kg kh ki kj gt mu ms mv mw aw mx bi"><span id="2deb" class="my lt iq ms b gy mz na l nb nc">Running 10s test @ <a class="ae lr" href="http://localhost:8080/user/max" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/user/max</a><br/> 12 threads and 400 connections<br/> Thread Stats Avg Stdev Max +/- Stdev<br/> Latency 19.77ms 25.89ms 503.95ms 93.01%<br/> Req/Sec 2.11k 299.31 5.39k 88.73%<br/> 252083 requests in 10.03s, 41.83MB read<br/> Socket errors: connect 0, read 151, write 0, timeout 0<br/>Requests/sec: 25135.86<br/>Transfer/sec: 4.17MB</span></pre><p id="fe28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我仍然使用PM2，因为它对应用程序的生产版本非常有用。默认情况下，Node.js即使在负载下也只会使用一个CPU核；PM2有助于其集群模式发挥其全部潜力。然而，结果是清楚的。</p><p id="e315" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">值得注意的是，这只是一个单一的测试——基于URL参数的比较。但是有太多其他的事情属于真正的web应用程序，通常性能不取决于后端框架而是其他因素。此外，尽管fiber的性能更高，但是如此多的并发请求在现实世界中是不现实的。</p><h1 id="cb50" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">总结</h1><p id="9b75" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">尝试新技术，惊叹性能总是很有趣。</p><p id="8a3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">问题只是它到底还剩下什么。正如已经提到的，人们不应该过分强调基准的结果。在现实中，将现有的Express.js应用程序完全转换为Fiber没有太大的意义——尤其是如果你对Golang没有很好的了解。毕竟，每种编程语言都有自己的问题和挑战。</p><p id="96fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我可以向任何已经了解Golang或希望用另一种语言实现几个项目的人推荐Fiber——Fiber和Express之间关系的巨大优势是，您可以沉浸在新技术中，而不会完全意识不到它。</p><p id="26a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">光纤的一个特别优势是它比Golang自己的<em class="mt"> net/http </em>模块更快。Fiber完全基于另一个针对Go的性能优化的HTTP引擎。所以如果你想用Golang实现一个web服务器，最好直接用Fiber。</p><p id="7a27" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在Express.js的情况下，这就不能说了。<a class="ae lr" href="https://medium.com/javascript-in-plain-english/i-built-the-same-api-with-without-express-here-are-the-differences-83bbeb7ddad" rel="noopener">正如这个实验所示，在没有任何框架或库的情况下，Express并不比Node.js中的基本HTTP服务器</a>更快。尤其是较小的应用程序可以也应该不用Express.js来实现——至少从性能的角度来看是这样。</p></div></div>    
</body>
</html>