<html>
<head>
<title>Using Node.js in Production (Part III)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在生产中使用Node.js(第三部分)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-node-js-in-production-part-iii-5a7a3f2fe942?source=collection_archive---------6-----------------------#2020-07-14">https://javascript.plainenglish.io/using-node-js-in-production-part-iii-5a7a3f2fe942?source=collection_archive---------6-----------------------#2020-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="00e7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何将Node.js应用程序部署到生产环境中，并拥有从开发到部署的强大管道</h2></div><p id="7ab8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您还没有阅读第2部分，我强烈建议您这样做，以确保您有一个与本文相关的上下文。你可以在这里读到它——</p><div class="lb lc gp gr ld le"><a href="https://medium.com/@ryan.dsilva/using-node-js-in-production-ii-c3906990e61e" rel="noopener follow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">在生产中使用node . js-II</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">这是关于如何将Node.js应用程序部署到生产环境中的系列文章的第2部分，以便拥有一个健壮的……</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">medium.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls lt le"/></div></div></a></div><p id="63b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，如果你已经跟随这个系列，我们现在有了我们的Node.js应用程序负载平衡和NGINX作为我们的反向代理。在这一部分，我们将通过使用gzip压缩来优化我们的服务器，并通过使用我们自己的来自“让我们加密”的SSL证书来强制实施HTTPS来保护所有端点。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="ma mb di mc bf md"><div class="gh gi lu"><img src="../Images/a969141aa20b97d616a2bf4e6ae1afe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ct8kEaWUcNyAhBephCmliA.jpeg"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Image Credit — Chris Sanity</figcaption></figure><p id="f3ef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，为什么要压缩呢？压缩使我们能够更有效地使用网络带宽，并减少客户端必须接收的有效负载大小。但是，为什么要在NGINX上使用压缩呢？因为express有一个非常方便的模块，可以作为一个中间件，您只需要使用——<code class="fe mj mk ml mm b">npm install --save compression</code>安装它，然后像这样使用它</p><pre class="lv lw lx ly gt mn mm mo mp aw mq bi"><span id="5fe7" class="mr ms iq mm b gy mt mu l mv mw">const compression = require('compression');<br/>...<br/><br/>app.use(compression());<br/><br/>...</span></pre><p id="ce6e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这没问题，但不是最佳解决方案。这是因为Node.js是一个单线程任务，并且压缩是资源密集型的，因此会使Node.js应用程序长时间处于繁忙状态，这使得服务器对新的传入请求没有响应。这就是为什么将压缩卸载到NGINX是一种好的做法，因为NGINX更适合处理这类任务，同时保持Node.js实例可以自由接受和处理新的请求。</p><p id="223b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，在NGINX中使用压缩非常容易。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5714" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在服务器块中—</p><ul class=""><li id="55a9" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated"><em class="ni">gzip</em><strong class="kh ir"><em class="ni">on</em></strong><em class="ni"/>——这告诉NGINX使用gzip压缩</li><li id="59f4" class="mz na iq kh b ki nj kl nk ko nl ks nm kw nn la ne nf ng nh bi translated"><em class="ni">gzip _ TYPES</em><strong class="kh ir"><em class="ni">MIME _ TYPES</em></strong>——这将告诉NGINX需要压缩哪些类型的数据</li><li id="6418" class="mz na iq kh b ki nj kl nk ko nl ks nm kw nn la ne nf ng nh bi translated"><em class="ni">gzip _ comp _ level</em><strong class="kh ir"><em class="ni">N</em></strong>——表示压缩级别，1表示最小压缩，10表示最大压缩</li><li id="0866" class="mz na iq kh b ki nj kl nk ko nl ks nm kw nn la ne nf ng nh bi translated"><em class="ni">gzip _ min _ length</em><strong class="kh ir"><em class="ni">VALUE</em></strong>——指定压缩开始后的最小数据大小(该值以字节为单位)</li></ul><p id="1157" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就这样！不需要其他配置。NGINX现在将压缩响应数据，您可以通过查看响应头来验证这一点。</p><p id="5ea1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果您注意到我们的应用是通过<code class="fe mj mk ml mm b">http</code>而不是<code class="fe mj mk ml mm b">https</code>提供服务的，对于生产环境来说，保护数据流是至关重要的。本教程的这一部分将对NGINX指令进行概要介绍，因为深入研究这些指令需要计算机网络、网络安全和密码学领域的先验知识。</p><p id="a729" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果你对细节感兴趣，这篇文章会给你一个很好的开始</p><div class="lb lc gp gr ld le"><a href="https://robertheaton.com/2014/03/27/how-does-https-actually-work/" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">HTTPS实际上是如何工作的？罗伯特·希顿</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">HTTPS只是你的标准HTTP协议，涂上一层美味的SSL/TLS加密善良…</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">robertheaton.com</p></div></div><div class="ln l"><div class="no l lp lq lr ln ls lt le"/></div></div></a></div><p id="efc5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，我将一步一步地为我们的Node.js应用程序使用NGINX设置HTTPS。</p><p id="6fe3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将从<a class="ae np" href="https://letsencrypt.org/" rel="noopener ugc nofollow" target="_blank">获取我们的SSL证书，让我们加密</a>。</p><blockquote class="nq nr ns"><p id="bc3d" class="kf kg ni kh b ki kj jr kk kl km ju kn nt kp kq kr nu kt ku kv nv kx ky kz la ij bi translated">“Let's Encrypt”是一个由互联网安全研究小组运营的非营利性证书颁发机构，免费提供传输层安全加密的X.509证书。证书的有效期为90天，在此期间可以随时更新。</p></blockquote><p id="34d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，有一个名为<a class="ae np" href="https://certbot.eff.org/" rel="noopener ugc nofollow" target="_blank"> CertBot </a>的自动化解决方案，它可以为我们完成所有繁重的工作，并通过一个简单的命令生成证书。让我们先安装CertBot</p><pre class="lv lw lx ly gt mn mm mo mp aw mq bi"><span id="a8e8" class="mr ms iq mm b gy mt mu l mv mw">sudo yum install certbot</span></pre><p id="e344" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在那之后，我们可以跑—</p><pre class="lv lw lx ly gt mn mm mo mp aw mq bi"><span id="507f" class="mr ms iq mm b gy mt mu l mv mw">certbot certonly --standalone -d DOMAIN_NAME</span></pre><p id="fc6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该命令将生成唯一标识我们的证书和私钥。它将存储在<code class="fe mj mk ml mm b">/etc/letsencrypt/live/DOMAIN_NAME/</code>下，你会发现两个文件——<code class="fe mj mk ml mm b">fullchain.pem</code>和<code class="fe mj mk ml mm b">privkey.pem</code></p><p id="c39c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，我们现在可以将以下配置指令添加到NGINX配置文件中。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="422e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几个要点—</p><ul class=""><li id="47dd" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated">在第一个服务器块中，来自<code class="fe mj mk ml mm b">http</code>即端口80的请求将全部转发/重定向到<code class="fe mj mk ml mm b">https</code>，状态码为<em class="ni"> 301 </em></li><li id="27ae" class="mz na iq kh b ki nj kl nk ko nl ks nm kw nn la ne nf ng nh bi translated">在第二个服务器模块中，使用的端口是443，这是<code class="fe mj mk ml mm b">https</code>的默认端口，之后，我们按照优先级、<code class="fe mj mk ml mm b">ssl</code>和<code class="fe mj mk ml mm b">http2</code>的顺序定义协议</li><li id="a56d" class="mz na iq kh b ki nj kl nk ko nl ks nm kw nn la ne nf ng nh bi translated">要更改的两个指令是<code class="fe mj mk ml mm b">ssl_certificate</code>和<code class="fe mj mk ml mm b">ssl_certificate_key</code>，它们应该指向certbot为您的域生成的密钥和证书。</li></ul><p id="e6a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您是高级用户，其他指令可能会让您感兴趣，您可能希望根据应用程序的需要对它们进行调整。但是对于这一点，这已经超出了本教程的范围，默认配置应该就可以了。</p><p id="4256" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们最终的NGINX配置文件应该是这样的—</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="0bfe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">概略地说，我们的部署可以这样来看—</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/f0b97ad77ba97f94583189a10fca8b0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*3iv-p0afi_HJcE2zMiiREg.png"/></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">Image Credit — DigitalOcean</figcaption></figure><p id="9f6d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了！现在，重启NGINX就大功告成了。在访问您的应用程序时检查<em class="ni">“绿锁”</em>，并检查通过<code class="fe mj mk ml mm b">http</code>的访问是否会将您重定向到<code class="fe mj mk ml mm b">https</code></p><p id="8668" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">恭喜你！这样，现在就有了Node.js应用程序，它通过NGINX服务器在HTTPS上提供服务，并对响应应用gzip压缩。</p><p id="6137" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">非常感谢你能走到这一步，我希望这是有用的。请分享这一点，并感谢任何反馈。</p><p id="f9e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要找到这个状态下的代码，请导航到GitHub库的<code class="fe mj mk ml mm b">nginx-2</code>分支——</p><div class="lb lc gp gr ld le"><a href="https://github.com/RyanDsilva/nodejs-in-production" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">RyanDsilva/生产中节点</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">gear:在生产中部署Node.js应用程序的分步指南:gear:-RyanDsilva/nodejs-in-production</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">github.com</p></div></div><div class="ln l"><div class="nx l lp lq lr ln ls lt le"/></div></div></a></div></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="ef01" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">[1]让我们加密(维基百科)——<a class="ae np" href="https://en.wikipedia.org/wiki/Let's_Encrypt" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Let's_Encrypt</a></p></div></div>    
</body>
</html>