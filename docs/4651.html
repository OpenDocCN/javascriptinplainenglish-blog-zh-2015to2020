<html>
<head>
<title>How to make a Twitch profanity filter Chrome extension</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使一个抽搐亵渎过滤器铬扩展</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-make-a-twitch-profanity-filter-chrome-extension-195bce36b38d?source=collection_archive---------7-----------------------#2020-12-28">https://javascript.plainenglish.io/how-to-make-a-twitch-profanity-filter-chrome-extension-195bce36b38d?source=collection_archive---------7-----------------------#2020-12-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1d05634bddb4882217ebf8ff858348a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*YUvWmn8SrVcvh8mP.jpg"/></div></div></figure><p id="a1d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我在这里和那里做了很多与Twitch相关的项目，试图看看有什么可能性。我最近的一个项目是为Chrome创建一个Twitch表情扩展，我展示了如何免费获得额外的表情“槽”。这让我进入了浏览器扩展，所以我想让我们通过为Twitch聊天构建一个脏话过滤器来展示如何从头开始制作一个。</p><p id="8b32" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们希望有一个扩展，当安装时，检查聊天中的一组标记的单词，并用更友好的版本替换它们。例如，这可能对观看视频流的儿童有用。</p><p id="a736" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您只是想要这个扩展的代码，在本文的底部有一个到最终结果的链接。</p><h1 id="d571" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">修补时间</h1><p id="2f14" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">好吧，让我们先进入正题。在你喜欢的地方创建一个文件夹，命名为<strong class="jx io">脏话过滤器</strong>。我在一个与GitHub同步的地方创建了我的。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lx"><img src="../Images/6af64b54bbd205b2eae83bb896bc8e1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kioG9qWmMJpTufNw3IS7A.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Any name will do, but this seems fitting</figcaption></figure><p id="56f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在在这个文件夹中，创建两个新文件:<strong class="jx io"> manifest.json </strong>和<strong class="jx io"> content.js </strong>。当我们开始构建扩展时，您将看到我们将如何使用它们。</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/d08bea607fd7abfafa087a6315339f94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYCbU1uIr6hxGhEhD8jDkw.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">There we go</figcaption></figure><p id="e705" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打开<strong class="jx io"> manifest.json </strong>，这是Google查找关于您的扩展的元数据的文件，并将以下内容粘贴到其中:</p><pre class="ly lz ma mb gt mh mi mj mk aw ml bi"><span id="5ac6" class="mm kv in mi b gy mn mo l mp mq">{</span><span id="914d" class="mm kv in mi b gy mr mo l mp mq">  "manifest_version": 2,</span><span id="f250" class="mm kv in mi b gy mr mo l mp mq">  "name": "Twitch Profanity Filter Extension",</span><span id="7d90" class="mm kv in mi b gy mr mo l mp mq">  "version": "0.1",</span><span id="bce9" class="mm kv in mi b gy mr mo l mp mq">  "content_scripts": [</span><span id="a9af" class="mm kv in mi b gy mr mo l mp mq">    {</span><span id="a9cb" class="mm kv in mi b gy mr mo l mp mq">      "matches": ["https://www.twitch.tv/*"],</span><span id="7297" class="mm kv in mi b gy mr mo l mp mq">      "js": ["content.js"]</span><span id="0f00" class="mm kv in mi b gy mr mo l mp mq">    }</span><span id="32f4" class="mm kv in mi b gy mr mo l mp mq">  ]</span><span id="0f6b" class="mm kv in mi b gy mr mo l mp mq">}</span></pre><p id="5da9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如你所看到的，我们告诉Google这个扩展应该可以在Twitch的任何页面上运行，我们还说应该在这些页面上运行的逻辑驻留在名为<strong class="jx io"> content.js </strong>的文件中。请注意，我将版本设为0.1，因为这是我的第一次尝试。</p><h2 id="4d63" class="mm kv in bd kw ms mt dn la mu mv dp le kg mw mx li kk my mz lm ko na nb lq nc bi translated">获取逻辑</h2><p id="a547" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">现在在你选择的文本编辑器中打开<strong class="jx io"> content.js </strong>。我强烈推荐<a class="ae kt" href="https://code.visualstudio.com/download" rel="noopener ugc nofollow" target="_blank"> Visual Studio Code </a>，它是我用来编辑任何编码相关内容的文本编辑器，而且是免费的。</p><p id="2546" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们将通过几个步骤来设置它。我们想要实现什么，我们如何实现？我们知道我们想要将某些单词改为其他单词，这意味着阅读聊天消息，扫描它们以寻找标记的单词，然后将这些单词更新为更友好的单词。因此，当页面加载时，我们希望我们的逻辑能够做到以下几点:</p><ul class=""><li id="57a0" class="nd ne in jx b jy jz kc kd kg nf kk ng ko nh ks ni nj nk nl bi translated">找到聊天框</li><li id="d004" class="nd ne in jx b jy nm kc nn kg no kk np ko nq ks ni nj nk nl bi translated">每次出现新的聊天消息时，获取消息或消息容器</li><li id="5a7a" class="nd ne in jx b jy nm kc nn kg no kk np ko nq ks ni nj nk nl bi translated">将标记的单词改为友好的对应单词</li></ul><p id="b3cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以让我们开始吧。第一部分实际上是在页面，或者更确切地说是窗口加载后激活脚本。在javascript中，您可以挂接加载事件，我们将这样做。更新您的<strong class="jx io"> content.js </strong>以包含以下内容:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/aecf78390278be103eea50f66e904477.png" data-original-src="https://miro.medium.com/v2/resize:fit:986/format:webp/1*BNR9il5wbgz3LDTLHqqDfg.png"/></div></figure><p id="55b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将确保无论我们在函数中放入什么，当页面加载时都会被调用。</p><h2 id="1363" class="mm kv in bd kw ms mt dn la mu mv dp le kg mw mx li kk my mz lm ko na nb lq nc bi translated">找到聊天框</h2><p id="a976" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">那么我们如何找到聊天框呢？嗯，在Twitch网站的Chrome版本中，聊天框包含在一个<strong class="jx io"> &lt; div &gt; </strong>元素中，该元素有一个名为<em class="ns">聊天滚动区_ _消息容器</em>的类。我们将通过javascript获得该元素或节点。更新文件，如下所示:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/6d14dad67c9234a837e1510668059a33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*njYpWxcBUxpaE4452heomQ.png"/></div></div></figure><p id="132d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们之所以加上<strong class="jx io">。item(0) </strong>在它后面，是因为<strong class="jx io"> getElementsByClassName() </strong>返回一个数组的元素。因为我们知道只有一个元素有这个类，我们通过指定我们想要的第一个东西(大多数编程语言从0开始计数)从数组中获取它。</p><h2 id="d371" class="mm kv in bd kw ms mt dn la mu mv dp le kg mw mx li kk my mz lm ko na nb lq nc bi translated">获取聊天中的每条新消息</h2><p id="4180" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">如果你不习惯编程或者不习惯观察者模式，理解起来就有点棘手了。我们获取每一条新消息的方法是在我们刚刚获得的chatbox节点上使用一个<strong class="jx io">突变观测器</strong>。更新文件以匹配以下内容，然后我们将逐步了解发生了什么:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/7978119d29a3ca90545c91ece408e885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DG_dTLdLb-FTJPnKJfFWdA.png"/></div></div></figure><p id="41c3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，在第4行，我们定义了一个回调函数，它接受一个突变列表和我们将在第8行创建的观察器。每当我们正在观察的节点中发生变化，或者<em class="ns">发生突变</em>，就会调用这个函数中的逻辑。</p><p id="2f55" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第8行，我们创建了观察者，并把回调函数传递给它。然后，在第9行，我们告诉观察者开始观察我们的目标节点，我们将一个配置传递给<strong class="jx io"> childList </strong>表示我们只对突变感兴趣。消息作为子节点出现在我们正在查看的chatbox节点中，所以我们的回调函数将在每次新的聊天消息出现时被触发。这正是我们想要的！</p><p id="f73c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是现在我们仍然需要获得实际的消息元素，为此我们在回调中增加了一行代码:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/bedfb027fc54261a35ba1942add9886c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0bhqWiIkYqEUXqTLjt2K1Q.png"/></div></div></figure><p id="006e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个名字可能看起来有点奇怪，但是消息的所有文本部分(我们没有扫描表情，只是实际的文本)都放在具有类<em class="ns"> text-fragment </em>的<strong class="jx io"> &lt; span &gt; </strong> HTML元素中。此外，因为这个函数在每个新消息时被触发，我们知道我们想要的消息必须是chatbox节点中的最后一个元素，所以这就是为什么我们要获取<strong class="jx io"> lastElementChild </strong>。</p><h2 id="d77f" class="mm kv in bd kw ms mt dn la mu mv dp le kg mw mx li kk my mz lm ko na nb lq nc bi translated">将标记的单词改为友好的对应单词</h2><p id="b541" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">让我们进入有趣的部分。如果我们想要改变被标记的单词，我们首先需要一些东西来告诉我们什么是被标记的单词以及它们的对应词。我们将通过使用一个简单的字典来做到这一点。更新文件，如下所示:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/78b4af1c6ed06dea9c8c35036f31c140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2Xv9DlrVQtL4jT3KHDy6CA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">You can add more words as you like, just remember the comma at the end</figcaption></figure><p id="536a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们将读取所有<em class="ns">文本片段</em>元素中的实际文本，循环所有禁用的单词，并在必要时替换它们。让我们开始这个循环，用下面的代码更新你的回调函数:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/eb3557a746e6a0414754283d54778fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g8Ur4_PF6cW9j6o-naoi9w.png"/></div></div></figure><p id="4aad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里发生的事情是，我们正在遍历所有这些包含文本的元素。在第18行，我们一次取一个特定的元素，在第19行，我们从它那里得到小写的实际文本，因为我们标记的单词也都是小写的。这使得比较更加容易，但是在更高级的版本中，我们会注意保持大小写的整洁。现在我们有了文本，我们想要循环我们标记的单词，并检查它们是否存在。如果是这样，我们删除它们。更新功能:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ny"><img src="../Images/daae9d0afca9318db2b3299aec296bff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EBzYYMxUJXCD0-zNSi4ewg.png"/></div></div></figure><p id="1473" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们制作的字典使用键-值对，其中键是标记的单词，值是友好的单词，所以在第21行我们简单地得到所有键的数组，这是我们想要循环的标记单词的数组。在循环中，我们获取当前正在查看的标记单词，如果我们的文本包含一个或多个标记单词，我们将获取友好单词，并通过替换标记单词来更新我们的文本。这几乎就是全部，现在我们只需要把我们新的和改进的文本放回我们获取它的元素中:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nz"><img src="../Images/c7a133044b834ebea920986c128d121b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*97Z2oD7EM65mclFI5H9ZWg.png"/></div></div></figure><p id="7b1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在第31行，我们已经将文本放回元素中，就这样！让我们在Chrome上测试一下。</p><h1 id="b666" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">测试</h1><p id="1d0c" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">打开Chrome，浏览到<strong class="jx io"> chrome://extensions </strong>。你应该会看到你的扩展，在右上角你会看到<strong class="jx io">开发者模式</strong>。如果还没有打开，就打开它。之后，在右上方，您会看到<strong class="jx io">加载解包</strong>选项。我们将使用它来加载我们的本地扩展，而不必通过Chrome网络商店。单击它并选择文件所在的文件夹:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oa"><img src="../Images/37d6579a35a8e9afadcdf1a6c66facb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HAlCyhhsO-47SKg-wfXczQ.png"/></div></div></figure><p id="d074" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这应该会使它立即出现在我们的扩展列表中:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/7534dabfaf3364e57f5ef1a47863b921.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*8Hrs67JcEZvOGm2U4nzaJw.png"/></div></figure><p id="693c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">很好！现在让我们去任何可以聊天的频道。我会去我的朋友<a class="ae kt" href="http://twitch.tv/bjarkeeeee" rel="noopener ugc nofollow" target="_blank"> Bjarke的频道</a>，一个热闹的丹麦流光，并尝试它:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/675ef7445aa022e2d95ffaa6665595cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:502/format:webp/1*ikDatLIP_H1Y8nuyAlAi0g.png"/></div></figure><p id="f1f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好了，成功了！我们自己的脏话过滤器。不是很难，对吧？剩下的就是发布到Chrome网上商店，如果你愿意的话。我将扩展这个单词列表并发布它，所以如果你不需要更多，你不必发布它，因为它需要一笔费用才能进入这个程序。我不会深入讨论这个版本是如何工作的，但是如果你感兴趣，我做了一个<a class="ae kt" href="https://chrome.google.com/webstore/detail/bjarkeeeee-emote-extensio/igpdgcgafncbamkndjppepompjlkaeoj" rel="noopener ugc nofollow" target="_blank"> Twitch表情扩展</a>来获得你自己的无限表情槽<a class="ae kt" href="https://nintendoengineer.medium.com/how-to-get-infinitely-more-twitch-emote-slots-7eb17ee9a6a1" rel="noopener">这篇文章</a>解释了如何在最后发布扩展。</p><p id="437f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想看到这个扩展的所有代码，请点击这里查看GitHub repo<a class="ae kt" href="https://github.com/NintendoEngineer/twitch/tree/main/extensions/profanity-filter" rel="noopener ugc nofollow" target="_blank"/>。快乐编码！</p></div></div>    
</body>
</html>