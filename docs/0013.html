<html>
<head>
<title>React Context API with Higher Order Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将上下文API与高阶组件进行反应</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-context-api-with-higher-order-component-279d5f93eda4?source=collection_archive---------2-----------------------#2018-07-07">https://javascript.plainenglish.io/react-context-api-with-higher-order-component-279d5f93eda4?source=collection_archive---------2-----------------------#2018-07-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4d31" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如大多数人已经知道的那样，我们可以使用上下文API将道具从父组件传递到其子组件或孙组件，而无需通过每个子组件向下钻取(传递)道具。</p><h2 id="4ee4" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">故事时间:</h2><p id="3690" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">就好像我的曾祖父保存了一个宝藏，并告诉了整个家族。所以他的任何血统都可以访问它，而不需要得到他们上一代(也就是父母)的许可。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/aa21d8959c1d638fafef6fc5612cbc3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*aFJVQ4H7iQALcN_68DFahw.gif"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">I don’t need to ask my Dad ?</figcaption></figure><p id="3b24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">他非常有创造力，他为家庭定制了更具体的宝藏，增加了功能(即定制提供商)，因此如果他们需要使用魔法钥匙(即定制消费者)，他的血统可以利用它。</p><h2 id="29f8" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">现实:</h2><p id="3f71" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">让我们使用上下文API来创建我们讨论过自定义宝藏和魔术密钥。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h2 id="91c3" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">创建上下文:</h2><p id="94dd" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">我们将确保react contextAPI创建神奇的宝盒。我们可以在声明<code class="fe lu lv lw lx b">createContext</code>时传递默认值</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h2 id="3ca6" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">声明提供者:</h2><p id="6c2a" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">这将作为我们的应用程序可以使用的自定义提供程序。他们所要做的就是用<code class="fe lu lv lw lx b">&lt;TreasureProvider&gt;</code>包装他们的根组件，并传递props。在我们的例子中，他们必须通过<code class="fe lu lv lw lx b">asset</code>。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h2 id="e013" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">添加额外功能</h2><p id="ce7f" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">这是可选的javascript类，它有一些助手方法，我们可以将这些方法传递给我们的<code class="fe lu lv lw lx b">&lt;TreasureProvider&gt;</code>的消费者。在子组件中(即消费者)可以访问这个类的任何方法。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h2 id="1322" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">创建特设消费者(魔术钥匙)</h2><p id="a35c" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">接受WrappedComponent并从TreasureBox注入props的高阶组件。因此，每当子组件用<code class="fe lu lv lw lx b">withMagicKey</code>包装时，它会自动从<code class="fe lu lv lw lx b">&lt;TreasureProvider&gt;</code>获取所有细节。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h2 id="733b" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">在应用程序中使用它:</h2><p id="e19c" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">现在让我们在实际应用中使用我们刚刚创建的特定上下文API。为了简单起见，我将只发布根组件，即<code class="fe lu lv lw lx b">App.js</code>和子组件<code class="fe lu lv lw lx b">FirstChild.js</code>。</p><p id="567a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">用<code class="fe lu lv lw lx b">&lt;TreasureProvider&gt;</code>包装<code class="fe lu lv lw lx b">App.js</code>，这样我们就可以让contextAPI对整个应用程序可用。请记住，我们在用<code class="fe lu lv lw lx b">&lt;TreasureProvider&gt;</code>包装时会将<code class="fe lu lv lw lx b">asset</code>作为道具传递。</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="2261" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们已经添加了自定义提供者，我们可以通过用<code class="fe lu lv lw lx b">withMagicKey</code>包装组件来从子组件或孙组件中检索上下文</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="ls lt l"/></div></figure><h2 id="bb27" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">控制台输出:</h2><pre class="lh li lj lk gt ly lx lz ma aw mb bi"><span id="5e6b" class="ki kj in lx b gy mc md l me mf">Anderson's family has asset worth of $200000000  CustomFeature.js:18</span></pre></div></div>    
</body>
</html>