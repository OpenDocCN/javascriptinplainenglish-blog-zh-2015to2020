<html>
<head>
<title>JavaScript Best Practices — ES6 Features and Regex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践— ES6特性和正则表达式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-es6-features-and-regex-40a1bcbe6026?source=collection_archive---------7-----------------------#2020-05-20">https://javascript.plainenglish.io/javascript-best-practices-es6-features-and-regex-40a1bcbe6026?source=collection_archive---------7-----------------------#2020-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/edd2e5dbaa8a99a449f8d2ee69d83d15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KiErV7preXZm8D3W"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@shane_young?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Shane Young</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b2bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="b841" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究模板标记间距、包装正则表达式和箭头函数体。</p><h1 id="97ec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">模板标记和它们的文字之间的间距</h1><p id="2556" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">从ES6开始，随着模板字符串的引入，引入了一种称为模板标签的新功能。</p><p id="5370" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们只适用于模板字符串。这是一个接受一些参数的函数，包括模板字符串本身及其组成部分。</p><p id="460e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过定义一个模板文字标签来使用模板标签，用法如下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ab89" class="mn lc iq mj b gy mo mp l mq mr">const foo = (strings, ...args) =&gt; {<br/>  console.log(strings, args);<br/>}</span><span id="f842" class="mn lc iq mj b gy ms mp l mq mr">const a = 1;<br/>const b = 2;<br/>foo`foo ${a} bar ${b}`</span></pre><p id="0d08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们定义了<code class="fe mt mu mv mj b">foo</code>文字标签，它有一个<code class="fe mt mu mv mj b">strings</code>参数，这个参数有一个静态字符串所有部分的数组。</p><p id="5139" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">args</code>参数是一个数组，包含字符串中所有插值的值。</p><p id="23f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，根据控制台日志输出的<code class="fe mt mu mv mj b">string</code>的值是<code class="fe mt mu mv mj b">[“foo “, “ bar “, “”, raw: Array(3)]</code>，而<code class="fe mt mu mv mj b">args</code>的值是<code class="fe mt mu mv mj b"> [1, 2]</code>，这是我们内插到字符串中的2个值。</p><p id="7bbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模板文字标签对于获取模板字符串的一部分，然后从中返回某些内容非常有用。</p><p id="e96f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，我们在模板文字标记名和模板字符串本身之间没有任何空格。</p><p id="65ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在上面的代码中一样，我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1b00" class="mn lc iq mj b gy mo mp l mq mr">foo`foo ${a} bar ${b}`</span></pre><p id="1d5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mt mu mv mj b">foo</code>和开始的反勾号之间没有空格，所以很明显我们是在紧随其后的模板字符串上调用<code class="fe mt mu mv mj b">foo</code>。</p><h1 id="622d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">换行正则表达式文本</h1><p id="cc24" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">正则表达式可以被包装，这样我们就清楚我们在正则表达式上调用了一个方法。</p><p id="dda6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想如下调用<code class="fe mt mu mv mj b">exec</code>函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7ea7" class="mn lc iq mj b gy mo mp l mq mr">const result = /foo/.exec("foo");</span></pre><p id="826e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么人们可能不知道我们实际上在它上面调用了<code class="fe mt mu mv mj b">exec</code>方法。</p><p id="12ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们用括号将正则表达式括起来，那么我们可以编写以下代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e416" class="mn lc iq mj b gy mo mp l mq mr">const result = (/foo/).exec("foo");</span></pre><p id="d5dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么对于一些人来说，我们在<code class="fe mt mu mv mj b">/foo/</code>正则表达式上调用<code class="fe mt mu mv mj b">exec</code>可能会更清楚。</p><p id="511e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个语法更像是一个可选的建议，而不是每个人都应该遵循的。</p><h1 id="fc48" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">箭头函数体中的大括号</h1><p id="2cee" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">箭头函数是较短的函数，不绑定到像<code class="fe mt mu mv mj b">this</code>或<code class="fe mt mu mv mj b">arguments</code>这样的变量。</p><p id="36a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不能将它们用作构造函数，也不能在其上使用<code class="fe mt mu mv mj b">bind</code>、<code class="fe mt mu mv mj b">call</code>或<code class="fe mt mu mv mj b">apply</code>。</p><p id="0287" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还让我们以更短的方式编写函数。它的一个好处是，如果我们返回的东西和arrow函数的签名在同一行，那么我们就不需要关键字<code class="fe mt mu mv mj b">return</code>来返回函数末尾的项目。</p><p id="0a85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，函数末尾的内容将被返回。</p><p id="d4f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于多行箭头函数，return语法的工作方式与任何其他函数相同。我们需要关键字<code class="fe mt mu mv mj b">return</code>来返回一些东西。</p><p id="390b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cf29" class="mn lc iq mj b gy mo mp l mq mr">const foo = () =&gt; 2;</span></pre><p id="90b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后由<code class="fe mt mu mv mj b">foo</code>函数返回2。</p><p id="d331" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想返回一个对象，我们可以编写下面的代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fac6" class="mn lc iq mj b gy mo mp l mq mr">const foo = () =&gt; ({<br/>  a: 1,<br/>  b: 2<br/>});</span></pre><p id="0408" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们返回用括号括起来的对象，所以当我们调用<code class="fe mt mu mv mj b">foo</code>时，我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a7c0" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  a: 1,<br/>  b: 2<br/>}</span></pre><p id="a00b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">已退回。</p><p id="c4f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有一个多行函数，那么return语法的工作方式和其他函数一样。</p><p id="0a50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们编写以下代码来返回多行函数中的内容:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="18b1" class="mn lc iq mj b gy mo mp l mq mr">const foo = () =&gt; {<br/>  return {<br/>    a: 1,<br/>    b: 2<br/>  }<br/>};</span></pre><p id="3232" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，<code class="fe mt mu mv mj b">foo</code>函数的第二行有<code class="fe mt mu mv mj b">return</code>语句。</p><p id="2654" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们调用<code class="fe mt mu mv mj b">foo</code>，我们会得到与前面的<code class="fe mt mu mv mj b">foo</code>函数相同的结果。</p><p id="8250" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，对于在函数的第一行返回的函数，我们不需要大括号。不然就要加大括号。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/a3694c101b5c7875e84f702d2fa903a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KxNxkn5OIyKw7xxz"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@hpzworkz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hassan Pasha</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="9f57" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="9ac0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">正则表达式可以用括号括起来，这样我们就可以清楚地知道我们是在对它调用方法。</p><p id="66cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常，我们不在模板标签名和模板字符串文字之间加空格，这样我们就清楚我们是在操作它。</p><p id="5c78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果箭头函数在第一行返回一些东西，它们通常没有大括号。</p><p id="8ea7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们需要大括号和<code class="fe mt mu mv mj b">return</code>关键字来返回一些东西。</p><h1 id="963b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简明英语笔记</h1><p id="7788" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们推出了一个YouTube频道吗？我们制作的每个视频都旨在教给你一些新的东西。点击此处 查看我们，并确保订阅该频道😎</p></div></div>    
</body>
</html>