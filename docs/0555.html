<html>
<head>
<title>How I used JavaScript generators to create a Casino game cards shuffler 🃏</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何使用JavaScript生成器创建一个赌场游戏纸牌洗牌机🃏</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-i-used-javascript-generators-to-create-a-casino-game-cards-shuffler-fef4f796110f?source=collection_archive---------2-----------------------#2019-11-07">https://javascript.plainenglish.io/how-i-used-javascript-generators-to-create-a-casino-game-cards-shuffler-fef4f796110f?source=collection_archive---------2-----------------------#2019-11-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a491" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过一个简单的例子理解JavaScript生成器的用途，让您的编程技能更上一层楼。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c8186895e15b21e79d7f6b25a8fe08c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SOi4dmvN6zV5tU36t006qw.png"/></div></div></figure><h1 id="3155" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">👨🏻‍🔬什么是发电机功能？</h1><blockquote class="lj lk ll"><p id="08a8" class="lm ln lo lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">生成器是可以用来控制迭代器的函数。它们可以暂停，以后随时恢复。</p></blockquote><p id="5aa8" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">发电机很酷的一点是它们可以是无限的。无限意味着您可以遍历一个无限的数据集，比如一个新闻提要或一个无限的图像转盘。</p><p id="efa7" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">您可以毫无问题地在生成器函数中使用一个<code class="fe mm mn mo mp b">while(true)</code>循环来实现这个无限的目标。这在经典编程中被认为是没有意义的，是崩溃的结果，但是这是完全合法的。</p><p id="c13f" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">听起来很奇怪，不是吗？这篇文章是关于生成器函数的实现，但是<strong class="lp ir">在深入之前:我邀请你看一下这篇文章，这将帮助你理解与标准循环相比的生成器的基础。</strong></p><div class="mq mr gp gr ms mt"><a href="https://codeburst.io/what-are-javascript-generators-and-how-to-use-them-c6f2713fd12e" rel="noopener follow" target="_blank"><div class="mu ab fo"><div class="mv ab mw cl cj mx"><h2 class="bd ir gy z fp my fr fs mz fu fw ip bi translated">什么是JavaScript生成器以及如何使用它们</h2><div class="na l"><h3 class="bd b gy z fp my fr fs mz fu fw dk translated">在本文中，我们将看看ECMAScript 6中引入的生成器。我们会看到它…</h3></div><div class="nb l"><p class="bd b dl z fp my fr fs mz fu fw dk translated">codeburst.io</p></div></div><div class="nc l"><div class="nd l ne nf ng nc nh kp mt"/></div></div></a></div></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="1630" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">发电机为引擎盖下的异步/等待功能供电。你可以看看从Typescript playground编译而来的<a class="ae np" href="http://www.typescriptlang.org/play/?target=2&amp;ssl=1&amp;ssc=1&amp;pln=4&amp;pc=2#code/IYZwngdgxgBAZgV2gFwJYHsI2QUxMgCgEoYBvAKBipik3xmBgF4GB3YVZGABQCd0AtqhA4AdLzzoANgDccBAEQAJHFKnoFRANyVqtCCGlj1AcwLBt5AL5A" rel="noopener ugc nofollow" target="_blank">这段代码</a>，它给了你一个很好的例子。</p><p id="81cd" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">在右边的面板中，您将看到我们的生成器代码转换后的输出。</p><p id="328a" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">看到<code class="fe mm mn mo mp b">yield Promise.resolve("hello");</code>语句了吗？你在一个发电机里，就是这样。</p><p id="7d19" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">对于任何基于循环的代码，如状态机、序列或任何游戏循环，生成器都非常酷。</p><p id="08a1" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">说到游戏循环，今天的文章是关于一个洗牌机，这是一种纸牌拾取循环系统。你可能已经在赌场见过这样的机器了？这是用来给庄家洗牌的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/f51856aa76e9f132cf0fe6ad1be3e994.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*HCkDtPaUWvBPRwR3.jpg"/></div></figure><h1 id="7258" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">🃏My洗牌机级别</h1><p id="0a7f" class="pw-post-body-paragraph lm ln iq lp b lq nr jr ls lt ns ju lv mj nt ly lz mk nu mc md ml nv mg mh mi ij bi translated">接下来是一个52张牌经典洗牌机的简单实现。</p><p id="7b12" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">✋🏻⚠️ <strong class="lp ir">这不适合生产使用</strong>，因为随机洗牌算法是一种伪随机洗牌算法。如果每秒钟多次调用这个函数，可能会导致重复的条目。</p><p id="edbe" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated"><strong class="lp ir">💡你可能会对阅读这篇文章感兴趣:</strong><a class="ae np" href="https://www.random.org/randomness/" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir">https://www.random.org/randomness/</strong></a><strong class="lp ir">，它很好地解释了计算机科学中的随机值。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/da295bca7c03d0e3cc504913f63b7695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*Vf5a6w9ev6VtlE6CWOIFLQ.png"/></div></figure><p id="5270" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">这个洗牌机将使用<code class="fe mm mn mo mp b">lodash</code> <code class="fe mm mn mo mp b">_.shuffle</code>方法随机洗牌一个代表整个52副扑克牌的数组。</p><p id="3410" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated"><a class="ae np" href="https://lodash.com/docs/4.17.15#shuffle" rel="noopener ugc nofollow" target="_blank"> <strong class="lp ir"> Lodash </strong> </a>是一个JS库，它为许多公共用例提供了一个强大工具箱。</p><p id="4a5f" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">洗牌将使用<a class="ae np" href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" rel="noopener ugc nofollow" target="_blank"><strong class="lp ir">Fisher–Yates洗牌算法</strong> </a>完成，如果你想了解更多，请点击维基百科的链接。</p><p id="0a97" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">所有的牌都将由经典的方块(、梅花(♣)、红心(♥)和黑桃(♠)及其数字代表。</p><p id="cc18" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">每次迭代将返回一对代表卡片的<strong class="lp ir">类型</strong> — <strong class="lp ir">值</strong>，允许在UI中显示合适的卡片。</p><p id="c3af" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">这是一张<strong class="lp ir">游戏卡</strong>的界面合约:</p><pre class="kg kh ki kj gt nx mp ny nz aw oa bi"><span id="cc36" class="ob ks iq mp b gy oc od l oe of">interface GameCard {<br/> type: ♥️ | ♦️ | ♠️ | ♣️, <br/> value: "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "J" | "Q" | "K"<br/>}</span></pre><p id="9659" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">我们可以得到一张名为<code class="fe mm mn mo mp b">{"type": "</code> ♠️ <code class="fe mm mn mo mp b">", value:"1"}</code>的牌，代表黑桃a🂡。</p><h2 id="0c2e" class="ob ks iq bd kt og oh dn kx oi oj dp lb mj ok ol ld mk om on lf ml oo op lh oq bi translated">💻卡洗牌机的全部代码在一个片段中</h2><blockquote class="lj lk ll"><p id="a3dd" class="lm ln lo lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated"><strong class="lp ir"> <em class="iq"> ❓ </em>它是如何工作的？</strong></p></blockquote><p id="a1a1" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">很简单，所有事情都包含在三个步骤中:</p><ol class=""><li id="2005" class="or os iq lp b lq lr lt lu mj ot mk ou ml ov mi ow ox oy oz bi translated">首先，将一副牌作为数组传递给CardShuffler构造函数，它将随机洗牌。</li><li id="582f" class="or os iq lp b lq pa lt pb mj pc mk pd ml pe mi ow ox oy oz bi translated">然后，通过调用<code class="fe mm mn mo mp b">getCardDrawer</code>初始化生成器迭代器，它返回我们这个游戏循环的主要工具。</li><li id="9ff3" class="or os iq lp b lq pa lt pb mj pc mk pd ml pe mi ow ox oy oz bi translated">享受使用发电机要求新的卡，一遍又一遍，直到甲板变空。</li></ol><p id="0e86" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">为了演示的简单，在给定的例子中，该副牌仅由4张牌组成。随意添加一副真正的52张牌来反映现实生活中的例子和更好的随机性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pf pg l"/></div></figure><h2 id="3920" class="ob ks iq bd kt og oh dn kx oi oj dp lb mj ok ol ld mk om on lf ml oo op lh oq bi translated">🎮游戏循环</h2><p id="3292" class="pw-post-body-paragraph lm ln iq lp b lq nr jr ls lt ns ju lv mj nt ly lz mk nu mc md ml nv mg mh mi ij bi translated">一旦实例化了<code class="fe mm mn mo mp b">GameShuffler</code>类并且构造函数洗出了整副牌:您可以调用<code class="fe mm mn mo mp b">getCardDrawer</code>方法来获得迭代器，该迭代器将用于一张一张地绘制每张牌。</p><p id="23d8" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">➡️(至少)有两种方法可以迭代游戏循环:</p><p id="9e01" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated"><strong class="lp ir"> ❶使用某种事件手动遍历生成器</strong></p><p id="b55d" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">在这个示例中，我们创建了一个函数，它可以绑定到任何事件处理程序，比如单击按钮，或者通过调用该函数来手动触发。</p><p id="c2ef" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">每个生成器的迭代器公开一个<code class="fe mm mn mo mp b">.next</code>方法，该方法将执行生成器函数中的代码到下一个<code class="fe mm mn mo mp b">yield</code>语句。</p><p id="623a" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">解释器将每次迭代while循环来检查牌组的大小，如果牌组中还有剩余的牌，将从牌组中取出一张新的牌。</p><p id="e8eb" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">然后它会在<code class="fe mm mn mo mp b">yield</code>语句处阻塞代码执行，直到我们再次调用迭代器的<code class="fe mm mn mo mp b">.next</code>函数。</p><pre class="kg kh ki kj gt nx mp ny nz aw oa bi"><span id="2cc9" class="ob ks iq mp b gy oc od l oe of">const onClick = () =&gt; {<br/>  const nextCardStatus = cardDrawer1.next();</span><span id="60ac" class="ob ks iq mp b gy ph od l oe of">  if (nextCardStatus.done) {<br/>    console.log("Deck is now empty!");<br/>  } else {<br/>    console.log("Picked card is: ", nextCardStatus.value.card);<br/>    console.log("Remaining cards in the deck: ", nextCardStatus.value.remainingCards);<br/>  }<br/>};</span></pre><p id="0336" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">每次我们从这副牌中抽出一张牌，这张牌就被取走了。一旦游戏面板是空的，我们就退出循环，生成器完成。</p><p id="c07d" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">你需要实例化一个新的<strong class="lp ir">洗牌机</strong>来玩另一个游戏。</p><p id="d399" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated"><strong class="lp ir"> ❷使用for…of运算符对生成器进行迭代</strong></p><p id="658c" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">生成器的迭代器也可以在Javascript语言循环中使用，如果我们使用作为ES6规范一部分的<code class="fe mm mn mo mp b">for…of</code>操作符就是这种情况。</p><pre class="kg kh ki kj gt nx mp ny nz aw oa bi"><span id="6ff6" class="ob ks iq mp b gy oc od l oe of">for (const cardStatus of cardDrawer2) {<br/>  console.log("Picked card is: ", cardStatus.card);<br/>  console.log("Remaining cards in the deck: ", cardStatus.remainingCards);<br/>}</span></pre><p id="505c" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">这允许我们迭代通过卡片序列，只要卡片组中有卡片。</p><p id="36b1" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">这只是一种语法糖，帮助你循环遍历迭代器。但实际上，这只是调用<code class="fe mm mn mo mp b">next</code>方法或迭代器，并检查返回对象的<code class="fe mm mn mo mp b">done</code>和<code class="fe mm mn mo mp b">value</code>键，以确定生成器是否已经完成。</p><h1 id="48d4" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">🚛外卖/TLDR；📦</h1><p id="3eb1" class="pw-post-body-paragraph lm ln iq lp b lq nr jr ls lt ns ju lv mj nt ly lz mk nu mc md ml nv mg mh mi ij bi translated">生成器是很好的工具，支持更好的异步功能、无限的数据流、惰性评估、内存高效的迭代。</p><p id="54ad" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">通过增强循环过程，它们可以使您的代码更具可读性和性能。对于像<a class="ae np" href="https://redux-saga.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux-Saga </a>这样的状态机来说，它们是非常强大的。</p><p id="62e6" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">它们非常适合在无限数据流上进行任何基于序列/循环的迭代。</p><p id="f4cf" class="pw-post-body-paragraph lm ln iq lp b lq lr jr ls lt lu ju lv mj lx ly lz mk mb mc md ml mf mg mh mi ij bi translated">你绝对应该试一试！</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pi pg l"/></div></figure></div></div>    
</body>
</html>