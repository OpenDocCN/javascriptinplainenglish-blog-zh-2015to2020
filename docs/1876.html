<html>
<head>
<title>Unit Test Your JavaScript Code Without a Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在没有框架的情况下对JavaScript代码进行单元测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/unit-test-front-end-javascript-code-without-a-framework-8f00c63eb7d4?source=collection_archive---------2-----------------------#2020-05-01">https://javascript.plainenglish.io/unit-test-front-end-javascript-code-without-a-framework-8f00c63eb7d4?source=collection_archive---------2-----------------------#2020-05-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ad2755cd9a6e0c0c1687459e4621e547.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ITKCUsaehSB8Wxzp"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ad55" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最近，我正在学习在没有任何库或框架帮助的情况下编写越来越多的JavaScript代码。我喜欢对我写的任何代码都有一个良好的单元测试覆盖率，因为每当我想重构我的代码或出于任何其他原因改变它时，这给了我信心。在这篇博文中，我展示了如何在没有任何框架的情况下编写单元测试。</p><p id="95df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将从创建两个文件开始:</p><ul class=""><li id="2888" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><code class="fe lh li lj lk b">test.js</code>包含我们测试需要的测试函数<code class="fe lh li lj lk b">assert</code>和<code class="fe lh li lj lk b">it</code>。它还包含所有的单元测试。</li><li id="dbe2" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated"><code class="fe lh li lj lk b">test.html</code>是试跑者。</li></ul><h1 id="e34e" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">测试功能</h1><p id="855c" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">让我们首先创建一个<code class="fe lh li lj lk b">test.js</code>文件，并编写如下所示的<code class="fe lh li lj lk b">it</code>函数</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="de21" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lh li lj lk b">it</code>函数有两个参数。第一个参数<code class="fe lh li lj lk b">desc</code>是测试用例的描述，第二个参数<code class="fe lh li lj lk b">fn</code>是测试函数。<code class="fe lh li lj lk b">fn</code>封装在<code class="fe lh li lj lk b">try/catch</code>块中。如果<code class="fe lh li lj lk b">fn</code>成功执行，我们将在控制台显示成功消息，如果测试失败，我们将在控制台显示失败消息。</p><p id="cc05" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们在<code class="fe lh li lj lk b">test.js</code>中实现<code class="fe lh li lj lk b">assert</code>功能。</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7029" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lh li lj lk b">assert</code>函数带一个参数<code class="fe lh li lj lk b">isTrue</code>，这个参数是一个条件，比如<br/> <code class="fe lh li lj lk b">x === y</code>。<code class="fe lh li lj lk b">assert</code>检查条件，如果条件为<code class="fe lh li lj lk b">false</code>则抛出错误。</p><p id="35f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样。这是我们的整个测试框架。</p><h1 id="f668" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">测试跑步者</h1><p id="1ff4" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated"><code class="fe lh li lj lk b">test.html</code>是我们的测试运行程序，它包含了<code class="fe lh li lj lk b">test.js</code>文件。</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="1e8c" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">测试框架的简单测试用例</h1><p id="e314" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">让我们通过编写几个简单的测试来确保我们的测试框架按预期工作。</p><h2 id="ced7" class="mz lr in bd ls na nb dn lw nc nd dp ma kl ne nf me kp ng nh mi kt ni nj mm nk bi translated"><strong class="ak">测试失败</strong></h2><p id="b04a" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">在<code class="fe lh li lj lk b">test.js</code>中的<code class="fe lh li lj lk b">assert</code>函数后编写以下测试用例</p><pre class="mt mu mv mw gt nl lk nm nn aw no bi"><span id="d0a1" class="mz lr in lk b gy np nq l nr ns">it('should fail', function() {<br/>  assert(1 !== 1);<br/>});</span></pre><p id="4f4c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在浏览器中打开测试运行器文件<code class="fe lh li lj lk b">test.html</code>(最好是Chrome)。打开浏览器控制台。您应该会在控制台中看到如下所示的失败消息</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/e319fd3eddb42cd01b6137c3d10cca39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BycvxbF5alIxcVIWnejijg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Sample Test Fail Message</figcaption></figure><p id="f7aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于<code class="fe lh li lj lk b">1 !== 1</code>是无效条件，测试失败。通过查看错误堆栈，您可以了解故障发生的位置。在这种情况下，我会检查test.js中的第26行，开始调试这个问题。</p><h2 id="1466" class="mz lr in bd ls na nb dn lw nc nd dp ma kl ne nf me kp ng nh mi kt ni nj mm nk bi translated">通过测试</h2><p id="e9a4" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">现在让我们在<code class="fe lh li lj lk b">test.js</code>写一个小的通过测试。</p><pre class="mt mu mv mw gt nl lk nm nn aw no bi"><span id="93be" class="mz lr in lk b gy np nq l nr ns">it('should pass', function() {<br/>  assert(1 === 1);<br/>});</span></pre><p id="2c23" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">刷新浏览器中的<code class="fe lh li lj lk b">test.html</code>并检查控制台。您应该会在控制台中看到如下所示的成功消息</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nu"><img src="../Images/c0b94e5f11c406ade926af32642cc2fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BZC_TDImqU1rErJi4OtiAw.png"/></div></div></figure><p id="037a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">太好了！我们的测试框架似乎运行良好。现在，让我们将我们的测试框架用于一些真实的场景。</p><h1 id="b094" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">创建应用程序代码文件</h1><p id="65fc" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">通常，您将在一个单独的JavaScript文件中编写应用程序代码，比如<code class="fe lh li lj lk b">app.js</code>。让我们创建<code class="fe lh li lj lk b">app.js</code>文件</p><pre class="mt mu mv mw gt nl lk nm nn aw no bi"><span id="63b5" class="mz lr in lk b gy np nq l nr ns">                           /* app.js */</span><span id="8245" class="mz lr in lk b gy nv nq l nr ns">(function(){<br/>  'use strict';</span><span id="ab2a" class="mz lr in lk b gy nv nq l nr ns">  //Create a global variable and expose it to the world<br/>  var $myapp = {};<br/>  self.$myapp = $myapp;</span><span id="6685" class="mz lr in lk b gy nv nq l nr ns">})();</span></pre><p id="75eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们创建了一个全局变量<code class="fe lh li lj lk b">$myapp</code>，并将其公开，这样我们就可以从<code class="fe lh li lj lk b">test.js</code>文件中调用这个全局变量。始终为全局变量使用唯一的名称，以免与其他全局变量冲突。</p><p id="6bdf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们将<code class="fe lh li lj lk b">app.js</code>文件包含在<code class="fe lh li lj lk b">test.html</code>中，如下所示</p><pre class="mt mu mv mw gt nl lk nm nn aw no bi"><span id="4058" class="mz lr in lk b gy np nq l nr ns">                           /* test.html */<br/>...<br/>&lt;body&gt;<br/>  ...<br/>  &lt;script src="app.js"&gt;&lt;/script&gt;<br/>  &lt;script src="test.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;</span></pre><p id="49a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">确保<code class="fe lh li lj lk b">app.js</code>包含在和<code class="fe lh li lj lk b">test.js</code>之前的<em class="nw"/></p><h1 id="5e00" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">在应用程序代码中测试方法</h1><p id="8bef" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">让我们在<code class="fe lh li lj lk b">app.js</code>文件中编写一个日期验证方法</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1079" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lh li lj lk b">isValidDate</code>判断给定的日期字符串是否有效，并返回<code class="fe lh li lj lk b">true</code>或<code class="fe lh li lj lk b">false</code>。</p><p id="8e1b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们在<code class="fe lh li lj lk b">test.js</code>中为这个方法写一个测试用例</p><pre class="mt mu mv mw gt nl lk nm nn aw no bi"><span id="9dfe" class="mz lr in lk b gy np nq l nr ns">//test.js</span><span id="9e8a" class="mz lr in lk b gy nv nq l nr ns">...<br/>it('should validate a date string', function () {</span><span id="4533" class="mz lr in lk b gy nv nq l nr ns">  // Valid Date<br/>  assert($myapp.isValidDate('02/02/2020'));</span><span id="e667" class="mz lr in lk b gy nv nq l nr ns">  // Invalid Date<br/>  assert(!$myapp.isValidDate('01/32/2020'));</span><span id="572d" class="mz lr in lk b gy nv nq l nr ns">});<br/>...</span></pre><p id="c1a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的测试案例中，第一个断言检查有效的日期字符串，第二个断言检查无效的日期字符串。打开或刷新<code class="fe lh li lj lk b">test.html</code>测试运行器文件并检查控制台。您应该会看到如下消息</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/78eb2ede871caacd94a43c0a60e95f34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PykOhubPG8_zuyx16EbIoQ.png"/></div></div></figure><h1 id="7936" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">测试DOM</h1><p id="bdda" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">假设我们正在编写一个简单的待办事项列表应用程序。我们有一个带有输入字段的表单，用于输入待办事项和提交按钮。我们监听我们的<code class="fe lh li lj lk b">app.js</code>文件中的提交事件，事件处理程序更新DOM中的todo列表。</p><p id="d7b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是html代码</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="308f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是<code class="fe lh li lj lk b">app.js</code>中更新待办事项列表的JavaScript代码。</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="5bf3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们想要测试JavaScript代码，并确保它像预期的那样向DOM中的<code class="fe lh li lj lk b">#todo-list</code>无序列表元素添加了一个todo项。</p><h2 id="a394" class="mz lr in bd ls na nb dn lw nc nd dp ma kl ne nf me kp ng nh mi kt ni nj mm nk bi translated">DOM的测试用例</h2><p id="4841" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">下面是检查事件处理程序代码的测试用例，以确保它在输入新的todo项时更新DOM</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8ff9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的<code class="fe lh li lj lk b">test.html</code>中，我们创建了一个占位符元素<code class="fe lh li lj lk b">&lt;div id="selector"&gt;&lt;/div&gt;</code>来将测试代码插入到我们的测试运行人员的DOM中。</p><p id="1704" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在测试用例中，<code class="fe lh li lj lk b">var selector = document.querySelector('#selector')</code>获得了对占位符元素的引用。然后我们将id为<code class="fe lh li lj lk b">aform</code>的表单追加到<code class="fe lh li lj lk b">selector</code>中。我们必须确保所有的元素名称和id都与<code class="fe lh li lj lk b">app.js</code>中事件处理程序所期望的一样。</p><p id="7ea5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面一行设置输入字段的值</p><p id="6e40" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lh li lj lk b">form.elements['todo-input'].value = 'task 1'</code></p><p id="2de4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们创建并初始化一个“提交”HTML事件，并让我们的表单调度该事件</p><p id="8a68" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lh li lj lk b">form.dispatchEvent(ev)</code></p><p id="5d06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将触发<code class="fe lh li lj lk b">app.js</code>文件中监听“提交”事件的事件处理程序。事件处理程序会将“任务1”添加到<code class="fe lh li lj lk b">todo-input</code> HTML列表中。</p><p id="fb81" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的代码行断言检查一个任务是否如预期的那样被添加到HTML列表中。</p><p id="2482" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lh li lj lk b">assert(selector.innerHTML.toLowerCase().includes('&lt;li&gt;task 1&lt;/li&gt;'));</code></p><p id="f61b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在浏览器中运行测试运行程序，并检查浏览器控制台。如果一切按预期进行，您应该会看到以下成功消息。</p><figure class="mt mu mv mw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ny"><img src="../Images/af34075b479ea9619e0892ff4be263eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XpTszgupVjOt86L0B38Lnw.png"/></div></div></figure><p id="8d6e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">测试用例<code class="fe lh li lj lk b">selector.innerHTML = ''</code>的最后一行清除了占位符元素。</p><h1 id="818f" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated"><strong class="ak">涉及异步功能时的测试</strong></h1><p id="2f3f" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">假设我们正在调用REST API来获取用户的名和姓，然后将它们呈现给DOM。我们想测试DOM是否能在不实际调用API的情况下成功呈现。</p><p id="e319" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是我们想要测试的代码</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f5f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lh li lj lk b">$myapp.get</code>方法封装了一个<code class="fe lh li lj lk b">XMLHttpRequest</code> GET请求。它接受一个字符串参数<code class="fe lh li lj lk b">url</code>并调用带有响应的<code class="fe lh li lj lk b">callback</code>函数。</p><p id="8d76" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lh li lj lk b">$myapp.getUser</code>是我们要测试的方法。它调用<code class="fe lh li lj lk b">$myapp.get</code>方法，然后回调函数用用户的名字和姓氏呈现DOM。</p><h2 id="0249" class="mz lr in bd ls na nb dn lw nc nd dp ma kl ne nf me kp ng nh mi kt ni nj mm nk bi translated">存根异步代码</h2><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a7df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上所示，我们存根异步<code class="fe lh li lj lk b">$myapp.get</code>方法并返回一个假的用户对象。</p><p id="d3be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们称之为<code class="fe lh li lj lk b">$myapp.getUser(1)</code>方法。这将成功执行存根<code class="fe lh li lj lk b">$myapp.get</code>方法，并按照存根中的定义呈现用户的名字和姓氏。</p><p id="8af3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面的代码断言查看我们的测试DOM是否用正确的名字和姓氏进行了更新。</p><p id="8333" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lh li lj lk b">assert(selector.innerHTML.includes('Amit Gupta'))</code></p><p id="6c17" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们通过重置占位符DOM对象的innerHTML来清除它。</p><h1 id="4aec" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">摘要</h1><p id="62df" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">这篇博文展示了如何在不使用任何框架的情况下对前端JavaScript代码进行单元测试。博客显示</p><ul class=""><li id="30c8" class="ky kz in kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">如何创建<code class="fe lh li lj lk b">it</code>和<code class="fe lh li lj lk b">assert</code>测试函数</li><li id="1ca9" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated">如何单元测试应用程序功能</li><li id="5909" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated">如何对DOM进行单元测试</li><li id="587b" class="ky kz in kc b kd ll kh lm kl ln kp lo kt lp kx ld le lf lg bi translated">当涉及异步调用时如何进行单元测试</li></ul><p id="0f1a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是在浏览器中对前端JavaScript代码进行单元测试的一种简单而实用的方法。</p><h1 id="e82a" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">源代码</h1><p id="140c" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">带有样本测试的源代码托管在<a class="ae jz" href="https://github.com/amitgupta15/unit-test-front-end-without-framework" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p></div><div class="ab cl nz oa hr ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ig ih ii ij ik"><h2 id="67d9" class="mz lr in bd ls na nb dn lw nc nd dp ma kl ne nf me kp ng nh mi kt ni nj mm nk bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="cc7d" class="pw-post-body-paragraph ka kb in kc b kd mo kf kg kh mp kj kk kl mq kn ko kp mr kr ks kt ms kv kw kx ig bi translated">我们总是有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae jz" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kc io">submissions @ plain English . io</strong></a><strong class="kc io"/>，并附上您的Medium用户名，我们会将您添加为作者。</p></div></div>    
</body>
</html>