<html>
<head>
<title>How Closures lead to Modules in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">闭包如何导致JavaScript中的模块</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-from-closure-to-modules-21d1ba30ab36?source=collection_archive---------6-----------------------#2020-04-20">https://javascript.plainenglish.io/javascript-from-closure-to-modules-21d1ba30ab36?source=collection_archive---------6-----------------------#2020-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/90fc654f27978cdcfb69e2ac31118870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4skjRZfCyYbNqOndPYOtvw.jpeg"/></div></div></figure><p id="99a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇博客中，我们将看到闭包在JavaScript中是如何操作的，以及它如何导致最强大的代码组织模式之一，模块。如果你不熟悉JavaScript的词法范围机制，我建议你先在这里阅读一下<a class="ae kw" href="https://medium.com/javascript-in-plain-english/javascript-my-favorite-compiled-language-a-blog-about-scope-2012071aac86" rel="noopener">。</a></p><p id="eba1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">闭包是计算机科学有史以来发明的最重要的思想之一，让我们看看为什么。</p><p id="3078" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">闭包定义:</strong>当一个函数能够<strong class="ka ir">记住</strong> <strong class="ka ir">并且</strong> <strong class="ka ir">访问</strong>它的词法作用域时，即使该函数在不同的作用域中执行。</p><p id="c102" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">一个</em> <strong class="ka ir"> <em class="kx">会认为</em> </strong> <em class="kx">当你返回一个函数，或者执行它的时候，它最初被定义的作用域已经消失了。但是结果是，那个作用域根本没有消失，无论你在哪里传递那个函数，它都可以继续访问那个作用域。</em></p><p id="ef57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论在哪里传递该值/执行该功能，对其定义的作用域的保留/链接都被理解为闭包。</p><p id="8b66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">两个简单的例子:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="e32b" class="lh li iq ld b gy lj lk l ll lm">********** Example 1 ************</span><span id="1f01" class="lh li iq ld b gy ln lk l ll lm">function ask(question){<br/>    return function encloseQuestion(){<br/>        console.log("My question is: ", question)<br/>    }<br/>}</span><span id="3444" class="lh li iq ld b gy ln lk l ll lm">var logMyQuestion = ask("What is closure ?")</span><span id="0290" class="lh li iq ld b gy ln lk l ll lm">logMyQuestion() // My question is:  What is closure ?</span><span id="fec4" class="lh li iq ld b gy ln lk l ll lm">********** Example 2 ************</span><span id="7fff" class="lh li iq ld b gy ln lk l ll lm">function outerFunction(){<br/>    var number = 1<br/>    return function innerFunction(){<br/>        number ++<br/>        console.log(number)<br/>    }<br/>}<br/>var logNumber = outerFunction()<br/>logNumber() // 2<br/>logNumber() // 3<br/>logNumber() // 4</span></pre><p id="b5d5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为这里最值得注意的是，我们没有将变量传入内部函数，但是我们仍然可以访问它们。我们保留对变量的访问。</p><p id="fad9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">据说<code class="fe lo lp lq ld b">encloseQuestion</code>和<code class="fe lo lp lq ld b">innerFunction</code>函数<strong class="ka ir">分别关闭<code class="fe lo lp lq ld b">question</code>和<code class="fe lo lp lq ld b">number</code>变量</strong>。</p><p id="e771" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">非常重要:我们<strong class="ka ir">不关闭值</strong>，我们<strong class="ka ir">关闭变量</strong>。这是<strong class="ka ir">而不是</strong>的快照！我们可以访问当时的变量值，而不是它在创作时的值！</p><h1 id="eb15" class="lr li iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">模块模式</h1><p id="15a1" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">现在我们理解了闭包是如何工作的，我们可以开始深入研究<strong class="ka ir">模块模式</strong>。</p><p id="0915" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模块模式是将一组<strong class="ka ir">行为(</strong>功能)和<strong class="ka ir">数据</strong>组合成一个逻辑单元。</p><p id="f554" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">先说什么<strong class="ka ir">不是</strong>一个模块。</p><p id="f665" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对功能和行为进行分组的最简单方法是创建一个对象，并将您的数据和行为放入其中。这就是所谓的<strong class="ka ir">名称空间</strong>模式。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="9263" class="lh li iq ld b gy lj lk l ll lm">var nameSpaceExample = {<br/>    name: "Mark",<br/>    logName: function (){<br/>        console.log(this.name);<br/>    }<br/>}</span></pre><p id="f964" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那就是<strong class="ka ir">不是</strong>一个模块，因为模块模式需要<strong class="ka ir">封装</strong>的概念。</p><p id="ae64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">封装</strong>是对模块用户隐藏<strong class="ka ir">数据和行为的想法。</strong></p><p id="36f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">模块模式因此</strong>既需要<strong class="ka ir">绑定</strong>我们的数据和行为，<strong class="ka ir">又需要</strong>和<strong class="ka ir">封装。</strong></p><p id="aaf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，一个模块允许向你的代码的用户提供一些数据和行为，而拒绝其他数据和行为。</p><p id="5237" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“经典”或“揭示”模块模式如下:“模块将数据和行为(方法)封装在一起。模块的状态(数据)由模块的方法通过<strong class="ka ir">闭包</strong>保存。</p><p id="02b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来看一个例子并进行分解:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="f9b3" class="lh li iq ld b gy lj lk l ll lm">function PetShopModule(animal){<br/>    var publicAPI = {animalName, };<br/>    return publicAPI;<br/>                   <br/>   function animalName(name){<br/>       console.log(`${name} is a ${animal}`)<br/>   }<br/>}<br/>    <br/>var animal = PetShopModule("Dog")<br/>animal.animalName("Kim")   // "Kim is a Dog"</span></pre><ul class=""><li id="52fb" class="mt mu iq ka b kb kc kf kg kj mv kn mw kr mx kv my mz na nb bi translated">我们定义了一个<code class="fe lo lp lq ld b">PetShopModule</code>，将第一个字母大写以区别于传统函数。<code class="fe lo lp lq ld b">PetShopModule</code>将负责保存<strong class="ka ir">数据</strong>和<strong class="ka ir">功能</strong>，通过确定返回什么，我们能够<strong class="ka ir">允许</strong> / <strong class="ka ir">限制</strong>访问<strong class="ka ir">数据</strong>和<strong class="ka ir">功能</strong>。</li><li id="c0b8" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">在<code class="fe lo lp lq ld b">PetShopModule</code>函数中，我们定义了一个函数<code class="fe lo lp lq ld b">animalName</code>，它将关闭作用域内的变量，在本例中是<code class="fe lo lp lq ld b">animal</code>(作为参数传递给<code class="fe lo lp lq ld b">PetShopModule</code>)和<code class="fe lo lp lq ld b">publicAPI</code>。</li><li id="38ae" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">我们将返回一个对象<code class="fe lo lp lq ld b">var publicAPI</code>，它将保存我们选择提供给模块用户的功能。</li><li id="c2e0" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">当我们声明<code class="fe lo lp lq ld b">var petShop = PetShopModule("Dog")</code>时，我们实际上是在创建我们的<code class="fe lo lp lq ld b">PetShopModule</code>的一个实例，并传入<code class="fe lo lp lq ld b">"Dog"</code>来设置为我们的<code class="fe lo lp lq ld b">animalName</code>函数可以访问的<code class="fe lo lp lq ld b">var name</code>。</li><li id="4663" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">由于调用<code class="fe lo lp lq ld b">PetShopModule("Dog")</code>的<code class="fe lo lp lq ld b">return</code>值是一个带有键<code class="fe lo lp lq ld b">animalName</code>的<code class="fe lo lp lq ld b">Object</code>，我们的<code class="fe lo lp lq ld b">animal variable</code>现在持有<code class="fe lo lp lq ld b">{animalName: animalName}</code>，这里的值是对我们的<code class="fe lo lp lq ld b">animalName</code>函数的引用。</li><li id="9b1a" class="mt mu iq ka b kb nc kf nd kj ne kn nf kr ng kv my mz na nb bi translated">这意味着我们可以调用<code class="fe lo lp lq ld b">petShop.animalName("Kim")</code>，其中<code class="fe lo lp lq ld b">animalName</code> <strong class="ka ir">可以访问</strong>到当我们声明<code class="fe lo lp lq ld b">var petShop = PetShopModule("Dog")</code>时传入的<code class="fe lo lp lq ld b">var animal</code>。</li></ul><p id="4777" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们如何捆绑数据和行为。</p><p id="e210" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种模式允许的另一个非常重要的特性是<strong class="ka ir">跟踪状态随时间的变化</strong>。</p><p id="d7f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，我们可以将<code class="fe lo lp lq ld b">var animal</code>的值改为<code class="fe lo lp lq ld b">"Cat"</code>。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="bffe" class="lh li iq ld b gy lj lk l ll lm">animal = PetShopModule("Cat")<br/>animal.animalName("Kim") // "Kim is a Cat"</span></pre><p id="1b1c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看如何拒绝行为的访问。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="6eb4" class="lh li iq ld b gy lj lk l ll lm">function PetShopModule(animal){<br/>    var publicAPI = {animalName, };<br/>    return publicAPI;<br/>                   <br/>   function animalName(name){<br/>       logDate.call(this)<br/>       console.log(`${name} is a ${animal}`)<br/>   }<br/>    <br/>    function logDate(){<br/>        var date = new Date();<br/>        console.log("Today's date is: ", date)<br/>    }<br/>}<br/>    <br/>var petShop = PetShopModule("Dog")<br/>petShop.animalName("Kim")</span></pre><p id="7961" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到我们的<code class="fe lo lp lq ld b">logDate</code>函数是如何对我们模块中的函数可用的，但是<strong class="ka ir">没有形状或形式</strong>对我们的用户可用。那就是<strong class="ka ir">封装。</strong></p><h1 id="9b78" class="lr li iq bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">ES6模块</h1><p id="ae3c" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">添加ES6模块是因为模块被证明是主要的代码组织模式。</p><p id="eb3a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ES6带来了基于文件的模块；你打开一个文件，开始创建变量和函数。</p><p id="4a4a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以想象这个文件被包装在一个函数中，就像我们在前面的例子中看到的那样。</p><p id="69b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为这个文件是作为一个模块加载的，所以它被认为是私有的。</p><p id="49d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">公开的方法是使用<code class="fe lo lp lq ld b">export</code>关键字。</p><p id="2394" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就拿这个<code class="fe lo lp lq ld b">PetShop.js</code>模块来说吧。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="36dc" class="lh li iq ld b gy lj lk l ll lm">var animal = "Dog";<br/>​<br/>export default function petName(name){<br/>    console.log(`${name} is a ${animal}`)<br/>}</span></pre><p id="fb57" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">值得注意的是，这些基于文件的模块也是<strong class="ka ir">单例的</strong>，这意味着即使它们被多次导入到应用程序中，<strong class="ka ir">它们也只运行一次</strong>。</p><p id="6b9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在ES6中有两种主要的导入和使用模块的方式，选择哪种方式是个人喜好的问题。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="8df4" class="lh li iq ld b gy lj lk l ll lm">// named import syntax<br/>import petName from 'PetShop.mjs';<br/>​<br/>petName("Kim");<br/>​<br/>// Or<br/>​<br/>// Namespaced import syntax<br/>import * as PetShop from 'PetShop.mjs'<br/>​<br/>var pet = PetShop.petName("Kim");</span></pre><p id="ac10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这有所帮助。</p><p id="fbb4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">博客灵感来自<a class="ae kw" href="https://frontendmasters.com/" rel="noopener ugc nofollow" target="_blank">前端大师</a> / <a class="nh ni ep" href="https://medium.com/u/1b199ed2dfd?source=post_page-----21d1ba30ab36--------------------------------" rel="noopener" target="_blank">前端大师</a>，深度JavaScript基础，v3，由<a class="nh ni ep" href="https://medium.com/u/5dccb9bb4625?source=post_page-----21d1ba30ab36--------------------------------" rel="noopener" target="_blank"> Kyle </a> Simpson教授。对于那些想大幅增加他们的前端编程知识的人来说，这是一个惊人的资源。</p><p id="51e0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读！</p><p id="afb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">爱，光，代码❤️</p><h2 id="aa98" class="lh li iq bd ls nj nk dn lw nl nm dp ma kj nn no me kn np nq mi kr nr ns mm nt bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="d09b" class="pw-post-body-paragraph jy jz iq ka b kb mo kd ke kf mp kh ki kj mq kl km kn mr kp kq kr ms kt ku kv ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kw" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ka ir">AI in Plain English</strong></a><a class="ae kw" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ka ir">UX in Plain English</strong></a><a class="ae kw" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ka ir">Python in Plain English</strong></a><strong class="ka ir"/>——谢谢，继续学习！</p><p id="c191" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kw" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">submissions @ plain English . io</strong></a><strong class="ka ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>