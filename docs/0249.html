<html>
<head>
<title>Cloning in JavaScript v. Cloning in Ruby</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的克隆与Ruby中的克隆</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/cloning-in-javascript-v-cloning-in-ruby-c63061eeda14?source=collection_archive---------4-----------------------#2019-09-05">https://javascript.plainenglish.io/cloning-in-javascript-v-cloning-in-ruby-c63061eeda14?source=collection_archive---------4-----------------------#2019-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="064f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在学习JavaScript时，细微的实现差异经常会让我用不同的方式处理问题。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/37932c701b073b190cdd855c8859b845.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sm2i7St7A-kWjnEyvbNnmw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by Grace Madeline on Unsplash</figcaption></figure><h2 id="e834" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">我是从Ruby的优势来学习编程的，Ruby有一个清晰的内置方法来制作数组的浅层副本。</h2><p id="d835" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">在学习JavaScript时，细微的实现差异经常会让我用不同的方式处理问题。在JS中，没有被称为<code class="fe mk ml mm mn b">clone </code>或<code class="fe mk ml mm mn b">dup</code>的函数，甚至没有专门为创建浅层副本而创建的<code class="fe mk ml mm mn b">initialize_copy</code>。有这样的Ruby方法。然而，认为没有这样的功能是天真的。</p><p id="1d7a" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">我开始依靠对克隆阵列的操作来解决一个问题。然后，我采用了不同的方法，因为我没有立即发现如何克隆阵列。用其他方法解决问题后，我找到了克隆阵列所需的工具。下面简单描述一下我的旅程。</p><h2 id="25a2" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">任务</strong></h2><p id="63f9" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">启动学校的课程让我创建自己版本的JS <code class="fe mk ml mm mn b">unshift</code>函数。目的是让学生熟悉内置JavaScript函数的实现。</p><p id="2bb4" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated"><code class="fe mk ml mm mn b"><a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift" rel="noopener ugc nofollow" target="_blank">unshift</a> </code>通过在数组开头插入新值来修改数组。新值的索引是<code class="fe mk ml mm mn b">0</code>，并且所有其他数组值的索引比它们之前的大1。</p><pre class="kg kh ki kj gt mu mn mv mw aw mx bi"><span id="44a1" class="kv kw iq mn b gy my mz l na nb">var array1 = [1, 2, 3];</span><span id="bff5" class="kv kw iq mn b gy nc mz l na nb">console.log(array1.unshift(4, 5));<br/>// expected output: 5</span><span id="f5f9" class="kv kw iq mn b gy nc mz l na nb">console.log(array1);<br/>// expected output: Array [4, 5, 1, 2, 3]</span></pre><p id="8947" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">该实现意味着使用带有<code class="fe mk ml mm mn b">for</code>的基本迭代来完成。没有巧妙解决的空间。这不是一个面向对象的解决方案，所以新函数是用一个要修改的数组参数调用的，而不是像JS内置版本那样在数组对象本身上调用。</p><p id="7b73" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">我最初的实施过程是:</p><ol class=""><li id="fef2" class="nd ne iq lt b lu mo lx mp le nf li ng lm nh mj ni nj nk nl bi translated">克隆输入数组</li><li id="7a2e" class="nd ne iq lt b lu nm lx nn le no li np lm nq mj ni nj nk nl bi translated">使用括号符号使插入值成为输入数组的第一个值</li><li id="2dbf" class="nd ne iq lt b lu nm lx nn le no li np lm nq mj ni nj nk nl bi translated">迭代克隆的数组</li><li id="f42c" class="nd ne iq lt b lu nm lx nn le no li np lm nq mj ni nj nk nl bi translated">使迭代中的每个对象成为输入数组的后续索引</li><li id="8698" class="nd ne iq lt b lu nm lx nn le no li np lm nq mj ni nj nk nl bi translated">返回数组的<code class="fe mk ml mm mn b">length</code></li></ol><p id="4fae" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">不幸的是，我在第一步就被打断了。</p><h2 id="6f20" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">为什么是克隆？</strong></h2><p id="8bdf" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">由于变量作为指针的概念，如果我简单地将原始数组赋给一个新变量，两个变量将指向同一个数组。修改存储数组的新变量也会修改原始数组。</p><pre class="kg kh ki kj gt mu mn mv mw aw mx bi"><span id="be65" class="kv kw iq mn b gy my mz l na nb">var arr = [1, 2, 3];<br/>var arr1 = arr;<br/>arr1[0] = 'New Value';</span><span id="e6d7" class="kv kw iq mn b gy nc mz l na nb">arr1;                  // ['New Value', 2, 3]<br/>arr;                   // ['New Value', 2, 3]</span></pre><p id="ac44" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">副本允许您修改包含与原始数组具有相同值的元素的数组，而无需修改原始数组。</p><p id="6455" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">我想复制，因为我最初的方法意味着修改复制数组的第一个索引(即索引0)，然后迭代原始数组，并在复制数组的后续索引中讲述其元素。</p><p id="d8aa" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">我没有立即推断如何复制。</p><p id="dd58" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">因此，我对原始数组进行迭代，将元素值存储在临时变量中，并在每次迭代中重新赋值:</p><pre class="kg kh ki kj gt mu mn mv mw aw mx bi"><span id="1291" class="kv kw iq mn b gy my mz l na nb">var count = [1, 2, 3];</span><span id="7080" class="kv kw iq mn b gy nc mz l na nb">function unshift(arr, insertionValue) {<br/>  var currentValue;<br/>  var newValue = insertionValue;<br/>  var iterations = arr.length;<br/>  for (var i = 0; i &lt;= iterations; i += 1) {<br/>    currentValue = arr[i];<br/>    arr[i] = newValue;<br/>    newValue = currentValue;<br/>  }<br/>  return arr.length;<br/>}</span><span id="f6e0" class="kv kw iq mn b gy nc mz l na nb">console.log(unshift(count, 0));      // 4<br/>console.log(count);                  // [ 0, 1, 2, 3 ]</span></pre><p id="70bf" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">这更接近于JS函数的镜像，因为它返回原始的修改后的数组，而不是一个副本。</p><h2 id="559f" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">问题仍然是，‘我如何克隆？’</strong></h2><p id="fcad" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">虽然问题解决了，但是一个JS开发者用什么方法论来获得浅层副本呢？</p><p id="f7f9" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">同名的Ruby方法:<code class="fe mk ml mm mn b"><a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank">slice</a></code>。</p><p id="17be" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">当Ruby开发人员只想复制数组的一部分时，可能会想到这种方法。然而，JavaScript提供了<code class="fe mk ml mm mn b">slice</code>，而不是创建一个冗余的方法，本质上用另一个名字做同样的事情。要获得数组一部分的副本，请指示起始和结束索引。要复制整个数组，从索引0开始。</p><pre class="kg kh ki kj gt mu mn mv mw aw mx bi"><span id="eb48" class="kv kw iq mn b gy my mz l na nb">var arr = [1, 2, 3];<br/>var arr1 = arr.slice(0);  // arr.slice(0, 3) would also work<br/>arr1[0] = 'New Value';</span><span id="ee69" class="kv kw iq mn b gy nc mz l na nb">arr1;                     // ['New Value', 2, 3]<br/>arr;                      // [1, 2, 3]</span></pre><p id="5ac7" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">对于Ruby开发者来说，这是非常有效的，尽管不够直观。</p><h2 id="acdc" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">惯用的红宝石诉恩……</strong></h2><p id="f8bb" class="pw-post-body-paragraph lr ls iq lt b lu lv jr lw lx ly ju lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">Ruby的设计意图是简单易读(<a class="ae mt" href="https://medium.com/the-renaissance-developer/idiomatic-ruby-1b5fa1445098" rel="noopener">‘惯用Ruby:编写漂亮的代码</a>’)。这意味着开发人员的生产力优先于语言优化。</p><p id="172e" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">JavaScript最初在10天内实现，只是为了在浏览器中提供脚本功能。它不一定是为了清晰而开发的。</p><p id="494d" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">这并不是说JavaScript开发人员不容易理解从零开始“切片”的意图。从一个角度来看，“如果功能已经存在，为什么还要在另一个功能中复制它？”。那不是干代码吗。</p><p id="8b23" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">Ruby反驳:更清楚了。如果一个方法只打算做一件事，那么在阅读另一个开发人员的代码时，更容易发现他们的意图。</p><p id="abdf" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">这难道没有反映出“在一个系统中，每一项知识都必须有一个单一的、明确的、权威的表示”吗，正如在<a class="ae mt" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="noopener ugc nofollow" target="_blank"> <em class="nr">《实用程序员</em> </a>中对DRY的定义所述？</p><p id="2cda" class="pw-post-body-paragraph lr ls iq lt b lu mo jr lw lx mp ju lz le mq mb mc li mr me mf lm ms mh mi mj ij bi translated">让读者来评判吧。</p></div></div>    
</body>
</html>