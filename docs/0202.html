<html>
<head>
<title>A Crash Course in NestJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NestJS速成班</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-crash-course-in-nestjs-cccfc0090a16?source=collection_archive---------0-----------------------#2019-08-09">https://javascript.plainenglish.io/a-crash-course-in-nestjs-cccfc0090a16?source=collection_archive---------0-----------------------#2019-08-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f8f96ed8d1bd32db818ba236914b085c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4oYuw26Yc9zPGMgq"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@dlanor_s?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dlanor S</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2b44" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">如果您曾经使用过Node JS或Express，那么您会正确地意识到维护和扩展您的应用程序是多么乏味和令人困扰。</h1><p id="b7f1" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这就是NestJS的用武之地。它使用Typescript等现代开发工具，并提供开箱即用的应用程序架构，允许开发人员和团队创建高度可测试、可伸缩、松散耦合且易于维护的应用程序。</p><p id="05e4" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在幕后，Nest利用了Express和Fastify等强大而健壮的HTTP框架。它在这些API上提供了一个抽象层，但也可以直接向我们开发人员公开它们的API。</p><p id="9961" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在本文中，我们将看看NestJS最重要的概念，甚至在最后构建一个小的CRUD应用程序。</p><p id="314b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">所以，不要再浪费时间了，让我们开始吧。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="35a4" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">为什么要关心NestJS</h1><p id="5107" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在的问题仍然是为什么首先应该使用NestJS。以下是NodeJS开发者应该考虑转用NestJS的一些原因。</p><h2 id="0ac6" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">类型检查:</h2><p id="d3fb" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">NestJS基于Typescript，它使我们开发人员能够向变量添加类型，并基于它们提供编译错误和警告。Typescript还为我们javascript开发人员提供了许多其他的好处，你可以在这个<a class="ae jz" href="https://medium.com/free-code-camp/a-crash-course-in-typescript-e6bf9c10946" rel="noopener">速成班</a>中找到更多。</p><h2 id="f7aa" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">依赖注入:</h2><p id="9b38" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">依赖注入是一种设计模式，用于提高应用程序的效率和模块化。它通常用于保持代码整洁，易于阅读和使用。NestJS提供了开箱即用的功能，甚至可以轻松地使用它来创建耦合组件。</p><h2 id="82bf" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">应用架构:</h2><p id="252b" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">NestJS项目有一个预定义的结构，提供了可测试性、可伸缩性和可维护性的最佳实践。尽管如此，它仍然非常灵活，可以根据需要进行更改。</p><h2 id="a01c" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">可测试:</h2><p id="2e51" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">NestJS提供了一个完整的Jest测试配置，但仍然允许我们开发人员使用我们认为合适的其他测试工具。</p><p id="6304" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">既然我们已经了解了NestJS为什么有用以及它可以在哪些方面改进我们的开发体验，那么让我们来看看这个框架最重要的概念和构建块。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="40d3" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">模块</h1><p id="2230" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">模块是每个NestJS应用程序的基本构建块，用于将控制器和服务等相关功能组合在一起。它们是用@Module()修饰器修饰的类型脚本文件。</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/d6f4a84708931870eb35a51112c2d367.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TWgy1I1Od7_cnHbz.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Src: <a class="ae jz" href="https://docs.nestjs.com/modules" rel="noopener ugc nofollow" target="_blank">https://docs.nestjs.com/modules</a></figcaption></figure><p id="461a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">每个应用程序至少需要一个模块，即所谓的根模块。根模块是应用程序的起点，在启动项目时自动生成。理论上，我们可以在这个模块中编写整个应用程序，但是建议将一个大的应用程序分成多个模块，以帮助维护和可读性。</p><p id="210b" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">建议和常规做法是将每个特性分组到它们自己的模块中，例如UserModule和ItemModule。</p><p id="04d6" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">一个简单的模块示例:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="bb88" class="mn kb in nf b gy nj nk l nl nm">@Module({<br/>  controllers: [ItemController],<br/>  providers: [ItemService],<br/>})<br/>export class ItemModule {}</span></pre></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="e43b" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">控制器</h1><p id="393e" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">在Nestjs中，控制器负责处理传入的请求并将响应返回给客户端。它们是使用@Controller()声明符定义的，该声明符将主路由的路径作为其参数。</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/8c3ae909902a5402763d7bb7728bceef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Rd_hfsunTNxr4I5G.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><a class="ae jz" href="https://docs.nestjs.com/controllers" rel="noopener ugc nofollow" target="_blank">https://docs.nestjs.com/controllers</a></figcaption></figure><p id="c079" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">控制器内部的每个函数都可以用以下声明符进行注释:</p><ul class=""><li id="dd4f" class="nn no in la b lb lw lf lx lj np ln nq lr nr lv ns nt nu nv bi translated">@Get() —定义一个Get请求</li><li id="d469" class="nn no in la b lb nw lf nx lj ny ln nz lr oa lv ns nt nu nv bi translated">@Post() —定义发布请求</li><li id="951e" class="nn no in la b lb nw lf nx lj ny ln nz lr oa lv ns nt nu nv bi translated">@Delete() —删除请求</li><li id="0a94" class="nn no in la b lb nw lf nx lj ny ln nz lr oa lv ns nt nu nv bi translated">@Put() — Put请求</li></ul><p id="f3c2" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">下面是一个具有一个get路径的简单控制器的示例:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="0f33" class="mn kb in nf b gy nj nk l nl nm">@Controller('item')<br/>export class ItemController {<br/>  @Get()<br/>  findAll(): string {<br/>    return 'Returns all items';<br/>  }<br/>}</span></pre><p id="83d7" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io">注意:</strong>在创建控制器之后，需要将它添加到一个模块中，以便NestJS能够识别它(当您使用Nest CLI生成它时，这将自动发生)。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="ec77" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">提供者</h1><p id="d8fd" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">NestJS中的提供者也被称为服务，用于封装和抽象控制器等其他类的逻辑。可以使用依赖注入将它们注入到其他类中。</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/431730e532d48f0d3287dbe5815d7741.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JpsTNIMFYCWHok2W.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><a class="ae jz" href="https://docs.nestjs.com/providers" rel="noopener ugc nofollow" target="_blank">https://docs.nestjs.com/providers</a></figcaption></figure><p id="4526" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">提供者是一个普通的Typescript类，顶部有一个@ Injectable()声明符。</p><p id="a937" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">例如，我们可以很容易地创建一个获取所有项目的服务，并在我们的<em class="ob"> ItemController </em>中使用它。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="795c" class="mn kb in nf b gy nj nk l nl nm">@Injectable()<br/>export class ItemService {<br/>  private readonly items: Item[] = [{ title: 'Great item', price: 10 }];<br/><br/>  create(item: Item) {<br/>    this.items.push(item);<br/>  }<br/><br/>  findAll(): Item[] {<br/>    return this.items;<br/>  }<br/>}</span></pre><p id="0b3c" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在我们已经定义了我们的服务，让我们在控制器中使用它:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="e7e0" class="mn kb in nf b gy nj nk l nl nm">@Controller('item')<br/>export class ItemController {<br/>  constructor(private readonly itemService: ItemService) {}<br/><br/>  @Get()<br/>  async findAll(): Promise&lt;Item[]&gt; {<br/>    return this.itemService.findAll();<br/>  }<br/>}</span></pre></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="f236" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">生命周期</h1><p id="6350" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">每个嵌套应用程序元素都有自己的生命周期，它由各种生命周期挂钩组成，这些生命周期挂钩可用于提供这些关键状态的可见性以及在它们发生时采取行动的能力。</p><h2 id="0708" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">生命周期事件:</h2><p id="1a39" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">以下是四个生命周期序列:</p><ul class=""><li id="f6ac" class="nn no in la b lb lw lf lx lj np ln nq lr nr lv ns nt nu nv bi translated">OnModuleInit —一旦初始化了主机模块就调用它</li><li id="5841" class="nn no in la b lb nw lf nx lj ny ln nz lr oa lv ns nt nu nv bi translated">OnApplicationBootstrap —在应用程序完全启动并引导后调用</li><li id="555f" class="nn no in la b lb nw lf nx lj ny ln nz lr oa lv ns nt nu nv bi translated">OnModuleDestroy —在Nest销毁主机模块之前进行清理</li><li id="083f" class="nn no in la b lb nw lf nx lj ny ln nz lr oa lv ns nt nu nv bi translated">OnApplicationShutdown —当应用程序关闭时</li></ul><h2 id="7e86" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">用法:</h2><p id="5384" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">这四个生命周期挂钩中的每一个都由一个接口表示。这意味着我们只需要在组件(类)中实现接口并覆盖函数。</p><p id="f1a7" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">下面是OnModuleInit接口的一个简单示例:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="35a5" class="mn kb in nf b gy nj nk l nl nm">import { Injectable, OnModuleInit } from '@nestjs/common';<br/><br/>@Injectable()<br/>export class ItemService implements OnModuleInit {<br/>  onModuleInit() {<br/>    console.log(`The module has been initialized.`);<br/>  }<br/>}</span></pre></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="d460" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">管道</h1><p id="e4f2" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">NestJS中的管道用于操作控制器路由处理程序的参数。这给了他们两个典型的用例:</p><ul class=""><li id="bdab" class="nn no in la b lb lw lf lx lj np ln nq lr nr lv ns nt nu nv bi translated">转换-将输入数据转换为所需的输出</li><li id="79bf" class="nn no in la b lb nw lf nx lj ny ln nz lr oa lv ns nt nu nv bi translated">验证-评估输入数据是否有效</li></ul><h2 id="2f6f" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">用法:</h2><p id="8ed3" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">可以通过在我们的类上实现PipeTransform接口并覆盖Transform函数来创建管道。让我们看一个自定义验证管道的简单示例:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="c6e5" class="mn kb in nf b gy nj nk l nl nm">import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';<br/><br/>@Injectable()<br/>export class CustomValidationPipe implements PipeTransform {<br/>  transform(value: any, metadata: ArgumentMetadata) {<br/>   const { metatype } = metadata;<br/>   if (!metatype) {<br/>     return value;<br/>   }<br/>   const convertedValue = plainToClass(metatype, value);<br/>   return convertedValue;<br/>  }<br/>}</span></pre><p id="a261" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这个例子中，我们检查我们提供的元标记是否为空，如果是，我们将接收到的数据转换为我们定义的元类型。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="2941" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">测试</h1><p id="c18b" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">NestJS为我们提供了Jest测试框架的完整设置，这使得开始单元、集成和端到端测试变得容易。</p><p id="ff70" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在您开始测试之前，我建议您熟悉测试金字塔和其他最佳实践，如KISS(保持简单愚蠢)技术。</p><h2 id="e13c" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">单元测试:</h2><p id="e74b" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在让我们来看看上面定义的<em class="ob">项目服务</em>的简单单元测试。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="4763" class="mn kb in nf b gy nj nk l nl nm">import { Test } from '@nestjs/testing';<br/>import { ItemService } from './item.service';</span><span id="39a6" class="mn kb in nf b gy oc nk l nl nm">describe('ItemService', () =&gt; {<br/>  let service: ItemService;<br/><br/>  beforeEach(async () =&gt; {<br/>    const module: TestingModule = await Test.createTestingModule({<br/>      providers: [ItemService],<br/>    }).compile();<br/><br/>    service = module.get&lt;ItemService&gt;(ItemService);<br/>  });<br/><br/>  it('should be defined', () =&gt; {<br/>    expect(service).toBeDefined();<br/>  });<br/>});</span></pre><p id="6f49" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这个例子中，我们使用NestJS提供的测试类，通过compile()和get()函数创建并获取我们的服务。之后，我们只需编写一个简单的测试来检查服务是否被定义。</p><p id="1013" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated"><strong class="la io">注意:</strong>为了模拟一个真实的实例，您需要用一个定制的提供者覆盖一个现有的提供者。</p><h2 id="6afb" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">端到端测试:</h2><p id="2ab9" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">端到端测试帮助我们测试API的整体功能，以及我们的小单元如何协同工作。端到端测试利用了我们用于单元测试的相同设置，但是额外利用了<a class="ae jz" href="https://github.com/visionmedia/supertest" rel="noopener ugc nofollow" target="_blank"> supertest </a>库，它允许我们模拟HTTP请求。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="37ad" class="mn kb in nf b gy nj nk l nl nm">describe('Item Controller (e2e)', () =&gt; {<br/>  let app;<br/><br/>  beforeEach(async () =&gt; {<br/>    const module: TestingModule = await Test.createTestingModule({<br/>      imports: [ItemModule],<br/>    }).compile();<br/><br/>    app = module.createNestApplication();<br/>    await app.init();<br/>  });<br/><br/>  it('/ (GET)', () =&gt; {<br/>    return request(app.getHttpServer())<br/>      .get('/item')<br/>      .expect(200)<br/>      .expect([{ title: 'Great item', price: 10 }]);<br/>  });<br/>});</span></pre><p id="6ffe" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这里，我们向前面创建的端点发送一个HTTP请求，并检查它是否返回正确的响应代码和数据。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="d612" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">入门指南</h1><p id="f3da" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">NestJS提供了自己的nice CLI(命令行界面),可以用来创建项目、模块、服务等等。我们可以使用节点包管理器(npm)和下面的命令来安装它。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="df30" class="mn kb in nf b gy nj nk l nl nm">npm i -g @nestjs/cli</span></pre><p id="9c13" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">之后，我们应该能够使用new命令创建一个新项目。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="c99b" class="mn kb in nf b gy nj nk l nl nm">nest new project-name</span></pre><p id="fed8" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在我们已经安装了CLI，让我们开始使用NestJS和MongoDB构建一个简单的CRUD应用程序。</p></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="19ae" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">CRUD示例</h1><p id="b04e" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">如本文前面所述，我们将使用NestJS和MongoDB作为数据库创建一个简单的CRUD应用程序。这将帮助您真正掌握Nest的核心概念。</p><h2 id="0aa8" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">创建项目:</h2><p id="3f67" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">首先，让我们使用上面讨论的命令创建项目。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="9577" class="mn kb in nf b gy nj nk l nl nm">nest new mongo-crud</span></pre><p id="6cd0" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">之后，让我们进入生成的目录并启动我们的开发服务器。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="4519" class="mn kb in nf b gy nj nk l nl nm">// Move into the directory<br/>cd mongo-crud</span><span id="3af8" class="mn kb in nf b gy oc nk l nl nm">// Start the development server<br/>npm run start:dev</span></pre><p id="022f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">使用Nodemon运行应用程序，这意味着当您保存项目时，它会自动更新页面。</p><p id="bf4e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在我们已经输入了这些命令，我们应该看到一个“Hello World！”我们http://localhost:3000上的消息。</p><h2 id="7c5e" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">生成文件:</h2><p id="a0af" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">接下来，我们需要创建这个项目所需的所有文件。让我们从使用CLI生成标准的NestJS文件开始。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="a87a" class="mn kb in nf b gy nj nk l nl nm">nest generate module items<br/>nest generate controller items<br/>nest generate service items</span></pre><p id="1156" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">之后，我们只需要为我们的数据库模式和访问对象添加一些文件。这是我的文件夹结构和文件的图片。</p><figure class="na nb nc nd gt jo gh gi paragraph-image"><div class="gh gi og"><img src="../Images/dfd99ed71bb61b3a53fd1d09f9934c73.png" data-original-src="https://miro.medium.com/v2/resize:fit:404/format:webp/1*r2cAtG2VEkuAn2uhu7OJgA.png"/></div></figure><p id="2e5e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如您所见，您只需在我们的项目目录中创建三个丢失的文件夹及其文件。</p><h2 id="1979" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">设置MongoDB:</h2><p id="d65a" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">接下来，我们将继续在我们的Nest项目中设置MongoDB数据库。为此，您首先需要在您的计算机上安装MongoDB。如果您还没有下载，您可以使用<a class="ae jz" href="https://www.mongodb.com/download-center/community" rel="noopener ugc nofollow" target="_blank">此链接</a>下载。</p><p id="5bcc" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">完成本地安装后，我们只需要在项目中安装所需的依赖项，然后将它们导入到我们的模块中。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="3067" class="mn kb in nf b gy nj nk l nl nm">npm install --save @nestjs/mongoose mongoose</span></pre><p id="44be" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在让我们在应用程序模块中导入Mongo:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="70d8" class="mn kb in nf b gy nj nk l nl nm"><em class="ob">import</em> { Module } <em class="ob">from</em> '@nestjs/common';<br/><em class="ob">import</em> { AppController } <em class="ob">from</em> './app.controller';<br/><em class="ob">import</em> { AppService } <em class="ob">from</em> './app.service';<br/><em class="ob">import</em> { MongooseModule } <em class="ob">from</em> '@nestjs/mongoose';<br/><em class="ob">import</em> { ItemsModule } <em class="ob">from</em> './items/items.module';</span><span id="e4e7" class="mn kb in nf b gy oc nk l nl nm">@Module({<br/>imports: [MongooseModule.forRoot('mongodb://localhost/nest'), ItemsModule],<br/>controllers: [AppController],<br/>providers: [AppService],<br/>})<br/><em class="ob">export</em> class AppModule {}</span></pre><p id="9c49" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如您所见，我们使用forRoot()方法导入了MongooseModule，该方法接受与mongoose.connect()相同的参数。</p><p id="a371" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们还需要在ItemsModule中设置Mongo，可以这样做:</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="e8f6" class="mn kb in nf b gy nj nk l nl nm"><em class="ob">import</em> { Module } <em class="ob">from</em> '@nestjs/common';<br/><em class="ob">import</em> { MongooseModule } <em class="ob">from</em> '@nestjs/mongoose';<br/><em class="ob">import</em> { ItemsController } <em class="ob">from</em> './items.controller';<br/><em class="ob">import</em> { ItemsService } <em class="ob">from</em> './items.service';<br/><em class="ob">import</em> { ItemSchema } <em class="ob">from</em> './schemas/item.schema';</span><span id="ba09" class="mn kb in nf b gy oc nk l nl nm">@Module({<br/>imports: [MongooseModule.forFeature([{ name: 'Item', schema: ItemSchema }])],<br/>controllers: [ItemsController],<br/>providers: [ItemsService],<br/>})<br/><em class="ob">export</em> class ItemsModule {}</span></pre><p id="d178" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这里我们也导入了MongooseModule，但是使用了forFeature()方法，该方法定义了将在当前作用域中注册什么模型。得益于此，我们以后将能够使用依赖注入来访问服务文件中的模型。</p><h2 id="ad72" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">构建模式:</h2><p id="39ea" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">接下来，我们将为数据库创建模式。模式定义了数据在数据库中的表示方式。让我们在我们的<code class="fe od oe of nf b">item.schema.ts</code>文件中定义它。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="43e3" class="mn kb in nf b gy nj nk l nl nm"><em class="ob">import</em> * <em class="ob">as</em> mongoose <em class="ob">from</em> 'mongoose';</span><span id="ae47" class="mn kb in nf b gy oc nk l nl nm"><em class="ob">export</em> const ItemSchema = new mongoose.Schema({<br/> name: String,<br/> qty: Number,<br/> description: String,<br/>});</span></pre><p id="84f8" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如你所见，我们首先需要导入<em class="ob">mongose</em>依赖项，然后使用<em class="ob">mongose创建一个新的模式。Schema() </em>。</p><h2 id="8a39" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">接口:</h2><p id="4944" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">接下来，我们将创建一个Typescript接口，用于我们的服务和控制器中的类型检查。要进行设置，只需将以下代码粘贴到您之前创建的<code class="fe od oe of nf b">item.interface.ts</code>文件中。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="3271" class="mn kb in nf b gy nj nk l nl nm"><em class="ob">export</em> interface Item {<br/> id?: string;<br/> name: string;<br/> description?: string;<br/> qty: number;<br/>}</span></pre><h2 id="6878" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">创建DTO:</h2><p id="226b" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">DTO(数据传输对象)是定义数据如何通过网络发送的对象。它是一个基本类，变量与我们的模式相同(在我们的例子中)。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="a7d9" class="mn kb in nf b gy nj nk l nl nm"><em class="ob">export</em> class CreateItemDto {<br/> readonly name: string;<br/> readonly description: string;<br/> readonly qty: number;<br/>}</span></pre><p id="143d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">我们现在已经完成了数据库的基本配置，可以继续编写实际的CRUD功能了。</p><h2 id="2239" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">设置服务:</h2><p id="fa17" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">服务文件将保存与我们的CRUD(创建、读取、更新、删除)功能的数据库交互相关的所有逻辑。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="f6da" class="mn kb in nf b gy nj nk l nl nm"><em class="ob">import</em> { Injectable } <em class="ob">from</em> '@nestjs/common';<br/><em class="ob">import</em> { Item } <em class="ob">from</em> './interfaces/item.interface';<br/><em class="ob">import</em> { Model } <em class="ob">from</em> 'mongoose';<br/><em class="ob">import</em> { InjectModel } <em class="ob">from</em> '@nestjs/mongoose';<br/><em class="ob">import</em> { CreateItemDto } <em class="ob">from</em> './dto/create-item.dto';</span><span id="ef16" class="mn kb in nf b gy oc nk l nl nm">@Injectable()<br/><em class="ob">export</em> class ItemsService {<br/> constructor(@InjectModel('Item') private readonly itemModel:  Model&lt;Item&gt;) {}</span><span id="5c69" class="mn kb in nf b gy oc nk l nl nm"> async findAll(): Promise&lt;Item[]&gt; {<br/>  <em class="ob">return</em> <em class="ob">await</em> <em class="ob">this</em>.itemModel.find();<br/> }</span><span id="2259" class="mn kb in nf b gy oc nk l nl nm"> async findOne(id: string): Promise&lt;Item&gt; {<br/>  <em class="ob">return</em> <em class="ob">await</em> <em class="ob">this</em>.itemModel.findOne({ _id: id });<br/> }</span><span id="6c29" class="mn kb in nf b gy oc nk l nl nm">async create(item: CreateItemDto): Promise&lt;Item&gt; {<br/>  const newItem = new this.itemModel(item);<br/>  <em class="ob">return</em> <em class="ob">await</em> newItem.save();<br/> }</span><span id="3385" class="mn kb in nf b gy oc nk l nl nm"> async delete(id: string): Promise&lt;Item&gt; {<br/>  <em class="ob">return</em> <em class="ob">await</em> <em class="ob">this</em>.itemModel.findByIdAndRemove(id);<br/> }</span><span id="0df9" class="mn kb in nf b gy oc nk l nl nm"> async update(id: string, item: Item): Promise&lt;Item&gt; {<br/>  <em class="ob">return</em> <em class="ob">await</em> <em class="ob">this</em>.itemModel.findByIdAndUpdate(id, item, { new: true });<br/> }<br/>}</span></pre><p id="2f7a" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">在这里，我们首先导入所有需要的依赖项，例如我们的item.interface、dto等等。</p><p id="08ac" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">接下来，我们需要将我们的项目模型注入到我们的服务中，这样我们就可以执行与数据库相关的活动。为此，我们在构造函数中使用@InjectModel()声明符。</p><p id="a00e" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">之后，我们最终创建处理CRUD功能的函数:</p><ul class=""><li id="3199" class="nn no in la b lb lw lf lx lj np ln nq lr nr lv ns nt nu nv bi translated">find all()-使用<em class="ob"> find() </em>方法查找数据库中的所有项目</li><li id="a1e0" class="nn no in la b lb nw lf nx lj ny ln nz lr oa lv ns nt nu nv bi translated">findOne() —查找与函数参数具有相同id的项目</li><li id="b5bf" class="nn no in la b lb nw lf nx lj ny ln nz lr oa lv ns nt nu nv bi translated">create() —使用我们的<em class="ob"> itemModel </em>和MongoDB <em class="ob"> save() </em>函数创建一个新项目</li><li id="ec54" class="nn no in la b lb nw lf nx lj ny ln nz lr oa lv ns nt nu nv bi translated">delete()-删除与函数参数具有相同id的项目</li><li id="4daf" class="nn no in la b lb nw lf nx lj ny ln nz lr oa lv ns nt nu nv bi translated">update() —用PUT请求中提供的新数据更新具有相同id属性的客户</li></ul><h2 id="e513" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">控制器:</h2><p id="d7a0" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">控制器负责处理传入的请求，并向客户端提供正确的响应。</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="6d0d" class="mn kb in nf b gy nj nk l nl nm"><em class="ob">import</em> {<br/>Controller,<br/>Get,<br/>Post,<br/>Put,<br/>Delete,<br/>Body,<br/>Param,<br/>} <em class="ob">from</em> '@nestjs/common';<br/><em class="ob">import</em> { CreateItemDto } <em class="ob">from</em> './dto/create-item.dto';<br/><em class="ob">import</em> { ItemsService } <em class="ob">from</em> './items.service';<br/><em class="ob">import</em> { Item } <em class="ob">from</em> './interfaces/item.interface';</span><span id="da7e" class="mn kb in nf b gy oc nk l nl nm">@Controller('items')<br/><em class="ob">export</em> class ItemsController {<br/> constructor(private readonly itemsService: ItemsService) {}</span><span id="e6b5" class="mn kb in nf b gy oc nk l nl nm"> @Get()<br/> findAll(): Promise&lt;Item[]&gt; {<br/>  <em class="ob">return</em> <em class="ob">this</em>.itemsService.findAll();<br/> }</span><span id="9e1a" class="mn kb in nf b gy oc nk l nl nm"> @Get(':id')<br/> findOne(@Param('id') id): Promise&lt;Item&gt; {<br/>  <em class="ob">return</em> <em class="ob">this</em>.itemsService.findOne(id);<br/> }</span><span id="c2de" class="mn kb in nf b gy oc nk l nl nm"> @Post()<br/> create(@Body() createItemDto: CreateItemDto): Promise&lt;Item&gt; {<br/>  <em class="ob">return</em> <em class="ob">this</em>.itemsService.create(createItemDto);<br/> }</span><span id="e2db" class="mn kb in nf b gy oc nk l nl nm"> @Delete(':id')<br/> delete(@Param('id') id): Promise&lt;Item&gt; {<br/>  <em class="ob">return</em> <em class="ob">this</em>.itemsService.delete(id);<br/> }</span><span id="934d" class="mn kb in nf b gy oc nk l nl nm"> @Put(':id')<br/> update(@Body() updateItemDto: CreateItemDto, @Param('id') id): Promise&lt;Item&gt; {<br/>  <em class="ob">return</em> <em class="ob">this</em>.itemsService.update(id, updateItemDto);<br/> }<br/>}</span></pre><p id="a62f" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">这里我们使用@Controller()声明符，它是定义任何基本控制器所必需的，并将路由路径前缀作为可选参数(在我们的示例中，我们使用/item)。</p><p id="33c3" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">之后，我们使用依赖注入在构造函数中注入我们的ItemService。</p><p id="dd3d" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">现在，我们只需使用HTTP请求方法声明符定义我们的HTTP端点，并调用我们在服务中定义的方法。</p><h2 id="08de" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">测试应用程序:</h2><p id="2c1d" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">现在我们已经完成了应用程序，是时候测试功能了。为此，我们需要启动我们的服务器，然后通过向端点发送HTTP请求来测试它(我们可以使用像<a class="ae jz" href="https://www.getpostman.com/" rel="noopener ugc nofollow" target="_blank">邮差</a>或<a class="ae jz" href="https://insomnia.rest/" rel="noopener ugc nofollow" target="_blank">失眠</a>这样的程序来完成)</p><pre class="na nb nc nd gt ne nf ng nh aw ni bi"><span id="3ec3" class="mn kb in nf b gy nj nk l nl nm">npm run start</span></pre><p id="74df" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">启动服务器后，您只需通过向我们上面创建的端点发送HTTP请求来测试应用程序。</p><p id="5042" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果你有任何问题，请在下面的评论中留下。完整的代码也可以在我的Github上找到。</p><div class="oh oi gp gr oj ok"><a href="https://github.com/TannerGabriel/Blog/tree/master/Nest-CRUD" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd io gy z fp op fr fs oq fu fw im bi translated">TannerGabriel/博客</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">我所有博客项目的存储库。在GitHub上创建一个帐户，为TannerGabriel/博客的发展做出贡献。</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">github.com</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy jt ok"/></div></div></a></div></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h2 id="611c" class="mn kb in bd kc mo mp dn kg mq mr dp kk lj ms mt ko ln mu mv ks lr mw mx kw my bi translated">推荐阅读:</h2><div class="oh oi gp gr oj ok"><a href="https://medium.com/dailyjs/an-introduction-into-stencil-js-a08e41e2102" rel="noopener follow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd io gy z fp op fr fs oq fu fw im bi translated">Stencil.js简介</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">Stencil是一个编译器，可以生成Ionic团队开发的Web组件。模板结合了…的最佳概念</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">medium.com</p></div></div><div class="ot l"><div class="oz l ov ow ox ot oy jt ok"/></div></div></a></div></div><div class="ab cl mb mc hr md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ig ih ii ij ik"><h1 id="d4ad" class="ka kb in bd kc kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx bi translated">结论</h1><p id="5264" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">你一直坚持到最后！希望这篇文章能帮助你理解NestJS的基础知识，以及为什么它对我们后端开发人员如此有用。</p><p id="b100" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果您发现这很有用，请考虑推荐并与其他开发人员分享。如果你有任何问题或反馈，请在下面的评论中告诉我。</p><p id="77fc" class="pw-post-body-paragraph ky kz in la b lb lw ld le lf lx lh li lj ly ll lm ln lz lp lq lr ma lt lu lv ig bi translated">如果你想获得我博客的持续更新，请确保在媒体上关注我，并且<a class="ae jz" href="https://gabrieltanner.us20.list-manage.com/subscribe/post?u=9d67fc028348a0eb71318768e&amp;amp;id=6845ed3555" rel="noopener ugc nofollow" target="_blank">加入我的时事通讯</a>。</p><blockquote class="pa pb pc"><p id="9b2b" class="ky kz ob la b lb lw ld le lf lx lh li pd ly ll lm pe lz lp lq pf ma lt lu lv ig bi translated">最初发表于<a class="ae jz" href="https://gabrieltanner.org/blog/nestjs-crashcourse" rel="noopener ugc nofollow" target="_blank">gabrieltanner.org</a>。</p></blockquote></div></div>    
</body>
</html>