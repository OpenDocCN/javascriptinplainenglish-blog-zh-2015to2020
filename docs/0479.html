<html>
<head>
<title>Build faster JavaScript Web Apps with Angular Universal, a TransferState Service and an API Watchdog</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Angular Universal、TransferState服务和API看门狗构建更快的JavaScript Web应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-faster-javascript-web-apps-with-angular-universal-a-transferstate-service-and-an-api-b7e4afd0fe9c?source=collection_archive---------2-----------------------#2019-10-24">https://javascript.plainenglish.io/build-faster-javascript-web-apps-with-angular-universal-a-transferstate-service-and-an-api-b7e4afd0fe9c?source=collection_archive---------2-----------------------#2019-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/70bb78eee0c410eef32ecedefa35c5de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Mn2Y9mJk6L3wJBn1.jpg"/></div></div></figure><p id="8523" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">搜索引擎优化(SEO)对于大多数web应用程序来说至关重要。你可以用<a class="ae kw" href="https://angular.io/guide/universal" rel="noopener ugc nofollow" target="_blank"> Angular Universal </a>构建SEO友好的Angular应用，但是这样一个应用的性能和效率如何呢？这篇文章将向您展示如何构建快速的Angular应用程序，在提供用于SEO目的的服务器端渲染(SSR)的同时，高效地使用客户端和服务器资源。</p><p id="3077" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本帖中，我们将:</p><ul class=""><li id="6fb0" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">创建一个<a class="ae kw" href="https://angular.io" rel="noopener ugc nofollow" target="_blank">角度的</a>应用程序</li><li id="6d1a" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">使用<a class="ae kw" href="https://angular.io/guide/universal" rel="noopener ugc nofollow" target="_blank">角度通用</a>添加服务器端渲染</li><li id="a2cf" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">用<a class="ae kw" href="https://angular.io/api/platform-browser/TransferState" rel="noopener ugc nofollow" target="_blank"> TransferState </a>服务建立一个<code class="fe ll lm ln lo b">HTTP_INTERCEPTOR</code>，以防止对服务器资源的重复调用</li><li id="269e" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">创建一个路由解析器来防止缓慢的外部API。</li></ul><p id="8b71" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了完成这篇文章中的任务，你需要安装<a class="ae kw" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js和npm</a>(node . js安装也会安装NPM)以及<a class="ae kw" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular CLI </a>。用于<a class="ae kw" href="https://curl.haxx.se/dlwiz/?type=source&amp;os=Mac+OS+X" rel="noopener ugc nofollow" target="_blank"> macOS </a>、<a class="ae kw" href="https://curl.haxx.se/download.html" rel="noopener ugc nofollow" target="_blank"> Linux </a>或Windows 10的cURL(<a class="ae kw" href="https://stackoverflow.com/questions/9507353/how-do-i-install-and-use-curl-on-windows" rel="noopener ugc nofollow" target="_blank">包含在</a>的内部版本1803和更高版本中)和<a class="ae kw" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank"> Git </a>在说明中有所提及，但不是必需的。</p><p id="3042" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要从这篇文章中最有效地学习，你应该具备以下条件:</p><ul class=""><li id="fe5a" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">打字稿和角度框架的工作知识</li><li id="9376" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">熟悉角度可观测量和依赖注入</li></ul><p id="a055" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<a class="ae kw" href="https://github.com/maciejtreder/angular-universal-transfer-state" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上有这篇文章的配套项目。本文中的每个主要步骤在存储库中都有自己的分支。</p><h1 id="7b4f" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建角度项目</h1><p id="3641" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">每个Angular项目都是从软件包的安装和初始化开始的。在命令提示符下，在要创建项目目录的目录中键入以下内容:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="a29e" class="na lq iq lo b gy nb nc l nd ne">ng new angular-universal-transfer-state --style css --routing true --directory angularApp</span></pre><p id="7df0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">项目初始化后，导航到其目录:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="b978" class="na lq iq lo b gy nb nc l nd ne">cd angular-universal-transfer-state</span></pre><p id="8f7e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并通过键入以下命令运行应用程序:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="f6f4" class="na lq iq lo b gy nb nc l nd ne">ng serve</span></pre><p id="5729" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该在控制台中看到以下输出:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="361b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">打开命令输出中提供的URL后，<a class="ae kw" href="http://localhost:4200," rel="noopener ugc nofollow" target="_blank"> http://localhost:4200，</a>您应该会在浏览器中看到以下内容:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/11d2aa800fe7424698f6b851ff0b577c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*InPg6JVTkIp8aGR2.png"/></div></figure><h1 id="8567" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">使用Angular Universal添加服务器端渲染</h1><p id="ae7d" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">在命令提示符下键入以下内容以安装角度通用模块:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="3691" class="na lq iq lo b gy nb nc l nd ne">ng add @ng-toolkit/universal</span></pre><p id="124d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以通过运行我们的应用程序并对其执行curl请求来检查Angular Universal是否正常工作:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="7e16" class="na lq iq lo b gy nb nc l nd ne">npm run build:prod;npm run server</span><span id="c7bf" class="na lq iq lo b gy ni nc l nd ne">curl http://localhost:8080</span></pre><p id="12c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您不想使用curl，您可以在浏览器中打开url并检查页面源代码。如下所示，结果应该是相同的。</p><p id="20de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下代码中的省略号(“<code class="fe ll lm ln lo b">...</code>”)表示为简洁起见而编辑的部分。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="f398" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以运行以下命令来赶上项目中的这一步:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="76ee" class="na lq iq lo b gy nb nc l nd ne">git clone <a class="ae kw" href="https://github.com/maciejtreder/angular-universal-transfer-state.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/angular-universal-transfer-state.git</a><br/>cd angular-universal-transfer-state<br/>git checkout step1<br/>cd angularApp<br/>npm install<br/>npm run build:prod<br/>npm run server</span></pre><h1 id="e999" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">创建外部API</h1><p id="cb7f" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">大多数应用程序执行对一个或多个API的调用，无论是在应用程序自己的服务器上还是在第三方主机上。我们的应用程序将调用我们将在Node.js服务器上创建并运行的服务，该服务的端口地址(8081)不同于应用程序的端口(4200)和服务器端呈现端口(8080)。</p><p id="32dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在创建服务之前，我们将构建一个简单的Node.js应用程序，它有两个端点，我们将使用服务在应用程序内部使用这些端点。在<code class="fe ll lm ln lo b">angular-universal-transfer-state</code>应用程序的目录结构之外创建一个<code class="fe ll lm ln lo b">externalApi</code>目录。在该目录中创建一个文件<code class="fe ll lm ln lo b">externalApi.js</code>(因此相对路径是:<code class="fe ll lm ln lo b">../externalApi/externalApi.js</code>)并将以下代码放入其中:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="94c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为我们使用Node.js的<a class="ae kw" href="https://www.express.com/" rel="noopener ugc nofollow" target="_blank"> Express </a> web framework来提供来自该应用程序的内容，所以我们需要将其初始化为npm项目并安装依赖项。在<code class="fe ll lm ln lo b">externalApi</code>目录下创建一个<code class="fe ll lm ln lo b">package.json</code>文件，并将以下内容放入其中:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ba7d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在<code class="fe ll lm ln lo b">externalApi</code>目录中运行以下命令，初始化npm应用程序并安装依赖项:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="0a3b" class="na lq iq lo b gy nb nc l nd ne">npm install</span></pre><h1 id="00e7" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">调用外部API</h1><p id="70d5" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">现在我们将创建一个服务，它将使用我们刚刚创建的<code class="fe ll lm ln lo b">externalApi</code>中的端点。通过在控制台的<code class="fe ll lm ln lo b">angular-universal-transfer-state/angularApp</code>目录中键入以下命令来生成它:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="a0ed" class="na lq iq lo b gy nb nc l nd ne">ng g s custom --spec false</span></pre><p id="7bcb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将<code class="fe ll lm ln lo b">CustomService</code>实现放在<code class="fe ll lm ln lo b">src/app/custom.service.ts</code>中:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d7de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要在我们的应用程序中导入一个<code class="fe ll lm ln lo b">HttpClientModule</code>,因为我们正在<a class="ae kw" href="https://en.wikipedia.org/wiki/Dependency_injection" rel="noopener ugc nofollow" target="_blank">向<code class="fe ll lm ln lo b">CustomService</code>注入</a>一个<code class="fe ll lm ln lo b">HttpClient</code>服务。用以下代码替换<code class="fe ll lm ln lo b">src/app/app.module.ts</code>文件的内容:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="92ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建两个组件来显示来自我们服务的响应。首先，一个为<code class="fe ll lm ln lo b">fast</code>端点:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="d908" class="na lq iq lo b gy nb nc l nd ne">ng g c fast -m app -s -t --spec false</span></pre><p id="d912" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下代码放入<code class="fe ll lm ln lo b">src/app/fast/fast.component.ts</code>中:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="daa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">二、一为“延迟”<code class="fe ll lm ln lo b">slow</code>端点:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="d690" class="na lq iq lo b gy nb nc l nd ne">ng g c slow -m app -s -t --spec false</span></pre><p id="dc50" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将下面的代码放在<code class="fe ll lm ln lo b">src/app/slow/slow.component.ts</code>中:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="7c83" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">应用程序路由</h1><p id="c808" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">将<code class="fe ll lm ln lo b">src/app/app-routing.module.ts</code>文件中的代码替换为:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ac79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe ll lm ln lo b">src/app/app.component.html</code>中放置导航链接:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2776" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想赶上项目中的这一步，请使用以下命令:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="6711" class="na lq iq lo b gy nb nc l nd ne">git clone <a class="ae kw" href="https://github.com/maciejtreder/angular-universal-transfer-state.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/angular-universal-transfer-state.git</a><br/>cd angular-universal-transfer-state<br/>git checkout step2<br/>cd externalApi<br/>npm install<br/>cd ../angularApp<br/>npm install</span></pre><h1 id="fdca" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">干(C):不要重复你的电话</h1><p id="c21a" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">到目前为止，我们所拥有的是一个Angular应用程序，它成功地执行了对外部API的调用。感谢Angular Universal，它也是搜索引擎优化的，来自这些呼叫的响应显示在服务器端呈现的构建中。</p><p id="9463" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是有一个陷阱。让我们围绕API调用进行一些调查。</p><p id="805a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个控制台窗口中，运行<code class="fe ll lm ln lo b">externalApi</code>目录中的<code class="fe ll lm ln lo b">externalApi.js</code>:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="87fd" class="na lq iq lo b gy nb nc l nd ne">node externalApi.js</span></pre><p id="8fe5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在另一个控制台窗口中，构建并运行<code class="fe ll lm ln lo b">angular-universal-transfer-state</code>目录中的应用程序:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="7f2a" class="na lq iq lo b gy nb nc l nd ne">npm run build:prod<br/>npm run server</span></pre><p id="9013" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用您最喜欢的浏览器导航到位于<a class="ae kw" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080 </a>的应用程序。呈现主页视图并检索来自外部API的数据。让我们看看<code class="fe ll lm ln lo b">externalApi</code>正在运行的控制台窗口中发生了什么):</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="3020" class="na lq iq lo b gy nb nc l nd ne">node externalApi.js<br/>Listening<br/>fast endpoint hit<br/>fast endpoint hit</span></pre><p id="d749" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如您所见，我们对API执行了两次调用，两次命中了<code class="fe ll lm ln lo b">fast</code>端点。怎么可能，我们只打开了一次网站？</p><p id="69ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这要“归功于”服务器端渲染。事情发生的顺序如下:</p><ol class=""><li id="6ed4" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv nj ld le lf bi translated">Node.js中的用户请求页面</li><li id="7a02" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv nj ld le lf bi translated">Node.js在向客户端提供Angular服务时调用<code class="fe ll lm ln lo b">externalApi</code> <code class="fe ll lm ln lo b">fast</code>端点，</li><li id="02df" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv nj ld le lf bi translated">externalApi快速端点返回一个响应，Node.js将其添加到生成的HTML中</li><li id="074e" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv nj ld le lf bi translated">HTML和Angular JavaScript被发送到浏览器</li><li id="d78b" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv nj ld le lf bi translated">Angular在浏览器中启动，并再次调用<code class="fe ll lm ln lo b">externalApi</code> <code class="fe ll lm ln lo b">fast</code>端点</li><li id="edb3" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv nj ld le lf bi translated">将<code class="fe ll lm ln lo b">externalApi</code> <code class="fe ll lm ln lo b">fast</code>端点响应返回给浏览器，并放置在应用程序视图中。</li></ol><p id="a81f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以在下图中查看该过程:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/ee09d5f4b6dcb09f3f6e9be00f55a047.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/0*vQUzq5izCeOBIaZa.png"/></div></figure><p id="c611" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你觉得是不是超高效？我同意你的观点。</p><h1 id="ed49" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">转移状态服务</h1><p id="2b1b" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">我们将通过创建<code class="fe ll lm ln lo b">TransferState</code>服务来提高应用程序的效率，该服务是Node.js服务器和浏览器中呈现的应用程序之间交换的键值注册中心。我们将通过一个<code class="fe ll lm ln lo b">HTTP_INTERCEPTOR</code>机制来使用它，这个机制将驻留在<code class="fe ll lm ln lo b">HttpClient</code>服务中，它将操纵请求和响应。</p><p id="fea5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">键入以下命令以生成新服务:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="bca1" class="na lq iq lo b gy nb nc l nd ne">ng g s HttpInterceptor --spec false</span></pre><p id="9b91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用以下代码替换<code class="fe ll lm ln lo b">src/app/http-interceptor.service.ts</code>的内容:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="86df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里放了很多代码。大家讨论一下。</p><p id="87d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的服务实现了<code class="fe ll lm ln lo b">HttpInterceptor</code>接口，所以我们需要实现相应的方法:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="9c84" class="na lq iq lo b gy nb nc l nd ne">public intercept(request: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt;</span></pre><p id="41ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每当在<code class="fe ll lm ln lo b">HttpClient</code>服务上执行任何API调用时，都会调用这个方法。</p><p id="aa55" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的演示中，为了简单起见，我们希望只对GET调用使用<code class="fe ll lm ln lo b">TransferState</code>注册表。我们需要检查来电是否符合该标准:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="0fcb" class="na lq iq lo b gy nb nc l nd ne">if (request.method !== 'GET') {<br/>     return next.handle(request);<br/>}</span></pre><p id="b656" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果是，我们就根据请求URL生成一个密钥。我们将使用键-值对来存储或检索请求响应，这取决于是在服务器端还是在浏览器端处理请求:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="12d9" class="na lq iq lo b gy nb nc l nd ne">const key: StateKey&lt;string&gt; = makeStateKey&lt;string&gt;(request.url);</span></pre><p id="2ec8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了区分服务器和浏览器，我们使用了来自<code class="fe ll lm ln lo b">@angular/common</code>库的<code class="fe ll lm ln lo b">isPlatformServer</code>方法和<code class="fe ll lm ln lo b">PLATFORM_ID</code>注入令牌:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="929d" class="na lq iq lo b gy nb nc l nd ne">if (isPlatformServer(this.platformId)) {<br/>    //serverSide<br/>} else {<br/>    //browserSide<br/>}</span></pre><p id="1ffc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在服务器端代码中，我们希望执行调用并将其响应存储在<code class="fe ll lm ln lo b">TransferState</code>注册表中:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="de78" class="na lq iq lo b gy nb nc l nd ne">if (isPlatformServer(this.platformId)) {<br/>    return next.handle(request).pipe(tap((event) =&gt; {<br/>        this.transferState.set(key, (&lt;HttpResponse&lt;any&gt;&gt; event).body);<br/>}));</span></pre><p id="8e79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在浏览器端代码中，我们希望检查给定调用的响应是否已经驻留在注册表中。如果有，我们希望检索它，清除注册表(以便将来的调用可以存储新数据)，并将响应返回给调用者(在本例中为<code class="fe ll lm ln lo b">CustomService</code>)。如果注册表中不存在给定的键，我们只需执行HTTP调用:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="dd27" class="na lq iq lo b gy nb nc l nd ne">else {<br/>    const storedResponse = this.transferState.get&lt;any&gt;(key, null);<br/>    if (storedResponse) {<br/>        const response = new HttpResponse({body: storedResponse, status: 200});<br/>        this.transferState.remove(key);<br/>        return of(response);<br/>    } else {<br/>        return next.handle(request);<br/>    }<br/>}</span></pre><p id="7566" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以在<code class="fe ll lm ln lo b">src/app/app.module.ts</code>中提供HTTP拦截器，用以下代码替换现有代码:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2882" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要将两个包含<code class="fe ll lm ln lo b">TransferState</code>服务的新模块导入我们的应用程序。通过用以下代码替换<code class="fe ll lm ln lo b">src/app/app.server.module.ts</code>中的现有代码，将<code class="fe ll lm ln lo b">ServerTransferStateModule</code>包含在服务器端模块中:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="7986" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过用以下代码替换<code class="fe ll lm ln lo b">src/app/app.browser.module.ts</code>中的代码，将<code class="fe ll lm ln lo b">BrowserTransferStateModule</code>包含在浏览器端模块中:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="c838" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ll lm ln lo b">src/main.ts</code>文件中的代码也需要修改。我们需要以稍微不同的方式引导我们的应用程序，以使<code class="fe ll lm ln lo b">TransferState</code>注册表正常工作；当浏览器发出<code class="fe ll lm ln lo b">DOMContentLoaded</code>事件时，我们需要引导我们的应用程序。用以下代码替换现有代码:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h1 id="da9b" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">测试TransferState服务</h1><p id="4e4b" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">重新编译应用程序，并检查对后端进行了多少次调用。</p><p id="a205" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">构建并运行服务器:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="557d" class="na lq iq lo b gy nb nc l nd ne">npm run build:prod<br/>npm run server</span></pre><p id="8af3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您因任何原因停止了<code class="fe ll lm ln lo b">externalApi</code>过程，您现在应该重启它。</p><p id="1a21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用浏览器的地址栏导航到第二个组件<a class="ae kw" href="http://localhost:8080/slow" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/slow</a>。这样做将对服务器执行调用，而不是像单击主页上的链接那样在浏览器中运行本地代码(Angular SPA)。</p><p id="468a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在控制台窗口中检查<code class="fe ll lm ln lo b">externalApi</code>过程的输出。它应该如下所示，其中前两个快速端点响应来自之前的测试，最后一行是当前测试的结果:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="a49a" class="na lq iq lo b gy nb nc l nd ne">Listening<br/>fast endpoint hit<br/>fast endpoint hit<br/>slow endpoint hit</span></pre><p id="a67d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任务完成！后端检索到的响应被传递给<code class="fe ll lm ln lo b">TransferState</code>注册表中的浏览器。</p><h1 id="baa5" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">另一种HTTP拦截器</h1><p id="2bd1" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">作为创建定制<code class="fe ll lm ln lo b">HTTP_INTERCEPTOR</code>的替代方法，您可以使用<code class="fe ll lm ln lo b">@nguniversal</code>库中的标准<code class="fe ll lm ln lo b">TransferHttpCacheModule</code>。这使得实现更加方便，但是它也强加了一个约束:您不能对标准库进行任何更改，所以您不能添加像我们将在接下来的步骤中创建的API watchdog这样的功能。</p><p id="a182" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要实现标准传输缓存，请安装依赖项:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="32f2" class="na lq iq lo b gy nb nc l nd ne">npm install @nguniversal/common</span></pre><p id="595f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将<code class="fe ll lm ln lo b">TransferHttpCacheModule</code>模块导入到<code class="fe ll lm ln lo b">src/app/app.module.ts</code>中，将内容替换为以下代码:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="fcfd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有其他步骤保持不变。如果您想赶上这一步，运行:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="6c8c" class="na lq iq lo b gy nb nc l nd ne">git clone <a class="ae kw" href="https://github.com/maciejtreder/angular-universal-transfer-state.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/angular-universal-transfer-state.git</a><br/>cd angular-universal-transfer-state<br/>git checkout step3<br/>cd externalApi<br/>npm install<br/>cd ../angularApp<br/>npm install</span></pre><h1 id="c9b6" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">实现性能监视器</h1><p id="c232" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">还有一件事我们需要考虑。正如你可能注意到的，加载<a class="ae kw" href="http://localhost:8080/slow" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/slow</a>需要很长时间。肯定不是SEO友好的。虽然这是因为我们在创建外部API时出于演示目的引入了时间延迟，但现实世界中有许多API响应缓慢或根本不响应的例子。</p><p id="17df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将通过在对<code class="fe ll lm ln lo b">SlowComponent</code>的调用中使用<code class="fe ll lm ln lo b">RouteResolver</code>来解决这个问题。</p><p id="2c1d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在用于构建和运行应用程序的控制台窗口中输入以下命令来生成它:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="8489" class="na lq iq lo b gy nb nc l nd ne">ng g s SlowComponentResolver --spec false</span></pre><p id="e656" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将<code class="fe ll lm ln lo b">src/app/slow-component-resolver.service.ts</code>中的代码替换为以下内容:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="b3cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">稍微检查一下这段代码。我们有一个需要实现的<code class="fe ll lm ln lo b">resolve</code>方法，因为我们正在实现<code class="fe ll lm ln lo b">Resolve</code>接口。在方法内部，我们检查代码是否在浏览器或服务器上执行。如果代码正在浏览器中执行，它会通过执行调用来等待调用:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="fc59" class="na lq iq lo b gy nb nc l nd ne">if (isPlatformBrowser(this.platformId)) {<br/>    return this.service.getSlow();<br/>}</span></pre><p id="ba94" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果代码正在Node.js服务器中执行，则使用<code class="fe ll lm ln lo b">rxjs</code>库中的<code class="fe ll lm ln lo b">timer</code>方法创建一个可观察对象<code class="fe ll lm ln lo b">watchdog</code>。<code class="fe ll lm ln lo b">timer</code>方法创建一个可观察对象，该对象在给定时间(以毫秒为单位)后仅发出一次值:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="7cef" class="na lq iq lo b gy nb nc l nd ne">const watchdog: Observable&lt;number&gt; = timer(500);</span></pre><p id="afcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将这个可观察对象与<code class="fe ll lm ln lo b">takeUntil</code>方法一起使用，通过管道传递给请求调用。如果observable在API发送响应之前发出一个值，它会将<code class="fe ll lm ln lo b">null</code>推送给组件。否则，它会推送API响应。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ef10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要更新应用程序的路由来使用这个解析器。用以下内容替换<code class="fe ll lm ln lo b">src/app/app-routing.module.ts</code>的内容:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="2bac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用以下代码替换<code class="fe ll lm ln lo b">src/app/slow/slow.component.ts</code>中的代码，更新“慢速”组件以使用路线解析器:</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="d91a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">重新构建应用程序，并检查现在渲染缓慢的组件需要多长时间。</p><p id="c250" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好多了！如果呼叫时间超过0.5秒，我们将放弃呼叫，并在浏览器中再次执行。那正是我们要找的。</p><p id="2376" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的插图中，你可以看到我们的新架构是如何工作的。</p><p id="de6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当API快速响应时，响应由服务器处理:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/e3131665f9efe3c15b836b518f5f61af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-2D5SEIQYBeHDh16.png"/></div></div></figure><p id="300a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当API在看门狗激活前没有回复时，我们向浏览器发送部分呈现的HTML并重复调用:</p><figure class="ms mt mu mv gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/4457f7eb15c45e401045dfdfee2977d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t_g8bfk-KiZgLEDr.png"/></div></div></figure><p id="dce3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为一种替代方法，如果您不想在全局设置看门狗机制，您可以通过在<code class="fe ll lm ln lo b">HTTP_INTERCEPTOR</code>中提供它来实现。</p><p id="2863" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您想赶上这一步，运行:</p><pre class="ms mt mu mv gt mw lo mx my aw mz bi"><span id="c96e" class="na lq iq lo b gy nb nc l nd ne">git clone <a class="ae kw" href="https://github.com/maciejtreder/angular-universal-transfer-state.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/angular-universal-transfer-state.git</a><br/>cd angular-universal-transfer-state<br/>git checkout step4<br/>npm install<br/>npm run build:prod<br/>npm run server</span></pre><h1 id="4da9" class="lp lq iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">摘要</h1><p id="9253" class="pw-post-body-paragraph jy jz iq ka b kb mn kd ke kf mo kh ki kj mp kl km kn mq kp kq kr mr kt ku kv ij bi translated">今天我们讨论了一个重要的挑战:提高实现服务器端渲染的应用程序的性能和效率。我们用两种方式做到了这一点:使用<code class="fe ll lm ln lo b">TransferState</code>服务，我们能够限制对可能很慢的API的调用。我们还实现了一个看门狗机制来放弃长时间运行的API调用，这会对服务器渲染视图所需的总时间产生负面影响。这两种技术都有助于改善Angular网站的性能，从而提高用户满意度，并帮助网站在搜索引擎排名中获得更好的分数。</p><p id="1ae2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想了解更多关于Angular Universal的技术，请查看我在Twilio博客上的其他帖子<a class="ae kw" href="https://www.twilio.com/blog/angular-universal-javascript-node-js-aws-lambda" rel="noopener ugc nofollow" target="_blank">开始使用AWS Lambda上的无服务器Angular Universal</a>和<a class="ae kw" href="https://www.twilio.com/blog/create-search-engine-friendly-internationalized-web-apps-angular-universal-ngx-translate" rel="noopener ugc nofollow" target="_blank">使用Angular Universal和ngx-translate模块</a>为Angular应用程序创建搜索引擎友好的国际化。</p><p id="bbe6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文中使用的代码的Git存储库可以在这里找到:<a class="ae kw" href="https://github.com/maciejtreder/angular-universal-transfer-state" rel="noopener ugc nofollow" target="_blank">https://github . com/maciejtreder/angular-universal-transfer-state</a></p><p id="7ce3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我是Maciej Treder，请通过GitHub、Twitter和LinkedIn上的<a class="ae kw" href="mailto:contact@maciejtreder.com" rel="noopener ugc nofollow" target="_blank">contact@maciejtreder.com</a>、<a class="ae kw" href="https://www.maciejtreder.com/" rel="noopener ugc nofollow" target="_blank">https://www.maciejtreder.com</a>或@maciejtreder与我联系。</p><p id="ba38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nn">本帖原载于</em> <a class="ae kw" href="https://www.twilio.com/blog/prevent-memory-leaks-angular-observable-ngondestroy" rel="noopener ugc nofollow" target="_blank"> <em class="nn"> Twilio博客</em> </a> <em class="nn">。</em></p></div></div>    
</body>
</html>