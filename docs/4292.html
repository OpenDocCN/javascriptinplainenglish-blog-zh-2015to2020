<html>
<head>
<title>Improve the UX of your React App with Skeleton Screens</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用骨架屏幕提高React应用程序的UX</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/perform-your-react-app-with-react-skeleton-screens-e021558af9d0?source=collection_archive---------17-----------------------#2020-11-30">https://javascript.plainenglish.io/perform-your-react-app-with-react-skeleton-screens-e021558af9d0?source=collection_archive---------17-----------------------#2020-11-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9f53" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一般来说，网站通过各种不同的方式处理获取数据，如显示旋转器(例如网飞的情况)、进度条或定制动画，其中一种方式(如Medium和脸书使用的)是通过使用<strong class="jm io"> React骨架屏幕</strong>在浏览器上处理获取数据，为使其更加清晰，请查看下图</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/77b39e7a660ea9f9093eb9aa0e781665.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*28AXTjUWtnvF0hDlywwapg.gif"/></div></div></figure><p id="155c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将是我们的应用程序，我们将建立一个快速简单和快速反应。js应用程序，显示一个随机诗人的随机诗歌，不要担心一切将解释如下，源代码将在最后提供😉</p><h1 id="b99c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">设置</h1><p id="b84a" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">首先，让我们通过创建react.js应用程序来初始化我们的项目:</p><blockquote class="lx ly lz"><p id="c864" class="jk jl ma jm b jn jo jp jq jr js jt ju mb jw jx jy mc ka kb kc md ke kf kg kh ig bi translated">npx创建-反应-应用反应-屏幕-示例</p></blockquote><p id="e032" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，为了初始化我们的内容，我们将使用一个免费的诗歌数据库提供商，你可以在这里找到<a class="ae me" href="https://github.com/thundercomb/poetrydb/blob/master/README.md" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"/></a><strong class="jm io"/>，所以让我们开始编码。所以我们需要两个状态变量“poems”和“poet”用Api回调来更新</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="37bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如上面的图片所示；函数“fetchPoems”进行第一次调用以获得可用诗人的列表，然后用一个随机的名字解析它，第二次调用以获得诗歌的列表，这个函数在useEffect挂钩中调用，首先用一个计时器来查看事情是如何工作的，然后我们将移除计时器，直接调用它，不使用任何计时器，这就是它的一般用法</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="4fd4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着在可视地改变内容之前，它将显示框架屏幕5秒钟，但是记住将该行放在注释中，并像第7行那样直接调用“fetchPoems”函数。</p><p id="865e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在return closure中，我们将根据状态有条件地呈现内容，因此在第一次呈现时，我们将有一个临时数据(稍后是骨架屏幕)，然后在安装useEffect后，我们将调用fetchPoems来更新内容，因此让我们构建骨架屏幕。</p><h1 id="ca0b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">骨架屏幕</h1><p id="30db" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">简单地说，我们的骨架屏幕是定制的html元素，以灰色作为背景色，并添加一些css动画来使其闪闪发光。首先，我们需要知道我们的渲染器内容的性质，即:文本，标题，标题，图像和头像，在我们的例子中，我们有三种类型的内容:单行文本(标题)，多行文本和头像，所以我们必须设计我们的骨架。首先创建一个文件夹，命名为“skeleton ”,包含两个文件“index.js”和“style . css”,“index . js”是一个React组件，它必须接收一个指示内容类型的属性，因为我们必须基于此自定义CSS</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="157b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，正如你所看到的，我们根据接收到的属性创建CSS类名，稍后在。/style.css "如下</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="3627" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们回到App.js，用这个新的逻辑更新render方法，在hooks函数中获取数据之前显示框架</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2923" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们只是测试初始数据是否为空，如果是这样，我们渲染四个块，每个块中有一个标题和一个正文元素，然后我们渲染一个关于作者的简单元素，有一个头像和一个标题元素，但是如果state更新得很好，那么我们渲染十首带有标题的诗，如第6行中的map()函数，右边的块有一些诗人的信息。</p><p id="55b8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就在结束之前，让我们添加一些快速的CSS动画，将与骨架一起显示，因此创建另一个文件夹，并将其命名为“twinkle”(如我所做的😜)有了“index.js”和“style.css”两个文件，这个动画块后面会被包裹在Skeleton元素中，所以我们来看看这个动画根文件:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="eb09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单地说，这里有一个包装块，我们将把它放入动画中，这个块将用于动画，在CSS文件中有定义X线上平移的动画关键帧，动画将花费1.5秒在一个无限循环中从左到右执行。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="ab67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们必须向Skeleton元素添加新的动画包装器，只需通过导入动画文件来更新fine skeleton/index.js，并将组件包装在根块中，如下所示:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="7de8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就是这样！😃</p><p id="3257" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">源代码:</strong><a class="ae me" href="https://github.com/BLemine/medium-article-React-Skeleton-Screens" rel="noopener ugc nofollow" target="_blank">https://github . com/bl mine/medium-article-React-Skeleton-Screens</a></p></div></div>    
</body>
</html>