<html>
<head>
<title>ComponentDidMount and useEffect Are Not The Same. Here’s Why</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ComponentDidMount和useEffect不相同。原因如下</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/componentdidmount-and-useeffect-are-not-the-same-heres-why-cea02f474c82?source=collection_archive---------0-----------------------#2020-08-19">https://javascript.plainenglish.io/componentdidmount-and-useeffect-are-not-the-same-heres-why-cea02f474c82?source=collection_archive---------0-----------------------#2020-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1aeb048de88b072f53adc1b3464873be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZnZE8df9sb72Rp-E3HeGPw.png"/></div></div></figure><p id="33f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个组件被挂载来执行像网络调用这样的任务时，需要一些设置是很常见的。在钩子被引入之前，我们被教导使用像<code class="fe kw kx ky kz b">componentDidMount()</code>这样的函数。在过渡到功能组件时，寻找等效的挂钩是很自然的。</p><p id="0142" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TL；DR、hooks和生命周期方法基于非常不同的原理。像<code class="fe kw kx ky kz b">componentDidMount()</code>这样的方法围绕生命周期和渲染时间，而钩子则围绕状态和与DOM的同步来设计。</p><p id="e211" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很多程序员认为他们可以用<code class="fe kw kx ky kz b">useEffect(fn, [])</code>代替<code class="fe kw kx ky kz b">componentDidMount()</code>的行为。虽然使用这种方法时似乎没有任何重大错误，但它仍然会导致一些破坏应用程序的错误。这两种方法根本不同，您可能得不到想要的预期行为。程序员不应该认为钩子是组件挂载时运行的函数。假设钩子以这种方式工作会阻碍你对钩子的理解(和学习)。</p><h1 id="af4a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">状态和道具捕捉方式不同</h1><p id="15d0" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">也许最明显的区别是这两种方法如何捕捉状态和道具。当使用异步方法时，这变得尤其明显。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi md"><img src="../Images/35a6aa1373d6d608fb52f2e9f1fde536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8HfvrayJ8QSoRJkLOmfhEg.png"/></div></div></figure><p id="7fc3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个组件看起来很简单。一旦它被装载，它就调用一个函数，这个函数返回一个承诺，这个承诺在一段时间后解决。一旦该承诺得到解决，它就会记录name变量的当前状态。让我们尝试将相同的代码移植到一个功能组件上。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mi"><img src="../Images/75bb402ca70fc5bcbc5d7768d2d8cc78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hc4z5ZlRGsooD9gP6v5rvg.png"/></div></div></figure><p id="6f12" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码不能正常工作。<code class="fe kw kx ky kz b">useEffect()</code>方法在创建时捕获状态和道具的值。因此，控制台将打印一个空行，即使用户在此时可以输入任何内容。要告诉React效果应该使用最新的值，必须将依赖关系直接传递到效果中。同样的逻辑也适用于道具。在这种情况下，效果比基于类的组件简单，因为它们也必须使用<code class="fe kw kx ky kz b">componentDidUpdate()</code>方法。</p><h1 id="7f4a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">这些方法在不同的时间被调用</h1><p id="04ee" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">React可以确定状态何时在<code class="fe kw kx ky kz b">componentDidMount()</code>方法中同步设置。让我们看看组件的实际生命周期:</p><ol class=""><li id="75ee" class="mj mk iq ka b kb kc kf kg kj ml kn mm kr mn kv mo mp mq mr bi translated">组件已安装</li><li id="c1d8" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">DOM是用从<code class="fe kw kx ky kz b">render()</code>返回的内容创建的</li><li id="e30b" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated"><code class="fe kw kx ky kz b">componentDidMount()</code>被调用，状态被更新</li><li id="ce84" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">DOM被重新呈现，内容被更新</li></ol><p id="eb0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有人可能会认为我们应该看到第一帧和第二帧之间的闪烁，但事实并非如此。React检测到状态已经更新，并且只显示第二帧。如果一个组件需要一个元素的比例，而这个比例只能在呈现DOM时计算，那么这就很有用。</p><p id="1f51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">钩子和<code class="fe kw kx ky kz b">useEffect()</code>都在组件安装后运行。不同之处在于，钩子也是在DOM内容被绘制之后运行的。因此，如果在一个效果方法中同步更新状态，当第一帧被第二帧替换时，用户将会看到闪烁。</p><p id="37d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过使用<code class="fe kw kx ky kz b">useLayoutEffect()</code>方法获得带有钩子的旧行为，该方法在内容提交到页面之前被调用。然而，大多数应用程序不需要使用这个钩子，大多数程序员应该坚持使用<code class="fe kw kx ky kz b">useEffect()</code>。</p><p id="6e02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于类的组件是围绕生命周期和时间设计的。相反，函数类的目标是与DOM同步状态。未能改变心态会导致一些奇怪的怪癖和错误，没有适当的知识很难解决。简而言之，人们应该考虑“根据状态，我的组件应该是什么样子，以及它应该在什么时候重新呈现。”这些问题将确保您的功能组件正常运行。</p></div></div>    
</body>
</html>