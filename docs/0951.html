<html>
<head>
<title>Integrating ActionCable with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将ActionCable与React集成</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/integrating-actioncable-with-react-9f946b61556e?source=collection_archive---------2-----------------------#2020-01-06">https://javascript.plainenglish.io/integrating-actioncable-with-react-9f946b61556e?source=collection_archive---------2-----------------------#2020-01-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ffa0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Action Cable是Ruby on Rails提供的一个框架，允许开发人员在他们的应用程序中使用WebSockets。</h2></div><p id="5c5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">WebSockets自2008年就已经出现，是一种完全独立于超文本传输协议(或HTTP)的协议。我非常熟悉使用HTTP的客户端和服务器之间的通信——客户端(我的浏览器)打开一个连接，向服务器发送某种请求(可能是加载网站，或者处理来自表单的输入)，服务器处理该请求，并以某种信息做出响应，然后连接关闭。这种来回操作在大多数情况下都非常有效。然而，有时应用程序需要非常频繁地从服务器获得更新的信息。一个例子是聊天功能。</p><p id="08b5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我属于一个聊天室，我的计算机(客户端)知道我的朋友是否给我发送了任何消息(如果我使用HTTP)的唯一方法是频繁地、定期地调用我的服务器来检查任何更新。这就是所谓的<em class="lb">轮询，</em>，我相信你能猜到，这是非常低效的。WebSockets通过在客户端和服务器之间创建一个<em class="lb">保持开放的TCP连接来消除这种低效。然后，不再是客户端一遍又一遍地向服务器请求更新，而是服务器一收到任何更新，<em class="lb">就会自动将它们推送到</em>该连接上的所有客户端。就像从对讲机升级到手机。</em></p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="lh li l"/></div></figure><h1 id="3dd8" class="lj lk iq bd ll lm ln lo lp lq lr ls lt jw lu jx lv jz lw ka lx kc ly kd lz ma bi translated">行动电缆和反应</h1><p id="636c" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">Action Cable的文档和大多数Rails文档一样，非常全面。但是，它假设您使用Rails作为全栈框架。如果你计划将一个Rails后端和一个独立的前端框架结合起来，那么关于如何整合ActionCable的资源是很稀缺的。这个博客是我试图澄清一些困惑，并帮助其他人开始。我已经创建了一个简单的聊天室应用程序，并将向您展示我是如何设置的。如果你想看完整的代码，这里有我在Github上的回复链接…</p><p id="477d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">后端—<a class="ae mg" href="https://github.com/jennyjean8675309/chitter_chat" rel="noopener ugc nofollow" target="_blank">https://github.com/jennyjean8675309/chitter_chat</a></p><p id="7303" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前端—<a class="ae mg" href="https://github.com/jennyjean8675309/chitter_chat_frontend" rel="noopener ugc nofollow" target="_blank">https://github.com/jennyjean8675309/chitter_chat_frontend</a></p><h2 id="1bd5" class="mh lk iq bd ll mi mj dn lp mk ml dp lt ko mm mn lv ks mo mp lx kw mq mr lz ms bi translated">入门指南</h2><p id="b617" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">我的Rails后端相当简单——我想将我的应用程序设计成有三个聊天室。每个聊天室都有许多消息(来自许多用户)，消息充当聊天室和用户之间的连接表。所以我的后端只有三个模型——房间、消息和用户，以及相应的控制器。</p><p id="83b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">*我的应用程序还包含了用于用户图像上传和授权的ActiveStorage(使用bcrypt gem和jwt令牌)，这导致了一些额外的控制器，但这些对于理解Action Cable是不必要的——在本文中，我将尝试只引用与Action Cable相关的代码。</em></p><h2 id="8b45" class="mh lk iq bd ll mi mj dn lp mk ml dp lt ko mm mn lv ks mo mp lx kw mq mr lz ms bi translated">路线</h2><p id="3b7f" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">我的第一步是为后端设置我的路线。在routes.rb文件中，您需要指定以下内容:</p><pre class="lc ld le lf gt mt mu mv mw aw mx bi"><span id="2166" class="mh lk iq mu b gy my mz l na nb">resources :rooms, only: [:index, :show]<br/>resources :messages, only: [:index, :create]<br/>resources :users, only: [:index, :create]<br/>mount ActionCable.server =&gt; '/cable'</span></pre><p id="b653" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您以前使用过Rails，那么前三行应该相当熟悉。最后一个有点奇怪——先说一下。记住WebSockets是它们自己的协议——它们不需要指定请求的类型(即get、post、put等)。)就像我们处理HTTP一样。相反，我们简单地<em class="lb">为我们的服务器安装</em>一个路由来处理WebSocket连接——我们的前端将连接到“/cable”端点来实例化一个连接——但是我们将稍后再做。</p><h2 id="c58b" class="mh lk iq bd ll mi mj dn lp mk ml dp lt ko mm mn lv ks mo mp lx kw mq mr lz ms bi translated">连接</h2><p id="c482" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">连接，我相信你可能已经猜到了，将客户机连接到服务器。每当服务器接受WebSocket(来自客户端)时，就会初始化一个连接。为了让WebSocket被接受，Rails提供了一个父ApplicationCable::Connection类(可以在channels-&gt; application _ cable-&gt; Connection . Rb中找到),它唯一的工作就是对当前用户进行身份验证和授权。因为我的前端正在为我的应用程序处理身份验证，所以我在后端忽略了这个过程，将类留空。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/72a357c0634e37e78b1e5a302bc4489b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1070/format:webp/1*Cy9Weau0C5DXuPkHSfvfnA.png"/></div></figure><p id="9ff3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单个动作有线服务器可以处理多个连接，并且单个用户(即客户端)可以简单地通过打开新的浏览器标签或窗口来打开多个连接。用有线电视的话说，通过WebSocket连接到你的服务器的客户被称为<em class="lb">消费者</em>。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nf li l"/></div></figure><p id="94df" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了说明我的意思，在上面的视频演示中，我有一个客户端(我的Chrome浏览器)通过打开两个窗口，实例化了两个单独的WebSocket连接到我的后端Action Cable服务器。他们都连接到我的服务器，但在右边我以“betty”登录，在左边以“harold”登录。因为两个用户都订阅了爱猫空间(单一频道)，所以有源源不断的交流来回流动。这意味着当贝蒂发送信息时，哈罗德会自动接收。这就是所谓的发布/订阅链接(或发布-订阅)。信息的<em class="lb">发布者</em>(即发送者)将数据推送到该特定频道的<em class="lb">所有订阅者</em>(不直接识别个人接收者)。这意味着，如果有一群其他用户订阅了爱猫室，他们将同时收到贝蒂的信息。</p><h2 id="805c" class="mh lk iq bd ll mi mj dn lp mk ml dp lt ko mm mn lv ks mo mp lx kw mq mr lz ms bi translated">频道</h2><p id="4c5e" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">您可以将通道视为一个单独的通信流，信息在其中来回流动。我有三个聊天室，每个聊天室都有自己的频道——每个想聊猫的用户都可以订阅爱猫人士频道，可以向订阅该频道的所有其他用户发送信息，也可以从订阅该频道的所有其他用户那里接收信息。我的Trekkies频道和阴谋论者频道也是如此。</p><p id="c9e3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与ApplicationRecord和ApplicationController类似，Rails创建了一个父ApplicationCable::Channel来处理通道之间的所有共享逻辑。</p><p id="b686" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如Rails中的控制器对应于模型一样，通道也是如此。因为我的三个通道都是房间模型的实例，所以我只需要创建一个通道类，我将其命名为RoomsChannel。那么，你可能会问，我的应用程序如何知道用户预订了哪个房间？答案是，我的前端将把关于房间的信息发送到后端(以params的形式)，然后我的RoomsChannel类将找到指定的特定房间，并只传输那个房间的信息。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ng"><img src="../Images/b956068170b5c73d0f665aff88061e9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4E2C6rlQ_7zo-6OwR5M-aw.png"/></div></div></figure><p id="2bb6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我的RoomsChannel继承自ApplicationCable::Channel。现在让我们转到前端(客户端)来看看这一切是如何关联的。</p><h2 id="77cc" class="mh lk iq bd ll mi mj dn lp mk ml dp lt ko mm mn lv ks mo mp lx kw mq mr lz ms bi translated">作为消费者的前端</h2><p id="5628" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">我已经为我的前端创建了一个基本的React应用程序。为了利用WebSockets，我需要做的第一件事是将我的前端客户端设置为一个<em class="lb">消费者</em>。请记住，一个用户(即一个自然人)可以同时打开多个连接，因此可以有多个消费者(将消费者想象成浏览器标签或窗口)。</p><p id="91c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，跑步</p><pre class="lc ld le lf gt mt mu mv mw aw mx bi"><span id="d27e" class="mh lk iq mu b gy my mz l na nb">npm install actioncable --save</span></pre><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nl"><img src="../Images/8fe65d7eecd4878235ab18effbbbab0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R4Nfr1PMkwTPfn6dmMT64Q.png"/></div></div></figure><p id="99d5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">安装actioncable节点包允许我们使用createConsumer()函数。还记得我们在后端安装WebSockets的路由吗？—这是我们打开连接的地方。注意，url的前缀是<em class="lb">而不是</em> http，而是ws——这是因为我们现在处于WebSocket协议的世界中！</p><p id="4798" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们将前端客户端创建为消费者，请注意，我现在将CableApp对象作为道具传递给我的应用程序组件。</p><h2 id="4cff" class="mh lk iq bd ll mi mj dn lp mk ml dp lt ko mm mn lv ks mo mp lx kw mq mr lz ms bi translated">数据结构</h2><p id="bf58" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">我在应用程序中有很多事情发生，但我们现在将忽略其中的大部分。首先，我想让大家关注一下App组件的状态。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nm"><img src="../Images/01fa0e78cc31153d6982b23d407da222.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*32YOuNMZrUbe16CxRDfFGQ.png"/></div></div></figure><p id="b589" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里需要注意的重要部分是currentRoom的<em class="lb">数据结构</em>——我将在整个应用程序中坚持使用相同的数据结构。认识到这种数据结构也匹配来自后端的广播信息是很重要的。回头参考rooms_channel.rb …</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nn"><img src="../Images/b9910e554900e79b3c5d114c99138eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KtLTXBq_PASqq2pKxTOrvg.png"/></div></div></figure><h2 id="cd89" class="mh lk iq bd ll mi mj dn lp mk ml dp lt ko mm mn lv ks mo mp lx kw mq mr lz ms bi translated">发送信息</h2><p id="6c6f" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">现在事情变得有点棘手了，但是我会尽可能的说清楚…现在继续听我说！</p><p id="a00c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我想关注的主要组件是我的RoomShow组件。我在App.js中为这个组件声明了一个路由。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi no"><img src="../Images/56ee566e432ee9fbf17a371f96da00dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WUxgnosEpwmg01SpaTrwZQ.png"/></div></div></figure><p id="7849" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我的RoomShow组件在浏览器中的样子…</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi np"><img src="../Images/0a5d5e841f5b29bb8492747b07f1378d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WNoLx1mW4y8SKXkjIx9THg.png"/></div></div></figure><p id="eeb6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我的RoomShow组件保存了用户提交新消息的表单。它也是我的ChatFeed组件(灰色框)的父组件，该组件是各个ChatMessage组件的父组件。RoomShow也是另一个我们看不见的组件——RoomWebSocket——的父组件。</p><p id="0299" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意我从应用程序中作为道具发送的内容…</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nq"><img src="../Images/ca448c3211462ef1ea0e34106e812ab7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TZXrFWl0Z9YLhB9HabicQw.png"/></div></div></figure><p id="d498" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个是router props，第二个是cableApp，我们已经看到了，是到我们从index.js创建的WebSocket的连接。接下来的两个，getRoomData和updateApp是函数…</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nr"><img src="../Images/46ef2b34aff36db3881ab7739cb80137.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9oCXNJNcCFkijhtrY3EWJA.png"/></div></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ns"><img src="../Images/94cd233bec02ab9358dd519fae96b0ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QXBszJC9mhTjIsFBs7XthQ.png"/></div></div></figure><p id="da58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">roomData和currentUser都是状态片段，分别跟踪我的用户正在查看的当前房间和当前登录的用户。</p><p id="0d25" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在回到我上面提到的那个不可见的RoomWebSocket组件…</p><h2 id="c9ea" class="mh lk iq bd ll mi mj dn lp mk ml dp lt ko mm mn lv ks mo mp lx kw mq mr lz ms bi translated">WebSocket组件</h2><p id="54ed" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">从我们的RoomShow组件呈现的最后一个组件是RoomWebSocket。尽管这个组件是不可见的(也就是说，它没有在浏览器中呈现任何东西)，但它是至关重要的。它收到了来自RoomShow的三个道具…</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/4b5382b647ee05f49506967d474432de.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/format:webp/1*Atdz_I57Vyg4QdfoIFD97w.png"/></div></figure><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/bf23d2b0d1f47b74b1fbf33d7ff4c69c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*o-dOsogf8_hvXqtBE_zrYg.png"/></div></figure><p id="a2bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有的动作都发生在这个组件挂载的时候。第一个被调用的函数是getRoomData()。这是我的应用程序中唯一调用这个函数的地方。它将房间id(从我的窗口位置获取)作为参数传入，对我的后端进行fetch调用，并为我的用户正在查看的当前房间设置状态。</p><h2 id="23c2" class="mh lk iq bd ll mi mj dn lp mk ml dp lt ko mm mn lv ks mo mp lx kw mq mr lz ms bi translated">创建订阅</h2><p id="4310" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">我们的RoomWebSocket组件也是(惊喜！惊喜！)我们的客户机和服务器之间的通信(通过我们在index.js中打开的连接)发生了。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/5c32ad4cef116c004c66e4693b030f80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1390/format:webp/1*5Rm87QSXwBpkk2VmvFCKAw.png"/></div></figure><p id="de38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意上面的第8–11行——在这里，我们的消费者通过创建订阅成为订阅者。有两个参数(对象)传递给了subscriptions.create()函数。第一个对象有两个键— channel(必需的)，它指定我们正在为其创建订阅的频道(' RoomsChannel ')，以及room，它的值是我们从窗口位置获取的房间id。</p><p id="1bc4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我把一个byebug放在我房间频道的订阅动作中，像这样…</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nw"><img src="../Images/f65c8562913d2448c3baa2cd602a5b80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fAmrB99vPGi0yDAEa_Sb6A.png"/></div></div></figure><p id="6133" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">…当我导航到一个RoomShow页面时，我可以在我的代码中暂停一会儿，以期待来自终端的参数。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi nx"><img src="../Images/5d32b24c5b2c561d611f881f3c69bf62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K9ctsqJz-mK_h491ojucNg.png"/></div></div></figure><p id="69aa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，我们从RoomsChannel订阅的操作首先找到我们想要连接到其通道的特定房间，然后使用stream_for命令创建一个通信流。移除byebug后，您应该可以在终端上看到一条消息，表明您正在直播信息！！！</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi ny"><img src="../Images/0492958df960cf56946fb43526f36d34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q5lvsehSy4Wk3_t_eEnY3A.png"/></div></div></figure><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nz li l"/></div></figure><p id="0d73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在不要太骄傲了…</p><h2 id="64b5" class="mh lk iq bd ll mi mj dn lp mk ml dp lt ko mm mn lv ks mo mp lx kw mq mr lz ms bi translated">广播</h2><p id="ccd8" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">现在，我们知道我们确实在将信息从前端消费者传输到后端，但是这些更新是如何被推出的呢？答案来自我们处理信息的方式。</p><p id="52a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当用户提交新消息时，会向后端发出一个HTTP post请求，由MessagesController处理…</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="nh ni di nj bf nk"><div class="gh gi oa"><img src="../Images/36cf0d44c320c693818b08b765c96fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dW4XiGxoQB8ZSEhClieh5w.png"/></div></div></figure><p id="5234" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的MessagesController的create操作中，如果成功地创建了一条新消息并保存到我的数据库中，那么我会向为其创建该消息的特定房间频道发送一条新的广播。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/bb3ec2ba3eca6a49676af20e76fed05a.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*bRiqqN4myDKM-9jBzH4i4A.png"/></div></figure><p id="c574" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">my subscriptions.create()函数的第二个参数是一个带有一个键received的对象，它指向一个回调函数。当在该通道上接收到新信息时，就像上面我创建新消息的例子一样，这个回调函数被调用并自动更新我的应用程序中的状态！</p><h2 id="0ee0" class="mh lk iq bd ll mi mj dn lp mk ml dp lt ko mm mn lv ks mo mp lx kw mq mr lz ms bi translated">结论</h2><p id="27d6" class="pw-post-body-paragraph kf kg iq kh b ki mb jr kk kl mc ju kn ko md kq kr ks me ku kv kw mf ky kz la ij bi translated">总之，WebSockets和Action Cable非常可爱！我希望对Action Cable和React的介绍能帮助到一些人！</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oc li l"/></div></figure></div></div>    
</body>
</html>