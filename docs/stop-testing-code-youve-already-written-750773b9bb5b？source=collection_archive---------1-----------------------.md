# 停止测试你已经写好的代码

> 原文：<https://javascript.plainenglish.io/stop-testing-code-youve-already-written-750773b9bb5b?source=collection_archive---------1----------------------->

## 一步一步来测试，而不是一座山一座山来测试

![](img/b4e86baf68bab614710414761c403b1d.png)

Photo by [Sven Scheuermeier](https://unsplash.com/@sveninho?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

一年中的这个时候，我们开始许下承诺，但到了二月，我们可能就忘记了。新年决心通常是善意的，但我们通常试图用我们以前尝试过的方式来解决同样的老问题。健康饮食。多去健身房。学习一门新的语言。编写更多的单元测试。

每次我和一个正在挣扎的团队谈话，问他们下次会有什么不同，我总是得到相同的回答:我们会写更多的测试。有时会有其他答案，但是测试是我们都认为应该做得更好的事情。

同样的团队一次又一次地做出同样的决定，所以我想知道为什么像这样的团队没有编写足够的测试。“足够的测试”可能是一个糟糕的词汇选择——测试的质量和数量一样重要。但是不管怎样:基于我自己的轶事发现，我们大多数人认为我们应该写更多/更好的测试。

那我们为什么不呢？当我从逻辑上思考时，有一个明显的结论(对一个狂热于 TDD 的人来说是显而易见的)。事后很难编写测试。

你看，测试驱动开发迫使你以易于测试的小步骤编写代码。我可能会写一个测试，然后再写几行，接着是另一个测试，接着是另外几行。

但是大多数在编写了特性之后编写测试的团队并不使用这种增量方法。在开始测试之前，您可能要编写 200 行代码。这给你留下了一个可工作的特性，很少有动力去测试它，并且在你完成之前有很多重构工作要做。

为什么要重构？嗯，那 200 行可能不太好考。为了使它们可测试，你需要做一点重构。重构很容易破坏你的代码，但是至少你有一个测试安全网来…哦，等等。看到问题了吗？

所以先写你的测试。它不仅从一开始就给你一个安全网，而且还意味着少了一次重构。或者更准确地说，这意味着重构将被分解成更小的块，更容易管理。这提供了一个更短的反馈循环，比不得不在最后重构更好地保持代码在正确的轨道上。

# 什么是 TDD，为什么要关心它？

测试驱动开发是在编写测试代码之前编写测试的行为。想写一个功能，让您添加一个产品到您的篮子？首先编写一个测试来检查该特性是否有效。测试将会失败，因为特性还没有被编写。然后，您可以编写特性来通过测试。简单吧？

## 我如何测试我还没有写的东西？

如果你想测试你还没有写的 200 行代码，你会很难做到。当你在写它们的时候，考虑接下来的 200 行已经够难的了，更不用说当你试图找出如何测试它们的时候。这个想法不是在你开始实现之前写一个完整特性的测试。这将需要难以置信的远见来准确地知道你将如何实现这个特性，而不需要任何类型的反馈。

相反，您只进行了足以导致测试失败的测试。这让你专注于眼前的问题，而不是最终的目的地。和往常一样，我发现在这种情况下例子很有用:

假设你正在一个电子商务网站上写一个篮子。目前，在向购物篮添加商品之前，添加商品不会检查库存水平。您需要确保产品只有在有库存时才能添加到购物篮中。

一开始你可能会想到一大堆测试。以下是我想到的一些例子:

1.  假设产品 A 有库存(数量> 0)
    当我将产品 A 添加到我的购物篮
    时，我的购物篮中应该有 1 个产品 A
2.  假设产品 A 有库存(数量= 0)
    当我将产品 A 添加到我的购物篮
    时，应该会出现一个错误，告诉我该商品没有库存
3.  假设产品 A 有库存(数量= 1)
    当我将 2 个产品 A 添加到我的购物篮
    时，应该会出现一个错误，告诉我库存不足

假设已经有了向购物篮中添加商品的测试(不检查库存)，那么测试 1 应该很容易编写，所以我们应该从那里开始。写下其他测试案例，只关注你面前的问题，即“我们如何检查库存水平？”

您的第一个测试可能看起来像这样:

这算不上什么测试——甚至还没有任何断言！但是当考虑如何检查库存水平时，我决定需要注入一个服务来完成这项工作。当我试图用这个服务实例化 Basket 类时，我得到一个错误，因为构造函数不需要任何参数。这是一个失败的测试，即使它只是由编译失败而不是断言引起的。

我还不知道服务上会有什么方法，但我现在可以更新`Basket`类，在其构造函数中接受 StockService。完成后，测试应该“通过”(即编译)，此时我可以继续我的第一个断言:

同样，我已经写了使测试失败的最小量。我认为我需要一个名为`getStockLevel`的方法，所以我实现了一个 spy，但没有返回值。我只想进入下一个论断。

这并不意味着你一次只考虑一个问题，而是简单地说，那些注意力最集中的人就是现在离你最近的人。不要把注意力集中在你还没有解决的问题上，因为你会把脑力从你已经解决的问题上夺走。当你不得不解决那个遥远的问题时，它可能看起来完全不同了。

这是我认为人们忘记解释测试驱动开发的一件事。这不仅仅是写更好的测试，而是自然地将大问题分解成小问题。因此，与有 200 行代码要测试的情况相比，测试通常不那么令人生畏。您通常只是试图找到导致测试运行失败的最少测试量，然后是通过测试的最少代码量。

如果需要的话，你可以重构。这一次你有了一个安全网，就是你刚刚写的测试。这个过程通常被称为红绿重构。

*   红色是当你考试失败的时候。
*   绿色表示测试通过。
*   重构是当你审视你是如何通过测试的，并决定有一个更好的方法。不要说“我们以后再解决这个问题”，而是现在就努力解决它，趁它还在你的脑海里。

请记住，这一切都是为了保持这个循环尽可能短。如果可以的话，你应该每隔几分钟就在测试/实现之间切换一次。这样做会把你正在解决的问题分解成可消化的小块，不会让你的大脑烧心。

因此，停止为你已经编写的代码编写测试，开始为你还没有编写的代码编写测试。