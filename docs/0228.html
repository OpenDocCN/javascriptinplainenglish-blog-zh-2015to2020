<html>
<head>
<title>JavaScript Classes: An In-Depth look (Part 2)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript类:深入研究(第2部分)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-classes-an-in-depth-look-part-2-88b666ed3546?source=collection_archive---------1-----------------------#2019-08-29">https://javascript.plainenglish.io/javascript-classes-an-in-depth-look-part-2-88b666ed3546?source=collection_archive---------1-----------------------#2019-08-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0c9c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">现在你是一名优秀的JavaScript开发人员</h2></div><h1 id="997e" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">欢迎回来</h1><p id="bafd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在第1部分中，我们介绍了一些核心术语，构建了一个简单的Person类，并演示了如何将数据隔离到对象中。</p><p id="e4dc" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我们展示了如何将它打包成一个漂亮的数组，以便进一步操作，以及如何在Json字符串之间进行转换。</p></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="445c" class="kf kg iq bd kh ki mg kk kl km mh ko kp jw mi jx kr jz mj ka kt kc mk kd kv kw bi translated">第二部分</h1><p id="075a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这一部分，我们将，</p><ol class=""><li id="89c0" class="ml mm iq kz b la lu ld lv lg mn lk mo lo mp ls mq mr ms mt bi translated">学习一些额外的术语。</li><li id="80b4" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated">使用getter和setter方法，get()和set()来添加功能和更好的封装。</li><li id="34c9" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated">理解并使用支持字段前缀“_”。</li><li id="bc50" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated">在我们的类中创建方法来赋予类功能。</li></ol><p id="85b1" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">和以前一样，</p><blockquote class="mz"><p id="44c7" class="na nb iq bd nc nd ne nf ng nh ni ls dk translated">我鼓励你编码，探索和扩展我们创造的东西。</p></blockquote></div><div class="ab cl lz ma hu mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ij ik il im in"><h1 id="b1ed" class="kf kg iq bd kh ki mg kk kl km mh ko kp jw mi jx kr jz mj ka kt kc mk kd kv kw bi translated">我们开始吧</h1><p id="12db" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我希望我们从第1部分的Person类开始。</p><figure class="nk nl nm nn gt no gh gi paragraph-image"><div role="button" tabindex="0" class="np nq di nr bf ns"><div class="gh gi nj"><img src="../Images/d3a791070a62c7e791929deb6244980d.png" data-original-src="https://miro.medium.com/v2/resize:fit:472/format:webp/1*IAP6WYmjyQFwlRXJwh2FdA.jpeg"/></div></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Person class</figcaption></figure><p id="92ef" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">至此，我们学习了如何创建Person对象，并对它们的属性进行了一些处理:姓名和年龄。</p><p id="a1bd" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我想指出的是，尽管我们可以在<em class="nz">实例化</em>或<em class="nz">创建</em>我们的对象时将数据传递给构造函数，但我们没有。</p><p id="7ecf" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">比较下面的三个代码示例。第一个在创建时设置属性name和age。第二个和第三个在对象创建后设置name和age的值。他们都达到了同样的结果。</p><p id="1037" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">例1 </strong></p><figure class="nk nl nm nn gt no gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/a5c27c2ccd519ffc821a46f025672555.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*GDqCr3w5GctO0YFV21_09w.jpeg"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Setting the properties upon creation</figcaption></figure><p id="9f9d" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">例2 </strong></p><figure class="nk nl nm nn gt no gh gi paragraph-image"><div class="gh gi ob"><img src="../Images/3372705b939efc05aa0447ec2ece09cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:734/format:webp/1*W4aAmmHZyxoXH5ay_0nuag.jpeg"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Having, but not using the constructor parameters</figcaption></figure><p id="ca1d" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">第三个变体在构造函数中没有参数。<strong class="kz ir">注意属性只是被声明，而不是被初始化。</strong>如果需要，我们可以设置默认值。</p><p id="363a" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">例3 </strong></p><figure class="nk nl nm nn gt no gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/804be95f1073ad2500bf29ed55994e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:738/format:webp/1*AbDkaGBN2doOobJ1_QcO1w.jpeg"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">No constructor parameters</figcaption></figure><p id="c1f5" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">对你自己来说，你可以选择一种方法，或者三种都用。</p><blockquote class="od oe of"><p id="42c7" class="kx ky nz kz b la lu jr lc ld lv ju lf og lw li lj oh lx lm ln oi ly lq lr ls ij bi translated">第二个(例2)是最灵活的，因为它为消费或使用该类的人(可能是您或另一个开发人员)提供了更多关于如何创建他们的对象的选项。</p></blockquote><p id="21e8" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">为了证明我上面的陈述，请看下面。请注意，在使用示例2中的语法时，我是如何用三种不同的方式构建对象并设置它们的属性的。</p><p id="71ae" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">例4 </strong></p><figure class="nk nl nm nn gt no gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/0d1f0c05e7174849edc946b8552e6000.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*lzFE22V5jTn7cWhm5GsrkQ.jpeg"/></div></figure><blockquote class="od oe of"><p id="975b" class="kx ky nz kz b la lu jr lc ld lv ju lf og lw li lj oh lx lm ln oi ly lq lr ls ij bi translated">我们会说这个类有<strong class="kz ir"> <em class="iq">重载</em> </strong>，这仅仅意味着我们有多种创建对象的方法。</p></blockquote><blockquote class="mz"><p id="ed2e" class="na nb iq bd nc nd ok ol om on oo ls dk translated">我鼓励你仔细研究这些，并进行比较。键入它们并进行实验。</p></blockquote><h1 id="0f10" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw op jx kr jz oq ka kt kc or kd kv kw bi translated">构建更加结构化和功能化的类</h1><p id="2f2b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在我们有了基础，我们需要实现约定和最佳实践。</p><p id="d4b1" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">此外，除了存储数据之外，我们还想给我们的类添加一些功能。</p><p id="ece2" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">首先，请注意，让我们这一类的消费者能够直接使用属性并不被认为是好的设计。</p><p id="8b3f" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我们所做的是通过使用setter和getter方法来“屏蔽”我们的实际属性，它们将具有我们属性的名称。</p><p id="7b20" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">然后，我们将在实际存储数据之前添加逻辑和检查。</p><p id="2a5a" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在下一个例子中，我将展示与get和set方法一起使用的典型约定。这里有很多东西需要研究。一会儿我会进一步解释。</p><blockquote class="od oe of"><p id="98bd" class="kx ky nz kz b la lu jr lc ld lv ju lf og lw li lj oh lx lm ln oi ly lq lr ls ij bi translated">如果遵循，它给我们的类一个良好定义的结构，并开始构建功能。</p></blockquote><p id="7a81" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">例5 </strong></p><figure class="nk nl nm nn gt no gh gi paragraph-image"><div class="gh gi os"><img src="../Images/82cb31e2ad18910f609487065482a66f.png" data-original-src="https://miro.medium.com/v2/resize:fit:948/format:webp/1*ZX3oQflJaUpRsAxspKxQBQ.jpeg"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Set and get methods</figcaption></figure><p id="08ce" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">起初，这看起来工作量很大，因为输出看起来与我们最初的Person类没有任何不同。</p><p id="ad45" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">然而，这为我们通过添加逻辑和检查来控制参数的设置奠定了基础。具体到我们的类，至少我们可以做这样的事情，</p><ol class=""><li id="b5ea" class="ml mm iq kz b la lu ld lv lg mn lk mo lo mp ls mq mr ms mt bi translated">验证传入名称，确保它至少有三个字符。</li><li id="0154" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated">验证即将到来的年龄，以确保它在我们想要的范围内。</li><li id="b6bb" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated">以特定格式返回数据。</li></ol><p id="cdd1" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">事实上，我们的选择几乎是无限的。</p><p id="16ea" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">设置说明</strong></p><p id="11d4" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">那么在例5中到底发生了什么呢？</p><p id="9d9e" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">set和get方法<em class="nz"> </em>用一个同名的方法<em class="nz">替换属性名，但是在使用时表现得像一个属性</em>。</p><p id="3f42" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">当我们说person1.name='Bob '，<em class="nz">它实际上调用了set方法，set name(newName) </em>。然后，该方法将真实重命名属性_name的值设置为“Bob”。</p><p id="8361" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">注意语法person1.name='Bob '就像我们在开始时设置属性的方式一样。但是它是通过一个方法传递的，<em class="nz">这给了我们控制数据的能力。</em></p><blockquote class="od oe of"><p id="22fe" class="kx ky nz kz b la lu jr lc ld lv ju lf og lw li lj oh lx lm ln oi ly lq lr ls ij bi translated">但是现在，我们可以在设置实际属性之前，在set方法中运行逻辑(或检查),这一点很快就会显示出来。这提供了更多的控制！</p><p id="e9ca" class="kx ky nz kz b la lu jr lc ld lv ju lf og lw li lj oh lx lm ln oi ly lq lr ls ij bi translated">如MDN网站<em class="iq">所述，set方法语法将对象属性绑定到试图设置该属性时要调用的函数。</em></p></blockquote><p id="f067" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">上面提到的函数是out set方法。</p><p id="c695" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">获取的解释</strong></p><p id="3326" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我不会详细阐述get方法，因为它执行与set类似的功能，但会返回dats。它也像实际的属性一样。但是它也可以有在返回属性值之前运行的逻辑。</p><p id="c4b6" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">重要！</strong></p><blockquote class="od oe of"><p id="f3cf" class="kx ky nz kz b la lu jr lc ld lv ju lf og lw li lj oh lx lm ln oi ly lq lr ls ij bi translated">按照惯例，set和get使用与原始属性相同的名称。因为这样做了，所以原始属性应该由支持前缀“_”来区分。</p></blockquote><p id="644e" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">不要求使用支持前缀，这是惯例，但是set和get方法名<strong class="kz ir">必须</strong>不同于属性名。</p><p id="df4a" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><em class="nz">无法区分属性名和用于set或get的名称将导致溢出</em>。见下文。</p><p id="4554" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">这是因为当一个set或get使用它的名字被调用时，并且set或get也使用这个名字，它无限地调用它自己。请看下面，在这里我为每个属性设置并获取与属性相同的名称。</p><p id="1c71" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">例6 </strong></p><figure class="nk nl nm nn gt no gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/43f396740247533d4560dd61b51dd54b.png" data-original-src="https://miro.medium.com/v2/resize:fit:930/format:webp/1*4Q0ym3gwkuHjc4GI9jA2fg.jpeg"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Keep property names different from set and get names. Backing prefix is the convention</figcaption></figure><h1 id="9f06" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">添加逻辑</h1><p id="9877" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在我们有了一个定义良好的结构，让我们添加我们一直在讨论的逻辑。</p><p id="6b97" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我们将做一些简单的事情来演示它是如何工作的。我鼓励你尝试更多的逻辑和检查。</p><p id="648f" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">这是我希望我们做的，</p><ol class=""><li id="54fa" class="ml mm iq kz b la lu ld lv lg mn lk mo lo mp ls mq mr ms mt bi translated">在name的set方法中，确保名称的长度至少为三个字符。</li><li id="5974" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated">在name的get方法中，检查以确保名称存在，如果不存在，则返回一条消息。</li><li id="1bb0" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated">在年龄的设置方法中，确保年龄在1到125之间。</li></ol><p id="9d63" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">例7 </strong></p><figure class="nk nl nm nn gt no gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/49abe7e134acc1d550b33dfdc7a21799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1090/format:webp/1*9lxWEobpRZ_zlcvu5XNPhw.jpeg"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Testing get and set logic</figcaption></figure><p id="9d20" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">这是一个简单的演示，但它清楚地表明了设置和获取的目的是什么。还要注意，get name()逻辑对空字符串的检查不为真，因为set name()逻辑会处理这一点。</p><p id="3a04" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">查看get name()逻辑。</p><p id="376e" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">例八</strong></p><figure class="nk nl nm nn gt no gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/03080edff704272a480e31143ff8abee.png" data-original-src="https://miro.medium.com/v2/resize:fit:836/format:webp/1*u5NtjmPRCrs6cxmQiTeJdQ.jpeg"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">get name() logic</figcaption></figure><p id="afb2" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">重要的是要注意，因为构造函数是一个方法，它也可以有逻辑。这将不会在这里处理，但会在第3部分做一个很好的演示。</p><h1 id="3672" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">方法</h1><p id="689f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你可能还记得我们提到过，类可以有<em class="nz">属性</em>和<em class="nz">方法</em>。我们已经看到了构造函数、set和get的特殊方法。</p><p id="1664" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我指的是其他方法。</p><p id="61e3" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">什么是方法？</strong></p><blockquote class="od oe of"><p id="76f1" class="kx ky nz kz b la lu jr lc ld lv ju lf og lw li lj oh lx lm ln oi ly lq lr ls ij bi translated">方法是一个函数。</p></blockquote><p id="5584" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">当我们在一个类中编写方法时，我们给它一个名字，但是不使用<em class="nz">函数</em>关键字。虽然属性是对象的数据，但方法通常被称为行为。</p><p id="3f7e" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我们使用语法objectName.methodName()调用函数。</p><p id="c1ad" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">方法以及set和get可以出现在构造函数的上面或下面。</p><blockquote class="od oe of"><p id="1e46" class="kx ky nz kz b la lu jr lc ld lv ju lf og lw li lj oh lx lm ln oi ly lq lr ls ij bi translated">方法决定了类的功能。</p></blockquote><p id="ff1a" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">例9 </strong></p><p id="3ab9" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">在这个例子中，我们将编写两个方法。一个显示人的姓名和年龄。另一个是考虑到他们年龄的增长。</p><figure class="nk nl nm nn gt no gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/dce229b331aa9cb8113494bb2b99910c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1130/format:webp/1*kykWH5qR6KmY-OmpY9wV5w.jpeg"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Methods are the functionality of the class</figcaption></figure><p id="32dd" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我们当然可以添加更多的功能，更多的数据检查和处理。但是这将为您提供一个良好结构的函数式simple的良好起点。</p><h1 id="915f" class="kf kg iq bd kh ki kj kk kl km kn ko kp jw kq jx kr jz ks ka kt kc ku kd kv kw bi translated">结论:</h1><p id="d42d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在第二部分中，我们介绍了一些额外的术语，但最重要的是学习了如何构建一个结构良好的类，能够将其数据和功能封装在一个对象中。</p><p id="6964" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">综上所述，</strong></p><ol class=""><li id="ca60" class="ml mm iq kz b la lu ld lv lg mn lk mo lo mp ls mq mr ms mt bi translated">构建您的类。</li><li id="55d1" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated">用逻辑添加set和get方法。</li><li id="7a20" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated">用方法添加功能。</li></ol><p id="23b5" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">第二部分结束</strong>。请和我一起看第三部分，</p><ol class=""><li id="9483" class="ml mm iq kz b la lu ld lv lg mn lk mo lo mp ls mq mr ms mt bi translated">继续在我们的课上探索方法。</li><li id="319d" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls mq mr ms mt bi translated">在我们的类中使用类。</li></ol><blockquote class="mz"><p id="9eb2" class="na nb iq bd nc nd ok ol om on oo ls dk translated">我鼓励你去尝试。</p></blockquote><p id="7a12" class="pw-post-body-paragraph kx ky iq kz b la ox jr lc ld oy ju lf lg oz li lj lk pa lm ln lo pb lq lr ls ij bi translated">同时，感谢阅读！</p><ul class=""><li id="2301" class="ml mm iq kz b la lu ld lv lg mn lk mo lo mp ls pc mr ms mt bi translated">第三部分</li><li id="2c84" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls pc mr ms mt bi translated"><a class="ae lt" href="https://medium.com/javascript-in-plain-english/a-practical-use-case-for-javascript-classes-8558f2ee1b09?source=friends_link&amp;sk=e761504545af36df0bc83ff61f381283" rel="noopener">有趣的使用案例</a></li><li id="6797" class="ml mm iq kz b la mu ld mv lg mw lk mx lo my ls pc mr ms mt bi translated"><a class="ae lt" href="https://medium.com/javascript-in-plain-english/a-practical-use-case-for-javascripts-object-assign-3c37e2e42d42" rel="noopener">实际使用案例</a></li></ul><p id="f9f0" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">或者跳到<a class="ae lt" href="https://link.medium.com/nrwjRHTQH0" rel="noopener">第四部</a></p><h2 id="a47e" class="pd kg iq bd kh pe pf dn kl pg ph dp kp lg pi pj kr lk pk pl kt lo pm pn kv po bi translated">附录</h2><p id="490d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">自从我最初发表这篇文章以来，就有人问我应该或者必须在哪里设置属性。它们不必在构造函数中设置。它们只能由set()方法设置。</p><p id="3bde" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">我如何做取决于我想如何使用这个类或者我想如何让别人实现这个类。</p><p id="6f60" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">如果将属性放在构造函数中，参数放在构造函数中，那么类的使用者可以选择在实例化时填充类。如果您还提供了set()方法，它们可以实例化一个空对象，然后在以后设置属性。下面是两个简单的例子。为了说明这一点，我把这些保持得非常简单。</p><p id="2dad" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">例10:构造函数和set()方法中的属性。</strong></p><figure class="nk nl nm nn gt no gh gi paragraph-image"><div class="gh gi pp"><img src="../Images/491ff0724db5641cfb09145e95e3edd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*FqmTnzukRNWOAH6DPUslDw.jpeg"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Two options for the consumer of the class</figcaption></figure><p id="b9b7" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated"><strong class="kz ir">示例11:构造函数中没有属性。</strong></p><figure class="nk nl nm nn gt no gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/ca78755b3ffee5292ff7fe815d410836.png" data-original-src="https://miro.medium.com/v2/resize:fit:726/format:webp/1*UNsiv0L6q40PxzP3TSGr-Q.jpeg"/></div><figcaption class="nv nw gj gh gi nx ny bd b be z dk">Only settable in with the set() method.</figcaption></figure><p id="2a3e" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">不管怎样，您必须有一个构造函数来构建对象。</p><p id="4dcb" class="pw-post-body-paragraph kx ky iq kz b la lu jr lc ld lv ju lf lg lw li lj lk lx lm ln lo ly lq lr ls ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>