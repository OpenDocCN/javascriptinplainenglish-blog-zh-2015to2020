<html>
<head>
<title>Some Useful Rxjs Creation Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一些有用的Rxjs创建操作符</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/some-useful-rxjs-creation-operators-f0909cfd6efb?source=collection_archive---------4-----------------------#2020-02-03">https://javascript.plainenglish.io/some-useful-rxjs-creation-operators-f0909cfd6efb?source=collection_archive---------4-----------------------#2020-02-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1f4a2b3be274e51cb2d5cd96d0ff2b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*12CjvjcquFA9cQlX"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@benchaccounting?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Bench Accounting</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f880" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rxjs是一个用于进行反应式编程的库。创建操作符对于从各种数据源生成供观察者订阅的数据非常有用。</p><p id="95f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看来自Rxjs的一些创建操作符。</p><h1 id="012e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">埃阿斯</h1><p id="e63a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">ajax()</code>操作符来获取从API返回的响应对象。</p><p id="4677" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c8fe" class="mq lc iq mh b gy mr ms l mt mu">const observable = ajax(`<a class="ae kc" href="https://api.github.com/meta`).pipe(" rel="noopener ugc nofollow" target="_blank">https://api.github.com/meta`).pipe(</a><br/>  map(response =&gt; {<br/>    console.log(response);<br/>    return response;<br/>  }),<br/>  catchError(error =&gt; {<br/>    console.log(error);<br/>    return of(error);<br/>  })<br/>);</span><span id="19e7" class="mq lc iq mh b gy mv ms l mt mu">observable.subscribe(res =&gt; console.log(res));</span></pre><p id="8a20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">map</code>操作符从响应中得到<code class="fe me mf mg mh b">pipe</code>数据。此外，我们可以用<code class="fe me mf mg mh b">catchError</code>操作符捕捉HTTP错误。</p><p id="d664" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以使用<code class="fe me mf mg mh b">ajax.getJSON()</code>来简化操作如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6897" class="mq lc iq mh b gy mr ms l mt mu">import { ajax } from "rxjs/ajax";<br/>import { map, catchError } from "rxjs/operators";<br/>import { of } from "rxjs";</span><span id="c014" class="mq lc iq mh b gy mv ms l mt mu">const observable = ajax.getJSON(`<a class="ae kc" href="https://api.github.com/meta`).pipe(" rel="noopener ugc nofollow" target="_blank">https://api.github.com/meta`).pipe(</a><br/>  map(response =&gt; {<br/>    console.log(response);<br/>    return response;<br/>  }),<br/>  catchError(error =&gt; {<br/>    console.log("error: ", error);<br/>    return of(error);<br/>  })<br/>);</span><span id="a060" class="mq lc iq mh b gy mv ms l mt mu">observable.subscribe(res =&gt; console.log(res));</span></pre><p id="2ce4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，在这两个例子中，我们在传递给<code class="fe me mf mg mh b">map</code>操作符的<code class="fe me mf mg mh b">map</code>的回调中返回了<code class="fe me mf mg mh b">response</code>。</p><p id="ad8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还适用于帖子请求:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5ebe" class="mq lc iq mh b gy mr ms l mt mu">import { ajax } from "rxjs/ajax";<br/>import { map, catchError } from "rxjs/operators";<br/>import { of } from "rxjs";</span><span id="1f4b" class="mq lc iq mh b gy mv ms l mt mu">const observable = ajax({<br/>  url: "<a class="ae kc" href="https://jsonplaceholder.typicode.com/posts" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/posts</a>",<br/>  method: "POST",<br/>  headers: {<br/>    "Content-Type": "application/json"<br/>  },<br/>  body: {<br/>    id: 1,<br/>    title: "title",<br/>    body: "body",<br/>    userId: 1<br/>  }<br/>}).pipe(<br/>  map(response =&gt; console.log("response: ", response)),<br/>  catchError(error =&gt; {<br/>    console.log("error: ", error);<br/>    return of(error);<br/>  })<br/>);</span><span id="2d57" class="mq lc iq mh b gy mv ms l mt mu">observable.subscribe(res =&gt; console.log(res));</span></pre><p id="140c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们看到的，我们可以设置请求的头部和主体，所以<code class="fe me mf mg mh b">ajax</code>可以处理大多数HTTP请求。</p><p id="cc18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">错误也可以用我们在<code class="fe me mf mg mh b">pipe</code>中使用的<code class="fe me mf mg mh b">catchError</code>操作符来捕获:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="641f" class="mq lc iq mh b gy mr ms l mt mu">import { ajax } from "rxjs/ajax";<br/>import { map, catchError } from "rxjs/operators";<br/>import { of } from "rxjs";</span><span id="c8fc" class="mq lc iq mh b gy mv ms l mt mu">const observable = ajax(`<a class="ae kc" href="https://api.github.com/404`).pipe(" rel="noopener ugc nofollow" target="_blank">https://api.github.com/404`).pipe(</a><br/>  map(response =&gt; {<br/>    console.log(response);<br/>    return response;<br/>  }),<br/>  catchError(error =&gt; {<br/>    console.log(error);<br/>    return of(error);<br/>  })<br/>);</span><span id="f193" class="mq lc iq mh b gy mv ms l mt mu">observable.subscribe(res =&gt; console.log(res));</span></pre><h1 id="3d8d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">绑定回调</h1><p id="cca2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">bindCallback</code>将回调API转换为返回可观察值的函数。</p><p id="7e8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它可以通过发出参数将带参数的函数转换为可观察的函数。</p><p id="220d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要三个参数。第一个是函数，它将回调函数作为参数。传入回调函数的任何内容都将由可观察对象发出。</p><p id="736a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是可选的<code class="fe me mf mg mh b">resultSelector</code>。我们可以传入一个函数来选择这里发出的结果。</p><p id="c654" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个参数是可选的调度程序。如果我们想改变第一个参数中回调函数的调用方式，我们可以传入一个调度器。</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dcce" class="mq lc iq mh b gy mr ms l mt mu">import { bindCallback } from "rxjs";</span><span id="4f2a" class="mq lc iq mh b gy mv ms l mt mu">const foo = fn =&gt; {<br/>  fn("a", "b", "c");<br/>};</span><span id="34f6" class="mq lc iq mh b gy mv ms l mt mu">const observableFn = bindCallback(foo);<br/>observableFn().subscribe(res =&gt; console.log(res));</span></pre><p id="2812" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会看到<code class="fe me mf mg mh b">'a'</code>、<code class="fe me mf mg mh b">'b'</code>和<code class="fe me mf mg mh b">'c'</code>，因为我们将它们传递给了我们的<code class="fe me mf mg mh b">fn</code>回调函数，这是<code class="fe me mf mg mh b">foo</code>的一个参数。</p><p id="559d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">bindCallback</code>函数返回一个返回可观察值的函数。然后我们可以订阅返回的可观察值。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/b8c8839c31e631fb4d8d886f0c834c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Anwtek2mUD__tIoO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@seteales?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Allef Vinicius</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a86c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">推迟</h1><p id="3554" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">defer</code>让我们创建一个仅在订阅时创建的可观察对象。</p><p id="1964" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要一个参数，这是一个可观察的工厂函数。例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9c6c" class="mq lc iq mh b gy mr ms l mt mu">import { defer, of } from "rxjs";</span><span id="d800" class="mq lc iq mh b gy mv ms l mt mu">const clicksOrInterval = defer(() =&gt; {<br/>  return Math.random() &gt; 0.5 ? of([1, 2, 3]) : of([4, 5, 6]);<br/>});<br/>clicksOrInterval.subscribe(x =&gt; console.log(x));</span></pre><p id="a6ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以有一个可观测值，它或者订阅<code class="fe me mf mg mh b">of([1, 2, 3])</code>或者订阅<code class="fe me mf mg mh b">of([4, 5, 6])</code>，这取决于<code class="fe me mf mg mh b">Math.random()</code>是否返回小于或等于0.5或者大于0.5。</p><h1 id="94bb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">空的</h1><p id="aa73" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">创建一个除了完整通知之外不向观察者发出任何信息的可观察对象。</p><p id="1ba4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有一个可选参数，即我们想要使用的调度程序。</p><p id="c851" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9b50" class="mq lc iq mh b gy mr ms l mt mu">import { empty } from "rxjs";</span><span id="4ce1" class="mq lc iq mh b gy mv ms l mt mu">const result = empty();<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="c45f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们应该看不到任何记录。</p><p id="9b92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个例子是，当从原始可观测值发出奇数时，发出值<code class="fe me mf mg mh b">'odd'</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e661" class="mq lc iq mh b gy mr ms l mt mu">import { empty, interval, of } from "rxjs";<br/>import { mergeMap } from "rxjs/operators";</span><span id="07b8" class="mq lc iq mh b gy mv ms l mt mu">const interval$ = interval(1000);<br/>const result = interval$.pipe(<br/>  mergeMap(x =&gt; (x % 2 === 1 ? of("odd") : empty()))<br/>);<br/>result.subscribe(x =&gt; console.log(x));</span></pre><h1 id="4604" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从</h1><p id="1a1a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">from</code>从数组、类数组对象、承诺、可迭代对象或类可观察对象创建可观察对象。</p><p id="f772" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有两个参数，一个是数组，一个类似数组的对象，一个promise，iterable对象或者一个类似Observable的对象。</p><p id="11b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个参数是可选参数，它是一个调度程序。</p><p id="303a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="69f3" class="mq lc iq mh b gy mr ms l mt mu">import { from } from "rxjs";</span><span id="5a08" class="mq lc iq mh b gy mv ms l mt mu">const array = [1, 2, 3];<br/>const result = from(array);</span><span id="abaa" class="mq lc iq mh b gy mv ms l mt mu">result.subscribe(x =&gt; console.log(x));</span></pre><p id="7395" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用它将承诺转换为可观察值，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="69b6" class="mq lc iq mh b gy mr ms l mt mu">import { from } from "rxjs";</span><span id="e3aa" class="mq lc iq mh b gy mv ms l mt mu">const promise = Promise.resolve(1);<br/>const result = from(promise);</span><span id="70fb" class="mq lc iq mh b gy mv ms l mt mu">result.subscribe(x =&gt; console.log(x));</span></pre><p id="8584" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于我们想要这样做的情况是很方便的，比如将<code class="fe me mf mg mh b">fetch</code> API承诺转换成可观察的。</p><p id="4c17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，创建操作符对于将各种数据源转化为可观察数据非常有用。</p><p id="7438" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有用于获取HTTP请求响应的<code class="fe me mf mg mh b">ajax</code>操作符。<code class="fe me mf mg mh b">bindCallback</code>函数将回调参数转化为可观察的数据。<code class="fe me mf mg mh b">defer</code>当某些东西订阅了由<code class="fe me mf mg mh b">defer</code>操作符返回的可观测量时，让我们动态地创建可观测量。</p><p id="7d4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们用<code class="fe me mf mg mh b">empty</code>操作符创建一个不发射任何东西的可观察对象，用<code class="fe me mf mg mh b">from</code>操作符从数组、类数组对象、promise、iterable对象或类可观察对象创建可观察对象。</p></div></div>    
</body>
</html>