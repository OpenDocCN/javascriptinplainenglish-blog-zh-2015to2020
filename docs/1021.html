<html>
<head>
<title>Setting up Routing In Svelte with Page.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Page.js在Svelte中设置路由</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/setting-up-routing-in-svelte-with-page-js-be428407db46?source=collection_archive---------3-----------------------#2020-01-16">https://javascript.plainenglish.io/setting-up-routing-in-svelte-with-page-js-be428407db46?source=collection_archive---------3-----------------------#2020-01-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f2f0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文是关于使用Svelte系列文章的第二部分。我们已经(或将)涵盖的主题和文章如下:</p><ol class=""><li id="0ef7" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated"><a class="ae ku" href="https://jackwhiting.co.uk/posts/setting-up-svelte-and-integrating-tailwind-css" rel="noopener ugc nofollow" target="_blank">设置苗条&amp;安装顺风CSS和后置CSS </a></li><li id="b69e" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://jackwhiting.co.uk/posts/setting-up-routing-in-svelte-with-pagejs/#" rel="noopener ugc nofollow" target="_blank">用Page.js设置路由</a></li><li id="72c6" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><a class="ae ku" href="https://jackwhiting.co.uk/posts/refactoring-our-router-within-svelte" rel="noopener ugc nofollow" target="_blank">重构和优化我们的路由器</a></li><li id="5106" class="kl km iq jp b jq kv ju kw jy kx kc ky kg kz kk kq kr ks kt bi translated"><em class="la">..还有更多</em></li></ol></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="d0e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上一篇文章中，我们简要地看了一下旋转苗条。这篇文章不要求你这样做，但是如果你没有一个苗条的安装，我建议你遵循苗条网站上的<a class="ae ku" href="https://svelte.dev/blog/the-easiest-way-to-get-started" rel="noopener ugc nofollow" target="_blank">快速入门指南</a>。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/f974d22742e64bdc7e69f45bdbd199cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*e7eLCt8Z5kfzKrM2.png"/></div></div></figure><p id="98de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过几种方式来查看Svelte中的路由，第一选择可能是<a class="ae ku" href="https://sapper.svelte.dev/" rel="noopener ugc nofollow" target="_blank"> Sapper </a>(目前处于测试阶段)，这是由Svelte团队构建的一个迷你框架。还有几个包可以用来集成路由，比如<a class="ae ku" href="https://github.com/EmilTholin/svelte-routing" rel="noopener ugc nofollow" target="_blank">svelet-routing</a>或<a class="ae ku" href="https://visionmedia.github.io/page.js/" rel="noopener ugc nofollow" target="_blank"> Page.js </a>。</p><p id="234d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这篇文章，我们将利用令人敬畏的库<a class="ae ku" href="https://visionmedia.github.io/page.js/" rel="noopener ugc nofollow" target="_blank"> Page.js </a>。我们选择了Page.js，因为它对我们的单个路线提供了大量的粒度控制，并且不需要任何定制组件就可以处理我们站点中的任何锚(<code class="fe lu lv lw lx b">&lt;a&gt;</code>)链接。我发现这样做效果更好，因为当内容从WYSIWYG或Markdown文件中呈现时，所有内部锚链接都可以完美地工作。</p><h1 id="d090" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">设置我们的环境</h1><p id="90e2" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">首先，我们需要安装Page.js。在站点的根目录下打开您的终端并运行以下命令:</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="c4cd" class="nf lz iq lx b gy ng nh l ni nj">yarn add page <em class="la"># or npm install page</em></span></pre><p id="0e2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要对package.json文件进行调整，以确保如果我们在已经导航到的页面上重新加载，例如，<em class="la"> /blog </em>，我们不会收到服务器错误，它会加载适当的路径。打开package.json并编辑下面一行:</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="2cf1" class="nf lz iq lx b gy ng nh l ni nj">"start"<strong class="lx ir">:</strong> "sirv public"</span></pre><p id="7575" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">追加<code class="fe lu lv lw lx b">--single</code>选项，如下所示。</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="a909" class="nf lz iq lx b gy ng nh l ni nj">"start"<strong class="lx ir">:</strong> "sirv public --single"</span></pre><p id="4ecd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这应该设置好一切，以便我们以后尽可能少地遇到错误。</p><h1 id="bc6c" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">编写路由器</h1><p id="3b9d" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">当我们考虑如何将Page.js集成到Svelte中时，我想解释一下事情是如何工作的，并展示几个例子。Page.js具有极强的可扩展性，因此您可以在每个路由的基础上执行许多逻辑。</p><h2 id="8c4d" class="nf lz iq bd ma nk nl dn me nm nn dp mi jy no np mm kc nq nr mq kg ns nt mu nu bi translated">设置路由器</h2><p id="f6b6" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">在<code class="fe lu lv lw lx b">App.svelte</code>文件的顶部包含来自Page.js包的路由器。我们还想为我们的Home route创建一个新文件，所以在下面的位置<code class="fe lu lv lw lx b">pages/Home.svelte</code>创建一个新文件。</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="7abf" class="nf lz iq lx b gy ng nh l ni nj">&lt;script&gt;<br/>  <strong class="lx ir">import</strong> router from "page"<br/>  <br/>  <em class="la">// Include our Routes<br/></em>  <strong class="lx ir">import</strong> Home from './pages/Home.svelte'<br/>&lt;/script&gt;</span></pre><p id="70f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">确保您用一些虚拟文本填充了<code class="fe lu lv lw lx b">pages/Home.svelte</code>文件，这样您就可以区分它是否加载了路线，如下所示:</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="a941" class="nf lz iq lx b gy ng nh l ni nj">&lt;h1&gt;Home Page&lt;/h1&gt;</span></pre><p id="f853" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，回到我们的<code class="fe lu lv lw lx b">App.svelte</code>文件中，我们将需要创建几个变量，我们将把它们传递给子组件，并告诉Svelte加载什么路径。</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="b36a" class="nf lz iq lx b gy ng nh l ni nj">&lt;script&gt;<br/>  ... </span><span id="ddeb" class="nf lz iq lx b gy nv nh l ni nj">  <strong class="lx ir">let</strong> page<br/>  <strong class="lx ir">let</strong> params<br/>&lt;/script&gt;</span></pre><p id="bb23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了查看Page.js，并根据我们所在的URL更改组件，我们需要调用<code class="fe lu lv lw lx b">router</code>包。我们可以这样做，将URL作为第一个属性，然后将我们的函数(更新组件)作为第二个属性。</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="560a" class="nf lz iq lx b gy ng nh l ni nj"><em class="la">// Set up the pages to watch for<br/></em>router('/', () =&gt; page <strong class="lx ir">=</strong> Home)</span></pre><p id="528f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，我们在"/"处观察对站点根目录的任何请求，然后将<code class="fe lu lv lw lx b">page</code>变量设置为我们之前从<code class="fe lu lv lw lx b">./routes/Home.svelte</code>文件导入的<code class="fe lu lv lw lx b">Home</code>组件。</p><p id="36ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们需要确保路由器一直在观察变化，这可以通过运行<code class="fe lu lv lw lx b">router.start()</code>来实现。这将如下所示:</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="5934" class="nf lz iq lx b gy ng nh l ni nj"><em class="la">// Set up the router to start and actively watch for changes<br/></em>router.start()</span></pre><p id="c2bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，为了让路由器加载正确的组件，我们可以利用<code class="fe lu lv lw lx b"><a class="ae ku" href="https://svelte.org/" rel="noopener ugc nofollow" target="_blank">svelte:component</a></code>，这将允许我们在任何页面加载时重新创建和销毁组件(这意味着当您导航到任何锚点/浏览器历史更改时，将加载不同的路由)。在结束的<code class="fe lu lv lw lx b">&lt;/script&gt;</code>标签后添加以下内容:</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="f84b" class="nf lz iq lx b gy ng nh l ni nj">&lt;svelte:component this<strong class="lx ir">=</strong>{page} params<strong class="lx ir">=</strong>{params} /&gt;</span></pre><p id="56ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你的<code class="fe lu lv lw lx b">App.svelte</code>放在一起应该看起来像下面这样。</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="6268" class="nf lz iq lx b gy ng nh l ni nj">&lt;script&gt;<br/>  <strong class="lx ir">import</strong> router from "page"<br/>  <br/>  <em class="la">// Include our Routes<br/></em>  <strong class="lx ir">import</strong> Home from './pages/Home.svelte'<br/>  <br/>  <em class="la">// Variables<br/></em>  <strong class="lx ir">let</strong> page<br/>  <strong class="lx ir">let</strong> params<br/>  <br/>  <em class="la">// Set up the pages to watch for<br/></em>  router('/', () =&gt; page <strong class="lx ir">=</strong> Home)</span><span id="f7dd" class="nf lz iq lx b gy nv nh l ni nj">  <em class="la">// Set up the router to start and actively watch for changes<br/></em>  router.start()<br/>&lt;/script&gt;</span><span id="64d1" class="nf lz iq lx b gy nv nh l ni nj">&lt;svelte:component this<strong class="lx ir">=</strong>{page} params<strong class="lx ir">=</strong>{params} /&gt;</span></pre><p id="93d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您从应用程序的根目录运行<code class="fe lu lv lw lx b">yarn dev</code>，您现在应该看到主页加载并显示您添加到<code class="fe lu lv lw lx b">Home.svelte</code>文件的任何内容。</p><h2 id="537d" class="nf lz iq bd ma nk nl dn me nm nn dp mi jy no np mm kc nq nr mq kg ns nt mu nu bi translated">扩展我们的路由器</h2><p id="03f8" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">为了让我们的路由器实际上路由东西，我们需要设置更多的routes实例，并将它们添加到我们的代码中。在routes目录中为<code class="fe lu lv lw lx b">Blog.svelte</code>和<code class="fe lu lv lw lx b">SingleBlog.svelte</code>创建两个新文件。</p><h2 id="ff00" class="nf lz iq bd ma nk nl dn me nm nn dp mi jy no np mm kc nq nr mq kg ns nt mu nu bi translated">博客.苗条</h2><p id="16f1" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">如果你不完全理解这里发生的一切，不要担心。我在<code class="fe lu lv lw lx b">Blog.svelte</code>的例子中包含了一些伪代码，因为我想展示我们如何基于路由参数动态加载内容。总结一下正在发生的事情——我们利用Svelte的<code class="fe lu lv lw lx b">onMount</code>从一个虚拟API获取一系列JSON博客文章，然后遍历所有文章并显示每个文章的链接。</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="8080" class="nf lz iq lx b gy ng nh l ni nj">&lt;script&gt;<br/>  <strong class="lx ir">import</strong> { onMount } from 'svelte'</span><span id="bb62" class="nf lz iq lx b gy nv nh l ni nj">  <strong class="lx ir">const</strong> apiUrl <strong class="lx ir">=</strong> 'https://jsonplaceholder.typicode.com/posts/'<br/>  <strong class="lx ir">let</strong> data <strong class="lx ir">=</strong> []</span><span id="cb5e" class="nf lz iq lx b gy nv nh l ni nj">  onMount(async () =&gt; {<br/>    <strong class="lx ir">const</strong> response <strong class="lx ir">=</strong> await fetch(apiUrl)<br/>    data <strong class="lx ir">=</strong> await response.json()<br/>  });<br/>&lt;/script&gt;</span><span id="04db" class="nf lz iq lx b gy nv nh l ni nj">&lt;h1&gt;Blog&lt;/h1&gt;</span><span id="5590" class="nf lz iq lx b gy nv nh l ni nj">{#each data as item }<br/>  &lt;div&gt;<br/>    &lt;h5&gt;&lt;a href<strong class="lx ir">=</strong>"/blog/{item.id}"&gt;{item.title}&lt;/a&gt;&lt;/h5&gt;<br/>  &lt;/div&gt;<br/>{/each}</span></pre><h2 id="06e6" class="nf lz iq bd ma nk nl dn me nm nn dp mi jy no np mm kc nq nr mq kg ns nt mu nu bi translated">单身博客</h2><p id="b28e" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">对于单个博客路径，我们将依靠我们在<code class="fe lu lv lw lx b">App.svelte</code>中设置的<code class="fe lu lv lw lx b">params</code>变量，然后从具有该ID的虚拟API中获取单个帖子。</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="5a54" class="nf lz iq lx b gy ng nh l ni nj">&lt;script&gt;<br/>  <strong class="lx ir">import</strong> { onMount } from 'svelte'</span><span id="d227" class="nf lz iq lx b gy nv nh l ni nj">  <strong class="lx ir">export</strong> <strong class="lx ir">let</strong> params</span><span id="d335" class="nf lz iq lx b gy nv nh l ni nj">  <strong class="lx ir">const</strong> apiUrl <strong class="lx ir">=</strong> 'https://jsonplaceholder.typicode.com/posts/'<br/>  <strong class="lx ir">let</strong> data <strong class="lx ir">=</strong> []</span><span id="2c2a" class="nf lz iq lx b gy nv nh l ni nj">  onMount(async () =&gt; {<br/>    <strong class="lx ir">const</strong> response <strong class="lx ir">=</strong> await fetch(apiUrl <strong class="lx ir">+</strong> params.id)<br/>    data <strong class="lx ir">=</strong> await response.json()<br/>  });<br/>&lt;/script&gt;</span><span id="9612" class="nf lz iq lx b gy nv nh l ni nj">&lt;h1&gt;{data.title}&lt;/h1&gt;<br/>&lt;p&gt;{data.body}&lt;/p&gt;</span></pre><h2 id="1569" class="nf lz iq bd ma nk nl dn me nm nn dp mi jy no np mm kc nq nr mq kg ns nt mu nu bi translated">修改我们的原始代码</h2><p id="edbe" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">现在我们已经创建了两个新文件，我们需要返回并编辑我们的<code class="fe lu lv lw lx b">App.svelte</code>来包含它们。打开文件并导入两条新路线。</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="4c4c" class="nf lz iq lx b gy ng nh l ni nj"><strong class="lx ir">import</strong> Blog from "./pages/Blog.svelte"<br/><strong class="lx ir">import</strong> SingleBlog from "./pages/SingleBlog.svelte"</span></pre><p id="3257" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">添加两个新的<code class="fe lu lv lw lx b">router</code>实例，这样我们可以观察新的页面。要监视访问<em class="la">/博客</em>的用户，添加以下内容:</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="3b25" class="nf lz iq lx b gy ng nh l ni nj">router('/blog', () =&gt; page <strong class="lx ir">=</strong> Blog);</span></pre><p id="b70d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当添加一个动态路由时，我们看到了另一个属性<code class="fe lu lv lw lx b">router()</code>,它允许我们在到达路由端点之前加载或操作任何数据。我们将在代码中利用这一点，这样我们就可以确保将任何查询参数传递给最终组件。</p><p id="d679" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe lu lv lw lx b">router()</code>的其他实例下添加以下代码:</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="89ae" class="nf lz iq lx b gy ng nh l ni nj">router(<br/>  '/blog/:id', <br/>  <br/>  <em class="la">// Before we set the component<br/></em>  (ctx, next) =&gt; {<br/>  	params <strong class="lx ir">=</strong> ctx.params<br/>  	next()<br/>  }, </span><span id="deeb" class="nf lz iq lx b gy nv nh l ni nj">  <em class="la">// Finally set the component<br/></em>  () =&gt; page <strong class="lx ir">=</strong> SingleBlog<br/>);</span></pre><p id="ae16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这段代码中，我们在中间有另一个函数，它允许我们传递<code class="fe lu lv lw lx b">ctx</code>(上下文)和一个<code class="fe lu lv lw lx b">next</code>函数调用。在这个例子中，在继续更新路由组件之前，我们将URL中定义的<code class="fe lu lv lw lx b">params</code>赋给代码中的<code class="fe lu lv lw lx b">params</code>变量。</p><p id="2d6c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你回头看一下<code class="fe lu lv lw lx b">routes/SingleBlog.svelte</code>文件的代码，你会看到我们使用了这些参数来允许我们从远程API获取我们正在访问的文章的ID。</p><p id="236b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了能够导航到这些路线，我们需要在我们的应用程序中添加一些样板文件，将<code class="fe lu lv lw lx b">App.svelte</code>文件中结束<code class="fe lu lv lw lx b">&lt;/script&gt;</code>标记后的代码更新为:</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="8488" class="nf lz iq lx b gy ng nh l ni nj">&lt;nav&gt;<br/>  &lt;a href<strong class="lx ir">=</strong>"/"&gt;Home&lt;/a&gt;<br/>  &lt;a href<strong class="lx ir">=</strong>"/blog"&gt;Blog&lt;/a&gt;<br/>&lt;/nav&gt;</span><span id="af92" class="nf lz iq lx b gy nv nh l ni nj">&lt;main&gt;<br/> &lt;svelte:component this<strong class="lx ir">=</strong>{page} params<strong class="lx ir">=</strong>{params} /&gt;<br/>&lt;/main&gt;</span></pre><p id="abec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的<code class="fe lu lv lw lx b">App.svelte</code>文件现在应该看起来有点像这样:</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="77db" class="nf lz iq lx b gy ng nh l ni nj">&lt;script&gt;<br/>  <strong class="lx ir">import</strong> router from "page"<br/>  <br/>  <em class="la">// Include our Routes<br/></em>  <strong class="lx ir">import</strong> Home from "./routes/Home.svelte"<br/>  <strong class="lx ir">import</strong> Blog from "./routes/Blog.svelte"<br/>  <strong class="lx ir">import</strong> SingleBlog from "./routes/SingleBlog.svelte"<br/>  <br/>  <em class="la">// Variables<br/></em>  <strong class="lx ir">let</strong> page<br/>  <strong class="lx ir">let</strong> params<br/>  <br/>  <em class="la">// Set up the pages to watch for<br/></em>  router('/', () =&gt; page <strong class="lx ir">=</strong> Home)<br/>  router('/blog', () =&gt; page <strong class="lx ir">=</strong> Blog)<br/>  router(<br/>    '/blog/:id', <br/>    (ctx, next) =&gt; {<br/>     params <strong class="lx ir">=</strong> ctx.params<br/>     next()<br/>    }, <br/>    () =&gt; page <strong class="lx ir">=</strong> SingleBlog<br/>  );</span><span id="44da" class="nf lz iq lx b gy nv nh l ni nj">  <em class="la">// Set up the router to start and actively watch for changes<br/></em>  router.start()<br/>&lt;/script&gt;</span><span id="89df" class="nf lz iq lx b gy nv nh l ni nj">&lt;nav&gt;<br/>  &lt;a href<strong class="lx ir">=</strong>"/"&gt;Home&lt;/a&gt;<br/>  &lt;a href<strong class="lx ir">=</strong>"/blog"&gt;Blog&lt;/a&gt;<br/>&lt;/nav&gt;</span><span id="7c75" class="nf lz iq lx b gy nv nh l ni nj">&lt;main&gt;<br/> &lt;svelte:component this<strong class="lx ir">=</strong>{page} params<strong class="lx ir">=</strong>{params} /&gt;<br/>&lt;/main&gt;</span></pre><p id="c9de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在您的浏览器中测试一下，您应该会看到一切正常，没有任何页面重新加载或错误。</p><h1 id="6eb0" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">进一步的例子</h1><p id="11e5" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">结合使用Page.js和Svelte可以做很多事情。虽然我觉得这篇文章有点长，但我确实想涵盖几个要点，这对任何构建更复杂应用程序的人来说都非常方便。</p><h2 id="573f" class="nf lz iq bd ma nk nl dn me nm nn dp mi jy no np mm kc nq nr mq kg ns nt mu nu bi translated">证明</h2><p id="6012" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">我们可以利用<code class="fe lu lv lw lx b">router()</code>来检查是否存储了用户变量，或者用户是否通过了身份验证，如果没有，则重定向到登录页面。这对于创建锁定区域非常有用。</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="b84d" class="nf lz iq lx b gy ng nh l ni nj">&lt;script&gt;<br/>  ...<br/>  <strong class="lx ir">import</strong> AuthedRoute from './pages/AuthedRoute.svelte' <br/>  <strong class="lx ir">import</strong> Login from './pages/Login.svelte'</span><span id="76c7" class="nf lz iq lx b gy nv nh l ni nj">  <em class="la">// any logic you have for getting the user here, or more to come on this later.<br/></em>  <strong class="lx ir">let</strong> user <strong class="lx ir">=</strong> <strong class="lx ir">null</strong><em class="la"><br/></em>  <br/>  router("/login", () =&gt; page <strong class="lx ir">=</strong> Login)<br/>  router('/private', () =&gt; {<br/>    <em class="la">// If the user is not set, redirect to login <br/></em>    <strong class="lx ir">if</strong> (<strong class="lx ir">!</strong> user) {<br/>      router.redirect('/login')<br/>    }</span><span id="a8b9" class="nf lz iq lx b gy nv nh l ni nj">    page <strong class="lx ir">=</strong> PrivateRoute<br/>  })<br/>  ...<br/>&lt;/script&gt;</span></pre><h2 id="0f7a" class="nf lz iq bd ma nk nl dn me nm nn dp mi jy no np mm kc nq nr mq kg ns nt mu nu bi translated">捕捉所有页面/错误页面</h2><p id="54cf" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">当用户点击一个我们没有设置路线的页面时会发生什么？嗯，目前他们会看到一个几乎空白的页面。我们可以通过在<code class="fe lu lv lw lx b">router()</code>上设置一个通配符来捕捉这一点，并显示一个错误路由。</p><pre class="lj lk ll lm gt nb lx nc nd aw ne bi"><span id="dd07" class="nf lz iq lx b gy ng nh l ni nj">&lt;script&gt;<br/>  ...<br/>  <strong class="lx ir">import</strong> ErrorPage from "./pages/ErrorPage.svelte"<br/>  <br/>  router('/*', () =&gt; page <strong class="lx ir">=</strong> Error)<br/>  ...<br/>&lt;/script&gt;</span></pre><h1 id="3ac6" class="ly lz iq bd ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv bi translated">结论</h1><p id="151b" class="pw-post-body-paragraph jn jo iq jp b jq mw js jt ju mx jw jx jy my ka kb kc mz ke kf kg na ki kj kk ij bi translated">这篇文章中有很多内容讨论了如何将Page.js实现为Svelte来创建一个动态路由器，我希望它是有用的。我们构建文档的方式目前还不是最干净的，因为这意味着我们必须在我们的<code class="fe lu lv lw lx b">router()</code>调用和主<code class="fe lu lv lw lx b">App.svelte</code>文件中重复很多逻辑。在以后的文章中，我想谈谈我们如何重构这一点，并更有效地设置路由。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="e674" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="la">这篇文章对你有帮助吗？考虑通过</em> <a class="ae ku" href="https://ko-fi.com/jackabox" rel="noopener ugc nofollow" target="_blank"> <em class="la">请我喝咖啡</em> </a> <em class="la">来支持我，帮助我制作更多优质的内容和未来的视频。</em> <em class="la">原载于</em><a class="ae ku" href="https://jackwhiting.co.uk/posts/setting-up-svelte-and-integrating-tailwind-css/" rel="noopener ugc nofollow" target="_blank"><em class="la">https://jackwhiting.co.uk</em></a><em class="la">。你可以在我的网站上找到更多类似的文章或者关于PHP、JavaScript、Vue、Svelte或者自由职业的文章。</em></p></div></div>    
</body>
</html>