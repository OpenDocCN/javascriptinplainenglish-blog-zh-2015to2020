<html>
<head>
<title>Different ways to handle HTTP requests inside a React Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React应用程序中处理HTTP请求的不同方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/different-ways-to-handle-http-request-inside-react-application-dcd580bbe5a4?source=collection_archive---------2-----------------------#2020-07-10">https://javascript.plainenglish.io/different-ways-to-handle-http-request-inside-react-application-dcd580bbe5a4?source=collection_archive---------2-----------------------#2020-07-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d195" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在这篇文章中，我们将集中讨论向远程数据库发送请求并在我们的界面中显示请求的不同方法。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d6ec748386d47b0bbbf35efbbf7c2eed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XhKq-iNIkGffTalDrV2auQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae ks" href="http://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cc5e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">制作UI组件是制作React应用程序的基础。我们仍然可以创建可以改变数据的大型web应用程序，而不需要重新加载页面。哪一部分是创建SPA应用程序的最佳部分？当处理向远程服务器发送HTTP请求时，有多种方式请求数据以及如何处理数据。</p><p id="1518" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里我们用四种方式来概括它:</p><ul class=""><li id="ebcf" class="lp lq in kv b kw kx kz la lc lr lg ls lk lt lo lu lv lw lx bi translated">在一条直线上的</li><li id="3a9d" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">集中的</li><li id="7a37" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">使用自定义挂钩</li><li id="f01b" class="lp lq in kv b kw ly kz lz lc ma lg mb lk mc lo lu lv lw lx bi translated">使用库</li></ul><h1 id="0f8c" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">在一条直线上的</h1><p id="dbe4" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">这是提出要求最简单直接的方式。发出请求并处理响应。</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="6a55" class="nf me in nb b gy ng nh l ni nj">fetch("/articles").then(response =&gt; response.json());</span></pre><p id="f369" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它现在是最简单的形式，但在现实世界中，我们可能还需要添加错误处理，设置和更新我们的状态，将加载器添加到我们的应用程序中。将这些添加到我们的应用程序中，我们将得到类似这样的代码。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="0ee9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们正在处理非常简单的应用程序，只有有限的调用次数，这可能看起来可以实现。但是在一个更大的应用程序中，我们有端点链，我们需要调用，这显然是一种更复杂的维护和读取方式。我们需要解决的问题太多了。考虑状态，更新它，设置加载和删除它，考虑错误处理，检查响应状态，声明空数组依赖，因此<strong class="kv io"> UseEffect </strong>只执行一次。</p><p id="8e4a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，内联调用以后会变得更加危险。在开发的后期，在我们的应用程序中避免这种类型的调用是非常好的。</p><h1 id="eda7" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">集中的</h1><p id="4b26" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">当我们在一个文件夹和位置中专门为我们的HTTP调用添加服务的不同层被称为集中式。对于这种方法，我们通常在应用程序中将其命名为<em class="nm">服务或用户服务</em>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="d0dc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一个我们定义的专用服务层的例子，通过普通的JavaScript和<strong class="kv io"> export </strong>指令来完成文章。它将作为<em class="nm"> getArticle </em>功能的集中位置。</p><p id="3cbc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们现在可以<strong class="kv io"> <em class="nm">将</em> </strong>这个函数导入到我们特定的组件文件中，并在那里使用这个函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="5254" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在示例代码中，我们已经导入了之前导出的articleService。这样做的好处是，我们可以随着应用程序的增长轻松扩展它，并且我们还实现了一致性。我们可以根据需要指定我们想要从特定的<em class="nm">服务</em>中导入的特定功能。</p><p id="5a55" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">毕竟，使用这种方法，我们将减少和重用我们的函数调用，并从一个单一的集中位置提供服务。</p><h1 id="df55" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">使用自定义挂钩</h1><p id="dab7" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">自定义钩子只是一个JavaScript函数，它的名字以单词use为前缀，用于调用其他钩子。它还有助于将可重用的逻辑片段提取到可重用的功能中。实际上，它们是普通的JavaScript函数，可以在自身内部使用另一个钩子。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="f2b8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一个关于我们如何创建句柄加载状态来获取数据的例子。这是另一个由状态挂钩管理的状态变量。这意味着如果我们想要实现一个加载状态，我们可以设置状态变量并相应地更新<code class="fe nn no np nb b">useFetch()</code>函数。使用这个简单的钩子简化了整个调用。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="ad96" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这个演示中，我们将URL传递给了我们用一个空选项创建的<em class="nm"> useFetch() </em>自定义挂钩，以获取我们从服务器获取的数据。获取数据后，代码从响应对象中提取数据并显示在屏幕上。</p><h1 id="7dd5" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">使用图书馆</h1><p id="a003" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">向服务器发出HTTP请求需要大量的库。我们将进入一些流行的前三名图书馆，这在实现这一目的时变得非常方便。但是您仍然可以使用一个本地浏览器API来发出请求，代替XMLHttpRequest，XMLHttpRequest也提供了一种简单、合理的异步获取资源的方法。</p><h2 id="3e76" class="nf me in bd mf nq nr dn mj ns nt dp mn lc nu nv mp lg nw nx mr lk ny nz mt oa bi translated"><a class="ae ks" href="https://yarnpkg.com/package/axios" rel="noopener ugc nofollow" target="_blank"> Axio </a> s</h2><p id="296b" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">这是我们可以使用的最受欢迎的图书馆之一。Axios是基于承诺的，因此我们可以利用<strong class="kv io">异步，等待</strong>更多可读的异步代码。我们还可以拦截和取消请求，并且有内置的客户端保护来防止跨站点请求伪造。使用起来非常简单。</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="b86c" class="nf me in nb b gy ng nh l ni nj">axios.get(`https://restcountries.eu/rest/v2/all`)<br/> .then(res =&gt; {<br/> const countries = res.data;<br/> this.setState({ countries });<br/>})</span></pre><h2 id="8ea4" class="nf me in bd mf nq nr dn mj ns nt dp mn lc nu nv mp lg nw nx mr lk ny nz mt oa bi translated"><a class="ae ks" href="https://github.com/visionmedia/superagent" rel="noopener ugc nofollow" target="_blank">超级代理</a></h2><p id="0b0a" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">这是一个轻量级的渐进式AJAX API，具有灵活性、可读性和较低的学习难度。它对初学者非常友好，即使是不了解JavaScript的开发人员也能轻松实现它。我们可以在代码中随意调用SuperAgent，他们自己的例子通常将其别名为<code class="fe nn no np nb b">request</code>而不是<code class="fe nn no np nb b">ajax</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div></figure><h2 id="16db" class="nf me in bd mf nq nr dn mj ns nt dp mn lc nu nv mp lg nw nx mr lk ny nz mt oa bi translated">SWR/反应查询</h2><p id="05f2" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">这是新的，也是我个人最喜欢的获取数据的库之一。它非常方便，因为它带有<a class="ae ks" href="https://github.com/tannerlinsley/react-query" rel="noopener ugc nofollow" target="_blank">反应查询</a>或<a class="ae ks" href="https://swr.now.sh/" rel="noopener ugc nofollow" target="_blank"> swr </a>、缓存、重试、焦点重取、重复查询、轻量级、类型严格、面向JAMstack。这个库背后的主要策略是首先从缓存返回数据(陈旧的)，然后发送获取请求(重新验证)，最后是最新的数据。有了SWR组件，我们将不断自动获得一系列数据更新。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="bb6f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这个例子中，useSWR钩子接受一个<em class="nm">键</em>字符串和一个<em class="nm"> getArticle </em>函数。<code class="fe nn no np nb b"><em class="nm">key</em></code>是数据的唯一标识符(通常是API URL ),将被传递给<em class="nm"> getArticle </em>。它可以是任何返回数据的异步函数。</p><p id="bb9a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于我的大多数应用程序，我已经开始把它作为我的首选。这在使我们的UI更快和更具反应性方面非常方便和有效😍</p><h1 id="a9cb" class="md me in bd mf mg mh mi mj mk ml mm mn jt mo ju mp jw mq jx mr jz ms ka mt mu bi translated">结论</h1><p id="b821" class="pw-post-body-paragraph kt ku in kv b kw mv jo ky kz mw jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">仍然有数百种方法和库可以从React应用程序发送HTTP请求。但是我个人做我使用和推荐使用的组合<strong class="kv io">国家管理，</strong> <a class="ae ks" href="https://swr.vercel.app/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> SWR </strong> </a>。</p><p id="a422" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">谢谢你阅读它。我希望这能帮助你们了解JavaScript生态系统中处理HTTP请求的不同方式，特别是REST架构。</p><p id="6dfc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">编码快乐！</p></div></div>    
</body>
</html>