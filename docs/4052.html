<html>
<head>
<title>Best of Modern JavaScript — Resolve and Reject Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华——解决和拒绝承诺</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-resolve-and-reject-promises-b1167f50e78?source=collection_archive---------11-----------------------#2020-11-12">https://javascript.plainenglish.io/best-of-modern-javascript-resolve-and-reject-promises-b1167f50e78?source=collection_archive---------11-----------------------#2020-11-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d9db4e4c4bebbdcf53d27bbf23e4ccbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uQhT8PCHp9G_87kM"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@markuswinkler?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Winkler</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0e41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript承诺。</p><h1 id="e262" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创造承诺的其他方式</h1><p id="43e4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">除了使用<code class="fe me mf mg mh b">Promise</code>构造函数，我们还可以用其他方式创建承诺。</p><p id="8ff7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种方法是<code class="fe me mf mg mh b">Promise.resolve</code>方法。</p><p id="a041" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将承诺的解析值作为其参数。</p><p id="dea8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它会回报一个承诺。</p><p id="7ade" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7f42" class="mq lc iq mh b gy mr ms l mt mu">Promise.resolve(1)<br/>  .then(x =&gt; console.log(x));</span></pre><p id="f06e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">x</code>是来自<code class="fe me mf mg mh b">Promise.resolve</code>的解析值。</p><p id="f10d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">x</code>是一个承诺，它的结构是接受者，那么这个承诺是不变的。</p><p id="33f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7ace" class="mq lc iq mh b gy mr ms l mt mu">const p = new Promise(() =&gt; null);<br/>console.log(Promise.resolve(p) === p);</span></pre><p id="8e77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们从控制台日志中得到<code class="fe me mf mg mh b">true</code>。</p><p id="65d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果参数是一个thenable，那么参数中的<code class="fe me mf mg mh b">then</code>方法是一个函数，那么用<code class="fe me mf mg mh b">Promise.resolve</code>解析的值就是我们用来调用<code class="fe me mf mg mh b">then</code>参数的参数。</p><p id="df8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="58ff" class="mq lc iq mh b gy mr ms l mt mu">const thenableObj = {<br/>  then(reaction) {<br/>    reaction('foo');<br/>  }<br/>};<br/>const promise = Promise.resolve(thenableObj);<br/>console.log(promise instanceof Promise); <br/>promise.then(x =&gt; console.log(x));</span></pre><p id="03d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个<code class="fe me mf mg mh b">thenableObj</code>，它有<code class="fe me mf mg mh b">then</code>方法。</p><p id="2507" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它采用了一个<code class="fe me mf mg mh b">reaction</code>函数，我们用<code class="fe me mf mg mh b">'foo'</code>调用它。</p><p id="0c74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们向<code class="fe me mf mg mh b">Promise.resolve</code>方法传递一个对象，该方法返回一个承诺。</p><p id="d481" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们检查<code class="fe me mf mg mh b">promise</code>是否是<code class="fe me mf mg mh b">Promise</code>的实例，那么它将返回<code class="fe me mf mg mh b">true</code>。</p><p id="0495" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以用回调来调用它的<code class="fe me mf mg mh b">then</code>以获得<code class="fe me mf mg mh b">'foo'</code>值，该值被赋给<code class="fe me mf mg mh b">x</code>。</p><h1 id="5363" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">Promise.reject()</code></h1><p id="fbc8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以调用<code class="fe me mf mg mh b">Promise.reject()</code>来返回一个被有值拒绝的承诺。</p><p id="8459" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="65c8" class="mq lc iq mh b gy mr ms l mt mu">const error = new Error('error');<br/>Promise.reject(error)<br/>  .catch(err =&gt; console.log(err === error));</span></pre><p id="a5fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过将一个<code class="fe me mf mg mh b">error</code>对象传递给<code class="fe me mf mg mh b">Promise.reject</code>方法来传递这个对象。</p><p id="8c42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们通过向其传递回调来调用<code class="fe me mf mg mh b">catch</code>。</p><p id="842f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">err</code>有我们称之为<code class="fe me mf mg mh b">Promise.reject</code>的error对象，应该和<code class="fe me mf mg mh b">error</code>一样。</p><h1 id="148c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">连锁承诺</h1><p id="d48e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">then</code>连锁承诺，只要我们还一个承诺。</p><p id="d923" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论我们在<code class="fe me mf mg mh b">then</code>回调中返回什么，都将是承诺的解析值。</p><p id="29ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4b49" class="mq lc iq mh b gy mr ms l mt mu">Promise.resolve('bar')<br/>  .then(function(value1) {<br/>    return 'foo';<br/>  })<br/>  .then(function(value2) {<br/>    console.log(value2);<br/>  });</span></pre><p id="9266" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">value2</code>就是<code class="fe me mf mg mh b">'foo'</code>。</p><p id="e7dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们展平承诺的锁链。</p><p id="dae4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="de20" class="mq lc iq mh b gy mr ms l mt mu">Promise.resolve('bar')<br/>  .then(function(value1) {<br/>    Promise.resolve('foo')<br/>      .then(function(value2) {<br/>        //...<br/>      });<br/>  })</span></pre><p id="7711" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d364" class="mq lc iq mh b gy mr ms l mt mu">Promise.resolve('bar')<br/>  .then(function(value1) {<br/>    return 'foo';<br/>  })<br/>  .then(function(value2) {<br/>    //...<br/>  });</span></pre><h1 id="be1d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">捕捉错误</h1><p id="77c9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">catch</code>方法捕捉错误。</p><p id="0c19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0f73" class="mq lc iq mh b gy mr ms l mt mu">Promise.reject(new Error('error'))<br/>  .catch(function() {<br/>    return 'error occurred';<br/>  })<br/>  .then(function(value) {<br/>    //...<br/>  });</span></pre><p id="a187" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">catch</code>来捕捉被拒绝的承诺中的错误，并运行我们自己的代码。</p><p id="a5c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们为下一个承诺设置一些值。</p><h1 id="dbef" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">抛出异常</h1><p id="d5b0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在<code class="fe me mf mg mh b">then</code>回调中抛出一个异常，那么返回的承诺将被拒绝。</p><p id="c615" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3839" class="mq lc iq mh b gy mr ms l mt mu">Promise.resolve()<br/>  .then(function(value) {<br/>    throw new Error();<br/>  })<br/>  .catch(function(reason) {<br/>    // ...<br/>  });</span></pre><p id="56d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe me mf mg mh b">then</code>回调中抛出了一个错误，所以<code class="fe me mf mg mh b">catch</code>回调将会运行。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/b0d85c2f3fbdcb9f5dc1a79e14ec8c88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S3GN681eR4nhhEUN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@raubfisch24de?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">www.raubfisch24.de</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c4ee" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4cbc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用一个值来解析一个承诺，这样就可以调用下一个。</p><p id="c964" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以拒绝承诺，用<code class="fe me mf mg mh b">catch</code>抓住错误。</p><p id="63ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>