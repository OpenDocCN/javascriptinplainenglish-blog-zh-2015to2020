<html>
<head>
<title>The Ultimate JavaScript Fetch API Cheatsheet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最终的JavaScript获取API清单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-ultimate-javascript-fetch-api-cheatsheet-e60b98c8cdbe?source=collection_archive---------2-----------------------#2020-10-11">https://javascript.plainenglish.io/the-ultimate-javascript-fetch-api-cheatsheet-e60b98c8cdbe?source=collection_archive---------2-----------------------#2020-10-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="04d8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript获取API用法、请求选项、异步等待、拦截、取消请求和全部承诺</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/92cf614ebeed3499ff52863b806abaab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dyRuvxRHDD9UvWJ0z3IeNQ.png"/></div></div></figure><p id="91a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">获取API不再是实验性的，而是MDN的生活标准。我们必须在这篇文章中涵盖获取API用例以及用法的不同方面。Fetch提供了请求和响应对象的通用定义，它将涉及网络请求。</p><p id="2cbb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">函数<code class="fe lk ll lm ln b">fetch()</code>是全局窗口对象的一部分。它是XMLHttpRequest的现代替代品。这几乎可以用在代码上下文的任何部分。</p><h1 id="880d" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">取得</h1><p id="8c75" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated"><code class="fe lk ll lm ln b">fetch()</code>需要一个强制参数，即资源的URL。它返回一个解决响应的承诺。</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="aff1" class="mp lp in ln b gy mq mr l ms mt"><em class="mu">// GET Request.</em><br/>fetch('<a class="ae mv" href="https://api.github.com/users/rich-harris" rel="noopener ugc nofollow" target="_blank">https://api.github.com/users/rich-harris</a>')<br/>  <em class="mu">// Handle success</em><br/>  .then(response =&gt; response.json())  <em class="mu">// convert to json</em><br/>  .then(json =&gt; console.log(json))    <em class="mu">// print data to console</em><br/>  .catch(err =&gt; console.log('Request Failed', err)); <em class="mu">// Catch errors</em></span></pre><h2 id="130a" class="mp lp in bd lq mw mx dn lu my mz dp ly kx na nb ma lb nc nd mc lf ne nf me ng bi translated">请求选项</h2><p id="7c73" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">该请求还有一个可选的第二个参数，具有不同的请求选项。如果你发送JSON作为主体，它需要使用<code class="fe lk ll lm ln b">JSON.stringify()</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2cde" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">带请求选项的示例<code class="fe lk ll lm ln b">POST</code>请求</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="8f32" class="mp lp in ln b gy mq mr l ms mt">fetch('/save/data', {<br/>  method: 'POST',  <br/>  body: JSON.stringify(data),// if sending data as array or object<br/>  headers: {<br/>    'Content-Type': 'application/json'<br/>  }<br/>})</span></pre><p id="abf2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果HTML表单作为数据，那么正文将</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="97c2" class="mp lp in ln b gy mq mr l ms mt">body: new FormData(form), // post body as form data<br/>headers: {<br/>    'Content-Type': '<!-- -->application/x-www-form-urlencoded<!-- -->'<br/>}</span></pre><h2 id="b296" class="mp lp in bd lq mw mx dn lu my mz dp ly kx na nb ma lb nc nd mc lf ne nf me ng bi translated">反应</h2><p id="73f1" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">解析API响应将非常重要，有各种方法可以用来处理响应。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1613" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">响应对象头有<code class="fe lk ll lm ln b">res.headers.get()</code>来获取响应头的值。</p><h2 id="ef08" class="mp lp in bd lq mw mx dn lu my mz dp ly kx na nb ma lb nc nd mc lf ne nf me ng bi translated">捕捉错误</h2><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="0264" class="mp lp in ln b gy mq mr l ms mt">fetch('/data.json').then(checkStatus)</span><span id="0b29" class="mp lp in ln b gy nj mr l ms mt">function checkStatus (res) {<br/>  if (res.status &gt;= 200 &amp;&amp; res.status &lt; 300) {<br/>    return res<br/>  } else {<br/>    var err = new Error(res.statusText)<br/>    err.response = res<br/>    throw err<br/>  }<br/>}</span></pre><p id="b681" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">非2xx响应仍然是成功的请求。用另一个函数把它们变成错误。</p><h2 id="cad8" class="mp lp in bd lq mw mx dn lu my mz dp ly kx na nb ma lb nc nd mc lf ne nf me ng bi translated">与Node.js一起使用</h2><p id="9a60" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">这将<code class="fe lk ll lm ln b">fetch</code>添加为一个全局变量，这样它的API在客户机和服务器之间是一致的。</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="c753" class="mp lp in ln b gy mq mr l ms mt">const fetch = require('isomorphic-fetch')</span></pre><p id="4452" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">参见npm包<code class="fe lk ll lm ln b"><a class="ae mv" href="https://www.npmjs.com/package/isomorphic-fetch" rel="noopener ugc nofollow" target="_blank">isomorphic-fetch</a></code></p><h1 id="454d" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">异步等待</h1><p id="241b" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">处理异步函数是捕捉承诺的一种简单方法。函数<code class="fe lk ll lm ln b">fetch()</code>可以与一个<code class="fe lk ll lm ln b">await</code>关键字结合来捕获响应。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="085d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">异步函数可以用来捕获回调的另一种方式。</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="a26a" class="mp lp in ln b gy mq mr l ms mt">// Get wrapper<br/>const get = async (url, callback) =&gt; {   <br/>  const response = await fetch(url)   <br/>  const status = await response.status      <br/>  if (callback) callback[status](await response.json()) <br/>}  </span><span id="e5ab" class="mp lp in ln b gy nj mr l ms mt">// Get usage based callback<br/>get(url, {   <br/>  200: body =&gt; doSomething,   <br/>  401: body =&gt; showSignInModal,   <br/>  403: body =&gt; redirectToSafeArea,   <br/>  422: body =&gt; showModalWithInstruction <br/>})</span></pre><h1 id="7431" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">截取</h1><p id="508d" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">对于多个网络请求，有时我们需要根据我们的需求添加一些逻辑或附加选项。拦截提取可能是有用的。</p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="4a99" class="mp lp in ln b gy mq mr l ms mt">fetch = (function (originalFetch) {<br/>    return function __myFetch(req) {<br/>        var result = originalFetch.apply(this, arguments);<br/>        result.then(functionToDoSomething);<br/>        return result; // or return the result of the `then` call<br/>    };<br/>})(fetch);</span></pre><p id="4fe2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此外，基于包装的拦截使用了新的<code class="fe lk ll lm ln b">Promise()</code></p><pre class="kd ke kf kg gt ml ln mm mn aw mo bi"><span id="8ae3" class="mp lp in ln b gy mq mr l ms mt">const iFetch = (url) =&gt; {<br/>    return new Promise((resolve, reject) =&gt; {</span><span id="64e1" class="mp lp in ln b gy nj mr l ms mt">        // Here we can do some prerequest actions</span><span id="bcff" class="mp lp in ln b gy nj mr l ms mt">        return fetch(url)<br/>        .then((response) =&gt; { return response.json() })<br/>        .then((data) =&gt; resolve(data))<br/>        .catch((error) =&gt; reject(error))<br/>    }<br/>}</span></pre><h1 id="052d" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">中止信号</h1><p id="f252" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">使用附加的<code class="fe lk ll lm ln b">AbortController()</code>发送信号选项将有助于使用<code class="fe lk ll lm ln b">controller.abort()</code>取消请求。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="a247" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">使用全部承诺</h1><p id="9df6" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">使用<code class="fe lk ll lm ln b">Promise.all()</code>和<code class="fe lk ll lm ln b">fetch()</code>调用多个请求将能够通过分割实现的响应和拒绝的响应来处理多个承诺，然后得到一个最终的响应。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="4a47" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">资源</h1><ol class=""><li id="2fcc" class="nk nl in kq b kr mg ku mh kx nm lb nn lf no lj np nq nr ns bi translated">Mozilla获取API(参见<a class="ae mv" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">链接</a></li><li id="117a" class="nk nl in kq b kr nt ku nu kx nv lb nw lf nx lj np nq nr ns bi translated">WHATWG获取API规范(参见<a class="ae mv" href="https://fetch.spec.whatwg.org/" rel="noopener ugc nofollow" target="_blank">链接</a>)</li><li id="a0de" class="nk nl in kq b kr nt ku nu kx nv lb nw lf nx lj np nq nr ns bi translated">我可以使用获取API浏览器支持吗(参见<a class="ae mv" href="https://caniuse.com/?search=fetch" rel="noopener ugc nofollow" target="_blank">链接</a></li></ol><h1 id="d3ff" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">结论</h1><p id="579b" class="pw-post-body-paragraph ko kp in kq b kr mg jo kt ku mh jr kw kx mi kz la lb mj ld le lf mk lh li lj ig bi translated">应用程序与外部资源紧密结合，以处理不同格式的数据。我们可以使用<code class="fe lk ll lm ln b">fetch()</code> API，它是浏览器本身支持的。希望使用备忘单有助于更好地进行<code class="fe lk ll lm ln b">fetch()</code> API调用。</p></div></div>    
</body>
</html>