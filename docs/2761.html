<html>
<head>
<title>React Tips — Query Strings, Wrappers, and Clicks Outside</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React提示—查询字符串、包装器和外部点击</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-tips-query-strings-wrappers-and-clicks-outside-a59b7c70bc?source=collection_archive---------6-----------------------#2020-07-21">https://javascript.plainenglish.io/react-tips-query-strings-wrappers-and-clicks-outside-a59b7c70bc?source=collection_archive---------6-----------------------#2020-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d12e9c4538315bf1a626145b2638d443.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*I3yBYUZJv5FEo68B"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mparzuchowski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Michał Parzuchowski</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b218" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些编写更好的React应用程序的技巧。</p><h1 id="3fa6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">修复“相邻的JSX元素必须包含在封闭标记中”错误</h1><p id="f4a2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">所有组件都必须有外部元素围绕。</p><p id="a371" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1b16" class="mn lc iq mj b gy mo mp l mq mr">return (<br/>  &lt;div&gt;<br/>    &lt;Child1 /&gt;<br/>    &lt;Child2 /&gt;<br/>  &lt;/div&gt;<br/>)</span></pre><p id="1129" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个围绕所有子元素的div。</p><p id="caff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果我们不想呈现包装器元素，可以使用片段来包围我们的组件。</p><p id="f208" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9635" class="mn lc iq mj b gy mo mp l mq mr">return (<br/>  &lt;&gt;<br/>    &lt;Child1 /&gt;<br/>    &lt;Child2 /&gt;<br/>  &lt;/&gt;<br/>)</span></pre><p id="0dd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d6d3" class="mn lc iq mj b gy mo mp l mq mr">return (<br/>  &lt;React.Fragment&gt;<br/>    &lt;Child1 /&gt;<br/>    &lt;Child2 /&gt;<br/>  &lt;/React.Fragment&gt;<br/>)</span></pre><h1 id="c700" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在React中修改状态数组的正确方法</h1><p id="d662" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了在React中正确地修改状态数组，我们应该用一个返回新数组的回调函数调用<code class="fe ms mt mu mj b">setState</code>的状态改变函数。</p><p id="e339" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们知道新的值是从最新的值中得到的。</p><p id="a69f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f5ac" class="mn lc iq mj b gy mo mp l mq mr">this.setState(prevState =&gt; ({<br/>  array: [...prevState.array, newThing]<br/>}))</span></pre><p id="125d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe ms mt mu mj b">newThing</code>添加到数组的末尾。</p><p id="b40a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用一个函数组件，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3140" class="mn lc iq mj b gy mo mp l mq mr">const [arr, setArr] = useState([]);<br/>//...<br/>setArr(prevArr =&gt; [...prevArr, newThing]);</span></pre><h1 id="ca1a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检测React组件外部的单击</h1><p id="c030" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过监听<code class="fe ms mt mu mj b">documen</code>的点击事件来检测React组件外部的点击。</p><p id="ec60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以处理任何元素的点击。</p><p id="2036" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="78de" class="mn lc iq mj b gy mo mp l mq mr">import React, { Component } from 'react';</span><span id="cdc3" class="mn lc iq mj b gy mv mp l mq mr"><br/>export default class App extends Component {<br/>  constructor(props) {<br/>    super(props);</span><span id="5902" class="mn lc iq mj b gy mv mp l mq mr">    this.setWrapperRef = this.setWrapperRef.bind(this);<br/>    this.handleClickOutside = this.handleClickOutside.bind(this);<br/>  }</span><span id="5b79" class="mn lc iq mj b gy mv mp l mq mr">  componentDidMount() {<br/>    document.addEventListener('mousedown', this.handleClickOutside);<br/>  }</span><span id="3678" class="mn lc iq mj b gy mv mp l mq mr">  componentWillUnmount() {<br/>    document.removeEventListener('mousedown', this.handleClickOutside);<br/>  }</span><span id="ad7a" class="mn lc iq mj b gy mv mp l mq mr">  setWrapperRef(node) {<br/>    this.wrapperRef = node;<br/>  }</span><span id="bb84" class="mn lc iq mj b gy mv mp l mq mr">  handleClickOutside(event) {<br/>    if (this.wrapperRef &amp;&amp; !this.wrapperRef.contains(event.target)) {<br/>      alert('clicked outside');<br/>    }<br/>  }</span><span id="c74c" class="mn lc iq mj b gy mv mp l mq mr">  render() {<br/>    return &lt;div ref={this.setWrapperRef}&gt;hello&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="7a73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe ms mt mu mj b">docuyment.addEventListener</code>方法来监听<code class="fe ms mt mu mj b">componentDidMount</code>钩子中的点击事件。</p><p id="f7b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们移除监听器，组件在<code class="fe ms mt mu mj b">componentWillUnmount</code>钩子中的<code class="fe ms mt mu mj b">removeListener</code>被卸载。</p><p id="1225" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们设置div的ref，这样我们就可以检查哪个元素被点击了<code class="fe ms mt mu mj b">handleclickOutside</code>，以及它是否在带有<code class="fe ms mt mu mj b">contains</code>的组件内部。</p><p id="c32e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以用钩子对功能组件做同样的事情。</p><p id="68e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="030f" class="mn lc iq mj b gy mo mp l mq mr">import React, { useRef, useEffect } from "react";</span><span id="0b8e" class="mn lc iq mj b gy mv mp l mq mr"><br/>function useClickOutside(ref) {<br/>  useEffect(() =&gt; {<br/>    function handleClickOutside(event) {<br/>      if (ref.current &amp;&amp; !ref.current.contains(event.target)) {<br/>        console.log("clicked outside");<br/>      }<br/>    }</span><span id="8bf7" class="mn lc iq mj b gy mv mp l mq mr">    document.addEventListener("mousedown", handleClickOutside);<br/>    return () =&gt; {<br/>      document.removeEventListener("mousedown", handleClickOutside);<br/>    };<br/>  }, [ref]);<br/>}</span><span id="5ec6" class="mn lc iq mj b gy mv mp l mq mr">export default function App() {<br/>  const wrapperRef = useRef(null);<br/>  <!-- -->useClickOutside<!-- -->(wrapperRef);<br/><br/>  return &lt;div ref={wrapperRef}&gt;hello&lt;/div&gt;;<br/>}</span></pre><p id="a22c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了<code class="fe ms mt mu mj b">useClickOutside</code>挂钩，以便在挂钩加载时添加事件监听器。</p><p id="37a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在函数中，我们在<code class="fe ms mt mu mj b">useEffect</code>回调中返回，我们移除点击监听器。</p><p id="2ae0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们观察<code class="fe ms mt mu mj b">ref</code>的变化，因此我们将<code class="fe ms mt mu mj b">[ref]</code>作为<code class="fe ms mt mu mj b">useEffect</code>的第二个参数。</p><p id="8ffd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe ms mt mu mj b">useRef</code>来创建ref，将它分配给div，并用它调用<code class="fe ms mt mu mj b">useClickOutside</code>。</p><h1 id="772b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何从查询字符串中获取参数值</h1><p id="7dda" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们使用React Router，我们可以用<code class="fe ms mt mu mj b">URLSearchParams</code>构造函数和<code class="fe ms mt mu mj b">location.search</code>属性从查询字符串中获取参数值。</p><p id="c770" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a2dc" class="mn lc iq mj b gy mo mp l mq mr">new URLSearchParams(this.props.location.search).get("foo")</span></pre><p id="6372" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">this.prop.location.search</code>有查询字符串。</p><p id="c68d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe ms mt mu mj b">URLSearchParams</code>构造函数把它解析成一个对象。</p><p id="3fbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用想要得到的查询参数的键调用<code class="fe ms mt mu mj b">get</code>。</p><p id="88b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d184" class="mn lc iq mj b gy mo mp l mq mr">this.props.match.params.foo</span></pre><p id="5166" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取带有关键字<code class="fe ms mt mu mj b">foo</code>的查询参数。</p><p id="4a9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用React路由器的hooks版本，我们可以编写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="416d" class="mn lc iq mj b gy mo mp l mq mr">import { useLocation } from 'react-router';<br/>import queryString from 'query-string';</span><span id="bf30" class="mn lc iq mj b gy mv mp l mq mr">const App = React.memo((props) =&gt; {<br/>  const location = useLocation();<br/>  console.log(queryString.parse(location.search));</span><span id="7597" class="mn lc iq mj b gy mv mp l mq mr">  return &lt;p&gt;search&lt;/p&gt;;<br/>}</span></pre><p id="f81d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用React路由器的<code class="fe ms mt mu mj b">useLocation</code>钩子从钩子中获取<code class="fe ms mt mu mj b">location</code>对象。</p><p id="9948" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe ms mt mu mj b">queryString</code>包来解析查询字符串。</p><p id="1ded" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用<code class="fe ms mt mu mj b">URLSearchParams</code>构造函数替换查询字符串包:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f47f" class="mn lc iq mj b gy mo mp l mq mr">import { useLocation } from 'react-router';</span><span id="6130" class="mn lc iq mj b gy mv mp l mq mr">const App = React.memo((props) =&gt; {<br/>  const location = useLocation();<br/>  console.log(new URLSearchParams(location.search));</span><span id="37dd" class="mn lc iq mj b gy mv mp l mq mr">  return &lt;p&gt;search&lt;/p&gt;;<br/>}</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/60fc47763b661bf63e7eb6ea0cd55f89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HTc_N30vY2aiI-7I"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@blakewisz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Blake Wisz</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d25b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="b45f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该用根元素或片段包装我们的组件。</p><p id="82df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">修改数组的正确方法是传递一个函数给<code class="fe ms mt mu mj b">setState</code>或者状态改变函数。</p><p id="fbf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过添加事件侦听器来监视组件外部的点击。</p><p id="03c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用React Router从组件中获取查询字符串。</p><h1 id="de7c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单英语的JavaScript</h1><p id="b286" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>