<html>
<head>
<title>Best of Modern JavaScript — Callable Entities and Array Like Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华——可调用的实体和类似数组的对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-callable-entities-and-array-like-objects-128509ee4f0b?source=collection_archive---------8-----------------------#2020-09-18">https://javascript.plainenglish.io/best-of-modern-javascript-callable-entities-and-array-like-objects-128509ee4f0b?source=collection_archive---------8-----------------------#2020-09-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e767f5c64b420502e7af2522a0fc75cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u-FSKmCOQ_QPYoAX"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jentheodore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jen Theodore</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2124" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript中的spread操作符和函数。</p><h1 id="189a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将可迭代或类似数组的对象转换为数组</h1><p id="6d44" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将可迭代或类似数组的对象转换成数组。</p><p id="a766" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用spread操作符来实现这一点。</p><p id="3085" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d0f3" class="mn lc iq mj b gy mo mp l mq mr">const set = new Set([1, 2, 6]);<br/>const arr = [...set];</span></pre><p id="7860" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">arr</code>就是<code class="fe ms mt mu mj b"> [1, 2, 6]</code>。</p><p id="1cdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用同样的方法将其他可迭代对象转换成数组。</p><p id="7f2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fa82" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  *[Symbol.iterator]() {<br/>    yield 1;<br/>    yield 2;<br/>    yield 3;<br/>  }<br/>};<br/>const arr = [...obj];</span></pre><p id="7faa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">arr</code>就是<code class="fe ms mt mu mj b">[1, 2, 3]</code>。</p><p id="c429" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有一些不是可迭代的，而是类似数组的东西，我们可以用<code class="fe ms mt mu mj b">Array.from</code>方法把它转换成一个数组。</p><p id="bd85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4310" class="mn lc iq mj b gy mo mp l mq mr">const arrayLike = {<br/>  '0': 'a',<br/>  '1': 'b',<br/>  '2': 'c',<br/>  length: 3<br/>};</span><span id="25f2" class="mn lc iq mj b gy mv mp l mq mr">const<!-- --> <!-- -->arr<!-- --> <!-- -->=<!-- --> <!-- -->Array.from(arrayLike);</span></pre><p id="20ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">arr</code>就是<code class="fe ms mt mu mj b">[“a”, “b”, “c”]</code>。</p><p id="de32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不能使用spread运算符将<code class="fe ms mt mu mj b">arrayLike</code>扩展到一个数组中。</p><p id="e31f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们尝试，我们会得到一个类型错误。</p><h1 id="6d96" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">ES6中的可调用实体</h1><p id="c882" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">ES6或更高版本有几种类型的可调用实体。</p><p id="30ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们是函数、方法和构造函数。</p><p id="0d29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数不是任何对象的一部分，所以我们通过编写<code class="fe ms mt mu mj b">foo(1)</code>来调用它们。</p><p id="f60f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">方法是作为对象属性的函数。</p><p id="8e44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比如我们可以通过写<code class="fe ms mt mu mj b">obj.foo(81)</code>来称呼他们。</p><p id="6e83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造函数是我们可以作为构造函数实例的对象的函数。</p><p id="e4ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比如我们可以写<code class="fe ms mt mu mj b">new Constr(8)</code>来调用它。</p><p id="753f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">super</code>通话仅限于特定地点。</p><p id="6e39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下代码来调用超级方法调用:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f167" class="mn lc iq mj b gy mo mp l mq mr">super.method('abc')</span></pre><p id="7b7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样调用超级构造函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="489b" class="mn lc iq mj b gy mo mp l mq mr">super(8)</span></pre><p id="6ff5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果一个类是使用<code class="fe ms mt mu mj b">extended</code>关键字创建的子类，我们可以这样做。</p><p id="fd02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0720" class="mn lc iq mj b gy mo mp l mq mr">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="c212" class="mn lc iq mj b gy mv mp l mq mr">  greet() {<br/>    console.log(`hello ${name}`)<br/>  }<br/>}</span><span id="8414" class="mn lc iq mj b gy mv mp l mq mr">class Employee extends Person {<br/>  constructor(name, title) {<br/>    super(name);<br/>    this.title = title;<br/>  }</span><span id="a86e" class="mn lc iq mj b gy mv mp l mq mr">  greet() {<br/>    super.greet()<br/>  }<br/>}</span></pre><p id="872a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用了<code class="fe ms mt mu mj b">super</code>构造函数来从子<code class="fe ms mt mu mj b">Employee</code>类中调用<code class="fe ms mt mu mj b">Person</code>构造函数。</p><p id="71a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe ms mt mu mj b">super.greet()</code>调用了<code class="fe ms mt mu mj b">Person</code>实例的<code class="fe ms mt mu mj b">greet</code>方法。</p><h1 id="22fc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">更喜欢将箭头函数作为回调函数</h1><p id="ad61" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">回调通常不需要自己的<code class="fe ms mt mu mj b">this</code>值，所以我们可以用箭头函数来定义。</p><p id="22b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也更紧凑，所以我们打字更少。</p><p id="b7ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些API使用<code class="fe ms mt mu mj b">this</code>作为回调的隐式参数。</p><p id="20fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这阻止了我们使用箭头函数作为回调函数。</p><p id="e72b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，<code class="fe ms mt mu mj b">addEventListener</code>可能在他们的回调中使用<code class="fe ms mt mu mj b">this</code>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dfdf" class="mn lc iq mj b gy mo mp l mq mr">document.addEventListener('click', function() {<br/>  console.log(this);<br/>})</span></pre><p id="61d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">this</code>是<code class="fe ms mt mu mj b">document</code>对象。</p><p id="3621" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们可以将<code class="fe ms mt mu mj b">this</code>改为<code class="fe ms mt mu mj b">document</code>，这样我们就可以在回调中使用箭头函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6546" class="mn lc iq mj b gy mo mp l mq mr">document.addEventListener('click', () =&gt; {<br/>  console.log(document);<br/>})</span></pre><h1 id="36b5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">更喜欢将函数声明作为独立函数</h1><p id="a463" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有独立的函数，我们应该使用函数声明，这样我们可以在任何地方使用它们。</p><p id="73d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fbb6" class="mn lc iq mj b gy mo mp l mq mr">function foo(arg1, arg2) {<br/>  // ···<br/>}</span></pre><p id="b3da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们可以在任何地方使用，它们看起来像发电机功能。</p><p id="d20d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，对于独立的功能，我们通常不需要<code class="fe ms mt mu mj b">this</code>。</p><p id="352a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们不需要自己的<code class="fe ms mt mu mj b">this</code>函数内部，那么我们可以将arrow函数设置为一个变量。</p><p id="51df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dccf" class="mn lc iq mj b gy mo mp l mq mr">const<!-- --> <!-- -->foo<!-- --> <!-- -->=<!-- --> <!-- -->(arg1,<!-- --> <!-- -->arg2)<!-- --> <!-- -->=&gt;<!-- --> <!-- -->{<br/>  //...<br/>};</span></pre><p id="4c0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们就不用担心函数内部<code class="fe ms mt mu mj b">this</code>的值了。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/d9ffade9e4aa51e94dc0a88597bb8c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XF3oh44wt7fZErfM"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@vivintsolar?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Vivint Solar</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="662b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="17a6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将不可迭代的类似数组的对象转换成数组。</p><p id="3650" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，现代JavaScript有各种各样的可调用实体。</p><h2 id="67cb" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="d21d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>