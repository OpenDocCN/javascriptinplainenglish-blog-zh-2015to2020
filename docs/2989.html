<html>
<head>
<title>A Visual Guide to How to Actually Invert a Binary Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实际反转二叉树的可视化指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-visual-guide-to-how-to-actually-invert-a-binary-tree-9e5df119218f?source=collection_archive---------0-----------------------#2020-08-16">https://javascript.plainenglish.io/a-visual-guide-to-how-to-actually-invert-a-binary-tree-9e5df119218f?source=collection_archive---------0-----------------------#2020-08-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4139" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你能在垂直轴上翻转<code class="fe kf kg kh ki b">binary tree</code>吗？这是一个著名的问题，通过这条推特变得流行起来:</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/ac5eeb05dc8284274f479e9f8cb4b144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sRwntyiitoxn_ijK.png"/></div></div></figure><blockquote class="kv kw kx"><p id="82d7" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><em class="iq">谷歌:我们90%的工程师使用您编写的软件(自制软件)，但您不能在白板上颠倒二叉树，所以滚开。</em></p><p id="6d3d" class="ky kz la lb b lc ld jr le lf lg ju lh li lj lk ll lm ln lo lp lq lr ls lt lu ij bi translated"><em class="iq">-Max Howell(@ mxcl)</em><a class="ae lv" href="https://twitter.com/mxcl/status/608682016205344768?ref_src=twsrc%5Etfw" rel="noopener ugc nofollow" target="_blank"><em class="iq">2015年6月10日</em> </a></p></blockquote><p id="62bd" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">给定这样的<code class="fe kf kg kh ki b">binary tree</code>:</p><pre class="kk kl km kn gt lz ki ma mb aw mc bi"><span id="a0da" class="md me iq ki b gy mf mg l mh mi">     4<br/>   /   \<br/>  2     7<br/> / \   / \<br/>1   3 6   9</span></pre><p id="b2a5" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">执行反演将导致:</p><pre class="kk kl km kn gt lz ki ma mb aw mc bi"><span id="dc05" class="md me iq ki b gy mf mg l mh mi">Output:<br/><br/>     4<br/>   /   \<br/>  7     2<br/> / \   / \<br/>9   6 3   1</span></pre><p id="4cfe" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">树节点的定义如下:</p><pre class="kk kl km kn gt lz ki ma mb aw mc bi"><span id="ca19" class="md me iq ki b gy mf mg l mh mi">function Node(val) {<br/>  this.val = val;<br/>  this.left = null;<br/>  this.right = null;<br/>}</span></pre><p id="b72d" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated"><em class="la">这节课最初发表在</em><a class="ae lv" href="https://algodaily.com/challenges/invert-a-binary-tree" rel="noopener ugc nofollow" target="_blank"><em class="la">https://algodaily.com</em></a><em class="la">上，在那里我开设了一门技术面试课程，并为雄心勃勃的开发者写一些想法。</em></p></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4595" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">这是著名问题<code class="fe kf kg kh ki b">Homebrew</code>的作者<code class="fe kf kg kh ki b">Max Howell</code> <a class="ae lv" href="https://twitter.com/mxcl/status/608682016205344768?lang=en" rel="noopener ugc nofollow" target="_blank">在谷歌采访</a>中出了名的错误。希望这能防止你有同样的不幸！</p><p id="7a15" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">让我们想想蛮力——如果没有任何巧妙的算法，我们怎么做？我们可以从非常基本的输入开始，如下所示:</p><pre class="kk kl km kn gt lz ki ma mb aw mc bi"><span id="9234" class="md me iq ki b gy mf mg l mh mi">  1<br/> / \<br/>2   3</span></pre><p id="2832" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">所以要垂直翻转它，我们要从<code class="fe kf kg kh ki b">1</code>开始，那里没有东西可以翻转或交换，它会保持不动。我们现在已经处理了第一行。</p><p id="ef21" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">转到第二个，我们遇到<code class="fe kf kg kh ki b">2</code>和<code class="fe kf kg kh ki b">3</code>，所以我们会交换它们，得到:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ms"><img src="../Images/22803e6d1a0fa72512386cec1abab068.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*75bsw3jv1OoojzVm.png"/></div></div></figure><pre class="kk kl km kn gt lz ki ma mb aw mc bi"><span id="22d8" class="md me iq ki b gy mf mg l mh mi">  1<br/> / \<br/>3   2</span></pre><p id="2b85" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">有趣的是，这似乎颠倒了它！当有多个节点时，它是否像交换一样简单？</p><p id="a83f" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">但是，如果每个级别有两个以上的节点可以交换呢？如果有额外的级别，可能如下所示:</p><pre class="kk kl km kn gt lz ki ma mb aw mc bi"><span id="a070" class="md me iq ki b gy mf mg l mh mi">      1<br/>     / \<br/>    3   2<br/>   / \   \<br/>  4   5   3</span></pre><p id="3a37" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">最后一行目前的方向是<code class="fe kf kg kh ki b">4 -&gt; 5 -&gt; 3</code>，但我们希望结果是<code class="fe kf kg kh ki b">3 -&gt; 5 -&gt; 4</code>被正确颠倒。</p><p id="01c4" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">然而，我们可以通过进行两次单独的互换来实现这一点。请注意，如果我们将<code class="fe kf kg kh ki b">4</code>和<code class="fe kf kg kh ki b">5</code>换成<code class="fe kf kg kh ki b">5 -&gt; 4</code>，然后将<code class="fe kf kg kh ki b">5 -&gt; 4</code>换成<code class="fe kf kg kh ki b">3</code>，就会得到下面的结果。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/b5d2d17f2e5c0aaf699542fa10d6a56d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1NUpVDlVOtm7mUIE"/></div></div></figure><pre class="kk kl km kn gt lz ki ma mb aw mc bi"><span id="7627" class="md me iq ki b gy mf mg l mh mi">      1<br/>     / \<br/>    2   3<br/>   /   / \<br/>  3   5   4</span></pre><p id="f398" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">因此，将所有这些放在一起:我们可以按顺序遍历，并在每次迭代时进行交换。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/27533cfd16de1b1c5011005c2a7a9253.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iBTVjfy_8dtxoAG7.png"/></div></div></figure><p id="6d5b" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">读者指出了一个警告——如果我们处理的是一个非常大的二叉树，那么递归解决方案可能会由于调用堆栈大小而引起问题。有两种方法可以解决这个问题:</p><ol class=""><li id="e450" class="mt mu iq lb b lc ld lf lg lw mv lx mw ly mx lu my mz na nb bi translated">使用堆栈来模拟递归</li><li id="263d" class="mt mu iq lb b lc nc lf nd lw ne lx nf ly ng lu my mz na nb bi translated">使用一个队列，以BFS方式一个接一个地访问各个级别，并交换左右节点来反转树。</li></ol><p id="0b88" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated">下面是最终代码的样子:</p><pre class="kk kl km kn gt lz ki ma mb aw mc bi"><span id="8cc6" class="md me iq ki b gy mf mg l mh mi">function invertTree(head) {<br/>  if (head) {<br/>    var temp = head.left;<br/>    head.left = head.right;<br/>    head.right = temp;<br/><br/>    invertTree(head.left);<br/>    invertTree(head.right);<br/>  }<br/><br/>  return head;<br/>}</span></pre></div><div class="ab cl mj mk hu ml" role="separator"><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo mp"/><span class="mm bw bk mn mo"/></div><div class="ij ik il im in"><p id="e48a" class="pw-post-body-paragraph ky kz iq lb b lc ld jr le lf lg ju lh lw lj lk ll lx ln lo lp ly lr ls lt lu ij bi translated"><em class="la">最初发表于</em><a class="ae lv" href="https://algodaily.com/challenges/invert-a-binary-tree" rel="noopener ugc nofollow" target="_blank"><em class="la">【https://algodaily.com】</em></a><em class="la">。</em></p></div></div>    
</body>
</html>