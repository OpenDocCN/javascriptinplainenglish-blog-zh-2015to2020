<html>
<head>
<title>DIY Kafka Topic Watcher tool — Node, Express, Server Sent Events and Apache Kafka</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">DIY Kafka主题观察工具——节点、快捷、服务器发送事件和Apache Kafka</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/diy-kafka-topic-watcher-tool-node-express-server-sent-events-and-apache-kafka-992b0ec2c70?source=collection_archive---------13-----------------------#2020-04-28">https://javascript.plainenglish.io/diy-kafka-topic-watcher-tool-node-express-server-sent-events-and-apache-kafka-992b0ec2c70?source=collection_archive---------13-----------------------#2020-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="9d88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这篇文章至少有两种不同的解读方式:</p><ol class=""><li id="698c" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk kq kr ks kt bi translated">作为一个方便工具的冗长介绍，您可以轻松地运行它来检查发布到Kafka集群中的主题的消息</li><li id="9c92" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk kq kr ks kt bi translated">作为一个详细但基本的例子，说明如何结合几种技术来创建从Kafka主题(在服务器上或云中)到客户端浏览器的端到端(推送)管道(包括:Node &amp; node-rdkafka、Express和服务器发送的事件、DHTML &amp;客户端JavaScript</li></ol><p id="8287" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文介绍了一个简单的工具——节点应用程序，它提供了有用的功能，并且可以很容易地用附加功能进行扩展。本文提供的代码包含许多有用的示例，包括Node/JavaScript语言用法、使用node-rdkafka创建Kafka客户端以及使用Express中间件在服务器和客户端幻灯片上实现服务器发送事件通道。</p><p id="ab59" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此图显示了Kafka主题观察器:在浏览器窗口中，当Kafka主题产生新消息时会自动刷新，显示了来自Apache Kafka集群中所有主题的消息的动态列表。所有历史消息都可以从主题刷新到浏览器中。在开发过程中非常方便——对于研讨会、演示和娱乐也是如此。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/c054e9ca338d08f2f79d73a572614cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*83Q50xn2cRgXaBoy.png"/></div></div></figure><p id="e7e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">节点应用程序可以在任何地方运行——在笔记本电脑上、在云中、在服务器上——并连接到指定的Kafka集群——该集群(假设网络访问规则配置正确)可以位于任何地方，例如在公共云中。</p><p id="f5d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该工具的源代码可从GitHub获得:<a class="ae ll" href="https://github.com/AMIS-Services/online-meetups-introduction-of-kafka/tree/master/lab2b-topic-watcher" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/AMIS-Services/online-meetups-introduction-of-Kafka/tree/master/lab2b-topic-watcher</a>(作为Apache Kafka三部分研讨会报告的一部分)</p><h1 id="7729" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">Kafka主题观察器应用程序概述</h1><p id="b16d" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">Kafka主题观察器的核心是节点应用程序——app . js是其中的主要模块。本模块:</p><ul class=""><li id="75f0" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk mp kr ks kt bi translated">启动HTTP服务器(端口3010)为web应用程序(一些静态文件— HTML、Javascript和图像)提供服务</li><li id="03cc" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk mp kr ks kt bi translated">处理来自web应用程序的REST请求</li><li id="3acc" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk mp kr ks kt bi translated">将SSE(服务器发送的事件)推送到web应用程序(使用<em class="mq"> sse.js </em>中的SSE支持)</li><li id="598b" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk mp kr ks kt bi translated">导入并初始化连接到目标Kafka集群的<em class="mq">消费</em>模块(在<em class="mq"> config.js </em>中指定)</li><li id="fbc1" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk mp kr ks kt bi translated">使用<em class="mq"> consume </em>模块设置一个消息处理程序，用于处理Kafka集群中所有主题的消息:函数<em class="mq"> handleMessage </em>。该函数准备将事件推送到浏览器，并使用函数<em class="mq"> updateSseClients </em>和<em class="mq"> sse.js </em>模块向所有连接的Kafka主题观察器客户端发送sse事件。</li></ul><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi mr"><img src="../Images/54ebfacb3bc907e189fa9e3732107d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3INYnGOlJXITFF0u.png"/></div></div></figure><p id="8420" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">web应用由文件<em class="mq">index.html</em>和两个支持(客户端)JavaScript文件:<em class="mq"> message-handler.js </em>和<em class="mq"> topics-management.js </em>组成。前者订阅SSE端点并处理SSE事件，这些事件是从节点应用程序为从Kafka主题之一消费的每个消息推送的。这些消息被收集在一个<em class="mq"> messages </em>数组中，并被写入到<em class="mq">topicmessagetable</em>HTML表格元素的顶部。</p><p id="523d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Kafka集群上的当前主题列表是从XHR中的节点应用程序请求的(也称为AJAX请求)，来自<em class="mq"> topic-management.js </em>。异步响应中返回的主题列表根据该请求的响应内容写入HTML页面。</p><p id="3c0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GUI包含一个按钮<em class="mq">清除消息</em>。按下时，调用函数<em class="mq"> clearMessages </em>(在message-handler.js中)。它清除<em class="mq">消息</em>数组，并从<em class="mq">主题消息表</em>中删除行。</p><p id="7ade" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GUI还包含一个链接<em class="mq">从头重读所有主题</em>。当点击时，函数<em class="mq"> config </em>被触发，该函数依次向<em class="mq"> /config </em>端点发送POST请求，该端点随后用一个标志重新初始化消费者，该标志指定将从所有主题中读取所有消息，而不仅仅是新到达的消息；函数<em class="mq"> initializeConsumer </em>被调用，将断开当前的流消费者并创建一个新的。</p><h1 id="2adf" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">运行Kafka主题观察器</h1><p id="fb8e" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">卡夫卡话题观察者差不多要出发了。您不需要对代码进行修改来获得乐趣——除了确保<em class="mq">文件config.js </em>具有适合您的环境的正确设置:需要定义Kafka Broker配置(针对您的本地集群或例如基于CloudKarafka云的集群)。</p><p id="2770" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在运行应用程序之前，您需要引入依赖项。从包含文件<em class="mq"> package.json </em>的目录中的命令行运行:</p><pre class="la lb lc ld gt ms mt mu mv aw mw bi"><span id="bd09" class="mx ln iq mt b gy my mz l na nb">npm install</span></pre><p id="5f10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将所有需要的NPM模块下载到目录节点-模块中。</p><p id="b5b8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在您可以运行web应用程序了:</p><p id="e8cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者</p><p id="431e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">HTTP服务器启动并监听端口3010。</p><p id="f7ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从浏览器打开Kafka主题观察器web应用程序:<a class="ae ll" href="http://localhost:3010" rel="noopener ugc nofollow" target="_blank"> http://localhost:3010 </a>。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nc"><img src="../Images/adbffdb2759238413dc08e923dc75583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wPjowlxVR047Rdw5.png"/></div></div></figure><p id="ab2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您应该会看到指定Kafka集群中所有非内部主题的列表。您将看到针对这些主题生成的所有新消息。您可以点击链接<em class="mq">从头重读所有主题</em>查看主题历史中的所有消息。除了来自Kafka主题的真实消息之外，您还将看到由节点应用程序每25秒发送给所有SSE客户端的心跳消息。</p><h1 id="cff5" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">实施细节</h1><p id="6577" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">该工具实现的某些方面也许值得再看一眼(或者从中截取一些代码):</p><ul class=""><li id="2c67" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk mp kr ks kt bi translated">如何通过合并另外两个对象来创建一个JavaScript对象</li><li id="86d8" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk mp kr ks kt bi translated">如何使用node-rdkafka连接到Kafka集群</li><li id="984a" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk mp kr ks kt bi translated">如何检索Kafka集群中所有主题的列表</li><li id="a8d6" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk mp kr ks kt bi translated">如何从JavaScript函数返回异步响应</li><li id="4e41" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk mp kr ks kt bi translated">如何设置服务器从节点发送事件的通道以及如何在浏览器中接收SSE消息</li><li id="3a9e" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk mp kr ks kt bi translated">如何发送XHR (fka AJAX)请求并使用await fetch处理响应</li></ul><h1 id="186d" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">如何通过合并另外两个对象来创建一个JavaScript对象</h1><p id="8d04" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">最好看一个例子:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/3d4f0a0f5fabc20e90577c2b55883508.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/0*2PC0zftZZDwlzJBz.png"/></div></figure><p id="3a40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过将<em class="mq">external config . kafkaConfig</em>与现场创建的对象合并，组成kafkaconfig。两个对象中的所有属性都将包含在结果对象中。如果两个对象包含相同的属性，则该属性将具有在该操作中第二个对象中的值。</p><h1 id="648f" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">如何使用node-rdkafka连接到Kafka集群</h1><p id="9f1f" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">首先在package.json中声明node-rdkafka上的依赖关系，这提供了从JavaScript通过C/C++到kafka通信协议的桥梁。</p><p id="118d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">连接是作为生产者或消费者的一部分创建的——基于Kafka配置对象——实际上是基于属性<em class="mq"> metadata.broker.list </em>。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ne"><img src="../Images/899c8986eb7bda2539433e654850fcc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vBT-yh3aHVwTR0mE.png"/></div></div></figure><p id="b6b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该属性是用Kafka集群中代理的端点(主机名和端口)设置的。根据Kafka集群的安全配置，配置对象可能需要具有处理安全限制的属性。我一直在使用的一个Kafka配置对象的例子:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nf"><img src="../Images/5d8ae010016126f9fdf1ebd097823cb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iNyNVEcsJriFsjvX.png"/></div></div></figure><h1 id="52f9" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">如何检索Kafka集群中所有主题的列表</h1><p id="bd22" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">node-rdkafka实现为消费者和生产者提供了一个选项来检索kafka集群的元数据，检查<a class="ae ll" href="https://github.com/Blizzard/node-rdkafka#metadata" rel="noopener ugc nofollow" target="_blank">这个链接</a>。在本例中，我使用了Producer对象，尽管该工具实际上并没有为集群产生任何东西。</p><p id="5bf4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生产者对象是基于kafkaConfig对象创建的。一旦连接完毕，<em class="mq"> ready </em>事件处理程序将被传递一个元数据对象，其中包含一个用于集群中所有主题的数组。以“__”开头的主题名称表示内部管理主题。这些在<em class="mq">减少</em>步骤中被过滤掉。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/b072a4e567dc898e9f0eff028de4ade0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/0*rnT1E3HksT2GntA2.png"/></div></figure><h1 id="a0b2" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">如何从JavaScript函数返回异步响应</h1><p id="3966" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">函数<em class="mq"> getTopics </em>被定义为一个<em class="mq">异步</em>函数。这个函数的调用者很可能在他们的调用中使用一个<em class="mq"> await </em>:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/258f04c97649dc274d2f8a3d55a84ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1216/format:webp/0*MRHv98dzk8JeoHvl.png"/></div></figure><p id="3974" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">函数<em class="mq"> getTopics </em>只能访问它将在<em class="mq">就绪</em>事件的(异步)事件处理程序中返回的结果。为了在函数返回后产生函数结果，我们使用了一个承诺。函数<em class="mq"> getTopics </em>返回一个承诺——这是一个“延迟结果”。只有当处理给调用者的承诺(<em class="mq"> getStarted() </em>)完成时，await才会实现。在承诺内部，我们使用对(内置函数)<em class="mq"> resolve </em>的显式调用来使承诺产生结果。感觉就像函数getTopics()将一个小盒子交给函数getStarted()，并指示getStarted()继续等待，直到结果弹出盒子。</p><p id="2420" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于回调函数、事件处理程序、promises和async/await的组合，请参阅我之前的文章:<a class="ae ll" href="https://technology.amis.nl/2020/01/11/javascript-mapping-and-wrapping-classic-callback-functions-to-promises-and-async-await/" rel="noopener ugc nofollow" target="_blank">https://technology . amis . nl/2020/01/11/JavaScript-mapping-and-wrapping-classic-callback-functions-to-promises-and-async-await/</a>。</p><h1 id="a60d" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">如何高效优雅地将数组过滤为满足条件的元素:Reduce</h1><p id="6ccc" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">由metadata.topics返回的主题数组包含内部主题(名称以__开头的主题)。为了生成没有这些元素的主题数组，最优雅的方法是在源数组上设置<em class="mq"> reduce </em>操作符。Reduce使用一个起始值(本例中是空数组:[])和一个接收两个输入的函数:中间结果(最初是起始值，这里是空数组)和下一个数组元素。该函数预计会产生下一个中间结果。在这种情况下，中间结果是一个数组，其中包含原始数组中满足过滤条件的所有元素。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ni"><img src="../Images/41f4143c44b718ec3580709ef4206179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Q2KXBIn7JfzCwyAX.png"/></div></div></figure><p id="da29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个片段或多或少可以理解为:</p><blockquote class="nj nk nl"><p id="1de1" class="jn jo mq jp b jq jr js jt ju jv jw jx nm jz ka kb nn kd ke kf no kh ki kj kk ij bi translated"><em class="iq">const cluster topics =(select * from metadata . topics as topic where substring(topic . name，1，2)！= '__') </em></p></blockquote><h1 id="602c" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">如何设置服务器从节点发送事件的通道以及如何在浏览器中接收SSE消息</h1><p id="b5ff" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">浏览器客户端使用EventSource(url)订阅SSE源。这就是建立一个允许服务器发送更新并由客户端异步处理的通道所需要做的全部工作。消息处理程序附加到事件源。每当服务器将事件推送到SSE订阅者时，都会调用该函数。浏览器只是接收一个JSON包，并需要对它做一些有用的事情。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi np"><img src="../Images/75f84999fddc17aa8473650e9d0679c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*41iwo7IuFWnzX8TF.png"/></div></div></figure><p id="9b09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用Node和Express时SSE的服务器端也不太复杂。</p><p id="c6af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Express配置了多个“拦截器”,这些拦截器可以在HTTP请求被真正交给特定于路径和方法的处理程序之前对其进行处理——对于那些具有Java (Servlet)背景的人来说，这非常类似于Servlet过滤器和Servlet。sseMiddleware“拦截器”是一个简单的拦截器，它为每个响应添加了一个SSE连接属性——不管它是否会被使用。注意:只有在/updates处理程序中才真正使用这个连接。</p><p id="2d5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从客户端通过EventSource(URL)发送到/updates路径的请求是导致订阅SSE通道的请求。建立连接(并将其发送到浏览器客户端)并将其添加到sseClients集合中，以便能够在服务器端需要表达自己时向其发送消息。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nq"><img src="../Images/0d0f2461b47902ebe13da96ff2655381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R-oQc7P55wwbITxH.png"/></div></div></figure><p id="e2f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">主题和连接对象在下一个代码片段中定义。连接是实际的SSE通道——与浏览器真正的握手。Topic是一个简单的管理对象，用于跟踪所有连接:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nr"><img src="../Images/05f293690f344c4261a2b631479baae9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*K8XUPfFLX5zmEHxs.png"/></div></div></figure><p id="cc61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，要从服务器向所有连接的SSE监听器发送消息，可以调用下一个函数。它接收一条消息并将其发送给所有SSE客户端。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nf"><img src="../Images/811bc67190ee33ef002a348f0f78f3ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4YDG15vC5L-dBmZX.png"/></div></div></figure><h1 id="b3ae" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">如何从浏览器发送XHR (fka AJAX)请求并使用await fetch处理响应</h1><p id="cfc2" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">我在上个世纪发送了我的第一个异步浏览器请求，那时AJAX这个术语还没有出现，XML HTTP Request对象还没有引入。我几乎相信是我发明了这个概念。网页中的一个(不可见的)框架提交了一个请求，并被重新加载了响应。顶部框架可以访问响应，并使用它来更新自身或其他框架。感觉当时的框架安全要宽松得多。无论如何，从浏览器到后台服务器的交互已经有了很大的发展。ES (ECMA脚本)最新版本中的异步语法使得AJAX风格的编程更加简洁。跨越浏览器和服务器之间的巨大鸿沟。</p><p id="07a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，函数config()利用postData()将一个带有JSON主体的POST请求发送到一个URL。async postData函数返回一个承诺，当收到对POST请求的响应时，该承诺将得到解决。响应从JSON解析为JavaScript对象结构，作为<em class="mq"> then </em>函数的输入:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ns"><img src="../Images/d709281106adf932a759b921cf85ab47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DG3ytygolpSDbq6t.png"/></div></div></figure><p id="d694" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们像下一个片段一样编写服务器请求时，需要的代码甚至更少。注意，我们需要<em class="mq">等待</em>两次。<em class="mq">获取</em>操作是异步的。它异步返回的不是响应，而是响应的承诺。所以有两层:首先等待请求的异步发送，然后等待响应的承诺，等待实际响应的到来。然后处理响应的JSON内容(将文本解析成JavaScript对象)，在这种情况下，根据数据中的数组元素编写一个列表。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/f1c4b1c974019da42ecb14f31f042f8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7qnpIG68yfGoRNui.png"/></div></figure><p id="689d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(参见例如<a class="ae ll" href="https://dev.to/shoupn/javascript-fetch-api-and-using-asyncawait-47mp" rel="noopener ugc nofollow" target="_blank">https://dev . to/shou pn/JavaScript-fetch-API-and-using-asynca wait-47mp</a>了解一些背景知识)</p><h1 id="5bf8" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">待办事项/后续步骤</h1><p id="19cd" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">即使卡夫卡主题观察者正在做它应该做的事情，它也很容易被改进。一些建议——读者可能会将其视为一种挑战来接受:</p><ul class=""><li id="acac" class="kl km iq jp b jq jr ju jv jy kn kc ko kg kp kk mp kr ks kt bi translated">允许过滤特定主题</li><li id="c108" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk mp kr ks kt bi translated">允许对各种属性进行排序</li><li id="9463" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk mp kr ks kt bi translated">通过样式、字体和小部件改善GUI的外观和感觉</li><li id="f16f" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk mp kr ks kt bi translated">允许<em class="mq">发布</em>消息以及消费它们</li><li id="446e" class="kl km iq jp b jq ku ju kv jy kw kc kx kg ky kk mp kr ks kt bi translated">允许从GUI设置目标Kafka集群(甚至同时使用多个集群)</li></ul></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="734b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mq">原载于2020年4月28日</em><a class="ae ll" href="https://technology.amis.nl/2020/04/28/diy-kafka-topic-watcher-tool-node-express-server-sent-events-and-apache-kafka/" rel="noopener ugc nofollow" target="_blank"><em class="mq">https://technology . amis . nl</em></a><em class="mq">。</em></p><h2 id="37a1" class="mx ln iq bd lo ob oc dn ls od oe dp lw jy of og ma kc oh oi me kg oj ok mi ol bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="fe84" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">我们已经推出了三种新的出版物！为我们的新出版物献上一点爱心吧，请跟随他们:<a class="ae ll" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="jp ir">AI in Plain English</strong></a>，<a class="ae ll" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="jp ir">UX in Plain English</strong></a>，<a class="ae ll" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="jp ir">Python in Plain English</strong></a><strong class="jp ir"/>——谢谢，继续学习！</p><p id="3bbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至:<a class="ae ll" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">submissions @ plain English . io</strong></a><strong class="jp ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>