<html>
<head>
<title>Proper Way To Connect MongoDb — NodeJs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">连接MongoDb — NodeJs的正确方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/proper-way-to-connect-mongodb-nodejs-db2eabf83f99?source=collection_archive---------7-----------------------#2020-10-12">https://javascript.plainenglish.io/proper-way-to-connect-mongodb-nodejs-db2eabf83f99?source=collection_archive---------7-----------------------#2020-10-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/996364cb588bbf2410a560dfc949e4de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1ZUueE5FIOalwboHHW-Waw.jpeg"/></div></div></figure><p id="4221" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">嘿伙计们！我想问你一个问题。一个应用的主要是什么？如你所想，什么都有可能。实际上，应用程序的目标定义了这一点。因此我会问你一个更具体的问题。如果一个应用程序是为了执行繁重的CRUD操作而构建的，那么它的主要功能是什么？</p><p id="6238" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，数据库是该应用程序的主要部分。我让你明白了，对吗？大多数应用程序、微服务、cronjobs等。在它们的生命周期中进行CRUD操作。我在伊斯坦布尔做全栈软件工程师，写过大量的CRUD操作。最后，我在NodeJs中找到了连接MongoDb的合适方法(当然是用Mongoose。).在我们深入研究这个问题之前，我们需要做几件事情。</p><h1 id="fbd1" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">我们需要什么？</h1><p id="590e" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">正如标题所说，我们需要</p><ul class=""><li id="6a60" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">NodeJs LTS — 10^</li><li id="e9bf" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">MongoDb</li><li id="1c4e" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">码头工人</li><li id="b022" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">Visual Studio代码(带有可爱的Lexcuim黑色主题)</li></ul><p id="547b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想这些是目前的需要。让我们用它们来完成我们的使命。</p><h1 id="b685" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">准备开始</h1><p id="7d43" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">首先，我们需要安装NodeJs。在另一个选项卡中打开此链接，下载NodeJs的LTS版本。</p><p id="27b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们需要准备MongoDb。因此我们需要在我们的机器上安装Docker，因为这是管理MongoDb的简单方法。安装完成后，打开此链接下载Docker并运行下面的代码。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="f82d" class="mt ku in mp b gy mu mv l mw mx">docker run -d  --name mongoDb  -p 27888:27017 mongo</span></pre><p id="20ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你不想安装Docker，我们可以简单地使用MongoDb Atlas。打开此链接创建一个帐户。</p><h1 id="0a3e" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">好了，我们准备好出发了！</h1><p id="bee8" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">按照以下步骤创建一个环境</p><ul class=""><li id="14fc" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">创建要工作的空文件夹</li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="9cd7" class="mt ku in mp b gy mu mv l mw mx">mkdir connect-mongo &amp;&amp; cd connect-mongo</span></pre><ul class=""><li id="2010" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">初始化一个nodeJs项目，<code class="fe my mz na mp b">-y</code>将跳过这个表单。</li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="e5b4" class="mt ku in mp b gy mu mv l mw mx">npm init -y</span></pre><ul class=""><li id="43bc" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">创建index.js</li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="74fe" class="mt ku in mp b gy mu mv l mw mx">touch index.js</span></pre><ul class=""><li id="160d" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">编辑package.json，如图所示</li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="64af" class="mt ku in mp b gy mu mv l mw mx">{<br/>  "name": "connect-mongo",<br/>  "version": "0.0.0",<br/>  "private": true,<br/>  "scripts": {<br/>    "start": "node index",<br/>  },<br/>  "dependencies": {},<br/>  "devDependencies": {}<br/>}</span></pre><ul class=""><li id="ddc2" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">安装依赖项</li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0755" class="mt ku in mp b gy mu mv l mw mx">npm install --save mongoose lodash</span></pre><ul class=""><li id="69f9" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">打开<code class="fe my mz na mp b">index.js</code>，让我们定义依赖关系和我们的功能</li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="7939" class="mt ku in mp b gy mu mv l mw mx">const mongoose = require('mongoose');<br/>const _ = require('lodash');</span><span id="e628" class="mt ku in mp b gy nb mv l mw mx">const clients = {};<br/>let connectionTimeout;</span><span id="1171" class="mt ku in mp b gy nb mv l mw mx">module.exports.init = () =&gt; {};</span><span id="87cd" class="mt ku in mp b gy nb mv l mw mx">module.exports.closeConnections = () =&gt; {};</span><span id="3542" class="mt ku in mp b gy nb mv l mw mx">module.exports.getClients = () =&gt; {};</span></pre><ul class=""><li id="d422" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">好了，我们定义了函数，让我们填充它们。首先，我们需要创建一个连接实例。我们这样做是因为将来我们可能需要第二次或第三次连接到另一个mongoDb数据库。不要问为什么，你最终会遇到这个问题。</li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="fc32" class="mt ku in mp b gy mu mv l mw mx">module.exports.init = () =&gt; {<br/>		const mongoInstance = mongoose.createConnection('mongodb://...', {<br/>        useNewUrlParser: true,<br/>        keepAlive: true,<br/>        autoReconnect: true,<br/>        reconnectTries: 3,<br/>        reconnectInterval: 5000,<br/>    });</span><span id="c4d7" class="mt ku in mp b gy nb mv l mw mx">    clients.mongoInstance = mongoInstance;<br/>};</span></pre><ul class=""><li id="8fd1" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">我们用Mongoose创建了我们的mongoDb连接，我将解释为什么我们传递这些选项。我们还将该连接保存在一个对象中，以便以后导入和使用。</li><li id="ddb8" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated"><code class="fe my mz na mp b">keepAlive: true</code>，如果你的应用会运行很长时间。如果您使用mongoose^5.2.0，默认情况下是这样的</li><li id="b069" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated"><code class="fe my mz na mp b">autoReconnect: true</code>，如果连接中断，mongoose会尝试连接而不是抛出错误。我们将手动处理这一功能。</li><li id="f0f2" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated"><code class="fe my mz na mp b">reconnectTries: number</code>，定义了猫鼬应该尝试连接多少次，</li><li id="f63a" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated"><code class="fe my mz na mp b">reconnectInterval: number</code>(毫秒)，定义猫鼬需要多少毫秒建立连接。</li></ul><p id="684d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一些事件将根据连接的状态被触发。最好是听他们采取行动。因为这个模块将管理整个连接流。我们需要知道任何中断或连接丢失。让我们看看这些事件是什么。</p><ul class=""><li id="269f" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated"><code class="fe my mz na mp b">connected</code>，连接成功后触发</li><li id="17e7" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated"><code class="fe my mz na mp b">disconnected</code>，连接断开时触发</li><li id="b9f7" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated"><code class="fe my mz na mp b">reconnected</code>，重新连接成功后被解雇</li><li id="c8c1" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated"><code class="fe my mz na mp b">close</code>，由你关闭连接后触发</li></ul><p id="d35c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们添加一个事件监听器，我改变了下面的<code class="fe my mz na mp b">init()</code>函数并添加了处理程序。在开发NodeJs应用程序时，我更喜欢RO-RO(接收对象-返回对象)方法。因为它提高了代码的可读性。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="ed30" class="mt ku in mp b gy mu mv l mw mx">function instanceEventListeners({ conn }) {<br/>    conn.on('connected', () =&gt; {<br/>        console.log('Database - Connection status: connected');<br/>    });</span><span id="03f3" class="mt ku in mp b gy nb mv l mw mx">    conn.on('disconnected', () =&gt; {<br/>        console.log('Database - Connection status: disconnected');<br/>    });</span><span id="4399" class="mt ku in mp b gy nb mv l mw mx">    conn.on('reconnected', () =&gt; {<br/>        console.log('Database - Connection status: reconnected');<br/>    });</span><span id="cbea" class="mt ku in mp b gy nb mv l mw mx">    conn.on('close', () =&gt; {<br/>        console.log('Database - Connection status: close ');<br/>    });<br/>}</span><span id="e1b9" class="mt ku in mp b gy nb mv l mw mx">module.exports.init = () =&gt; {<br/>    const mongoInstance = mongoose.createConnection(config.DATABASE.HOST, {<br/>        useNewUrlParser: true,<br/>        keepAlive: true,<br/>        autoReconnect: true,<br/>        reconnectTries: 3,<br/>        reconnectInterval: 5000,<br/>    });</span><span id="e454" class="mt ku in mp b gy nb mv l mw mx">    clients.mongoInstance = mongoInstance;<br/>    instanceEventListeners({ conn: mongoInstance });<br/>};</span></pre><p id="a542" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在怎么办？正如我上面所说，我们将自己处理重新连接程序。按照下面的代码，我只是简单地添加了一个超时功能。就我而言，我可以忍受很少的连接中断。我的意思是，只要它在一定的时间内重新连接，失去连接是可以的吗？</p><p id="abcb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们添加超时函数来看看它是如何工作的，</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="950e" class="mt ku in mp b gy mu mv l mw mx">function throwTimeoutError() {<br/>    connectionTimeout = setTimeout(() =&gt; {<br/>        throw new DatabaseError();<br/>    }, 16000); // (reconnectTries * reconnectInterval) + buffer<br/>}</span><span id="d2b5" class="mt ku in mp b gy nb mv l mw mx">function instanceEventListeners({ conn }) {<br/>    conn.on('connected', () =&gt; {<br/>        console.log('Database - Connection status: connected');<br/>				clearTimeout(connectionTimeout);<br/>    });</span><span id="cba7" class="mt ku in mp b gy nb mv l mw mx">    conn.on('disconnected', () =&gt; {<br/>        console.log('Database - Connection status: disconnected');<br/>				throwTimeoutError();<br/>    });</span><span id="f516" class="mt ku in mp b gy nb mv l mw mx">    conn.on('reconnected', () =&gt; {<br/>        console.log('Database - Connection status: reconnected');<br/>				clearTimeout(connectionTimeout);<br/>    });</span><span id="b998" class="mt ku in mp b gy nb mv l mw mx">    conn.on('close', () =&gt; {<br/>        console.log('Database - Connection status: close ');<br/>				clearTimeout(connectionTimeout);<br/>    });<br/>}</span><span id="7508" class="mt ku in mp b gy nb mv l mw mx">module.exports.init = () =&gt; {<br/>    const mongoInstance = mongoose.createConnection(config.DATABASE.HOST, {<br/>        useNewUrlParser: true,<br/>        keepAlive: true,<br/>        autoReconnect: true,<br/>        reconnectTries: 3,<br/>        reconnectInterval: 5000,<br/>    });</span><span id="0081" class="mt ku in mp b gy nb mv l mw mx">    clients.mongoInstance = mongoInstance;<br/>    instanceEventListeners({ conn: mongoInstance });<br/>};</span></pre><p id="55d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">啊哈，我们成功了！我们现在有什么？我们来分解一下，</p><ul class=""><li id="4d8d" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated">我们将connectionTimeout定义为null，因为我们希望在断开连接的特定事件触发时开始超时，</li><li id="c317" class="lw lx in jx b jy mf kc mg kg mh kk mi ko mj ks mb mc md me bi translated">当我们得到一个<code class="fe my mz na mp b">disconnected</code>事件时，超时将开始，然后重新连接过程将根据我们定义的值尝试重新连接。这里的数学很简单，将重新连接间隔乘以重新连接尝试，然后用小缓冲区求和，找到完美的超时值。当猫鼬尝试连接时，会记录时间。如果连接再次建立，我们需要清除超时，因为我们不想在此之后抛出错误。顺便说一下，当connectionTimeout设置为null或undefined时，<code class="fe my mz na mp b">clearTimeout</code>不会产生任何影响。</li></ul><p id="1687" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们留了一些好吃的，让我们把它们装满。我想管理关闭连接的流程，如何管理打开的流程。因为如果您在Kubernetes中运行应用程序，优雅地关闭应用程序总是最佳实践。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="de86" class="mt ku in mp b gy mu mv l mw mx">module.exports.closeConnections = () =&gt; _.forOwn(clients, (conn) =&gt; conn.close());</span></pre><ul class=""><li id="3b3c" class="lw lx in jx b jy jz kc kd kg ly kk lz ko ma ks mb mc md me bi translated"><code class="fe my mz na mp b">forOwn()</code>将循环对象键，而每一个连接我们只是简单地称之为<code class="fe my mz na mp b">close()</code></li></ul><p id="ec22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">利用关系怎么样？让我们添加它，我们就完成了！</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="b108" class="mt ku in mp b gy mu mv l mw mx">module.exports.getClients = () =&gt; clients;</span></pre><p id="2e71" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用功能块，您可以导入和使用您创建的连接。</p><h1 id="6247" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">最后</h1><p id="aa2c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">我们到达了终点，为自己创建了一个漂亮的Mongoose连接处理程序。这是我们找到的最适合我们微服务的方式。处理连接状态并了解发生了什么将会提高您的服务质量。</p><p id="0866" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TL；DR；<a class="ae nc" href="https://github.com/ErenYatkin/microservice-base/blob/master/loaders/database.js" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="0e58" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于<a class="ae nc" href="https://github.com/ErenYatkin/microservice-base/blob/master/loaders/database.js" rel="noopener ugc nofollow" target="_blank">全码结账这个链接</a>，</p><p id="a094" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于<a class="ae nc" href="https://medium.com/faun/the-best-docker-introduction-8b518b6f0b05" rel="noopener">介绍码头工人结账这个环节</a>，</p><p id="13c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于<a class="ae nc" href="https://www.freecodecamp.org/news/elegant-patterns-in-modern-javascript-roro-be01e7669cbd/" rel="noopener ugc nofollow" target="_blank">滚装进场检验环节</a>，</p><p id="eb3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下次见，保持冷静！</p><p id="37d8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae nc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="jx io">！</strong></p></div></div>    
</body>
</html>