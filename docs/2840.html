<html>
<head>
<title>Top Six GraphQL Clients for 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2020年前六大GraphQL客户端</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/top-six-graphql-clients-for-2020-666a7bc00e73?source=collection_archive---------7-----------------------#2020-07-28">https://javascript.plainenglish.io/top-six-graphql-clients-for-2020-666a7bc00e73?source=collection_archive---------7-----------------------#2020-07-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/7fd443edac05657d8b2ca7c5b9205c26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5ri8W3LSfnLHSFVd-ghUbw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="http://unsplash.com/@ilayapavlov" rel="noopener ugc nofollow" target="_blank">Ilaya Pavlov</a> on <a class="ae jz" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d4a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一篇关于2020年绝对新手顶级GraphQL客户端的全新文章。在转到内容之前，建议接受GraphQL方面的培训，并至少对服务器端和客户端有一个基本的了解。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="5445" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">什么是GraphQL？</strong></h1><p id="6519" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">GraphQL是一种令人困惑的技术和架构风格。GraphQL是一种强大的查询语言，由Facebook.inc开发，用于在客户端(浏览器)和服务器之间进行通信。它允许我们以比RESTful方法更灵活、更直观的语法和更高效的方式构建数据驱动的应用程序。GraphQL只处理一个端点，post请求总是到达这个端点。GraphQL可以在任何服务器端语言框架中实现，也可以在任何前端语言框架中实现。</p><h2 id="428e" class="mi lg in bd lh mj mk dn ll ml mm dp lp kl mn mo lt kp mp mq lx kt mr ms mb mt bi translated"><strong class="ak">graph QL的优点</strong></h2><p id="0e90" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">GraphQL允许查询数据并得到他们想要的东西。</p><p id="0e2f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用GraphQL，可以在单个工作表中查询多个相关资源。换句话说，可以跨关系进行查询。</p><p id="02dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它为查询相关的对象提供了灵活性，并得到与查询本身完全相同的响应。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="a178" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak"> 1。阿波罗客户端</strong></h1><p id="c101" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">阿波罗客户端是一个完整的数据管理解决方案，适用于任何客户端。由于Apollo客户端是一个全功能的缓存GraphQL，它允许从GraphQL服务器获取数据。这是一个社区驱动的努力，以建立一个易于理解，灵活和强大的GraphQL客户端。它还是一个全面的状态管理库，能够使用GraphQL管理本地和远程数据。</p><p id="a86b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Apollo客户机包括React钩子和GraphQL请求处理。</p><p id="ff1d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Apollo客户端的缓存更加灵活，性能更高。</p><p id="0ab2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最新版本的Apollo支持垃圾收集，存储规范化和非规范化数据。此外，它还可以使用TypePolicy和FieldPolicy APIs定制缓存数据。</p><h2 id="0eda" class="mi lg in bd lh mj mk dn ll ml mm dp lp kl mn mo lt kp mp mq lx kt mr ms mb mt bi translated"><strong class="ak">React应用程序中的阿波罗客户端</strong></h2><p id="583b" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">让我们安装最新版本的阿波罗客户端和所需的软件包，</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="50c2" class="mi lg in mz b gy nd ne l nf ng">npm install @apollo/client graphql</span></pre><p id="6a46" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建名为apolloClient.js的组件</p><p id="5a90" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在apolloClient.js组件中创建一个客户端。</p><p id="979a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在已经安装了所有的依赖项，让我们初始化一个ApolloClient实例。</p><p id="17c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">导入ApolloClient和InMemoryCache。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="1bd7" class="mi lg in mz b gy nd ne l nf ng">import { ApolloClient, InMemoryCache, gql } from “@apollo/client”;</span></pre><p id="7c50" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们将导出函数定义如下:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="9c38" class="mi lg in mz b gy nd ne l nf ng">export const ApolloClientExapmle = () =&gt; {}</span></pre><p id="d1a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，在函数中添加以下代码片段。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="d7d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可以注意到，uri是一个正在运行的GraphQL服务器的URL。即CodeSandbox。</p><p id="d8b8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，客户端已经准备好获取数据。</p><p id="f5ba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们定义一个查询字符串如下，建议导入gql函数解析查询字符串(已经导入)。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="488b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">连接客户端以做出反应</p><p id="57d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">打开ApolloClient.js组件并导入ApolloProvider，如下所示，</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="6d23" class="mi lg in mz b gy nd ne l nf ng">import { ApolloProvider } from “@apollo/client”;</span></pre><p id="2262" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将代码片段添加到return语句中，如下所示:</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="fd3a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们运行代码，</p><p id="c7ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这可以从一份声明中观察到。</p><p id="6139" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">打开控制台并检查结果对象。显然，我们可以观察到一个数据属性，其速率与负载和网络状态相关联。</p><p id="9e82" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/04d366bef2e04a30a70c7899c6448441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r-wLrGA-cJldgxAP"/></div></div></figure><h1 id="6b7f" class="lf lg in bd lh li nk lk ll lm nl lo lp lq nm ls lt lu nn lw lx ly no ma mb mc bi translated"><strong class="ak"> 2 </strong>。<strong class="ak">graph QL-请求</strong></h1><p id="4183" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">它被称为同构，因为它既适用于节点又适用于浏览器。它是一个最小的GraphQL客户端，支持脚本和简单应用程序的节点和浏览器。它包括几个特征。这是一个轻量级的简单的GraphQL客户端。它还可以与async和await一起工作。值得注意的是，它支持Typescript。</p><h2 id="c3c4" class="mi lg in bd lh mj mk dn ll ml mm dp lp kl mn mo lt kp mp mq lx kt mr ms mb mt bi translated"><strong class="ak">graph QL-React应用程序中的请求</strong></h2><p id="5ee8" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">让我们创建一个简单的GraphQL查询。</p><p id="4d9b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们使用节点包管理器(npm)安装最新版本的graphql-request</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="0bb3" class="mi lg in mz b gy nd ne l nf ng">npm install graphql-request</span></pre><p id="644a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">创建一个名为graphqlRequest.js的组件</p><p id="50c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">按如下方式导入graphql-request:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="3227" class="mi lg in mz b gy nd ne l nf ng">import request from “graphql-request”;</span></pre><p id="0739" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们将导出函数定义如下:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="e8f6" class="mi lg in mz b gy nd ne l nf ng">export const GraphqlRequest = () =&gt; {}</span></pre><p id="87bc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在函数中添加以下内容</p><p id="d1ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们创建一个查询</p><p id="4d60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它是从电影中检索数据。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="266f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们请求控制台日志中的相应数据，如下所示:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="2874" class="mi lg in mz b gy nd ne l nf ng">request(“https://api.graph.cool/simple/v1/movies", query).then((data) =&gt;</span><span id="9074" class="mi lg in mz b gy np ne l nf ng">console.log(data)</span><span id="760b" class="mi lg in mz b gy np ne l nf ng">);</span></pre><p id="a821" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">添加以下return语句</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="a4b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，调用graphqlRequest.js组件和App.js组件中的相关函数，如下所示:</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e33e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/8addbf7ac026ea324d2511be3663a0cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mvuo4CZtG6xau6dH"/></div></div></figure><h1 id="b8bf" class="lf lg in bd lh li nk lk ll lm nl lo lp lq nm ls lt lu nn lw lx ly no ma mb mc bi translated"><strong class="ak"> 3。GraphQL-CLI </strong></h1><p id="d27f" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">它是一个用于通用GraphQL开发工作流的命令行工具。它具有重新格式化(缩进，修饰)查询语言和重新格式化模式定义语言的特性。因为它有一个强大的插件系统，它可以用自定义命令扩展graphql-cli。GraphQL的主要目的是为社区提供一个默认的入口点，使用成熟的技术来构建和部署支持GraphQL的应用程序，同时与供应商无关。</p><p id="e39a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在GraphQL CLI的最新版本中，可以观察到几个特性。</p><p id="a044" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它有重要和有用的命令，以改善日常工作流程，从开始到长期维护。</p><p id="b993" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它拥有丰富的生态系统，并且兼容库、编辑器和ide。</p><p id="e725" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用命令行界面(CMD)使用npm安装CLI</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="cdcd" class="mi lg in mz b gy nd ne l nf ng">npm install graphql-cli@canary</span></pre><p id="3892" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们通过在CMD中执行以下命令，使用GraphQL CLI创建一个新项目:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="c6ca" class="mi lg in mz b gy nd ne l nf ng">graphql init</span></pre><p id="a89a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GraphQL CLI将通过询问几个问题进行如下指导:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="762a" class="mi lg in mz b gy nd ne l nf ng">? What is the type of the project? Full Stack</span><span id="6e0e" class="mi lg in mz b gy np ne l nf ng">? Select the best option for you I want to create a new project from a GraphQL CLI Project Template.</span><span id="8fd3" class="mi lg in mz b gy np ne l nf ng">? What is the name of the project? GraphQL-Project</span><span id="859c" class="mi lg in mz b gy np ne l nf ng">√ Loading template list...</span><span id="ef2d" class="mi lg in mz b gy np ne l nf ng">? Which template do you want to start with your new Full Stack project? Full Stack Template with React Hooks, Apollo, NodeJS and PostgreSQL</span><span id="f96b" class="mi lg in mz b gy np ne l nf ng">? Do you want to have GraphQL Inspector tools for your frontend? Yes</span><span id="cc1f" class="mi lg in mz b gy np ne l nf ng">? Do you want to have GraphQL Inspector tools for your backend? Yes</span><span id="3cd0" class="mi lg in mz b gy np ne l nf ng">🚀 GraphQL CLI project successfully initialized:</span><span id="56d5" class="mi lg in mz b gy np ne l nf ng">Full Stack</span><span id="535a" class="mi lg in mz b gy np ne l nf ng">Next Steps:</span><span id="3747" class="mi lg in mz b gy np ne l nf ng">- Change directory to the project folder - cd Full Stack</span><span id="3dd7" class="mi lg in mz b gy np ne l nf ng">- Run yarn install to install dependencies</span><span id="69ad" class="mi lg in mz b gy np ne l nf ng">- (Optional) Initialize your git repo. git init.</span></pre><p id="94cd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将目录更改为项目文件夹，即cd全栈</p><p id="1159" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">安装依赖项</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="d959" class="mi lg in mz b gy nd ne l nf ng">yarn install</span></pre><p id="4bf4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将目录切换到项目文件夹，即GraphQL-Project，并执行以下命令</p><p id="6049" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">启动数据库</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="2332" class="mi lg in mz b gy nd ne l nf ng">docker-compose up -d</span></pre><p id="62d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">生成资源(模式和解析器)并创建数据库</p><p id="67af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">纱线图生成—后端</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="ee60" class="mi lg in mz b gy nd ne l nf ng">yarn graphql generate –backend</span><span id="dcd1" class="mi lg in mz b gy np ne l nf ng">yarn graphql generate — db</span></pre><p id="cfc4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为数据库模式和解析程序生成类型</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="9cf5" class="mi lg in mz b gy nd ne l nf ng">yarn schemats generate</span><span id="7832" class="mi lg in mz b gy np ne l nf ng">yarn graphql codegen</span></pre><p id="34dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">启动服务器</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="33ea" class="mi lg in mz b gy nd ne l nf ng">yarn start: server</span></pre><p id="588b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为客户端项目生成查询、变更和订阅</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="b92b" class="mi lg in mz b gy nd ne l nf ng">yarn graphql generate — client</span></pre><p id="172c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">生成反应组分</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="c5aa" class="mi lg in mz b gy nd ne l nf ng">yarn graphql codegen</span></pre><p id="a568" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">启动React应用程序</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="0dc9" class="mi lg in mz b gy nd ne l nf ng">yarn start:client</span></pre><p id="4a8a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/dd8d5da9465971f908dfbf4d1bccb045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rMTvJEofv97hvyAu"/></div></div></figure><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nq"><img src="../Images/c78bd160e8597697d2da87bb713b5e9f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CLTojbZjuQuUkQIM"/></div></div></figure><h1 id="63cf" class="lf lg in bd lh li nk lk ll lm nl lo lp lq nm ls lt lu nn lw lx ly no ma mb mc bi translated"><strong class="ak"> 4。GraphQL-Compose </strong></h1><p id="5ad4" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">对于在Node.js上生成复杂的GraphQL模式，这是一个非常好的工具包。</p><p id="e319" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它包括编辑GraphQL输出/输入类型(添加/删除/字段/参数/接口)的方法。引入了graphql fieldConfigs，即Resolver，可用于搜索、更新和删除记录。</p><p id="f78d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它提供了一个从OutputType到InputType的转换器和一个从AST的投影解析器。graph QL-composite提供了一个类型注册表，其中包含一系列用于编程模式构建的方法。</p><p id="2b88" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它具有GraphQL模式语言的一个特征，用于定义简单类型。</p><p id="9da8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">顶置式发电机。</strong></p><ul class=""><li id="f10d" class="nr ns in kc b kd ke kh ki kl nt kp nu kt nv kx nw nx ny nz bi translated">graph QL-composite-JSON</li><li id="2b84" class="nr ns in kc b kd oa kh ob kl oc kp od kt oe kx nw nx ny nz bi translated">GraphQL-const-mongose</li><li id="aef8" class="nr ns in kc b kd oa kh ob kl oc kp od kt oe kx nw nx ny nz bi translated">graph QL-composite-elastics search</li><li id="484e" class="nr ns in kc b kd oa kh ob kl oc kp od kt oe kx nw nx ny nz bi translated">graph QL-composite-AWS</li></ul><p id="8833" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">实用插件</strong></p><ul class=""><li id="dcfd" class="nr ns in kc b kd ke kh ki kl nt kp nu kt nv kx nw nx ny nz bi translated">graph QL-合成-继电器</li><li id="912a" class="nr ns in kc b kd oa kh ob kl oc kp od kt oe kx nw nx ny nz bi translated">graph QL-撰写-连接</li><li id="895a" class="nr ns in kc b kd oa kh ob kl oc kp od kt oe kx nw nx ny nz bi translated">graph QL-composite-DataLoader</li></ul><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="a25e" class="mi lg in mz b gy nd ne l nf ng">npm install graphql-compose</span></pre><p id="6761" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们导入所需的模块:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="766c" class="mi lg in mz b gy nd ne l nf ng">import { schemaComposer } from “graphql-compose”;</span></pre><p id="251b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们如下创建一些模拟数据。作者和文章的两个数组:</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="cb53" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">构建GraphQL模式从复杂的类型声明开始。它们的名称必须唯一。让我们创建如下两种不同的类型:</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="e88d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们在上述两种类型之间建立关系。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="1796" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们构建一个模式</p><p id="10df" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们刚刚建立了两种类型，这些类型是链接的，能够获取数据。现在，建议使用刚刚从上面的模块导入的schemaComposer初始化模式。</p><p id="e632" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，它请求将哪些读取数据放入查询。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8155" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">修改数据的请求被放入突变</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="942a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在根类型定义之后，我们准备构建一个必须传递给express-graphql的模式。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="821c" class="mi lg in mz b gy nd ne l nf ng">export const schema = schemaComposer.buildSchema();</span></pre><p id="4e12" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们创建一个HTTP服务器</p><p id="57ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经成功构建了模式；它需要实现一个服务器。如上所述，让我们导入express-graphql和所需的依赖项。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="a3f3" class="mi lg in mz b gy nd ne l nf ng">import express from ‘express’;</span><span id="84b2" class="mi lg in mz b gy np ne l nf ng">import graphqlHTTP from ‘express-graphql’;</span></pre><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="8cbb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最终，我们成功地开发了graph QL-composite。</p><h1 id="be48" class="lf lg in bd lh li nk lk ll lm nl lo lp lq nm ls lt lu nn lw lx ly no ma mb mc bi translated"><strong class="ak"> 5 .@octokit/GraphQL </strong></h1><p id="eeea" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">它是一个用于浏览器和节点的GitHub GraphQL API客户端。它提供了几个优点，</p><p id="aa2a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">发送简单的查询</p><p id="76f8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简单的身份验证方式</p><p id="c426" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它可以与GitHub企业版一起使用</p><p id="d91c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">利用自定义@octokit/request实例</p><p id="8138" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Octokit。GraphQL提供了对. Net中的GitHub GraphQL API的访问。它还将GitHub GraphQL API公开为一种强类型语言集成查询，类似于旨在尽可能遵循GraphQL查询语法的API，这提供了强类型化的好处。Net语言。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="58ce" class="mi lg in mz b gy nd ne l nf ng">npm install @octokit/graphql</span></pre><p id="70f2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从octokit库中导入graphql，如下所示:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="0a0b" class="mi lg in mz b gy nd ne l nf ng">import { graphql } from “@octokit/graphql”;</span></pre><p id="6f16" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们发送一个简单的查询如下:</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="bfb4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里建议对请求进行身份验证。因此，最简单的身份验证方法是设置授权头。</p><p id="d2a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上所述，需要生成PAT(个人访问令牌)并使用授权头中的密钥。</p><p id="ce73" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">可通过<a class="ae jz" href="https://github.com/settings/tokens" rel="noopener ugc nofollow" target="_blank">生成PAT，此处为</a></p><h1 id="35aa" class="lf lg in bd lh li nk lk ll lm nl lo lp lq nm ls lt lu nn lw lx ly no ma mb mc bi translated"><strong class="ak"> 6。继电器</strong></h1><p id="51ad" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">这是一个由GraphQL支持的JavaScript框架，用于构建数据驱动的React应用程序。继电器耦合React和GraphQL。使用Relay的最大好处是，relay-compiler不包含在前端包中，使用户不必下载整个GraphQL解析器——它在构建时“预编译”GraphQL查询。</p><p id="ec4c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不幸的是，每当任何GraphQL查询或模式中有修改时，都需要运行中继编译器。</p><p id="da36" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了在客户端运行中继，必须遵循以下规范。</p><p id="a3f1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">建议在<strong class="kc io">中插入一个继电器插件。babelrc </strong>配置</p><p id="f0b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将中继编译器设置为yarn脚本</p><p id="d93f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">设置中继环境，即本质上获取实用程序以将数据传递到中继环境</p><p id="a490" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">QueryRenderer的实现</p><p id="283a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们使用npm安装反应继电器</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="58fb" class="mi lg in mz b gy nd ne l nf ng">npm install react-relay</span></pre><p id="c743" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们创建一个名为ReactRelay.js的组件</p><p id="2b37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">中继环境</p><p id="dd00" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们设置中继环境。这是因为该环境将中继运行所需的配置、高速缓存和网络处理捆绑在一起。</p><p id="dd7d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们安装所需的模块来配置环境。</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="8159" class="mi lg in mz b gy nd ne l nf ng">npm install relay-runtime</span></pre><p id="d4b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们按如下方式导入继电器时间模块:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="f4e9" class="mi lg in mz b gy nd ne l nf ng">import { Environment, Network, RecordSource, Store } from “relay-runtime”;</span></pre><p id="0eb7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们获取查询。</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="9407" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们将查询呈现如下:</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="2085" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">环境的配置</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="83a3" class="mi lg in mz b gy nd ne l nf ng">const environment = new Environment({</span><span id="00e1" class="mi lg in mz b gy np ne l nf ng">network: Network.create(fetchQuery),</span><span id="9b28" class="mi lg in mz b gy np ne l nf ng">store: new Store(new RecordSource()),</span><span id="0ab0" class="mi lg in mz b gy np ne l nf ng">});</span></pre><p id="49d5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们创建一个ReactRelay导出函数，如下所示:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="5f8c" class="mi lg in mz b gy nd ne l nf ng">export const Example = () =&gt; {}</span></pre><p id="208e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将以下代码片段添加到上述函数的return语句中</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="933e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">打开App.js文件并导入ReactRelay，如下所示:</p><pre class="mu mv mw mx gt my mz na nb aw nc bi"><span id="005f" class="mi lg in mz b gy nd ne l nf ng">import { ReactRelay} from “./graphql/ReactRelay”;</span></pre><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="ce33" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">结论</strong></p><p id="6d4f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GraphQL基本上是一种查询语言。GraphQL查询是发送给运行时的字符串，它将JSON返回给客户机。随着GraphQL越来越多地被采用，一个丰富活跃的生态系统开始围绕它成长。它不依赖于任何数据库或存储，由代码和数据提供支持。GraphQl不处理专用资源。相反，一切都被视为一个图形，暗示它是连接的。GraphQL库使前端的快速产品迭代成为可能，因为它允许开发人员在客户端进行更改，而无需对服务器进行任何改动。</p><p id="96da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GraphQL允许查询数据并得到他们想要的东西。</p><p id="6daa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用GraphQL，可以在单个工作表中查询多个相关资源。换句话说，可以跨关系进行查询。</p><p id="25e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它为查询相关的对象提供了灵活性，并得到与查询本身完全相同的响应。</p></div></div>    
</body>
</html>