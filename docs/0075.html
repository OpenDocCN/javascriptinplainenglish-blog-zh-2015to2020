<html>
<head>
<title>TypeScript Rest API with Express.js, JWT, Authorization Roles and TypeORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带有Express.js、JWT、授权角色和TypeORM的TypeScript Rest API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-a-rest-api-with-jwt-authentication-and-role-based-authorization-using-typescript-fbfa3cab22a4?source=collection_archive---------0-----------------------#2019-02-07">https://javascript.plainenglish.io/creating-a-rest-api-with-jwt-authentication-and-role-based-authorization-using-typescript-fbfa3cab22a4?source=collection_archive---------0-----------------------#2019-02-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/bbad78821d40d49c9c8e55eb204f48d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMGk1weePZlzdIWmHi16Bg.png"/></div></div></figure><p id="d212" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">今天，我们将使用TypeScript Express.js和TypeORM来创建一个企业级Rest API，它具有JWT身份验证和基于角色的授权。目标是创建一个存储库，您可以使用它作为您现实生活项目的基础。</p><p id="da8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们开始之前，建议您熟悉以下主题。你不需要成为专家，但是，如果你从未听说过这些，我选择了一个入门读物:</p><p id="d4ea" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">什么是Rest API和基础http响应代码</strong></p><div class="kt ku gp gr kv kw"><a href="https://medium.com/@parastripathi/what-is-rest-api-a-beginners-guide-700e4931e67c" rel="noopener follow" target="_blank"><div class="kx ab fo"><div class="ky ab kz cl cj la"><h2 class="bd io gy z fp lb fr fs lc fu fw im bi translated">什么是REST API:初学者指南</h2><div class="ld l"><h3 class="bd b gy z fp lb fr fs lc fu fw dk translated">由于这是一个初学者指南，我不会使用各种技术术语，而是一个简单的例子和…</h3></div><div class="le l"><p class="bd b dl z fp lb fr fs lc fu fw dk translated">medium.com</p></div></div><div class="lf l"><div class="lg l lh li lj lf lk jt kw"/></div></div></a></div><p id="d644" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">什么是JWT，为什么我们用它来进行无状态认证</strong></p><div class="kt ku gp gr kv kw"><a href="https://medium.com/vandium-software/5-easy-steps-to-understanding-json-web-tokens-jwt-1164c0adfcec" rel="noopener follow" target="_blank"><div class="kx ab fo"><div class="ky ab kz cl cj la"><h2 class="bd io gy z fp lb fr fs lc fu fw im bi translated">理解JSON Web令牌的5个简单步骤(JWT)</h2><div class="ld l"><h3 class="bd b gy z fp lb fr fs lc fu fw dk translated">在本文中，将解释什么是JSON Web令牌(JWT)的基本原理，以及为什么使用它们。JWT是…</h3></div><div class="le l"><p class="bd b dl z fp lb fr fs lc fu fw dk translated">medium.com</p></div></div><div class="lf l"><div class="ll l lh li lj lf lk jt kw"/></div></div></a></div><p id="135b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">什么是ORM(对象关系映射器)</strong></p><div class="kt ku gp gr kv kw"><a href="https://blog.bitsrc.io/what-is-an-orm-and-why-you-should-use-it-b2b6f75f5e2a" rel="noopener  ugc nofollow" target="_blank"><div class="kx ab fo"><div class="ky ab kz cl cj la"><h2 class="bd io gy z fp lb fr fs lc fu fw im bi translated">什么是ORM，为什么要使用它</h2><div class="ld l"><h3 class="bd b gy z fp lb fr fs lc fu fw dk translated">对象关系映射器简介</h3></div><div class="le l"><p class="bd b dl z fp lb fr fs lc fu fw dk translated">blog.bitsrc.io</p></div></div><div class="lf l"><div class="lm l lh li lj lf lk jt kw"/></div></div></a></div><h1 id="efee" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">为什么是TypeORM？</h1><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/2a4fc7e34ded3b9bf27d156c6cd82e06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*10ldIs5O8Y1kXzDn.png"/></div></div></figure><p id="edfc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TypeORM允许您只编写一个TypeScript类，使用synchronize工具，它会自动为您的实体生成所有SQL结构。有了类验证器包，我们可以使用相同的模型类来进行验证。</p><p id="e3d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">兼容MySQL / MariaDB / Postgres / SQLite /微软SQL Server/Oracle/SQL . js/MongoDB。您可以在这些数据库之间切换，而不必重写代码。</p><p id="0df8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将从SQLite开始这个项目。我不建议留着生产。但是，因为我不知道您将使用什么DB，所以它允许我们创建一个通用项目，您只需“npm install”即可运行，而无需设置数据库服务器。</p><h1 id="2693" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">我们开始吧</h1><p id="c5b9" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">TypeORM有一个CLI工具，允许我们在TypeScript中生成一个基本应用程序。要使用这个工具，我们首先需要安装typeORM作为一个全局依赖项:</p><pre class="mm mn mo mp gt mv mw mx my aw mz bi"><span id="96f0" class="na lo in mw b gy nb nc l nd ne">npm install -g typeorm</span></pre><p id="b8dc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以设置我们的应用程序了:</p><pre class="mm mn mo mp gt mv mw mx my aw mz bi"><span id="3265" class="na lo in mw b gy nb nc l nd ne">typeorm init --name jwt-express-typeorm --database sqlite --express</span></pre><p id="15ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它将使用TypeORM和body-parser在TypeScript中创建一个示例express应用程序。让我们安装这些依赖项:</p><pre class="mm mn mo mp gt mv mw mx my aw mz bi"><span id="f663" class="na lo in mw b gy nb nc l nd ne">npm install</span></pre><p id="baeb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们将安装一些附加的依赖项</p><pre class="mm mn mo mp gt mv mw mx my aw mz bi"><span id="9b25" class="na lo in mw b gy nb nc l nd ne">npm install -s helmet cors jsonwebtoken bcryptjs class-validator ts-node-dev</span></pre><p id="59cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我们将拥有以下依赖关系</p><p id="44d2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过设置各种HTTP头，帮助我们保护我们的应用程序</p><p id="9258" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> cors <br/> </strong>启用跨来源请求</p><p id="9647" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> body-parser <br/> </strong>将客户端的请求从json解析成javascript对象</p><p id="4c52" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">jsonwebtoken将为我们处理jwt操作</p><p id="ff17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">bcryptjs<br/>T20】帮助我们散列用户密码</strong></p><p id="ad7f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> typeorm <br/> </strong>我们将要使用的orm来操作数据库</p><p id="a19c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> reflect-metadata <br/> </strong>允许一些标注特性与TypeORM一起使用</p><p id="5e17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">class-validator  <br/>一个非常适合TypeORM的验证包</p><p id="e584" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用sqlite作为开发数据库</p><p id="54f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我们更改任何文件时，ts-node-dev会自动重启服务器</p><h2 id="7669" class="na lo in bd lp nf ng dn lt nh ni dp lx kg nj nk mb kk nl nm mf ko nn no mj np bi translated">安装类型检查依赖项</h2><p id="9fef" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">因为我们正在使用TypeScript，所以为我们的依赖项安装@types是一个好主意。</p><pre class="mm mn mo mp gt mv mw mx my aw mz bi"><span id="9aef" class="na lo in mw b gy nb nc l nd ne">npm install -s @types/bcryptjs @types/body-parser @types/cors @types/helmet @types/jsonwebtoken</span></pre><p id="3045" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，你将能够使用自动完成和类型检查，甚至是JavaScript包。</p><h1 id="c2c6" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">src文件夹</h1><p id="f10f" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">TypeORM CLI创建了一个包含所有typescript文件的<code class="fe nq nr ns mw b">src</code>文件夹。现在我们将修改这些文件来创建我们的API。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/a04829faf201b00836acb2558146fe17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*ctZ7uPNEt8Xmknjb2OH8eA.png"/></div></figure><h2 id="fa0d" class="na lo in bd lp nf ng dn lt nh ni dp lx kg nj nk mb kk nl nm mf ko nn no mj np bi translated">索引</h2><p id="eb07" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">CLI已经创建了一个<code class="fe nq nr ns mw b">index.ts</code>文件作为应用程序的入口点。让我们重写以更好地适应我们的目的。</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="563e" class="na lo in bd lp nf ng dn lt nh ni dp lx kg nj nk mb kk nl nm mf ko nn no mj np bi translated">路线</h2><p id="d0e8" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">CLI还创建了一个<code class="fe nq nr ns mw b">routes.ts</code>文件。在大型项目中，将所有路线放在同一个文件中可能不是一个好主意。我们将创建一个<code class="fe nq nr ns mw b">routes/</code>文件夹，其中有一个<code class="fe nq nr ns mw b">routes/index.ts </code>，它聚集了来自其他文件的路线。</p><p id="cbc8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">路线/授权交易</strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="1e9c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">路线/用户ts </strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b12e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">路线/索引. ts </strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="3952" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，要访问登录路径，您需要调用:</p><pre class="mm mn mo mp gt mv mw mx my aw mz bi"><span id="13d7" class="na lo in mw b gy nb nc l nd ne">http://localhost:3000/auth/login</span></pre><h2 id="d15f" class="na lo in bd lp nf ng dn lt nh ni dp lx kg nj nk mb kk nl nm mf ko nn no mj np bi translated">中间件</h2><p id="1421" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">如您所见，路由在调用控制器之前会调用一些中间件。中间件实际上只是一个处理你的请求并调用下一个中间件的功能。最好的理解方式是创建你的第一个中间件。</p><p id="8bfc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">middleware/checkjwt . ts<br/></strong>这个中间件会在每一个需要登录用户的路由上被调用。它将检查请求头中是否有有效的JWT。如果令牌有效，它将调用控制器将处理的下一个函数。否则，它将发送一个带有401(未授权)状态代码的响应。</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="78c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">middleware/check role . ts</strong><br/>即使用户有效登录，他也可能试图访问他可能没有角色授权访问的路由。这个中间件将检查登录的用户是否真正拥有访问这个路由所需的角色。如果没有，用401(未授权)状态代码响应。请注意，我们将角色作为字符串数组。这是因为将来您可能需要多个角色来访问同一条路线。</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="a791" class="na lo in bd lp nf ng dn lt nh ni dp lx kg nj nk mb kk nl nm mf ko nn no mj np bi translated">配置文件</h2><p id="44d6" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">为了生成和验证jwt令牌，我们需要一个密钥。我们将把它存储在一个配置文件中。您可以将jwtSecret更改为您想要的任何字符串。</p><p id="52ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">配置/配置文件</strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="8195" class="na lo in bd lp nf ng dn lt nh ni dp lx kg nj nk mb kk nl nm mf ko nn no mj np bi translated">用户实体</h2><p id="1721" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">CLI已经创建了一个“实体/用户. ts”文件。但是我们希望更改字段，添加验证并创建散列密码的方法。所以我们需要重写这个类。</p><p id="c506" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">实体/用户. ts </strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="1301" class="na lo in bd lp nf ng dn lt nh ni dp lx kg nj nk mb kk nl nm mf ko nn no mj np bi translated">控制器</h2><p id="e361" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">CLI还创建了一个名为<code class="fe nq nr ns mw b">controller</code>的文件夹。您可以删除它，并创建另一个名为<code class="fe nq nr ns mw b">controllers</code>(复数)的。然后，我们将创建auth和用户控制器。</p><p id="7cab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">控制器/授权控制器. ts </strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="c9a9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">控制器/用户控制器. ts </strong></p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><h2 id="41e9" class="na lo in bd lp nf ng dn lt nh ni dp lx kg nj nk mb kk nl nm mf ko nn no mj np bi translated">文件中的请求流</h2><p id="c111" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">我们写了很多代码，可以忘记每个文件被调用的顺序。为此，我创建了一个简单的图表，举例说明了用户请求检查角色和使用userController函数的流程。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nw"><img src="../Images/9c4dc9a6a52044ec47ba6fd9654d8226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cYneDhjzkAKDJBTEJ4rDog.png"/></div></div></figure><h1 id="f839" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">开发和生产脚本</h1><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/4d5d213d1e2a9f8618cdcd479028ad48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l5Eb6PGvHR0AB2XZsdCLBg.png"/></div></div></figure><p id="40e9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Node.js本身不能运行本地的<code class="fe nq nr ns mw b">.ts</code>文件。因此，了解以下工具非常重要。<br/> <code class="fe nq nr ns mw b">"tsc"</code> —创建一个<code class="fe nq nr ns mw b">/build</code>文件夹，将你所有的<code class="fe nq nr ns mw b">.ts</code>文件转换成<code class="fe nq nr ns mw b">.js</code>文件。<br/> <code class="fe nq nr ns mw b">"ts-node"</code> —允许节点运行<code class="fe nq nr ns mw b">.ts</code>项目。不建议用于生产用途。<br/> <code class="fe nq nr ns mw b">"ts-node-dev"</code> —同上，但允许您在每次更改文件时重新启动节点服务器</p><p id="465c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了更好地设置开发和生产环境，我们将修改<code class="fe nq nr ns mw b">package.json</code>的脚本会话。</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="6b3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们添加了最后一行s <code class="fe nq nr ns mw b">migration:run.</code>一些windows用户在尝试从npm运行TypeORM迁移时会收到一个错误。直接从节点模块文件夹运行它解决了这个问题。</p><h1 id="30fa" class="ln lo in bd lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk bi translated">第一个用户呢？</h1><p id="22e4" class="pw-post-body-paragraph jv jw in jx b jy mq ka kb kc mr ke kf kg ms ki kj kk mt km kn ko mu kq kr ks ig bi translated">正如你所看到的，即使创建一个新用户，我们也需要有一个管理员。第一个用户将由迁移过程创建。迁移对于维护生产数据库也非常重要。如果您打算在生产中使用TypeORM，我强烈建议您阅读迁移文档:<br/><a class="ae ny" href="http://typeorm.io/#/migrations" rel="noopener ugc nofollow" target="_blank">http://typeorm.io/#/migrations</a></p><p id="e9c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们创建我们的第一个迁移</p><pre class="mm mn mo mp gt mv mw mx my aw mz bi"><span id="9f72" class="na lo in mw b gy nb nc l nd ne">typeorm migration:create -n CreateAdminUser</span></pre><p id="f182" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我们将修改生成的文件:</p><figure class="mm mn mo mp gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b44e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们启动服务器，这样同步工具可以生成我们的数据库表。</p><pre class="mm mn mo mp gt mv mw mx my aw mz bi"><span id="ee96" class="na lo in mw b gy nb nc l nd ne">npm start</span></pre><p id="75f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以运行迁移，插入第一个管理员用户。</p><pre class="mm mn mo mp gt mv mw mx my aw mz bi"><span id="09b0" class="na lo in mw b gy nb nc l nd ne">npm run migration:run</span></pre><p id="bc41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，您的服务器已经准备就绪。就找邮递员，或者其他什么工具，提一些要求。</p><p id="3cce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最终的资源库可以在GitHub上找到:</p><div class="kt ku gp gr kv kw"><a href="https://github.com/andregardi/jwt-express-typeorm" rel="noopener  ugc nofollow" target="_blank"><div class="kx ab fo"><div class="ky ab kz cl cj la"><h2 class="bd io gy z fp lb fr fs lc fu fw im bi translated">andregardi/jwt-express-typeorm</h2><div class="ld l"><h3 class="bd b gy z fp lb fr fs lc fu fw dk translated">Rest API使用TypeScript Express.js和TypeORM进行JWT身份验证和基于角色的授权…</h3></div><div class="le l"><p class="bd b dl z fp lb fr fs lc fu fw dk translated">github.com</p></div></div><div class="lf l"><div class="nz l lh li lj lf lk jt kw"/></div></div></a></div></div></div>    
</body>
</html>