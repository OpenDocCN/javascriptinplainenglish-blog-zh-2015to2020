<html>
<head>
<title>How To Share State Between React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React组件之间共享状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/sharing-state-between-react-components-8c138c505e36?source=collection_archive---------12-----------------------#2020-11-20">https://javascript.plainenglish.io/sharing-state-between-react-components-8c138c505e36?source=collection_archive---------12-----------------------#2020-11-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1505a04357ae8918ef546f0a3f6661d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aJoU48mHS9UhRdGNQrtxnQ.jpeg"/></div></div></figure><p id="a169" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">React是一个非常棒的编写应用程序的平台。随着React挂钩和JavaScript改进的引入，编写更复杂的React应用程序变得更加容易。我最近发现了一个在React组件之间共享状态的好模式，我想我应该分享一下:)</p><p id="aea9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从一个带有子组件的简单应用程序开始:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="3115" class="lc ld in ky b gy le lf l lg lh">import Child from './Child';<br/><br/>export default function App(props) {<br/>  return &lt;Child /&gt;;<br/>}</span></pre><p id="fec4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">子组件将只公开一个按钮来增加计数器，状态保存在子组件中:</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="e837" class="lc ld in ky b gy le lf l lg lh">import React, { useState } from 'react';<br/><br/>export default function Child1(props) {<br/>  const [counter, setCounter] = useState(0);<br/>  return &lt;button onClick={() =&gt; setCounter(counter + 1)}&gt;<br/>    Child Counter: {counter}<br/>  &lt;/button&gt;;<br/>}</span></pre><p id="79c9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个应用程序非常简单，只是一个增加计数器的按钮:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/4500506ed479d385a01d6ffd2c0e3bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wqr2_t7dLQLVfafI.png"/></div></div></figure><p id="7cbf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">点击按钮，计数器递增:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/2cf9ed6b8528d5905cf0c3d3fa106a3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*VrzJJQwNchnkye8i.png"/></div></div></figure><p id="4e24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设父母想要访问计数器。这可以通过使用由子组件管理的全局状态来实现。<code class="fe lj lk ll ky b">reactn</code> NPM模块提供了<code class="fe lj lk ll ky b">setGlobal</code>和<code class="fe lj lk ll ky b">useGlobal</code>方法来使数据全球化。(React允许通过上下文实现这一点，但是使用起来非常复杂，所以我们使用<code class="fe lj lk ll ky b">reactn</code>。</p><p id="dcfa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们更改Child以将计数器存储为全局。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="c3be" class="lc ld in ky b gy le lf l lg lh">import React, { useEffect } from 'react';<br/>import { useGlobal, setGlobal } from 'reactn';<br/><br/>setGlobal({});<br/><br/>export default function Child1(props) {<br/>  const [child, setChild] = useGlobal('child');<br/>  useEffect(() =&gt; (child ? true : setChild({ ...child, counter: 0 })), [child, setChild]);<br/>  return &lt;button onClick={() =&gt; setChild({ ...child, counter: child?.counter + 1 })}&gt;Child Counter: {child?.counter}&lt;/button&gt;;<br/>}</span></pre><p id="4104" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这段代码的输出和以前一样，除了计数器现在可以作为全局变量使用。注意，需要useEffect来初始化<code class="fe lj lk ll ky b">child</code>全局对象。为了保持简洁，我使用的符号非常简洁，它只是初始化代码，所以让我们将其最小化。</p><p id="31d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意<code class="fe lj lk ll ky b">child?.counter</code>的使用。<code class="fe lj lk ll ky b">?.</code>操作符是一个非常方便的新JavaScript操作符。第一次渲染child 1<code class="fe lj lk ll ky b">child</code>会是<code class="fe lj lk ll ky b">undefined</code>。<code class="fe lj lk ll ky b">?.</code>短路评估，因此<code class="fe lj lk ll ky b">counter</code>成员不被访问，以防止运行时错误...因试图访问<code class="fe lj lk ll ky b">undefined.counter</code>而导致。</p><p id="0d1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们在另一个组件中使用这个计数器。为了简单起见，我们只从父组件中访问它。从子组件的对等组件或子组件中访问也同样容易。</p><pre class="kt ku kv kw gt kx ky kz la aw lb bi"><span id="03ed" class="lc ld in ky b gy le lf l lg lh">import { useGlobal } from 'reactn';<br/>import Child from './Child';<br/><br/>export default function App(props) {<br/>  const [child] = useGlobal('child');<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;div&gt;Parent Value: {child?.counter ? child.counter : 'NA'}&lt;/div&gt;<br/>      &lt;Child /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="a89c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe lj lk ll ky b">child</code>在点击按钮之前是未定义的，因此初始屏幕如下所示:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/84ca989a5feb677e576279d1870bd1b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jr-H-pntfKvUbgp_.png"/></div></div></figure><p id="3701" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">单击按钮增加子代中的计数器，并更新父代中的计数器:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/3c68edcd8ca9fa0ce16eba3c82960a59.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*G__ZrTNupeDXgGUI.png"/></div></div></figure><p id="bc1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这看起来很简单，事实也的确如此。使用钩子和<code class="fe lj lk ll ky b">reactn</code>可以减少至少80%的代码量。唯一棘手的事情是处理由于父组件在它使用的子组件之前被挂载而导致的竞争情况。幸运的是，令人敬畏的<code class="fe lj lk ll ky b">?.</code>现在可以最大限度地减少处理类似<code class="fe lj lk ll ky b">undefined</code>的东西所需的代码，无论如何，这是一种短暂的情况。</p></div><div class="ab cl lm ln hr lo" role="separator"><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr ls"/><span class="lp bw bk lq lr"/></div><div class="ig ih ii ij ik"><p id="5bf4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lt">原载于2020年11月20日</em><a class="ae lu" href="https://focusedforsuccess.com/sharing-state-between-react-components/" rel="noopener ugc nofollow" target="_blank"><em class="lt">【https://focusedforsuccess.com】</em></a><em class="lt">。</em></p></div></div>    
</body>
</html>