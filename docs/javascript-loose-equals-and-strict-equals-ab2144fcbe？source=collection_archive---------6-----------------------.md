# JavaScript:宽松等于和严格等于

> 原文：<https://javascript.plainenglish.io/javascript-loose-equals-and-strict-equals-ab2144fcbe?source=collection_archive---------6----------------------->

## java 描述语言

## 隐性强制是邪恶的、有害的吗？在某些情况下，是的！从广义上说，也不尽然。

![](img/a8b59890b66bba677f1915fcbab1c045.png)

Photo by [NordWood Themes](https://unsplash.com/@nordwood?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

***宽松等于*** 指“==”(双等号)运算符，而**严格等于**表示“===”(三等号)运算符。通常这两个运算符都用于两个值的比较和“相等”检查。然而,“宽松”和“严格”的平等者在行为上有显著的不同，尤其是在他们得出“平等”的方式上。

对这两个运算符的一个常见误解是:" ***双等号检查值是否相等，而三等号检查值及其类型是否相等*** "。虽然这听起来似乎很合理和清晰，但它从根本上是不正确的。有许多流行的 JavaScript 书籍和博客已经明确指出了这种区别，但不幸的是，它们都是错误的。

更恰当的定义应该是:" ***双等号允许等式比较中的强制，而三等号操作避免强制。***

# 两个等式的性能比较

让我们花点时间考虑一下这两种定义，首先是不正确的定义，然后是更合适的定义。

请注意，在第一个解释中，它只是表明运算符“===”比运算符“==”工作更多。这似乎是显而易见的，因为它涉及到检查类型。但是考虑第二种解释，其中“==”完成了更多的工作，因为它遵循了不同类型情况下的强制步骤。

当心这个陷阱！许多人认为这与性能有关，因为“==”的运行速度相对较慢。虽然强制过程花费了大量的处理时间在数量上是有效的，但是额外的时间以微秒计。

或者，在考虑比较同一类型的两个不同值时，“==”运算符和“===”运算符都使用相同的算法。因此，他们应该做同样多的工作，即使我们包括他们相应的工程实现中的微小差异。

现在，如果我们比较两个不同的值，性能不一定是主要关注点。相反，我们应该重新考虑是否有强制过程的要求。如果我们真的想要强制，我们选择“==”作为松散的等式，否则我们选择“===”作为严格的操作符。

**注意:**这里，主要的含义是两个操作符(“==”和“===”)都检查它们的操作数的类型。区别在于它们在类型不匹配的情况下的响应方式。

# 抽象等式

“==”操作符的行为在 [ES5 规范](https://www.ecma-international.org/ecma-262/5.1/#sec-11.9)的 11.9.3 节中定义为*“抽象等式比较算法”*。本节通过一个全面而又简化的算法，说明了对于每种可能的组合类型，强制过程(如果需要的话)应该如何发生。

换句话说，这一节的第一个分句(即 11.9.3.1)提到，如果被比较的两个价值属于同一类型，那么它们应该通过同一性进行简单而自然的比较。也就是说，考虑***【123】***哪个只等于***【123】***就像***【qwerty】***怎么只应该等于***【qwerty】***一样。

子句 11.9.3.1 的最后一段致力于“==”松散等式与对象(包括函数和数组)的比较。这里，两个这样的值只有当且仅当它们引用完全相同的值时才能被认为是相等的。因此，这里没有观察到强制。

11.9.3 节中算法的剩余部分提到，当在比较不同类型的两个值时使用“==”宽松等式运算符时，可能需要隐式强制一个或两个值。这是为了确保这两个值最终属于同一类型，因此可以通过简单的值标识直接用于比较是否相等。

**注:**“中！= "松散的不等运算符也正如我们所期望的那样定义。它只是执行完整的“==”运算比较，然后对结果求反。同样的“！== "用作严格的不等运算符。

# 隐式强制的安全使用

让我们建立一个简单的基本规则:总是浏览程序并推理可能出现在“==”比较两边的值。为了避免比较，你可以遵循以下准则:

*   在比较的任何一方可能有真或假值的情况下，总是**避免使用“==”运算符**。
*   在比较的任何一方可以有[]、" "(空字符串)或 0 值的情况下，再次**避免**使用“==”运算符。

在上述情况下，最好使用“===”操作符代替“==”操作符，以避免强制。如果掌握了这两个规则，许多与强制程序有关的麻烦就可以轻易避免。在这些情况下，更加明确和罗嗦将有助于避免很多麻烦。

所以现在，关于“==”和“===”操作符的比较，更恰当的问题形式应该是:应该允许强制比较吗？

在许多情况下，强制是很方便的，它使我们能够以一种非常简洁的方式构建一些比较逻辑(例如，未定义或空)。相反，隐性胁迫可能相当有害的情况相对较少。然而，在这种情况下，强烈建议使用“===”操作符作为预防措施。

现在的问题是:隐性强制是邪恶和有害的吗？在某些情况下，是的！从广义上说，也不尽然。

# 结论

做一个负责任、成熟的开发者很重要。学习并获得无缝有效地使用强制(显性和隐性)的经验，以及将知识传授给他人，是这里的关键。

## **用简单英语写的 JavaScript 笔记**

我们已经推出了三种新的出版物！请关注我们的新出版物:[**AI in Plain English**](https://medium.com/ai-in-plain-english)[**UX in Plain English**](https://medium.com/ux-in-plain-english)[**Python in Plain English**](https://medium.com/python-in-plain-english)**——谢谢，继续学习！**

**我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至[**submissions @ plain English . io**](mailto:submissions@plainenglish.io)**，并附上您的 Medium 用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。****

****感谢阅读这篇文章！如果你有任何问题，请在下面留言。此外，看看我的其他文章，你可能会喜欢:****

****[](https://medium.com/@vpodk/most-popular-javascript-frameworks-in-2020-afefe8c7c6c5) [## 2020 年最流行的 JavaScript 框架

### 每个框架都有自己的优点和缺陷。

medium.com](https://medium.com/@vpodk/most-popular-javascript-frameworks-in-2020-afefe8c7c6c5) [](https://medium.com/@vpodk/progressive-web-apps-and-their-advantages-70d3e119f165) [## 渐进式网络应用及其优势

### 许多人甚至不知道很多流行的日常应用实际上是进步的网络应用。

medium.com](https://medium.com/@vpodk/progressive-web-apps-and-their-advantages-70d3e119f165)****