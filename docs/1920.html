<html>
<head>
<title>JavaScript Prototype — Understanding The Basics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript原型——理解基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-prototype-understanding-the-basics-1d323166fbf8?source=collection_archive---------9-----------------------#2020-05-04">https://javascript.plainenglish.io/javascript-prototype-understanding-the-basics-1d323166fbf8?source=collection_archive---------9-----------------------#2020-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="a0c1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">与面向对象编程相比，原型通常与继承联系在一起。但是<strong class="jp ir">为什么是</strong>？甚至原型在JavaScript中意味着什么。在这篇博客中，我将解释<strong class="jp ir">什么是原型</strong>，以及<strong class="jp ir">如何用JavaScript设计和构建原型</strong>。当然，还有为什么。</p><blockquote class="kl km kn"><p id="a0b1" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">在JavaScript中，所有的函数都是对象，唯一不同的是函数可以被调用。</em></p></blockquote><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="c689" class="lb lc iq kx b gy ld le l lf lg">// Here is a simple function<br/>function Superman() {<br/>  // ...<br/>}</span><span id="9869" class="lb lc iq kx b gy lh le l lf lg">// Since function Superman is also an object we can add properties and methods like in objects.<br/>Superman.isHero = true;<br/>Superman.test = function() {<br/>  console.log('test ok')<br/>}</span><span id="935f" class="lb lc iq kx b gy lh le l lf lg">console.log(Superman.isHero) // true<br/>console.log(Superman.test()) // test ok</span></pre><p id="3948" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个博客中，我将告诉你一个小故事，在这个故事中，我们有像超人、蝙蝠侠和神奇女侠这样的超级英雄，他们每个人都有独特的超能力。还有一些科学家。</p><blockquote class="kl km kn"><p id="28b7" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">超人</em>:飞行、超人力量、x光视觉、热视觉、冷呼吸、超速度、强化听觉、高无敌等。</p><p id="d5e5" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">蝙蝠侠</em>:小玩意，超人级别的力量，敏捷，智力等。</p><p id="9479" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">神奇女侠</em>:超人的力量和耐力、飞行、超人的速度、反应和敏捷；感官增强，包括嗅觉、视觉、听觉等。</p></blockquote><p id="58d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们稍微调整一下这个故事，每个超级英雄的超能力都放在一个包里，他们只能打开自己的包。</p><p id="a27a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在JavaScript中，我们都见过像数组、日期、对象、集合、承诺、字符串、数字等标准内置对象。让我们把他们想象成JavaScript的超级英雄，就像故事里一样，他们的超能力也存放在一个标有‘原型’的袋子里。是的，这是原型，细节如下。</p><figure class="ks kt ku kv gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi li"><img src="../Images/82912bd67679d063a03b2899c1fddfb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZTh_b5xpOUVNCrAexEkVw.jpeg"/></div></div></figure><p id="af9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我确信我们都在JavaScript中使用过很多次超能力。他们在这里:</p><blockquote class="kl km kn"><p id="8261" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">数组</em> : forEach，filter，sort，slice，concat，length等。</p><p id="637e" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">字符串</em> : toUpperCase，toLowerCase，replace，substr等。</p><p id="9631" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">设置</em>:有、增加、删除、清除、取值等。</p><p id="80d5" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">许诺</em>:然后，抓住，最后，等等。</p></blockquote><p id="d57e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有这些属性(或方法)都存储在每个函数对象的一个名为“原型”的属性中。这意味着原型也是一个对象。您可以通过在浏览器的控制台中直接访问它们的原型来查看所有这些属性(或方法)——array . prototype、Set.prototype等等。下面是一些相关图片。</p><div class="ks kt ku kv gt ab cb"><figure class="lq lj lr ls lt lu lv paragraph-image"><img src="../Images/cfe46bd7b2ea6b10c8aa2c1b98eb7fb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*g88BSOWvUqNp2E2OIyzzAg.png"/></figure><figure class="lq lj lw ls lt lu lv paragraph-image"><img src="../Images/24b557ef604317b08d28802d1eee924f.png" data-original-src="https://miro.medium.com/v2/resize:fit:934/format:webp/1*x_kxRjRQbCSniJvJpsAT9w.png"/><figcaption class="lx ly gj gh gi lz ma bd b be z dk mb di mc md">showing properties and functions that are stored inside prototype properties</figcaption></figure></div><blockquote class="kl km kn"><p id="e981" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">超级英雄= &gt;函数对象(</em>数组，集合，日期，诺言，地图等。<em class="iq"> ) </em></p><p id="bad5" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq"> superpowers = &gt;属性和方法(</em>长度，forEach，map，size等。<em class="iq"> ) </em></p><p id="586e" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated"><em class="iq">袋子= &gt;原型</em></p></blockquote><p id="e8ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在介绍一组科学家，他们可以创造或克隆这些超级英雄。让我们称其中一位科学家为<em class="ko">构造者</em>，他使用<strong class="jp ir"> new </strong>操作符来创建超级英雄的实例。其他科学家可以称为<em class="ko"> Object.create </em>、<em class="ko"> Object.setPrototypeOf和syntax构造。他们有不同的原型制作方法。</em></p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="61ce" class="lb lc iq kx b gy ld le l lf lg"><em class="ko">// Lets first create our own Superhero in LAB1</em></span><span id="5b66" class="lb lc iq kx b gy lh le l lf lg">function Superhero(name, faction) {<br/>  this.name = name;<br/>  this.faction = faction;<br/>  this.XRayVision = false;<br/>  this.fly = false;  <br/>}</span><span id="4c8e" class="lb lc iq kx b gy lh le l lf lg">// add toggleXRayVision method to Superhero prototype<br/>Superhero.prototype.toggleXRayVision = function() {<br/>  this.XRayVision = !this.XRayVision;<br/>  console.log(`Superhero ${this.name} has turned ${this.XRayVision ? "on" : "off"} X Ray vision.`);<br/>};</span><span id="f59e" class="lb lc iq kx b gy lh le l lf lg">// add toggleFlight method to Superhero prototype<br/>Superhero.prototype.toggleFlight = function() {<br/>  this.fly = !this.fly;<br/>  console.log(`Superhero ${this.name} ${this.fly ? "is now flying" :       "has stopped flying"} over ${this.faction}.`);<br/>};</span><span id="fe0d" class="lb lc iq kx b gy lh le l lf lg">// create instances s1 &amp; s2 using new operator<br/>let s1 = new Superhero("Hero1", "Asia");<br/>let s2 = new Superhero("Hero2", "Europe");</span><span id="d0a1" class="lb lc iq kx b gy lh le l lf lg">// **************</span><span id="e36c" class="lb lc iq kx b gy lh le l lf lg">s1.toggleXRayVision(); <br/><em class="ko">// Superhero Hero1 has turned on X Ray vision.<br/></em>s2.toggleXRayVision(); <br/><em class="ko">// Superhero Hero2 has turned on X Ray vision.</em></span><span id="d09a" class="lb lc iq kx b gy lh le l lf lg">// update method so that changes reflect in all instances<br/>Superhero.prototype.toggleXRayVision = function() {<br/>  this.XRayVision = !this.XRayVision;<br/>  console.log(`Modified: Superhero ${this.name} has turned ${this.XRayVision ? "on" : "off"} X Ray vision.`);<br/>};</span><span id="da36" class="lb lc iq kx b gy lh le l lf lg">s1.toggleXRayVision(); <br/>// Modified: Superhero Hero1 has turned off X Ray vision.<br/>s2.toggleXRayVision(); <br/><em class="ko">// </em>Modified: Superhero Hero2 has turned off X Ray vision.</span><span id="29f9" class="lb lc iq kx b gy lh le l lf lg">// **************</span><span id="e829" class="lb lc iq kx b gy lh le l lf lg">s1.toggleFlight(); <em class="ko">// Superhero Hero1 is now flying over Asia.<br/></em>s2.toggleFlight(); <em class="ko">//Superhero Hero2 is now flying over Europe.</em></span><span id="51f3" class="lb lc iq kx b gy lh le l lf lg"><em class="ko">// this is called </em><a class="ae me" href="https://en.wikipedia.org/wiki/Method_overriding" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="ko">method shadowing</em></strong></a><em class="ko"> or </em><a class="ae me" href="https://en.wikipedia.org/wiki/Method_overriding" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="ko">method overriding</em></strong></a><em class="ko">, affect only s1 instance but not prototype<br/></em>s1.toggleFlight = function()  {<br/>  this.fly = !this.fly;<br/>  console.log(`Defect: Superhero ${this.name} flying has been defected`);<br/>};</span><span id="67ca" class="lb lc iq kx b gy lh le l lf lg">s1.toggleFlight();<br/><em class="ko">// Defect: Superhero Hero1 flying has been defected<br/></em>s2.toggleFlight();<br/><em class="ko">// Superhero Hero2 has stopped flying over Europe.</em></span><span id="f3b3" class="lb lc iq kx b gy lh le l lf lg"><em class="ko">// dynamically update toggleFlight method for all instances<br/></em>Superhero.prototype.toggleFlight = function()  {<br/>  this.fly = !this.fly;<br/>  console.log(`Fly Repaired: Superhero ${this.name} ${this.fly ? "is now flying" : "has stopped flying"} over ${this.faction}.`);<br/>};</span><span id="024b" class="lb lc iq kx b gy lh le l lf lg"><em class="ko">// if s1 hadn't overridden this method, it would have been repaired too, so update on prototype level will not affect this method<br/></em>s1.toggleFlight(); <br/><em class="ko">// Defect: Superhero Hero1 flying has been defected<br/></em>s2.toggleFlight(); <br/><em class="ko">// Fly Repaired: Superhero Hero2 is now flying over Europe.</em></span></pre><blockquote class="kl km kn"><p id="6dbe" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">注意:对于创建的每个新实例，不会创建原型的新副本，但是它们都共享(或链接到)同一个原型。</p></blockquote><p id="6159" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">怎么会？每个实例(对象)都有一个私有属性，用于保存到另一个对象的链接，该对象称为其原型(父对象)。在大多数浏览器中，私有属性被命名为<strong class="jp ir"> <em class="ko"> __proto__ </em> </strong>，它链接到一个函数对象的属性原型。你可以在JavaScript的每个对象中找到它，如下图所示(<em class="ko"> __proto__ </em>最后)。</p><blockquote class="kl km kn"><p id="1786" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">注意:<em class="iq"> __proto__ </em>的标准符号是[[prototype]]。</p></blockquote><div class="ks kt ku kv gt ab cb"><figure class="lq lj mf ls lt lu lv paragraph-image"><img src="../Images/ad7fc49c06d653fd9c538c7b54419e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*n_uhbfC2WhAEPjMPUcy-1A.png"/></figure><figure class="lq lj mg ls lt lu lv paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><img src="../Images/d7af27ec0067b6690b65b1fa2d128bb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*ioa_Rw4vl-Sy14UfFtSKrA.png"/></div></figure></div><p id="cea9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">proto的这个概念创建了一个<strong class="jp ir">原型链</strong>(下面解释)，在这里孩子可以访问原型。这就是JavaScript继承属性和方法的方式。</p><p id="6876" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，如果替换或修改任何对象的<em class="ko"> __proto__ </em>，链可能会断开，这可能会导致继承无法正常工作。所以更新它是不可取的，除非它是必要的，你知道你在做什么。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="4134" class="lb lc iq kx b gy ld le l lf lg">// few expressions<br/>let array = new Array(); // constructor<br/>or, let array = []; // syntax constructs<br/>array.<em class="ko">__proto__</em> === Array.prototype // true</span><span id="9b8a" class="lb lc iq kx b gy lh le l lf lg">let set = new Set();<br/>set.<em class="ko">__proto__</em> === Set.prototype // true</span></pre><blockquote class="kl km kn"><p id="548d" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">注意:set继承自Set.prototype而不是Set本身，这意味着属性prototype字面上是它的原型(父对象)而不是Set。</p></blockquote><p id="45af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在JavaScript中，几乎所有的对象都是对象的实例。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="dd55" class="lb lc iq kx b gy ld le l lf lg">// Array.prototype inherits from Object.prototype</span><span id="6fbc" class="lb lc iq kx b gy lh le l lf lg">Array.prototype.<em class="ko">__proto__</em> === Object.prototype // true</span><span id="1cbb" class="lb lc iq kx b gy lh le l lf lg">array.<em class="ko">__proto__</em>.<em class="ko">__proto__</em> === Object.prototype // true</span><span id="bb2f" class="lb lc iq kx b gy lh le l lf lg">Object.prototype.<em class="ko">__proto__</em> // null</span></pre><figure class="ks kt ku kv gt lj gh gi paragraph-image"><div role="button" tabindex="0" class="lk ll di lm bf ln"><div class="gh gi mh"><img src="../Images/916d0b1f753321b25cd91eb04845eb0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5MvCM6g42KyV2XK_H1nLIw.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">prototypal structure in JavaScript</figcaption></figure><p id="e1d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上图所示，你可以看到一连串的原型一直连接到Object prototype object。这意味着对象位于其<em class="ko"> __proto__ </em>为空的<strong class="jp ir">原型链</strong>的顶部。</p><p id="86a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于原型链有趣的事情是，当访问一个属性时，如果在一个对象中没有找到一个属性，它的<em class="ko"> __proto__ </em>通过<em class="ko"> </em>被查看，如果在<em class="ko"> __proto__ </em>中没有找到，那么<em class="ko"> __proto__ </em>的<em class="ko"> __proto__ </em>被查看，直到到达链的末端，即空，最终返回<em class="ko">未定义的【T28是的，<code class="fe mi mj mk kx b">console.log(array2[0])</code>从上面的图片打印1。</em></p><p id="52ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，出于性能的考虑，尽量把链条做的小一点。此外，您可以使用每个对象从Object.prototype继承的<em class="ko"> hasOwnProperty </em>方法来检查当前对象上是否存在属性，并防止遍历整个链。虽然它不检查一个属性值是否<em class="ko">未定义</em>。</p><p id="511b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们已经知道从一个函数初始化一个对象会继承它的原型。然而，我们也可以使用<strong class="jp ir"> Object.create </strong>方法从一个对象继承，这使得第一个参数成为新对象的原型。</p><pre class="ks kt ku kv gt kw kx ky kz aw la bi"><span id="d8f5" class="lb lc iq kx b gy ld le l lf lg">let obj = {a: 1, b: 2};<br/>obj ---&gt; Object.prototype ---&gt; null</span><span id="02e1" class="lb lc iq kx b gy lh le l lf lg">let o = Object.create(obj); // obj is prototype for o<br/>o ---&gt; obj --&gt; Object.prototype ---&gt; null<br/>console.log(o.a) // 1</span><span id="5cea" class="lb lc iq kx b gy lh le l lf lg">let arr = [1, 2];<br/>arr ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null</span><span id="470c" class="lb lc iq kx b gy lh le l lf lg">let a = Object.create(arr);<br/>a --&gt; arr --&gt; Array.prototype ---&gt; Object.prototype ---&gt; null<br/>console.log(a[1]) // 2</span></pre><blockquote class="kl km kn"><p id="1582" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">通常，JavaScript中的prototype是一个对象(不一定存储在property prototype中)，从它创建的新对象链接到该对象，因此可以使用它的属性和方法。</p></blockquote><blockquote class="ml"><p id="116a" class="mm mn iq bd mo mp mq mr ms mt mu kk dk translated">在JavaScript中，对象为王。如果你理解了对象，你就理解了JavaScript。—已复制</p></blockquote><p id="f888" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">如果你想了解更多关于原型或者原型链的知识，这里有链接:<a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Inheritance _ and _ the _ prototype _ chain</a></p><p id="bd57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读。非常感谢评论。请随意评论你对这个博客的看法或有任何问题。</p><p id="79fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">链接到我以前的博客:<a class="ae me" href="https://medium.com/swlh/react-render-optimization-few-tips-360837d98e91" rel="noopener">反应渲染优化几个技巧</a></p><h2 id="a02a" class="lb lc iq bd na nb nc dn nd ne nf dp ng jy nh ni nj kc nk nl nm kg nn no np nq bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="638e" class="pw-post-body-paragraph jn jo iq jp b jq nr js jt ju ns jw jx jy nt ka kb kc nu ke kf kg nv ki kj kk ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae me" href="https://medium.com/ai-in-plain-english" rel="noopener"> <strong class="jp ir"> AI in Plain English </strong> </a>，<a class="ae me" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="jp ir">UX in Plain English</strong></a>，<a class="ae me" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="jp ir">Python in Plain English</strong></a><strong class="jp ir"/>——谢谢，继续学习！</p><p id="a869" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae me" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jp ir">submissions @ plain English . io</strong></a><strong class="jp ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>