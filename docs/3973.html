<html>
<head>
<title>Fundamentals of Redux with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux with React的基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/fundamentals-of-redux-with-reactjs-dd14426b1ae1?source=collection_archive---------12-----------------------#2020-11-06">https://javascript.plainenglish.io/fundamentals-of-redux-with-reactjs-dd14426b1ae1?source=collection_archive---------12-----------------------#2020-11-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="ec43" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">Javascript React Redux教程</h2><div class=""/><div class=""><h2 id="942f" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">冗余模式、不变性和纯函数</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/1be18be80dea2f7c36c0653dbb5efb97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lSbm5so0zwaSZFwh0BlXfg.jpeg"/></div></div></figure><p id="a833" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">在本教程中，我们将介绍在您的应用程序中使用Redux的核心概念和原则。</p><p id="ff18" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">根据官方<a class="ae lt" href="https://redux.js.org/tutorials/essentials/part-1-overview-concepts" rel="noopener ugc nofollow" target="_blank">网站</a>，Redux可以定义为:</p><blockquote class="lu"><p id="570b" class="lv lw in bd lx ly lz ma mb mc md ls dk translated">Redux是一个模式和库，用于管理和更新应用程序状态，使用称为“动作”的事件。</p></blockquote><p id="761a" class="pw-post-body-paragraph kx ky in kz b la me jx lc ld mf ka lf lg mg li lj lk mh lm ln lo mi lq lr ls ig bi translated">Redux是一个集中式存储，其中每个组件都可以访问应用程序的状态。Redux有助于管理全局状态，应用程序的多个部分都需要这个状态。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="f2a9" class="mo mp in mk b gy mq mr l ms mt">function Counter() {<br/>  // State: a counter value<br/>  <strong class="mk ix">const [counter, setCounter] = useState(0)</strong></span><span id="7727" class="mo mp in mk b gy mu mr l ms mt">// Action: code that causes an update to the state when something happens<br/> <strong class="mk ix"> const increment = () =&gt; {<br/>    setCounter(prevCounter =&gt; prevCounter + 1)<br/>  }</strong></span><span id="0cd1" class="mo mp in mk b gy mu mr l ms mt">// View: the UI definition<br/>  return (<br/>    <strong class="mk ix">&lt;div&gt;<br/>      Value: {counter} &lt;button onClick={increment}&gt;Increment&lt;/button&gt;<br/>    &lt;/div&gt;</strong><br/>  )<br/>}</span></pre><p id="9fa2" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">正如Redux网站上解释的例子，我们有一个小程序做一件事，每点击一次它就增加1。我们可以看到这个应用程序有3个阶段，第一个阶段是“<strong class="kz ix">状态</strong>，在这里计数器变量和setCounter函数得到它们的初始状态。第二个概念是“<strong class="kz ix">动作</strong>”。increment函数只做一件事，它将计数器加1。第三个概念是“<strong class="kz ix">视图</strong>”，在div标签内，我们显示一个按钮。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mv"><img src="../Images/39b403d4d0ca7058ab14a122c549919d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ajnyxfcMcK364tYb31vcYQ.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">one-way data flow</figcaption></figure><p id="bc9b" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">然而，大多数应用程序并没有这么简单，状态可能出现在不同的组件上，随着组件越来越多，从这些组件访问状态会变得越来越困难。</p><p id="e433" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">解决这个问题的一个方法是将状态从组件中分离出来，这叫做状态管理。一个全局状态和所有的组件可以共享这个状态，这是创建Redux的唯一想法。</p><p id="76ed" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">现在我们知道了为什么要用Redux，下面来看看怎么用Redux。</p><h1 id="a8ab" class="na mp in bd nb nc nd ne nf ng nh ni nj kc nk kd nl kf nm kg nn ki no kj np nq bi translated">不变</h1><p id="016f" class="pw-post-body-paragraph kx ky in kz b la nr jx lc ld ns ka lf lg nt li lj lk nu lm ln lo nv lq lr ls ig bi translated">所有的状态更新必须是不可变的。我们想要不变性的原因是我们不想永久地改变状态。一旦一个物体发生变异，就不可能再回到原来的状态。为了实现不变性，我们的代码必须复制现有的对象/数组，然后修改这些副本。</p><h2 id="1778" class="mo mp in bd nb nw nx dn nf ny nz dp nj lg oa ob nl lk oc od nn lo oe of np it bi translated">示例1</h2><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="4d43" class="mo mp in mk b gy mq mr l ms mt">let person = {  <br/>   <strong class="mk ix">firstName: "john",  <br/>   lastName: "smith",<br/></strong>}</span></pre><p id="388d" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">现在，假设我们编写一个函数来添加地址</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="88b8" class="mo mp in mk b gy mq mr l ms mt">function addAddress(person) {<br/>    <strong class="mk ix">person.address = " 123 main st ";<br/>    return person;<br/></strong>}</span></pre><p id="ccf8" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">现在让我们看看我们在控制台中发现了什么</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="8f8e" class="mo mp in mk b gy mq mr l ms mt">console.log(person);</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi og"><img src="../Images/fd81037c5842f70f530bdf88abf86c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*2ALLAlDBfS-mfpKgskdVoA.png"/></div></figure><p id="519e" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我们可以看到我们还没有添加地址属性。</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="b94f" class="mo mp in mk b gy mq mr l ms mt">let addedPerson = addAddress(person)<br/>console.log(person)<br/>console.log(addedPerson)</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oh"><img src="../Images/c8a763ea2b9d7100ea027a24d9c3680f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HKTTmLmgZz1tjdSMauSJfQ.png"/></div></div></figure><p id="3da4" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">现在，person对象发生了变异，并且更新了一个地址。</p><p id="ab5d" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这可能会导致系统中出现一些严重的错误。对象的内部已经改变，但是对象引用没有改变。外面是同一个物体。</p><p id="d759" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">如果我们想让addedPerson函数不修改Person，我们必须做一些修改。一个函数要成为纯函数，必须遵循两条规则。</p><ol class=""><li id="d5d9" class="oi oj in kz b la lb ld le lg ok lk ol lo om ls on oo op oq bi translated">当给定相同的输入时，纯函数必须总是返回相同的值。</li><li id="ecb8" class="oi oj in kz b la or ld os lg ot lk ou lo ov ls on oo op oq bi translated">一个纯函数一定不能有任何<em class="ow">副作用。</em></li></ol><h1 id="2cbc" class="na mp in bd nb nc nd ne nf ng nh ni nj kc nk kd nl kf nm kg nn ki no kj np nq bi translated">副作用</h1><p id="68c4" class="pw-post-body-paragraph kx ky in kz b la nr jx lc ld ns ka lf lg nt li lj lk nu lm ln lo nv lq lr ls ig bi translated">举一个这个函数的例子</p><h2 id="23d0" class="mo mp in bd nb nw nx dn nf ny nz dp nj lg oa ob nl lk oc od nn lo oe of np it bi translated">示例2</h2><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="f9b0" class="mo mp in mk b gy mq mr l ms mt"><strong class="mk ix">function add(a, b) {<br/>   return a + b; <br/>}</strong></span></pre><p id="0495" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">它总是只做一件事，如果你传递两个整数，它将返回这两个整数的和。而且没有副作用。它没有改变任何函数，参数，或者其他什么。</p><blockquote class="lu"><p id="dde9" class="lv lw in bd lx ly lz ma mb mc md ls dk translated">纯函数只能调用其他纯函数</p></blockquote><h1 id="3a9a" class="na mp in bd nb nc nd ne nf ng nh ni nj kc ox kd nl kf oy kg nn ki oz kj np nq bi translated">纯函数</h1><p id="ac8c" class="pw-post-body-paragraph kx ky in kz b la nr jx lc ld ns ka lf lg nt li lj lk nu lm ln lo nv lq lr ls ig bi translated">我们将addAddress函数转换为纯函数的方法如下所示:</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="83aa" class="mo mp in mk b gy mq mr l ms mt">function addAddress(person){<br/><strong class="mk ix">  let newPerson = Object.assign({}, person , {<br/>  address: '123 main st'<br/>})</strong></span><span id="7b29" class="mo mp in mk b gy mu mr l ms mt"><strong class="mk ix">  return newPerson;</strong><br/>}</span></pre><p id="14f5" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我们没有修改对象本身，而是创建了一个对象，并将以前的对象分配给这个新对象，以前的对象保持不变。</p><p id="7cfc" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我们可以这样写:</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="dcc6" class="mo mp in mk b gy mq mr l ms mt">function addAddress(person){<br/><strong class="mk ix">  let newPerson = {<br/>  ...person,  <br/>  address: '123 main st'<br/>})</strong></span><span id="e4b9" class="mo mp in mk b gy mu mr l ms mt"><strong class="mk ix">return newPerson;</strong><br/>}</span></pre><p id="f4e3" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这个纯函数将返回一个全新的对象。</p><h1 id="52ae" class="na mp in bd nb nc nd ne nf ng nh ni nj kc nk kd nl kf nm kg nn ki no kj np nq bi translated">JavaScript中的引用相等</h1><p id="23c5" class="pw-post-body-paragraph kx ky in kz b la nr jx lc ld ns ka lf lg nt li lj lk nu lm ln lo nv lq lr ls ig bi translated">在javascript中，所有的数组和对象都存储在内存中。如果你把内存想象成一个盒子，那么变量就是指向盒子的指针，值就是盒子里面的东西。让我们来看一个例子，它是如何与一个对象一起工作的。</p><h2 id="cfc1" class="mo mp in bd nb nw nx dn nf ny nz dp nj lg oa ob nl lk oc od nn lo oe of np it bi translated">示例3</h2><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="bc23" class="mo mp in mk b gy mq mr l ms mt">let student = { name : "john" }</span></pre><p id="7fab" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">这里的学生是指向内存位置的指针，大括号里面的东西就是盒子里面的东西。</p><p id="eca5" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">如果我们像这样把值改成dave</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="195e" class="mo mp in mk b gy mq mr l ms mt">let student = { name : "dave" }</span></pre><p id="b9bd" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">会将指针更改为内存中的新值。</p><p id="3e31" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">但是，以下更改不会影响存储位置</p><pre class="km kn ko kp gt mj mk ml mm aw mn bi"><span id="869d" class="mo mp in mk b gy mq mr l ms mt">let student = { name : "john" }<br/>student.name = "dave";<br/></span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mv"><img src="../Images/0da9ab7b3988781a184e8ab92a2fe182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9LQkbq4kwB_tZ5kNVNflng.png"/></div></div></figure><p id="eb86" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">我们可以通过引用相等来测试这一点。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi pa"><img src="../Images/4582aaec616a6188cd3f78719ec41bab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uApEdygKqRR_muXRQZyiCg.png"/></div></div></figure><p id="258b" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">通过引用相等检查，我们可以看到两个对象是否指向同一个内存位置。</p><blockquote class="lu"><p id="8df2" class="lv lw in bd lx ly lz ma mb mc md ls dk translated">提示:</p><p id="1c09" class="lv lw in bd lx ly lz ma mb mc md ls dk translated">比较运算符应用于数组或对象，运算符===比较它们指向的内存地址(它们的引用)。这就是所谓的参照平等。</p></blockquote><p id="1be9" class="pw-post-body-paragraph kx ky in kz b la me jx lc ld mf ka lf lg mg li lj lk mh lm ln lo mi lq lr ls ig bi translated">在下一个教程中，我们将学习如何在Redux中更新状态。</p><p id="e200" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae lt" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ix">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kz ix">！</strong></p></div><div class="ab cl pb pc hr pd" role="separator"><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg ph"/><span class="pe bw bk pf pg"/></div><div class="ig ih ii ij ik"><p id="d990" class="pw-post-body-paragraph kx ky in kz b la lb jx lc ld le ka lf lg lh li lj lk ll lm ln lo lp lq lr ls ig bi translated">奥斯卡·伊尔迪兹在<a class="ae lt" href="https://unsplash.com/s/photos/react?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"> Unsplash </a>上拍摄的照片</p></div></div>    
</body>
</html>