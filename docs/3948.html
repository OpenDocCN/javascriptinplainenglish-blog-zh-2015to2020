<html>
<head>
<title>JavaScript Pure Functions and Side Effects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript纯函数和副作用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-pure-functions-and-side-effects-f0642b70a484?source=collection_archive---------4-----------------------#2020-11-05">https://javascript.plainenglish.io/javascript-pure-functions-and-side-effects-f0642b70a484?source=collection_archive---------4-----------------------#2020-11-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b63d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想知道开发人员所说的纯功能或副作用是什么意思吗？想知道为什么它们在JavaScript生态系统中如此普遍，理解它们非常重要吗？</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/f22c3ff99d719711faeb2021e88ba229.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dFcPmgq63qH-kpZwLhhMag.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@rojekilian?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Sarah Kilian</a> on <a class="ae ky" href="https://unsplash.com/s/photos/accident?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="20ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文中，我将通过定义它们是什么，以及为什么使用代码块示例理解它们很重要，来带您浏览这些纯函数和副作用的术语。到本文结束时，你应该能够分辨出常规函数和纯函数之间的区别。最重要的是，你应该了解什么是副作用，以及为什么你应该避免在许多不同的情况下产生它们。</p><p id="7575" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们一起享受和学习:</p><h1 id="21e1" class="la lb in bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">纯函数</strong></h1><p id="ba3c" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">JavaScript中被认为是纯函数的函数必须具有以下两个属性:</p><ul class=""><li id="810a" class="md me in jm b jn jo jr js jv mf jz mg kd mh kh mi mj mk ml bi translated">给出相同的输入总是返回相同的输出。</li><li id="9e8b" class="md me in jm b jn mm jr mn jv mo jz mp kd mq kh mi mj mk ml bi translated">该功能不会产生任何副作用。</li></ul><p id="04bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在本文的后面，我们将进一步了解副作用，但首先让我们看看第一个属性:</p><h2 id="ed90" class="mr lb in bd lc ms mt dn lg mu mv dp lk jv mw mx lo jz my mz ls kd na nb lw nc bi translated">1.同样的输入，同样的输出。</h2><p id="d298" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">纯函数在其输入和输出之间有一对一的映射或连接，这意味着每个唯一的输入都有一个唯一的对应输出。为了进一步理解这看起来像什么，让我们看下面的clear块:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="8087" class="mr lb in ne b gy ni nj l nk nl">const customSalutation = (name) =&gt; {<br/>return `Hey ${name}`;<br/>}</span></pre><p id="8ac9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">函数<code class="fe nm nn no ne b">customSalutation</code>将<em class="kz">名称</em>作为一个参数，并返回我的自定义问候语，这个函数的伟大之处在于输出很容易预测，对于您给它的相同名称，您将得到您期望的相同的返回问候语。</p><p id="1f3b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们在这里创建一个名为<code class="fe nm nn no ne b">salutaion</code>的常量，我调用<code class="fe nm nn no ne b">customSalutation</code>并传递我自己的名字，然后我打印出我的问候常量，我得到<code class="fe nm nn no ne b">Hey Hafid</code>作为输出。</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="17aa" class="mr lb in ne b gy ni nj l nk nl">const customSalutation = (name) =&gt; {<br/>return `Hey ${name}`;<br/>}</span><span id="0ab3" class="mr lb in ne b gy np nj l nk nl">const salutation = customSalutation('Hafid');<br/>console.log(salutation);<br/>// Hey Hafid</span></pre><p id="33b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，不管这个方法如何被调用或使用，如果你给它相同的输入，你总是可以期望得到相同的输出。这里有一个不同的情况，我们有一个名为<code class="fe nm nn no ne b"><em class="kz">names</em></code>的数组，它的正下方有一个变量<code class="fe nm nn no ne b">nameSalutaions</code>，它是从映射中分配的返回值，首先将第一个函数<code class="fe nm nn no ne b">customeSalutations</code>作为一个<em class="kz">回调函数</em>，它将在<code class="fe nm nn no ne b">names</code>数组<em class="kz">的每个元素上被调用。</em></p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="5503" class="mr lb in ne b gy ni nj l nk nl">const customSalutation = (name) =&gt; {<br/>return `Hey ${name}`;<br/>}</span><span id="ece9" class="mr lb in ne b gy np nj l nk nl">const names = ['Hafid', John', 'Lucy''];<br/>const nameSalutation = name.map(customSalutation);</span><span id="c3b5" class="mr lb in ne b gy np nj l nk nl">console.log(nameSalutation);<br/>// [<br/>//   'Hey Hafid'<br/>//   'Hey John',<br/>//   'Hey Lucy' <br/>// ]</span></pre><p id="d3d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出是对每个人的称呼。纯函数允许你有这样的期望，给定相同的输入，你应该有相同的输出，这使得你的代码可读性更好，因为很容易看到你的输入和输出之间的映射。这对于<em class="kz">记忆</em>或<em class="kz">缓存</em>来说也是很棒的，因为如果你有相同的输入，你可以预测输出，所以不用每次都调用你的纯函数，你可以把你的输出保存在某个位置，然后在你需要的时候获取它。通过利用这一点，您可以真正优化您的应用程序。</p></div><div class="ab cl nq nr hr ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ig ih ii ij ik"><h2 id="2746" class="mr lb in bd lc ms mt dn lg mu mv dp lk jv mw mx lo jz my mz ls kd na nb lw nc bi translated">2.副作用。</h2><p id="57dd" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">好了，现在我们理解了<em class="kz">相同输入，相同输出</em>的概念，让我们仔细看看副作用是什么。JavaScript中的这个术语指的是可以改变应用程序外部状态的函数的概念，这意味着函数可以改变应用程序中不直接驻留在同一方法中的部分或值。</p><p id="f567" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在两种常见情况下，函数会产生副作用。</p><h2 id="f2ae" class="mr lb in bd lc ms mt dn lg mu mv dp lk jv mw mx lo jz my mz ls kd na nb lw nc bi translated">2 .改变外部范围:</h2><p id="0b03" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">第一个是函数可以进入它的外部作用域并直接改变那些外部变量的值。</p><p id="a8fa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们举一个这个场景的例子:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="57eb" class="mr lb in ne b gy ni nj l nk nl">const show = {<br/>  title: 'One peace',<br/>  episodes: 120,<br/>}</span><span id="3077" class="mr lb in ne b gy np nj l nk nl">const watchNextEpisode = () =&gt; {<br/>  show.episodes = show.episodes +1;<br/>  return show.episodes;<br/>}</span><span id="9f86" class="mr lb in ne b gy np nj l nk nl">console.log(watchNextEpisode);<br/>// 121<br/>console.log(watchNextEpisode);<br/>// 122</span></pre><p id="72df" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的方法产生了一个副作用，因为它在每次<code class="fe nm nn no ne b">show</code>对象中的<code class="fe nm nn no ne b">episodes</code>的数量改变时都会改变。</p><h2 id="88ad" class="mr lb in bd lc ms mt dn lg mu mv dp lk jv mw mx lo jz my mz ls kd na nb lw nc bi translated">2.b改变方法参数:</h2><p id="0586" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">在这种情况下，方法直接改变它的参数</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="3158" class="mr lb in ne b gy ni nj l nk nl">const comedies = ['The Office', 'House', 'Comunity'];</span><span id="cc27" class="mr lb in ne b gy np nj l nk nl">const appendShow = (shows, newShow) =&gt; {<br/>  shows.push(newShow);<br/>  return shows;<br/>}</span><span id="b79f" class="mr lb in ne b gy np nj l nk nl">const shows = appendShow(comedies, '30 Rock');</span><span id="582f" class="mr lb in ne b gy np nj l nk nl">console.log(shows);<br/>// ['The Office', 'House', 'Comunity', '30 Rock'];</span><span id="dc80" class="mr lb in ne b gy np nj l nk nl">console.log(comedies);<br/>// ['The Office', 'House', 'Comunity', '30 Rock'];</span></pre><p id="e3be" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的副作用发生在将<code class="fe nm nn no ne b">newShow</code>字符串推送到<code class="fe nm nn no ne b">shows</code>数组参数时，该参数是对<code class="fe nm nn no ne b">comedies</code>数组的引用。</p><p id="acfa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当有些人不清楚传递给该方法的原始参数将被更改时，就会出现问题。</p><p id="2023" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了避免这种情况，让我们仔细看看这个代码块:</p><pre class="kj kk kl km gt nd ne nf ng aw nh bi"><span id="2700" class="mr lb in ne b gy ni nj l nk nl">const comedies = ['The Office', 'House', 'Comunity'];</span><span id="ca13" class="mr lb in ne b gy np nj l nk nl">const appendShow = (shows, newShow) =&gt; {<br/>  return [...shows, newShow];<br/>}</span><span id="57b0" class="mr lb in ne b gy np nj l nk nl">const shows = appendShow(comedies, '30 Rock');</span><span id="6018" class="mr lb in ne b gy np nj l nk nl">console.log(shows);<br/>// ['The Office', 'House', 'Comunity', '30 Rock'];</span><span id="83eb" class="mr lb in ne b gy np nj l nk nl">console.log(comedies);<br/>// ['The Office', 'House', 'Comunity'];      =]</span></pre><p id="51dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，不是直接传递给参数<code class="fe nm nn no ne b">shows</code>，而是追加字符串<code class="fe nm nn no ne b">newShow</code>，然后返回新的<em class="kz">数组。</em></p></div><div class="ab cl nq nr hr ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ig ih ii ij ik"><p id="6439" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在某些情况下，纯功能和副作用可能真的很明显，可以很好地识别，但有时却不是。所以，就像你学习JavaScript过程中的其他事情一样，你需要花一些时间来训练自己识别一个纯函数是什么样的，或者副作用是什么样的，但是我希望这篇文章是一个很好的起点。</p></div><div class="ab cl nq nr hr ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ig ih ii ij ik"><h1 id="6498" class="la lb in bd lc ld nx lf lg lh ny lj lk ll nz ln lo lp oa lr ls lt ob lv lw lx bi translated">关于我</h1><p id="7cc4" class="pw-post-body-paragraph jk jl in jm b jn ly jp jq jr lz jt ju jv ma jx jy jz mb kb kc kd mc kf kg kh ig bi translated">一名自动化工程师，一名Web开发人员，一名数据科学爱好者，有时也是一名博客作者。总是在寻找新的挑战，所以请在LinkedIn上关注我，不要犹豫就任何问题联系我。</p></div></div>    
</body>
</html>