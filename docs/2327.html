<html>
<head>
<title>Using TypeScript — Generic Collections and Index Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript泛型集合和索引类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-typescript-generic-collections-and-index-types-48aef82c9162?source=collection_archive---------2-----------------------#2020-06-13">https://javascript.plainenglish.io/using-typescript-generic-collections-and-index-types-48aef82c9162?source=collection_archive---------2-----------------------#2020-06-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c9cc0f6901d3e635838aed7bf5f7b228.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*t39Bfkslq3rgVtFw"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@evelynnnnn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Evelyn</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="cae0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript是JavaScript的自然扩展，在许多项目中取代了JavaScript。</p><p id="cc57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，并不是每个人都知道它实际上是如何工作的。</p><p id="ec06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何在TypeScript中扩展泛型集合和索引类型。</p><h1 id="6f5e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用泛型集合</h1><p id="4e6c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript提供了各种JavaScript集合的通用版本。</p><p id="78cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们采用类型参数来限制可以用它们填充的数据类型。</p><p id="bbff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Map&lt;K, V&gt;</code>是一个JavaScript映射，键被限制为类型<code class="fe me mf mg mh b">K</code>，值被限制为类型<code class="fe me mf mg mh b">V</code>。</p><p id="ab6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">ReadonlyMap&lt;K, V&gt;</code>不能修改的地图。</p><p id="e81c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Set&lt;T&gt;</code>是值类型为<code class="fe me mf mg mh b">T</code>的集合。</p><p id="80d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">ReadonlySet&lt;T&gt;</code>是不能修改的集合。</p><p id="3153" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下内容来定义地图:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f9b9" class="mq lc iq mh b gy mr ms l mt mu">const map: Map&lt;string, number&gt; = new Map([["foo", 1], ["bar", 2]]);</span></pre><p id="903b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入字符串和值，如果我们不这样做，将从TypeScript编译器得到错误。</p><h1 id="4775" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通用迭代器</h1><p id="5f15" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript还为我们提供了迭代器的通用版本。</p><p id="526d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Iterator&lt;T&gt;</code>是一个描述迭代器的接口，迭代器的<code class="fe me mf mg mh b">next</code>方法返回<code class="fe me mf mg mh b">IteratorResult&lt;T&gt;</code>对象。</p><p id="9277" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">IteratorResult&lt;T&gt;</code>描述了由具有<code class="fe me mf mg mh b">done</code>和<code class="fe me mf mg mh b">value</code>属性的迭代器产生的结果。</p><p id="fefd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Iterable&lt;T&gt;</code>定义一个具有<code class="fe me mf mg mh b">Symbol.iterator</code>属性并支持迭代的对象，</p><p id="bae9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">IterableIterator&lt;T&gt;</code>结合<code class="fe me mf mg mh b">Iterator&lt;T&gt;</code>和<code class="fe me mf mg mh b">Iterable&lt;T&gt;</code>接口描述具有<code class="fe me mf mg mh b">Symbol.iterator</code>属性的对象的接口，具有<code class="fe me mf mg mh b">next</code>和<code class="fe me mf mg mh b">result</code>属性。</p><p id="7d50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cc1a" class="mq lc iq mh b gy mr ms l mt mu">function* gen() {<br/>  yield 1;<br/>  yield 2;<br/>}</span><span id="1925" class="mq lc iq mh b gy mv ms l mt mu">const iterator: Iterator&lt;number&gt; = gen();</span></pre><p id="331e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们限制迭代器只能顺序返回数字。</p><p id="eb8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以创建一个iterable对象，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6055" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  *[Symbol.iterator]() {<br/>    yield 1;<br/>    yield 2;<br/>  }<br/>};</span><span id="123c" class="mq lc iq mh b gy mv ms l mt mu">const iteratable: Iterable&lt;number&gt; = obj;</span></pre><p id="fd8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以像其他任何可迭代对象一样，将它与spread操作符或for-of循环一起使用。</p><h1 id="56a6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建可迭代类</h1><p id="9527" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以像创建iterable对象一样创建一个iterable类。</p><p id="6e23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有<code class="fe me mf mg mh b">Symbol.iterator</code>方法，就像我们之前看到的iterable对象。</p><p id="0423" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a964" class="mq lc iq mh b gy mr ms l mt mu">class GenericIterable&lt;T&gt; implements Iterable&lt;T&gt; {<br/>  items: T[] = [];<br/>  constructor(...items: T[]) {<br/>    this.items = items;<br/>  }</span><span id="47b3" class="mq lc iq mh b gy mv ms l mt mu">  *[Symbol.iterator]() {<br/>    for (const i of this.items) {<br/>      yield i;<br/>    }<br/>  }<br/>}</span></pre><p id="de10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用自己的iterable类实现了<code class="fe me mf mg mh b">Iterable&lt;T&gt;</code>接口。</p><p id="0176" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只要它有<code class="fe me mf mg mh b">Symbo.iterator</code>方法并且是一个生成器函数，那么它就正确地实现了接口。</p><p id="9a8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ef98" class="mq lc iq mh b gy mr ms l mt mu">const itr: GenericIterable&lt;number&gt; = new GenericIterable&lt;number&gt;(1, 2, 3);</span></pre><h1 id="c31e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">索引类型</h1><p id="a9fa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">TypeScript有索引类型，我们可以用它来限制另一个对象的键的值。</p><p id="291c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="edfc" class="mq lc iq mh b gy mr ms l mt mu">function getProp&lt;T, K extends keyof T&gt;(item: T, keyname: K) {<br/>  console.log(item[keyname]);<br/>}</span></pre><p id="cbb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe me mf mg mh b">K</code>被限制为任何具有<code class="fe me mf mg mh b">T</code>类型和<code class="fe me mf mg mh b">keyof</code>关键字的键。</p><p id="8c46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f3f6" class="mq lc iq mh b gy mr ms l mt mu">interface Person {<br/>  name: string;<br/>}</span><span id="6bea" class="mq lc iq mh b gy mv ms l mt mu">const person: Person = { name: "joe" };<br/>getProp(person, "name");</span></pre><p id="4887" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有带<code class="fe me mf mg mh b">name</code>属性的<code class="fe me mf mg mh b">Person</code>接口，然后我们可以用用<code class="fe me mf mg mh b">Person</code>接口和字符串<code class="fe me mf mg mh b">'name'</code>创建的对象调用<code class="fe me mf mg mh b">getProp</code>。</p><p id="0267" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将第二个参数中的字符串替换为不在接口中的任何内容，我们将得到一个错误。</p><p id="eb37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以添加类型参数。</p><p id="5e14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9f8e" class="mq lc iq mh b gy mr ms l mt mu">getProp&lt;Person, "name"&gt;(person, "name");</span></pre><p id="bbaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这和我们没有它的时候是一样的。</p><p id="295c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们可以对类型进行更多的限制。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/1e14ebe9e650a5a62743b9e63c5cb1c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NTKzrGP0E5RQkSaA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@alysa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alysa Bajenaru</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="b55f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">索引存取运算符</h1><p id="a272" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在索引中使用<code class="fe me mf mg mh b">keyof</code>操作符。</p><p id="1da8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以获取所有属性的类型，并将其作为一个联合放入一个类型别名中。</p><p id="f197" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有接口<code class="fe me mf mg mh b">Person</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f72c" class="mq lc iq mh b gy mr ms l mt mu">interface Person {<br/>  name: string;<br/>  age: number;<br/>}</span></pre><p id="4421" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么如果我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="86a7" class="mq lc iq mh b gy mr ms l mt mu">type allTypes = Person[keyof Person];</span></pre><p id="1e97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">allTypes</code>就是<code class="fe me mf mg mh b">string | number</code>。</p><p id="cd14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5eee" class="mq lc iq mh b gy mr ms l mt mu">const foo: allTypes = 1;<br/>const bar: allTypes = "foo";</span></pre><p id="e1c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们看到的，我们可以指定一个字符串或一个数字。</p><h1 id="10f0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="6641" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">泛型集合类型内置于TypeScript中。</p><p id="2d19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有可迭代的类型，迭代器，映射，集合等等。</p><p id="8667" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一些类型可以获取其他类型成员的键。</p><h2 id="ce34" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="b85c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>