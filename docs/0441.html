<html>
<head>
<title>Svelte vs React: First impressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">苗条与反应:第一印象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/svelte-vs-react-first-impression-1ce5d3ee6889?source=collection_archive---------0-----------------------#2019-10-16">https://javascript.plainenglish.io/svelte-vs-react-first-impression-1ce5d3ee6889?source=collection_archive---------0-----------------------#2019-10-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/df86f05ad89e8838ffef70dd1c1dc6d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_uJb2fuCWjniWe2r"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@coffeegeek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Coffee Geek</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c103" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3年前，Rich Harris创建了一个名为Svelte的框架。对这个新框架最大的影响是它不适用于像ReactJS、VueJS或AngularJS这样的虚拟DOM。</p><p id="c7eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在Svelte和React中创建了完全相同的待办事项列表应用程序。我所指的不仅仅是它的功能或视觉性，而且我没有使用任何第三方库，也没有使用它们的内部API来管理一个工作的应用程序。</p><p id="6991" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的todo应用程序将有列表，添加和删除项目。每个项目都将存储在全局状态中。此外，还有一些组件将订阅全局存储，并在更改时显示当前值</p><blockquote class="ky kz la"><p id="14b3" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">Svelte和React源代码都在<a class="ae jz" href="https://github.com/muratcatal/svelte-vs-react-todolist" rel="noopener ugc nofollow" target="_blank"> github </a>上</p></blockquote><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lf"><img src="../Images/42c2a4eaf5fc953d6ae32a687c20592a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*tu3_hjnpehxepgiReL9spA.gif"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Todo list</figcaption></figure><h1 id="7b83" class="lk ll in bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">SvelteJS</h1><pre class="lg lh li lj gt mi mj mk ml aw mm bi"><span id="5627" class="mn ll in mj b gy mo mp l mq mr">$ npx degit sveltejs/template svelte-todo-list</span></pre><h2 id="cf44" class="mn ll in bd lm ms mt dn lq mu mv dp lu kl mw mx ly kp my mz mc kt na nb mg nc bi translated">Svelte简介</h2><ul class=""><li id="cd48" class="nd ne in kc b kd nf kh ng kl nh kp ni kt nj kx nk nl nm nn bi translated">在DOM上工作，没有虚拟DOM</li><li id="ef61" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">Svelte有文件。苗条的延伸</li><li id="baf4" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">用svelte文件编写的每个<style> </style>都是css范围的。</li><li id="1c5a" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">您可以使用它的内部存储API。不需要安装外部库</li><li id="b070" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">使用默认配置按汇总生成。但是，您也可以使用Parsel和Webpack。</li><li id="e0e4" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">您可以很容易地订阅任何变量，但是它有一些检测数组突变的方法。(这个我不喜欢)</li><li id="1f4a" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">你可以像写一个html文件一样，在svelte文件中写javascript、html和样式。(有细微差别)</li><li id="a6f8" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">您可以使用<strong class="kc io"> on: </strong>前缀访问DOM事件，例如，单击 ={} / &gt;上的&lt;按钮</li><li id="8e28" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">您不需要将回调从孩子传递给父母。您可以使用createEventDispatcher。</li><li id="0fb6" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">您以{#}开头，以{/}结尾，例如{#if}…{/if}</li></ul></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><h2 id="8b9b" class="mn ll in bd lm ms mt dn lq mu mv dp lu kl mw mx ly kp my mz mc kt na nb mg nc bi translated">ReactJS</h2><pre class="lg lh li lj gt mi mj mk ml aw mm bi"><span id="cfb1" class="mn ll in mj b gy mo mp l mq mr">$ npx create-react-app react-todo-list</span></pre><h2 id="cb74" class="mn ll in bd lm ms mt dn lq mu mv dp lu kl mw mx ly kp my mz mc kt na nb mg nc bi translated">关于ReactJS的简要信息</h2><ul class=""><li id="f622" class="nd ne in kc b kd nf kh ng kl nh kp ni kt nj kx nk nl nm nn bi translated">使用虚拟DOM</li><li id="870f" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">您可以使用React的内部全局状态管理，称为上下文API</li><li id="abac" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">您编写的是纯javascript，没有块元素语法可以像Svelte一样做出特殊反应(#if，#每个……)</li><li id="30ae" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">DOM事件只是javascript事件，所以您可以像使用纯javascript一样使用onClick<em class="lb">(click的standart DOM事件是onClick！但是，您的OnCLICK oNCLiCk也将由浏览器呈现。)</em></li><li id="3452" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">文件扩展名为。射流研究…</li></ul></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><h2 id="0221" class="mn ll in bd lm ms mt dn lq mu mv dp lu kl mw mx ly kp my mz mc kt na nb mg nc bi translated">一些代码比较</h2><p id="d097" class="pw-post-body-paragraph ka kb in kc b kd nf kf kg kh ng kj kk kl oa kn ko kp ob kr ks kt oc kv kw kx ig bi translated">让我们比较一下Svelte和reaction的一些要点。</p><h2 id="8a4a" class="mn ll in bd lm ms mt dn lq mu mv dp lu kl mw mx ly kp my mz mc kt na nb mg nc bi translated">App.svelte</h2><pre class="lg lh li lj gt mi mj mk ml aw mm bi"><span id="a2f0" class="mn ll in mj b gy mo mp l mq mr">&lt;script&gt;<br/>  import TodoHeader from "./TodoHeader.svelte";<br/>  import TodoList from "./TodoList.svelte";<br/>  import { itemStore } from "./store";<br/>&lt;/script&gt;</span><span id="2ff5" class="mn ll in mj b gy od mp l mq mr">&lt;style&gt;<br/>  main {<br/>    font-family: sans-serif;<br/>    text-align: center;<br/>  }<br/>&lt;/style&gt;</span><span id="07a5" class="mn ll in mj b gy od mp l mq mr">&lt;main&gt;<br/>  &lt;div&gt;Total item: {$itemStore.length}&lt;/div&gt;<br/>  &lt;TodoHeader /&gt;<br/>  &lt;TodoList /&gt;<br/>&lt;/main&gt;</span></pre><h2 id="4d5e" class="mn ll in bd lm ms mt dn lq mu mv dp lu kl mw mx ly kp my mz mc kt na nb mg nc bi translated">App.js</h2><pre class="lg lh li lj gt mi mj mk ml aw mm bi"><span id="823d" class="mn ll in mj b gy mo mp l mq mr">import React from 'react';<br/>import './App.css';<br/>import { TodoHeader } from './TodoHeader';<br/>import { TodoList } from './TodoList';<br/>import { TodoListProvider } from './store';<br/>import { Total } from './Total';</span><span id="2393" class="mn ll in mj b gy od mp l mq mr">function App() {<br/>  return (<br/>    &lt;TodoListProvider todoList={[]}&gt;<br/>      &lt;Total /&gt;<br/>      &lt;TodoHeader /&gt;<br/>      &lt;TodoList /&gt;<br/>    &lt;/TodoListProvider&gt;<br/>  );<br/>}</span><span id="698b" class="mn ll in mj b gy od mp l mq mr">export default App;</span></pre><p id="3d41" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">应用程序文件是这两个框架的入口点。两者之间没有太大的区别，它们都有要渲染的组件。<strong class="kc io"> <em class="lb">这里唯一的区别在于全局样式绑定</em> </strong>。在反应中，用于反应的包装组件。ContextAPI是所有子级的父级，而在Svelte中，不需要全局状态的包装器。</p></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><p id="b8b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">SVE te/store . js</p><pre class="lg lh li lj gt mi mj mk ml aw mm bi"><span id="0396" class="mn ll in mj b gy mo mp l mq mr">import { writable } from "svelte/store";</span><span id="8d6a" class="mn ll in mj b gy od mp l mq mr">const createItemStore = () =&gt; {<br/>    const { subscribe, update } = writable([]);</span><span id="4f82" class="mn ll in mj b gy od mp l mq mr">return {<br/>        subscribe,<br/>        addItem: newItem =&gt; update(items =&gt; {<br/>            if (!items.find(item =&gt; item === newItem)) {<br/>                items.push(newItem);<br/>            }<br/>            return items;<br/>        }),<br/>        removeItem: removedItem =&gt; update(items =&gt; {<br/>            const newItems = items.filter(item =&gt; item !== removedItem);<br/>            return newItems;<br/>        })<br/>    };<br/>};</span><span id="685c" class="mn ll in mj b gy od mp l mq mr">export const itemStore = createItemStore();</span></pre><p id="8367" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">reactor/store . js</p><pre class="lg lh li lj gt mi mj mk ml aw mm bi"><span id="c49c" class="mn ll in mj b gy mo mp l mq mr">import React, { useState } from 'react';</span><span id="edc0" class="mn ll in mj b gy od mp l mq mr">export const TodoListContext = React.createContext({});</span><span id="f45b" class="mn ll in mj b gy od mp l mq mr">export const TodoListProvider = ({ todoList, children }) =&gt; {<br/>    const [todos, setTodos] = useState(todoList);</span><span id="f15f" class="mn ll in mj b gy od mp l mq mr">const addItem = (item) =&gt; {<br/>        if (!todos || !todos.find(listItem =&gt; listItem === item)) {<br/>            setTodos([...todos, item])<br/>        }<br/>    };<br/>    const removeItem = (item) =&gt; {<br/>        setTodos(<br/>            todos.filter(listItem =&gt; listItem !== item)<br/>        )<br/>    };</span><span id="b03d" class="mn ll in mj b gy od mp l mq mr">return (<br/>        &lt;TodoListContext.Provider<br/>            value={{<br/>                todoList: todos,<br/>                addItem,<br/>                removeItem<br/>            }}<br/>        &gt;<br/>            {children}<br/>        &lt;/TodoListContext.Provider&gt;<br/>    )<br/>}</span><span id="598f" class="mn ll in mj b gy od mp l mq mr">export const TodoListConsumer = TodoListContext.Consumer;</span></pre><p id="ced0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这两家商店做同样的事情。它们都有改变存储数据的操作方法。然而，在React中使用上下文API和创建类似于Svelte的相同结构可能会有些痛苦。如上例所示，首先，我们从createContext创建了一个上下文，在我们的Provider中，我们必须使用钩子在本地存储值。在Svelte中事情更简单，你只需要创建一个可写的存储，初始化它的值，然后用它的动作返回你的值。</p></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><p id="10c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">苗条/丰满</p><pre class="lg lh li lj gt mi mj mk ml aw mm bi"><span id="04c5" class="mn ll in mj b gy mo mp l mq mr">&lt;script&gt;<br/>  import { itemStore } from "./store";<br/>  const handleRemoveItem = item =&gt; {<br/>    itemStore.removeItem(item);<br/>  };<br/>&lt;/script&gt;</span><span id="be5e" class="mn ll in mj b gy od mp l mq mr">&lt;style&gt;<br/>  ul {<br/>    list-style-type: none;<br/>  }<br/>&lt;/style&gt;</span><span id="c957" class="mn ll in mj b gy od mp l mq mr">&lt;ul&gt;<br/>  {#each $itemStore as item}<br/>    &lt;li&gt;<br/>      {item}<br/>      &lt;button on:click={() =&gt; handleRemoveItem(item)}&gt;Remote Item&lt;/button&gt;<br/>    &lt;/li&gt;<br/>  {/each}<br/>  {#if $itemStore.length === 0}<br/>    &lt;div&gt;There is not any item added. Please add one&lt;/div&gt;<br/>  {/if}<br/>&lt;/ul&gt;</span></pre><p id="45ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">反应/分解</p><pre class="lg lh li lj gt mi mj mk ml aw mm bi"><span id="ba44" class="mn ll in mj b gy mo mp l mq mr">import React, { useContext } from 'react';<br/>import { TodoListContext } from './store';</span><span id="71b2" class="mn ll in mj b gy od mp l mq mr">export const TodoList = () =&gt; {<br/>    const todoListContext = useContext(TodoListContext);<br/>    const handleRemove = (item) =&gt; {<br/>        todoListContext.removeItem(item);<br/>    }</span><span id="b5da" class="mn ll in mj b gy od mp l mq mr">const { todoList } = todoListContext;</span><span id="8596" class="mn ll in mj b gy od mp l mq mr">return (<br/>        &lt;ul&gt;<br/>            {todoList &amp;&amp; todoList.map(todoList =&gt; {<br/>                return (<br/>                    &lt;li&gt;<br/>                        {todoList}<br/>                        &lt;button onClick={handleRemove.bind(null, todoList)}&gt;Remote Item&lt;/button&gt;<br/>                    &lt;/li&gt;<br/>                )<br/>            })}<br/>            {(todoList.length === 0) &amp;&amp; (&lt;div&gt;There is not any item added. Please add one&lt;/div&gt;)}<br/>        &lt;/ul&gt;<br/>    )<br/>}</span></pre><p id="efcc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">迫使我编写第一个苗条应用程序的是在组件中使用条件和循环。我不喜欢在循环或条件中使用语法而不是纯javascript。但是，访问商店项目只需要导入，而不需要任何外部挂钩或层来访问全局存储，这是Svelte和React之间的关键区别。</p></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><p id="af81" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">苗条/肥胖的头</p><pre class="lg lh li lj gt mi mj mk ml aw mm bi"><span id="6dd3" class="mn ll in mj b gy mo mp l mq mr">&lt;script&gt;<br/>  import { onMount } from "svelte";<br/>  import { itemStore } from "./store";<br/>  let value;<br/>  onMount(() =&gt; {<br/>    value = "";<br/>  });<br/>  const handleAddItem = () =&gt; {<br/>    itemStore.addItem(value);<br/>    value = "";<br/>  };<br/>&lt;/script&gt;</span><span id="b6c1" class="mn ll in mj b gy od mp l mq mr">&lt;style&gt;<br/>  .disabled {<br/>    color: graytext;<br/>  }<br/>&lt;/style&gt;</span><span id="4d41" class="mn ll in mj b gy od mp l mq mr">&lt;input type="text" bind:value placeholder="Item name" /&gt;<br/>&lt;button on:click={handleAddItem} disabled={!value} class:disabled={!value}&gt;<br/>  Add Item<br/>&lt;/button&gt;</span></pre><p id="7f7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">反应/至主管</p><pre class="lg lh li lj gt mi mj mk ml aw mm bi"><span id="2159" class="mn ll in mj b gy mo mp l mq mr">import React, { useContext, useState } from 'react';<br/>import { TodoListContext } from './store';</span><span id="583d" class="mn ll in mj b gy od mp l mq mr">export const TodoHeader = () =&gt; {<br/>    const todoListStore = useContext(TodoListContext);<br/>    const [itemName, setItemName] = useState('')</span><span id="57e6" class="mn ll in mj b gy od mp l mq mr">const handleAddItem = (e) =&gt; {<br/>        e.preventDefault();<br/>        todoListStore.addItem(itemName);<br/>        setItemName('');<br/>    }</span><span id="3c1c" class="mn ll in mj b gy od mp l mq mr">return (<br/>        &lt;&gt;<br/>            &lt;input placeholder="Item name" type="text" value={itemName} onChange={(event) =&gt; setItemName(event.target.value.trim())} /&gt;<br/>            &lt;button onClick={handleAddItem} disabled={!itemName} className={!itemName &amp;&amp; 'disabled'}&gt;Add Item&lt;/button&gt;<br/>        &lt;/&gt;<br/>    )<br/>}</span></pre><p id="a0ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在Svelte中，您不需要将输入的值存储在外部状态中。Svelte使将关键字绑定到任何现有属性变得更加容易，它还有一个附加特性，即您可以使用反应性声明跟踪适当的更改，而无需为值(而不是数组)付出额外的努力。</p></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><h2 id="e18c" class="mn ll in bd lm ms mt dn lq mu mv dp lu kl mw mx ly kp my mz mc kt na nb mg nc bi translated">结果</h2><p id="e031" class="pw-post-body-paragraph ka kb in kc b kd nf kf kg kh ng kj kk kl oa kn ko kp ob kr ks kt oc kv kw kx ig bi translated">此外，让我们分享一些我在开发过程中遇到的关于构建过程、困难和便利的结果。</p><p id="e11a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我遵循完全相同的模式，同时开发两者。我没有使用任何外部库，只使用了内部API的两个框架支持。存在连接到全局状态的组件。有些组件订阅了全局状态变量。</p><h2 id="5e6a" class="mn ll in bd lm ms mt dn lq mu mv dp lu kl mw mx ly kp my mz mc kt na nb mg nc bi translated">我喜欢苗条的❤️</h2><ul class=""><li id="7691" class="nd ne in kc b kd nf kh ng kl nh kp ni kt nj kx nk nl nm nn bi translated">建筑真的很快。但这也可能是因为使用了Rollup作为捆绑器，我认为用Webpack测试捆绑也是不错的。</li><li id="d56c" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">同样，相对于React，包的大小确实很小。然而，这也可能是因为Rollup的树摇动性能。</li><li id="b45f" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">它的商店使用非常灵活。您可以在store中修改您的组件，并开始轻松地订阅或变更store值。❤️</li><li id="bdf4" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">我喜欢在一个组件中编写的所有样式都是作用域css。</li><li id="34f4" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">绑定一个条件样式有简单的语法，你不需要为类绑定创建一个逻辑。(<em class="lb">class:disabled =变量)</em></li></ul><h2 id="89de" class="mn ll in bd lm ms mt dn lq mu mv dp lu kl mw mx ly kp my mz mc kt na nb mg nc bi translated">我不喜欢苗条💔</h2><ul class=""><li id="3079" class="nd ne in kc b kd nf kh ng kl nh kp ni kt nj kx nk nl nm nn bi translated">我真的不喜欢在一个文件中编写模板，比如#each，#if。我不喜欢使用新的方法，因为我可以完全用JavaScript来完成。</li><li id="96e4" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">当你使用反应性声明来订阅一个变量变化时，Svelte不能检测数组上的突变。Svelte为这种情况提供了一些简单的方法。</li><li id="9073" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">一些开发人员可能喜欢在一个组件中编写模板，但这仍然是我不喜欢的。此外，这种方法导致使用我在第1项中提到的循环、条件等的模板。</li><li id="89ea" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">你应该给列表中的每一个条目一个唯一的id，否则每当你想对列表中的条目进行操作时，一个错误的条目就会被影响。</li><li id="acdb" class="nd ne in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated">DOM事件中的使用风格，比如<em class="lb"> on:click </em>是我不喜欢的事情之一。我更喜欢使用onClick作为普通的DOM事件。<em class="lb">(点击的标准DOM事件是onclick！然而，您的OnCLICK oNCLiCk也将由浏览器呈现。)</em></li></ul><h2 id="06b3" class="mn ll in bd lm ms mt dn lq mu mv dp lu kl mw mx ly kp my mz mc kt na nb mg nc bi translated">生产构建比较</h2><p id="f7d7" class="pw-post-body-paragraph ka kb in kc b kd nf kf kg kh ng kj kk kl oa kn ko kp ob kr ks kt oc kv kw kx ig bi translated">SvelteJS在默认设置中使用Rollup和ReactJS Webpack，我没有接触过它们的配置，它们都有默认配置。苗条的建造时间是<strong class="kc io">1.40秒</strong>，而React建造时间是<strong class="kc io">5.49秒</strong>。苗条赢了！❤️</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oe"><img src="../Images/af148b59160eded61885a4016a317796.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B3qoFX4_7GL8b8tk7ZII7g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Build Times</figcaption></figure><p id="beac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这两个应用程序都是由服务npm包提供的。Svelte将其包导出到公共文件夹，而react应用程序将它们放入构建文件夹。</p><pre class="lg lh li lj gt mi mj mk ml aw mm bi"><span id="c442" class="mn ll in mj b gy mo mp l mq mr">serve -s build  // this is for react app<br/>serve -s public // this is for svelte app</span></pre><p id="4ccb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我检查网络选项卡时，Svelte的包在gzip之后只有2.9 KB，而React的包在gzip之后只有42.1 KB。这里再次苗条的w️️ins与它的捆绑大小在生产❤️</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi of"><img src="../Images/6060639ec890587aa194d53f542aa32e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXVrLdeuUspHq7tcCaFhgA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Svelte vs React in production build instead of size</figcaption></figure></div><div class="ab cl nt nu hr nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ig ih ii ij ik"><p id="71aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lb">如果你喜欢我的文章，可以鼓掌支持我，关注我。<br/>我也在</em><a class="ae jz" href="http://www.linkedin.com/in/muratcatal" rel="noopener ugc nofollow" target="_blank"><em class="lb">LinkedIn</em></a><em class="lb">上，欢迎所有邀请。</em></p></div></div>    
</body>
</html>