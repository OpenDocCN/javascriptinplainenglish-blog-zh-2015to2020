<html>
<head>
<title>I created the exact same app in React and Vue. Here are the differences. [2020 Edition]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在React和Vue中创建了完全相同的应用程序。以下是不同之处。[2020版]</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2020-edition-36657f5aafdc?source=collection_archive---------0-----------------------#2020-08-09">https://javascript.plainenglish.io/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2020-edition-36657f5aafdc?source=collection_archive---------0-----------------------#2020-08-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="fc9d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">React vs Vue:现在有了React Hooks Vue 3合成API！</h2></div><h1 id="fcf3" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">React vs Vue:传奇继续</h1><p id="7e25" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">几年前，我决定尝试在React和Vue中构建一个相当标准的Do App。这两个应用程序都是使用默认cli构建的(react使用create-react-app，vue使用vue-cli)。我的目标是写一些不偏不倚的东西，并简单地提供如何使用这两种技术执行某些任务的快照。</p><p id="bd26" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">当React钩子发布时，我用一个'<a class="ae lv" href="https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2019-edition-42ba2cab9e56" rel="noopener"> 2019版</a>'跟踪了原始文章，它用函数钩子替换了类组件的使用。<strong class="kw io">随着Vue版本3及其组合API的发布，现在是时候再次用‘2020版’更新这篇文章了。</strong></p><h1 id="0021" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">让我们快速看一下这两款应用的外观:</h1><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi lw"><img src="../Images/fb43cb8085c808f7acc45bba31237801.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1kULfPOxq7V67gOy.png"/></div></div></figure><p id="a54e" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">两个应用程序的CSS代码完全相同，但是它们的位置不同。记住这一点，接下来让我们看看这两个应用程序的文件结构:</p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mi"><img src="../Images/8a36ea11cbc103cea5e8078eee30bd9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*kNTmE--MjjoFrMiO.png"/></div></div></figure><p id="6314" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">你会发现它们的结构也很相似。到目前为止，关键的区别是React应用程序有两个CSS文件，而Vue应用程序没有。这样做的原因是因为create-react-app创建其默认react组件，并为其样式创建单独的CSS文件，而Vue CLI创建包含其默认Vue组件的HTML、CSS和JavaScript的单个文件。</p><p id="47c5" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">最终，它们都实现了同样的事情，没有什么可以说你不能继续在React或Vue中以不同的方式构建你的文件。真的归结为个人喜好。您将会听到来自开发社区的关于CSS应该如何构建的大量讨论，特别是关于React，因为有许多CSS-in-JS解决方案，如styled-components和emotion。顺便说一下，CSS-in-JS就是字面上的意思。虽然这些都很有用，但现在，我们将只遵循两个CLI中的结构。</p><p id="2d4b" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">但是在我们继续之前，让我们快速看一下典型的Vue和React组件是什么样子的:</p><p id="49ff" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">一个典型的React文件:</strong></p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mj"><img src="../Images/34583fecb609cd32909ab422339422ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3L0xvtpLx0ALMQuq.png"/></div></div></figure><p id="8bc9" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">一个典型的Vue文件:</strong></p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mk"><img src="../Images/8d2c6647d8e720c030076238b75723f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DGUq2Lz2SnoaqKkU.png"/></div></div></figure><p id="aee8" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">现在，让我们进入本质的细节！</p><h1 id="2b60" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">我们如何改变数据？</h1><p id="49e2" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">但是首先，我们所说的“变异数据”是什么意思？听起来有点专业，不是吗？它基本上只是意味着改变我们已经存储的数据。所以，如果我们想把一个人的名字从约翰改成马克，我们就要“改变数据”。所以这就是React和Vue的关键区别所在。Vue本质上创建了一个数据对象，其中的数据可以自由更新，而React通过所谓的状态挂钩来处理这个问题。</p><p id="454c" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">让我们看看下图中两者的设置，然后我们将解释接下来会发生什么:</p><p id="d3ee" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io">反应状态:</strong></p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi ml"><img src="../Images/9b4a6f0ed2ea2a41232babe0502cf0f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*D7krtJMFqKPVVZBB.png"/></div></div></figure><p id="1f3d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><strong class="kw io"> Vue状态:</strong></p><figure class="lx ly lz ma gt mb gh gi paragraph-image"><div role="button" tabindex="0" class="mc md di me bf mf"><div class="gh gi mm"><img src="../Images/f28dce7e00b4dda2b12a1251c23815c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4EopBjBjZDnqWMfj.png"/></div></div></figure><p id="879b" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">因此，您可以看到，我们将相同的数据传递给了两者，但结构略有不同。</p><p id="5249" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">使用React——或者至少从2019年开始——我们通常会通过一系列挂钩来处理状态。如果你以前没有见过这种类型的概念，这些可能看起来有点奇怪。基本上，它的工作方式如下:</p><p id="1c97" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">假设我们想要创建一个待办事项列表。我们可能需要创建一个名为list的变量，它可能需要一个字符串或者对象的数组(如果我们想给每个todo字符串一个ID或者一些其他的东西。我们可以通过写<code class="fe mn mo mp mq b">const [list, setList] = useState([])</code>来设置它。这里我们使用了React称之为钩子的东西——称为<code class="fe mn mo mp mq b">useState</code>。这基本上让我们在组件中保持本地状态。</p><p id="6cdd" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">另外，你可能已经注意到我们在<code class="fe mn mo mp mq b">useState()</code>中传递了一个空数组<code class="fe mn mo mp mq b">[]</code>。我们在里面放的是我们希望list最初被设置的值，在我们的例子中，我们希望它是一个空数组。然而，你会从上面的图片中看到，我们在数组内部传递了一些数据，这些数据最终成为list的初始化数据。想知道setList是干什么的吗？稍后会有更多关于这个的内容！</p><p id="8008" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在Vue中，您通常会将组件的所有可变数据放在一个<code class="fe mn mo mp mq b">setup()</code>函数中，该函数返回一个包含您想要公开的数据和函数的对象(这基本上意味着您希望能够在您的应用程序中使用的东西)。您会注意到，我们应用程序中的每个状态数据(也就是我们希望能够变异的数据)都被包装在一个<code class="fe mn mo mp mq b">ref()</code>函数中。这个<code class="fe mn mo mp mq b">ref()</code>函数是我们从Vue导入的，它使得我们的应用程序可以在任何数据发生变化/更新时进行更新。简而言之，如果您想在Vue中创建可变数据，可以为<code class="fe mn mo mp mq b">ref()</code>函数分配一个变量，并将任何默认数据放入其中。</p><h1 id="7b29" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">那么，我们如何在应用程序中引用可变数据呢？</h1><p id="8e26" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">好吧，假设我们有一些名为name的数据，它被赋予了一个值<code class="fe mn mo mp mq b">Sunil</code>。</p><p id="654a" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在React中，由于我们有用<code class="fe mn mo mp mq b">useState()</code>创建的更小的状态片段，很可能我们会按照<code class="fe mn mo mp mq b">const [name, setName] = useState('Sunil')</code>的思路创建一些东西。在我们的应用程序中，我们可以通过简单地调用名字来引用相同的数据。现在这里的关键区别是，我们不能简单地写<code class="fe mn mo mp mq b">name = 'John'</code>，因为React有适当的限制，以防止这种容易的，无忧无虑的变异。所以在React中，我们会写<code class="fe mn mo mp mq b">setName('John')</code>。这就是setName位发挥作用的地方。基本上，在<code class="fe mn mo mp mq b">const [name, setName] = useState('Sunil')</code>中，它创建了两个变量，一个变成了<code class="fe mn mo mp mq b">const name = 'Sunil'</code>，而第二个<code class="fe mn mo mp mq b">const setName</code>被赋予了一个函数，使得name可以用一个新值重新创建。</p><p id="c7c2" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在Vue中，这将位于<code class="fe mn mo mp mq b">setup()</code>函数内部，并被称为<code class="fe mn mo mp mq b">const name = ref(‘Sunil')</code>。在我们的应用程序中，我们将通过调用<code class="fe mn mo mp mq b">name.value</code>来引用它。使用Vue，如果我们想使用在<code class="fe mn mo mp mq b">ref()</code>函数中创建的值，我们在变量上寻找<code class="fe mn mo mp mq b">.value</code>，而不是简单地调用变量。换句话说，如果我们想要保存状态的变量的值，我们寻找<code class="fe mn mo mp mq b">name.value</code>，<em class="mr">而不是</em> <code class="fe mn mo mp mq b">name</code>。如果你想更新<code class="fe mn mo mp mq b">name</code>的值，你可以通过更新<code class="fe mn mo mp mq b">name.value</code>来实现。比如说，我想把我的名字从Sunil改成John。我会通过写<code class="fe mn mo mp mq b">name.value = "John"</code>来做到这一点。我不确定我被叫做约翰是什么感觉，但是嘿，事情发生了！😅</p><p id="1571" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">Effectively React和Vue在这里做着同样的事情，那就是创建可以更新的数据。默认情况下，每当一个<code class="fe mn mo mp mq b">ref()</code>函数中的一段数据被更新时，Vue本质上组合了它自己版本的name和setName。React要求您调用setName()并在其中包含值，以便更新状态，Vue假设如果您试图更新数据对象中的值，您会希望这样做。那么，为什么React还要费心将值从函数中分离出来，为什么还需要<code class="fe mn mo mp mq b">useState()</code>？本质上，React希望能够在状态改变时重新运行某些生命周期挂钩。在我们的例子中，如果调用了<code class="fe mn mo mp mq b">setName()</code>，React将知道一些状态已经改变，因此可以运行那些生命周期挂钩。如果您直接改变状态，React将不得不做更多的工作来跟踪变化以及运行什么生命周期挂钩等等。</p><p id="6662" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">现在我们已经有了一些变化，让我们看看如何在我们的待办事项应用程序中添加新的项目，从而进入本质。</p><h1 id="e4ed" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">我们如何创建新的待办事项？</h1><h2 id="ce3c" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">反应:</h2><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="acb8" class="ms kd in mq b gy ni nj l nk nl">const createNewToDoItem = () =&gt; {<br/>    const newId = generateId();<br/>    const newToDo = { id: newId, text: toDo };<br/>    setList([...list, newToDo]);<br/>    setToDo("");<br/>};</span></pre><h2 id="f5a5" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">React是怎么做到的？</h2><p id="9887" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在React中，我们的输入字段有一个名为<strong class="kw io"> value的属性。</strong>每当这个值通过所谓的<strong class="kw io"> onChange事件监听器</strong>发生变化时，这个值就会自动更新。JSX(基本上是HTML的一种变体)如下所示:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="5f45" class="ms kd in mq b gy ni nj l nk nl">&lt;input<br/>    type="text"<br/>    placeholder="I need to..."<br/>    value={toDo}<br/>    onChange={handleInput}<br/>    onKeyPress={handleKeyPress}<br/>/&gt;</span></pre><p id="bcc1" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">所以每次值改变时，它更新状态。handleInput函数如下所示:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="21e3" class="ms kd in mq b gy ni nj l nk nl">const handleInput = (e) =&gt; {<br/>    setToDo(e.target.value);<br/>};</span></pre><p id="6fed" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">现在，每当用户按下页面上的<strong class="kw io"> + </strong>按钮来添加新项目时，就会触发<strong class="kw io">createnewdoitem</strong>功能。让我们再来看一下这个函数，以分解正在发生的事情:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="663a" class="ms kd in mq b gy ni nj l nk nl">const createNewToDoItem = () =&gt; {<br/>    const newId = generateId();<br/>    const newToDo = { id: newId, text: toDo };<br/>    setList([...list, newToDo]);<br/>    setToDo("");<br/>};</span></pre><p id="5c62" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">基本上，<code class="fe mn mo mp mq b">newId</code>函数基本上是创建一个新的ID，我们将赋予新的<code class="fe mn mo mp mq b">toDo</code>项目。<code class="fe mn mo mp mq b">newToDo</code>变量是一个对象，它具有一个id键，该键的值来自newId。它还有一个<code class="fe mn mo mp mq b">text</code>键，将来自<code class="fe mn mo mp mq b">toDo</code>的值作为它的值。这与输入值改变时更新的<code class="fe mn mo mp mq b">toDo</code>相同。</p><p id="2fc1" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">然后我们运行setList函数，并传入一个数组，该数组包含我们的整个<code class="fe mn mo mp mq b">list</code>以及新创建的<code class="fe mn mo mp mq b">newToDo</code>。</p><p id="fb88" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">如果<code class="fe mn mo mp mq b">...list</code>，位看起来很奇怪，那么开头的三个点就是所谓的spread运算符，它基本上传递来自<code class="fe mn mo mp mq b">list</code>的所有值，但作为单独的项，而不是简单地将整个项数组作为数组传递。迷茫？如果是这样，我强烈推荐阅读spread，因为它很棒！</p><p id="36e7" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">总之，最后我们运行<code class="fe mn mo mp mq b">setToDo()</code>，传入一个空字符串。这使得我们的输入值为空，准备好输入新的toDos。</p><h2 id="4535" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">Vue:</h2><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="6830" class="ms kd in mq b gy ni nj l nk nl">function createNewToDoItem() {<br/>    const newId = generateId();<br/>    list.value.push({ id: newId, text: todo.value });<br/>    todo.value = "";<br/>}</span></pre><h2 id="560d" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">Vue是怎么做到的？</h2><p id="370c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在Vue中，我们的<strong class="kw io">输入</strong>字段上有一个名为<strong class="kw io"> v-model </strong>的句柄。这允许我们做一些被称为<strong class="kw io">双向绑定</strong>的事情。让我们快速查看一下我们的输入字段，然后我们将解释这是怎么回事:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="c457" class="ms kd in mq b gy ni nj l nk nl">&lt;input<br/>    type="text"<br/>    placeholder="I need to..."<br/>    v-model="todo"<br/>    v-on:keyup.enter="createNewToDoItem"<br/>/&gt;</span></pre><p id="c474" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">V-Model将该字段的输入与我们在<code class="fe mn mo mp mq b">setup()</code>函数顶部创建的一个变量联系起来，然后在我们返回的对象内部公开为一个键。到目前为止，我们还没有涉及从对象返回的内容，所以为了您的信息，这里是我们从<strong class="kw io"> ToDo.vue </strong>中的<code class="fe mn mo mp mq b">setup()</code>函数返回的内容:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="d767" class="ms kd in mq b gy ni nj l nk nl">return {<br/>    list,<br/>    todo,<br/>    showError,<br/>    generateId,<br/>    createNewToDoItem,<br/>    onDeleteItem,<br/>    displayError<br/>};</span></pre><p id="582b" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在这里，<code class="fe mn mo mp mq b">list</code>、<code class="fe mn mo mp mq b">todo</code>和<code class="fe mn mo mp mq b">showError</code>是我们的有状态值，而其他的都是我们希望能够在应用程序的其他地方调用的函数。好了，从我们的切线回来，当页面加载时，我们将<code class="fe mn mo mp mq b">todo</code>设置为空字符串，如下:<code class="fe mn mo mp mq b">const todo = ref("")</code>。如果这里已经有一些数据，比如<code class="fe mn mo mp mq b">const todo = ref("add some text here"):</code>，我们的输入字段将加载<em class="mr">在这里添加一些文本</em>已经在输入字段内。无论如何，回到空字符串，我们在输入域中输入的任何文本都会被绑定到<code class="fe mn mo mp mq b">todo.value</code>。这实际上是双向绑定——输入字段可以更新ref()值，ref()值可以更新输入字段。</p><p id="6018" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">所以回头看看前面的<code class="fe mn mo mp mq b">createNewToDoItem()</code>代码块，我们看到我们将<code class="fe mn mo mp mq b">todo.value</code>的内容推入<code class="fe mn mo mp mq b">list</code>数组——通过将<code class="fe mn mo mp mq b">todo.value</code>推入<code class="fe mn mo mp mq b">list.value</code>——然后将<code class="fe mn mo mp mq b">todo.value</code>更新为一个空字符串。</p><p id="7451" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">我们还使用了与React示例中相同的newId()函数。</p><h1 id="3c4c" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">我们如何从列表中删除？</h1><h2 id="724c" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">反应:</h2><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="1041" class="ms kd in mq b gy ni nj l nk nl">const deleteItem = (id) =&gt; {<br/>    setList(list.filter((item) =&gt; item.id !== id));<br/>};</span></pre><h2 id="4825" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">React是怎么做到的？</h2><p id="c12a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">因此，虽然deleteItem()函数位于<strong class="kw io"> ToDo.js </strong>中，但我可以很容易地在<strong class="kw io"> ToDoItem.js </strong>中引用它，首先将<strong class="kw io"> deleteItem() </strong>函数作为一个属性传递给:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="a14d" class="ms kd in mq b gy ni nj l nk nl">&lt;ToDoItem key={item.id} item={item} deleteItem={deleteItem} /&gt;</span></pre><p id="1f1c" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">这首先将功能向下传递，使孩子可以访问它。然后，在<strong class="kw io"> ToDoItem </strong>组件中，我们执行以下操作:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="3d96" class="ms kd in mq b gy ni nj l nk nl">&lt;button className="ToDoItem-Delete" onClick={() =&gt; deleteItem(item.id)}&gt;<br/>    -<br/>&lt;/button&gt;</span></pre><p id="77bd" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">要引用父组件中的函数，我只需引用<strong class="kw io"> props.deleteItem </strong>。现在你可能已经注意到，在代码示例中，我们只写了deleteItem而不是props.deleteItem。这是因为我们使用了一种称为<strong class="kw io">析构</strong>的技术，这种技术允许我们获取部分<strong class="kw io"> props </strong>对象并将它们赋给变量。所以在我们的<strong class="kw io"> ToDoItem.js </strong>文件中，我们有如下内容:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="ddc1" class="ms kd in mq b gy ni nj l nk nl">const ToDoItem = (props) =&gt; {<br/>    const { item, deleteItem } = props;<br/>}</span></pre><p id="55be" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">这为我们创建了两个变量，一个叫做item，它被赋予与props.item相同的值，另一个叫做deleteItem，它被赋予来自props.deleteItem的值。我们可以通过简单地使用props.item和props.deleteItem来避免整个析构过程，但是我认为这是值得一提的！</p><h2 id="a941" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">Vue:</h2><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="d883" class="ms kd in mq b gy ni nj l nk nl">function onDeleteItem(id) {<br/>    list.value = list.value.filter(item =&gt; item.id !== id);<br/>}</span></pre><h2 id="be51" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">Vue是怎么做到的？</h2><p id="acb9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在Vue中需要一种稍微不同的方法。我们必须做三件事:</p><p id="a119" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">首先，在我们想要调用函数的元素上:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="7fe4" class="ms kd in mq b gy ni nj l nk nl">&lt;button class="ToDoItem-Delete" @click="deleteItem(item.id)"&gt;<br/>    -<br/>&lt;/button&gt;</span></pre><p id="f107" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">然后我们必须创建一个emit函数作为子组件内部的方法(在本例中是<strong class="kw io"> ToDoItem.vue </strong>)，如下所示:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="5ecb" class="ms kd in mq b gy ni nj l nk nl">function deleteItem(id) {<br/>    emit("delete", id);<br/>}</span></pre><p id="625d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">与此同时，你会注意到当我们在<strong class="kw io"> ToDo.vue </strong>内添加<strong class="kw io"> ToDoItem.vue </strong>时，我们实际上引用了一个<strong class="kw io">函数</strong>:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="699f" class="ms kd in mq b gy ni nj l nk nl">&lt;ToDoItem v-for="item in list" :item="item" @delete="onDeleteItem" :key="item.id" /&gt;</span></pre><p id="f91f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">这就是所谓的自定义事件侦听器。它监听任何使用字符串“delete”触发发出的情况。如果它听到这个消息，就会触发一个名为<strong class="kw io"> onDeleteItem </strong>的函数。该函数位于<strong class="kw io"> ToDo.vue </strong>中，而不是<strong class="kw io"> ToDoItem.vue </strong>中。如前所述，这个函数只是从<code class="fe mn mo mp mq b">list.value</code>数组中过滤出<code class="fe mn mo mp mq b">id</code>。</p><p id="a23f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">这里值得注意的是，在Vue示例中，我可以简单地在<code class="fe mn mo mp mq b">@click</code>侦听器中编写<code class="fe mn mo mp mq b">$emit</code>部分，如下所示:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="a8fb" class="ms kd in mq b gy ni nj l nk nl">&lt;button class="ToDoItem-Delete" @click="emit("delete", item.id)"&gt;<br/>    -<br/>&lt;/button&gt;</span></pre><p id="ca5d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">这会将步骤数从3个减少到2个，这完全取决于个人偏好。</p><p id="6cee" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">简而言之，React中的子组件将通过<strong class="kw io"> props </strong>访问父函数(假设您正在向下传递props，这是相当标准的做法，您将在其他React示例中多次遇到这种情况)，而在Vue中，您必须从子组件发出事件，这些事件通常将在父组件中收集。</p><h1 id="fb24" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">我们如何传递事件侦听器？</h1><h2 id="f7c6" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">反应:</h2><p id="d097" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">诸如点击事件等简单事件的事件侦听器是直接的。以下是我们如何为创建新ToDo项目的按钮创建click事件的示例:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="27a1" class="ms kd in mq b gy ni nj l nk nl">&lt;button className="ToDo-Add" onClick={createNewToDoItem}&gt;<br/>    +<br/>&lt;/button&gt;</span></pre><p id="04a3" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">这里非常简单，看起来很像我们用普通JS处理内嵌onClick的方式。正如在Vue一节中提到的，每当按下enter按钮时，设置一个事件监听器来处理它要花一点时间。这实际上要求输入标记处理onKeyPress事件，如下所示:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="4dc0" class="ms kd in mq b gy ni nj l nk nl">&lt;input<br/>    type="text"<br/>    placeholder="I need to..."<br/>    value={toDo}<br/>    onChange={handleInput}<br/>    onKeyPress={handleKeyPress}<br/>/&gt;</span></pre><p id="d430" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">每当该函数识别出“输入”键被按下时，就会触发<strong class="kw io">createnewdoitem</strong>函数，如下所示:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="e4cb" class="ms kd in mq b gy ni nj l nk nl">const handleKeyPress = (e) =&gt; {<br/>    if (e.key === "Enter") {<br/>    createNewToDoItem();<br/>    }<br/>};</span></pre><h2 id="30bf" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">Vue:</h2><p id="87a7" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在Vue中，这是非常直接的。我们简单地使用<code class="fe mn mo mp mq b">@</code>符号，然后是我们想要做的事件监听器的类型。例如，要添加一个点击事件监听器，我们可以编写如下代码:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="1891" class="ms kd in mq b gy ni nj l nk nl">&lt;button class="ToDo-Add" @click="createNewToDoItem"&gt;<br/>    +<br/>&lt;/button&gt;</span></pre><p id="93a3" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">注:<code class="fe mn mo mp mq b">@click</code>其实是<code class="fe mn mo mp mq b">v-on:click</code>的简写。Vue事件侦听器最酷的一点是，您还可以将许多东西链接到它们上面，比如。once防止事件侦听器被触发多次。在编写处理击键的特定事件侦听器时，也有许多快捷方式。我发现，每当按下enter按钮时，在React中创建一个事件侦听器来创建新的ToDo项会花费相当长的时间。在Vue中，我可以简单地写下:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="da7a" class="ms kd in mq b gy ni nj l nk nl">&lt;input type=”text” v-on:keyup.enter=”createNewToDoItem”/&gt;</span></pre><h1 id="1a05" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">我们如何将数据传递给子组件？</h1><h2 id="ab61" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">反应:</h2><p id="a85c" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在react中，我们在创建子组件时将道具传递给子组件。比如:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="423a" class="ms kd in mq b gy ni nj l nk nl">&lt;ToDoItem key={item.id} item={item} deleteItem={deleteItem} /&gt;;</span></pre><p id="5874" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">这里我们看到两个道具被传递给了<strong class="kw io"> ToDoItem </strong>组件。从这一点开始，我们现在可以通过this.props在子组件中引用它们。你可能已经注意到还有一个<code class="fe mn mo mp mq b">key</code>道具(所以从技术上来说我们实际上传递了三个道具)。这主要是针对React的内部，因为它使得在同一组件的多个版本之间进行更新和跟踪更改变得更加容易(我们在这里这样做是因为每个<strong class="kw io"> todo </strong>都是<code class="fe mn mo mp mq b">ToDoItem</code>组件的副本)。确保您的组件有惟一的键也很重要，否则React会在控制台中警告您。</p><h2 id="5efd" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">Vue:</h2><p id="fd0e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在Vue中，我们在创建子组件时将道具传递给子组件。比如:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="5620" class="ms kd in mq b gy ni nj l nk nl">&lt;ToDoItem v-for="item in list" :item="item" @delete="onDeleteItem" :key="item.id" /&gt;</span></pre><p id="6617" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">完成后，我们将它们传递给子组件中的props数组，如下所示:<code class="fe mn mo mp mq b">props: [ "todo" ]</code>。然后可以在孩子中通过它们的名字引用它们——因此在我们的例子中是<code class="fe mn mo mp mq b">todo</code>。如果您不确定在哪里放置那个<code class="fe mn mo mp mq b">prop</code>键，下面是整个<code class="fe mn mo mp mq b">export default</code>对象在我们的子组件中的样子:</p><pre class="lx ly lz ma gt ne mq nf ng aw nh bi"><span id="c7ad" class="ms kd in mq b gy ni nj l nk nl">export default {<br/>    name: "ToDoItem",<br/>    props: ["item"],<br/>    setup(props, { emit }) {<br/>        function deleteItem(id) {<br/>        emit("delete", id);<br/>        }<br/>        return {<br/>        deleteItem,<br/>        };<br/>    },<br/>};</span></pre><p id="6417" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><em class="mr">有一点你可能已经注意到了，当在Vue中循环数据时，我们实际上只是循环了</em> <code class="fe mn mo mp mq b"><em class="mr">list</em></code> <em class="mr">而不是</em> <code class="fe mn mo mp mq b"><em class="mr">list.value</em></code> <em class="mr">。试图通过</em> <code class="fe mn mo mp mq b"><em class="mr">list.value</em></code> <em class="mr">循环在这里是行不通的</em></p><h1 id="4041" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">我们如何将数据发送回父组件？</h1><h2 id="9847" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">反应:</h2><p id="7e48" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们首先将函数传递给子组件，在调用子组件的地方将它作为一个道具进行引用。然后我们通过引用<strong class="kw io">props . whateverthefunction称为</strong>——或者<strong class="kw io">whateverthefunction称为</strong>(如果我们使用了析构)来添加对子进程的函数调用。这将触发父组件中的函数。我们可以在<em class="mr">‘我们如何从列表中删除’一节中看到整个过程的例子。</em></p><h2 id="fcba" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">Vue:</h2><p id="8260" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在我们的子组件中，我们只需编写一个函数，将值发送回父函数。在我们的父组件中，我们编写了一个函数来监听何时发出该值，然后触发一个函数调用。我们可以在“如何从列表中删除”一节中看到整个过程的示例。</p><h1 id="cca0" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">我们做到了！🎉</h1><p id="b1ff" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我们已经了解了如何添加、删除和更改数据，如何以props的形式将数据从父节点传递到子节点，以及如何以事件侦听器的形式将数据从子节点发送到父节点。当然，React和Vue之间还有许多其他的小差异和怪癖，但是希望本文的内容有助于为理解这两个框架如何处理东西提供一点基础。</p><p id="7c65" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">如果您对本文中使用的样式感兴趣，并想制作您自己的等效作品，请随时这样做！👍</p><h2 id="36f6" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">Github链接到两个应用程序:</h2><p id="9c82" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">https://github.com/sunil-sandhu/vue-todo-2020</p><p id="ac34" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">https://github.com/sunil-sandhu/react-todo-2020</p><h2 id="877a" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">本文的2021版</h2><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2021-edition-a7ebfc19a9d"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">我在React和Vue中创建了完全相同的应用程序。以下是不同之处。[2021版]</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">React vs Vue。Vue和React的并列代码对比！🎉</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ny l"><div class="nz l oa ob oc ny od mg np"/></div></div></a></div><h2 id="13ef" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">本文的2019版</h2><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2019-edition-42ba2cab9e56"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">我在React和Vue中创建了完全相同的应用程序。以下是不同之处。[2019版]</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">React vs Vue。最后是Vue和React的并列代码对比！🎉[2019年更新:现在与React…</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ny l"><div class="oe l oa ob oc ny od mg np"/></div></div></a></div><h2 id="b1c0" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated">本文的2018版</h2><div class="nm nn gp gr no np"><a rel="noopener  ugc nofollow" target="_blank" href="/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd"><div class="nq ab fo"><div class="nr ab ns cl cj nt"><h2 class="bd io gy z fp nu fr fs nv fu fw im bi translated">我在React和Vue中创建了完全相同的应用程序。以下是不同之处。</h2><div class="nw l"><h3 class="bd b gy z fp nu fr fs nv fu fw dk translated">React vs Vue。最后是Vue和React的并列代码对比！🎉</h3></div><div class="nx l"><p class="bd b dl z fp nu fr fs nv fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ny l"><div class="of l oa ob oc ny od mg np"/></div></div></a></div><p id="90b0" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">如果你想把这篇文章翻译成另一种语言，请继续这样做——当它完成时让我知道，以便我可以把它添加到上面的翻译列表中。</p><h2 id="7bce" class="ms kd in bd ke mt mu dn ki mv mw dp km ld mx my ko lh mz na kq ll nb nc ks nd bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="0d4e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae lv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kw io">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kw io">！</strong></p><p id="063b" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><em class="mr">最初发布于:</em><a class="ae lv" href="http://sunilsandhu.com" rel="noopener ugc nofollow" target="_blank"><em class="mr">sunilsandhu.com</em></a></p></div></div>    
</body>
</html>