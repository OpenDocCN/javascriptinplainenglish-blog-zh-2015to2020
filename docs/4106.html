<html>
<head>
<title>Object-Oriented JavaScript — Prototype Catches</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的JavaScript——原型捕获</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-oriented-javascript-prototype-catches-203576f080ee?source=collection_archive---------11-----------------------#2020-11-16">https://javascript.plainenglish.io/object-oriented-javascript-prototype-catches-203576f080ee?source=collection_archive---------11-----------------------#2020-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/46623b4eb957b0693860a9ff3892fc04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zacv6uFHGJTedcNj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sarahleejs?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jongsun Lee</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f8ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript在一定程度上是一种面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究对象属性。</p><h1 id="15e5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">枚举属性</h1><p id="2980" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用for…in循环枚举一个对象的属性。</p><p id="2bfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="458b" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  a: 1,<br/>  b: 2<br/>};</span></pre><p id="ff1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="437e" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  a: 1,<br/>  b: 2<br/>};</span><span id="21f8" class="mn lc iq mj b gy ms mp l mq mr">for (const key in obj) {<br/>  console.log(key, obj[key]);<br/>}</span></pre><p id="0fee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cb31" class="mn lc iq mj b gy mo mp l mq mr">a 1<br/>b 2</span></pre><p id="5b85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">key</code>为键，<code class="fe mt mu mv mj b">obj[key]</code>为值。</p><p id="807c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不是所有的属性都是可枚举的，我们可以设置<code class="fe mt mu mv mj b">ebumerable</code>属性描述符使属性不可枚举。</p><p id="3f7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过<code class="fe mt mu mv mj b">propertyIsEnumerable()</code>方法来检查一个属性是否可以枚举。</p><p id="fde3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过以下方式进行检查:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c3d4" class="mn lc iq mj b gy mo mp l mq mr">console.log(obj.propertyIsEnumerable('a'))</span></pre><p id="78d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们应该得到<code class="fe mt mu mv mj b">true</code>因为对象属性是可枚举的，除非另有说明。</p><h1 id="bd40" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用isPrototypeOf()方法</h1><p id="e744" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对象也有<code class="fe mt mu mv mj b">isPrototypeOf</code>方法，告诉特定的对象是否被用作另一个对象的原型。</p><p id="1cd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="19a7" class="mn lc iq mj b gy mo mp l mq mr">const monkey = {<br/>  hair: true,<br/>  feeds: 'bananas',<br/>  breathes: 'air'<br/>};</span><span id="b44a" class="mn lc iq mj b gy ms mp l mq mr">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="ac90" class="mn lc iq mj b gy ms mp l mq mr">Person.prototype = monkey;</span><span id="ae6e" class="mn lc iq mj b gy ms mp l mq mr">const james = new Person('james');<br/>console.log(monkey.isPrototypeOf(jane));</span></pre><p id="6f35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后控制台日志应该记录<code class="fe mt mu mv mj b">true</code>，因为我们将<code class="fe mt mu mv mj b">monkey</code>设置为<code class="fe mt mu mv mj b">Person</code>构造函数的原型。</p><h1 id="6255" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">__proto__ Property</h1><p id="0d6a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">自从ES6以来,<code class="fe mt mu mv mj b">__proto__</code>属性是一个标准属性，让我们设置一个对象的原型。</p><p id="ea32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也可以用作获取属性的吸气剂。</p><p id="6d83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="765c" class="mn lc iq mj b gy mo mp l mq mr">const monkey = {<br/>  hair: true,<br/>  feeds: 'bananas',<br/>  breathes: 'air'<br/>};</span><span id="ee2b" class="mn lc iq mj b gy ms mp l mq mr">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="e68c" class="mn lc iq mj b gy ms mp l mq mr">Person.prototype = monkey;</span><span id="4187" class="mn lc iq mj b gy ms mp l mq mr">const james = new Person('james');<br/>console.log(james.__proto__ === monkey);</span></pre><p id="683a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe mt mu mv mj b">true</code>，因为我们已经有了<code class="fe mt mu mv mj b">james</code>的原型，对象就是我们设定的<code class="fe mt mu mv mj b">monkey</code>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c519" class="mn lc iq mj b gy mo mp l mq mr">Person.prototype = monkey;</span></pre><p id="76a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过以下方式获得相同的结果:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="007d" class="mn lc iq mj b gy mo mp l mq mr">james.constructor.prototype</span></pre><p id="7630" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用它来设定一个物体的原型，这样我们就可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0a12" class="mn lc iq mj b gy mo mp l mq mr">const monkey = {<br/>  hair: true,<br/>  feeds: 'bananas',<br/>  breathes: 'air'<br/>};</span><span id="cb5b" class="mn lc iq mj b gy ms mp l mq mr">const person = {<br/>  name: 'bob',<br/>  __proto__: monkey<br/>}</span></pre><p id="94ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到具有<code class="fe mt mu mv mj b">__proto__</code>属性的原型，或者我们可以使用<code class="fe mt mu mv mj b">Object.getPrototypeOf()</code>来检查:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3766" class="mn lc iq mj b gy mo mp l mq mr">Object.getPrototypeOf(person)</span></pre><p id="9e0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe mt mu mv mj b">monkey</code>对象。</p><h1 id="7c84" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">扩充内置对象</h1><p id="10c8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以向内置对象添加功能。</p><p id="51bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用聚合填充向某些环境中不可用的对象添加标准功能。</p><h1 id="8086" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">原型的问题</h1><p id="761c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该知道原型链是活动的。</p><p id="924c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们改变<code class="fe mt mu mv mj b">proottype</code>对象时，它就会改变。</p><p id="c495" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">prototype.constructur</code>房产不可用。</p><p id="cf36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以随心所欲地设置<code class="fe mt mu mv mj b">constructor</code>顶部。</p><p id="5d33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们改变原型，那么我们必须改变构造函数。</p><p id="fcb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7ca9" class="mn lc iq mj b gy mo mp l mq mr">function Dog() {}</span><span id="caa9" class="mn lc iq mj b gy ms mp l mq mr">Dog.prototype = {<br/>  paws: 4,<br/>  hair: true<br/>};</span><span id="d7bb" class="mn lc iq mj b gy ms mp l mq mr">const dog = new Dog();<br/>console.log(dog.constructor === Dog);</span></pre><p id="91a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe mt mu mv mj b">false</code>。</p><p id="0733" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须将构造函数设置为<code class="fe mt mu mv mj b">Dog</code>使其成为<code class="fe mt mu mv mj b">true</code>，这样它才能正确报告:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fe3b" class="mn lc iq mj b gy mo mp l mq mr">Dog.prototype.constructor = Dog;</span></pre><p id="a74d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="14d5" class="mn lc iq mj b gy mo mp l mq mr">console.log(dog.constructor === Dog);</span></pre><p id="1d4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如我们所料。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/084f320f24438534e3498bdc5c875acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YpTSVqVfMtXPgrOX"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jakobowens1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jakob Owens</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7d14" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="93a7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用原型时，我们必须小心。</p><p id="2adc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以设置它，有时我们可能会得到意想不到的结果。</p><p id="7327" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>