<html>
<head>
<title>What does Stack Overflow mean in Programming?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编程中栈溢出是什么意思？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-does-stack-overflow-mean-in-programming-37c896e1ecdd?source=collection_archive---------9-----------------------#2020-12-19">https://javascript.plainenglish.io/what-does-stack-overflow-mean-in-programming-37c896e1ecdd?source=collection_archive---------9-----------------------#2020-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1cec" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">找出堆栈溢出的真正含义</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/48636941bd4b585343149ea54f06a0df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Zv08wE_W7rRoj7K7"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">screenshot from<a class="ae kv" href="https://stackoverflow.com/questions/214741/what-is-a-stackoverflowerror" rel="noopener ugc nofollow" target="_blank"> st</a>ackover<a class="ae kv" href="https://stackoverflow.com/questions/214741/what-is-a-stackoverflowerror" rel="noopener ugc nofollow" target="_blank">flow</a> edited by Toluwani Elemosho</figcaption></figure><p id="08e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你想到堆栈溢出时，你会想到什么？网站吗？好吧，跟我来解释堆栈溢出的真正含义。</p><p id="010e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一天结束时，JavaScript程序做两件事:将信息写入内存和从内存中读取信息。</p><p id="187f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">两个存储区域用于读取或写入这些信息:</p><ol class=""><li id="7770" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">许多</li><li id="dc1f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">堆</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/eb0bd556bcbfc90c5d19cdbe6ef0b489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WDMBPXzilHdMrb-f"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">image by via<a class="ae kv" href="https://fr.tidybooks.com/produit/coffre-a-jouet-enfant/" rel="noopener ugc nofollow" target="_blank"> tidyboks</a> (right) and<a class="ae kv" href="https://www.pinterest.com.au/mtaau/" rel="noopener ugc nofollow" target="_blank"> Modern Teaching Aids</a>(left)</figcaption></figure><h2 id="f97c" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">什么是堆栈？</h2><p id="7a1a" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">可以把stack想象成一个内存区域，在逐行运行时跟踪并存储函数或变量。</p><p id="a927" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">堆栈以后进先出(LIFO)模式运行。想象一下，乐高积木从上到下垂直堆叠在一起，更多的乐高积木放在顶部，从底部移除。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/c0e9735e461d506502b39d1d76924746.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/1*oXvwi8o6LR9QfW0VuRxyRA.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Images by <a class="ae kv" href="https://dribbble.com/AmmanV" rel="noopener ugc nofollow" target="_blank">Amman Vedi</a> via <a class="ae kv" href="https://dribbble.com/" rel="noopener ugc nofollow" target="_blank">https://dribbble.com/</a></figcaption></figure><h2 id="704e" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">如何添加到堆栈？</h2><p id="5e5c" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">下面的代码图说明了添加到堆栈的想法。每当在第8行调用<code class="fe nf ng nh ni b">calculate()</code>函数时，calculate()被推到堆栈的最顶层。第5行的下一个<code class="fe nf ng nh ni b"><em class="nj">const sumTotal = (4+5)</em></code>将被执行，也将被压入堆栈。随着更多代码的运行，它们被压入堆栈。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/34f75e9f7c59139c975d6e728d8c270f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OGrliU0-JqlMcTUZ"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">source:<a class="ae kv" href="http://latentflip.com/loupe/?" rel="noopener ugc nofollow" target="_blank"> loupe</a></figcaption></figure><h2 id="be3e" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">怎么从栈中减去？</h2><p id="cab9" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">当一个函数、变量或对象被执行时，它被从堆栈中清除。在上面的例子中，因为<code class="fe nf ng nh ni b">const sumTotal = (4+5)</code>在<code class="fe nf ng nh ni b">calculate()</code>函数之前完成了它的任务，所以它被从堆栈中删除。</p><h2 id="f73f" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated"><strong class="ak">考虑另一个例子:</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/ec2ffe8c9c10c9833dc5dd5c7ad55598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iDOF40icI-RoAfFB"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">source:<a class="ae kv" href="http://latentflip.com/loupe/?" rel="noopener ugc nofollow" target="_blank"> loupe</a></figcaption></figure><p id="04ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑上面代码图中的步骤:</p><ol class=""><li id="15d6" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nf ng nh ni b">Calculate()</code>第12行调用的函数被推到堆栈的第一层。</li><li id="5a83" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">第8行中的<code class="fe nf ng nh ni b">(4+5) </code>接下来运行，并且也被推到calculate()函数顶部的堆栈中，但是很快被从堆栈中移除，因为它已经完成了它的任务。</li><li id="8ab5" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">要执行的下一个函数<code class="fe nf ng nh ni b">subTractTwo()</code>被添加到堆栈中。</li><li id="3946" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nf ng nh ni b">(return num-2)</code>已经在<code class="fe nf ng nh ni b">subTractTwo()</code>中被处理，然后被添加，但是因为它已经完成了它的任务，所以立即被删除。</li><li id="4a6d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">现在<code class="fe nf ng nh ni b">subTractTwo()</code>已经完成了它的进程，它被从堆栈中移除。</li><li id="7ca4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">最后，<code class="fe nf ng nh ni b">calculate()</code>结束执行并从堆栈中移除。</li></ol><p id="e160" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">综上所述，stack是一个在每行代码执行时跟踪和存储数据的容器。</p><h2 id="07ab" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">什么是堆栈溢出？</h2><p id="4a26" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">有可能在不释放内存的情况下，不断向容器(栈)添加和添加，由于栈的大小是有限的，最终会耗尽内存，使程序崩溃。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/001d98ab8811be9515ab144465d5f8de.png" data-original-src="https://miro.medium.com/v2/resize:fit:578/0*so0VGT1Rtiws5CRk"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">image by<a class="ae kv" href="https://www.improvutopia.com/author/improvutopiamaster/" rel="noopener ugc nofollow" target="_blank"> Improv Utopia</a></figcaption></figure><p id="d1c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们做些有趣的事，好吗？从前面的例子中，我们发现当调用<code class="fe nf ng nh ni b">calculate()</code>时，代码被放入堆栈并从堆栈中移除。</p><p id="1843" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们一直增加堆栈，直到它变得越来越大，最后会耗尽内存(stack)怎么办。这被称为<strong class="ky ir">堆栈溢出</strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/3f6b1382c264a1db620f43574e8812b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5PBsl4TDhEhTGEoi"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">source:<a class="ae kv" href="http://latentflip.com/loupe/?" rel="noopener ugc nofollow" target="_blank"> loupe</a></figcaption></figure><p id="deff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码显示了一个在自身内部调用的函数。这叫做<strong class="ky ir">递归。</strong>如果我们在第6行调用<code class="fe nf ng nh ni b">recurse()</code>会发生什么？<code class="fe nf ng nh ni b">recurse()</code>将继续调用<code class="fe nf ng nh ni b">recurse()</code>和，并不断将<code class="fe nf ng nh ni b">recurse()</code>添加到堆栈中，直到堆栈填满，应用程序崩溃。这称为堆栈溢出。</p><p id="08b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">递归是导致堆栈溢出的最常见方式之一。它只是一个在自身内部调用的函数，用来创建一个不断增长的堆栈，直到堆栈填满。</p><h2 id="3802" class="mg mh iq bd mi mj mk dn ml mm mn dp mo lf mp mq mr lj ms mt mu ln mv mw mx my bi translated">结论</h2><p id="a3a3" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">总之，本文解释了JavaScript V8引擎用来存储和读取信息的两个内存:<strong class="ky ir"> Stack和Heap </strong>。它还描述了什么是堆栈，如何在堆栈中添加或删除信息，以及什么是堆栈溢出。</p><p id="cd89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望您在学习这些概念的过程中获得了乐趣，因为它们有助于您编写更好的JavaScript代码。</p></div></div>    
</body>
</html>