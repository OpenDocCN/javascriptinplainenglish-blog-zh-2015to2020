<html>
<head>
<title>How to use the app object in Express.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Express.js中使用app对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/guide-to-the-express-application-object-d6544a8f87cd?source=collection_archive---------3-----------------------#2020-02-20">https://javascript.plainenglish.io/guide-to-the-express-application-object-d6544a8f87cd?source=collection_archive---------3-----------------------#2020-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e4d41e588e9206ce3ebcef2c193de8b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vpAMQn1O0l3t0HRa"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@brucemars?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">bruce mars</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5360" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">快速应用程序的核心部分是应用程序对象。是应用本身。</p><p id="06a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看<code class="fe lb lc ld le b">app</code>对象的属性和方法，以及我们可以用它做什么。</p><h1 id="36d1" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">它能做什么？</h1><p id="36db" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">app</code>对象有以下方法:</p><ul class=""><li id="679c" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated">路由HTTP请求</li><li id="2303" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">配置中间件</li><li id="acab" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">呈现HTML视图</li><li id="09cc" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">注册模板引擎</li></ul><h1 id="f5a9" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">性能</h1><h2 id="1db9" class="mw lg iq bd lh mx my dn ll mz na dp lp ko nb nc lt ks nd ne lx kw nf ng mb nh bi translated">app.locals</h2><p id="4ab5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">app.locals</code>对象的属性是应用程序中的局部变量。</p><p id="0114" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将它用作getter或setter。</p><p id="aefa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="6e96" class="mw lg iq le b gy nq nr l ns nt">console.dir(app.locals.title);</span></pre><p id="f789" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些属性在整个应用程序中都是持久的，而不仅仅是请求的生命周期。</p><p id="8634" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以根据需要设置属性:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="ee72" class="mw lg iq le b gy nq nr l ns nt">app.locals.title = 'foo';</span></pre><h2 id="993e" class="mw lg iq bd lh mx my dn ll mz na dp lp ko nb nc lt ks nd ne lx kw nf ng mb nh bi translated">app.mountpath</h2><p id="7e05" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">app.mountpath</code>属性有一个或多个安装了子应用程序的路径模式。</p><p id="8357" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">子应用程序是<code class="fe lb lc ld le b">express</code>的一个实例，用于处理路由请求。</p><p id="c4c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="28c1" class="mw lg iq le b gy nq nr l ns nt">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="2df3" class="mw lg iq le b gy nu nr l ns nt">const app = express();</span><span id="a37d" class="mw lg iq le b gy nu nr l ns nt">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));<br/>const foo = express();</span><span id="4bfe" class="mw lg iq le b gy nu nr l ns nt">foo.get('/', (req, res) =&gt; {<br/>  res.send(foo.mountpath);<br/>})</span><span id="c750" class="mw lg iq le b gy nu nr l ns nt">app.use('/foo', foo);</span><span id="4f2e" class="mw lg iq le b gy nu nr l ns nt">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="5b73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们应该得到<code class="fe lb lc ld le b">/foo</code>，因为我们有:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="7e3c" class="mw lg iq le b gy nq nr l ns nt">app.use('/foo', foo);</span></pre><p id="a8b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">定义子应用路径<code class="fe lb lc ld le b">/foo</code>。</p><p id="1d2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像常规路径一样，子应用程序的路径也可以有通配符或特殊字符来匹配模式。</p><p id="e214" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="0163" class="mw lg iq le b gy nq nr l ns nt">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="381b" class="mw lg iq le b gy nu nr l ns nt">const app = express();</span><span id="ae80" class="mw lg iq le b gy nu nr l ns nt">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));<br/>const foo = express();</span><span id="8cc4" class="mw lg iq le b gy nu nr l ns nt">foo.get('/', (req, res) =&gt; {<br/>  res.send(foo.mountpath);<br/>})</span><span id="e745" class="mw lg iq le b gy nu nr l ns nt">app.use('/ab*d', foo);</span><span id="b019" class="mw lg iq le b gy nu nr l ns nt">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="4eef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当我们转到<code class="fe lb lc ld le b">/abcd</code>时，我们会看到<code class="fe lb lc ld le b">/ab*d</code>，因为在<code class="fe lb lc ld le b">b</code>和<code class="fe lb lc ld le b">d</code>之间有通配符<code class="fe lb lc ld le b">*</code>。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/e24dc8daea5fd19239f625d291fa4e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RM273yYrCenqN8Kw"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@coinviewapp?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">CoinView App</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2cb1" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">事件</h1><h2 id="6771" class="mw lg iq bd lh mx my dn ll mz na dp lp ko nb nc lt ks nd ne lx kw nf ng mb nh bi translated">app.on('mount '，回调(父))</h2><p id="8b26" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">当子应用程序装载到父应用程序上时，在子应用程序上触发<code class="fe lb lc ld le b">mount</code>事件。父应用程序被传递给回调。</p><p id="88ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">子应用程序不会继承有默认值的值，也不会继承没有默认值的设置值。</p><p id="6b78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="14b9" class="mw lg iq le b gy nq nr l ns nt">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="8311" class="mw lg iq le b gy nu nr l ns nt">const app = express();</span><span id="b3bf" class="mw lg iq le b gy nu nr l ns nt">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));<br/>const foo = express();</span><span id="d2eb" class="mw lg iq le b gy nu nr l ns nt">foo.on('mount', (parent) =&gt; {<br/>  console.log(parent);<br/>})</span><span id="6266" class="mw lg iq le b gy nu nr l ns nt">foo.get('/', (req, res) =&gt; {<br/>  res.send('foo');<br/>})</span><span id="2076" class="mw lg iq le b gy nu nr l ns nt">app.use('/foo', foo);</span><span id="75fb" class="mw lg iq le b gy nu nr l ns nt">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="709f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该看到父应用程序对象被记录。</p><h1 id="8d1e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">方法</h1><h2 id="9281" class="mw lg iq bd lh mx my dn ll mz na dp lp ko nb nc lt ks nd ne lx kw nf ng mb nh bi translated">app.all(路径，回调[，回调…])</h2><p id="2319" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">这个应用程序允许我们传递路由处理程序来处理所有的请求方法。</p><p id="d927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它采用以下参数:</p><ul class=""><li id="766f" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated"><code class="fe lb lc ld le b">path</code> —它可以是表示路径或路径模式的字符串或正则表达式。默认为<code class="fe lb lc ld le b">/</code>。</li><li id="40c3" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><code class="fe lb lc ld le b">callback</code> —处理请求的功能。它可以是一个中间件功能、一系列中间件功能、一系列中间件功能或以上所有功能的组合</li></ul><p id="d5b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="c812" class="mw lg iq le b gy nq nr l ns nt">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="c912" class="mw lg iq le b gy nu nr l ns nt">const app = express();</span><span id="4211" class="mw lg iq le b gy nu nr l ns nt">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="7988" class="mw lg iq le b gy nu nr l ns nt">app.all('/', function (req, res, next) {<br/>  res.send('hi');<br/>})</span><span id="d605" class="mw lg iq le b gy nu nr l ns nt">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="ef20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么无论我们对<code class="fe lb lc ld le b">/</code>提出什么样的要求，都要看到<code class="fe lb lc ld le b">hi</code>。</p><p id="5533" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于像检查身份验证或加载用户数据这样的全局逻辑来说，这很方便。</p><h2 id="1aa7" class="mw lg iq bd lh mx my dn ll mz na dp lp ko nb nc lt ks nd ne lx kw nf ng mb nh bi translated">app.delete(路径，回调[，回调…])</h2><p id="55cf" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">这个应用程序允许我们传递路由处理程序来处理删除请求。</p><p id="17e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它采用以下参数:</p><ul class=""><li id="6b41" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated"><code class="fe lb lc ld le b">path</code> —可以是表示路径或路径模式的字符串或正则表达式。默认为<code class="fe lb lc ld le b">/</code>。</li><li id="de72" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><code class="fe lb lc ld le b">callback</code> —处理请求的功能。它可以是一个中间件功能、一系列中间件功能、一系列中间件功能或以上所有功能的组合</li></ul><p id="04d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="6fb6" class="mw lg iq le b gy nq nr l ns nt">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="bfc7" class="mw lg iq le b gy nu nr l ns nt">const app = express();</span><span id="98b9" class="mw lg iq le b gy nu nr l ns nt">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="e2d1" class="mw lg iq le b gy nu nr l ns nt">app.delete('/', function (req, res, next) {<br/>  res.send('DELETE request made');<br/>})</span><span id="8d31" class="mw lg iq le b gy nu nr l ns nt">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="1754" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们用Postman这样的HTTP客户端发出删除请求时，应该会看到<code class="fe lb lc ld le b">DELETE request made</code>。</p><h2 id="e7db" class="mw lg iq bd lh mx my dn ll mz na dp lp ko nb nc lt ks nd ne lx kw nf ng mb nh bi translated">app.disable(名称)</h2><p id="0559" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用<code class="fe lb lc ld le b">disable</code>方法来设置给定的<code class="fe lb lc ld le b">name</code>到<code class="fe lb lc ld le b">false.</code>的设置，这与调用<code class="fe lb lc ld le b">app.set('setting', false)</code>是一样的；</p><p id="ebe8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="1cf4" class="mw lg iq le b gy nq nr l ns nt">const express = require('express');<br/>const bodyParser = require('body-parser');</span><span id="f363" class="mw lg iq le b gy nu nr l ns nt">const app = express();</span><span id="7bce" class="mw lg iq le b gy nu nr l ns nt">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="d857" class="mw lg iq le b gy nu nr l ns nt">app.disable('foo');</span><span id="c39a" class="mw lg iq le b gy nu nr l ns nt">app.get('/', function (req, res, next) {<br/>  res.json({ foo: app.get('foo') });<br/>})</span><span id="0d21" class="mw lg iq le b gy nu nr l ns nt">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="e854" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们应该看到:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="0f7b" class="mw lg iq le b gy nq nr l ns nt">{"foo":false}</span></pre><p id="e7a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们叫<code class="fe lb lc ld le b">app.disable(‘foo’);</code></p><h1 id="b3f2" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="a7e6" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">app</code>对象是Express app的核心对象。它有让我们添加中间件和路由处理器的方法。</p><p id="c191" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当子应用程序装载到父应用程序上时，它还允许我们处理<code class="fe lb lc ld le b">mount</code>事件。</p><p id="31cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以从<code class="fe lb lc ld le b">app</code>对象中获取子应用的<code class="fe lb lc ld le b">mountpath</code>。</p></div></div>    
</body>
</html>