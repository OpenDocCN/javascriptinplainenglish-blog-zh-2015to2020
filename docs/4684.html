<html>
<head>
<title>How to Verify Users in Express.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在Express.js中验证用户</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-verify-users-in-express-js-24c020433b2a?source=collection_archive---------9-----------------------#2020-12-30">https://javascript.plainenglish.io/how-to-verify-users-in-express-js-24c020433b2a?source=collection_archive---------9-----------------------#2020-12-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/31ca70aa9cc3836d4417ee8cdc890d4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PXERgH2KjBhj1j2c.jpg"/></div></div></figure><p id="50bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你正在构建一个应用程序，你可能希望你的平台上有很多用户。但是，你不只是想要大量的用户，你想要真实的、高质量的、会和你的app互动的用户。您想要验证这些用户。</p><p id="add9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于使用假电子邮件地址的机器人或用户来说，没有认真使用你的应用程序进行注册的意图是很常见的。一开始处理这个问题的一个方法是确保验证用户。</p><p id="7e0d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本文是关于ExpressJS中用户验证的教程，也是我的Express web开发系列的继续。我将在我上一篇关于<a class="ae kt" href="https://kelvinmwinuka.com/how-to-handle-password-reset-in-expressjs/" rel="noopener ugc nofollow" target="_blank">处理密码重置的文章中讨论的概念的基础上进行构建。</a></p><p id="5f9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该文章中指定了设置和所需的包，但是您将能够看到在代码示例中使用了什么包。</p><p id="c8a3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我建议先看看本系列中的其他文章，尽管不管怎样，您应该能够理解这篇文章。如果你想随着系列的进展跟踪这个项目，请在<a class="ae kt" href="https://github.com/kelvinmwinuka/express-tutorial" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上查看。</p><h1 id="3fd8" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">模型</h1><p id="cfa1" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">让我们首先创建保存验证令牌的模型。导航到models文件夹并创建一个名为“UserVerification.js”的文件。该文件应包含以下内容:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8247" class="mg kv in mc b gy mh mi l mj mk">const { Schema, model } = require('mongoose')</span><span id="12aa" class="mg kv in mc b gy ml mi l mj mk">const schema = new Schema({<br/>  user : {<br/>    type: Schema.Types.ObjectId,<br/>    ref: 'User',<br/>    required: true<br/>  },<br/>  token: {<br/>    type: Schema.Types.String,<br/>    required: true<br/>  }<br/>}, {<br/>  timestamps: true<br/>})</span><span id="7ebf" class="mg kv in mc b gy ml mi l mj mk">schema.index({ 'updatedAt': 1 }, { expireAfterSeconds: 300 })</span><span id="c0e6" class="mg kv in mc b gy ml mi l mj mk">const UserVerification = model('UserVerification', schema)</span><span id="1b1f" class="mg kv in mc b gy ml mi l mj mk">module.exports = UserVerification</span></pre><p id="3970" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">模型模式包含一个将包含在验证链接中的令牌，以及与之相关联的用户。</p><p id="aeab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在“updatedAt”字段上创建一个索引，指示MongoDB在记录更新5分钟后删除记录。对于测试来说，5分钟是合理的，但是在生产中，您会希望将这个时间增加到更合理的时间。</p><p id="c6ae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在用户模型中，向模式添加一个布尔型“已验证”属性。将默认值设置为false，因为用户在注册时不会被验证。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="7e7f" class="mg kv in mc b gy mh mi l mj mk">const { Schema, model } = require('mongoose')</span><span id="3dac" class="mg kv in mc b gy ml mi l mj mk">const saltRounds = 10</span><span id="842d" class="mg kv in mc b gy ml mi l mj mk">var userSchema = new Schema({<br/>  name: {<br/>    type: Schema.Types.String,<br/>    required: [true, 'You must provide a name']<br/>  },<br/>  email: {<br/>    type: Schema.Types.String,<br/>    required: [true, 'Email address is required']<br/>  },<br/>  username: {<br/>    type: Schema.Types.String,<br/>    required: [true, 'Username is required']<br/>  },<br/>  password: {<br/>    type: Schema.Types.String,<br/>    required: [true, 'You must provide a password']<br/>  },<br/>  verified: {<br/>    type: Schema.Types.Boolean,<br/>    required: true,<br/>    default: false<br/>  }<br/>})</span><span id="3d7b" class="mg kv in mc b gy ml mi l mj mk">...</span><span id="0a4d" class="mg kv in mc b gy ml mi l mj mk">const User = model('User', userSchema)</span><span id="6ece" class="mg kv in mc b gy ml mi l mj mk">module.exports = User</span></pre><h1 id="122f" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">路线</h1><h1 id="7220" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">配置路线</h1><p id="2a78" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们必须创建的第一条路线是轮廓路线。这条路线将简单地呈现一个带有用户个人资料细节的模板。在routes文件夹中创建一个名为“profile.js”的文件，并添加一个呈现“profile.html”模板的路由。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="f2e6" class="mg kv in mc b gy mh mi l mj mk">const router = require('express').Router()</span><span id="90e0" class="mg kv in mc b gy ml mi l mj mk">router.get('/profile', (req, res) =&gt; {<br/>  if (!req.isAuthenticated()) return res.redirect('/login')<br/>  return res.render('profile.html')<br/>})</span><span id="8c9b" class="mg kv in mc b gy ml mi l mj mk">module.exports = router</span></pre><h1 id="5b08" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用户验证路线</h1><p id="ccdb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">现在让我们创建处理用户验证的路由。在routes文件夹中，创建一个名为“user-verification.js”的文件。首先，该文件将包含以下内容:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a156" class="mg kv in mc b gy mh mi l mj mk">const router = require('express').Router()<br/>const { v4 } = require('uuid')<br/>const { User, UserVerification } = require('../models')<br/>const { sendEmail } = require('../helpers')</span><span id="8021" class="mg kv in mc b gy ml mi l mj mk">/* Create routes here */</span><span id="a9cb" class="mg kv in mc b gy ml mi l mj mk">module.exports = router</span></pre><p id="ecb4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">导入用户和用户验证模型。导入我们在上一篇文章中创建的“sendMail”助手函数。这是一个简单的函数，它使用NodeMailer通过传递给它的参数发送电子邮件。</p><p id="6c9f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们创建路线。</p><h2 id="ddcf" class="mg kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">创建验证url</h2><p id="3a09" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">第一个路由是获取路由'/verify '。该路由负责创建验证URL，并包含以下内容:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="3ccf" class="mg kv in mc b gy mh mi l mj mk">router.get('/verify', async (req, res) =&gt; {<br/>  if (!req.isAuthenticated()) return res.redirect('/login')<br/>  if (req.user.verified) return res.redirect('back')</span><span id="b922" class="mg kv in mc b gy ml mi l mj mk">const token = v4().toString().replace(/-/g, '')<br/>  const verificationUrl = `${process.env.DOMAIN}/verify-confirm/${token}`</span><span id="ded9" class="mg kv in mc b gy ml mi l mj mk">await UserVerification.updateOne({ <br/>    user: req.user._id <br/>  }, {<br/>    user: req.user._id,<br/>    token: token<br/>  }, {<br/>    upsert: true<br/>  })</span><span id="5985" class="mg kv in mc b gy ml mi l mj mk">sendEmail({<br/>    to: req.user.email,<br/>    subject: 'Verify your email address',<br/>    text: `Here's your email verification link: ${verificationUrl}`<br/>  })</span><span id="31ef" class="mg kv in mc b gy ml mi l mj mk">req.flash('verify_success', 'Check your email address for your verification link. It may take a few minutes')<br/>  res.redirect('/profile')<br/>})</span></pre><p id="d6d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，检查用户是否经过身份验证。用户应该只能在登录时请求验证链接。如果不是，将他们重定向到登录页面。</p><p id="6380" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">检查用户是否已经过验证。如果用户已经验证，我们不想发送验证链接。如果是，请重定向到上一页。</p><p id="c70f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建令牌，然后创建包含令牌的验证URL。</p><p id="8d43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更新与当前用户关联的用户验证记录。确保将upsert选项设置为“true”。我们希望替换当前的验证链接，以便一次只能有一个链接处于活动状态，但是如果集合中没有链接，我们还希望创建一个新的链接。</p><p id="dd24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">发送包含用户验证链接的电子邮件，闪现一条提示用户检查其电子邮件地址的成功消息，然后重定向到用户的个人资料。</p><h2 id="f34d" class="mg kv in bd kw mm mn dn la mo mp dp le kg mq mr li kk ms mt lm ko mu mv lq mw bi translated">验证用户</h2><p id="56e5" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">第二个路由处理发送给用户的链接:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ac3a" class="mg kv in mc b gy mh mi l mj mk">router.get('/verify-confirm/:token', async (req, res) =&gt; {<br/>  if (!req.isAuthenticated()) return res.redirect('/login')<br/>  <br/>  const token = req.params.token</span><span id="bcda" class="mg kv in mc b gy ml mi l mj mk">const userVerification = await UserVerification.findOne({<br/>    user: req.user._id,<br/>    token: token<br/>  })</span><span id="c794" class="mg kv in mc b gy ml mi l mj mk">if (userVerification) {<br/>    await User.updateOne({ _id: req.user._id }, { verified: true })<br/>    await UserVerification.deleteOne({ <br/>      user: req.user._id,<br/>      token: token<br/>    })<br/>    sendEmail({<br/>      to: req.user.email,<br/>      subject: 'Verified',<br/>      text: `Congratulations ${req.user.name}, your account is now verified!`<br/>    })<br/>    req.flash('verify_success', 'Congrats, you are now verified!')<br/>  } else {<br/>    req.flash('verify_error', 'Verification link is invalid or has expired.')<br/>  }</span><span id="3fe8" class="mg kv in mc b gy ml mi l mj mk">return res.redirect('/profile')<br/>})</span></pre><p id="6f2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该路由需要一个令牌，我们稍后将验证该令牌。首先检查用户是否登录，如果没有，重定向到登录页面。</p><p id="c44d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">从url中提取令牌，并在UserVerification集合中查询具有当前令牌和当前用户的文档。</p><p id="7ae2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果文档不存在，闪现一条错误消息，指出链接无效或过期。</p><p id="820c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果文档存在，将用户的验证状态更新为“true ”,并删除当前的UserVerification文档，以防止链接被再次点击(这无论如何都是没有意义的，但却是一个好的实践)。</p><p id="0656" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">向用户发送确认其验证状态的电子邮件，然后显示一条成功消息，说明用户现已通过验证。之后重定向到用户的个人资料页面。</p><h1 id="fd8b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">导入路线</h1><p id="e9d4" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">进入应用程序的入口文件夹，用以下代码包含配置文件和用户验证路径:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8d24" class="mg kv in mc b gy mh mi l mj mk">app.use('/', require('./routes/profile')) <br/>app.use('/', require('./routes/user-verification'))</span></pre><h1 id="3b78" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">模板</h1><p id="6fd6" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们需要为这个特性创建一个新的模板:概要文件模板。</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a0f1" class="mg kv in mc b gy mh mi l mj mk">{% extends 'base.html' %}</span><span id="4259" class="mg kv in mc b gy ml mi l mj mk">{% set title = 'Profile' %}</span><span id="407e" class="mg kv in mc b gy ml mi l mj mk">{% block content %}<br/>  {% if messages.verify_success %}<br/>    &lt;div class="alert alert-success" role="alert"&gt;<br/>      {{ messages.verify_success }}<br/>    &lt;/div&gt;<br/>  {% endif %}<br/>  {% if messages.verify_error %}<br/>    &lt;div class="alert alert-danger" role="alert"&gt;<br/>      {{ messages.verify_error }}<br/>    &lt;/div&gt;<br/>  {% endif %}<br/>  &lt;div&gt;<br/>    &lt;h5&gt;Hi, {{ user.name }}&lt;/h5&gt;<br/>    {% if not user.verified %}<br/>      Your email is not verified, <br/>      &lt;a class="btn btn-sm btn-warning" href="/verify"&gt;Verify Email&lt;/a&gt;<br/>    {% endif %}<br/>  &lt;/div&gt;<br/>{% endblock %}</span><span id="90ae" class="mg kv in mc b gy ml mi l mj mk">{% block scripts %}<br/>{% endblock %}</span></pre><p id="5612" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该模板呈现在先前请求中闪现的错误或成功消息。我们有一个显示用户名的div和一个根据用户的验证状态有条件地生成验证URL的按钮。</p><h1 id="c9d0" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="ea15" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在本文中，我演示了如何在您的Express应用程序中验证用户。您可能有许多原因想要验证用户:您可能想要确保您的应用程序上有活跃的人类用户，或者您可能想要限制需要验证用户的功能。</p><p id="7ecf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">不管是什么原因，我希望这篇文章为验证过程的流程和执行提供了足够的指导。</p><p id="879b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一篇文章将介绍如何使用MongoDB中的多对多关系创建用户关注和关注者关系。</p><p id="e7e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如果你喜欢这篇文章，可以考虑关注我的</strong> <a class="ae kt" href="https://kelvinmwinuka.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">个人网站</strong> </a> <strong class="jx io">，以便在我的内容在媒体上发表之前提前获得。另外，请随意评论这篇文章。我很想听听你们的想法！</strong></p></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><p id="8edb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ne">原载于2020年12月30日https://kelvinmwinuka.com</em><em class="ne">的</em> <a class="ae kt" href="https://kelvinmwinuka.com/how-to-verify-users-in-expressjs/" rel="noopener ugc nofollow" target="_blank"> <em class="ne">。</em></a></p></div></div>    
</body>
</html>