<html>
<head>
<title>JavaScript: Loose Equals and Strict Equals</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:宽松等于和严格等于</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-loose-equals-and-strict-equals-ab2144fcbe?source=collection_archive---------6-----------------------#2020-04-16">https://javascript.plainenglish.io/javascript-loose-equals-and-strict-equals-ab2144fcbe?source=collection_archive---------6-----------------------#2020-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="104b" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">java描述语言</h2><div class=""/><div class=""><h2 id="5411" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">隐性强制是邪恶的、有害的吗？在某些情况下，是的！从广义上说，也不尽然。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/a8b59890b66bba677f1915fcbab1c045.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YWzqwQPNpcZBkHc3"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@nordwood?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">NordWood Themes</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3d40" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja"> <em class="mb">宽松等于</em> </strong>指“==”(双等号)运算符，而<strong class="lh ja">严格等于</strong>表示“===”(三等号)运算符。通常这两个运算符都用于两个值的比较和“相等”检查。然而,“宽松”和“严格”的平等者在行为上有显著的不同，尤其是在他们得出“平等”的方式上。</p><p id="87a1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">对这两个运算符的一个常见误解是:"<strong class="lh ja"> <em class="mb">双等号检查值是否相等，而三等号检查值及其类型是否相等</em> </strong>"。虽然这听起来似乎很合理和清晰，但它从根本上是不正确的。有许多流行的JavaScript书籍和博客已经明确指出了这种区别，但不幸的是，它们都是错误的。</p><p id="b51a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">更恰当的定义应该是:"<strong class="lh ja"> <em class="mb">双等号允许等式比较中的强制，而三等号操作避免强制。</em> </strong></p><h1 id="7fc2" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">两个等式的性能比较</h1><p id="da4c" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">让我们花点时间考虑一下这两种定义，首先是不正确的定义，然后是更合适的定义。</p><p id="96a0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">请注意，在第一个解释中，它只是表明运算符“===”比运算符“==”工作更多。这似乎是显而易见的，因为它涉及到检查类型。但是考虑第二种解释，其中“==”完成了更多的工作，因为它遵循了不同类型情况下的强制步骤。</p><p id="8fb3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当心这个陷阱！许多人认为这与性能有关，因为“==”的运行速度相对较慢。虽然强制过程花费了大量的处理时间在数量上是有效的，但是额外的时间以微秒计。</p><p id="02d5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">或者，在考虑比较同一类型的两个不同值时，“==”运算符和“===”运算符都使用相同的算法。因此，他们应该做同样多的工作，即使我们包括他们相应的工程实现中的微小差异。</p><p id="438b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，如果我们比较两个不同的值，性能不一定是主要关注点。相反，我们应该重新考虑是否有强制过程的要求。如果我们真的想要强制，我们选择“==”作为松散的等式，否则我们选择“===”作为严格的操作符。</p><p id="8aee" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">注意:</strong>这里，主要的含义是两个操作符(“==”和“===”)都检查它们的操作数的类型。区别在于它们在类型不匹配的情况下的响应方式。</p><h1 id="d7ca" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">抽象等式</h1><p id="09cb" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">“==”操作符的行为在<a class="ae le" href="https://www.ecma-international.org/ecma-262/5.1/#sec-11.9" rel="noopener ugc nofollow" target="_blank"> ES5规范</a>的11.9.3节中定义为<em class="mb">“抽象等式比较算法”</em>。本节通过一个全面而又简化的算法，说明了对于每种可能的组合类型，强制过程(如果需要的话)应该如何发生。</p><p id="1b9c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">换句话说，这一节的第一个分句(即11.9.3.1)提到，如果被比较的两个价值属于同一类型，那么它们应该通过同一性进行简单而自然的比较。也就是说，考虑<strong class="lh ja"><em class="mb">【123】</em></strong>哪个只等于<strong class="lh ja"><em class="mb">【123】</em></strong>就像<strong class="lh ja"><em class="mb">【qwerty】</em></strong>怎么只应该等于<strong class="lh ja"><em class="mb">【qwerty】</em></strong>一样。</p><p id="50cc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">子句11.9.3.1的最后一段致力于“==”松散等式与对象(包括函数和数组)的比较。这里，两个这样的值只有当且仅当它们引用完全相同的值时才能被认为是相等的。因此，这里没有观察到强制。</p><p id="6e17" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">11.9.3节中算法的剩余部分提到，当在比较不同类型的两个值时使用“==”宽松等式运算符时，可能需要隐式强制一个或两个值。这是为了确保这两个值最终属于同一类型，因此可以通过简单的值标识直接用于比较是否相等。</p><p id="8e71" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><strong class="lh ja">注:</strong>“中！= "松散的不等运算符也正如我们所期望的那样定义。它只是执行完整的“==”运算比较，然后对结果求反。同样的“！== "用作严格的不等运算符。</p><h1 id="cd94" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">隐式强制的安全使用</h1><p id="c6da" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">让我们建立一个简单的基本规则:总是浏览程序并推理可能出现在“==”比较两边的值。为了避免比较，你可以遵循以下准则:</p><ul class=""><li id="538b" class="mz na iq lh b li lj ll lm lo nb ls nc lw nd ma ne nf ng nh bi translated">在比较的任何一方可能有真或假值的情况下，总是<strong class="lh ja">避免使用“==”运算符</strong>。</li><li id="273c" class="mz na iq lh b li ni ll nj lo nk ls nl lw nm ma ne nf ng nh bi translated">在比较的任何一方可以有[]、" "(空字符串)或0值的情况下，再次<strong class="lh ja">避免</strong>使用“==”运算符。</li></ul><p id="3294" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在上述情况下，最好使用“===”操作符代替“==”操作符，以避免强制。如果掌握了这两个规则，许多与强制程序有关的麻烦就可以轻易避免。在这些情况下，更加明确和罗嗦将有助于避免很多麻烦。</p><p id="c5fd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">所以现在，关于“==”和“===”操作符的比较，更恰当的问题形式应该是:应该允许强制比较吗？</p><p id="35e9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在许多情况下，强制是很方便的，它使我们能够以一种非常简洁的方式构建一些比较逻辑(例如，未定义或空)。相反，隐性胁迫可能相当有害的情况相对较少。然而，在这种情况下，强烈建议使用“===”操作符作为预防措施。</p><p id="fa4f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在的问题是:隐性强制是邪恶和有害的吗？在某些情况下，是的！从广义上说，也不尽然。</p><h1 id="ee51" class="mc md iq bd me mf mg mh mi mj mk ml mm kf mn kg mo ki mp kj mq kl mr km ms mt bi translated">结论</h1><p id="0207" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">做一个负责任、成熟的开发者很重要。学习并获得无缝有效地使用强制(显性和隐性)的经验，以及将知识传授给他人，是这里的关键。</p><h2 id="cf40" class="nn md iq bd me no np dn mi nq nr dp mm lo ns nt mo ls nu nv mq lw nw nx ms iw bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="87d9" class="pw-post-body-paragraph lf lg iq lh b li mu ka lk ll mv kd ln lo mw lq lr ls mx lu lv lw my ly lz ma ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae le" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="lh ja">AI in Plain English</strong></a><a class="ae le" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="lh ja">UX in Plain English</strong></a><a class="ae le" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="lh ja">Python in Plain English</strong></a><strong class="lh ja"/>——谢谢，继续学习！</p><p id="26a5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae le" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja">submissions @ plain English . io</strong></a><strong class="lh ja"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div><div class="ab cl ny nz hu oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ij ik il im in"><p id="f122" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">感谢阅读这篇文章！如果你有任何问题，请在下面留言。此外，看看我的其他文章，你可能会喜欢:</p><div class="of og gp gr oh oi"><a href="https://medium.com/@vpodk/most-popular-javascript-frameworks-in-2020-afefe8c7c6c5" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ja gy z fp on fr fs oo fu fw iz bi translated">2020年最流行的JavaScript框架</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">每个框架都有自己的优点和缺陷。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow ky oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/@vpodk/progressive-web-apps-and-their-advantages-70d3e119f165" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ja gy z fp on fr fs oo fu fw iz bi translated">渐进式网络应用及其优势</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">许多人甚至不知道很多流行的日常应用实际上是进步的网络应用。</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow ky oi"/></div></div></a></div></div></div>    
</body>
</html>