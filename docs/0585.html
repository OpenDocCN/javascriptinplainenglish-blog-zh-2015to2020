<html>
<head>
<title>Object Oriented JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-oriented-javascript-part-1-1881c3aa694f?source=collection_archive---------2-----------------------#2019-11-12">https://javascript.plainenglish.io/object-oriented-javascript-part-1-1881c3aa694f?source=collection_archive---------2-----------------------#2019-11-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9416" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">[第一部分]</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/bbbab6fc99628470add15052bb51d73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-25KB7EbSHjv70HXrdl6w.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">JavaScript</figcaption></figure><h1 id="344f" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">JavaScript中的面向对象编程是什么？💻</h1><p id="0c20" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">面向对象编程是一种流行的编程风格，它从一开始就扎根于JavaScript。</p><p id="5e37" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">如果你已经有了用另一种语言进行面向对象编程的经验，请把你所掌握的知识放在一边，以初学者的心态通读整个模块。</p><p id="5d38" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">这是因为JavaScript中的面向对象编程与其他语言中的面向对象编程非常不同。这比实际情况更困难。</p><p id="51d8" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">现在，让我们从了解JavaScript中的OOP是什么开始:</p><h1 id="310f" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">从公共对象创建对象:</h1><p id="2812" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">JavaScript中的对象有<code class="fe ml mm mn mo b">properties</code>和<code class="fe ml mm mn mo b">methods</code>。这些物体可以模拟现实生活中的事物。</p><p id="7d31" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">这里，我们试图用JavaScript构建一个<code class="fe ml mm mn mo b">user</code>对象。一个<code class="fe ml mm mn mo b">user</code>有一个<code class="fe ml mm mn mo b">firstName</code>、<code class="fe ml mm mn mo b">lastName</code>和一个<code class="fe ml mm mn mo b">age</code>。我们可以在JavaScript中添加这些属性。</p><p id="e334" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">用户有一些细节，我们可以通过函数<code class="fe ml mm mn mo b">getDetails()</code>提取这些细节，我们也可以将这个函数作为<code class="fe ml mm mn mo b">method</code>写在<code class="fe ml mm mn mo b">user</code>对象中。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Simple_Object.js</figcaption></figure><p id="c40e" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">通过使用这种方法，对于每个新用户，我们必须重新编写整个代码，这将使代码又长又乱。</p><p id="2136" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">我们可以不使用上述方法，而是创建一个函数(或类似的东西)来使个体。</p><p id="2c24" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">然后构造一个带有<code class="fe ml mm mn mo b">this</code>关键字的函数，我们将创建带有<code class="fe ml mm mn mo b">new</code>关键字的个体。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Constructor_Function.js</figcaption></figure><p id="e078" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io">注意:</strong>在面向对象编程中，<strong class="lm io">构造函数的第一个字母是大写的</strong> ( <code class="fe ml mm mn mo b">User</code>)，而每个实例的写法都像普通变量(akash，abha等)..).</p><p id="01dc" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">这种微小的差异立即向您展示了代码中构造函数和实例之间的区别。</p><h1 id="ad42" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">“这个”是什么？</h1><p id="a62a" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated"><code class="fe ml mm mn mo b">this</code>是JavaScript中的一个关键字。当在构造函数中使用时，它指的是用构造函数创建的实例。</p><p id="8074" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><code class="fe ml mm mn mo b">this</code>是面向对象编程中一个非常重要的概念。所以你需要熟悉它。</p><p id="e12b" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">不幸的是，JavaScript中的<code class="fe ml mm mn mo b">this</code>的值会根据调用函数的方式而变化，这是意料之外的，会造成很多混乱。</p><p id="fe1d" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">因此，在给定的课程中，您将了解更多关于<code class="fe ml mm mn mo b">this</code>的知识，以帮助您熟悉<code class="fe ml mm mn mo b">this</code>可能采用的不同值。</p><div class="mr ms gp gr mt mu"><a href="https://blog.skylinee.me/how-to-master-javascripts-this-keyword-ck1052xz3002civs1hwsuwj9k" rel="noopener  ugc nofollow" target="_blank"><div class="mv ab fo"><div class="mw ab mx cl cj my"><h2 class="bd io gy z fp mz fr fs na fu fw im bi translated">如何掌握JavaScript的“This”关键字！！</h2><div class="nb l"><h3 class="bd b gy z fp mz fr fs na fu fw dk translated">这是一个在面向对象编程中经常使用的关键字。在传统的面向对象编程中…</h3></div><div class="nc l"><p class="bd b dl z fp mz fr fs na fu fw dk translated">blog . skyline . me</p></div></div><div class="nd l"><div class="ne l nf ng nh nd ni km mu"/></div></div></a></div><h1 id="3bb6" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">js中有4层oops:</h1><ul class=""><li id="6a89" class="nj nk in lm b ln lo lq lr lt nl lx nm mb nn mf no np nq nr bi translated"><strong class="lm io">第1层</strong> —单个对象的对象定向</li><li id="f224" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf no np nq nr bi translated"><strong class="lm io">第2层</strong> —对象的原型链</li><li id="2f25" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf no np nq nr bi translated"><strong class="lm io">第三层</strong> —构造函数作为实例的工厂，类似于其他语言中的类</li><li id="9d7c" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf no np nq nr bi translated"><strong class="lm io">第4层</strong> —子类化，通过继承现有的构造函数来创建新的构造函数</li></ul><h1 id="848b" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">简而言之，这4层:</h1><ul class=""><li id="886c" class="nj nk in lm b ln lo lq lr lt nl lx nm mb nn mf no np nq nr bi translated">第一层:单一对象——JavaScript的基本OOP构建模块——对象是如何独立工作的？</li><li id="b4de" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf no np nq nr bi translated"><strong class="lm io">第二层</strong>:原型链:每个对象都有一个零个或多个原型对象的链。原型是JavaScript的核心继承机制。</li><li id="8973" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf no np nq nr bi translated">第三层:类——JavaScript的类是对象的工厂。类和它的实例之间的关系是基于原型继承的。</li><li id="a66e" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf no np nq nr bi translated">第4层:子类化——子类和超类之间的关系也是基于原型继承的。</li></ul></div><div class="ab cl nx ny hr nz" role="separator"><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc od"/><span class="oa bw bk ob oc"/></div><div class="ig ih ii ij ik"><h1 id="cbc9" class="ks kt in bd ku kv oe kx ky kz of lb lc jt og ju le jw oh jx lg jz oi ka li lj bi translated">第1层:单一对象的对象定向</h1><h1 id="58e0" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">什么是对象？</h1><p id="b03c" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">JavaScript中的对象是一种数据类型，它由<code class="fe ml mm mn mo b">names</code>或<code class="fe ml mm mn mo b">keys</code>和<code class="fe ml mm mn mo b">values</code>的集合组成，用<code class="fe ml mm mn mo b">key</code> : <code class="fe ml mm mn mo b">value</code>对表示。<code class="fe ml mm mn mo b">key</code> : <code class="fe ml mm mn mo b">value</code>对由可能包含任何数据类型的属性组成——包括字符串、数字和布尔值——以及方法，即包含在对象中的函数。</p><h1 id="20cf" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">什么是属性、键和值？</h1><p id="420a" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">JavaScript中的所有对象都是从字符串到值的映射(字典)。对象中的一个条目被称为<code class="fe ml mm mn mo b">Property</code>。属性的<code class="fe ml mm mn mo b">key</code>总是一个文本字符串，属性的<code class="fe ml mm mn mo b">value</code>可以是任何JavaScript值，包括函数。方法是其值是函数的属性。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Property_Keys_Example</figcaption></figure><h2 id="9640" class="oj kt in bd ku ok ol dn ky om on dp lc lt oo op le lx oq or lg mb os ot li ou bi translated">有三种属性:</h2><ul class=""><li id="6bf4" class="nj nk in lm b ln lo lq lr lt nl lx nm mb nn mf no np nq nr bi translated"><strong class="lm io">属性</strong>:这些是对象中的普通属性，即从字符串键到值的映射。&amp;多包含1个调用为<code class="fe ml mm mn mo b">named data properties</code>，其中包含<code class="fe ml mm mn mo b">methods</code></li><li id="d4e9" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf no np nq nr bi translated"><strong class="lm io">访问器</strong>:特殊的方法，其调用看起来像读取或写入属性。(普通属性是属性值的存储位置，访问器允许我们计算属性值)。</li><li id="9405" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf no np nq nr bi translated"><strong class="lm io">内部属性</strong>:这些不能从JavaScript直接访问，但是可能有一些间接的方法访问它们:<br/> <strong class="lm io">例子</strong> : <code class="fe ml mm mn mo b">[[Prototype]]</code>保存一个对象的原型，可以通过<code class="fe ml mm mn mo b">Object.getPrototypeof()</code>读取。</li></ul><h1 id="0dc6" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">JavaScript中对象的两个角色:</h1><ul class=""><li id="f4a2" class="nj nk in lm b ln lo lq lr lt nl lx nm mb nn mf no np nq nr bi translated">对象作为记录</li><li id="515c" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf no np nq nr bi translated">对象作为字典</li></ul><h1 id="fdbd" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">作为记录的对象:</h1><ul class=""><li id="c600" class="nj nk in lm b ln lo lq lr lt nl lx nm mb nn mf no np nq nr bi translated"><strong class="lm io">记录</strong>:作为记录的对象有固定数量的属性，它们的键在开发时是已知的。它们的值可以有不同的类型。</li></ul><p id="c0c4" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">对象作为记录是通过所谓的对象文字创建的。对象文字是JavaScript的一个突出特性:它允许我们直接创建对象而不需要类。</p><p id="0ec6" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">示例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">objectAsRecords</figcaption></figure><h1 id="8405" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">点运算符(。):通过固定键访问属性:</h1><ul class=""><li id="b347" class="nj nk in lm b ln lo lq lr lt nl lx nm mb nn mf no np nq nr bi translated"><strong class="lm io">获取属性</strong>:点运算符允许我们“获取”一个属性(读取它的值)。</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Getting_Properties</figcaption></figure><ul class=""><li id="1fe7" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io">调用方法</strong>:点运算符也用于调用方法。</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Calling_Properties</figcaption></figure><ul class=""><li id="7aec" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io">设置属性</strong>:对于设置值，我们通过点符号使用赋值运算符(=)。</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Setting_Properties</figcaption></figure><ul class=""><li id="cfdf" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io">删除属性</strong>:T2操作符允许我们完全删除一个属性(整个键-值对)。</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Delete_Properties_1</figcaption></figure><p id="d5be" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><code class="fe ml mm mn mo b">delete</code>返回<code class="fe ml mm mn mo b">false</code>，如果该属性是不能删除的自有属性。否则在所有其他情况下返回<code class="fe ml mm mn mo b">true</code></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Delete_Properties_2</figcaption></figure><p id="0212" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><code class="fe ml mm mn mo b">delete</code>返回<code class="fe ml mm mn mo b">true</code>，即使它没有改变任何东西(继承的属性永远不会被删除)</p><pre class="kd ke kf kg gt oy mo oz pa aw pb bi"><span id="2aa9" class="oj kt in mo b gy pc pd l pe pf">delete user.toString // true<br/>console.log(user.toString) // [λ: toString] (Still Exists)</span></pre><h2 id="c647" class="oj kt in bd ku ok ol dn ky om on dp lc lt oo op le lx oq or lg mb os ot li ou bi translated"><strong class="ak">访问器:</strong>JavaScript中有两种访问器:</h2><ol class=""><li id="581e" class="nj nk in lm b ln lo lq lr lt nl lx nm mb nn mf pg np nq nr bi translated"><strong class="lm io"> Getter </strong>(读取)一个属性。</li><li id="59cd" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf pg np nq nr bi translated"><strong class="lm io"> Setter </strong>(写)一个属性。</li></ol><ul class=""><li id="54c7" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io">Getter:</strong>Getter是通过在方法定义前加上关键字<code class="fe ml mm mn mo b">get</code>来创建的:</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Getter_Properties</figcaption></figure><ul class=""><li id="d709" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io"> Setter : </strong>通过在方法定义前加上关键字<code class="fe ml mm mn mo b">set</code>来创建Setter:</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Setter_Properties</figcaption></figure><h2 id="4920" class="oj kt in bd ku ok ol dn ky om on dp lc lt oo op le lx oq or lg mb os ot li ou bi translated">扩展成对象文字(…)</h2><p id="9e64" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">在对象文字内部，扩展属性将另一个对象的属性添加到当前对象中:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Spreading_In_Object_literals</figcaption></figure><h2 id="841c" class="oj kt in bd ku ok ol dn ky om on dp lc lt oo op le lx oq or lg mb os ot li ou bi translated">方法:</h2><p id="f573" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我们知道普通函数扮演着几个角色。<code class="fe ml mm mn mo b">Method</code>就是那种角色。</p><p id="b1ab" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">示例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Methods_in_Object</figcaption></figure><ul class=""><li id="6ea3" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io"> Call() : </strong> <code class="fe ml mm mn mo b">call</code>是一个允许我们调用/调用/激活另一个函数的函数。当我们使用<code class="fe ml mm mn mo b">call</code>调用一个函数时，我们可以改变<code class="fe ml mm mn mo b">this</code>的上下文。<br/> <strong class="lm io">例如:</strong></li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Call_Method_1</figcaption></figure><p id="059c" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><code class="fe ml mm mn mo b">call</code>用于从另一个函数(或方法)借用方法。</p><p id="585a" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">例:假设你有一个数字数组。您想使用<code class="fe ml mm mn mo b">slice</code>将数字复制到一个新的数组中。使用<code class="fe ml mm mn mo b">slice</code>的一种方法是通过数字数组调用slice方法。</p><p id="2fd7" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">通过<code class="fe ml mm mn mo b">call</code>的另一种方式是当您使用<code class="fe ml mm mn mo b">call</code>时，您需要传递数字数组作为<code class="fe ml mm mn mo b">this</code>上下文。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Call_Method_2</figcaption></figure><p id="7c4f" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io">但为什么我们用这个</strong> <code class="fe ml mm mn mo b"><strong class="lm io">Array.prototype.slice.call</strong></code> <strong class="lm io">胜过</strong> <code class="fe ml mm mn mo b"><strong class="lm io">array.slice</strong></code> <strong class="lm io">时其如此复杂呢？</strong></p><p id="3456" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">人们将<code class="fe ml mm mn mo b">call</code>与数组方法一起使用，因为大多数数组方法(如<code class="fe ml mm mn mo b">slice</code>、<code class="fe ml mm mn mo b">forEach</code>、<code class="fe ml mm mn mo b">filter</code>和<code class="fe ml mm mn mo b">map</code>)既可以处理数组，也可以处理类似数组的对象。</p><p id="7d90" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io">例子:</strong>我们也可以对类似数组的对象进行操作。</p><pre class="kd ke kf kg gt oy mo oz pa aw pb bi"><span id="9a61" class="oj kt in mo b gy pc pd l pe pf">const obj = { foo: [1, 2, 3] } <br/>const arrayMethods = Array.prototype.reverse.call(obj.foo) console.log(arrayMethods)// [3, 2, 1]</span></pre><ul class=""><li id="48e6" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io">应用()</strong></li></ul><p id="7ffe" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">call和apply方法之间的唯一区别是传递参数的方式。对于<code class="fe ml mm mn mo b">apply</code>方法，第二个参数是一个<code class="fe ml mm mn mo b">array</code>参数，而对于<code class="fe ml mm mn mo b">call</code>方法，参数是单独传递的。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Apply_Method</figcaption></figure><p id="7069" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io">注意</strong>:在ES6中，不需要<code class="fe ml mm mn mo b">apply</code>方法，因为我们可以用<code class="fe ml mm mn mo b">spread</code>操作符展开数组。</p><ul class=""><li id="b352" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io"> Bind() </strong></li></ul><p id="5817" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><code class="fe ml mm mn mo b">bind</code>允许您更改<code class="fe ml mm mn mo b">this</code>上下文。然而，<code class="fe ml mm mn mo b">bind</code>并没有立即调用函数，而是返回一个带有您提供的参数的函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Bind_Method</figcaption></figure><h2 id="e0c6" class="oj kt in bd ku ok ol dn ky om on dp lc lt oo op le lx oq or lg mb os ot li ou bi translated">异常属性键:</h2><p id="b893" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我们不能用保留字(如var和function)作为变量名，但我们可以用它们作为属性键:</p><pre class="kd ke kf kg gt oy mo oz pa aw pb bi"><span id="c6fd" class="oj kt in mo b gy pc pd l pe pf">var obj = { var: 'a', function: 'b' };<br/>obj.var // 'a'<br/>obj.function // 'b'</span></pre><h1 id="a9bf" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">作为词典的对象:</h1><p id="ac29" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated"><strong class="lm io">字典:</strong>作为字典的对象具有数量可变的属性，其关键字在开发时是未知的。它们所有的值都具有相同的类型。</p><p id="056c" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">对象最好用作记录。但是在ES6之前，JavaScript没有字典的数据结构(ES6带来了地图)。因此，对象必须被用作字典。因此，<code class="fe ml mm mn mo b">keys</code>必须是字符串，但是<code class="fe ml mm mn mo b">values</code>可以有任意的类型。</p><p id="8bd9" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io">任意固定字符串作为属性键:</strong></p><p id="781d" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">随着我们从作为记录的对象向作为字典的对象前进，将会有一个重要的变化，那就是我们必须能够使用<code class="fe ml mm mn mo b">arbitrary strings &amp; numbers</code>作为属性键。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Object_As_Dictionaries</figcaption></figure><h1 id="269e" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">方括号运算符([ ]):通过计算的键访问属性</h1><p id="b9c6" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">括号运算符允许我们通过表达式引用属性。</p><ul class=""><li id="60ea" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io">获取属性</strong></li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Getting_Property_With_Bracket_Operator</figcaption></figure><ul class=""><li id="9e8f" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io">调用方法</strong></li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Calling_Property_With_Bracket_Operator</figcaption></figure><ul class=""><li id="e9d0" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io">设置属性</strong></li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Setting_Property_With_Bracket_Operator</figcaption></figure><ul class=""><li id="678d" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io">删除属性</strong></li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Delete_Property_With_Bracket_Operator</figcaption></figure><h1 id="ec0a" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">检测属性:</h1><p id="36b1" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我们将使用<code class="fe ml mm mn mo b">in</code>操作符来检测属性，因为<code class="fe ml mm mn mo b">in</code>操作符检查给定的键是否存在于哈希表中，这被认为是确定属性是否存在于对象中的最佳方式。此外，从性能角度来看，它不会延迟。</p><p id="0000" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">在某些情况下，我们可能希望只在某个属性是自己的属性时才检查它是否存在。<code class="fe ml mm mn mo b">in</code>操作员检查自身属性和原型属性。所以我们将需要采取不同的方法<code class="fe ml mm mn mo b">hasOwnProperty()</code>函数，如果当属性为对象所拥有时返回<code class="fe ml mm mn mo b">true</code>，对于原型属性返回<code class="fe ml mm mn mo b">false</code>。</p><p id="8891" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">在给定的例子中,<code class="fe ml mm mn mo b">toString</code>是一个原型属性。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Detecting_Property</figcaption></figure><h1 id="e512" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">高级方法:</h1><h2 id="cec5" class="oj kt in bd ku ok ol dn ky om on dp lc lt oo op le lx oq or lg mb os ot li ou bi translated">标准方法:</h2><p id="eaba" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated"><code class="fe ml mm mn mo b">Object.prototype</code>定义了几个可以被覆盖的标准方法。两个重要的是:</p><ul class=""><li id="f924" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><code class="fe ml mm mn mo b">.toString</code>:配置如何将对象转换为字符串:主要用于调试目的</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">toString_Method</figcaption></figure><ul class=""><li id="b806" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><code class="fe ml mm mn mo b">.valueOf</code>:配置如何将对象转换为数字</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">valueOf_Method</figcaption></figure><h1 id="c3fb" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">枚举:</h1><p id="8616" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">默认情况下，添加到对象中的所有属性都是可枚举的，这意味着您可以使用一个<code class="fe ml mm mn mo b">for-in</code>循环迭代它们。可枚举属性的内部<code class="fe ml mm mn mo b">[[Enumerable]]</code>属性设置为true。<code class="fe ml mm mn mo b">for-in</code>循环枚举一个对象的所有可枚举属性。</p><p id="5b8d" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">借助给定的示例，您可以很容易理解这一点:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Enumeration_1</figcaption></figure><p id="e6bb" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">如果您想列出一个对象的所有属性以便以后在程序中使用。ECMAScript 5引入了<code class="fe ml mm mn mo b">Object.keys ()</code>方法来检索可枚举属性名的数组。</p><p id="6fa3" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io">注意:</strong>并不是所有的属性都是可枚举的。</p><p id="abe0" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">事实上，对象的大多数本地方法都将其<code class="fe ml mm mn mo b">[[Enumerable]]</code>属性设置为。您可以使用<code class="fe ml mm mn mo b">propertyIsEnumerable()</code>方法检查属性是否可枚举，该方法存在于每个对象中:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Enumeration_2</figcaption></figure><h1 id="33ea" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">属性和属性描述符</h1><p id="a242" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated"><strong class="lm io">属性属性:</strong>属性属性是属性的原子构建块。</p><p id="41e3" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">属性的所有状态，包括数据和元数据，都存储在属性中。它们是属性拥有的字段，就像对象拥有属性一样。</p><ul class=""><li id="e036" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated">属性键通常写在双括号中。</li><li id="6313" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf no np nq nr bi translated">属性对于普通属性和访问器很重要。</li></ul><p id="7681" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io">属性描述符:</strong>这是一个数据结构，用于以编程方式处理属性。</p><p id="f250" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io">常用属性:</strong></p><ul class=""><li id="3786" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io">可枚举</strong>:决定是否可以迭代属性。</li><li id="ed9b" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf no np nq nr bi translated"><strong class="lm io">可配置</strong>:决定属性是否可以更改。</li></ul><p id="4ba2" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io"> 1。</strong> <strong class="lm io">数据属性属性: (包含多余的两个)</strong></p><ul class=""><li id="99f4" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io"> Value </strong>:保存属性值(在示例中可以更好的理解)</li><li id="1150" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf no np nq nr bi translated"><strong class="lm io">可写</strong>:表示属性是否可写的布尔值。</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Data_Properties</figcaption></figure><p id="f82a" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io"> 2。</strong> <strong class="lm io">取值属性(包含不同的两个属性)</strong></p><p id="fe9c" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">访问者属性还有两个附加属性。由于没有为访问器属性存储值，这就是为什么不需要<code class="fe ml mm mn mo b">[[value]]</code>或<code class="fe ml mm mn mo b">[[writable]]</code>。</p><ul class=""><li id="7c2a" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><strong class="lm io">获取</strong>:包含获取功能</li><li id="2e4a" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf no np nq nr bi translated"><strong class="lm io">设定</strong>:包含设定器功能</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Accessor_Properties</figcaption></figure><p id="2bd1" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io"> 3。多重属性</strong></p><p id="1565" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">如果使用<code class="fe ml mm mn mo b">Object.defineProperties()</code>而不是<code class="fe ml mm mn mo b">Object.defineProperty()</code>，也可以同时定义一个对象的多个属性</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Multiple_Properties</figcaption></figure><p id="84b4" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io"> 4。检索方法</strong></p><p id="4f00" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">如果你想获取属性，你可以使用<code class="fe ml mm mn mo b"><strong class="lm io">Object.getOwnPropertyDescriptor().</strong></code>很容易做到</p><ul class=""><li id="5890" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf no np nq nr bi translated"><code class="fe ml mm mn mo b">Object.getOwnPropertyDescriptor()</code>:返回一个具有可枚举、可配置、可写值的对象</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Reriveal_Method</figcaption></figure><h1 id="07f2" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">防止对象修改:使对象不可变</h1><p id="7191" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">正如我们所知，默认情况下，对象是可变的，这意味着我们可以向它添加新的属性，但是为了防止这些添加，我们使用了名为<code class="fe ml mm mn mo b">[[Extensible]]</code>的属性，它本质上是布尔型的。</p><p id="7e97" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">如果<code class="fe ml mm mn mo b">[[Extensible]]</code>是<code class="fe ml mm mn mo b">false</code>，那么我们可以阻止新的属性被添加到一个对象中。</p><p id="4b3c" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">默认情况下，<code class="fe ml mm mn mo b">[[Extensible]]</code>被设置为每个对象上的一个<code class="fe ml mm mn mo b">true</code></p><p id="ade5" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">还有三种不同的方法可以防止对象被修改:</p><ol class=""><li id="8c5d" class="nj nk in lm b ln mg lq mh lt ov lx ow mb ox mf pg np nq nr bi translated"><strong class="lm io">防止扩展</strong></li><li id="4633" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf pg np nq nr bi translated"><strong class="lm io">密封对象</strong></li><li id="5547" class="nj nk in lm b ln ns lq nt lt nu lx nv mb nw mf pg np nq nr bi translated"><strong class="lm io">冻结物体</strong></li></ol><h1 id="74d5" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">1.防止扩展</h1><p id="a00f" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">在这个方法中，我们可以使用<code class="fe ml mm mn mo b">Object.preventExtensions()</code>法。在此之后，我们将再也不能添加任何新的属性。</p><p id="eaf0" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">我们也可以通过使用方法<code class="fe ml mm mn mo b">Object.isExtensible()</code>来检查<code class="fe ml mm mn mo b">[[Extensible]]</code>的值</p><p id="44ff" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io">例如:</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Preventing_Extensions</figcaption></figure><h1 id="fb20" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">2.密封物体</h1><p id="be59" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">在这个方法中，我们可以使用<code class="fe ml mm mn mo b">Object.seal()</code>方法和这个函数<code class="fe ml mm mn mo b">seal</code>对象，这意味着我们既不能添加属性，也不能删除或更改它们的类型。</p><p id="eb9f" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io">例如:</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Sealing_Object</figcaption></figure><h1 id="45aa" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">3.冷冻物体</h1><p id="e7e9" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">在这个方法中我们可以使用<code class="fe ml mm mn mo b">Object.freeze()</code>方法和这个函数<code class="fe ml mm mn mo b">freezes</code>对象。这类似于密封函数，但在这个方法中，我们不能写入现有的属性。</p><p id="bbbb" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated">此方法中的数据属性是只读的。</p><p id="05e3" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io">注</strong>:冻结的物体不能解冻</p><p id="1584" class="pw-post-body-paragraph lk ll in lm b ln mg jo lp lq mh jr ls lt mi lv lw lx mj lz ma mb mk md me mf ig bi translated"><strong class="lm io">例如:</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mp mq l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Freezing_Objects</figcaption></figure></div></div>    
</body>
</html>