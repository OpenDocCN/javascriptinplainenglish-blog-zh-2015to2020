<html>
<head>
<title>Data Access Models with Node</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">节点数据访问模型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/data-access-models-with-node-15b0e30807b4?source=collection_archive---------2-----------------------#2020-08-09">https://javascript.plainenglish.io/data-access-models-with-node-15b0e30807b4?source=collection_archive---------2-----------------------#2020-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/837c808605e31389d30ead6e0fbbebd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*10xBxuQ2K3uH7E0O"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mvdheuvel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Maarten van den Heuvel</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b329" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不必为需要访问的每个表编写CRUD方法，我们可以创建一个模块来提供数据，并且可以根据需要进行扩展。本文将详细介绍这一过程，并提供一个示例应用程序来总结这些步骤。</p><p id="c5ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相关的存储库可以在<a class="ae kc" href="https://github.com/grovercoder/article-data-access-model" rel="noopener ugc nofollow" target="_blank">https://github.com/grovercoder/article-data-access-model</a>找到。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="405c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经编写了许多应用程序，几乎每一个都需要一个公共实体——特定于数据库表的数据访问模型。在过去，我已经在飞行中创建了这些，但这个问题不断出现，所以是时候让它变得更容易了。</p><p id="ce3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也许可以通过使用一个像<a class="ae kc" href="https://sequelize.org/" rel="noopener ugc nofollow" target="_blank"> Squelize </a>或<a class="ae kc" href="https://vincit.github.io/objection.js/" rel="noopener ugc nofollow" target="_blank"> Objection这样的对象关系映射系统来完成这个任务。JS </a>。这些是健壮的通用系统，可能比我们需要的要多得多。在某些情况下，向应用程序中添加另一个框架并不是最佳解决方案。在我的例子中，数据库需求要么非常基本，要么非常特定于应用程序和数据库。所以ORM通常不是正确的答案。</p><p id="ef2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想要的是一个简单的通用模块，它提供通用的CRUD方法，并且可以扩展附加功能。</p><p id="bd94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注:</strong>我们这里说的是抽象的想法。但是当谈到使用这些想法时，我们需要一个具体的例子。我们将假设一个简单的任务数据库，因为我们通过代码工作。该数据库将有两个表——组和任务。我们将在构建实例时使用这些。</p><h1 id="5bbd" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">要求</h1><p id="2bc9" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们可能应该更详细地定义我们试图构建的内容，这样我们就知道什么时候完成了。</p><ul class=""><li id="63df" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">核心模块不应该了解数据库或表。</li><li id="1b3d" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">数据库连接和表模式(也就是字段及其数据类型的列表)应该被传递到模块中。</li><li id="310e" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">然后，该模块将使用模式信息来构建必要的函数。</li><li id="b433" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">该模块将导出一个对象，然后可以立即用于处理指定的表。</li><li id="126e" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">解决方案应该允许一些字段被“保护”。也就是说，当返回一个记录或记录集时，受保护的字段应该从输出中省略。(即，用户密码不应包含在默认使用模式中。)如果需要，受保护的字段仍然可以通过自定义方法使用。</li><li id="4794" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">CRUD方法都应该在导出的对象上定义。</li><li id="e645" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">如果需要，可以覆盖CRUD方法。</li><li id="4b21" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">导出的对象可以包括只读信息属性(即，反映出当前设置的表名、模式和保护值)。</li></ul><h1 id="7196" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">草案初稿</h1><p id="6016" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">基于这些要求，我们正在寻找看起来有点像这样的东西:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c098" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到这立即失败了，因为我们没有办法指定表名、模式或保护值。我们可以通过导出函数而不是对象来解决这个问题。该函数将通过一个<code class="fe nf ng nh ni b">config</code>参数接收所需的数据，并返回所需的对象。这是一个<a class="ae kc" href="https://en.wikipedia.org/wiki/Factory_method_pattern" rel="noopener ugc nofollow" target="_blank">工厂方法</a>的实现。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="9b25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们利用<em class="nj">依赖注入</em>来传递数据库连接和其他模型配置。我们的<code class="fe nf ng nh ni b">_model.js</code>文件并不依赖于任何特定的东西。</p><p id="1fb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了继续，我们需要做出两个选择，这两个选择将决定将来如何使用该模块。</p><ul class=""><li id="c8ec" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated">首先，我们需要决定如何指定表模式。</li><li id="073b" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">其次，我们需要决定数据库连接对象的外观。</li></ul><p id="6da9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两者都将这个版本的模块锁定在那些特定的决策上。例如，如果我们决定连接将是一个已配置的Knex。JS对象，那么我们就永远不能将这个模型定义用于MongoDB数据存储。(除非我们的MongoDB连接具有与Knex相同的方法。JS对象。)通过一些努力，我们可以减轻这种情况，也许可以使用适配器模式。出于我们的目的，我们将保持事情(相对)简单，并假设我们只是创建一个不同的模块实例来处理不同的连接类型。所以我们可能会以<code class="fe nf ng nh ni b">_model.knex.js</code>和<code class="fe nf ng nh ni b">_model.mongo.js</code>结束。那么我们的应用程序模型可能只需要适当的基础模块。这只是一种选择。</p><h2 id="1503" class="nk lj iq bd lk nl nm dn lo nn no dp ls ko np nq lw ks nr ns ma kw nt nu me nv bi translated">定义模式</h2><p id="c12b" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们可以用一个数组，甚至一个对象数组来定义我们的模式。或逗号分隔的字符串。然而<a class="ae kc" href="https://json-schema.org/" rel="noopener ugc nofollow" target="_blank"> JSON Schema </a>已经是一个很好的工具来满足这种需求。它不仅允许我们定义自己的字段和字段类型(以一种适用于JS的方式)，还允许我们使用标准系统，而不需要定义自己的系统。</p><p id="278c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将要求模型对象的所有实例都必须传入一个JSON模式对象，以定义表的字段列表。我们一会儿会看到一个例子。</p><h2 id="485e" class="nk lj iq bd lk nl nm dn lo nn no dp ls ko np nq lw ks nr ns ma kw nt nu me nv bi translated">定义数据库连接</h2><p id="aee8" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">如上所述，我们可以选择任何数据库连接对象。对于我们这里的例子，我们将使用Knex.JS .只是因为我需要定期连接到RDBMS类型的数据库，我相信这是一个非常常见的任务。</p><h2 id="b747" class="nk lj iq bd lk nl nm dn lo nn no dp ls ko np nq lw ks nr ns ma kw nt nu me nv bi translated">创建更好的实例对象</h2><p id="55b4" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">到目前为止，我们只是在用法部分使用了我们的核心模型。但这不是我们真正要做的。相反，让我们为两个示例表——组和任务——创建一个实际的实例。</p><p id="94eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关于命名标准的简短说明。我的模型使用表名的单数时态来命名。表名是表包含的对象的复数时态。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4013" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，我们将“knex”对象与表名、模式和保护值一起传递到模型中。</p><p id="b283" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经为任务模型包含了“受保护”的值，这样我们就不需要在以后重新讨论它。假设<code class="fe nf ng nh ni b">public_code</code>字段由数据库生成并在第三方系统中使用，但我们的代码并不真正需要它。通过将其标记为guarded，它将从我们的模型函数的输出中省略。(我们还需要构建它)。因此，受保护的值只是一个与JSON模式对象的“属性”相匹配的字段名数组。空数组也是有效的，表明我们不需要保护任何字段。</p><p id="f4d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该模式看起来很复杂，但它主要是剪切和粘贴现有的定义，并根据需要进行调整。对于JSON模式，我们可以做/指定更多的事情，但是此时我们最感兴趣的是属性列表。属性也非常有用，但是如果/当你需要的时候，我会留给你去扩展它。</p><p id="f478" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的实例模型定义就完成了。从这里，我们可以访问our _model.js模块为我们展示的所有功能。不过现在这还很少。</p><h2 id="4242" class="nk lj iq bd lk nl nm dn lo nn no dp ls ko np nq lw ks nr ns ma kw nt nu me nv bi translated">向模型添加功能</h2><p id="cd9d" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">有两个我们还没有谈到的必要功能:</p><ul class=""><li id="ceae" class="ml mm iq kf b kg kh kk kl ko mn ks mo kw mp la mq mr ms mt bi translated"><code class="fe nf ng nh ni b">guard()</code>法。这个方法检查一个数据对象，并删除在<code class="fe nf ng nh ni b">guarded</code>数组中命名的任何属性。这主要是一个内部函数，在需要的时候会被CRUD方法调用。</li><li id="bac4" class="ml mm iq kf b kg mu kk mv ko mw ks mx kw my la mq mr ms mt bi translated">一种<code class="fe nf ng nh ni b">populate()</code>方法。它接受一个数据对象，然后只提取与模式定义的属性相匹配的属性。这为我们提供了一个基本的验证过程，并确保生成的数据对象可以在我们的创建和更新方法中使用。不需要额外的检查来确保我们没有无意中通过一个不存在的字段。同样，这主要是一个内部方法。(尽管仍然强烈建议进行良好的验证，但这超出了本文的范围……)</li></ul><p id="6510" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将首先创建这两个方法，因为其余的依赖于它们，这两个方法都很好地定义了剩余CRUD函数的秘密。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c16a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们在工厂方法中定义两个函数— <code class="fe nf ng nh ni b">_guard</code>和<code class="fe nf ng nh ni b">_populate</code>。两者都是返回函数的函数。<code class="fe nf ng nh ni b">config</code>参数(定义为模块工厂方法的一部分)被传递给这两个方法。这允许我们访问配置数据。如果没有这种方法，我们将需要以<code class="fe nf ng nh ni b">MyModel.guard(config, record)</code>的形式调用函数，这是不自然的。相反，我们希望<code class="fe nf ng nh ni b">MyModel.guard(record)</code>和“我的模型”对象应该已经知道什么配置信息是需要的。</p><p id="f397" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe nf ng nh ni b">guard</code>方法非常简单。它返回的函数接受一个“记录”参数(它应该是任何普通的键/值对象)。它检查我们的模型配置是否定义了一个受保护的数组。如果是这样，它遍历受保护数组中的每个值，并从记录对象中删除该字段。然后返回记录对象，不包含不需要的字段。</p><p id="0441" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">populate方法只是稍微复杂一点。它返回的函数接受一个“数据”对象。它检查模型是否定义了schema.properties对象。如果是这样，它从该对象中提取键并循环访问它们。属性对象是从模式中提取出来的—稍后将使用它来确保我们返回正确的数据类型。提取传入数据对象的当前值，我们将对此进行一些操作。如果提取的值被定义，那么我们将它与模式属性的类型进行比较，以确保它被设置为适当的JS数据类型。</p><p id="025c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果/当需要时，此部分可以扩展到包括其他项目。例如，如果属性格式是“email”，您可能希望验证当前值是否是正确的电子邮件地址，或者将它包装在mailto锚标记中。如果需要，请随意扩展此部分。(当然，也可以是任何代码)。</p><p id="9306" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于每个CRUD操作，都要重复将config对象传递给一个函数的方法，该函数将返回该函数的最终版本。然后，它们执行必要的步骤来执行适当的CRUD操作，但是使用config对象进行设置。例如，findById方法可以用命令<code class="fe nf ng nh ni b">config.knex(config.tablename).where({id: passedInID}).first()</code>来完成。这是一个简单的Knex。JS命令。在下面的代码中，我调用了几个Knex方法，逻辑应该非常清楚。我建议看看Knex。JS文档来了解这里可以/应该做些什么。</p><h2 id="0751" class="nk lj iq bd lk nl nm dn lo nn no dp ls ko np nq lw ks nr ns ma kw nt nu me nv bi translated">私有与公共属性/方法</h2><p id="955f" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在我们模型的当前版本中，我们已经在返回的对象上设置了<code class="fe nf ng nh ni b">guard</code>和<code class="fe nf ng nh ni b">populate</code>方法。这些现在是对象的公共属性，可以被覆盖。我们的CRUD方法也将是公共的。这满足了我们可以覆盖它们的要求。</p><p id="09a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，我们有一个要求，我们应该有一些只读属性，公开tablename、schema和guarded的当前配置设置。我们可以通过使用原生的JS <a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="noopener ugc nofollow" target="_blank"> Object.defineProperty </a>方法来实现这一点。我们可以将所需的对象放入一个临时变量中，添加只读属性，然后返回临时变量，而不是直接从工厂方法中返回。</p><pre class="mz na nb nc gt nw ni nx ny aw nz bi"><span id="980c" class="nk lj iq ni b gy oa ob l oc od">const output = {...}  <br/>Object.defineProperty(output, '_tablename', {value: config.tablename, writeable: false})</span><span id="5187" class="nk lj iq ni b gy oe ob l oc od">return output</span></pre><p id="3f8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将稍微清理一下代码，并在分配完只读属性后分配方法。这将导致在对象上执行console.log()时，只读项目位于对象的顶部。</p><p id="7ac5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们的final _model.js文件应该如下所示:</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="2eb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们没有错误，并且数据库连接模块工作正常，我们将对我们为其定义实例模型的每个表进行完整的CRUD操作。</p><h2 id="03fa" class="nk lj iq bd lk nl nm dn lo nn no dp ls ko np nq lw ks nr ns ma kw nt nu me nv bi translated">覆盖方法</h2><p id="c49e" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们的需求之一是CRUD方法可以被覆盖。让我们假设我们的任务模型需要create方法的一些附加功能——我们不希望创建一个名称为“Task”的任务。如果名称是“运行”,我们希望将名称更改为“自动任务”。我们仍然需要一个创建方法，我们只需要它的一个特殊版本。</p><figure class="mz na nb nc gt jr"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="b2d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从模型实例的相同定义开始。然后我们存储一个对最初的<code class="fe nf ng nh ni b">create</code>方法的引用。接下来，我们为Model.create属性分配一个新函数。在该函数中，我们可以选择调用原始方法，或者我们可以在这里放置适当的Knex代码来完成我们的任务。这里的要点是我们已经替换了“核心”创建方法。</p><p id="b29f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你尝试<code class="fe nf ng nh ni b">Model._tablename = ‘new value'</code>，你会收到一个错误，因为这是一个只读属性。</p><h2 id="c413" class="nk lj iq bd lk nl nm dn lo nn no dp ls ko np nq lw ks nr ns ma kw nt nu me nv bi translated">样本储存库</h2><p id="ef85" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我已经创建了一个<a class="ae kc" href="https://github.com/grovercoder/article-data-access-model" rel="noopener ugc nofollow" target="_blank">样本库</a>，其中包含了本文中定义的思想。这个示例代码演示了为什么SQLite不应该在生产中使用。我们在<code class="fe nf ng nh ni b">_model.js</code>文件上的<code class="fe nf ng nh ni b">create</code>和<code class="fe nf ng nh ni b">update</code>方法调用Knex的<code class="fe nf ng nh ni b">.returning()</code>方法。SQLite不支持这一点，并阻止我们直接获取新的或更新的数据。我已经在一些应用程序中解决了这个问题，方法是立即对填充的记录数据执行<code class="fe nf ng nh ni b">.find()</code>，减去任何自动生成的数据(比如created_at字段)。这可能看起来像下面这样:</p><pre class="mz na nb nc gt nw ni nx ny aw nz bi"><span id="28fa" class="nk lj iq ni b gy oa ob l oc od">async function create(data) {<br/>  const record = _populate(data)<br/>  await config.knex(config.tablename).insert(record)<br/>  delete record.created_at<br/>  const newRecord = await config.knex(config.tablename)<br/>      .where(record)<br/>      .first()<br/>  return _guard(newRecord)<br/>}</span></pre><p id="ac7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您正在使用SQLite，或者不能依赖于<code class="fe nf ng nh ni b">.returns()</code>方法，这可能对您有用。</p><h2 id="a80b" class="nk lj iq bd lk nl nm dn lo nn no dp ls ko np nq lw ks nr ns ma kw nt nu me nv bi translated">结论</h2><p id="b062" class="pw-post-body-paragraph kd ke iq kf b kg mg ki kj kk mh km kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们可以做很多事情来改善这一点。添加更好的验证和错误处理，处理数据库事务，为模型创建测试，或者只是根据我们的需要进行调整。这应该被视为您自己的应用程序需求的起点。</p><p id="ce37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我欢迎评论/建议/问题来改进这一点。我只是一个人，几乎没有经过同行评议就建立了这个公司。尽管这个解决方案对我的应用程序有效。希望对你自己的应用有用。</p></div></div>    
</body>
</html>