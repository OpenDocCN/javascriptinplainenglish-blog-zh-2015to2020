<html>
<head>
<title>How To Implement Your First Linked List Data Structure In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中实现第一个链表数据结构</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-your-first-linked-list-data-structure-in-javascript-433652a55445?source=collection_archive---------10-----------------------#2020-07-23">https://javascript.plainenglish.io/how-to-implement-your-first-linked-list-data-structure-in-javascript-433652a55445?source=collection_archive---------10-----------------------#2020-07-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2742cabc42b38a867f0807220bb73026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*k6cJ0F7uZt5rInSm"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2b5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将介绍链表的概念，什么是链表，以及如何在项目中实现链表。本文介绍了在JavaScript中实现链表的基本方法。</p><p id="05a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我将假设您已经了解或有了javascript和一般编程概念(如字符串和数组)的基本知识。</p><p id="9c3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">链表只是另一种类似数组、堆栈或队列的数据结构。与数组不同的是，链表包含节点，其中每个节点都有一个存储数据的数据部分和列表中下一个节点的下一部分或引用。</p><p id="adda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些节点通过链接连接在一起。更简单地说，链表是通过链接相互连接的节点的集合。这些节点有两部分。第一部分存储我们的数据，而第二部分存储列表中下一个节点的地址或链接。</p><p id="9437" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想想下面的图表。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/09a42267a9d6e73ed00af725f3da5df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/0*fQPMISdV5C6pCGMT"/></div></figure><p id="b696" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">列表中的第一个节点通常被称为head。头通过下一个链接链接到下一个节点，并且它一直持续到最后一个不指向任何其他节点的节点，所以最后一个节点的下一个值变为空。</p><p id="9c18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">链表不能随机访问。也就是说，您不能使用它的索引访问数据(这是可以操作的，但不像我们使用数组那样)。在链表中，我们指的是内存位置地址，而不是索引位置。</p><p id="73cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们对链表有了更好的理解。让我们继续用javascript实现它。</p><p id="4a10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要做的第一件事是创建一个节点构造函数或类。我将在本文中使用ES6类。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="bb31" class="ll lm iq lh b gy ln lo l lp lq">class Node{</span><span id="e065" class="ll lm iq lh b gy lr lo l lp lq">constructor(data, next = null){</span><span id="387c" class="ll lm iq lh b gy lr lo l lp lq">this.data = data;</span><span id="3045" class="ll lm iq lh b gy lr lo l lp lq">this.next = next;</span><span id="edda" class="ll lm iq lh b gy lr lo l lp lq">}</span></pre><p id="2682" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当我们需要向列表中添加一个新节点时，这个节点类将帮助我们创建或制作一个新节点。</p><p id="2b8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是创建我们的链表。为了创建链表，我们还需要另一个类来创建链表，并编写函数来帮助我们对链表进行一些基本的操作</p><ul class=""><li id="9fe6" class="ls lt iq kf b kg kh kk kl ko lu ks lv kw lw la lx ly lz ma bi translated">添加节点</li><li id="60a8" class="ls lt iq kf b kg mb kk mc ko md ks me kw mf la lx ly lz ma bi translated">附加节点</li><li id="0e93" class="ls lt iq kf b kg mb kk mc ko md ks me kw mf la lx ly lz ma bi translated">删除节点</li><li id="6ec5" class="ls lt iq kf b kg mb kk mc ko md ks me kw mf la lx ly lz ma bi translated">获取节点的值</li><li id="c1fa" class="ls lt iq kf b kg mb kk mc ko md ks me kw mf la lx ly lz ma bi translated">也可以在阵列上完成的其他相关操作</li></ul><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="a89c" class="ll lm iq lh b gy ln lo l lp lq">class List{</span><span id="82e0" class="ll lm iq lh b gy lr lo l lp lq">constructor(){</span><span id="916c" class="ll lm iq lh b gy lr lo l lp lq">this.head = null;</span><span id="1893" class="ll lm iq lh b gy lr lo l lp lq">this.size = 0;</span><span id="4358" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="3e7e" class="ll lm iq lh b gy lr lo l lp lq">}</span></pre><p id="eaf9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个我们的类称为列表，是我们实际的链表。我们已经将头部初始化为空，因为它现在是空的。因此，我们需要向其中添加第一个元素或节点。就像javascript array unshift方法将一个元素放在数组的第一个位置一样，我们也可以将一个节点放在链表的第一个位置(头),这就是我们现在要做的。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="0e53" class="ll lm iq lh b gy ln lo l lp lq">First(data){</span><span id="9b4d" class="ll lm iq lh b gy lr lo l lp lq">this.head = new Node(data, this.head);</span><span id="c4e4" class="ll lm iq lh b gy lr lo l lp lq">this.size++;</span><span id="680d" class="ll lm iq lh b gy lr lo l lp lq">}</span></pre><p id="bc7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个函数接受我们传递给它的数据，并设置一个新的节点作为链表的头。还要注意，我们正在设置与下一个节点相同的头，这样，如果链表中有一个节点，它将被移动到第二个位置，我们刚刚创建的节点将成为头。</p><p id="afc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经创建了第一个节点，它是链表的头，让我们继续添加另一个节点到链表中。下一个函数将把一个节点追加到链表中的最后一个节点。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="5fe3" class="ll lm iq lh b gy ln lo l lp lq">Append(data){</span><span id="48e2" class="ll lm iq lh b gy lr lo l lp lq">if(!this.head){</span><span id="2bf1" class="ll lm iq lh b gy lr lo l lp lq">this.head = new Node(data, this.head);</span><span id="a091" class="ll lm iq lh b gy lr lo l lp lq">this.size++;</span><span id="3750" class="ll lm iq lh b gy lr lo l lp lq">return;</span><span id="9f78" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="37fd" class="ll lm iq lh b gy lr lo l lp lq">let current = this.head; let node = new Node(data);</span><span id="f7d1" class="ll lm iq lh b gy lr lo l lp lq">while(current.next){</span><span id="5df5" class="ll lm iq lh b gy lr lo l lp lq">current = current.next;</span><span id="7083" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="af66" class="ll lm iq lh b gy lr lo l lp lq">current.next = node;</span><span id="4e32" class="ll lm iq lh b gy lr lo l lp lq">this.size++;</span><span id="5404" class="ll lm iq lh b gy lr lo l lp lq">}</span></pre><p id="596d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的函数中，首先我们检查了链表中是否已经有一个头，如果没有，我们将继续添加新的节点作为链表的第一个节点或头。如果我们已经有一个头部，那么我们将变量current设置为头部，并实例化一个新的节点。使用while循环，我们遍历所有节点，直到到达最后一个节点，在那里我们简单地添加了新节点，该节点在实例化过程中已经接收了我们的数据。</p><p id="c032" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们看看如何像数组一样使用索引将节点添加到链表中。我们可以通过遍历链表在链表中的任何索引处添加节点，当我们到达索引时，我们只需追加我们的节点，然后设置新节点的下一部分指向链表的继续部分。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="9bb3" class="ll lm iq lh b gy ln lo l lp lq">appendAtIndex(data, index){</span><span id="d892" class="ll lm iq lh b gy lr lo l lp lq">if(index &lt; 0 || index &gt; this.size) return;</span><span id="1b44" class="ll lm iq lh b gy lr lo l lp lq">if(index == 0){</span><span id="5533" class="ll lm iq lh b gy lr lo l lp lq">this.head = new Node(data);</span><span id="c6a0" class="ll lm iq lh b gy lr lo l lp lq">this.size++;</span><span id="9b82" class="ll lm iq lh b gy lr lo l lp lq">}else{</span><span id="7563" class="ll lm iq lh b gy lr lo l lp lq">let current, previous, count = 0;</span><span id="0a2f" class="ll lm iq lh b gy lr lo l lp lq">current = this.head; let node = new Node(data);</span><span id="94a9" class="ll lm iq lh b gy lr lo l lp lq">while(count &lt; index){</span><span id="9a93" class="ll lm iq lh b gy lr lo l lp lq">previous = current;</span><span id="92f3" class="ll lm iq lh b gy lr lo l lp lq">current = current.next;</span><span id="42a9" class="ll lm iq lh b gy lr lo l lp lq">count++;</span><span id="1a79" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="f2c9" class="ll lm iq lh b gy lr lo l lp lq">previous.next = node;</span><span id="d878" class="ll lm iq lh b gy lr lo l lp lq">node.next = current;</span><span id="9075" class="ll lm iq lh b gy lr lo l lp lq">this.size++;</span><span id="6d21" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="3345" class="ll lm iq lh b gy lr lo l lp lq">}</span></pre><p id="f4b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的函数接收两个参数，一个是我们的数据，另一个是我们想要添加到节点的索引。</p><p id="d3f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的逻辑是循环遍历列表并设置一个计数器，帮助我们计数到我们正在寻找的索引。一旦我们得到了索引，我们就将列表一分为二，并使用我们的新节点将两部分再次连接在一起，从而将新节点放在两部分之间。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/21a9a3f0e6a119bcab612d09b095ae81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/0*RO5_ECcDwWWsnTWf"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">append new node at an index position</figcaption></figure><p id="326d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经看到了向链表添加节点的不同方法，让我们探索从链表中检索数据的方法。</p><p id="dcea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们既可以打印出链表中的全部数据，也可以打印出我们在特定时刻需要的特定数据。</p><p id="68b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们先看看如何打印出链表中的全部数据。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="13c7" class="ll lm iq lh b gy ln lo l lp lq">printListdata(){</span><span id="cca3" class="ll lm iq lh b gy lr lo l lp lq">let current = this.head;</span><span id="9f8c" class="ll lm iq lh b gy lr lo l lp lq">while(current){</span><span id="3f95" class="ll lm iq lh b gy lr lo l lp lq">console.log(current.data);</span><span id="fc6c" class="ll lm iq lh b gy lr lo l lp lq">current = current.next;</span><span id="b14d" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="7382" class="ll lm iq lh b gy lr lo l lp lq">}</span></pre><p id="a8fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的简单逻辑是遍历列表并打印出每个数据。简单吧？。</p><p id="cdf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就是这么爽。</p><p id="1f41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们要写的下一个函数将帮助我们根据想要得到的索引打印出特定的数据。所以我们来看看下面的函数。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="e9d1" class="ll lm iq lh b gy ln lo l lp lq">getAtIndex(index){</span><span id="5207" class="ll lm iq lh b gy lr lo l lp lq">if(index &lt; 0 || index &gt; this.size) return;</span><span id="374a" class="ll lm iq lh b gy lr lo l lp lq">let current = this.head; let count = 0;</span><span id="71d7" class="ll lm iq lh b gy lr lo l lp lq">while(count &lt; index){</span><span id="8169" class="ll lm iq lh b gy lr lo l lp lq">current = current.next;</span><span id="84bd" class="ll lm iq lh b gy lr lo l lp lq">count++</span><span id="d659" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="d72e" class="ll lm iq lh b gy lr lo l lp lq">console.log(current.data);</span><span id="62dc" class="ll lm iq lh b gy lr lo l lp lq">}</span></pre><p id="0289" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑上面的函数，注意它接受一个名为index的参数，这个参数实际上决定了我们想要访问的节点的索引。我们还初始化了一个计数器，帮助我们在遍历列表时计数。一旦计数器等于我们的索引，我们就简单地记录该索引处的数据。</p><p id="8c09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，让我们试着从列表中删除。我们的函数将帮助我们找到并删除任何我们想要删除的节点。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="b039" class="ll lm iq lh b gy ln lo l lp lq">deleteIndex(index){</span><span id="d85d" class="ll lm iq lh b gy lr lo l lp lq">if(index &lt; 0 || index &gt; this.size)return</span><span id="d6c0" class="ll lm iq lh b gy lr lo l lp lq">let current = this.head; let previous; let count = 0;</span><span id="5f30" class="ll lm iq lh b gy lr lo l lp lq">if(index == 0){</span><span id="eb09" class="ll lm iq lh b gy lr lo l lp lq">previous = current;</span><span id="a355" class="ll lm iq lh b gy lr lo l lp lq">current = current.next;</span><span id="f51a" class="ll lm iq lh b gy lr lo l lp lq">this.head = current;</span><span id="b141" class="ll lm iq lh b gy lr lo l lp lq">return;</span><span id="6eda" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="161d" class="ll lm iq lh b gy lr lo l lp lq">current = this.head;</span><span id="f944" class="ll lm iq lh b gy lr lo l lp lq">while(count &lt; index){</span><span id="de5f" class="ll lm iq lh b gy lr lo l lp lq">previous = current;</span><span id="a564" class="ll lm iq lh b gy lr lo l lp lq">current = current.next;</span><span id="c172" class="ll lm iq lh b gy lr lo l lp lq">count++;</span><span id="aa58" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="44db" class="ll lm iq lh b gy lr lo l lp lq">previous.next = current.next;</span><span id="c2c8" class="ll lm iq lh b gy lr lo l lp lq">this.size--;</span><span id="8035" class="ll lm iq lh b gy lr lo l lp lq">}</span></pre><p id="8ce1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的函数中，我们检查索引是否为0，当它为0时，我们简单地断开头部，并将下一个节点设置为头部。</p><p id="1260" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当索引大于0时，我们循环遍历列表，并在计数器变量的帮助下计数。一旦计数器等于索引，我们就断开该索引处的节点。current变量保存我们想要从列表中断开的节点，因此我们通过将previous链接到current.next来断开连接，从而从列表中删除当前节点。</p><p id="949b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们已经看到了可以在链表上执行的不同操作，下面是完整的代码。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="dbba" class="ll lm iq lh b gy ln lo l lp lq">class Node{</span><span id="e59e" class="ll lm iq lh b gy lr lo l lp lq">constructor(data, next = null){</span><span id="b87e" class="ll lm iq lh b gy lr lo l lp lq">this.data = data;</span><span id="9634" class="ll lm iq lh b gy lr lo l lp lq">this.next = next;</span><span id="c927" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="c5c1" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="2e40" class="ll lm iq lh b gy lr lo l lp lq">class List{</span><span id="5fe0" class="ll lm iq lh b gy lr lo l lp lq">constructor(){</span><span id="3328" class="ll lm iq lh b gy lr lo l lp lq">this.head = null;</span><span id="55ac" class="ll lm iq lh b gy lr lo l lp lq">this.size = 0;</span><span id="c742" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="3445" class="ll lm iq lh b gy lr lo l lp lq">First(data){</span><span id="b1c8" class="ll lm iq lh b gy lr lo l lp lq">this.head = new Node(data, this.head);</span><span id="0a07" class="ll lm iq lh b gy lr lo l lp lq">this.size++;</span><span id="b03d" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="c9ee" class="ll lm iq lh b gy lr lo l lp lq">Append(data){</span><span id="7099" class="ll lm iq lh b gy lr lo l lp lq">if(!this.head){</span><span id="5aab" class="ll lm iq lh b gy lr lo l lp lq">this.head = new Node(data, this.head);</span><span id="cfc2" class="ll lm iq lh b gy lr lo l lp lq">this.size++;</span><span id="1457" class="ll lm iq lh b gy lr lo l lp lq">return;</span><span id="95f0" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="e103" class="ll lm iq lh b gy lr lo l lp lq">let current = this.head; let node = new Node(data);</span><span id="4fb5" class="ll lm iq lh b gy lr lo l lp lq">while(current.next){</span><span id="988d" class="ll lm iq lh b gy lr lo l lp lq">current = current.next;</span><span id="8e76" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="4fcd" class="ll lm iq lh b gy lr lo l lp lq">current.next = node;</span><span id="660b" class="ll lm iq lh b gy lr lo l lp lq">this.size++;</span><span id="39e6" class="ll lm iq lh b gy lr lo l lp lq">}<br/></span><span id="4bfe" class="ll lm iq lh b gy lr lo l lp lq">appendAtIndex(data, index){</span><span id="56aa" class="ll lm iq lh b gy lr lo l lp lq">if(index &lt; 0 || index &gt; this.size) return;</span><span id="bccd" class="ll lm iq lh b gy lr lo l lp lq">if(index == 0){</span><span id="57e4" class="ll lm iq lh b gy lr lo l lp lq">this.head = new Node(data);</span><span id="8f8c" class="ll lm iq lh b gy lr lo l lp lq">this.size++;</span><span id="f242" class="ll lm iq lh b gy lr lo l lp lq">}else{</span><span id="6a43" class="ll lm iq lh b gy lr lo l lp lq">let current, previous, count = 0;</span><span id="9bf0" class="ll lm iq lh b gy lr lo l lp lq">current = this.head; let node = new Node(data);</span><span id="6934" class="ll lm iq lh b gy lr lo l lp lq">while(count &lt; index){</span><span id="683c" class="ll lm iq lh b gy lr lo l lp lq">previous = current;</span><span id="8ad3" class="ll lm iq lh b gy lr lo l lp lq">current = current.next;</span><span id="8b60" class="ll lm iq lh b gy lr lo l lp lq">count++;</span><span id="f1ba" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="396c" class="ll lm iq lh b gy lr lo l lp lq">previous.next = node;</span><span id="76cd" class="ll lm iq lh b gy lr lo l lp lq">node.next = current;</span><span id="1443" class="ll lm iq lh b gy lr lo l lp lq">this.size++;</span><span id="f0d4" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="d5f2" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="ea0c" class="ll lm iq lh b gy lr lo l lp lq">getAtIndex(index){</span><span id="7cbf" class="ll lm iq lh b gy lr lo l lp lq">if(index &lt; 0 || index &gt; this.size) return;</span><span id="6cb4" class="ll lm iq lh b gy lr lo l lp lq">let current = this.head; let count = 0;</span><span id="4d96" class="ll lm iq lh b gy lr lo l lp lq">while(count &lt; index){</span><span id="66e1" class="ll lm iq lh b gy lr lo l lp lq">current = current.next;</span><span id="9b66" class="ll lm iq lh b gy lr lo l lp lq">count++</span><span id="b2f6" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="4055" class="ll lm iq lh b gy lr lo l lp lq">console.log(current.data);</span><span id="991f" class="ll lm iq lh b gy lr lo l lp lq">}<br/></span><span id="e277" class="ll lm iq lh b gy lr lo l lp lq">printListdata(){</span><span id="80f2" class="ll lm iq lh b gy lr lo l lp lq">let current = this.head;</span><span id="68db" class="ll lm iq lh b gy lr lo l lp lq">while(current){</span><span id="298c" class="ll lm iq lh b gy lr lo l lp lq">console.log(current.data);</span><span id="0a60" class="ll lm iq lh b gy lr lo l lp lq">current = current.next;</span><span id="a3db" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="76a5" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="aac5" class="ll lm iq lh b gy lr lo l lp lq">deleteIndex(index){</span><span id="22c9" class="ll lm iq lh b gy lr lo l lp lq">if(index &lt; 0 || index &gt; this.size)return</span><span id="214f" class="ll lm iq lh b gy lr lo l lp lq">let current = this.head; let previous; let count = 0;</span><span id="8cf1" class="ll lm iq lh b gy lr lo l lp lq">if(index == 0){</span><span id="8f3b" class="ll lm iq lh b gy lr lo l lp lq">previous = current;</span><span id="7c0c" class="ll lm iq lh b gy lr lo l lp lq">current = current.next;</span><span id="d599" class="ll lm iq lh b gy lr lo l lp lq">this.head = current;</span><span id="d9a0" class="ll lm iq lh b gy lr lo l lp lq">return;</span><span id="6b3d" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="d918" class="ll lm iq lh b gy lr lo l lp lq">current = this.head;</span><span id="14c3" class="ll lm iq lh b gy lr lo l lp lq">while(count &lt; index){</span><span id="15a6" class="ll lm iq lh b gy lr lo l lp lq">previous = current;</span><span id="07c5" class="ll lm iq lh b gy lr lo l lp lq">current = current.next;</span><span id="6c92" class="ll lm iq lh b gy lr lo l lp lq">count++;</span><span id="2323" class="ll lm iq lh b gy lr lo l lp lq">}</span><span id="e60c" class="ll lm iq lh b gy lr lo l lp lq">previous.next = current.next;</span><span id="e06e" class="ll lm iq lh b gy lr lo l lp lq">this.size--;</span><span id="9494" class="ll lm iq lh b gy lr lo l lp lq">}<br/></span><span id="e2dc" class="ll lm iq lh b gy lr lo l lp lq">}</span></pre><p id="245c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以通过尝试下面的实现来测试您的代码。</p><pre class="lc ld le lf gt lg lh li lj aw lk bi"><span id="923d" class="ll lm iq lh b gy ln lo l lp lq">const list = new List();</span><span id="02a9" class="ll lm iq lh b gy lr lo l lp lq">list.First(231);</span><span id="7831" class="ll lm iq lh b gy lr lo l lp lq">list.First(232);</span><span id="b5a9" class="ll lm iq lh b gy lr lo l lp lq">list.First(233);</span><span id="0bf7" class="ll lm iq lh b gy lr lo l lp lq">list.First(200);</span><span id="7cc9" class="ll lm iq lh b gy lr lo l lp lq">list.Append(100);</span><span id="bf60" class="ll lm iq lh b gy lr lo l lp lq">list.appendAtIndex(780,2);</span><span id="f1b3" class="ll lm iq lh b gy lr lo l lp lq">list.getAtIndex(3);</span><span id="7f3c" class="ll lm iq lh b gy lr lo l lp lq">list.deleteIndex(4);</span><span id="fde5" class="ll lm iq lh b gy lr lo l lp lq">list.printListdata();</span></pre></div></div>    
</body>
</html>