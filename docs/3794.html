<html>
<head>
<title>JavaScript Algorithms: Checking for Palindromes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法:检查回文</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-algorithms-checking-for-palindromes-5db4b844ef41?source=collection_archive---------11-----------------------#2020-10-25">https://javascript.plainenglish.io/javascript-algorithms-checking-for-palindromes-5db4b844ef41?source=collection_archive---------11-----------------------#2020-10-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="88e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能已经猜到了，但是我们今天要学习回文。具体来说，我们如何测试一个回文？我的初学者数据结构和算法博客系列的第三部分。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/4b892da1ee15ecc838c2b0d9a2679e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mMBaSbVqFD2x1wYH"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@moroo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Moritz Schmidt</a></figcaption></figure><p id="819a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上周，我们讨论了整数反转。本周，我们将检查回文。回文是一个在前景和背景中拼写相同的单词。简单回文的一个例子是世界“赛车”。由于我们只是从简单的问题开始，这个回文检查器将会是比未来版本更简单的版本。我们将只传入不包含特殊字符或大写字母的字符串参数。</p><p id="3ee1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们讨论完这个问题之后，我会给出一些提示，告诉我们如何处理更复杂的字符串。现在，让我们先看看简单的回文验证问题:</p><p id="5c66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">给定一个字符串，写一个函数检查该字符串是否是回文。如果字符串是回文，函数将返回true。如果不是回文，函数将返回false。例如，“赛车”、“眼睛”和“夫人”都将返回true，而“苹果”、“水”和“窗户”都将返回false。</strong></p><h2 id="4a8b" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated"><strong class="ak">方案一</strong></h2><p id="cf21" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">在我讨论字符串反转的第一个问题中，我介绍了三种简化字符串反转过程的辅助方法:split、reverse和join。为了检查一个回文，我们需要做的就是确保单词的拼写和它倒着拼写的完全一样！为了做到这一点，我们必须声明一个变量来分配反向拼写的字符串，然后将其与原始字符串进行比较。下面的代码看起来与第一个问题非常相似，只是多了一行用于严格的等式测试。我将在解决方案后更详细地讨论三重等号。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ly"><img src="../Images/be7467a15c7974d34504c280848170c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oAWbvq5Yu00S2ov8ivg7lQ.png"/></div></div></figure><p id="63a4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第12行的代码并不新鲜。我把字符串拆开，然后把它转换成一个数组，把数组中的每一个字母反过来，再把它们连接起来形成一个字符串。在第13行，我使用三重等号来测试严格相等性，这意味着backwardStr中的值必须与Str中的值完全相等。使用三等号和双等号之间有一些非常明显的区别。布兰登·莫雷利的博客对此做了很好的解释。</p><p id="0357" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们试着给这个函数传入一个字符串。如果我们传入一个单词，比如eye，它将返回true。然而，如果我们传入一个像apple这样的单词，它将比较“elppa”和“apple”，这将返回false。这就是回文检查的基础！现在让我们深入一个需要稍微复杂一点的逻辑的解决方案。</p><h2 id="fc5c" class="la lb in bd lc ld le dn lf lg lh dp li jv lj lk ll jz lm ln lo kd lp lq lr ls bi translated"><strong class="ak">解决方案2 </strong></h2><p id="64cc" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">如果一个回文前后相同，这意味着左边的每一个字母或字符，应该在右边完全相反的位置有一个相等的字符。下一个解决方案可能看起来有点吓人，但是我向你保证，一旦我解释了<em class="ki"> every </em> helper方法是如何工作的，它就会变得更有意义。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ly"><img src="../Images/a33197a5a2095c6ef7f9700dd9f34503.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*005bpiI04zEbup704Ygmtg.png"/></div></div></figure><p id="b3ca" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">开始也是这样，在字符串上使用split创建一个数组。<em class="ki"> every </em> array helper方法接受几个参数，但是这个问题只需要两个参数，即每次传递的元素以及该元素的索引。在解决方案中，这些被标记为字符的<em class="ki">字符</em>和索引的<em class="ki"> i </em>。Char表示迭代中传递的每个字符，所以如果我们以数组["r "、" a "、" c "、" e "、" c "、" a "、" r"]为例，在数组的第一次迭代中，char将等于<em class="ki"> r </em>。<em class="ki"> i </em>表示字符的索引，因此在第一次迭代中，<em class="ki"> i </em>将等于0。记住数组索引从0开始。数组[0]是<em class="ki"> r，</em>数组[1]是<em class="ki"> a </em>，数组[2]<em class="ki">T19】是<em class="ki"> c </em>，以此类推。</em></p><p id="1e2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki"> every </em>助手的迷人之处在于它根据传入的特定条件返回一个布尔值。在第23行，我指定的条件是，如果当前字符等于字符串长度索引处的字符减当前字符索引减1，那么我们返回true并继续下一个字符。有很多东西需要理解，所以让我们来分析一下。字符串长度不是从0开始，这与数组索引不同。所以racecar的字符串长度是7，而其字符的最后一个索引是6。这就是为什么我们要从字符串长度中减去1。我们从字符串长度中减去当前字符索引，以便根据我们已经进入字符串的程度进行递减。例如，如果我们测试第二个字符，或者索引为1的数组，我们也想从右边开始测试第二个字符。如果我们创建的数组来自字符串“racecar ”,我们测试的是<em class="ki">、一个</em>、或者从左边数第二个字符，数组长度7减1得到6，减去索引1得到5。Array[5]会给我们<em class="ki">一个</em>，它正好是右边第二个字符。</p><p id="ce4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种解释可能真的令人困惑，所以我强烈建议熟悉数组索引和导航的最好方法是通过实践！打开您的Google命令控制台，编写一个字符串，将它的分割版本设置为一个变量，然后摆弄索引！</p><p id="0aa4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这两行代码之后，我们的返回值要么是真，要么是假。如果在任何时候，我们测试的字符与另一端的字符不匹配，那么<em class="ki"> every </em>函数将立即返回false。如果它成功地比较了所有的字符，并且没有一个布尔值返回false，那么every将返回true，我们就有了一个回文！</p></div><div class="ab cl lz ma hr mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="ig ih ii ij ik"><p id="ad8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来的这一周可能会令人困惑，但如果你明白了一切，干得好！如果没有，那完全没关系。尝试，尝试，再尝试！不要忘记休息。如果你在数组索引上有一点困难，那对我来说也是一个挑战。对自己要有耐心，要知道你用得越多，事情就会变得越容易。你能行的！</p><p id="3200" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下周，我将处理一个概念而不是一个问题。我在数据结构博客的第一周提到了这个概念:时间和空间复杂性，也称为大O符号！我将解释它是什么，谈论各种类型，然后我将回顾前三个问题，谈论它们的时间和空间复杂性。这也是一个很难理解的话题，所以如果你很好奇，<a class="ae kz" href="https://www.freecodecamp.org/news/my-first-foray-into-technology-c5b6e83fe8f1/" rel="noopener ugc nofollow" target="_blank">现在就开始阅读吧！</a></p><p id="ca28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="jm io">！</strong></p></div></div>    
</body>
</html>