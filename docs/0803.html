<html>
<head>
<title>Optimize Redux before it kills your Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Redux杀死你的应用程序之前优化它</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/optimize-redux-before-it-kills-your-application-6b73cf5f520b?source=collection_archive---------3-----------------------#2019-12-13">https://javascript.plainenglish.io/optimize-redux-before-it-kills-your-application-6b73cf5f520b?source=collection_archive---------3-----------------------#2019-12-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d12b15a0fb0cd0df26a1d5691a9dab97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IRFVykIzGHyYoSiXV7Zsjw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">CodeSandbox Image</figcaption></figure><p id="4746" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，我们来看看一个React-Redux应用程序是如何工作的。Redux在内部做了什么，它为我们的应用程序状态提供了一个商店，并提供了与商店通信的方法。其中一种方法是<em class="kx"> connect() </em>函数。在自定义组件上调用<em class="kx"> connect() </em>之后，您会得到一个包装器，它将状态作为道具从存储传递到您的组件。这通过每次状态改变时调用的<em class="kx"> mapStateToProps() </em>函数来实现。</p><p id="0339" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在<em class="kx"> mapStateToProps() </em>产生重新计算的属性后，新属性比旧属性浅，如果它们不同，组件将被重新渲染。再次使用引用等式(===)来比较道具。</p><p id="cdf3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">好好反应和Redux </strong>互相恭维。React组件订阅Redux store，因此每次状态(Redux state)改变时，子组件都会重新呈现。因此，订阅Redux re的任何组件都会在状态发生变化时呈现(除非我们提到不要这样做)。这是需要优化React Redux应用程序以避免不必要的重新渲染的主要原因。</p><p id="18bf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了避免所有这些冲突，有一些方法如下所述:</p><ul class=""><li id="b68f" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">使用<strong class="kb io"> React的PureComponent </strong>，React shallow比较以前的道具和现在的道具，如果没有变化就避免重新渲染。</li><li id="681d" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">使用<strong class="kb io"> shouldComponentUpdate </strong>生命周期，我们可以有选择地避免React组件的重新呈现。</li><li id="4450" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">不使用内部状态时使用<strong class="kb io">功能组件</strong>。</li></ul><p id="7707" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这有助于避免重新渲染<strong class="kb io">,除非并且直到组件消耗了适当的改变。</strong></p><h1 id="885c" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">重新选择概念</h1><p id="6b61" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">根据图书馆的主页</p><p id="634a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">选择器可以计算派生数据，允许Redux存储最小可能状态。</strong>这可以被认为是尽可能保持店铺的最小化。通过选择器计算任何派生的数据。</p><p id="f2d1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">选择器是高效的。除非选择器的一个参数发生更改，否则不会重新计算选择器。</p><figure class="mp mq mr ms gt jo"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="d010" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面示例的控制台选项卡中，默认情况下，您会看到两个日志:</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/48f4fc889d2c750d2d3161ed7102238b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Sa2TpQoziPveFHz50m5Cw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Logs</figcaption></figure><p id="9872" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的屏幕中，默认情况下Header和Counter组件都被加载，因此我们得到了两个控制台输出。在此之后，如果您单击changeUser按钮，它将只呈现标题组件，这是我们在这里优化。</p><figure class="mp mq mr ms gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/972f6ac3357f8e7d14fc01cfc53a68ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GTEaBOv6G5ubj2coplOHoQ.png"/></div></div></figure><p id="79d0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">为了实现这一点，我们需要理解“重新选择”库中的选择器。</p><h1 id="40ec" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">什么是选择器？</h1><p id="25b9" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">在我们的上下文中，<strong class="kb io">选择器只不过是可以计算或从存储中检索数据的函数。我们通常像这样使用mapStateToProps函数获取状态数据。</strong></p><pre class="mp mq mr ms gt mv mw mx my aw mz bi"><span id="2e53" class="na ln in mw b gy nb nc l nd ne">//selectCounterValue<br/>import { createSelector } from "reselect";<br/>const selectCounter = state =&gt; state.counter;</span><span id="0796" class="na ln in mw b gy nf nc l nd ne">export const selectCounterValue = createSelector(<br/>[selectCounter],<br/>counter =&gt; counter.counter<br/>);</span></pre><p id="7918" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">' selectCounterValue '帮助我们从整个状态对象中只检索计数器状态，我们可以在组件中利用它，如上所述。</p><pre class="mp mq mr ms gt mv mw mx my aw mz bi"><span id="a480" class="na ln in mw b gy nb nc l nd ne">//In Component<br/>const mapStateToProps = createStructuredSelector({<br/>counter: selectCounterValue<br/>});</span></pre><p id="2eb6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这里createStructuredSelector将为我们创建一个结构，在这个结构中我们不需要将我们的状态作为参数传递&amp;它也是由“reselect”库提供的。</p><h1 id="4491" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">让你的生活更美好的小贴士</h1><p id="d5c2" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">总而言之，我将指定我在使用Reselect库时为自己获得的一些技巧。</p><ol class=""><li id="68cf" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ng le lf lg bi translated">如果它以任何方式从状态转换值，总是使用Reselect中的<em class="kx"> createSelector() </em>来创建选择器。</li><li id="5acc" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ng le lf lg bi translated">避免咖喱选择器。一般来说，你不需要它们。您可以使用选择器的第二个参数传递您需要的所有参数。事实上，我能想到的唯一需要curried选择器的情况是在<a class="ae nh" href="https://github.com/reactjs/reselect#sharing-selectors-with-props-across-multiple-components" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io">文档</strong> </a> <strong class="kb io">中描述的。</strong></li><li id="f897" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ng le lf lg bi translated">从生命周期功能向商店分派动作时要小心。一般来说，避免这样做。但如果你不得不，也许在派遣一个动作之前手动比较道具是个好主意。</li></ol></div></div>    
</body>
</html>