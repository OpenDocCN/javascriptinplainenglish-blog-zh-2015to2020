<html>
<head>
<title>Handling Exceptions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中处理异常</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/handling-exceptions-in-javascript-f14d855be11c?source=collection_archive---------4-----------------------#2019-11-20">https://javascript.plainenglish.io/handling-exceptions-in-javascript-f14d855be11c?source=collection_archive---------4-----------------------#2019-11-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/26bc45c81836cf03c8e2dc4b97dfcc00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C4g4DGif1ZnaB5N3"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@maxchen2k?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Max Chen</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9ef4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何程序一样，JavaScript会遇到错误情况，例如，JSON解析失败，或者变量中意外出现空值。这意味着，如果我们希望我们的应用程序给用户带来良好的用户体验，我们必须优雅地处理这些错误。这意味着我们必须优雅地处理这些错误。错误经常以异常的形式出现，所以我们必须优雅地处理它们。为了处理它们，我们必须使用<code class="fe lb lc ld le b">try...catch</code>语句来处理这些错误，这样它们就不会使程序崩溃。</p><h1 id="efdb" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">试着…接住</h1><p id="0287" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">要使用<code class="fe lb lc ld le b">try...catch</code>块，我们必须使用以下语法:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f3f7" class="mq lg iq le b gy mr ms l mt mu">try{<br/>  // code that we run that may raise exceptions<br/>  // one or more lines is required in this block<br/>}<br/>catch (error){<br/>  // handle error here<br/>  // optional if finally block is present<br/>}<br/>finally {<br/>  // optional code that run either <br/>  // when try or catch block is finished<br/>}</span></pre><p id="c241" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码来捕捉异常:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="8bcc" class="mq lg iq le b gy mr ms l mt mu">try {<br/>  undefined.prop<br/>} catch (error) {<br/>  console.log(error);<br/>}</span></pre><p id="8ef5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们试图从<code class="fe lb lc ld le b">undefined</code>获取一个属性，这显然是不允许的，所以抛出了一个异常。在<code class="fe lb lc ld le b">catch</code>块中，我们捕捉到运行<code class="fe lb lc ld le b">undefined.prop</code>导致的“类型错误:无法读取未定义的属性‘prop’”并记录异常的输出。所以我们得到的是输出的错误信息，而不是崩溃的程序。</p><p id="392d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">try...catch</code>语句有一个<code class="fe lb lc ld le b">try</code>块。<code class="fe lb lc ld le b">try</code>块内部必须至少有一个语句，并且必须始终使用花括号，这是针对单个语句的事件。那么可以包括<code class="fe lb lc ld le b">catch</code>条款或<code class="fe lb lc ld le b">finally</code>条款。这意味着我们可以拥有:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1663" class="mq lg iq le b gy mr ms l mt mu">try {<br/>  ...<br/>} <br/>catch {<br/>  ...<br/>}</span><span id="90ed" class="mq lg iq le b gy mv ms l mt mu">try {<br/>  ...<br/>} <br/>finally{<br/>  ...<br/>}</span><span id="021e" class="mq lg iq le b gy mv ms l mt mu">try {<br/>  ...<br/>} <br/>catch {<br/>  ...<br/>}<br/>finally {<br/>  ...<br/>}</span></pre><p id="eb5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">catch</code>子句有指定当<code class="fe lb lc ld le b">try</code>块中抛出异常时该做什么的代码。如果他们的<code class="fe lb lc ld le b">try</code>块没有成功并抛出异常，那么<code class="fe lb lc ld le b">catch</code>块中的代码将会运行。如果运行了<code class="fe lb lc ld le b">try</code>块中的所有代码而没有抛出任何异常，那么<code class="fe lb lc ld le b">catch</code>块中的代码将被跳过。</p><p id="9eb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">finally</code>块在<code class="fe lb lc ld le b">try</code>块或<code class="fe lb lc ld le b">catch</code>块运行完所有代码后执行。不管是否抛出异常，它总是运行。</p><p id="9e78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">try</code>块可以相互嵌套。如果内部<code class="fe lb lc ld le b">try</code>块没有捕获异常，而外部块有一个<code class="fe lb lc ld le b">catch</code>块，那么外部块将捕获内部<code class="fe lb lc ld le b">try</code>块抛出的异常。例如，如果我们有:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a778" class="mq lg iq le b gy mr ms l mt mu">try {<br/>  try {<br/>    undefined.prop<br/>  } finally {<br/>    console.log('Inner finally block runs');<br/>  }<br/>} catch (error) {<br/>  console.log('Outer catch block caught:', error);<br/>}</span></pre><p id="e6b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行上面的代码，我们应该会看到“内部finally块运行”和“外部catch块被捕获:类型错误:无法读取未定义的“已记录”的属性“prop ”,这是我们所期望的，因为内部<code class="fe lb lc ld le b">try</code>块没有用<code class="fe lb lc ld le b">catch</code>块捕获异常，而外部<code class="fe lb lc ld le b">catch</code>块捕获了异常。正如我们看到的，内部的finally块在外部的catch块之前运行。<code class="fe lb lc ld le b">try...catch...finally</code>按顺序运行，所以先添加的代码会在后添加的代码之前运行。</p><p id="ec32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们编写的<code class="fe lb lc ld le b">catch</code>块都是无条件的。这意味着它们捕捉任何抛出的异常。<code class="fe lb lc ld le b">error</code>对象保存关于抛出的异常的数据。它只保存<code class="fe lb lc ld le b">catch</code>块中的数据。如果我们想把数据放在它之外，那么我们必须把它赋给<code class="fe lb lc ld le b">catch</code>块之外的一个变量。在<code class="fe lb lc ld le b">catch</code>块完成运行后，<code class="fe lb lc ld le b">error</code>对象不再可用。</p><p id="2c48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">finally</code>子句包含在<code class="fe lb lc ld le b">try</code>块或<code class="fe lb lc ld le b">catch</code>块中的代码执行之后，但在<code class="fe lb lc ld le b">try...catch...finally</code>块之下执行的语句之前出现的语句。不管是否抛出异常，它都会被执行。如果抛出异常，那么即使没有<code class="fe lb lc ld le b">catch</code>块捕获和处理异常，也会执行<code class="fe lb lc ld le b">finally</code>块中的语句。</p><p id="9e6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当错误发生时，<code class="fe lb lc ld le b">finally</code>块可以方便地使我们的程序优雅地失败。例如，我们可以放置清理代码，不管是否抛出异常都运行，就像关闭文件读取句柄一样。在运行<code class="fe lb lc ld le b">try</code>块中的一行代码时，当抛出异常时，不会执行<code class="fe lb lc ld le b">try</code>块中的剩余代码，因此，如果我们被期望关闭<code class="fe lb lc ld le b">try</code>中的文件句柄，并且在关闭文件句柄的行运行之前抛出异常，那么为了优雅地结束程序，我们应该在<code class="fe lb lc ld le b">finally</code>块中这样做，以确保文件句柄总是被清理。我们可以把不管是否抛出异常都运行的代码像清理代码一样放在<code class="fe lb lc ld le b">finally</code>块中，这样我们就不必在<code class="fe lb lc ld le b">try</code>和<code class="fe lb lc ld le b">catch</code>块中复制它们。例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="8dc4" class="mq lg iq le b gy mr ms l mt mu">openFile();<br/>try {<br/>  // tie up a resource<br/>  writeFile(data);<br/>}<br/>finally {<br/>  closeFile(); <br/>  // always close the resource<br/>}</span></pre><p id="f602" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，无论<code class="fe lb lc ld le b">writeFile</code>运行时是否抛出异常，函数<code class="fe lb lc ld le b">closeFile</code>总是运行，从而消除了重复代码。</p><p id="b950" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以嵌套<code class="fe lb lc ld le b">try</code>块，如以下代码所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f000" class="mq lg iq le b gy mr ms l mt mu">try {<br/>  try {<br/>    throw new Error('error');<br/>  }<br/>  finally {<br/>    console.log('finally runs');<br/>  }<br/>}<br/>catch (ex) {<br/>  console.error('exception caught', ex.message);<br/>}</span></pre><p id="9318" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们查看控制台日志，我们应该看到“最终运行”出现在“异常捕获错误”之前这是因为<code class="fe lb lc ld le b">try...catch</code>块中的所有内容都是逐行运行的，即使它是嵌套的。如果我们有更多的嵌套，如下面的代码所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6e92" class="mq lg iq le b gy mr ms l mt mu">try {<br/>  try {<br/>    throw new Error('error');<br/>  }<br/>  finally {<br/>    console.log('first finally runs');<br/>  }</span><span id="0fee" class="mq lg iq le b gy mv ms l mt mu">  try {<br/>    throw new Error('error2');<br/>  }<br/>  finally {<br/>    console.log('second finally runs');<br/>  }<br/>}<br/>catch (ex) {<br/>  console.error('exception caught', ex.message);<br/>}</span></pre><p id="8894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到，我们得到了与以前相同的控制台日志输出。这是因为第一个内部<code class="fe lb lc ld le b">try</code>块没有捕获异常，所以异常被传播到外部<code class="fe lb lc ld le b">catch</code>块并被其捕获。如果我们想运行第二个<code class="fe lb lc ld le b">try </code>块，那么我们必须向第一个<code class="fe lb lc ld le b">try</code>块添加一个<code class="fe lb lc ld le b">catch</code>块，如下例所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="140b" class="mq lg iq le b gy mr ms l mt mu">try {<br/>  try {<br/>    throw new Error('error');<br/>  }<br/>  catch {<br/>    console.log('first catch block runs');<br/>  }  <br/>  finally {<br/>    console.log('first finally runs');<br/>  }</span><span id="2dce" class="mq lg iq le b gy mv ms l mt mu">  try {<br/>    throw new Error('error2');<br/>  }<br/>  finally {<br/>    console.log('second finally runs');<br/>  }<br/>}<br/>catch (ex) {<br/>  console.error('exception caught', ex.message);<br/>}</span></pre><p id="00fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们看到按顺序记录的以下消息:“第一个catch块运行”、“第一个最终运行”、“第二个最终运行”、“异常捕获错误2”。这是因为第一个<code class="fe lb lc ld le b">try</code>块有一个<code class="fe lb lc ld le b">catch</code>块，所以由<code class="fe lb lc ld le b">throw new Error('error')</code>行引起的异常现在被第一个内部<code class="fe lb lc ld le b">try</code>块的<code class="fe lb lc ld le b">catch</code>块捕获。现在第二个内部<code class="fe lb lc ld le b">try</code>模块没有关联的<code class="fe lb lc ld le b">catch</code>模块，因此<code class="fe lb lc ld le b">error2</code>将被外部<code class="fe lb lc ld le b">catch</code>模块捕获。</p><p id="4874" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以重新抛出在<code class="fe lb lc ld le b">catch</code>块中捕获的错误。例如，我们可以编写以下代码来实现这一点:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="b7b4" class="mq lg iq le b gy mr ms l mt mu">try {<br/>  try {<br/>    throw new Error('error');<br/>  } catch (error) {<br/>    console.error('error', error.message);<br/>    throw error;<br/>  } finally {<br/>    console.log('finally block is run');<br/>  }<br/>} catch (error) {<br/>  console.error('outer catch block caught', error.message);<br/>}</span></pre><p id="8945" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，如果我们运行上面的代码，那么我们会按顺序记录以下内容:“error error”、“finally block is run”和“outer catch block catched error”。这是因为内部的<code class="fe lb lc ld le b">catch</code>块记录了由<code class="fe lb lc ld le b">throw new Error(‘error’)</code>抛出的异常，但是在<code class="fe lb lc ld le b">console.error(‘error’, error.message);</code>运行之后，我们运行<code class="fe lb lc ld le b">throw error;</code>再次抛出异常。然后运行内部<code class="fe lb lc ld le b">finally</code>块，然后外部<code class="fe lb lc ld le b">catch</code>块捕获重新抛出的异常，该外部<code class="fe lb lc ld le b">catch</code>块记录了由内部<code class="fe lb lc ld le b">catch</code>块中的<code class="fe lb lc ld le b">throw error</code>语句重新抛出的<code class="fe lb lc ld le b">error</code>。</p><p id="bdf9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于代码是顺序运行的，我们可以在一个<code class="fe lb lc ld le b">try</code>块的末尾运行<code class="fe lb lc ld le b">return</code>语句。例如，如果我们想将一个JSON字符串解析成一个对象，如果在解析传入的字符串时出现错误，例如，当传入的字符串不是有效的JSON字符串时，我们希望返回一个空对象，那么我们可以编写以下代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="9bf1" class="mq lg iq le b gy mr ms l mt mu">const parseJSON = (str) =&gt; {<br/>  try {<br/>    return JSON.parse(str);<br/>  }<br/>  catch {<br/>    return {};<br/>  }<br/>}</span></pre><p id="6ae0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们运行<code class="fe lb lc ld le b">JSON.parse</code>来解析字符串，如果它不是有效的JSON，那么将会抛出一个异常。如果抛出异常，那么将调用<code class="fe lb lc ld le b">catch</code>子句返回一个空对象。如果<code class="fe lb lc ld le b">JSON.parse</code>成功运行，那么将返回解析后的JSON对象。所以如果我们跑:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a768" class="mq lg iq le b gy mr ms l mt mu">console.log(parseJSON(undefined));<br/>console.log(parseJSON('{"a": 1}'))</span></pre><p id="3f83" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在第一行得到一个空对象，在第二行得到<code class="fe lb lc ld le b">{a: 1}</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/fe617b60e77fd0377c2132ceb30837a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wJyboS6E3Ch4Mlc0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sharonmccutcheon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sharon McCutcheon</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="dc42" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">异步代码中的Try块</h1><p id="74e9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">通过<code class="fe lb lc ld le b">async</code>和<code class="fe lb lc ld le b">await</code>，我们可以缩短承诺代码。在<code class="fe lb lc ld le b">async</code>和<code class="fe lb lc ld le b">await</code>之前，我们必须使用<code class="fe lb lc ld le b">then</code>函数，我们把回调函数作为所有<code class="fe lb lc ld le b">then</code>函数的参数。这使得代码很长，因为我们有很多承诺。相反，我们可以使用<code class="fe lb lc ld le b">async</code>和<code class="fe lb lc ld le b">await</code>语法来替换<code class="fe lb lc ld le b">then</code>及其相关的回调，如下所示。使用<code class="fe lb lc ld le b">async</code>和<code class="fe lb lc ld le b">await</code>语法来链接承诺，我们也可以使用<code class="fe lb lc ld le b">try</code>和<code class="fe lb lc ld le b">catch</code>块来捕捉被拒绝的承诺并优雅地处理被拒绝的承诺。例如，如果我们想用一个<code class="fe lb lc ld le b">catch</code>块捕捉承诺拒绝，我们可以这样做:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2940" class="mq lg iq le b gy mr ms l mt mu">(async () =&gt; {<br/>  try {<br/>    await new Promise((resolve, reject) =&gt; {<br/>      reject('error')<br/>    })<br/>  } catch (error) {<br/>    console.log(error);<br/>  }</span><span id="e8e0" class="mq lg iq le b gy mv ms l mt mu">})();</span></pre><p id="3707" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，因为我们拒绝了在<code class="fe lb lc ld le b">try</code>块中定义的承诺，所以<code class="fe lb lc ld le b">catch</code>块捕获了承诺拒绝并记录了错误。因此，当我们运行上面的代码时，应该会看到记录的“错误”。尽管它看起来是一个普通的<code class="fe lb lc ld le b">try...catch</code>块，但它不是，因为这是一个<code class="fe lb lc ld le b">async</code>函数。一个<code class="fe lb lc ld le b">async</code>函数只返回承诺，所以我们不能返回除了<code class="fe lb lc ld le b">try...catch</code>块中的承诺之外的任何东西。<code class="fe lb lc ld le b">async</code>函数中的<code class="fe lb lc ld le b">catch</code>块只是链接到then函数的<code class="fe lb lc ld le b">catch</code>函数的简写。所以上面的代码实际上和:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="abfb" class="mq lg iq le b gy mr ms l mt mu">(() =&gt; {<br/>  new Promise((resolve, reject) =&gt; {<br/>      reject('error')<br/>    })<br/>    .catch(error =&gt; console.log(error))<br/>})()</span></pre><p id="5651" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到，当上面的<code class="fe lb lc ld le b">async</code>函数运行时，我们得到了相同的控制台日志输出。</p><p id="b4eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">async</code>功能中<code class="fe lb lc ld le b">finally</code>模块也与<code class="fe lb lc ld le b">try...catch</code>模块一起工作。例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6f49" class="mq lg iq le b gy mr ms l mt mu">(async () =&gt; {<br/>  try {<br/>    await new Promise((resolve, reject) =&gt; {<br/>      reject('error')<br/>    })<br/>  } catch (error) {<br/>    console.log(error);<br/>  } finally {<br/>    console.log('finally is run');<br/>  }<br/>})();</span></pre><p id="97ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，因为我们拒绝了在<code class="fe lb lc ld le b">try</code>块中定义的承诺，所以<code class="fe lb lc ld le b">catch</code>块捕获了承诺拒绝并记录了错误。因此，当我们运行上面的代码时，应该会看到记录的“错误”。运行<code class="fe lb lc ld le b">finally</code>块，以便我们得到“最终运行”日志。<code class="fe lb lc ld le b">async</code>函数中的<code class="fe lb lc ld le b">finally</code>块与将<code class="fe lb lc ld le b">finally</code>函数链接到承诺的末尾是一样的，所以上面的代码相当于:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="857b" class="mq lg iq le b gy mr ms l mt mu">(() =&gt; {<br/>  new Promise((resolve, reject) =&gt; {<br/>      reject('error')<br/>    })<br/>    .catch(error =&gt; console.log(error))<br/>    .finally(() =&gt; console.log('finally is run'))<br/>})()</span></pre><p id="46b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到，当上面的<code class="fe lb lc ld le b">async</code>函数运行时，我们得到了相同的控制台日志输出。</p><p id="fa20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们上面提到的嵌套<code class="fe lb lc ld le b">try...catch</code>的规则仍然适用于<code class="fe lb lc ld le b">async</code>函数，因此我们可以编写如下代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="c7b2" class="mq lg iq le b gy mr ms l mt mu">(async () =&gt; {<br/>  try {<br/>    await new Promise((resolve, reject) =&gt; {<br/>      reject('outer error')<br/>    })<br/>    try {<br/>      await new Promise((resolve, reject) =&gt; {<br/>        reject('inner error')<br/>      })<br/>    } catch (error) {<br/>      console.log(error);<br/>    } finally {</span><span id="ebf4" class="mq lg iq le b gy mv ms l mt mu">    }<br/>  } catch (error) {<br/>    console.log(error);<br/>  } finally {<br/>    console.log('finally is run');<br/>  }<br/>})();</span></pre><p id="f15c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们可以轻松地嵌套承诺，并相应地处理它们的错误。这比我们在拥有<code class="fe lb lc ld le b">async</code>函数之前将<code class="fe lb lc ld le b">then</code>、<code class="fe lb lc ld le b">catch</code>和<code class="fe lb lc ld le b">finally</code>函数链接起来要干净。</p><p id="dd22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了处理JavaScript程序中的错误，我们可以使用<code class="fe lb lc ld le b">try...catch...finally</code>块来捕捉错误。这可以用同步或异步代码来完成。我们将可能抛出异常的代码放在<code class="fe lb lc ld le b">try</code>块中，然后将处理异常的代码放在<code class="fe lb lc ld le b">catch</code>块中。在<code class="fe lb lc ld le b">finally</code>块中，我们运行任何代码，不管是否抛出异常。<code class="fe lb lc ld le b">async</code>函数也可以使用<code class="fe lb lc ld le b">try...catch</code>块，但它们和其他<code class="fe lb lc ld le b">async</code>函数一样只返回承诺，而普通函数中的<code class="fe lb lc ld le b">try...catch...finally</code>块可以返回任何东西。</p></div></div>    
</body>
</html>