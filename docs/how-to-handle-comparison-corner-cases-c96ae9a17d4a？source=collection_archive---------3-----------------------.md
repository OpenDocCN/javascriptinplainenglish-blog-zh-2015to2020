# 如何处理比较角案例？

> 原文：<https://javascript.plainenglish.io/how-to-handle-comparison-corner-cases-c96ae9a17d4a?source=collection_archive---------3----------------------->

## JavaScript 算法可以“不可预测”！

## 抓住所有这些案例，开始编写一流的代码！

![](img/27fb5ab25fa6c9f7da8edb56bc992a6f.png)

Photo by [Joshua Aragon](https://unsplash.com/@goshua13?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/javascript?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

> 任何足够先进的技术都和魔法没什么区别
> 
> *——*亚瑟·C·克拉克(第三克拉克定律)

在我们开始熟悉 JavaScript 边角案例之前，我想区分一下**边角案例**和**边缘案例**。

我们可以说**边缘情况是一个只有在最小或最大参数**下才会发生的问题。预测它可能是一项重要的任务，因为这些情况可能会被忽视或低估。例如，处于全功率的 PC 可能会过热，其性能可能会略有下降。

我也很乐意介绍一个**边界案例**(也是一个有疑问的主题)。如果其中一个参数超出最小或最大限值，就会发生这种情况。

**边角案例**呢？我不会给出任何定义，因为在你看了下面的例子后，你就可以自己做了。

# 你不会相信的！

如果我问你，某物的强制性能等于它自身的否定吗，你会怎么回答？你可能会说这是一个无意义的问题，但是:

你可能认为 JS 是一种疯狂的语言，对于 JS 这样的流行语言来说，这种情况不应该发生。这个例子很傻，因为在真实的例子中，你永远不会把价值和它本身的否定相比较。但是这是一个很好的例子，可以帮助你澄清和采用正确的心智模式！

**你永远也不会遇到将数组与负数组进行比较的情况。你永远不会用这种方式设计代码。这是你不想管理代码库的一个很好的例子。**

在下一个例子中，我将详细解释发生了什么，这样你就可以清楚地了解算法在做什么:

首先，我将参考[文档](http://documentation)。在第 6 行，我们比较了原始值和非原始值。在这种情况下，规则 11 适用。**这个算法的结果是一个空字符串。**

下一步，我们将一个空字符串与假字符串进行比较。根据算法，适用规则№9。下一步(第 8 行)是应用规则№5。第五步，比较两个数。由于我们正在使用相等比较，**我们将调用严格相等比较算法**。

最后一步是从严格的相等比较中返回一个 *true* 。第二个例子更实际一点，因为我们使用了 not equals(双重相等否定)- **检查是否不强制相等**:

当我们比较两个非原始类型时，这意味着我们将执行一个身份比较。这同样适用于使用严格相等比较的情况。

# 不要惹布尔人

让我们来谈谈布尔及其与抽象等式的联系。这是你经常做的事情。我们应该看看可能发生的极端情况:

**直截了当有时会产生不必要的问题。**在第二个 if 子句中，我们比较了 array 和 boolean。你可能认为这个操作的结果是布尔*真*，但事实并非如此。**同样的效果会与严格的相等。**

一个数组和一个布尔值的比较将贯穿于许多关键情况。在我们看例子之前，我给你一个提示:**永远不要在 boolean ( *true* 和 *false* )** 中使用 double equals。我们来分析一下算法是如何工作的:

第一个 if 子句不言自明，所以我不会浪费时间解释。和前面的例子一样，**我参考了** [**的文档**](https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison) 。比较数组和布尔是要调用[*to primitive()*](https://www.ecma-international.org/ecma-262/#sec-toprimitive)抽象运算(规则№11)因为比较的值之一是非原语类型。

接下来的三步很简单。首先，我们将一个布尔值转换成一个数字(rule№9:[*to number(true)*](https://www.ecma-international.org/ecma-262/#sec-tonumber))，下一步字符串变成数字(rule№5:[*to number(" "*](https://www.ecma-international.org/ecma-262/#sec-tonumber))，最后一步是执行严格的相等比较。第三条与前一条相同。

强制的缺点之一是抽象操作 *ToNumber()* 。我不确定将一个空字符串转换成数字是否应该返回 *0* 。最好返回 *NaN* ，因为 *NaN* 代表一个无效数字。

结论:**无谓的输入总会产生无谓的输出。我们不必一直都很明确。隐式有时比显式更好。**

当您检查数组中的值是否存在时，您可以做的最好的事情是更明确地检查`.length`的存在，以确保它是一个字符串或数组:

深查更靠谱。如你所见，一个空数组将返回*真*(在布尔强制之后)。同样的事情也适用于对象- **总是做深度检查**。当我们确定类型是字符串或数组时，我们将使用`typeof`操作符(或`Array.isArray()`方法)。

# 澄清

有一些指导方针你必须遵循，以避免陷入困境。到处使用双等号可能是一把双刃剑。请记住，当被比较值的任一侧为 *0* 时，使用双等号，空字符串或只有空格的字符串是一种不好的做法。

要记住的下一件大事是避免对非原始类型使用双等号。**唯一可以用的时候就是身份对比。**我不能说这是 100%安全的，因为它离死角足够近，不值得这么做。

[ECMAScript 6](https://www.w3schools.com/js/js_es6.asp) 引入了新的实用工具 [*Object.is()*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) 。有了这个方法，我们终于可以在没有副作用风险的情况下进行身份比对了。最后，我们可以说，使用双等号只对基元类型安全，对非基元类型不安全。

最后但并非最不重要的是避免对布尔值使用双等号(*真*和*假*)。允许隐式布尔强制要好得多(调用 *ToBoolean()* 抽象操作)。如果您不能启用隐式强制，并且您被限制对布尔值使用双重等于( *true* 和 *false* )，那么**使用三重等于**。

结论:**通过重构我们的代码库，可以避免大部分的死角。**