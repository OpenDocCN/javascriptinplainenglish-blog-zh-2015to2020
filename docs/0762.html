<html>
<head>
<title>Importance of JavaScript Exec method for pattern matching in regular expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Exec方法在正则表达式模式匹配中的重要性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/importance-of-javascript-exec-method-for-pattern-matching-in-regular-expressions-e6620676d6f2?source=collection_archive---------7-----------------------#2019-12-06">https://javascript.plainenglish.io/importance-of-javascript-exec-method-for-pattern-matching-in-regular-expressions-e6620676d6f2?source=collection_archive---------7-----------------------#2019-12-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="06af" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">一个非常著名的面试问题的不同和伟大的解决方案</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/743b77ce1eec36cd39d47f6dfd216431.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_dcW4RFolMB41oOP"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@rachel_danner156?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rachel Danner</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8081" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正则表达式对于在字符串中查找特定匹配的模式非常有用。它们帮助我们将复杂的逻辑转换成简短易懂的代码。<br/>今天我们将看到javascript中一个非常棒的模式匹配方法，那就是<code class="fe lp lq lr ls b">exec</code>方法。</p><p id="d916" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">它具有以下语法</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="afc0" class="lx ly in ls b gy lz ma l mb mc">regexObj.exec(string)</span></pre><p id="c851" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在进入实际问题之前，我们先了解一下<code class="fe lp lq lr ls b">exec</code>是什么，它是做什么的。</p><p id="f799" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">exec方法类似于正则表达式的match方法，如果成功则返回找到的匹配数组，否则返回null </strong></p><p id="c019" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="md">模式还维护一个lastIndex属性，它是一个索引，一旦找到一个特定的匹配，它将从这个索引开始搜索下一个匹配。</em></p><p id="86b1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们通过一个例子来了解一下。</p><p id="c6de" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">假设，我们想要找到字符串中所有元音的出现以及匹配的位置，我们可以像下面这样做</strong></p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="ce8e" class="lx ly in ls b gy lz ma l mb mc">const text = "This is a simple text";<br/>const pattern = /[aeiou]/g;<br/>let output = "";<br/>while((result = pattern.exec(text)) !== null) {<br/> output += result[0] + " " + pattern.lastIndex + "\n";<br/>}<br/>console.log(output);</span><span id="5e24" class="lx ly in ls b gy me ma l mb mc">/* output</span><span id="0305" class="lx ly in ls b gy me ma l mb mc">i 3<br/>i 6<br/>a 9<br/>i 12<br/>e 16<br/>e 19</span><span id="d123" class="lx ly in ls b gy me ma l mb mc">*/</span></pre><p id="c184" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">正如您从输出中看到的，打印的索引不是匹配的索引，而是它将开始搜索下一个匹配的索引，考虑到索引计数从0而不是1开始。</strong></p><p id="bdae" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在开始真正的面试问题。<br/>问题是这样的</p><p id="f39e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">写一个程序，它将打印一个单词在一个特定的字符串中出现了多少次，并且打印出它的索引。 </p><p id="760d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们从它开始</p><p id="5319" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设，我们想检查单词“happy”在字符串中出现了多少次，我们可以这样做，如下所示</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="edae" class="lx ly in ls b gy lz ma l mb mc">const str = "I felt happy because I saw the others were happy and because I knew I should feel happy, but I wasn’t really happy.";<br/>const pattern = /happy/g;<br/>let count = 0;<br/>while((result = pattern.exec(str)) !== null) {<br/> count++;<br/> console.log(result[0], pattern.lastIndex - result[0].length);<br/>}<br/>console.log("Total Occurrences:", count);</span><span id="5029" class="lx ly in ls b gy me ma l mb mc">/* output</span><span id="43cb" class="lx ly in ls b gy me ma l mb mc">happy 7<br/>happy 43<br/>happy 82<br/>happy 109<br/>Total Occurrences: 4</span><span id="9a5a" class="lx ly in ls b gy me ma l mb mc">*/</span></pre><p id="a675" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是上面的代码有一个问题，我们直接将模式中的文本happy硬编码为<br/><strong class="kv io">const pattern =/happy/g；</strong></p><p id="2af1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是如果预先不知道要搜索的文本，我们可以使用正则表达式的RegExp构造函数来实现与下面相同的事情</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="b100" class="lx ly in ls b gy lz ma l mb mc">const str = "I felt happy because I saw the others were happy and because I knew I should feel happy, but I wasn’t really happy.";<br/><strong class="ls io">const string = "happy";<br/>const pattern = new RegExp(string,"g");</strong><br/>let count = 0;<br/>while((result = pattern.exec(str)) !== null) {<br/> count++;<br/> console.log(result[0], pattern.lastIndex - result[0].length);<br/>}<br/>console.log("Total Occurrences:", count);</span><span id="e912" class="lx ly in ls b gy me ma l mb mc">/* output</span><span id="8964" class="lx ly in ls b gy me ma l mb mc">happy 7<br/>happy 43<br/>happy 82<br/>happy 109<br/>Total Occurrences: 4</span><span id="dd52" class="lx ly in ls b gy me ma l mb mc">*/</span></pre><p id="4a0e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在上面的代码中，我们刚刚更改了:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="70f8" class="lx ly in ls b gy lz ma l mb mc">const string = "happy";<br/>const pattern = new RegExp(string,"g");</span></pre><p id="a551" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">而不是:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="2ab8" class="lx ly in ls b gy lz ma l mb mc">const pattern = /happy/g;</span></pre><p id="9066" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以现在您可以在字符串变量中存储要搜索的动态文本，并将其用作RegExp构造函数的第一个参数。</p><p id="915c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">今天就到这里，希望你今天学到了新的东西。</p><p id="73bc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">别忘了直接在你的收件箱</strong> <a class="ae ks" href="https://yogeshchavan.dev" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">这里</strong> </a> <strong class="kv io">订阅我的每周时事通讯，里面有惊人的技巧、诀窍和文章。</strong></p></div></div>    
</body>
</html>