<html>
<head>
<title>Web Components Crash Course (Custom Elements)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件速成班(自定义元素)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/web-components-crash-course-7c0df961a8b7?source=collection_archive---------1-----------------------#2019-11-01">https://javascript.plainenglish.io/web-components-crash-course-7c0df961a8b7?source=collection_archive---------1-----------------------#2019-11-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ce6a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分:定制元素</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8fd492b1726e8185071cedb29b6b3b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*huON82ngbYi-v_BeSLLNeg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@ryoji__iwata?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ryoji Iwata</a> on <a class="ae kv" href="https://unsplash.com/s/photos/puzzle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="1cd6" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="7938" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">市面上比较流行的框架有几个，分别是Angular，React和Vue。这些框架在执行不同任务的方式上有所不同，但它们都有一个共同点。它们都使用<em class="mk">组件</em>作为UI的基本构建模块。做前端开发时很容易陷入框架的土地，因为它们经常被新兵训练营和其他在线课程所推销。完全有可能在不使用这些框架的情况下为您的web应用程序创建组件。几乎所有的现代浏览器都提供了一套被称为<em class="mk"> web组件</em>的本地API。</p><p id="cd03" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir">注意:</strong> <em class="mk">你可以通过从</em> <a class="ae kv" href="https://github.com/Haseeb90/web-components-crash-course" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="mk">这里</em> </strong> </a> <em class="mk">克隆Git库来跟随本文中的代码示例。克隆存储库后，运行</em> <code class="fe mq mr ms mt b">npm install</code> <em class="mk">来设置项目。</em></p><h1 id="9197" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">Web组件API</h1><p id="b4ba" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在处理web组件时，有三种主要的技术可以让您开发和发布可重用的UI组件:</p><ul class=""><li id="674d" class="mu mv iq lq b lr ml lu mm lx mw mb mx mf my mj mz na nb nc bi translated"><strong class="lq ir">自定义元素:</strong>这个API允许你创建新的DOM元素，类似于<code class="fe mq mr ms mt b">&lt;input&gt;</code>、<code class="fe mq mr ms mt b">&lt;article&gt;</code>、<code class="fe mq mr ms mt b">&lt;footer&gt;</code>等。</li><li id="0d70" class="mu mv iq lq b lr nd lu ne lx nf mb ng mf nh mj mz na nb nc bi translated"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/web-components-crash-course-b0a2feb11be1" rel="noopener"> <strong class="lq ir"> HTML模板</strong> </a> <strong class="lq ir"> : </strong> <em class="mk">(链接)</em><strong class="lq ir"/><strong class="lq ir"/><code class="fe mq mr ms mt b">&lt;template&gt;</code>允许您保留未呈现但稍后将在JavaScript中使用的内容</li><li id="7564" class="mu mv iq lq b lr nd lu ne lx nf mb ng mf nh mj mz na nb nc bi translated"><a class="ae kv" href="https://medium.com/@haseebkhan_90/web-components-crash-course-shadow-dom-803183fcfabc" rel="noopener"><strong class="lq ir"/></a><strong class="lq ir">:</strong><em class="mk">【链接】</em>是一种非常有用的技术，可以让你的组件与外部应用程序隔离开来。如果您计划在NPM上发布您的web组件以与其他开发人员共享，这将非常有用。</li></ul><p id="a45c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir">注意:</strong> <em class="mk">这三项技术涉及的内容很多，所以我将按照上面的顺序把它分成三篇独立的文章。</em></p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="05bf" class="kw kx iq bd ky kz np lb lc ld nq lf lg jw nr jx li jz ns ka lk kc nt kd lm ln bi translated">自定义元素</h1><p id="c768" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">自定义元素允许您创建自定义HTML标签。这是您将创建的任何web组件的核心。以下是自定义元素的外观:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="e03d" class="ny kx iq mt b gy nz oa l ob oc">&lt;app-toolbar&gt;&lt;/app-toolbar&gt;</span></pre><p id="1403" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当你用自定义元素API创建一个标签时，你<strong class="lq ir">必须</strong>使用至少两个用连字符<code class="fe mq mr ms mt b">-</code>分隔的单词。这样做的原因是每个单词标签都是针对W3C的，这个规则帮助浏览器区分自定义元素和W3C定义的标签。</p><p id="c099" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">要创建自定义元素，您只需创建一个从<code class="fe mq mr ms mt b">HTMLElement</code>基类扩展而来的类，如下所示:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="1a65" class="ny kx iq mt b gy nz oa l ob oc">// app-toolbar.component.js</span><span id="c36c" class="ny kx iq mt b gy od oa l ob oc">export default class AppToolbar extends HTMLElement {<br/>  // logic for your component...<br/>}</span></pre><p id="eb25" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">浏览器有一个组件注册表，它跟踪浏览器能够理解的有效标签。要在HTML文件中使用该组件，您必须首先将其添加到<strong class="lq ir">浏览器组件注册表</strong>。将我们的组件添加到浏览器组件注册表意味着将标记名连接到一个定制元素类。你应该这么做:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="f1ad" class="ny kx iq mt b gy nz oa l ob oc">// app.js<br/>import AppToolbar from './app-toolbar.component.js';</span><span id="9f29" class="ny kx iq mt b gy od oa l ob oc">customElements<br/>  .define('app-toolbar', AppToolbar);</span></pre><p id="67ca" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir">注意:</strong> <em class="mk">你不需要在一个单独的文件中完成，你可以在一个文件中完成所有的工作，但是这种方式保持了你的组件逻辑的整洁，并且允许你在一个单独的位置将所有的定制组件添加到注册表中。</em></p><p id="2d54" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">一旦将自定义元素添加到浏览器组件注册表中，就可以在HTML文件中使用标记，如下所示:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="e8b3" class="ny kx iq mt b gy nz oa l ob oc">...<br/>&lt;body&gt;<br/>  &lt;div id="root"&gt;<br/>    &lt;app-toolbar&gt;&lt;/app-toolbar&gt;<br/>  &lt;/div&gt;<br/>&lt;/body&gt;<br/>...</span></pre><p id="8717" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果你已经克隆了<a class="ae kv" href="https://github.com/Haseeb90/web-components-crash-course" rel="noopener ugc nofollow" target="_blank"> Git repo </a>并且在主分支上，运行命令<code class="fe mq mr ms mt b">npm run serve</code>，你不会看到任何太令人兴奋的东西。您实际上根本看不到任何东西，因为我们还没有向组件添加任何逻辑、模板或样式。</p><h2 id="1d16" class="ny kx iq bd ky oe of dn lc og oh dp lg lx oi oj li mb ok ol lk mf om on lm oo bi translated">属性以及如何管理它们</h2><p id="116c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><strong class="lq ir">注:</strong> <em class="mk">如果您想了解本节及其示例，请切换到管理属性分支</em> <code class="fe mq mr ms mt b">git checkout managing-attributes</code></p><p id="261c" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">web组件有很多优点，但最突出的一点是它们可以用于任何框架和任何应用程序，无论是新的还是旧的。为了实现这一点，您创建的定制元素需要与原生HTML元素具有相同的API。这意味着，如果您想要向您的自定义元素添加一个属性，它应该像任何其他属性一样易于管理。以<code class="fe mq mr ms mt b">&lt;input&gt;</code>元素为例，您可以通过HTML、带有<code class="fe mq mr ms mt b">element.getAttribute(…)</code>和<code class="fe mq mr ms mt b">element.setAttribute(…, …)</code>的DOM API以及属性访问<code class="fe mq mr ms mt b">element.value = ‘someValue’;</code>来添加和修改属性。这里有一个例子:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="f488" class="ny kx iq mt b gy nz oa l ob oc">&lt;input id='someId' type='text' value='someValue'/&gt;</span><span id="5173" class="ny kx iq mt b gy od oa l ob oc">const element = document<strong class="mt ir">.getElementById</strong>('someId');</span><span id="0142" class="ny kx iq mt b gy od oa l ob oc"><strong class="mt ir">element</strong>.<strong class="mt ir">setAttribute</strong>('value', 'someOtherValue');<br/>const value = <strong class="mt ir">element.getAttribute</strong>('value');</span><span id="9329" class="ny kx iq mt b gy od oa l ob oc">console.log(value); //'someOtherValue'<br/><strong class="mt ir">element.value =</strong> 'brandNewValue';<br/>const newValue = <strong class="mt ir">element.value</strong>;<br/>console.log(newValue); //'brandNewValue'</span></pre><p id="10e8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这些方法中的每一个都做同样的事情，它们设置或获取属性值并保持同步，因此无论您使用什么方式获取或设置属性，它总是返回预期的<em class="mk">同步</em>值。在向自定义元素添加属性时，我们需要记住这条规则。</p><p id="78a9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们在工具栏示例中添加一些属性。打开src目录中的<code class="fe mq mr ms mt b">toolbar.component.js</code>,添加以下代码</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="3ebd" class="ny kx iq mt b gy nz oa l ob oc">export default class AppToolbar extends HTMLElement {<br/>  get title() {<br/>    return this.getAttribute('title');<br/>  }<br/>  <br/>  set title(value){<br/>    this.setAttribute('title', value);<br/>  }<br/>}</span></pre><p id="9498" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">准备就绪后，对<code class="fe mq mr ms mt b">index.html</code>进行以下更改</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="eee7" class="ny kx iq mt b gy nz oa l ob oc">&lt;app-toolbar title="some title"&gt;&lt;/app-toolbar&gt;</span></pre><p id="ce0b" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在，如果您还没有，运行<code class="fe mq mr ms mt b">npm run serve</code>，在您的浏览器控制台中，您应该能够获得并设置<code class="fe mq mr ms mt b">app-toolbar</code>元素的标题属性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/78f961b7efee1ae8067d4304b6713caa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*bCyKd5zwCujcYsMdrv2VTw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">We’re able to get and set the title attribute with the same API as any other native element.</figcaption></figure><p id="4228" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">我们添加到自定义元素类中的<code class="fe mq mr ms mt b">getter</code>和<code class="fe mq mr ms mt b">setter</code>只是由<code class="fe mq mr ms mt b">HTMLElement</code>类提供的<code class="fe mq mr ms mt b">setAttribute()</code>和<code class="fe mq mr ms mt b">getAttribute()</code>方法的包装器，因此设置属性的三种方式会自动同步。现在，您可以通过<code class="fe mq mr ms mt b">markup</code>，使用<code class="fe mq mr ms mt b">setAttribute()</code>或使用类上的<code class="fe mq mr ms mt b">setter</code>来设置属性。</p><p id="82d7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir">注意:</strong> <em class="mk">在我们的自定义元素类中，我们使用</em> <code class="fe mq mr ms mt b">this.getAttribute()</code> <em class="mk">和</em> <code class="fe mq mr ms mt b">this.setAttribute()</code> <em class="mk">来表示自定义元素</em> <code class="fe mq mr ms mt b">this</code> <em class="mk">所指的是元素本身，即我们正在创建的元素。</em></p><p id="7e78" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">HTML属性的一个限制是它们是字符串。如果你想设置一个不是字符串的属性，你必须先把它转换成字符串。当您将组件发布给其他人在他们的应用程序中使用时，这种约束是很好的，因为您不知道他们将使用什么数据类型。但是，您编写的许多组件可能是为您的私人应用程序编写的，它们可能不会公开发布供公众使用。在这种情况下，您可以只使用setter来设置属性，而不必先将其转换为字符串。</p><h1 id="42b9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">组件生命周期挂钩</h1><p id="ee13" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><strong class="lq ir">注意:</strong> <em class="mk">如果您想了解本节及其示例，请切换到生命周期挂钩分支</em> <code class="fe mq mr ms mt b">git checkout lifecycle-hooks</code></p><p id="da1e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">有四个主要的生命周期挂钩，你会在日常生活中看到，其中一个并没有真正使用很多。它们如下:</p><ul class=""><li id="d805" class="mu mv iq lq b lr ml lu mm lx mw mb mx mf my mj mz na nb nc bi translated"><code class="fe mq mr ms mt b">connectedCallback</code>:用于监听你的组件何时被添加到DOM中</li><li id="2a7e" class="mu mv iq lq b lr nd lu ne lx nf mb ng mf nh mj mz na nb nc bi translated"><code class="fe mq mr ms mt b">constructor</code>:用于设置状态，在元素附加到DOM之前调用</li><li id="e089" class="mu mv iq lq b lr nd lu ne lx nf mb ng mf nh mj mz na nb nc bi translated"><code class="fe mq mr ms mt b">disconnectedCallback</code>:用于当你的组件从DOM中移除时进行清理</li><li id="020a" class="mu mv iq lq b lr nd lu ne lx nf mb ng mf nh mj mz na nb nc bi translated"><code class="fe mq mr ms mt b">attributeChangedCallback</code>:用于监听组件的属性变化</li><li id="300a" class="mu mv iq lq b lr nd lu ne lx nf mb ng mf nh mj mz na nb nc bi translated"><code class="fe mq mr ms mt b">adoptedCallback</code>:不常用，但是当你的组件移动到不同的文档时会调用它。</li></ul><p id="3898" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这些方法是构建从定制组件到整个应用程序的基本构件，因此，了解它们如何工作、何时被调用以及如何有效地使用它们是一个好主意。</p><h2 id="9356" class="ny kx iq bd ky oe of dn lc og oh dp lg lx oi oj li mb ok ol lk mf om on lm oo bi translated">ConnectedCallback方法</h2><p id="7e38" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><code class="fe mq mr ms mt b">connectedCallback</code>方法是你渲染DOM的地方，你也可以在这里调用Ajax。</p><p id="3b8e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们将这个方法添加到我们一直在构建的AppToolbar中。下面是它的样子:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="b0fa" class="ny kx iq mt b gy nz oa l ob oc">// toolbar.component.js</span><span id="0c50" class="ny kx iq mt b gy od oa l ob oc">export default class AppToolbar extends HTMLElement {<br/>  ...<br/>  connectedCallback() {<br/>    this.innerHTML = '&lt;p&gt;Yay! Finally something visual!&lt;/p&gt;';<br/>  }<br/>}</span></pre><p id="e9e9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果您还没有，从您的终端运行<code class="fe mq mr ms mt b">npm run serve</code>。当浏览器打开时，您应该会看到浏览器上的文本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/ad27dfaee8977c04ed2d0318ff5c6dbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o2or0SB2xu9AI4M6fAdsLA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><code class="fe mq mr ms mt b">connectedCallback</code> set the innerHTML of our element</figcaption></figure><p id="5ec9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">但是什么时候调用<code class="fe mq mr ms mt b">connectedCallback</code>方法呢？当我们的元素<code class="fe mq mr ms mt b">&lt;app-toolbar&gt;</code>被附加到DOM时，它被调用。为了证明这一点，让我们做一个小实验。打开<code class="fe mq mr ms mt b">index.html</code>文件，删除以下位:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="f6b6" class="ny kx iq mt b gy nz oa l ob oc">&lt;app-toolbar title="some title"&gt;&lt;/app-toolbar&gt;</span></pre><p id="2146" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">保存并刷新浏览器。您会看到一个完全空白的页面，如果您检查该页面，您会看到我们的脚本标记仍然在那里。这意味着我们仍然完全定义了我们的组件，我们仍然把它放在浏览器组件注册表中，但是因为它没有附加到DOM，所以它不会运行。现在，在浏览器控制台中执行以下操作:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="adb1" class="ny kx iq mt b gy nz oa l ob oc">const myElement = document.createElement('app-toolbar');</span></pre><p id="766d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">嗯……屏幕上还是什么都没有。这是因为我们已经创建了元素，但是还没有将它附加到DOM中。仍然在浏览器控制台上，执行以下操作:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="b55d" class="ny kx iq mt b gy nz oa l ob oc">const root = document.getElementById('root');<br/>root.appendChild(myElement);</span></pre><p id="aa30" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">它被附加到DOM上，现在我们看到了我们所期望的</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/e02327a3f529ebda0928596fcc60db36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dXrp-IWzVZSuKz14Whwiag.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The connectedCallback() only runs when the element is attached to the DOM</figcaption></figure><h2 id="022c" class="ny kx iq bd ky oe of dn lc og oh dp lg lx oi oj li mb ok ol lk mf om on lm oo bi translated">构造函数方法</h2><p id="9b87" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">构造函数通常是你想要为你的组件设置某种状态的地方。通常避免在构造函数中调用Ajax，因为这会增加测试的难度。一般来说，你只是想在这里做初始设置，避免做任何“工作”。</p><p id="6d6d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">正如本节开始时提到的，构造函数在<code class="fe mq mr ms mt b">connectedCallback</code>方法之前被调用。让我们用上面的例子来证明这一点。在<code class="fe mq mr ms mt b">toolbar.component.js</code>文件中添加构造函数:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="b51c" class="ny kx iq mt b gy nz oa l ob oc">export default class AppToolbar extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    console.log('This is from the constructor');<br/>  }<br/>  ...<br/>  connectedCallback() {<br/>    this.innerHTML = '&lt;p&gt;Yay! Finally something visual!&lt;/p&gt;';<br/>  }<br/>}</span></pre><p id="b905" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated"><strong class="lq ir">注意:</strong> <em class="mk">如果你在定义自己的构造函数，你必须在里面的第一行调用</em> <code class="fe mq mr ms mt b">super();</code> <em class="mk">，这样</em> <code class="fe mq mr ms mt b">HTMLElement</code> <em class="mk">构造函数首先运行。</em></p><p id="cbeb" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在您的浏览器上，您仍然会看到一个空白屏幕。同样，我们的脚本标签在那里，这意味着它正在运行，但是我们没有实例化该元素，也没有将它附加到DOM。因此，结果我们什么也没看到。在浏览器控制台中，执行以下操作:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="a519" class="ny kx iq mt b gy nz oa l ob oc">const myElement = document.createElement('app-toolbar');</span></pre><p id="a3f8" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">您应该会看到控制台日志被打印出来，但是窗口上没有任何元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/086cbf39cc761f601e31d0dc307deee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EyoHoXdeOjRdrHRf_QgXOA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">document.createElement() instantiates your element and runs the constructor</figcaption></figure><h2 id="25a0" class="ny kx iq bd ky oe of dn lc og oh dp lg lx oi oj li mb ok ol lk mf om on lm oo bi translated">disconnectedCallback方法</h2><p id="c57a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当元素从DOM中移除时，将调用此方法。在这里，您将清除任何状态、事件处理程序以及任何您不再需要的东西。有两个主要的原因可以解释为什么当元素不再存在于DOM中时，您需要进行清理。首先，您不希望您不需要的代码继续被执行。第二，它给了垃圾收集器一个运行的机会。所以，如果不小心，未使用的变量和事件将继续消耗内存。要将<code class="fe mq mr ms mt b">disconnectedCallback</code>方法添加到我们的示例中，打开<code class="fe mq mr ms mt b">src/toolbar-component/toolbar.component.js</code>并在<code class="fe mq mr ms mt b">AppToolbar</code>类中添加以下位:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="b22f" class="ny kx iq mt b gy nz oa l ob oc">disconnectedCallback() {<br/>  console.log('This is from the disconnectedCallback method');<br/>}</span></pre><p id="70f7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">要在操作中看到这一点，请在浏览器控制台中执行以下操作:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="5038" class="ny kx iq mt b gy nz oa l ob oc">const myElement = document.createElement('app-toolbar');<br/>const root = document.getElementById('root');</span><span id="b1c7" class="ny kx iq mt b gy od oa l ob oc">root.appendChild(myElement);</span><span id="5902" class="ny kx iq mt b gy od oa l ob oc">root.removeChild(myElement);</span></pre><p id="eeed" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当您执行<code class="fe mq mr ms mt b">root.appendChild(myElement);</code>时，您会看到它出现在窗口中；当您执行<code class="fe mq mr ms mt b">root.removeChild(myElement);</code>时，它会消失，并在控制台中打印消息。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/d52e73f35245f3f96725e97ebfa8844a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*408qPoS1UqxYKqlzppCSZw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The disconnectedCallback() method gets called when an element is removed from the DOM.</figcaption></figure><h2 id="9c4b" class="ny kx iq bd ky oe of dn lc og oh dp lg lx oi oj li mb ok ol lk mf om on lm oo bi translated">attributeChangedCallback方法</h2><p id="626d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于与该方法相关的示例，让我们将自定义元素添加回<code class="fe mq mr ms mt b">index.html</code>文件，并更改我们的<code class="fe mq mr ms mt b">connectedCallback</code>方法来渲染标题。</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="7976" class="ny kx iq mt b gy nz oa l ob oc">// index.html<br/>&lt;app-toolbar title="some title"&gt;&lt;/app-toolbar&gt;</span><span id="862a" class="ny kx iq mt b gy od oa l ob oc">// toolbar.component.js<br/>export default class AppToolbar extends HTMLElement {<br/>  ...<br/>  connectedCallback() {<br/>    this.innerHTML = `&lt;p&gt;{this.title}&lt;/p&gt;`;<br/>  }<br/>  ...<br/>}</span></pre><p id="995d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">你应该看看这样的东西</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/cf0274f6b2ff93731eee0b0b0451d303.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kIw_GgqMnC9qIoJrBnPfvA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">connectedCallback sets the innerHTML to the value provided by the title attribute.</figcaption></figure><p id="cfe7" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">一切都准备好了，让我们开始吧。此时，您在浏览器中看到的是页面的初始渲染。<code class="fe mq mr ms mt b">title</code>属性通过标记设置在我们的自定义元素上，我们通过获取值并将其设置为元素的<code class="fe mq mr ms mt b">innerHTML</code>来显示它。但是，如果属性在初始渲染后发生变化，会发生什么？我们该如何处理？正如您现在可能已经猜到的，我们将使用<code class="fe mq mr ms mt b">attirbuteChangedCallback</code>在元素的整个生命周期中跟踪属性的任何变化。这个方法，就像它的名字一样，在我们元素的属性每次改变时都会被调用。让我们对示例组件进行必要的更改，看看会是什么样子。</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="85e8" class="ny kx iq mt b gy nz oa l ob oc">export default class AppToolbar extends HTMLElement {</span><span id="4e72" class="ny kx iq mt b gy od oa l ob oc">  constructor() {<br/>    super();<br/>    console.log('This is from the constructor');<br/>    <strong class="mt ir">this.parah = document.createElement('p');</strong><br/>  }</span><span id="fed6" class="ny kx iq mt b gy od oa l ob oc">  <strong class="mt ir">static get observedAttributes() {<br/>    return ['title'];<br/>  }</strong></span><span id="955d" class="ny kx iq mt b gy od oa l ob oc">  get title() {<br/>    return this.getAttribute('title');<br/>  }</span><span id="8352" class="ny kx iq mt b gy od oa l ob oc">  set title(value) {<br/>    this.setAttribute('title', value);<br/>  }</span><span id="48f8" class="ny kx iq mt b gy od oa l ob oc">  <strong class="mt ir">connectedCallback() {<br/>    this.parah.textContent = this.title;<br/>    this.appendChild(this.parah);<br/>  }</strong></span><span id="4ce4" class="ny kx iq mt b gy od oa l ob oc">  disconnectedCallback() {<br/>    console.log('This is from the disconnectedCallback method');<br/>  }</span><span id="2276" class="ny kx iq mt b gy od oa l ob oc">  <strong class="mt ir">attributeChangedCallback(name, oldValue, newValue) {<br/>    if (name === 'title') {<br/>      this.parah.textContent = newValue;<br/>    }<br/>  }<br/></strong>}</span></pre><p id="4ffb" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这就是我们的自定义元素类在变化后的样子。保存更改，并在浏览器控制台中执行以下操作:</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="d591" class="ny kx iq mt b gy nz oa l ob oc">const myElement = document.querySelector('app-toolbar');<br/>myElement.title = "Cool new title change";</span></pre><p id="88c6" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">您应该马上看到我们元素的文本发生了变化</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/d85616eac889772f8264f5dc8dd8d76a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jdGMoy06eEV7UWWYjgPfkw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The attributeChangeCallback() detected the change in the title attribute and updated the DOM</figcaption></figure><p id="94aa" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">让我们多谈一点这个方法本身以及它是如何工作的。在类的顶部，我们定义了一个名为<code class="fe mq mr ms mt b">observedAttributes</code>的新静态getter，它返回一个数组。这个getter返回您希望观察变化的属性数组，因此有了自定义名称<code class="fe mq mr ms mt b">observedAttributes</code>。为了看到这一点，让我们向组件添加另一个属性。首先，让我们修改我们的<code class="fe mq mr ms mt b">index.html</code>来拥有新的属性。</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="15e3" class="ny kx iq mt b gy nz oa l ob oc">// index.html<br/>&lt;app-toolbar title="some title" <strong class="mt ir">color="green"</strong>&gt;&lt;/app-toolbar&gt;</span></pre><p id="8f18" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在，我们必须在组件类中为这个新属性添加一个getter和setter。当我们这样做的时候，让我们把它作为一种风格应用到我们的段落中。组件类现在应该看起来像这样。</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="2e04" class="ny kx iq mt b gy nz oa l ob oc">export default class AppToolbar extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    console.log('This is from the constructor');<br/>    this.parah = document.createElement('p');<br/>  }</span><span id="fbc4" class="ny kx iq mt b gy od oa l ob oc">  ...</span><span id="9f15" class="ny kx iq mt b gy od oa l ob oc">  <strong class="mt ir">get color() {<br/>    return this.getAttribute('color');<br/>  }</strong></span><span id="c487" class="ny kx iq mt b gy od oa l ob oc"><strong class="mt ir">  set color(value) {<br/>    this.setAttribute('color', value);<br/>  }</strong></span><span id="aa9e" class="ny kx iq mt b gy od oa l ob oc">  connectedCallback() {<br/>    this.parah.textContent = this.title;<br/>    <strong class="mt ir">this.parah.style.color = this.color;</strong><br/>    this.appendChild(this.parah);<br/>  }<br/>  <br/>  ...<br/>}</span></pre><p id="7e9e" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当你刷新你的浏览器时，你应该看到应用的样式，文字应该是绿色的。这是我们最初的渲染:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/ef3f6ecef5673ab981b263237d788d5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MdGyLA98GE_1vKQsWvfM5Q.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Initial render</figcaption></figure><p id="1953" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在，我们还没有将我们的<code class="fe mq mr ms mt b">color</code>属性添加到<code class="fe mq mr ms mt b">observedAttributes</code>的列表中，但是让我们修改<code class="fe mq mr ms mt b">attributeChangedCallback</code>来跟踪变化并应用它们，就像这样</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="5803" class="ny kx iq mt b gy nz oa l ob oc">export default class AppToolbar extends HTMLElement {<br/>  ...<br/>  static get observedAttributes() {<br/>    return ['title'];<br/>  }<br/>  ...<br/>  attributeChangedCallback(name, oldValue, newValue) {<br/>    if (name === 'title') {<br/>      this.heading.textContent = newValue;<br/>    }<br/>    <strong class="mt ir">if (name === 'color') {<br/>      this.heading.style.color = newValue;<br/>    }</strong><br/>  }<br/>}</span></pre><p id="9709" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">当我们试图通过API改变颜色时，你认为会发生什么？颜色会变吗？让我们看看:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/79519fa020bbe7f40e2d29b95fa6c4cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8k9iVF-sYka_OD6KwaFwJw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Attributes not atted to the observedAttributes array won’t be detected in attributeChangedCallback method</figcaption></figure><p id="c7aa" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">风格没变。这是因为没有添加到列表<code class="fe mq mr ms mt b">observedAttributes</code>中的属性不会被<code class="fe mq mr ms mt b">attributeChangedCallback</code>方法选取。让我们将它添加到列表中，然后重试。</p><pre class="kg kh ki kj gt nu mt nv nw aw nx bi"><span id="8e45" class="ny kx iq mt b gy nz oa l ob oc">export default class AppToolbar extends HTMLElement {<br/>  ...<br/>  static get observedAttributes() {<br/>    <strong class="mt ir">return ['title', 'color'];</strong><br/>  }<br/>  ...<br/>  attributeChangedCallback(name, oldValue, newValue) {<br/>    if (name === 'title') {<br/>      this.heading.textContent = newValue;<br/>    }<br/>    if (name === 'color') {<br/>      this.heading.style.color = newValue;<br/>    }<br/>  }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/810474887e6490e9a938ebec6db19eb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPdRNkORksX5mjlBHBB3NA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Once added to the list of observedAttributes the changes are detected and applied as specified</figcaption></figure><p id="e35a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">因此，有了这个证明，无论何时你想要跟踪一个属性的变化，你必须首先把它添加到<code class="fe mq mr ms mt b">observedAttributes</code>列表中，然后在<code class="fe mq mr ms mt b">attributeChangedCallback</code>回调中处理这个变化。</p></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><h1 id="2da6" class="kw kx iq bd ky kz np lb lc ld nq lf lg jw nr jx li jz ns ka lk kc nt kd lm ln bi translated">结论</h1><p id="4f97" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">到目前为止，您应该已经了解了定制元素的基础知识</p><ul class=""><li id="8cf8" class="mu mv iq lq b lr ml lu mm lx mw mb mx mf my mj mz na nb nc bi translated">如何用getters和setters管理属性</li><li id="a894" class="mu mv iq lq b lr nd lu ne lx nf mb ng mf nh mj mz na nb nc bi translated">如何以及何时使用组件的不同生命周期挂钩</li></ul><p id="3013" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在这篇文章中，我们没有太多的接口可以使用，我们主要关注类和如何管理组件。在下一篇文章中，我将讨论模板以及如何使用它们为你构建的组件提供布局。</p><p id="f360" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果你喜欢这篇文章，请分享给你的朋友，并期待下一篇！</p><p id="fd52" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">直到下一次，和平！</p></div></div>    
</body>
</html>