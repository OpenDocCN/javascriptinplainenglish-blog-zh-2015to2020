<html>
<head>
<title>Destructure React Props with ES6 Object Destructuring for Cleaner Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用ES6对象进行析构来获得更清晰的代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/destructure-react-props-with-es6-object-destructuring-for-cleaner-code-3984453e484d?source=collection_archive---------2-----------------------#2020-12-08">https://javascript.plainenglish.io/destructure-react-props-with-es6-object-destructuring-for-cleaner-code-3984453e484d?source=collection_archive---------2-----------------------#2020-12-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7731" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">当您在React中为一个组件编写渲染函数时，它接受一个包含属性(“props”)的<code class="fe kf kg kh ki b">props</code>对象，您将使用该对象来配置该组件。道具使得组件可以重用。为了编写更干净的代码，您可以使用ES6对象析构将<code class="fe kf kg kh ki b">props</code>对象析构为单独的变量。</h2></div><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/88a49002e53d36a57ebac2b9e95865bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9CZu2_V6BYqEAyy_"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@deeprahim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">ibrahim sabuncuoğlu</a> on <a class="ae kz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e022" class="la lb iq bd lc ld le lf lg lh li lj lk jw ll jx lm jz ln ka lo kc lp kd lq lr bi translated">在React中使用ES6对象析构</h1><p id="1fc4" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">React <code class="fe kf kg kh ki b"><a class="ae kz" href="https://reactjs.org/docs/components-and-props.html" rel="noopener ugc nofollow" target="_blank">props</a></code>对象是由React中父组件传递给组件的属性(简称“props”)组成的。拥有道具是React组件可重用和模块化的原因。</p><p id="ab88" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><code class="fe kf kg kh ki b">props</code>对象是<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_getting_started" rel="noopener ugc nofollow" target="_blank"> React的</a> <code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_getting_started" rel="noopener ugc nofollow" target="_blank">render</a></code> <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_getting_started" rel="noopener ugc nofollow" target="_blank">函数</a> ( <code class="fe kf kg kh ki b"><a class="ae kz" href="https://reactjs.org/docs/rendering-elements.html" rel="noopener ugc nofollow" target="_blank">render(props)</a></code>)的唯一参数。您从<a class="ae kz" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"> JSX </a>中的父组件传递<code class="fe kf kg kh ki b">props</code>:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mt"><img src="../Images/0fea8a051409178b124ea90713dbc43e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tycZe-l_hnBAH6OlUUnN_g.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae kz" href="https://gist.github.com/DoctorDerek/b146ee0653677e094676d1684aa11b54" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="b8c2" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">通常，我们使用<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors" rel="noopener ugc nofollow" target="_blank"/><code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors" rel="noopener ugc nofollow" target="_blank">.</a></code><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors" rel="noopener ugc nofollow" target="_blank">语法</a>从<code class="fe kf kg kh ki b">props</code>中提取<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Glossary/property/JavaScript" rel="noopener ugc nofollow" target="_blank">属性</a>，因为<code class="fe kf kg kh ki b">props</code>对象只是一个典型的<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics" rel="noopener ugc nofollow" target="_blank"> JavaScript对象</a>。例如，我们可能调用React <a class="ae kz" href="https://reactjs.org/docs/components-and-props.html#function-and-class-components" rel="noopener ugc nofollow" target="_blank">功能组件</a>中的<code class="fe kf kg kh ki b">props.name</code>或React <a class="ae kz" href="https://reactjs.org/docs/components-and-props.html#function-and-class-components" rel="noopener ugc nofollow" target="_blank">类组件</a>中的<code class="fe kf kg kh ki b">this.props.name</code>。不过，有一个更好的语法:<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> ES6对象析构</a>。</p><blockquote class="mu mv mw"><p id="3be7" class="ls lt mx lu b lv mo jr lx ly mp ju ma my mq md me mz mr mh mi na ms ml mm mn ij bi translated">“<strong class="lu ir">析构赋值</strong>语法是一个JavaScript表达式，它可以将数组中的值或对象中的属性解包到不同的变量中。”— <a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> MDN文档</a></p></blockquote><p id="23e7" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果你尝试过使用<a class="ae kz" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank"/><code class="fe kf kg kh ki b"><a class="ae kz" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">useState</a></code><a class="ae kz" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank">钩子</a>(<a class="ae kz" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank">React钩子</a>之一)，那么你已经看到了数组析构语法:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nb"><img src="../Images/6ed982b41f49bd0ae01c9fb456267ca7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x-0PvLWmJ-J63Q_cVXqrZA.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae kz" href="https://gist.github.com/DoctorDerek/3e34712b3e0f31508190fe506966ecc9" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="01e3" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">对象析构对对象的作用类似，允许您将它们的属性提取到同名的变量中:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nc"><img src="../Images/9b679283057246af66b22732e0381a2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9wNWjm4-RpnOOYwMv9dXSQ.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae kz" href="https://gist.github.com/DoctorDerek/c4137b083fabc39e0280baae3a49e797" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="0921" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">乍一看，析构似乎是一个毫无意义的把戏(<em class="mx">谁需要更多的变量？我喜欢在我的React代码中使用道具析构。</em></p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="027c" class="la lb iq bd lc ld nk lf lg lh nl lj lk jw nm jx lm jz nn ka lo kc no kd lq lr bi translated">析构有什么好处？</h1><p id="2937" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">当在React中使用props时，您的代码可能会以一堆<code class="fe kf kg kh ki b">this.props.someProp</code>和<code class="fe kf kg kh ki b">this.props.otherProp</code>结束——使其难以阅读，并且在开发过程中可能更容易出现简单的输入错误。</p><blockquote class="mu mv mw"><p id="5b81" class="ls lt mx lu b lv mo jr lx ly mp ju ma my mq md me mz mr mh mi na ms ml mm mn ij bi translated">"通过析构赋值，等价代码变得更加简洁，可读性更好."— <a class="np nq ep" href="https://medium.com/u/a34c2323ffbc?source=post_page-----3984453e484d--------------------------------" rel="noopener" target="_blank">尼克·菲茨杰拉德</a>和<a class="np nq ep" href="https://medium.com/u/d441603593d6?source=post_page-----3984453e484d--------------------------------" rel="noopener" target="_blank">杰森·奥伦多夫</a> <a class="ae kz" href="https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/" rel="noopener ugc nofollow" target="_blank">在Mozilla Hacks博客</a></p></blockquote><p id="7bce" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">当我们不用<code class="fe kf kg kh ki b">props.name</code>(在<a class="ae kz" href="https://reactjs.org/docs/components-and-props.html#function-and-class-components" rel="noopener ugc nofollow" target="_blank">函数组件</a>中)或<code class="fe kf kg kh ki b">this.props.name</code>(在<a class="ae kz" href="https://reactjs.org/docs/components-and-props.html#function-and-class-components" rel="noopener ugc nofollow" target="_blank">类组件</a>中)而只说<code class="fe kf kg kh ki b">name</code>时，我们的代码对我们和其他任何阅读代码的开发人员来说都会变得更加清晰。</p><blockquote class="mu mv mw"><p id="391b" class="ls lt mx lu b lv mo jr lx ly mp ju ma my mq md me mz mr mh mi na ms ml mm mn ij bi translated">"析构在React应用中大放异彩，它可以大大简化你编写道具的方式."——<a class="np nq ep" href="https://medium.com/u/22a65413b48f?source=post_page-----3984453e484d--------------------------------" rel="noopener" target="_blank">林赛·克里斯威尔</a> <a class="ae kz" href="https://medium.com/@lcriswell/destructuring-props-in-react-b1c295005ce0" rel="noopener">在她的媒体博客</a>上</p></blockquote><p id="f48b" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这可能没什么意义，但是你可以在React代码库中轻松地输入几百次<code class="fe kf kg kh ki b">this.props.</code>。相反，通过在<code class="fe kf kg kh ki b">props</code>对象上使用ES6对象析构，您可以使您的代码更加简单。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="b957" class="la lb iq bd lc ld nk lf lg lh nl lj lk jw nm jx lm jz nn ka lo kc no kd lq lr bi translated">支持函数组件中的析构</h1><p id="3b6c" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">让我们来看一个代码示例，在这个示例中，我们将一个名字和一个表情符号传递给一个将显示它的组件。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nr"><img src="../Images/998fb62c4913f9a68908e60c33cf36b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aex93Su7rVayR1kSpR61yw.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae kz" href="https://gist.github.com/DoctorDerek/07f94cc733865dfe500c76270af4999c" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="fbee" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">特别是当你重复使用一个道具的时候，当你可以参考<code class="fe kf kg kh ki b">{emoji}</code>而不是<code class="fe kf kg kh ki b">{props.emoji}</code>的时候，你开始节省大量的输入。</p><p id="59d0" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">下面是相同的React函数组件，但没有析构:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ns"><img src="../Images/267ee6379ff8c9513aa93e5f2dd837f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yj6s59mY2wLmmFZNd1rD4g.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae kz" href="https://gist.github.com/DoctorDerek/45bbd012ef3198f54affb2fb24006407" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="d121" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">对于这样一个小的组件来说，这并不是很大的区别，但是对于一个有几十个道具的反应组件来说，破坏对于可读性来说是一件大事。</p><p id="a250" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">通过破坏来明确指定道具也是对你自己和其他开发者的一种提醒，提醒他们你在期待什么样的道具——当你从未破坏过这些道具时，这是很容易被遗忘的。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="f9c6" class="la lb iq bd lc ld nk lf lg lh nl lj lk jw nm jx lm jz nn ka lo kc no kd lq lr bi translated">类组件中的道具破坏</h1><p id="6291" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">我更喜欢在reactor中使用函数组件，但是ES6破坏在reactor类组件中的工作原理是一样的。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nt"><img src="../Images/052f6594d9aa5c67ba1509a87c302d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QnABQBZjmcVlEl5TEJsNQg.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae kz" href="https://gist.github.com/DoctorDerek/b20bff911c44717fa0c9b2ed3c0fff87" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="7d53" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">破坏道具比筛选代码中的几十个<code class="fe kf kg kh ki b">this.props.someProp</code>引用更容易阅读。</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="500a" class="la lb iq bd lc ld nk lf lg lh nl lj lk jw nm jx lm jz nn ka lo kc no kd lq lr bi translated">函数参数中的道具破坏</h1><p id="5b99" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">为了更好的可读性，我们可以在render函数的参数中破坏<code class="fe kf kg kh ki b">props</code>对象。在函数声明中，析构的工作方式与变量赋值相同。</p><p id="35af" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这意味着您可以在参数中正确地破坏道具对象:<code class="fe kf kg kh ki b">render(props)</code>变为<code class="fe kf kg kh ki b">render({name, emoji})</code>。如果这对你来说没什么意义，那么<a class="np nq ep" href="https://medium.com/u/22a65413b48f?source=post_page-----3984453e484d--------------------------------" rel="noopener" target="_blank">林赛·克里斯威尔</a> <a class="ae kz" href="https://medium.com/@lcriswell/destructuring-props-in-react-b1c295005ce0" rel="noopener">在她的Medium博客上有一篇很棒的帖子</a>解释了如何在渲染函数的参数中破坏道具。</p><p id="ff45" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这里是以前的同一个函数组件的例子，但是我把析构函数移到了函数的参数中。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nu"><img src="../Images/6db08f80d9100c55984ad8c83c45a1f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F6PHiem6SuTdAWDB_X2K8Q.png"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk"><a class="ae kz" href="https://gist.github.com/DoctorDerek/acd59884d2a41726208df5ea19f0212f" rel="noopener ugc nofollow" target="_blank">View raw code</a> as a GitHub Gist</figcaption></figure><p id="6e01" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在这个例子中，我通过使用<code class="fe kf kg kh ki b">render</code>函数参数中的析构语法从<code class="fe kf kg kh ki b">props</code>中提取<code class="fe kf kg kh ki b">name</code>和<code class="fe kf kg kh ki b">emoji</code>属性。</p><p id="3f5b" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">许多开发人员更喜欢这种用于破坏反作用道具的语法——你从来不需要真正键入单词<code class="fe kf kg kh ki b">props</code>。😂</p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><h1 id="1f36" class="la lb iq bd lc ld nk lf lg lh nl lj lk jw nm jx lm jz nn ka lo kc no kd lq lr bi translated">结论:被破坏的反应道具更好</h1><p id="fa0d" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">你应该总是在反应中破坏你的道具吗？嗯，也许不是每次都这样，但是您至少应该熟悉这样做的语法。</p><p id="5ff1" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">我认为通过破坏道具对象，反应组件变得更加可读，我一直是<a class="ae kz" href="https://medium.com/better-programming/why-you-should-make-your-code-as-simple-as-possible-3b35e89f137" rel="noopener">简单代码</a>的拥护者。</p><p id="549f" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">破坏反作用道具非常有效，尤其是当你同时绕过所有的道具时，正如我在《黎明编码》中讲解的<a class="ae kz" href="https://medium.com/coding-at-dawn/how-to-pass-all-props-to-a-child-component-in-react-bded9e38bb62" rel="noopener">:</a></p><div class="nv nw gp gr nx ny"><a href="https://medium.com/coding-at-dawn/how-to-pass-all-props-to-a-child-component-in-react-bded9e38bb62" rel="noopener follow" target="_blank"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd ir gy z fp od fr fs oe fu fw ip bi translated">如何在React中将所有属性传递给子组件</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">能够在React中共享从父组件到子组件的所有道具，让您可以轻松地将您的应用程序分解成小…</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">medium.com</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om kt ny"/></div></div></a></div><p id="4340" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果您需要<code class="fe kf kg kh ki b">props</code>对象使用<code class="fe kf kg kh ki b">...</code>扩展操作符(<code class="fe kf kg kh ki b">{...props}</code>)将所有道具传递给子组件，那么您不会希望在函数<code class="fe kf kg kh ki b">render(props)</code>的参数中析构<code class="fe kf kg kh ki b">props</code>。</p><p id="804f" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">相反，您可能希望使用赋值语法(使用<a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment" rel="noopener ugc nofollow" target="_blank"/><code class="fe kf kg kh ki b"><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment" rel="noopener ugc nofollow" target="_blank">=</a></code><a class="ae kz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment" rel="noopener ugc nofollow" target="_blank">操作符</a>)在渲染函数的顶部析构<code class="fe kf kg kh ki b">props</code>，让<code class="fe kf kg kh ki b">props</code>对象保持不变，以便能够将其传递给子组件。</p><p id="0fe6" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">希望这有助于您理解在使用React props时ES6对象析构语法的有用性。</p><p id="742c" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ir">快乐编码！💻 (☞ﾟヮﾟ)☞ 🤑</strong></p></div><div class="ab cl nd ne hu nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ij ik il im in"><p id="40de" class="pw-post-body-paragraph ls lt iq lu b lv mo jr lx ly mp ju ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">德里克·奥斯汀博士是《职业规划:如何在6个月内成为一名成功的6位数程序员》一书的作者，该书现已在亚马逊上出售。</p></div></div>    
</body>
</html>