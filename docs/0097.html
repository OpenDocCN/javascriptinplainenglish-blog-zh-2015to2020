<html>
<head>
<title>When to Write Jest Snapshot Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">何时编写笑话快照测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/should-i-be-writing-snapshot-tests-47da13a62085?source=collection_archive---------0-----------------------#2019-03-07">https://javascript.plainenglish.io/should-i-be-writing-snapshot-tests-47da13a62085?source=collection_archive---------0-----------------------#2019-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6438" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从哪里开始，知道何时使用它们</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/22f88b4ae08e4639cab0c245642c8888.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PBrCN1E2znxkF8nV"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jakobowens1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jakob Owens</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="60b5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">当我在研究测试框架，特别是那些与React集成的框架时，Jest是一个明显的选择。</h1><p id="035b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Jest的特征之一是一种称为快照测试的新工具。起初，这听起来很有趣，但在做了更多的研究并看到开发者的许多不同意见后，我变得谨慎起来。</p><p id="05c7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">以下是我们团队对快照测试的看法以及我们从经验中学到的东西:</p><ul class=""><li id="db9e" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">什么时候写，</li><li id="4c26" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">为什么要写它们，</li><li id="4b4a" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">如何利用它们来防止退化？</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/62c3b04466cedc0deb052741f013c89b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsMaT2xpKIoY3g4c1nlcwA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">React + Jest = a match made in heaven!</figcaption></figure><h1 id="c651" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">快照测试是Jest的一个特性，它允许您测试Javascript对象。</h1><p id="17b4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">它们与React组件配合良好，因为当您渲染组件时，您可以查看DOM输出，并在测试运行时创建<em class="ne">“快照”</em>。这些类型的测试有助于防止回归，因为如果有任何东西导致组件改变，这个测试就会抓住它。根据我们团队的经验，当您可以将道具传递给功能组件并测试有限数量的案例时，快照测试是最有效的。</p><h2 id="961b" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated">何时写入快照测试</h2><ul class=""><li id="d000" class="mp mq iq lq b lr ls lu lv lx nr mb ns mf nt mj mu mv mw mx bi translated">如果组件不经常更新</li><li id="6c59" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">如果一个组件不是太复杂</li><li id="f517" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">如果很容易看到您实际测试的内容</li></ul><p id="cd72" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这些规则非常模糊，但应该可以很快帮助您决定快照测试是否合适。</p><p id="2003" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您有一个测试经常更新的组件的快照测试，那么您需要不断更新附带的测试。如果您养成了只更新这些测试而不仔细检查输出文件的坏习惯，这些测试就会失去它们的价值。</p><p id="6785" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果一个组件太复杂，就很难确定实际测试的是什么。如果在渲染之前有大量的业务逻辑和条件语句，那么没有使用该功能的人怎么知道发生了什么呢？</p><p id="f6fb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">编写快照测试时要记住的最重要的规则是给测试命名。如果您不能轻松准确地命名您的测试，很可能它不应该是快照测试。</p><h1 id="be21" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">快照测试示例</h1><p id="0546" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><strong class="lq ir"> spinner.spec.js </strong>使用<a class="ae kv" href="https://medium.com/@chrisgirard/testing-components-with-jest-and-react-testing-library-d36f5262cde2" rel="noopener">反应-测试-库</a></p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="037c" class="nf kx iq nv b gy nz oa l ob oc">// Spinner component<br/>const Spinner = props =&gt; (<br/> props.loading ?<br/>  &lt;div className={`icon icon-spin text-center ${props.size} ${props.color}} /&gt;<br/>  : null)<br/>        <br/>export default Spinner;</span><span id="a753" class="nf kx iq nv b gy od oa l ob oc">// Spinner spec<br/>describe('Spinner snapshot test ', () =&gt; {<br/>    it('should render a large blue spinner', () =&gt; {<br/>        const props = {<br/>            loading: true,<br/>            size: "large",<br/>            color: "blue"<br/>        };</span><span id="3921" class="nf kx iq nv b gy od oa l ob oc">const container = render(&lt;Spinner {...props} /&gt;);<br/>        expect(container.firstChild).toMatchSnapshot();<br/>    })<br/>})</span></pre><p id="6b83" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"> spinner.spec.js.snap </strong></p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="9a54" class="nf kx iq nv b gy nz oa l ob oc">// Jest Snapshot v1</span><span id="d629" class="nf kx iq nv b gy od oa l ob oc">exports[`&lt;Spinner /&gt; Snapshot Tests renders as expected 1`] = `<br/>&lt;div<br/>  class="icon icon-spin icon-large icon-blue"<br/>/&gt;</span></pre><p id="56fd" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是呈现微调器组件的快照测试的简单示例。查看。捕捉输出文件并看到一个清晰的测试名称，您可以很容易地看到我们期望渲染一个大的蓝色微调器组件。</p><p id="e16b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在这种情况下，快照测试的好处是，如果有人将微调器从div更改为span，测试将失败。如果我们没有编写快照测试，我们可能只会断言大小和颜色应用正确。下面是两个快照断言的示例。如果加载是假的，那么我们不应该渲染组件并返回null。</p><p id="d1ec" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"> spinner.spec.js </strong></p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="aec8" class="nf kx iq nv b gy nz oa l ob oc">it('should render a large blue spinner', () =&gt; {<br/>    const props = {<br/>        loading: true,<br/>        size: "large",<br/>        color: "blue"<br/>    };</span><span id="b94f" class="nf kx iq nv b gy od oa l ob oc">const container = render(&lt;Spinner {...props} /&gt;);<br/>    expect(container.firstChild).toMatchSnapshot();<br/>})</span><span id="4a0a" class="nf kx iq nv b gy od oa l ob oc">it('should return null if loading is false', () =&gt; {<br/>    const props = {<br/>        loading: false<br/>    };</span><span id="e151" class="nf kx iq nv b gy od oa l ob oc">const container = render(&lt;Spinner {...props} /&gt;);<br/>    expect(container.firstChild).toMatchSnapshot();<br/>})</span></pre><p id="7d0d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"> spinner.spec.js.snap </strong></p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="505b" class="nf kx iq nv b gy nz oa l ob oc">// Jest Snapshot v1</span><span id="5d5c" class="nf kx iq nv b gy od oa l ob oc">exports[`&lt;Spinner /&gt; should render a large blue spinner 1`] = `<br/>&lt;div<br/>  class="icon icon-spin icon-large icon-blue"<br/>/&gt;;</span><span id="ae93" class="nf kx iq nv b gy od oa l ob oc">exports[`&lt;Spinner /&gt; should return null if loading is false 1`] = `<br/>null;</span></pre><p id="04ee" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">看spinner.spec.js，不清楚测试的是什么。这就是为什么验证spinner.spec.js.snap文件并检查输出如此重要。</p><h1 id="e249" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">更新快照测试</h1><p id="36e8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们第一次创建快照测试时，它会创建一个. snap引用文件，并且每次都针对这个文件运行您的测试。如果我们的组件被更改，我们必须手动更新快照测试。</p><pre class="kg kh ki kj gt nu nv nw nx aw ny bi"><span id="b575" class="nf kx iq nv b gy nz oa l ob oc">jest --updateSnapshot</span></pre><h2 id="f611" class="nf kx iq bd ky ng nh dn lc ni nj dp lg lx nk nl li mb nm nn lk mf no np lm nq bi translated">走向</h2><p id="e8d3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">希望您能从我们的快照测试经验中获得一些要点和建议。当将这种类型的测试引入到您自己的项目中时，请记住:</p><ul class=""><li id="3712" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">创建并遵循您自己的关于何时编写快照测试的规则</li><li id="7e4d" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">验证组件是否在输出文件中正确呈现</li><li id="74c9" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">在代码审查中要严格</li></ul><p id="d42d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们的团队使用<a class="ae kv" href="https://medium.com/@chrisgirard/testing-components-with-jest-and-react-testing-library-d36f5262cde2" rel="noopener"> React测试库</a>，我们在测试中不使用浅层渲染。当编写快照测试时，如果我们的父组件有许多子组件，那么这些子组件也会被渲染。一方面，我们创建了一个测试来快速验证整个组件是否被渲染，另一方面，由我们来检查组件是否被正确渲染。</p><p id="a9eb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过这个过程，我们的团队在审查这些类型的测试时变得更加严格。我们确切地看看发生了什么变化及其原因。我们倾向于编写快照测试，作为共享React组件的<em class="ne">总括</em>。</p><p id="1195" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">拍照快乐！📸</p></div></div>    
</body>
</html>