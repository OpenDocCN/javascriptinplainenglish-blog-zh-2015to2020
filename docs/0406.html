<html>
<head>
<title>When 80 percent code coverage is not enough.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">当80%的代码覆盖率不够时。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/when-80-percent-code-coverage-is-not-enough-843a92260bdc?source=collection_archive---------4-----------------------#2019-10-07">https://javascript.plainenglish.io/when-80-percent-code-coverage-is-not-enough-843a92260bdc?source=collection_archive---------4-----------------------#2019-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cbfe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何为你的web应用程序编写一个以上的单元(声纳)测试？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a6d2cf6e140eaf0ac3dafd178288178c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZISoGBZKRw9tR_P8"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@dtravisphd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David Travis</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="38d3" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">多年来，字体端开发人员一直试图遵循一些最佳实践，用传统的服务器实践来测试他们的代码。这些实践中的大多数都需要编写一个单元测试，然后确保它们覆盖了大部分代码。然后，团队会将此发送给静态检查器，以查看他们是否有覆盖率，并根据一些任意的标准检查代码。声纳就是一个很好的例子。为了提高性能，常见的做法是添加一些URL端点，并让系统访问这些端点一段时间，然后查看响应时间。这种类型的测试对于API来说是非常好的，但是它并不是网站的全部。</p><p id="d699" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">首先，对于一个网站来说，80%的代码覆盖率是一个非常随意的数字。例如，假设我正在为一个输入字段创建一个web组件，并且我有一个基类。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="dc9a" class="me mf iq ma b gy mg mh l mi mj">import {BaseInput} from '../base-input.js'<br/>export class NewInput extends BaseInput {<br/>  constructor(){<br/>    super();<br/>    try {<br/>      if(this.x === 1) {<br/>        console.log('1');<br/>      }<br/>      this.innerHTML = '&lt;h1&gt;Hello Word&lt;/h1&gt;';</span><span id="9281" class="me mf iq ma b gy mk mh l mi mj">} catch (error) {<br/>      console.log(error);<br/>    }<br/>  }<br/>}<br/>if(!customElement.get('new-input')){<br/>  customElement.define('new-input',NewInput);<br/>}</span></pre><p id="113f" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在这段代码中，有一个catch语句很难用大多数单元测试框架来测试。如果您在您的测试框架上使用了一个预处理器构建系统，那么您将从BaseInput中获得您必须覆盖的所有代码。最后，你有if语句，你可以把它放在一行中，但是这可能会弄乱你的覆盖行，所以你不要这样做。最重要的是，你在这里测试了什么。测试不仅仅是编写一个单元测试来获得代码覆盖率的分数。有可访问性，可用性，它看起来怎么样，自从上次签入以来视觉上做的事情。这些场景通常不是仅仅通过单元测试就能解决的，而且在UAT测试中也不会被发现。这里还有两种方法可以让你的前端测试框架发挥更大的作用。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="d0ff" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们以一个简单的按钮为例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="c38b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">按钮是红色的，在标签之间有文本。当你悬停在按钮上时，它会变绿并变大。仅仅通过将它添加到测试中，您就可以获得100%的覆盖率。</p><p id="459a" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我要添加的第一种测试是感知差异测试。在这里，我们尝试获取网页的快照，并将其与之前的快照进行比较。一个例子是在Chrome中打开DevTools并给你的页面拍一张快照。对页面进行一些更改后，拍摄第二个快照图像。现在，如果你对两幅图像进行逐个像素的比较，这将是一个感知测试。</p><p id="732f" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">有许多库可以做这种类型的测试，但是这个例子中我将使用differencify。Differencify建立在木偶师的基础上。我的例子是，我将使用Jasmine作为我的测试跑步者。首先让我们安装differencify。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="a335" class="me mf iq ma b gy mg mh l mi mj">npm install --save-dev differencify</span></pre><p id="997d" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">创建您的Jasmine测试</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="cde8" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这个测试中发生了什么？Differencify对象是木偶对象的扩展。您在木偶对象上拥有的所有功能都将在差异对象上拥有。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="cf23" class="me mf iq ma b gy mg mh l mi mj">const Differencify = require('differencify');</span><span id="3dcc" class="me mf iq ma b gy mk mh l mi mj">const differencify = new Differencify({});</span></pre><p id="cbe5" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">然后我们初始化这个对象并给它一个名字。然后，我们需要将按钮添加到页面中</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="69d8" class="me mf iq ma b gy mg mh l mi mj">browser = differencify.init({<br/>  testName: 'Test hover on button will turn it green',<br/>  chain: false,<br/>  headless: true,<br/>});<br/>jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000;<br/>await browser.launch();<br/>page = await browser.newPage();<br/>await page.setBypassCSP(true);<br/>await page.setViewport({ width: 1600, height: 1200 });<br/>await page.addScriptTag({ path: 'SimpleButton.js' });<br/>const bodyhandle = await page.$('body');<br/>await page.evaluate(element =&gt; {<br/>  element.innerHTML = `&lt;simple-button &gt;Test Button&lt;/simple-button&gt;`;<br/>}, bodyhandle);</span></pre><p id="6c66" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">神奇的是，我们给页面上的按钮拍了一张快照。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="0b31" class="me mf iq ma b gy mg mh l mi mj">const result1 = await browser.toMatchSnapshot(image);<br/>expect(result1).toBeTruthy();</span></pre><p id="7717" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这将创建一个名为differencify _ reports的目录。此目录是存储快照映像的位置。如果有先前的图像，它会将这个图像与先前的图像进行比较，并返回图像是否相同。</p><p id="71c8" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">最后一步是将鼠标悬停在按钮上，并在鼠标悬停在按钮上时拍摄按钮的快照。</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="de21" class="me mf iq ma b gy mg mh l mi mj">const button = await page.evaluateHandle(() =&gt; {<br/>  const btn = document<br/>    .querySelector('simple-button')<br/>    .shadowRoot.querySelector('button');<br/>  return btn;</span><span id="59e0" class="me mf iq ma b gy mk mh l mi mj">});<br/>await button.hover();<br/>await page.waitFor(2000);<br/>const image = await page.screenshot({ path: 'hover.png' });<br/>const result2 = await browser.toMatchSnapshot(image);<br/>expect(result2).toBeTruthy();</span></pre><p id="82bb" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">您现在已经对您的元素进行了一些视觉测试。对元素的任何更改都将显示在differencify _ report目录中。这是检查元素中微小变化的一个很好的方法。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="872b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我想对我的元素应用的下一组测试是可访问性。为此，我将使用axe-core库。这个库和axe coconut插件或者lighthouse用的一样。要安装这个添加斧头木偶师</p><pre class="kg kh ki kj gt lz ma mb mc aw md bi"><span id="22e0" class="me mf iq ma b gy mg mh l mi mj">npm install --save-dev axe-puppeteer</span></pre><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="8c59" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">你可能已经注意到它正在使用木偶师。因此，我们可以使用differencify，例如，我们的木偶版本。</p><p id="6ef4" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">这个测试中唯一显著的不同是我们添加了AxePuppeteer行来分析我们的页面，并且只在报告中包含我们的按钮。报告将返回一个包含所有分析结果的大型JSON。在我的例子中，我创建了一个函数来遍历报告，只查找失败的问题。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="7d0b" class="pw-post-body-paragraph ld le iq lf b lg lh jr li lj lk ju ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">通过这两种测试实践，您将能够更全面地测试您的web元素。另一种测试需求是性能，但是我将把它留给另一个博客来讨论。</p></div></div>    
</body>
</html>