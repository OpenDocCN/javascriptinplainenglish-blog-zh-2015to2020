<html>
<head>
<title>Preview: ReactJS Concurrent Mode</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预览:ReactJS并发模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/preview-reactjs-concurrent-mode-f6eb81fa6216?source=collection_archive---------9-----------------------#2020-03-13">https://javascript.plainenglish.io/preview-reactjs-concurrent-mode-f6eb81fa6216?source=collection_archive---------9-----------------------#2020-03-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d911" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">介绍新的渲染引擎</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/94badc6b24fe56ae58d6e0116a140b42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U6t3WkWLS8iIWkboM_GRig.png"/></div></div></figure><p id="9002" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React引擎正在发展，加入了一些高级渲染功能。继续阅读，了解新的<em class="ln">并发渲染模式</em>的概况。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="1d3c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这太令人兴奋了。</p><blockquote class="lv lw lx"><p id="5d33" class="kr ks ln kt b ku kv jr kw kx ky ju kz ly lb lc ld lz lf lg lh ma lj lk ll lm ij bi translated">“……组件中一定量的工作总是会导致断断续续……<strong class="kt ir">并发模式通过使渲染可中断来解决这一基本限制。”</strong></p></blockquote><p id="1565" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是来自<a class="ae mb" href="https://reactjs.org/docs/concurrent-mode-intro.html" rel="noopener ugc nofollow" target="_blank">的React文档</a>，它很好地深入描述了即将到来的C <em class="ln"> oncurrent Mode </em>。现在可以使用了，作为React 16.6+中的一个实验特性。</p><p id="2604" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我在这里要做的是给出一个简明的概述，以防你没有足够的带宽浏览整篇文档。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="7f23" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi mc translated">这项技术背后的基本思想是，渲染引擎将接受来自应用程序的暗示UI更新的更新，并首先将它们应用到内存中。</p><blockquote class="ml"><p id="38ac" class="mm mn iq bd mo mp mq mr ms mt mu lm dk translated">这项技术背后的基本思想是，渲染引擎将接受来自应用程序的暗示UI更新的更新，并首先将它们应用到内存中。</p></blockquote><p id="ce62" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">目的是让绘制UI更流畅。</p><p id="afb2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">动态更新首先应用于虚拟dom，然后写入屏幕。</p><p id="cd85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与其依赖开发人员使用去抖动或节流(无论如何，它们的有效性有限)来避免不稳定的UI更新，<em class="ln">渲染引擎将承担起在数据更改和屏幕写入之间进行调解的任务。</em></p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="3530" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我认为React团队在这个特性上为开发者做了更多的工作。他们对如何最大化用户体验进行了大量的思考和研究，然后将其纳入框架(… <em class="ln">库)</em>本身。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><p id="91d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi mc translated">用于管理这些功能的API仍在不断变化，您必须像这样明确地安装它:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="5326" class="nf ng iq nb b gy nh ni l nj nk">npm install react@experimental react-dom@experimental</span></pre><p id="fe7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">并发模式是对react工作方式的全面改变，要求根级节点通过并发引擎传递。这是通过在应用程序根上调用createRoot来完成的，而不仅仅是“reactDOM.render()”:</p><pre class="kg kh ki kj gt na nb nc nd aw ne bi"><span id="651f" class="nf ng iq nb b gy nh ni l nj nk">ReactDOM.createRoot(<br/>  document.getElementById('root')<br/>).render(&lt;App /&gt;);</span></pre><p id="f893" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(createRoot只有在安装了实验包的情况下才可用)</p><p id="c992" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为这是一个更大的根本性改变，现有的代码库可能与它不兼容。尤其是现在前置UNSAFE的生命周期方法是不兼容的。</p><p id="20a0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为这个事实，React在我们今天使用的老式渲染引擎和并发模式之间引入了一个中间步骤。这被称为“阻塞模式”,它更加向后兼容，但是具有较少的并发特性。</p><p id="9f00" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从长远来看，并发模式将成为默认模式。</p><p id="329f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在中期，React将支持以下三种模式(这直接来自<a class="ae mb" href="https://reactjs.org/docs/concurrent-mode-adoption.html" rel="noopener ugc nofollow" target="_blank">这份文件</a>):</p><ul class=""><li id="2ee3" class="nl nm iq kt b ku kv kx ky la nn le no li np lm nq nr ns nt bi translated"><strong class="kt ir">遗留模式:</strong> <code class="fe nu nv nw nb b">ReactDOM.render(&lt;App /&gt;, rootNode)</code>。这就是React应用程序现在使用的。在可预见的未来，没有计划移除传统模式——但它将无法支持这些新功能。</li><li id="ec6e" class="nl nm iq kt b ku nx kx ny la nz le oa li ob lm nq nr ns nt bi translated"><strong class="kt ir">封锁模式:</strong> <code class="fe nu nv nw nb b">ReactDOM.createBlockingRoot(rootNode).render(&lt;App /&gt;)</code>。目前还在试验阶段。这是希望获得并发模式特性子集的应用程序的第一步迁移。</li><li id="2714" class="nl nm iq kt b ku nx kx ny la nz le oa li ob lm nq nr ns nt bi translated"><strong class="kt ir">并发模式:</strong> <code class="fe nu nv nw nb b">ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</code>。目前还在试验阶段。将来，当它稳定下来后，我们打算让它成为默认的反应模式。该模式启用<em class="ln">所有</em>新功能。</li></ul></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><blockquote class="ml"><p id="29d5" class="mm mn iq bd mo mp mq mr ms mt mu lm dk translated"><a class="ae mb" href="http://www.darkhorse.tech" rel="noopener ugc nofollow" target="_blank"> www.darkhorse.tech </a></p></blockquote></div></div>    
</body>
</html>