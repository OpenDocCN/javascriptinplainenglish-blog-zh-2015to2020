<html>
<head>
<title>Is Object Oriented Programming Dead?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象编程死了吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/oop-considered-harmful-5017a17ebdff?source=collection_archive---------3-----------------------#2019-10-31">https://javascript.plainenglish.io/oop-considered-harmful-5017a17ebdff?source=collection_archive---------3-----------------------#2019-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a9de" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">重新考虑面向对象编程</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d7414c6c5a84bdaf0387bf468ebdeaa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Mzh5MYySmJIpq23r_Vo-aA.png"/></div></div></figure><h2 id="a6d1" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">以下是有史以来最受欢迎的媒体文章之一:</h2><div class="ln lo gp gr lp lq"><a href="https://medium.com/@cscalfani/goodbye-object-oriented-programming-a59cda4c0e53" rel="noopener follow" target="_blank"><div class="lr ab fo"><div class="ls ab lt cl cj lu"><h2 class="bd ir gy z fp lv fr fs lw fu fw ip bi translated">再见，面向对象编程</h2><div class="lx l"><h3 class="bd b gy z fp lv fr fs lw fu fw dk translated">我已经用面向对象语言编程几十年了。我用的第一个OO语言是C++然后是Smalltalk…</h3></div><div class="ly l"><p class="bd b dl z fp lv fr fs lw fu fw dk translated">medium.com</p></div></div><div class="lz l"><div class="ma l mb mc md lz me kp lq"/></div></div></a></div><p id="9a9c" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">这篇文章的前提是，面向对象编程承诺良好设计的代码，交付一塌糊涂，应该被<a class="ae my" href="https://medium.com/swlh/functional-programming-vs-object-oriented-programming-48eee6cf6830" rel="noopener">函数式编程</a>所取代。</p><p id="9274" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">这种反应将从两个方面进行。</p><p id="9de3" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">首先，我们来看看文章中的实际论点。</p><p id="5bc6" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">其次，我们将在现实世界中寻找帮助，看看OOP是否真的应该以p开头(这是一个便便笑话)。</p><h1 id="0f7d" class="mz ks iq bd kt na nb nc kw nd ne nf kz jw ng jx ld jz nh ka lh kc ni kd ll nj bi translated">香蕉猴子丛林问题</h1><p id="6f78" class="pw-post-body-paragraph mf mg iq mh b mi nk jr mk ml nl ju mn la nm mp mq le nn ms mt li no mv mw mx ij bi translated">这是作者对OOP的第一次批判。以下是他发现这个多彩名字的引文:</p><blockquote class="np nq nr"><p id="d3df" class="mf mg ns mh b mi mj jr mk ml mm ju mn nt mo mp mq nu mr ms mt nv mu mv mw mx ij bi translated"><em class="iq">面向对象语言的问题是，它们随身携带着所有这些隐含的环境。你想要一个香蕉，但你得到的是一只大猩猩拿着香蕉和整个丛林。</em></p></blockquote><p id="daca" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated"><em class="ns"> ( </em> <strong class="mh ir"> <em class="ns">乔·阿姆斯特朗</em> </strong>，二郎的创造者)</p><p id="8d3d" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">这方面没有太多细节。没有代码。但批评似乎是，如果你想从一个类继承，你实际上必须从该类的整个层次结构中继承。</p><p id="620f" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">现在，我认为关于设计使用对象的应用程序有一个有效的<em class="ns">顾虑</em>，因为你可以在运行时创建交互的对象图<em class="ns">变得很霸道。也就是说，物体可以暗示一个环境的宇宙。</em></p><p id="8d1b" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">我认为乔·阿姆斯特朗的话指的就是这个。注意，他说的是<em class="ns">“内隐环境”。我们一会儿会好好看看这是什么意思。</em></p><p id="3555" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">然而，那根本不是媒体文章的作者所指的。相反，他抱怨在设计类的结构时，由于隐含的与层次结构的耦合，继承对于引用类来说变得很麻烦。</p><p id="1621" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">现在，对设计OOP代码和层次结构有一个真正的批评:在层次结构的祖先之间真的有隐含的耦合。</p><p id="a98f" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">但是问题是在整个代码的变化中，<strong class="mh ir"> <em class="ns">而不是</em> </strong>在消耗对象/类的客户端代码/类中。</p><p id="b7c9" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">后一点是作者在《面向对象》中提出的批评:</p><blockquote class="np nq nr"><p id="55ca" class="mf mg ns mh b mi mj jr mk ml mm ju mn nt mo mp mq nu mr ms mt nv mu mv mw mx ij bi translated">现在不会编译了。为什么？？哦，我明白了……<strong class="mh ir"><em class="iq">这个</em> </strong>物体包含<strong class="mh ir"> <em class="iq">这个</em> </strong>物体。所以我也需要那个。没问题。</p></blockquote><p id="0c5a" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">嗯，底线是这不是对OOP的有效批评。这是对糟糕的OOP API设计的有效批评。</p><p id="d38a" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">所以，为了让大家明白这一点:不要创建将自己暴露给客户端代码的交互类层次结构。将它们打包，以便暴露一个干净的接口，并尽可能隐藏更多的内容。</p><p id="3d24" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">完成了。</p><p id="5117" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">第一个批评暗示了有效的<em class="ns">关注</em>，但并不是对OOP的真正攻击。</p><h1 id="cb3f" class="mz ks iq bd kt na nb nc kw nd ne nf kz jw ng jx ld jz nh ka lh kc ni kd ll nj bi translated">钻石问题</h1><p id="52ca" class="pw-post-body-paragraph mf mg iq mh b mi nk jr mk ml nl ju mn la nm mp mq le nn ms mt li no mv mw mx ij bi translated">第二个批评是“钻石问题”</p><p id="c72f" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">这个关于OOP语言设计的事实长期以来被冠以“<a class="ae my" href="https://en.wikipedia.org/wiki/Multiple_inheritance" rel="noopener ugc nofollow" target="_blank">多重继承</a>”的名称。这实际上意味着:很难创建一个从两个具体类派生出来的类。</p><p id="f9b9" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">为什么？</p><p id="ee67" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">因为你有冲突的公共成员。</p><p id="69b5" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">这根本不是对OOP的批评。这是对逻辑本身的批评。</p><p id="d73e" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">然而，文章中的抱怨是，有时这正是我们所需要的！(但是，但是……如果我必须对此建模呢？我要我的重用！)</p><p id="ce71" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">下面是作者提到的一个类似的代码情况:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="f15f" class="kr ks iq nx b gy ob oc l od oe">Class WheeledVehicle {<br/>}Class Automobile inherits from WheeledVehicle{<br/>  function roll() {<br/>  }<br/>}Class Scooter inherits from WheeledVehicle {<br/>  function roll() {<br/>  }<br/>}Class PoweredScooter inherits from Automobile, Scooter{<br/>}</span></pre><p id="96d9" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">可以看到多重继承问题:<code class="fe of og oh nx b">PoweredScooter</code>要继承什么<code class="fe of og oh nx b">roll()</code>方法？</p><p id="c129" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">作者提供了一个“包含和委托”的解决方案。本质上，PoweredScooter类“拥有”汽车和小型摩托车，而不是“是”汽车和小型摩托车。</p><p id="7f7a" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">这是一个潜在的解决方案。作者没有说明为什么它是不可接受的。这实际上是OOP设计中的一个常见主题:<a class="ae my" href="https://en.wikipedia.org/wiki/Composition_over_inheritance" rel="noopener ugc nofollow" target="_blank">更喜欢组合而不是继承</a>。(这个想法是最小化第一部分中提到的层次结构的强耦合的一种方法。)</p><p id="2da9" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">还有其他解决方案，比如用正在讨论的方法创建一个具体的基类。但是我对这个批评最大的不满是:它抱怨他想用对象来建模他的问题，但是它不够灵活。</p><p id="8cad" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">因此:扔掉对象建模？即使你想用它？</p><p id="5fef" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">这就像说我的车只能在路上行驶，不能割草，所以我要扔掉我的车。也许骑着我的割草机到处跑。</p><p id="fbd2" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">如果汽车带来优势，那就利用它们。不要因为它有局限性就湮灭整个事物。</p><p id="c419" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">嘘。</p><h1 id="f1b5" class="mz ks iq bd kt na nb nc kw nd ne nf kz jw ng jx ld jz nh ka lh kc ni kd ll nj bi translated">脆弱的基础类问题</h1><p id="da7c" class="pw-post-body-paragraph mf mg iq mh b mi nk jr mk ml nl ju mn la nm mp mq le nn ms mt li no mv mw mx ij bi translated">接下来的热门话题是文章中所谓的“脆弱的基础阶级问题”。</p><p id="758d" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">TL；DR总结是这样的:如果一个基类以一种破坏性的方式改变，它将破坏你的后代类。</p><p id="0101" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">你猜怎么着:如果你所依赖的代码是一个突破性的改变，那么它将会破坏你的代码。</p><p id="d4ba" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">这就是为什么语义版本化是一个好主意。但这与OOP没有任何关系。</p><p id="ae0c" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">在构建目标代码时，这是同样的<em class="ns">关注点</em>:子类和父类之间有很强的耦合。但这就是依赖API的本质。</p><p id="75c1" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">我想我们可以很快取消这个。</p><p id="467a" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">诚然，基类是一个潜在的破坏依赖点，但这是编写代码的现实，应该通过良好的设计和谨慎的版本控制过程来处理。</p><p id="f833" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">不抛弃语言特征。</p><p id="0cf4" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">差不多完成了，但是让我们快速浏览一下…</p><h1 id="1a08" class="mz ks iq bd kt na nb nc kw nd ne nf kz jw ng jx ld jz nh ka lh kc ni kd ll nj bi translated">…封装</h1><p id="20a0" class="pw-post-body-paragraph mf mg iq mh b mi nk jr mk ml nl ju mn la nm mp mq le nn ms mt li no mv mw mx ij bi translated">看这里。封装是代码组织的一个基本特征，包括函数式编程。</p><p id="52f1" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">在面向对象的程序中，你可能对它的实现方式有问题，但是攻击封装本身是…poco loco。</p><h1 id="448d" class="mz ks iq bd kt na nb nc kw nd ne nf kz jw ng jx ld jz nh ka lh kc ni kd ll nj bi translated">让我们看看现实世界</h1><p id="c2bc" class="pw-post-body-paragraph mf mg iq mh b mi nk jr mk ml nl ju mn la nm mp mq le nn ms mt li no mv mw mx ij bi translated">现在，文章中还有一些条目，但它们都归结为同一个批评:对象层次结构意味着强耦合和(我会自己加上)不完整的信息隐藏。</p><p id="bd5d" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">我认为我们可以接受这些是好的设计应该避免的问题。</p><p id="450e" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">但是可以肯定的是，在现实世界中，存在着超级聪明、专注和资金充足的函数式编程类型，OOP已经被完全取代了。</p><p id="07c0" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">对吗？</p><h1 id="4609" class="mz ks iq bd kt na nb nc kw nd ne nf kz jw ng jx ld jz nh ka lh kc ni kd ll nj bi translated">反应</h1><p id="910a" class="pw-post-body-paragraph mf mg iq mh b mi nk jr mk ml nl ju mn la nm mp mq le nn ms mt li no mv mw mx ij bi translated">看看这个。<a class="ae my" href="https://www.youtube.com/watch?v=2gm29WZpBJc" rel="noopener ugc nofollow" target="_blank">如果可以</a>。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="20f5" class="kr ks iq nx b gy ob oc l od oe">class Parent extends React.Component {<br/> render() {<br/>   return &lt;div class=”parent”&gt;Parent<br/>     &lt;Child&gt;&lt;/Child&gt;<br/>     &lt;/div&gt;;<br/>   }<br/> }class Child extends React.Component {<br/>   render() {<br/>   return &lt;div class=”child”&gt;child&lt;/div&gt;;<br/> }<br/>}</span></pre><p id="c1e4" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">这是我对React的介绍(你应该<a class="ae my" href="https://medium.com/@matthewcarltyson/react-in-7-minutes-a4fe81eb13ef" rel="noopener">看看</a>)。</p><p id="6071" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">上面明显是从<code class="fe of og oh nx b">React.Component</code>往下的React组件。但这一定意味着开发人员只是被灌输了OOP的僵尸白痴…对吗？</p><p id="87f4" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">React使用函数式编程。有意义的地方。</p><p id="fa4c" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">然后在有意义的地方使用对象。</p><p id="d094" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">这是一个令人信服的想法。我们应该考虑一下:使用最适合手头任务的工具，<em class="ns">而不是，</em>使用看起来最酷或最流行的工具。或者甚至:用我们最了解的，因为那是我们用得最多的。</p><p id="9377" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">我是说，反应是我最喜欢脸书的一点。我认为这是真正天才的作品。我觉得，在与他们的代码互动之后，他们真的知道他们在做什么，而且真的关心框架(ok，library)如何为开发人员处理。</p><p id="2b97" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">事实上，我真的很喜欢在这里使用对象。</p><p id="cedd" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">这使得<em class="ns">很容易</em>插入他们的API，并创建一个封装的代码块，具有有用的可变范围。事实上，组件内部状态的概念与对象封装非常相似。</p><p id="3e3b" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">你<em class="ns">可以</em>定义纯粹的功能组件。</p><p id="59c6" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">你也可以用螺丝刀钉钉子。</p><p id="ab45" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">本文的信息:<strong class="mh ir">根据任务</strong>的表现，选择最适合手头工作的工具。</p><h1 id="72f7" class="mz ks iq bd kt na nb nc kw nd ne nf kz jw ng jx ld jz nh ka lh kc ni kd ll nj bi translated">有角的</h1><p id="0d53" class="pw-post-body-paragraph mf mg iq mh b mi nk jr mk ml nl ju mn la nm mp mq le nn ms mt li no mv mw mx ij bi translated">Angular 2+实际上是强FP(贯穿始终的RxJs)和强OOP (IoC容器、基于类的组件和模块、基于类的装饰器)的巧妙结合。</p><p id="e8ba" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">创建模块:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="d0dd" class="kr ks iq nx b gy ob oc l od oe">class MyModule {} // Declare a module containing Angular assets</span></pre><p id="e38a" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">创建组件:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="8923" class="kr ks iq nx b gy ob oc l od oe">@Component({…})<br/>class MyComponent() {}</span></pre><p id="478e" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">创建指令:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="7c61" class="kr ks iq nx b gy ob oc l od oe"><strong class="nx ir">@</strong><a class="ae my" href="https://angular.io/api/core/Directive" rel="noopener ugc nofollow" target="_blank"><strong class="nx ir">Directive</strong></a><strong class="nx ir">({…})</strong><br/>class MyDirective() {}</span></pre><p id="6d09" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">诸如此类。</p><h1 id="fae0" class="mz ks iq bd kt na nb nc kw nd ne nf kz jw ng jx ld jz nh ka lh kc ni kd ll nj bi translated">某视频剪辑软件</h1><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="667b" class="kr ks iq nx b gy ob oc l od oe">@Component<br/>export default MyBtn extends Vue {<br/>  count = 0;<br/><br/>  handleClick() {<br/>    this.count++;<br/>    console.log('clicked', this.count);<br/>  }<br/>}</span></pre><p id="a0b3" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">并且:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="b649" class="kr ks iq nx b gy ob oc l od oe">Vue.component('my-btn', {<br/>  data() {<br/>    return {<br/>      text: 'Click me',<br/>    };<br/>  },<br/>  methods: {<br/>    handleClick() {<br/>      console.log('clicked');<br/>    },<br/>  },<br/>  render() {<br/>    return (<br/>      &lt;button class="btn-primary" @click.prevent="handleClick"&gt;<br/>        {this.$slots.default}(clicked - {{count}})<br/>      &lt;/button&gt;<br/>    );<br/>  },<br/>});</span></pre><h1 id="b500" class="mz ks iq bd kt na nb nc kw nd ne nf kz jw ng jx ld jz nh ka lh kc ni kd ll nj bi translated">表达</h1><p id="42b0" class="pw-post-body-paragraph mf mg iq mh b mi nk jr mk ml nl ju mn la nm mp mq le nn ms mt li no mv mw mx ij bi translated">糟糕，也许这只是一个前端的事情，在后端，在节点。JS，现实世界的JS重量级人物都逃课了。</p><p id="2b08" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">我们来看看ExpressJS。</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="517c" class="kr ks iq nx b gy ob oc l od oe">class Routes {<br/>    constructor(){<br/>        this.foo = 10<br/>    }<br/><br/>    Root = (req, res, next) =&gt; {<br/>        res.json({foo: this.foo});<br/>    }<br/>}<br/><br/>var routes = new Routes();<br/>app.get('/', routes.Root);</span></pre><p id="f4d5" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">好了，以上其实是ES7语法，用对象在Express中映射路线，由此<a class="ae my" href="https://stackoverflow.com/questions/33798933/nodejs-express-routes-as-es6-classes" rel="noopener ugc nofollow" target="_blank"> SO提问</a>。那只是为了好玩。</p><p id="9c60" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">我不一定会那样做。实际上，我认为函数式风格非常适合处理RESTful端点。</p><p id="7e79" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">但是代码中有一个更深层次的观点。它是快速请求对象。</p><p id="fa10" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">什么？</p><p id="020a" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">快速请求对象。是的，请求被建模为一个对象。是的，他们从<a class="ae my" href="https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/ServletRequest.html" rel="noopener ugc nofollow" target="_blank"> Java Servlets </a>那里得到了这个想法。是的，因为这是个好主意。是的，不同种类的请求可以被建模为基本请求对象的派生。</p><p id="a32c" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">但是不管怎样，我的意思是，Express不会在它的<em class="ns">源代码中使用OOP。</em></p><p id="ccc3" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">比如这里的<a class="ae my" href="https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/router/route.js" rel="noopener ugc nofollow" target="_blank"/>:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="9c6e" class="kr ks iq nx b gy ob oc l od oe">Route.prototype._handles_method = function _handles_method(method) {<br/>  if (this.methods._all) { <br/>    return true; <br/>  } <br/>  var name = method.toLowerCase(); <br/>  if (name === ‘head’ &amp;&amp; !this.methods[‘head’]) { <br/>    name = ‘get’; <br/>  } <br/>  return Boolean(this.methods[name]);};</span></pre><p id="2c13" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">或者这里的<a class="ae my" href="https://github.com/expressjs/express/blob/3ed5090ca91f6a387e66370d57ead94d886275e1/lib/middleware/init.js" rel="noopener ugc nofollow" target="_blank"/>。</p><h1 id="b31f" class="mz ks iq bd kt na nb nc kw nd ne nf kz jw ng jx ld jz nh ka lh kc ni kd ll nj bi translated">NodeJS</h1><p id="c354" class="pw-post-body-paragraph mf mg iq mh b mi nk jr mk ml nl ju mn la nm mp mq le nn ms mt li no mv mw mx ij bi translated">当然，NodeJS本身会避免使用有害的对象编程。我的意思是，该死，它的整个前提是一个事件循环。</p><p id="bb1d" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">像这里的<a class="ae my" href="https://github.com/nodejs/node/blob/739f113ba63367a93e1567032d85573a079b97b5/lib/internal/child_process.js" rel="noopener ugc nofollow" target="_blank"/>、这里的<a class="ae my" href="https://github.com/nodejs/node/blob/8b4af64f50c5e41ce0155716f294c24ccdecad03/deps/v8/test/mjsunit/es6/spread-call-super-property.js" rel="noopener ugc nofollow" target="_blank"/>和这里的<a class="ae my" href="https://github.com/nodejs/node/blob/d247a8e1dc398b76558b7eb8cceace911047e912/lib/_http_client.js" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="d489" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">而<a class="ae my" href="https://github.com/nodejs/node/blob/0af62aae07ccbb3783030367ffe405f45687abb3/src/handle_wrap.h" rel="noopener ugc nofollow" target="_blank">在这里</a>，用这个整洁的花絮评论道:</p><pre class="kg kh ki kj gt nw nx ny nz aw oa bi"><span id="9e78" class="kr ks iq nx b gy ob oc l od oe">// — uv_ref, uv_unref counts are managed at this layer to avoid needless<br/>// js/c++ boundary crossing. At the javascript layer that should all be<br/>// taken care of.</span></pre><p id="307a" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">我无法想象他们究竟为什么会选择使用C++(即带对象的C)。</p><h1 id="fbb0" class="mz ks iq bd kt na nb nc kw nd ne nf kz jw ng jx ld jz nh ka lh kc ni kd ll nj bi translated">所以，总而言之</h1><p id="ed72" class="pw-post-body-paragraph mf mg iq mh b mi nk jr mk ml nl ju mn la nm mp mq le nn ms mt li no mv mw mx ij bi translated">朋友们，我们正在看一场真正的范式战争。这就是:</p><blockquote class="oi"><p id="7e32" class="oj ok iq bd ol om on oo op oq or mx dk translated">根据我们对某样东西的感觉和它在给定目的下的表现来做出技术选择</p></blockquote><p id="6747" class="pw-post-body-paragraph mf mg iq mh b mi os jr mk ml ot ju mn la ou mp mq le ov ms mt li ow mv mw mx ij bi translated">卡波。</p><p id="38a0" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">很多时候，当我们应该使用最简单的解决方案时，我们试图应用太复杂或太复杂的解决方案，并与对象对称性纠缠在一起。(顺便说一句，这个问题在设计模式中更严重，为可插拔架构设计的模式被应用到小问题中)。</p><p id="3502" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">有时候我们不喜欢OOP，因为它不能按照我们想要的方式处理一个项目(或多个项目)，或者我们从来没有真正理解它，或者其他什么。</p><p id="c1df" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">FP也一样。</p><p id="32cb" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">我们必须把这些都放在一边。看穿炒作进入目的。没有什么是最好的。正如鲍勃·马利所说:</p><blockquote class="oi"><p id="6f4c" class="oj ok iq bd ol om on oo op oq or mx dk translated">生活中的每件事都有它的目的，</p><p id="c8c8" class="oj ok iq bd ol om on oo op oq or mx dk translated">找到它的原因，</p><p id="4e18" class="oj ok iq bd ol om on oo op oq or mx dk translated">在每个季节。</p></blockquote><p id="14e8" class="pw-post-body-paragraph mf mg iq mh b mi os jr mk ml ot ju mn la ou mp mq le ov ms mt li ow mv mw mx ij bi translated">好吧，这是因为我喜欢鲍勃·马利。但是很合适。</p><p id="8531" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">我们不想屈服于怨恨<em class="ns">或</em>群体思维。</p><p id="0936" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">不要因为有人告诉你就决定去做OOP。但是，不要因为有人告诉你而不去做。</p><p id="655d" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">同样，这篇文章中的信息:<strong class="mh ir">根据任务的表现为手头的工作选择最好的工具</strong>。</p></div><div class="ab cl ox oy hu oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="ij ik il im in"><p id="1794" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">我将留给你们最后一个，令人欢呼的，巨大的，高耸的OOP的例子，它只是做它该做的事情，让事情变得震撼。</p><p id="160d" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">在这里。</p><p id="1a81" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">不在JS里，抱歉。</p><p id="ff79" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated"><a class="ae my" href="https://www.javaworld.com/article/3444936/what-is-spring-component-based-development-for-java.html" rel="noopener ugc nofollow" target="_blank">弹簧框架</a></p></div><div class="ab cl ox oy hu oz" role="separator"><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc pd"/><span class="pa bw bk pb pc"/></div><div class="ij ik il im in"><p id="1b1a" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">马特·泰森是<a class="ae my" href="http://www.darkhorse.tech/" rel="noopener ugc nofollow" target="_blank">黑马集团</a>的首席技术官</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/ad6655f7332c8a0e3c1f1190a5ec7574.png" data-original-src="https://miro.medium.com/v2/resize:fit:414/format:webp/0*cwJ6kiZvJe9N87ZC.png"/></div><figcaption class="pf pg gj gh gi ph pi bd b be z dk">Dark Horse Group, Inc.</figcaption></figure><p id="d969" class="pw-post-body-paragraph mf mg iq mh b mi mj jr mk ml mm ju mn la mo mp mq le mr ms mt li mu mv mw mx ij bi translated">有关服务的信息:dev@darkhorse.tech</p></div></div>    
</body>
</html>