<html>
<head>
<title>Create a Passwordless Authentication Server</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建无密码认证服务器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-passwordless-authentication-server-dac438182374?source=collection_archive---------6-----------------------#2020-09-21">https://javascript.plainenglish.io/create-a-passwordless-authentication-server-dac438182374?source=collection_archive---------6-----------------------#2020-09-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="88de" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用Node.js和Express为您的应用程序创建一个简单的登录系统</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a1aead4040e150b08b2bfaacbffd5b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ll8QU79ptqCy0tmeqtTBBw.jpeg"/></div></div></figure><p id="e394" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将使用Node.js和Express创建一个Express REST API服务器。我们不会创建和管理数据库来验证用户凭证，但是我们会在JavaScript代码中模拟这种行为。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h2 id="882a" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">我们开始吧。</h2><p id="6f40" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">我们将从安装所有需要的包开始。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="e3dc" class="lr ls in mq b gy mu mv l mw mx">&gt;&gt; npm init -y<br/>&gt;&gt; npm install express body-parser cors jsonwebtoken nodemailer</span></pre><p id="09dd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">注:<br/> </strong> 1。<strong class="kq io">快递</strong> —为我们的服务器路由<br/> 2。<strong class="kq io">主体解析器</strong> —用于提取请求对象主体中传输的信息<br/> 3。<strong class="kq io"> cors </strong> —允许跨来源资源共享(域调用之间)<br/> 4。<strong class="kq io"> jsonwebtoken </strong> —构造一个<strong class="kq io"> JWT </strong> (jsonwebtoken)，我们将使用它进行认证<br/> 5。<strong class="kq io">节点邮件程序</strong> —允许我们的服务器发送电子邮件</p><p id="ef36" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们还需要一个名为“ngrok”的程序。它允许我们向外界公开我们的<br/><strong class="kq io">本地主机</strong>地址127.0.0.1。</p><p id="a3bd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我们点击传递到我们电子邮件收件箱的神奇链接时，如果我们指向'<strong class="kq io"> localhost </strong>'，你的电子邮件服务器(Protonmail，Outlook，Gmail等。)不会知道‘localhost’是什么。</p><p id="a397" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们必须重定向到一个真实的网址。</p><p id="a7ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可以在这里找到<strong class="kq io">ngrok</strong>:<a class="ae my" href="https://ngrok.com/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">https://ngrok.com/</strong></a></p><p id="5706" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要启动到本地主机的隧道，只需打开命令行shell并键入，</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="ba61" class="lr ls in mq b gy mu mv l mw mx">&gt;&gt; ngrok http 3000</span></pre></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h2 id="ac77" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">让我们为我们的服务器创建基本的脚手架。</h2><p id="bc86" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">我们将创建<strong class="kq io">三个路由</strong>，一个基本的404处理程序路由，和一个<br/>错误处理中间件。</p><p id="2436" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将有一个'<strong class="kq io">/send _ magic _ link</strong>'<strong class="kq io">POST</strong>route，它将接收一个电子邮件地址，查找与之关联的唯一ID，并向该电子邮件地址发送一个神奇的链接。</p><p id="a2c8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，我们需要一个'<strong class="kq io">/authenticate _ user</strong>'<strong class="kq io">GET</strong>路由，它将从用户的电子邮件收件箱获取重定向，在URL查询参数中获取<strong class="kq io"> JWT </strong> (jsonwebtoken)，并对其进行身份验证。</p><p id="176b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，我们有一个'<strong class="kq io">/welcome</strong>'<strong class="kq io">GET</strong>route，它只显示一个文本，通知用户他们现在已经登录。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8b6e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">注意:</strong> <br/>获取“<strong class="kq io">ngrok</strong>”HTTP URL，并将其保存在服务器文件的一个变量中。我们以后会需要这个。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h2 id="cff0" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">让我们填写我们的'/send_magic_link '路线。</h2><p id="cf51" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">当我们获得用户的电子邮件地址时，我们将模拟检查我们的数据库，寻找一个唯一的'<strong class="kq io"> sub </strong> '(subject) ID。<br/>这让我们能够用我们开发的任何一款应用来个性化他们的体验。</p><p id="1333" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一旦我们得到他们的<strong class="kq io">潜艇</strong>，我们将建造一个<strong class="kq io"> JWT </strong>。<br/>将会有:<br/> - an ' <strong class="kq io"> iss </strong> '(issuer)，us<br/>-an '<strong class="kq io">exp</strong>'(expiration date)，从创建令牌起5分钟<br/> - a ' <strong class="kq io"> sub </strong> '(subject)，我们的用户的唯一ID<br/>-a '<strong class="kq io">nonce</strong>，一个可以标识整个令牌的随机唯一字符串。</p><p id="72ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们用一个<strong class="kq io">秘密</strong>来构造我们的<strong class="kq io"> JWT </strong>。这使我们能够确保令牌没有被其他任何人修改。</p><p id="5c9c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">构造好令牌后，我们使用'<strong class="kq io"> nodemailer </strong>'将其发送到用户的电子邮件。<br/>我这里用的是<strong class="kq io"> <em class="nb">谷歌的Gmail服务器</em> </strong>，<strong class="kq io">smtp.gmail.com</strong>。<br/>“<strong class="kq io">auth</strong>”属性应该是<strong class="kq io">您的电子邮件帐户的用户名和密码</strong>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="f707" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">注意:</strong> <br/>注意我们邮件的HTML正文。<br/>我们已经构建了一个锚标签，它通过“<strong class="kq io"> ngrok </strong>”代理将用户指引到我们的REST API。<br/>同样，我们在那个“<strong class="kq io"> href </strong>”的<strong class="kq io"> <em class="nb">查询字符串</em> </strong>中附加<strong class="kq io"> JWT </strong>。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h2 id="e4d2" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">让我们来解决“/authenticate_user”路线。</h2><p id="99c1" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">在'<strong class="kq io"> /send_magic_link </strong>'路由中，我们向用户发送了一个链接，通过查询参数中的令牌将他们重定向到我们的'<strong class="kq io"> /authenticate_user </strong>'路由。</p><p id="1259" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将首先提取令牌。一旦我们有了它，我们将使用我们的'<strong class="kq io">秘密</strong>'来验证<strong class="kq io"> JWT </strong>。</p><p id="440a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们验证了用户传递给我们的令牌与我们传递给他们的令牌相同之后，我们可以模拟一些数据库事务:</p><p id="e146" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">创建唯一的'<strong class="kq io"> session_id </strong>'并将其放入数据库。<br/>获取用户信息。</p><p id="fa90" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们想用这些信息做些什么，我们可以在这里做。</p><p id="d44b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">相反，我们只需要用两个cookie将用户重定向到我们的“<strong class="kq io"> /welcome </strong>”路径:它们是唯一的“<strong class="kq io"> sub </strong>和唯一的“<strong class="kq io"> session_id </strong>”。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mz na l"/></div></figure></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h2 id="51a1" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">最后是我们的“/欢迎”路线。</h2><p id="2d85" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">这是最基本的。<br/>我们将向用户发送一条消息，通知他们“<strong class="kq io">登录了</strong>”运行该服务器的应用程序。</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="5d73" class="lr ls in mq b gy mu mv l mw mx">// ...<br/>    res.status(200).send(<br/>        `&lt;h1&gt;Welcome&lt;/h1&gt;<br/>        &lt;br&gt;<br/>        &lt;h3&gt;You are now logged into the *APP*&lt;/h3&gt;`<br/>    );<br/>// ...</span></pre></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><p id="2577" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你想要更深入的指导，可以看看我在YouTube上的完整视频教程，<strong class="kq io">一个对象就是一个</strong>。</p><h2 id="2f2b" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">创建您自己的无密码认证服务器| Node.js &amp; Express</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nc na l"/></div></figure></div></div>    
</body>
</html>