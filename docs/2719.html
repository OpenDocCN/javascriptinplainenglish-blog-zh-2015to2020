<html>
<head>
<title>How to implement an image upload system with Express and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Express和React实现图像上传系统</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-an-image-upload-system-with-express-and-react-4a6511d8e097?source=collection_archive---------1-----------------------#2020-07-18">https://javascript.plainenglish.io/how-to-implement-an-image-upload-system-with-express-and-react-4a6511d8e097?source=collection_archive---------1-----------------------#2020-07-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/87cc4c12db19f61982014f9ba7b6072e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4KLDKe9kyEp7VqYnLiLE3w.png"/></div></div></figure><div class=""/><p id="eaf8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi kt translated"><span class="l ku kv kw bm kx ky kz la lb di">在</span>这篇文章中，我们将学习如何使用multer将图像上传到服务器，并保存在cloudinary这样的云服务中。如果你只是想把图片保存在服务器上，这篇文章也会有。我们将使用React作为前端上传我们的图像，并在一个旋转木马显示我们的图像。</p><p id="7dfb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以看到我们最终的应用程序如下所示:</p><figure class="ld le lf lg gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi lc"><img src="../Images/9f27f5cf9f253accbb36fa58a071a568.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gpMb094UeCxbVH4RMOvawA.png"/></div></div></figure></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="8ce8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你需要对Node.js、Express.js、mongoose、React.js、React Bootstrap有一个基本的了解才能理解这篇文章。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><h2 id="46cd" class="lo lp iy bd lq lr ls dn lt lu lv dp lw kg lx ly lz kk ma mb mc ko md me mf mg bi translated">multer简介</h2><p id="e363" class="pw-post-body-paragraph jv jw iy jx b jy mh ka kb kc mi ke kf kg mj ki kj kk mk km kn ko ml kq kr ks ig bi translated">Multer是一个快速中间件，帮助我们上传文件到服务器。中间件是一种帮助我们执行特定任务的功能。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="0dc5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们开始吧。</p><p id="374b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在工作目录中，编写以下命令:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="cc89" class="lo lp iy mn b gy mr ms l mt mu">npm int -y</span></pre><p id="3356" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的<code class="fe mv mw mx mn b">-y</code>标志有助于将所有值设置为默认值。</p><p id="53c0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们安装一些软件包。</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="c6e9" class="lo lp iy mn b gy mr ms l mt mu">npm i cloudinary dotenv express mongoose multer multer-storage-cloudinary</span></pre><p id="6a0b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经安装了相当多的软件包。我认为您理解了大多数包的用例，并且您将会在这个过程中学习其他包的用例。</p><p id="aab5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在主项目目录中创建一个名为<strong class="jx iz"> index.js </strong>的文件。这应该使我们的文件夹结构看起来像这样:</p><figure class="ld le lf lg gt ip gh gi paragraph-image"><div class="gh gi my"><img src="../Images/84c2da599f7a0623ea1491925d8ee0ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:330/format:webp/1*GegU8dGakKTwqsWO_zHD4Q.png"/></div></figure><p id="f46c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在文件<strong class="jx iz"> index.js </strong>中编写以下代码行:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="7acc" class="lo lp iy mn b gy mr ms l mt mu">require("dotenv").config();</span><span id="d7f8" class="lo lp iy mn b gy mz ms l mt mu">const express = require("express");</span><span id="e56a" class="lo lp iy mn b gy mz ms l mt mu">const mongoose = require("mongoose");</span><span id="df9f" class="lo lp iy mn b gy mz ms l mt mu">const appRoute = require("./routes/appRoute");</span><span id="4ddb" class="lo lp iy mn b gy mz ms l mt mu">const app = express();</span><span id="5fef" class="lo lp iy mn b gy mz ms l mt mu">const PORT = process.env.PORT || 5000;</span><span id="d2f6" class="lo lp iy mn b gy mz ms l mt mu">app.use("/api", appRoute);</span><span id="dd8e" class="lo lp iy mn b gy mz ms l mt mu">mongoose</span><span id="6db2" class="lo lp iy mn b gy mz ms l mt mu">.connect(process.env.MONGO_URI, {</span><span id="c099" class="lo lp iy mn b gy mz ms l mt mu">useNewUrlParser: true,</span><span id="7f3e" class="lo lp iy mn b gy mz ms l mt mu">useUnifiedTopology: true,</span><span id="0da9" class="lo lp iy mn b gy mz ms l mt mu">})</span><span id="843a" class="lo lp iy mn b gy mz ms l mt mu">.then(() =&gt; console.log("connected to mongo database"))</span><span id="744f" class="lo lp iy mn b gy mz ms l mt mu">.catch((<em class="na">error</em>) =&gt; console.errror(error));</span><span id="e0e6" class="lo lp iy mn b gy mz ms l mt mu">app.listen(PORT, () =&gt; console.log(`listening on port : ${PORT}`));</span></pre><p id="1f62" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的代码中，我们已经导入并初始化了<code class="fe mv mw mx mn b">dotenv</code>。然后我们有进口<code class="fe mv mw mx mn b">express</code>、<code class="fe mv mw mx mn b">mongoose</code>、<code class="fe mv mw mx mn b">appRoute</code>。不用担心<code class="fe mv mw mx mn b">appRoute</code>。我们很快就会着手处理。之后，我们初始化了我们的<code class="fe mv mw mx mn b">app</code>。然后，我们创建了一个端点<code class="fe mv mw mx mn b">/api/</code>，它使用<code class="fe mv mw mx mn b">appRoute</code>作为中间件。然后，我们连接到我们的mongoDB数据库。之后，我们在<code class="fe mv mw mx mn b">PORT</code>上启动了我们的服务器。很清楚，对吗？</p><p id="4e17" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以在代码中看到，我们已经指定<code class="fe mv mw mx mn b">mongoose</code>通过<code class="fe mv mw mx mn b">process.env.MONGO_URI</code>连接到数据库URL。但是我们还没有告诉URI应该是什么。为此，创建一个<strong class="jx iz">。env </strong>文件在我们的主项目目录中。然后，打开该文件并编写以下内容:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="10c0" class="lo lp iy mn b gy mr ms l mt mu">MONGO_URI=      //enter the mongo URL here</span></pre><p id="ea94" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如上所述，您需要在那里输入<code class="fe mv mw mx mn b">MONGO_URI</code>。</p><p id="4107" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在您已经输入了<code class="fe mv mw mx mn b">MONGO_URI</code>，您现在需要在您的主工作目录中创建一个名为routes的文件夹。之后，在routes目录中创建一个名为<strong class="jx iz"> appRoute.js </strong>的文件。这将使文件夹结构看起来像这样:</p><figure class="ld le lf lg gt ip gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/18a8f49d3669067af7fd9d7b737cef16.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*waeFDVZ1utDbs8FzmoIf7A.png"/></div></figure><p id="9e5e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，打开文件<strong class="jx iz"> appRoute.js </strong>并编写以下代码行:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="aad2" class="lo lp iy mn b gy mr ms l mt mu">const express = require("express");</span><span id="19f0" class="lo lp iy mn b gy mz ms l mt mu">const upload = require("../services/upload");</span><span id="d3d9" class="lo lp iy mn b gy mz ms l mt mu">const { uploadImage, getImages } = require("../controller/appController");</span><span id="7c39" class="lo lp iy mn b gy mz ms l mt mu">const router = express.Router();<br/></span><span id="9404" class="lo lp iy mn b gy mz ms l mt mu"><em class="na">// /api/images</em></span><span id="badc" class="lo lp iy mn b gy mz ms l mt mu">router.get("/images", getImages);</span><span id="50a5" class="lo lp iy mn b gy mz ms l mt mu"><em class="na">// /api/upload</em></span><span id="d2b7" class="lo lp iy mn b gy mz ms l mt mu">router.post("/upload", upload.single("picture"), uploadImage);</span><span id="88f1" class="lo lp iy mn b gy mz ms l mt mu">module.exports = router;</span></pre><p id="7a36" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">可以看到在文件<strong class="jx iz"> appRoute.js </strong>中，有导入。我们已经导入了<code class="fe mv mw mx mn b">express</code>来创建路由器。然后我们导入了<code class="fe mv mw mx mn b">upload</code>，这是一个中间件，我们将很快创建它来帮助我们上传文件。然后你可以看到我们已经导入了<code class="fe mv mw mx mn b">getImages</code>，和<code class="fe mv mw mx mn b">uploadImage</code>。这些是控制器，我们将很快创建。之后，我们创建了两个端点<code class="fe mv mw mx mn b">/api/images</code>和<code class="fe mv mw mx mn b">/api/upload</code>。在这些端点，我们提供了控制器。注意，在端点<code class="fe mv mw mx mn b">/api/upload</code>中，我们使用了<code class="fe mv mw mx mn b">upload</code>中间件。现在不要担心创建<code class="fe mv mw mx mn b">upload</code>中间件。但是请记住,<code class="fe mv mw mx mn b">upload</code>将为我们提供上传文件的功能。<code class="fe mv mw mx mn b">upload</code>为我们提供了一个<code class="fe mv mw mx mn b">.single</code>选项，帮助我们上传单个文件。<code class="fe mv mw mx mn b">single</code>选项接受表单字段的名称作为参数。在我们的例子中是<code class="fe mv mw mx mn b">"picture"</code>。</p><blockquote class="nc nd ne"><p id="ca4a" class="jv jw na jx b jy jz ka kb kc kd ke kf nf kh ki kj ng kl km kn nh kp kq kr ks ig bi translated">如果我们想上传多个文件呢？在这种情况下，我们需要使用<code class="fe mv mw mx mn b">.array</code>而不是<code class="fe mv mw mx mn b">.single</code>。<code class="fe mv mw mx mn b">array</code>接受两个参数。第一个参数是字段的名称，而第二个参数是可以上传的文件的最大数量。让我们在代码中看看这个:<code class="fe mv mw mx mn b">upload.array("picture", 12)</code>。这里<code class="fe mv mw mx mn b">"picture"</code>是表单字段的名称，<code class="fe mv mw mx mn b">12</code>是可以上传的最大图像数量。如果你想深入了解，你可以查看multer的文档。</p></blockquote><p id="4d68" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经在<strong class="jx iz"> appRoute.js </strong>中编写了代码，让我们创建一个名为services的文件夹。然后，在services文件夹中创建一个名为<strong class="jx iz"> upload.js </strong>的文件。我们的文件夹结构应该是这样的:</p><figure class="ld le lf lg gt ip gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/6fef951e45f67a4fe7a1b109108267f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*8KRO8iYf8isNN5aD5clEtw.png"/></div></figure><p id="f9af" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经创建了文件<strong class="jx iz"> upload.js </strong>，让我们写一些代码。</p><p id="0a08" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在进入这一部分之前，让我们创建一个<a class="ae ni" href="https://cloudinary.com/" rel="noopener ugc nofollow" target="_blank"> Cloudinary </a>帐户。创建帐户后，检查您的仪表板。你会看到一个类似这样的部分:</p><figure class="ld le lf lg gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi nk"><img src="../Images/d0d3835bdf4e90a12c043ac158f0e5f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*85d3exGCoRbguwse0QuXFQ.png"/></div></div></figure><p id="e143" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，坚持住。我们需要将一些值复制到我们的<strong class="jx iz">中。env </strong>文件。让我们打开<strong class="jx iz">。env </strong>文件，并编写以下内容:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="0317" class="lo lp iy mn b gy mr ms l mt mu">MONGO_URI=          // Mongodb URL<br/>CLOUD_NAME=         // Clodudinary cloud name<br/>API_KEY=            // Cloudinary API Key<br/>API_SECRET=         // Cloudinary API Secret</span></pre><p id="1404" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在文件中，我们只需要输入它们各自的值，就像上面的评论中提到的那样。</p><p id="d1eb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们继续看文件<strong class="jx iz"> upload.js </strong>。然后，编写下面几行代码:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="78ba" class="lo lp iy mn b gy mr ms l mt mu">const multer = require("multer");</span><span id="1564" class="lo lp iy mn b gy mz ms l mt mu">const cloudinary = require("cloudinary").v2;</span><span id="6845" class="lo lp iy mn b gy mz ms l mt mu">const { CloudinaryStorage } = require("multer-storage-cloudinary");<br/></span><span id="e594" class="lo lp iy mn b gy mz ms l mt mu">cloudinary.config({</span><span id="c352" class="lo lp iy mn b gy mz ms l mt mu">  cloud_name: process.env.CLOUD_NAME,</span><span id="e938" class="lo lp iy mn b gy mz ms l mt mu">  api_key: process.env.API_KEY,</span><span id="96a3" class="lo lp iy mn b gy mz ms l mt mu">  api_secret: process.env.API_SECRET,</span><span id="3b4e" class="lo lp iy mn b gy mz ms l mt mu">});<br/></span><span id="eb6f" class="lo lp iy mn b gy mz ms l mt mu">const storage = new CloudinaryStorage({</span><span id="7385" class="lo lp iy mn b gy mz ms l mt mu">  cloudinary: cloudinary,</span><span id="39eb" class="lo lp iy mn b gy mz ms l mt mu">  folder: "app",</span><span id="bc42" class="lo lp iy mn b gy mz ms l mt mu">  allowedFormats: ["jpg", "png", "jpeg"],</span><span id="a00b" class="lo lp iy mn b gy mz ms l mt mu">  transformation: [{ width: 500, height: 500, crop: "limit" }],</span><span id="733c" class="lo lp iy mn b gy mz ms l mt mu">});</span><span id="cb37" class="lo lp iy mn b gy mz ms l mt mu">const upload = multer({ storage: storage });</span><span id="4715" class="lo lp iy mn b gy mz ms l mt mu">module.exports = upload;</span></pre><p id="2739" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们来谈谈上面几行代码。</p><p id="3006" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们分别从<code class="fe mv mw mx mn b">multer</code>、<code class="fe mv mw mx mn b">cloudinary</code>、<code class="fe mv mw mx mn b">multer-storage-cloudinary</code>引进了<code class="fe mv mw mx mn b">multer</code>、<code class="fe mv mw mx mn b">cloudinary</code>、<code class="fe mv mw mx mn b">CloudinaryStorage</code>。很清楚了，对吧？</p><p id="2317" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我们使用<code class="fe mv mw mx mn b">cloudinary.config</code>来配置我们的Cloudinary帐户。<code class="fe mv mw mx mn b">cloudinary.config</code>接收<code class="fe mv mw mx mn b">cloud_name</code>、<code class="fe mv mw mx mn b">api_key</code>和<code class="fe mv mw mx mn b">api_secret</code>。从名字本身就很清楚了，对吧？</p><p id="d26b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们来看看<code class="fe mv mw mx mn b">CloudinaryStorage</code>。在说涉及的代码之前，先说一下<code class="fe mv mw mx mn b">CloudinaryStorage</code>是做什么的。它帮助我们创建一个存储选项，multer需要它来将文件上传到特定的目的地。</p><p id="8f64" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们来谈谈<code class="fe mv mw mx mn b">CloudinaryStorage</code>中涉及的代码。它接受<code class="fe mv mw mx mn b">cloudinary</code>选项。它还接受了<code class="fe mv mw mx mn b">folder</code>选项，这是我们的Cloudinary cloud中的文件夹的名称。你想叫它什么都可以。之后，您可以看到<code class="fe mv mw mx mn b">allowedFormat</code>，它接受允许的文件格式类型的数组。在我们的例子中，它是PNG和jpeg/jpg。然后就可以看到<code class="fe mv mw mx mn b">transformation</code>。这有助于我们对文件进行一些转换。这是Cloudinary提供的一个功能。如果想了解一下，可以查看Cloudinary的文档。</p><p id="ed6a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在来说说<code class="fe mv mw mx mn b">multer()</code>。你可以看到<code class="fe mv mw mx mn b">multer</code>接受了一个对象。这个对象接收<code class="fe mv mw mx mn b">storage</code>。记住，这个<code class="fe mv mw mx mn b">storage</code>是由<code class="fe mv mw mx mn b">CloudinaryStorage</code>创造出来的。</p><p id="aebd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我们导出了<code class="fe mv mw mx mn b">upload</code>中间件。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="eef9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们暂停一下，看看如果我们把文件上传到我们自己的服务器而不是上传到云端，我们会有什么不同。如果您已经知道如何上传和保存文件到服务器，您可以跳过这一部分。</p><p id="c0ac" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，看一下下面的代码:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="1efe" class="lo lp iy mn b gy mr ms l mt mu">const multer = require("multer");</span><span id="48cb" class="lo lp iy mn b gy mz ms l mt mu">const path = require("path");</span><span id="9b7e" class="lo lp iy mn b gy mz ms l mt mu">let storage = multer.diskStorage({</span><span id="fe11" class="lo lp iy mn b gy mz ms l mt mu">destination: (<em class="na">req</em>, <em class="na">file</em>, <em class="na">cb</em>) =&gt; {</span><span id="df29" class="lo lp iy mn b gy mz ms l mt mu">  cb(null, "uploads");</span><span id="e6b2" class="lo lp iy mn b gy mz ms l mt mu">},</span><span id="d433" class="lo lp iy mn b gy mz ms l mt mu">  filename: (<em class="na">req</em>, <em class="na">file</em>, <em class="na">cb</em>) =&gt; {</span><span id="a494" class="lo lp iy mn b gy mz ms l mt mu">  cb(null,</span><span id="9472" class="lo lp iy mn b gy mz ms l mt mu">  `${file.fieldname}-${Date.now()}-${Math.random() * 1000}${path.extname(file.originalname)}`</span><span id="18b6" class="lo lp iy mn b gy mz ms l mt mu"> );</span><span id="c67b" class="lo lp iy mn b gy mz ms l mt mu"> },</span><span id="b1c6" class="lo lp iy mn b gy mz ms l mt mu">  });</span><span id="9f13" class="lo lp iy mn b gy mz ms l mt mu">const fileFilter = (<em class="na">req</em>, <em class="na">file</em>, <em class="na">cb</em>) =&gt; {</span><span id="0677" class="lo lp iy mn b gy mz ms l mt mu">  if (</span><span id="10cf" class="lo lp iy mn b gy mz ms l mt mu">  file.mimetype === "image/png" ||</span><span id="d68e" class="lo lp iy mn b gy mz ms l mt mu">  file.mimetype === "image/jpg" ||</span><span id="7d3e" class="lo lp iy mn b gy mz ms l mt mu">  file.mimetype === "image/jpeg"</span><span id="eaa9" class="lo lp iy mn b gy mz ms l mt mu">  ) {</span><span id="6848" class="lo lp iy mn b gy mz ms l mt mu">  cb(null, true);</span><span id="e49d" class="lo lp iy mn b gy mz ms l mt mu">  } else {</span><span id="f93a" class="lo lp iy mn b gy mz ms l mt mu">  cb(new Error("File format should be PNG,JPG,JPEG"), false);</span><span id="b197" class="lo lp iy mn b gy mz ms l mt mu">  }</span><span id="61b7" class="lo lp iy mn b gy mz ms l mt mu">};</span><span id="7dea" class="lo lp iy mn b gy mz ms l mt mu">const upload = multer({ storage: storage, fileFilter: fileFilter });</span><span id="e88c" class="lo lp iy mn b gy mz ms l mt mu">module.exports = upload;</span></pre><p id="7a70" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们不会使用这个项目的工作代码。但是，你绝对可以在你的下一个项目中尝试一下。您也可以尝试在这个项目中上传文件的代码。但是你需要在控制器中做一些改变，我们很快就会开始工作。我不会在这里谈论这个。在使用控制器将文件上传到Cloudinary之后，您可以很容易地理解这一点。</p><p id="ad31" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们仔细看看上面的代码。我们已经导入了<code class="fe mv mw mx mn b">multer</code>和<code class="fe mv mw mx mn b">path</code>。在这里，<code class="fe mv mw mx mn b">path</code>是由节点提供的。</p><p id="2571" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在代码中，你可以看到<code class="fe mv mw mx mn b">multer.diskStorage</code>，它接受了<code class="fe mv mw mx mn b">destination</code>和<code class="fe mv mw mx mn b">file</code>选项。这个<code class="fe mv mw mx mn b">destination</code>选项帮助我们告诉multer我们的文件应该存储在哪里。记住<code class="fe mv mw mx mn b">destination</code>有三个参数<code class="fe mv mw mx mn b">req</code>、<code class="fe mv mw mx mn b">file</code>和<code class="fe mv mw mx mn b">cb</code>。<code class="fe mv mw mx mn b">cb</code>接受两个参数。第二个参数接受存储上传文件的文件夹的名称。在我们的例子中，文件夹是“上传”。如果我们不定义<code class="fe mv mw mx mn b">destination</code>，文件将被上传到我们操作系统的临时文件夹。这里您还应该注意的一点是，您必须在主项目目录中创建文件夹uploads。</p><p id="c61b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们来看看<code class="fe mv mw mx mn b">filename</code>选项。顾名思义，<code class="fe mv mw mx mn b">filename</code>帮助我们改变文件的文件名。如果我们没有使用<code class="fe mv mw mx mn b">filename</code>选项，multer会给文件分配一个随机名称。</p><p id="54a5" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们来谈谈代码。<code class="fe mv mw mx mn b">filename</code>函数接受<code class="fe mv mw mx mn b">req</code>、<code class="fe mv mw mx mn b">file</code>和<code class="fe mv mw mx mn b">cb</code>——类似于<code class="fe mv mw mx mn b">destination</code>。然后你可以看到我们已经实现了<code class="fe mv mw mx mn b">cb</code>，它接受两个参数。第一个是<code class="fe mv mw mx mn b">null</code>，另一个是文件名。在那里你可以看到我们使用了反勾号(<code class="fe mv mw mx mn b">`</code>)。你显然知道<code class="fe mv mw mx mn b">`</code>的用法。你也可以看到我们已经为文件名创建了一个模式，就像这样:<code class="fe mv mw mx mn b">&lt;file's fieldname&gt;-&lt;current date&gt;-&lt;random number&gt;.&lt;file extension&gt;</code>。为了实现这种模式，我们在<code class="fe mv mw mx mn b">file.fieldname</code>的帮助下添加了字段名，其中<code class="fe mv mw mx mn b">file</code>是参数。然后我们用<code class="fe mv mw mx mn b">Date.now()</code>添加了当前日期。之后我们通过<code class="fe mv mw mx mn b">Math.random()*1000</code>添加随机数。之后，我们在<code class="fe mv mw mx mn b">path.extname</code>的帮助下添加了文件的扩展名。<code class="fe mv mw mx mn b">extname</code>接受文件名并返回扩展名。</p><p id="9201" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我们创建了一个<code class="fe mv mw mx mn b">fileFilter</code>。<code class="fe mv mw mx mn b">fileFilter</code>的作用是过滤可以上传的文件类型。在函数<code class="fe mv mw mx mn b">fileFilter</code>中，我们实现了一个<code class="fe mv mw mx mn b">mimetype</code>检查。如果它与<code class="fe mv mw mx mn b">mimetype</code>匹配，我们就实现了回调，并且不会以这种方式返回任何错误:<code class="fe mv mw mx mn b">cb(null,true)</code>。如果<code class="fe mv mw mx mn b">mimetype</code>不匹配，我们在<code class="fe mv mw mx mn b">cb</code>的帮助下抛出一个新的错误。</p><p id="ef3a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后，我们在<code class="fe mv mw mx mn b">multer</code>上增加了<code class="fe mv mw mx mn b">storage</code>和<code class="fe mv mw mx mn b">fileFilter</code>选项。这个过程很简单，对吗？</p><p id="6755" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，您就可以将文件上传到服务器。既然你已经学会了如何上传文件到服务器，让我们回到我们真正的任务。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="3748" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们在主项目目录中创建一个名为controller的目录。然后，在控制器目录中创建一个名为<strong class="jx iz"> appController.js </strong>的文件。这应该使我们的文件夹结构看起来像这样:</p><figure class="ld le lf lg gt ip gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/9ea1ca0adc52b0c268da70923dc4e3bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:464/format:webp/1*6X74F8xj4LtiZJA0qDsrrQ.png"/></div></figure><p id="f3d0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，在文件<strong class="jx iz"> appController.js </strong>中，编写以下代码行:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="a87b" class="lo lp iy mn b gy mr ms l mt mu">const Image = require("../models/Image");</span><span id="2f3a" class="lo lp iy mn b gy mz ms l mt mu">const getImages = async (<em class="na">req</em>, <em class="na">res</em>) =&gt; {</span><span id="df56" class="lo lp iy mn b gy mz ms l mt mu">  try {</span><span id="2424" class="lo lp iy mn b gy mz ms l mt mu">    let images = await Image.find({}, " -__v");</span><span id="0ce4" class="lo lp iy mn b gy mz ms l mt mu">    return res.status(200).json({ images, msg: "image info fetched"    });</span><span id="37f1" class="lo lp iy mn b gy mz ms l mt mu">  } catch (error) {</span><span id="8c80" class="lo lp iy mn b gy mz ms l mt mu">    console.error(error);</span><span id="5b29" class="lo lp iy mn b gy mz ms l mt mu">      return res.status(500).json({ error: "some error occured" });</span><span id="ef6f" class="lo lp iy mn b gy mz ms l mt mu">    }</span><span id="c19e" class="lo lp iy mn b gy mz ms l mt mu">    };</span><span id="88ae" class="lo lp iy mn b gy mz ms l mt mu">const uploadImage = async (<em class="na">req</em>, <em class="na">res</em>) =&gt; {</span><span id="db1e" class="lo lp iy mn b gy mz ms l mt mu">  try {</span><span id="3905" class="lo lp iy mn b gy mz ms l mt mu">    if (req.file &amp;&amp; req.file.path) {</span><span id="0c20" class="lo lp iy mn b gy mz ms l mt mu">      const image = new Image({</span><span id="6159" class="lo lp iy mn b gy mz ms l mt mu">  description: req.body.desc,</span><span id="5df6" class="lo lp iy mn b gy mz ms l mt mu">      url: req.file.path,</span><span id="6348" class="lo lp iy mn b gy mz ms l mt mu">});</span><span id="eab8" class="lo lp iy mn b gy mz ms l mt mu">await image.save();</span><span id="f4eb" class="lo lp iy mn b gy mz ms l mt mu">return res.status(200).json({ msg: "image successfully saved" });</span><span id="1aad" class="lo lp iy mn b gy mz ms l mt mu">} else {</span><span id="1bac" class="lo lp iy mn b gy mz ms l mt mu">  console.log(req.file);</span><span id="3970" class="lo lp iy mn b gy mz ms l mt mu">  return res.status(422).json({ error: "invalid" });</span><span id="f6c5" class="lo lp iy mn b gy mz ms l mt mu">    }</span><span id="5ba9" class="lo lp iy mn b gy mz ms l mt mu">    } catch (error) {</span><span id="4cd3" class="lo lp iy mn b gy mz ms l mt mu">  console.error(error);</span><span id="bc3a" class="lo lp iy mn b gy mz ms l mt mu"> return res.status(500).json({ error: "some error occured" });</span><span id="7d08" class="lo lp iy mn b gy mz ms l mt mu">  }</span><span id="955d" class="lo lp iy mn b gy mz ms l mt mu">};</span><span id="0fd1" class="lo lp iy mn b gy mz ms l mt mu">module.exports = {</span><span id="7937" class="lo lp iy mn b gy mz ms l mt mu">  getImages,</span><span id="14a5" class="lo lp iy mn b gy mz ms l mt mu">  uploadImage,</span><span id="ff26" class="lo lp iy mn b gy mz ms l mt mu">};</span></pre><p id="9f4a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以看到在上面的代码中我们已经导入了<code class="fe mv mw mx mn b">Image</code>模型。不要担心那个。我们将很快创建它。</p><p id="a391" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们来看看<code class="fe mv mw mx mn b">getImages</code>功能。当用户向路线<code class="fe mv mw mx mn b">/api/images</code>发出get请求时，该函数被调用；你显然知道那件事。在这个函数中，我们向用户发送图像数组。如果出现任何服务器错误，我们将向用户发送状态代码500。我认为这不需要更多的解释。</p><p id="efe0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们来看看函数<code class="fe mv mw mx mn b">uploadImage</code>。您显然知道，当用户向路由<code class="fe mv mw mx mn b">/api/upload</code>发出post请求时，就会调用这个函数。在代码中，我们检查了<code class="fe mv mw mx mn b">req.file</code>和<code class="fe mv mw mx mn b">req.file.path</code>是否存在。如果它们存在，我们已经编写了代码来创建一个新的<code class="fe mv mw mx mn b">Image</code>模型实例，然后用状态代码200和一条消息来响应用户。如果它们不存在，我们实现代码向用户发送状态代码422和一条错误消息。如果在这个过程中有任何错误，我们将用状态代码500和一条错误消息来响应用户。很简单吧？</p><p id="af74" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">之后我们又导出了<code class="fe mv mw mx mn b">uploadImage</code>和<code class="fe mv mw mx mn b">getImages</code>函数。</p><p id="74c4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经完成了控制器的实现，让我们在工作目录中创建名为models的文件夹。然后创建一个名为<strong class="jx iz"> Image.js </strong>的文件。之后，编写下面几行代码:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="0f43" class="lo lp iy mn b gy mr ms l mt mu">const mongoose = require("mongoose");</span><span id="5bcd" class="lo lp iy mn b gy mz ms l mt mu">const { Schema } = mongoose;</span><span id="4176" class="lo lp iy mn b gy mz ms l mt mu">const Image = new Schema({</span><span id="b4cc" class="lo lp iy mn b gy mz ms l mt mu">url: { type: String },</span><span id="bd77" class="lo lp iy mn b gy mz ms l mt mu">description: { type: String },</span><span id="32bc" class="lo lp iy mn b gy mz ms l mt mu">});</span><span id="334a" class="lo lp iy mn b gy mz ms l mt mu">module.exports = mongoose.model("image", Image);</span></pre><p id="d06a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我想这里很清楚了。我们有一个带有<code class="fe mv mw mx mn b">url</code>和<code class="fe mv mw mx mn b">description</code>的图像模型，它们都有<code class="fe mv mw mx mn b">String</code>数据类型。</p><p id="c0bc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样，我们终于完成了项目的后端。现在让我们来做项目的前端部分。</p><p id="4d0c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们在主项目目录中打开命令行，并编写以下命令:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="8da0" class="lo lp iy mn b gy mr ms l mt mu">npx create-react-app views</span></pre><p id="de0a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">安装完成后，我们的文件结构应该如下所示:</p><figure class="ld le lf lg gt ip gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/6ace5f51a2f8b1ea702b70d11f29aa0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:396/format:webp/1*-_hisZQUPkly05BqRuDi7A.png"/></div></figure><p id="7f15" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们在前端部分安装我们需要的包。首先，让我们在终端中将工作目录改为视图。为此，我们需要编写以下命令行:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="b609" class="lo lp iy mn b gy mr ms l mt mu">cd views</span></pre><p id="f924" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们安装我们需要的包。为此，我们需要编写以下命令行:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="92e4" class="lo lp iy mn b gy mr ms l mt mu">npm i axios bootstrap react-bootstrap</span></pre><p id="7162" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要axios进行请求，需要bootstrap和react-bootstrap进行样式设计。</p><p id="45f0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们需要在前端部分添加代理。为此，从视图目录中打开<strong class="jx iz"> package.json </strong>文件。然后在文件末尾添加这一行:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="71a8" class="lo lp iy mn b gy mr ms l mt mu">"proxy": "http://localhost:5000/"</span></pre><p id="76dc" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们这样做是为了防止向后端发出请求时出现CORS错误。</p><p id="0a6c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在打开views/src目录中的文件<strong class="jx iz"> App.js </strong>。然后在文件中编写以下代码行:</p><pre class="ld le lf lg gt mm mn mo mp aw mq bi"><span id="f5e8" class="lo lp iy mn b gy mr ms l mt mu">import React from "react";</span><span id="aad7" class="lo lp iy mn b gy mz ms l mt mu">import "bootstrap/dist/css/bootstrap.css";</span><span id="9358" class="lo lp iy mn b gy mz ms l mt mu">import Upload from "./component/Upload";</span><span id="a6e7" class="lo lp iy mn b gy mz ms l mt mu">import ImageCarousel from "./component/ImageCarousel";</span><span id="dc44" class="lo lp iy mn b gy mz ms l mt mu">function App() {</span><span id="1e5d" class="lo lp iy mn b gy mz ms l mt mu">  return (</span><span id="1ed8" class="lo lp iy mn b gy mz ms l mt mu">    &lt;div className="container"&gt;</span><span id="a6b2" class="lo lp iy mn b gy mz ms l mt mu">    &lt;ImageCarousel /&gt;</span><span id="ef02" class="lo lp iy mn b gy mz ms l mt mu">    &lt;Upload /&gt;</span><span id="7ba1" class="lo lp iy mn b gy mz ms l mt mu">    &lt;/div&gt;</span><span id="cd20" class="lo lp iy mn b gy mz ms l mt mu">    );</span><span id="feed" class="lo lp iy mn b gy mz ms l mt mu">}</span><span id="7b34" class="lo lp iy mn b gy mz ms l mt mu">export default App;</span></pre><p id="c0ba" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在文件中，我们导入了React。我们还从bootstrap导入了CSS文件。我们还导入了两个组件<code class="fe mv mw mx mn b">Upload</code>和<code class="fe mv mw mx mn b">ImageCarousel</code>。然后我们渲染组件。</p><p id="e683" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，让我们继续研究这些组件。为此，让我们在views/src目录中创建一个名为component的目录。现在，创建两个名为<strong class="jx iz"> ImageCarousel.js </strong>和<strong class="jx iz"> Upload.js </strong>的文件。</p><p id="f6f2" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们打开文件<strong class="jx iz"> Upload.js </strong>并编写以下代码行:</p><figure class="ld le lf lg gt ip"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="b2f6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在这里创建了一个按钮和一个模态。在本文中，我不会解释如何创建模态。如果你想了解它，你可以查看react-bootstrap的文档<a class="ae ni" href="https://react-bootstrap.github.io/components/modal/" rel="noopener ugc nofollow" target="_blank">的这一部分。你可以看到我们在模态中有一个形式。它包含两个字段，即描述和文件字段。我们已经编写了代码，以便在表单字段发生变化时改变状态。</a></p><p id="9706" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在图像字段中看到，我们在第80行调用了<code class="fe mv mw mx mn b">fileData()</code>函数。这个函数返回图像的名称。现在，我们来看看第15行的<code class="fe mv mw mx mn b">onSubmit</code>函数。在这个函数中，我们创建了一个新的<code class="fe mv mw mx mn b">FormData</code>实例。<code class="fe mv mw mx mn b">FromData</code>返回给我们<code class="fe mv mw mx mn b">Content-Type: multipart/form-data</code>。如果你想了解更多关于<code class="fe mv mw mx mn b">FormData</code>的信息，请点击<a class="ae ni" href="https://javascript.info/formdata" rel="noopener ugc nofollow" target="_blank">链接</a>到javascript.info。之后，我们编写代码来实现对URL <code class="fe mv mw mx mn b">/api/upload</code>的POST请求。</p><p id="22cb" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经实现了上传模型，让我们来处理图片轮播。在文件<strong class="jx iz"> ImageCarousel.js </strong>中，编写以下代码行:</p><figure class="ld le lf lg gt ip"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9ab1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们已经从react bootstrap导入了<code class="fe mv mw mx mn b">Carousel</code>。我不会在这篇文章里谈论<code class="fe mv mw mx mn b">Carousel</code>。如果你想了解更多，你可以按照文档的这部分去做。下面我们来谈谈<code class="fe mv mw mx mn b">getImages</code>功能。在这个函数中，我们编写了对URL <code class="fe mv mw mx mn b">/api/images</code>发出get请求的代码。当组件被挂载时，这个函数被调用。之后，我们添加了<code class="fe mv mw mx mn b">Carousel.Item</code>内部的图像和<code class="fe mv mw mx mn b">Carousel.Caption</code>内部的图像描述。</p><p id="6491" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样我们就完成了项目的开发。现在，你可以尝试这个项目了。</p></div></div>    
</body>
</html>