<html>
<head>
<title>Handling Asynchrony in Vue 3 / Composition API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Vue 3 /组合API中处理异步</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/handling-asynchrony-in-vue-3-composition-api-part-1-managing-async-state-e993842ebf8f?source=collection_archive---------0-----------------------#2020-08-08">https://javascript.plainenglish.io/handling-asynchrony-in-vue-3-composition-api-part-1-managing-async-state-e993842ebf8f?source=collection_archive---------0-----------------------#2020-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="fe78" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第1部分:管理异步状态</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/a22046e13b14f7675c94e63b7bb4feb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HiaXiMuqJDpCA2g6Fs1NGw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Reactive state in vue-concurrency</figcaption></figure><p id="06cd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">几个月前，在工作中，我们决定全力以赴开发我们产品的新版本。</p><p id="22f4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">据我所知——看看新出现的插件，看看discord社区中的所有讨论——复合API变得越来越流行。不仅仅是我们。</p><p id="3519" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">Composition API使许多事情变得更容易，但它也带来了一些挑战，因为有些事情需要重新考虑如何适应这个新概念，并且在建立最佳实践之前可能需要一些时间。</p><p id="e6dd" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">挑战之一是管理状态，尤其是当涉及到异步时。</p><p id="485e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">我将尝试展示不同的方法，包括我创建并维护的<a class="ae lo" href="https://github.com/MartinMalinda/vue-concurrency" rel="noopener ugc nofollow" target="_blank"> vue-concurrency </a>。</p><h1 id="3e9b" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">管理异步状态</h1><p id="fd06" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">你可能会问有什么需要管理的？组合API足够灵活，这应该不是问题。</p><p id="0416" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">最典型的异步操作是向服务器发出AJAX请求。在过去的几年中，AJAX的一些一般性问题已经得到解决或缓解。回调地狱被承诺扑灭了，这些承诺后来被加入了async/await。Async/await非常棒，与几年前编写的原始回调hell spaghetti相比，代码读起来是一种享受。</p><p id="1c99" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但事实是，现在情况好多了，并不意味着没有改进的空间。</p><h1 id="c4ed" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">异步函数/承诺不跟踪状态</h1><p id="fa34" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">当你带着承诺工作时，有一个<code class="fe mm mn mo mp b">promise.then</code>、<code class="fe mm mn mo mp b">promise.catch</code>、<code class="fe mm mn mo mp b">promise.finally</code>，就是这样。您无法访问<code class="fe mm mn mo mp b">status</code>或某些<code class="fe mm mn mo mp b">isPending</code>属性和其他国家属性。这就是为什么您经常必须自己管理这种状态，并且使用Composition API，您的代码可能如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="d0f8" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这里我们将类似<code class="fe mm mn mo mp b">isLoading</code> <code class="fe mm mn mo mp b">error</code> <code class="fe mm mn mo mp b">data</code>的引用传递给模板。<code class="fe mm mn mo mp b">getUsers</code>功能也被传递，以允许在出现错误的情况下重试操作。你可能认为上面的代码仍然很合理，在很多情况下，我同意你的观点。如果异步逻辑不太复杂，像这样管理状态仍然是可行的。</p><p id="5725" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">然而，我在上面的代码中隐藏了一个逻辑错误。你能发现它吗？</p><p id="89ed" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mm mn mo mp b">isLoading.value = false;</code>仅在成功加载数据后发生，但在出现错误时不会发生。如果服务器发送错误响应，视图将永远停留在spinner land。</p><p id="add2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这是一个微不足道的错误，但如果你一遍又一遍地重复这样的逻辑，这是一个容易犯的错误。</p><p id="4c78" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这种情况下，消除样板代码也意味着消除出现逻辑错误、打字错误等的机会。让我们看看如何减少这种情况的不同方法:</p><h2 id="fb1d" class="ms lq in bd lr mt mu dn lv mv mw dp lz lb mx my mb lf mz na md lj nb nc mf nd bi translated">自定义钩子:useAsync，usePromise等等</h2><p id="0b36" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">你可以创建你自己的钩子，你自己的<code class="fe mm mn mo mp b">use</code>函数来包装上面的逻辑。或者您可以从现有的composition API实用程序库中选择一个解决方案:</p><p id="77e3" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">vue-use—</strong><a class="ae lo" href="https://vueuse.js.org/?path=/story/state--useasyncstate" rel="noopener ugc nofollow" target="_blank">use sync state</a></p><pre class="kd ke kf kg gt ne mp nf ng aw nh bi"><span id="c014" class="ms lq in mp b gy ni nj l nk nl">const { state, ready } = useAsyncState(<br/>      axios<br/>        .get('https://jsonplaceholder.typicode.com/todos/1')<br/>        .then(t =&gt; t.data),<br/>      {<br/>        id: null,<br/>      },<br/>    )</span></pre><p id="2d1d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">优点:简单，接受简单的承诺。<strong class="ku io">缺点:</strong>没办法重试。</p><p id="2f4e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">vue-composition-toolkit</strong>—<a class="ae lo" href="https://github.com/HcySunYang/vue-composition-toolkit/blob/master/src/useAsyncState.ts" rel="noopener ugc nofollow" target="_blank">useAsyncState</a></p><pre class="kd ke kf kg gt ne mp nf ng aw nh bi"><span id="bb15" class="ms lq in mp b gy ni nj l nk nl">const { refData, refError, refState, runAsync } = useAsyncState(() =&gt; axios('<!-- -->https://jsonplaceholder.typicode.com/todos/1<!-- -->'))</span></pre><p id="dad9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">优点:</strong>覆盖所有州。<strong class="ku io">缺点:</strong>也许冗长的命名？</p><h2 id="bb16" class="ms lq in bd lr mt mu dn lv mv mw dp lz lb mx my mb lf mz na md lj nb nc mf nd bi translated"><strong class="ak"> &lt; </strong> <a class="ae lo" href="https://v3.vuejs.org/guide/component-dynamic-async.html#using-with-suspense" rel="noopener ugc nofollow" target="_blank"> <strong class="ak">悬念</strong> </a> <strong class="ak"> / &gt; </strong></h2><p id="fd6d" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">悬念是一个新的API，最初来自React land，它以一种稍微不同的、相当独特的方式解决了这个问题。</p><p id="67a0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">如果要使用悬念，我们可以直接在设置函数中使用async / await来开始:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="5626" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">但是等等，目前为止还没有<code class="fe mm mn mo mp b">&lt;Suspense&gt;</code>被使用！这是因为它实际上会在相对于这个组件的父组件中使用。暂停有效地观察其默认槽中的组件，并且如果任何组件承诺没有实现，则可以显示回退内容:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="fda0" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">在这种情况下，<code class="fe mm mn mo mp b">&lt;Suspense&gt;</code>在<code class="fe mm mn mo mp b">&lt;Admins /&gt;</code>和<code class="fe mm mn mo mp b">&lt;Users /&gt;</code>等待承诺的实现。如果任何promise被拒绝或者抛出了其他错误，它会在<code class="fe mm mn mo mp b"><a class="ae lo" href="https://v3.vuejs.org/api/composition-api.html#lifecycle-hooks" rel="noopener ugc nofollow" target="_blank">onErrorCaptured</a></code>钩子中被捕获并设置为ref。</p><p id="560b" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">这种方法比上面概述的钩子有一些好处，因为这些钩子通过返回<code class="fe mm mn mo mp b">ref</code>来工作，因此在你的<code class="fe mm mn mo mp b">setup</code>函数中，你必须考虑到引用还没有被数据填充的可能性:</p><pre class="kd ke kf kg gt ne mp nf ng aw nh bi"><span id="22eb" class="ms lq in mp b gy ni nj l nk nl">setup() {<br/>  const { refData: response } = useAsyncState(() =&gt; ajax('/users');<br/>  const users = computed(() =&gt; response.value<br/>                                 &amp;&amp; response.value.data.users);<br/>  return { users };<br/>}<br/><br/></span></pre><p id="f7d2" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">有了TS链接操作符，它可能就变成了<code class="fe mm mn mo mp b">response.value?.data.users</code>。但是，使用<code class="fe mm mn mo mp b">&lt;Suspense /&gt;</code>你不需要处理<code class="fe mm mn mo mp b">ref</code>，在这种情况下你甚至不需要<code class="fe mm mn mo mp b">computed</code>！</p><pre class="kd ke kf kg gt ne mp nf ng aw nh bi"><span id="c84a" class="ms lq in mp b gy ni nj l nk nl">const response = await ajax('/users');<br/>const { users } = response.data;<br/>return { users }; </span></pre><p id="4a6a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">优点:</strong></p><ul class=""><li id="f0a1" class="nm nn in ku b kv kw ky kz lb no lf np lj nq ln nr ns nt nu bi translated">平原<code class="fe mm mn mo mp b">async / await</code>直接在设置功能！</li><li id="4d12" class="nm nn in ku b kv nv ky nw lb nx lf ny lj nz ln nr ns nt nu bi translated">没必要用那么多<code class="fe mm mn mo mp b">ref</code>和<code class="fe mm mn mo mp b">computed</code>！</li></ul><p id="c9ca" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">缺点:</strong></p><ul class=""><li id="963a" class="nm nn in ku b kv kw ky kz lb no lf np lj nq ln nr ns nt nu bi translated">按照设计，逻辑必须分成两个(或更多)组件。错误处理和加载视图必须在父组件中处理。</li><li id="8556" class="nm nn in ku b kv nv ky nw lb nx lf ny lj nz ln nr ns nt nu bi translated">数据加载是在子组件中完成的，而加载/错误处理是在父组件中完成的，这一事实起初可能是违反直觉的</li><li id="0e74" class="nm nn in ku b kv nv ky nw lb nx lf ny lj nz ln nr ns nt nu bi translated">错误处理需要通过一些额外的样板代码<code class="fe mm mn mo mp b">onErrorCaptured</code>和手动设置ref来完成。</li><li id="379d" class="nm nn in ku b kv nv ky nw lb nx lf ny lj nz ln nr ns nt nu bi translated">悬念对于数据的异步呈现来说很方便，但是对于保存表单、有条件地禁用按钮等异步处理来说可能并不理想。为此需要一种不同的方法。</li></ul><h2 id="d5eb" class="ms lq in bd lr mt mu dn lv mv mw dp lz lb mx my mb lf mz na md lj nb nc mf nd bi translated">vue-Promised—<a class="ae lo" href="https://github.com/posva/vue-promised" rel="noopener ugc nofollow" target="_blank">&lt;Promised/&gt;</a></h2><p id="56d7" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">还有另一种通过特殊组件的方法:<code class="fe mm mn mo mp b">&lt;Promised /&gt;</code>。它以更经典的方式使用——它接受prop中的承诺，而不是像<code class="fe mm mn mo mp b">&lt;Suspense /&gt;</code>那样观察子组件的状态。通过命名插槽来设置错误和加载视图:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="6ca4" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">优点:</strong></p><ul class=""><li id="0936" class="nm nn in ku b kv kw ky kz lb no lf np lj nq ln nr ns nt nu bi translated">与<code class="fe mm mn mo mp b">&lt;Suspsense /&gt;</code>相比:可能将所有数据/加载/错误视图放在同一个地方。</li></ul><p id="0fa7" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">缺点:</strong></p><ul class=""><li id="1f71" class="nm nn in ku b kv kw ky kz lb no lf np lj nq ln nr ns nt nu bi translated">与<code class="fe mm mn mo mp b">&lt;Suspense /&gt;</code>相同:仅限于异步渲染，对于提交表单/按钮切换状态等其他用例不理想。</li><li id="907d" class="nm nn in ku b kv nv ky nw lb nx lf ny lj nz ln nr ns nt nu bi translated">与<code class="fe mm mn mo mp b">&lt;Suspsence /&gt;</code>相比，您可能需要使用更多的<code class="fe mm mn mo mp b">ref</code>和<code class="fe mm mn mo mp b">computed</code>。</li></ul><h2 id="3fb9" class="ms lq in bd lr mt mu dn lv mv mw dp lz lb mx my mb lf mz na md lj nb nc mf nd bi translated"><a class="ae lo" href="https://github.com/MartinMalinda/vue-concurrency" rel="noopener ugc nofollow" target="_blank">vue-并发—使用任务</a></h2><p id="cb40" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated"><a class="ae lo" href="https://github.com/MartinMalinda/vue-concurrency" rel="noopener ugc nofollow" target="_blank">vue-concurrency</a>——我创建这个插件是因为我想在Vue中体验一种新方法——借用了<a class="ae lo" href="http://ember-concurrency.com/" rel="noopener ugc nofollow" target="_blank"> ember-concurrency </a>的一个成熟的解决方案来解决这些问题。vue-concurrency的核心概念是一个任务对象，它封装了一个异步操作并保存了一系列派生的反应状态:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="718e" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">与之前的解决方案相比，这里有一些更具体的语法，比如<code class="fe mm mn mo mp b">perform</code> <code class="fe mm mn mo mp b">yield</code>和<code class="fe mm mn mo mp b">isRunning</code>，访问<code class="fe mm mn mo mp b">last</code>等等。vue并发确实需要一点初步的学习。但应该很值得。<code class="fe mm mn mo mp b">yield</code>在这种情况下的行为与<code class="fe mm mn mo mp b">await</code>相同，因此它等待承诺解析。<code class="fe mm mn mo mp b">perform()</code>调用底层生成器函数。</p><p id="cb2c" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">赞成者:</p><ul class=""><li id="d7ee" class="nm nn in ku b kv kw ky kz lb no lf np lj nq ln nr ns nt nu bi translated">任务不限于模板。反应状态可以用在其他地方。</li><li id="4585" class="nm nn in ku b kv nv ky nw lb nx lf ny lj nz ln nr ns nt nu bi translated">任务的反应状态可以很容易地用于禁用按钮、处理表单提交</li><li id="895d" class="nm nn in ku b kv nv ky nw lb nx lf ny lj nz ln nr ns nt nu bi translated">该任务总是可以再次执行，这使得重试操作很容易。</li><li id="e1cc" class="nm nn in ku b kv nv ky nw lb nx lf ny lj nz ln nr ns nt nu bi translated">任务实例是<code class="fe mm mn mo mp b">PromiseLike</code>，因此它可以与其他解决方案一起使用，例如<code class="fe mm mn mo mp b">&lt;Promised /&gt;</code>。</li><li id="b48a" class="nm nn in ku b kv nv ky nw lb nx lf ny lj nz ln nr ns nt nu bi translated">任务可以很好地适应更复杂的情况，因为它们提供了取消和并发管理，这使得防止不必要的行为和实现去抖动、节流、轮询等技术变得容易。</li></ul><p id="110a" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><strong class="ku io">缺点:</strong></p><ul class=""><li id="086f" class="nm nn in ku b kv kw ky kz lb no lf np lj nq ln nr ns nt nu bi translated">与<code class="fe mm mn mo mp b">&lt;Suspense /&gt;</code>相比，可能需要一些额外的参考和计算。</li><li id="efba" class="nm nn in ku b kv nv ky nw lb nx lf ny lj nz ln nr ns nt nu bi translated">一个新的概念需要学习，即使是很小的。</li></ul><h1 id="2f86" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><p id="7356" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">当我们处理异步逻辑时，我们最有可能使用某种异步函数，我们处理承诺。跟踪运行进度、错误和已解决数据的状态需要在一旁处理。</p><p id="5b4d" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated"><code class="fe mm mn mo mp b">&lt;Suspense /&gt;</code>允许消除<code class="fe mm mn mo mp b">ref</code>和<code class="fe mm mn mo mp b">computed</code>的过度使用，允许在<code class="fe mm mn mo mp b">setup</code>中直接使用<code class="fe mm mn mo mp b">async/await</code>。<code class="fe mm mn mo mp b">vue-concurrency</code>提出了一个任务的概念，它可以非常灵活地在模板中使用，也可以扩展到更高级的场景。</p><h1 id="81f7" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">下一个</h1><p id="7328" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">在下一篇文章中，我将深入探讨承诺的另一个缺点以及如何解决它:缺乏取消。我将展示<code class="fe mm mn mo mp b">vue-concurrency</code>如何用生成器函数解决这个问题，以及它带来了什么好处，但是我也将概述其他替代方案。</p><div class="oa ob gp gr oc od"><a href="https://medium.com/@martinmalinda/handling-asynchrony-with-vue-composition-api-and-vue-concurrency-part-2-canceling-throttling-4e0305c82367" rel="noopener follow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd io gy z fp oi fr fs oj fu fw im bi translated">用vue组合API和Vue并发处理异步:第2部分——取消、节流…</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">在上一篇文章中，我谈到了承诺和处理异步状态。这篇文章将指向另一个弱点…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">medium.com</p></div></div><div class="om l"><div class="on l oo op oq om or km od"/></div></div></a></div><p id="9bc9" class="pw-post-body-paragraph ks kt in ku b kv kw jo kx ky kz jr la lb lc ld le lf lg lh li lj lk ll lm ln ig bi translated">感谢阅读！</p><h2 id="365d" class="ms lq in bd lr mt mu dn lv mv mw dp lz lb mx my mb lf mz na md lj nb nc mf nd bi translated">在herohero上订阅每周编码示例、技巧和提示</h2><p id="3cae" class="pw-post-body-paragraph ks kt in ku b kv mh jo kx ky mi jr la lb mj ld le lf mk lh li lj ml ll lm ln ig bi translated">嘿👋如果你觉得这些内容有帮助，<a class="ae lo" href="https://herohero.co/martin" rel="noopener ugc nofollow" target="_blank">在herohero </a>上订阅我，在那里我经常分享来自我日常使用JavaScript和Vue的经验的简洁而有用的编码技巧。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><a href="https://herohero.co/martin"><div class="gh gi os"><img src="../Images/19339e390e1513a8a73f83e1ec1036a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*29xXbBkTMAe_w-dkMYfI4Q.png"/></div></a></figure></div></div>    
</body>
</html>