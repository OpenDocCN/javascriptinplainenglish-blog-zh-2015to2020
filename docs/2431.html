<html>
<head>
<title>Writing resilient, unbreakable code using functional patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用功能模式编写有弹性的、牢不可破的代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/writing-resilient-unbreakable-code-using-functional-patterns-bcd63d28ac1e?source=collection_archive---------2-----------------------#2020-06-23">https://javascript.plainenglish.io/writing-resilient-unbreakable-code-using-functional-patterns-bcd63d28ac1e?source=collection_archive---------2-----------------------#2020-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2533" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">抽象的质量取决于其单元的质量</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3af7ce6d6825974a81d7f813c9135347.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0E1DH9l5-yP1dw7NYyoTw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by <a class="ae kv" href="https://pixabay.com/users/EdiNugraha-30562/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=102840" rel="noopener ugc nofollow" target="_blank">Edi Nugraha</a> from <a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=102840" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="da9f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">刚毕业的学生，从编码营招募的新人，以前的Java/Perl/Ruby/Python程序员倾向于用命令式风格写作。这没有错，我也是一样。我记得有时某些数据转换函数嵌套了大量的条件逻辑，几个月后我都无法推理出自己的代码。调试是一场噩梦。然后我读了函数式编程，它改变了我写代码的方式。</p><h2 id="e08e" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">一个例子</h2><p id="6736" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我们将编写一个简单的函数，它接受一个数字数组，并将小于7的值作为一个新的格式化字符串数组返回。如果你的函数看起来像这样，你并不孤单。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="9cdb" class="ls lt iq mr b gy mv mw l mx my">const earlyHours = (hours) =&gt; {<br/>  const early = [];<br/>  for (let i = 0; i &lt; hours.length; i++) {<br/>    if (hours[i] &lt; 7) {<br/>      early.push(`${hours[i]} am`);<br/>    }<br/>  }<br/>  return early;<br/>};</span><span id="b2aa" class="ls lt iq mr b gy mz mw l mx my">console.log(earlyHoursImp(hours));<br/>// returns ["1 am", "2 am", "3 am", "4 am", "5 am", "6 am"]</span></pre><p id="d57e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它工作了。那问题是什么？</p><p id="3fdc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">势在必行。你是在告诉计算机明确的指令去做这个，加这个，做那个等等。命令式代码充满了潜在的错误点。它依赖于状态突变。earlyHours()函数需要两个临时状态值来进行计算。，两者都是多次变异。“<em class="na">I”</em>在每次循环中初始化并递增。“<em class="na">早期”</em>也是以增量方式初始化和构建的。查看下图。请注意由爆炸和下划线标注的部分。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/010610bfb670b3ec7d75951fa0f2d12f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RDXRjnBaFstm7_UYzeqVGQ.png"/></div></div></figure><p id="2a86" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里大概有七个潜在的漏洞。</p><h2 id="82c8" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">纯函数</h2><p id="3428" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">使用函数式风格的第一步是学习编写纯函数。纯函数具有以下性质:</p><ul class=""><li id="8749" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">它们是100%可预测的。对于给定的一组输入参数，返回值总是<strong class="ky ir">与</strong>相同。</li></ul><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="84d6" class="ls lt iq mr b gy mv mw l mx my">const sum = (a, b) =&gt; a + b;</span></pre><ul class=""><li id="ee25" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">它不会访问或改变其范围之外的任何东西。</li></ul><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="cb86" class="ls lt iq mr b gy mv mw l mx my">// These are not cool inside a pure function<br/>locaStorage.getItem("name"); <br/>locaStorage.setItem("name", "me");<br/>fetch("/api/items");<br/>window.addEventListener(...<br/>location<!-- -->.assign(...</span></pre><ul class=""><li id="6c82" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">它不会改变它的函数参数。</li></ul><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="183e" class="ls lt iq mr b gy mv mw l mx my">// do not modify the input values<br/>const getNewOnes = list =&gt; {<br/>  list.forEach(list =&gt; <strong class="mr ir">list.id = </strong>"id-" + list.num);<br/>  return list.filter(list =&gt; list.num &gt; 5);<br/>}</span></pre><ul class=""><li id="a886" class="nc nd iq ky b kz la lc ld lf ne lj nf ln ng lr nh ni nj nk bi translated">返回值总是数据的新副本。这意味着您不能返回仍然引用输入参数中的属性的对象</li></ul><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="d81d" class="ls lt iq mr b gy mv mw l mx my">// person = {<br/>//  name: "Me",<br/>//  address: { "city": "San Jose", state: "CA"}<br/>// }</span><span id="208a" class="ls lt iq mr b gy mz mw l mx my">const getAddressTheWrongWay = person =&gt; {<br/>  return { address: person.address };<br/>  // address is pointing to the argument's property<br/>}</span><span id="7a4c" class="ls lt iq mr b gy mz mw l mx my">const getAddressTheRightWay = person =&gt; {<br/>  return { address: {...person.address} };<br/>  // spread operator clones the properties<br/>}</span></pre><p id="1a17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用纯函数作为设计的基础给你的设计带来了一个重要的品质:<strong class="ky ir">不变性</strong>。这意味着突变只会发生在明确指定的地方，不会有任何意外。</p><h2 id="676f" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">功能风格</h2><p id="de31" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">说到列表的数据转换，我们必须掌握三种方法。映射、过滤和减少。我们的函数可以重写如下:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="355b" class="ls lt iq mr b gy mv mw l mx my">const earlyHours = <br/>  (hours) =&gt; hours.filter(h =&gt; h &lt; 7).map(h =&gt; `${h} am`);</span></pre><p id="4fb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里没有临时状态变量，只有两个潜在的错误点，一个在比较中，另一个在模板字符串中。</p><p id="310e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">map和filter等功能性工具经过时间考验，迭代在内部处理。还要记住，<em class="na"> forEach </em>仍然是必不可少的，因为为了有效，它需要在其作用域之外改变状态。</p><h2 id="1860" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">代码表面区域</h2><p id="f03e" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">为了好玩，我在<a class="ae kv" href="https://codepen.io/rajeshnaroth/pen/WNrjybX" rel="noopener ugc nofollow" target="_blank"> codepen </a>上截图了两个功能，测量了它们占用的空间。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="308f" class="ls lt iq mr b gy mv mw l mx my">Imperative: 473 x 245 = 115885 pixels</span><span id="687b" class="ls lt iq mr b gy mz mw l mx my">Functional: 890 x 30 = 267000 pixels</span></pre><p id="2ca8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用函数式风格，您可以将代码表面减少到原来的23%。你的代码越少，出错的几率就越低。</p><h1 id="0f19" class="nl lt iq bd lu nm nn no lx np nq nr ma jw ns jx md jz nt ka mg kc nu kd mj nv bi translated">进一步提高代码质量</h1><p id="a832" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">但是仅仅采用更好的模式就足够了吗？还有什么能让你的功能牢不可破？</p><h2 id="0fd1" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">添加输入验证</h2><p id="6a28" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果函数的输入无效怎么办？该功能将崩溃。在这个例子中，您可以使用JavaScript的<strong class="ky ir">可选链接</strong>来防止错误输入。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="6c7a" class="ls lt iq mr b gy mv mw l mx my">// returns undefined if input is not an array<br/>const earlyHours =<br/>  hours<strong class="mr ir">?.</strong>filter?.(h =&gt; h &lt; 7).map(h =&gt; `${h} am`)</span></pre><h2 id="2943" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">向函数参数添加默认值</h2><p id="3644" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">如果适用，应该对函数参数使用默认值。这可以在大多数情况下消除不必要的空/未定义检查。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="3074" class="ls lt iq mr b gy mv mw l mx my">const earlyHours = <br/>  (hours = []) =&gt; hours?.filter(h =&gt; h &lt; 7).map(h =&gt; `${h} am`);</span></pre><h2 id="fb6b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">返回有意义的空值</h2><p id="ddb7" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">我建议返回有意义的空值，如`、{}或[]，而不是null和undefined。这意味着函数的调用者可以安全地使用字符串和数组函数，而不必担心未定义的错误。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="6576" class="ls lt iq mr b gy mv mw l mx my">const earlyHours = <br/>  (hours) =&gt; hours?.filter(h =&gt; h &lt; 7).map(h =&gt; `${h} am`) || [];</span></pre><h2 id="c9e4" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">单元测试</h2><p id="f64f" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">希望你的项目有一个测试框架。您可以非常容易地对纯函数进行单元测试。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="21b6" class="ls lt iq mr b gy mv mw l mx my">// using expect BDD assertions<br/>expect(earlyHoursImp([1, 2, 3])).to.eql(["1 am", "2 am", "3 am"])</span></pre><p id="9c19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以为更多类似这样的场景添加测试。</p><h2 id="1375" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">静态打字</h2><p id="55b0" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">使用TypeScript进行静态类型化可以防止函数被不正确地调用。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="6431" class="ls lt iq mr b gy mv mw l mx my">const earlyHours = <br/>  (hours<strong class="mr ir">: number[]</strong>) =&gt; hours.filter(h =&gt; h &lt; 7).map(h =&gt; `${h} am`) || [];</span></pre><p id="9478" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使得除了数字数组之外，无法调用其他函数。运行时不存在TypeScript，因此不会保护您免受类型不兼容的影响。</p><p id="9237" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以在这里玩code sandbox:【https://codepen.io/rajeshnaroth/pen/WNrjybXT2】</p><h2 id="e8f3" class="ls lt iq bd lu lv lw dn lx ly lz dp ma lf mb mc md lj me mf mg ln mh mi mj mk bi translated">使用功能实用程序库</h2><p id="b9d8" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">除了map、reduce和filter之外，还有几个实用程序可以帮助您使用函数式编程风格。<a class="ae kv" href="https://github.com/lodash/lodash/wiki/FP-Guide" rel="noopener ugc nofollow" target="_blank"> lodash </a>和<a class="ae kv" href="https://ramdajs.com/docs/" rel="noopener ugc nofollow" target="_blank"> ramda </a>是两个非常受欢迎的库。我喜欢ramda的API设计。作为家庭作业，我建议你研究一下<em class="na">合成、管道、展平、拾取、查找</em>等功能。</p><p id="36bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">命令式代码是必不可少的，否则你将只有一个静态的网站。您的应用程序需要根据用户/浏览器/网络事件从一种状态转换到另一种状态。JavaScript的伟大之处在于它支持这两种风格。</p><h1 id="947d" class="nl lt iq bd lu nm nn no lx np nq nr ma jw ns jx md jz nt ka mg kc nu kd mj nv bi translated">摘要</h1><ol class=""><li id="7cf6" class="nc nd iq ky b kz ml lc mm lf nw lj nx ln ny lr nz ni nj nk bi translated">编写纯函数</li><li id="ff64" class="nc nd iq ky b kz oa lc ob lf oc lj od ln oe lr nz ni nj nk bi translated">使用功能模式，如映射/减少/过滤/合成</li><li id="d203" class="nc nd iq ky b kz oa lc ob lf oc lj od ln oe lr nz ni nj nk bi translated">添加输入验证。</li><li id="580a" class="nc nd iq ky b kz oa lc ob lf oc lj od ln oe lr nz ni nj nk bi translated">在参数中使用默认值</li><li id="2803" class="nc nd iq ky b kz oa lc ob lf oc lj od ln oe lr nz ni nj nk bi translated">返回空对象，而不是null或undefined</li><li id="3447" class="nc nd iq ky b kz oa lc ob lf oc lj od ln oe lr nz ni nj nk bi translated">编写单元测试</li><li id="6acc" class="nc nd iq ky b kz oa lc ob lf oc lj od ln oe lr nz ni nj nk bi translated">使用静态类型</li></ol><p id="9dd2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要构建高质量的抽象，用弹性的、可组合的单元来构建它们。这些建议可以帮助你实现这一点。</p></div></div>    
</body>
</html>