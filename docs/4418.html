<html>
<head>
<title>Building a CLI With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js构建CLI</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-cli-cef1e080b8a9?source=collection_archive---------3-----------------------#2020-12-10">https://javascript.plainenglish.io/node-js-cli-cef1e080b8a9?source=collection_archive---------3-----------------------#2020-12-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e20d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">您自己的命令行界面只需5分钟</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/30955b67b9c0bd02f2a3cb989af5fd20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4euTIwtvsR0xvrZXk2zpPA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: the author</figcaption></figure><p id="e9e2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们都知道<strong class="kx ir">CLI</strong>，所谓的命令行界面。</p><p id="f2ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它们是我们可以在终端中调用的小程序。几乎我们用npm install -g安装的所有东西都是CLI。</p><p id="ad2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是您知道吗，有了Node.js，我们可以非常轻松地编写CLI程序。例如，我们不需要太多，因为有了它，我们可以实现流程自动化。</p><p id="e573" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本教程中，我将向您展示如何实现在所有系统上运行的Node.js CLI。我们的目标是最终我们只需要在终端的某个地方用命令调用我们的CLI。</p><p id="b727" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们走吧！</p><p id="ca9a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，为项目创建一个目录。我把这个项目文件夹叫做<em class="lr"> hello-cl </em> i。</p><p id="5f52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">进入您刚刚创建的目录。然后照常做，初始化一个Node.js项目的时候:<code class="fe ls lt lu lv b">npm init -y</code>。我们还不需要安装任何东西。</p><p id="ee03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建一个index.js，在那里我们存储了Node.js CLI的所有代码。<br/>在文件中，我们现在只写这一行:<code class="fe ls lt lu lv b">console.log("Our CLI-tool!")</code>。</p><p id="bbdd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，当我们在文件夹中执行index.js时，我们会在控制台上看到输出。为了能够在任何地方只用一个命令执行我们的代码，我们必须改变两件事。</p><p id="c8af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的index.js中，我们需要在顶部添加一行。<br/>我们的index.js现在看起来像这样:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="c3f7" class="ma mb iq lv b gy mc md l me mf"><em class="lr">#!/usr/bin/env node</em></span><span id="3dcc" class="ma mb iq lv b gy mg md l me mf">console.log(‘Our CLI-tool!’)</span></pre><p id="2881" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这条线通常被称为shebang。尽管它是来自UNIX世界的一个表达式，但是我们的节点命令行界面也可以在Windows上工作。</p><p id="fa83" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们项目的package.json中，我们必须添加一些内容:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="e8cc" class="ma mb iq lv b gy mc md l me mf">"bin": "./index.js",</span></pre><p id="faba" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">完成的package.json应该是这样的，例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="411a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">重要提示:</strong>项目的名称(在package.json中表示为‘name ’)决定了全局shell命令的名称。</p><p id="9145" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们已经定制了package.json和index.js。我们只需运行<code class="fe ls lt lu lv b">npm link</code>就可以做到这一点。</p><p id="12cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦在目录中运行这个命令，就可以使用<code class="fe ls lt lu lv b">hello-cli</code>从任何地方执行index.js。</p><h1 id="ad8b" class="mj mb iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">获取用户输入</h1><p id="3fa6" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">到目前为止，我们的Node.js命令行工具可以输出任何内容。但是现有的大多数真正实用的CLI可以做得更多。</p><p id="3031" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一件非常重要的事情是读入用户输入。同样，对于这一点，我们可以使用我们通常在Node.js中使用的解决方案。</p><p id="c1e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">多亏了Node.js中默认可用的<a class="ae nf" href="https://medium.com/javascript-in-plain-english/3-pretty-cool-built-in-node-js-modules-c2c3283276e6#92d6" rel="noopener"> <strong class="kx ir"> readline </strong> </a>模块，我们可以在终端中请求用户输入并对其做出反应。</p><p id="337c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">只有当第一个问题被回答后，才会问第二个问题。嵌套readline-functions不是最优雅的解决方案。但是对于我们的目的来说，这是可以的。</p><p id="9157" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">index.js现在看起来像这样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="7cb9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">执行时，我们的CLI如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/2d5b2f074584cc0b4cc1a4de0bb38cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1356/format:webp/1*D2GsMkLuppU6qvDq5umlKg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: the author</figcaption></figure><p id="0442" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦保存了index.js的更改，就可以在终端的某个地方再次键入<code class="fe ls lt lu lv b">hello-cli </code>。</p><p id="68cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您不需要再次运行<code class="fe ls lt lu lv b">npm link</code>,因为它作为参考工作。因此，如果我们运行了link命令，那么每次运行CLI时，它都会运行我们目录中的代码。</p><p id="bedb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们对代码库所做的任何更改都会立即生效。</p><h1 id="e3d2" class="mj mb iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">让我们把它变得丰富多彩</h1><p id="431f" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">到目前为止，我们已经可以在自己的CLI中读取用户输入。这很好，但还可以更花哨一点。<br/>特别是对于更复杂的CLI，将我们打印到终端的内容着色会非常方便。以下是Vue.js CLI的一个示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/82125e8139013dc683ad2269c0862c85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0HcZH0ILwY2OTeeFbzAD1A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: the author</figcaption></figure><p id="1f0d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，我们可以使用粉笔。我已经在这里更详细地展示了它<a class="ae nf" href="https://medium.com/javascript-in-plain-english/node-js-4-of-the-most-popular-and-useful-libraries-cbf9fa758432#b070" rel="noopener">。</a></p><p id="48a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，我们需要安装粉笔:<code class="fe ls lt lu lv b">npm install chalk</code></p><p id="8c33" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用粉笔非常简单。<br/>不同风格有不同的功能。我想用库来标记“<em class="lr">名</em>”和“<em class="lr">姓</em>”这两个字。我们可以让成品完全绿色。代码如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="6040" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们想要改变颜色的文本，我们只需要传递给适当的粉笔函数。这是执行后的程序的样子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/70d756d34cad4b233bccefe2770cf0d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1016/format:webp/1*yqgvy14cmzvD21AskiDXFQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: the author</figcaption></figure><p id="cf70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在看起来好多了，对吧？</p><h1 id="f4f7" class="mj mb iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">使用文件系统和命令行参数</h1><p id="5411" class="pw-post-body-paragraph kv kw iq kx b ky na jr la lb nb ju ld le nc lg lh li nd lk ll lm ne lo lp lq ij bi translated">我们可以使用的另一个非常强大的特性是<strong class="kx ir">文件系统</strong>。许多用于React或Vue等框架的CLI也使用文件系统来创建新文件和目录。</p><p id="9661" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我们想要的——现在我们重新构建index.js，以便它为我们创建一个新文件。如果我们在控制台中键入<code class="fe ls lt lu lv b">hello-cli</code>，并在后面写另一个字符串，一个<strong class="kx ir">。应该会创建js </strong>文件，这个文件就是以这个字符串命名的。</p><p id="9c71" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如:<code class="fe ls lt lu lv b">hello-world new-project</code>创建一个名为<em class="lr"> new-project.js </em>的文件。</p><p id="b10d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以用<code class="fe ls lt lu lv b">process.argv</code>访问所谓的命令行参数。让我们看看它由什么组成—为此，我只在index.js中编写了以下代码:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="8b83" class="ma mb iq lv b gy mc md l me mf"><em class="lr">#!/usr/bin/env node</em></span><span id="ab5b" class="ma mb iq lv b gy mg md l me mf">console.log(process.argv)</span></pre><p id="c5c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们现在运行<code class="fe ls lt lu lv b">hello-cli</code>，我们会看到以下输出:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="5f2d" class="ma mb iq lv b gy mc md l me mf">[<br/> ‘/usr/local/Cellar/node/14.14.0/bin/node’,<br/> ‘/usr/local/bin/hello-cli’<br/>]</span></pre><p id="ae29" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们运行<code class="fe ls lt lu lv b">hello-cli new-project</code>时，我们看到:</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="df6d" class="ma mb iq lv b gy mc md l me mf">[<br/> ‘/usr/local/Cellar/node/14.14.0/bin/node’,<br/> ‘/usr/local/bin/hello-cli’,<br/> ‘new-project’<br/>]</span></pre><p id="9b44" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">无论我们在<code class="fe ls lt lu lv b">hello-cli</code>后键入什么，它都将在数组中获得索引2。</p><p id="22f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">重要:</strong> Node.js用空格区分各个参数。因此，如果我们键入<code class="fe ls lt lu lv b">hello-cli new-project another</code>，“<em class="lr"> new-project </em>”在数组中仍然有索引2，但是还会有索引3的第四个条目。索引3后面的值将是“<em class="lr">另一个</em>”。</p><p id="511f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们开始实践吧。用<code class="fe ls lt lu lv b">process.argv[2]</code>我们读出用户想要的文件名。如果这个条目也存在于数组中，我们可以用<code class="fe ls lt lu lv b">fs.writeFile</code>创建一个新的空文件。文件的扩展名为<em class="lr">。js </em>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="fa68" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这就是我们整个工作所需要的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/7c189bf4c3b756f28c9aa54edfaa3816.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/format:webp/1*3GlqvxmA83TA2Uu3pNwOog.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: the author</figcaption></figure><p id="e928" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如你所见，我在一个空文件夹中。我一运行CLI，它就会创建一个新文件。可以就这么简单。<br/>CLI可在Windows、Mac和Linux上运行。</p><p id="d894" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">感谢阅读&amp;一切顺利！</strong><br/><em class="lr">——路易</em></p></div></div>    
</body>
</html>