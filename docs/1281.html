<html>
<head>
<title>10 Ways to Level Up Your Knowledge of Promises in JavaScript/ES6</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">提高JavaScript/ES6中承诺知识的10种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/10-ways-to-level-up-your-knowledge-of-promises-in-javascript-d53d25a27645?source=collection_archive---------2-----------------------#2020-02-24">https://javascript.plainenglish.io/10-ways-to-level-up-your-knowledge-of-promises-in-javascript-d53d25a27645?source=collection_archive---------2-----------------------#2020-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a6ee48d6b65cd714743e72730aa67edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tPLS6-QjSjdYjVxfL2aL2A.png"/></div></div></figure><div class=""/><p id="ce8d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有许多很好的方法来提高你的编码技能，尝试新技术。事情的真相是理解JavaScript和Promise。</p><h1 id="93cb" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第一部分:</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="5d05" class="md kx jb lz b gy me mf l mg mh">const prom = new Promise((res, rej) =&gt; {<br/>  console.log('first');<br/>  res();<br/>  console.log('second');<br/>});<br/>prom.then(() =&gt; {<br/>  console.log('third');<br/>});<br/>console.log('fourth');<br/><br/>// first<br/>// second<br/>// fourth<br/>// third</span></pre><p id="d82d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk lz b">Promise</code>同步执行，<code class="fe mi mj mk lz b">promise.then</code>异步执行</p><h1 id="2475" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第二部分:</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="86e0" class="md kx jb lz b gy me mf l mg mh">const prom = new Promise((res, rej) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    res('success');<br/>  }, 1000);<br/>});<br/>const prom2 = prom.then(() =&gt; {<br/>  throw new Error('error');<br/>});<br/><br/>console.log('prom', prom);<br/>console.log('prom2', prom2);<br/><br/>setTimeout(() =&gt; {<br/>  console.log('prom', prom);<br/>  console.log('prom2', prom2);<br/>}, 2000);<br/><br/>// prom <br/>// Promise {&lt;pending&gt;}<br/>// __proto__: Promise<br/>// [[PromiseStatus]]: "resolved"<br/>// [[PromiseValue]]: "success"<br/><br/>// prom2<br/>// Promise {&lt;pending&gt;}__proto__: <br/>// Promise[[PromiseStatus]]: "rejected"[[PromiseValue]]: <br/>// Error: error<br/>//     at &lt;anonymous&gt;:7:9</span></pre><p id="d4d4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk lz b">promise</code>有三种不同的状态:</p><ul class=""><li id="c40e" class="ml mm jb ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">悬而未决的</li><li id="ae31" class="ml mm jb ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">感到满足的</li><li id="9eeb" class="ml mm jb ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">拒绝</li></ul><p id="fccf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦状态更新，<code class="fe mi mj mk lz b">pending-&gt;fulfilled</code>或<code class="fe mi mj mk lz b">pending-&gt;rejected</code>，可以再次更改。<code class="fe mi mj mk lz b">prom1</code>与<code class="fe mi mj mk lz b">prom2</code>不同，都返回新的承诺状态。</p><h1 id="b503" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第三部分:</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="750b" class="md kx jb lz b gy me mf l mg mh">const prom = new Promise((res, rej) =&gt; {<br/>  res('1');<br/>  rej('error');<br/>  res('2');<br/>});<br/><br/>prom<br/>  .then(res =&gt; {<br/>    console.log('then: ', res);<br/>  })<br/>  .catch(err =&gt; {<br/>    console.log('catch: ', err);<br/>  });<br/><br/>// then: 1</span></pre><p id="5e3e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk lz b">resolve</code>或<code class="fe mi mj mk lz b">reject</code>仅执行一次，即使在拒绝后有解决调用。它不会执行。</p><h1 id="55d6" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第四部分:</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="7d16" class="md kx jb lz b gy me mf l mg mh">Promise.resolve(1)<br/>  .then(res =&gt; {<br/>    console.log(res);<br/>    return 2;<br/>  })<br/>  .catch(err =&gt; {<br/>    return 3;<br/>  })<br/>  .then(res =&gt; {<br/>    console.log(res);<br/>  });<br/><br/>// 1<br/>// 2</span></pre><p id="9f4e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">承诺是可以连锁的。当提到连锁调用时，我们通常会想到返回这个，但承诺不会。每次一个承诺调用<code class="fe mi mj mk lz b">.then</code>或者<code class="fe mi mj mk lz b">.catch</code>，都会返回一个新的承诺，这样就实现了链式调用。</p><h1 id="b611" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第五部分:</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="ac2c" class="md kx jb lz b gy me mf l mg mh">const promise = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    console.log('first')<br/>    resolve('second')<br/>  }, 1000)<br/>})<br/><br/>const start = Date.now()<br/>promise.then((res) =&gt; {<br/>  console.log(res, Date.now() - start, "third")<br/>})<br/>promise.then((res) =&gt; {<br/>  console.log(res, Date.now() - start, "fourth")<br/>})<br/><br/>// first<br/>// second 1054 third<br/>// second 1054 fourth</span></pre><p id="ca64" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">promise <code class="fe mi mj mk lz b">.then</code>或<code class="fe mi mj mk lz b">.catch</code>可以被多次调用，但是这里promise构造函数只被执行一次。换句话说，一旦一个承诺的内部状态发生变化并获得一个值，那么随后对<code class="fe mi mj mk lz b">.then</code>或<code class="fe mi mj mk lz b">.catch</code>的每次调用都将直接获得该值。</p><h1 id="f988" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第六部分:</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="43ab" class="md kx jb lz b gy me mf l mg mh">const promise = Promise.resolve()<br/>  .then(() =&gt; {<br/>    return promise<br/>  })<br/>promise.catch(console.error)<br/><br/>// [TypeError: Chaining cycle detected for promise #&lt;Promise&gt;]<br/>// Uncaught SyntaxError: Identifier 'promise' has already been declared<br/>//    at &lt;anonymous&gt;:1:1<br/>// (anonymous) @ VM218:1</span></pre><p id="c4b1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk lz b">.then</code>或<code class="fe mi mj mk lz b">.catch</code>返回的值不能是承诺本身，否则会造成无限循环。</p><h1 id="84c5" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第七部分:</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="c62a" class="md kx jb lz b gy me mf l mg mh">Promise.resolve()<br/>  .then(() =&gt; {<br/>    return new Error('error');<br/>  })<br/>  .then(res =&gt; {<br/>    console.log('then: ', res);<br/>  })<br/>  .catch(err =&gt; {<br/>    console.log('catch: ', err);<br/>  });<br/><br/>// then: Error: error!<br/>// at Promise.resolve.then (...)<br/>// at ...</span></pre><p id="e722" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mi mj mk lz b">.then</code>或<code class="fe mi mj mk lz b">.catch</code>中返回一个错误对象并不会抛出错误，所以不会被后续的<code class="fe mi mj mk lz b">.catch</code>捕获，需要改为其中一个:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="2397" class="md kx jb lz b gy me mf l mg mh">return Promise.reject(new Error('error')) throw new Error('error')</span></pre><p id="0aa4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为返回任何非promise值都会被包装到一个promise对象中，即return new Error ('error ')等价于return promise . resolve(new Error(' Error '))。</p><h1 id="5fe5" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第八部分:</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="11d2" class="md kx jb lz b gy me mf l mg mh">Promise.resolve(1)<br/>  .then(2)<br/>  .then(Promise.resolve(3))<br/>  .then(console.log)<br/><br/>  // 1</span></pre><p id="e4e0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">的论点。然后还是。catch应该是一个函数，传入一个非函数会导致value的结果被忽略比如<code class="fe mi mj mk lz b">.then(2)</code>或者<code class="fe mi mj mk lz b">.then(Promise.resolve(3)</code>。</p><h1 id="b48a" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第九部分:</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="324a" class="md kx jb lz b gy me mf l mg mh">Promise.resolve()<br/>  .then(<br/>    function success(res) {<br/>      throw new Error('Error after success');<br/>    },<br/>    function fail1(e) {<br/>      console.error('fail1: ', e);<br/>    }<br/>  )<br/>  .catch(function fail2(e) {<br/>    console.error('fail2: ', e);<br/>  });<br/><br/>//   fail2:  Error: Error after success<br/>//     at success (&lt;anonymous&gt;:4:13)</span></pre><p id="319e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk lz b">.then</code>可以接受两个参数，第一个是处理成功的函数，第二个是处理错误的函数。<code class="fe mi mj mk lz b">.catch</code>是写<code class="fe mi mj mk lz b">.then</code>第二个参数的方便方式，但是在使用中有一点要注意:<code class="fe mi mj mk lz b">.then</code>第二个错误处理函数不能捕捉到第一个成功的函数和后续的函数抛出的错误。catch捕获以前的错误。当然，如果您想重写，下面的代码是有效的:</p><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="64ef" class="md kx jb lz b gy me mf l mg mh">Promise.resolve()<br/>  .then(function success1 (res) {<br/>    throw new Error('success1 error')<br/>  }, function fail1 (e) {<br/>    console.error('fail1: ', e)<br/>  })<br/>  .then(function success2 (res) {<br/>  }, function fail2 (e) {<br/>    console.error('fail2: ', e)<br/>  })</span></pre><h1 id="16cb" class="kw kx jb bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">第10部分:</h1><pre class="lu lv lw lx gt ly lz ma mb aw mc bi"><span id="6e83" class="md kx jb lz b gy me mf l mg mh">process.nextTick(() =&gt; {<br/>  console.log('1')<br/>})<br/>Promise.resolve()<br/>  .then(() =&gt; {<br/>    console.log('2')<br/>  })<br/>setImmediate(() =&gt; {<br/>  console.log('3')<br/>})<br/>console.log('4');<br/><br/>// Print 4<br/>// Print 1<br/>// Print 2<br/>// Print 3</span></pre><p id="3e09" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mi mj mk lz b">process.nextTick</code>和<code class="fe mi mj mk lz b">promise.then</code>都属于微任务，而<code class="fe mi mj mk lz b">setImmediate</code>属于宏任务，在事件循环的检查阶段执行。在事件循环(macrotask)的每个阶段之间执行一次microtask，事件循环的开始执行一次。</p></div></div>    
</body>
</html>