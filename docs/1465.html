<html>
<head>
<title>Handle API calls using async await with the useEffect hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用带有useEffect挂钩的异步await处理API调用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/handling-api-calls-using-async-await-in-useeffect-hook-990fb4ae423?source=collection_archive---------0-----------------------#2020-03-19">https://javascript.plainenglish.io/handling-api-calls-using-async-await-in-useeffect-hook-990fb4ae423?source=collection_archive---------0-----------------------#2020-03-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="96af" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解对useEffect函数直接使用async关键字的问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/646e778240c74ec2751c83a63b0ffc10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nUHiscLsztYADsMk"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clément H</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="53ac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您是<code class="fe ls lt lu lv b">async await</code>语法的粉丝，您可以尝试在<code class="fe ls lt lu lv b">useEffect</code> hook中使用它，但是它并不像预期的那样工作。在本文中，我们将看到如何处理这个问题。</p><p id="f5aa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们先用promises写一些代码，然后我们将把它转换成async-await。</p><p id="8bd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将调用API来显示10个随机用户。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="4da7" class="ma mb iq lv b gy mc md l me mf">useEffect(() =&gt; {<br/> axios.get('https://randomuser.me/api/?page=1&amp;results=10&amp;nat=us')<br/>  .then(response =&gt; {<br/>   setUsers(response.data.results);<br/> });<br/>}, []);</span></pre><p id="5afd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">演示:<a class="ae kv" href="https://codesandbox.io/s/laughing-bhaskara-dwi0d" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/laughing-bhaskara-dwi0d</a></p><p id="441e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个<code class="fe ls lt lu lv b">useEffect</code>钩子中，我们提供了一个空数组<code class="fe ls lt lu lv b">[]</code>作为第二个参数，这样当组件被挂载时<code class="fe ls lt lu lv b">useEffect</code>中的代码将只运行一次，这是在react钩子中实现<code class="fe ls lt lu lv b">componentDidMount</code>生命周期方法的一种方式。</p><p id="677f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们将相同的代码转换为异步await语法。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="9abe" class="ma mb iq lv b gy mc md l me mf">useEffect(async () =&gt; {<br/>  const users = await axios.get("https://randomuser.me/api/?page=1&amp;results=10&amp;nat=us");<br/>  setUsers(users.data.results);<br/>}, []);</span></pre><p id="9b41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">演示:<a class="ae kv" href="https://codesandbox.io/s/lively-sound-cw964" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/lively-sound-cw964</a></p><p id="ea68" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里，我们将<code class="fe ls lt lu lv b">useEffect</code>回调函数设为异步，这样我们就可以在其中使用await关键字。</p><p id="6ed2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您运行该应用程序，您将在控制台中看到一条警告</p><p id="3873" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现场演示:<a class="ae kv" href="https://cw964.csb.app/" rel="noopener ugc nofollow" target="_blank">https://cw964.csb.app/</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mg"><img src="../Images/739c1950f4a2d575a4af4dc23dc3e965.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ULdCWakD2jK9LrAO4J9Lw.png"/></div></div></figure><blockquote class="mh mi mj"><p id="54f4" class="kw kx mk ky b kz la jr lb lc ld ju le ml lg lh li mm lk ll lm mn lo lp lq lr ij bi translated">在React中，用红色显示的每个警告都应该被修复，因为它可能会影响性能或应用程序行为，或者可能是改进应用程序的建议。</p></blockquote><p id="6429" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mk">上面代码的问题是，当我们声明一个异步函数时，它会返回一个承诺</em></p><p id="15a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看看下面的代码。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="9403" class="ma mb iq lv b gy mc md l me mf">const getResults = async () =&gt; { return "Hello"; };</span><span id="2076" class="ma mb iq lv b gy mo md l me mf">const App = () =&gt; {<br/> const result = getResults();<br/> console.log(result);<br/> return null;<br/>};</span></pre><p id="6c65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">演示:<a class="ae kv" href="https://codesandbox.io/s/busy-rgb-pdqgz" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/busy-rgb-pdqgz</a></p><p id="baff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您打开控制台，您会看到，打印的结果不是字符串“Hello ”,而是一个承诺。</p><p id="946c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了获得实际值，我们需要将<code class="fe ls lt lu lv b">then</code>处理程序附加到函数调用上。</p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="658c" class="ma mb iq lv b gy mc md l me mf">const getResults = async () =&gt; { return "Hello"; };</span><span id="4f66" class="ma mb iq lv b gy mo md l me mf">const App = () =&gt; {<br/> getResults().then(response =&gt; console.log(response));<br/> return null;<br/>};</span></pre><p id="b15e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">演示:<a class="ae kv" href="https://codesandbox.io/s/trusting-curran-5qorx" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/trusting-curran-5qorx</a></p><p id="6be9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们在控制台中获得了实际值“Hello”。</p><p id="a7dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mk">但是我们不能将</em> <code class="fe ls lt lu lv b"><em class="mk">then</em></code> <em class="mk">句柄附加到</em> <code class="fe ls lt lu lv b"><em class="mk">useEffect</em></code> <em class="mk">钩子上，因为传递给useEffect的函数除了清理效果函数</em>之外不应该返回任何东西</p><p id="626a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以有一些方法可以解决这个问题。</p><ol class=""><li id="17a8" class="mp mq iq ky b kz la lc ld lf mr lj ms ln mt lr mu mv mw mx bi translated"><strong class="ky ir">在useEffect之外创建一个单独的异步函数，并从useEffect: </strong>中调用它</li></ol><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="6d99" class="ma mb iq lv b gy mc md l me mf">const getUsers = async () =&gt; {<br/> const users = await axios.get('https://randomuser.me/api/?page=1&amp;results=10&amp;nat=us');<br/> setUsers(users.data.results);<br/>};</span><span id="6ef0" class="ma mb iq lv b gy mo md l me mf">useEffect(() =&gt; {<br/> getUsers();<br/>}, []);</span></pre><p id="cdc3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">演示:【https://codesandbox.io/s/eloquent-solomon-o32gn T2】</p><p id="4fce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<strong class="ky ir">在useEffect中创建一个单独的异步函数，并从useEffect中调用它:</strong></p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="c301" class="ma mb iq lv b gy mc md l me mf">useEffect(() =&gt; {<br/>  const getUsers = async () =&gt; {<br/>    const users = await axios.get("https://randomuser.me/api/?page=1&amp;results=10&amp;nat=us");<br/>    setUsers(users.data.results);<br/>  };</span><span id="8efd" class="ma mb iq lv b gy mo md l me mf">  getUsers();<br/>}, []);</span></pre><p id="e7c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">演示:<a class="ae kv" href="https://codesandbox.io/s/trusting-mclaren-p77vn" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/trusting-mclaren-p77vn</a></p><p id="19b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.<strong class="ky ir">使用IIFE(立即调用的函数表达式):</strong></p><pre class="kg kh ki kj gt lw lv lx ly aw lz bi"><span id="051b" class="ma mb iq lv b gy mc md l me mf">useEffect(() =&gt; {<br/> (async () =&gt; {<br/>  const users = await axios.get("https://randomuser.me/api/?page=1&amp;results=10&amp;nat=us");<br/>  setUsers(users.data.results);<br/> })();<br/>}, []);</span></pre><p id="3cd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">演示:<a class="ae kv" href="https://codesandbox.io/s/distracted-sky-d8qgn" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/distracted-sky-d8qgn</a></p><p id="998d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天到此为止。希望你今天学到了新东西。</p><p id="a062" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">别忘了订阅我的每周简讯，里面有惊人的技巧、窍门和文章，直接在这里的收件箱里</strong> <a class="ae kv" href="https://yogeshchavan.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">。</strong> </a></p></div></div>    
</body>
</html>