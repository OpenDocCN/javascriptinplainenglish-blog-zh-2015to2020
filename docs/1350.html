<html>
<head>
<title>A White Label Solution In Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角坐标中的白标解</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-white-label-solution-using-powerful-features-in-angular-7-517444f6fc9?source=collection_archive---------1-----------------------#2020-03-05">https://javascript.plainenglish.io/a-white-label-solution-using-powerful-features-in-angular-7-517444f6fc9?source=collection_archive---------1-----------------------#2020-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="29d5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">它允许你分享，重复使用和重新标记Angular应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c0e15353f6081dbb9425ec7fbba96c1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X9lSda-JgRRTvgMxQM7fvQ.png"/></div></div></figure><p id="be56" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本文中，我将介绍一个使用动态路由和延迟加载模块构建白标Angular应用的解决方案。</p><h2 id="6480" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">什么是白标App？</h2><p id="4e7c" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">白标应用是由一家公司制作的应用，并为其他公司重新贴牌，使产品看起来像他们自己的。</p><p id="cc8d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用白标App会省时省力(省钱)。大多数时候，变化是外观和感觉的定制，功能是基于现有的应用程序提供的。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="e58c" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">我想达到的目标</h2><p id="12d1" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在这个例子中，我想开发一个基于现有的Angular应用程序的白标应用程序。</p><p id="6fab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的目标是:</p><ol class=""><li id="f44c" class="ms mt iq kt b ku kv kx ky la mu le mv li mw lm mx my mz na bi translated">白色标签应用程序有自己的登录页面，具有定制的风格。</li><li id="6d6a" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">它可以与原始应用程序中的现有功能相同，也可以是其子集</li><li id="37bb" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">它可以作为一个独立的应用程序来构建和部署，分布式包应该只包含必要的代码。</li><li id="dd83" class="ms mt iq kt b ku nb kx nc la nd le ne li nf lm mx my mz na bi translated">最大化代码共享。</li></ol></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="8494" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">Angular应用</h2><p id="aa27" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">为了简单起见，示例Angular应用程序包含一个带有home组件的着陆模块和两个功能模块。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="46b4" class="ln lo iq nh b gy nl nm l nn no">| — app<br/>    | — Landing modules<br/>           |-- [+] home components<br/>           |-- default-landing-routing.module.ts<br/>           |-- default-landing.module.ts<br/>    | — feature1 modules<br/>           |-- [+] view1 components<br/>           |-- feature1-routing.module.ts<br/>           |-- feature1-landing.module.ts<br/>    | — feature2 modules<br/>           |-- [+] view2 components<br/>           |-- feature2-routing.module.ts<br/>           |-- feature2-landing.module.ts<br/>    | - app-routing.module.ts<br/>    | - app.module.ts<br/>    | - app-component.html<br/>    | - app.component.ts</span></pre><p id="358e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">新的白色标签应用程序是为“<code class="fe np nq nr nh b">abc</code>”公司制作的，它有自己的带有<code class="fe np nq nr nh b">AbcHome</code>组件的<code class="fe np nq nr nh b">abc-landing</code>模块。</p><p id="18f4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了识别原始应用程序与白标应用程序，添加了一个新的环境文件，该文件具有新的“<code class="fe np nq nr nh b">orgId</code>”属性。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="f95b" class="ln lo iq nh b gy nl nm l nn no">// environment.ts<br/>export const environment = { production: false, orgId: ‘default’};</span><span id="5795" class="ln lo iq nh b gy ns nm l nn no">// environment.abc.ts<br/>export const environment = {  production: false,  orgId: 'abc'};</span></pre><p id="2322" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了让Angular了解新的<code class="fe np nq nr nh b">abc </code>环境，我们需要将以下配置添加到Angular.json中</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="ef41" class="ln lo iq nh b gy nl nm l nn no">// angular.json<br/>configurations": {<br/>    ...,<br/>    "abc": {<br/>        "fileReplacements": [<br/>            {<br/>                "replace": "src/environments/environment.ts",<br/>                "with": "src/environments/environment.abc.ts"<br/>            }<br/>        ]<br/>    }<br/>}</span></pre><p id="ffa2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">配置完成后，我们可以通过下面的ng build命令为新环境构建一个<code class="fe np nq nr nh b">abc </code>应用程序。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="edf8" class="ln lo iq nh b gy nl nm l nn no">//package.json<br/>...<br/>  "start-abc": "ng serve -c abc",<br/>...<br/>   "build-abc": "ng build -c abc",</span></pre><p id="aa6a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当构建用于生产时，dist文件夹将包含带有<code class="fe np nq nr nh b">abc </code>配置的构建输出。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="7df6" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">动态路由</h2><p id="4cfa" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">动态路由是这个解决方案的关键。</p><p id="6a0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们为<code class="fe np nq nr nh b">abc </code>公司添加新的登陆模块。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="bff2" class="ln lo iq nh b gy nl nm l nn no">| — abc Landing modules<br/>           |-- [+] abc home components<br/>           |-- abc-landing-routing.module.ts<br/>           |-- abc-landing.module.ts</span></pre><p id="487f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，我们在App.module.ts中定义路由</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="36d3" class="ln lo iq nh b gy nl nm l nn no"><em class="nt">const routes: Routes = [<br/>{ path: '', data: {name: 'default', roles: ['all']}, redirectTo: 'home', pathMatch: 'full' },<br/>{ path: '</em><strong class="nh ir"><em class="nt">home</em></strong><em class="nt">', data: { name: 'home', </em><strong class="nh ir"><em class="nt">roles</em></strong><em class="nt">: ['default']},</em><strong class="nh ir"><em class="nt">loadChildren</em></strong><em class="nt">: () =&gt; import('./default-landing/default-landing.module').then(m =&gt; m.DefaultLandingModule) },<br/>{ path: '</em><strong class="nh ir"><em class="nt">home</em></strong><em class="nt">', data: { name: 'home', </em><strong class="nh ir"><em class="nt">roles</em></strong><em class="nt">: ['abc']},</em><strong class="nh ir"><em class="nt">loadChildren</em></strong><em class="nt">: () =&gt; import('./abc-landing/abc-landing.module').then(m =&gt; m.AbcLandingModule) }<br/>];</em></span></pre><p id="e9ee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这里，我们有两条“回家”路线，一条用于origin应用程序，另一条用于新的<code class="fe np nq nr nh b">abc </code>白标应用程序。两条“回家”路径是如何工作的？</p><p id="5851" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们使用APP_INITIALIZER令牌来挂钩角度引导过程。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="f560" class="ln lo iq nh b gy nl nm l nn no">providers: [{ provide: APP_INITIALIZER, useFactory: initApp, deps: [Injector], multi: true }]</span></pre><p id="4929" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在工厂函数“<code class="fe np nq nr nh b">initApp</code>”中，运行时通过环境设置“<code class="fe np nq nr nh b">orgId</code>”和先前定义的路线数据中的“<code class="fe np nq nr nh b">roles</code>”属性加载路线。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk">Init the dynamic routing</figcaption></figure><h2 id="664c" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">延迟加载模块</h2><p id="c9ce" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">您可能已经注意到，default-landing和<code class="fe np nq nr nh b">abc-landing</code>模块都是延迟加载模块，因为使用了“loadChildren”语法，后跟一个使用浏览器内置<code class="fe np nq nr nh b">import('...')</code>进行动态导入的函数。</p><p id="a1dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好处是延迟加载模块被构建到单独的小块中，而不是一个单独的包文件中。尽管特定于环境的模块都是在编译时构建的，但只有在导航到路由器时，它们才会被下载到浏览器。例如，当我们运行<code class="fe np nq nr nh b">abc </code>配置时，只有<code class="fe np nq nr nh b">abc-landing</code>模块会被加载，而默认着陆模块永远不会被调用，因为它不在路线中！</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="2869" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">代码共享</h2><p id="39e9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">由于所有的登陆模块都是“活”在一起的，它们可以根据需要访问/共享所有的代码。在本例中，白标应用程序在其子路线中使用功能1和功能2模块，以及默认应用程序。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ff27" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于白色标签应用程序有一个不同的“入口组件”:AbcHomeComponent，可以根据需要定制外观和感觉。它可以有自己的页眉/页脚组件和样式。我们还可以选择在白标App中使用或不使用哪些功能模块。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h2 id="77ba" class="ln lo iq bd lp lq lr dn ls lt lu dp lv la lw lx ly le lz ma mb li mc md me mf bi translated">摘要</h2><p id="9ccf" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在本文中，一个完全可定制的白标应用程序建立在现有代码基础之上。我们只是增加了一个新的登陆舱和一些配置。通过传递<code class="fe np nq nr nh b">— c</code>参数，origin应用和新的White label应用都可以构建为独立的应用，并部署在不同的web主机中。</p><p id="2634" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">希望这篇文章对任何打算构建多前端Angular App的人有所帮助。<a class="ae oa" href="https://github.com/sunnyy02/ngWhite/" rel="noopener ugc nofollow" target="_blank">源代码</a>可以在GitHub上获得。</p><p id="c989" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你喜欢这篇文章，你也可以看看下面的文章。</p><div class="ob oc gp gr od oe"><a rel="noopener  ugc nofollow" target="_blank" href="/angular-state-management-with-observable-service-pattern-27b18538f4c3"><div class="of ab fo"><div class="og ab oh cl cj oi"><h2 class="bd ir gy z fp oj fr fs ok fu fw ip bi translated">具有可观察服务模式的角度状态管理</h2><div class="ol l"><h3 class="bd b gy z fp oj fr fs ok fu fw dk translated">Angular状态管理是任何Angular应用程序的核心，但没有放之四海而皆准的解决方案。</h3></div><div class="om l"><p class="bd b dl z fp oj fr fs ok fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="on l"><div class="oo l op oq or on os kp oe"/></div></div></a></div></div></div>    
</body>
</html>