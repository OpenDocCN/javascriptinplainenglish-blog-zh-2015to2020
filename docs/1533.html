<html>
<head>
<title>Using React Strict Mode to Avoid Deprecated Code and Side Effects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React Strict模式避免不推荐使用的代码和副作用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-react-strict-mode-to-avoid-deprecated-code-and-side-effects-f8958324dd3c?source=collection_archive---------1-----------------------#2020-03-28">https://javascript.plainenglish.io/using-react-strict-mode-to-avoid-deprecated-code-and-side-effects-f8958324dd3c?source=collection_archive---------1-----------------------#2020-03-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f87f2a38cebc7c4dd428ec7f6923344f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RpTsdfKEeK_CG93x"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@introoke?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Julian Friedle</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9156" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建前端视图的库。它有一个庞大的图书馆生态系统与之合作。此外，我们可以用它来增强现有的应用程序。</p><p id="c50c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何使用React的严格模式来获得关于开发过程中不推荐使用的API和副作用的额外警告。</p><h1 id="ed1c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">严格模式</h1><p id="64f1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">严格模式是一种突出应用程序中潜在问题的工具。它不呈现任何可见的用户界面。</p><p id="533e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只用于为它的后代激活额外的检查和警告。</p><p id="c97a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">严格模式不影响生产版本。</p><p id="9e33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以向React应用程序添加严格模式，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c6f1" class="mn lc iq mj b gy mo mp l mq mr">class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;p&gt;foo&lt;/p&gt;<br/>        &lt;React.StrictMode&gt;<br/>          &lt;p&gt;bar&lt;/p&gt;<br/>        &lt;/React.StrictMode&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="e355" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，带有‘foo’的<code class="fe ms mt mu mj b">p</code>标签没有被严格模式检查，因为它在<code class="fe ms mt mu mj b">React.StrictMode</code>组件之外，但是里面的<code class="fe ms mt mu mj b">p</code>元素被严格模式检查。</p><h1 id="9960" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">识别不安全的生命周期</h1><p id="9af5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">严格模式检查不安全的生命周期。一些生命周期方法正在被否决，因为它们鼓励不安全的编码实践。</p><p id="7f9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们是:</p><ul class=""><li id="81d0" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><code class="fe ms mt mu mj b">componentWillMount</code></li><li id="6385" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">componentWillReceiveProps</code></li><li id="45c3" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">componentWillUpdate</code></li></ul><p id="e3bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">前缀<code class="fe ms mt mu mj b">UNSAFE_</code>将在即将发布的版本中添加。</p><p id="7be5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2新的生命周期方法正在取代上述方法。它们是静态的<code class="fe ms mt mu mj b">getDerivedStateFromProps</code>和<code class="fe ms mt mu mj b">getSnapshotBeforeUpdate</code>方法。</p><p id="67cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">getSnapshotBeforeUpdate</code>在进行突变之前调用lifecycle，其返回值将作为第三个参数传递给<code class="fe ms mt mu mj b">componentDidUpdate</code>。</p><p id="55ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">getSnapshotBeforeUpdate</code>和<code class="fe ms mt mu mj b">componentDidUpdate</code>一起涵盖了<code class="fe ms mt mu mj b">componentWillUpdate</code>的所有用例。</p><p id="71ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">严格模式将警告旧的生命周期钩子的废弃。</p><h1 id="9079" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关于旧字符串引用API用法的警告</h1><p id="e862" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">此外，React strict模式将警告在我们的代码中使用字符串引用。</p><p id="30f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不推荐使用字符串引用，因为它们不能被静态类型化。它们需要始终保持一致。神奇的动态字符串打破了虚拟机中的优化，它只在一个层面上有效。</p><p id="c687" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不能像回调和对象引用那样传递它。</p><p id="1c6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，它会警告我们关于字符串引用的用法，因为它们已被弃用。</p><p id="1b32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将来还支持回调引用和<code class="fe ms mt mu mj b">createRef</code>。</p><h1 id="3823" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关于已弃用的findDOMNode用法的警告</h1><p id="b265" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">不推荐使用<code class="fe ms mt mu mj b">findDOMNode</code>方法。我们可以用它来搜索给定类实例的DOM节点。</p><p id="be59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不需要这样做，因为我们可以将一个引用附加到一个DOM节点。</p><p id="81ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只返回第一个孩子，但是一个组件可以使用片段来呈现多个DOM级别。</p><p id="f484" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，它现在不是很有用，因为它只搜索一个级别，我们可以使用ref来获得我们正在寻找的确切元素。</p><p id="8fbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在包装元素上附加一个<code class="fe ms mt mu mj b">ref</code>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4bb0" class="mn lc iq mj b gy mo mp l mq mr">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.wrapper = React.createRef();<br/>  }<br/>  render() {<br/>    return &lt;div ref={this.wrapper}&gt;{this.props.children}&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="9c34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们不想包装<code class="fe ms mt mu mj b">div</code>来呈现，如果我们不想让节点成为布局的一部分，我们可以在CSS中设置<code class="fe ms mt mu mj b">display: contents</code>。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/f3d34e800848718c643e0b7a7096b98b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lA_qo79Wt1el8tsR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@timonrets?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Timo Stern</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="9aa7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检测意外的副作用</h1><p id="c35d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">React分两个阶段工作:</p><ul class=""><li id="fa13" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">呈现阶段对DOM进行任何更改。React在这个阶段调用<code class="fe ms mt mu mj b">render</code>，然后将结果与之前的渲染进行比较。</li><li id="b60f" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">提交阶段运行任何生命周期方法来应用任何所需的更改。</li></ul><p id="1126" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">渲染阶段生命周期包括以下类组件方法:</p><ul class=""><li id="42db" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><code class="fe ms mt mu mj b">constructor</code></li><li id="a196" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">componentWillMount</code></li><li id="dac8" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">componentWillReceiveProps</code></li><li id="411d" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">componentWillUpdate</code></li><li id="f15a" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">getDerivedStateFromProps</code></li><li id="0e44" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">shouldComponentUpdate</code></li><li id="a9f8" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">render</code></li><li id="dfc2" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">setState</code></li></ul><p id="011f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为它们可能被调用不止一次，所以它们不应该产生任何副作用。忽略这条规则可能会导致内存泄漏和应用程序状态无效等问题。</p><p id="9bcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">严格模式通过运行以下方法两次来检查是否有副作用:</p><ul class=""><li id="4e7a" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">类组件<code class="fe ms mt mu mj b">constructor</code>方法</li><li id="c109" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">render</code>方法</li><li id="04f4" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe ms mt mu mj b">setState</code></li><li id="4f5d" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">静态<code class="fe ms mt mu mj b">getDerivedStateFromProps</code>生命周期</li></ul><h1 id="3b62" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检测旧上下文API</h1><p id="78a1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">严格模式将检测旧上下文API的使用。它将在未来版本中被删除。如果它是用过的，我们应该搬到新的。</p><h1 id="d6e8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="f461" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用严格模式来检测弃用的生命周期方法、遗留上下文API、字符串引用和一些会产生意外副作用的代码的使用。</p><p id="d9af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只显示开发中的警告，不影响生产代码。</p></div></div>    
</body>
</html>