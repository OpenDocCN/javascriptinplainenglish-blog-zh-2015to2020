<html>
<head>
<title>How to Query the Full History of Your JSON Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何查询JSON数据库的完整历史</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/query-the-full-history-of-your-json-database-6585ac8fed9b?source=collection_archive---------6-----------------------#2020-10-07">https://javascript.plainenglish.io/query-the-full-history-of-your-json-database-6585ac8fed9b?source=collection_archive---------6-----------------------#2020-10-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5baa841d44a561ba2fd8182566e48147.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nREytY-M4Bkq3D6pyCpB8g.jpeg"/></div></div></figure><figure class="jw jx jy jz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jv"><img src="../Images/f4af62ae6917e88b1b99baa73fce3a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NiIJH8obQlntk0Cb"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk">Evolution of states through modifications and commits in SirixDB</figcaption></figure><p id="5ca2" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated"><strong class="kg io">有助于进化，只积累数据库系统称为</strong> <a class="ae lc" href="https://github.com/sirixdb/sirix" rel="noopener ugc nofollow" target="_blank"> <strong class="kg io"> SirixDB </strong> </a> <strong class="kg io">和以</strong> <a class="ae lc" href="https://github.com/sirixdb/sirix" rel="noopener ugc nofollow" target="_blank"> <strong class="kg io">为基础的前端</strong> </a></p><h1 id="2722" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">介绍</h1><p id="336e" class="pw-post-body-paragraph ke kf in kg b kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx mf kz la lb ig bi translated">首先，您可能不需要数据库系统来处理小的JSON文件，范围从几兆字节。</p><p id="3b90" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">但是，如果您必须管理和查询千兆字节的数据，您应该使用数据库系统。</p><p id="95cd" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">然而，通常数据库系统并不是为保存数据的完整历史而设计的。通常，系统会在更改过程中覆盖数据或短时间保留数据。后者通常由于事务而发生，事务当前读取稍微过时的数据。因此，垃圾收集器必须等到所有读取事务完成。然后，它能够删除旧数据。</p><p id="ffab" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">相反，<a class="ae lc" href="https://sirix.io" rel="noopener ugc nofollow" target="_blank"> SirixDB </a>生成了一个巨大的持久树，在提交期间是持久的。它只追加数据。每个修订都被索引，而修订共享未改变的页面片段。可以把它想象成Git，但是是在子文件级别。持久树在函数式语言中也很常见，比如Haskell和Closure。下图描述了在后序遍历中序列化页面的事务提交:</p><figure class="jw jx jy jz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/4f1c859e1955ba0db61d91b614124b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NrRTPt95l1ozqF6V"/></div></div><figcaption class="ka kb gj gh gi kc kd bd b be z dk">Two revisions — second commit</figcaption></figure><p id="9e3d" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">通常，将这些持久的内存结构映射到持久的设备会增加写入放大，因为必须适应完整的叶到根路径。然而，我们在主文档存储中使用了键控trie。因此，不会像B树那样发生结构变化。此外，我们开发了一种新的滑动快照算法来对数据页面进行版本化，并存储可变大小的页面片段。因此，只有少数更改的记录被写入新的页面片段。重构内存中的页面包括从随机位置并行读取页面片段的滑动窗口。</p><p id="a682" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">由于对快速、随机、细粒度读取的要求，字节可寻址NVM等现代硬件对于良好的性能至关重要。</p><p id="616b" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">SirixDB以二进制格式存储JSON数据，而每个事务都绑定到一个特定的修订版。目前，一个资源上的N个只读事务可以与一个资源上的一个读写事务共存(表示JSON数据)。</p><p id="40c9" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">编码如下，只是我们最近还引入了一个从父节点指向最后一个子节点的指针。</p><figure class="jw jx jy jz gt jo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/7e1e9276dc7b52016f0c764d06811937.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/0*QtzkGjZ9byxULSa8.png"/></div></figure><h1 id="4627" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">查询您的数据</h1><p id="a30b" class="pw-post-body-paragraph ke kf in kg b kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx mf kz la lb ig bi translated">该系统使用并扩展了XQuery 3.0处理器来处理XML和JSON数据。</p><p id="a3be" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">我们能够通过以下方式从特定目录导入JSON文件:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="490a" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">它将创建一个名为<code class="fe mk ml mm mn b">mycol.jn</code>的数据库和几个资源。</p><p id="1ebb" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">我们还可以在数据库(mycol.jn)的几个资源中存储一组JSON字符串:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="66e7" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">注意，当JSON-strings出现时，我们必须用<code class="fe mk ml mm mn b">true()</code>和<code class="fe mk ml mm mn b">false()</code>替换<code class="fe mk ml mm mn b">true</code>和<code class="fe mk ml mm mn b">false</code>，用<code class="fe mk ml mm mn b">jn:null()</code>替换<code class="fe mk ml mm mn b">null</code>。</p><p id="1418" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">然后，我们可以通过以下方式查询数据库集合:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="7a52" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">或者，如果我们想打开数据库中的特定资源，我们可以使用:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="43a7" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">此外，我们可以更新资源。假设我们有下面的小JSON文件:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="d07c" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">我们可以插入一个JSON对象:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="a7bb" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">我们用<code class="fe mk ml mm mn b">=&gt;</code>操作符取消对对象字段名的引用。它甚至可以深入数组，找到字段名的值。</p><p id="51b6" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">更新操作将用字段名和添加的值创建一个新的版本。例如</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="0e55" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">将选择数组中第一个对象的值的字段名<code class="fe mk ml mm mn b">tada</code>。</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="6b73" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">我们隐式查询修订版2。如果我们改为查询修订版1，我们仍然会检索旧的JSON对象。</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="6eeb" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">请注意，我们将one指定为函数的第三个参数。输出是:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9d57" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">除了向第三个参数提供数值，我们还可以通过时间戳打开特定的修订(这里:检查特定资源在2018年4月的情况):</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="e346" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">使用open-revisions函数，我们能够加载两个时间点之间资源的所有修订:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9f8a" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">以下查询将把一个对象作为第二项插入到由<code class="fe mk ml mm mn b">=&gt;foo</code>取消引用的数组值中:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="d5e4" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">使用</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="db63" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">我们得到输出:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="d6c0" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">同样，我们可以用以下内容替换JSON值</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="4549" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">或者删除一个值:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="66cf" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">如果您通过REST-API提交查询，您首先必须获得授权。因此，Git中的修订版也存储作者姓名和UUID。</p><p id="747b" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">要获得提交特定修订的作者姓名:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b61c" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">要获得UUID奖:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="f593" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">您还可以投影字段:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="c940" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">这将输出:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="b916" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">时间旅行功能</h1><p id="9829" class="pw-post-body-paragraph ke kf in kg b kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx mf kz la lb ig bi translated">此外，我们可以使用一系列时间旅行查询。以下函数检索不同版本的JSON项目:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="2945" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">用于选择未来或未来自我的json-item的函数。第一个参数是上下文项。第二个参数表示当前项是否应该包含在结果中。</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="dcab" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">用于选择过去或过去或自我的json项的功能。第一个参数是上下文项。第二个参数表示当前项是否应该包含在结果中。</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="64cd" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">用于在所有修订中选择json-item的功能。</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="56c2" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">用于在第一次修订中选择json-item的功能。</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="c2be" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">用于选择最后/最近版本中的json-item的功能。</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="38f8" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">用于选择先前版本中的json-item的功能。</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="718f" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">用于在下一版本中选择json-item的功能。</p><p id="8b4f" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">要在所有修订版本中获取某个物件，请执行以下操作:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="2d97" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">差异</h1><p id="3b78" class="pw-post-body-paragraph ke kf in kg b kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx mf kz la lb ig bi translated">我们当然也能够检索差异:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="432c" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">该函数比较名为<code class="fe mk ml mm mn b">myresource2</code>的资源的版本1和版本3。</p><p id="d8da" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">输出格式是JSON字符串:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="8765" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">例如，我们的也使用这种格式，我们目前基于<strong class="kg io"> Svelte </strong>开发这种格式。</p><p id="f044" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">它表示SirixDB比较了修订版1和3。此外，不同的diff类型是<code class="fe mk ml mm mn b">insert, delete, update and replace</code>(后者未示出)。<code class="fe mk ml mm mn b">insertPositionNodeKey</code>是上下文节点，在这里插入发生，<code class="fe mk ml mm mn b">insertPosition</code>表示它是作为第一个孩子、作为右兄弟还是左兄弟插入的。</p><p id="bf4b" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">我们还可以区分一个子树并指定两个附加参数。将要进行比较的<code class="fe mk ml mm mn b">root node</code>和<code class="fe mk ml mm mn b">depth</code>:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="95f3" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">这也比较了<code class="fe mk ml mm mn b">mydocs.col</code>数据库中<code class="fe mk ml mm mn b">myresource2</code>资源的版本1和版本3。然而，这一次，差异从节点开始，由它唯一的nodeKey 7453表示。此外，区分应该跳过比2级更深的后代。</p><p id="8408" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">为了得到某个特定项的<code class="fe mk ml mm mn b">nodeKey</code>，我们可以使用:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><h1 id="4001" class="ld le in bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="4937" class="pw-post-body-paragraph ke kf in kg b kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx mf kz la lb ig bi translated">SirixDB提供了查询数据完整历史的强大方法。</p><p id="e37c" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">我们省略了索引结构的创建，但是您也可以使用XQuery创建二级索引结构，这也是自动版本化的。</p><p id="48da" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">考虑下面的文档(带有两个修订版的序列化SirixDB资源):</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="b9dd" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">我们可以创建内容和结构(CAS)索引，如下所示:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="7b80" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">为了回答这个问题</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure><p id="9bcc" class="pw-post-body-paragraph ke kf in kg b kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb ig bi translated">此外，我们没有提到FLOWR表达式，它是XQuery的基石。一个简单的隐式连接示例:</p><figure class="jw jx jy jz gt jo"><div class="bz fp l di"><div class="mi mj l"/></div></figure></div></div>    
</body>
</html>