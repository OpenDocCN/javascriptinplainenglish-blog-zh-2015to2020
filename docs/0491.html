<html>
<head>
<title>Architecture of a web application built with Svelte</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Svelte构建的web应用程序的架构</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/architecture-of-a-web-application-built-with-svelte-1ea9614228f4?source=collection_archive---------1-----------------------#2019-10-28">https://javascript.plainenglish.io/architecture-of-a-web-application-built-with-svelte-1ea9614228f4?source=collection_archive---------1-----------------------#2019-10-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a746b1a3c44c3328d7d8fc6919e22fa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ldjKFBthtSWX-FidEupsFg.png"/></div></div></figure><p id="d61b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过这篇文章，我想让你和我一起踏上一段旅程。这个旅程是关于发展一套规则，以利用过去两年中最令人惊叹的新软件开发工具之一。</p><h1 id="23f5" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">放弃</h1><p id="59d1" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">作为一名架构师，我有时必须提供代码来说明想法背后的概念。但是不要指望我解释这些代码是如何工作的以及为什么工作。你会找到很多比我更好的资源。</p><h1 id="c78a" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">介绍</h1><p id="2862" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">当我偶然发现<a class="ae lw" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">苗条的</strong> </a>时，我被拥有一种构建web应用程序的新方法的前景迷住了。首先吸引我的是用html编写代码的自然习惯——不像在React、Vue或Angular等熟悉的框架中那样被复杂的结构所困扰。</p><p id="a8c2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我开始研究<a class="ae lw" href="https://svelte.dev/docs" rel="noopener ugc nofollow" target="_blank">文档</a>，遵循<a class="ae lw" href="https://svelte.dev/tutorial" rel="noopener ugc nofollow" target="_blank">教程</a>和<a class="ae lw" href="https://svelte.dev/examples" rel="noopener ugc nofollow" target="_blank">示例</a>，尝试<a class="ae lw" href="https://svelte.dev/repl" rel="noopener ugc nofollow" target="_blank"> REPL </a>编写我的第一个简单应用程序——姑且称之为<em class="lx">App.html</em>。</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="c02a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这三个块很容易识别:任何要在屏幕上绘制的<em class="lx"> html </em>元素、<em class="lx">T38】style/&gt;</em>来定义相应的css，以及<em class="lx"> &lt; script/ &gt; </em>来用JavaScript编写所需的代码。</p><p id="9a3e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是这个片段不能在浏览器中运行。它有一个事件处理程序<em class="lx"> {clicked} </em>的快捷方式，必须先翻译。这就是苗条的人在幕后做的事情。它将代码编译到一个浏览器友好的环境中，翻译快捷方式并将所有部分放置到位。</p><p id="82db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看一个简单的起点<em class="lx">index.html</em></p><pre class="ly lz ma mb gt me mf mg mh aw mi bi"><span id="d5c9" class="mj ku in mf b gy mk ml l mm mn">&lt;!doctype html&gt;<br/>&lt;html&gt;<br/>&lt;head&gt;<br/> &lt;meta charset='utf8'&gt;<br/> &lt;meta name='viewport' content='width=device-width'&gt;<br/> &lt;title&gt;Conway's Game of Life&lt;/title&gt;<br/> &lt;link rel='stylesheet' href='global.css'&gt;<br/> &lt;link rel='stylesheet' href='bundle.css'&gt;<br/> &lt;script defer src='bundle.js'&gt;&lt;/script&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="0f3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了提供这个html文件，Svelte需要编译并将<strong class="jx io"> html </strong>和<strong class="jx io"> JavaScript代码</strong>捆绑到<em class="lx"> bundle.js </em>中，将<strong class="jx io"> css代码</strong>捆绑到<em class="lx"> bundle.css </em>中。瞧啊。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><p id="edc8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在可以愉快地开始编码了——用这三个块填充我们的<em class="lx">App.html</em>。Svelte并没有规定你如何构建你的代码。它只是一个工具，让你找到自己的方式作为一个编码和生产纯html之后，直接在浏览器中运行。让我们看看如何将应用程序分割成可理解的部分。</p><h1 id="0449" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">成分</h1><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="cb3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">亲爱的，我把应用程序缩小了！</p><p id="8b40" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lx">App.html</em>现在使用组件<em class="lx">Button.html</em>(<em class="lx">导入按钮… </em>)公开他的名字(<em class="lx">导出字母名字</em>)并传播由父组件<em class="lx"> {clicked} </em>处理的on:click事件。<br/>为了容易区分组件和原生html元素，它们的名称必须大写，如<em class="lx">&lt;</em><strong class="jx io"><em class="lx">B</em></strong><em class="lx">按钮……/&gt;</em>。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><p id="3bd9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个非常简单的例子，仅仅是闻到奥斯曼厨房里的香草味。我建议你去看看更复杂的一种，找出它不同的味道。为此，我编写了一个web应用程序，以朴实无华的可视化方式展示了“<a class="ae lw" href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life#Rules" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">【康威的人生游戏】</strong> </a>”。对<a class="ae lw" href="https://github.com/jcschmidig/Game-of-Life" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">完整源代码</strong> </a>感兴趣请点击链接。您还可以在这个<a class="ae lw" href="https://jsfiddle.net/vq341tcd/1/embedded/result/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> jsfiddle </strong> </a>中找到生成的html页面。</p><h1 id="bc8b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">作文</h1><p id="dfe8" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这个“单人游戏”由三部分组成:</p><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/31ee59695b8e47e812500f5128a86704.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5gqyXJlVW1Vn4o5kh4kOAA.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Starting conditions (&lt;Start/&gt;; Start.html)</figcaption></figure><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/288f98384d629e82c71e4f80807cf244.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-TR1YBcSaLBFRxWRTT2ghw.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Game button and statistics (&lt;Game/&gt;; Game.html)</figcaption></figure><figure class="ly lz ma mb gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/30a1141298f554f395cda954ccc85803.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y809BpFVmD8wcmNiDI8JLQ.png"/></div></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">Board with its fields (&lt;Board/&gt;; Board.html)</figcaption></figure><p id="217f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如你可能猜到的，所有三个部分都在<em class="lx">App.html</em>中构建自己的组件</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="mw mx gj gh gi my mz bd b be z dk">App.html</figcaption></figure><p id="d307" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你在这里看到的应该已经很熟悉了。三个组件&lt;<em class="lx"> Start/ &gt; </em>、&lt; <em class="lx"> Game/ &gt; </em>和&lt; <em class="lx"> Board/ &gt; </em>被给定一些输入数据，并传播不同的事件，这些事件必须由父应用程序(<em class="lx">App.html，参见下面的</em>)。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><p id="e29d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这个相当大的介绍之后，我想继续我答应你要制定的规则。背后的原因是，<strong class="jx io"> Svelte </strong>是一个工具，在推荐某些行为的同时，并没有也无法强制执行我提议你的严格使用。</p><h1 id="8241" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">规则1:使用流量控制</h1><p id="f8e0" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">必须有一个地方来控制应用程序的流程。这通常是集成组件的事件被分派到的根组件。让我们看另一个例子，通过<Start/>组件的透镜减少App.html:</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="8418" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lx"> &lt; Start/ &gt; </em>组件有一个绑定到<em class="lx"> {dimension} </em>的输入字段和一个<em class="lx">on:click</em>event { create board }触发(<em class="lx"> dispatches </em>)父组件上的<strong class="jx io"><em class="lx"/></strong>事件，其参数为<strong class="jx io"> dimension </strong>(板长)。</p><p id="04f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种结构自然地让信息从一个组件流向另一个组件。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="4530" class="kt ku in bd kv kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq bi translated">规则2:保持关注点的分离</h1><p id="bb7c" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">通过对不同的任务严格使用不同的组件，我们可能能够单独构建有用的模块，以便在许多不同的情况下很好地集成。</p><p id="2be0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们已经看到的，这样一个组成部分</p><ul class=""><li id="e860" class="nh ni in jx b jy jz kc kd kg nj kk nk ko nl ks nm nn no np bi translated">公开了一个默认的html、css和数据接口(<em class="lx"> export let &lt; var &gt; </em>)，这些接口可以导入到任何其他组件中(<em class="lx">import&lt;Component&gt;from……</em>)。</li><li id="cdce" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated">将(<em class="lx"> on:click </em>)或调度(<em class="lx">on:click = {&lt;method&gt;}</em>)事件传播到父组件，使流程在一个地方得到控制。</li></ul><p id="1e8a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">但还有更多。</strong> <br/>下面的代码片段显示了一个组件<strong class="jx io"><em class="lx">Measure.html</em></strong>，正如您所料，它能够启动和停止计时器，并返回上次运行的差值。<br/>首先，您会发现默认的组件界面通常包含html、css和脚本。<br/>其次，还有另一个<em class="lx"> &lt;脚本&gt; </em>标签，增加了属性<em class="lx"> context="module "。</em>虽然保存在同一个文件中，但是本节中的JavaScript代码没有连接到默认组件接口，必须完全独立地实现。</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="0e5b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">其主要目的是映射支持组件可视化的逻辑。在这种情况下，它公开了一个<em class="lx"> createMeasure </em>函数，返回一个用JavaScript对象封装的接口。</p><p id="7760" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下代码片段显示了该组件在<em class="lx">App.html</em>中的用法:</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="bad4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在你可以看到<em class="lx">Measure.html</em>是如何服务于其他组件的。由<em class="lx">App.html(create measure)</em>实例化，通过事件由<em class="lx">棋盘</em>组件启动和停止，最后由<em class="lx">游戏</em>组件通过<em class="lx"> showDiff </em>变量显示。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="16b1" class="kt ku in bd kv kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq bi translated">规则3:维护状态</h1><p id="451d" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><strong class="jx io">斯韦特的</strong>最大优势在于其反应性。这自然是通过以下方式实现的</p><ul class=""><li id="ed35" class="nh ni in jx b jy jz kc kd kg nj kk nk ko nl ks nm nn no np bi translated">观察默认组件界面的任意变量(<em class="lx">导出让&lt;变量&gt; </em>)</li><li id="5537" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated">使用特殊语法指定附加观察值(<em class="lx"> $: var= &lt;值&gt;，</em>见下文)</li></ul><p id="dcf3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦这些可观察到的东西发生了变化，依赖于其中一个的每个组件都会立即更新。</p><p id="0474" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">举个例子，我们来看看<em class="lx">板卡</em>组件使用的<em class="lx"> Field </em>组件的镜头，该组件由<em class="lx"> App </em>组件控制。</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="4d9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lx"> Board </em>组件暴露了一个参数(<em class="lx"> export let rows </em>，见下文)由<em class="lx">App.html</em>用来初始化该板(<em class="lx">&lt;Board { rows }……/&gt;</em>)。在任何事件(清除、创建、翻转)中，<em class="lx">板</em>变量是新设置的，并通过可观察部分(<em class="lx">$:……</em>)触发<em class="lx">行的更新。</em></p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="5923" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lx"> Board </em>组件在暴露的<em class="lx">行</em> ( <em class="lx"> {#each …} </em>)的每个单元格中实例化一个<em class="lx">字段</em>组件，并提供一个组件接口，该接口提供了操作(<em class="lx"> create </em>，<em class="lx"> clear </em>，<em class="lx"> … </em>)其状态的方法。</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="e78f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lx">字段</em>组件接受三个参数(<em class="lx"> index、state、changed </em>)，并使用css类(<em class="lx"> {colorState} </em>、<em class="lx"> {colorCycle} </em>来反映单元格的状态以及它是否已更改。顺便说一下，这是在屏幕上更新DOM元素的最快技术。<br/>同样，可观察值(<em class="lx"> $: … </em>)用于在单元状态改变时保持这些变量最新。</p></div><div class="ab cl mo mp hr mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ig ih ii ij ik"><h1 id="f940" class="kt ku in bd kv kw nc ky kz la nd lc ld le ne lg lh li nf lk ll lm ng lo lp lq bi translated">摘要</h1><p id="65f1" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><strong class="jx io"> Svelte </strong>让你自然地编码html，关心后台所有模糊的东西。</p><p id="a21a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过遵循三条黄金法则，您能够构建丰富而复杂的web应用程序:</p><ul class=""><li id="526f" class="nh ni in jx b jy jz kc kd kg nj kk nk ko nl ks nm nn no np bi translated"><strong class="jx io"> #1:使用流量控制<br/> </strong>这意味着一个好的应用程序设计，把它分解成小的组件，不管它们的目的是可视化还是展示一些逻辑，或者两者都有。子组件中的事件被传播到根组件并通过observables返回到子组件，从而触发流。</li><li id="8513" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated"><strong class="jx io"> #2:保持关注点分离<br/> </strong>通过用一种创建方法编写组件，将逻辑与表示严格分离，这种创建方法在提供给其他组件的JavaScript对象中返回其接口。这概括了你的逻辑，给你一个体面的睡眠。</li><li id="cf40" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated"><strong class="jx io"> #3:维持状态</strong> <br/>这听起来比实际简单。有三种变量:成分变量、可观察变量和自由变量。Svelte 观察组件参数以触发DOM更新，并根据其输入保持观察值最新。将这些变量与用于内部逻辑的任何其他变量严格分开，不要在它们的作用域之外更改它们。</li></ul><h1 id="5302" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="e707" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">苗条的人做了一件惊人的工作。构建上面提到的web应用程序，我发现它是</p><ul class=""><li id="f61c" class="nh ni in jx b jy jz kc kd kg nj kk nk ko nl ks nm nn no np bi translated">原型制作非常快</li><li id="672d" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated">产品代码非常小(压缩了大约7 kB，包括html、css、JavaScript和sveltejs代码)</li><li id="6968" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated">通过直接更新DOM和尽可能使用css来提高性能</li></ul><p id="edfc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">苗条的组件是<a class="ae lw" href="https://www.w3.org/wiki/WebComponents/" rel="noopener ugc nofollow" target="_blank"> Web组件</a>更好的兄弟姐妹，谢谢<a class="nv nw ep" href="https://medium.com/u/a11f7c00cbbe?source=post_page-----1ea9614228f4--------------------------------" rel="noopener" target="_blank"> Rich Harris </a>提供了一个神奇的工具！</p><p id="85db" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望你喜欢阅读，有一个伟大的时间！</p><h2 id="96e4" class="mj ku in bd kv nx ny dn kz nz oa dp ld kg ob oc lh kk od oe ll ko of og lp oh bi translated">本文中使用的链接</h2><ul class=""><li id="9ba5" class="nh ni in jx b jy lr kc ls kg oi kk oj ko ok ks nm nn no np bi translated"><a class="ae lw" href="https://svelte.dev" rel="noopener ugc nofollow" target="_blank">苗条的</a></li><li id="c77e" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated"><a class="ae lw" href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life#Rules" rel="noopener ugc nofollow" target="_blank">康威的人生游戏</a></li><li id="e601" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated"><a class="ae lw" href="https://github.com/jcschmidig/Game-of-Life" rel="noopener ugc nofollow" target="_blank">Github上的源代码</a></li><li id="2fac" class="nh ni in jx b jy nq kc nr kg ns kk nt ko nu ks nm nn no np bi translated">js dild上的<a class="ae lw" href="https://jsfiddle.net/vq341tcd/1/embedded/result/" rel="noopener ugc nofollow" target="_blank">生产代码</a></li></ul></div></div>    
</body>
</html>