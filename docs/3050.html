<html>
<head>
<title>How to run AI models locally in a mobile device with React Native and Tensorflow.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用React Native和Tensorflow.js在移动设备中本地运行AI模型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-run-ai-models-locally-in-the-smartphone-with-react-native-and-tensorflow-js-666f52fd15ca?source=collection_archive---------0-----------------------#2020-08-24">https://javascript.plainenglish.io/how-to-run-ai-models-locally-in-the-smartphone-with-react-native-and-tensorflow-js-666f52fd15ca?source=collection_archive---------0-----------------------#2020-08-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/de8b8e37add8d1f4375a02f5717654d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*15wgC1qneHy3YZnk"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@vmxhu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Szabo Viktor</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><p id="1654" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这些年来JavaScript的发展令人难以置信。当我第一次开始web开发时，它更像是一个黑客，没有人真正喜欢使用它，但是现在JavaScript已经变得非常重要，并且提供了许多远远超出web开发的方面:React Native使跨平台移动开发变得很容易。Tensorflow.js为JavaScript配备了所有的机器学习能力。</p><p id="76c6" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在本教程中，我想用一个图像分类器的例子向你展示在移动设备上直接和本地运行一个人工智能模型是多么容易。</p><h2 id="5757" class="lf lg in bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">入门指南</h2><p id="5260" class="pw-post-body-paragraph kh ki in kj b kk ly km kn ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">如果您已经训练了Tensorflow.js模型，那么您就可以开始了。如果您的投资组合中有Tensorflow或Keras模型，您可以<a class="ae jz" href="https://www.tensorflow.org/js/guide/conversion" rel="noopener ugc nofollow" target="_blank">将其转换为Tensorflow.js </a>。</p><p id="ef0d" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在下文中，我将使用我训练过的图像分类器中的一个作为例子，它能够检测皮肤痣是黑素瘤(皮肤癌)的概率。训练是通过<a class="ae jz" href="https://cloud.google.com/automl?hl=en" rel="noopener ugc nofollow" target="_blank"> Google Auto ML </a>进行的，并基于<a class="ae jz" href="https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/DBW86T" rel="noopener ugc nofollow" target="_blank"> 10.000张公开可访问的图片</a>，带有二元分类(黑色素瘤或非黑色素瘤)。</p><p id="2517" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在训练之后，模型被导出到Tensorflow.js模型。因此，我们拥有了围绕它构建一个简单应用程序所需的一切。你可以在下面的插图中看到，该应用程序希望用户选择一张皮肤痣图片。然后，应用程序返回这颗痣成为黑色素瘤的概率百分比:</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/c4f6b7f5532733cf58209592fe97da95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s83a2gDLhW7fllHBIQJ0mw.png"/></div></div></figure><p id="b025" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">让我们重新创建这个简单的React原生应用程序(用Expo引导)，并将这个项目命名为<strong class="kj io"> mel-detect-poc </strong>(用于“<strong class="kj io">Mel</strong>anoma<strong class="kj io">detect</strong>ion<strong class="kj io">p</strong>roof<strong class="kj io">o</strong>f<strong class="kj io">c</strong>oncept”):</p><p id="2518" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><code class="fe mi mj mk ml b">expo init mel-detect-poc</code></p><p id="61b8" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们的项目具有以下结构:</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mm"><img src="../Images/cc47939f802472ae1fece8713fc1ddde.png" data-original-src="https://miro.medium.com/v2/resize:fit:354/format:webp/1*dnCYfEQGMAtGlMKNjD6JxA.png"/></div></div></figure><p id="4381" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">如上所述，Tensorflow.js模型数据保存在<code class="fe mi mj mk ml b">assets</code>文件夹中，与其他文件捆绑在一起。重要提示:为了让React Native识别用于捆绑的<code class="fe mi mj mk ml b">.bin</code>文件，我们需要在根级别向文件<code class="fe mi mj mk ml b">metro.config.js</code>添加以下内容:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Source: <a class="ae jz" href="https://www.npmjs.com/package/@tensorflow/tfjs-react-native" rel="noopener ugc nofollow" target="_blank">@tensorflow/tfjs-react-native</a></figcaption></figure><p id="9100" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="mp">这里作为旁注:如果你有多个权重</em> <code class="fe mi mj mk ml b"><em class="mp">.bin</em></code> <em class="mp">分片文件，你需要把它们合并成一个(对于Mac/Linux的说明可以在这里</em><a class="ae jz" href="https://stackoverflow.com/questions/62579876/how-to-merge-shard-bin-files-into-one" rel="noopener ugc nofollow" target="_blank"><em class="mp"/></a><em class="mp">，对于Windows </em> <a class="ae jz" href="https://stackoverflow.com/questions/53279744/how-to-join-two-binary-files-on-windows" rel="noopener ugc nofollow" target="_blank"> <em class="mp">这里</em> </a> <em class="mp">)。</em></p><p id="274f" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">对于我们的简单项目，我们只需要两个组件:</p><ul class=""><li id="42f8" class="mq mr in kj b kk kl ko kp ks ms kw mt la mu le mv mw mx my bi translated">App.js</li><li id="9d8e" class="mq mr in kj b kk mz ko na ks nb kw nc la nd le mv mw mx my bi translated">输出. js</li></ul><p id="f163" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">从App.js开始，我们需要导入这些包:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="ee8e" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">第3行导入了Tensorflow.js模块，而第4行引用了我们需要的来自Tensorflow.js模块的两个助手，这两个助手适用于React Native。</p><p id="f4ce" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们将需要<code class="fe mi mj mk ml b">fetch</code>来捕捉用户选择的图像文件，而<code class="fe mi mj mk ml b">bundleResourceIO</code>对于加载你已经保存在本地的模型是必不可少的，它将被编译到应用捆绑包中。这正是我们努力争取的优势:不需要网络服务器和互联网连接，一切都可以离线工作。</p><p id="6d67" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">由于该模型在本地运行，并包含在移动设备中——不与外界交换——该应用程序可以满足最严格的数据隐私要求。</p><p id="40ba" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们将使用以下状态变量和函数:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h2 id="e3db" class="lf lg in bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">启动Tensorflow.js并加载模型</h2><p id="9d4c" class="pw-post-body-paragraph kh ki in kj b kk ly km kn ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">Tensorflow.js模型只需加载一次。我们可以用<code class="fe mi mj mk ml b">useEffect</code>钩子和一个空数组作为第二个参数轻松地做到这一点。因此，每当我们的组件第一次并且仅在那里被呈现时，我们的模型将被加载并进入状态:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="1a3f" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">注意:上面的异步函数是一个嵌套函数，可以被立即调用。如果它是顶级的，它将返回一个承诺(作为每个异步函数)，然后将触发来自 <code class="fe mi mj mk ml b"><em class="mp">useEffect</em></code> <em class="mp">的警告，因为它期望一个不同的返回函数用于清理目的。</em></p><p id="9abc" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们总是需要等到Tensorflow.js准备就绪(第5行)之后，才能使用<code class="fe mi mj mk ml b">loadGraphModel</code>和助手<code class="fe mi mj mk ml b">bundleResourceIO</code>来最终启动我们的本地模型(第11–13行)。如果成功，<code class="fe mi mj mk ml b">loadGraphModel</code>将返回一个我们保存在常量<code class="fe mi mj mk ml b">loadedModel</code>中的模型对象。</p><p id="ecc5" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">这个对象将包括使用我们的模型的方法。我们稍后将回到这一点。<code class="fe mi mj mk ml b">useEffect</code>也是获得用户访问他们的相机胶卷和图像库的许可的好地方(第16行)。如果您想要访问iOS用户设备上的任何照片，这是他们必须完成的操作:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><h2 id="0863" class="lf lg in bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">处理图像选择过程</h2><p id="cf00" class="pw-post-body-paragraph kh ki in kj b kk ly km kn ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">太好了！现在，我们的模型已经准备好预测用户从他们的图像库中选择的任何图像，我们可以构建一个基本的接口来处理图像选择过程:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="a480" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们使用Expo的ImagePicker包，它可以方便地在移动设备上处理所有的图像选择和编辑。如果模型已经成功加载并进入状态(第6行)，那么触摸界面只处理图像选择器。还记得我们在<code class="fe mi mj mk ml b">useEffect</code>中所做的，在那里我们启动了本地保存的模型。</p><p id="1e67" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">现在，用户为我们的模型选择了一个图像来预测黑色素瘤的概率，我们需要首先准备这个图像，以便它与我们的模型兼容。我们在函数<code class="fe mi mj mk ml b">imageToTensor</code>中做这些准备工作(第27行)。我们一直等到图像被抛光，然后才将其发送给<code class="fe mi mj mk ml b">predict</code>方法(第28行)。还记得我们在<code class="fe mi mj mk ml b">useEffect</code> <em class="mp"> : </em> Tensorflow.js中初始化模型时，返回了模型的一个对象以及使用它的方法。这里，我们简单地使用方法<code class="fe mi mj mk ml b">predict</code>,将选择和准备的图像作为参数，让我们的模型返回一个概率值。</p><p id="fd78" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">基本就是这样！</p><p id="aff1" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">您会看到Tensorflow.js的使用非常简单，只需几行代码就可以完成！在我看来，你只需付出最少的努力就能实现的东西是相当惊人的——我们实际上是在我们的移动设备上运行一个复杂的人工智能模型！</p><h2 id="02c8" class="lf lg in bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">为人工智能预测准备图像</h2><p id="98bf" class="pw-post-body-paragraph kh ki in kj b kk ly km kn ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">然而，我们还没有完成。图像准备部分我欠你更多解释。为了更好地理解，让我们一行一行地看一下:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mn mo l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The code above for image preparation is adapted from <a class="ae jz" href="https://thekevinscott.com/image-classification-with-javascript/" rel="noopener ugc nofollow" target="_blank">thekevinscott.com</a></figcaption></figure><p id="bcd3" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">第4–6行不言自明，因为我们首先需要获取选定的图像，并将其二进制数据解码为JPEG格式。jpeg-js模块在这里帮助了我们。返回的二进制数组包括每个像素的RGBA ( <strong class="kj io"> r </strong> ed、<strong class="kj io"> g </strong> reen、<strong class="kj io"> b </strong> lue和<strong class="kj io"> a </strong> lpha = opacity)颜色值。</p><p id="e905" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">当我们处理JPEG文件时，我们不需要alpha维度。因此，我们需要创建一个没有该维度的新缓冲区数组，并从原始数组中复制RGB值(第11–18行)。之后，我们能够创建一个三维图像张量的维度宽度，高度和RGB颜色通道(第21行)。</p><p id="a144" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">所选的用户图像对我们的模型来说太大了，Google Auto ML要求图像大小为224x224像素。这意味着我们需要调整图像的大小。为了保持宽高比，我们需要首先对图像进行中心裁剪，这意味着我们要砍掉较长的一边。下图说明了问题和解决方案:</p><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/e0cb0c9d7ad75ba2a2c35d0444b349cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZZ3z2xIzZB0TstgPt4xYQ.png"/></div></div></figure><p id="7ff3" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">方形中心裁剪区域(红色方框)可以通过取较短的一边(在上图中是高度)来计算，并使用它来计算宽度和高度的开始和结束像素。例如，要计算裁剪框宽度尺寸的起始像素，只需用较短的一边减去原始宽度，然后用新宽度除以2。对于裁剪框宽度尺寸的结束像素，然后将较短的边添加到开始像素。结果就是你在上图中看到的红框。</p><p id="b8ee" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><code class="fe mi mj mk ml b">imageToTensor</code>方法的第24–28行在代码级别演示了这一点。找到中心裁剪区域后，可以相应地裁剪图像(第31–34行)，并最终调整到224x224的正方形大小(第35行)。我们还没有完成:我们的模型期望一个所谓的秩4张量(= 4维张量)，格式为[n，224，224，3]，n是批量大小。因为我们希望一次只分析一张图片，所以批量大小只有一张。方法<code class="fe mi mj mk ml b">expandDims</code>可以在这里帮助我们(第38行),并在我们当前的3D张量前面增加一个额外的维度，大小为1。结果是一个格式为[1，224，224，3]的图像张量，这正是我们正在寻找的。</p><p id="45af" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在我们将图像发送给人工智能之前，最后一步是将RGB值从0–255的范围归一化到-1–1的范围(第41行)。本节中的所有内容当然只适用于我的模型(也适用于其他经过Google Auto ML视觉训练的模型)——你当然需要根据你的模型训练规范准备你的图像。</p><h2 id="4226" class="lf lg in bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated">输出结果</h2><p id="79db" class="pw-post-body-paragraph kh ki in kj b kk ly km kn ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">最后，在预测完成后，我们希望向用户展示它。为此，我们将值从App.js传递到组件Output.js，在那里它以一种风格化的方式呈现:</p><figure class="me mf mg mh gt jo"><div class="bz fp l di"><div class="mn mo l"/></div></figure><p id="b681" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">我们的模型返回二元类别(黑色素瘤或非黑色素瘤)的概率值为(0-1)的张量。为了提取第一类(黑色素瘤),我们首先需要将张量转换成一个数组，这是通过<code class="fe mi mj mk ml b">dataSync</code>方法完成的，只需访问它的第一个元素(第14行)。</p><p id="4f87" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">仅此而已！你可以在我的Github账户上的这里找到整个项目<a class="ae jz" href="https://github.com/RyanLinXiang/mel-detect-poc" rel="noopener ugc nofollow" target="_blank">。请注意，我在这里使用的图像分类器只是为了说明的目的，并不能取代医生的皮肤癌咨询。我训练的模型只是基于一个小的图像数据集，因此它预测的概率值并不真正可靠和有代表性。</a></p><p id="5cdc" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated">在本教程中，我的目标是向您展示如今在移动设备上使用JavaScript技术本地运行人工智能模型是多么简单。我的图像分类器例子可以很容易地替换并适应您的用例。我向您展示了通过<code class="fe mi mj mk ml b">bundleResourceIO</code>初始化React原生项目中任何模型的技术。此外，本教程有希望并最终展示了React Native和Tensorflow.js的结合所蕴含的巨大潜力。我希望您发现它有所帮助并喜欢它。我非常期待你的反馈！</p><p id="8e71" class="pw-post-body-paragraph kh ki in kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ig bi translated"><em class="mp">最后一点:应用程序在覆盖大量渐变时会触发一些警告。如果你有解决这个问题的方法，请在Stackoverflow的这里给我一个答案</em><a class="ae jz" href="https://stackoverflow.com/questions/62612347/react-native-strange-warnings-on-overriding-gradient-any-explanation" rel="noopener ugc nofollow" target="_blank"><em class="mp"/></a><em class="mp">。可以通过在App.js. </em>开头添加注释行 <code class="fe mi mj mk ml b"><em class="mp">//console.disableYellowBox = true</em></code> <em class="mp">来禁用警告</em></p><h2 id="9809" class="lf lg in bd lh li lj dn lk ll lm dp ln ks lo lp lq kw lr ls lt la lu lv lw lx bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="4a7c" class="pw-post-body-paragraph kh ki in kj b kk ly km kn ko lz kq kr ks ma ku kv kw mb ky kz la mc lc ld le ig bi translated">你知道我们有三份出版物和一个YouTube频道吗？在<a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kj io">plain English . io</strong></a>找到所有内容的链接！</p></div></div>    
</body>
</html>