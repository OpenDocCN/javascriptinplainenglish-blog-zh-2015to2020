<html>
<head>
<title>A Try/Catch Decorator to Stylize Your Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个尝试/捕捉装饰器来风格化你的代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-try-catch-decorator-to-stylize-your-code-bdd0202765c8?source=collection_archive---------1-----------------------#2020-05-19">https://javascript.plainenglish.io/a-try-catch-decorator-to-stylize-your-code-bdd0202765c8?source=collection_archive---------1-----------------------#2020-05-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="38a0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">让我们为ECMA/TypeScript构建一个Try/Catch装饰器来风格化和简化我们的错误处理代码</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/1cf517a575c81282c0418a6e7bea4f7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C5lNWF0dnNcdxqzF"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clément H</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="90dc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">应用程序有错误。有时这些是我们的错误，比如空引用，或者它们超出了我们的范围，比如来自用户方的错误连接。但是不管它们来自哪里，我们都应该对待它们，这样我们的应用程序才能优雅地继续。</p><p id="366a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了处理ECMA/TypeScript中的错误，我们用一个<code class="fe lp lq lr ls b">try/catch</code>块包围我们的代码，或者我们将<code class="fe lp lq lr ls b">.catch()</code>附加到一个承诺上。这些可以快速生成嵌套代码和样板文件，特别是当我们需要处理许多类型的错误时。</p><h1 id="56b3" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">装修工</h1><p id="ca51" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">装饰者，顾名思义，装饰我们的代码(函数、类)来添加信息或修改它的行为。装饰器是JavaScript的第二阶段提案，是TypeScript的一个实验性特性。</p><p id="c4c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了启用对装饰者的实验性支持，您必须启用您的<code class="fe lp lq lr ls b">tsconfig.json</code>中的<code class="fe lp lq lr ls b">experimentalDecorators</code>编译器选项:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="770a" class="mu lu in ls b gy mv mw l mx my">{<br/>  "compilerOptions": {<br/>    "target": "ES6",<br/>    "experimentalDecorators": true<br/>  }<br/>}</span></pre><p id="d4e1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个<em class="mz">装饰器工厂</em>的基本结构，简单来说就是一个返回表达式的函数，这个表达式将在运行时被装饰器调用，如下所示:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="a0ae" class="mu lu in ls b gy mv mw l mx my">const Log = (msg: string): any =&gt; {<br/>  return (target: any, propertyKey: string, descriptor: PropertyDescriptor) =&gt; {<br/>    // target: class constructor or current object's prototype<br/>    // propertyKey: name of the decorated method<br/>    // descriptor: property descriptor of the method<br/>    modify class or method...<br/>  }<br/>}</span></pre><p id="b46f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">那么我们将如下使用它:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="2380" class="mu lu in ls b gy mv mw l mx my">@Log('decorating class')<br/>class Test {<br/>  @Log('decorate method')<br/>  testMethod() {}<br/>}</span></pre></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><h1 id="e1a9" class="lt lu in bd lv lw nh ly lz ma ni mc md jt nj ju mf jw nk jx mh jz nl ka mj mk bi translated">履行</h1><p id="d110" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">现在我们知道了装饰器是什么以及它是如何实现的，让我们编写自己的装饰器。</p><p id="0417" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们想要编程的是:</p><ul class=""><li id="fcbb" class="nm nn in kv b kw kx kz la lc no lg np lk nq lo nr ns nt nu bi translated">捕捉特定错误的装饰器</li><li id="b56f" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">捕捉所有错误的装饰器</li><li id="5933" class="nm nn in kv b kw nv kz nw lc nx lg ny lk nz lo nr ns nt nu bi translated">将这些装饰器应用于一个类或一个方法</li></ul><h2 id="569b" class="mu lu in bd lv oa ob dn lz oc od dp md lc oe of mf lg og oh mh lk oi oj mj ok bi translated">方法装饰者</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="2b85" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里有很多东西需要解开，所以让我们一行一行来。</p><p id="27bf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">[1] <br/>我们需要传递给装饰器的处理函数的定义。该函数接收捕获的错误和函数的上下文(<code class="fe lp lq lr ls b">this</code>)。</p><p id="e79d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">【3】<br/>装修工的签名。<code class="fe lp lq lr ls b">Catch</code> decorator需要捕捉特定的错误以及处理该错误的函数。</p><p id="b831" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">[5–6]<br/><code class="fe lp lq lr ls b">descriptor.value</code>保存对原始修饰方法的引用。我们保存此参考供以后使用。</p><p id="7dda" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">[9] <br/>我们用一个新的函数覆盖了修饰过的方法。</p><p id="ceb1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">【10，23-25】<br/>我们周围的<code class="fe lp lq lr ls b">try/catch</code>街区。</p><p id="0550" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">[11] <br/>原修饰方法的执行和结果。如果抛出一个错误，它将被前面提到的<code class="fe lp lq lr ls b">try/catch</code>块捕获。</p><p id="7b24" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们检查修饰的方法是否是异步的(也就是返回一个承诺)。如果是这样，我们返回原始方法的结果，并添加一个<code class="fe lp lq lr ls b">.catch</code>来处理错误(如果有的话)。</p><p id="cb73" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">[21–22]<br/>如果修饰的方法是同步的，我们返回它的结果。</p><p id="3ace" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">[27–28]<br/>我们返回新的描述符，即由<code class="fe lp lq lr ls b">try/catch</code>包围的原始方法，如果是异步的，则添加<code class="fe lp lq lr ls b">.catch</code>。</p><p id="c18d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">[32] <br/>随着<code class="fe lp lq lr ls b">Catch</code>装饰器的实现，它只是一个返回装饰器函数的函数，我们可以简单地将<code class="fe lp lq lr ls b">CatchAll</code>定义为<code class="fe lp lq lr ls b">Catch</code>，但是已经指定它应该捕捉任何错误。</p><p id="ef00" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">[34–44]<br/>错误处理函数。我们确认传递的函数确实是一个函数，并且错误属于指定的类型。如果是，我们执行给定的函数。否则，我们再次抛出错误，并转发给下一个装饰器或被装饰的方法。</p><h2 id="c85d" class="mu lu in bd lv oa ob dn lz oc od dp md lc oe of mf lg og oh mh lk oi oj mj ok bi translated">类装饰者</h2><p id="2780" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">如果我们装饰一个类，我们想要遍历这个类的所有方法并装饰它们。</p><p id="b769" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们修饰一个类，我们可以使用<code class="fe lp lq lr ls b">target</code>来获得它的所有(非静态)方法。然后我们可以用和以前一样的方法覆盖它们。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ol om l"/></div></figure><p id="4ca5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">[4–7]<br/>如果定义了<code class="fe lp lq lr ls b">descriptor</code>，那么我们就是在修饰一个方法。我们像以前一样生成一个描述符并返回它。</p><p id="1fc5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">【8–17】<br/>否则，我们就是在布置一个班级。在这种情况下，<code class="fe lp lq lr ls b">target</code>是类构造函数，我们可以访问它的原型。我们使用<code class="fe lp lq lr ls b">Reflect.ownKeys(target.prototype)</code>来获取它所有(非静态)方法的名称，包括构造函数，所以我们需要过滤掉它。<br/>然后我们得到方法的描述符，确认它是一个方法，像以前一样生成新的描述符。我们还需要重新定义修改后的类属性。</p><p id="ac38" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">[21–50]<br/><code class="fe lp lq lr ls b">_generateDescriptor</code>函数做的事情与之前在<code class="fe lp lq lr ls b">Catch</code>装饰器中做的完全一样。</p><h1 id="94da" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">结论</h1><p id="8170" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">我们现在已经编写了一个装饰器，它用一个<code class="fe lp lq lr ls b">try/catch</code>块来包围我们的方法，这个块将处理我们定义的错误。</p><p id="9632" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了这个装饰器，我们可以改变它:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="11e3" class="mu lu in ls b gy mv mw l mx my">class Messenger {<br/>  getMessages() {<br/>    try {<br/>      ...<br/>    } catch(err) {<br/>      if (err instanceof TypeError) {<br/>        console.log(this, err)<!-- -->;<br/>      } else {<br/>        throw err;<br/>      }<br/>    }<br/>  }</span><span id="3c9a" class="mu lu in ls b gy on mw l mx my">  // and the same surrounding block for all the class functions<br/>}</span></pre><p id="42a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">收件人:</p><pre class="kd ke kf kg gt mq ls mr ms aw mt bi"><span id="e9be" class="mu lu in ls b gy mv mw l mx my">@Catch(TypeError, (err, ctx) =&gt; console.log(ctx, err))<br/>class Messenger {<br/>  getMessages() {<br/>    ...<br/>  }</span><span id="e964" class="mu lu in ls b gy on mw l mx my">  // all the other functions<br/>}</span></pre></div><div class="ab cl na nb hr nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ig ih ii ij ik"><p id="d472" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">谢谢你看我的文章！我希望你能从中学到一些新的东西，或者它能帮助你使你的代码更整洁。</p><p id="1b63" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你不想自己实现装饰器，你可以安装<a class="ae ks" href="https://www.npmjs.com/package/@magna_shogun/catch-decorator" rel="noopener ugc nofollow" target="_blank">这个NPM包</a>。如果你想看到所有的东西，你也可以找到源代码。</p><h1 id="d783" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">参考</h1><div class="oo op gp gr oq or"><a href="https://www.typescriptlang.org/docs/handbook/decorators.html" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd io gy z fp ow fr fs ox fu fw im bi translated">装修工#</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">编辑描述</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">www.typescriptlang.org</p></div></div></div></a></div><div class="oo op gp gr oq or"><a href="https://www.npmjs.com/package/@magna_shogun/catch-decorator" rel="noopener  ugc nofollow" target="_blank"><div class="os ab fo"><div class="ot ab ou cl cj ov"><h2 class="bd io gy z fp ow fr fs ox fu fw im bi translated">@ magna _幕府/catch-decorator</h2><div class="oy l"><h3 class="bd b gy z fp ow fr fs ox fu fw dk translated">ECMAScript/TypeScript捕获类和函数的装饰器。基于@enkot/catch-decorator。npm安装…</h3></div><div class="oz l"><p class="bd b dl z fp ow fr fs ox fu fw dk translated">www.npmjs.com</p></div></div><div class="pa l"><div class="pb l pc pd pe pa pf km or"/></div></div></a></div><h2 id="4602" class="mu lu in bd lv oa ob dn lz oc od dp md lc oe of mf lg og oh mh lk oi oj mj ok bi translated"><strong class="ak">简明英语团队的笔记</strong></h2><p id="fc19" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io"> plainenglish.io </strong> </a>找到所有这些内容——关注我们的出版物并<a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kv io">订阅我们的YouTube频道</strong> </a> <strong class="kv io">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>