<html>
<head>
<title>How to make HTTP requests in Angular using HttpClient</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用HttpClient在Angular中发出HTTP请求</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-make-http-requests-in-angular-using-httpclient-15e1fdf76a03?source=collection_archive---------9-----------------------#2020-10-06">https://javascript.plainenglish.io/how-to-make-http-requests-in-angular-using-httpclient-15e1fdf76a03?source=collection_archive---------9-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e8029a05e33f050633351fb3d8410b5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ae-ZmzKHKdWZIe-9Ve4mtA.png"/></div></div></figure><p id="8ae8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">web开发的首要原则之一是学习如何与后端通信，以获取或更新数据，并访问它提供的其他服务。</p><p id="fa23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了做到这一点，我们将使用Angular在4.3.1版本中引入的新HttpClientModule。这取代了前面的HttpModule，通过提供内置接口使利用和测试更加容易。</p><h2 id="3870" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">导入适当的模块</strong></h2><p id="e16d" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">开始使用HTTP客户端需要做的第一件事是将正确的模块导入到我们的项目中。</p><p id="213e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们要注意的是，我们使用的应该是位于<strong class="ka ir"><em class="lu">@ angular/common/http</em></strong>和<strong class="ka ir">中的<strong class="ka ir"> <em class="lu"> HttpClientModule </em> </strong>而不是</strong><strong class="ka ir"><em class="lu">中的</em></strong>http module<em class="lu"/><strong class="ka ir"><em class="lu">@ angular/http</em></strong>目录<em class="lu">。</em></p><p id="b86c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是现在用Angular写Http请求时常见的困惑之一。有些人仍然引用旧模块，因此在服务中使用它时会出错。</p><p id="6ada" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们只需要将<strong class="ka ir"><em class="lu">imports</em></strong><em class="lu"/><strong class="ka ir"><em class="lu">array</em></strong>中的HttpClientModule加上其他默认模块，如<em class="lu"> BrowserModule </em>和<em class="lu">approving module</em>。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/d77928a1e3516ec9d0b4241104f8ab7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nqqgh5IuyYE6xz55E2reTw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Importing HttpClientModule in the app module.</figcaption></figure><h2 id="1f5f" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">将HttpClient服务作为依赖项注入</h2><p id="9885" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">在我们的服务文件中，我们必须在构造函数中注入<em class="lu"> HttpClient </em>模块，并使用它在我们的应用程序中发送任何HTTP请求。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lv"><img src="../Images/ca8c0f38fbddafe21a0b879d2154c562.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5SMUPmmaqK5jlri_FGHy3Q.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Injecting the HttpClient token inside the constructor.</figcaption></figure><h2 id="cc86" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">使用GET方法从服务器获取数据</h2><p id="4575" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">在这个例子中，我们将使用<a class="ae me" href="https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/iTuneSearchAPI/Searching.html" rel="noopener ugc nofollow" target="_blank"> iTunes </a> URL来执行HTTP请求并在模板上显示一些数据。</p><p id="8d96" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将呼叫<strong class="ka ir">。在<em class="lu"> getSongDetails </em>函数中的get()方法</strong>，这将返回一个在收到响应时发出请求数据的可观察对象。我已经定义了一个实例，并把它放在上面，这样我们就可以在需要向服务器发出请求时引用iTunes API。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/20e1c938505059f2bc0712c3b5fcb3cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-RkPy_pQw2NW2PCXAAczw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Creating a method that will execute Http request.</figcaption></figure><h2 id="5274" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">向方法添加类型</h2><p id="adf4" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">指定Http请求结果的类型是一种常见的做法，这样我们就知道我们将得到什么类型的数据。如果我们没有指定它的类型，那么调用的结果将是一个<object>。</object></p><p id="d7d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的图片中，我创建了一个歌曲界面模型来给我们的数据赋予形状。这将用于设置函数和HttpClient方法的类型。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mf"><img src="../Images/0ed8a092b8fa480c00318585e0917607.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bKanwSlbxprsAkhlRLja9g.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Creating a Song interface.</figcaption></figure><p id="8a46" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们必须在服务文件中导入这个接口。</p><p id="bd85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您会注意到，除了接口之外，我们还从RxJS导入了Observable。</p><p id="5239" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，请记住，当您将<em class="lu"> getSongDetails() </em>函数的类型指定为可观察的&lt;歌曲&gt;时，您还必须添加实际的<em class="lu">的类型。get() </em>调用&lt;歌曲&gt;，这样就不会出现错误。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/75f9ecfa5cae84ace8dbe10ed66e185a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Xl1Q-GZym4tbs37xIWCJQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Specifying get method result as an Observable with Song as its type.</figcaption></figure><h2 id="5b6a" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">创建具有不可变状态的其他Http操作</h2><h2 id="e998" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">PUT方法</h2><p id="c869" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">这个方法类似于我们之前创建的方法。但是，没有使用<em class="lu">。get()，</em>我们现在将使用<em class="lu">。放()</em>方法。我们还需要传递附加信息，比如该项目的ID和更新值，以便能够在数据库中更新它。</p><p id="07c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">查看下面的示例:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/dd619a8c79cd3cef819ae0e115d9cdaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LiROXgWh2xhLap9Gh7HEcA.png"/></div></div></figure><h2 id="b1ad" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">删除方法</h2><p id="d835" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">对于删除请求，非常简单，我们只需要创建一个新函数来构造<strong class="ka ir">。delete() </strong>请求方法。这次我们不需要传递更新的数据，所以我们可以只引用完整的URL (ITUNES_API)并传递项目的ID，然后它将从数据库中删除。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/9c658cdc3113f12e011db6e241193918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NIek6h-NknWYMmtZfbCRYA.png"/></div></div></figure><h2 id="0f3f" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">过帐方法</h2><p id="5332" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">POST请求类似于。put()请求，在这个方法中，我们需要引用资源URL，并且需要传递一个额外的参数，即<em class="lu">主体</em>或我们需要添加到数据库中的数据。当我们成功添加数据后，组件将返回一组新的数据，包括我们刚刚添加的数据。</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/4e08a2008905b27f7b45293e0714c744.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6tEhgpugpx7stH1nYjmpzA.png"/></div></div></figure><h2 id="b9c0" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">添加自定义标题和参数</h2><h2 id="c10c" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">HttpHeaders</h2><p id="9a5f" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">一些服务器在向数据库添加数据时需要额外的协议。常见的有以下<a class="ae me" href="https://developer.mozilla.org/en-US/docs/Glossary/Entity_header" rel="noopener ugc nofollow" target="_blank">实体头</a>:</p><ul class=""><li id="efe2" class="mi mj iq ka b kb kc kf kg kj mk kn ml kr mm kv mn mo mp mq bi translated">内容类型(Mime类型)</li><li id="543e" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">内容长度(要上传的数据量)</li><li id="9b3e" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">授权令牌</li></ul><p id="b172" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Angular的<strong class="ka ir"> HttpHeaders </strong>类提供了一种处理这种需求的方法。您只需要创建一个包含这些标题选项属性的对象。</p><p id="27b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个例子:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/02d56f97a421384d6cc41ddd59beb3d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-VZT8FDF-jgH2yYOEHu8EA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Creating new HttpHeaders entity and assigning it to an object.</figcaption></figure><p id="8fa9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了更新headers属性，我们需要引用<em class="lu"> options </em>对象并使用<strong class="ka ir">。设置</strong>操作，为其分配新值。在本例中，我们将更新前面定义的标题的授权令牌。</p><p id="f105" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是传递新headers属性的实际Http请求的示例:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/891cce26bde642e08905a4de0d016e63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*InOeheN0CgLjW0L-0mo4vw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Passing updated headers to response.</figcaption></figure><h2 id="7ddf" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">http程序</h2><p id="3d27" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">获取数据时，GET请求通常有多个参数。参数需要动态地传递或分配给请求。为此，我们需要将HttpParams 类导入到我们的服务中。</p><p id="87c0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面的例子中，我们定义了新的HttpParams并添加了三个URL查询字符串，分别是<em class="lu">‘term’、‘media’和‘limit’:</em></p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mh"><img src="../Images/644458ec1e480e1a366a9ac98bee92ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z3EYWrYEk7Z6wRbM8xqLlg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Defining new Httpparams and assigning query strings.</figcaption></figure><p id="ab27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于HttpParams对象是不可变的，我们需要使用<strong class="ka ir">。set() </strong>方法是否需要更新选项。</p><p id="a739" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下图中，我们已经更新了<em class="lu"> getSongDetails </em>函数并动态分配了参数。在这种情况下，代码看起来更加清晰:</p><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mg"><img src="../Images/a0515dac12a966f68f92a5ddf2fce408.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bGtvQlfe6CsbvSR9vYTQNQ.png"/></div></div></figure></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h2 id="44bb" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">备忘单:</h2><ul class=""><li id="ed8a" class="mi mj iq ka b kb lp kf lq kj nd kn ne kr nf kv mn mo mp mq bi translated"><strong class="ka ir"> HttpClientModule </strong>需要导入到应用程序的根模块中。</li><li id="943c" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated"><strong class="ka ir"> HttpClient </strong>类应该导入并注入到服务的构造函数内部。</li><li id="b32b" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated"><strong class="ka ir"> HttpHeaders </strong>类应该在定义新的头选项之前导入。</li><li id="8b81" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated"><strong class="ka ir">定义动态参数查询字符串时导入HttpParams </strong>类。</li><li id="b44e" class="mi mj iq ka b kb mr kf ms kj mt kn mu kr mv kv mn mo mp mq bi translated">在编写Http调用时，最好的做法是<strong class="ka ir">创建模型并将类型</strong>添加到方法和请求中。</li></ul></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><figure class="lw lx ly lz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/03cdc13ab9647f48f21b47193dd8cda2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b2-sriMuBz5V9OV8cbUw-g.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk"><a class="ae me" href="https://unsplash.com/@alexkixa" rel="noopener ugc nofollow" target="_blank">Alexandre Debiève</a></figcaption></figure><p id="5d4b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你觉得这个博客有帮助吗？别忘了在评论区留下一些反馈。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><h2 id="6d58" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">资源</h2><p id="59dd" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated"><a class="ae me" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" rel="noopener ugc nofollow" target="_blank"> http头</a> | <a class="ae me" href="https://angular.io/guide/http#configuring-http-url-parameters" rel="noopener ugc nofollow" target="_blank">使用http的后端服务</a></p></div></div>    
</body>
</html>