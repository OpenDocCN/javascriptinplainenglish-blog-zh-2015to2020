<html>
<head>
<title>Setting up a REST API using Express</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express设置REST API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/setting-up-a-rest-api-using-express-d92d5dc42e2a?source=collection_archive---------10-----------------------#2020-09-27">https://javascript.plainenglish.io/setting-up-a-rest-api-using-express-d92d5dc42e2a?source=collection_archive---------10-----------------------#2020-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f5f9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个可以用作模板的基本REST API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fd31683eb1cf9e9c7cbe41e779845230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*26xm7tQDyxjgbJhRIrP5Ag.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@sushioutlaw?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Brian McGowan</a> on <a class="ae kv" href="https://unsplash.com/s/photos/express?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="060d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我想向您展示一种快速而可靠的方法来用<a class="ae kv" href="http://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> ExpressJS </a>设置一个<a class="ae kv" href="https://en.wikipedia.org/wiki/Representational_state_transfer" rel="noopener ugc nofollow" target="_blank"> REST-API </a>。这不包括任何种类的认证或授权。我们将只建立一个单一的路线，并定义一些标准，这将有助于我们扩展这个API，如果我们选择这样做。</p><h1 id="1d24" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">先决条件</h1><p id="a5a8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我们开始编码之前，我们需要在我们的系统上安装NodeJS和NPM的版本。只需点击链接<a class="ae kv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">的官方网站</a>，下载NodeJS的LTS(长期支持)版本。这将自动安装<a class="ae kv" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a>作为它的软件包管理器。</p><p id="4280" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们通过创建一个名为<em class="mp"> express_api_template </em>的文件夹来生成我们的项目，然后使用<em class="mp"> npm </em>来初始化NodeJS项目。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="236f" class="mv lt iq mr b gy mw mx l my mz">$ mkdir express_api_template<br/>$ cd express_api_template/<br/>$ npm init</span></pre><p id="1a67" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mp"> npm，init </em>将带您了解建立新项目的流程。除了<em class="mp">入口点</em>我一般都用默认设置。我喜欢调用我的主javascript文件<em class="mp"> server.js </em>而不是默认的<em class="mp"> index.js </em>然后填写作者。完成后，我们需要通过将ExpressJS添加到我们的<em class="mp">包中来安装它。为此，我们将使用以下命令。</em></p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="357f" class="mv lt iq mr b gy mw mx l my mz">$ npm install express</span></pre><p id="d13c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下载完成后，我们应该有一个<em class="mp"> node_modules </em>文件夹和两个文件<em class="mp"> package.json </em>和<em class="mp"> package-lock.json </em>。</p><h1 id="87b7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基础知识</h1><p id="2df8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">首先，我们需要创建两个新文件夹和两个新文件，以及一些新的依赖项。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="950d" class="mv lt iq mr b gy mw mx l my mz">$ mkdir src<br/>$ mkdir src/config<br/>$ touch src/server.js src/config/config.env<br/>$ npm install colors dotenv<br/>$ npm install nodemon --save-dev</span></pre><p id="9a80" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">普通安装和-save-dev安装的区别在于普通安装安装生产所需的依赖项。— save-dev只安装开发所需的依赖项。但是我们实际上在这里安装了什么呢？</p><ul class=""><li id="5f5a" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><a class="ae kv" href="https://www.npmjs.com/package/colors" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mp">颜色</em></strong></a><strong class="ky ir"><em class="mp">:</em></strong>这个包用来使控制台输出丰富多彩。</li><li id="78f5" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><a class="ae kv" href="https://www.npmjs.com/package/dotenv" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mp">dotenv</em></strong></a><strong class="ky ir"><em class="mp">:</em></strong>这个包从。env文件到process.env.{variable_name}</li><li id="911d" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><a class="ae kv" href="https://nodemon.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mp">nodemon</em></strong></a><strong class="ky ir"><em class="mp">:</em></strong>这是在开发中用于每次保存更改时重新加载服务器。</li></ul><p id="16cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装所有这些不会使应用程序运行。为此，我们还需要做两件事:</p><ol class=""><li id="f85e" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr no ng nh ni bi translated">配置我们的<em class="mp"> package.json </em>来启动<em class="mp"> server.js </em></li><li id="a4eb" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr no ng nh ni bi translated">在<em class="mp"> server.js </em>中实现基本Express服务器</li></ol><p id="883c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从这样配置<em class="mp"> package.json </em>开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">package.json</figcaption></figure><p id="8963" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们定义了两个命令用于<strong class="ky ir"> npm </strong>。第一个是生产用的。它将NODE_ENV变量设置为<em class="mp">生产</em>，然后使用<em class="mp">节点命令</em>启动服务器。第二个用于开发，将NODE_ENV设置为<em class="mp"> development </em>，然后使用<em class="mp"> nodemon </em>而不是<em class="mp"> node </em>，这样我们就可以在开发过程中利用保存时重新加载功能。</p><p id="1894" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong>如果你使用Windows作为操作系统，你需要安装<a class="ae kv" href="https://www.npmjs.com/package/cross-env" rel="noopener ugc nofollow" target="_blank"> cross-env </a>作为开发依赖来设置NODE_ENV。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8a1f" class="mv lt iq mr b gy mw mx l my mz">$ npm install cross-env --save-dev</span></pre><p id="8583" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后像这样编辑两个脚本:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="43f1" class="mv lt iq mr b gy mw mx l my mz">"scripts": {<br/>  "start": "cross-env NODE_ENV=production node src/server.js",<br/>  "dev": "cross-env NODE_ENV=development nodemon src/server.js"<br/>},</span></pre><p id="2d71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让所有这些工作，我们需要先完成第二步。我们必须创建一个express应用程序，然后通过使用我们在<em class="mp"> config.env </em>中定义的端口来启动它。将端口添加到文件中，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8273" class="mv lt iq mr b gy mw mx l my mz">PORT=5000</span></pre><p id="2bf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以开始在<em class="mp"> server.js </em>上写一些代码了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">server.js</figcaption></figure><p id="7e35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这非常简单，我们将路径设置为我们的<em class="mp"> config.env </em>，然后初始化express应用程序。之后，我们开始监听我们刚刚在<em class="mp"> config.env </em>中设置的端口。如果我们运行以下命令:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b0db" class="mv lt iq mr b gy mw mx l my mz">$ npm run dev</span></pre><p id="be7d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您应该会看到以下输出:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="fad9" class="mv lt iq mr b gy mw mx l my mz">[nodemon] 2.0.4<br/>[nodemon] to restart at any time, enter `rs`<br/>[nodemon] watching path(s): *.*<br/>[nodemon] watching extensions: js,mjs,json<br/>[nodemon] starting `node src/server.js`<br/>Server up and running in development mode on port 5000</span></pre><p id="a83d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了一个非常基本的设置。现在让我们在下一节中将它作为REST-API的模板。</p><h1 id="75a8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">调试和安全性</h1><p id="9a7b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们的目标是添加更多的特性，比如将更多的信息记录到控制台，用于调试目的和保护API。</p><p id="b7a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了实现上述目标，我们需要添加更多的依赖项。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f276" class="mv lt iq mr b gy mw mx l my mz">$ npm install helmet cors<br/>$ npm install morgan  --save-dev</span></pre><p id="931f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这三个新的依赖项是做什么的？</p><ul class=""><li id="5798" class="na nb iq ky b kz la lc ld lf nc lj nd ln ne lr nf ng nh ni bi translated"><a class="ae kv" href="https://helmetjs.github.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mp">头盔</em></strong></a><strong class="ky ir"><em class="mp">:</em></strong>这个包是一个中间件，通过添加多个HTTP头来帮助保护你的API。</li><li id="98fb" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><a class="ae kv" href="https://www.npmjs.com/package/cors" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mp">CORS</em></strong></a><strong class="ky ir"><em class="mp">:</em></strong>这个中间件帮助我们实现<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>。</li><li id="4aab" class="na nb iq ky b kz nj lc nk lf nl lj nm ln nn lr nf ng nh ni bi translated"><a class="ae kv" href="https://www.npmjs.com/package/morgan" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mp">摩根</em></strong></a><strong class="ky ir"><em class="mp">:</em></strong>这是一个简单的HTTP请求记录器，它将传入的请求输出到节点控制台。</li></ul><p id="d2b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">安装完所有这些中间件后，我们需要继续将它们添加到我们的express应用程序中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">updated server.js</figcaption></figure><p id="4439" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最值得注意的是对当前NODE_ENV的新检查。我们这样做是因为如果我们处于开发模式，我们只需要摩根。如果您以后想要为开发中的数据库添加类似数据播种脚本的东西，那么您可以在那里完成。</p><p id="d1f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在新的检查之后，我们将中间件连接到我们的express应用程序。对于<em class="mp"> cors </em>，我们配置一个原点。这意味着只允许来自这个来源的请求与我们的API通信。例如您构建的前端应用程序。我们只需要将地址添加到我们的<em class="mp"> config.env </em>文件中，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="dab9" class="mv lt iq mr b gy mw mx l my mz">CORS_ORIGIN=http://localhost:8000</span></pre><p id="1e1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据您的web应用程序开发设置，端口可能会有所不同。如果是这样的话，那就去改变它。</p><h1 id="88dc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">端点和定制中间件</h1><p id="90b5" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们已经完成了保护API的工作，我们将实现两个基本的中间件和一个示例路由。为了保持项目的整洁和可维护性，我们将添加三个文件夹和四个新文件。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="5d92" class="mv lt iq mr b gy mw mx l my mz">$ mkdir src/routes src/middleware src/controllers<br/>$ touch src/middleware/notFound.js src/middleware/errorHandler.js src/routes/post.js src/controllers/postsController.js</span></pre><h2 id="25ce" class="mv lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">中间件</h2><p id="fff7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们首先在<em class="mp"> notFound.js </em>中创建第一个中间件函数，它通过抛出<em class="mp"> 404 Not Found错误</em>来处理没有命中API端点的请求。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">notFound.js</figcaption></figure><p id="2a57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它只是一个接收请求、响应和next的函数。我们创建一个错误，将HTTP状态代码设置为404，并将错误传递给next。</p><p id="3907" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">光靠这个中间件根本帮不了我们。我们需要一些东西来处理传入的错误，比如我们刚刚创建的<em class="mp"> Not Found Error </em>。为此，我们实现了下一个中间件功能，称为<em class="mp"> errorHandler </em>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">errorHandler.js</figcaption></figure><p id="31dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有人点击了没有端点的路由，我们的API将返回一个包含错误消息的JSON对象，如果我们正在开发中运行，它也将返回堆栈。</p><p id="4249" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一步是将中间件添加到我们的<em class="mp"> server.js </em>中。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7f31" class="mv lt iq mr b gy mw mx l my mz">// After the other require statements:<br/>const notFound = require('./middleware/notFound');<br/>const errorHandler = require('./middleware/errorHandler');<br/>// Custom middleware here<br/>app.use(notFound);<br/>app.use(errorHandler);</span></pre><h2 id="6a52" class="mv lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">路由器</h2><p id="dc2b" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们离终点越来越近了。只剩下两步了。我们现在重点关注其中一个:增加一条路线。为此，我们需要问自己想要添加什么路线。在本文中，我想添加两个不同的获取路径，一个获取所有文章，另一个根据文章ID获取文章。让我们从实现文件<em class="mp"> post.js </em>中的路由开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">post.js</figcaption></figure><p id="998f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mp">快速路由器</em>让我们基于HTTP动词定义路由，如GET、POST等。我们只需要将我们稍后将实现的控制器方法添加到HTTP动词中，然后<em class="mp">路由器</em>就会施展他的魔法。在<em class="mp"> server.js </em>中，我们需要像这样添加路由器:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="e7b5" class="mv lt iq mr b gy mw mx l my mz">// Between helmet and custom middleware:<br/>// All routes here<br/>app.use('/api/posts', require('./routes/post'));</span></pre><p id="4798" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这将抛出一个错误，因为我们还没有实现<em class="mp">控制器函数</em>。</p><h2 id="049a" class="mv lt iq bd lu nr ns dn ly nt nu dp mc lf nv nw me lj nx ny mg ln nz oa mi ob bi translated">控制器</h2><p id="4524" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们处于REST-API模板的最后一步。控制器起作用。我们需要创建其中的两个，<em class="mp"> getPosts </em>和<em class="mp"> getPostById </em>。让我们通过在<em class="mp"> postsController.js </em>中实现这些方法来开始工作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">postsController.js</figcaption></figure><p id="f218" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在文件的顶部，我们有一些静态数据。之后，我们导出两个函数。第一个函数getPosts返回静态数据的完整列表。第二个方法getPostById，如果Id匹配，则从数组中返回一个对象；如果没有post匹配请求中提供的id，则返回一个错误。</p><p id="946f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要做的最后一件事是通过添加另一个中间件来为我们的应用程序启用JSON。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="159e" class="mv lt iq mr b gy mw mx l my mz">// Right below helmet:<br/>app.use(express.json());</span></pre><p id="a90d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">添加这个之后，我们的<em class="mp"> server.js </em>应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Final version of server.js</figcaption></figure><h1 id="352d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="ed81" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你现在可以输入<strong class="ky ir">http://localhost:5000/api/posts</strong>或者<strong class="ky ir">http://localhost:5000/API/posts/2</strong>来访问API(当它正在运行的时候)。我希望你喜欢这个设置模板express API的快速指南。您可以在此基础上添加数据库、身份验证和授权、更多端点等等。让我知道你对它的想法，如果你在这个模板上建立一些东西。整个项目可以在我的<a class="ae kv" href="https://github.com/JakobKIT/express_api_template" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到。</p></div></div>    
</body>
</html>