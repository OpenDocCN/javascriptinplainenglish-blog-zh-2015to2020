<html>
<head>
<title>One-Dimensional Cellular Automaton in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的一维元胞自动机</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/one-dimensional-cellular-automaton-in-javascript-85eb31ad6e67?source=collection_archive---------6-----------------------#2020-10-02">https://javascript.plainenglish.io/one-dimensional-cellular-automaton-in-javascript-85eb31ad6e67?source=collection_archive---------6-----------------------#2020-10-02</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><figure class="gm go jp jq jr js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj jo"><img src="../Images/2bb9be102b032610e281be5597c55787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JNhgWGjvEMxu7ulo9G89VA.png"/></div></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Rule 126</figcaption></figure><p id="9095" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">在这篇文章中，我将用JavaScript编写一个一维元胞自动机的简单实现。</p><p id="9ab8" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">细胞自动机的概念自20世纪中期就已经存在，并且已经发展成为一个具有许多实际和理论应用的广阔领域。</p><p id="2f84" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">细胞自动机由排列在1、2、3或更多维中的任意数量的“细胞”组成。每一个都有一个与之相关的状态(在最简单的情况下只是开或关)，每个单元以及整个自动机都根据一个或一组规则随时间从一个状态转换到下一个状态。</p><p id="cb4f" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">维度的数量、可能的细胞状态的数量和规则可以变得任意大和复杂，但是对于这个项目，我将实现最简单类型的一维细胞自动机，称为初等细胞自动机。</p><h2 id="d9ee" class="lb lc ir bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">基本细胞自动机</h2><p id="90dc" class="pw-post-body-paragraph kd ke ir kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ik bi translated">一个基本的细胞自动机由一排细胞组成，每一个细胞都可以“开”或“关”，在下表中用0和1表示。</p><figure class="ma mb mc md gu js gi gj paragraph-image"><div class="gi gj lz"><img src="../Images/8f7ec09ed1e7f6be54200e99371d6408.png" data-original-src="https://miro.medium.com/v2/resize:fit:324/format:webp/1*pPU3Z_4qd9NIIqtlQTNyBw.png"/></div></figure><p id="573a" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">为了计算每个单元的下一个状态，单个单元被认为具有由单元本身和两侧的两个单元组成的“邻域”。对于两端的单元，邻域的一部分是另一端的单元，因此自动机可以被认为是逻辑循环的。下表显示了以粗体显示的两个小区的邻域。</p><figure class="ma mb mc md gu js gi gj paragraph-image"><div class="gi gj me"><img src="../Images/b13052520d071b81c65ecf9f2c1add81.png" data-original-src="https://miro.medium.com/v2/resize:fit:334/format:webp/1*V08Vxv7F3-PcJdeZ3JUsWg.png"/></div></figure><p id="ddd7" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">有8个可能的邻域，因此用于设置下一个单元状态的规则可以用一个字节来表示。由所有可能的字节表示的十进制值0-255形成了众所周知的沃尔夫拉姆码，这是以史蒂夫·沃尔夫勒姆的名字命名的，他在该领域进行了研究，并写了《一种新的科学》一书。</p><p id="8e82" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">这是规则30的Wolfram代码，第二行的位形成二进制的30</p><figure class="ma mb mc md gu js gi gj paragraph-image"><div class="gi gj mf"><img src="../Images/1f68964313e8f9e08a598b01445df48f.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*Xaz9JbraicFYx5tULpE8jA.png"/></div></figure><p id="ba87" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">1D元胞自动机随时间变化的状态通常由连续的行表示，状态由不同颜色的块表示。在这个项目中，我将编写一个基于HTML/JavaScript的实现，这是一个使用规则109运行示例的截图。产生的一些模式可能比其他模式更有趣。</p><figure class="ma mb mc md gu js gi gj paragraph-image"><div role="button" tabindex="0" class="jt ju di jv bf jw"><div class="gi gj mg"><img src="../Images/3ed273425457153fb51a072c360af145.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PJ-ps4EqtKeCNg7YSrP6oA.png"/></div></div></figure><p id="30ee" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">该项目由以下文件以及css文件和图形组成，所有这些都可以从<a class="ae mh" href="https://github.com/CodeDrome/cellular-automata-1d-javascript" rel="noopener ugc nofollow" target="_blank"> Github库</a>中克隆/下载。</p><ul class=""><li id="894b" class="mi mj ir kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated">ca1d.js —实现细胞自动机本身</li><li id="267b" class="mi mj ir kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">ca1dsvg.js在HTML页面中输出ca1d.js中的细胞自动机</li><li id="6c30" class="mi mj ir kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">ca1d.htm—包含一个细胞自动机，它的输出和控制</li><li id="ab12" class="mi mj ir kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">ca1d page . js—ca1d.htm的后台代码</li></ul><p id="a9e6" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">首先让我们看一下<strong class="kf is"> ca1d.js </strong>，它作为ES6/ES2015类实现了一个细胞自动机，从构造函数开始。</p><figure class="ma mb mc md gu js"><div class="bz fq l di"><div class="mw mx l"/></div></figure><p id="851b" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">这里发生的事情不多，是吗？！我们所做的就是为属性创建一些后备变量。</p><figure class="ma mb mc md gu js"><div class="bz fq l di"><div class="mw mx l"/></div></figure><p id="cf96" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">前两个属性是数组，最初为空，可以向其中添加函数，当当前状态或单元格数量发生变化时会调用这些函数。这使得任何负责绘制细胞自动机的代码都包含对<code class="fe my mz na nb b">CellularAutomaton1D</code>对象的引用，并向其添加事件处理程序。然后，这些事件处理程序将做任何必要的事情来绘制自动机的可视化输出。这使得细胞自动机和它的视觉输出完全分离。我将使用<code class="fe my mz na nb b">CellularAutomaton1DSVG</code>类，但是你可以编写并“插入”你自己的实现，而不用修改<code class="fe my mz na nb b">CellularAutomaton1D</code>类。</p><p id="8fbf" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">然后我们又多了几处房产。请注意，最后一个按钮<code class="fe my mz na nb b">NumberOfCells</code>触发了一个适当的事件，以便插入的任何UI都知道如何更新自己。</p><figure class="ma mb mc md gu js"><div class="bz fq l di"><div class="mw mx l"/></div></figure><p id="fa87" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">前两个方法调用了<code class="fe my mz na nb b">_StateChangedEventHandlers</code>和<code class="fe my mz na nb b">_NumberOfCellsChangedEventHandlers</code>数组中的所有函数。通常只有一个，但如果你愿意，你可以添加更多。</p><p id="1f99" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">接下来是<code class="fe my mz na nb b">Randomize</code>方法。这会以相等的概率将每个单元格随机设置为0或1。</p><p id="60ac" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated"><code class="fe my mz na nb b">InitializeToCentre</code>方法将所有单元格设置为0，除了设置为1的中间单元格。</p><p id="1ead" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">方法是最复杂的，位于类的核心。首先，我们需要将规则转换为二进制数，转换为字符串并填充到8位。例如，规则30变为“00011110”。</p><p id="67a0" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">然后我们迭代单元格，首先获取前一个和下一个单元格的索引，并允许第一个和最后一个单元格滚动到另一端。然后，我们可以将三个单元的邻域值设置为一个字符串。</p><p id="a8b2" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">然后，在一个开关块中，我们将<code class="fe my mz na nb b">_NextState</code>数组中的相关单元设置为正确的值。我们需要在一个单独的数组中设置下一个状态；就地设置单元格会打乱连续单元格下一个值的计算。循环结束后，我们只需将新状态复制到当前状态，并触发相关事件。</p><p id="1509" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">最后一个方法是<code class="fe my mz na nb b">Iterate</code>，它简单地循环函数参数中的迭代次数，每次调用<code class="fe my mz na nb b">CalculateNextState</code>。</p><p id="65fd" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">现在我们可以转到显示细胞自动机的代码，也是一个类。</p><figure class="ma mb mc md gu js"><div class="bz fq l di"><div class="mw mx l"/></div></figure><p id="4a46" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">在为各种属性设置了一些支持变量之后，我们为<code class="fe my mz na nb b">CellularAutomaton1D</code>类事件设置了几个处理程序。对于状态改变，我们需要调用函数来增加SVG元素的高度，以容纳额外的一行，然后绘制该行。对于单元格数量的变化，我们需要改变宽度以适应新的单元格数量。</p><p id="5e6b" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">最后，我们需要调用函数来设置SVG元素的初始宽度和高度。</p><figure class="ma mb mc md gu js"><div class="bz fq l di"><div class="mw mx l"/></div></figure><p id="1e4a" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">这里没有什么令人兴奋的事情发生——只有一些getters和setters。</p><figure class="ma mb mc md gu js"><div class="bz fq l di"><div class="mw mx l"/></div></figure><h2 id="2d9c" class="lb lc ir bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">_DrawState</h2><p id="4584" class="pw-post-body-paragraph kd ke ir kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ik bi translated">该函数为每个单元格创建一个新元素，设置其大小、位置和颜色，并将其添加到SVG元素中。总体效果是在显示的底部添加一行新的单元格。</p><h2 id="37ce" class="lb lc ir bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">_SetHeight和_SetWidth</h2><p id="f055" class="pw-post-body-paragraph kd ke ir kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ik bi translated">设置SVG元素相关属性的非常简单的函数。</p><h2 id="1f12" class="lb lc ir bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">清楚的</h2><p id="ccbf" class="pw-post-body-paragraph kd ke ir kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ik bi translated">从SVG元素中移除所有元素，同时重置迭代，并将SVG元素的大小设置为0，从而有效地隐藏它。</p><h2 id="91c1" class="lb lc ir bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">ca1d.htm</h2><p id="97de" class="pw-post-body-paragraph kd ke ir kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ik bi translated">我没有在这里列出页面的HTML，但是它包含在zip和Github库中。它只包含屏幕截图中显示的控件和SVG元素。</p><h2 id="ac45" class="lb lc ir bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">ca1dpage.js</h2><p id="e5c8" class="pw-post-body-paragraph kd ke ir kf b kg lu ki kj kk lv km kn ko lw kq kr ks lx ku kv kw ly ky kz la ik bi translated">同样，这里我没有展示代码，但是它创建了<code class="fe my mz na nb b">CellularAutomaton1D</code>和<code class="fe my mz na nb b">CellularAutomaton1DSVG</code>类的实例，以及在各种控件的事件处理程序中设置属性或调用方法。</p><p id="2802" class="pw-post-body-paragraph kd ke ir kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ik bi translated">在你的浏览器中打开<strong class="kf is">ca1d.htm</strong>，设置一个规则，点击初始化到中心按钮，然后点击运行按钮。这里有几个例子。</p><figure class="ma mb mc md gu js gi gj paragraph-image"><div class="gi gj nc"><img src="../Images/cee5f28b0a87804268921b5b875d16d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*ZZSolwbC5s9WMzP-TuDhbw.png"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Rule 22</figcaption></figure><figure class="ma mb mc md gu js gi gj paragraph-image"><div class="gi gj nd"><img src="../Images/0e478fa15715fdcd4334dd86b31d7bf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:784/format:webp/1*VOXgKYT9GVSUpnp68YR33Q.png"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Rule 122</figcaption></figure><figure class="ma mb mc md gu js gi gj paragraph-image"><div class="gi gj nc"><img src="../Images/d343c76b0f04ce9deb2d7f33ef786399.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*jzvFdYmTGBALtuyXMxFVdA.png"/></div><figcaption class="jz ka gk gi gj kb kc bd b be z dk">Rule 158</figcaption></figure></div></div>    
</body>
</html>