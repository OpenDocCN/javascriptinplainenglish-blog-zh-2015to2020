<html>
<head>
<title>JavaScript Type Checking with Flow — Utility Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用流检查JavaScript类型—实用程序类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-type-checking-with-flow-utility-types-1172205a981b?source=collection_archive---------7-----------------------#2020-02-24">https://javascript.plainenglish.io/javascript-type-checking-with-flow-utility-types-1172205a981b?source=collection_archive---------7-----------------------#2020-02-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4ebd3bb97ff8f4414cf7c203de313b6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TFmeMxXh5L3BX9ZN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@theframedbear?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">The Framed Bear</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8a5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Flow是一个由脸书开发的类型检查器，用于检查JavaScript数据类型。它有许多内置的数据类型，我们可以用它们来注释变量和函数参数的类型。</p><p id="03af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看Flow自带的一些内置的实用程序类型。</p><h1 id="31a8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">$Keys <t/></h1><p id="8db6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">$Keys&lt;T&gt;</code>类型从一个类型中获取属性，并将其作为自己的类型。它对于创建枚举也很有用。</p><p id="e1f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7cf3" class="mq lc iq mh b gy mr ms l mt mu">const fruits = {<br/>  apple: 'Apple',<br/>  orange: 'Orange',<br/>  banana: 'Banana'<br/>};</span><span id="b9f4" class="mq lc iq mh b gy mv ms l mt mu">type Fruit = $Keys&lt;typeof fruits&gt;;<br/>let a: Fruit = 'apple';</span></pre><p id="0697" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将使用<code class="fe me mf mg mh b">fruits</code>对象的键的联合定义一个新的类型<code class="fe me mf mg mh b">Fruit</code>。这意味着对于一个类型为<code class="fe me mf mg mh b">Fruit</code>的变量，我们可以给它赋值<code class="fe me mf mg mh b">'apple'</code>、<code class="fe me mf mg mh b">'orange'</code>或<code class="fe me mf mg mh b">'banana'</code>。</p><p id="f885" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分配其他值会给我们带来一个错误:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ed2f" class="mq lc iq mh b gy mr ms l mt mu">let b: Fruit = 'grape';</span></pre><h1 id="3eac" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">$Values <t/></h1><p id="acc0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类型让我们获得一个对象类型的类型，并从它们的联合中创建一个类型。</p><p id="9b5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="057f" class="mq lc iq mh b gy mr ms l mt mu">type Person = {<br/>  name: string,<br/>  age: number,<br/>};</span><span id="6859" class="mq lc iq mh b gy mv ms l mt mu">type PersonValues = $Values&lt;Person&gt;;<br/>let a: PersonValues = 1;<br/>let b: PersonValues = 'Joe';</span></pre><p id="ba12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在代码中，我们定义了带有一些属性的<code class="fe me mf mg mh b">Person</code>类型，然后<code class="fe me mf mg mh b">$Values&lt;Person&gt;</code>接受<code class="fe me mf mg mh b">name</code>和<code class="fe me mf mg mh b">age</code>的类型并从中创建一个联合。所以<code class="fe me mf mg mh b">PeronValues</code>的类型是<code class="fe me mf mg mh b">string | number</code>。</p><h1 id="bd25" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">$ReadOnly <t/></h1><p id="03e4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">$ReadOnly&lt;T&gt;</code>获取类型<code class="fe me mf mg mh b">T</code>的只读版本。</p><p id="4dc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下内容:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="209c" class="mq lc iq mh b gy mr ms l mt mu">type ReadOnlyObj = {<br/>  +foo: string<br/>};</span></pre><p id="27be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dc19" class="mq lc iq mh b gy mr ms l mt mu">type ReadOnlyObj = <!-- -->$ReadOnly&lt;<!-- -->{<br/>  foo: string<br/>}&gt;;</span></pre><p id="c7ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是等价的。</p><p id="2d32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们想将一个对象类型的所有属性重定义为只读时，这很方便。</p><p id="b70b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码来定义只读类型和对象:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2cf6" class="mq lc iq mh b gy mr ms l mt mu">type Person  = {<br/>  name: string,<br/>  age: number,<br/>};</span><span id="bc2a" class="mq lc iq mh b gy mv ms l mt mu">type ReadOnlyPerson = $ReadOnly&lt;Person&gt;;</span><span id="bc45" class="mq lc iq mh b gy mv ms l mt mu">let person: ReadOnlyPerson = {<br/>  name: 'Joe',<br/>  age: 10<br/>}</span></pre><p id="da24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们试图在<code class="fe me mf mg mh b">person</code>对象中重新分配一个属性时，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fde0" class="mq lc iq mh b gy mr ms l mt mu">person.name = 'Bob';</span></pre><p id="57b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会得到一个错误。</p><h1 id="aa60" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">$Exact <t/></h1><p id="53d0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">$Exact&lt;T&gt;</code>让我们从一个对象类型创建一个精确的类型。</p><p id="9240" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="db5d" class="mq lc iq mh b gy mr ms l mt mu">type ExactPerson = $Exact&lt;{name: string}&gt;;</span></pre><p id="4611" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与以下内容相同:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c6a0" class="mq lc iq mh b gy mr ms l mt mu">type ExactPerson = {| name: string |};</span></pre><h1 id="d6a7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">$Diff <a b=""/></h1><p id="42da" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">$Diff&lt;A, B&gt;</code>创建一个类型，其属性在<code class="fe me mf mg mh b">A</code>中，但不在<code class="fe me mf mg mh b">B</code>中，它们都是对象类型。和<code class="fe me mf mg mh b">A \ B</code>一样，是<code class="fe me mf mg mh b">A</code>和<code class="fe me mf mg mh b">B</code>的设定区别。</p><p id="96d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有两种类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b346" class="mq lc iq mh b gy mr ms l mt mu">type Person  = {<br/>  name: string,<br/>  age: number,<br/>};</span><span id="e9cb" class="mq lc iq mh b gy mv ms l mt mu">type Age = { age: number };</span></pre><p id="7e70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以创建一个接受<code class="fe me mf mg mh b">name</code>属性的对象类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5dba" class="mq lc iq mh b gy mr ms l mt mu">type Name = $Diff&lt;Person, Age&gt;;</span></pre><p id="0b17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们创建一个类型为<code class="fe me mf mg mh b">Name</code>的对象时，我们需要<code class="fe me mf mg mh b">name</code>属性:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="01cd" class="mq lc iq mh b gy mr ms l mt mu">let name: Name = { name: 'Mary' };</span></pre><p id="5120" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">name</code>属性不包含在对象中:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5313" class="mq lc iq mh b gy mr ms l mt mu">let foo: Name = { age: 10 };</span></pre><p id="011b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会得到一个错误。</p><h1 id="a956" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">$Rest <a b=""/></h1><p id="18d9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">$Rest&lt;A, B&gt;</code>类似于<code class="fe me mf mg mh b">$Diff&lt;A, B&gt;</code>，但是属性检查是在运行时完成的。属性是rest操作符的一部分。</p><p id="db88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导致<code class="fe me mf mg mh b">A</code>的自有属性不是<code class="fe me mf mg mh b">B</code>的自有属性。在Flow中，精确的对象类型被视为具有自己的属性。</p><p id="960d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过运行以下命令用<code class="fe me mf mg mh b">$Rest&lt;A, B&gt;</code>定义一个新的对象类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e8fa" class="mq lc iq mh b gy mr ms l mt mu">type Person = { name: string, age: number };<br/>const person: Person = {name: 'Jon', age: 42};<br/>const {age, ...rest} = person;<br/>(name: $Rest&lt;Person, {|age: number|}&gt;);</span></pre><p id="0367" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，<code class="fe me mf mg mh b">name</code>对象不能再有属性<code class="fe me mf mg mh b">age</code>，因为我们把它转换成了<code class="fe me mf mg mh b">$Rest&lt;Person, {|age: number|}&gt;</code>类型。<code class="fe me mf mg mh b">$Rest&lt;Person, {|age: number|}&gt;</code>返回从<code class="fe me mf mg mh b">Person</code>类型中移除了<code class="fe me mf mg mh b">age</code>属性的新类型。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/c3f8367f1db7734a5561744d07a4fbf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o4g3kubU9o1AtCqc"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nicolasjleclercq?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nicolas J Leclercq</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0363" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">$PropertyType <t k=""/></h1><p id="9a24" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">$PropertyType&lt;T, k&gt;</code>从类型<code class="fe me mf mg mh b">T</code>中获取键<code class="fe me mf mg mh b">k</code>的类型。键<code class="fe me mf mg mh b">k</code>是一个字符串。例如，如果我们如下创建<code class="fe me mf mg mh b">Person</code>类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0dda" class="mq lc iq mh b gy mr ms l mt mu">type Person = { name: string, age: number };</span></pre><p id="4d97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe me mf mg mh b">$PropertyType&lt;Person, ‘name’&gt;</code>将为我们获取<code class="fe me mf mg mh b">string</code>类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6faa" class="mq lc iq mh b gy mr ms l mt mu">let foo: $PropertyType&lt;Person, 'name'&gt; = 'name';</span></pre><p id="eb08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">嵌套查找也有效。例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0072" class="mq lc iq mh b gy mr ms l mt mu">type Person = { <br/>  name: {<br/>    firstName: string,<br/>    lastName: string<br/>  }, <br/>  age: number <br/>};</span><span id="7ce7" class="mq lc iq mh b gy mv ms l mt mu">let foo: &lt;$PropertyType&lt;$PropertyType&lt;Person, 'name'&gt;, 'firstName'&gt; = 'name';</span></pre><h1 id="0ad6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">$ElementType <t k=""/></h1><p id="2f20" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">$ElementType&lt;T, K&gt;</code>是表示数组、元组或对象类型<code class="fe me mf mg mh b">T</code>中与键名<code class="fe me mf mg mh b">K</code>匹配的每个元素的类型。</p><p id="2d21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a52e" class="mq lc iq mh b gy mr ms l mt mu">type Person = { <br/>  name: string, <br/>  age: number <br/>};</span></pre><p id="6a50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以用它来获取<code class="fe me mf mg mh b">name</code>属性的类型，方法是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3272" class="mq lc iq mh b gy mr ms l mt mu">$ElementType&lt;Person, 'name'&gt;</span></pre><p id="b6ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用它来注释其他变量的类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d4ac" class="mq lc iq mh b gy mr ms l mt mu">let foo: $ElementType&lt;Person, 'name'&gt; = 'name';</span></pre><p id="8790" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将它与元组一起使用，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7f67" class="mq lc iq mh b gy mr ms l mt mu">type Tuple = [boolean, string];<br/>let foo: $ElementType&lt;Tuple, 0&gt; = true;</span></pre><p id="e001" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于动态对象类型，我们可以将键的类型直接传递给第二个参数。例如，如果我们有以下类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6460" class="mq lc iq mh b gy mr ms l mt mu">type DynamicObj = { [key: string]: number };</span></pre><p id="7e5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过编写以下内容来获得带有<code class="fe me mf mg mh b">$ElementType</code>的属性键的类型:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ef73" class="mq lc iq mh b gy mr ms l mt mu">let x: $ElementType&lt;DynamicObj, string&gt; = 1;</span></pre><p id="9ff8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于数组，我们可以写如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a53f" class="mq lc iq mh b gy mr ms l mt mu">type StrArrayObj = {<br/>  strings: Array&lt;string&gt;,<br/>};</span><span id="bb39" class="mq lc iq mh b gy mv ms l mt mu">let x: $ElementType&lt;$ElementType&lt;StrArrayObj, 'strings'&gt;, number&gt; = 'abc';</span></pre><p id="2d61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码工作如下。<code class="fe me mf mg mh b">$ElementType&lt;StrArrayObj, ‘strings’&gt;</code>获取<code class="fe me mf mg mh b">StrArrayObj</code>的<code class="fe me mf mg mh b">strings</code>属性的类型。然后我们将<code class="fe me mf mg mh b">$ElementType</code>与<code class="fe me mf mg mh b">$ElementType&lt;StrArrayObj, ‘strings’&gt;</code>和<code class="fe me mf mg mh b">number</code>相结合，得到<code class="fe me mf mg mh b">strings</code>的数组元素的类型。</p><p id="b40e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">number</code>用于检索<code class="fe me mf mg mh b">strings</code>数组的索引。</p><p id="5153" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Flow有许多有用的实用程序类型，这使得创建新类型更加容易。我们可以获取一个对象的键来创建一个新的联合类型。此外，我们可以获取值的类型，并根据它们创建一个新的联合类型。</p><p id="5200" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，还有一种将所有属性都改为只读的类型。我们还可以获得对象键、元组或数组条目的类型。</p></div></div>    
</body>
</html>