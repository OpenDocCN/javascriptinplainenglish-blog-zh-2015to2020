<html>
<head>
<title>Deno vs. Node — The Neverending Challenge of JavaScript Runtimes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">deno vs . Node——JavaScript运行时的永无止境的挑战</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/deno-vs-node-658fc5e1fb5c?source=collection_archive---------4-----------------------#2020-12-26">https://javascript.plainenglish.io/deno-vs-node-658fc5e1fb5c?source=collection_archive---------4-----------------------#2020-12-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f6f8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Deno vs. Node —有什么区别，哪个更好？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/ca72ae7ca48c9d4f9d4587f2f41de92d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JWh5J-K8NbZnoL1nNaigRw.png"/></div></div></figure><p id="d380" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Node.js的创始人Ryan Dahl在过去的几年里一直致力于开发新的Javascript运行时Deno，根据Ryan自己的说法，它应该可以解决困扰Node.js的所有问题。</p><p id="8bd4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">不要误会，Node.js是一个很棒的运行时，主要得益于庞大的userland模块和JavaScript的使用；然而，Dahl自己也承认，他没有考虑一些基本的方面，例如安全性、模块和依赖关系等等。</p><p id="4f65" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是为Ryan辩护，他在他的时代从来没有想到这个平台会在如此短的时间内增长如此之快。</p><p id="c426" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">必须指出的是，在2009年，JavaScript仍然是那种每个人都取笑的语言，今天出现的许多功能都不存在。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lk ll l"/></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">Ryan Dahl</figcaption></figure><h1 id="0a4a" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">什么是德诺？</h1><p id="3a95" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">Deno是基于Google的JavaScript运行时V8的TypeScript运行时；如果你熟悉流行的服务器端JavaScript生态系统Node.js，你就会明白Deno完全一样。除了在设计上做了一些改进:</p><ul class=""><li id="57f2" class="mn mo in kq b kr ks ku kv kx mp lb mq lf mr lj ms mt mu mv bi translated">它基于JavaScript语言的现代功能；</li><li id="5d2f" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">它有一个广泛的标准库；</li><li id="5325" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">它原生支持TypeScript</li><li id="7eb7" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">支持EcmaScript模块；</li><li id="fc51" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">它没有像npm那样的集中式包管理器；</li><li id="a8b1" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">它有几个内置的工具，如依赖检查器和代码格式化程序；</li><li id="61d0" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">旨在尽可能与浏览器兼容；</li><li id="2687" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">安全性是主要特点。</li></ul><h1 id="4248" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">与Node.js的主要区别是什么？</h1><p id="b56a" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">我认为Deno的主要目标是取代Node.js，然而有一些重要的共同特征。例如:</p><ul class=""><li id="3d8f" class="mn mo in kq b kr ks ku kv kx mp lb mq lf mr lj ms mt mu mv bi translated">两者都是由瑞安·达尔创作的；</li><li id="8a99" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">两者都是基于谷歌的V8引擎开发的；</li><li id="7553" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">两者都是为了执行服务器端JavaScript而开发的。</li></ul><p id="3b1a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但另一方面，也有一些重要的不同之处:</p><ul class=""><li id="7310" class="mn mo in kq b kr ks ku kv kx mp lb mq lf mr lj ms mt mu mv bi translated"><strong class="kq io">生锈和打字稿</strong>。与用C++和JavaScript编写的Node.js不同，Deno是用Rust和TypeScript编写的。</li><li id="8aff" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><strong class="kq io">东京</strong>。作为一个事件驱动的异步平台，取代了libuv。</li><li id="24f8" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><strong class="kq io">包装经理</strong>。与Node.js不同，Deno没有集中的包管理器，因此可以从URL导入任何ECMAScript模块。</li><li id="49c5" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><strong class="kq io"> ECMAScript </strong>。Deno在其所有API中使用现代ECMAScript功能，而Node.js使用标准的基于回调的库。</li><li id="5fa6" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><strong class="kq io">安全</strong>。Node.js程序默认情况下从运行脚本的系统用户那里继承权限，与之不同，Deno程序在沙箱中运行。例如，对文件系统、网络资源等的访问。必须被授予标志权限。</li></ul><h1 id="5135" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">装置</h1><p id="0537" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">Deno是一个独立的可执行文件。我们可以通过从<a class="ae nb" href="https://github.com/denoland/deno/releases" rel="noopener ugc nofollow" target="_blank">本页</a>下载二进制版本在我们的机器上安装它，或者我们可以下载并执行下面列出的安装程序之一。</p><h2 id="6dde" class="nc lr in bd ls nd ne dn lw nf ng dp ma kx nh ni mc lb nj nk me lf nl nm mg nn bi translated">Shell (Mac、Linux)</h2><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="6363" class="nc lr in np b gy nt nu l nv nw">$ curl -fsSL https://deno.land/x/install/install.sh | sh</span></pre><h2 id="6a64" class="nc lr in bd ls nd ne dn lw nf ng dp ma kx nh ni mc lb nj nk me lf nl nm mg nn bi translated">PowerShell (Windows)</h2><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="7e02" class="nc lr in np b gy nt nu l nv nw">$ iwr https://deno.land/x/install/install.ps1 -useb | iex</span></pre><h2 id="aa7c" class="nc lr in bd ls nd ne dn lw nf ng dp ma kx nh ni mc lb nj nk me lf nl nm mg nn bi translated">自制软件(Mac OS)</h2><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="3b69" class="nc lr in np b gy nt nu l nv nw">$ brew install deno</span></pre><h1 id="ad7d" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">让我们来看看安全性</h1><p id="c4ef" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">Deno的主要特性之一是安全性。与Node.js相比，Deno在沙箱中执行源代码，这意味着运行时:</p><ul class=""><li id="988b" class="mn mo in kq b kr ks ku kv kx mp lb mq lf mr lj ms mt mu mv bi translated">无权访问文件系统；</li><li id="b11b" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">无权访问网络资源；</li><li id="e9c4" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">无法执行其他脚本；</li><li id="7bb1" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">无权访问环境变量。</li></ul><p id="b7e6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们举个简单的例子。考虑以下脚本:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="e7df" class="nc lr in np b gy nt nu l nv nw"><em class="nx">async</em> function main () {<br/>  const encoder <strong class="np io">=</strong> <strong class="np io">new</strong> TextEncoder ()<br/>  const data <strong class="np io">=</strong> encoder<strong class="np io">.</strong>encode ('Hello Deno! 🦕 \n')<br/>  <strong class="np io">await</strong> Deno<strong class="np io">.</strong>writeFile( 'hello.txt' , data)<br/>}<br/>main()</span></pre><p id="30e8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">剧本真的很简单。它只是创建一个名为<code class="fe ny nz oa np b">hello.txt</code>的文本文件，其中包含字符串<code class="fe ny nz oa np b">Hello Deno </code>🦕。真的简单！还是没有？</p><p id="8113" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如我们之前所说的，代码将在沙箱中运行，显然，它不能访问文件系统。事实上，如果我们用以下命令执行脚本:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="1eec" class="nc lr in np b gy nt nu l nv nw">$ deno run hello-world.ts</span></pre><p id="09e3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它将在终端上打印如下内容:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="b008" class="nc lr in np b gy nt nu l nv nw">Check file:///home/davide/denoExample/hello-world.ts<br/>error: Uncaught PermissionDenied: write access to "hello.txt", run again with the --allow-write flag<br/>    at unwrapResponse ($deno$/ops/dispatch_json.ts:42:11)<br/>    at Object.sendAsync ($deno$/ops/dispatch_json.ts:93:10)<br/>    at async Object.open ($deno$/files.ts:38:15)<br/>    at async Object.writeFile ($deno$/write_file.ts:61:16)<br/>    at async file:///home/davide/projects/denoExample/hello-world.ts:5:3</span></pre><p id="393b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">正如我们所看到的，错误信息非常清楚。文件没有在文件系统上创建，因为脚本没有写权限，但是通过添加标志<code class="fe ny nz oa np b">--allow-write</code>:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="464b" class="nc lr in np b gy nt nu l nv nw">$ deno run --allow-write hello-world.ts</span></pre><p id="e8b0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">脚本将无错误地结束，并且文件<code class="fe ny nz oa np b">hello.txt</code>已在当前工作目录中正确创建。</p><p id="838a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">除了让我们访问文件系统的标志<code class="fe ny nz oa np b">--allow-write</code>之外，还有其他标志，比如让我们访问网络资源的标志<code class="fe ny nz oa np b">--allow-net</code>，或者对运行外部脚本或子进程有用的标志<code class="fe ny nz oa np b">--allow-run</code>。我们可以在以下网址找到完整的许可列表<a class="ae nb" href="https://deno.land/manual/getting_started/permissions" rel="noopener ugc nofollow" target="_blank">https://deno.land/manual/getting_started/permissions</a>。</p><h1 id="e46c" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">简单的服务器</h1><p id="dd45" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">现在我们将创建一个简单的服务器，它接受端口<code class="fe ny nz oa np b">8000</code>上的连接，并向客户机返回字符串<code class="fe ny nz oa np b">Hello Deno</code>。</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="aae3" class="nc lr in np b gy nt nu l nv nw">// file server.ts<br/><em class="nx">import</em> { serve } <em class="nx">from</em> 'https://deno.land/std/http/server.ts'</span><span id="aa1d" class="nc lr in np b gy ob nu l nv nw">const s <strong class="np io">=</strong> serve({ port: 8000 })<br/>console<strong class="np io">.</strong>log('Server listening on port :8000')<br/><strong class="np io">for</strong> <strong class="np io">await</strong> (const req <strong class="np io">of</strong> s) {<br/>  req<strong class="np io">.</strong>respond({ body: 'Hello Deno!\n' })<br/>}</span></pre><p id="162e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">显然，要运行这个脚本，我们需要指定<code class="fe ny nz oa np b">--allow-net</code>标志:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="7fe2" class="nc lr in np b gy nt nu l nv nw">$ deno run --allow-net server.ts</span></pre><p id="5e61" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的终端上会出现类似这样的东西:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/c3e16b159370daaba01184594e5dc79c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*PrR84E8KjKPhknUlIexmkg.png"/></div></figure><p id="27cf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，如果我们打开我们最喜欢的浏览器，或者如果我们想使用<code class="fe ny nz oa np b">curl</code>命令，我们可以测试URL <code class="fe ny nz oa np b">http://localhost:8000</code>。结果将是这样的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi od"><img src="../Images/73e792cbbc3b12afafd6b70aa3177f55.png" data-original-src="https://miro.medium.com/v2/resize:fit:636/format:webp/1*omY7w9dMQpbVmPFbouwdxA.png"/></div></div></figure><h1 id="9f9f" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">模块</h1><p id="1e6b" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">就像浏览器一样，Deno通过URL加载他所有的模块。许多人最初对这种方法感到困惑，但这是有道理的。这里有一个例子:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="1609" class="nc lr in np b gy nt nu l nv nw">import { assertEquals } from "https://deno.land/std/testing/asserts.ts";</span></pre><p id="55e4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过URL导入包有其优点和缺点。主要优点是:</p><ul class=""><li id="eddd" class="mn mo in kq b kr ks ku kv kx mp lb mq lf mr lj ms mt mu mv bi translated">更大的灵活性；</li><li id="db01" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">我们可以创建一个包，而不用将它发布到公共存储库中(如npm)。</li></ul><p id="be9b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我认为，一种包管理器可以在未来发布，但目前还没有正式发布。</p><p id="62d2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Deno的官方网站给了我们机会来托管我们的源代码，然后通过网址发布:<a class="ae nb" href="https://deno.land/x/" rel="noopener ugc nofollow" target="_blank">https://deno.land/x/</a>。</p><p id="8570" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过URL导入包给了开发人员他们需要的自由，可以在任何他们想要的地方托管他们的代码:最好的分散。因此，我们不需要<code class="fe ny nz oa np b">package.json</code>文件或<code class="fe ny nz oa np b">node_modules</code>目录。</p><p id="0e9b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当应用程序启动时，所有导入的包都被下载、编译并存储在缓存中。如果我们想再次下载所有的包，我们需要指定旗帜<code class="fe ny nz oa np b">--reload</code>。</p><h2 id="84bf" class="nc lr in bd ls nd ne dn lw nf ng dp ma kx nh ni mc lb nj nk me lf nl nm mg nn bi translated">我需要每次都输入网址吗？🤯🤬</h2><p id="280f" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">Deno本机支持<a class="ae nb" href="https://github.com/WICG/import-maps" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">导入地图</strong> </a>。这意味着可以指定一个类似<code class="fe ny nz oa np b">--importmap=&lt;FILENAME&gt;</code>的特殊命令标志。让我们看一个简单的例子。</p><p id="2d51" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设我们有一个文件<code class="fe ny nz oa np b">import_map.json</code>，里面有以下内容:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="cbff" class="nc lr in np b gy nt nu l nv nw">{<br/>  "imports": {<br/>    "fmt/": "https://deno.land/std@0.65.0/fmt/"<br/>  }<br/>}</span></pre><p id="fedb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">该文件指定在<code class="fe ny nz oa np b">/ftm</code>键处，在<code class="fe ny nz oa np b">imports</code>对象中，对应于URL <code class="fe ny nz oa np b"><a class="ae nb" href="https://deno.land/sdt@0.65.0/ftm/" rel="noopener ugc nofollow" target="_blank">https://deno.land/sdt@0.65.0/ftm/</a></code>，可以如下使用:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="1c6e" class="nc lr in np b gy nt nu l nv nw">// file colors.ts<br/><em class="nx">import</em> { green } <em class="nx">from</em> "fmt/colors.ts";</span><span id="ac3d" class="nc lr in np b gy ob nu l nv nw">console<strong class="np io">.</strong>log(green("Hello Deno! 🦕"));</span></pre><p id="3821" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个功能现在不稳定，我们需要使用标志<code class="fe ny nz oa np b">--unstable</code>运行我们的脚本<code class="fe ny nz oa np b">color.ts</code>，所以:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="9435" class="nc lr in np b gy nt nu l nv nw">$ deno run --unstable --importmap=import_map.json colors.ts</span></pre><p id="b3bb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在在我们的终端里出现了这样的东西:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/fff1e97192ade3b6873fdb3f304ec1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*QaQq67u0KOJztN28QgwUJg.png"/></div></figure><h2 id="c81f" class="nc lr in bd ls nd ne dn lw nf ng dp ma kx nh ni mc lb nj nk me lf nl nm mg nn bi translated">版本控制</h2><p id="b00a" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">包版本控制是开发人员的责任，在客户端，我们可以在导入包时决定在包的URL中使用特定的版本:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="2bfa" class="nc lr in np b gy nt nu l nv nw">https://unpkg.com/package-name@0.0.5/dist/package-name.js</span></pre><h1 id="5959" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">准备使用实用程序</h1><p id="8165" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">老实说:开发者的JavaScript工具的当前状态是非常混乱的！当添加TypeScript类型时，混乱会变得更糟。😱</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi of"><img src="../Images/2dd36d5b3cd32c26468f560c74b0a34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TeB6IgrAMdE_CQXnTqX4Cw.jpeg"/></div></div><figcaption class="lm ln gj gh gi lo lp bd b be z dk">Photo by <a class="ae nb" href="https://unsplash.com/@ryansnaadt?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ryan Snaadt</a> on <a class="ae nb" href="https://unsplash.com/s/photos/scream?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8e5d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">JavaScript最好的特性之一是代码不需要编译，可以在浏览器中立即执行。这使得开发人员的生活变得更加容易，并且很容易获得对所写代码的即时反馈。然而，不幸的是，这种过去时期的简单性并没有被我所认为的<em class="nx">“过度工具崇拜”</em>所确定。这些工具将JavaScript开发变成了一场真正的复杂性噩梦。Webpack配置指南有完整的在线课程！是的，你答对了…一整个课程！</p><p id="ab49" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">工具的混乱已经增加到许多开发人员渴望回到实际编写代码而不是玩弄配置文件的地步。一个旨在解决这个问题的新兴项目是脸书的罗马项目。</p><p id="8a90" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">另一方面，Deno有一个完整的生态系统，比如运行时和模块管理。这种方法为开发人员提供了构建应用程序所需的所有工具。现在，让我们看看Deno 1.6生态系统提供的工具，以及开发人员如何使用它们来减少对第三方的依赖并简化开发。</p><p id="e522" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在Deno中替换整个构建管道是不可能的，但是我认为我们不会在拥有它之前等待太久。下面是集成功能的列表:</p><ul class=""><li id="94c7" class="mn mo in kq b kr ks ku kv kx mp lb mq lf mr lj ms mt mu mv bi translated"><strong class="kq io"> bundler: </strong>它在单个JavaScript文件中写入指定的模块及其所有依赖关系；</li><li id="9bcb" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><strong class="kq io">调试器:</strong>它让我们能够用Chrome Devtools、VS Code以及其他工具调试我们的Deno程序；</li><li id="c192" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><strong class="kq io">依赖检查器:</strong>如果我们在一个ES模块上执行这个工具，它会显示所有的依赖树；</li><li id="31f1" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><strong class="kq io">文档生成器:</strong>它分析给定文件中的所有JSDoc注释，并为我们生成文档；</li><li id="c41f" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><strong class="kq io">格式化程序:</strong>自动格式化JavaScript或TypeScript代码；</li><li id="c244" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><strong class="kq io"> test runner: </strong>这是一个实用程序，它让我们能够使用标准库的<code class="fe ny nz oa np b">assertions</code>模块来测试我们的源代码。</li><li id="e394" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated">用于识别我们程序中潜在的错误。</li></ul><h2 id="7c96" class="nc lr in bd ls nd ne dn lw nf ng dp ma kx nh ni mc lb nj nk me lf nl nm mg nn bi translated">打包机</h2><p id="b58e" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">Deno可以使用<code class="fe ny nz oa np b">deno bundle</code>命令从命令行创建一个简单的包，但是它在内部公开了一个API。有了这个API，开发者可以创建一个定制的输出，或者可以用于前端的东西。这个API不稳定，所以我们需要使用<code class="fe ny nz oa np b">--unstable</code>标志。让我们以前面的例子为例，修改如下:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="bfec" class="nc lr in np b gy nt nu l nv nw">// file colors.ts<br/><em class="nx">import</em> { green } <em class="nx">from "</em>https://deno.land/std@0.65.0/fmt/colors.ts";</span><span id="d373" class="nc lr in np b gy ob nu l nv nw">console<strong class="np io">.</strong>log(green("Hello Deno! 🦕"));</span></pre><p id="9ccf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在让我们从命令行创建我们的包:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="d029" class="nc lr in np b gy nt nu l nv nw">$ deno bundle colors.ts colors.bundle.js</span></pre><p id="37cf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个命令创建了一个文件<code class="fe ny nz oa np b">colors.bundle.js</code>，其中包含了我们执行它所需的所有源代码。事实上，如果我们尝试使用该命令运行脚本</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="a189" class="nc lr in np b gy nt nu l nv nw">$ deno run colors.bundle.js</span></pre><p id="2c33" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">…我们会注意到没有模块会从Deno的存储库中下载。这是因为执行所需的所有代码都包含在<code class="fe ny nz oa np b">colors.bundle.js</code>文件中。我们将在终端上看到的结果与前面的示例相同:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/fff1e97192ade3b6873fdb3f304ec1a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*QaQq67u0KOJztN28QgwUJg.png"/></div></figure><h2 id="bd59" class="nc lr in bd ls nd ne dn lw nf ng dp ma kx nh ni mc lb nj nk me lf nl nm mg nn bi translated">调试器</h2><p id="ae7f" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">Deno有一个集成的调试器。如果我们想在调试模式下手动启动程序，我们需要使用<code class="fe ny nz oa np b">--inspect-brk</code></p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="9f67" class="nc lr in np b gy nt nu l nv nw">$ deno run -A — inspect-brk fileToDebug.ts</span></pre><p id="eb9d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，如果我们打开Chrome inspector <code class="fe ny nz oa np b">chrome://inspect</code>，我们会发现一个类似这样的页面</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi og"><img src="../Images/67a7f51cc273638355572d6a2f78dd7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1106/format:webp/1*mpW-Mk1607xtD_7w9O4jVQ.png"/></div></figure><p id="a49a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们点击<code class="fe ny nz oa np b">inspect</code>，我们可以开始调试我们的代码。</p><h2 id="c17f" class="nc lr in bd ls nd ne dn lw nf ng dp ma kx nh ni mc lb nj nk me lf nl nm mg nn bi translated">依赖性检查器</h2><p id="07df" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">使用这个工具真的很简单！简单地说，我们需要使用后面的<code class="fe ny nz oa np b">info</code>子命令和一个模块的URL(或路径),它将打印该模块的依赖树。如果我们使用前面例子中使用的<code class="fe ny nz oa np b">server.ts</code>文件启动命令，它将在我们的终端中打印如下内容:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/fc8f2582784b20bdca402204e8983eac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*RjrkAEtodOIigb4bntf1AQ.png"/></div></figure><p id="ce5b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">命令<code class="fe ny nz oa np b">deno info</code>也可用于显示缓存信息:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oi"><img src="../Images/31f9b63f937ff14ec6687384073af56e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zumv5mRxxkCuz9zjR8NgSw.png"/></div></div></figure><h2 id="28ef" class="nc lr in bd ls nd ne dn lw nf ng dp ma kx nh ni mc lb nj nk me lf nl nm mg nn bi translated">文档生成器</h2><p id="e6f9" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">这是一个非常有用的工具，它允许我们自动生成JSDoc。如果我们想使用它，只需运行命令<code class="fe ny nz oa np b">deno doc</code>，后面跟着一个或多个源文件的列表，它会自动将我们模块的所有导出文件的所有文档打印到终端。让我们通过一个简单的例子来看看它是如何工作的。假设我们有一个包含以下内容的文件<code class="fe ny nz oa np b">add.ts</code>:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="d483" class="nc lr in np b gy nt nu l nv nw">/**<br/> * Adds x and y.<br/> * <a class="ae nb" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {number} x<br/> * <a class="ae nb" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {number} y<br/> * <a class="ae nb" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> {number} Sum of x and y<br/> */<br/>export function add(x: number, y: number): number {<br/>  return x + y;<br/>}</span></pre><p id="8dd2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">执行<code class="fe ny nz oa np b">deno doc</code>命令，它将在标准输出上打印以下JSDoc:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oj"><img src="../Images/1f52c93868acf3db282c5d9b5133704d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2mE-eBb_aCf38ib1ZUxU9g.png"/></div></div></figure><p id="505a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">可以使用<code class="fe ny nz oa np b">--json</code>标志生成JSON格式的文档。Deno的网站可以使用这种JSON格式自动生成模块文档。</p><h2 id="2dc2" class="nc lr in bd ls nd ne dn lw nf ng dp ma kx nh ni mc lb nj nk me lf nl nm mg nn bi translated">格式程序</h2><p id="6731" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">格式化程序是由prettle的替代者<a class="ae nb" href="https://github.com/dprint/dprint" rel="noopener ugc nofollow" target="_blank"> dprint </a>提供的，它克隆了Prettier 2.0所支持的所有规则。如果我们想要格式化一个或多个文件，我们可以使用<code class="fe ny nz oa np b">deno ftm &lt;files&gt;</code>或一个VSCode扩展名。如果我们运行带有<code class="fe ny nz oa np b">--check</code>标志的命令，将对当前工作目录中的所有JavaScript和TypeScript文件执行格式检查。</p><h2 id="d30d" class="nc lr in bd ls nd ne dn lw nf ng dp ma kx nh ni mc lb nj nk me lf nl nm mg nn bi translated">测试跑步者</h2><p id="34ce" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">这个工具的语法非常简单。我们只需要使用<code class="fe ny nz oa np b">deno test</code>命令，就会对所有以<code class="fe ny nz oa np b">_test</code>或<code class="fe ny nz oa np b">.test</code>结尾，扩展名为<code class="fe ny nz oa np b">.js</code>、<code class="fe ny nz oa np b">.ts</code>、<code class="fe ny nz oa np b">.tsx</code>或<code class="fe ny nz oa np b">.jsx</code>的文件执行测试。除了这个实用程序之外，还可以使用标准的Deno API，它为我们提供了<code class="fe ny nz oa np b">asserts</code>模块，我们可以通过以下方式使用它:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="6d6f" class="nc lr in np b gy nt nu l nv nw">import { assertEquals } from "https://deno.land/std/testing/asserts.ts"<br/><br/>Deno.test({<br/>  name: "testing example",<br/>  fn(): void {<br/>    assertEquals("world", "world")<br/>    assertEquals({ hello: "world" }, { hello: "world" })<br/>  },<br/>})</span></pre><p id="0596" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个模块给了我们九个可以在测试用例中使用断言:</p><ul class=""><li id="154a" class="mn mo in kq b kr ks ku kv kx mp lb mq lf mr lj ms mt mu mv bi translated"><code class="fe ny nz oa np b">assert(expr: unknown, msg = ""): asserts expr</code></li><li id="03ba" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><code class="fe ny nz oa np b">assertEquals(actual: unknown, expected: unknown, msg?: string): void</code></li><li id="8420" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><code class="fe ny nz oa np b">assertNotEquals(actual: unknown, expected: unknown, msg?: string): void</code></li><li id="0202" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><code class="fe ny nz oa np b">assertStrictEquals(actual: unknown, expected: unknown, msg?: string): void</code></li><li id="7914" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><code class="fe ny nz oa np b">assertStringContains(actual: string, expected: string, msg?: string): void</code></li><li id="c41c" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><code class="fe ny nz oa np b">assertArrayContains(actual: unknown[], expected: unknown[], msg?: string): void</code></li><li id="a9a9" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><code class="fe ny nz oa np b">assertMatch(actual: string, expected: RegExp, msg?: string): void</code></li><li id="233e" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><code class="fe ny nz oa np b">assertThrows(fn: () =&gt; void, ErrorClass?: Constructor, msgIncludes = "", msg?: string): Error</code></li><li id="e13d" class="mn mo in kq b kr mw ku mx kx my lb mz lf na lj ms mt mu mv bi translated"><code class="fe ny nz oa np b">assertThrowsAsync(fn: () =&gt; Promise&lt;void&gt;, ErrorClass?: Constructor, msgIncludes = "", msg?: string): Promise&lt;Error&gt;</code></li></ul><h2 id="c66f" class="nc lr in bd ls nd ne dn lw nf ng dp ma kx nh ni mc lb nj nk me lf nl nm mg nn bi translated">棉绒</h2><p id="3e3f" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">Deno集成了JavaScript和TypeScript linter。这是一个新特性，它不稳定，显然，如果我们想使用它，需要<code class="fe ny nz oa np b">--unstable</code>标志来执行它。</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="fc39" class="nc lr in np b gy nt nu l nv nw"><em class="nx"># This command lint all the ts and js files in the current working directory<br/></em>$ deno lint --unstable</span><span id="4c29" class="nc lr in np b gy ob nu l nv nw"><em class="nx"># This command lint all the listed files<br/></em>$ deno lint --unstable myfile1.ts myfile2.ts</span></pre><h1 id="a00c" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">基准</h1><p id="6932" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">好了，伙计们！我们到了关键时刻了！谁是最好的JavaScript环境Deno或Node？但我认为正确的问题是另一个:<strong class="kq io">谁最快？我做了一个非常简单的基准测试(一个http hello服务器),结果非常有趣。我在我的笔记本电脑上做的，它有以下特点:</strong></p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="8587" class="nc lr in np b gy nt nu l nv nw">Model: XPS 13 9380<br/>Processor: Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz<br/>RAM: 16GB DDR3 2133MHz<br/>OS: Ubuntu 20.04 LTS<br/>Kernel version: 5.4.0-42</span></pre><p id="7bf7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我用来制作这些基准的工具是<a class="ae nb" href="https://github.com/mcollina/autocannon" rel="noopener ugc nofollow" target="_blank">auto canon</a>，使用的脚本如下:</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="2842" class="nc lr in np b gy nt nu l nv nw">// file node_http.js<br/>const http = require("http");</span><span id="e6f6" class="nc lr in np b gy ob nu l nv nw">const hostname = "127.0.0.1";<br/>const port = 3000;</span><span id="e6d1" class="nc lr in np b gy ob nu l nv nw">http.createServer((req, res) =&gt; {  <br/>  res.end("Hello World");<br/>}).listen(port, hostname, () =&gt; {  <br/>  console.log("node listening on:", port);<br/>});<br/></span><span id="6d79" class="nc lr in np b gy ob nu l nv nw">// file deno_http.ts<br/>import { serve } from "<a class="ae nb" href="https://deno.land/std@0.61.0/http/server.ts" rel="noopener ugc nofollow" target="_blank">https://deno.land/std@0.61.0/http/server.ts</a>";</span><span id="b4ad" class="nc lr in np b gy ob nu l nv nw">const port = 3000;<br/>const s = serve({ port });<br/>const body = new TextEncoder().encode("Hello World");</span><span id="c150" class="nc lr in np b gy ob nu l nv nw">console.log("deno_http listen on", port);<br/>for await (const req of s) {<br/>  const res = {<br/>    body,<br/>    headers: new Headers(),<br/>  };<br/>  res.headers.set("Date", new Date().toUTCString());<br/>  res.headers.set("Connection", "keep-alive");<br/>  req.respond(res).catch(() =&gt; {});<br/>}</span></pre><p id="41e5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以在下面的github资源库中找到它们:</p><div class="ok ol gp gr om on"><a href="https://github.com/trivikr/node-deno-http-benchmarks" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd io gy z fp os fr fs ot fu fw im bi translated">tri vikr/node-deno-http-基准</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">测试deno的步骤安装Deno在后台运行Deno服务器Deno Run-allow-net Deno _ http . ts &amp; Run…</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">github.com</p></div></div><div class="ow l"><div class="ox l oy oz pa ow pb km on"/></div></div></a></div><p id="d3ae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一个测试用例使用命令<code class="fe ny nz oa np b">autconannon <a class="ae nb" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a> -c100</code>在100个并发连接上执行，结果如下:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pc"><img src="../Images/b98033439d6308cecd418a5685a936d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpX8842evCQxlalT-DaYmw.png"/></div></div></figure><p id="622e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好像Node在速度上打败了Deno！但是这个基准测试是基于100个并发连接的，这对于中小型服务器来说是很多的。所以让我们做另一个测试:这次有10个并发连接。</p><p id="db9c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同样，Node打败了Deno:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi pd"><img src="../Images/50e87c10bf893d7190df6ecb72ab97a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Owe6uy7kOFl4AIhJqtyOg.png"/></div></div></figure><p id="4fbb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">就性能而言，Node似乎以2:0击败了Deno！它在两种分析的情况下都表现得更好。然而，Deno是一个非常年轻的项目，社区正在努力工作以尽快在生产环境中被采用，但这将是一场艰苦的战斗。</p><h1 id="5cf9" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">结论</h1><p id="d280" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">本文的主要目的不是支持Node或Deno，而是比较这两种环境。现在你应该对两者的异同有所了解了。</p><p id="461d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Deno对开发人员来说有一些特别的优势，包括健壮的支持系统和本机类型脚本支持。设计决策和额外的内置工具旨在提供高效的环境系统和良好的开发人员体验。我不知道这些选择在未来是否会成为一把双刃剑，但现在似乎吸引了更多的开发者。</p><p id="3b72" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">另一方面，Node有一个强大的生态系统，十年的开发和发布，一个海洋社区和在线课程，可以在许多线程或问题上帮助我们，一个无限的框架列表(Fastify，Express，哈比神，Koa等)。)，许多书籍，如<em class="nx">《Node.js设计模式》</em>或<em class="nx">《Node Cookbook》</em>，都是我认为讨论Node . js的最佳书籍。出于这些和许多其他原因，我认为Node是目前最安全的选择。我能说什么呢…</p><pre class="kd ke kf kg gt no np nq nr aw ns bi"><span id="56b2" class="nc lr in np b gy nt nu l nv nw">HAPPY CODING!</span></pre><h1 id="229e" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">文献学</h1><div class="ok ol gp gr om on"><a href="https://deno.land/" rel="noopener  ugc nofollow" target="_blank"><div class="oo ab fo"><div class="op ab oq cl cj or"><h2 class="bd io gy z fp os fr fs ot fu fw im bi translated">德诺</h2><div class="ou l"><h3 class="bd b gy z fp os fr fs ot fu fw dk translated">编辑描述</h3></div><div class="ov l"><p class="bd b dl z fp os fr fs ot fu fw dk translated">德诺.兰德</p></div></div><div class="ow l"><div class="pe l oy oz pa ow pb km on"/></div></div></a></div><p id="8f31" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nx">更多内容请看</em><a class="ae nb" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="nx">plain English . io</em></strong></a></p></div></div>    
</body>
</html>