<html>
<head>
<title>Using Angular and Chart.js to build real-time charts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Angular和Chart.js构建实时图表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-angular-and-chart-js-to-build-real-time-charts-7683666eec2f?source=collection_archive---------4-----------------------#2020-08-10">https://javascript.plainenglish.io/using-angular-and-chart-js-to-build-real-time-charts-7683666eec2f?source=collection_archive---------4-----------------------#2020-08-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1c59432e8b0732c71667e70eebbea730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Y5MingNL3Rc4eTX8.jpg"/></div></div></figure><p id="4e75" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular </a>和<a class="ae kt" href="https://www.chartjs.org/" rel="noopener ugc nofollow" target="_blank"> Chart.js </a>是创建任何数据可视化应用程序时的流行组合。第一个可以处理非常大的数据吞吐量，而后者能够实时渲染图形，这要归功于Canvas API。在这篇文章中，我将指导你使用Angular和Chart.js创建一个实时图表</p><h1 id="f556" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">先决条件</h1><p id="6312" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在开始编写任何代码之前，请确保您具备以下条件:</p><ul class=""><li id="f27c" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated"><a class="ae kt" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a> —我用的是13.2.0版本</li><li id="7a74" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><a class="ae kt" href="https://cli.angular.io/" rel="noopener ugc nofollow" target="_blank">角度CLI </a> —我用的是8.3.20版本</li><li id="734a" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">10分钟的自由时间</li></ul><h1 id="32f3" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">创建新的角度项目</h1><p id="25eb" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">所需的第一步是创建一个新的角度项目。正如先决条件中提到的，我正在使用Angular CLI这样做，我强烈建议您也这样做。打开一个终端窗口，导航到所需的目录并执行命令:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="bec8" class="mu kv in mq b gy mv mw l mx my">ng new angular-charts --routing=true --styling=scss</span></pre><p id="e2ce" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该命令在同名目录下创建一个名为<em class="mz"> angular-charts </em>的新角度项目。此外，我添加了两个可选标志— <code class="fe na nb nc mq b">routing</code>将路由器模块添加到应用程序中，<code class="fe na nb nc mq b">styling</code>设置所使用的样式表的扩展。</p><p id="c25c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建好项目后，在您选择的IDE中打开它——我将为此使用Visual Studio代码。</p><h1 id="359a" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">添加服务层*</h1><p id="190d" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">本教程的下一步是添加服务图层。我用星号标记了这个步骤，因为它是可选的。如果您已经有一个，或者您不需要，那么可以跳过这一部分。</p><p id="b221" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们从生成一个使用<code class="fe na nb nc mq b">Observable</code>访问实时数据源的服务开始这一部分。要生成服务，请使用以下命令:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c4f5" class="mu kv in mq b gy mv mw l mx my">ng generate service sse</span></pre><p id="77c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">执行该命令后，就会创建<code class="fe na nb nc mq b">SseService</code>，这就是服务层代码将被放置的位置。对于本教程，我使用SSE或服务器发送的事件数据源，你可以在这里找到<a class="ae kt" href="https://bartoszgajda.com/2019/12/22/angular-and-server-sent-events-sse/" rel="noopener ugc nofollow" target="_blank">教程</a>。如果你需要更多的解释，不要犹豫去读那个教程。为了避免在这篇文章中重复，我将只粘贴以下内容:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="52c6" class="mu kv in mq b gy mv mw l mx my">import { Injectable, NgZone } from "@angular/core";<br/>import { Observable } from "rxjs";<br/>@Injectable({<br/>  providedIn: "root"<br/>})<br/>export class SseService {<br/>  constructor(private _zone: NgZone) {}<br/>  getServerSentEvent(url: string): Observable&lt;any&gt; {<br/>    return Observable.create(observer =&gt; {<br/>      const eventSource = this.getEventSource(url);<br/>      eventSource.onmessage = event =&gt; {<br/>        this._zone.run(() =&gt; {<br/>          observer.next(event);<br/>        });<br/>      };<br/>      eventSource.onerror = error =&gt; {<br/>        this._zone.run(() =&gt; {<br/>          observer.error(error);<br/>        });<br/>      };<br/>    });<br/>  }<br/>  private getEventSource(url: string): EventSource {<br/>    return new EventSource(url);<br/>  }<br/>}</span></pre><h1 id="2041" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">挂钩图表. js</h1><p id="7caf" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">下一步是将Chart.js库挂接到我们的Angular项目中。有几种方法可以做到这一点，但是我将使用一个专用的包，名为<a class="ae kt" href="https://valor-software.com/ng2-charts/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> Ng2-Charts </strong> </a>。这个包公开了一个更好的API，同时保留了所有需要的功能。在我的例子中，我将以下依赖项添加到我的<code class="fe na nb nc mq b">package.json</code>文件中:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="a32a" class="mu kv in mq b gy mv mw l mx my">"chart.js": "^2.9.3",<br/>"ng2-charts": "^2.3.0",</span></pre><p id="7a15" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">修改完<code class="fe na nb nc mq b">package.json</code>文件后，不要忘记根据您的包管理器运行<code class="fe na nb nc mq b">npm install</code>或<code class="fe na nb nc mq b">yarn</code>。</p><h1 id="488b" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">添加HTML模板</h1><p id="1688" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">更进一步，我们必须添加一个HTML模板来呈现图表。在本教程中，您可以将它放在您喜欢的任何地方——代码是带有自定义属性的单个HTML标记，我们将在下一步中探讨。我将它放在一个名为<code class="fe na nb nc mq b">count-events.component.html</code>的组件HTML模板中。HTML模板应该包括以下内容:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f1be" class="mu kv in mq b gy mv mw l mx my">&lt;canvas<br/>    width="600"<br/>    height="400"<br/>    [datasets]="countEventsData"<br/>    [chartType]="countEventsChartType"<br/>    [labels]="countEventsLabels"<br/>    [colors]="countEventsColors"<br/>    [options]="countEventsOptions"<br/>&gt;&lt;/canvas&gt;</span></pre><p id="c070" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我已经把我的图表放在count-events文件夹中，因此所有的变量都加上了这些。在<code class="fe na nb nc mq b">canvas</code>标签中，我们指定了高度、宽度和变量配置，它们将被放在相应的<code class="fe na nb nc mq b">.ts</code>文件中。</p><h1 id="88f8" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">配置Chart.js</h1><p id="e145" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">正如在上面的章节中提到的，我们将添加一些自定义配置到Chart.js图中。这个配置将被放在组件的TypeScript文件中，在我的例子中它被称为<code class="fe na nb nc mq b">count-events.component.ts</code>。</p><p id="9726" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先要设置的是<code class="fe na nb nc mq b">datasets</code>属性。这是一个容器，它将保存显示在绘图本身上的数据。这方面的代码应该如下所示:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="6b4c" class="mu kv in mq b gy mv mw l mx my">countEventsData: ChartDataSets[] = [<br/>  { data: [], label: "Number of Events", fill: false }<br/>];</span></pre><p id="b4dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个变量是一个数组，意味着在一个图上可以显示许多数据集。每个元素内部都有三个核心部分:</p><ul class=""><li id="a3f7" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated"><code class="fe na nb nc mq b">data</code> -保存要在图表上显示的单个值的数组</li><li id="f3e0" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><code class="fe na nb nc mq b">label</code> -数据集的标签</li><li id="59a0" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><code class="fe na nb nc mq b">fill</code> -配置选项设置数据集在图表上的外观</li></ul><p id="8da7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一个配置是<code class="fe na nb nc mq b">chartType</code>属性。这是一个字符串，标记应该使用的图表类型。有各种各样的选项可用，包括线条、条形图、图表或饼图，但对于本教程，我们将坚持使用最简单的一行:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="7bd2" class="mu kv in mq b gy mv mw l mx my">countEventsChartType = "line";</span></pre><p id="3035" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更进一步，必须设置<code class="fe na nb nc mq b">labels</code>属性。该元素设置<strong class="jx io"> X </strong>轴接收什么标签。然而，在我们的例子中，我们不想将它们设置为常量。我们希望能够根据输入的数据实时更新标签。因此，该属性被设置为空数组:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="f914" class="mu kv in mq b gy mv mw l mx my">countEventsLabels: Label[] = [];</span></pre><p id="0470" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下一个属性是<code class="fe na nb nc mq b">colors</code>。名称本身可能是不言自明的，所以我将直接跳到代码:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="93d8" class="mu kv in mq b gy mv mw l mx my">countEventsColors: Color[] = [<br/>    {<br/>      borderColor: "#039BE5",<br/>      pointBackgroundColor: "#039BE5"<br/>    }<br/>];</span></pre><p id="4e04" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一点配置叫做<code class="fe na nb nc mq b">options</code>。这是所有可以设置的主要标志的中心配置点。可用选项的数量非常广泛，因此请参考<a class="ae kt" href="https://www.chartjs.org/docs/latest/general/options.html" rel="noopener ugc nofollow" target="_blank"> Chart.js文档</a>获取完整的文档。在我们的例子中，我们只对删除动画感兴趣——这将优化图表，使它运行得更快。为此，请将以下内容粘贴到您的代码中:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ffcf" class="mu kv in mq b gy mv mw l mx my">countEventsOptions: ChartOptions = {<br/>    animation: {<br/>      duration: 0<br/>    }<br/> };</span></pre><h1 id="b9ce" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">连接服务和Chart.js</h1><p id="adc7" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">本教程的最后一章将向您展示如何将服务和Chart.js粘合在一起。为了实现这一点，我们将在<code class="fe na nb nc mq b">count-events.component.ts</code>文件中实现几个函数。</p><p id="3abc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们从订阅数据源开始，在我们的例子中是一个<code class="fe na nb nc mq b">SseService</code>。这是在<code class="fe na nb nc mq b">ngOnInit</code>钩子中完成的，因此每当我们的组件被加载到应用程序中时，我们就连接到数据源。在这里，我们为端点创建一个<code class="fe na nb nc mq b">Subscription</code>并调用<code class="fe na nb nc mq b">pushEventToChartData</code>函数。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="925e" class="mu kv in mq b gy mv mw l mx my">private countEventsSubscription$: Subscription;<br/>ngOnInit() {<br/>    this.countEventsSubscription$ = this.sseService<br/>      .getServerSentEvent("http://localhost:8082/count-events")<br/>      .subscribe(event =&gt; {<br/>        let data = JSON.parse(event.data);<br/>        this.pushEventToChartData(data);<br/>      });<br/>  }</span></pre><p id="364e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">前面提到的函数有一个简单的目的——它检查<code class="fe na nb nc mq b">datasets</code>是否达到了一个任意的限制(在本例中为20 ),如果是，在将新的元素推入集合之前删除最后一个元素。记住一件事——如果添加或删除元素，必须对<code class="fe na nb nc mq b">datasets</code>集合和标签<code class="fe na nb nc mq b">collections</code>都这样做。它们都必须一直保持同步。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="1559" class="mu kv in mq b gy mv mw l mx my">private pushEventToChartData(event: CountEvents): void {<br/>    if (this.isChartDataFull(this.countEventsData, 20)) {<br/>      this.removeLastElementFromChartDataAndLabel();<br/>    }<br/>    this.countEventsData[0].data.push(event.count);<br/>    this.countEventsLabels.push(<br/>      this.getLabel(event)<br/>    );<br/>  }</span></pre><p id="cebe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后几段代码包括对helper函数的调用，可以在上面的代码片段中找到。第一个函数可以用来实现一些更漂亮的标签。第二个从<code class="fe na nb nc mq b">datasets</code>和<code class="fe na nb nc mq b">labels</code>集合中删除最后一个元素。第三个检查a集合是否达到了它的限制，在我的例子中我设置为20。这些内容的片段如下:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="4512" class="mu kv in mq b gy mv mw l mx my">private getLabel(event: CountEvents): string {<br/>    return `${event.window}`;<br/>  }</span><span id="1410" class="mu kv in mq b gy nd mw l mx my">  private removeLastElementFromChartDataAndLabel(): void {<br/>    this.countEventsData[0].data = this.countEventsData[0].data.slice(1);<br/>    this.countEventsLabels = this.countEventsLabels.slice(1);<br/>  }</span><span id="6163" class="mu kv in mq b gy nd mw l mx my">  private isChartDataFull(chartData: ChartDataSets[], limit: number): boolean {<br/>    return chartData[0].data.length &gt;= limit;<br/>  }</span></pre><p id="ffba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">综上所述，<code class="fe na nb nc mq b">count-events.component.ts</code>文件的完整代码如下所示:</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="213e" class="mu kv in mq b gy mv mw l mx my">export class CountEventsComponent implements OnInit, OnDestroy {<br/>  private countEventsSubscription$: Subscription;<br/>  private eventsOnChartLimit = 20;<br/>  countEventsChartType = "line";<br/>  countEventsData: ChartDataSets[] = [<br/>    { data: [], label: "Number of Events", fill: false }<br/>  ];<br/>  countEventsLabels: Label[] = [];<br/>  countEventsColors: Color[] = [<br/>    {<br/>      borderColor: "#039BE5",<br/>      pointBackgroundColor: "#039BE5"<br/>    }<br/>  ];<br/>  countEventsOptions: ChartOptions = {<br/>    animation: {<br/>      duration: 0<br/>    }<br/>  };</span><span id="c2bd" class="mu kv in mq b gy nd mw l mx my">  constructor(private sseService: SseService) {}</span><span id="084f" class="mu kv in mq b gy nd mw l mx my">  ngOnInit() {<br/>    this.countEventsSubscription$ = this.sseService<br/>      .getServerSentEvent("http://localhost:8082/count-events")<br/>      .subscribe(event =&gt; {<br/>        let data = JSON.parse(event.data);<br/>        this.pushEventToChartData(data);<br/>      });<br/>  }</span><span id="2062" class="mu kv in mq b gy nd mw l mx my">  private pushEventToChartData(event: CountEvents): void {<br/>    if (this.isChartDataFull(this.countEventsData, 20)) {<br/>      this.removeLastElementFromChartDataAndLabel();<br/>    }<br/>    this.countEventsData[0].data.push(event.count);<br/>    this.countEventsLabels.push(<br/>      this.getLabel(event)<br/>    );<br/>  }</span><span id="76ce" class="mu kv in mq b gy nd mw l mx my">  private getLabel(event: CountEvents): string {<br/>    return `${event.window}`;<br/>  }</span><span id="edb2" class="mu kv in mq b gy nd mw l mx my">  private removeLastElementFromChartDataAndLabel(): void {<br/>    this.countEventsData[0].data = this.countEventsData[0].data.slice(1);<br/>    this.countEventsLabels = this.countEventsLabels.slice(1);<br/>  }</span><span id="aaff" class="mu kv in mq b gy nd mw l mx my">  private isChartDataFull(chartData: ChartDataSets[], limit: number): boolean {<br/>    return chartData[0].data.length &gt;= limit;<br/>  }</span><span id="846c" class="mu kv in mq b gy nd mw l mx my">  ngOnDestroy() {<br/>    this.countEventsSubscription$.unsubscribe();<br/>  }<br/>}</span></pre><p id="42ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本教程到此结束。使用Angular和Chart.js并不是火箭科学，拥有实时图表的好处是巨大的。</p><h1 id="3c63" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">摘要</h1><p id="48aa" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我希望这篇文章对你有用。如果有，不要犹豫，喜欢或分享这个帖子。此外，如果你愿意，你可以在我的社交媒体上关注我:)</p><figure class="ml mm mn mo gt jo"><div class="bz fp l di"><div class="ne nf l"/></div></figure></div></div>    
</body>
</html>