<html>
<head>
<title>Routes and Middleware in Node.js/Express, Simplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js/Express,的路由和中间件得到简化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/routes-and-middleware-simplified-with-code-samples-node-js-express-a6c513f212e7?source=collection_archive---------5-----------------------#2020-11-12">https://javascript.plainenglish.io/routes-and-middleware-simplified-with-code-samples-node-js-express-a6c513f212e7?source=collection_archive---------5-----------------------#2020-11-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3cdc575d74c8089069f1815b09ac5fb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4d92FeMpelVNUvohqf_mOQ.png"/></div></div></figure><h1 id="2465" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">当你在应用中听到路由时，你会想到什么？</h1><p id="eacd" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这是指应用程序如何使用特定的http请求方法(POST、PUT、DELETE等)来响应客户端对特定端点的请求。)，你懂了吗？如果没有，不用担心…</p><p id="4d57" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">简而言之，路由指的是应用程序如何通过特定的HTTP方法在特定的url或路径上运行</p><p id="139e" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">例如，假设您有一个URL为(http://mywebsite.com)的3页网站，它包括主页、联系我们页面和关于我们页面，</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/c5b70c1577b5ec9ebf5c7b260f9624ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m4w5gWH_z-BXXX-g1ckHiA.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Just a simple header to display 3 links</figcaption></figure><p id="99c0" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这就是路由发挥作用的地方，对主页的get请求，即(http://mywebsite.com)，你打算用主页或登录页来响应，在那里你有这些花哨的旋转木马，所有这些都使它看起来很棒，不是吗？</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/d5b0f146833c4532a867cde8734e1d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8OXlTl9reksvte-BfDQ-Mg.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Credit to @uiraygan on IG for the awesome UI design</figcaption></figure><p id="d460" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">但是对于URL(<a class="ae mg" href="https://ourwebsite.com/contact" rel="noopener ugc nofollow" target="_blank">https://ourwebsite.com/contact</a>美国)的get请求，显然我们打算用某种形式来响应，用户可以在其中输入详细信息，比如电子邮件、姓名和给我们留言</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/76c17380b4d2debb5b44e971009b4621.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Pj1v2jpn1Ug1uF9JyyPZdw.png"/></div></div></figure><p id="ac3b" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">有了这个关于应用程序中路由的基本解释，我希望你明白我到底想表达什么…是的！</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h2 id="691c" class="mp jw in bd jx mq mr dn kb ms mt dp kf le mu mv kj li mw mx kn lm my mz kr na bi translated">现在让我们看看如何通过代码示例(Node.js/express)使用不同的HTTP方法创建简单的路由</h2><p id="2183" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在我们继续之前，请确保您已经安装了<a class="ae mg" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> node js </a>和<a class="ae mg" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"> postman </a>，您可以点击链接从他们的官方网站下载，我们将使用postman通过HTTP POST方法测试我们的路由</p><p id="569f" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">假设我们在端口8080上运行了一个非常简单的express应用程序</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/7470dbf6f0ed2f68fb1fa875517c1f58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FhBikPGanpEepl5L6RBjzw.png"/></div></div></figure><p id="bcd8" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">注意:我可以通过在我的package.json文件中添加“type”:“module”来使用Es6语法。</p><p id="490a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在，在express应用程序中定义路线的语法包括</p><p id="a30a" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">app.method(路径，回调)</p><p id="49d3" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">其中方法是指HTTP方法/动词(get、post、put等。)要应用，path是指请求将应用的路由或URL，callback也是当http方法的请求命中path时将运行的函数或中间件(下面解释)。</p><p id="efe2" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">考虑向路由"/"发出get请求，如下所示</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nb"><img src="../Images/9f402d35248bbdaf53dfa5e383f82555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XjY0zZ3O1VWvQdUFCnYdMQ.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">get request to the route (‘’/”)</figcaption></figure><p id="6e92" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">注意，回调函数接受两个参数，即请求和响应，它还接受一个可选的第三个参数(函数),当有另一个中间件运行时调用该参数</p><p id="0235" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">不要担心，我们将很快研究中间件</p><p id="21da" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">启动服务器并导航到<a class="ae mg" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8080/ </a></p><p id="73ba" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">万岁！！！您刚刚创建了您的第一条路线，您应该会得到如下回应</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/ebacb3a319f190ba9d8642316b29947f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4-mRlHl3rmbO1KEP5ECGtg.png"/></div></div></figure><p id="a5a5" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">您应该会看到与上面相同的响应，也就是说，这意味着它已经成功地向“/”发出了get请求，同时，让我们尝试以“http://localhost:8080/contact us”的形式向联系人页面发出get请求</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nc"><img src="../Images/3bb9c68d6d7b0a47011319603a7ded5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2FSOd6hDEd9PqOpV_aFPRA.png"/></div></div></figure><p id="6679" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">启动服务器并导航到<a class="ae mg" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank">http://localhost:8080/</a>contact us，您应该得到如下响应</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/e610ff22ca6d5e9b830296dc12a84e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BUuwoeA3CLqpXcsnaDwPXA.png"/></div></div></figure><p id="b8f1" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">用这个简单的路由解释，希望你爱，留点爱…</p></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h1 id="3256" class="jv jw in bd jx jy nd ka kb kc ne ke kf kg nf ki kj kk ng km kn ko nh kq kr ks bi translated">什么是中间件？</h1><p id="d251" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">中间件功能是可以访问请求和响应对象以及应用程序的请求-响应周期中的下一个中间件功能的功能…..你还是不明白吗？别担心…</p><p id="fc00" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">简而言之，顾名思义，“中间”，这是一个在服务器收到请求和服务器向客户端发送响应之间运行的功能或程序。</p><p id="4151" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">有两种主要类型的中间件，即全局中间件(这是一种可以被应用中的所有路由访问的中间件，因此其名称为“全局”)和特定中间件(这是一种仅应用于特定路由的中间件)</p><p id="0509" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">在express应用程序中使用全局中间件利用了语法app . use(middleware)；</p><p id="1a84" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">需要注意的一点是中间件是按照它们被定义的顺序运行的(一个接一个)，不要担心我们很快就会看到代码样本。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/0593989af71c8436b73f6d6726c55ecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X1sbR5t7SY-VasdXPdGY2Q.png"/></div></div></figure><p id="d2ae" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">从上面的代码示例来看，checkIsAuth是一个全局中间件(适用于所有路由),它在访问路由之前检查用户是否通过了身份验证，</p><p id="7d19" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">当我启动服务器并导航到(http://localhost:8080/secret)…我将无法访问该页面，而是以“未登录”的状态登录到控制台，因为“中间件”会检查我是否通过了身份验证。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/266a8e087724e1d16f3e2695f1a0f456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0bjch-BDFDsFbrbCZKFKNg.png"/></div></div></figure><p id="a345" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">但是当isAuth标志设置为true时，我现在可以访问所有其他路由。</p><p id="a280" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">现在让我向您展示一个“中间件按照定义的顺序运行”的好例子</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ni"><img src="../Images/21f795d8a3425253efdc7777f4ddded5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n_JBy2lckTx0BByypf4i9A.png"/></div></div></figure><p id="05fa" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">注意中间件应用在哪里(app.use(checkIsAuth))？它出现在所有其他路由之后，现在即使isAuth标志为假，我仍然可以在应用中间件之前访问所有秘密路由！！！。</p><p id="c4cb" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">例如，当我导航到(http://localhost:8080/secret)时，我可以访问该页面。</p><figure class="lx ly lz ma gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lw"><img src="../Images/148124b4db3e40bfff181b73f89a861c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BzC7fvh243uIl-PrrL3Ksw.png"/></div></div></figure><p id="cab2" class="pw-post-body-paragraph kt ku in kv b kw lr ky kz la ls lc ld le lt lg lh li lu lk ll lm lv lo lp lq ig bi translated">这就是为什么最好将所有全局中间件放在任何路由之前。</p></div></div>    
</body>
</html>