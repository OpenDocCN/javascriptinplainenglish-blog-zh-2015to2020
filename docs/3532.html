<html>
<head>
<title>Dockerize your Development Environment for Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为Node.js整理您的开发环境</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dockerize-your-development-environment-in-node-js-c64de51c540c?source=collection_archive---------8-----------------------#2020-10-06">https://javascript.plainenglish.io/dockerize-your-development-environment-in-node-js-c64de51c540c?source=collection_archive---------8-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9fa0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么在开发工作流中一定要使用Docker</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4c70197b942254b70296e8b76df61512.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VIQU9n-i_nUu5ccI4DyQcw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@exdigy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Dominik Lückmann</a> on <a class="ae kv" href="https://unsplash.com/s/photos/container-port?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="96b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在开发工作流中使用Docker对您的工作效率有积极的影响。它消除了典型的“它在我的机器上工作”类型的错误，在不同机器上的设置只需要一个正在运行的Docker守护程序，其他什么都不需要。在我们开始实施之前，我们将非常快速地检查一下Docker。</p><h1 id="6561" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">什么是码头工人？</h1><p id="3127" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">码头工人是一个平台，可以运行<em class="mp">容器</em>，软件包。为了运行这些容器，Docker使用操作系统级虚拟化。您可以将容器视为虚拟机的轻量级版本。</p><p id="850c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您在Docker平台上运行的所有容器都是相互隔离的。例如，运行Docker的主机和运行在该主机上的一个容器不共享相同的文件系统，除非明确告诉它们共享。</p><p id="f769" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要启动一个容器，您需要一个Docker <em class="mp">图像</em>。此图像是您的容器的蓝图。您可以从<a class="ae kv" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker-Hub </a>获取预先定义的图像，或者通过编写所谓的Dockerfile来配置您自己的图像。</p><p id="acc6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是对Docker的简要概述，如果您想深入了解，我建议您从<a class="ae kv" href="https://www.docker.com/resources/what-container" rel="noopener ugc nofollow" target="_blank">开始。</a></p><h1 id="965d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">您为什么要整理您的开发工作流程？</h1><p id="6b30" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在介绍中，我已经谈到了在您的开发环境中使用Docker的一个好处。这是因为它摆脱了典型的“它在我的机器上工作”问题。其他一些优势包括:</p><ul class=""><li id="181c" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated">更加标准化团队成员之间的开发工作流程</li><li id="cdb3" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">如果您也使用Docker进行部署，则可以减少只针对生产的错误(生产和开发之间的配置可能非常相似)</li><li id="af46" class="mq mr iq ky b kz mz lc na lf nb lj nc ln nd lr mv mw mx my bi translated">摆脱前面提到的“在我的机器上工作”类型的臭虫</li></ul><h1 id="a09d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">入门指南</h1><p id="8510" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们从创建一个新文件夹开始，在其中放置我们的项目，我们创建我们的Dockerfile，如下所示:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="3ed8" class="nj lt iq nf b gy nk nl l nm nn">$ mkdir node-docker &amp;&amp; cd node-docker<br/>$ touch Dockerfile</span></pre><h2 id="4b02" class="nj lt iq bd lu no np dn ly nq nr dp mc lf ns nt me lj nu nv mg ln nw nx mi ny bi translated">文件</h2><p id="440f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们将用于我们的快速应用程序的容器将在Dockerfile中配置。为此，我们需要给它一些生命:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Dockerfile</figcaption></figure><p id="aa99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> FROM </strong>告诉docker从Docker中枢获取一个名为<em class="mp">节点</em>(版本:最新)的图像。</p><p id="139b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">工作目录</strong>设置所有即将执行的命令的目录。</p><p id="8180" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> COPY </strong>言行一致，它得到<em class="mp"> package.json </em>和<em class="mp"> package-lock.json </em>并将其复制到<em class="mp"> WORKDIR </em>中。</p><p id="59da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> ENV </strong>在容器内设置环境变量，名称为<em class="mp"> PORT </em>，值为5000</p><p id="e0db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> RUN </strong>执行我们传入的命令。在这种情况下，清除npm缓存，然后安装来自<em class="mp"> package.json </em>的所有依赖项。</p><p id="c503" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">入口点</strong>在docker容器启动时执行您在这里插入的命令</p><h2 id="1292" class="nj lt iq bd lu no np dn ly nq nr dp mc lf ns nt me lj nu nv mg ln nw nx mi ny bi translated">简单快捷应用程序</h2><p id="face" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">既然我们已经准备好docker文件，我们需要一个简单的express应用程序，我们可以在容器中运行。为此，我们创建两个新文件，如下所示:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="265d" class="nj lt iq nf b gy nk nl l nm nn">$ touch server.js package.json</span></pre><p id="e299" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mp"> package.json </em>将获得两个依赖项，第一个是express，第二个是nodemon:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">package.json</figcaption></figure><p id="7e8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当点击主页时，express应用程序将只返回简单的HTML。因此<em class="mp"> server.js </em>应该是这样的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">server.js</figcaption></figure><h2 id="5829" class="nj lt iq bd lu no np dn ly nq nr dp mc lf ns nt me lj nu nv mg ln nw nx mi ny bi translated">。dockerignore</h2><p id="e3a2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在我们开始设置MongoDB容器和express容器之前，我们想从正在运行的容器中排除一些文件。一个<em class="mp">的语法。dockerignore </em>文件与<em class="mp">文件完全相同。gitignore </em>文件:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">.dockerignore</figcaption></figure><h2 id="7d82" class="nj lt iq bd lu no np dn ly nq nr dp mc lf ns nt me lj nu nv mg ln nw nx mi ny bi translated">docker-compose.yml</h2><p id="61a2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">最后但同样重要的是，我们想要定义一个<em class="mp"> docker-compose.yml </em>。这个文件将包含在两个不同的容器中同时运行express应用程序和MongoDB所需的所有信息。让我们继续创建文件。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="a6f3" class="nj lt iq nf b gy nk nl l nm nn">$ touch docker-compose.yml</span></pre><p id="9e8e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们这样配置它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nz oa l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">docker-compose.yml</figcaption></figure><p id="cfb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">版本</strong>:首先我们定义想要使用的docker-compose的版本。第3版和第2版有相当多的区别，所以在选择版本时要小心！</p><p id="1697" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">服务</strong>:这是我们定义express API (api)和MongoDB (mongo)的部分</p><p id="e870" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">构建&amp;映像</strong> : <em class="mp">构建</em>告诉Docker从Docker文件中构建一个映像。在我们的例子中，我们希望它使用当前目录中的docker文件。这就是为什么我们把？因为它定义了当前目录。<em class="mp"> image </em>告诉Docker从docker hub中提取一个已经存在的图像。</p><p id="f051" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">端口&amp;卷</strong>:顾名思义<em class="mp">端口</em>在这里定义端口。冒号是映射运算符。我们将容器的端口5000映射到主机系统的端口5000，在本例中是本地机器，这样我们就可以访问容器外部的应用程序。MongoDB的端口映射也是如此。<em class="mp">卷</em>做一些类似的事情，但这次是用卷。我们将本地目录映射到容器的WORKDIR中，在这个目录中我们编写代码。这样，如果我们改变了源代码中的任何内容，容器都会立即做出反应。</p><p id="3869" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">保留</strong>:这是一个特殊的卷，本地<em class="mp"> node_modules </em>文件夹如果存在，不会覆盖容器内的<em class="mp"> node_modules </em>文件夹。</p><p id="bd74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您运行以下命令，Docker将从我们的Docker文件创建一个映像，然后运行两个容器(api和mongo):</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="5cd6" class="nj lt iq nf b gy nk nl l nm nn">$ docker-compose up</span></pre><p id="8183" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您想停止容器，只需使用以下命令:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="d40e" class="nj lt iq nf b gy nk nl l nm nn">$ docker-compose down</span></pre><h1 id="d993" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="3925" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是一个简单的Docker开发环境设置，可以很容易地扩展。如果你想改变数据库或者添加一个Nginx来呈现你的前端，只需要继续添加一个新的服务到<em class="mp"> docker-compose.yml </em>或者改变一个现有的服务。也可以dockerize。NET Core、Java或GoLang应用程序。</p><p id="365b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想了解更多关于ExpressJS的知识，请查看我的教程“<a class="ae kv" href="https://medium.com/javascript-in-plain-english/setting-up-a-rest-api-using-express-d92d5dc42e2a" rel="noopener">使用Express </a>设置REST API”。像往常一样，代码在我的<a class="ae kv" href="https://github.com/JakobKIT/node-docker" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上。</p><p id="84d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="ky ir">！</strong></p></div></div>    
</body>
</html>