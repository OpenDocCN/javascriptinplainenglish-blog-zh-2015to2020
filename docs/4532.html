<html>
<head>
<title>Handle Asynchronous JavaScript With Generators + Yield</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用生成器+ Yield处理异步JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/make-yield-great-again-javascript-ec6ced93f86?source=collection_archive---------4-----------------------#2020-12-19">https://javascript.plainenglish.io/make-yield-great-again-javascript-ec6ced93f86?source=collection_archive---------4-----------------------#2020-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ecb0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript和yield让异步代码和数据流变得简单！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0bbf815a5853ca64fa8fdb9dbc8b8fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*82vB5ZfZHDZiXDFESs-b4g.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://www.freeimages.com/photographer/clowdomega-32111" rel="noopener ugc nofollow" target="_blank">Dodgeball Time</a> from <a class="ae kv" href="https://freeimages.com/" rel="noopener ugc nofollow" target="_blank">FreeImages</a></figcaption></figure><p id="e9b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">*注:</strong> <em class="ls">如果想只读JavaScript特定部分，跳转到JavaScript </em>  <em class="ls">章节中的</em> <strong class="ky ir"> <em class="ls">。</em></strong></p><p id="4373" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> Yield </em>自2.0版本发布以来就已经是C#语言的一部分。几乎每个开发人员都读过一些关于它的东西，至少知道它“与LINQ有关”——但是具体是什么，很少有人能回答。具有讽刺意味的是，LINQ是在C# 3.0中引入的，所以yield关键字在连接建立之前就存在了。因此，它至少还有一个用途。</p><p id="655d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，yield-related构造在C#中使用相对频繁，具有<em class="ls"> IEnumerable </em>和<em class="ls"> IEnumerator </em>接口以及它们的通用对应物<em class="ls">IEnumerable&lt;T&gt;T19】和<em class="ls"> IEnumerator &lt; T &gt;。</em></em></p><p id="6029" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接口<em class="ls"> IEnumerable </em>基本上是用可枚举元素来标识一个类型。因此，中的每个可枚举类型。NET实现了这个接口:从简单的数组到通用的特殊类型，如<em class="ls"> List &lt; T &gt; </em>。IEnumerable本身提供了一个名为<em class="ls"> GetEnumerator </em>的方法，该方法返回一个<em class="ls"> IEnumerator </em>的实例。</p><p id="3a17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通用对应物<em class="ls"> IEnumerable &lt; T &gt; </em>实现<em class="ls"> IEnumerable </em>，但在其他方面的行为完全类似，并相应地返回<em class="ls"> IEnumerator &lt; T &gt; </em>的实例。</p><h1 id="b47c" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">从一数到IEnumerator</h1><p id="7a7d" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated"><em class="ls"> IEnumerator </em>和<em class="ls"> IEnumerator &lt; T &gt; </em>是允许类型实际迭代的接口。为了使这成为可能，他们为你提供了属性C<em class="ls">current</em>T62】方法<em class="ls"> MoveNext() </em>。[1][2]每次使用forEach循环迭代集合时，C#都会创建一个枚举数，并使用它来逐步迭代集合。为了正常工作，你要迭代的对象必须实现非接口或者通用接口<em class="ls">。</em></p><p id="14ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只有当一个方法的返回类型是<em class="ls">IEnumerable&lt;T&gt;T47】时，C#才允许你访问关键字<em class="ls"> yield </em>。您可以将yield视为一个链接到forEach循环迭代中的小家伙:当在forEach循环中调用一个方法时，它首先照常执行，直到C#遇到yield return语句。</em></p><p id="ff11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在那里指定的值被返回给调用方，方法的执行结束。在forEach循环的下一次迭代中，将再次调用该方法。然而，这一次执行不是从头开始，而是在yield返回后，再次执行，直到下一个yield返回。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8cd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着C#保存被调用方法的状态，并在再次调用该方法时恢复它。一旦方法到达其结尾，枚举完成，调用forEach循环终止。如果你想提前终止循环，这可以通过使用<em class="ls">屈服</em> <em class="ls">中断</em>来完成。</p><p id="c606" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个必要的调用，因为传统的返回是不可能的:在这种情况下，您必须根据方法的签名返回一个实现IEnumerable <t>的对象。</t></p><p id="aa62" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">利用收益率的优势再明显不过了。</p><ol class=""><li id="eb52" class="ms mt iq ky b kz la lc ld lf mu lj mv ln mw lr mx my mz na bi translated">Yield逐渐创建结果列表，因此我们可以更好地利用计算能力。如果forEach循环没有完全运行，则只生成实际需要的结果。</li><li id="ef56" class="ms mt iq ky b kz nb lc nc lf nd lj ne ln nf lr mx my mz na bi translated">我们使用更少的内存，因为之前不必建立大的列表，这可能并不完全需要。</li></ol><p id="1f2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正是因为这些原因，<em class="ls"> yield </em>关键字也被用于C#中的LINQ。<em class="ls">延期执行</em>基于<em class="ls">收益率。</em>【3】<em class="ls"/>这样做的话，并不是所有的查询结果都必须一次加载并保存在内存中。</p><p id="ddd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">提示:</strong> Unity提供协程。它们还返回一个类型为<em class="ls"> IEnumerable </em>的对象，并且必须使用带有<em class="ls"> yield </em>语句的返回。</p><div class="ng nh gp gr ni nj"><a href="https://medium.com/unity-hub" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">统一中心</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">在篝火旁取暖，在团结中心与长者和智者聊天，以确保你的…</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx kp nj"/></div></div></a></div><h1 id="abbd" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">JavaScript中的产量</h1><p id="f5b4" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">JavaScript也知道关键字<em class="ls"> yield。从ECMAScript 2015开始，接口<em class="ls"> IEnumerator </em>的对应物也实现了。JavaScript将其标记为<em class="ls">生成器函数</em>。</em></p><p id="1451" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> Yield </em>只有在包含函数被定义为生成器函数的情况下，才能在JavaScript中使用。这是通过<em class="ls">函数* </em>关键字完成的。第一眼看到的唯一区别是，不用<em class="ls"> yield </em> return，你只需要写yield。[4]</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="fd74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之后，您可以调用这个函数，首先获得一个生成器，它是一个<em class="ls"> IEnumerator </em>实例的JavaScript副本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="05c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这允许我们接下来调用函数，该函数实际上执行生成器函数。发生<em class="ls">时中断产生</em>，并返回一个对象，该对象带有当前值和是否到达发生器结尾的信息:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="3591" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过使用C#的forEach循环的JavaScript对应物:for … of 循环的<em class="ls">，生成器函数也可以更简单地运行。在底层，它负责调用下一个函数，并在到达生成器末尾时结束迭代:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="b3e5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果想提前终止一个生成器函数，只需用return关键字退出该函数。不匹配返回类型的问题是不必要的，因为函数调用没有静态定义的类型。所以处理起来比C#简单一点。</p><h1 id="ef21" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">异步发电机</h1><p id="56eb" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">自ECMAScript 2018以来，JavaScript还知道生成器的异步变体，这些变体是用<em class="ls"> async </em>关键字定义的，并允许在生成器中使用<em class="ls"> await </em>调用异步代码。以前，这些函数只是为同步代码设计的，不可否认这是很不切实际的。</p><p id="0ef7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">异步生成器的定义如下:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="1717" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了运行这样的生成器，JavaScript还知道一种新形式的循环，因为经典的<em class="ls"> for … of- </em>循环在这里并不合适——毕竟，它也是为同步代码设计的。</p><p id="d3c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">解决方法是- 循环中 <em class="ls"> await …的<em class="ls">:</em></em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="5625" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该注意到- 循环的<em class="ls"> for </em> <em class="ls"> await …只能在异步函数中使用，因为它使用了<em class="ls"> await </em>关键字。</em></p><h1 id="9e8d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">流动</h1><p id="6a0b" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">总的来说，这实现了令人兴奋的新场景，尤其是在数据的异步处理中。这种数据通常以流的形式提供，必须将数据和结束附加到流的事件上:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="177d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这只是最小的实现，因为您实际上还必须监听错误事件。我还建议删除流后面附加的事件处理程序，以防止内存泄漏。这同样适用于错误发生后。您用以下示例中的结构替换了以前紧凑且易于管理的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="7c16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很容易想象当不止一个流在运行时，这样的代码退化得有多快。然而，ECMAScript 2018引入的异步文献器以最优雅的方式解决了这个问题，并且在内部基于已经描述的异步发电机的基本概念。</p><p id="073b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从版本10开始，Node.js至少包括对此的实验性支持，流行的web浏览器甚至包括最终支持。[5]</p><p id="91a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">X _ 3 _ 1 _ stream processing . js</em>中显示的代码可以简化为以下几行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="2100" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls"> for await … of- </em>循环处理正确连接和分离事件处理程序的逻辑。即使调用break手动退出循环，构造也会执行所有必要的清理。这极大地简化了基于流(或其他异步数据源)编写JavaScript代码。</p><h1 id="b439" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">结论</h1><p id="65bf" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">C#和yield的开发者并不是那么好的朋友。随着LINQ的引入，更多的开发人员定期使用<em class="ls"> yield </em>，但大多是间接使用。</p><p id="c8c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们谈到JavaScript时，它的行为是一样的。<em class="ls">收益率</em>不是很受欢迎。最近，由于异步数据处理通过生成器函数&amp;变得更加方便，ECMAScript 2018结合用于await的<em class="ls">为我们带来了异步生成器和迭代器..的</em>-环<em class="ls">产量</em>得到了比以前更多的关注。</p><p id="77a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过在浏览器或服务器上使用Node开发代码，您可以轻松地使用yield更快、更轻松地达到目标。JS，并抱怨在处理流时不方便地开发策略。</p><p id="719b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为你自己节省大量的时间，专注于重要的主题。  </p><p id="4581" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">延伸阅读:</strong></p><div class="ng nh gp gr ni nj"><a href="https://medium.com/next-level-source-code/game-engines-guide-to-pick-the-right-16b843905ba6" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">游戏引擎:选择正确的指南！</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">如何开发游戏第一步:为你的开发选择合适的引擎</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="ny l nu nv nw ns nx kp nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://pjdarnold.medium.com/enums-typescript-4-0-and-javascript-guide-all-you-need-to-know-5e090355bff6" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">Enums TypeScript 4.0和JavaScript指南—您需要知道的一切</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">你将读到的关于enums的最后一个指南！</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">pjdarnold.medium.com</p></div></div><div class="ns l"><div class="nz l nu nv nw ns nx kp nj"/></div></div></a></div><div class="ng nh gp gr ni nj"><a href="https://medium.com/javascript-in-plain-english/the-dark-side-of-typescript-try-catch-deeded18ba0d" rel="noopener follow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">TypeScript中Try/Catch的黑暗面</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">用“unknown”转义TypeScript 4.0中的任何错误异常</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">medium.com</p></div></div><div class="ns l"><div class="oa l nu nv nw ns nx kp nj"/></div></div></a></div><h1 id="6d8f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">参考</h1><p id="9d63" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">[1]当前c# API<a class="ae kv" href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerator.current?view=net-5.0" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/API/system . collections . ienumerator . Current？view = net-5.0</a><br/>【2】MoveNext()C # API<a class="ae kv" href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerator.movenext?view=net-5.0" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/de-de/dot net/API/system . collections . ienumerator . MoveNext？view = net-5.0</a><br/>【3】延迟执行微软示例<br/><a class="ae kv" href="https://docs.microsoft.com/en-us/dotnet/standard/linq/deferred-execution-example" rel="noopener ugc nofollow" target="_blank">https://docs . Microsoft . com/en-us/dot net/standard/linq/Deferred-Execution-example</a><br/>【4】Yield JavaScript<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/de/docs/Web/JavaScript/Reference/Operators/Yield</a><br/>【5】节点。JS第十版<a class="ae kv" href="https://nodejs.org/docs/latest-v10.x/api/index.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v10.x/api/index.html</a></p></div></div>    
</body>
</html>