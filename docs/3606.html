<html>
<head>
<title>The Beauty of the Optional Chaining Operator (?.) in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可选链接操作符(？。)在打字稿中</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-beauty-of-optional-chaining-in-typescript-32dd58ce1380?source=collection_archive---------5-----------------------#2020-10-12">https://javascript.plainenglish.io/the-beauty-of-optional-chaining-in-typescript-32dd58ce1380?source=collection_archive---------5-----------------------#2020-10-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="c1b5" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">类型脚本重构</h2><div class=""/><div class=""><h2 id="e150" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">可选链接提供了一种重构我们的TypeScript和JavaScript代码的新方法。TypeScript 3.7呈现猫王(？。)</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/bf5e6f700d9e4815e886df944dbe8155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Fgi7b9lI8Fn8905U"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@shelly94?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Michèle Eckert</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="lf"><p id="6e0e" class="lg lh iq bd li lj lk ll lm ln lo lp dk translated">可选的链接操作符支持除IE、Firefox for Android、Opera for Android和Samsung Browser之外的所有流行浏览器。</p></blockquote><h1 id="2a51" class="lq lr iq bd ls lt lu lv lw lx ly lz ma kf mb kg mc ki md kj me kl mf km mg mh bi translated">猫王接线员？。(也称为可选链接)</h1><h2 id="5368" class="mi lr iq bd ls mj mk dn lw ml mm dp ma mn mo mp mc mq mr ms me mt mu mv mg iw bi translated">更简洁代码的简化JavaScript符号</h2><p id="f0a6" class="pw-post-body-paragraph mw mx iq my b mz na ka nb nc nd kd ne mn nf ng nh mq ni nj nk mt nl nm nn lp ij bi translated">JavaScript发展很快，因此，<strong class="my ja"> TypeScript也随之发展很快</strong>以我们编写JavaScript的方式推动新的特性和创新。</p><p id="7ffe" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">所有这些都是为了提高开发人员的生产力和改善开发人员的体验。</p><h2 id="862f" class="mi lr iq bd ls mj mk dn lw ml mm dp ma mn mo mp mc mq mr ms me mt mu mv mg iw bi translated">输入TypeScript 3.7…</h2><p id="d6c4" class="pw-post-body-paragraph mw mx iq my b mz na ka nb nc nd kd ne mn nf ng nh mq ni nj nk mt nl nm nn lp ij bi translated">TypeScript 3.7给了我们可选的链接操作符(<code class="fe nt nu nv nw b">?.</code>),使得<strong class="my ja">能够缩短我们原本冗长而复杂的代码</strong>。一旦开始使用这个操作符，重构的可能性就变得显而易见了。</p><p id="4e12" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">学会了Swift，它一直是我认为TypeScript中缺失的一个功能。</p><p id="5c0f" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated"><strong class="my ja">我总是开始写它，意识到我在用错误的语言思考，然后在开始写包含多个<code class="fe nt nu nv nw b">&amp;&amp;</code>、<code class="fe nt nu nv nw b">!==</code>和<code class="fe nt nu nv nw b">?</code>的更令人畏惧的版本时，想知道为什么它不是JavaScript </strong>的一部分</p><p id="e8d3" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">我下意识地写可选链接<strong class="my ja"> </strong>的原因是<strong class="my ja">它只是对我讲常识。过去，必须用TypeScript编写替代方案是冗长、耗时和重复的。直到它最终被实现。我从未回头。</strong></p><blockquote class="nx ny nz"><p id="a466" class="mw mx oa my b mz no ka nb nc np kd ne ob nq ng nh oc nr nj nk od ns nm nn lp ij bi translated">TypeScript的伟大之处在于，您总是可以使用最新的特性，因为您最终只是转换成了标准的JavaScript。</p></blockquote><h2 id="a982" class="mi lr iq bd ls mj mk dn lw ml mm dp ma mn mo mp mc mq mr ms me mt mu mv mg iw bi translated">背后的逻辑是什么？</h2><blockquote class="lf"><p id="e53f" class="lg lh iq bd li lj oe of og oh oi lp dk translated">当使用点(。)符号来访问属性/方法，如果引用(对象)是<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Glossary/nullish" rel="noopener ugc nofollow" target="_blank"> nullish </a> ( <code class="fe nt nu nv nw b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null" rel="noopener ugc nofollow" target="_blank">null</a></code>或<code class="fe nt nu nv nw b"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" rel="noopener ugc nofollow" target="_blank">undefined</a></code>)，表达式会短路，返回未定义的<code class="fe nt nu nv nw b">.</code></p></blockquote><p id="8232" class="pw-post-body-paragraph mw mx iq my b mz oj ka nb nc ok kd ne mn ol ng nh mq om nj nk mt on nm nn lp ij bi translated"><strong class="my ja">它让我的代码更加……</strong></p><ul class=""><li id="be9b" class="oo op iq my b mz no nc np mn oq mq or mt os lp ot ou ov ow bi translated">简单的</li><li id="320b" class="oo op iq my b mz ox nc oy mn oz mq pa mt pb lp ot ou ov ow bi translated">易读的</li><li id="6680" class="oo op iq my b mz ox nc oy mn oz mq pa mt pb lp ot ou ov ow bi translated">直觉的</li><li id="846d" class="oo op iq my b mz ox nc oy mn oz mq pa mt pb lp ot ou ov ow bi translated">简明的</li></ul><h2 id="67a2" class="mi lr iq bd ls mj mk dn lw ml mm dp ma mn mo mp mc mq mr ms me mt mu mv mg iw bi translated">为什么写…</h2><pre class="kp kq kr ks gt pc nw pd pe aw pf bi"><span id="e6e1" class="mi lr iq nw b gy pg ph l pi pj">const val = otherVal !== null &amp;&amp; otherVal !== undefined &amp;&amp; otherVal.prop !== null &amp;&amp; otherVal.prop !== undefined &amp;&amp; otherVal.prop.name;</span></pre><h2 id="7f0a" class="mi lr iq bd ls mj mk dn lw ml mm dp ma mn mo mp mc mq mr ms me mt mu mv mg iw bi translated">当你能写的时候…</h2><pre class="kp kq kr ks gt pc nw pd pe aw pf bi"><span id="66b6" class="mi lr iq nw b gy pg ph l pi pj">const val = otherVal?.prop?.name;</span></pre><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="pk pl l"/></div></figure><blockquote class="nx ny nz"><p id="f5b9" class="mw mx oa my b mz no ka nb nc np kd ne ob nq ng nh oc nr nj nk od ns nm nn lp ij bi translated">可选的链接简化了不必要的复杂性。</p></blockquote><h1 id="1da8" class="lq lr iq bd ls lt lu lv lw lx ly lz ma kf pm kg mc ki pn kj me kl po km mg mh bi translated">使用可选链接，您可以问一个问题</h1><p id="fb29" class="pw-post-body-paragraph mw mx iq my b mz na ka nb nc nd kd ne mn nf ng nh mq ni nj nk mt nl nm nn lp ij bi translated">可选的链接操作符让我们能够编写高效、干净的代码，包括<code class="fe nt nu nv nw b">null</code>或<code class="fe nt nu nv nw b">undefined</code>检查，能够在执行任何操作之前安静地失败，同时不会分散对<em class="oa">快乐路径</em>的注意力。</p><p id="15ef" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">当你在代码中写<code class="fe nt nu nv nw b">?.</code>时，你实际上是在问(<strong class="my ja">在操作一个变量之前)</strong> …</p><blockquote class="lf"><p id="d4c7" class="lg lh iq bd li lj oe of og oh oi lp dk translated">“如果允许的话…”</p></blockquote><p id="0f7f" class="pw-post-body-paragraph mw mx iq my b mz oj ka nb nc ok kd ne mn ol ng nh mq om nj nk mt on nm nn lp ij bi translated">哪个<strong class="my ja">更准确地说</strong>是指…</p><blockquote class="lf"><p id="7e79" class="lg lh iq bd li lj oe of og oh oi lp dk translated">“如果你不为空或未定义…否则就当我没问，然后返回undefined "</p></blockquote><p id="195c" class="pw-post-body-paragraph mw mx iq my b mz oj ka nb nc ok kd ne mn ol ng nh mq om nj nk mt on nm nn lp ij bi translated">所以用上面的例子:</p><pre class="kp kq kr ks gt pc nw pd pe aw pf bi"><span id="0220" class="mi lr iq nw b gy pg ph l pi pj">const val = otherVal?.prop?.name;</span></pre><p id="ae36" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">你是在用这段代码说“如果<code class="fe nt nu nv nw b">otherVal</code>及其<code class="fe nt nu nv nw b">prop</code>属性都<strong class="my ja">不为空</strong>或<strong class="my ja">未定义，</strong>请获取<code class="fe nt nu nv nw b">name</code>属性，否则返回<code class="fe nt nu nv nw b">undefined</code>”。</p><blockquote class="nx ny nz"><p id="7835" class="mw mx oa my b mz no ka nb nc np kd ne ob nq ng nh oc nr nj nk od ns nm nn lp ij bi translated">简单可选链接表达式中的<strong class="my ja">或</strong>值，在无效检查失败时触发，总是<strong class="my ja"/><code class="fe nt nu nv nw b"><strong class="my ja">undefined</strong></code>。</p></blockquote><h1 id="f42f" class="lq lr iq bd ls lt lu lv lw lx ly lz ma kf pm kg mc ki pn kj me kl po km mg mh bi translated">我什么时候应该使用可选链接？</h1><p id="9f6f" class="pw-post-body-paragraph mw mx iq my b mz na ka nb nc nd kd ne mn nf ng nh mq ni nj nk mt nl nm nn lp ij bi translated">在编写新的类型脚本代码时，有几种不同的情况可以考虑使用操作符:</p><ul class=""><li id="b4ba" class="oo op iq my b mz no nc np mn oq mq or mt os lp ot ou ov ow bi translated">当你想<strong class="my ja">访问</strong>一个嵌套值时，只有当它存在时(不是nullish)。</li><li id="2456" class="oo op iq my b mz ox nc oy mn oz mq pa mt pb lp ot ou ov ow bi translated">当你想<strong class="my ja">执行</strong>一个函数时，只有当它存在时(不是nullish)。</li></ul><blockquote class="lf"><p id="ba59" class="lg lh iq bd li lj lk ll lm ln lo lp dk translated">在可选链接之前面对这些情况时，您可能已经用三元运算符编写了长格式的nullish检查。</p></blockquote><p id="e3c0" class="pw-post-body-paragraph mw mx iq my b mz oj ka nb nc ok kd ne mn ol ng nh mq om nj nk mt on nm nn lp ij bi translated">因此，在重构现有的TypeScript代码时，使用可选链接的主要思想是用简化的<code class="fe nt nu nv nw b">?.</code>替换长格式的<code class="fe nt nu nv nw b">null</code>和<code class="fe nt nu nv nw b">undefined</code>检查。</p><h2 id="21f2" class="mi lr iq bd ls mj mk dn lw ml mm dp ma mn mo mp mc mq mr ms me mt mu mv mg iw bi translated">可选链接是一个消音器</h2><p id="9faa" class="pw-post-body-paragraph mw mx iq my b mz na ka nb nc nd kd ne mn nf ng nh mq ni nj nk mt nl nm nn lp ij bi translated">底层逻辑围绕<strong class="my ja">设计，以防止未捕获的错误，或者</strong>通过在某种意义上处理它们，通过支持<strong class="my ja"> </strong> <code class="fe nt nu nv nw b">undefined</code>值，而不是抛出错误，这可能在运行时表现为<em class="oa">未捕获的</em>。</p><p id="85d9" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">所以你可以把操作者的行为看作是<strong class="my ja">消除</strong>对变量操作的失败尝试，让应用程序照常运行。所以你应该意识到你可能在处理一个<code class="fe nt nu nv nw b">undefined</code>值。</p><p id="6ec8" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">话虽如此，可选链接的行为可能会使您陷入困境，因为在处理<code class="fe nt nu nv nw b">undefined</code>值时需要权衡实现的方法。</p><h2 id="098a" class="mi lr iq bd ls mj mk dn lw ml mm dp ma mn mo mp mc mq mr ms me mt mu mv mg iw bi translated">权衡——显式还是隐式错误处理</h2><p id="7e16" class="pw-post-body-paragraph mw mx iq my b mz na ka nb nc nd kd ne mn nf ng nh mq ni nj nk mt nl nm nn lp ij bi translated">有了可选链接，当使用三元运算符时，您可以用更可选的错误处理替换更显式的错误处理方法，其中or条件是强制的。你可以说错误是用<code class="fe nt nu nv nw b">undefined</code>处理的，但这不是严格地处理错误，只是忽略它。</p><h1 id="0c6a" class="lq lr iq bd ls lt lu lv lw lx ly lz ma kf pm kg mc ki pn kj me kl po km mg mh bi translated">如何用(？。)</h1><p id="7a4c" class="pw-post-body-paragraph mw mx iq my b mz na ka nb nc nd kd ne mn nf ng nh mq ni nj nk mt nl nm nn lp ij bi translated"><strong class="my ja">深度对象访问— </strong>访问嵌套对象属性</p><pre class="kp kq kr ks gt pc nw pd pe aw pf bi"><span id="98aa" class="mi lr iq nw b gy pg ph l pi pj">// making sure <strong class="nw ja">employee</strong>, and it's <strong class="nw ja">address</strong> isn't nullish before accessing postCode</span><span id="86df" class="mi lr iq nw b gy pp ph l pi pj">employee?.address?.postCode</span></pre><p id="64ca" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated"><strong class="my ja">函数调用— </strong>如果对象/函数存在，则执行实例方法</p><pre class="kp kq kr ks gt pc nw pd pe aw pf bi"><span id="b1ff" class="mi lr iq nw b gy pg ph l pi pj">// making sure <strong class="nw ja">employee</strong> isn't nullish before executing the function</span><span id="3312" class="mi lr iq nw b gy pp ph l pi pj">employee?.sayHowCanIHelp();</span><span id="eb83" class="mi lr iq nw b gy pp ph l pi pj">// making sure the function exists before executing it</span><span id="3ec7" class="mi lr iq nw b gy pp ph l pi pj">employee?.sayHowCanIHelp?.();</span></pre><p id="c43e" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated"><strong class="my ja">索引— </strong>防止无效的对象/数组索引</p><pre class="kp kq kr ks gt pc nw pd pe aw pf bi"><span id="b7b7" class="mi lr iq nw b gy pg ph l pi pj">// making sure <strong class="nw ja">employees</strong> and <strong class="nw ja">employees[0]</strong> isn't nullish</span><span id="01e4" class="mi lr iq nw b gy pp ph l pi pj">company.employees?.[0]?.name</span></pre><p id="1c82" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated"><strong class="my ja">简化映射— </strong>防止(先前)不可避免的三元运算符</p><pre class="kp kq kr ks gt pc nw pd pe aw pf bi"><span id="40c2" class="mi lr iq nw b gy pg ph l pi pj">const val = myMap.get('Nope')?.val;</span><span id="ac55" class="mi lr iq nw b gy pp ph l pi pj">// <strong class="nw ja">This is an alternative to...</strong></span><span id="e863" class="mi lr iq nw b gy pp ph l pi pj">const val = myMap.has('Nope') &amp;&amp; myMap.get('Nope') ? myMap.get('Nope').val : undefined;</span></pre><h1 id="1215" class="lq lr iq bd ls lt lu lv lw lx ly lz ma kf pm kg mc ki pn kj me kl po km mg mh bi translated">真实世界示例-角度英尺。NgOnChanges</h1><p id="1df7" class="pw-post-body-paragraph mw mx iq my b mz na ka nb nc nd kd ne mn nf ng nh mq ni nj nk mt nl nm nn lp ij bi translated">让我们抛开琐碎的例子，用可选的链接展示重构前后的一个更真实的代码例子。</p><h2 id="896c" class="mi lr iq bd ls mj mk dn lw ml mm dp ma mn mo mp mc mq mr ms me mt mu mv mg iw bi translated">一些背景</h2><p id="ec8b" class="pw-post-body-paragraph mw mx iq my b mz na ka nb nc nd kd ne mn nf ng nh mq ni nj nk mt nl nm nn lp ij bi translated">我在我的项目中使用了Angular，所以我在Angular组件中的一个函数中找到了一些带有大量可选链接的代码。</p><p id="2690" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">该组件实现了<code class="fe nt nu nv nw b">NgOnChanges</code>生命周期钩子，该钩子在检测到组件的数据绑定输入的每个变化后执行。</p><p id="b79c" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">这里可以使用可选链接，因为类型为<code class="fe nt nu nv nw b">SimpleChanges</code> <strong class="my ja">的<code class="fe nt nu nv nw b">ngOnChanges()</code>的<code class="fe nt nu nv nw b">changes</code>参数需要深度对象访问</strong>来检索改变的值，包括先前和当前的值。</p><p id="f5a8" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">此外，我在处理组件中的Mapbox标记时遇到了一个问题。经常会有这样的情况，当不是有意的时候，组件会让标记失效。</p><p id="d418" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">随后，当标记不存在时，组件会尝试与它交互。</p><h2 id="d124" class="mi lr iq bd ls mj mk dn lw ml mm dp ma mn mo mp mc mq mr ms me mt mu mv mg iw bi translated">具有可选链接的NgOnChanges函数</h2><p id="b302" class="pw-post-body-paragraph mw mx iq my b mz na ka nb nc nd kd ne mn nf ng nh mq ni nj nk mt nl nm nn lp ij bi translated">由于知道Mapbox在涉及Angular's Zone (NgZone)时会不经意间做出一些事情<strong class="my ja">，并且您永远无法保证某个标记与组件共存，因此<strong class="my ja">可选链接是一种确保应用程序在这些情况下不会中断的简单方法</strong>。</strong></p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="pq pl l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">NgOnChanges with Optional Chaining</figcaption></figure><p id="6c20" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated"><code class="fe nt nu nv nw b">markerInstance</code>域是一个Mapbox标记，如果它存在的话<strong class="my ja">我只想处理它</strong>。可选链接修复了这个问题，允许隐藏标记的未定义或空值，而不会引发错误。</p><p id="c910" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated"><strong class="my ja">看起来也很干净简单</strong>。在可选链接之前，另一种选择怎么样…</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="pq pl l"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">NgOnChanges without Optional Chaining</figcaption></figure><p id="ff62" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">如果没有可选的链接，由于<strong class="my ja">附加的显式条件检查</strong> ( <code class="fe nt nu nv nw b">if</code>语句)，函数逻辑看起来更复杂，可读性也更差。</p><p id="0f20" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">因此，在可选链接之前编写该功能将产生一个具有2-3层深度的<strong class="my ja">嵌套函数，而不是1层深度。</strong></p><h1 id="4d1d" class="lq lr iq bd ls lt lu lv lw lx ly lz ma kf pm kg mc ki pn kj me kl po km mg mh bi translated">“但我不想让‘未定义’作为返回值”</h1><h2 id="ce47" class="mi lr iq bd ls mj mk dn lw ml mm dp ma mn mo mp mc mq mr ms me mt mu mv mg iw bi translated">引入零化合并(？？)</h2><p id="992e" class="pw-post-body-paragraph mw mx iq my b mz na ka nb nc nd kd ne mn nf ng nh mq ni nj nk mt nl nm nn lp ij bi translated">为什么不把可选链接和新操作符<code class="fe nt nu nv nw b">nullish coalescing</code>结合起来？</p><p id="d655" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">Nullish合并启用一个<strong class="my ja">指定的默认</strong>返回值。这与可选链接一起工作很好，因为它使用相同的<strong class="my ja">无效</strong>检查来短路。如果左边表达式的结果是<code class="fe nt nu nv nw b">null</code>或<code class="fe nt nu nv nw b">undefined</code>，就会触发。</p><pre class="kp kq kr ks gt pc nw pd pe aw pf bi"><span id="84df" class="mi lr iq nw b gy pg ph l pi pj">const name = company.employees?.[0]?.name;</span><span id="15e6" class="mi lr iq nw b gy pp ph l pi pj">// <strong class="nw ja">with Nullish Coalescing...</strong></span><span id="9fa4" class="mi lr iq nw b gy pp ph l pi pj">const name = company.employees?.[0]?.name ?? 'Anonymous';</span></pre></div><div class="ab cl pr ps hu pt" role="separator"><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw"/></div><div class="ij ik il im in"><h1 id="1b0d" class="lq lr iq bd ls lt py lv lw lx pz lz ma kf qa kg mc ki qb kj me kl qc km mg mh bi translated">如何在您的项目中启用最新的TypeScript &amp; JavaScript特性🚀</h1><p id="17eb" class="pw-post-body-paragraph mw mx iq my b mz na ka nb nc nd kd ne mn nf ng nh mq ni nj nk mt nl nm nn lp ij bi translated">使用最新特性的能力取决于您安装的TypeScript编译器，以及<code class="fe nt nu nv nw b">tsconfig.json</code>中的配置细节。</p><h2 id="7f98" class="mi lr iq bd ls mj mk dn lw ml mm dp ma mn mo mp mc mq mr ms me mt mu mv mg iw bi translated">安装TypeScript 3.7</h2><pre class="kp kq kr ks gt pc nw pd pe aw pf bi"><span id="6860" class="mi lr iq nw b gy pg ph l pi pj">$ npm i typescript@3.7 --save-dev</span></pre><h2 id="c99d" class="mi lr iq bd ls mj mk dn lw ml mm dp ma mn mo mp mc mq mr ms me mt mu mv mg iw bi translated">将“esnext”指定为tsconfig.json中的模块</h2><pre class="kp kq kr ks gt pc nw pd pe aw pf bi"><span id="69f5" class="mi lr iq nw b gy pg ph l pi pj">"module"                : "<strong class="nw ja">esnext</strong>",<br/>"moduleResolution"      : "node",<br/>"target"                : "<strong class="nw ja">es5</strong>",<br/>"typeRoots"             : [<br/>  "node_modules/@types"<br/>],</span></pre></div><div class="ab cl pr ps hu pt" role="separator"><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw px"/><span class="pu bw bk pv pw"/></div><div class="ij ik il im in"><h1 id="f8a9" class="lq lr iq bd ls lt py lv lw lx pz lz ma kf qa kg mc ki qb kj me kl qc km mg mh bi translated">所以总结一下</h1><p id="4df2" class="pw-post-body-paragraph mw mx iq my b mz na ka nb nc nd kd ne mn nf ng nh mq ni nj nk mt nl nm nn lp ij bi translated">可选链接引入了一个干净简单的<strong class="my ja">替代结构，否则在处理属性访问链<strong class="my ja">时会涉及深度嵌套和不必要的复杂</strong> <code class="fe nt nu nv nw b"><strong class="my ja">if</strong></code> <strong class="my ja">语句</strong>。</strong></p><p id="5ce2" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">这是在对该变量进行操作时确保<strong class="my ja">非空</strong>条件的可读性最好的方法。</p><p id="3805" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">感谢阅读！有任何问题，请在评论中告诉我。</p><p id="938c" class="pw-post-body-paragraph mw mx iq my b mz no ka nb nc np kd ne mn nq ng nh mq nr nj nk mt ns nm nn lp ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae le" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="my ja">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="my ja">！</strong></p></div></div>    
</body>
</html>