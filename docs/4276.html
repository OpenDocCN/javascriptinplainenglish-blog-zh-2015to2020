<html>
<head>
<title>5 JavaScript Technical Interview Questions That You Should Be Prepared For</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该准备好的5个JavaScript技术面试问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-javascript-technical-interview-questions-that-everyone-has-to-prepare-39c0c062891f?source=collection_archive---------1-----------------------#2020-11-30">https://javascript.plainenglish.io/5-javascript-technical-interview-questions-that-everyone-has-to-prepare-39c0c062891f?source=collection_archive---------1-----------------------#2020-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/59013d704c8d0d92a6ed05cdc9832c8d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SZ9hlfia03wfgsth.jpg"/></div></div></figure><h1 id="d297" class="jy jz iq bd ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">1.JavaScript与其他语言有何不同</h1><h2 id="cd69" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> 1.1) JS是JIT编译的</strong></h2><p id="dd27" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">虽然其他语言(如C、Java、C#)是预先编译的，但JS是在运行时用实时(JIT)编译器解释和编译的。</p><p id="fec2" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated"><em class="ml"> JavaScript跳过了&lt;编译器&gt; &amp; &amp; &lt;字节码&gt;的步骤。</em></p><p id="2bd7" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated"><em class="ml"> Java示例编译步骤如下:</em></p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mm"><img src="../Images/d4b98c98aa21479114c6c5a86d9f30c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z4JQbxDfpYrBY0fy.png"/></div></div></figure><h2 id="1ea5" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> 1.2) JS动态类型化</strong></h2><p id="2aa1" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">除非使用TypeScript，否则JavaScript是动态类型的。</p><p id="7b84" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">在JS中，可以动态地改变或重新分配类型。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/40a742c1204c33331d31a27810d73550.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/0*O1YQ9Nb-Evm5v5Ej.png"/></div></figure><h2 id="fe5e" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> 1.3) JS是无类语言</strong></h2><p id="32a3" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">*ECMAScript 2015，也称为ES6，引入了JavaScript类。</p><p id="e216" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">JavaScript是一种无类语言；可以模拟上课。尽管JavaScript没有类，但它有对象，这就定义了语言是面向对象的。例如，可以通过使用<strong class="ln ir">原型</strong>来使用继承，函数本身也是对象，因为它们有自己的属性和方法。</p><p id="23be" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated"><strong class="ln ir"> Cat </strong>对象函数可以作为带有‘new’关键字的类工作:</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/e8518bc92db2ccc35f53db362d261fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*QA09QxQ1LGoKl2R8.png"/></div></figure><h2 id="83e3" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> 1.4)变量范围</strong></h2><p id="be3f" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">没有公共变量、私有变量或受保护变量这样的东西:这些都是可以模拟的。</p><p id="1765" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated"><em class="ml">您可以使用作用域模拟公共、私有或受保护的变量。</em></p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/d089d747b15d4a3f0d1cef680a17d177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*wcyGLZ_L2XTkGv9_.png"/></div></div></figure></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="2f15" class="jy jz iq bd ka kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv bi translated">2.什么是REST(ful) API？</h1><p id="086e" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated"><em class="ml">它的</em> <strong class="ln ir"> <em class="ml">架构</em> </strong> <em class="ml">风格为分布式系统，REST是</em><strong class="ln ir"><em class="ml">RE</em></strong><em class="ml">presentation</em><strong class="ln ir"><em class="ml">S</em></strong><em class="ml">tate</em><strong class="ln ir"><em class="ml">T</em></strong><em class="ml">transfer。</em></p><p id="0729" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">一个<strong class="ln ir"> API </strong>是一个应用程序编程接口。它是一组允许程序相互交流的规则。开发人员在服务器上创建API，并允许客户端与之对话。</p><p id="f639" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated"><strong class="ln ir"> REST </strong>决定<strong class="ln ir">API的外观。</strong>还有5个定义RESTful系统的指导性架构约束。在本文中，我将只介绍<strong class="ln ir">统一接口</strong>，因为它是一个约束，使得RESTful风格的架构与大多数其他网络应用程序架构不同。</p><h2 id="321d" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> HATEOAS(统一接口)</strong></h2><p id="35a3" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">HATEOAS表示超文本是应用程序状态的引擎。它允许客户端可以通过遍历超媒体来动态地导航到适当的资源(<strong class="ln ir"> REST资源寻址能力)。</strong></p><p id="23cb" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">与特定方法一起使用的HATEOAS(即<code class="fe ng nh ni nj b">POST</code>、<code class="fe ng nh ni nj b">GET</code>)告诉服务器客户端想要执行哪个任务。例如，<code class="fe ng nh ni nj b">/customers/{id}</code> URI路径和<code class="fe ng nh ni nj b">GET</code>请求意味着客户想要<em class="ml">得到一个特定的客户。</em></p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/a357d03f42aceee9b72ddf8522809154.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vPE5AyQ0wHl7QvbH.png"/></div></div></figure><h2 id="c44e" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">Restful API的优点:</strong></h2><ul class=""><li id="d0f3" class="nl nm iq ln b lo lp ls lt lb nn le no lh np mf nq nr ns nt bi translated">将客户端和服务器解耦。</li><li id="daea" class="nl nm iq ln b lo nu ls nv lb nw le nx lh ny mf nq nr ns nt bi translated">统一的接口有助于开发者之间的交流更加容易。</li></ul><h2 id="46df" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> Restful API vs SOAP </strong></h2><p id="0f1b" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated"><em class="ml">总结:SOAP专门依靠</em><strong class="ln ir"><em class="ml">XML</em></strong><em class="ml">来提供消息服务。这给了SOAP一个好处，即它有一个标准。但是它对XML的使用也是SOAP的缺点，因为JSON现在更容易使用，也更受欢迎。</em></p><p id="c007" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">与基于SOAP的web服务不同，RESTful web APIs没有“官方”标准。这是因为REST是一种架构风格，而SOAP是一种协议。REST本身不是一个标准，但是RESTful实现利用了一些标准，比如HTTP、URI、JSON和XML。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/5fa4fb2e7fa5cb3a628d16a69a9d03e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/0*XFJmB6Gdk_caSuQ5.png"/></div></figure></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="0a3c" class="jy jz iq bd ka kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv bi translated">3.你如何测试代码？</h1><p id="ebf6" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">有许多方法可以确保你编写出高质量的代码。首先，让我们比较单元测试和端到端(E2E)测试。</p><h2 id="5654" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> 3.1) JavaScript单元测试</strong></h2><p id="f0c2" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">单元测试测试一个代码块(即函数)“单元”，以确保它们都按预期<strong class="ln ir">运行</strong>。这种测试允许开发人员检查程序的单个区域，以查看错误发生的位置(和原因)。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/0c708cc527d152a404101a414da678b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/0*Idsvp6xgDj9f_1vw.png"/></div></figure><h2 id="1032" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">单元测试的好处</strong></h2><p id="f724" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">1.它使你的项目更加敏捷。每当你添加一个新的功能，你可能不得不改变旧的代码。改变一个已经测试过的代码既昂贵又有风险。然而，如果您对新代码运行单元测试，您将确信新代码不会破坏任何旧的特性。</p><p id="2313" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">2.有助于在开发周期的早期发现bug。</p><h2 id="20f5" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">流行的单元测试工具</strong></h2><p id="3e66" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated"><strong class="ln ir">笑话</strong></p><p id="b1f5" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">Jest是一个由脸书维护的JavaScript测试框架。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/4265fa747b1ec76515a90c96c45744e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*SBOJRIzhw9ZAeWhy.jpg"/></div></div></figure><h2 id="11cf" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> 3.2) JavaScript E2E测试</strong></h2><p id="1176" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">端到端(E2E)测试是一种用于测试应用程序<strong class="ln ir">是否按预期运行的技术。</strong>简单来说，一种软件测试方法，用来从头到尾测试一个应用流程。E2E的主要目的是模拟真实的用户场景。</p><h2 id="b25d" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">流行的E2E测试工具</strong></h2><p id="8451" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated"><strong class="ln ir"> Cypress.io </strong></p><p id="b277" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">快速，简单和可靠的测试任何在浏览器中运行的东西。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oc"><img src="../Images/12a940576595f77de1b6f24428f3bd64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*tWT9XANtxfX1xc3J.png"/></div></div></figure><h2 id="0b09" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> TDD与BDD的对比</strong></h2><p id="739a" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">“你在测试什么？”在比较<strong class="ln ir">单元测试</strong>和<strong class="ln ir"> E2E测试</strong>时，这是一个很大的问题。在行为驱动开发(<strong class="ln ir"> BDD </strong>)中，你在寻找行为，例如，在某个条件下这个系统会发生什么。但是在测试驱动开发(<strong class="ln ir"> TDD </strong>)中，你有一个方法测试，它将断言一些条件，但是随着系统的发展，这些测试可能会给你错误的结果。</p><h2 id="f412" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">进一步简单地说，它可以写成</strong></h2><p id="c135" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">在<strong class="ln ir"> TDD </strong>中，我不太在意输出。唯一需要的是以特定的方式进行测试。</p><p id="b211" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">在<strong class="ln ir"> BDD </strong>中，我不介意你如何得出输出，只关心在给定条件下输出必须正确。</p><h2 id="27ef" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">总结</strong></h2><p id="c58b" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">BDD是从TDD发展而来的，作为一种消除TDD缺点的方法。</p><p id="36cd" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">最好实现两种方法——一种支持开发人员编写的代码的质量，另一种支持产品所有者定义的系统行为。</p><h2 id="79cc" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> 3.3。棉绒</strong></h2><p id="5ece" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">lint是一种静态代码分析工具，用于标记编程错误、bug、风格错误和可疑结构。他们扫描你的脚本，找出常见问题和错误，然后给你一个报告，报告中有行号，你可以用它来修复问题。除了实际的bug和错误，他们还会检查主观的、<strong class="ln ir">风格偏好</strong>。</p><h2 id="22e2" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">棉绒的好处</strong></h2><p id="2501" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">1.Linter有助于轻松捕捉常见错误和bug。</p><p id="c37b" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">2.通过允许同事使用相同的代码风格，Linter有助于提高生产率。</p><h2 id="8ddf" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">流行棉绒</strong></h2><p id="a91f" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">埃斯林特</p><p id="5f3e" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">定制配置是ESLint的最大特色之一。虽然JSLint不允许配置，这意味着它强制实施单一的样式指南，但ESLint稍微灵活一些。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi od"><img src="../Images/298c6074ff65a908e96783f130b2edec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1EmqWWQoz74enAH6.png"/></div></div></figure><p id="2785" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">通过使用ESLint，你可以很容易地采用大型IT公司的编码风格。</p><h2 id="d967" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated">谷歌</h2><pre class="mn mo mp mq gt oe nj of og aw oh bi"><span id="862b" class="kw jz iq nj b gy oi oj l ok ol">“extends”: [“eslint:recommended”, “google”]</span></pre><h2 id="a2dd" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> AirBnb </strong></h2><pre class="mn mo mp mq gt oe nj of og aw oh bi"><span id="5bff" class="kw jz iq nj b gy oi oj l ok ol">"extends": ["eslint:recommended", "airbnb"]</span></pre><h2 id="950d" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">标准</strong></h2><pre class="mn mo mp mq gt oe nj of og aw oh bi"><span id="ed6d" class="kw jz iq nj b gy oi oj l ok ol">"extends": ["eslint:recommended", "standard"]</span></pre><h2 id="98e6" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> 3.4。在线代码编辑器</strong></h2><p id="0484" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">许多开发人员在日常开发和调试中使用在线代码编辑器，它的确是现代开发人员最好的测试工具之一。</p><h2 id="9a47" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> jsfiddle &amp; repl.it </strong></h2><p id="b933" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">适用于检查令人困惑的JavaScript类型和变量范围。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi om"><img src="../Images/b674a215e15b534c04f764fc93de1c3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:764/0*z_QpYPoklXv2Tc-t"/></div><figcaption class="on oo gj gh gi op oq bd b be z dk">repl.it</figcaption></figure><h2 id="70c5" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> CodeSandbox </strong></h2><p id="e04c" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">适合测试SPA代码(React、Vue或Angular)。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi or"><img src="../Images/d9afa912b055e5363fe7d84c6e14a486.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QFVcBSIROmFV3fL1.png"/></div></div></figure><h2 id="333f" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">代码打开</strong></h2><p id="e508" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">适合测试CSS和HTML。CSS很难调试和发现错误，因为CSS通常不会抛出任何错误。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi os"><img src="../Images/d274656f2043bec7b5c3177924de204f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sK7uqQtpD1v0Vse5.png"/></div></div></figure></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="f676" class="jy jz iq bd ka kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv bi translated">4.深度复制和浅度复制有什么区别？</h1><p id="f898" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">一个<strong class="ln ir">深度复制</strong>意味着新变量的所有值都被复制，并且<strong class="ln ir">与原来的</strong>变量断开。一个<strong class="ln ir">浅拷贝</strong>意味着某些(子)值仍然<strong class="ln ir">连接</strong>到原始变量。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/af2a5d960cd7e94d0d9ffdbc74b30726.png" data-original-src="https://miro.medium.com/v2/resize:fit:780/0*pgDMAdamYOEVk-w9"/></div></figure><h2 id="5362" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">JavaScript对象中的浅拷贝与深拷贝</strong></h2><p id="febe" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">在JavaScript中使用object时，浅层复制经常会出现问题。</p><h2 id="1b62" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">浅抄</strong></h2><p id="aa9f" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">我们只改变了对象<code class="fe ng nh ni nj b">b</code> ( <code class="fe ng nh ni nj b">b.pt </code>)的<code class="fe ng nh ni nj b">pt</code>属性，但是对象<code class="fe ng nh ni nj b">a</code>也改变了:</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="5c7d" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">在上面的例子中，我们实际上做了一个<strong class="ln ir">浅层拷贝。这经常是有问题的，因为我们期望旧变量有原始值，而不是改变后的值。</strong></p><h2 id="d381" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">深度复制</strong></h2><p id="0a3a" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">有多种方法可以制作对象的副本，特别是使用新的扩展和改进的JavaScript规范。</p><h2 id="4d6a" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">深度复制—扩展运算符</strong></h2><p id="5ad8" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">ES2015中引入的扩展运算符简短而简单。它<em class="ml">将</em>所有的值展开到一个新的对象中。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="ou ov l"/></div></figure><p id="6caf" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">例如，您还可以使用它将两个对象合并在一起</p><pre class="mn mo mp mq gt oe nj of og aw oh bi"><span id="36d5" class="kw jz iq nj b gy oi oj l ok ol">const c = {...a, ...b}</span></pre><h2 id="3c60" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">深度复制—对象.分配</strong></h2><p id="4492" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">这主要是在spread操作符出现之前使用的。<code class="fe ng nh ni nj b">Object.assign</code>将对象<code class="fe ng nh ni nj b">a</code>分配给空对象<code class="fe ng nh ni nj b">{}</code></p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="ou ov l"/></div></figure><h2 id="7812" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">陷阱:嵌套对象</strong></h2><p id="2372" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">在处理复制对象时有一个很大的注意事项，它适用于上面列出的两种方法。当你有<strong class="ln ir">一个嵌套对象(或数组)</strong>并复制它时，该对象内的嵌套对象不会被复制，因为只有指针/引用。<strong class="ln ir">浅浅再抄一遍</strong></p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="ou ov l"/></div></figure><h2 id="47f8" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">嵌套对象的深层副本——扩展操作符</strong></h2><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="ou ov l"/></div></figure><h2 id="66ba" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">嵌套对象的深层副本—stringy&amp;解析</strong></h2><p id="e325" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">手动遍历大对象并手动复制每个嵌套对象是非常乏味的。有一种方法可以不假思索地复制一切。你只需<code class="fe ng nh ni nj b">stringify</code>你的对象，然后<code class="fe ng nh ni nj b">parse</code>它</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="ou ov l"/></div></figure></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><h1 id="c32c" class="jy jz iq bd ka kb nb kd ke kf nc kh ki kj nd kl km kn ne kp kq kr nf kt ku kv bi translated">5.服务器端渲染是用来做什么的？</h1><h2 id="0544" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">服务器端渲染</strong></h2><p id="b041" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">服务器端呈现(SSR)是在服务器上呈现网页并将它们传递给浏览器(客户端)的过程，而不是在浏览器中呈现它们。SSR向客户端发送完全呈现的页面；客户端的JavaScript包接管并支持SPA框架的运行</p><h2 id="4850" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> SSR与客户端渲染</strong></h2><p id="d33b" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">服务器端呈现将完全呈现的页面发送给客户端；而客户端呈现需要导航到页面(<code class="fe ng nh ni nj b">router</code>)以获得页面的内容</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ow"><img src="../Images/12d8cb420cc5b612865d540f1ae2ca50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vONChn1G7LM0tdNY.png"/></div></div></figure><h2 id="bd21" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">SSR；赞成者</strong></h2><ul class=""><li id="279d" class="nl nm iq ln b lo lp ls lt lb nn le no lh np mf nq nr ns nt bi translated">它使页面加载更快，从而提供更好的用户体验</li><li id="61d1" class="nl nm iq ln b lo nu ls nv lb nw le nx lh ny mf nq nr ns nt bi translated">它在SEO(搜索引擎优化)中起着重要的作用，并能正确地索引网页，因为Google喜欢加载速度更快的网页</li></ul><h2 id="ca4e" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">SSR；CONS </strong></h2><ul class=""><li id="c39c" class="nl nm iq ln b lo lp ls lt lb nn le no lh np mf nq nr ns nt bi translated">在服务器端渲染一个大的应用程序可能非常耗时，并且可能会增加加载时间，因为这是一个<strong class="ln ir">单一瓶颈</strong></li><li id="be1b" class="nl nm iq ln b lo nu ls nv lb nw le nx lh ny mf nq nr ns nt bi translated">如果最终用户使用的是<strong class="ln ir">慢速互联网连接</strong>(即移动连接)或<strong class="ln ir">功能不足的设备</strong>(即老一代移动设备)，则会出现性能问题</li></ul><h2 id="cfc9" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak"> Next.js (SSR for React) </strong></h2><p id="6a2a" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">Next.js是一个开源的React前端开发web框架，支持服务器端渲染和为基于React的web应用程序生成静态网站等功能</p><pre class="mn mo mp mq gt oe nj of og aw oh bi"><span id="c399" class="kw jz iq nj b gy oi oj l ok ol">npm install next react react-dom<br/># or<br/>yarn add next react react-dom</span><span id="08c6" class="kw jz iq nj b gy ox oj l ok ol">yarn create next-app &lt;project-name&gt;<br/># or<br/>npx create-next-app &lt;project-name&gt;</span></pre><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oy"><img src="../Images/cdcd90e4032bd9b320c1eca2fcaf1d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PxqdreOelym_6ArA.png"/></div></div></figure><h2 id="ea28" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">nuxt . js(Vue的SSR)</strong></h2><p id="8f7d" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">Nuxt.js是基于Vue.js构建SSR的免费开源web应用框架</p><pre class="mn mo mp mq gt oe nj of og aw oh bi"><span id="767c" class="kw jz iq nj b gy oi oj l ok ol">npx create-nuxt-app &lt;project-name&gt;</span></pre><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oz"><img src="../Images/2d26368559f68cfadbebcfe84d4d87ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iGfPcKIolnF44ZGq.png"/></div></div></figure><h2 id="5a4d" class="kw jz iq bd ka kx ky dn ke kz la dp ki lb lc ld km le lf lg kq lh li lj ku lk bi translated"><strong class="ak">我对SSR的看法</strong></h2><p id="1841" class="pw-post-body-paragraph ll lm iq ln b lo lp lq lr ls lt lu lv lb lw lx ly le lz ma mb lh mc md me mf ij bi translated">很多公司会问你对诸如Next.js (React)或Nuxt.js (Vue)等SSR的体验。如果你有使用SSR的个人/专业经验，你是幸运的🙌你有值得夸耀的经历。但是如果你不这样做，我认为你仍然不需要太担心或者使用SSR建立一个新的应用程序。我认为SSR仍然是像D3.js这样的数据可视化前端开发人员的**可选* *技能</p><p id="3ffa" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">有SSR的经验是好的，但是如果你没有，就学习一下SSR以及它与客户端渲染的不同之处。只要表明你了解SSR，并且你有能力了解更多。</p></div><div class="ab cl mu mv hu mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ij ik il im in"><p id="a028" class="pw-post-body-paragraph ll lm iq ln b lo mg lq lr ls mh lu lv lb mi lx ly le mj ma mb lh mk md me mf ij bi translated">感谢您的阅读，希望它能帮助您准备即将到来的面试。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi pa"><img src="../Images/a7ef0c45b23ecc677d248ac30adeac41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PMFiDP17ii2MG2DR"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk">Photo by <a class="ae pb" href="https://unsplash.com/@jontyson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jon Tyson</a> on <a class="ae pb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div></div>    
</body>
</html>