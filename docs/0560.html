<html>
<head>
<title>React Inheritance: States and Props</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应继承:状态和道具</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-inheritance-states-and-props-658d7c433d8a?source=collection_archive---------0-----------------------#2019-11-08">https://javascript.plainenglish.io/react-inheritance-states-and-props-658d7c433d8a?source=collection_archive---------0-----------------------#2019-11-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f2c8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">分解把状态和类方法作为道具传下去的过程…</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/bc386178da031ebe2ac9f89dc97d5d99.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*gYD2K-gr_Syyqu05.png"/></div></div></figure><p id="1580" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi lk translated">eact是一个强大的JavaScript库，用于构建用户界面。它为开发人员提供了许多工具来帮助构建应用程序，并且像所有代码一样，它坚持“单一来源的真理”的实践</p><p id="24eb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">“真实的单一来源”意味着当编写代码时，它的结构使得对象模型(类结构)和它们相关联的数据模式将属于一起，而不是在任何其他位置(即，一个模型的类方法将与所有其他与该模型相关联的方法和属性一起编写在一个文件中)。它要干净得多，并且使代码更容易调试。</p><p id="db6a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们想在一个对象模型中编写一个方法，要求访问一个只存在于不同模型中的属性，那该怎么办？我们如何让这个模型访问另一个模型的属性呢？</p><p id="ded4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这就是<code class="fe lt lu lv lw b">states</code>和<code class="fe lt lu lv lw b">props</code>的用武之地。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/ca695b0a83c6a5352c2c4ec2d6ff856c.png" data-original-src="https://miro.medium.com/v2/resize:fit:486/format:webp/0*dFCOtl6Nxjc6yN1e.png"/></div></figure><p id="0ff4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您熟悉其他面向对象的编程语言(比如Ruby)，您就会知道在定义对象模型时，定义将在每个实例中分配给该模型的属性是非常重要的。</p><p id="39cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在Ruby中，类是用一组属性初始化的(例如，一个Person的模型类可以用名字、年龄、性别等属性初始化)。).</p><p id="2cb7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在JavaScript中，我们使用<em class="ly">构造函数</em>和关键字<em class="ly"> this </em>来调用这个属性赋值。关键字<em class="ly">这个</em>告诉开发商房产属于谁。</p><blockquote class="lz ma mb"><p id="c60f" class="ko kp ly kq b kr ks jo kt ku kv jr kw mc ky kz la md lc ld le me lg lh li lj ig bi translated">我可以写一个全新的博客来说明“这个”对于JavaScript的重要性，但这不是我这篇博客的重点…😅</p></blockquote><p id="b07b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在React中，您的应用程序文件(包括模型)被分成叫做<em class="ly">组件</em>的东西。它们非常像普通的JavaScript函数，但行为像对象模型。</p><p id="dac3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是React组件<em class="ly"> </em>的语法(确保将‘React’作为一个依赖项包含在您的<code class="fe lt lu lv lw b">package.json</code>文件中，并预先<code class="fe lt lu lv lw b">npm install</code>):</p><pre class="kd ke kf kg gt mf lw mg mh aw mi bi"><span id="9bb4" class="mj mk in lw b gy ml mm l mn mo">import React from 'react'</span><span id="823f" class="mj mk in lw b gy mp mm l mn mo">export default class Example extends React.Component{<br/>  render() {<br/>    return (<br/>      &lt;div&gt;This is an Example Component&lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="46c0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当然，组件不一定必须是类组件。</p><p id="f112" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它可以是一个功能组件:</p><pre class="kd ke kf kg gt mf lw mg mh aw mi bi"><span id="e220" class="mj mk in lw b gy ml mm l mn mo">import React from 'react'</span><span id="4481" class="mj mk in lw b gy mp mm l mn mo">const Example = (props) =&gt; {<br/>  return (<br/>    &lt;div&gt;This is an Example Functional Component&lt;/div&gt;<br/>  )<br/>}</span><span id="4f64" class="mj mk in lw b gy mp mm l mn mo">export default Example</span></pre><p id="97bb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请注意，在这两个文件中，我不得不<code class="fe lt lu lv lw b">import</code>‘反应’。这很重要，因为它告诉你的应用程序你的React库在哪里被使用。如果不先从React库导入，就不能编写React代码。</p><p id="983d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请记住，无论何时使用React，都要以<code class="fe lt lu lv lw b">import React from 'react'</code>开始文件。</p><p id="e5f4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在你可能想知道:我在哪里给这个组件分配属性？</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mq"><img src="../Images/c3bfa767e3772e55a71ebcc831d14fd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UOyk1bUdlM4BZctG.png"/></div></div></figure><p id="f15d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">很棒的问题！</p><p id="1a34" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们看看这个组件在另一个组件中被调用时的样子:</p><pre class="kd ke kf kg gt mf lw mg mh aw mi bi"><span id="ec2d" class="mj mk in lw b gy ml mm l mn mo">import React from 'react'<br/>import Example from './Example'</span><span id="dea1" class="mj mk in lw b gy mp mm l mn mo">export default class ExampleContainer extends React.Component{</span><span id="1280" class="mj mk in lw b gy mp mm l mn mo">  state={<br/>    firstProperty: 'I am number One!'<br/>    secondProperty: 'Second is the best!'<br/>  }</span><span id="b0c0" class="mj mk in lw b gy mp mm l mn mo">  componentMethod = () =&gt; {<br/>    this.setState({<br/>      secondProperty: 'Sucks to be second...'<br/>    })<br/>  }</span><span id="d1ac" class="mj mk in lw b gy mp mm l mn mo">  render () {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;Example firstProperty={this.state.firstProperty} <br/>                 secondProperty={this.state.secondProperty}<br/>                 classMethod={this.componentMethod} <br/>      /&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="9568" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">重要的是，在编写每个组件时，也要将它导出。这样,<em class="ly">从它那里导入</em>的每个其他组件都可以使用这个组件。</p><p id="058a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您正在使用一个类组件，您还必须包含一个render函数，该函数被调用并返回您希望在DOM上显示的内容(一个函数组件在没有呈现的情况下返回相同的内容)。</p><p id="9dd6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我刚才做了什么？</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mr"><img src="../Images/4a26e30c7919ba88636ca3832592a6cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WPVjn9WA03voRM25.jpg"/></div></div></figure><p id="fa17" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，让我们回顾一下<code class="fe lt lu lv lw b">props</code>和<code class="fe lt lu lv lw b">states</code>是什么。</p><p id="9009" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lt lu lv lw b">Props</code>是继承自另一个成分。在上面的示例组件中，我传入了三个<code class="fe lt lu lv lw b">props</code> : <em class="ly"> firstProperty </em>、<em class="ly"> secondProperty </em>和<em class="ly"> classMethod </em>。</p><p id="2e79" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这基本上与<em class="ly">在Ruby中初始化</em>具有某些属性的模型实例，并使用<em class="ly">构造函数</em>在普通JavaScript中定义对象模型的属性是一样的。</p><p id="5e3b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lt lu lv lw b">Props</code>无法改变。虽然可以在Ruby对象的实例中重新分配属性，但是不能直接修改组件的属性。</p><p id="eb39" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">遵循同样的约定，将父组件的一个属性指定为子组件的一个<code class="fe lt lu lv lw b">prop</code>。</p><p id="e2cf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在什么是<code class="fe lt lu lv lw b">state</code>？</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/35f2b46c52ac15a4af54bb5da1ca6874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jsamXY1CGCDO5BBw"/></div></figure><p id="4834" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lt lu lv lw b">States</code>是我们计划操作的组件的属性。它们将被赋予一个初始值，但是可以通过我们写入组件的方法进行修改。</p><p id="a7e7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因为<code class="fe lt lu lv lw b">state</code>是一个对象，所以我使用<em class="ly"> this.state </em>和属性的键来调用这个属性。请注意，我将我的<code class="fe lt lu lv lw b">prop</code>赋值的值用花括号括起来。这是因为我使用的是JavaScript代码，在React中使用JavaScript代码时，必须用花括号括起来。</p><p id="6b2b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当你想修改<code class="fe lt lu lv lw b">state</code>时，你必须使用一个调用方法<em class="ly"> this.setState </em>的函数，因为React不喜欢你直接修改状态。</p><p id="2b21" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我的ExampleContainer组件中，我有一个修改<code class="fe lt lu lv lw b">state</code>的方法。我将这个方法作为道具传递给示例组件。这允许子组件从自身内部调用该方法。要调用这个方法，通常要将它分配给一个事件处理程序(onClick、onSubmit等)。</p><p id="86e0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">调用方法的类组件的示例:</p><pre class="kd ke kf kg gt mf lw mg mh aw mi bi"><span id="e5c6" class="mj mk in lw b gy ml mm l mn mo">import React from 'react'</span><span id="a896" class="mj mk in lw b gy mp mm l mn mo">export default class Example extends React.Component{<br/>  render() {<br/>    return (<br/>      &lt;div onClick={this.props.classMethod}&gt;This is an Example Component&lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="55dd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">调用方法的功能组件的示例:</p><pre class="kd ke kf kg gt mf lw mg mh aw mi bi"><span id="072d" class="mj mk in lw b gy ml mm l mn mo">import React from 'react'</span><span id="1f51" class="mj mk in lw b gy mp mm l mn mo">const Example = (props) =&gt; {<br/>  return (<br/>    &lt;div onClick={props.classMethod}&gt;This is an Example Functional Component&lt;/div&gt;<br/>  )<br/>}</span><span id="1ac7" class="mj mk in lw b gy mp mm l mn mo">export default Example</span></pre><p id="9346" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了让一个功能组件访问它的<code class="fe lt lu lv lw b">props</code>,你必须把它作为一个参数传递给它。类组件没有要传递给它的参数。你可以用<em class="ly"> this.props </em>调用它的道具。</p><p id="c6ec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">功能组件没有<em class="ly">这个。</em></p><p id="3933" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于一个类组件，当你引用它的时候，你可以在<code class="fe lt lu lv lw b">props</code>前加上<em class="ly"> this </em>。</p><p id="41e1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">记住，您传递的是方法定义，而不是方法调用！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/5cf57ed6b77fdf866da798e3d3887dcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1182/format:webp/0*UnfU2Ns2ipD82tOi.png"/></div></figure><p id="4623" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">此外，由于<code class="fe lt lu lv lw b">props</code>基本上是属性赋值，只要引用正确的父属性，就可以给它取任何名称。</p><p id="707b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这意味着，如果您有一个只有一个事件处理程序(即onClick)的子组件，您可以根据子组件被调用的位置为该事件处理程序提供多个方法。</p><p id="e35d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，如果我有另一个容器也调用示例组件:</p><pre class="kd ke kf kg gt mf lw mg mh aw mi bi"><span id="17ec" class="mj mk in lw b gy ml mm l mn mo">import React from 'react'</span><span id="9ee2" class="mj mk in lw b gy mp mm l mn mo">export default class NewContainer extends React.Component{</span><span id="278a" class="mj mk in lw b gy mp mm l mn mo">  state={<br/>    differentProperty: 'I am not like the first!'<br/>    anotherProperty: 'Do not underestimate me!'<br/>  }</span><span id="166a" class="mj mk in lw b gy mp mm l mn mo">  anotherClassMethod = () =&gt; {<br/>    this.setState({<br/>      anotherProperty: 'I give up...'<br/>    })<br/>  }</span><span id="67ee" class="mj mk in lw b gy mp mm l mn mo">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;Example differentProperty={this.state.differentProperty}<br/>                 anotherProperty={this.state.anotherProperty}<br/>                 classMethod={this.anotherClassMethod}<br/>        /&gt;<br/>      &lt;/div&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="4f02" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这里，我将一组全新的属性传递到一个示例组件中，该示例组件在另一个父组件中被调用。</p><p id="c74b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意，我仍然使用<em class="ly"> classMethod </em>作为专有名称。这是因为我编写了一个事件处理程序，在Example的类组件中调用这个prop方法。</p><p id="3942" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是由于分配给正确名称的属性是不同的，所以我实际上调用了一个不同的方法，而不是示例组件在ExampleContainer组件中时所调用的方法。</p><p id="d208" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我基本上是为示例组件中引用的<code class="fe lt lu lv lw b">prop</code>重新分配一个新属性。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/3907bb922dc1259924f5af5fc3b47110.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*fhdisvCCG-ZpIVBd.jpg"/></div></figure><p id="45dd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这基本上总结了如何将属性传递给组件以及修改状态。如果您希望在层次结构中更低的位置调用父组件中编写的方法，也可以将props链接到孙组件。</p><blockquote class="lz ma mb"><p id="5a2c" class="ko kp ly kq b kr ks jo kt ku kv jr kw mc ky kz la md lc ld le me lg lh li lj ig bi translated">请注意，我改变了在组件内部编写函数的方式。有时我使用箭头函数，有时我使用函数声明。我这样做是因为箭头函数为我提供了“这个”的隐式绑定。</p><p id="1e96" class="ko kp ly kq b kr ks jo kt ku kv jr kw mc ky kz la md lc ld le me lg lh li lj ig bi translated">因为这个博客关注的是如何传递道具和状态，所以我不会讨论“这个”对于保持真理的单一来源的重要性。</p><p id="c672" class="ko kp ly kq b kr ks jo kt ku kv jr kw mc ky kz la md lc ld le me lg lh li lj ig bi translated">但是请记住“这个”在反应中非常重要。作为一个好习惯，为了安全起见，我尽量使用箭头函数来编写我的所有方法，因为我不希望“this”改变。</p><p id="5d17" class="ko kp ly kq b kr ks jo kt ku kv jr kw mc ky kz la md lc ld le me lg lh li lj ig bi translated">如果你不明白“这个”的重要性，你应该谷歌一下为什么会这样。😊</p></blockquote></div></div>    
</body>
</html>