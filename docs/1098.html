<html>
<head>
<title>Node.js &amp; Redis. High performance caching</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js &amp; Redis。高性能缓存</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/getting-started-with-redis-and-how-to-use-it-in-node-js-8d4f1a3f7369?source=collection_archive---------3-----------------------#2020-01-29">https://javascript.plainenglish.io/getting-started-with-redis-and-how-to-use-it-in-node-js-8d4f1a3f7369?source=collection_archive---------3-----------------------#2020-01-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/aeec9a9cbedea598835e4878770ceba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ZEonl9174VQzf2842OXpg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Performance &amp; simplicity in two technologies. It’s a match!</figcaption></figure><p id="dfde" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我不想在这里长篇大论。<br/>让我们从解释&amp;在你的机器上安装Redis开始，包括Redis CLI的基础知识&amp;然后在Node.js中使用它。现在我们将只处理Redis中的简单数据类型。因为这是我们最需要的。<br/>这里有一个好消息:无论您使用Redis with Node还是任何其他编程语言，一旦我向您介绍了Redis中最重要的命令，它在任何地方都会非常相似。</p><h1 id="4c72" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated"><strong class="ak">Redis是什么，为什么它这么酷？</strong></h1><p id="1b06" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">Redis是一个内存数据库，使用键值。所以每个值都有一个键。因此，Redis不是一个SQL数据库，它是为原始数据结构设计的，我们将在本文中使用它。由于Redis读写数据的速度和简单的键值系统，Redis可以很好地用于缓存。<br/>然而，用户信息或图像等永久数据不应存储在Redis中，因为其易变。你已经饿了吗？我们走吧！</p><div class="md me gp gr mf mg"><a href="https://medium.com/better-programming/how-to-build-a-node-js-api-cache-with-redis-ac0aa54dee48" rel="noopener follow" target="_blank"><div class="mh ab fo"><div class="mi ab mj cl cj mk"><h2 class="bd ir gy z fp ml fr fs mm fu fw ip bi translated">如何用Redis构建Node.js API缓存</h2><div class="mn l"><h3 class="bd b gy z fp ml fr fs mm fu fw dk translated">API调用是必不可少的，但也很昂贵。对于Redis和Node，我们可以通过构建API缓存来优化它们</h3></div><div class="mo l"><p class="bd b dl z fp ml fr fs mm fu fw dk translated">medium.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu jw mg"/></div></div></a></div><h1 id="789d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">在你的机器上安装Redis</h1><p id="f897" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated"><strong class="ke ir">Linux:</strong><br/><a class="ae mv" href="https://redis.io/topics/quickstart" rel="noopener ugc nofollow" target="_blank">https://redis.io/topics/quickstart</a><br/>sudo服务redis启动<em class="mw">或</em> sudo服务redis-服务器启动</p><p id="f995" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> MacOS: </strong> <em class="mw"> <br/> </em>安装brew，如果你还没有安装的话:<a class="ae mv" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank">https://brew.sh/</a><br/>brew安装redis <br/> brew服务启动redis</p><p id="2a8c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> Windows: </strong> <em class="mw"> </em>使用Windows的Linux子系统。然后就像在linux上一样安装它。</p><h2 id="ad46" class="mx lb iq bd lc my mz dn lg na nb dp lk kn nc nd lo kr ne nf ls kv ng nh lw ni bi translated">检查Redis是否正常工作:</h2><p id="81f7" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">一旦您已经启动了Redis服务，您应该能够通过redis-cli与它通信。试着做<em class="mw">redis-clip<br/></em>和Redis应anser用<em class="mw"/>“PONG”。这意味着，Redis正在工作。</p><h1 id="53ed" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Redis CLI</h1><p id="f928" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">当您的Redis正在运行时，您总是可以使用redis-cli直接连接到它。在CLI中，您可以运行所有的Redis命令，所以让我们来看一些命令。</p><h2 id="1416" class="mx lb iq bd lc my mz dn lg na nb dp lk kn nc nd lo kr ne nf ls kv ng nh lw ni bi translated">使用简单的字符串</h2><p id="b81f" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">注意:在CLI中，SET和其他命令是否大写无关紧要。<br/>简单数据的原理很简单。我们说SET，然后给出键，即变量名，后面加一个空格，简单地给出值。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="45c5" class="mx lb iq no b gy ns nt l nu nv">SET name Max</span></pre><p id="efe0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们可以打印出名为“name”的键的值。我们应该收到“最大值”</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="009d" class="mx lb iq no b gy ns nt l nu nv">GET name     </span></pre><p id="5eba" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我们玩够了我们的名字，我们当然可以再次删除它。之后，当我们再次尝试访问已经删除的值时，a <em class="mw"> (nil) </em>应该会期待我们。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="940a" class="mx lb iq no b gy ns nt l nu nv">DEL name <br/>GET name    // (nil) will be printed.</span></pre><p id="f157" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但也许我们想以后再存一个名字。要做到这一点，让我们首先再次创建一个单独的名称，并有意地将这个键命名为“names”</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="9336" class="mx lb iq no b gy ns nt l nu nv">SET names Max</span></pre><p id="b4c0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们可以扩展这个字符串，在这种情况下，我将使用引号，这样Redis也将包含空格&amp;特殊字符。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="4b41" class="mx lb iq no b gy ns nt l nu nv">APPEND names “ &amp; Matt”</span></pre><p id="1240" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">像以前一样，我们现在应该能够再次输出完整的字符串。我们应该买《麦克斯和马特》。</p><h1 id="19e0" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">但是我们现在如何优雅地实现一个缓存呢？</h1><p id="9e38" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我认为这是个好问题。很明显，当我说Redis非常适合这个项目时，你一开始很小心。缓存的作用是临时存储数据。现在我们知道如何擦除数据，但对于整个缓存来说，这有点麻烦。<br/>因此，Redis提供了在我们定义的时间后自动终止数据的可能性。</p><p id="74ca" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">我们有两种方法可以做到:</strong> <br/> 1)要么我们在创建密钥时直接指定，它应该在多少秒后过期。<br/> 2)或者我们事后确定这一点。同样，我们传递的数字是密钥过期前的秒数。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="c116" class="mx lb iq no b gy ns nt l nu nv">// 1) The name-key will expire after 60 seconds<br/>SET name Max EX 60</span><span id="89a5" class="mx lb iq no b gy nw nt l nu nv">// 2) First we define the name<br/>SET name Max<br/>// Then we define when to expire<br/>EXPIRE name 60</span></pre><p id="3a69" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因此，如果已经确定某个密钥应该在某个点过期，我们也可以在任何时候读出当前剩余寿命。只是为了再次说明:只有剩余的<strong class="ke ir">时间</strong>被输出，当然它每秒都在变化。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="83ec" class="mx lb iq no b gy ns nt l nu nv">SET name Max EX 60</span><span id="1895" class="mx lb iq no b gy nw nt l nu nv">// get the remaining time<br/>TTL name</span><span id="32f2" class="mx lb iq no b gy nw nt l nu nv">// will be 60, 59, 58 etc...</span></pre><h1 id="b39d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">但是我们仍然需要一个工作缓存…</h1><p id="6ad6" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我们现在可以手动和自动删除密钥。但是如果我们只是想检查我们的钥匙是否还在那里呢？<br/>为此，Redis中有<strong class="ke ir"> exists </strong>功能。如果键存在，则返回1，如果不存在，则返回0。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="8ea7" class="mx lb iq no b gy ns nt l nu nv">SET name Max<br/>EXISTS name <br/>// will return: (integer) 1</span><span id="6954" class="mx lb iq no b gy nw nt l nu nv">DEL name<br/>EXISTS name<br/>// will return: (integer) 0</span></pre><p id="02e5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在您已经熟悉了CLI和Redis中最重要的命令。现在让我们用Node.js将它付诸实践！</p><h1 id="560b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Node.js中的Redis入门</h1><p id="1456" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">首先，我们需要在Node.js项目中安装Redis:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="9dfe" class="mx lb iq no b gy ns nt l nu nv">npm install redis</span></pre><p id="9a1b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后我们可以在代码中导入它，并连接到我们机器上的Redis实例。createClient的参数将是我们机器上实例的地址(这就是为什么我们使用localhost ),端口6379是Redis的默认端口。</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="a68d" class="mx lb iq no b gy ns nt l nu nv">const redis = require(‘redis’)<br/>const client = redis.createClient(‘redis://localhost:6379’)</span></pre><p id="aa45" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">目前为止就这些。现在我们可以在Node中使用它，命令和以前一样。<br/>所以你应该记住这个命令:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="8c8e" class="mx lb iq no b gy ns nt l nu nv">SET name Max</span></pre><p id="7bc6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是一样的，只是对于Node.js:</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="c243" class="mx lb iq no b gy ns nt l nu nv">client.set(‘hi’, ‘there’)</span></pre><p id="d3ef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如你所见，几乎一样。只有语法有一点改变，通过客户端对象，我们总是在点之后访问相应的命令。当然，在JavaScript中我们必须在引号中传递字符串，在CLI中这不是必须的。</p><p id="1196" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这是我们已经学过的所有命令。与Node.js进行比较</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="5180" class="mx lb iq no b gy ns nt l nu nv">GET name<br/></span><span id="45f3" class="mx lb iq no b gy nw nt l nu nv">client.get('name', (error, value) =&gt; {<br/> console.log(value)<br/>})</span><span id="4f45" class="mx lb iq no b gy nw nt l nu nv">// or to print it out directly: (Will not just print out the value)<br/>client.get('name', console.log)</span></pre><p id="8be0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如你所看到的，我们总是对所有的命令使用另一个函数来获取某些东西。第一个参数给出了可能的错误消息，第二个是实际结果。<br/>是的，对于第二个例子中显示的直接输出，我们可以将console.log直接写入函数中。重要提示:输出应该是“null Max”，但是这里的“null”只表示没有发生错误。在第一个例子中,“value”仅用于直接输出键的<strong class="ke ir">值</strong>。</p><p id="9bdd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下一个例子，<strong class="ke ir">删除:</strong></p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="6580" class="mx lb iq no b gy ns nt l nu nv">DEL name</span><span id="f5c3" class="mx lb iq no b gy nw nt l nu nv">client.del(‘name’)</span></pre><p id="c014" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">追加:</strong></p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="707d" class="mx lb iq no b gy ns nt l nu nv">APPEND name ‘ &amp; Tom’</span><span id="152a" class="mx lb iq no b gy nw nt l nu nv">client.append(‘name’, ‘ &amp; Tom’)</span></pre><p id="13e2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">直接确定密钥何时到期:</strong></p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="2352" class="mx lb iq no b gy ns nt l nu nv">SET name Max EX 60</span><span id="ef42" class="mx lb iq no b gy nw nt l nu nv">client.set('name', 'Max', 'EX', 60)</span></pre><p id="0dc2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">以及之后我们如何做:</strong></p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="1336" class="mx lb iq no b gy ns nt l nu nv">EXPIRE name 60</span><span id="7568" class="mx lb iq no b gy nw nt l nu nv">client.expire('name', 60)</span></pre><p id="7924" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">到期前的剩余时间:</strong></p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="57c6" class="mx lb iq no b gy ns nt l nu nv">TTL name</span><span id="a460" class="mx lb iq no b gy nw nt l nu nv">client.ttl(‘name’, (error, value) =&gt; {<br/> console.log(value)<br/>})</span></pre><p id="748e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">检查键是否存在:</strong> (JavaScript将0视为假，1当然视为真)</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="8358" class="mx lb iq no b gy ns nt l nu nv">EXISTS name</span><span id="7d71" class="mx lb iq no b gy nw nt l nu nv">client.exists('name', (error, value) =&gt; {<br/> if (value) {<br/>  console.log('Key does exist')<br/> } else {<br/>  console.log('Key does not exist')<br/> }<br/>})</span></pre><p id="aeab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我想现在原理应该清楚了。Node.js的语法对于命令类型来说是绝对固定的，所以您现在能够自己扩展Redis的知识，不仅在CLI中，而且在Node.js中实现新学到的命令。这并不困难:)</p><p id="cfcc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">但是这里有一个额外的东西给你——因为我们都喜欢使用JSON对象。下面是如何在Redis中保存一个JS对象。然后如何打印出来</p><pre class="nj nk nl nm gt nn no np nq aw nr bi"><span id="6058" class="mx lb iq no b gy ns nt l nu nv">client.set(‘name’, <br/>  JSON.stringify({ firstname: ‘max’, lastname: ‘meyer’})<br/>)</span><span id="61cc" class="mx lb iq no b gy nw nt l nu nv"><br/>client.get(‘name’, (err, val) =&gt; {<br/> console.log(JSON.parse(val))<br/>})</span></pre><p id="8272" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">谢谢你阅读它。如果你有补充，写在评论里。我计划一直添加到这篇文章中，所以请经常回来查看。<br/>在你最终能和Redis独处之前，还有最后一件事:给我一个掌声，这不需要花费任何东西:)</p><h2 id="d654" class="mx lb iq bd lc my mz dn lg na nb dp lk kn nc nd lo kr ne nf ls kv ng nh lw ni bi translated"><strong class="ak">关于我，作者:)</strong></h2><p id="f819" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">嗨！再次感谢您的阅读，我叫路易斯，是一名来自德国的18岁学生。我热爱Web开发，包括后端和前端。我最喜欢的技术是React，Vue，React Native和Node.js. <br/>请务必关注我，了解更多与这些相关的内容，并随时查看我的IG @ Louis . jsx&amp;@ codingcultureshop<br/>祝您愉快！</p></div></div>    
</body>
</html>