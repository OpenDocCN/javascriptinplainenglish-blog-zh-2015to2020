<html>
<head>
<title>JavaScript Refactoring —More Class Refactoring</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript重构——更多的类重构</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-refactoring-more-class-refactoring-bd269c22220f?source=collection_archive---------10-----------------------#2020-05-23">https://javascript.plainenglish.io/javascript-refactoring-more-class-refactoring-bd269c22220f?source=collection_archive---------10-----------------------#2020-05-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8ecbbcc44d5933e96235d6bda4b9ad02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jo68bc4FL8mO5NMg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kimberlyfarmer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kimberly Farmer</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8d4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以清理我们的JavaScript代码，这样我们可以更容易地使用它们。</p><p id="8fa5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些与清理JavaScript条件相关的重构思想。</p><h1 id="6acd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用委派替换继承</h1><p id="fa79" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有不需要从超类继承任何东西的子类，那么这个子类不一定是超类的子类。</p><p id="3fc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有一个子类，除了从它调用一些方法之外，不需要从超类中得到任何东西:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e97e" class="mn lc iq mj b gy mo mp l mq mr">class Animal {<br/>  //...<br/>  speak() {<br/>    //...<br/>  }<br/>}</span><span id="2c89" class="mn lc iq mj b gy ms mp l mq mr">class Cat extends Animal {<br/>  //...<br/>  talk() {<br/>    super.speak()<br/>  }<br/>}</span></pre><p id="33a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以删除<code class="fe mt mu mv mj b">extends</code>并调用<code class="fe mt mu mv mj b">Animal</code>类，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="554f" class="mn lc iq mj b gy mo mp l mq mr">class Animal {<br/>  //...<br/>  speak() {<br/>    //...<br/>  }<br/>}</span><span id="9aec" class="mn lc iq mj b gy ms mp l mq mr">class Cat {<br/>  constructor() {<br/>    this.animal = new Animal();<br/>  }</span><span id="6447" class="mn lc iq mj b gy ms mp l mq mr">  talk() {<br/>    this.animal.speak()<br/>  }<br/>}</span></pre><h1 id="b701" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">减少继承层次</h1><p id="fce0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以减少继承层次，只保留必要的部分。</p><p id="3489" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不想要一个复杂的难以导航的继承树。</p><p id="778c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f31f" class="mn lc iq mj b gy mo mp l mq mr">class Animal {<br/>  //...<br/>}</span><span id="cbb1" class="mn lc iq mj b gy ms mp l mq mr">class Cat extends Animal {</span><span id="0491" class="mn lc iq mj b gy ms mp l mq mr">}</span><span id="edb8" class="mn lc iq mj b gy ms mp l mq mr">class Dog extends Animal {</span><span id="fe25" class="mn lc iq mj b gy ms mp l mq mr">}</span><span id="c38f" class="mn lc iq mj b gy ms mp l mq mr">class BlackCat extends Cat {</span><span id="1a0a" class="mn lc iq mj b gy ms mp l mq mr">}</span><span id="8037" class="mn lc iq mj b gy ms mp l mq mr">class Labrador extends Dog {</span><span id="f242" class="mn lc iq mj b gy ms mp l mq mr">}</span></pre><p id="c0e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可能需要重新考虑是否要为每种类型的猫和狗创建子类。</p><p id="6c9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过删除这些类来减小树的大小。例如，我们可以通过编写以下代码来删除上面代码中的最后两个类:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1408" class="mn lc iq mj b gy mo mp l mq mr">class Animal {<br/>  //...<br/>}</span><span id="ddc1" class="mn lc iq mj b gy ms mp l mq mr">class Cat extends Animal {</span><span id="84b6" class="mn lc iq mj b gy ms mp l mq mr">}</span><span id="fc00" class="mn lc iq mj b gy ms mp l mq mr">class Dog extends Animal {</span><span id="58d2" class="mn lc iq mj b gy ms mp l mq mr">}</span></pre><p id="6e9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么继承树就简单多了。</p><h1 id="a0b4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将程序设计转化为功能</h1><p id="c6d9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有很多过程在做类似的事情，我们可以把这些过程转换成函数，这样我们就可以在很多地方使用它们。</p><p id="b309" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e07c" class="mn lc iq mj b gy mo mp l mq mr">const subtotal = 100<br/>const provincialSalesTax = subtotal * 0.05;<br/>const federalSalesTax = subtotal * 0.1;<br/>const total = subtotal + provincialSalesTax + federalSalesTax;</span></pre><p id="2f30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将计税代码移入自己的函数中，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1cd4" class="mn lc iq mj b gy mo mp l mq mr">const calculateTax = (amount, taxRate) =&gt; amount * taxRate;<br/>const subtotal = 100<br/>const provincialSalesTax = calculateTax(subtotal, 0.05);<br/>const federalSalesTax = calculateTax(subtotal, 0.1);<br/>const total = subtotal + provincialSalesTax + federalSalesTax;</span></pre><p id="8cd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们必须再次计算税额，我们可以使用<code class="fe mt mu mv mj b">calculateTax</code>函数，而不是每次都编写代码来计算这些金额。</p><h1 id="ab65" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">提取层次结构</h1><p id="6594" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们的类因为方法中的大量条件语句而做了太多的事情，我们可以将这些代码提取到子类中。</p><p id="5a8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不要写以下内容:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="41f8" class="mn lc iq mj b gy mo mp l mq mr">class Invoice {<br/>  getInvoice(type) {<br/>    if (type === 'residental') {<br/>      //...<br/>    } else if (type === 'commercial') {<br/>      //...<br/>    } else if (type === 'concession') {<br/>      //...<br/>    }<br/>  }<br/>}</span></pre><p id="5891" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将<code class="fe mt mu mv mj b">getInvoice</code>逻辑分解成它们自己的子类，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e59a" class="mn lc iq mj b gy mo mp l mq mr">class Invoice {</span><span id="a269" class="mn lc iq mj b gy ms mp l mq mr">}</span><span id="6a6d" class="mn lc iq mj b gy ms mp l mq mr">class ResidentialInvoice extends Invoice {<br/>  getInvoice() {<br/>    // residential logic<br/>  }<br/>}</span><span id="3510" class="mn lc iq mj b gy ms mp l mq mr">class CommercialInvoice extends Invoice {<br/>  getInvoice() {<br/>    // commercial logic<br/>  }<br/>}</span><span id="cc1f" class="mn lc iq mj b gy ms mp l mq mr">class ConcessionInvoice extends Invoice {<br/>  getInvoice() {<br/>    // concession logic<br/>  }<br/>}</span></pre><p id="6c76" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设<code class="fe mt mu mv mj b">getInvoice</code>方法体在每个子类中是不同的，那么<code class="fe mt mu mv mj b">getInvoice</code>方法可以留在那里，因为它们除了名字之外都是不同的。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/73f804365b2d1de708753c0d89d71174.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jci3yBPUq-2XyW1T"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">NeONBRAND</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="bad2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7d94" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通过将复杂的逻辑分解成子类，我们可以使代码更加清晰。</p><p id="97e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果一个类不需要继承它，也可能不需要继承。</p><p id="a80a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">减少继承层次也是一个好主意，因为复杂性是不好的。</p><p id="052c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在不同的地方有相似的逻辑，我们应该为它们提取一个函数。</p><h2 id="5712" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">简明英语笔记</strong></h2><p id="1019" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> plainenglish.io </strong> </a>找到所有这些内容——关注我们的出版物并<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>