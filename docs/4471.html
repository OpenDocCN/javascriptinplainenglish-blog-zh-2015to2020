<html>
<head>
<title>A Minimal Node.js, Express, &amp; Babel Setup: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个最小的Node.js、Express和Babel设置:第1部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-minimal-node-js-express-babel-setup-part-1-6be7b3f3bb55?source=collection_archive---------6-----------------------#2020-12-14">https://javascript.plainenglish.io/a-minimal-node-js-express-babel-setup-part-1-6be7b3f3bb55?source=collection_archive---------6-----------------------#2020-12-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/5ed624b64b393bd1992f9c7189343b28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cWD7Wnj5I1h_Qq5I32ZIPw.png"/></div></div></figure><p id="cfe0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们设置一个使用Babel的基本Node.js / Express.js API。出于兼容性目的，Babel将把我们的ES2015+代码和模块语法“移植”到旧风格的代码中。我将使用一个基本的Express API作为例子，通过Babel添加绝对导入，并简要讨论我们在2020年是否需要Babel来设置我们的节点。</p><p id="e851" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://neightjones.medium.com/a-minimal-node-js-setup-part-2-eslint-prettier-vs-code-7963768dbb30" rel="noopener">在这个最小设置的第2部分</a>，我将添加eslint和prettier的设置，并向您展示如何让它们很好地一起玩。然后我们将更新VS代码中的一些设置来完成这个过程。</p><p id="5520" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最终存储库可在此处找到:</p><div class="ku kv gp gr kw kx"><a href="https://github.com/neightjones/node-babel-template" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd io gy z fp lc fr fs ld fu fw im bi translated">邻居/节点巴别塔模板</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">该模板使用babel创建了一个基本的Node.js / Express.js API。它还为eslint和…设置了很好的默认值</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">github.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll jt kx"/></div></div></a></div><h1 id="092f" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">1.节点版本和快速框架</h1><p id="773c" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">首先，让我们关心一下我们的节点版本。我喜欢使用nvm来管理不同项目中的节点版本。<a class="ae kt" href="https://github.com/nvm-sh/nvm#installing-and-updating" rel="noopener ugc nofollow" target="_blank">请遵循他们提供的安装说明</a>。</p><p id="2a57" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将在<a class="ae kt" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank">nodejs.org</a>使用“当前”版本，也就是在撰写本文时的<code class="fe mp mq mr ms b">15.4.0</code>。运行这两个命令:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="2ba5" class="nb ln in ms b gy nc nd l ne nf">nvm install 15.4.0<br/>nvm alias default 15.4.0</span></pre><p id="b83c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将把节点版本<code class="fe mp mq mr ms b">15.4.0</code>安装到我们机器上的nvm版本列表中(运行<code class="fe mp mq mr ms b">nvm ls</code>查看你有哪些版本)。我们将很快再介绍一个nvm配置，但是让我们继续看代码。</p><p id="7751" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了让我们的代码开始运行，我们将使用<a class="ae kt" href="https://expressjs.com/en/starter/generator.html" rel="noopener ugc nofollow" target="_blank">Express application generator</a>创建一个新项目(在我的新repo <code class="fe mp mq mr ms b">node-babel-template</code>中运行):</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="8aff" class="nb ln in ms b gy nc nd l ne nf">npx express-generator .</span></pre><p id="d50b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个工具为我们生成了一个超级简单的Express API(<code class="fe mp mq mr ms b">bin/www</code>是入口文件，<code class="fe mp mq mr ms b">app.js</code>设置Express应用程序，<code class="fe mp mq mr ms b">routes</code>目录中有几个简单的路线处理程序)。</p><p id="8801" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们如何指定我们的项目要使用哪个节点版本呢？</p><ol class=""><li id="e62c" class="ng nh in jx b jy jz kc kd kg ni kk nj ko nk ks nl nm nn no bi translated">在项目的根目录下创建一个名为<code class="fe mp mq mr ms b">.nvmrc</code>的文件，并将<code class="fe mp mq mr ms b">15.4.0</code>放入该文件中。在终端的项目根目录中，键入<code class="fe mp mq mr ms b">nvm use</code> —该命令告诉nvm查找<code class="fe mp mq mr ms b">.nvmrc</code>文件并使用指定的版本</li><li id="8fdc" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated">在您的<code class="fe mp mq mr ms b">package.json</code>中，添加一个名为<code class="fe mp mq mr ms b">engines</code>的部分，如下所示:</li></ol><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="ce5f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mp mq mr ms b">package.json</code>的这一部分指定了构建工具和代码在指定版本上工作的其他工具。您还可以指定一些更通用的东西，比如“至少节点15”，但这目前有效。</p></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="5d83" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们开始进行更改之前，让我们确保事情按预期进行。运行初始的<code class="fe mp mq mr ms b">npm install</code>来安装包，然后运行Express generator放在我们的<code class="fe mp mq mr ms b">package.json</code>中的已经定义好的<code class="fe mp mq mr ms b">npm start</code>脚本。服务器应该在监听(默认情况下在端口3000上)，生成器为我们创建了一条“回家”路线<code class="fe mp mq mr ms b"><a class="ae kt" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></code>——在浏览器中访问它，您应该会看到快速欢迎消息。</p><p id="ca21" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们做几个快速的更改来简化接下来的步骤——在我们的项目的根目录下创建一个<code class="fe mp mq mr ms b">src</code>目录，并将这些内容移动到其中:<code class="fe mp mq mr ms b">bin</code>、<code class="fe mp mq mr ms b">public</code>、<code class="fe mp mq mr ms b">routes</code>、<code class="fe mp mq mr ms b">views</code>和<code class="fe mp mq mr ms b">app.js</code> …这将破坏当前的<code class="fe mp mq mr ms b">npm start</code>脚本，但我们还是要替换它。其次，将文件<code class="fe mp mq mr ms b">www</code>(在<code class="fe mp mq mr ms b">src/bin</code>中)改为<code class="fe mp mq mr ms b"><a class="ae kt" href="http://www.js." rel="noopener ugc nofollow" target="_blank">www.js</a></code>。</p><p id="70da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在让我们开始把这变成一个巴别塔项目。</p></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><h1 id="a654" class="lm ln in bd lo lp od lr ls lt oe lv lw lx of lz ma mb og md me mf oh mh mi mj bi translated">2.基本巴别塔设置</h1><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="8053" class="nb ln in ms b gy nc nd l ne nf">npm install --save-dev <a class="ae kt" href="http://twitter.com/babel/core" rel="noopener ugc nofollow" target="_blank">@babel/core</a> <a class="ae kt" href="http://twitter.com/babel/cli" rel="noopener ugc nofollow" target="_blank">@babel/cli</a> <a class="ae kt" href="http://twitter.com/babel/preset-env" rel="noopener ugc nofollow" target="_blank">@babel/preset-env</a> <a class="ae kt" href="http://twitter.com/babel/node" rel="noopener ugc nofollow" target="_blank">@babel/node</a></span></pre><ul class=""><li id="1e36" class="ng nh in jx b jy jz kc kd kg ni kk nj ko nk ks oi nm nn no bi translated"><code class="fe mp mq mr ms b">@babel/core</code>给了我们B <a class="ae kt" href="https://babeljs.io/docs/en/usage#core-library" rel="noopener ugc nofollow" target="_blank"> abel核心编译器</a></li><li id="f632" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks oi nm nn no bi translated"><code class="fe mp mq mr ms b">@babel/cli</code>给了我们<a class="ae kt" href="https://babeljs.io/docs/en/usage#cli-tool" rel="noopener ugc nofollow" target="_blank">命令行工具</a></li><li id="ec71" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks oi nm nn no bi translated"><code class="fe mp mq mr ms b">@babel/preset-env</code>是<a class="ae kt" href="https://babeljs.io/docs/en/presets#official-presets" rel="noopener ugc nofollow" target="_blank">官方预置</a>之一，可通过巴别塔获得。什么是预设？Babel通过一系列插件工作，每个插件都定义了Babel应用于代码的转换。你可以在没有任何插件的情况下运行Babel，在这种情况下，它会吐出和你开始时完全一样的代码。假设你找到了<a class="ae kt" href="https://babeljs.io/docs/en/babel-plugin-transform-arrow-functions" rel="noopener ugc nofollow" target="_blank">这个插件—<em class="oj">@ Babel/plugin-transform-arrow-functions</em></a><em class="oj"/>，并在你的Babel config中设置它。这很好，因为现在你可以使用es6 arrow函数语法，Babel会把它转换回普通的<code class="fe mp mq mr ms b">function</code>语法。但是—您不希望为es6及更高版本管理所有这些规则！幸运的是，Babel presets包含了许多这样的规则——<em class="oj">Babel preset-env</em>将为您提供使用最新最好的语法所需的一切</li><li id="1032" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks oi nm nn no bi translated"><code class="fe mp mq mr ms b">@babel/node</code>的工作方式<a class="ae kt" href="https://babeljs.io/docs/en/babel-node" rel="noopener ugc nofollow" target="_blank">就像节点cli本身</a>一样，但是当然也运行巴别塔进程。因此，不用运行<code class="fe mp mq mr ms b">node index.js</code>来运行节点流程，您可以使用<code class="fe mp mq mr ms b">babel-node index.js</code>(在开发中…在生产中，您将通过Babel构建transpiled代码并运行普通的节点流程…您很快就会在我们的<code class="fe mp mq mr ms b">package.json</code>脚本中看到)</li></ul><p id="07cc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们很快就会回到<code class="fe mp mq mr ms b">package.json</code>，但是首先让我们制作一个简单的B <a class="ae kt" href="https://babeljs.io/docs/en/config-files" rel="noopener ugc nofollow" target="_blank"> abel配置文件</a>，当它运行时，Babel将会识别并相应地采取行动。在项目的根级别创建一个名为<code class="fe mp mq mr ms b">.babelrc.json</code>的新文件，并赋予它以下内容:</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="d6fe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着我们的核心Babel包的安装和<code class="fe mp mq mr ms b">.babelrc.json</code>的设置，让我们更新我们的npm脚本。在<code class="fe mp mq mr ms b">package.json</code>的<code class="fe mp mq mr ms b">scripts</code>部分，删除Express generator为我们制作的<code class="fe mp mq mr ms b">start</code>命令，并添加以下新命令:</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ok ol gj gh gi om on bd b be z dk">scripts section of package.json so far</figcaption></figure><p id="b96c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看着每一个人:</p><ul class=""><li id="ffc0" class="ng nh in jx b jy jz kc kd kg ni kk nj ko nk ks oi nm nn no bi translated"><code class="fe mp mq mr ms b">dev</code> —使用我们安装的<code class="fe mp mq mr ms b">@babel/node</code>包，这是进行本地开发的简单方法。就像使用<code class="fe mp mq mr ms b">node</code>，但是为我们处理巴别塔翻译</li><li id="b5f7" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks oi nm nn no bi translated"><code class="fe mp mq mr ms b">clean</code>—<code class="fe mp mq mr ms b">build</code>命令(next)将巴别塔构建的结果输出到一个<code class="fe mp mq mr ms b">dist</code>文件夹中……这只是删除了构建的目录，这样我们每次都可以重新开始</li><li id="f6a9" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks oi nm nn no bi translated"><code class="fe mp mq mr ms b">build</code> —在我们的源文件上运行<code class="fe mp mq mr ms b">babel</code>过程，这样我们就有一个<code class="fe mp mq mr ms b">dist</code>目录，其中包含我们传输的代码，可以在生产中正常运行<code class="fe mp mq mr ms b">node</code></li><li id="f246" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks oi nm nn no bi translated"><code class="fe mp mq mr ms b">prod</code> —假设我们已经用<code class="fe mp mq mr ms b">build</code>命令构建了我们的代码，现在我们可以用<code class="fe mp mq mr ms b">node</code>运行它</li></ul><p id="cb6c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">测试我们的新脚本</p><p id="dda3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mp mq mr ms b">dev</code>:作为健全性检查，我们应该能够立即使用我们的<code class="fe mp mq mr ms b">dev</code>命令。我们还没有任何需要转换的代码，因为Express generator生成的代码不使用ES2015+语法，不过没关系……我们还是<em class="oj">可以</em>使用<code class="fe mp mq mr ms b">babel-node</code>来运行我们所拥有的。</p><p id="daf9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">运行<code class="fe mp mq mr ms b">npm run dev</code>，一切都应该像以前一样工作。</p><p id="90c0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们确保可以用巴别塔来构建我们的代码。运行<code class="fe mp mq mr ms b">npm run build</code>,你会看到一个<code class="fe mp mq mr ms b">dist</code>目录，它是用transpile文件创建的(当然，我们还没有多少要trans pile的)。</p><p id="3b24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe mp mq mr ms b">prod</code>:最后<code class="fe mp mq mr ms b">npm run prod</code>将使用普通的<code class="fe mp mq mr ms b">node</code>来运行位于<code class="fe mp mq mr ms b">dist</code>目录中的入口文件——运行它，看看你仍然可以在你的浏览器中访问<code class="fe mp mq mr ms b">localhost:3000</code>。</p><p id="ac68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">又一个与巴别塔相关的项目… </strong></p><p id="3fbd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们设置了上面的构建过程，以利用Babel及其<code class="fe mp mq mr ms b">preset-env</code>将ES2015+代码(我们将很快编写)的语法转换回旧样式的语法，以便它可以在更多环境中运行。转换语法的一个例子是将箭头函数<code class="fe mp mq mr ms b">const x = () =&gt; {}</code>转换成普通函数<code class="fe mp mq mr ms b">function x() {}</code>。然而,<strong class="jx io"> polyfill </strong>的概念略有不同……poly fill是一段代码，它实际上使用了该语言的旧目标版本的原语来<strong class="jx io">添加该语言的<em class="oj"> </em> </strong>功能，因此它与我们的新代码兼容。比如我们在web开发中经常用到的<code class="fe mp mq mr ms b">fetch</code>调用。没有将语法从ES2015+ fetch转换到旧版本的概念，而是编写了一个polyfill来<strong class="jx io">添加</strong>一个兼容的fetch调用。这篇文章在更深入的解释方面做得很好。</p><p id="22e6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，为了我们的目的，我们如何确保正确的东西是为我们填充的呢？<a class="ae kt" href="https://babeljs.io/docs/en/usage#polyfill" rel="noopener ugc nofollow" target="_blank">这个巴别塔文档</a>告诉我们<code class="fe mp mq mr ms b">@babel/polyfill</code>已经被弃用，取而代之的是直接使用它的两个主要组成库:<code class="fe mp mq mr ms b">core-js</code>和<code class="fe mp mq mr ms b">regenerator-runtime</code>。让我们安装这两个:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="8a95" class="nb ln in ms b gy nc nd l ne nf">npm install --save core-js regenerator-runtime</span></pre><p id="18d5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，正如他们在巴别塔文档中建议的那样，将这些作为前两行添加到<code class="fe mp mq mr ms b">src/bin/www</code>(在<code class="fe mp mq mr ms b">#!/user/bin/env node</code>之后):</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="746e" class="nb ln in ms b gy nc nd l ne nf">import 'core-js/stable';<br/>import 'regenerator-runtime/runtime';</span></pre><p id="2e2f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您应该仍然能够运行<code class="fe mp mq mr ms b">npm run dev</code>并在浏览器中访问您的页面。事实上，我们刚刚介绍了我们的第一个ES2015+代码(ES模块导入语法)！由于我们的代码仍然工作，这意味着我们的<code class="fe mp mq mr ms b">dev</code>脚本中的<code class="fe mp mq mr ms b">babel-node</code>工作正常。如果您将该脚本更改为<code class="fe mp mq mr ms b">node ./src/bin/www.js</code>，它将会失败并说<em class="oj">“不能在模块外使用导入语句”，</em>因此我们知道Babel(与<code class="fe mp mq mr ms b">preset-env</code>结合)正在完成它的工作。</p><p id="b97f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们将更新我们的Express generator代码以使用现代语法。</p></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><h1 id="d602" class="lm ln in bd lo lp od lr ls lt oe lv lw lx of lz ma mb og md me mf oh mh mi mj bi translated">3.将代码更新为现代语法</h1><p id="cfb2" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">请记住，所有代码都可以在顶部链接的repo中找到，但这里是我们将在样板文件中进行的主要更新:</p><ol class=""><li id="c007" class="ng nh in jx b jy jz kc kd kg ni kk nj ko nk ks nl nm nn no bi translated">转换成ES模块(<code class="fe mp mq mr ms b">export</code>、<code class="fe mp mq mr ms b">export default</code>和<code class="fe mp mq mr ms b">import</code>语法，而不是常见的JS <code class="fe mp mq mr ms b">module.exports</code>和<code class="fe mp mq mr ms b">require</code>语法)</li><li id="ac2a" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated">切换到<code class="fe mp mq mr ms b">const</code>变量(块范围的)而不是<code class="fe mp mq mr ms b">var</code>变量</li><li id="c942" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated">使用箭头功能</li></ol><p id="be4c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们从Express generator开始的结果文件现在看起来像这样:</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ok ol gj gh gi om on bd b be z dk">Updated <a class="ae kt" href="http://www.js" rel="noopener ugc nofollow" target="_blank">www.js</a> file</figcaption></figure><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ok ol gj gh gi om on bd b be z dk">updated app.js file</figcaption></figure><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ok ol gj gh gi om on bd b be z dk">updated routes/index.js file</figcaption></figure><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ok ol gj gh gi om on bd b be z dk">updated routes/users.js file</figcaption></figure><p id="924e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">重新运行<code class="fe mp mq mr ms b">npm run dev</code>，你会发现一切仍然完美运行。同样，我们让所有这些新语法贯穿于<code class="fe mp mq mr ms b">babel-node</code>，使用<code class="fe mp mq mr ms b">preset-env</code>，已经触发了我们需要的所有转换。</p></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="0502" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">怎么能像预期的那样进行复查呢？让我们测试一下我们的<code class="fe mp mq mr ms b">build</code>命令，现在我们依靠Babel来传输我们的代码。运行<code class="fe mp mq mr ms b">npm run build</code>并打开<code class="fe mp mq mr ms b">dist/routes/index.js</code>——这是我们上面更新的传输索引路径文件。它看起来会像这样:</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="ok ol gj gh gi om on bd b be z dk">Babel-transpiled routes/index.js file (now in dist)</figcaption></figure><p id="bfb8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有很多，但是基于我们的语法更新，请注意两点:</p><ul class=""><li id="ddb2" class="ng nh in jx b jy jz kc kd kg ni kk nj ko nk ks oi nm nn no bi translated">自从我们切换到ES模块风格<code class="fe mp mq mr ms b">export default router</code>，一堆transpiled代码负责使其与旧环境兼容</li><li id="f8d8" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks oi nm nn no bi translated">在第16行，我们可以看到我们创建的箭头函数被切换回了一个普通的函数声明</li></ul><p id="5a0b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们都准备好了巴别塔管道！我们可以用ES2015+语法编写任何代码，包括在<code class="fe mp mq mr ms b">preset-env</code>中，并且知道它会被正确编译。<code class="fe mp mq mr ms b">npm run prod</code>可以成功地使用普通的<code class="fe mp mq mr ms b">node</code>来运行你内置的<code class="fe mp mq mr ms b">dist</code>代码。</p></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><h1 id="61f6" class="lm ln in bd lo lp od lr ls lt oe lv lw lx of lz ma mb og md me mf oh mh mi mj bi translated">额外收获:绝对进口</h1><p id="7fec" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">我总是喜欢从一开始就设置绝对进口。你曾经像<code class="fe mp mq mr ms b">../../../directoryX/thing</code>一样在你的代码中写导入吗？使用绝对导入，我们可以为我们想要的任何目录创建名称，并在“绝对”意义上使用这些名称——之前的路径可以简化为例如<code class="fe mp mq mr ms b">directoryX/thing</code>(注意没有前导点或斜线)。使用Babel插件很容易做到这一点。</p><p id="63c8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们用以下代码安装插件:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="0fae" class="nb ln in ms b gy nc nd l ne nf">npm install --save-dev babel-plugin-module-resolver</span></pre><p id="d811" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://www.npmjs.com/package/babel-plugin-module-resolver" rel="noopener ugc nofollow" target="_blank">点击这里查看巴别插件模块解析器</a>。正如它所说的，它允许你添加包含你的模块的新的“根”目录。设置很好也很简单。</p><p id="e83f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，将你的<code class="fe mp mq mr ms b">.babelrc.json</code>更新成这样:</p><figure class="mt mu mv mw gt jo"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="fbbf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你会看到我们添加了一个新的<code class="fe mp mq mr ms b">plugins</code>部分，在这里我们使用了新的插件。最重要的是，看到<code class="fe mp mq mr ms b">alias</code>对象。在这里，我们可以在整个代码的import语句中使用我们想要的别名。作为一个例子，您可以看到<code class="fe mp mq mr ms b">#routes</code>现在是我们在<code class="fe mp mq mr ms b">src</code>下的<code class="fe mp mq mr ms b">routes</code>目录的别名。<code class="fe mp mq mr ms b">#</code>字符不是必需的，但是我见过其他人使用它作为一种简单的方法，在你的代码中看到你正在使用一个定制的别名。</p><p id="a5d6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用我们的新别名，回到您的<code class="fe mp mq mr ms b">src/app.js</code>文件。对于我们的<code class="fe mp mq mr ms b">routes</code>，这里有两个导入:</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="405b" class="nb ln in ms b gy nc nd l ne nf">import indexRouter from './routes/index';<br/>import usersRouter from './routes/users';</span></pre><p id="e470" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些导入非常简单，所以您不一定需要/想要在这里使用别名，但是我们还是在示例中使用别名。现在它们看起来像这样(注意没有前导点或斜杠):</p><pre class="mt mu mv mw gt mx ms my mz aw na bi"><span id="6e66" class="nb ln in ms b gy nc nd l ne nf">import indexRouter from '#routes/index';<br/>import usersRouter from '#routes/users';</span></pre><p id="b904" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">重启你的节点服务器，一切都会像以前一样。请注意，这只是一个开发依赖——当您运行<code class="fe mp mq mr ms b">npm run build</code>并查看<code class="fe mp mq mr ms b">dist/app.js</code>时，您会看到Babel将那些绝对导入改回了相对require语句。</p></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><h1 id="894e" class="lm ln in bd lo lp od lr ls lt oe lv lw lx of lz ma mb og md me mf oh mh mi mj bi translated">最后一个想法——2020年你需要巴别塔吗？</h1><p id="30ca" class="pw-post-body-paragraph jv jw in jx b jy mk ka kb kc ml ke kf kg mm ki kj kk mn km kn ko mo kq kr ks ig bi translated">在我看来，在这一点上是否值得使用带有Node的巴别塔设置是一个艰难的决定。<a class="ae kt" href="https://node.green/" rel="noopener ugc nofollow" target="_blank">看看这个网站</a>，它追踪了Node的各种版本的语言特性(本文使用的是15.4.0)。</p><p id="ef12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">ES模块呢？<a class="ae kt" href="https://nodejs.medium.com/announcing-core-node-js-support-for-ecmascript-modules-c5d6dc29b663" rel="noopener">从节点13.2.0开始，ES模块已经可用，没有任何实验标志。</a>这意味着如果您将<code class="fe mp mq mr ms b">type: "module"</code>添加到您的<code class="fe mp mq mr ms b">package.json</code>文件中(或者使用<code class="fe mp mq mr ms b">.mjs</code>文件扩展名)，您现在可以在节点中使用<code class="fe mp mq mr ms b">import</code> / <code class="fe mp mq mr ms b">export</code>模块语法。但是，有几个小问题需要注意:</p><ul class=""><li id="b07a" class="ng nh in jx b jy jz kc kd kg ni kk nj ko nk ks oi nm nn no bi translated"><a class="ae kt" href="https://blog.logrocket.com/es-modules-in-node-today/" rel="noopener ugc nofollow" target="_blank">正如LogRocket提到的</a>(截止到2020年3月)<em class="oj">“ES模块仍被标记为实验性的，因为该功能尚未完全为生产环境做好准备，”</em>他们还注意到ES模块和CommonJS模块之间的一些兼容性问题(后者在Babel中不是问题，它会转换回CommonJS模块)</li><li id="2b30" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks oi nm nn no bi translated"><a class="ae kt" href="https://nodejs.org/api/esm.html#esm_differences_between_es_modules_and_commonjs" rel="noopener ugc nofollow" target="_blank">在Node的文档这里</a>，你可以看到更多关于es模块细微之处的注释。例如，你需要包含文件扩展名，<code class="fe mp mq mr ms b">__dirname</code>超出范围，JSON文件导入改变等。</li></ul><p id="a872" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">更普遍的是，在<a class="ae kt" href="https://nodejs.org/api/esm.html" rel="noopener ugc nofollow" target="_blank">那些相同的文件</a>，你可以看到一些作品仍然是实验性的。尽管如此，支持似乎主要在这里。</p><p id="737d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">那么，您需要为您的节点设置而烦恼Babel吗？我认为在这一点上任何一个决定都是好的。就我个人而言，目前我更倾向于坚持使用本文中的Babel工作流，但也许在未来的几个月里会有所改变。</p><ol class=""><li id="c043" class="ng nh in jx b jy jz kc kd kg ni kk nj ko nk ks nl nm nn no bi translated">我想坚持使用我习惯的导入语法(特别是这样我就可以在例如Create React App应用程序中使用相同的语法)</li><li id="624e" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated">我喜欢巴别塔插件生态系统——我可以继续使用像上面我们看到的<code class="fe mp mq mr ms b">babel-plugin-module-resolver</code>这样的插件。插件让这一切变得非常灵活</li><li id="958f" class="ng nh in jx b jy np kc nq kg nr kk ns ko nt ks nl nm nn no bi translated">Node / Babel工作流在这一点上已经相当成熟，所以你可以在网上找到大量的资源和问答</li></ol></div><div class="ab cl nw nx hr ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ig ih ii ij ik"><p id="ca68" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请看下面这个系列的第2部分，我们在项目中配置了ESlint &amp; Prettier来帮助语法和样式:</p><div class="ku kv gp gr kw kx"><a href="https://neightjones.medium.com/a-minimal-node-js-setup-part-2-eslint-prettier-vs-code-7963768dbb30" rel="noopener follow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd io gy z fp lc fr fs ld fu fw im bi translated">最简单的Node.js设置第2部分:ESlint、Prettier和VS代码</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">这是我关于使用Babel建立一个最小的Node.js &amp; Express项目的系列文章的第2/2部分。点击此处查看第1部分:</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">neightjones.medium.com</p></div></div><div class="lg l"><div class="oo l li lj lk lg ll jt kx"/></div></div></a></div></div></div>    
</body>
</html>