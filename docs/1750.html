<html>
<head>
<title>Angular: what is forwardRef and how does it work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Angular:什么是forwardRef，它是如何工作的？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-what-is-forwardref-and-how-does-it-work-54f567e37636?source=collection_archive---------0-----------------------#2020-04-19">https://javascript.plainenglish.io/angular-what-is-forwardref-and-how-does-it-work-54f567e37636?source=collection_archive---------0-----------------------#2020-04-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/070b9e648c616bd7c7a51a1465518efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p_kQedq-CvmL3sFqHtsXBA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@steinart?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Steinar Engeland</a> on <a class="ae kc" href="https://unsplash.com/s/photos/arrow?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d92e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular是一个完整的开发框架，它为你能想到的大多数问题提供了解决方案。甚至可能是你想不到的。<code class="fe lb lc ld le b">forwardRef</code>解决的问题很可能是其中之一。</p><h1 id="a94c" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">不现实但简单的例子</h1><p id="5e71" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">让一个组件向服务请求一些数据是一种非常常见的情况。这个服务本身需要另一个服务的帮助，这种情况也不罕见。在一个经典的Angular项目中，组件和服务位于不同的文件中。但是没有任何东西禁止在一个文件中有多个类，所以我们可以这样做:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="04e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，服务<code class="fe lb lc ld le b">Test1Service</code>首先被定义，但是注入了第二个被声明的<code class="fe lb lc ld le b">Test2Service</code>。这不会导致任何林挺或编译错误，您可以用<code class="fe lb lc ld le b">ng serve</code>启动您的应用程序。</p><p id="07b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，在浏览器中打开应用程序时，您没有看到预期的“Hello ”,而是在控制台中看到一个错误:</p><pre class="mi mj mk ml gt mo le mp mq aw mr bi"><span id="968b" class="ms lg iq le b gy mt mu l mv mw">Uncaught ReferenceError: Cannot access 'Test2Service' before initialization</span></pre><p id="bfee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，在<code class="fe lb lc ld le b">Test1Service</code>中使用<code class="fe lb lc ld le b">Test2Service</code>，而<code class="fe lb lc ld le b">Test2Service</code>是在<code class="fe lb lc ld le b">Test1Service</code>下物理定义的，确实会产生问题。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="f3ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ne">为什么会编译？为什么Angular显然知道这项服务，但却没有初始化它？</em></p><p id="df7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个错误没有告诉我们<code class="fe lb lc ld le b">Test2Service</code>没有被定义，它清楚地告诉我们它还没有被初始化。是因为<code class="fe lb lc ld le b">Test2Service</code>已经被<strong class="kf ir">吊起</strong>。该错误是在初始化之前试图使用用<code class="fe lb lc ld le b">let</code>或<code class="fe lb lc ld le b">const</code>定义的类或变量时收到的典型错误。JavaScript引擎在执行前扫描了脚本，并创建了执行上下文。变量和类已经存在，但没有初始化。创建<code class="fe lb lc ld le b">Test1Service</code>时，<code class="fe lb lc ld le b">Test2Service</code>仍未初始化，但我们知道它存在。因此出现了这个错误。你可以查看<a class="ae kc" href="https://medium.com/javascript-in-plain-english/javascript-interview-question-what-is-hoisting-e02c1f95d5a4" rel="noopener">这篇文章</a>，快速了解提升和ES6变量和类的情况。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="6bbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以将<code class="fe lb lc ld le b">Test2Service</code>移动到文件的顶部，这样就可以解决问题了。但是由于我们在一个不现实的例子中，我们将使用<code class="fe lb lc ld le b">forwardRef</code>。</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9712" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">forwardRef</code>，正如Angular文档所说，允许你引用尚未定义的参考。它是一个以函数为参数的函数，这个函数本身返回我们要引用的类，这里是<code class="fe lb lc ld le b">Test2Service</code>。当我们试图创建一个<code class="fe lb lc ld le b">Test1Service</code>的实例时，Angular将解析<code class="fe lb lc ld le b">Test2Service</code>，并且能够创建实例。</p><p id="fab3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ne">值得注意的一点:带棱角的8(或据我所知更低)，</em> <code class="fe lb lc ld le b"><em class="ne">Test1Service</em></code> <em class="ne">不应该是</em> <code class="fe lb lc ld le b"><em class="ne">providedIn: 'root'</em></code> <em class="ne">而是必须在</em> <code class="fe lb lc ld le b"><em class="ne">AppModule</em></code> <em class="ne">中提供，否则我们有错误。Angular 9不再是这种情况。</em></p><h1 id="c7fd" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">它是如何工作的？</h1><p id="f4c1" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">从技术上讲，问题来自于角度依赖性注入。在一个基本的普通JS文件中，您可以毫无问题地完成如下工作:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="1159" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在定义<code class="fe lb lc ld le b">TestClass2</code>之前，<code class="fe lb lc ld le b">TestClass1</code>实际上使用了<code class="fe lb lc ld le b">TestClass2</code>，但是当我们在脚本末尾实例化<code class="fe lb lc ld le b">TestClass1</code>时，由于闭包的奇迹，我们在控制台中看到了<code class="fe lb lc ld le b">1</code>。类似地，如果我们放弃在<code class="fe lb lc ld le b">Test1Service</code>中注入<code class="fe lb lc ld le b">Test2Service</code>,而是简单地手工实例化，这将会起作用:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="16e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为在运行时，<code class="fe lb lc ld le b">Test1Service</code>实际被实例化时，<code class="fe lb lc ld le b">Test2Service</code>已经被定义了。</p><p id="34c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">forwardRef</code>中，我们将令牌(类名)的解析与运行时不同。<code class="fe lb lc ld le b">forwardRef</code>功能本身并没有多大作用:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="ba1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它接受作为参数传递的函数(我们的<code class="fe lb lc ld le b">() =&gt; Test2Service</code>)，设置属性<code class="fe lb lc ld le b">__forward_ref__</code>并返回函数。它几乎是一个标识函数，只是将该函数标记为需要“ref forwarded”。</p><p id="5d95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当创建一个<code class="fe lb lc ld le b">Test1Service</code>的实例时，Angular会尝试解析依赖关系。如果一个参数是标有<code class="fe lb lc ld le b">__forward_ref__</code>的函数，它就调用它:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="0ca9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有这样，才会创建一个实例并将其添加到提供程序中，这才是最重要的。</p><h1 id="cdd9" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">现实生活中的例子</h1><p id="20ad" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">作为最后的手段。通常可以通过为每个服务创建一个文件来避免这种情况。还有一些情况是避免不了的，否则就不存在了。例如，如果你想为角度反应式表单创建你自己的表单控件，你需要为你的组件提供一个<a class="ae kc" href="https://angular.io/api/forms/ControlValueAccessor" rel="noopener ugc nofollow" target="_blank"> ControlValueAccessor </a>，它就是…本身。在decorator中直接引用组件会导致与我们的例子中相同的错误，所以您需要使用<code class="fe lb lc ld le b">forwardRef</code>:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="a6b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是众多例子中的一个，用来展示它在现实生活中的应用。</p><h2 id="ce21" class="ms lg iq bd lh nf ng dn ll nh ni dp lp ko nj nk lt ks nl nm lx kw nn no mb np bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="f6e1" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"> <strong class="kf ir"> AI in Plain English </strong> </a>，<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="231f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>