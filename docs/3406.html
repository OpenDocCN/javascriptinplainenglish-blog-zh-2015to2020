<html>
<head>
<title>An introduction to Babel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">巴别塔介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/an-introduction-to-babel-545ac22bca67?source=collection_archive---------7-----------------------#2020-09-26">https://javascript.plainenglish.io/an-introduction-to-babel-545ac22bca67?source=collection_archive---------7-----------------------#2020-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="90d1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么是巴别塔，你今天可以如何开始使用它</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f007200bce192765b8931c6d942d8ef0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KZGaB1L194Qkojz_"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae kv" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">https://unsplash.com/</a></figcaption></figure><h1 id="e695" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">巴别塔是什么？</h1><p id="c6a0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Babel 是一个帮助我们<a class="ae kv" href="https://scotch.io/tutorials/javascript-transpilers-what-they-are-why-we-need-them" rel="noopener ugc nofollow" target="_blank">将新版JavaScript代码</a>如<a class="ae kv" href="https://www.w3schools.com/js/js_es6.asp" rel="noopener ugc nofollow" target="_blank"> ES6 </a>转换成旧版JavaScript的工具:它甚至可以帮助你转换<a class="ae kv" href="https://iamturns.com/typescript-babel/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>。</p><p id="43fa" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Babel根据您为其定义的配置读取源代码，并编译更新的JavaScript特性，如<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头函数</a>或<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank">可选链接</a>。巴别塔的三个主要工具就是如此:</p><ul class=""><li id="f50c" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">首先，Babel的<a class="ae kv" href="https://github.com/babel/babel/tree/master/packages/babel-parser" rel="noopener ugc nofollow" target="_blank">解析器</a>获取JavaScript代码，并将其转换为<a class="ae kv" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" rel="noopener ugc nofollow" target="_blank">抽象语法树(AST) </a>，这是计算机可以理解的源代码结构。</li><li id="8581" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">接下来，Babel的<a class="ae kv" href="https://github.com/babel/babel/tree/master/packages/babel-traverse" rel="noopener ugc nofollow" target="_blank">遍历器</a>获取AST，研究它，并将其修改为我们在Babel配置中定义的预期代码。</li><li id="6e1f" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">最后，Babel的<a class="ae kv" href="https://github.com/babel/babel/tree/master/packages/babel-generator" rel="noopener ugc nofollow" target="_blank">生成器</a>会将修改后的AST翻译回常规代码。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/6d190aaa302dbaf931e90378d114fdd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WFQClivWEcD_md70.png"/></div></div></figure><h1 id="1a7c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">巴别塔用法</h1><p id="7e1d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Babel可以通过<a class="ae kv" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> NPM </a>软件包管理器作为软件包依赖项安装。</p><p id="7c93" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将在初始化项目目录后安装这些依赖项:</p><ul class=""><li id="39e4" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">这是一个非常好的使用命令行编译JavaScript文件的工具</li><li id="0f60" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">babel-plugin-transform-async-to-generator—通过这个插件，我们告诉Babel只为我们传输某个特性；在这种情况下<a class="ae kv" href="https://medium.com/@habibridho/javascript-es7-async-await-tutorial-64275c81ce2e" rel="noopener"> ES7的异步功能特性</a></li><li id="4361" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated"><a class="ae kv" href="https://babeljs.io/docs/en/babel-preset-es2015/" rel="noopener ugc nofollow" target="_blank">巴别塔-预设-es2015</a>——这是一个巴别塔插件的集合，允许巴别塔移植ES6(或者换句话说es 2015)的特性:</li></ul><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="b1e7" class="nj kx iq nf b gy nk nl l nm nn">// use `cd` to go to the right directory and then run</span><span id="4897" class="nj kx iq nf b gy no nl l nm nn">mkdir babel_project</span><span id="d2e3" class="nj kx iq nf b gy no nl l nm nn">// initialize a package.json</span><span id="4f9b" class="nj kx iq nf b gy no nl l nm nn">npm init</span><span id="add5" class="nj kx iq nf b gy no nl l nm nn">// install babel-cli as a tool for running babel, as well as its presets and plugins</span><span id="f3fc" class="nj kx iq nf b gy no nl l nm nn">npm install --save-dev babel-cli babel-preset-es2015 babel-plugin-transform-async-to-generator</span></pre><p id="a71b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">安装完CLI以及相关预置和插件后，我们需要一个地方来定义顶级巴别塔设置。为此，我们将在根目录下创建一个.<a class="ae kv" href="https://babeljs.io/docs/en/6.26.3/babelrc" rel="noopener ugc nofollow" target="_blank"> babelrc </a>文件。该文件中的代码如下所示:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="217c" class="nj kx iq nf b gy nk nl l nm nn">{</span><span id="0ad6" class="nj kx iq nf b gy no nl l nm nn">    "presets": ["es2015"],</span><span id="7956" class="nj kx iq nf b gy no nl l nm nn">    "plugins": ["transform-async-to-generator"]</span><span id="d601" class="nj kx iq nf b gy no nl l nm nn">}</span></pre><p id="30df" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">下一步，我们构建一个文件async.js文件，用一个async函数来测试babel:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="70ed" class="nj kx iq nf b gy nk nl l nm nn">//  async.js</span><span id="cf7b" class="nj kx iq nf b gy no nl l nm nn">const fetch = require("node-fetch")</span><span id="c5ad" class="nj kx iq nf b gy no nl l nm nn">async function getData() {</span><span id="011c" class="nj kx iq nf b gy no nl l nm nn">    let res = await          fetch("https://jsonplaceholder.typicode.com/todos/1")</span><span id="1d3d" class="nj kx iq nf b gy no nl l nm nn">    let json = await res.json()</span><span id="b1d4" class="nj kx iq nf b gy no nl l nm nn">    console.log('data', json);</span><span id="fc62" class="nj kx iq nf b gy no nl l nm nn">}</span><span id="bdb1" class="nj kx iq nf b gy no nl l nm nn">getData();</span><span id="88a7" class="nj kx iq nf b gy no nl l nm nn">// result:</span><span id="7827" class="nj kx iq nf b gy no nl l nm nn">// ▶<em class="np">Object {userId: 1, id: 1, title: "delectus aut autem", completed: false}</em></span></pre><p id="fd7d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们将使用以下命令运行babel CLI:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="0b72" class="nj kx iq nf b gy nk nl l nm nn">npx <em class="np">babel async.js</em></span></pre><p id="90e4" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">要对某个文件运行babel，可以使用以下命令:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="cd98" class="nj kx iq nf b gy nk nl l nm nn">npx babel async.js --out-file async.transpiled.js --source-maps</span></pre><p id="2e64" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这样，我们指定了transpiled文件的名称以及源映射文件；这将通过告诉浏览器传输文件的哪一行与原始文件匹配来帮助我们进行调试。要查看babel如何将该文件传输到ES5的示例，请确保查看这里的<a class="ae kv" href="https://babeljs.io/repl#?browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=MYewdgzgLgBAZgUysAFjAvDATggjgVwEscAKAIjBABMEBaRZFMgSgG4AodgQwgE8xg8fAKiFwMAOZIAIlyhcSzGAG92MGABsk2BBAwwuAdy6FYDVORRQoABwgAuAPSOAVhHA2NXYAhQgNNFgAdFC8NoSgNEGgALaOUNQgEI4AjCwc6lqwbuKYRiawOBBBOWCKGTCgkP4IQRogEuRUclxkADQwpWzsAL6cUlCy8uXsQA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015%2Ces2017%2Creact%2Cstage-1&amp;prettier=false&amp;targets=&amp;version=7.9.0&amp;externalPlugins=" rel="noopener ugc nofollow" target="_blank"/>。</p><p id="38cc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">通过CLI运行babel可以处理这样一个简单的例子，但是在实际的应用程序中，我们更愿意将它作为构建过程的一部分。在一个典型的项目中，构建过程包括蒸发、缩小、美化、缩小或输出构建，这些可以通过像<a class="ae kv" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank">package</a>这样的工具来处理。</p><p id="30cc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">让我们看看如何设置它；为此，我们设置了package.json文件:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="ce0a" class="nj kx iq nf b gy nk nl l nm nn">{</span><span id="ce66" class="nj kx iq nf b gy no nl l nm nn">    "name": "babel",</span><span id="6eb6" class="nj kx iq nf b gy no nl l nm nn">    "version": "1.0.0",</span><span id="a947" class="nj kx iq nf b gy no nl l nm nn">    "description": "",</span><span id="d406" class="nj kx iq nf b gy no nl l nm nn">    "main": "index.html",</span><span id="5aba" class="nj kx iq nf b gy no nl l nm nn">    "scripts": {</span><span id="4f23" class="nj kx iq nf b gy no nl l nm nn">    "start": "parcel index.html --open",</span><span id="5b7b" class="nj kx iq nf b gy no nl l nm nn">    "build": "parcel build index.html"</span><span id="125c" class="nj kx iq nf b gy no nl l nm nn">},</span><span id="990f" class="nj kx iq nf b gy no nl l nm nn">"dependencies": {</span><span id="6566" class="nj kx iq nf b gy no nl l nm nn">    "babel-preset-es2015": "6.24.1",</span><span id="3e2c" class="nj kx iq nf b gy no nl l nm nn">    "node-fetch": "2.6.0"</span><span id="76f6" class="nj kx iq nf b gy no nl l nm nn">},</span><span id="f671" class="nj kx iq nf b gy no nl l nm nn">"devDependencies": {</span><span id="8b46" class="nj kx iq nf b gy no nl l nm nn">    "@babel/core": "7.2.0",</span><span id="82bb" class="nj kx iq nf b gy no nl l nm nn">    "@babel/plugin-transform-async-to-generator": "7.9.5",</span><span id="cf8f" class="nj kx iq nf b gy no nl l nm nn">    "parcel-bundler": "^1.6.1"</span><span id="beac" class="nj kx iq nf b gy no nl l nm nn">},</span><span id="f470" class="nj kx iq nf b gy no nl l nm nn">"keywords": []</span><span id="2a9f" class="nj kx iq nf b gy no nl l nm nn">}</span></pre><p id="16d7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">此时，运行<code class="fe nq nr ns nf b">npm run-script</code> build应该可以为我们处理传输文件了。请注意，在这个例子中，我们使用<a class="ae kv" href="https://parceljs.org/" rel="noopener ugc nofollow" target="_blank">包</a>作为捆绑器/构建器，它有一个内置的转换器Babel。</p></div></div>    
</body>
</html>