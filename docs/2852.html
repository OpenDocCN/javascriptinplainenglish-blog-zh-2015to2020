<html>
<head>
<title>Abstract Forms Component in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的抽象表单组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/abstract-forms-component-in-react-25304681fd55?source=collection_archive---------7-----------------------#2020-07-29">https://javascript.plainenglish.io/abstract-forms-component-in-react-25304681fd55?source=collection_archive---------7-----------------------#2020-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/c5592fbe3d3f48639a43426e10c0d447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CHJGo3wr7Llx8vcUde1zsQ.jpeg"/></div></div></figure><div class=""/><p id="fd18" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">DRY(不要重复自己)是软件开发的一个原则，旨在减少软件模式的<strong class="ka jc">重复</strong>，用<strong class="ka jc">抽象</strong>代替或者使用<strong class="ka jc">数据规范化</strong>来避免冗余。虽然React开发在富表单应用程序中的本质将包括大量处理状态变量、验证和呈现字段的重复工作；我在本文中介绍了一种通过抽象的React组件来抽象这些操作的方法。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="259e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一步是创建一个作为抽象表单组件的React组件，它应该从任何需要访问这些特性的视图组件继承而来。该组件的示例如下:</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ld"><img src="../Images/9f880afb221c925e01036f1bc87224d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MnQhr5w6f7Lw0mdEw00HfA.png"/></div></div></figure><h1 id="e68f" class="li lj jb bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">抽象处理字段生成</h1><p id="f728" class="pw-post-body-paragraph jy jz jb ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">通常我们需要有相同的渲染字段的方式，通常包含以下步骤:</p><p id="255c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1-选择输入组件(当然，在这种情况下，不要忘记实现您自己的低级输入组件:)</p><p id="ca71" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2-选择组的结构和需要的CSS类</p><p id="f4a5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3-呈现错误消息组件</p><p id="03ae" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">4-呈现验证类逻辑</p><p id="81c0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来是一个如何在代码中处理这个问题的例子:</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ml"><img src="../Images/da93da65ea85918eed3f4164baee9674.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0q1ALHZOsq2n-vyXZuALnQ.png"/></div></div></figure><p id="6c9e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数将呈现一个表单组(引导表单组),它包括一个标签、一个低级组件的占位符、一个帮助块来呈现其中的错误。我还使用了一个显示错误的就绪组件。</p><p id="1acd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，我做了另一个函数来根据字段的类型呈现低级输入组件，函数代码如下:</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mm"><img src="../Images/5a443e78d0140669840f14b0514dd950.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dV8yH5ELg6w-chQ-Mgqr2A.png"/></div></div></figure><p id="5e0e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通常，如果是一个私有函数，我更喜欢用_作为函数名的开头。</p><p id="2503" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以注意到，对于三种类型(密码、文本和电子邮件),我们正在呈现一个文本框组件。以此类推，我们将呈现适合该类型的底层组件。像文件上传的图像类型和日期类型的日期选择器…等。</p><p id="03e1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到，在出现错误的情况下，has-error将被附加到组件CSS类中，我们可以根据需要显示错误(比如输入组件周围的红色边框)。</p><p id="f400" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，为了在任何子组件中使用“renderField”函数，我们只需像下面这样调用它:</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ld"><img src="../Images/b57cb3b16dc203732bccf67b0ee36c7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JIzH6nyuEGif0aZrFfNXPg.png"/></div></div></figure><p id="56f4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，在这个函数中，如果状态变量尚未初始化，我们将对其进行初始化，对于每个变量(字段)，我们有三个属性:</p><ul class=""><li id="1de0" class="mo mp jb ka b kb kc kf kg kj mq kn mr kr ms kv mt mu mv mw bi translated"><strong class="ka jc"> Value </strong>:存储字段的真实值</li><li id="d8b1" class="mo mp jb ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated"><strong class="ka jc"> IsValid </strong>:一个布尔值，用来知道该字段是否有效</li><li id="e6fb" class="mo mp jb ka b kb mx kf my kj mz kn na kr nb kv mt mu mv mw bi translated"><strong class="ka jc">信息</strong>:无效时的错误信息</li></ul><p id="402b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是，如果需要在呈现组件之前对其进行初始化，我们可以为此实现下一个函数:</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nc"><img src="../Images/aa2d7a26a1d4d21847ca478287575fe3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8WTDIMzMg56C5R7kg1KZKA.png"/></div></div></figure><h1 id="0b77" class="li lj jb bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">抽象验证操作</h1><p id="c696" class="pw-post-body-paragraph jy jz jb ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">大多数时候，在表单内部，我们可能需要验证字段，拥有一个以简洁的方式处理验证的函数是一个非常好的主意。下一个函数是接受字段名、验证类型和需要时的附加参数。如果它遵循与该类型相关的验证规则，它将检查具有该名称的字段。然后，该函数将IsValid更新为false，如果它无效，则使用目标字段的错误消息更新消息；这意味着该字段将使用错误样式和消息再次重新呈现。</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nd"><img src="../Images/ba74e4ac41b3a3d38bd52c12ff914716.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FgHwB7YGFjFDA1GMpT-YWA.png"/></div></div></figure><p id="001c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以根据需要添加更多的验证类型，我们还需要一个函数来重置整个字段，这样错误消息和样式就会消失，下一个函数可以轻松地迭代所有表单字段并重置它们:</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ne"><img src="../Images/a62c6092fa84d2384af65a19ba954f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CAmdcWkMO3OlUPfcK7XdXQ.png"/></div></div></figure><p id="184f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意,“resetValidationStates”函数需要一个参数(回调参数),因为在React中更新状态不是以同步的方式进行的，所以我们需要确保在再次验证之前所有字段都被重置。</p><p id="c52c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们得到了一个非常简洁的方法，只需几行代码就可以在视图组件中验证任何表单字段，比如下一个示例显示了我如何在分派操作之前验证忘记密码的表单:</p><figure class="le lf lg lh gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nf"><img src="../Images/ee361c4b3d0b9d5b802d5d6933017a72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zy2KyCX5h0AgweHiAoyLCg.png"/></div></div></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="4d89" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这篇文章能够支持您的React项目，使代码更有组织、更短、更干净，并且在需要遵循DRY原则时有一个修改的地方:)</p><h2 id="a96a" class="ng lj jb bd lk nh ni dn lo nj nk dp ls kj nl nm lw kn nn no ma kr np nq me nr bi translated">简单英语的JavaScript</h2><p id="562b" class="pw-post-body-paragraph jy jz jb ka b kb mg kd ke kf mh kh ki kj mi kl km kn mj kp kq kr mk kt ku kv ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae ns" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="ka jc">！</strong></p></div></div>    
</body>
</html>