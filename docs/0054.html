<html>
<head>
<title>How to Implement a GraphQL CRUD BFF</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现一个GraphQL CRUD BFF</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-a-graphql-crud-bff-efcb0117ec71?source=collection_archive---------5-----------------------#2018-11-25">https://javascript.plainenglish.io/how-to-implement-a-graphql-crud-bff-efcb0117ec71?source=collection_archive---------5-----------------------#2018-11-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="013f" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><em class="kc">在本教程中学习如何实现GraphQL CRUD BFF，作者是JavaScript CloudNative开发指南</em><a class="ae kd" href="https://www.packtpub.com/application-development/javascript-cloud-native-development-cookbook" rel="noopener ugc nofollow" target="_blank"><em class="kc"/></a><em class="kc">。</em></h2></div><p id="0990" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">BFF模式加速了创新，因为实现前端的团队也拥有并实现了支持前端的后端服务。这使得团队能够自给自足，不受共享后端服务的竞争需求的影响。在本文中，您将创建一个CRUD BFF服务，该服务在其生命周期的开始阶段支持数据。</p><p id="a2cf" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">该服务的唯一职责是为特定的有界上下文创作数据。它利用<strong class="kg io">数据库优先</strong>事件源向下游服务发布域事件。该服务公开了一个基于GraphQL的API。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi la"><img src="../Images/23e2e81bfdb41665e32c106967455fc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*55Tp4JdXkjmDk06cofn6qg.png"/></div></div></figure><h1 id="9165" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">做好准备</h1><p id="0980" class="pw-post-body-paragraph ke kf in kg b kh me jo kj kk mf jr km kn mg kp kq kr mh kt ku kv mi kx ky kz ig bi translated">在开始这个食谱之前，你需要一个AWS Kinesis流。</p><h1 id="5e06" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">怎么做…</h1><ol class=""><li id="319d" class="mj mk in kg b kh me kk mf kn ml kr mm kv mn kz mo mp mq mr bi translated">从以下模板创建项目:</li></ol><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="edca" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">2.用<code class="fe mu mv mw mx b">cd cncb-bff-graphql-crud</code>导航到<code class="fe mu mv mw mx b">cncb-bff-graphql-crud</code>目录。</p><p id="b4b4" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">3.然后，查看名为<code class="fe mu mv mw mx b">serverless.yml</code>的文件，内容如下:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6925" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">4.查看名为<code class="fe mu mv mw mx b">./schema/thing/typedefs.js</code>的文件，内容如下:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="cb58" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">5.查看名为<code class="fe mu mv mw mx b">./schema/thing/resolvers.js</code>的文件，内容如下:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="4805" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">6.查看名为<code class="fe mu mv mw mx b">handler.js</code>的文件，内容如下:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="646d" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">7.使用npm install安装依赖项。</p><p id="50c8" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">8.用<code class="fe mu mv mw mx b">npm test — -s $MY_STAGE</code>运行测试。</p><p id="305e" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">9.查看在<code class="fe mu mv mw mx b">.serverless</code>目录中生成的内容。</p><p id="707c" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">10.部署堆栈:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="d354" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">11.在AWS控制台中查看堆栈。</p><p id="30a6" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">12.使用以下curl命令调用该函数:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="60dc" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">13.通过在部署期间使用端点输出，使用GraphQL执行相同的转换和查询:</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="gh gi my"><img src="../Images/07fcbaeabb14910317739c65ef30c862.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pOfKmJs_asyadKBLFEpgXA.png"/></div></div></figure><p id="a2e0" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">14.看一下<code class="fe mu mv mw mx b">trigger</code>功能日志:</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="5a27" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">15.查看数据湖桶中收集的事件。</p><p id="77ec" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">16.完成<code class="fe mu mv mw mx b">npm run rm:lcl — -s $MY_STAGE</code>后，移除堆叠。</p><h1 id="01d5" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">它是如何工作的…</h1><p id="479b" class="pw-post-body-paragraph ke kf in kg b kh me jo kj kk mf jr km kn mg kp kq kr mh kt ku kv mi kx ky kz ig bi translated">GraphQL正变得越来越流行，这是因为由此产生的API的灵活性和客户端库的强大功能，比如Apollo客户端。我们实现一个单独的<code class="fe mu mv mw mx b">graphql</code>函数来支持我们的API，然后通过<code class="fe mu mv mw mx b">schema</code>、<code class="fe mu mv mw mx b">resolvers</code>、<code class="fe mu mv mw mx b">models</code>和<code class="fe mu mv mw mx b">connectors</code>添加必要的功能。</p><p id="8168" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">GraphQL模式是我们定义<code class="fe mu mv mw mx b">types</code>、<code class="fe mu mv mw mx b">queries</code>和<code class="fe mu mv mw mx b">mutations</code>的地方。在本教程中，我们可以通过ID和名称查询<code class="fe mu mv mw mx b">thing</code>类型，以及<code class="fe mu mv mw mx b">save</code>和<code class="fe mu mv mw mx b">delete</code>。<code class="fe mu mv mw mx b">resolvers</code>将GraphQL请求映射到封装业务逻辑的<code class="fe mu mv mw mx b">model</code>对象。</p><p id="40d1" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">反过来，<code class="fe mu mv mw mx b">models</code>与封装数据库API细节的<code class="fe mu mv mw mx b">connectors</code>对话。<code class="fe mu mv mw mx b">models</code>和<code class="fe mu mv mw mx b">connectors</code>在<code class="fe mu mv mw mx b">handler</code>函数中用<code class="fe mu mv mw mx b">schema</code>注册，这是一种非常简单但有效的基于构造函数的依赖注入形式。</p><p id="b0f1" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们并不经常在原生云中使用依赖注入，因为这些函数非常小而且非常集中，以至于它是多余的，并且会影响性能。对于GraphQL，这种简单的形式对于促进测试非常有效。<code class="fe mu mv mw mx b">Graphiql</code>工具对于揭示API的自文档化本质非常有用。</p><p id="3ca9" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">该服务的唯一职责是使用数据库优先事件源为特定的有界上下文创作数据和发布事件。服务中的代码遵循一个非常可重复的编码约定<code class="fe mu mv mw mx b">types</code>、<code class="fe mu mv mw mx b">resolvers</code>、<code class="fe mu mv mw mx b">models</code>、<code class="fe mu mv mw mx b">connectors</code>和<code class="fe mu mv mw mx b">triggers</code>。因此，即使服务中的业务域数量增加，也很容易推断出代码的正确性。</p><p id="be63" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">这就是为什么在单个创作BFF服务中有大量域是合理的，只要这些域是内聚的，是同一有界上下文的一部分，并且是由一致的用户组创作的。</p><p id="701d" class="pw-post-body-paragraph ke kf in kg b kh ki jo kj kk kl jr km kn ko kp kq kr ks kt ku kv kw kx ky kz ig bi translated">我们希望本教程对你有所帮助。如果想了解更多关于云原生的知识，可以阅读 <a class="ae kd" href="https://www.amazon.com/JavaScript-Cloud-Native-Development-Cookbook/dp/1788470419" rel="noopener ugc nofollow" target="_blank"> <em class="mz"> JavaScript云原生开发食谱</em> </a> <em class="mz">。本书通过采用基于菜谱的方法，帮助您更快地学习云原生开发的主要概念，您可以尝试不同的解决方案来理解这些概念。</em></p></div></div>    
</body>
</html>