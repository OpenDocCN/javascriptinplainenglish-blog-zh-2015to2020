<html>
<head>
<title>Understanding Singly Linked Lists and Their Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解单链表及其功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-singly-linked-lists-and-their-functions-ae8f2e53f92d?source=collection_archive---------5-----------------------#2020-07-06">https://javascript.plainenglish.io/understanding-singly-linked-lists-and-their-functions-ae8f2e53f92d?source=collection_archive---------5-----------------------#2020-07-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/4672cc7eb80b6c4ebe4d1fb9c7328a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iiEWrP2IznA6HbmuIdK0lQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Structure of a singly linked list</figcaption></figure><p id="a70a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">链表是我们都听说过的东西，并且有很好的理由:<strong class="kb io">它们作为所有其他数据结构的基础理解。有两种不同的链表:单向链表和双向链表。在本文中，我们将讨论前者(并将对两者进行简单的比较)。</strong></p><p id="0cf9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">在继续之前:</strong>本文要求理解ES2015 JavaScript“类”和“实例方法”语法。如果您从未听说过或使用过JavaScript类，这些信息将非常难以理解(除了链表之外，许多其他数据结构也是如此)。如果是这种情况，做一点研究，然后回来！如果您已经理解了这个语法，那么让我们直接开始吧。</p></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><h1 id="574b" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">什么是单链表？</strong></h1><figure class="md me mf mg gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mc"><img src="../Images/49771c0d63f2e5f0dda6f8f88edd284c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ReSYwX-z-n4jWPCRSxqBw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Fig. 1: Structure of a singly linked list. Credit: <a class="ae mh" href="https://www.geeksforgeeks.org/data-structures/linked-list/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/data-structures/linked-list/</a></figcaption></figure><p id="8162" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">单链表是一种包含头部、尾部和长度属性的数据结构</strong>(最后一个属性是可选的，尽管它使事情变得简单多了)。</p><p id="9a1c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">链表由叫做<strong class="kb io">的节点组成。</strong> <strong class="kb io">一个节点是一段数据，它有一个值以及一个指向另一个节点或空值的指针。</strong>链表的头是第一个节点，尾是最后一个节点，始终指向空。</p><blockquote class="mi"><p id="3560" class="mj mk in bd ml mm mn mo mp mq mr kw dk translated">单链表是由节点组成的数据结构。每个节点都有一个值和一个指向下一个节点的指针，或者在到达末尾时为null。</p></blockquote><p id="76e5" class="pw-post-body-paragraph jz ka in kb b kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw ig bi translated">单链表和双链表的区别如下:<strong class="kb io">单链表中，每个节点只指向它前面的节点(或者下一行)。在双向链表中，每个节点也有一个指针引用它后面的节点。</strong>同样地，单链表提供了对整体链表数据结构的更容易的基本理解。</p><p id="318e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">值得一提的是，与数组不同，<strong class="kb io">链表没有内置索引。</strong>这意味着为了在链表中找到一个特定的点，你需要从起点开始，一个接一个地遍历每个节点，直到找到你要找的东西。</p><p id="4e58" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我曾经听过一个有趣的比喻:链表就像没有电梯的摩天大楼。要到达你要找的楼层，你需要一次爬一层楼。在一个阵列中，你可以按下一个按钮，直接带你到你需要去的楼层。</p><p id="45b9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">你可能在想:“链表听起来非常复杂和低效，我会用它吗？”好吧，那就说说吧。</p><h1 id="657b" class="le lf in bd lg lh mx lj lk ll my ln lo lp mz lr ls lt na lv lw lx nb lz ma mb bi translated">为什么/什么时候我会使用单链表？</h1><p id="6616" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">有一些不同的时候链表会比数组亮，反之亦然。这取决于你到底要用这些数据做什么。</p><h2 id="38ba" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">在列表的开头插入或删除数据</strong></h2><p id="a71a" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">请记住，数组带有内置索引。这意味着，如果一个数组中有1000个条目，我们需要将一个条目放在数组的最开始，整个数组中的每个索引都需要向右移动并递增(这意味着我们在这里有一个O(n ),但我们将在本文结尾回到数组与链表的大O)。</p><p id="0b97" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在链表中，将数据添加到开头是极其简单和高效的。你只需要告诉新的一段数据指向头部，然后把那段数据赋值为新的头部。不需要重新索引。</p><h2 id="4a79" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">在列表中间插入或删除数据</strong></h2><p id="f2eb" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">与上面的原因相同，在链表中插入和删除数据不需要重新索引整个列表，这比在数组中插入或删除数据更快(当然，除非您从数组的最末端添加或删除某些内容，这不需要任何重新索引)。)</p><blockquote class="mi"><p id="9ca3" class="mj mk in bd ml mm mn mo mp mq mr kw dk translated">在插入和删除数据时，链表非常有用。当需要随机访问时，数组更有用。</p></blockquote><p id="174a" class="pw-post-body-paragraph jz ka in kb b kc ms ke kf kg mt ki kj kk mu km kn ko mv kq kr ks mw ku kv kw ig bi translated">好了，现在我们已经简单了解了什么是单链表，以及使用它们的基本原理。<strong class="kb io">让我们创建一个并构建它的功能。</strong></p><p id="9a34" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">重要提示:</strong>有许多方法可以构建这些功能。这些都只是做每一件事的一种方法。因此，如果你在其他地方看到过不同的做法，这两种方法都没有错。但是如果你找到了更好的解决方法，请在评论中分享吧！</p></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><h2 id="709f" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">创建单链表</strong></h2><p id="74ff" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated"><strong class="kb io">要创建一个单链表，我们需要从创建两个类开始:</strong> <code class="fe nt nu nv nw b"><strong class="kb io">Node</strong></code> <strong class="kb io">和</strong> <code class="fe nt nu nv nw b"><strong class="kb io">SinglyLinkedList</strong></code></p><p id="2250" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">因为我们的节点由某种值和指向下一个值的指针组成，所以它需要包含一个<code class="fe nt nu nv nw b">val</code>属性和一个<code class="fe nt nu nv nw b">next</code>属性。<code class="fe nt nu nv nw b">next</code>将从等于<code class="fe nt nu nv nw b">null</code>开始。</p><p id="8a1f" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">记住，我们的单链表需要包含一个<code class="fe nt nu nv nw b">head</code>和一个<code class="fe nt nu nv nw b">tail</code>来指定它的开始和结束位置。我们还将添加一个<code class="fe nt nu nv nw b">length</code>属性，使我们的一些功能更容易实现。头尾会以<code class="fe nt nu nv nw b">null</code>开头。</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Creating a Singly Linked List</figcaption></figure><h2 id="a00f" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">添加到列表末尾</strong></h2><p id="8dde" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">要添加到列表的末尾，我们需要做的就是创建一个新节点，并将当前tail的<code class="fe nt nu nv nw b">next</code>属性设置为新节点，然后使新节点成为tail。</p><p id="9dec" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">不要忘记<strong class="kb io">边缘情况:</strong>如果没有头(即列表尚不存在)，则将头和尾设置为新节点。将长度增加1并返回列表。</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Adding a new node to the end of a Singly Linked List</figcaption></figure><h2 id="de0c" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">从列表末尾删除</strong></h2><p id="0e26" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">为此，我们需要循环遍历列表，直到找到尾部，然后将尾部之前的节点的<code class="fe nt nu nv nw b">next</code>值设置为空，并将该节点设置为新的尾部。然后将列表的长度减1，并返回被删除的节点的值(记住，您需要提前保存这个变量以便返回它)。</p><p id="9904" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">边缘情况:</strong>如果没有头，返回<code class="fe nt nu nv nw b">undefined</code>；如果删除节点后列表的长度为零，请确保将头部和尾部设置回null。</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Removing a node from the end of a Singly Linked List</figcaption></figure><h2 id="a895" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">从列表的开头删除</strong></h2><p id="3d6d" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">从单链表的开头删除一个节点非常简单。我们需要做的就是将head设置为当前head的下一个值，然后将长度减1并返回旧的head(记住将原始head保存为变量，以便可以返回它。)</p><p id="e495" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">边缘情况:</strong><code class="fe nt nu nv nw b">shift()</code>的边缘情况是<strong class="kb io"> </strong>与<code class="fe nt nu nv nw b">pop().</code>非常相似，如果没有头，返回<code class="fe nt nu nv nw b">undefined</code>。如果在移除头部之后列表的长度为零，确保尾部被设置回null(在这种情况下头部已经被设置为null，但是尾部将被默认设置为<code class="fe nt nu nv nw b">Node</code>。将其设置为null可以防止这种情况发生)。</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Removing from the beginning of a Singly Linked List</figcaption></figure><h2 id="dd21" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">添加到列表的开头</strong></h2><p id="9df1" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">添加到单链表的开头也很容易。我们只需要创建一个新节点，并将其<code class="fe nt nu nv nw b">next</code>值设置为当前头，将其指定为新头，将列表递增1，然后返回列表。</p><p id="7263" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">边缘情况:</strong>如果head当前为空，那么这意味着我们要卸载的将是列表中唯一的值。因此，需要将它设置为头部和尾部。</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Adding to the beginning of a Singly Linked List</figcaption></figure><h2 id="82c8" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">根据节点在列表中的位置检索节点</strong></h2><p id="a3a7" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">记住，链表不像数组那样有索引！所以我们需要在这里做一些额外的工作。我们的函数将被传递一个索引，所以我们将需要创建某种类型的<code class="fe nt nu nv nw b">counter</code>变量，当它小于索引时，我们可以用它来循环遍历列表(从头开始)。一旦我们到达传入的索引，我们就返回那个节点。</p><p id="4daf" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">边缘情况:</strong>如果传入的索引小于零或者大于等于列表长度，则返回<code class="fe nt nu nv nw b">null</code>(或-1，<code class="fe nt nu nv nw b">undefined</code>等。(不好的东西)。</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Retrieving a Node by its index</figcaption></figure><h2 id="0f53" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">给定节点在列表中的位置，改变节点的值(和新值)</strong></h2><p id="951a" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">因为我们已经创建了<code class="fe nt nu nv nw b">get</code>函数，我们可以用它来查找给定索引处的节点。我们可以很容易地将这个节点设置为一个变量，因为我们的<code class="fe nt nu nv nw b">get</code>函数返回找到的节点。找到节点后，我们需要做的就是将它的值设置为传入的值，然后返回true。如果没有找到节点，返回false。</p><p id="0b3b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">边缘情况:</strong>我们定义的<code class="fe nt nu nv nw b">get</code>函数已经处理了无效的索引。这使得我们的<code class="fe nt nu nv nw b">set</code>函数非常简洁。</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Changing the value of a specified node in a Singly Linked List</figcaption></figure><h2 id="a17d" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">在列表的指定位置添加一个新节点</strong></h2><p id="be23" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">这个函数有点棘手。首先，我们需要根据传入的值创建新节点。现在，为了让我们在某个地方插入节点，我们需要找到直接在传入的索引之前的节点，并将其<code class="fe nt nu nv nw b">next</code>值设置为新节点。在这之后，我们需要将我们的新节点的<code class="fe nt nu nv nw b">next</code>值设置为找到的节点的<code class="fe nt nu nv nw b">next</code>值(我知道，有很多“nexts”)。这意味着我们需要确保我们已经提前将它保存为一个变量。一旦我们添加了新的节点，将长度增加1并返回true。</p><p id="deb2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">但是等等！如果我们的函数传递给我们一个零索引或者一个等于列表长度的索引，我们已经为它们写了函数！在这些情况下使用您的<code class="fe nt nu nv nw b">unshift</code>或<code class="fe nt nu nv nw b">push</code>函数，并将给定值传递给它们。</strong></p><p id="67ea" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">边缘情况:</strong>如果给定的索引小于零或大于列表的长度(在这种情况下，它是否等于列表的长度并不重要，因为我们可以将新节点添加到末尾)，返回false。此外，我们希望这个函数只返回true或false。现在，如果我们在这里使用了<code class="fe nt nu nv nw b">unshift</code>或<code class="fe nt nu nv nw b">push</code>方法，它将返回整个列表。这不是世界末日，但作为程序员，我们喜欢保持一致。这里一个简单的解决方法是，如果使用了这两个方法中的任何一个，就让我们的方法返回true。</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Adding a new Node to a Singly Linked List</figcaption></figure><h2 id="32f6" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">从列表的指定位置删除一个新节点</strong></h2><p id="1658" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">要删除一个节点，我们需要做的就是找到传入的索引之前的节点，然后将其<code class="fe nt nu nv nw b">next</code>设置为下一个节点(我们要删除的节点)的<code class="fe nt nu nv nw b">next</code>。我们在这里所做的就是通过使前一个节点的<code class="fe nt nu nv nw b">next</code>成为它前面两个下一个的节点，来切断前一个节点和曾经在它后面的节点之间的链接(厌倦了读“下一个”这个词了吗？).</p><p id="b14b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">完成后，将长度减1并返回移除的节点(这意味着您需要将它保存到一个变量中)。</p><p id="518e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">但是等等！如果传入的索引等于列表长度减一，或者等于零，我们已经为这些写了方法！在这些情况下，分别返回您的<code class="fe nt nu nv nw b"> pop()</code>或<code class="fe nt nu nv nw b">shift()</code>方法。</strong></p><p id="e4b7" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">边缘情况:</strong>如果传入的索引小于零或者大于等于列表长度，则返回<code class="fe nt nu nv nw b">null</code>。</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Removing a Node from a Singly Linked List given its index</figcaption></figure><h2 id="bbce" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">原地反转单链表</strong></h2><p id="5b99" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">就地反转单链表(“就地”的意思是不复制它)是一个经典的问题，同样也是最难解释的问题。也有很多方法可以做到。下面是我们将如何解决这个问题<strong class="kb io">(这是一个迭代解决方案的例子，也有递归解决方案)</strong>:</p><p id="249c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">首先，交换头部和尾部，将尾部保存为一个新变量(通常称为<code class="fe nt nu nv nw b">curr</code>)。然后创建一个变量<code class="fe nt nu nv nw b">next</code>和一个变量<code class="fe nt nu nv nw b">prev</code>。<code class="fe nt nu nv nw b">prev</code>应该从<code class="fe nt nu nv nw b">null</code>开始。接下来，遍历列表。将<code class="fe nt nu nv nw b">next</code>设置为当前<code class="fe nt nu nv nw b">curr</code>的下一个属性(如上定义，它从尾部开始)。然后，将<code class="fe nt nu nv nw b">curr</code>节点的下一个属性设置为我们定义的<code class="fe nt nu nv nw b">prev</code>变量。现在，设置<code class="fe nt nu nv nw b">prev</code>等于<code class="fe nt nu nv nw b">curr</code>，设置<code class="fe nt nu nv nw b">curr</code>等于<code class="fe nt nu nv nw b">next</code>。</p><p id="21d3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一旦这些都完成了，返回更新的列表。</p><p id="5d6d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">感觉极度迷茫？可以理解。看看下面的解决方案，试着理解发生了什么。如果您仍然有问题，我在解决方案下提供了一个有用的gif，可能会有所帮助。</p><figure class="md me mf mg gt jo"><div class="bz fp l di"><div class="nx ny l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Reversing a Singly Linked List</figcaption></figure><p id="633a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你很难理解这个，看看下面这张来自geeksforgeeks.org的gif图片。</p><figure class="md me mf mg gt jo gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/d33b1cd1c429c32cef30fa22429dd879.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*o4QixeDthTcTcZ3dc11cgw.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Fig. 2: Reversing a singly linked list. Credit: <a class="ae mh" href="https://www.geeksforgeeks.org/reverse-a-linked-list/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/reverse-a-linked-list/</a></figcaption></figure></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><h1 id="35bb" class="le lf in bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated"><strong class="ak">单链表与数组的大O</strong></h1><p id="2a30" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">咻！还和我在一起吗？让我们花点时间来看看单链表和数组的大O符号。</p><h2 id="a395" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">插入:O(1) </strong></h2><p id="af7d" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">单链表对于在一组数据的开头插入值非常有用。它不像数组那样需要任何重新索引，因此需要恒定的时间。</p><h2 id="4aff" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">清除:O(1)或O(n) </strong></h2><p id="6e9b" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">如果我们从一个单链表的开头开始移除，这是非常有效的，并且花费恒定的时间。然而，如果我们从最末端开始，我们需要在尾部之前找到条目，这涉及到遍历整个列表。</p><h2 id="75d0" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">搜索:O(n) </strong></h2><p id="f17d" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">如果我们在一个单链表中寻找一个特定的值，这需要线性的时间，因为我们需要从头开始并遍历整个链表，直到找到我们想要的。这类似于数组，尽管不是完全平等的比较。</p><h2 id="1de0" class="nh lf in bd lg ni nj dn lk nk nl dp lo kk nm nn ls ko no np lw ks nq nr ma ns bi translated"><strong class="ak">访问:O(n) </strong></h2><p id="bf72" class="pw-post-body-paragraph jz ka in kb b kc nc ke kf kg nd ki kj kk ne km kn ko nf kq kr ks ng ku kv kw ig bi translated">正如本文开头所讨论的，访问单向链表的特定索引远不如数组有效，因为它没有数组那样的内置“随机访问”。访问数组中的第1000个元素非常简单，并且花费恒定的时间，因为每个值都被索引，由于上面讨论的原因，访问单链表中的第1000个元素要慢得多，并且花费线性时间。</p></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="0824" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在本文中，我们讨论了什么是单链表/它们与双向链表和数组有什么不同，它们有什么用，什么时候数组可能更好，单链表的常见函数，以及它们的用例。</p><p id="8439" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们在这篇文章中已经讨论了很多。如果看起来很多，花点时间消化这些信息，然后回来尽可能多地复习。</p><p id="7621" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">有比这里提供的更好的解决方案吗？欢迎在评论中分享！</strong></p></div></div>    
</body>
</html>