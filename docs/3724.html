<html>
<head>
<title>Data Structures: Binary Tree</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据结构:二叉树</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/data-structures-binary-tree-f8da24fe9602?source=collection_archive---------4-----------------------#2020-10-20">https://javascript.plainenglish.io/data-structures-binary-tree-f8da24fe9602?source=collection_archive---------4-----------------------#2020-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b263" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从数学表达式到语言语法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/337d4537e35d495229eb255123899a2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WpIrwWA3BkpS15051EI3zg.png"/></div></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="ac6a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">作为我关于JS数据结构的全新系列文章的一部分，我想写一点关于<em class="lu">二叉树</em>的内容。你可能会认为二叉树是二元数学的一部分。但事实上，它只是一棵树，其中每个节点最多有2个值，因此被称为“二叉树”。二叉树在现实世界中有很多应用，但众所周知，它们用于解析编程语言语法和数学表达式。</p><p id="cda5" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">二叉树由<em class="lu">节点</em>组成。每个节点有两个值，我称之为左边的<em class="lu">和右边的</em>和<em class="lu">。</em>每个节点的左值或右值也可以是节点。为了评估一个节点，每个节点还应该知道它将使用其左右值执行的二元运算。因为每个节点都知道其子节点，所以我们只需引用树中的头节点。让我们用代码想象一下这个结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lv"><img src="../Images/ef2af092808d20c03bdf953854c857ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQ5zWcghNwxt8vVW80SVNw.png"/></div></div></figure><p id="c30a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如你所见，我们已经使用构造函数创建模式在代码中定义了二叉树的最小数据接口。现在，我们可以很容易地使用<code class="fe lw lx ly lz b">new</code>关键字来创建树或节点的实例。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lv"><img src="../Images/403920535b0fb3029becbd46383800ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iLOUrl07WluDFJpFonJZbw.png"/></div></div></figure><p id="6f89" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">同样值得注意的是，节点很容易专门化。我们可以定义自定义函数来创建已经知道其操作的节点，而不是通过<code class="fe lw lx ly lz b">new</code>来构造并传递操作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lv"><img src="../Images/e007bdd1a522b456d42d69e4dceed7fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3qYJjGvxi6NMXdSNgNbtfA.png"/></div></div></figure><p id="624c" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">采取这种方法是一个好主意。我们抽象掉了<code class="fe lw lx ly lz b">new</code>的使用(我个人并不喜欢)，并且我们通过抽象掉为构造函数提供操作符的需要，保持编程上的枯燥(不要重复自己)。当我们抽象掉不便之处时，让我们一起放弃使用<code class="fe lw lx ly lz b">new</code>创建二叉树的需要:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lv"><img src="../Images/67c5cb5d8f608e9486ea5ec64a67d3a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MH5NVh4d5KSfL7wgPtadmg.png"/></div></div></figure><p id="372a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">那里，干净而<code class="fe lw lx ly lz b">new</code>——自由。所以现在我们应该对二叉树所表示的数据结构有了牢固的理解。但是我们如何利用这些数据呢？我们建造这些树终究不是白建的。使用提供的算术示例，我们接下来需要做的是处理我们在树中构建的表达式。为此，我将在二叉树原型上定义一个名为<code class="fe lw lx ly lz b">collapse</code>的方法。<code class="fe lw lx ly lz b">collapse </code>函数将为我们提供一种递归地将任意复杂度的树简化为单个值的方法。这个函数是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lv"><img src="../Images/64b43a8eec8eb562ba25200115c4aa54.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zunLgdTcqqOXGJNhETJixA.png"/></div></div></figure><p id="099f" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">我们还必须定义一个助手函数来确定一个对象是否也是一个二叉树节点。让我们一步一步地完成折叠功能。</p><p id="8a71" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">首先我们定义一些东西——当且仅当<code class="fe lw lx ly lz b">node</code>没有被定义为参数时，我们设置<code class="fe lw lx ly lz b">node</code>等于二叉树的<code class="fe lw lx ly lz b">head</code>属性；我们为子节点的计算结果分配变量<code class="fe lw lx ly lz b">l</code>和<code class="fe lw lx ly lz b">r</code>来占用。</p><p id="0091" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">接下来是递归部分。使用我们定义的助手函数<code class="fe lw lx ly lz b">isNode</code>，我们确定<code class="fe lw lx ly lz b">l</code>或<code class="fe lw lx ly lz b">r</code>值是否是节点。如果是，那么我们开始向左遍历树。这意味着我们总是先访问节点的左分支，然后再访问右分支。我们通过调用collapse函数本身来实现这一点，并以所讨论的节点作为参数。一会儿我会解释更多关于递归的内容。</p><p id="9c7f" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">递归之后，我们决定是否必须设置我们的<code class="fe lw lx ly lz b">l</code>或<code class="fe lw lx ly lz b">r</code>值。如果我们没有设置它们，这意味着节点已经是一个终端值(在本例中是一个普通的数字)，所以我们不必减少它，因此我们可以使用原始的<code class="fe lw lx ly lz b">node.left</code>或<code class="fe lw lx ly lz b">.right</code>值。</p><p id="7986" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最后，我们可以使用我们最初的节点操作将<code class="fe lw lx ly lz b">l</code>和<code class="fe lw lx ly lz b">r</code>的值减少到一个结果。</p><p id="a2ea" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">现在谈谈递归。每当我们在函数内部调用一个函数时，我们都在利用递归。注意collapse在试图计算任何东西之前是如何检查节点的？这迫使它打开，但还没有返回，一个新的框架，你每下降一级树。把每个函数调用想象成一个图片框架，把每个递归调用想象成一个框架中的一个框架。对树的递归操作是深度优先的。在您点击第一个最左边的终端节点之前，没有任何东西能够返回。</p><p id="1e53" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">为了说明这一点，我用这篇文章的封面图片制作了一个表达式树。绿色数字是我们访问节点的顺序:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/2985065c3c9e40ca31c98366b5186fac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*41YzlgMUjBJcFkHc-rImNA.png"/></div></div></figure><p id="eb4f" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">原谅它的质量。这就是表情<code class="fe lw lx ly lz b">(10 - (2 * 2)) + (8 + (10 / 2))</code>。因为我们的函数走的是偏左的路径，所以我们可以画出它实际上是如何被手动解释的。</p><ol class=""><li id="d9a1" class="ma mb iq la b lb lc le lf lh mc ll md lp me lt mf mg mh mi bi translated">第一个端子左侧值为10。这不是一个节点，所以我们继续到正确的节点。</li><li id="f273" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">右边的值是一个节点，所以我们对它调用<code class="fe lw lx ly lz b">collapse</code>。我们首先访问终端左值2…</li><li id="f828" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">…然后是终端右值，也是2。</li><li id="369a" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">每个节点都知道它将执行什么操作。这是一个乘法节点，所以我们将它的左右值相乘。这是我们折叠的第一个节点，评估为4。</li><li id="ac5a" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">像我们的第四步，这是一个操作。我们用减法将10和减少后的4相加，得到6。</li><li id="b9b3" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">现在，我们移到根节点的右侧。我们遇到的第一个终值是8。然后，我们必须寻找正确的节点…</li><li id="9225" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">…这确实是一个节点。我们进入它，在左边遇到终值10。</li><li id="0d46" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">右边是一个2</li><li id="86ef" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">现在我们再次减少左边和右边，这次是通过除法，结果是5。</li><li id="a966" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">再一次，我们在一个操作符上，这次是加法。我们将终端8与缩减后的5相结合，得到13。</li><li id="b67c" class="ma mb iq la b lb mj le mk lh ml ll mm lp mn lt mf mg mh mi bi translated">最后，我们可以用缩减后的值6 + 13 = 19来完成对表达式的求值。</li></ol><p id="f8ed" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">下面是我们实现<code class="fe lw lx ly lz b">BinaryTree</code>后的树形图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lv"><img src="../Images/50f3e6f88cb466eaf79d1b69dfe11ee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CPGEOuYK8kt8ZDVdjwUwdw.png"/></div></div></figure><p id="bd27" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果我们调用<code class="fe lw lx ly lz b">tree.collapse()</code>,我们将以值19结束，正如我们通过手动遍历树所预期的那样。</p><p id="3a81" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">最后，我将留给我的读者一支笔来写:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="8c95" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">快乐的编码人们，记得保持你的代码功能！</p><p id="0e8e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae mq" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="la ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="la ir">！</strong></p></div></div>    
</body>
</html>