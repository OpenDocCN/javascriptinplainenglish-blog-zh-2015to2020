<html>
<head>
<title>Implementing GraphQL: A Journey to the Underworld</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">实现GraphQL:地下世界之旅</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implementing-graphql-a-journey-to-the-underworld-c6cbc2447710?source=collection_archive---------0-----------------------#2019-04-18">https://javascript.plainenglish.io/implementing-graphql-a-journey-to-the-underworld-c6cbc2447710?source=collection_archive---------0-----------------------#2019-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0284c5157b0fe476b5a72eb9930c0710.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*LTsEb_d9RGG6k38g"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@julianhochgesang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Julian Hochgesang</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e85f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您经常与数据库和API端点交互，您可能听说过GraphQL。但如果没有，这里有一个快速入门:</p><p id="261f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GraphQL既是一种描述如何请求数据的语法，也是一种实现从客户端到服务器的查询的运行时。由于GraphQL只是一个规范，它与特定的语言、库或平台无关，因此您可以在客户端使用它，也可以自己调用GraphQL服务器。所有实施的共同点如下:</p><ul class=""><li id="8dd0" class="lb lc iq kf b kg kh kk kl ko ld ks le kw lf la lg lh li lj bi translated">它只使用请求的数据来响应客户端的查询。</li><li id="559f" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">它可以将来自多个来源的数据压缩到一个端点。</li><li id="670e" class="lb lc iq kf b kg lk kk ll ko lm ks ln kw lo la lg lh li lj bi translated">它通过使用类型系统来验证数据。</li></ul><p id="7722" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那些受到传统REST APIs限制的人将接受GraphQL的灵活性，将应用与服务分离。GraphQL的单个“智能”端点可以接受复杂的查询，然后将数据输出转化为客户端需要的任何内容，而不是拥有多个“哑”端点。</p><p id="5bd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本质上，您可以将GraphQL视为一个在一个请求中调用许多嵌套端点的系统，模拟一个多路复用的REST端点。这意味着团队可以更高效地跨多个平台运输，对数据使用方式的可见性和控制达到前所未有的水平。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lp"><img src="../Images/6bfc9c583d37ee6e30d90f9b49c037aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DR4eHqEUQK9fqq5PonA1tQ.png"/></div></div></figure><p id="f8da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，GraphQL允许在没有状态管理库的情况下执行。当客户机可以指定它需要的来自服务器的状态的确切形状，并在单个请求中接收它时，就不太需要与那些库相关的所有额外代码了。</p><p id="a332" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，尽管GraphQL具有开创性，但其简单的语法和易用性可能并不像看起来那样简单:查询最终可能会执行各种不同的操作。GraphQL抽象出了数据库调用的各种底层功能，因此您所做的查询可能会出乎意料地变得计算密集型或资源密集型。</p><p id="a8fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，许多公司对从他们的REST平台转换到GraphQL持谨慎态度，并且实现GraphQL的程序员不确定哪些特定查询可能会成为他们应用程序的性能瓶颈。此外，GraphQL查询作为嵌套的JSON对象返回；很难理解不同嵌套数据项之间的关系。抽象的糖是有代价的！</p><p id="5a8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现有的工具确实提供了一些度量标准，让我们能够深入了解GraphQL查询。例如，<a class="ae kc" href="https://github.com/apollographql/apollo-engine-js" rel="noopener ugc nofollow" target="_blank"> Apollo Engine </a>通过其跟踪仓库(一个数据管道和存储层)提供对单个GraphQL的全面了解，该跟踪仓库捕获关于Apollo服务器处理的每个GraphQL操作的结构化信息，包括访问的特定字段集、使用每个字段的计时数据进行的解析器调用树，以及重要的元数据，如客户端身份和查询的模式版本。但是，它要求您使用Apollo构建自己的GraphQL服务器，并部署到他们的云上。这并不是对每个人都可行的解决方案。</p><p id="c534" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://github.com/facebook/dataloader" rel="noopener ugc nofollow" target="_blank"> DataLoader </a>是一个由脸书开发的批处理和缓存库，它可以最大限度地减少对数据库的请求数量(即使在单个查询中，由于它们的嵌套性质，请求数量也可能很大)，从而防止应用程序的性能受到影响。但是，虽然DataLoader确实有助于减少不必要的读取冗余，但它并没有向您显示指标。</p><p id="e056" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有各种不是专门为GraphQL构建的JSON可视化工具，但是它们可以帮助用户处理从查询返回的复杂数据。它们包括:<a class="ae kc" href="https://codebeautify.org/jsonviewer" rel="noopener ugc nofollow" target="_blank">代码美化</a>、<a class="ae kc" href="https://archive.codeplex.com" rel="noopener ugc nofollow" target="_blank"> CodePlex JsonViewer </a>或<a class="ae kc" href="https://marketplace.visualstudio.com/items?itemName=MykolaTarasyuk.JSONViewer" rel="noopener ugc nofollow" target="_blank"> Visual Studio JSON Viewer </a>。</p><p id="f98d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但到目前为止，还没有创建出易于设置的工具来处理GraphQL查询，向用户提供深入的查询分析。</p><p id="3a2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">进入<a class="ae kc" href="https://github.com/orpheus-gql/orpheus-dist" rel="noopener ugc nofollow" target="_blank"> Orpheus GQL </a>，这是我们开发的一个工具，它可以分解和说明查询的不同部分，以了解它们对应用程序的运行时和性能影响。Orpheus可以作为节点模块安装，它提供了查询成本分析(嵌套深度、解析器命中数、数据点、运行时间)，以及所提供查询中每个组件的成本的阳光可视化。更多关于俄耳甫斯的信息可以在<a class="ae kc" href="https://orpheusgql.com/" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</p><figure class="lq lr ls lt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/dbabc671a3d760954f53570eac4e54fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nyO_8EqeLU2h1F4r70cwtA.gif"/></div></div></figure><p id="9748" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它包含一个不可知的后端，足够灵活以适应关系和非关系数据库。所有需要做的就是安装Orpheus并提供您的GraphQL端点。Orpheus将作为带有GUI端点的GraphQL扩展提供，类似于graph QL的工作方式。</p><p id="0963" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，如果您可以避免使用REST而使用GraphQL，那么您应该这样做。切换将避开客户端状态管理中的大量复杂性，并将客户端代码的范围最小化为只需要在UI中呈现的数据。</p><p id="01d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在有一些工具可以让您深入了解GraphQL查询，减少数据库调用，并快速搭建GraphQL服务器，考虑进行这一转变的开发人员不仅可以从总体上更深入地了解GraphQL，还可以了解他们的特定查询、模式和解析器是如何操作的。那些已经使用GraphQL的人将从如何重新配置模式或数据库以优化应用性能的见解中受益。</p><p id="05db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有关GraphQL的更多信息，<a class="ae kc" href="https://graphql.org/" rel="noopener ugc nofollow" target="_blank">点击此处</a>。</p><p id="dd69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">特约作者:<br/><a class="ae kc" href="https://github.com/shaneallantaylor" rel="noopener ugc nofollow" target="_blank"/><a class="ae kc" href="https://github.com/tttaaannnggg" rel="noopener ugc nofollow" target="_blank">唐</a><a class="ae kc" href="https://github.com/wisdom161" rel="noopener ugc nofollow" target="_blank">智刘</a><a class="ae kc" href="https://github.com/nkchatterjee" rel="noopener ugc nofollow" target="_blank">妮莎</a></p></div></div>    
</body>
</html>