<html>
<head>
<title>Build your own REST API with Node, Express, Knex and PostgreSQL — part 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node、Express、Knex和PostgreSQL构建自己的REST API第3部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-your-own-rest-api-with-node-express-knex-and-postgresql-part-3-c1e904478bfa?source=collection_archive---------2-----------------------#2020-03-31">https://javascript.plainenglish.io/build-your-own-rest-api-with-node-express-knex-and-postgresql-part-3-c1e904478bfa?source=collection_archive---------2-----------------------#2020-03-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/342f695501cece11b4a0dc82ddc37ff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-VwEyZ5IQ1WPn_nAASpCvA.png"/></div></div></figure><p id="f76f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你是这个系列的新手，点击这里查看<a class="ae kw" href="https://medium.com/@fajardocj/build-your-own-rest-api-with-node-express-knex-and-postgresql-aec98fe75e5" rel="noopener">第一部分</a>和<a class="ae kw" href="https://medium.com/@fajardocj/build-your-own-rest-api-with-node-express-knex-and-postgresql-part-2-d9ff74f6f2fa" rel="noopener">第二部分</a>。到目前为止，我们已经处理了我们的数据库模式，但是我们在其他地方没有做太多，所以我们的api还没有真正做任何事情。让我们改变这一点。今天，我们将开始添加将成为API端点的路由。</p><h1 id="091c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">添加开发依赖项</h1><p id="665e" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们将开始对我们的API进行一些补充，所以每次我们添加一个更改时重新启动它将是一个很大的麻烦，所以我们将使用nodemon来解决这个问题。我们还增加了cors来处理来自任何地方的请求；以及chai、mocha和supertest来编写我们的测试。所以打开终端，输入:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f0f5" class="mj ky iq mf b gy mk ml l mm mn">npm i -D supertest mocha nodemon chai cors</span></pre><p id="19d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">D开关是<code class="fe mo mp mq mf b">--save-dev</code>的简写，它会将任何所需的依赖项添加到package.json文件的开发组中。现在，打开package.json文件，将以下内容添加到脚本部分，就在start之后:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4ff6" class="mj ky iq mf b gy mk ml l mm mn">"dev": "nodemon",<br/>"test": "(dropdb --if-exists api-server-test &amp;&amp; createdb api-server-test) &amp;&amp; NODE_ENV=test mocha --exit"</span></pre><p id="791d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不要忘记在start后面加一个逗号！</p><p id="713c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，在项目根目录下创建三个新文件夹，分别名为db、api和test:</p><h2 id="a54f" class="mj ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated">数据库文件夹:</h2><p id="ac6a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">db文件夹将包含我们数据库的附加配置，以及从其中检索数据所需的查询。在内部，创建一个名为knex.js的文件，其内容如下:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="f807" class="mj ky iq mf b gy mk ml l mm mn">const environment = process.env.NODE_ENV || 'development';<br/>const config = require('../knexfile');<br/>const environmentConfig = config[environment];<br/>const knex = require('knex');<br/>const connection = knex(environmentConfig);</span><span id="4e0c" class="mj ky iq mf b gy nc ml l mm mn">module.exports = connection;</span></pre><p id="82b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，仍然在db文件夹中，创建另一个名为dbqueries.js的文件，并将以下内容放入其中:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="3274" class="mj ky iq mf b gy mk ml l mm mn">const knex = require('./knex');</span><span id="77a4" class="mj ky iq mf b gy nc ml l mm mn">module.exports = {<br/>    getAll(table) {<br/>        return knex(table);<br/>    }<br/>}</span></pre><h2 id="b644" class="mj ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated">api文件夹:</h2><ul class=""><li id="991b" class="nd ne iq ka b kb lv kf lw kj nf kn ng kr nh kv ni nj nk nl bi translated">api文件夹将包含我们将使用的路线。在内部，创建三个名为users.js、posts.js和comments.js的文件。</li></ul><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="2746" class="mj ky iq mf b gy mk ml l mm mn">const express = require('express');<br/>const router = express.Router();<br/>const queries = require('../db/queries');</span><span id="a94a" class="mj ky iq mf b gy nc ml l mm mn">router.get('/', (req, res) =&gt; {<br/>    queries.getAll('users').then(users =&gt; {<br/>        res.json(users);<br/>    })<br/>});</span><span id="6e0d" class="mj ky iq mf b gy nc ml l mm mn">module.exports = router;</span></pre><p id="9f81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当然，在各自的文件中把<code class="fe mo mp mq mf b">posts</code>和<code class="fe mo mp mq mf b">comments</code>改成<code class="fe mo mp mq mf b">'users'</code>，注意引号。</p><h2 id="650b" class="mj ky iq bd kz mr ms dn ld mt mu dp lh kj mv mw ll kn mx my lp kr mz na lt nb bi translated">测试文件夹:</h2><ul class=""><li id="f4f5" class="nd ne iq ka b kb lv kf lw kj nf kn ng kr nh kv ni nj nk nl bi translated">测试文件夹将包含我们的，你用它，测试。在里面创建三个名为users.test.js、posts.test.js和comments.test.js的文件，暂时将它们留空。</li></ul><h1 id="2c66" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">app.js的最后润色</h1><p id="3cc0" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">回到你的app.js文件，在<code class="fe mo mp mq mf b">const app = express();</code>后的新一行添加<code class="fe mo mp mq mf b">const cors = require('cors');</code>。应该在文件的顶部附近。你可能还想把那些老派的<code class="fe mo mp mq mf b">var</code>改成<code class="fe mo mp mq mf b">const</code>来保持美观，但这并不是真正必要的。现在删除这两行:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="4d2d" class="mj ky iq mf b gy mk ml l mm mn">var indexRouter = require('./routes/index');<br/>var usersRouter = require('./routes/users');</span></pre><p id="9897" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将它们更改为:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="6eb0" class="mj ky iq mf b gy mk ml l mm mn">const users = require('./api/users');<br/>const posts = require('./api/posts');<br/>const comments = require('./api/comments');</span></pre><p id="11c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另外，添加cors来表示:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="c3a8" class="mj ky iq mf b gy mk ml l mm mn">app.use(cors());</span></pre><p id="9a0f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也不需要视图引擎或显示任何东西，所以删除这样的行</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="7948" class="mj ky iq mf b gy mk ml l mm mn">// view engine setup<br/>app.set('views', path.join(__dirname, 'views'));<br/>app.set('view engine', 'jade');</span></pre><p id="ad5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后将错误处理程序改为输出json，而不是在屏幕上绘制任何内容:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="949c" class="mj ky iq mf b gy mk ml l mm mn">app.use(function (err, req, res, next) {<br/>  res.status(err.status || 500);<br/>  res.json({<br/>    message: err.message,<br/>    error: res.locals.error = req.app.get('env') === 'development' ? err : {}<br/>  });<br/>});</span></pre><h1 id="ef1e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我们到底做了什么？</h1><p id="1474" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们做了一些改动，让我们来看看:</p><ul class=""><li id="1540" class="nd ne iq ka b kb kc kf kg kj nm kn nn kr no kv ni nj nk nl bi translated">knex.js文件是我们让knex知道它将在什么环境中工作的方式。当我们部署到Heroku时，我们会自动获得一个名为production的环境变量，它会被检测到。然后，我们导入knexfile并导出模块，以使一切可用。</li><li id="460d" class="nd ne iq ka b kb np kf nq kj nr kn ns kr nt kv ni nj nk nl bi translated">dbqueries文件是大部分数据库操作将要发生的地方，它将与我们的路由密切配合。我们需要从数据库中获取的任何东西都会在这里被请求，目前，我们只有一个简单的请求，相当于一个<code class="fe mo mp mq mf b">SELECT * FROM</code>查询。</li><li id="5ff7" class="nd ne iq ka b kb np kf nq kj nr kn ns kr nt kv ni nj nk nl bi translated">然后我们有我们的api文件夹。这个文件夹中的每个文件都对应于我们API中的一个端点，所以这意味着我们有<code class="fe mo mp mq mf b">/users</code>、<code class="fe mo mp mq mf b">/posts</code>和<code class="fe mo mp mq mf b">/comments</code>可用。我们将向它们添加更多的路由，但是现在，请注意我们是如何在顶部导入查询文件的？这就是我们访问查询的方式，也是我所说的dbqueries文件“与我们的路线紧密合作”的意思。然后，我们在每个路由的根级别上有一个简单的get操作，它从dbqueries文件执行查询，并返回json格式的结果。</li><li id="719e" class="nd ne iq ka b kb np kf nq kj nr kn ns kr nt kv ni nj nk nl bi translated">最后，我们设置app.js文件来使用我们的路线，并去掉预定义的路线。然后我们去掉了视图引擎，因为我们只需要它输出json，这就是为什么我们也修改了错误处理程序来这样做。最后，我们添加了cors。知道使用cors有潜在的危险是非常重要的，因为它允许来自任何地方的请求使用您的API。在现实世界中，您可以限制您的api仅响应来自特定IP的传入请求。其他的都应该忽略。同时，由于我们处于开发环境中，我们将坚持使用cors。</li></ul><h1 id="518d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">编写测试</h1><p id="d952" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这是拼图的最后一块。每当我们在api中添加新的功能时，我们都需要为它编写测试。我们写一个吧！</p><p id="6d63" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在你的<code class="fe mo mp mq mf b">test</code>文件夹中，创建一个<code class="fe mo mp mq mf b">users.test.js</code>文件。然后把这个贴在上面:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="15c7" class="mj ky iq mf b gy mk ml l mm mn">const request = require('supertest');<br/>const expect = require('chai').expect;<br/>const knex = require('../db/knex');<br/>const app = require('../app');</span></pre><p id="4dcf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们正在导入数据库文件和测试所需的任何依赖项。现在我们需要做的就是调用describe函数的第一个任务:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="055f" class="mj ky iq mf b gy mk ml l mm mn">describe('Testing users', () =&gt; {</span><span id="8163" class="mj ky iq mf b gy nc ml l mm mn">    before((done) =&gt; {<br/>        knex.migrate.latest()<br/>            .then(() =&gt; {<br/>                return knex.seed.run();<br/>            }).then(() =&gt; done())<br/>    });<br/>});</span></pre><p id="75f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将在我们每次运行测试时运行。如果您检查package.json文件，您可以看到其中有一行删除了测试数据库(如果它存在的话),并在我们每次运行测试时创建一个新的数据库。然后，我们的第一个动作是在测试数据库上运行迁移，然后播种它。</p><p id="288c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们的第一个测试将是检查我们是否真的得到了我们设定要交付的东西，所以我们将编写一个快速测试来检查我们在<code class="fe mo mp mq mf b">/users</code>路线上的根路径:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="8ef3" class="mj ky iq mf b gy mk ml l mm mn">it('Lists all users', (done) =&gt; {<br/>        request(app)<br/>            .get('/users')<br/>            .set('Accept', 'application/json')<br/>            .expect('Content-Type', /json/)<br/>            .expect(200)<br/>            .then((response) =&gt; {<br/>                expect(response.body).to.be.a('array');<br/>                done();<br/>            }).catch((e) =&gt; {<br/>                console.log(e);<br/>            });<br/>    });</span></pre><p id="12de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，它仍然在我们的<code class="fe mo mp mq mf b">describe</code>调用中，就在我们的第一个操作之后和最后一个右括号之前，所以它应该是这样的:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="a1ce" class="mj ky iq mf b gy mk ml l mm mn">describe('Testing users', () =&gt; {<br/>    before((done) =&gt; {<br/>        knex.migrate.latest()<br/>            .then(() =&gt; {<br/>                return knex.seed.run();<br/>            }).then(() =&gt; done())<br/>    });</span><span id="68b4" class="mj ky iq mf b gy nc ml l mm mn">    it('Lists all users', (done) =&gt; {<br/>        request(app)<br/>            .get('/users')<br/>            .set('Accept', 'application/json')<br/>            .expect('Content-Type', /json/)<br/>            .expect(200)<br/>            .then((response) =&gt; {<br/>                expect(response.body).to.be.a('array');<br/>                done();<br/>            }).catch((e) =&gt; {<br/>                console.log(e);<br/>            });<br/>    });<br/>});</span></pre><p id="012b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您需要做的就是运行<code class="fe mo mp mq mf b">npm test</code>，如果一切顺利，您应该会看到类似下面的内容:</p><pre class="ma mb mc md gt me mf mg mh aw mi bi"><span id="fc89" class="mj ky iq mf b gy mk ml l mm mn">&gt; api-tutorial@1.0.0 test /home/john/Development/post<br/>&gt; (dropdb --if-exists tutorial-test &amp;&amp; createdb tutorial-test) &amp;&amp; NODE_ENV=test mocha --exit</span><span id="31f4" class="mj ky iq mf b gy nc ml l mm mn">  Testing users<br/>GET /users 200 10.777 ms - 123<br/>    ✓ Lists all users (4ms)<br/></span><span id="2eed" class="mj ky iq mf b gy nc ml l mm mn">  1 passing (105ms)</span></pre><p id="e46f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果此时有问题，请尝试删除开发和测试数据库，然后再次运行测试。</p><p id="9cd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，回到控制台并输入<code class="fe mo mp mq mf b">nodemon</code>，然后启动postman并向<code class="fe mo mp mq mf b">http://localhost:3000/users</code>、<code class="fe mo mp mq mf b">http://localhost:3000/posts</code>和<code class="fe mo mp mq mf b">http://localhost:3000/comments</code>发出get请求。如果一切顺利，您应该会看到我们输入到json格式的种子文件中的数据。</p><p id="9703" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天就到这里吧！请继续关注<a class="ae kw" href="https://medium.com/swlh/build-your-own-rest-api-with-node-express-knex-and-postgresql-part-4-44205b1dc7f0" rel="noopener">下一部分</a>的新功能。</p></div></div>    
</body>
</html>