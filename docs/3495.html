<html>
<head>
<title>How to Properly Clone Objects in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中正确克隆对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-properly-clone-objects-in-javascript-bd7409474211?source=collection_archive---------3-----------------------#2020-10-04">https://javascript.plainenglish.io/how-to-properly-clone-objects-in-javascript-bd7409474211?source=collection_archive---------3-----------------------#2020-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5fde" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Object.assign()与object . getownpropertydescriptors()</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7d298bc3e42ffff13c77724ae29b69d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xZdhspP5mo27PQUn.jpg"/></div></div></figure><h2 id="0595" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">对象.分配()</h2><p id="daa9" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated"><strong class="lp ir">定义</strong></p><p id="d4e1" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><code class="fe ml mm mn mo b">Object.assign</code>方法是ECMAScript 2015 (ES6)引入的新功能之一。此方法将一个或多个源对象的值(所有可枚举的自身属性的值)复制到目标对象</p><p id="2dec" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">用例</strong></p><p id="857f" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">这对于合并对象或简单地克隆它们是有用的。</p><p id="5b5a" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">示例</strong></p><p id="9068" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><code class="fe ml mm mn mo b">Object.assign</code>方法对于合并对象很有用，因为目标对象中的属性会被源中的属性覆盖，如果它们具有相同的属性的话</p><p id="26fa" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">例如:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/3144f4aa83d3dcbb078c6e7e41c10aa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:348/format:webp/1*64LHrT_2ucob3_pQyP8rig.png"/></div></figure><p id="a615" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><code class="fe ml mm mn mo b">targetObj</code>具有以下特性:<code class="fe ml mm mn mo b">name</code>、<code class="fe ml mm mn mo b">value</code>、<code class="fe ml mm mn mo b">level</code></p><p id="810c" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">并且:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/d08c3607fd482d24656d25e70dc3ad8f.png" data-original-src="https://miro.medium.com/v2/resize:fit:362/format:webp/1*Vf_Muvt94z26BBIsZA0aTg.png"/></div></figure><p id="29ec" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><code class="fe ml mm mn mo b">sourceObj</code>具有以下属性:<code class="fe ml mm mn mo b">name</code>、<code class="fe ml mm mn mo b">value</code>、<code class="fe ml mm mn mo b">color</code>、<code class="fe ml mm mn mo b">strength</code>、<code class="fe ml mm mn mo b">overall</code></p><p id="4090" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">属性<code class="fe ml mm mn mo b">name</code>、<code class="fe ml mm mn mo b">value</code>是两个对象的公共属性；因此，<code class="fe ml mm mn mo b">targetObj</code>中的属性将被<code class="fe ml mm mn mo b">sourceObj</code>中的属性覆盖</p><pre class="kg kh ki kj gt mr mo ms mt aw mu bi"><span id="7b1c" class="kr ks iq mo b gy mv mw l mx my">Object.assign(targetObj, sourceObj);</span><span id="318d" class="kr ks iq mo b gy mz mw l mx my">console.log(targetObj);<br/>// OUTPUT</span><span id="efc2" class="kr ks iq mo b gy mz mw l mx my">{<br/>  name: 'sourceObj', // overwritten <br/>  value: 100, // overwritten<br/>  level: 5,<br/>  color: 'red',<br/>  strength: 'high',<br/>  overal: 6<br/>}</span></pre></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h2 id="c196" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">object . getownpropertydescriptors()</h2><p id="7db3" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated"><strong class="lp ir">定义</strong></p><p id="6374" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><code class="fe ml mm mn mo b">getOwnPropertyDescriptors</code>方法是ECMAScript 2017引入的新功能之一。该方法返回给定对象的所有属性的<strong class="lp ir">信息，包括关于<strong class="lp ir">获取器和设置器</strong>的信息</strong></p><p id="e15b" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">用例</strong></p><p id="acaa" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">它允许我们创建对象的副本，并在复制所有属性(包括getters和setters)的同时克隆它</p><p id="64c0" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><strong class="lp ir">示例</strong></p><p id="e411" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><code class="fe ml mm mn mo b">Object.getOwnPropertyDescriptors</code>返回给定对象的所有自身属性描述符，如<code class="fe ml mm mn mo b">value</code>、<code class="fe ml mm mn mo b">writable</code>、<code class="fe ml mm mn mo b">enumerable</code>、<code class="fe ml mm mn mo b">configurable</code></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kg kh ki kj gt mr mo ms mt aw mu bi"><span id="2cbe" class="kr ks iq mo b gy mv mw l mx my">{<br/>  <strong class="mo ir">name</strong>: { <strong class="mo ir">// NAME PROPERTY</strong><br/>    value: 'sourceObj',<br/>    writable: true,<br/>    enumerable: true,<br/>    configurable: true<br/>  },<br/>  <strong class="mo ir">value</strong>: { <strong class="mo ir">// VALUE PROPERTY</strong><br/>    value: 100, <br/>    writable: true, <br/>    enumerable: true, <br/>    configurable: true <br/>  },<br/>  <strong class="mo ir">color</strong>: { <strong class="mo ir">// COLOR PROPERTY</strong><br/>    value: 'red',<br/>    writable: true,<br/>    enumerable: true,<br/>    configurable: true<br/>  },<br/>  <strong class="mo ir">strength</strong>: { <strong class="mo ir">// STRENGTH PROPERTY</strong><br/>    value: 'high',<br/>    writable: true,<br/>    enumerable: true,<br/>    configurable: true<br/>  },<br/>  <strong class="mo ir">overall</strong>: { <strong class="mo ir">// OVERALL PROPERTY</strong><br/>   value: 6, <br/>   writable: true, <br/>   enumerable: true, <br/>   configurable: true <br/>  }<br/>}</span></pre><p id="1ab3" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><code class="fe ml mm mn mo b">Object.getOwnPropertyesDescriptors</code>返回<code class="fe ml mm mn mo b">sourceObj</code>的所有自己的属性描述符，我们需要使用<code class="fe ml mm mn mo b">Ojbect.defineProperties</code>在<code class="fe ml mm mn mo b">targetObj</code>上定义新的或修改现有的属性</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kg kh ki kj gt mr mo ms mt aw mu bi"><span id="c50f" class="kr ks iq mo b gy mv mw l mx my">{<br/>  name: 'sourceObj',<br/>  value: 100,<br/>  level: 5,<br/>  color: 'red',<br/>  strength: 'high',<br/>  overall: 6<br/>}</span></pre><p id="cec5" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">其工作原理与<code class="fe ml mm mn mo b">Object.assign()</code>相同。常用属性如<code class="fe ml mm mn mo b">name</code>、<code class="fe ml mm mn mo b">value</code>被<code class="fe ml mm mn mo b">sourceObj</code>的属性覆盖，其他属性从<code class="fe ml mm mn mo b">sourceObj</code>复制</p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h2 id="e62f" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">Object.assign()的限制</h2><p id="e65c" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated"><code class="fe ml mm mn mo b">Object.assign()</code>方法只是将源对象中的<em class="nj">可枚举</em>和<em class="nj">自身属性</em> <strong class="lp ir"> <em class="nj"> </em> </strong>复制到目标对象中。它在源上使用<strong class="lp ir"> [[Get]] </strong>，在目标上使用<strong class="lp ir"> [[Set]] </strong>，因此它将调用<code class="fe ml mm mn mo b">getters</code>和<code class="fe ml mm mn mo b">setters</code></p><p id="1b79" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">因此，它<em class="nj">分配</em>属性，而不是复制或定义新属性。如果合并源包含<strong class="lp ir"> getters </strong>，那么<strong class="lp ir">可能不适合</strong>将新属性合并到原型中</p><p id="18f9" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">举个例子，</p><p id="b35e" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">给定一个对象，它有<code class="fe ml mm mn mo b">getters</code>和<code class="fe ml mm mn mo b">setters</code></p><pre class="kg kh ki kj gt mr mo ms mt aw mu bi"><span id="51e4" class="kr ks iq mo b gy mv mw l mx my">const obj = {</span><span id="590f" class="kr ks iq mo b gy mz mw l mx my"> name: 'Ben',</span><span id="c18a" class="kr ks iq mo b gy mz mw l mx my"> type: 'reptilian',</span><span id="dc0a" class="kr ks iq mo b gy mz mw l mx my"> get fullName(){ <strong class="mo ir">// getters</strong></span><span id="33db" class="kr ks iq mo b gy mz mw l mx my">  return `${this.name}${this.type}`;</span><span id="c478" class="kr ks iq mo b gy mz mw l mx my"> },</span><span id="9d6d" class="kr ks iq mo b gy mz mw l mx my"> set gatorName(name){  <strong class="mo ir">// setters</strong></span><span id="8336" class="kr ks iq mo b gy mz mw l mx my">  this.name = name;</span><span id="7b1b" class="kr ks iq mo b gy mz mw l mx my"> }</span><span id="4174" class="kr ks iq mo b gy mz mw l mx my">};</span></pre><p id="2642" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated"><code class="fe ml mm mn mo b">Object.assign</code>返回<strong class="lp ir">值</strong>而不是<strong class="lp ir"> getter </strong>函数</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kg kh ki kj gt mr mo ms mt aw mu bi"><span id="5c14" class="kr ks iq mo b gy mv mw l mx my">{<br/><strong class="mo ir">  value: 'Benreptilian',</strong><br/>  writable: true,<br/>  enumerable: true,<br/>  configurable: true<br/>}</span></pre><p id="b0e5" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">鉴于<code class="fe ml mm mn mo b">Object.getOwnPropertyDescriptors</code>返回<strong class="lp ir">吸气器</strong>功能正确</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><pre class="kg kh ki kj gt mr mo ms mt aw mu bi"><span id="bd37" class="kr ks iq mo b gy mv mw l mx my">{<br/><strong class="mo ir">  get: [Function: get fullName],</strong><br/>  set: undefined,<br/>  enumerable: true,<br/>  configurable: true<br/>}</span></pre><p id="3195" class="pw-post-body-paragraph ln lo iq lp b lq mg jr ls lt mh ju lv la mi lx ly le mj ma mb li mk md me mf ij bi translated">同样，<code class="fe ml mm mn mo b">Object.assign()</code>在源上自动使用使用<strong class="lp ir"> [[Get]] </strong>，在目标上自动使用<strong class="lp ir"> [[Set]] </strong>，因此它将调用<code class="fe ml mm mn mo b">getters</code>和<code class="fe ml mm mn mo b">setters</code></p></div><div class="ab cl na nb hu nc" role="separator"><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf ng"/><span class="nd bw bk ne nf"/></div><div class="ij ik il im in"><h2 id="cbff" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h2><p id="09a7" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated">为了将属性定义(包括它们的可枚举性)复制到原型中，使用<code class="fe ml mm mn mo b">Object.getOwnPropertyDescriptor()</code>和<code class="fe ml mm mn mo b">Object.defineProperty()</code>而不是<code class="fe ml mm mn mo b">Object.assign()</code>。如果源对象包含<strong class="lp ir"/>getter，则<code class="fe ml mm mn mo b">Object.assign()</code>不适用。</p><h2 id="b746" class="kr ks iq bd kt ku kv dn kw kx ky dp kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">TL；速度三角形定位法(dead reckoning)</h2><p id="c1ac" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv la lw lx ly le lz ma mb li mc md me mf ij bi translated"><code class="fe ml mm mn mo b">getOwnPropertyDescriptors</code>方法有助于避免数据丢失，使用它我们可以创建对象的<strong class="lp ir">深层副本，而无需依赖另一个实用函数</strong></p></div></div>    
</body>
</html>