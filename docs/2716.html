<html>
<head>
<title>Importance of JavaScript Array methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript数组方法的重要性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/importance-of-javascript-array-methods-61cca3469380?source=collection_archive---------2-----------------------#2020-07-17">https://javascript.plainenglish.io/importance-of-javascript-array-methods-61cca3469380?source=collection_archive---------2-----------------------#2020-07-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2b83" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">学习JavaScript中数组方法的重要功能和概念</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d583187c8dbcf68506ae8728c09dc8fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hChV9eA3TBPWhyGttvbMdA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by Arif Riyanto on Unsplash</figcaption></figure><p id="b9ed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天我们将了解每个开发人员都必须知道的数组的重要功能。首先让我们了解一点数组。数组只不过是元素的集合，它包含许多内置的属性和方法来解决任何任务。现在让我们深入正题。</p><ul class=""><li id="69ef" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">一些()</li><li id="d525" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">每隔()</li><li id="157a" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">扁平()</li><li id="7ee8" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">过滤器()</li><li id="1e7c" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">forEach()</li><li id="3de4" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">findIndex()</li><li id="99cf" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">查找()</li><li id="1b56" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">排序()</li><li id="a6a1" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">concat()</li><li id="133f" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">平面地图()</li></ul></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="6712" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">一些()</h1><p id="ae90" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated"><strong class="kx ir"> some() </strong>方法用于测试数组中至少有一个元素通过了由<strong class="kx ir">回调</strong>函数实现的测试。当使用参数执行<strong class="kx ir">回调</strong>函数时，可以为<strong class="kx ir">这个</strong>赋值。</p><p id="f651" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="590c" class="no mn iq nk b gy np nq l nr ns">arr.some(callback(element[, index[, array]])[, thisArg])</span></pre><p id="6dfd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">示例:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="f0ec" class="no mn iq nk b gy np nq l nr ns">const a = [1, 2, 3, 5, 8].some(item =&gt; item &gt; 5)<br/>const b = [1, 2, 3, 4, 5].some(item =&gt; item &gt; 5)<br/><br/>console.log(a)<br/>console.log(b)<br/><br/><br/>---------<br/>Output<br/>---------<br/>&gt; true<br/>&gt; false</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="8087" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">每隔()</h1><p id="5057" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated"><strong class="kx ir"> every() </strong>方法类似于<strong class="kx ir"> some() </strong>方法。它测试数组中的所有元素是否通过了由<strong class="kx ir">回调</strong>函数实现的测试。</p><p id="f106" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="a38c" class="no mn iq nk b gy np nq l nr ns">arr.every(callback(element[, index[, array]])[, thisArg])</span></pre><p id="0152" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">示例:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="daf2" class="no mn iq nk b gy np nq l nr ns">const a = [10, 9, 8, 7, 6].every(item =&gt; item &gt; 5)<br/>const b = [7, 6, 5].every(item =&gt; item &gt; 5)<br/><br/>console.log(a)<br/>console.log(b)<br/><br/><br/>---------<br/>Output<br/>---------<br/>&gt; true<br/>&gt; false</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="2e7b" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">扁平()</h1><p id="11ed" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated"><strong class="kx ir"> flat() </strong>方法用于创建一个新数组，所有的子数组都连接到其中。默认情况下，平坦级别始终设置为级别1。</p><p id="073d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="c47f" class="no mn iq nk b gy np nq l nr ns">arr.flat([depth])</span></pre><p id="f579" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">示例:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="dd52" class="no mn iq nk b gy np nq l nr ns">const arr1 = [1, 2, [3, 4]]<br/>console.log(arr1.flat())<br/><br/>const arr2 = [1, 2, [3, 4, [5, 6]]]<br/>console.log(arr2.flat())<br/><br/>const arr3 = [1, 2, [3, 4, [5, 6]]]<br/>console.log(arr3.flat(2))<br/><br/>const arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]]<br/>console.log(arr4.flat(Infinity))<br/><br/>---------<br/>Output<br/>---------<br/>&gt; (4) [1, 2, 3, 4]<br/>&gt; (5) [1, 2, 3, 4, Array(2)]<br/>&gt; (6) [1, 2, 3, 4, 5, 6]<br/>&gt; (10) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></pre><p id="cb3b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请注意，如果您想要重复执行，请将<strong class="kx ir"> infinity </strong>值作为参数传递给它。</p></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="65cf" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">过滤器()</h1><p id="81eb" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated"><strong class="kx ir"> filter() </strong>方法也用于创建一个新数组，所有元素都通过测试，由<strong class="kx ir">回调</strong>函数实现。</p><p id="ac89" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="341f" class="no mn iq nk b gy np nq l nr ns">arr.filter(callback(element[, index, [array]])[, thisArg])</span></pre><p id="31c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">示例:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="7c04" class="no mn iq nk b gy np nq l nr ns">const array = [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]<br/><br/>function isPrime(num) {<br/>  for (let i = 2; num &gt; i; i++) {<br/>    if (num % i == 0) {<br/>      return false<br/>    }<br/>  }<br/>  return num &gt; 1<br/>}<br/><br/>console.log(array.filter(isPrime))<br/><br/>---------<br/>Output<br/>---------<br/>&gt; (6) [2, 3, 5, 7, 11, 13]</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="a031" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">ForEach()</h1><p id="4b27" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated"><strong class="kx ir"> forEach() </strong>方法用于对每个数组元素只执行一次提供的方法。</p><p id="a20d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="d393" class="no mn iq nk b gy np nq l nr ns">arr.forEach(callback(currentValue [, index [, array]])[, thisArg])</span></pre><p id="6a1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">示例:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="9003" class="no mn iq nk b gy np nq l nr ns">const array = [1, 2, 3, 4, 5]<br/>array.forEach((item) =&gt; console.log(item))<br/><br/>---------<br/>Output<br/>---------<br/>1<br/>2<br/>3<br/>4<br/>5</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="b855" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">Findindex()</h1><p id="c205" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated"><strong class="kx ir"> findindex() </strong>方法用于返回回调函数提供的数组中第一个元素的索引。当没有元素传入测试时，它总是返回-1。即使索引没有赋值，<strong class="kx ir"> findindex () </strong>方法也会执行<strong class="kx ir">回调</strong>函数。</p><p id="5145" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="03e4" class="no mn iq nk b gy np nq l nr ns">arr.findIndex(callback( element[, index[, array]] )[, thisArg])</span></pre><p id="45b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">示例:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="f7cc" class="no mn iq nk b gy np nq l nr ns">function isPrime(num) {<br/>  for (let i = 2; num &gt; i; i++) {<br/>    if (num % i == 0) {<br/>      return false<br/>    }<br/>  }<br/>  return num &gt; 1<br/>}<br/><br/>console.log([4, 6, 8, 9, 12].findIndex(isPrime))<br/>console.log([4, 6, 7, 9, 12].findIndex(isPrime))<br/><br/>---------<br/>Output<br/>---------<br/>-1<br/>2</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="3388" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">查找()</h1><p id="d800" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated"><strong class="kx ir"> find() </strong>方法也类似于<strong class="kx ir"> findindex() </strong>方法。不同之处在于它返回由<strong class="kx ir">回调</strong>函数提供的第一个元素的值。如果没有元素满足<strong class="kx ir">回调</strong>函数，则返回undefined。</p><p id="e5e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="14ed" class="no mn iq nk b gy np nq l nr ns">arr.find(callback(element[, index[, array]])[, thisArg])</span></pre><p id="5615" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">示例:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="6e86" class="no mn iq nk b gy np nq l nr ns">const inventory = [<br/>  {name: 'apples', quantity: 2},<br/>  {name: 'bananas', quantity: 0},<br/>  {name: 'cherries', quantity: 5}<br/>]<br/><br/>const result = inventory.find( ({ name }) =&gt; name === 'cherries' )<br/><br/>console.log(result)<br/><br/><br/>---------<br/>Output<br/>---------<br/>&gt; {name: "cherries", quantity: 5}</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="5641" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">排序()</h1><p id="fb8b" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated"><strong class="kx ir"> sort() </strong>方法用于将数组元素排序到正确的位置，并返回排序后的数组。默认排序始终是升序。这种方法的复杂性和性能不是恒定的。这取决于实现。</p><p id="4de8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="7d0c" class="no mn iq nk b gy np nq l nr ns">arr.sort([compareFunction])</span></pre><p id="0bbb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">示例:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="5f58" class="no mn iq nk b gy np nq l nr ns">const numbers = [4, 2, 5, 1, 3]<br/>const numbers2 = numbers.sort((a, b) =&gt; a - b)<br/><br/>console.log('numbers', numbers)<br/>console.log('numbers2', numbers2)<br/>console.log(numbers === numbers2)<br/><br/>---------<br/>Output<br/>---------<br/>numbers &gt; (5) [1, 2, 3, 4, 5]<br/>numbers2 &gt; (5) [1, 2, 3, 4, 5]<br/>true</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="25c7" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">Concat()</h1><p id="0d99" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">concat()方法用于将两个或多个数组连接到一个新数组中。</p><p id="e81c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="89d4" class="no mn iq nk b gy np nq l nr ns">const new_array = old_array.concat([value1[, value2[, ...[, valueN]]]])</span></pre><p id="5735" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">示例:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="45b8" class="no mn iq nk b gy np nq l nr ns">const letters = ['a', 'b', 'c']<br/>const numbers = [1, 2, 3]<br/><br/>console.log(letters.concat(numbers))<br/><br/>---------<br/>Output<br/>---------<br/>&gt; (6) ["a", "b", "c", 1, 2, 3]</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="1a3e" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">平面图()</h1><p id="0371" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated"><strong class="kx ir"> flatmap() </strong>方法用于对数组中的每个元素应用一个函数，并将平坦的结果返回到数组中。它将<strong class="kx ir"> flat() </strong>和<strong class="kx ir"> map() </strong>结合在一个功能中。</p><p id="7691" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="0d87" class="no mn iq nk b gy np nq l nr ns">arr.flatMap(callback(currentValue[, index[, array]])[, thisArg])</span></pre><p id="a5af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">示例:</p><pre class="kg kh ki kj gt nj nk nl nm aw nn bi"><span id="c842" class="no mn iq nk b gy np nq l nr ns">const array = [[1], [2], [3], [4], [5]]<br/><br/>const a = array.flatMap(arr =&gt; arr * 10)<br/><br/><br/>// With .flat() and .map()<br/>const b = array.flat().map(arr =&gt; arr * 10)<br/><br/>console.log('flatMap', a)<br/>console.log('flat&amp;map', b)<br/><br/>---------<br/>Output<br/>---------<br/>flatMap (5) [10, 20, 30, 40, 50]<br/>flat&amp;map (5) [10, 20, 30, 40, 50]</span></pre></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="70ed" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">结论</h1><p id="6926" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">我希望你喜欢这个故事，并且知道一些关于JavaScript数组方法的新知识。一般来说，JavaScript数组包含一些很好的方法来简化我们的工作。通过了解这些概念，它将提高我们项目的性能。</p><p id="c2a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">谢谢你的阅读！</p></div></div>    
</body>
</html>