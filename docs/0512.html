<html>
<head>
<title>React Native Dark Mode and Theming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应自然黑暗模式和主题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-dark-mode-and-theming-dc299bec206d?source=collection_archive---------0-----------------------#2019-11-01">https://javascript.plainenglish.io/react-native-dark-mode-and-theming-dc299bec206d?source=collection_archive---------0-----------------------#2019-11-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="42cb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">iOS中新的黑暗模式让我兴奋不已。我可以使用所有我喜欢的应用程序，但现在它们都变暗了😎。好吧，没那么令人兴奋，但我认为对许多人来说，只是演示文稿的变化就令人耳目一新。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/dd0fb3d39ae924c32d3160a380d529a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8tUA-mpXYG-iSr7XFtiw7A.jpeg"/></div></div></figure><p id="28e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我不得不立即对我们工作中的应用程序进行一些修改，我也开始思考如何将这一特性推广到我自己的应用程序中。自然地，当谈到颜色(或色彩)时，它们都遵循相似的模式🙄)和主题化。</p><p id="b9fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将讲述我提出的主题化和黑暗模式的方法和设置，以及如何调整它，使用户在你的应用程序中定制他们的体验更加多样化。</p><h1 id="2668" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">当前设置</h1><p id="31bc" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">目前，我们将颜色和主题集中在一个地方。为了这篇文章，我将只讨论颜色，但是当然主题化可以并且可能应该包含<code class="fe lx ly lz ma b">spacing</code>、<code class="fe lx ly lz ma b">font</code>、<code class="fe lx ly lz ma b">icon</code> …任何你想要在你的应用程序中保持一定一致性的东西。</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="664c" class="mf kv in ma b gy mg mh l mi mj">/src<br/>-- /theme/index.js</span></pre><p id="1ff7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在根处，我们有我们的<code class="fe lx ly lz ma b">theme</code>。这是我们存储颜色的地方(以及你想在应用范围内使用的所有东西)。这是一个例子。</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="aa09" class="mf kv in ma b gy mg mh l mi mj">// theme/index.js</span><span id="9e27" class="mf kv in ma b gy mk mh l mi mj">const palette = {<br/>  palette01: '#000000',<br/>  palette02: 'rgba(255,255,255,1)',<br/>}</span><span id="abb8" class="mf kv in ma b gy mk mh l mi mj">export const colors = {<br/>  paragraphText: palette.palette01,<br/>  buttonPrimaryBg: palette.palette02,<br/>  headingText: palette.palette01,<br/>}</span></pre><p id="2e14" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ml">为什么要拆分调色板和颜色？</em>好问题。这样，我们就可以通过使用案例在更精细的层次上定义颜色，并从调色板中重复使用。这确保了我们不会产生50种灰度😏。当然，我们最终会在所有颜色中重复使用调色板，但这实际上并不重要，这也是重点。这也意味着在主题化的时候，我们可以单独改变调色板或者颜色(或者两者都改变，如果我们愿意的话)。</p><p id="9893" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只是一个简单的例子来说明它们是如何被清晰地使用的；</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="1ed0" class="mf kv in ma b gy mg mh l mi mj">// ButtonPrimary/index.js</span><span id="455c" class="mf kv in ma b gy mk mh l mi mj">...</span><span id="84cc" class="mf kv in ma b gy mk mh l mi mj">import { colors } from 'theme'</span><span id="b4e3" class="mf kv in ma b gy mk mh l mi mj">const ButtonPrimary = ({ onPress, children }) =&gt; (<br/>  &lt;TouchableOpacity onPress={onPress} style={styles}&gt;<br/>    {children}<br/>  &lt;/TouchableOpacity&gt;<br/>)</span><span id="5f0c" class="mf kv in ma b gy mk mh l mi mj">const styles = {<br/>  backgroundColor: colors.buttonPrimaryBg,<br/>}</span><span id="ba97" class="mf kv in ma b gy mk mh l mi mj">export default ButtonPrimary</span></pre><p id="ac2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里没有什么令人兴奋的事情发生，但是我们确实把主题从组件本身中分离出来了。很好的开始。</p><h1 id="8225" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">黑暗模式</h1><p id="6403" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">黑暗模式是这篇短文的主题，是iOS独有的，但也有其他主题/UI影响Android的设置，如夜间模式。我想这在未来会变得更加普遍，不管用户对<em class="ml">设备</em>的偏好如何，这种相同的想法都可以用来改变用户的内部设置。</p><p id="e705" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你像我一样正在使用<a class="ae mm" href="https://docs.expo.io/versions/latest/" rel="noopener ugc nofollow" target="_blank"> Expo </a>(我真的很喜欢它…但是下次会有更多关于它的内容)，那么你可以使用<code class="fe lx ly lz ma b"><a class="ae mm" href="https://www.npmjs.com/package/react-native-appearance" rel="noopener ugc nofollow" target="_blank">react-native-appearance</a></code>来倾听用户的设备偏好。这目前仅适用于iOS，不考虑Android，但根据这里的文档；</p><blockquote class="mn mo mp"><p id="1d4b" class="jk jl ml jm b jn jo jp jq jr js jt ju mq jw jx jy mr ka kb kc ms ke kf kg kh ig bi translated"><code class="fe lx ly lz ma b">Appearance</code> API可能会在<code class="fe lx ly lz ma b">react-native@&gt;=0.61</code>发布</p></blockquote><p id="03c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以这应该为我们将来的使用做好准备。如果你没有使用Expo，还有其他的模块，比如<code class="fe lx ly lz ma b"><a class="ae mm" href="https://www.npmjs.com/package/react-native-dark-mode" rel="noopener ugc nofollow" target="_blank">react-native-dark-mode</a></code>也采用了类似的方法。</p><p id="9b1f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe lx ly lz ma b">react-native-appearance</code>为我们提供了几种处理用户偏好的方法，但对我来说最直接和实用的似乎是<a class="ae mm" href="https://www.npmjs.com/package/react-native-appearance#usage" rel="noopener ugc nofollow" target="_blank">挂钩</a>。</p><p id="e431" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ml">我不打算深入研究如何使用钩子，但是我推荐你</em> <a class="ae mm" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> <em class="ml">花点时间阅读一下它们</em> </a> <em class="ml">。他们太棒了。</em></p><p id="eb24" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里是正在使用的<code class="fe lx ly lz ma b">react-native-appearance</code>钩子，直接取出文档；</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="b758" class="mf kv in ma b gy mg mh l mi mj">...</span><span id="78fb" class="mf kv in ma b gy mk mh l mi mj">import { useColorScheme } from 'react-native-appearance'</span><span id="3216" class="mf kv in ma b gy mk mh l mi mj">function MyComponent() {</span><span id="57fc" class="mf kv in ma b gy mk mh l mi mj">  let colorScheme <strong class="ma io">=</strong> useColorScheme()</span><span id="5849" class="mf kv in ma b gy mk mh l mi mj"><strong class="ma io">  if</strong> (colorScheme <strong class="ma io">===</strong> 'dark') {</span><span id="a561" class="mf kv in ma b gy mk mh l mi mj"><em class="ml">   // render some dark thing</em></span><span id="451a" class="mf kv in ma b gy mk mh l mi mj">  } <strong class="ma io">else</strong> {</span><span id="6e5a" class="mf kv in ma b gy mk mh l mi mj"><em class="ml">  // render some light thing</em></span><span id="d8aa" class="mf kv in ma b gy mk mh l mi mj">  }</span><span id="4c33" class="mf kv in ma b gy mk mh l mi mj">}</span></pre><p id="edc7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，如果我们以之前的例子为例，我们可以这样做:</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="c1d5" class="mf kv in ma b gy mg mh l mi mj">// ButtonPrimary/index.js</span><span id="9b17" class="mf kv in ma b gy mk mh l mi mj">import { useColorScheme } from 'react-native-appearance'<br/>import { colors } from 'theme'</span><span id="d79a" class="mf kv in ma b gy mk mh l mi mj">const ButtonPrimary = ({ onPress, children }) =&gt; { <br/>const colorScheme = useColorScheme()<br/>  return (<br/>    &lt;TouchableOpacity <br/>      onPress={onPress} <br/>      style={{ <br/>        backgroundColor: colorScheme === 'dark' <br/>          ? colors.buttonPrimaryBgDark <br/>          : colors.buttonPrimaryBg <br/>      }}<br/>    &gt;<br/>      {children}<br/>    &lt;/TouchableOpacity&gt;<br/>  )</span><span id="9d15" class="mf kv in ma b gy mk mh l mi mj">export default ButtonPrimary</span></pre><p id="7066" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我的意思是……会有用的。但是它的可读性不是很好，所有关于选择颜色的逻辑现在都在我们的组件和我们可能想要影响的其他组件中，这些组件可能是最具代表性的组件。</p><p id="83a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以不实用。但是很容易解决。</p><p id="bf5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我将创建我自己的挂钩，它将使用和<code class="fe lx ly lz ma b">useColorScheme</code>挂钩，并返回我的<em class="ml">主题</em>颜色。如果我需要的话，它还可以返回配色方案。这将意味着对我之前写的<code class="fe lx ly lz ma b">colors</code>对象做一些改动，但不会太大。先看那个；</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="e961" class="mf kv in ma b gy mg mh l mi mj">// theme/index.js</span><span id="d074" class="mf kv in ma b gy mk mh l mi mj">const palette = {<br/>  palette01: '#000000',<br/>  palette02: 'rgba(255,255,255,1)',<br/>}</span><span id="1beb" class="mf kv in ma b gy mk mh l mi mj">export const colors = {<br/>  paragraphText: palette.palette01,<br/>  buttonPrimaryBg: palette.palette02,<br/>  headingText: palette.palette01,<br/>}</span><span id="9be7" class="mf kv in ma b gy mk mh l mi mj">export const themedColors = {<br/>  default: {<br/>    ...colors,<br/>  },<br/>  light: {<br/>    ...colors,<br/>  },<br/>  dark: {<br/>    ...colors,<br/>    buttonPrimaryBg: palette.palette01,<br/>    paragraphText: palette.palette02,<br/>  },<br/>}</span></pre><p id="a2a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">同样，这里没有什么太令人兴奋的事情发生——只是添加了一个新的对象<code class="fe lx ly lz ma b">themedColors</code>这是我们将进行主题化的地方。<code class="fe lx ly lz ma b">light</code>和<code class="fe lx ly lz ma b">default</code>此刻正在做同样的事情，简单地在原始颜色集中展开，但是<code class="fe lx ly lz ma b">dark</code>现在用一个特定主题集覆盖了一些原始颜色(注意<code class="fe lx ly lz ma b">dark</code>和<code class="fe lx ly lz ma b">light</code>的颜色现在是如何反转的)。</p><p id="1084" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在轮到钩子了。</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="4051" class="mf kv in ma b gy mg mh l mi mj">// theme/hooks.js</span><span id="8dc8" class="mf kv in ma b gy mk mh l mi mj">import { useColorScheme } from 'react-native-appearance'</span><span id="685b" class="mf kv in ma b gy mk mh l mi mj">import { themedColors } from '.'</span><span id="3483" class="mf kv in ma b gy mk mh l mi mj">export const useTheme = () =&gt; {<br/>  const theme = useColorScheme()</span><span id="3063" class="mf kv in ma b gy mk mh l mi mj">  const colors = theme ? themedColors[theme] : themedColors.default</span><span id="0317" class="mf kv in ma b gy mk mh l mi mj">  return {<br/>    colors,<br/>    theme,<br/>  }<br/>}</span></pre><p id="2592" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们从我们的定制挂钩返回颜色和主题。<code class="fe lx ly lz ma b">colors</code>将被分配给用户偏好的主题(如果可用)，如果没有选择或定义，则返回到<code class="fe lx ly lz ma b">default</code>。</p><p id="1c7c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个钩子的用法变得与我们最初的<code class="fe lx ly lz ma b">ButtonPrimary</code>实现惊人地相似。</p><pre class="kj kk kl km gt mb ma mc md aw me bi"><span id="0924" class="mf kv in ma b gy mg mh l mi mj">// ButtonPrimary/index.js</span><span id="20ad" class="mf kv in ma b gy mk mh l mi mj">...</span><span id="c6a5" class="mf kv in ma b gy mk mh l mi mj">import { useTheme } from 'theme/hooks'</span><span id="0afc" class="mf kv in ma b gy mk mh l mi mj">const ButtonPrimary = ({ onPress, children }) =&gt; {<br/>  const { colors } = useTheme()<br/>  return (<br/>    &lt;TouchableOpacity <br/>      onPress={onPress} <br/>      style={{ <br/>        backgroundColor: colors.buttonPrimaryBg <br/>      }}<br/>    &gt;<br/>      {children}<br/>    &lt;/TouchableOpacity&gt;<br/>  )<br/>}</span><span id="be5c" class="mf kv in ma b gy mk mh l mi mj">export default ButtonPrimary</span></pre><p id="989f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要做的就是导入定制的挂钩，并从那里解构颜色，而不是直接从我们的主题🎉</p><p id="65e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于整个应用程序的大规模部署，这是可扩展和可管理的。</p><h1 id="f650" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">不利方面</h1><p id="35bc" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">总是有一个…我们不得不写我们的颜色风格，这有点令人失望。如果你需要的话，你仍然可以扩展你的其他风格，但是这会让它变得稍微有点混乱。在我看来，这是一个很好的权衡主题风格。</p><h1 id="94d8" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">扩展示例</h1><p id="2b5c" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">这只是显示了如何使用用户设备设置，它只限于iOS。您可以相对容易地扩展挂钩以包含来自用户的设置，这意味着用户可以决定他们的应用内设置来覆盖设备设置。</p></div></div>    
</body>
</html>