<html>
<head>
<title>Angular: Dependency Injection vs. Static methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度:依赖注入与静态方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-dependency-injection-vs-static-methods-2191fc08e078?source=collection_archive---------0-----------------------#2020-11-21">https://javascript.plainenglish.io/angular-dependency-injection-vs-static-methods-2191fc08e078?source=collection_archive---------0-----------------------#2020-11-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2001a7a460d5583a65f1eca10efe9420.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rUGd9y3H5kmXfahm"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@diesektion?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Robert Anasch</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dbf9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在日常生活中，问题往往源于选择。我们经营一项活动的机会越多，就越难选择。这也发生在开发过程中，今天我们比以往任何时候都有许多工具可以让我们以不同的方式获得相同的结果。</p><p id="3057" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天，我们将快速解释何时以及为什么对静态类使用依赖注入。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="bd87" class="lf lg in bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated"><strong class="ak">依赖性注射液</strong></h2><p id="cb4b" class="pw-post-body-paragraph ka kb in kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">依赖注入(DI)是一种重要的应用程序设计模式。【Angular有自己的DI框架。特别是一种编码模式，在这种模式下，一个类向外部源请求依赖，而不是自己创建依赖。</p><p id="94a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请记住，当我们谈论依赖关系时，我们指的是类执行其功能所需的服务或对象。</p><p id="da62" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="md">提示:</em></p><p id="0b06" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Angular团队建议您在多个文件中分离组件和服务。</p><p id="ef4a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是为什么它可能令人困惑，因为如果您选择将所有内容压缩在一个文件中，如果您不想陷入运行时空引用错误，您必须在组件之前定义服务。</p><p id="957c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">按照使用Angular CLI生成新的“MagicianService”类的命令，路径为“src/app/magic”。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="af61" class="lf lg in mj b gy mn mo l mp mq">ng generate service magic/magician</span></pre><p id="70c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">为什么选择依赖注射？</strong></p><p id="a0f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">依赖注入框架不能做任何大多数开发人员还不熟悉的事情。</p><p id="fa5b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，主要目标是通过注入依赖关系而不是直接在组件中实例化依赖关系来避免紧密耦合的组件。<br/>所以，分离服务和组件，最后一种更灵活，因为您可以将不同的实现注入到同一个组件中。</p><p id="a5b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">事实上，直接投资的一个非常有用的特性是令牌。</p><p id="12bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注入令牌是Angular的一个特性，它提供了一种机制来将令牌链接到一个值，并将该值注入到一个组件中。</p><p id="3682" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">注意……</strong></p><p id="000f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Angular开发人员的典型行为是在AppModule(根模块)中记录所有的提供者。这很有用，因为通过这种方式，所有组件都可以访问服务的同一个实例，从而创建一个Singleton。</p><blockquote class="mr ms mt"><p id="5139" class="ka kb md kc b kd ke kf kg kh ki kj kk mu km kn ko mv kq kr ks mw ku kv kw kx ig bi translated">服务是注射器范围内的单个项目</p></blockquote><p id="00af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://angular.io/guide/singleton-services" rel="noopener ugc nofollow" target="_blank">文档</a>中的这句话是什么意思？</p><p id="cff1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在根模块中记录所有提供程序会产生同步组件效果，即如果某个组件更改了服务中的某个属性，所有其他组件都可以访问该属性的相同值。</p><p id="daf0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">但</strong> …</p><p id="b93c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您在不同的子模块中两次实例化同一个服务时会发生什么？</p><p id="3dde" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，特定子模块下的所有组件将具有相同的服务和所有值属性。然而，这与注入到另一个子模块中的服务完全无关，从而失去了跨应用程序的同步效果，仅将其保持在子模块分支中。</p><h2 id="7478" class="lf lg in bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated">为什么是静态方法类？</h2><p id="f836" class="pw-post-body-paragraph ka kb in kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">具体来说:</p><ul class=""><li id="72e0" class="mx my in kc b kd ke kh ki kl mz kp na kt nb kx nc nd ne nf bi translated">仅仅是一个功能吗？</li><li id="2d81" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">它没有依赖关系吗？</li><li id="e352" class="mx my in kc b kd ng kh nh kl ni kp nj kt nk kx nc nd ne nf bi translated">你希望它是纯洁的吗？</li></ul><p id="3457" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这些简单的情况下，您应该使用静态类。</p><p id="c6ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">深陷</strong></p><p id="5c87" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与实例方法不同，类的静态方法在类本身上是可见的，它们不是类的实例。</p><p id="d41b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常，当我们谈论静态方法时，它从参数中获取输入，对其执行操作，并独立于您的应用程序返回结果。</p><p id="1ebb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我说的是utils函数，这是一个对所有应用程序都有用的会话服务，以及所有那些不关心执行情况的情况。</p><p id="2573" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，静态方法对性能没有任何影响，调用它们也不会实例化该类。</p><p id="dc95" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看一下这个用法的例子</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0ec2" class="lf lg in mj b gy mn mo l mp mq">import { MagicianService } from '../services/magic/magician.service';</span><span id="a977" class="lf lg in mj b gy nl mo l mp mq">export class PerformanceComponent {</span><span id="7bc4" class="lf lg in mj b gy nl mo l mp mq">   constructor() {<br/>      // Note that I didn't inject the service or instantiated it like new MagicianService()<br/>      const bunniesNumber = MagicianService.getBunniesNumber(1,5);<br/>      <br/>      console.log(bunniesNumber); // =&gt; 3</span><span id="799f" class="lf lg in mj b gy nl mo l mp mq">   }</span></pre><p id="9d59" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">你应该考虑的事情</strong></p><p id="77b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们把一个方法赋给类函数本身和它的“原型”时，静态方法中的<strong class="kc io"> this </strong>的值就是类构造函数本身。</p><p id="0f43" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看一个例子</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4296" class="lf lg in mj b gy mn mo l mp mq">export class SessionService {</span><span id="eccf" class="lf lg in mj b gy nl mo l mp mq">   static test() {<br/>      alert(this === SessionService);<br/>   }</span><span id="61df" class="lf lg in mj b gy nl mo l mp mq">}</span></pre><p id="e30d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您调用“test”方法，警报将打印“true”。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="05b8" class="lf lg in mj b gy mn mo l mp mq">SessionService.test(); // =&gt; true</span></pre><h2 id="086d" class="lf lg in bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated">结论</h2><p id="1a79" class="pw-post-body-paragraph ka kb in kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">选择哪种方式是最好的总是很困难的。</p><p id="0519" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们应该一个案例一个案例地分析，但是作为一个主要的规则，建议如果一个方法变得越来越复杂并且依赖是必要的，那么你最好通过依赖注入来开始你的代码。</p><p id="b9e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相反，如果你的函数保持简单，它不必知道你的业务逻辑的一部分，并且属于类而不是任何特定的对象，你应该使用静态方法和属性。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="0f39" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你喜欢这篇文章，请按👏想按多少次就按多少次。另外，如果你有任何问题，请随时提问。</p><p id="e82b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">非常感谢你的阅读！</p><p id="6643" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="md">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="md">plain English . io</em></strong></a></p></div></div>    
</body>
</html>