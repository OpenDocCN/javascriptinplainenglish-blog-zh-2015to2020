<html>
<head>
<title>Power of RxJS schedulers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJS调度程序的能力</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/power-of-rxjs-schedulers-951bb1deb8d0?source=collection_archive---------1-----------------------#2020-11-27">https://javascript.plainenglish.io/power-of-rxjs-schedulers-951bb1deb8d0?source=collection_archive---------1-----------------------#2020-11-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/53553e4c4e877da337a5c29ef4f95101.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DRizYI6EqPpBJj_6"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@contentpixie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Content Pixie</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="235f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你对RxJS中的调度器了解多少？他们对开发人员隐藏了Observable的执行上下文。就像《哈利·波特》中的家养小精灵，他们在霍格沃茨做所有的粗活，甚至没有人听说过他们。让我们解决这个问题，并进一步了解他们。</p><h1 id="1970" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是调度程序？</h1><blockquote class="lw lx ly"><p id="a490" class="ka kb lz kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated"><em class="in">一个</em> <code class="fe md me mf mg b"><em class="in">Scheduler</em></code> <em class="in">让你定义一个</em> <code class="fe md me mf mg b"><em class="in">Observable</em></code> <em class="in">在什么执行上下文中向它的</em> <code class="fe md me mf mg b"><em class="in">Observer</em></code> <em class="in">发送通知。</em></p></blockquote><p id="ee26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">换句话说，一个<code class="fe md me mf mg b">Scheduler</code>在<code class="fe md me mf mg b">Observable</code>中管理操作的顺序和执行时间。下面的例子将帮助我们理解它是如何工作的。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="1dcf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，代码是同步执行的。但是如果我们希望<code class="fe md me mf mg b">Observable</code>异步运行，我们需要添加带有特殊<code class="fe md me mf mg b">Scheduler</code>的<code class="fe md me mf mg b">observeOn</code>操作符。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="00fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在<code class="fe md me mf mg b">Observable</code>异步提供数据。酷毙了。就好像我们把它包装在<code class="fe md me mf mg b">setTimeout</code>函数里，不是吗？顺便说一下，我们在代码中使用了<code class="fe md me mf mg b">asyncScheduler</code>。这是传说中的调度之一。</p><h1 id="f2c6" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">调度程序类型</h1><p id="4536" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">您需要知道JavaScript中的事件循环是如何工作的，以便理解调度器的强大功能。可以用<a class="ae jz" href="https://youtu.be/8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank">这个视频</a>来刷新一下你的知识。</p><p id="c9a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总之，浏览器有自己的代码执行顺序:</p><ol class=""><li id="8434" class="ms mt in kc b kd ke kh ki kl mu kp mv kt mw kx mx my mz na bi translated">同步代码(调用堆栈)</li><li id="278a" class="ms mt in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated">微任务队列(承诺)</li><li id="0f98" class="ms mt in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated">宏任务队列(setTimeout、setInterval、XMLHttpRequest等。).</li><li id="d153" class="ms mt in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated">在下一次浏览器重画之前要执行的代码队列(requestAnimationFrame)</li></ol><p id="a3eb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">RxJS对这些项目都有一个<code class="fe md me mf mg b">Scheduler</code>:</p><ul class=""><li id="eadc" class="ms mt in kc b kd ke kh ki kl mu kp mv kt mw kx ng my mz na bi translated"><code class="fe md me mf mg b">queueScheduler</code>同步执行任务</li><li id="b75a" class="ms mt in kc b kd nb kh nc kl nd kp ne kt nf kx ng my mz na bi translated"><code class="fe md me mf mg b">asapScheduler</code>微任务队列中的计划</li><li id="21e5" class="ms mt in kc b kd nb kh nc kl nd kp ne kt nf kx ng my mz na bi translated"><code class="fe md me mf mg b">asyncScheduler</code>宏任务队列中的调度</li><li id="854f" class="ms mt in kc b kd nb kh nc kl nd kp ne kt nf kx ng my mz na bi translated"><code class="fe md me mf mg b">animationFrameScheduler</code>在下一次浏览器重画之前，在要执行的代码队列上进行调度</li></ul><p id="f512" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还有<code class="fe md me mf mg b">VirtualTimeScheduler</code>和<code class="fe md me mf mg b">TestScheduler</code>，用于测试。点击阅读相关内容<a class="ae jz" href="https://medium.com/angular-in-depth/so-what-is-rxjs-virtualtimescheduler-796e92ed722f" rel="noopener">。</a></p><p id="8754" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看一下下面的代码。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="450e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如你所见，<code class="fe md me mf mg b">“queueScheduler”</code>同步工作，因为它在<code class="fe md me mf mg b">“synchronous code”</code>之前。并且<code class="fe md me mf mg b">“asapScheduler”</code>出现在<code class="fe md me mf mg b">“asyncScheduler“</code>之前，因为它使用了微任务队列。</p><h1 id="b9e8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">如何使用调度程序？</h1><p id="901f" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">您可以使用带有<code class="fe md me mf mg b"><strong class="kc io">observeOn</strong></code>和<code class="fe md me mf mg b"><strong class="kc io">subscribeOn</strong></code>操作符的调度程序。两者都接受第一个参数<code class="fe md me mf mg b">Scheduler</code>，第二个参数<code class="fe md me mf mg b">delay</code>，默认为零。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><blockquote class="lw lx ly"><p id="db97" class="ka kb lz kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated"><em class="in">使用</em> <code class="fe md me mf mg b"><em class="in">subscribeOn</em></code> <em class="in">来调度</em> <code class="fe md me mf mg b"><em class="in">subscribe()</em></code> <em class="in">调用会在什么上下文中发生。<br/>使用</em> <code class="fe md me mf mg b"><em class="in">observeOn</em></code> <em class="in">来安排在什么上下文中发送通知。</em></p></blockquote><p id="5cd3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有趣的事实——无论您使用什么，<code class="fe md me mf mg b">Scheduler</code>都会以大于零的延迟回落到<code class="fe md me mf mg b"><strong class="kc io">asyncScheduler</strong></code>。遵循代码是没有用的。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="040c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在RxJS 6.5.0之前，您可以为<code class="fe md me mf mg b">of</code>、<code class="fe md me mf mg b">from</code>、<code class="fe md me mf mg b">merge</code>、<code class="fe md me mf mg b">range</code>等添加一个调度器作为第二个参数。在RxJS的新版本中，这种行为已被否决，您应该使用<code class="fe md me mf mg b"><strong class="kc io">scheduled</strong></code>函数来实现这一点。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><h1 id="d015" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">调度程序用例</h1><p id="17f5" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">在处理RxJS时，我们通常不会考虑调度程序，因为库作者在抽象这种逻辑方面做得很好。但是有些时候使用<code class="fe md me mf mg b">Scheduler</code>会有帮助，你应该为此做好准备。</p><p id="2d1e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，如果我们需要用<code class="fe md me mf mg b">Observable</code>制作流畅的动画，我们应该使用<code class="fe md me mf mg b"><strong class="kc io">animationFrameScheduler</strong></code>。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="b250" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我还有一个来自我的实践的例子。我不得不为不同的<code class="fe md me mf mg b"><em class="lz">id</em></code>请求开发缓存。我写了这样一个函数:</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="f678" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个代码是有效的。但是有一个问题。第一次使用我的函数时，它异步返回值，第二次同步返回值。</p><p id="7360" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于消费者来说，一个功能的行为如此不可预测，这是一个悲剧。不幸的是，我发布了<a class="ae jz" href="https://medium.com/@bluepnume/intentionally-unleashing-zalgo-with-promises-ab3f63ead2fd" rel="noopener"> Zalgo </a>🔥。</p><p id="5f39" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们添加带有<code class="fe md me mf mg b">asyncScheduler</code>的<code class="fe md me mf mg b">scheduled</code>函数来修复这个问题。</p><figure class="mh mi mj mk gt jo"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="59d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">伟大的扎尔戈被放逐了。是啊。</p><h1 id="7fc3" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="c21d" class="pw-post-body-paragraph ka kb in kc b kd mn kf kg kh mo kj kk kl mp kn ko kp mq kr ks kt mr kv kw kx ig bi translated">调度器控制可观察操作的时间和顺序执行。四分之一的RxJS操作员在引擎盖下使用它们。最有可能的是，关于它们的知识在实践中没有帮助。但是你永远不知道调度程序什么时候会派上用场。</p><p id="7053" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我很想听听你对调度的经验。感谢关注！</p></div></div>    
</body>
</html>