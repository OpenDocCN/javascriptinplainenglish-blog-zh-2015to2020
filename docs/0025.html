<html>
<head>
<title>Understanding ‘this’ in Javascript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解Javascript中的“this”</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/hello-javascript-this-bb97c54f0823?source=collection_archive---------2-----------------------#2018-08-15">https://javascript.plainenglish.io/hello-javascript-this-bb97c54f0823?source=collection_archive---------2-----------------------#2018-08-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="dc22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你是一名Javascript开发人员，你可能会在某些时候对使用'<strong class="jm io"> this </strong>'感到困惑。</p><p id="e59a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">大多数开发人员仍然无法掌握<code class="fe ki kj kk kl b"><strong class="jm io">this</strong></code>的用法。原因是<code class="fe ki kj kk kl b"><strong class="jm io">this</strong></code>的动态性质和它改变其上下文的方式。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/7eba012220e089e460bc00b634325533.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8s5GX3dnlw8z7KYDWNmCwg.jpeg"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">“I can see ‘this’ in your eyes, I can see ‘this’ in your smile…”</figcaption></figure><p id="5b06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">今天，我们要看看<code class="fe ki kj kk kl b"><strong class="jm io">this</strong></code>到底是什么，以及我们为什么需要它。其次是<code class="fe ki kj kk kl b"><strong class="jm io">this</strong></code>的相关概念。</p><p id="bd27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“<code class="fe ki kj kk kl b"><strong class="jm io">this</strong></code>”如其所言指向Javascript在其上下文中的当前值。Javascript基于作用域、函数和上下文。Javascript是一种动态脚本语言。这种动态的行为使得它的行为也不一样，这导致了所有的混乱。</p><p id="d939" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当您想要访问函数或上下文中的值时，您可以使用<code class="fe ki kj kk kl b">this</code>。<code class="fe ki kj kk kl b">this</code>'在不同的上下文中表现不同:</p><h1 id="447d" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">1.全球背景</h1><p id="fe5c" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">在全局范围内定义的任何东西都可以被<code class="fe ki kj kk kl b"><strong class="jm io">this</strong></code>访问。默认情况下，<code class="fe ki kj kk kl b"><strong class="jm io">this</strong></code>总是指全局对象(因此，如果您正在为浏览器编写代码，<code class="fe ki kj kk kl b"><strong class="jm io">this</strong></code>通常会是<code class="fe ki kj kk kl b"><strong class="jm io">window</strong></code> <strong class="jm io"> </strong>对象)。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mf"><img src="../Images/39adab630145c23f6810a154f69502a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8M88d4FR238mPpRarZh9JQ.png"/></div></div><figcaption class="ky kz gj gh gi la lb bd b be z dk">Unsure what ‘strict mode’ is? Do a quick Google search :)</figcaption></figure><h1 id="1cec" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">2.功能上下文</h1><p id="e168" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">在函数中，<code class="fe ki kj kk kl b"><strong class="jm io">this</strong></code>将默认为全局对象，在浏览器中是<code class="fe ki kj kk kl b"><strong class="jm io">window</strong></code>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mg"><img src="../Images/2b89e25e9ddff50b7acbb36a4b1330fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kso6ii-lcMmI9nnlRUaXLg.png"/></div></div></figure><p id="e55a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里值得注意的是，如果我们尝试<code class="fe ki kj kk kl b"><strong class="jm io">console.log(color)</strong></code>，它将返回<code class="fe ki kj kk kl b"><strong class="jm io">blue</strong></code></p><h1 id="38c2" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">3.对象上下文</h1><p id="9a30" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated"><code class="fe ki kj kk kl b"><strong class="jm io">this</strong></code>在一个对象中的‘始终’指向该对象，并按照您所期望的那样工作:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mh"><img src="../Images/e4827028ba24b5bc5e7a86b5813785a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4KUzzQhhnKv0i5jnAFQgQ.png"/></div></div></figure><p id="e14f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对象的神奇之处在于，您可以将对象(以及它们的方法——当它在对象内部时，我们称之为函数)作为参数传递给函数。所以这里我们把<code class="fe ki kj kk kl b">obj.getColor()</code>传入<code class="fe ki kj kk kl b">console.log</code>。</p><h2 id="d4d8" class="mi ld in bd le mj mk dn li ml mm dp lm jv mn mo lq jz mp mq lu kd mr ms ly mt bi translated"><strong class="ak"> <em class="mu">谓()</em> </strong></h2><p id="23d5" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated"><code class="fe ki kj kk kl b">call()</code>通过将<code class="fe ki kj kk kl b">obj</code>对象作为第一个参数来改变<code class="fe ki kj kk kl b">this</code>的上下文。如果什么都没有传递，那么<code class="fe ki kj kk kl b">call()</code>将指向窗口的范围。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mv"><img src="../Images/2a5b9cf75d0238d9831f80eb71477336.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sDJ7AyGcyHR5lPZF4PoApQ.png"/></div></div></figure><h2 id="99db" class="mi ld in bd le mj mk dn li ml mm dp lm jv mn mo lq jz mp mq lu kd mr ms ly mt bi translated"><strong class="ak"> <em class="mu">敷()</em> </strong></h2><p id="bca5" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated"><code class="fe ki kj kk kl b">apply()</code>通过将<code class="fe ki kj kk kl b">obj</code>对象作为第一个参数来改变上下文。如果没有传递任何东西，那么apply()将指向窗口的范围。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mw"><img src="../Images/8694a485091781bfb74bea2617af039a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kmv1ahAOPKfLBQF5pvzl1A.png"/></div></div></figure><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mx"><img src="../Images/76efb20af7843cb65bb018a3b9dc7fab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BK2Dju6NoiRXl-af-kOGRA.png"/></div></div></figure><h2 id="07ec" class="mi ld in bd le mj mk dn li ml mm dp lm jv mn mo lq jz mp mq lu kd mr ms ly mt bi translated"><strong class="ak"> <em class="mu"> bind() </em> </strong></h2><p id="54cc" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated"><code class="fe ki kj kk kl b">bind()</code>也有助于改变“<code class="fe ki kj kk kl b">this</code>的上下文，但是<code class="fe ki kj kk kl b">call()</code>、<code class="fe ki kj kk kl b">apply()</code>和<code class="fe ki kj kk kl b">bind()</code>的区别在于<code class="fe ki kj kk kl b">bind()</code>只工作一次，它不执行该功能。它只是<strong class="jm io">将</strong>与<code class="fe ki kj kk kl b">this</code>绑定在一起。</p><p id="4c5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">call()</code>和<code class="fe ki kj kk kl b"> apply()</code>的区别在于<code class="fe ki kj kk kl b">apply()</code>期望参数作为一个数组，而<code class="fe ki kj kk kl b">call()</code>期望单个参数。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi my"><img src="../Images/0077a7f7869b5e7a036fff450f071aaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R86M1NUnIQJu5P8LrOXd_w.png"/></div></div></figure><h1 id="c1ca" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">4.构造器</h1><p id="a15f" class="pw-post-body-paragraph jk jl in jm b jn ma jp jq jr mb jt ju jv mc jx jy jz md kb kc kd me kf kg kh ig bi translated">当您创建一个函数实例时，<code class="fe ki kj kk kl b">this</code>的上下文移动到新创建的实例。在下面的例子中，<code class="fe ki kj kk kl b">this</code>的上下文指向新创建的实例<code class="fe ki kj kk kl b">var o</code>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi mx"><img src="../Images/b2ba0d8722dbd59b7e6b15fd72c53970.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DEyegk6faflAMx-f20z0eg.png"/></div></div></figure><h1 id="88ea" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">summary/TL；速度三角形定位法(dead reckoning)</h1><ol class=""><li id="fda6" class="mz na in jm b jn ma jr mb jv nb jz nc kd nd kh ne nf ng nh bi translated">在函数和全局作用域中,“this”总是指向窗口。尽管在严格模式或Nodejs下这种情况会发生变化。</li><li id="e0f3" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated">在Object中，它仅指向对象的上下文</li><li id="0712" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated">在构造函数中，它指向新创建的实例。</li><li id="a68e" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated">我们可以通过使用call()、apply()和bind()来改变上下文</li><li id="1ee4" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated">如果您只是绑定上下文，而不想执行函数，那么使用bind()。永远记住bind()只工作一次</li><li id="ada6" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated">如果您想将一个参数数组传递给它，那么您可以使用apply()。否则，请使用call()。</li><li id="5090" class="mz na in jm b jn ni jr nj jv nk jz nl kd nm kh ne nf ng nh bi translated">它的美妙之处在于它的动态特性，它会随着您运行它的环境而变化。</li></ol><p id="9ff0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们希望您发现这很有用！如果是这样，请留下一些掌声，关注JSIPE并与您所有的朋友、家人和宠物分享！👫 👨‍👨‍👧‍👧 🐶</p></div></div>    
</body>
</html>