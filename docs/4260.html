<html>
<head>
<title>An Introduction to Bottom-Up Dynamic Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自底向上动态编程导论</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/an-introduction-to-bottom-up-dynamic-programming-992fa2a8c11f?source=collection_archive---------4-----------------------#2020-11-29">https://javascript.plainenglish.io/an-introduction-to-bottom-up-dynamic-programming-992fa2a8c11f?source=collection_archive---------4-----------------------#2020-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="91e4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对递归不自信？别担心——下面是如何用自下而上的方法解决DP问题的指南。</h2></div><p id="a0c6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">动态编程</strong> ( <strong class="kh ir"> DP </strong>)是个搞笑的名词。这样命名是为了避免<a class="ae lb" href="https://en.wikipedia.org/wiki/Dynamic_programming#History" rel="noopener ugc nofollow" target="_blank">激怒前国防部长</a>，这个名字一直沿用至今。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/06835bdf4778b0d539bd403c134241fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wvCQnMaOoxqZvGiz"/></div></div></figure><p id="6b1b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本质上，它没有什么动态。DP可以简单地归类为一种算法策略，其中将单个问题分解为子问题。通过解决每个子问题，算法越来越接近解决原问题。在解决了所有的子问题之后，就找到了原问题的答案。</p><p id="fbe5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有经验的读者很可能会认为这个定义非常接近于递归的概念——的确如此，大多数采用DP解决方案的问题都可以用递归来解决。</p><p id="02f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，出于本文的目的，我们将研究一下<strong class="kh ir">自底向上的动态编程</strong> ( <strong class="kh ir"> BUDP </strong>)，它不一定使用递归。在彻底检查完手头的主题后，我们将使用BUDP解决问题<a class="ae lb" href="https://leetcode.com/problems/minimum-path-sum/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">最小路径和</strong> </a>，并使用几个说明性的图来完成。</p><h1 id="beac" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">快速浏览一下这个问题</h1><p id="9cba" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在深入BUDP之前，让我们分解一下<a class="ae lb" href="https://leetcode.com/problems/minimum-path-sum/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">最小路径和</strong> </a>问题。我们现在就这样做，因为对BUDP是什么以及它如何工作的解释将取决于使用这个问题作为例子。</p><p id="35f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题描述如下:</p><blockquote class="ml mm mn"><p id="7efb" class="kf kg mo kh b ki kj jr kk kl km ju kn mp kp kq kr mq kt ku kv mr kx ky kz la ij bi translated">给定一个填充了非负数的<code class="fe ms mt mu mv b">m x n</code> <code class="fe ms mt mu mv b">grid</code>，找出一条从左上到右下的路径，使沿其路径的所有数字之和最小。</p><p id="49a6" class="kf kg mo kh b ki kj jr kk kl km ju kn mp kp kq kr mq kt ku kv mr kx ky kz la ij bi translated"><strong class="kh ir">注意:</strong>在任何时间点你只能向下或向右移动。</p></blockquote><p id="6c6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以，我们有一个网格，这是一个像<code class="fe ms mt mu mv b">[[1,3,1], [1,5,1], [4,2,1]]</code>一样的二维数组。它看起来会像这样，取决于<code class="fe ms mt mu mv b">m &amp;&amp; n</code>的大小:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/604edc007faf4da9f154a38a129098f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*N9HZUoCyw64ZAEoMAHfUvQ.png"/></div></figure><p id="f370" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这张图片中，蓝色方块代表在<strong class="kh ir">最小路径</strong>中的方块。这就把我们带到了下一个相关的问题:最小路径是什么？</p><p id="cb89" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此题中的最小路径是从左上(第一个索引)到右下(最后一个索引)的<strong class="kh ir">最小</strong>T5】累加和。当我们在网格中移动时，我们需要通过<strong class="kh ir">添加</strong> <strong class="kh ir">一个先前的元素</strong>(一个数字)到当前的方块来将方块连接成路径。</p><p id="b2a0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就引出了下一个问题:我们如何穿越网格？根据问题的描述，我们只能下移或右移。因此，我们可以选择的路径仅限于两个方向:向下或向右。</p><p id="7119" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可以看到，这个例子中的最小路径是从<code class="fe ms mt mu mv b">1 -&gt; 3 -&gt; 1 -&gt; 1 -&gt; 1</code>开始，加起来就是<code class="fe ms mt mu mv b">7</code>。所有其他可能的路径都大于<code class="fe ms mt mu mv b">7</code>(继续，试着数出来)。</p><p id="aa35" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们到了一个有趣的问题:我们如何解决这个问题？让我们通过BUDP了解一下。</p><h1 id="961c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">BUDP是什么？</h1><p id="978a" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">首先解释使用DP解决了什么问题是很重要的。</p><p id="2b4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，发现DP问题相当容易。DP问题是需要找到<strong class="kh ir">约简</strong>或<strong class="kh ir">累积</strong>答案的问题。</p><p id="ef76" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们当前的例子中，我们正在寻找一个简化的答案。我们正在寻找<strong class="kh ir">最小的可能路径</strong>，因此我们需要找到具有最小总和的最后一个索引的路径。</p><p id="685e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">减少/积累问题非常适合动态规划的原因是动态规划采用解决子问题的策略来解决整体问题。在这类问题中，我们需要迭代整个输入(通常是一个矩阵)来寻找答案，因为在寻找答案时必须考虑整个输入。</p><p id="a03a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，在我们当前的例子中，我们将需要找到到达矩阵末端的最小可能路径。这意味着我们需要检查每个元素，并为其解决一个子问题。然而，我们需要从某个地方开始。</p><p id="3bc6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们真正定义动态编程的<strong class="kh ir">自底向上</strong>风格的地方。采用自下而上的策略，我们从起点开始，解决子问题，直到到达终点。一旦我们到达终点并计算了所有的子问题，整个问题的答案应该是显而易见的。这是因为累积的子问题是用来计算整体问题的最终答案的。</p><p id="c7b3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们把这种思维方式运用到例题中:这道题中的子题是什么？</p><p id="a0eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">子问题反映了总体问题:不同之处在于，我们需要找到通向矩阵中任意给定索引集<strong class="kh ir">的最小路径，而不是找到通向最终索引的最小路径。对于这个策略，这意味着我们需要遍历整个矩阵。通过将矩阵中的每个元素视为整体问题的一个微小子问题，我们可以使用<strong class="kh ir">累积解</strong>来计算<strong class="kh ir">整体解</strong>。</strong></p><blockquote class="ml mm mn"><p id="cf7b" class="kf kg mo kh b ki kj jr kk kl km ju kn mp kp kq kr mq kt ku kv mr kx ky kz la ij bi translated">注意:如果这没有意义也没关系——下一节包括巩固子问题用法概念的图表。</p></blockquote><p id="0158" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">至此，我们对BUDP有了足够的了解，可以用最小路径和问题来实践它。</p><h1 id="d914" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">将BUDP应用于最小路径和</h1><p id="fdbd" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">在本节的剩余部分，我们将使用下图来说明BUDP的用法:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/5bc180adf4472be67422e9850f170ef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*OefMb8S-C6lMd1gelDEuWg.png"/></div></figure><p id="b8c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个矩阵表示<code class="fe ms mt mu mv b">[[1,3,1], [1,5,1], [4,2,1]]</code>的输入数组。</p><p id="e0d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将只用图表来解决这个问题。然后，我们将写出代码来实现我们的解决方案。</p><p id="8413" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经确定，使用BUDP，我们从输入的开始处开始，一直到末尾，这是它的最终索引。我们还确定我们将需要遍历整个输入数组，因为我们将需要考虑所有的数字，以便确信我们最终达到了最小路径和。所以，让我们突出第一个元素，<code class="fe ms mt mu mv b">1</code>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/852a2842b2b1135cdf7dab597f5c9f61.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*-l7mvZpgG40sK-tc3IywlA.png"/></div></figure><p id="fcfc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们来解决这个索引处的子问题，就是:这个索引处的最小路径和<strong class="kh ir">是多少？因为我们在第一个索引处，我们的路径必然从这里开始。所以，我们把它作为<code class="fe ms mt mu mv b">1</code>，因为这是在这个索引中唯一可能的路径和。迭代到第二个元素<code class="fe ms mt mu mv b">3</code>。</strong></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/8ce66fbb50af0c60322f471100703aeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*VcNC5PCZZUC07JyKvF7-tg.png"/></div></figure><p id="9f56" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个指数的最小路径和是多少？我们必须考虑一条路径如何达到这个指数。我们可以用哪两种方法来构造一条穿过这个矩阵的路径？没错——只有向下和向右。例如，我们不能从<code class="fe ms mt mu mv b">5</code>移动到<code class="fe ms mt mu mv b">3</code>，也不能从<code class="fe ms mt mu mv b">2</code>移动回它之前的<code class="fe ms mt mu mv b">4</code>。</p><p id="f374" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着路径只能从当前元素左侧或上方的<strong class="kh ir">连接。我们知道这一点，因为我们只能在路径上向右或向下移动。因此，我们可以通过检查以下内容来检查任何给定索引处的最小路径和:当前元素左侧的元素、当前元素正上方(上一行)的元素，然后从它们中挑选比<strong class="kh ir">小</strong>的元素。我们将把左边或顶部元素中较小的一个加到当前元素上，将其转换成当前元素的最小路径和。</strong></p><p id="9925" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在最上面一行，我们只能检查左边的元素，所以这必然是要添加到当前元素的数字。因此，我们将<code class="fe ms mt mu mv b">1</code>加到<code class="fe ms mt mu mv b">3</code>上，然后继续迭代到第一行的最后一个元素<code class="fe ms mt mu mv b">1</code>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/aa77eca8973753d790124cded673b389.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*vR4FM9WB7yVD7EmcMcLzLg.png"/></div></figure><p id="e24b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们仍然在顶行，所以这个子问题的答案与上一个相同:我们将当前元素左边的元素添加到我们的当前元素中。这意味着先前的最小路径和<code class="fe ms mt mu mv b">4</code>被添加到<code class="fe ms mt mu mv b">1</code>。接下来，向下移动到下一行，并遍历这些元素。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/32e74ead05497fcf270f30d7d390b458.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*KjtnSql_ScGH2YThU4RnZQ.png"/></div></figure><blockquote class="ml mm mn"><p id="20e2" class="kf kg mo kh b ki kj jr kk kl km ju kn mp kp kq kr mq kt ku kv mr kx ky kz la ij bi translated">注意:现在我们已经开始突出显示<strong class="kh ir">潜在元素</strong> ( <strong class="kh ir">黄色</strong>)以添加到<strong class="kh ir">当前元素</strong> ( <strong class="kh ir">蓝色</strong>)。</p></blockquote><p id="a59e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们到了第二行，这意味着我们<strong class="kh ir">有一个顶部元素来检查最小路径和。然而，在第一个元素<code class="fe ms mt mu mv b">1</code>，我们没有左元素，因为我们在该行的第一个索引处。因此，我们将<code class="fe ms mt mu mv b">1</code>(从顶部元素)添加到当前元素<code class="fe ms mt mu mv b">1</code>。继续进行<code class="fe ms mt mu mv b">5</code>。</strong></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/8224ce42c881fad64f9dd9edd666863d.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*Gdwsd7fo8enkJb0163kZMA.png"/></div></figure><p id="67e1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mv b">5</code>是第一个元素，我们实际上需要检查左边和顶部的元素。记住，由于我们在遍历矩阵时计算每个元素的最小路径和，所以在任何遍历的索引处的元素不再代表原始元素；相反，该元素表示<strong class="kh ir">最小路径和</strong>。使用这些新元素，我们可以在遍历矩阵时计算每个元素的最小路径和，一直到最后的索引。</p><p id="8e8c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查左侧和顶部的最小路径，然后将两者中较小的路径添加到当前元素中，因为我们需要的是最小路径，而不是最大路径。我们将<code class="fe ms mt mu mv b">2</code>(从左起)添加到<code class="fe ms mt mu mv b">5</code>，并继续迭代到<code class="fe ms mt mu mv b">1</code>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/ae9ffc0c834edad89e2338fb38bdae90.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*yZPGs-QdicHVPPorPRDajw.png"/></div></figure><p id="00b4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在<code class="fe ms mt mu mv b">1</code>。通过分别找到左侧和顶部元素<code class="fe ms mt mu mv b">7 &amp;&amp; 5</code>的最小值来计算最小路径和。我们将<code class="fe ms mt mu mv b">5</code>加到<code class="fe ms mt mu mv b">1</code>上，因为它是两者中较小的一个。迭代到矩阵的下一行和最后一行。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/099cf765e5c335988eaba039e1a51180.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*cRPaC6lfLFSlJ3dREu6l9Q.png"/></div></figure><p id="6409" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">元素<code class="fe ms mt mu mv b">4</code>从顶部只有一条潜在路径。将<code class="fe ms mt mu mv b">2</code>(顶部元素)添加到当前元素<code class="fe ms mt mu mv b">4</code>，继续迭代到<code class="fe ms mt mu mv b">2</code>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/77c9f7788583856e62dfad8acce114b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*y7xXjkd0L260HRfjtg6cuQ.png"/></div></figure><p id="342a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有两个路径选项，即<code class="fe ms mt mu mv b">6</code>和<code class="fe ms mt mu mv b">7</code>。两者中较小的是<code class="fe ms mt mu mv b">6</code>，所以把它加到<code class="fe ms mt mu mv b">2</code>，迭代到最后一个元素<code class="fe ms mt mu mv b">1</code>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/3868e9dee3d2e1c452f9816b75e7ab71.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*3mAJO5ODVsFsSo50soaUFw.png"/></div></figure><p id="a7f0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的选择是显而易见的:<code class="fe ms mt mu mv b">6</code>是最小路径，因此将其添加到<code class="fe ms mt mu mv b">1</code>，从而连接并创建我们最终的<strong class="kh ir">最小路径和</strong>以解决整体问题<code class="fe ms mt mu mv b">7</code>。最终的图表如下所示:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/353bb9d6393e3b3f23bf96b66b5101d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*vuPbXG1RwqJDe3_ugKYZWg.png"/></div></figure><p id="f52f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这难道不像魔术吗？通过使用在每个元素计算的子问题，我们能够为整个矩阵创建最小路径和。现在，让我们把这些图画翻译成代码。</p><h1 id="d42c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">翻译成代码</h1><p id="7812" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我们需要两个循环，一个嵌套在另一个里面。外部循环将遍历矩阵行，内部循环将遍历当前行中的元素。您可以随意使用<strong class="kh ir">指针</strong>或内置的<strong class="kh ir">迭代</strong>方法来完成这项工作；然而，使用像<code class="fe ms mt mu mv b">forEach</code>这样的迭代方法可能会更容易，因为它可以轻松地传递当前元素的<code class="fe ms mt mu mv b">index</code>。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mx my l"/></div></figure><blockquote class="ml mm mn"><p id="c34f" class="kf kg mo kh b ki kj jr kk kl km ju kn mp kp kq kr mq kt ku kv mr kx ky kz la ij bi translated">记住，我们需要当前行和元素的索引来检查当前元素的左邻和上邻。</p></blockquote><p id="886c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经完成了迭代，让我们继续嵌套循环中的条件逻辑。在这里，我们将检查以下分支:</p><ol class=""><li id="5b1e" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated">这是第一行的第一个元素吗？</li><li id="4446" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">这个元素在第一行吗？</li><li id="9bfd" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated">这是除第一行之外的任何行中的第一个元素吗？</li></ol><p id="a46d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果满足这些条件中的任何一个，我们都不需要检查左侧或顶部邻居，这取决于满足哪个条件。如果这些条件都不满足，我们必须检查左邻和上邻，以确定当前元素的最小路径和。让我们实现条件逻辑:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2a2e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们实际创建一个逻辑，将当前元素重新分配给最小路径和。</p><blockquote class="ml mm mn"><p id="c334" class="kf kg mo kh b ki kj jr kk kl km ju kn mp kp kq kr mq kt ku kv mr kx ky kz la ij bi translated">记住，在<code class="fe ms mt mu mv b">else</code>的例子中，我们同时检查左边和顶部的元素。</p></blockquote><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="6282" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要让所有的指数把你难倒；我们只是检查当前元素之前的元素(向左)或当前元素之前的行中的元素(向上)。<code class="fe ms mt mu mv b">Math.min</code>用于计算其参数的最小值，在这种情况下非常适用。</p><p id="4b6e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们需要返回矩阵中最后一行的最后一个索引处的元素。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7e7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了！我们都完了。这段代码在<code class="fe ms mt mu mv b">O(m * n)</code>时间内运行，占用<code class="fe ms mt mu mv b">O(1)</code>空间，因为我们改变了输入数组，并且没有复制它。</p><h1 id="e1fa" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="d8ab" class="pw-post-body-paragraph kf kg iq kh b ki mg jr kk kl mh ju kn ko mi kq kr ks mj ku kv kw mk ky kz la ij bi translated">我希望动态编程及其自底向上的策略现在对您来说不那么令人生畏了。这需要更多的实践，而不是本文所能提供的，所以我建议将本文中使用的策略应用于以下问题:</p><ol class=""><li id="f86e" class="mz na iq kh b ki kj kl km ko nb ks nc kw nd la ne nf ng nh bi translated"><a class="ae lb" href="https://leetcode.com/problems/unique-paths/?tab=Description" rel="noopener ugc nofollow" target="_blank">独特的道路</a></li><li id="3cb0" class="mz na iq kh b ki ni kl nj ko nk ks nl kw nm la ne nf ng nh bi translated"><a class="ae lb" href="https://leetcode.com/problems/climbing-stairs/" rel="noopener ugc nofollow" target="_blank">爬楼梯</a></li></ol><p id="ca1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">祝你好运，编码快乐！</p></div></div>    
</body>
</html>