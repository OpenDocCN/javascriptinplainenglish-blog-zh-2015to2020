<html>
<head>
<title>Deep Clone an Object and Preserve its Type with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">深度克隆一个对象并用TypeScript保留其类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/deep-clone-an-object-and-preserve-its-type-with-typescript-d488c35e5574?source=collection_archive---------0-----------------------#2020-10-05">https://javascript.plainenglish.io/deep-clone-an-object-and-preserve-its-type-with-typescript-d488c35e5574?source=collection_archive---------0-----------------------#2020-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e2da" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">从浅层复制到深层克隆</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e54c037b713b92da04c3455849a5a356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iabno476PKpy0uCb.jpg"/></div></div></figure><p id="08d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">JavaScript世界中的一切都是对象。我们经常需要克隆一个对象。使用TypeScript时，可能还需要保留对象类型。</p><p id="76aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文将探索使用TypeScript深度克隆对象的选项。克隆的实现不依赖于外部库。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="7a4d" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">浅拷贝</h2><p id="6177" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">使用<code class="fe ms mt mu mv b">Object.Assign</code>或Spread操作符的浅层复制将复制顶级属性。但是作为对象的属性在浅层复制后作为引用被复制，因此它在原始源和目标(复制的对象)之间被共享。</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="dbbe" class="lu lv iq mv b gy na nb l nc nd">const objShallowCopy = Object.assign({}, Obj1);<br/>// or<br/>const objShallowCopy = {...Obj1};</span></pre><p id="8dc2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上述方法不能正确地对复杂对象进行深度克隆。但是对于不需要嵌套对象属性的情况，这已经足够好了。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="c6d9" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">做深层拷贝最简单的方法</h2><p id="af1f" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">使用<code class="fe ms mt mu mv b">JSON.parse</code>和<code class="fe ms mt mu mv b">JSON.stringify</code>是深度克隆一个对象最简单的方法。使用下面的一行代码，可以对复杂对象的嵌套属性进行深度克隆。</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="bd72" class="lu lv iq mv b gy na nb l nc nd">const objCloneByJsonStringfy = JSON.parse(JSON.stringify(Obj1));</span></pre><p id="3b51" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是它确实有一些警告。</p><ul class=""><li id="f654" class="ne nf iq kt b ku kv kx ky la ng le nh li ni lm nj nk nl nm bi translated">这个过程很慢，因为这个方法的本质涉及到JSON对象的序列化和反序列化。使用这种方法克隆大型对象时，性能将是一个问题。</li><li id="ffdb" class="ne nf iq kt b ku nn kx no la np le nq li nr lm nj nk nl nm bi translated">不支持<code class="fe ms mt mu mv b">date </code>类型。日期将被解析为字符串，因此源对象中的日期对象将在复制后丢失。</li><li id="2b6f" class="ne nf iq kt b ku nn kx no la np le nq li nr lm nj nk nl nm bi translated">它不保留对象的类型和方法。如下面的代码片段所示，<code class="fe ms mt mu mv b">instanceof </code>返回<code class="fe ms mt mu mv b">false</code>，因为它在对象的原型链中找不到构造函数。复制后源对象中的函数将会丢失。</li></ul><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="3e97" class="lu lv iq mv b gy na nb l nc nd">const objCloneByJsonStringfy = JSON.parse(JSON.stringify(obj1));<br/>// the type of obj1 is ObjectWithName<br/>console.log(objCloneByJsonStringfy instanceof ObjectWithName);<br/>// the output is false</span></pre></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="270f" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">保留类型</h2><p id="c2ae" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">为了解决上述问题，开发了以下递归深度克隆函数。它支持<code class="fe ms mt mu mv b">Date </code>数据类型，并在其原型链中保留原来的对象类构造函数和方法。它也是紧凑和高效的。</p><p id="c996" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">代码的要点如下。用源对象原型实例化一个新对象，并使用<code class="fe ms mt mu mv b">reduce </code>操作符递归复制每个属性。</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="ca3c" class="lu lv iq mv b gy na nb l nc nd">return Array.isArray(source)<br/>  ? source.map(item =&gt; deepCopy(item))<br/>    : source instanceof Date<br/>    ? new Date(source.getTime())<br/>    : source &amp;&amp; typeof source === 'object'<br/>    ? Object.getOwnPropertyNames(source).reduce((o, prop) =&gt; <br/>      o[prop] = deepCopy(source[prop]);<br/>      return o;<br/>      }, Object.create(Object.getPrototypeOf(source))<br/>      : source as T;</span></pre><p id="c808" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面代码的关键是<code class="fe ms mt mu mv b">Object.create</code>，它相当于下面的:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="bb90" class="lu lv iq mv b gy na nb l nc nd">Object.create = function (o) {<br/>    function F() {}<br/>    F.prototype = o;<br/>    return new F();<br/>};</span></pre><p id="d418" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此复制后对象将指向源对象的同一原型。</p></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="138a" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">属性描述符</h2><p id="5787" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">JavaScript中的每个属性不仅有一个<code class="fe ms mt mu mv b">value</code>，还有三个属性(<code class="fe ms mt mu mv b"><em class="ns">configurable</em></code>、<code class="fe ms mt mu mv b"><em class="ns">enumerable</em></code>、T5、和<code class="fe ms mt mu mv b"><em class="ns">writable</em></code>)。所有四个属性被称为<a class="ae nt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" rel="noopener ugc nofollow" target="_blank">属性描述符</a>。</p><p id="5832" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要完成上面的深度克隆功能并使其成为原始对象的“真实”副本，应该克隆属性描述符以及属性值。我们可以使用“Object.defineProperty”来实现这一点。</p><p id="3b8b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里列出了完整的功能</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure></div><div class="ab cl ln lo hu lp" role="separator"><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls lt"/><span class="lq bw bk lr ls"/></div><div class="ij ik il im in"><h2 id="f7ee" class="lu lv iq bd lw lx ly dn lz ma mb dp mc la md me mf le mg mh mi li mj mk ml mm bi translated">摘要</h2><p id="0147" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">在本文中，我们将讨论<code class="fe ms mt mu mv b">JSON.Parse/JSON.Stringify</code>在深度克隆对象中的用法和缺陷。提出了一种定制的解决方案来实现真正的深度克隆并保持对象的类型。</p><p id="79e2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">希望这篇文章能帮助你用TypeScript复制对象。</p><p id="936f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你喜欢这篇文章，你可能也会喜欢我最近的其他文章。</p><div class="nw nx gp gr ny nz"><a rel="noopener  ugc nofollow" target="_blank" href="/case-study-a-practical-usage-of-typescript-discriminated-union-type-and-generics-87e75a2717f8"><div class="oa ab fo"><div class="ob ab oc cl cj od"><h2 class="bd ir gy z fp oe fr fs of fu fw ip bi translated">TypeScript区分联合类型和泛型的用例</h2><div class="og l"><h3 class="bd b gy z fp oe fr fs of fu fw dk translated">我非常喜欢Typescript的一个原因是它的类型系统，它实用且功能丰富。应用右边的类型…</h3></div><div class="oh l"><p class="bd b dl z fp oe fr fs of fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oi l"><div class="oj l ok ol om oi on kp nz"/></div></div></a></div><p id="3d19" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">编程快乐！</p></div></div>    
</body>
</html>