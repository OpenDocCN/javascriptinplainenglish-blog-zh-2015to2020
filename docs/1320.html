<html>
<head>
<title>Google Analytics with React Router</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带React路由器的谷歌分析</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/google-analytics-with-react-router-and-hooks-16d403ddc528?source=collection_archive---------1-----------------------#2020-03-01">https://javascript.plainenglish.io/google-analytics-with-react-router-and-hooks-16d403ddc528?source=collection_archive---------1-----------------------#2020-03-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b976" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使你正在建立一个没有“盈利战略”的有趣的副业，你也应该收集相关的分析。最简单的方法仍然是<strong class="jm io"> Google Analytics </strong>但是如果你正在构建一个单页面应用程序，比如一个带有<a class="ae ki" href="https://reacttraining.com/react-router/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> React Router </a>的<a class="ae ki" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React应用程序</a>，你会发现建议的复制&amp;粘贴解决方案有一个缺口！</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/92be164932e25cfb0d424497e9f3ddd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qCXBlQjubroFDl4O"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@alexradelich?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alex Radelich</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7bcb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你将会追踪用户登陆的地方，但是你不会追踪他们导航到不同的路线！如果说客户端路由的好处是极快的导航速度，那么这就是它的坏处:你并不是真的<strong class="jm io">在服务器上点击一个新的页面，你总是得到相同的<code class="fe kz la lb lc b">/index.html</code>服务，并在整个会话过程中保持在那里。</strong></p><p id="e8d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React路由器通知你的浏览器你进入了一个新的页面，但这都是假装的！这是为了避免与服务器之间的往返，让你的应用程序感觉更快，响应更快。因此，即使你的浏览器的历史记录认为你从<code class="fe kz la lb lc b">/</code>，到<code class="fe kz la lb lc b">/about</code>，到<code class="fe kz la lb lc b">/contact</code>，它只对服务器做了一个请求，第一个是对<code class="fe kz la lb lc b">/</code>。</p><p id="bd8a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是为什么如果你只遵循谷歌分析的基本设置指南，你只会跟踪最初的请求到<code class="fe kz la lb lc b">/</code>，这可能会让你认为你的应用程序中的所有其他路线都是完全无用的，没有人能到达那里。</p><p id="a303" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，让我向你展示在客户端React应用程序中添加谷歌分析的简单方法，使用一个你自己编写的<strong class="jm io">钩子</strong>;没有要安装的定制库！</p><h2 id="5481" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">谷歌分析片段</h2><p id="07ac" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">如果你<a class="ae ki" href="https://analytics.google.com/analytics/web" rel="noopener ugc nofollow" target="_blank">按照流程在Google Analytics </a>中为你的新应用程序设置一个新账户/资产，你最终会进入<a class="ae ki" href="https://developers.google.com/analytics/devguides/collection/gtagjs" rel="noopener ugc nofollow" target="_blank">一个页面，要求你“在你网站的每个页面上的&lt; head &gt;标签之后立即粘贴一段代码”</a>:</p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="026b" class="ld le in lc b gy mf mg l mh mi">&lt;!-- Global site tag (gtag.js) - Google Analytics --&gt;<br/>&lt;script async src="https://www.googletagmanager.com/gtag/js?id=GA_MEASUREMENT_ID"&gt;&lt;/script&gt;<br/>&lt;script&gt;<br/>  window.dataLayer = window.dataLayer || [];<br/>  function gtag(){dataLayer.push(arguments);}<br/>  gtag('js', new Date());<br/><br/>  gtag('config', 'GA_MEASUREMENT_ID');<br/>&lt;/script&gt;</span></pre><p id="d8b2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如上所述，如果你用React路由器创建了一个React应用程序，你的网站上实际上只有一个页面！因此，将上述内容添加到您的<code class="fe kz la lb lc b">public/index.html</code>中，用您的跟踪键替换<code class="fe kz la lb lc b">GA_MEASUREMENT_ID</code>是有意义的:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="8396" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如上所述，这是可行的，但只能追踪用户最初登陆的位置。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ml"><img src="../Images/927f60b7ee4919aa9260f9a1ac7673bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bo10JqsB5zhUTRrZ"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@joshuaearle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joshua Earle</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0c22" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是如果你的应用程序看起来像这样呢:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a057" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看来除了回家的<code class="fe kz la lb lc b">/</code>路线，你还有两条，<code class="fe kz la lb lc b">/about</code>和<code class="fe kz la lb lc b">/contact</code>。大概在<code class="fe kz la lb lc b">Header</code>的某个地方，你有用户可以点击导航的链接。那么，你如何追踪它呢？</p><p id="f526" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">眼尖的读者可能会注意到文档中确实有一小段叫做<a class="ae ki" href="https://developers.google.com/analytics/devguides/collection/gtagjs/single-page-applications" rel="noopener ugc nofollow" target="_blank">单页应用</a>，在那里他们指示我们当“网站动态加载新页面内容而不是整页加载”时再次调用<code class="fe kz la lb lc b">gtag</code>，就像这样:</p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="9f40" class="ld le in lc b gy mf mg l mh mi">gtag('config', 'UA-1234567-89', {'page_path': '/new-page.html'});</span></pre><p id="03f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我们如何知道“何时”，我们如何知道何时我们已经导航到一个新的“客户端”路线？</p><h2 id="4da5" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">倾听的钩子</h2><p id="1c3a" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">幸运的是，React Router现在给你<a class="ae ki" href="https://reacttraining.com/react-router/web/api/Hooks/usehistory" rel="noopener ugc nofollow" target="_blank">一个钩子来获取它的历史对象</a>，并且这个历史对象有一个方法来在它改变时附加一个监听器！这是我们将在自己的钩子中使用的:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="f34d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这可能需要解析很多内容，所以让我们一节一节地分解它:</p><h2 id="0218" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">文件名:<code class="fe kz la lb lc b">useTracking.ts</code></h2><p id="23aa" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">对于钩子来说，即使这样也很重要！为了让React知道某个东西是一个钩子，需要将其定义为一个以<code class="fe kz la lb lc b">use</code>开头的方法。如果不这样做，它就不知道如何运行它所需要的钩子魔法。</p><p id="c62b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有点像为了让React知道某个东西是React组件，它需要以大写字母开头。我们<code class="fe kz la lb lc b">import App</code>，不是<code class="fe kz la lb lc b">import app</code>，同样在这里，我们需要<code class="fe kz la lb lc b">import useTracking</code>。这不是惯例。我们必须做这件事！</p><h2 id="b392" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">进口我们需要的东西</h2><p id="4913" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">所以，在<code class="fe kz la lb lc b">useTracking.ts</code>中，我们将会使用一些有副作用的东西！我们将关注路线历史的变化，并将这些变化通知谷歌。</p><p id="011f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在React hooks的时代，你在<code class="fe kz la lb lc b">useEffect</code>中包装这些东西，所以我们把它带进来:</p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="8b75" class="ld le in lc b gy mf mg l mh mi">import { useEffect } from 'react'</span></pre><p id="c6cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kz la lb lc b">useHistory</code>是钩子，它将为我们获取路由器在<code class="fe kz la lb lc b">App.tsx</code>中使用的历史对象。我们想听听它的变化！</p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="0a77" class="ld le in lc b gy mf mg l mh mi">import { useHistory } from 'react-router-dom'</span></pre><h2 id="06c6" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">通知打字稿我们已经在<code class="fe kz la lb lc b">window</code>中添加了<code class="fe kz la lb lc b">gtag</code></h2><p id="0b62" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">这些例子是用Typescript编写的，这样做是为了阻止我们运行不存在的方法。</p><p id="ece4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常它会在分析我们的源代码后“自动”解决问题。但是Typescript如何知道我们在<code class="fe kz la lb lc b">public/index.html</code>中内嵌粘贴的代码片段将一个<code class="fe kz la lb lc b">gtag</code>方法添加到全局变量中呢？它不知道我们所有的源代码只打算由那个<code class="fe kz la lb lc b">public/index.html</code>导入，在它注入那个方法之后。</p><p id="5303" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们必须自己声明<code class="fe kz la lb lc b">window</code>中的可能是什么<em class="mm">，就像这样:</em></p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="f360" class="ld le in lc b gy mf mg l mh mi">declare global {<br/>  interface Window {<br/>    gtag?: (<br/>      key: string,<br/>      trackingId: string,<br/>      config: { page_path: string }<br/>    ) =&gt; void<br/>  }<br/>}</span></pre><h2 id="b3ba" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">在我们的钩子签名中接受一个<code class="fe kz la lb lc b">trackingId</code></h2><p id="1c0a" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">谷歌为这个被美化的<code class="fe kz la lb lc b">apiKey</code>起了几个名字；在上面的例子中，我把它记为<code class="fe kz la lb lc b">UA-YOUR1KEY-HERE</code>，你当然应该用你自己的、实际的键/项目id / <code class="fe kz la lb lc b">GA_MEASUREMENT_ID</code>来替换它。</p><p id="c33a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">实际上，你不太可能想在整个应用程序中用不同的<code class="fe kz la lb lc b">trackingId</code>调用这个方法。你通常想在每个应用程序中使用一次，用一个<code class="fe kz la lb lc b">apiKey</code>，所以你也可以直接在这个方法体中硬编码它，或者使用<code class="fe kz la lb lc b">process.env.GA_MEASUREMENT_ID </code>，或者任何你创建的环境变量。</p><p id="df73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，我<strong class="jm io">确实</strong>认为接受一个论点会让发布这个钩子更容易，如果你愿意的话！或者，更有可能的是，当你将它粘贴到下一个应用程序中时，你会记得更新到正确的值！</p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="402a" class="ld le in lc b gy mf mg l mh mi">export const useTracking = (<br/>  trackingId: string | undefined = process.env.GA_MEASUREMENT_ID<br/>) =&gt; {</span></pre><h2 id="127c" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">将方法更改为<code class="fe kz la lb lc b">listen</code></h2><p id="5159" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">如前所述，我们将使用<code class="fe kz la lb lc b">useHistory</code>钩子来获取我们的应用程序的<code class="fe kz la lb lc b">Router</code>将要使用的历史对象。我们只对它的一个方法感兴趣，你可以用它来附加一个回调来运行浏览器历史记录的改变。实际上，任何时候路线改变！该方法被恰当地命名为<code class="fe kz la lb lc b">listen</code>，我们不妨直接将其析构:</p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="ffa9" class="ld le in lc b gy mf mg l mh mi">const { listen } = useHistory()</span></pre><h2 id="9efa" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">额外学分阅读:效果清理</h2><p id="c0fe" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我们还没有真正看到我们设置了什么，但是这一行首先出现，所以它可能会使您出错:</p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="2e7b" class="ld le in lc b gy mf mg l mh mi">useEffect(() =&gt; {<br/>    const unlisten = listen((location) =&gt; {</span></pre><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mn"><img src="../Images/c332a63ab49b38136e90ba1fb30b4088.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WcMHpTYbwZQUgHma"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@johnnymcclung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Johnny McClung</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="08c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这一部分非常专业，所以请随意跳过/略读，不要太担心理解它！你可能以后还会回来。</p><p id="7283" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每当你<code class="fe kz la lb lc b">useEffect</code>的时候，你都应该考虑这个效果是否需要清理。如果您正在附加事件监听器或设置超时，答案几乎总是“<strong class="jm io"> yes </strong>”。</p><p id="93f5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">即使你不这样做，你的应用程序也很有可能像预期的那样工作，但是你将为难以调试的性能问题和错误打开大门。</p><p id="1ea4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们没有清理的情况下，我们将继续添加侦听器，这些侦听器将继续向google analytics发送<code class="fe kz la lb lc b">page_path</code>更新，因此“double/triple/n-where-n-equals-how-times-our-App-component-re-renders”——计算我们的页面浏览量。</p><p id="f89c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据你如何设置你的<code class="fe kz la lb lc b">App</code>和你实际使用这个钩子的地方，有可能它永远不会重新运行，并侥幸躲过那颗子弹。但考虑一下，如果你为Instagram这样的应用程序设置一个类似的挂钩，每当用户点击时间轴中每条帖子末尾出现的“心脏”按钮时，它就会运行。这需要几十个处理程序，每次心脏从轮廓变为充满颜色时，每个处理程序都可能被重新添加！不要介意把有价值的用户数据变成垃圾，这将是一个明显的UX性能打击。</p><p id="0a2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在任何情况下，如果您不想躲避子弹，那么您需要设置删除事件侦听器的指令。有帮助的是，history的<code class="fe kz la lb lc b">listen</code>方法返回了另一个方法，这个方法删除了您刚刚设置的事件监听器！这就是为什么我们编写了<code class="fe kz la lb lc b">const unlisten = listen(...)</code>，我们将保留那个<code class="fe kz la lb lc b">unlisten</code>方法，并在我们想要移除事件监听器时运行它。</p><p id="e71d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是我们想什么时候运行它呢？在钩子的清理阶段。您传递给<code class="fe kz la lb lc b">useEffect</code>的方法可以有一个您想要在其清理期间运行的方法的返回值。这就是为什么后来我们<code class="fe kz la lb lc b">return unlisten</code>。这指示在钩子的清理阶段对<code class="fe kz la lb lc b">unlisten()</code>作出反应，这将删除我们设置的“路由改变事件监听器”。</p><p id="6f2e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">咻，好一段！如果你成功了，干得好！如果你没有通过，<em class="mm">不管怎样</em>做得很好。这篇文章更多的是关于使用React钩子设置Google Analytics，你可以在不知道<code class="fe kz la lb lc b">useEffect</code>的来龙去脉的情况下完成。所以，让我们继续…更多的细节！</p><h2 id="d681" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">设置处理程序</h2><p id="73cf" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">所以在上面的超级技术部分，我们已经设置了一个效果和它的清理。如果你跳过了它，你不需要知道细节，因为现在我们将放大到我们正在用<code class="fe kz la lb lc b">listen</code>方法做的事情！</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="180f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么<code class="fe kz la lb lc b">listen</code>是如何工作的呢？好吧，你用你想要的处理程序调用它，当浏览器历史有变化时你想要运行的方法。本质上，每当用户导航到不同的路线！因此，在一个带有React Router的应用程序中，每当他们点击一个<code class="fe kz la lb lc b">Link</code>组件，或者任何我们已经设置为可编程<code class="fe kz la lb lc b">history.push('/somewehere-else')</code>的东西。</p><p id="2b7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kz la lb lc b">listen</code>将以一个<code class="fe kz la lb lc b">location</code>对象作为第一个参数，以一个<code class="fe kz la lb lc b">action</code>作为第二个参数来调用给定的方法。我们不需要<code class="fe kz la lb lc b">action</code>在我们的钩子里，所以不要再想它了。</p><p id="b04f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以我们创建了一个匿名的胖箭头方法，这个方法只使用它的第一个参数<code class="fe kz la lb lc b">location</code>。</p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="246d" class="ld le in lc b gy mf mg l mh mi">listen((location) =&gt; {</span></pre><h2 id="3183" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">健全性检查</h2><p id="ce8a" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">然后，我们检查窗口中是否真的存在一个<code class="fe kz la lb lc b">gtag</code>方法，如果不存在，就提前退出。</p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="2b05" class="ld le in lc b gy mf mg l mh mi">if (!window.gtag) return;</span></pre><p id="9b13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在实践中，我们知道情况总是这样，因为我们在<code class="fe kz la lb lc b">public/index.html</code>中的内联脚本在这个钩子之前运行。但是<em class="mm">我们真的了解这个</em>吗？如果我们以稍微不同的方式实现<code class="fe kz la lb lc b">gtag</code>注入会怎么样？如果页面中的一个冲突脚本出于某种原因删除了那个全局方法，该怎么办？如果我奶奶有轮子呢？</p><p id="563c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">撇开不太可能的if不谈，使用全局作用域永远不会太安全，所以不妨做一个健全性检查。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mo"><img src="../Images/e72033e3800f956517f1e99dedc68038.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9JFhmzbnwqYoRl75"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@robschreckhise?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rob Schreckhise</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9f8d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，我们有一个更需要的健全性检查，因为它可以防止人为错误:</p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="a4bb" class="ld le in lc b gy mf mg l mh mi">if (!trackingId) {<br/>  console.log(<br/>    "Tracking not enabled, as `trackingId` was not given and there is no `GA_MEASUREMENT_ID`."<br/>  )<br/>  return<br/>}</span></pre><p id="9b0c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我喜欢帮助开发人员找出问题所在的聊天式/有用的日志记录。React团队是我发现的典范，所以我想在这里尝试一下！</p><p id="7ab4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，如果我们调用这个钩子而没有使用<code class="fe kz la lb lc b">trackingId</code>，并且没有默认的<code class="fe kz la lb lc b">process.env. GA_MEASUREMENT_ID</code>，我们将得到这个日志来提示我们为什么在我们的仪表板中除了<code class="fe kz la lb lc b">/</code>之外，我们仍然看不到任何页面视图。</p><p id="02a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们<code class="fe kz la lb lc b">return</code>甚至不尝试注册<code class="fe kz la lb lc b">page_path</code>更新，因为没有<code class="fe kz la lb lc b">trackingId</code>它就不能工作。如果我们的<code class="fe kz la lb lc b">trackingId</code> <strong class="jm io">被</strong>设置，但是<strong class="jm io">无效</strong>，例如，如果我们使用上面例子中粘贴的字符串<code class="fe kz la lb lc b">'UA-YOUR1KEY-HERE'</code>，谷歌的脚本会告诉我们有猫腻。我们可以自己进行打字防范，但我认为那会是太多的工作，几乎没有任何好处。</p><h2 id="ecaf" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">追踪新路线！</h2><p id="9a71" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">最后，我们成功地向谷歌发出信号说“实际上，我们现在在一条新的路线上”！这类似于React Router告诉浏览器的历史，就像我们在一条新的路线上一样，只是我们自己编写了这段代码！</p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="58a3" class="ld le in lc b gy mf mg l mh mi">window.gtag('config', trackingId, { page_path: location.pathname })</span></pre><p id="3cee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">嗯，我们已经把它从上面提到的文档中粘贴进来，并调整它使用参数…仍然有效！</p><h2 id="2e83" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">依赖数组</h2><p id="3478" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我们以<code class="fe kz la lb lc b">useEffect</code>的第二个参数结束，它的依赖项数组:</p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="85b5" class="ld le in lc b gy mf mg l mh mi">}, [trackingId, listen])</span></pre><p id="dd63" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于<code class="fe kz la lb lc b">useEffect</code>，我们已经讲了很多；大概太多了吧！所以对于它的依赖数组，我们只能说，我们告诉React，如果<code class="fe kz la lb lc b">trackingId</code> <code class="fe kz la lb lc b">useTracking</code>把它作为一个参数，或者<code class="fe kz la lb lc b">useHistory</code>的<code class="fe kz la lb lc b">listen</code>方法改变了，它就应该重新运行这个效果。</p><p id="a979" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的用例中,<code class="fe kz la lb lc b">trackingId</code>和<code class="fe kz la lb lc b">listen</code>永远不会改变，所以它只会在第一次渲染时运行一次，并且永远不会重新运行。即使有，也没有问题，因为我们已经在上面的部分做了适当的清理。</p><p id="ed6c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">钩子就这样了！如果我们设法使用它，我们就完成了！</p><h2 id="ac34" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">使用钩子</h2><p id="7189" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">我们的钩子已经准备好了，但是因为它从React路由器调用了<code class="fe kz la lb lc b">useHistory</code>，所以它只能在一个组件或者其他钩子中运行，这个组件或者钩子在<code class="fe kz la lb lc b">Router</code>中。我们上面定义的<code class="fe kz la lb lc b">App</code>是路由器内部的<strong class="jm io">而不是</strong>。这是我们第一次使用路由器，通过渲染<code class="fe kz la lb lc b">&lt;BrowserRouter&gt;</code>！</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mp"><img src="../Images/afdafd2b0da254bbbbfe22f50f6ed90f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dSn4aWQ_SeNYfYnY"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@javigabbo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Javier García</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="caf9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，让我们进行重构，让事情变得简单一点:</p><h2 id="9452" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">重构<code class="fe kz la lb lc b">App.tsx</code></h2><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="7ec4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最大的变化是我们创建了命名的导出，<code class="fe kz la lb lc b">export const App</code> <strong class="jm io">返回没有提供者的JSX</strong>。我们的供应商，<code class="fe kz la lb lc b">ApolloProvider</code>和<code class="fe kz la lb lc b">BrowserRouter</code>去哪里了？</p><p id="c94b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它们现在在我们的默认导出中，我们已经从仅仅是<code class="fe kz la lb lc b">export default App</code>改变为返回包装在我们所有提供者中的应用程序！</p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="b63f" class="ld le in lc b gy mf mg l mh mi">export default () =&gt; (<br/>  &lt;ApolloProvider client={apolloClient}&gt;<br/>    &lt;BrowserRouter&gt;<br/>      &lt;App /&gt;<br/>    &lt;/BrowserRouter&gt;<br/>  &lt;/ApolloProvider&gt;<br/>)</span></pre><p id="5a4b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我发现这对测试很有帮助，因为我们现在可以使用我们的命名导出，并在我们自己的定制提供者中呈现它:比如React Router的内存路由器，或者<a class="ae ki" href="https://www.apollographql.com/docs/react/development-testing/testing/" rel="noopener ugc nofollow" target="_blank"> Apollo </a>的<code class="fe kz la lb lc b">MockedProvider</code>。</p><p id="f1f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是这是另一篇文章的主题！在我们的例子中，它不仅仅是有用的，而且是必要的，因为现在我们可以在<code class="fe kz la lb lc b">App</code>中使用我们的钩子，因为<code class="fe kz la lb lc b">const</code>现在应该在<code class="fe kz la lb lc b">BrowserRouter</code>中呈现；而不是负责渲染<code class="fe kz la lb lc b">BrowserRouter</code>本身。一个小小的转变可以让我们…</p><h2 id="c017" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated"><code class="fe kz la lb lc b">useTracking.ts</code>中的<code class="fe kz la lb lc b">App.tsx</code></h2><p id="2268" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">剩下的就是添加我们新钩子的导入，并在<code class="fe kz la lb lc b">App</code>的主体中调用它！</p><pre class="kk kl km kn gt mb lc mc md aw me bi"><span id="ae55" class="ld le in lc b gy mf mg l mh mi">import { useTracking } from './useTracking'<br/>...<br/>export const App = () =&gt; {<br/>  useTracking('UA-YOUR1KEY-HERE')<br/><br/>  return (<br/>    &lt;Container&gt;<br/>      ...<br/>    &lt;/Container&gt;<br/>  )<br/>}</span></pre><p id="1d64" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就这样！<code class="fe kz la lb lc b">public/index.html</code>中的片段将首先跟踪“整页加载”，我们的钩子将跟踪每一个后续的路由改变。<code class="fe kz la lb lc b">App.tsx</code>这里是完整的、最终的:</p><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="mj mk l"/></div></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi mq"><img src="../Images/492d1c930f6302b2388b675928764096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cfIBoQMzPBkfTRNy"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@lephunghia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nghia Le</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="6205" class="ld le in bd lf lg lh dn li lj lk dp ll jv lm ln lo jz lp lq lr kd ls lt lu lv bi translated">引人深思的事</h2><p id="00f1" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">如果您对在<code class="fe kz la lb lc b">public/index.html</code>中粘贴老派的谷歌代码感到不确定，并且有两个地方可以在您的<code class="fe kz la lb lc b">GA_MEASUREMENT_ID</code>中键入，您可以<em class="mm">将</em>修改为加载<code class="fe kz la lb lc b">gtag</code>脚本并进行初始“整页加载”调用的东西。</p><p id="976a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你想了解更多关于这个更“程序化”的解决方案的细节，一定要告诉我；目前，我认为上面讨论的代码是谷歌文档指导你做的事情的更自然的扩展。</p><p id="fd88" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">说到让我知道，我最近几个周末都在做的“有趣的小项目”，引发了这一切的是X的表情符号<a class="ae ki" href="https://emoji-of.com/" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="1481" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">它运行一个调度任务，该任务写入到<a class="ae ki" href="https://www.postgresql.org/" rel="noopener ugc nofollow" target="_blank"> Postgres </a>数据库，以及<a class="ae ki" href="https://www.heroku.com/" rel="noopener ugc nofollow" target="_blank"> Heroku </a>上的<a class="ae ki" href="https://www.graphql.com/" rel="noopener ugc nofollow" target="_blank"> GraphQL </a>服务器，并在<a class="ae ki" href="https://www.netlify.com/" rel="noopener ugc nofollow" target="_blank"> Netlify </a>上有一个<a class="ae ki" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">reaction</a>前端。<a class="ae ki" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank">样式组件</a>和<a class="ae ki" href="https://github.com/react-spring/react-spring" rel="noopener ugc nofollow" target="_blank">对css和动画进行弹簧反作用</a>。它现在运行谷歌分析，看看是否有人真的在访问！</p><p id="3ca4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我知道你是否喜欢一篇关于上述任何技术的文章！</p></div></div>    
</body>
</html>