<html>
<head>
<title>The Window &amp; Document Object In JavaScript — 7 Useful Things You Can Do With Them</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的窗口和文档对象——你可以用它们做7件有用的事情</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-window-document-object-in-javascript-7-useful-things-you-can-do-with-them-14888333ec91?source=collection_archive---------4-----------------------#2020-04-16">https://javascript.plainenglish.io/the-window-document-object-in-javascript-7-useful-things-you-can-do-with-them-14888333ec91?source=collection_archive---------4-----------------------#2020-04-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="b736" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">普通JavaScript</h2><div class=""/><figure class="gl gn jx jy jz ka gh gi paragraph-image"><div role="button" tabindex="0" class="kb kc di kd bf ke"><div class="gh gi jw"><img src="../Images/580ef648bfce37c4b6aa4d3029db3eff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1Ar3QljBfc9raoH7R3dqdw.jpeg"/></div></div><figcaption class="kh ki gj gh gi kj kk bd b be z dk">Source: <a class="ae kl" href="https://unsplash.com/photos/lDEW4qMiizc" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5d21" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="ko ja">文档</strong>和<strong class="ko ja">窗口</strong>对象是我们可以用JavaScript访问的两个父对象。文档对象本身从属于窗口对象。我想每个人都知道它们，因为它们无处不在，尤其是在用普通javascript开发web应用程序时。</p><p id="cd17" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">本文旨在向您展示这两者的一些实用功能。没有必要更详细地介绍这两者到底是什么，我现在给你一些实际的例子，你不需要太多以前的知识就可以使用。</p><h1 id="f1ca" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">处理浏览器中的右键单击—上下文菜单</h1><p id="8840" class="pw-post-body-paragraph km kn iq ko b kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf mm lh li lj ij bi translated"><strong class="ko ja">上下文菜单</strong>是一个DOM事件，当用户右键单击上下文菜单想要调用的DOM元素时触发。上下文菜单就是当用户右键单击网页时默认显示的菜单，除非网页以不同的方式处理事件，我们马上就要这样做。因此，尽管可能不知道它的名字，但这个小菜单看起来会因操作系统的不同而有所不同，并提供诸如“图像另存为”、“检查”、“重新加载”&amp;“返回”等功能。<br/>基本上，当用户右击时，我们可以使用DOM中的<code class="fe mn mo mp mq b"><strong class="ko ja">contextmenu</strong></code>事件来执行我们自己的动作。</p><h2 id="978b" class="mr ll iq bd lm ms mt dn lq mu mv dp lu kx mw mx ly lb my mz mc lf na nb mg iw bi translated">右键单击并阻止显示默认上下文菜单</h2><pre class="nc nd ne nf gt ng mq nh ni aw nj bi"><span id="55b6" class="mr ll iq mq b gy nk nl l nm nn">&lt;div <em class="no">id</em>=”nocontext”&gt;No context menu available for this&lt;/div&gt;</span><span id="4518" class="mr ll iq mq b gy np nl l nm nn">&lt;script&gt;<br/>noContext = document.getElementById(‘nocontext’)</span><span id="5334" class="mr ll iq mq b gy np nl l nm nn">noContext.addEventListener(‘contextmenu’, (event) =&gt; {<br/>  event.preventDefault()<br/>})<br/>&lt;/script&gt;</span></pre><p id="fed6" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，我们为我们的<div>设置了一个EventListener，它应该在上下文菜单被调用时执行，即右键单击。它返回一个事件，我们可以用标准函数<strong class="ko ja"> preventDefault </strong>来阻止这个事件。</div></p><p id="c53c" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">默认情况就像右键单击上下文菜单一样。但是有了<strong class="ko ja"> preventDefault </strong>我们就阻止了它。所以什么都没发生。</p><p id="2bfe" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">当然，我们不仅可以阻止标准事件，还可以在用户右键单击时执行各种代码。然后，我们可以将它与preventDefault结合起来，提供我们自己的上下文菜单，例如:</p><pre class="nc nd ne nf gt ng mq nh ni aw nj bi"><span id="af13" class="mr ll iq mq b gy nk nl l nm nn">contextAvailable.addEventListener(‘contextmenu’, (e) =&gt; {<br/>  console.log(‘you rightclicked this’)<br/>  e.preventDefault()<br/>})</span></pre><h1 id="a34c" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">文档的设计模式</h1><p id="ce34" class="pw-post-body-paragraph km kn iq ko b kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf mm lh li lj ij bi translated">直到这篇文章的研究，这是完全未知的，但实际上这个功能可以非常实用。例如，您可以将它用于内容管理系统，或者在没有代码的情况下快速编辑，以可视化网站上潜在的内容更改。<br/>因为designMode使我们可以编辑我们在浏览器中看到的网站的所有内容，而无需更改devtools的HTML代码。</p><p id="50fe" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">你现在就可以尝试一下。只需转到任何网站，打开控制台，并输入以下内容:</p><p id="cab9" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe mn mo mp mq b">document.designMode = "on"</code></p><p id="083d" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">现在，您可以像编辑Word文档一样简单地编辑显示的网站。很酷吧。<br/><strong class="ko ja">设计模式</strong>只知道两种状态:<strong class="ko ja">开和关</strong>。所以，如果你想停用它，只要做以下事情:</p><p id="5968" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe mn mo mp mq b">document.designMode = "off"</code></p><p id="9ae2" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果你想保护单个元素不改变内容，你可以给它们以下属性:(然后你只能<strong class="ko ja">完全移除</strong>它们，而不能<strong class="ko ja">操作</strong>它们)</p><p id="18fa" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><code class="fe mn mo mp mq b">&lt;i contenteditable = "false"&gt;This is not editable.&lt;/i&gt;</code></p><h1 id="f138" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">用代码复制一些东西到用户的剪贴板</h1><p id="fcc2" class="pw-post-body-paragraph km kn iq ko b kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf mm lh li lj ij bi translated">最初，众所周知的<strong class="ko ja"> document.execCommand() </strong>就是为了这个目的而设计的，但是现在被认为已经过时了。<br/>现在，剪贴板API可用于使用JavaScript自动复制内容。<br/>可以通过<strong class="ko ja">导航器</strong>对象使用，导航器对象从属于<strong class="ko ja">窗口</strong>对象。</p><p id="3dde" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">让我们看一个例子，在按下按钮后，我们将输入字段中输入的文本复制到剪贴板:</p><figure class="nc nd ne nf gt ka"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="d766" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">获取文档的状态</h1><p id="fe42" class="pw-post-body-paragraph km kn iq ko b kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf mm lh li lj ij bi translated">特别是对于更复杂和性能优化的web应用程序的开发，应该对文档的加载时间和一般行为进行调查，以便找到潜在的弱点或提高性能和UX。</p><p id="7dba" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，通过<strong class="ko ja"> document.readyState </strong>，我们可以访问文档的当前状态，并根据结果做出进一步的决策。</p><p id="8e41" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">下面是可能的结果，<strong class="ko ja"> document.readyState </strong>可以返回:</p><ul class=""><li id="9e7e" class="ns nt iq ko b kp kq kt ku kx nu lb nv lf nw lj nx ny nz oa bi translated">未初始化—尚未开始加载</li><li id="6fda" class="ns nt iq ko b kp ob kt oc kx od lb oe lf of lj nx ny nz oa bi translated">正在加载—正在加载</li><li id="3495" class="ns nt iq ko b kp ob kt oc kx od lb oe lf of lj nx ny nz oa bi translated">已加载—已加载</li><li id="6df2" class="ns nt iq ko b kp ob kt oc kx od lb oe lf of lj nx ny nz oa bi translated">交互式—已加载足够的内容，用户可以与之交互</li><li id="6e3c" class="ns nt iq ko b kp ob kt oc kx od lb oe lf of lj nx ny nz oa bi translated">完成—满载<br/>来源:<a class="ae kl" href="https://www.w3schools.com/jsref/prop_doc_readystate.asp" rel="noopener ugc nofollow" target="_blank">https://www.w3schools.com/jsref/prop_doc_readystate.asp</a></li></ul><p id="08cc" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果你在实践中尝试一下，会有一些有趣的结果。为此，我创建了一个小的HTML样板文件，用它我们可以在不同的地方输出状态。每个外部脚本只包含<code class="fe mn mo mp mq b">console.log(document.readyState)</code></p><figure class="nc nd ne nf gt ka"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="3b98" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">以下是我们网站按时间顺序记录的内容:</p><ul class=""><li id="0922" class="ns nt iq ko b kp kq kt ku kx nu lb nv lf nw lj nx ny nz oa bi translated"><strong class="ko ja">正常:</strong>加载</li><li id="9ff7" class="ns nt iq ko b kp ob kt oc kx od lb oe lf of lj nx ny nz oa bi translated"><strong class="ko ja">脚本标签:</strong>加载</li><li id="4a0f" class="ns nt iq ko b kp ob kt oc kx od lb oe lf of lj nx ny nz oa bi translated"><strong class="ko ja">延期:</strong>互动</li><li id="a76d" class="ns nt iq ko b kp ob kt oc kx od lb oe lf of lj nx ny nz oa bi translated"><strong class="ko ja">异步:</strong>交互</li><li id="20b2" class="ns nt iq ko b kp ob kt oc kx od lb oe lf of lj nx ny nz oa bi translated"><strong class="ko ja">加载正文:</strong>完成</li></ul><p id="07da" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">包含外部脚本的不同方式在这里都可以正常工作。但有趣的是，如果我们在页面上只包含一个大图片，图片的加载时间也会延迟body标签的<strong class="ko ja"> onload </strong>事件。</p><p id="8690" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，在任何情况下，如果我们用onload-event输出状态，状态都是“完成”。</p><h1 id="0ff0" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">使用焦点/活动元素</h1><p id="ab53" class="pw-post-body-paragraph km kn iq ko b kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf mm lh li lj ij bi translated">当涉及到网站用户实际可以与之交互的元素时，例如按钮、输入和文本区域，这些可以具有所谓的焦点。如果输入有焦点，我们在键盘上输入一些东西，它会被写入输入字段。如果该字段没有焦点，则不会写入输入字段。我想每个人都知道重点是什么。</p><h2 id="2636" class="mr ll iq bd lm ms mt dn lq mu mv dp lu kx mw mx ly lb my mz mc lf na nb mg iw bi translated">确定哪个元素具有焦点</h2><p id="aedf" class="pw-post-body-paragraph km kn iq ko b kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf mm lh li lj ij bi translated">也许你已经知道了<strong class="ko ja"> onfocus </strong>属性，它是一个元素获得焦点时的事件。然后我们可以用它来创建很酷的CSS动画，或者，如果我们想分析用户行为，保存这个事件。</p><p id="5cc2" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">同样，我们可以确定哪个元素具有焦点，而不必给所有元素赋予<strong class="ko ja"> onfocus </strong>属性。<br/>我们可以通过以下方式做到这一点:</p><pre class="nc nd ne nf gt ng mq nh ni aw nj bi"><span id="e1c9" class="mr ll iq mq b gy nk nl l nm nn">var x = document.activeElement.id</span><span id="ef28" class="mr ll iq mq b gy np nl l nm nn">console.log(x)</span></pre><p id="e060" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，我们可以获得拥有焦点/处于活动状态的元素的id。</p><h2 id="d2d7" class="mr ll iq bd lm ms mt dn lq mu mv dp lu kx mw mx ly lb my mz mc lf na nb mg iw bi translated">手动改变焦点</h2><p id="afc6" class="pw-post-body-paragraph km kn iq ko b kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf mm lh li lj ij bi translated">特别是对于UX，有时减轻用户选择元素的负担会很有帮助。例如，如果他在一个表单中输入错误，我们希望他在每个输入字段中更改输入:</p><pre class="nc nd ne nf gt ng mq nh ni aw nj bi"><span id="a1e1" class="mr ll iq mq b gy nk nl l nm nn">document.getElementById(‘input1’).focus()</span></pre><h1 id="6614" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">读取元素的当前样式</h1><p id="9f90" class="pw-post-body-paragraph km kn iq ko b kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf mm lh li lj ij bi translated">在大型动态web应用程序中，我们不断地改变DOM中任何元素的活动样式。<br/>我们也可以随时输出这个到two，所以检查一下我们的元素有哪些CSS属性和值。</p><ol class=""><li id="965f" class="ns nt iq ko b kp kq kt ku kx nu lb nv lf nw lj og ny nz oa bi translated"><code class="fe mn mo mp mq b"><strong class="ko ja">element.style</strong></code>也可用于读取样式，但用于编辑它们</li><li id="7767" class="ns nt iq ko b kp ob kt oc kx od lb oe lf of lj og ny nz oa bi translated"><code class="fe mn mo mp mq b"><strong class="ko ja">Window.getComputedStyle()</strong></code> <strong class="ko ja"> </strong>用于获取当前的样式</li></ol><p id="9fc0" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，使用最后一个函数，我们可以获得包含元素所有样式的整个对象:</p><pre class="nc nd ne nf gt ng mq nh ni aw nj bi"><span id="16c5" class="mr ll iq mq b gy nk nl l nm nn">let box = document.getElementById(‘box’)</span><span id="7044" class="mr ll iq mq b gy np nl l nm nn">console.log(window.getComputedStyle(box)) // CSSStyleDeclaration{}</span></pre><p id="f705" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">但是我们也可以更精确地输出单个属性和相应的值:</p><pre class="nc nd ne nf gt ng mq nh ni aw nj bi"><span id="4208" class="mr ll iq mq b gy nk nl l nm nn">let box = document.getElementById(‘box’)</span><span id="6475" class="mr ll iq mq b gy np nl l nm nn">console.log(<br/>  window.getComputedStyle(box)<br/>  .getPropertyValue(‘background-color’) // E.g. rgb(0, 128, 0)<br/>)</span></pre><h1 id="90d9" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">处理浏览器和显示的网站的大小</h1><p id="13e0" class="pw-post-body-paragraph km kn iq ko b kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf mm lh li lj ij bi translated">当然，在现代web开发中，大小是无法回避的。这是你需要的:</p><ul class=""><li id="2b9c" class="ns nt iq ko b kp kq kt ku kx nu lb nv lf nw lj nx ny nz oa bi translated"><code class="fe mn mo mp mq b"><strong class="ko ja">window.outerWidth</strong></code></li><li id="ac72" class="ns nt iq ko b kp ob kt oc kx od lb oe lf of lj nx ny nz oa bi translated"><code class="fe mn mo mp mq b"><strong class="ko ja">window.outerHeight</strong></code></li></ul><p id="4033" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这两个返回浏览器窗口本身的尺寸，因此网页是否被例如开发者工具减小尺寸并不重要。</p><p id="119d" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">因此，当真正确定网站当前显示的维度时，可以使用以下功能:</p><ul class=""><li id="4bb6" class="ns nt iq ko b kp kq kt ku kx nu lb nv lf nw lj nx ny nz oa bi translated"><code class="fe mn mo mp mq b"><strong class="ko ja">window.innerWidth</strong></code></li><li id="81a7" class="ns nt iq ko b kp ob kt oc kx od lb oe lf of lj nx ny nz oa bi translated"><code class="fe mn mo mp mq b"><strong class="ko ja">window.innerHeight</strong></code></li></ul><p id="b3c2" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">例如，您可以这样全屏显示一个元素:</p><pre class="nc nd ne nf gt ng mq nh ni aw nj bi"><span id="c999" class="mr ll iq mq b gy nk nl l nm nn">elem.style.width = window.innerWidth + ‘px’</span></pre><h2 id="8b85" class="mr ll iq bd lm ms mt dn lq mu mv dp lu kx mw mx ly lb my mz mc lf na nb mg iw bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="ef3d" class="pw-post-body-paragraph km kn iq ko b kp mi kr ks kt mj kv kw kx mk kz la lb ml ld le lf mm lh li lj ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kl" href="https://medium.com/ai-in-plain-english" rel="noopener"> <strong class="ko ja"> AI in Plain English </strong> </a>，<a class="ae kl" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ko ja">UX in Plain English</strong></a>，<a class="ae kl" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ko ja">Python in Plain English</strong></a><strong class="ko ja"/>——谢谢，继续学习！</p><p id="f39b" class="pw-post-body-paragraph km kn iq ko b kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kl" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ko ja">submissions @ plain English . io</strong></a><strong class="ko ja"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>