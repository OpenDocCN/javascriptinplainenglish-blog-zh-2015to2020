<html>
<head>
<title>Asynchronous vs Synchronous Programming in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的异步与同步编程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-break-promises-keep-callbacks-4dbf9cff3d9a?source=collection_archive---------11-----------------------#2020-12-10">https://javascript.plainenglish.io/javascript-break-promises-keep-callbacks-4dbf9cff3d9a?source=collection_archive---------11-----------------------#2020-12-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="93b5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript打破承诺&amp;保持回调</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/47a281fbc0ad8f27e324a9efd6a4f7db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*Ysl_6PzX5oe8MC3a"/></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk"><a class="ae kr" href="https://www.pexels.com/@rojan-maguyon-2774791" rel="noopener ugc nofollow" target="_blank">Rojan Maguyon</a>, by <a class="ae kr" href="https://www.pexels.com/photo/man-love-people-woman-5343553/" rel="noopener ugc nofollow" target="_blank">pexels</a> (CC0)</figcaption></figure><h1 id="d8e0" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">介绍</h1><p id="58d5" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">JavaScript由单个线程执行。据此，建议首先避免长时间的操作。如果回调无处不在，我们该怎么办？</p><p id="a4ec" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">每当涉及到I/O操作时，比如网络或文件系统，这种情况就会变得非常严重。幸运的是，JavaScript中有两种回调。想深入了解一下吗？浩劫的博客对此做了非常详细的调查。同步回调和异步回调的基本区别是:同步回调是在调用的上下文方法中执行的，而异步不是。</p><p id="1b55" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">一个很好的例子就是展平数组的数组。当执行这个函数时，传入的参数将被减少，以消除一个数组中的多个数组，并将其转换为一个扁平的数组。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="7f25" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">当这将是异步的时，函数不能返回到变量<em class="mn"> flat </em>的赋值。这样做必须是同步的，这是同步回调应用领域的一个很好的例子，也是为什么使用它们的原因。</p><h1 id="c177" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">同步和异步回调</h1><p id="f5d4" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">当有理由使用同步回调时，也有理由使用异步回调。每当程序需要外部资源并不得不等待时，例如，正在建立的连接、将要下载的文件等等。</p><p id="ae8e" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">以下示例将从著名的搜索引擎Google请求一个状态代码和一条状态消息，并将其打印到控制台。将被打印出来的第一条消息是这个简短脚本的最后一行:<em class="mn">请求… </em>，随后是<em class="mn"> 200 </em>和<em class="mn"> OK </em>。这个例子反映了由JavaScript传播的对I/O资源的非阻塞异步调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="541f" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">API的一致性和可靠性的关键是它的行为。它必须是一致的，永远不会像函数式编程那样改变。将A<em class="mn">作为输入将总是返回a <em class="mn"> B </em>作为输出，除此之外别无其他。将此转换回API:函数应该总是返回一个同步回调异或(异或)一个异步回调。函数本身有时返回同步回调，有时返回异步回调，这两种情况应该没有区别。当你阅读ha浩劫的博客文章时，你会发现“<strong class="lm ir">选择同步或异步，但不要两者都选</strong>”并给出了充分的理由:</em></p><blockquote class="mo mp mq"><p id="0173" class="lk ll mn lm b ln mg jr lp lq mh ju ls mr mi lv lw ms mj lz ma mt mk md me mf ij bi translated">因为同步和异步回调有不同的规则，所以它们会产生不同的错误。测试套件只异步触发回调是非常典型的，但是生产中一些不常见的情况会同步运行回调并中断(反之亦然)。</p><p id="a43f" class="lk ll mn lm b ln mg jr lp lq mh ju ls mr mi lv lw ms mj lz ma mt mk md me mf ij bi translated">要求应用程序开发人员计划和测试同步和异步的情况太难了，在库中很容易解决:<strong class="lm ir">如果回调在任何情况下都必须推迟，总是推迟它。</strong> —浩劫的博客</p></blockquote><h1 id="13fa" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">Process.nextTick与setImmediate</h1><p id="5a08" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">JavaScript为服务器端应用程序提供了两个函数:<em class="mn"> process.nextTick </em>和<em class="mn"> setImmediate </em>。乍一看，它们似乎可以互换。你可以在它们的文档中阅读它们:<a class="ae kr" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank">next tick</a>【2】&amp;<a class="ae kr" href="https://nodejs.dev/learn/understanding-setimmediate" rel="noopener ugc nofollow" target="_blank">set immediate</a>【3】。</p><p id="7cc3" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">对于客户端的代码解释，只有<em class="mn"> setImmediate </em>可用。两者都期望回调作为参数，并将在以后执行这个回调。根据定义，似乎两者都在做同样的事情。看看下面的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="588e" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">两者都显示出同样的效果。但是当你看引擎盖下的时候，他们两个是明显不同的。<em class="mn"> process.nextTick </em>会将执行延迟到稍后的日期，但在节点之前。JS进行I/O访问，并将控制权交还给事件循环。</p><p id="33eb" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">假设您正在递归调用<em class="mn"> process.nextTick </em>。这将在哪里结束？它在另一个延迟中结束，直到它们累积，并让事件循环饥饿。给孩子起了个名字"<a class="ae kr" href="https://snyk.io/blog/nodejs-how-even-quick-async-functions-can-block-the-event-loop-starve-io/" rel="noopener ugc nofollow" target="_blank">事件循环饥饿</a> " [6]。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/f4579a6678a44c720d927e592eb07e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*i8n0pFwSvu-x1UpP.jpg"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Node.js under the Hood by <a class="ae kr" href="https://dev.to/khaosdoctor/node-js-under-the-hood-3-deep-dive-into-the-event-loop-135d" rel="noopener ugc nofollow" target="_blank">dev.to</a>, <a class="ae kr" href="https://dev.to/khaosdoctor" rel="noopener ugc nofollow" target="_blank">Lucas Santos</a> (All rights reserved)</figcaption></figure><p id="9959" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated"><em class="mn"> SetImmediate </em>，顾名思义，确实会立即执行回调函数。<strong class="lm ir">对不起</strong>，不是马上，而是在事件循环的下一轮。几乎立刻。</p><p id="452a" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">如果你是一个真正的夏洛克，那么你解决了这里的谜题并发现，特别是当用递归调用<em class="mn"> process.nextTick </em>并在代码中使用<em class="mn"> setImmediate </em>时，不仅事件循环被搁置，而且<em class="mn"> setImmediate </em>也被挂起。这个例子说明了，确切地了解你所使用的API的情况是多么重要。</p><p id="1616" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">当您计划使用它们时，使用官方文档[2]，[3]来详细了解这两者之间的区别。</p><h1 id="d957" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">最后的堡垒:异步</h1><div class="mz na gp gr nb nc"><a href="https://medium.com/javascript-in-plain-english/javascript-async-await-promisify-the-future-to-callback-never-again-6762707e18e5" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">JavaScript Async Await:承诺未来不再回调！</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">对承诺的回调直到异步等待</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">medium.com</p></div></div><div class="nl l"><div class="nm l nn no np nl nq kl nc"/></div></div></a></div><p id="f62b" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">在大多数情况下，通过使用<em class="mn"> process.nextTick </em>方法，可以将同步函数转换为异步函数。下面的例子说明了一种混合方法，异步和同步工作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="5356" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">将同步部分改为异步部分将使该函数具有统一性和一致性，说明每次将<em class="mn"> A </em>放入函数时，将<em class="mn"> B </em>作为输出的原理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="3e1f" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">你想得到更详细的信息吗？查看艾萨克·施鲁特的博客文章。</p><h1 id="7a44" class="ks kt iq bd ku kv kw kx ky kz la lb lc jw ld jx le jz lf ka lg kc lh kd li lj bi translated">结论</h1><p id="1341" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">我们应该把编程建立在稳定性和一致性的基础上。不能因为代码中有变量，就一定要让代码本身成为变量。函数调用必须是可靠的，不依赖于大小写。让你的回调要么是纯同步的，要么是纯异步的，以避免不一致性，并在可靠性的基础上构建你的API。如果有疑问，将您的同步调用转换为合成异步调用。<br/>对我们有利，那个节点。JS都知道:<em class="mn">流程。NextTick </em>和<em class="mn"> setImmediate </em>。</p><p id="cb87" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated"><a class="ae kr" href="https://arnoldcodeacademy.ck.page/26-web-dev-cheat-sheets" rel="noopener ugc nofollow" target="_blank"> <strong class="lm ir"> <em class="mn">节省自己大量的时间，专注于重要的主题。</em> </strong> </a></p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h2 id="e87f" class="ny kt iq bd ku nz oa dn ky ob oc dp lc lt od oe le lx of og lg mb oh oi li oj bi translated">延伸阅读:</h2><div class="mz na gp gr nb nc"><a href="https://medium.com/javascript-in-plain-english/javascript-es6-modules-import-export-129a90e83ad6" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">JavaScript ES6模块导入导出</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">ES6模块导入导出业务用JavaScript和JS遗留代码</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">medium.com</p></div></div><div class="nl l"><div class="ok l nn no np nl nq kl nc"/></div></div></a></div><div class="mz na gp gr nb nc"><a href="https://medium.com/next-level-source-code/enums-typescript-4-0-and-javascript-guide-all-you-need-to-know-5e090355bff6" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">Enums TypeScript 4.0和JavaScript指南—您需要知道的一切</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">你将读到的关于enums的最后一个指南！</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">medium.com</p></div></div><div class="nl l"><div class="ol l nn no np nl nq kl nc"/></div></div></a></div><div class="mz na gp gr nb nc"><a href="https://medium.com/next-level-source-code/do-you-follow-these-10-principles-for-good-programmers-1445727af447" rel="noopener follow" target="_blank"><div class="nd ab fo"><div class="ne ab nf cl cj ng"><h2 class="bd ir gy z fp nh fr fs ni fu fw ip bi translated">你遵循了优秀程序员的这10条原则吗？</h2><div class="nj l"><h3 class="bd b gy z fp nh fr fs ni fu fw dk translated">从接吻和干燥到足球和YAGNI和聪明屁股代码的10个原则！</h3></div><div class="nk l"><p class="bd b dl z fp nh fr fs ni fu fw dk translated">medium.com</p></div></div><div class="nl l"><div class="om l nn no np nl nq kl nc"/></div></div></a></div><h2 id="5510" class="ny kt iq bd ku nz oa dn ky ob oc dp lc lt od oe le lx of og lg mb oh oi li oj bi translated">参考和链接:</h2><p id="519c" class="pw-post-body-paragraph lk ll iq lm b ln lo jr lp lq lr ju ls lt lu lv lw lx ly lz ma mb mc md me mf ij bi translated">[1] <strong class="lm ir">浩劫的博客</strong>:<a class="ae kr" href="https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/" rel="noopener ugc nofollow" target="_blank">https://Blog . ometer . com/2011/07/24/callbacks-synchronous-and-asynchronous/</a></p><p id="f304" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">[2]<strong class="lm ir">process . next tick()</strong>:<a class="ae kr" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank">https://nodejs . org/en/docs/guides/event-loop-timers-and-next tick/</a></p><p id="a43b" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">[3] <strong class="lm ir">立即设置</strong>:<a class="ae kr" href="https://nodejs.dev/learn/understanding-setimmediate" rel="noopener ugc nofollow" target="_blank">https://nodejs.dev/learn/understanding-setimmediate</a></p><p id="4b74" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated"><strong class="lm ir">【4】节点。JS V0.10 </strong>(稳定):<a class="ae kr" href="https://nodejs.org/en/blog/release/v0.10.0/" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/en/blog/release/v0.10.0/</a></p><p id="5867" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">[5] <strong class="lm ir">为异步设计API</strong>:【https://blog.izs.me/2013/08/designing-apis-for-asynchrony】T2</p><p id="437d" class="pw-post-body-paragraph lk ll iq lm b ln mg jr lp lq mh ju ls lt mi lv lw lx mj lz ma mb mk md me mf ij bi translated">[6] <strong class="lm ir">事件循环饥饿</strong>:<a class="ae kr" href="https://snyk.io/blog/nodejs-how-even-quick-async-functions-can-block-the-event-loop-starve-io/" rel="noopener ugc nofollow" target="_blank">https://snyk . io/blog/nodejs-how-even-quick-async-functions-can-block-the-event-loop-stark-io/</a></p></div></div>    
</body>
</html>