# 如何在 Node.js 中实现 JWT 用户认证

> 原文：<https://javascript.plainenglish.io/how-to-implement-jwt-user-authentication-in-node-js-b6d093f6fa4?source=collection_archive---------3----------------------->

![](img/7233ea8c5f7b243620b2cd5606edcb34.png)

## 使用 JWT 实现用户认证的分步指南

## 先决条件

为了理解本文，您需要对 express 和 node.js 有一个基本的了解。

## JWT 简介

JWT 代表 JSON 网络令牌。这是一种紧凑而安全的传输 JSON 数据的方式。JWT 很容易被验证，因为它是数字签名的。JWT 可用于授权或交换信息。

在本文中，我们将使用 JWT 进行授权。

## 我们开始工作吧！

在主项目目录中打开终端，并编写以下命令:

```
npm init -y
```

这里的`-y`标志有助于将每个值设置为默认值。

现在让我们安装我们需要的软件包。为此，让我们在主项目目录的终端中编写以下命令:

```
npm i express jsonwebtoken express-validator mongoose bcrypt dotenv
```

随着上面的命令，我们安装了`express`、`jsonwebtoken`、`express-validator`、`mongoose`、`bcrypt`、`dotenv`。你显然知道`express`是干什么的。这里，`jsonwebtoken`用于生成和验证 JWT。我们一会儿会用到它。`express-validator`包将帮助我们验证数据。同样，`dotenv`将帮助我们访问**。env** 文件。

现在让我们创建一个名为**的文件。env** 放在我们的主项目目录中，并在文件中写入以下内容:

```
MONGO_URI=             // add mongo URI here
SECRET=               // add secret here
```

`MONGO_URI`应该包含 MongoDB 数据库的 URL。`SECRET`应该包含一些秘密值。`SECRET`可以是任意一组随机的字符串。

输入值后，让我们在主项目目录中创建一个名为 **index.js** 的文件，并编写以下代码行:

在上面的代码中，前几行只是导入。在第 1 行，我们已经导入并配置了`dotenv`。在第 3 行，我们导入了`express`。然后，在第 4 行，我们导入了`mongoose`。在第 6 行，我们导入了`AuthRoute`。在第 8 行，我们初始化了 express 应用程序。然后，在第 10 行，我们使用了`express.json()`中间件。这个中间件帮助我们识别从客户端接收的 JSON 数据。在第 11 行，我们为 *api/auth* 创建了一个路由，并使用`AuthRoute`作为该路由的路由器。在第 13 行，我们创建了一个名为`PORT`的常量。`PORT`存储环境变量`PORT`的值，如果存在，则存储`5000`。在第 14 行，我们在`PORT`启动了我们的服务器。从第 16 行到第 22 行，我们连接到 MongoDB 数据库。在第 17 行，我们输入了`MONGO_URI`的值来建立连接。连接完成后，我们`console.log`它(在第 21 行)。如果出现任何错误，我们在第 22 行记录该错误。

现在让我们来研究路线。为此，让我们在主项目目录中创建一个名为 *routes* 的目录。然后，在 *routes* 目录下创建一个名为 **Auth.js** 的文件。现在让我们打开文件 **Auth.js** ，并在文件中写入以下代码行:

前几行只是导入。在第 1 行，我们导入了`express`。在第 2 行，我们从`express-validator`导入了`check`和`validationResult`。在第 4 行，我们导入了`login`、`signup`和`me`控制器。在第 6 行，我们创建了`router`常量并将`express.Router()`存储在其中。

从第 9 行到第 45 行，我们创建了 */api/auth/signup* 路由。从 11 到 43，我们在`express-validator`的帮助下增加了验证。如果你对`express-validator`没有基本的了解，你可能想看看我写的一篇文章:

[](https://medium.com/javascript-in-plain-english/getting-started-with-express-validator-fae0bbeeb0f9) [## 快速验证器入门

medium.com](https://medium.com/javascript-in-plain-english/getting-started-with-express-validator-fae0bbeeb0f9) 

让我们快速浏览第 9 行到第 45 行。

从第 12 行到第 15 行，我们添加了对`"name"`字段的验证，这样它的最小长度应该是 3。我们还借助于`.withMessage()`(在第 14 行)指定了验证错误消息应该是什么。然后我们修剪数据(在第 15 行)。

从第 17 行到第 20 行，我们向`"email"`字段添加了验证。我们检查了`"email"`字段是否有实际的电子邮件地址。我们指定了验证错误消息应该是什么(在第 19 行)，然后我们序列化了电子邮件(在第 20 行)。

从第 22 行到第 28 行，我们添加了对`"password"`字段的验证。我们已经指定密码的最小长度为 8，最大长度为 15。我们还指定密码字段应该至少有一个数字和一个特殊字符。我们还指定了验证错误消息应该是什么。

然后从第 30 行到第 35 行，我们在自定义验证的帮助下检查了`"password"`和`"confirmPassword"`是否匹配。

现在让我们看一下第 37 到 43 行。在第 38 行，我们将格式化的错误存储在`error`常量中。然后，我们检查第 40 行是否存在`error`。如果`error` 存在，我们发送错误数组和状态码 422，否则我们运行`next()`。之后，在第 44 行，我们定义了控制器应该是`signup`。

从第 48 行到第 66 行，我们为 */api/auth/login* 创建了一个路由。从第 50 行到第 64 行，我们使用`express-validator`添加了验证。让我们把这些台词讲得快一点。从第 50 行到第 56 行，我们添加了对`"email"`和`"password"`字段的验证。我们检查了`"email"`字段是否有有效的电子邮件地址，并在第 51 行定义了验证错误消息。然后，从第 53 行到第 55 行，我们定义了`"password"`字段的最小和最大长度以及验证错误消息。在第 58 行，我们格式化了错误并将其存储在`error`变量中。然后，在第 60 行，我们检查了`error`是否存在。如果`error`存在，我们向用户发送一组错误消息和一个状态代码 422(在第 61 行)。如果`error`不存在，我们运行`next()`。然后，我们在第 65 行指定了`login`控制器。

类似地，在第 69 行，我们为 */api/auth/me* 创建了一个路由，并指定了`me`控制器。

最后，在第 71 行，我们导出了`router`。

既然我们已经研究了路线，现在让我们研究模型。为此，让我们在主项目目录中创建一个名为 *models* 的目录。然后，让我们在*模型*目录中创建一个名为 **User.js** 的文件。现在，让我们在文件中编写以下代码行:

前几行是导入。在第 1 行，我们导入了`mongoose`。在第 2 行，我们导入了`bcrypt`。

从第 4 行到第 8 行，我们创建了`UserSchema`。模式中有`name`、`email`和`password`字段。它们都有`String`的类型，并且是必需的。

在第 10 行，我们使用了`pre`方法。这在保存用户模型之前运行。在第 14 行，我们检查用户模型中的`"password"`字段是否被修改。如果`"password"`字段没有被修改，我们运行`next()`。如果它被修改，我们散列`"password"`字段的数据并将其存储在`hash`变量中(在第 16 行)。然后我们在第 17 行将`hash`存储在`user.password`中。之后，我们在第 19 行运行`next()`。如果在这个过程中发生了一些错误，我们在第 21 行记录这个错误。然后，我们在第 22 行运行`next(e)`。

从第 26 行到第 36 行，我们在`UserSchema`中创建了`comparePassword`方法。在第 28 行，我们比较了纯文本密码(`password`)和散列密码(`this.password`)并将其存储在`result`变量中。然后我们在第 30 行返回了`result`。如果在这个过程中出现任何错误，我们在第 32 行记录错误。然后我们在第 34 行返回`false`。

我们最终在第 38 行导出了`"user"`模型。

到目前为止，我们一直在研究模型。现在让我们来研究控制器。为此，让我们在主项目目录中创建一个名为*控制器*的目录。之后，让我们在*控制器*目录中创建一个名为 **AuthController.js** 的文件。现在让我们打开文件 **AuthController.js** ，并编写下面几行代码:

前几行是导入。在第 1 行，我们导入了`jsonwebtoken`。然后，在第 3 行，我们导入了`User`模型。

从第 5 行到第 26 行，我们创建了`signup`控制器。在第 6 行，我们存储了来自`req.body`的`name`、`email`和`password`的值。在第 9 行，我们用`email`过滤了`User`。如果具有该电子邮件地址的用户已经存在，我们将向该用户发送状态代码 422 和一条错误消息(从第 19 行到第 21 行)。如果拥有这个`email`的用户不存在，我们创建一个新的`User`实例，并将其存储在第 12 行的`newUser`变量中。之后，在第 14 行，我们保存了`newUser`。保存`newUser`后，我们向用户发送成功消息和状态代码 200(在第 16 行)。如果在这个过程中出现任何错误，我们在第 23 行记录这个错误。然后，我们在第 24 行发送一个状态代码 500 和一个错误消息。

从第 28 行到第 49 行，我们创建了`login`控制器。在第 29 行，我们存储了来自`req.body`的`email`和`password`的值。在第 32 行，我们用`email`查询了`User`，并将其存储在`user`变量中。如果`user`不存在，我们向用户发送状态代码 422 和第 34 行的错误消息。如果`user`存在，我们继续比较密码。在第 36 行，我们借助我们在`User`模型中创建的`comparePassword`方法检查密码是否匹配。如果`password`不匹配，我们向用户发送状态代码 403 和第 44 行的错误消息。如果`password`匹配，我们在第 37 行使用`jwt.sign`创建 JSON Web 令牌，并将其存储在`token`常量中。`jwt.sign`接受三个参数。第一个参数接受一个对象。这个对象必须包含一些关于`user`的独一无二的东西，这样我们才能识别这个令牌属于谁。在我们的例子中，我们有一个对象`{id: user._id}`作为第一个参数。类似地，第二个参数接受一个密钥。在我们的例子中，我们使用了`process.env.SECRET`。记得我们之前已经创建了这个`SECRET`变量。第三个参数接受 options 对象。在我们的例子中，我们使用了`expiresIn`选项，并将其设置为`"24h"`。它的作用是，指定`jwt`这个令牌只在 24 小时内有效。这意味着，用户在登录 24 小时后会自动注销。之后，我们编写了代码，在第 41 行向用户发送状态代码 200、成功消息和令牌。如果在这个过程中出现任何错误，我们在第 46 行记录这个错误。然后，我们编写了代码，在第 47 行向用户发送状态代码 500 和一条错误消息。

从第 51 行到第 68 行，我们创建了一个`me`控制器。该控制器有助于获取登录用户的一些信息。让我们仔细看看。在第 52 行，我们存储了来自`"X-Auth"`头的令牌，并将其存储在`token`变量中。这个头应该不一定是`"X-Auth"`。您也可以选择其他标题进行授权。但是您必须足够小心，以免覆盖其他标题。对此还有其他几种方法。如何处理就看你自己了。但在我们的情况下，我们会坚持这一点，好吗？

如果令牌不存在，我们在第 56 行向用户发送状态代码 403 和错误消息。在第 58 行，我们解码了 JWT 并将其存储在`decoded`变量中。为了解码，我们使用了`jwt.verify`。这个`verify`方法接受两个参数。第一个参数应该是`token`，第二个参数应该是密钥。在我们的例子中，密钥是`process.env.SECRET`。

解码令牌后，我们通过 id 查询`User`，并将其存储在`user`变量的第 60 行。在通过 id 进行查询时，我们使用了`decoded.id`。这里的`decoded`包含一个对象。该对象与我们签名时使用的对象相同。在给 JWT 签名时，在第 37 行，我们有一个对象作为`jwt.sign`方法的第一个参数。该对象与我们在`decoded`变量中的对象相同。

在查询了`User`之后，我们检查了`user`是否存在。如果`user`不存在，我们在第 62 行发送状态代码 403 和错误消息。如果`user`存在，我们在第 64 行发送`user`和状态码 200 以及用户信息。

如果在这个过程中出现任何错误，我们在第 66 行记录这个错误。然后，我们在第 67 行发送一个状态代码为 500 的错误消息。

然后，我们最终导出了`login`、`signup`和`me`函数(从第 71 行到第 75 行)。

这意味着，我们已经使用 JWT 完成了认证过程。你可能想用 postman 试试这个。

## **简单英语的 JavaScript**

你知道我们有三份出版物和一个 YouTube 频道吗？在 [**寻找一切的链接 plainenglish.io**](https://plainenglish.io/) ！