<html>
<head>
<title>Your Front End Code Needs To Be Unit Tested</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您的前端代码需要进行单元测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/your-front-end-code-needs-to-be-unit-tested-f998b016c448?source=collection_archive---------2-----------------------#2020-12-01">https://javascript.plainenglish.io/your-front-end-code-needs-to-be-unit-tested-f998b016c448?source=collection_archive---------2-----------------------#2020-12-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9566e706e412824db7967b5cba036966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9E5NA0zT1rLvrbEobtcJGg.png"/></div></div></figure><p id="01b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://www.testcraft.io/front-end-testing/" rel="noopener ugc nofollow" target="_blank">前端测试</a>可以通过多种方式完成，比如单元测试、集成测试、系统测试和验收测试。今天，我们将探讨单元测试的重要性和测试前端代码的技巧。</p><h1 id="d212" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">介绍</h1><p id="80e6" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在我7年多的前端开发经验中，我遇到过很少有人愿意为他们的代码编写单元测试用例。它通常是可选的；如果开发人员有多余的时间，他们会把它作为一项技术任务。很多人认为这是浪费时间、精力和资源。</p><p id="412e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是，如果有什么不同的话，单元测试是对未来的投资。如果处理得当，从长远来看，单元测试可以节省大量的时间、精力和资源。</p><p id="7aff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，我觉得现在需要更多地谈论它，并且像重视业务逻辑一样重视<a class="ae kt" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发</a>。</p><h1 id="4313" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是单元测试？</h1><p id="195f" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated"><a class="ae kt" href="https://en.wikipedia.org/wiki/Unit_testing" rel="noopener ugc nofollow" target="_blank">单元测试</a>意味着测试源代码的单个单元，并验证特定单元是否如预期那样工作。</p><p id="021e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，<strong class="jx io">单元</strong>可以是应用程序/模块中可以被隔离测试的最小部分。</p><p id="62ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它可以是:</p><ul class=""><li id="aa15" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">面向对象编程中的一个类，</li><li id="1808" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">程序设计中的一种功能，</li><li id="fa92" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated">反应、有角、脆弱、苗条等的组成部分。</li></ul><p id="46ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">单元测试的主要目的是验证我们代码的逻辑——代码应该在所有可能的场景下都能很好地工作。如果是的话，那么我们可以确定应用程序不会崩溃。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ml"><img src="../Images/b0a952abcfb8b9680e6c603ed4a984a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*vygtG6PROtGq3XXA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Image credits: <a class="ae kt" href="https://www.pcloudy.com/wp-content/uploads/2019/05/importance-of-unit-testing.png" rel="noopener ugc nofollow" target="_blank">pcloudy.com</a></figcaption></figure><h1 id="172c" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">单元测试的好处</h1><h2 id="0c80" class="mu kv in bd kw mv mw dn la mx my dp le kg mz na li kk nb nc lm ko nd ne lq nf bi translated">使流程<a class="ae kt" href="https://www.agilealliance.org/agile101/" rel="noopener ugc nofollow" target="_blank">更加敏捷</a></h2><p id="51e9" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">随着应用程序的发展和附加功能的增加，可能需要重新审视早期的设计和代码。单元测试可以检测设计契约中的代码破坏变更，允许这些问题被及早发现，从而更快地解决。</p><h2 id="71cc" class="mu kv in bd kw mv mw dn la mx my dp le kg mz na li kk nb nc lm ko nd ne lq nf bi translated">有助于更安全的重构和更简单的调试</h2><p id="7c20" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">当我们重构代码时，我们只改变代码结构，而不是最终结果。重构后的代码应该像以前一样工作。因此，如果我们有适当的单元测试，任何引入代码重构的缺陷都可以很容易地被测试用例检测出来。如果任何一个测试用例失败了，我们也可以很容易地检测到在哪里调试。这也使得<a class="ae kt" href="https://www.geeksforgeeks.org/software-engineering-debugging/" rel="noopener ugc nofollow" target="_blank">调试</a>过程更加容易。</p><h2 id="f77b" class="mu kv in bd kw mv mw dn la mx my dp le kg mz na li kk nb nc lm ko nd ne lq nf bi translated">帮助我们创建一个健壮的、可理解的代码库</h2><p id="365b" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated"><em class="ng">编写逻辑测试用例</em>至关重要，这样，如果任何人对组件/功能进行任何设计变更，单元测试就应该失败。这就是任何不熟悉该代码库的开发人员能够理解该代码最初目的的方式。</p><h2 id="515d" class="mu kv in bd kw mv mw dn la mx my dp le kg mz na li kk nb nc lm ko nd ne lq nf bi translated">帮助文档</h2><p id="609a" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">好的单元测试用例可以作为未来的文档。当一个代码库被很好的记录和正确的单元测试，那么它就很容易维护。</p><p id="2730" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们已经知道了单元测试如何帮助开发周期，让我们来看看测试前端代码的一些技巧。</p><h1 id="eda9" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">决定单元测试的前端代码</h1><p id="cbf2" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">为了能够有效地单元测试我们的代码，我们应该知道测试什么。如果我们看看断言库，或者为编写单元测试用例而提供的API，我们可能会被可以为一段代码编写的测试用例的可能性所淹没。</p><blockquote class="nh"><p id="5caf" class="ni nj in bd nk nl nm nn no np nq ks dk translated"><em class="nr">你的测试越像你的软件被使用的方式，他们就越能给你信心——肯特·多德的推特</em></p></blockquote><p id="0852" class="pw-post-body-paragraph jv jw in jx b jy ns ka kb kc nt ke kf kg nu ki kj kk nv km kn ko nw kq kr ks ig bi translated">我们将通过基本的JavaScript示例探索一些重要的技巧，并看看可以编写什么断言。单元测试用例写在<a class="ae kt" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank">笑话</a>中。</p><p id="a693" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们有一个输入框，应该只接受来自用户的字母数字值。为了验证用户的输入，我创建了一个名为“字母数字验证器”的验证器函数它接受一个字符串并返回一个布尔值(对于有效输入为真，对于无效输入为假)。代码如下:</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="1293" class="mu kv in ny b gy oc od l oe of">export function alphanumericValidator (input) {    <br/>  if (!input) {    <br/>    return false;  <br/>  }<br/>  var alphanumericExp = /^[0-9a-z]+$/;<br/>  if (input.match(alphanumericExp)) {<br/>    return true;<br/>  } else {<br/>    return false;<br/>  }<br/>}</span></pre><p id="cfe3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">测试应该涵盖的基本场景是:</p><h2 id="3534" class="mu kv in bd kw mv mw dn la mx my dp le kg mz na li kk nb nc lm ko nd ne lq nf bi translated">实现的业务逻辑应该被正确地测试</h2><p id="b327" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">单元测试应该测试代码应该做什么。例如，我们将使用下面的断言来检查验证器是否正常工作:</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="23a0" class="mu kv in ny b gy oc od l oe of">// test if it returns true for valid input</span><span id="8afc" class="mu kv in ny b gy og od l oe of">//TEST 1: for only alphabets expect(alphanumericValidator('onlyAlphabets')).toBe(true);</span><span id="0d7a" class="mu kv in ny b gy og od l oe of">// TEST 2: for only numbers expect(alphanumericValidator('123')).toBe(true);</span><span id="656e" class="mu kv in ny b gy og od l oe of">// TEST 3: for both numeric and alphabets together<br/>expect(alphanumericValidator('alphabets123')).toBe(true);</span></pre><p id="0203" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些测试确保了我们的前端代码如预期的那样工作。验证器确实正确地验证了字母数字值，因此，它工作正常，符合业务逻辑。</p><h2 id="3681" class="mu kv in bd kw mv mw dn la mx my dp le kg mz na li kk nb nc lm ko nd ne lq nf bi translated">应测试代码中存在的所有条件和分支</h2><p id="7715" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">代码中的所有<em class="ng"> if </em>和<em class="ng">否则</em>开关情况<strong class="jx io"> </strong>都应该进行单元测试，以验证代码是否在所有可能的实时场景中按预期工作。</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="849c" class="mu kv in ny b gy oc od l oe of">// TEST 4: testing the else path for invalid inputexpect(alphanumericValidator('alpha123@@@@@@')).toBe(false);</span><span id="561a" class="mu kv in ny b gy og od l oe of">// TEST 5: for special characters inputexpect(alphanumericValidator('#./')).toBe(false);</span></pre><p id="5d02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些测试确保了我们的前端代码不允许用户输入任何不可接受的值，比如特殊字符。这是第一条规则的扩展，帮助我们防止由于用户错误地发送了不正确的值而可能发生的错误。</p><h2 id="5d39" class="mu kv in bd kw mv mw dn la mx my dp le kg mz na li kk nb nc lm ko nd ne lq nf bi translated">测试意外场景或负面用例</h2><p id="f33f" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们应该通过尝试中断代码来测试错误场景，并通过测试用例来验证代码不会在角落或者意外的输入场景中中断，比如null/undefined值。当我们有可选参数时，这一点尤其重要。</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="d068" class="mu kv in ny b gy oc od l oe of">// TEST 6, 7: for null/undefined input valuesexpect(alphanumericValidator(null)).toBe(false);<br/>expect(alphanumericValidator(undefined)).toBe(false);</span><span id="7949" class="mu kv in ny b gy og od l oe of">// TEST 8, 9: for empty strings or no input valuesexpect(alphanumericValidator('')).toBe(false);<br/>expect(alphanumericValidator()).toBe(false);</span></pre><p id="d9e0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些测试使我们的前端代码健壮，并避免由于用户输入的意外输入而破坏应用程序和网站。</p><h1 id="3bea" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">可跳过的场景</h1><p id="8cad" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">虽然有一些场景对于测试我们的代码是否健壮是必不可少的，但是也有一些场景对于通过单元测试用例进行测试来说是不那么必要的。</p><p id="330e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来探索一些这样的使用案例:</p><ol class=""><li id="2bce" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks oh md me mf bi translated">测试静态值、常量、枚举等。</li></ol><p id="11cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样的测试用例没有任何实质性的帮助，而只是增加了代码覆盖率(这与代码质量没有太大关系)。示例:</p><pre class="mm mn mo mp gt nx ny nz oa aw ob bi"><span id="369c" class="mu kv in ny b gy oc od l oe of">expect(1).toBe(1);</span></pre><p id="dfa0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> 2。测试外部依赖或库的功能</strong></p><p id="3f41" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">术语“单元测试”是指测试<em class="ng">单元</em>，因此，测试该单元中使用的任何依赖项的实际功能不会给单元测试过程增加任何价值。这是因为外部依赖的功能已经通过单元测试时编写的单独测试用例进行了验证和测试。</p><h1 id="d330" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">单元测试工具</h1><p id="8237" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">因为有多种编程语言可供我们编码，所以有多种工具、库和框架可用于对代码进行单元测试。PFB使用普通JavaScript或JavaScript库/框架编写的前端代码的一些单元测试工具:</p><ul class=""><li id="97b7" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated"><a class="ae kt" href="https://mochajs.org/" rel="noopener ugc nofollow" target="_blank">摩卡</a></li><li id="410c" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><a class="ae kt" href="https://jestjs.io/" rel="noopener ugc nofollow" target="_blank">笑话</a></li><li id="e40a" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><a class="ae kt" href="https://jasmine.github.io/" rel="noopener ugc nofollow" target="_blank">茉莉</a></li><li id="05cb" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><a class="ae kt" href="https://github.com/testing-library/react-testing-library" rel="noopener ugc nofollow" target="_blank"> React测试库</a></li><li id="77f1" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><a class="ae kt" href="https://vuejs.org/v2/guide/testing.html" rel="noopener ugc nofollow" target="_blank"> Vue测试库</a></li><li id="8e01" class="lx ly in jx b jy mg kc mh kg mi kk mj ko mk ks mc md me mf bi translated"><a class="ae kt" href="https://github.com/testing-library/svelte-testing-library" rel="noopener ugc nofollow" target="_blank">苗条测试库</a></li></ul><h1 id="965d" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="cd19" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">有很多次，我感谢过去的自己编写了一个测试用例，让我避免了一个巨大的错误，并防止了一个几乎肯定会出现的产品错误。</p><p id="6d2a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">单元测试不应该被视为开销或负担，相反，我们应该将它们作为日常实践和健康的编码习惯。</p><figure class="mm mn mo mp gt jo gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/522d8662a43d44acc582baa009a1f3ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/0*Lvqc6b-wRncG9Zxe.jpg"/></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">image credits: <a class="ae kt" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fmemegenerator.net%2Finstance%2F36483108%2Fone-does-not-simply-one-does-not-simply-refactor-legacy-code-without-unit-tests&amp;psig=AOvVaw3ksrMMi97Y53Y2cu9Gi-Dk&amp;ust=1606325242135000&amp;source=images&amp;cd=vfe&amp;ved=0CA0QjhxqFwoTCNi-oLPam-0CFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">meme generator</a></figcaption></figure></div><div class="ab cl oj ok hr ol" role="separator"><span class="om bw bk on oo op"/><span class="om bw bk on oo op"/><span class="om bw bk on oo"/></div><div class="ig ih ii ij ik"><p id="07d3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">敬请期待，下篇再来抓你！！任何反馈都是非常值得的。</p><p id="fc22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢您的阅读，祝您有美好的一天！！</p></div></div>    
</body>
</html>