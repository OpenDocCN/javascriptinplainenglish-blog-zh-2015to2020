<html>
<head>
<title>How to Deep Copy Objects and Arrays in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中深度复制对象和数组</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-deep-copy-objects-and-arrays-in-javascript-7c911359b089?source=collection_archive---------0-----------------------#2019-10-07">https://javascript.plainenglish.io/how-to-deep-copy-objects-and-arrays-in-javascript-7c911359b089?source=collection_archive---------0-----------------------#2019-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e06d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">复制对象或数组的常用方法只能进行浅层复制，因此深层嵌套引用是个问题。如果一个JavaScript对象包含其他对象，您需要一个深层副本。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c36a88a066f5f715d71a189c9a01d7e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G2DfJtQ5-h9DE_ps"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@joaosilas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">João Silas</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="79da" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是浅抄？</h1><p id="a585" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated">对数组或对象进行浅层复制意味着在对象内部创建对原始值的新引用，并复制它们。</p><p id="9ae7" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">这意味着对原始数组的更改不会影响复制的数组，如果只复制了对数组的引用就会发生这种情况(例如使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators" rel="noopener ugc nofollow" target="_blank">赋值操作符</a> <code class="fe my mz na nb b">=</code>)就会发生这种情况。</p><p id="f723" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">浅拷贝是指只拷贝一个级别，这对于只包含原始值的数组或对象来说很好。</p><p id="2282" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">对于包含其他对象或数组的对象和数组，复制这些对象需要深层复制。否则，对嵌套引用所做的更改将会更改嵌套在原始对象或数组中的数据。</p><p id="6a9f" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">在本文中，我描述了用JavaScript制作浅层副本的4种方法和制作深层副本的5种方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/179e42ae44c5879ae14d6f33df5c2433.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cz2cRp04Zi9wPOf1"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jakobowens1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jakob Owens</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="be86" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">使用<code class="fe my mz na nb b">…</code>进行浅层复制</h1><p id="cf3f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 1。</span><a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-add-to-an-array-in-react-state-3d08ddb2e1dc" rel="noopener">spread操作符</a> ( <code class="fe my mz na nb b">…</code>)是一种简单复制数组或对象的便捷方法——当没有嵌套时，它非常有效。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="a276" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">如上所示，spread运算符对于创建新的数组实例很有用，这些实例不会由于旧的引用而出现意外行为。因此，扩展操作符对于<a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-add-to-an-array-in-react-state-3d08ddb2e1dc" rel="noopener">添加到处于反应状态</a>的数组是有用的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/cd57d21eca8ccf10fd0f6487cc556de6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S4g0aW00iw4lpbzl"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@wizwow?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Donald Giannatti</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6b68" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">使用<code class="fe my mz na nb b">.slice()</code>进行浅层复制</h1><p id="9115" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 2。</span>特别是对于数组，使用内置的<code class="fe my mz na nb b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank">.slice()</a></code>方法与spread操作符的工作原理相同——创建一个级别的浅层副本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/8d1cee78423ec9c271d4df9a87ed0298.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dN3av_QweZPI1NMp"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@angarav?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Antonio Garcia</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ae07" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">浅层复制使用。分配()</h1><p id="9684" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 3。</span>使用<code class="fe my mz na nb b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" rel="noopener ugc nofollow" target="_blank">Object.assign()</a></code>可以创建相同类型的浅拷贝，它可以用于任何对象或数组:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/b785c61a748e9c47dcbeaf3fd2f7bed7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bV7fRKw2hF2Wmx0N"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Paweł Czerwiński</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="aecb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">使用<code class="fe my mz na nb b">Array.from()</code>浅拷贝数组</h1><p id="973f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 4。</span>复制JavaScript数组的另一种方法是使用<code class="fe my mz na nb b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" rel="noopener ugc nofollow" target="_blank">Array.from()</a></code>，这也将进行浅层复制，如下例所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="72ef" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">如果一个对象或数组包含其他对象或数组，浅表副本将意外工作，因为嵌套对象实际上并没有被克隆。</p><p id="d1e9" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">对于深度嵌套的对象，需要一个深度副本。我在下面解释原因。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/e3e1af88c7479b7375e5b8f58a18b6ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AlvC_hNb886n_ds4"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@brabusbiturbo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">brabus biturbo</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="55cf" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">小心深层嵌套的陷阱！</h1><p id="8a08" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di">另一方面，当JavaScript对象(包括数组)深度嵌套时，spread操作符只复制第一层的新引用，但更深的值仍然链接在一起。</span></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="8145" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">要解决这个问题，需要创建深层拷贝，而不是浅层拷贝。可以使用Ramda函数编程库中的<a class="ae kv" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash </a>、<a class="ae kv" href="https://github.com/davidmarkclements/rfdc" rel="noopener ugc nofollow" target="_blank"> rfdc </a>或<a class="ae kv" href="https://ramdajs.com/docs/#clone" rel="noopener ugc nofollow" target="_blank"> R.clone()方法</a>来制作深度副本。接下来我探索深层副本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nj"><img src="../Images/eed581690d3c4f7d8f8153a61aba7e5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QpvcBwJoh1kyxmWM"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@lbmartin12?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Landon Martin</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2553" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是深度复制？</h1><p id="367e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> F </span>或包含其他对象或数组的对象和数组，复制这些对象需要深度复制。否则，对嵌套引用所做的更改将会更改嵌套在原始对象或数组中的数据。</p><p id="408b" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">这与浅复制相比，浅复制对于只包含基元值的对象或数组工作良好，但是对于任何具有对其他对象或数组的嵌套引用的对象或数组都将失败。</p><p id="49ce" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">理解<a class="ae kv" href="https://medium.com/better-programming/making-sense-of-vs-in-javascript-f9dbbc6352e3" rel="noopener"/><code class="fe my mz na nb b"><a class="ae kv" href="https://medium.com/better-programming/making-sense-of-vs-in-javascript-f9dbbc6352e3" rel="noopener">==</a></code><a class="ae kv" href="https://medium.com/better-programming/making-sense-of-vs-in-javascript-f9dbbc6352e3" rel="noopener">和</a> <code class="fe my mz na nb b"><a class="ae kv" href="https://medium.com/better-programming/making-sense-of-vs-in-javascript-f9dbbc6352e3" rel="noopener">===</a></code>之间的区别有助于直观地看到浅拷贝和深拷贝之间的区别，因为严格相等运算符(<code class="fe my mz na nb b">===</code>)表明嵌套引用是相同的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="ac71" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">我将介绍制作深度副本(或深度克隆)的5种方法:<a class="ae kv" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash </a>、<a class="ae kv" href="https://ramdajs.com" rel="noopener ugc nofollow" target="_blank"> Ramda </a>、自定义函数、<code class="fe my mz na nb b"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-use-stringify-and-parse-in-javascript-6b637b571a32" rel="noopener">JSON.parse()</a></code> / <code class="fe my mz na nb b"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-use-stringify-and-parse-in-javascript-6b637b571a32" rel="noopener">JSON.stringify()</a></code>和<code class="fe my mz na nb b"><a class="ae kv" href="https://www.npmjs.com/package/rfdc" rel="noopener ugc nofollow" target="_blank">rfdc</a></code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/c0370bfa6a10899891f125e3285b6ada.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m8aVB1a1QNn9yB94"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@htetwai2000?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">mya thet khine</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a938" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">带lodash的深层副本</h1><p id="de65" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 1。</span>库<a class="ae kv" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash </a>是JavaScript开发者进行深度复制最常见的方式。它非常容易使用:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="4375" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">Lodash的名字来自于被引用为下划线(<code class="fe my mz na nb b">_</code>)、“低破折号”或简称lodash的库。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/0b5bc96005f04be53b709b9eff77d295.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4i31CiN9e3lcXJHa"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@anniespratt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Annie Spratt</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a30c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">使用Ramda进行深度复制</h1><p id="1300" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 2。</span>函数式编程库<a class="ae kv" href="https://ramdajs.com" rel="noopener ugc nofollow" target="_blank"> Ramda </a>包含<code class="fe my mz na nb b"><a class="ae kv" href="https://ramdajs.com/docs/#clone" rel="noopener ugc nofollow" target="_blank">R.clone()</a></code> <a class="ae kv" href="https://ramdajs.com/docs/#clone" rel="noopener ugc nofollow" target="_blank">方法</a>，对一个对象或数组进行深度复制。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="f047" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">注意，来自Ramda的<code class="fe my mz na nb b">R.clone()</code>相当于lodash的<code class="fe my mz na nb b">_.cloneDeep()</code>，因为Ramda没有浅层复制帮助器方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/72286ceee67fb04cf3825e823551b945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jmRmo9KcWVYCeTUN"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@roi_dimor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Roi Dimor</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a15d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">具有自定义功能的深层复制</h1><p id="855d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 3。编写一个递归的JavaScript函数来深度复制嵌套的对象或数组是非常容易的。这里有一个例子:</span></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c228" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">注意，我还需要<a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-check-for-null-in-javascript-dffab64d8ed5" rel="noopener">检查空值</a>，因为空值<code class="fe my mz na nb b">typeof</code>是“对象”</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/39706a0e6b7a819f600d10633c67bfc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pNTB7aSB_rIqK3BN"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@scottwebb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Scott Webb</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d82c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">深度复制与<a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-use-stringify-and-parse-in-javascript-6b637b571a32" rel="noopener">JSON.parse/stringify</a></h1><p id="6382" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 4。</span>如果你的数据符合规范(见下文)，那么<code class="fe my mz na nb b"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-use-stringify-and-parse-in-javascript-6b637b571a32" rel="noopener">JSON.stringify</a></code> <a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-use-stringify-and-parse-in-javascript-6b637b571a32" rel="noopener">后面跟着</a> <code class="fe my mz na nb b"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-use-stringify-and-parse-in-javascript-6b637b571a32" rel="noopener">JSON.parse</a></code>将深度复制你的对象。</p><blockquote class="nn"><p id="072d" class="no np iq bd nq nr ns nt nu nv nw mj dk translated">“如果你不在你的对象中使用<code class="fe my mz na nb b">Date</code>、函数、<code class="fe my mz na nb b">undefined</code>、<code class="fe my mz na nb b">Infinity</code>、【NaN】、正则表达式、映射、集合、Blobs、文件列表、ImageDatas、稀疏数组、类型化数组或其他复杂类型，一个非常简单的深度克隆对象的方法是:<code class="fe my mz na nb b">JSON.parse(JSON.stringify(object))</code>”——<a class="nx ny ep" href="https://medium.com/u/6717ba7c28b2?source=post_page-----7c911359b089--------------------------------" rel="noopener" target="_blank">丹·达斯卡雷斯库</a> <a class="ae kv" href="https://stackoverflow.com/a/122704" rel="noopener ugc nofollow" target="_blank">在他的StackOverflow回答</a></p></blockquote><p id="1f37" class="pw-post-body-paragraph lo lp iq lq b lr nz jr lt lu oa ju lw lx ob lz ma mb oc md me mf od mh mi mj ij bi translated">为了说明通常不推荐这种方法的原因，这里有一个使用<code class="fe my mz na nb b">JSON.parse(JSON.stringify(object))</code>创建深层副本的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="c758" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">自定义函数或提到的库可以进行深度复制，而不需要担心内容的类型，尽管循环引用会使它们出错。</p><p id="4696" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">接下来，我将讨论一个名为<code class="fe my mz na nb b">rfdc</code>的速度极快的库，它可以处理循环引用，速度与定制的深度复制函数一样快。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/0d3513a25c31cd3adf1b371ba5613b2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xQeIG-uByn5uQOVx"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@scottwebb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Scott Webb</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="1faa" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">真的快速深度复制？思考<code class="fe my mz na nb b"><a class="ae kv" href="https://www.npmjs.com/package/rfdc" rel="noopener ugc nofollow" target="_blank">rfdc</a></code></h1><p id="6fa5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di"> 5。</span>为了获得最佳性能，库<code class="fe my mz na nb b"><a class="ae kv" href="https://www.npmjs.com/package/rfdc" rel="noopener ugc nofollow" target="_blank">rfdc</a></code> <a class="ae kv" href="https://www.npmjs.com/package/rfdc" rel="noopener ugc nofollow" target="_blank">(真正快速的深度克隆)</a>将比lodash的<code class="fe my mz na nb b">_.cloneDeep</code>快400%左右进行深度复制:</p><blockquote class="nn"><p id="b9df" class="no np iq bd nq nr ns nt nu nv nw mj dk translated">"<code class="fe my mz na nb b">rdfc</code>克隆所有JSON类型:<code class="fe my mz na nb b">Object </code><code class="fe my mz na nb b">Array </code><code class="fe my mz na nb b">Number </code><code class="fe my mz na nb b">String </code><code class="fe my mz na nb b">null</code></p><p id="e1f4" class="no np iq bd nq nr ns nt nu nv nw mj dk translated">附加支持:<code class="fe my mz na nb b">Date</code>(复制)<code class="fe my mz na nb b">undefined</code>(复制)<code class="fe my mz na nb b">Function</code>(引用)<code class="fe my mz na nb b">AsyncFunction</code>(引用)<code class="fe my mz na nb b">GeneratorFunction</code>(引用)<code class="fe my mz na nb b">arguments</code>(复制到普通对象)</p><p id="826c" class="no np iq bd nq nr ns nt nu nv nw mj dk translated">所有其他类型的输出值与<code class="fe my mz na nb b">JSON.parse(JSON.stringify(o))</code>的输出相匹配。“— <a class="ae kv" href="https://github.com/davidmarkclements/rfdc" rel="noopener ugc nofollow" target="_blank"> rfdc文档</a></p></blockquote><p id="9230" class="pw-post-body-paragraph lo lp iq lq b lr nz jr lt lu oa ju lw lx ob lz ma mb oc md me mf od mh mi mj ij bi translated">使用<code class="fe my mz na nb b">rfdc</code>非常简单，就像其他库一样:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nd ne l"/></div></figure><p id="85f7" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated"><code class="fe my mz na nb b">rfdc</code>库支持所有类型，也支持带有可选标志的循环引用，这会降低大约25%的性能。</p><p id="e335" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">循环引用会破坏其他讨论过的深度复制算法。</p><p id="60bd" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">如果你正在处理一个大型复杂的对象，比如从3MB的JSON文件中加载的对象(大小为15MB ),这样的库会很有用。</p><p id="036b" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">以下是基准测试，显示在处理如此大的对象时<code class="fe my mz na nb b">rfdc</code>快了大约400%:</p><blockquote class="of og oh"><p id="c31a" class="lo lp oi lq b lr mt jr lt lu mu ju lw oj mv lz ma ok mw md me ol mx mh mi mj ij bi translated"><code class="fe my mz na nb b">benchLodashCloneDeep*100: 1461.134ms<br/>benchRfdc*100: 323.899ms<br/>benchRfdcCircles*100: 384.561ms </code> — <a class="ae kv" href="https://github.com/davidmarkclements/rfdc" rel="noopener ugc nofollow" target="_blank"> rfdc文件</a></p></blockquote><ul class=""><li id="9631" class="om on iq lq b lr mt lu mu lx oo mb op mf oq mj or os ot ou bi translated">库<code class="fe my mz na nb b">rfdc</code>(真正快速的深度克隆)是GitHub 上的<a class="ae kv" href="https://github.com/davidmarkclements/rfdc" rel="noopener ugc nofollow" target="_blank">和</a><a class="ae kv" href="https://www.npmjs.com/package/rfdc" rel="noopener ugc nofollow" target="_blank"> npm </a>:</li></ul><div class="ov ow gp gr ox oy"><a href="https://github.com/davidmarkclements/rfdc" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">davidmarkclements/rfdc</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">真正快速的深度克隆。通过在GitHub上创建一个帐户来为davidmarkclements/rfdc开发做贡献。</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">github.com</p></div></div><div class="ph l"><div class="pi l pj pk pl ph pm kp oy"/></div></div></a></div><div class="ov ow gp gr ox oy"><a href="https://www.npmjs.com/package/rfdc" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">rfdc</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">真正快速的深度克隆</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">www.npmjs.com</p></div></div><div class="ph l"><div class="pn l pj pk pl ph pm kp oy"/></div></div></a></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/9b0096df2be0e549c5c7ac6156eb5306.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GLuWlkSBRzK5q-gC"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@scottwebb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Scott Webb</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="197a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">JavaScript复制算法的性能</h1><p id="4e49" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated"><span class="l ml mm mn bm mo mp mq mr ms di">在</span>的各种复制算法中，浅层复制最快，其次是使用自定义函数或<code class="fe my mz na nb b">rfdc</code>的深层复制:</p><blockquote class="of og oh"><p id="9d09" class="lo lp oi lq b lr mt jr lt lu mu ju lw oj mv lz ma ok mw md me ol mx mh mi mj ij bi translated"><strong class="lq ir">“按表现深度复制:</strong>从最好到最差排序</p><p id="b2fa" class="lo lp oi lq b lr mt jr lt lu mu ju lw oj mv lz ma ok mw md me ol mx mh mi mj ij bi translated">重新分配"<code class="fe my mz na nb b"><em class="iq">=</em></code>"(仅字符串数组、数字数组)</p><p id="8f8b" class="lo lp oi lq b lr mt jr lt lu mu ju lw oj mv lz ma ok mw md me ol mx mh mi mj ij bi translated">切片(仅字符串数组、数字数组)</p><p id="eda6" class="lo lp oi lq b lr mt jr lt lu mu ju lw oj mv lz ma ok mw md me ol mx mh mi mj ij bi translated">串联(仅字符串数组、数字数组)</p><p id="85d2" class="lo lp oi lq b lr mt jr lt lu mu ju lw oj mv lz ma ok mw md me ol mx mh mi mj ij bi translated">自定义函数:for循环或递归复制</p><p id="246f" class="lo lp oi lq b lr mt jr lt lu mu ju lw oj mv lz ma ok mw md me ol mx mh mi mj ij bi translated">【<em class="iq">作者注:</em> <code class="fe my mz na nb b"><em class="iq">rfdc</em></code> <em class="iq">会在这里，像自定义函数</em>一样快</p><p id="ad33" class="lo lp oi lq b lr mt jr lt lu mu ju lw oj mv lz ma ok mw md me ol mx mh mi mj ij bi translated">jQuery的<code class="fe my mz na nb b"><em class="iq">$.extend</em></code></p><p id="29d9" class="lo lp oi lq b lr mt jr lt lu mu ju lw oj mv lz ma ok mw md me ol mx mh mi mj ij bi translated"><code class="fe my mz na nb b"><em class="iq">JSON.parse</em></code>(仅字符串数组、数字数组、对象数组)</p><p id="1660" class="lo lp oi lq b lr mt jr lt lu mu ju lw oj mv lz ma ok mw md me ol mx mh mi mj ij bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Underscore.js" rel="noopener ugc nofollow" target="_blank">下划线. js </a>的<code class="fe my mz na nb b"><em class="iq">_.clone</em></code>(仅字符串数组、数字数组)</p><p id="5eed" class="lo lp oi lq b lr mt jr lt lu mu ju lw oj mv lz ma ok mw md me ol mx mh mi mj ij bi translated">洛-达什的<code class="fe my mz na nb b"><em class="iq">_.cloneDeep</em></code>——<a class="nx ny ep" href="https://medium.com/u/1972a0656243?source=post_page-----7c911359b089--------------------------------" rel="noopener" target="_blank">蒂姆·蒙塔古</a> <a class="ae kv" href="https://stackoverflow.com/users/1404726" rel="noopener ugc nofollow" target="_blank">在他的StackOverflow回答</a></p></blockquote><p id="6523" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">使用<code class="fe my mz na nb b">JSON.parse</code> / <code class="fe my mz na nb b">JSON.stringify</code>会产生关于数据类型的问题，所以推荐使用<code class="fe my mz na nb b">rfdc</code>——除非你想写一个定制函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/cec0fdba3ff1c41acdabb4b0dcdb8baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5GsmBgThck8et4My"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@keilahoetzel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Keila Hötzel</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="355e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论:如何在JavaScript中深度复制</h1><p id="dc8f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi mk translated">如果你不能将对象和数组嵌套在一起，实际上很容易避免JavaScript中的深度复制。</p><p id="bcce" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">因为在这种情况下——没有嵌套，对象和数组只包含原始值——使用spread操作符(<code class="fe my mz na nb b">…</code>)、<code class="fe my mz na nb b">.slice()</code>和<code class="fe my mz na nb b">.assign()</code>进行浅层复制都非常有效。</p><p id="5dd1" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">但是，在现实世界中，对象内部有数组，反之亦然，那么就需要使用深度拷贝。深度克隆我推荐<code class="fe my mz na nb b"><a class="ae kv" href="https://www.npmjs.com/package/rfdc" rel="noopener ugc nofollow" target="_blank">rfdc</a></code>。</p><p id="4057" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">(注意，有些人可能还会建议使用<code class="fe my mz na nb b"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-use-stringify-and-parse-in-javascript-6b637b571a32" rel="noopener">JSON.stringify()</a></code> <a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-use-stringify-and-parse-in-javascript-6b637b571a32" rel="noopener">后跟</a> <code class="fe my mz na nb b"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-use-stringify-and-parse-in-javascript-6b637b571a32" rel="noopener">JSON.parse()</a></code>，但这不是进行深度复制的可靠方式。)</p><p id="8bd5" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated">现在出去深层复制一些嵌套的对象！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/d23e78fe4c50f079d00d213f03ae5787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2VEW0qnKmZobujSD"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@kristinaco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kristina Evstifeeva</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="986f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">进一步阅读</h1><ul class=""><li id="2d32" class="om on iq lq b lr ls lu lv lx pq mb pr mf ps mj or os ot ou bi translated"><a class="ae kv" href="https://alligator.io/js/deep-cloning-javascript-objects/" rel="noopener ugc nofollow" target="_blank"> Alligator.io </a>有一篇关于使用lodash进行深度克隆的很棒的文章:</li></ul><div class="ov ow gp gr ox oy"><a href="https://alligator.io/js/deep-cloning-javascript-objects/" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">JavaScript中的深度克隆对象(及其工作原理)</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">如果你计划用JavaScript编码，你需要理解对象是如何工作的。它们是最重要的…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">鳄鱼. io</p></div></div><div class="ph l"><div class="pt l pj pk pl ph pm kp oy"/></div></div></a></div><ul class=""><li id="de41" class="om on iq lq b lr mt lu mu lx oo mb op mf oq mj or os ot ou bi translated"><a class="nx ny ep" href="https://medium.com/u/829a804ea5da?source=post_page-----7c911359b089--------------------------------" rel="noopener" target="_blank"> Samantha Ming </a>向解释<a class="ae kv" href="https://dev.to/samanthaming/how-to-deep-clone-an-array-in-javascript-3cig" rel="noopener ugc nofollow" target="_blank"> dev上的浅层和深层副本:</a></li></ul><div class="ov ow gp gr ox oy"><a href="https://dev.to/samanthaming/how-to-deep-clone-an-array-in-javascript-3cig" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">如何在JavaScript中深度克隆数组</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">有两种类型的阵列克隆:浅层和深层。浅层拷贝仅覆盖阵列的第一级，其余的…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">开发到</p></div></div><div class="ph l"><div class="pu l pj pk pl ph pm kp oy"/></div></div></a></div><ul class=""><li id="8a61" class="om on iq lq b lr mt lu mu lx oo mb op mf oq mj or os ot ou bi translated"><a class="nx ny ep" href="https://medium.com/u/e3bdfe7f3308?source=post_page-----7c911359b089--------------------------------" rel="noopener" target="_blank"> Peter Tasker </a>关于<a class="ae kv" href="https://dev.to/ptasker/best-way-to-copy-an-object-in-javascript-827" rel="noopener ugc nofollow" target="_blank">开发到</a>的文章引发了许多评论，包括对<code class="fe my mz na nb b">JSON.parse(JSON.stringify(obj))</code>何时失败的解释:</li></ul><div class="ov ow gp gr ox oy"><a href="https://dev.to/ptasker/best-way-to-copy-an-object-in-javascript-827" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">用JavaScript复制对象的最好方法是什么？</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">所以这些天我一直在寻找一种尽可能使用普通JS的方法，我发现深度复制一个</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">开发到</p></div></div><div class="ph l"><div class="pv l pj pk pl ph pm kp oy"/></div></div></a></div><ul class=""><li id="96f2" class="om on iq lq b lr mt lu mu lx oo mb op mf oq mj or os ot ou bi translated"><a class="nx ny ep" href="https://medium.com/u/f9fae2b0ef24?source=post_page-----7c911359b089--------------------------------" rel="noopener" target="_blank"> James Dorr </a>用简单的英语在<a class="ae kv" href="https://medium.com/javascript-in-plain-english/setstate-not-working-shallow-copy-vs-deep-copy-lodash-55a015db80ff" rel="noopener"> JavaScript中讲述了</a><a class="ae kv" href="https://medium.com/javascript-in-plain-english/how-to-add-to-an-array-in-react-state-3d08ddb2e1dc" rel="noopener">向一个数组添加React状态</a>(因为React状态是不可变的)时需要复制:</li></ul><div class="ov ow gp gr ox oy"><a href="https://medium.com/javascript-in-plain-english/setstate-not-working-shallow-copy-vs-deep-copy-lodash-55a015db80ff" rel="noopener follow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">。setState()不起作用—浅层复制与深层复制&amp; Lodash</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">浅层拷贝与深层拷贝&amp; Lodash</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">浅层复制vs深层复制&amp; Lodashmedium.com</p></div></div><div class="ph l"><div class="pw l pj pk pl ph pm kp oy"/></div></div></a></div><ul class=""><li id="fb85" class="om on iq lq b lr mt lu mu lx oo mb op mf oq mj or os ot ou bi translated"><a class="nx ny ep" href="https://medium.com/u/4b427da842ba?source=post_page-----7c911359b089--------------------------------" rel="noopener" target="_blank"> Ramón Miklus </a>使用<a class="ae kv" href="https://www.npmjs.com/package/immutability-helper" rel="noopener ugc nofollow" target="_blank">immutanbility-helper</a>，一个用于维护数据不变性的库，而不是lodash到<a class="ae kv" href="https://www.codementor.io/ramnmiklus/deep-copying-an-object-in-javascript-mdlj2c318" rel="noopener ugc nofollow" target="_blank"> Codementor </a>上的深度复制:</li></ul><div class="ov ow gp gr ox oy"><a href="https://www.codementor.io/ramnmiklus/deep-copying-an-object-in-javascript-mdlj2c318" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">在JavaScript | Codementor中深度复制对象</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">使用spread语法或Object.assign()是在JavaScript中复制对象的标准方式。这两种方法都可以…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">www.codementor.io</p></div></div><div class="ph l"><div class="px l pj pk pl ph pm kp oy"/></div></div></a></div><ul class=""><li id="5e9f" class="om on iq lq b lr mt lu mu lx oo mb op mf oq mj or os ot ou bi translated">说到不变性，<a class="nx ny ep" href="https://medium.com/u/7b585b769590?source=post_page-----7c911359b089--------------------------------" rel="noopener" target="_blank"> Gabriel Lebec </a>在<a class="ae kv" href="https://dev.to/glebec/four-ways-to-immutability-in-javascript-3b3l" rel="noopener ugc nofollow" target="_blank"> dev.to </a>中有一个很好的指导:</li></ul><div class="ov ow gp gr ox oy"><a href="https://dev.to/glebec/four-ways-to-immutability-in-javascript-3b3l" rel="noopener  ugc nofollow" target="_blank"><div class="oz ab fo"><div class="pa ab pb cl cj pc"><h2 class="bd ir gy z fp pd fr fs pe fu fw ip bi translated">JavaScript中实现不变性的四种方式</h2><div class="pf l"><h3 class="bd b gy z fp pd fr fs pe fu fw dk translated">本文介绍了在JavaScript中不变地更新数据结构的四种不同技术:许多代码…</h3></div><div class="pg l"><p class="bd b dl z fp pd fr fs pe fu fw dk translated">开发到</p></div></div><div class="ph l"><div class="py l pj pk pl ph pm kp oy"/></div></div></a></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pz"><img src="../Images/0ae92c2c9ae875309ff5d80cc27a90b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VkivJ4WAUVw0_n4x"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jiangxulei1990?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">青 晨</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl qa qb hu qc" role="separator"><span class="qd bw bk qe qf qg"/><span class="qd bw bk qe qf qg"/><span class="qd bw bk qe qf"/></div><div class="ij ik il im in"><p id="fba6" class="pw-post-body-paragraph lo lp iq lq b lr mt jr lt lu mu ju lw lx mv lz ma mb mw md me mf mx mh mi mj ij bi translated"><a class="ae kv" href="https://www.linkedin.com/in/derek-austin/" rel="noopener ugc nofollow" target="_blank">Derek Austin</a>博士是《职业编程:如何在6个月内成为一名成功的6位数程序员 》一书的作者，该书现已在亚马逊上架。</p></div></div>    
</body>
</html>