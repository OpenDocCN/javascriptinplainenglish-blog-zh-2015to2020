<html>
<head>
<title>JavaScript Code Styling Best Practices — Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript代码样式最佳实践—函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-code-styling-best-practices-functions-8d0f5176c8f7?source=collection_archive---------9-----------------------#2020-05-20">https://javascript.plainenglish.io/javascript-code-styling-best-practices-functions-8d0f5176c8f7?source=collection_archive---------9-----------------------#2020-05-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/afa3ab75825592a172fb5ce368658d7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*hSIqlpMZksHDlJFi"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@louishansel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Louis Hansel @shotsoflouis</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b357" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种非常宽容的语言。很容易写出看起来乱七八糟、难以阅读但却能运行的代码。</p><p id="eed2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将关注一些问题，比如从赋给变量的函数中删除名字，以及函数声明或表达式的一致使用。</p><h1 id="e377" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有命名的F <code class="fe lz ma mb mc b">unction</code>表达式</h1><p id="419c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果我们有一个JavaScript函数表达式，其中我们将一个函数赋给一个变量、常量或属性，那么我们不需要在关键字<code class="fe lz ma mb mc b">function</code>后给函数添加一个名称。</p><p id="cc1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不需要这个名字，因为在我们把它赋给变量、常量或属性之后，我们不能用这个名字来调用或引用函数。</p><p id="981a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c9c2" class="mq lc iq mc b gy mr ms l mt mu">function Foo() {}<br/>Foo.prototype.bar = function foo() {};</span><span id="b406" class="mq lc iq mc b gy mv ms l mt mu">const foo = new Foo();<br/>foo.bar();<br/>foo.foo();</span></pre><p id="3f04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe lz ma mb mc b">foo.bar</code>按照我们的预期运行，因为我们创建了<code class="fe lz ma mb mc b">Foo</code>实例，它的原型中有<code class="fe lz ma mb mc b">bar</code>实例方法。</p><p id="cb02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，<code class="fe lz ma mb mc b">foo.foo</code>不起作用，因为我们把函数赋给了<code class="fe lz ma mb mc b">Foo.prototype.bar</code>，也就是说只能用标识符<code class="fe lz ma mb mc b">bar</code>调用。</p><p id="cb8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe lz ma mb mc b">foo();</code>调用它也不起作用，因为我们已经将它赋给了一个属性。</p><p id="6b3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个名字对于阅读代码的人来说很容易混淆。</p><p id="23cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该删除名称。就是写的少了，我们也没有一个没用的名字把人搞糊涂。</p><p id="708f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以改为编写以下内容:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="63b5" class="mq lc iq mc b gy mr ms l mt mu">function Foo() {}<br/>Foo.prototype.bar = function() {};</span><span id="34ed" class="mq lc iq mc b gy mv ms l mt mu">const foo = new Foo();<br/>foo.bar();</span></pre><p id="d334" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样我们就知道只能在<code class="fe lz ma mb mc b">foo</code>上调用<code class="fe lz ma mb mc b">bar</code>，这是一个<code class="fe lz ma mb mc b">Foo</code>实例。</p><p id="6555" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也适用于对象。如果我们有以下对象:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="73a6" class="mq lc iq mc b gy mr ms l mt mu">const obj = {<br/>  foo: function bar() {}<br/>}</span><span id="5ce5" class="mq lc iq mc b gy mv ms l mt mu">obj.foo();<br/>obj.bar();</span></pre><p id="a56b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe lz ma mb mc b">obj.foo()</code>像我们预期的那样运行，但是<code class="fe lz ma mb mc b">obj.bar()</code>会给我们错误‘未捕获类型错误:obj.bar不是函数’。再一次，我们应该去掉<code class="fe lz ma mb mc b">function</code>关键字后面的名字。</p><p id="ff61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，如果我们有一个如下所示的数组:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="43ad" class="mq lc iq mc b gy mr ms l mt mu">const arr = [<br/>  function bar() {}<br/>]</span></pre><p id="f469" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用如下函数:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="49fb" class="mq lc iq mc b gy mr ms l mt mu">arr[0]();</span></pre><p id="86b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以还是那句话，名字没用。</p><p id="f40a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们立即调用如下函数表达式:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8431" class="mq lc iq mc b gy mr ms l mt mu">(function bar() {</span><span id="340c" class="mq lc iq mc b gy mv ms l mt mu">})();</span></pre><p id="a575" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么函数名也是无用的，因为我们不能从外部调用<code class="fe lz ma mb mc b">bar</code>。因此，如果我们有如下所示的代码:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="4a32" class="mq lc iq mc b gy mr ms l mt mu">(function bar() {</span><span id="34f9" class="mq lc iq mc b gy mv ms l mt mu">})();</span><span id="c7bf" class="mq lc iq mc b gy mv ms l mt mu">bar();</span></pre><p id="4c21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到错误“未捕获的引用错误:<code class="fe lz ma mb mc b">bar</code>未定义”。这意味着这个名字又一次没用了，它只是占据了不必要的空间。</p><h1 id="50ef" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一致地使用F <code class="fe lz ma mb mc b">unction</code>声明或表达式</h1><p id="abff" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在JavaScript中，有两种方法来声明函数。一个是函数声明，我们用<code class="fe lz ma mb mc b">function</code>关键字写函数，并给它一个名字，而不把它赋给变量。</p><p id="3cdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种方法是函数表达式，我们传统的函数被定义，然后我们把它赋给一个变量或常数。</p><p id="5365" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两者的区别在于函数声明被提升了，这样在代码中定义它们之前，它们就可以被引用和调用。</p><p id="e2ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写如下函数声明:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8012" class="mq lc iq mc b gy mr ms l mt mu">function foo() {<br/>  console.log('foo');<br/>}</span></pre><p id="2794" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3da3" class="mq lc iq mc b gy mr ms l mt mu">foo();</span><span id="6376" class="mq lc iq mc b gy mv ms l mt mu">function foo() {<br/>  console.log('foo');<br/>}</span></pre><p id="129d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将把<code class="fe lz ma mb mc b">'foo'</code>记录到控制台，因为函数声明被提升，所以它们可以在脚本中的任何地方被调用。</p><p id="616b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数表达式编写如下:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="2d21" class="mq lc iq mc b gy mr ms l mt mu">var foo = function() {<br/>  console.log('foo');<br/>}</span></pre><p id="3a92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在定义它们之前，不能引用或调用它们。因此，如果我们试着这样称呼它们:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3368" class="mq lc iq mc b gy mr ms l mt mu">foo();</span><span id="bf0c" class="mq lc iq mc b gy mv ms l mt mu">var foo = function() {<br/>  console.log('foo');<br/>}</span></pre><p id="bf88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会得到一个“<code class="fe lz ma mb mc b">foo</code>不是函数”的错误，因为<code class="fe lz ma mb mc b">foo</code>没有定义。</p><p id="49f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显然，如果我们用<code class="fe lz ma mb mc b">let</code>或<code class="fe lz ma mb mc b">const</code>替换<code class="fe lz ma mb mc b">var</code>，我们会得到错误，因为任何用<code class="fe lz ma mb mc b">let</code>或<code class="fe lz ma mb mc b">const</code>声明的东西都不能被引用或调用，除非首先声明它们。</p><p id="7c33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数表达式更容易理解，因为没有提升。我们只能在他们定义好之后给他们打电话。</p><p id="d489" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这更好，因为它消除了任何与提升混淆。</p><p id="316c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们选择一致的风格来定义函数，那么函数表达式就是我们要走的路。</p><p id="0d4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，箭头函数只适用于函数表达式，因为没有地方放置箭头函数的名称。我们要么把它们赋给一个变量或常数，要么让它们保持匿名。</p><p id="5490" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了保持一切一致，最好使用如下函数表达式:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="73d3" class="mq lc iq mc b gy mr ms l mt mu">const foo = function() {<br/>  console.log('foo');<br/>}</span><span id="474c" class="mq lc iq mc b gy mv ms l mt mu">const bar = () =&gt; {<br/>  console.log('bar');<br/>}</span><span id="f49d" class="mq lc iq mc b gy mv ms l mt mu">foo();<br/>bar();</span></pre><p id="650d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们就不用担心吊装的不一致性了。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/42680f6be321401cdbb345dfac637277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E3iU-xU1F_GpBBPv"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@louishansel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Louis Hansel @shotsoflouis</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f3f3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="2acb" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">赋给属性、变量或常量的函数不应该有名字，因为它们没用。</p><p id="725b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数表达式更好，因为它更一致，因为我们不能在它们被定义之前引用或调用它们。此外，它们还用于为箭头函数指定名称。</p><h1 id="1615" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">简明英语笔记</strong></h1><p id="7788" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">你知道我们推出了一个YouTube频道吗？我们制作的每个视频都旨在教给你一些新的东西。点击此处 查看我们，并确保订阅该频道😎</p></div></div>    
</body>
</html>