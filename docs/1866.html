<html>
<head>
<title>Plain JavaScript versions of Lodash Array Filtering and Manipulation Methods</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Lodash数组过滤和操作方法的普通JavaScript版本</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/plain-javascript-versions-of-lodash-array-filtering-and-manipulation-methods-2469e2c6a5fa?source=collection_archive---------9-----------------------#2020-04-29">https://javascript.plainenglish.io/plain-javascript-versions-of-lodash-array-filtering-and-manipulation-methods-2469e2c6a5fa?source=collection_archive---------9-----------------------#2020-04-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/3c1a1ab9a2c1f9f70eab13bab4e6553b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D1uL9uNDvEenTo3Z"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nate_dumlao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nathan Dumlao</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9ecd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lodash是一个非常有用的工具库，让我们可以轻松地处理对象和数组。</p><p id="7fcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，现在JavaScript标准库正在赶上诸如Lodash之类的库，我们可以用简单的方法实现许多功能。</p><p id="12f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用普通的JavaScript轻松实现<code class="fe lb lc ld le b">pullAllBy</code>、<code class="fe lb lc ld le b">pullAllWith</code>、<code class="fe lb lc ld le b">pullAt</code>和<code class="fe lb lc ld le b">remove</code>方法。</p><h1 id="fa76" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">pullAllBy</code></h1><p id="7c83" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">pullAllBy</code>返回一个数组，在用<code class="fe lb lc ld le b">iteratee</code>函数转换后，删除与我们想要删除的项目相匹配的给定值。</p><p id="565e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下实现它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="32e5" class="mq lg iq le b gy mr ms l mt mu">const pullAllBy = (arr, values, iteratee) =&gt; arr.filter(a =&gt; !values.map(iteratee).includes(iteratee(a)))</span></pre><p id="9b54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，在与<code class="fe lb lc ld le b">includes</code>进行比较之前，我们调用给定的<code class="fe lb lc ld le b">iteratee</code>函数来映射值。同样在<code class="fe lb lc ld le b">includes</code>中，我们也调用<code class="fe lb lc ld le b">iteratee</code>来做同样的转换，这样就可以正确的比较它们了。</p><p id="38b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以如下使用我们的<code class="fe lb lc ld le b">pullAllBy</code>函数:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4a71" class="mq lg iq le b gy mr ms l mt mu">const result = pullAllBy([1, 2.1, 3], [2.2, 3], Math.floor)</span></pre><p id="97d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe lb lc ld le b">result</code>得到<code class="fe lb lc ld le b">[1]</code>。</p><h1 id="2a6f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">pullAllWith</code></h1><p id="448c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash <code class="fe lb lc ld le b">pullAllWith</code>方法使用比较器而不是<code class="fe lb lc ld le b">iteratee</code>来比较要排除的值，使用比较器而不是<code class="fe lb lc ld le b">iteratee</code>在比较之前转换值。</p><p id="75d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下实现它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="fd3b" class="mq lg iq le b gy mr ms l mt mu">const pullAllWith = (arr, values, comparator) =&gt; arr.filter(a =&gt; values.findIndex((v) =&gt; comparator(a, v)) === -1)</span></pre><p id="55e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们使用普通JavaScript的<code class="fe lb lc ld le b">findIndex</code>方法和一个调用<code class="fe lb lc ld le b">comparator</code>来比较值的回调函数。</p><p id="8345" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe lb lc ld le b">filter</code>来过滤出包含在<code class="fe lb lc ld le b">values</code>数组中的条目。</p><p id="6824" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们这样称呼它的时候:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6d73" class="mq lg iq le b gy mr ms l mt mu">const result = pullAllWith([1, 2, 3], [2, 3], (a, b) =&gt; a === b)</span></pre><p id="89b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe lb lc ld le b">result</code>得到<code class="fe lb lc ld le b">[1]</code>。</p><h1 id="6056" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">pullAt</code></h1><p id="16bc" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash <code class="fe lb lc ld le b">pullAt</code>方法返回一个数组，该数组包含具有给定索引的项目的元素。</p><p id="4d19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还会删除那些索引中的元素。</p><p id="4237" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以使用<code class="fe lb lc ld le b">filter</code>方法过滤出我们想要删除的项目，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="afa6" class="mq lg iq le b gy mr ms l mt mu">const pullAt = (arr, indexes) =&gt; {<br/>  let removedArr = [];<br/>  const originalLength = arr.length<br/>  for (let i = 0; i &lt; originalLength; i++) {<br/>    if (indexes.includes(i)) {<br/>      removedArr.push(arr[i]);<br/>    }<br/>  }</span><span id="aabd" class="mq lg iq le b gy mv ms l mt mu">  for (let i = originalLength - 1; i &gt;= 0; i--) {<br/>    if (indexes.includes(i)) {<br/>      arr.splice(i, 1);<br/>    }<br/>  }<br/>  return removedArr.flat()<br/>}</span></pre><p id="272d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们使用了一个<code class="fe lb lc ld le b">for</code>循环来遍历数组，并在<code class="fe lb lc ld le b">indexes</code>数组中具有给定索引的项目上调用<code class="fe lb lc ld le b">arr</code>上的<code class="fe lb lc ld le b">splice</code>。</p><p id="7e93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将移除的项目推入到<code class="fe lb lc ld le b">removedArr</code>数组中。</p><p id="cffa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们有第二个循环，它反向循环<code class="fe lb lc ld le b">arr</code>，这样在我们调用<code class="fe lb lc ld le b">splice</code>之前它不会改变<code class="fe lb lc ld le b">arr</code>的索引。</p><p id="4f6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在循环中，我们只需调用<code class="fe lb lc ld le b">splice</code>来删除给定索引的项目。</p><p id="78e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们调用<code class="fe lb lc ld le b">flat</code>来展平数组，因为<code class="fe lb lc ld le b">splice</code>返回一个数组。</p><p id="bd77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当我们这样称呼它时:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="9203" class="mq lg iq le b gy mr ms l mt mu">const arr = [1, 2, 3]<br/>const result = pullAt(arr, [1, 2])</span></pre><p id="8fb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到<code class="fe lb lc ld le b">result</code>是<code class="fe lb lc ld le b">[2, 3]</code>，因为我们在数组中指定了要移除的索引<code class="fe lb lc ld le b">[1, 2]</code>，而<code class="fe lb lc ld le b">arr</code>现在是<code class="fe lb lc ld le b">[1]</code>，因为它是唯一没有被移除的索引。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/2efc8e4bc541f51178b76df7ad05afee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3y4v9xXTGABfhW8F"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@timmossholder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tim Mossholder</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4773" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b">remove</code></h1><p id="87d3" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">remove</code>方法根据给定的条件从数组中移除项目，并返回移除的项目。</p><p id="66a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用如下的<code class="fe lb lc ld le b">for</code>循环自己实现它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2114" class="mq lg iq le b gy mr ms l mt mu">const remove = (arr, predicate) =&gt; {<br/>  let removedArr = [];<br/>  const originalLength = arr.length<br/>  for (let i = 0; i &lt; originalLength; i++) {<br/>    if (predicate(arr[i])) {<br/>      removedArr.push(arr[i]);<br/>    }<br/>  }<br/>  for (let i = originalLength - 1; i &gt;= 0; i--) {<br/>    if (predicate(arr[i])) {<br/>      arr.splice(i, 1);<br/>    }<br/>  }<br/>  return removedArr.flat();<br/>}</span></pre><p id="bd38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有两个循环，就像使用<code class="fe lb lc ld le b">pullAt</code>方法一样。然而，我们不是检查索引，而是检查一个<code class="fe lb lc ld le b">predicate</code>。</p><p id="6251" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像<code class="fe lb lc ld le b">pullAt</code>一样，我们必须反向循环数组索引，以避免<code class="fe lb lc ld le b">splice</code>在循环<code class="fe lb lc ld le b">arr</code>的项目时改变索引。</p><p id="bb2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们调用<code class="fe lb lc ld le b">remove</code>时如下:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="e778" class="mq lg iq le b gy mr ms l mt mu">const arr = [1, 2, 3]<br/>const result = remove(arr, a =&gt; a &gt; 1)</span></pre><p id="d16c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe lb lc ld le b">result</code>是<code class="fe lb lc ld le b">[2, 3]</code>和<code class="fe lb lc ld le b">arr</code>是<code class="fe lb lc ld le b">[1]</code>，因为我们指定了<code class="fe lb lc ld le b">predicate</code>是<code class="fe lb lc ld le b">a =&gt; a &gt; 1</code>，所以任何大于1的都从原始数组中移除，其余的返回。</p><h1 id="a684" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="4726" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">pullAt</code>和<code class="fe lb lc ld le b">remove</code>方法非常相似，除了<code class="fe lb lc ld le b">pullAt</code>接受一个索引数组而<code class="fe lb lc ld le b">remove</code>接受一个给定条件的回调。</p><p id="4d2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">pullAllBy</code>和<code class="fe lb lc ld le b">pullAllWith</code>通过<code class="fe lb lc ld le b">filter</code>方法实现。在进行比较之前，<code class="fe lb lc ld le b">pullAllBy</code>也需要用<code class="fe lb lc ld le b">iteratee</code>函数映射值。</p><h2 id="3bf9" class="mq lg iq bd lh mx my dn ll mz na dp lp ko nb nc lt ks nd ne lx kw nf ng mb nh bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="d24a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="8daf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>