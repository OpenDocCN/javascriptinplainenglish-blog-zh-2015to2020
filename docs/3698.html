<html>
<head>
<title>Social Share Images in Nuxt Content</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nuxt内容中的社交分享图片</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/social-share-images-in-nuxt-content-be5f2ae36755?source=collection_archive---------13-----------------------#2020-10-18">https://javascript.plainenglish.io/social-share-images-in-nuxt-content-be5f2ae36755?source=collection_archive---------13-----------------------#2020-10-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/04a152fb67767feb334ab99d3b001bd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ctI2XCebbGkj0Sbs.png"/></div></div></figure><h1 id="3d78" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="b832" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在社交媒体上分享博客内容或文章时，脱颖而出很重要。在Twitter帖子的海洋中，如果博客预览不够吸引眼球，用户可能会简单地滚动浏览你努力撰写的一篇文章！</p><p id="43e6" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">在这篇文章中，我们将教你如何为你的Nuxt内容博客文章制作漂亮的分享卡！这篇文章将使用Jason Lengstorfs的精彩文章中的概念，他在文章中详细介绍了如何使用Cloundinary的API和自定义模板为文章生成图像，但是我们将更关注Nuxt内容！</p><p id="f829" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我建议在继续之前去阅读他的帖子，因为你需要在Cloundinary中设置自己的模板，并上传任何你想用于模板的自定义字体。</p><h1 id="edc3" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">设置</h1><p id="8e52" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这篇文章不会详细介绍如何从头开始建立一个Nuxt内容博客，但是不言而喻的是，要确保你已经安装了<code class="fe ly lz ma mb b">@nuxt/content</code>包并添加到你的<code class="fe ly lz ma mb b">nuxt.config.js</code>模块中，如下所示:</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="7781" class="mk jw in mb b gy ml mm l mn mo">modules: [<br/>  '@nuxt/content',<br/>],</span></pre><p id="fca1" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">为了开始生成动态社交媒体卡，我们还需要安装杰森·伦斯托夫的软件包<code class="fe ly lz ma mb b">@jlengstorf/get-share-image</code>。</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="735f" class="mk jw in mb b gy ml mm l mn mo"># install using npm <br/>npm install --save @jlengstorf/get-share-image </span><span id="4be4" class="mk jw in mb b gy mp mm l mn mo"># install using yarn <br/>yarn add @jlengstorf/get-share-image</span></pre><p id="b5d4" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">一旦你安装好了所有的东西，并把你的模板上传到Cloudinary，就该开始生成你的图片了！</p><h1 id="da50" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">获取博客并生成图像</h1><p id="1d83" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在一个动态页面组件中(我的博客页面在/blog/_slug.vue中),我们需要使用<code class="fe ly lz ma mb b">asyncData</code> Nuxt钩子，因为它在<code class="fe ly lz ma mb b">head</code>方法之前被调用，我们需要在那里为文章设置打开的图表和Twitter元数据。</p><p id="0f36" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">我们将从从<code class="fe ly lz ma mb b">'@jlengstorf/get-share-image'</code>导入<code class="fe ly lz ma mb b">getShareImage</code>开始，然后在获取我们特定页面的文章后从<code class="fe ly lz ma mb b">asyncData</code>内部调用这个函数。</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="fb17" class="mk jw in mb b gy ml mm l mn mo">&lt;script&gt;<br/>import getShareImage from '@jlengstorf/get-share-image';<br/><br/>export default {<br/>  async asyncData({ $content, params }) {<br/>    const article = await $content('blogs', params.slug).fetch()<br/><br/>    const socialImage = getShareImage({<br/>        title: article.title,<br/>        tagline:  article.subtitle,<br/>        cloudName: 'YOUR_CLOUDINARY_NAME',<br/>        imagePublicID: 'YOUR_TEMPLATE_NAME.png',<br/>        titleFont: 'unienueueitalic.otf',<br/>        titleExtraConfig: '_line_spacing_-10',<br/>        taglineFont: 'unienueueitalic.otf',<br/>        titleFontSize: '72',<br/>        taglineFontSize: '48',<br/>        titleColor: 'fff',<br/>        taglineColor: '6CE3D4',<br/>        textLeftOffset: '100',<br/>        titleBottomOffset: '350',<br/>        taglineTopOffset: '380'<br/>      });<br/><br/>    return { article, socialImage }<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="1e4d" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><code class="fe ly lz ma mb b">getShareImage</code>函数将使用指定的文本、变换、颜色和字体通过Cloudinary生成一个图像URL。例如，我这篇文章的网址是</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="d774" class="mk jw in mb b gy ml mm l mn mo"><a class="ae lx" href="https://res.cloudinary.com/dzxp4ujfz/image/upload/w_1280,h_669,c_fill,q_auto,f_auto/w_760,c_fit,co_rgb:fff,g_south_west,x_100,y_350,l_text:unienueueitalic.otf_72_line_spacing_-10:Social%20Share%20Images%20in%20Nuxt%20Content/w_760,c_fit,co_rgb:6CE3D4,g_north_west,x_100,y_380,l_text:unienueueitalic.otf_48:Beautiful%20social%20sharing%20cards%20for%20your%20Nuxt%20Content%20blogs/template_oxlcmb.png" rel="noopener ugc nofollow" target="_blank">https://res.cloudinary.com/dzxp4ujfz/image/upload/w_1280,h_669,c_fill,q_auto,f_auto/w_760,c_fit,co_rgb:fff,g_south_west,x_100,y_350,l_text:unienueueitalic.otf_72_line_spacing_-10:Social%20Share%20Images%20in%20Nuxt%20Content/w_760,c_fit,co_rgb:6CE3D4,g_north_west,x_100,y_380,l_text:unienueueitalic.otf_48:Beautiful%20social%20sharing%20cards%20for%20your%20Nuxt%20Content%20blogs/template_oxlcmb.png</a></span></pre><p id="dee5" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">因为我已经创建了自己的模板，并包含了自己的字体，所以当设置<code class="fe ly lz ma mb b">textLeftOffset</code>或其他偏移量时，我的设置可能会与你的不同。包的<a class="ae lx" href="https://github.com/jlengstorf/get-share-image#readme" rel="noopener ugc nofollow" target="_blank"> Github页面上提供了您可以设置的属性的完整列表。</a></p><p id="75df" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">请随意在此处<a class="ae lx" href="https://res.cloudinary.com/jlengstorf/raw/upload/v1578342420/social-sharing-cards/learnwithjason-social-card-template.fig" rel="noopener ugc nofollow" target="_blank"/>查看杰森·凌斯托夫的Figma模板，并根据您的喜好进行定制。</p><h1 id="a27f" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">设置元标签</h1><p id="3c98" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">太好了，我们正在通过动态的Nuxt Content文章属性来生成我们的图像！</p><p id="60ea" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">现在，我们如何将这些变量注入我们的博客页面“head ”,以便社交媒体用户能够看到我们的图像和元数据？</p><p id="df71" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">为此，我们将利用内置在<a class="ae lx" href="https://nuxtjs.org/api/pages-head/" rel="noopener ugc nofollow" target="_blank"> head </a>方法中的Nuxt.js，该方法允许我们设置Open Graph和Twitter元标签。我们还会包括一些有用的信息，比如文章发表的时间，以及最后一次使用Nuxt Content自动为我们注入的<code class="fe ly lz ma mb b">createdAt</code>和<code class="fe ly lz ma mb b">updatedAt</code>属性修改文章的时间。</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="8bbf" class="mk jw in mb b gy ml mm l mn mo">&lt;script&gt;<br/>import getShareImage from '@jlengstorf/get-share-image';<br/>import getSiteMeta from "~/utils/getSiteMeta.js";<br/><br/>export default {<br/>  async asyncData({ $content, params }) {<br/>    const article = await $content('blogs', params.slug).fetch()<br/><br/>    const socialImage = getShareImage({<br/>        title: article.title,<br/>        tagline:  article.subtitle,<br/>        cloudName: 'YOUR_CLOUDINARY_NAME',<br/>        imagePublicID: 'YOUR_TEMPLATE_NAME.png',<br/>        titleFont: 'unienueueitalic.otf',<br/>        titleExtraConfig: '_line_spacing_-10',<br/>        taglineFont: 'unienueueitalic.otf',<br/>        titleFontSize: '72',<br/>        taglineFontSize: '48',<br/>        titleColor: 'fff',<br/>        taglineColor: '6CE3D4',<br/>        textLeftOffset: '100',<br/>        titleBottomOffset: '350',<br/>        taglineTopOffset: '380'<br/>      });<br/><br/>    return { article, socialImage }<br/>  },<br/>  computed: {<br/>    meta() {<br/>      const metaData = {<br/>        type: "article",<br/>        title: this.article.title,<br/>        description: this.article.description,<br/>        url: `https://davidparks.dev/blog/${this.$route.params.slug}`,<br/>        mainImage: this.socialImage,<br/>      };<br/>      return getSiteMeta(metaData);<br/>    }<br/>  },<br/>  head() {<br/>    return {<br/>      title: this.article.title,<br/>      meta: [<br/>        ...this.meta,<br/>        {<br/>          property: "article:published_time",<br/>          content: this.article.createdAt,<br/>        },<br/>        {<br/>          property: "article:modified_time",<br/>          content: this.article.updatedAt,<br/>        },<br/>        {<br/>          property: "article:tag",<br/>          content: this.article.tags ? this.article.tags.toString() : "",<br/>        },<br/>        { name: "twitter:label1", content: "Written by" },<br/>        { name: "twitter:data1", content: "David Parks" },<br/>        { name: "twitter:label2", content: "Filed under" },<br/>        {<br/>          name: "twitter:data2",<br/>          content: this.article.tags ? this.article.tags.toString() : "",<br/>        },<br/>      ],<br/>      link: [<br/>        {<br/>          hid: "canonical",<br/>          rel: "canonical",<br/>          href: `https://davidparks.dev/blog/${this.$route.params.slug}`,<br/>        },<br/>      ],<br/>    };<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="c373" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">您已经在上面注意到我正在从<code class="fe ly lz ma mb b">"~/utils/getSiteMeta.js"</code>进口<code class="fe ly lz ma mb b">getSiteMeta</code>。这是一个我用来覆盖默认元标签的实用函数。如果显式提供，我们将使用计算属性来覆盖我在这个文件中设置的一些默认元数据值。这确保了我们正在将Nuxt内容降价文件中的适当变量注入我们的大脑。该文件如下所示:</p><pre class="mc md me mf gt mg mb mh mi aw mj bi"><span id="6f77" class="mk jw in mb b gy ml mm l mn mo">const type = "website";<br/>const url = "https://davidparks.dev";<br/>const title = "David Parks";<br/>const description = "David Parks is a Front-end Developer from Milwaukee, Wisconsin. This blog will focus on Nuxt.js, Vue.js, CSS, Animation and more!";<br/>const mainImage = "https://davidparksdev.s3.us-east-2.amazonaws.com/template.png";<br/>const twitterSite = "@dparksdev";<br/>const twitterCard = "summary_large_image"<br/>export default (meta) =&gt; {<br/>  return [<br/>    {<br/>      hid: "description",<br/>      name: "description",<br/>      content: (meta &amp;&amp; meta.description) || description,<br/>    },<br/>    {<br/>      hid: "og:type",<br/>      property: "og:type",<br/>      content: (meta &amp;&amp; meta.type) || type,<br/>    },<br/>    {<br/>      hid: "og:url",<br/>      property: "og:url",<br/>      content: (meta &amp;&amp; meta.url) || url,<br/>    },<br/>    {<br/>      hid: "og:title",<br/>      property: "og:title",<br/>      content: (meta &amp;&amp; meta.title) || title,<br/>    },<br/>    {<br/>      hid: "og:description",<br/>      property: "og:description",<br/>      content: (meta &amp;&amp; meta.description) || description,<br/>    },<br/>    {<br/>      hid: "og:image",<br/>      property: "og:image",<br/>      content: (meta &amp;&amp; meta.mainImage) || mainImage,<br/>    },<br/>    {<br/>      hid: "twitter:url",<br/>      name: "twitter:url",<br/>      content: (meta &amp;&amp; meta.url) || url,<br/>    },<br/>    {<br/>      hid: "twitter:title",<br/>      name: "twitter:title",<br/>      content: (meta &amp;&amp; meta.title) || title,<br/>    },<br/>    {<br/>      hid: "twitter:description",<br/>      name: "twitter:description",<br/>      content: (meta &amp;&amp; meta.description) || description,<br/>    },<br/>    {<br/>      hid: "twitter:image",<br/>      name: "twitter:image",<br/>      content: (meta &amp;&amp; meta.mainImage) || mainImage,<br/>    },<br/>    { <br/>      hid: "twitter:site",<br/>      name: "twitter:site", <br/>      content: (meta &amp;&amp; meta.twitterSite) || twitterSite,<br/>    },<br/>    { <br/>      hid: "twitter:card",<br/>      name: "twitter:card", <br/>      content: (meta &amp;&amp; meta.twitterCard) || twitterCard,<br/>    }<br/>  ];<br/>};</span></pre><p id="c77b" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">除非有显式提供的覆盖，否则它将使用我在该文件顶部定义的回退值。如果你想避免那些你忘记设置元标签的情况，这是很好的！</p><p id="a431" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">计算出的属性<code class="fe ly lz ma mb b">meta</code>然后通过扩展运算符<code class="fe ly lz ma mb b">...this.meta,</code>被合并到<code class="fe ly lz ma mb b">head</code>方法中。这将确保任何默认值都被覆盖，并且您的文章标题、描述和图像被正确地注入到您的文档头中。</p><h1 id="23b4" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">使用脸书和推特工具进行测试</h1><p id="1d7e" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如果一切顺利，您现在应该可以在DOM中看到这些元标签了！</p><p id="d7e0" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">下一次你的网站部署时，当你在推特、脸书、领英或其他任何地方分享你的博客时，你会看到一个令人敬畏的共享图像！使用像推特的<a class="ae lx" href="https://cards-dev.twitter.com/validator" rel="noopener ugc nofollow" target="_blank">卡片调试器</a>和<a class="ae lx" href="https://developers.facebook.com/tools/debug/" rel="noopener ugc nofollow" target="_blank">脸书的开放图形调试器</a>这样的工具对于根据您的喜好调整它们并调试任何潜在的缺失标签是必不可少的。</p><h1 id="dc4f" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">包扎</h1><p id="6b9a" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">这种方法的好处在于，如果您决定在未来某个时候更新或更改您的博客模板，它将更新所有博客的预览图像。它也节省了你在Figma或你选择的设计工具中为每个博客创建独特的预览图像的时间和麻烦。就这么定了，算了！</p><p id="5d16" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated">如果你已经走了这么远，干得好。我期待在不久的将来，在我的feeds上看到一些很棒的Nuxt内容博客，上面有漂亮的分享卡。感谢阅读！</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><p id="f28f" class="pw-post-body-paragraph kt ku in kv b kw ls ky kz la lt lc ld le lu lg lh li lv lk ll lm lw lo lp lq ig bi translated"><em class="lr">最初发布于2020年10月18日</em><a class="ae lx" href="https://davidparks.dev/blog/social-share-images-in-nuxt-content" rel="noopener ugc nofollow" target="_blank"><em class="lr">https://David parks . dev</em></a><em class="lr">。</em></p></div></div>    
</body>
</html>