<html>
<head>
<title>What are these strict compiler options in TypeScript: Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript:第1部分中这些严格的编译器选项是什么</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-are-typescript-strict-compiler-options-part-1-5822c67c1df5?source=collection_archive---------2-----------------------#2020-01-09">https://javascript.plainenglish.io/what-are-typescript-strict-compiler-options-part-1-5822c67c1df5?source=collection_archive---------2-----------------------#2020-01-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/ebb6d5a06d0a76d5f3e9a27ad66281f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*lMQsNKYZvksBylFzuRcDoA.jpeg"/></div><figcaption class="jr js gj gh gi jt ju bd b be z dk">When TypeScript compiler runs in strict mode</figcaption></figure></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><blockquote class="kc kd ke"><p id="f238" class="kf kg kh ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld ig bi translated"><a class="ae le" href="https://medium.com/javascript-in-plain-english/there-is-no-point-to-use-typescript-in-your-project-if-you-dont-care-about-types-68131deeb43a" rel="noopener">在我的上一篇文章</a>中，我简要提到了每个严肃的TypeScript项目都应该启用<code class="fe lf lg lh li b"><em class="in">--strict </em></code>编译器选项，但是我没有提供任何关于它做什么的额外细节。<a class="ae le" href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" rel="noopener ugc nofollow" target="_blank">官方打字手册第</a>页很没用，也没有太多细节。因此，为了缩小这一差距，我将详细描述严格家庭中最重要的选择。</p></blockquote></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h1 id="71b9" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">-不需要</h1><p id="7b53" class="pw-post-body-paragraph kf kg in ki b kj mh kl km kn mi kp kq mj mk kt ku ml mm kx ky mn mo lb lc ld ig bi translated">该选项防止您在代码库中添加意外的<strong class="ki io">任何</strong>类型。为了将您的注意力集中在该标志的好处上，我将向您展示一个尽可能简单的代码示例。这可能看起来很傻，但这种问题是真实的，并且经常发生在没有质量测试覆盖的大规模代码库中。因此，让我们假设您有一个普通的<em class="kh"> isOddNumber </em>函数，其中您忘记了添加类型注释:</p><pre class="mp mq mr ms gt mt li mu mv aw mw bi"><span id="a337" class="mx lk in li b gy my mz l na nb"><strong class="li io">const </strong>isOddNumber = (num) =&gt; (num % 2) !== 0;<br/><strong class="li io">const</strong> nums = [1, 2, 3];</span><span id="ced0" class="mx lk in li b gy nc mz l na nb">console.log(isOddNumber(nums[0])); <em class="kh">// =&gt; prints true<br/></em>console.log(isOddNumber(nums[1])); <em class="kh">// =&gt; prints false</em></span><span id="a48d" class="mx lk in li b gy nc mz l na nb"><em class="kh">// oops there is a typo in our code, we planned to pass nums[2];</em><br/>console.log(isOddNumber(nums)) <em class="kh">// =&gt; prints true</em></span><span id="0a70" class="mx lk in li b gy nc mz l na nb"><em class="kh">// funny that it would work as intended with 1 element in array</em><br/>console.log(isOddNumber([3])) <em class="kh">// =&gt; prints true</em></span></pre><p id="5c9e" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq mj ks kt ku ml kw kx ky mn la lb lc ld ig bi translated">尽管该代码可以成功编译，并且不会产生运行时异常，但是第三个console.log语句有一个令人讨厌的错误，如果不加注意，它可能会在您的应用程序中存在很长时间。罪魁祸首是<strong class="ki io">任何</strong>类型。即使您没有在代码中显式地看到它，它也是存在的。这是因为每当TypeScript编译器找不到更好的方法时，它就有权添加任何类型。所以在编译的时候，你的前两行将被转换成这样:</p><pre class="mp mq mr ms gt mt li mu mv aw mw bi"><span id="de6b" class="mx lk in li b gy my mz l na nb"><strong class="li io">const </strong>isOddNumber = (num: <strong class="li io">any</strong>): <strong class="li io">boolean </strong>=&gt; (num % 2) !== 0;<br/><strong class="li io">const</strong> nums: <strong class="li io">number</strong>[] = [1, 2, 3];</span></pre><p id="18ef" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq mj ks kt ku ml kw kx ky mn la lb lc ld ig bi translated">这里，TypeScript编译器毫无问题地正确推断了两种类型(对于数组和返回值)，但是对于它来说，<em class="kh"> isOddNumber </em>函数的输入值是一项不可能完成的任务。但是，如果您的编译器在启用了<code class="fe lf lg lh li b"><em class="kh">--noImplicitAny </em></code>选项的情况下运行，它将无法在您的控制台中构建和打印以下错误消息:</p><pre class="mp mq mr ms gt mt li mu mv aw mw bi"><span id="99a0" class="mx lk in li b gy my mz l na nb"><strong class="li io">ERROR: Parameter 'num' implicitly has an 'any' type</strong></span></pre><p id="5cc3" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq mj ks kt ku ml kw kx ky mn la lb lc ld ig bi translated">太棒了，现在作为开发人员，您可以控制是否为<em class="kh"> num </em>参数编写一个<strong class="ki io"> number </strong>类型，或者将其声明为<strong class="ki io"> any </strong>。</p></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h1 id="5b5a" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">-不影响这个</h1><p id="1aea" class="pw-post-body-paragraph kf kg in ki b kj mh kl km kn mi kp kq mj mk kt ku ml mm kx ky mn mo lb lc ld ig bi translated">因为JavaScript是一种非常动态的语言，能够调用任意传递<strong class="ki io">这个</strong>上下文的函数，所以在很多情况下TypeScript不能进行正确的类型推断。因此，如果我们不启用该选项，TypeScript会假设您不关心这个关键字的类型<strong class="ki io">，并且会对它使用<strong class="ki io">任何</strong>类型<strong class="ki io"> </strong>，直到您指定了其他内容。</strong></p><pre class="mp mq mr ms gt mt li mu mv aw mw bi"><span id="e335" class="mx lk in li b gy my mz l na nb"><strong class="li io">function</strong> foo(hello: <strong class="li io">string</strong>) {<br/>    console.log(hello + ' ' + <strong class="li io">this</strong>.fullName);<br/>}</span><span id="15cd" class="mx lk in li b gy nc mz l na nb">foo.call({ fullName: 'Kirill' }, 'hi'); // =&gt; prints "hi Kirill"</span><span id="ff74" class="mx lk in li b gy nc mz l na nb"><strong class="li io">const </strong>x = { fullName: 'Max', foo: foo }<br/>x.foo("hello"); // =&gt; prints "hello Max"</span><span id="2ac7" class="mx lk in li b gy nc mz l na nb">foo.call(10, "hey"); // no errors, prints "hey undefined"<br/>foo('hi'); // runtime error, but no compile time error</span></pre><p id="852f" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq mj ks kt ku ml kw kx ky mn la lb lc ld ig bi translated">为了向TypeScript显示您关心这个关键字的<strong class="ki io">类型，并防止它默认为<strong class="ki io">任何一个</strong>只要<strong class="ki io"> </strong>您忘记声明它，我们需要启用<code class="fe lf lg lh li b"><em class="kh">--noImplicitThis </em></code>选项。在此之后，您将在构建时遇到错误，直到您为此<strong class="ki io"/>提供类型。要定义<strong class="ki io">这个</strong>类型，需要先添加一个<strong class="ki io">的</strong> <em class="kh">伪参数</em>，并命名为<strong class="ki io">这个</strong>:</strong></p><pre class="mp mq mr ms gt mt li mu mv aw mw bi"><span id="9638" class="mx lk in li b gy my mz l na nb"><strong class="li io">interface </strong>User { fullName: <strong class="li io">string </strong>}</span><span id="df4a" class="mx lk in li b gy nc mz l na nb"><strong class="li io">function</strong> foo(<strong class="li io">this</strong>: User, hello: <strong class="li io">string</strong>) {<br/>    console.log(hello + ' ' + this.fullName);<br/>}</span><span id="7e43" class="mx lk in li b gy nc mz l na nb">foo.call({ fullName: 'Kirill' }, 'hi'); // =&gt; prints "hi Kirill"</span><span id="94ef" class="mx lk in li b gy nc mz l na nb"><strong class="li io">const </strong>x = { fullName: 'Max', foo: foo }<br/>x.foo("hello"); <em class="kh">// =&gt; prints "hello Max"</em></span><span id="ecb0" class="mx lk in li b gy nc mz l na nb">foo.call(10, "hey"); // <strong class="li io">compile error</strong>, '10' is not a type of 'User'<br/>foo('hi'); <em class="kh">// </em><strong class="li io"><em class="kh">compile error</em></strong><em class="kh">, 'void' is not assignable to 'User'.</em></span></pre><p id="b902" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq mj ks kt ku ml kw kx ky mn la lb lc ld ig bi translated">太好了，现在<strong class="ki io">的类型这个</strong>关键词在你的应用中永远不会是<strong class="ki io">任何</strong>直到开发者决定它是某个特定功能所必需的。</p></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h1 id="0d59" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">---------------------------------------------------------------------------------------------------------------------------------------------------------------------------</h1><p id="a652" class="pw-post-body-paragraph kf kg in ki b kj mh kl km kn mi kp kq mj mk kt ku ml mm kx ky mn mo lb lc ld ig bi translated">当您使用<strong class="ki io">绑定</strong>、<strong class="ki io">调用</strong>或<strong class="ki io">应用</strong>时，该选项要求TypeScript编译器检查参数类型。默认情况下，它不关心这种上下文中的类型，给你留下更多出错的机会:</p><pre class="mp mq mr ms gt mt li mu mv aw mw bi"><span id="1321" class="mx lk in li b gy my mz l na nb"><strong class="li io">function </strong>bar(a: <strong class="li io">string</strong>, b: <strong class="li io">number</strong>) {<br/>   console.log(a, b);<br/>}</span><span id="32f2" class="mx lk in li b gy nc mz l na nb"><strong class="li io">// no errors</strong><br/>bar('cool', 10);</span><span id="1799" class="mx lk in li b gy nc mz l na nb"><strong class="li io">// error </strong>since we didn't pass the second argument<br/>bar('cool');</span><span id="48ba" class="mx lk in li b gy nc mz l na nb"><strong class="li io">// no errors</strong><br/>bar.call(null, 'cool');<br/>bar.call(null, true, false); <strong class="li io"><br/></strong>bar.bind(null)();<br/>bar.bind(null, 'cool')(10);</span></pre><p id="72d1" class="pw-post-body-paragraph kf kg in ki b kj kk kl km kn ko kp kq mj ks kt ku ml kw kx ky mn la lb lc ld ig bi translated">一旦我们启用<code class="fe lf lg lh li b"><em class="kh">--strictBindCallApply</em></code>选项，在编译过程中将会看到完全不同的结果:</p><pre class="mp mq mr ms gt mt li mu mv aw mw bi"><span id="6125" class="mx lk in li b gy my mz l na nb"><strong class="li io">// no errors</strong><br/>bar('cool', 10);</span><span id="c483" class="mx lk in li b gy nc mz l na nb"><strong class="li io">// error </strong>since we didn't pass the second argument<br/>bar('cool');</span><span id="2169" class="mx lk in li b gy nc mz l na nb"><strong class="li io">// error </strong>since we didn't pass the second argument<br/>bar.call(null, 'cool');</span><span id="9e4e" class="mx lk in li b gy nc mz l na nb"><strong class="li io">// error </strong>since types are not matching<br/>bar.call(null, true, false);</span><span id="2ca1" class="mx lk in li b gy nc mz l na nb"><strong class="li io">// error </strong>since we didn't pass arguments at all<br/>bar.bind(null)();</span><span id="8e1b" class="mx lk in li b gy nc mz l na nb"><strong class="li io">// no errors </strong>type and amount of parameters mathes<br/>bar.bind(null, 'cool')(10);</span></pre></div><div class="ab cl jv jw hr jx" role="separator"><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka kb"/><span class="jy bw bk jz ka"/></div><div class="ig ih ii ij ik"><h1 id="89ea" class="lj lk in bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">结论</h1><p id="bb87" class="pw-post-body-paragraph kf kg in ki b kj mh kl km kn mi kp kq mj mk kt ku ml mm kx ky mn mo lb lc ld ig bi translated">我希望这篇文章能够向你解释这些选择有多重要。然而，这并不是一个详尽的列表，我在第二部分<a class="ae le" href="https://medium.com/@kreznykov/what-are-these-strict-compiler-options-in-typescript-part-2-a7e974b13e54" rel="noopener"/>中写了剩余的严格选项。别错过了。</p></div></div>    
</body>
</html>