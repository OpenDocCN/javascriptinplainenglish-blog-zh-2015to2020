<html>
<head>
<title>JavaScript: Iterators &amp; Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:迭代器和生成器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-iterators-generators-d59ff15a4e68?source=collection_archive---------5-----------------------#2020-05-12">https://javascript.plainenglish.io/javascript-iterators-generators-d59ff15a4e68?source=collection_archive---------5-----------------------#2020-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="26f5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">遍历“元素集”中的每个元素是一种非常普通的操作。JavaScript为我们提供了很多方法。</h2></div><h2 id="787e" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">但是，在本文中，我们不会爱上那些方法。相反，我们将探索这一切背后的机制，即概念:iterable、iterator、generator。</h2><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/1e633551f96d5f3b097a4c5ced6b57f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcVV-Stq79lbp4y8tYcdqA.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://unsplash.com/@casparrubin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Caspar Camille Rubin</a> on <a class="ae lr" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5ed0" class="ls kg iq bd kh lt lu lv kk lw lx ly kn jw lz jx kr jz ma ka kv kc mb kd kz mc bi translated">可迭代的</h1><p id="df4d" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml ko mm mn mo ks mp mq mr kw ms mt mu mv ij bi translated">如果一个对象安装了可迭代协议，那么这个对象就叫做<em class="mw">可迭代</em>(稍后再谈)。这些可迭代对象经常可以使用元素浏览方法，例如<code class="fe mx my mz na b">for..of</code>。</p><p id="326b" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">在JavaScript中，<code class="fe mx my mz na b">Array</code>是<em class="mw">可迭代的</em>。</p><pre class="lc ld le lf gt ng na nh ni aw nj bi"><span id="081a" class="kf kg iq na b gy nk nl l nm nn">for (let v of [1, 2, 3, 4]) console.log(v)<br/>// 1<br/>// 2<br/>// 3<br/>// 4</span></pre><p id="98a6" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">此外，许多其他内置对象是可迭代的，例如<code class="fe mx my mz na b">String</code>:</p><pre class="lc ld le lf gt ng na nh ni aw nj bi"><span id="6b8b" class="kf kg iq na b gy nk nl l nm nn">for (let v of 'hello') console.log(v)<br/>// h<br/>// e<br/>// l<br/>// l<br/>// o</span></pre><p id="5325" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">如果一个对象代表一组“元素”，那么我们完全可以用for..循环遍历其元素。浏览这些元素的操作称为“迭代”(类似于许多其他语言)。</p><p id="0198" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">但是你有没有想过这样的事情是如何运作的？不需要等太久，我们很快就会知道。</p><h1 id="9f01" class="ls kg iq bd kh lt lu lv kk lw lx ly kn jw lz jx kr jz ma ka kv kc mb kd kz mc bi translated">可迭代协议</h1><p id="19af" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml ko mm mn mo ks mp mq mr kw ms mt mu mv ij bi translated">Iterable协议是一个允许JavaScript对象自定义自己的浏览操作的协议，这些操作将在元素审批中使用(例如，<code class="fe mx my mz na b">for..of</code>)。</p><p id="708e" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">JavaScript的许多内置数据类型已经安装了可迭代协议(例如，<code class="fe mx my mz na b">Array</code>，<code class="fe mx my mz na b">Map</code>)，这使得我们可以轻松地遍历它的元素。</p><p id="d0d2" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">只有实现了iterable协议的对象才是iterable的。安装将通过<code class="fe mx my mz na b">@@iterator</code>方法完成。也就是说，对象必须具有<code class="fe mx my mz na b">@@iterator</code>属性。可通过<code class="fe mx my mz na b">[Symbol.iterator]</code>设置该属性，如下所示:</p><pre class="lc ld le lf gt ng na nh ni aw nj bi"><span id="9153" class="kf kg iq na b gy nk nl l nm nn">let range = {<br/>	from: 1,<br/>	to: 5,<br/>	[Symbol.iterator]: () =&gt; {<br/>		return {<br/>			current: this.from,<br/>			last: this.to,<br/>			next: () =&gt; {<br/>				if (this.current &lt;= this.last) {<br/>					return { done: false, value: this.current++ };<br/>				} else {<br/>				return { done: true };<br/>			}<br/>		}<br/>	};<br/>}</span></pre><p id="dabf" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated"><code class="fe mx my mz na b">@@iterator</code>属性(通过<code class="fe mx my mz na b">[Symbol.iterator]</code>设置)是一个没有参数的函数，在我们可以浏览元素之前，它的结果必须是一个迭代器(稍后会学到)。一个对象的。实际上，这个函数可以返回任何东西，但是如果它不是迭代器，那么我们一浏览元素就会得到一个错误，我认为没有人会在为整个对象设置属性<code class="fe mx my mz na b">@@iterator</code>时做这种“愚蠢”的事情。</p><p id="07fb" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">每当一个对象需要遍历它的元素时，例如使用<code class="fe mx my mz na b">for..of</code>。这些方法首先调用该对象的<code class="fe mx my mz na b">@@iterator</code>(不带参数)，然后使用该方法的结果返回迭代。在上面的例子中，我们可以通过自己定义方法<code class="fe mx my mz na b">@@iterator</code>来完全构建我们自己的可迭代对象。通过自定义方法，我们可以完全自定义元素迭代的方法。</p><p id="e7b0" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">和上面的例子一样，我们将浏览元素1–5(实际上，这些“元素”并不完全在对象中，但是由于定制了browse方法，我们已经完全遍历了这些元素)。</p><pre class="lc ld le lf gt ng na nh ni aw nj bi"><span id="d186" class="kf kg iq na b gy nk nl l nm nn">for(let num of range) console.log(num)<br/>// 1<br/>// 2<br/>// 3<br/>// 4<br/>// 5</span></pre><p id="54ab" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">浏览方法，如..只处理返回的迭代器。注意，这个迭代器可能是一个完全不同的对象，而不是一个批准的对象，这取决于每个特定对象的设置。</p><h1 id="b2f9" class="ls kg iq bd kh lt lu lv kk lw lx ly kn jw lz jx kr jz ma ka kv kc mb kd kz mc bi translated">迭代程序</h1><p id="61ef" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml ko mm mn mo ks mp mq mr kw ms mt mu mv ij bi translated">在JavaScript中，迭代器是一个对象，它定义了一个“字符串”元素，并将返回每个元素，直到遇到某个端点。更精确的定义是，迭代器是迭代器协议实现的对象。</p><p id="faee" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">迭代器协议完全独立于iterable协议，一个对象不一定要安装在两种协议上。这也意味着可迭代对象不一定是迭代器，反之亦然。</p><p id="ef77" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated"><strong class="mf ir">迭代器协议<br/> </strong>迭代器协议是一种协议，它定义了标准方法来“生成”一个结果序列(可以是有限的，也可以是无限的)，并依次返回结果供我们在迭代中使用。</p><p id="e428" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">这是将与从<code class="fe mx my mz na b">@@iterator</code>属性返回的迭代器的<code class="fe mx my mz na b">for..of</code>一起使用的协议。</p><p id="bbdb" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">如果一个对象定义了迭代器协议，它就是迭代器。这个协议很简单，它要求对象必须用下一个方法(没有参数)安装，结果是返回的对象具有以下两个属性:</p><ul class=""><li id="1952" class="no np iq mf b mg nb mj nc ko nq ks nr kw ns mv nt nu nv nw bi translated"><code class="fe mx my mz na b">done (boolean</code>:表示迭代器是否结束。还有其他值可以浏览的时候就是<code class="fe mx my mz na b">false</code>了。如果该值为<code class="fe mx my mz na b">false</code>，则需要下一个属性。</li><li id="7dd3" class="no np iq mf b mg nx mj ny ko nz ks oa kw ob mv nt nu nv nw bi translated"><code class="fe mx my mz na b">value</code>:下一次浏览的返回值。该属性的值可以是任何JavaScript对象。</li></ul><p id="c1ce" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated"><code class="fe mx my mz na b">next</code>方法必须总是返回一个具有上述两个属性的对象(如果<code class="fe mx my mz na b">done</code>是<code class="fe mx my mz na b">true</code>，则可能不需要<code class="fe mx my mz na b">value</code>)。如果返回的不是上面描述的对象，我们在执行元素浏览时会得到一个<code class="fe mx my mz na b">TypeError</code>错误。</p><p id="9e87" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">事实上，很难知道一个对象是否安装了迭代器协议。但是我们可以很容易地构建一个安装了这个协议的对象。</p><p id="d378" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">如上所述，迭代器对象不一定是可迭代的，反之亦然，但是如果我们有意构建一个对象，我们可以同时安装可迭代协议和迭代器协议。那么，我们的对象将既是一个可迭代对象，又是一个迭代器。</p><p id="4076" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated"><strong class="mf ir">自己构建迭代器<br/></strong>JavaScript的内置迭代器之一，Array就是一个最好的例子。这个迭代器简单地返回其中每个元素的值，我们将相应地浏览它们。</p><p id="c635" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">我们可以想象迭代器类似于数组。但事实上不是那样的。迭代器完全可以自由运行(甚至没有停顿)，取决于如何安装自己的迭代器协议。</p><p id="595b" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">下面是一个自建迭代器的例子。它构造了一个给定范围内的值序列。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="oc od l"/></div></figure><p id="d11c" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">我们甚至可以把迭代器协议和iterable协议结合起来，这样我们都可以构造一个迭代器，我们可以用<code class="fe mx my mz na b">for..of</code>迭代它的元素。</p><pre class="lc ld le lf gt ng na nh ni aw nj bi"><span id="3f4e" class="kf kg iq na b gy nk nl l nm nn">var myIterator = {<br/>    next: function() {<br/>        // ...<br/>    },<br/>    [Symbol.iterator]: function() { return this }<br/>};</span></pre><h1 id="a0c7" class="ls kg iq bd kh lt lu lv kk lw lx ly kn jw lz jx kr jz ma ka kv kc mb kd kz mc bi translated">发电机</h1><p id="e052" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml ko mm mn mo ks mp mq mr kw ms mt mu mv ij bi translated">构建自己的迭代器是一项非常酷且有效的工作。但是这要求我们在设置iterable协议和iterator协议时非常小心。因为我们必须手动管理当前状态以及计算下一个值。</p><p id="f218" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">但是JavaScript有另一个工具，生成器函数，它将帮助我们在这方面更加轻松。生成器能够使用一个函数帮助我们定义一系列要浏览的值。</p><p id="dd20" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">从语法上来说，生成器函数是由关键字<code class="fe mx my mz na b">function*</code>定义的，这与常规函数有点不同。发电机性能也大不相同。当被调用时，它实际上并不立即执行。相反，它返回一个对象，我们可以称之为生成器。</p><p id="582b" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated"><strong class="mf ir">生成器是迭代器</strong></p><p id="1417" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">在<code class="fe mx my mz na b">next</code>方法上将自动定义一个生成器，因此它将自动成为一个迭代器。即使这是全自动的，我们也不需要担心管理生成器的状态和值。</p><p id="115d" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">每次方法为<code class="fe mx my mz na b">next</code>时，实际执行此时的生成器函数，直到遇到<code class="fe mx my mz na b">yield</code>才会停止。而<code class="fe mx my mz na b">yield</code>的值也是<code class="fe mx my mz na b">next</code>将要返回的值。</p><p id="f046" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">回到上面自建迭代器的例子，我们可以很容易地用生成器重写它，如下所示:</p><pre class="lc ld le lf gt ng na nh ni aw nj bi"><span id="886f" class="kf kg iq na b gy nk nl l nm nn">function* makeRangeIterator(start = 0, end = Infinity, step = 1) {<br/>    let iterationCount = 0;<br/>    for (let i = start; i &lt; end; i += step) {<br/>        iterationCount++;<br/>        yield i;<br/>    }<br/>}</span></pre><p id="f69a" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">用预定义的<code class="fe mx my mz na b">next</code>方法，我们可以调用如下:</p><pre class="lc ld le lf gt ng na nh ni aw nj bi"><span id="57dd" class="kf kg iq na b gy nk nl l nm nn">range = makeRangeIterator(1, 10, 2);<br/>range.next()<br/>// {value: 1, done: false}<br/>range.next()<br/>// {value: 1, done: false}</span></pre><p id="2576" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated"><strong class="mf ir">生成器是可迭代的<br/> </strong>不仅是一个迭代器，<em class="mw">生成器</em>也是一个可迭代的对象。也就是会自动定义为既有iterable协议又有iterator协议，方便我们。由于协议的实现，我们可以使用元素批准，类似于其他常规的<em class="mw"> iterables </em>:</p><pre class="lc ld le lf gt ng na nh ni aw nj bi"><span id="63d7" class="kf kg iq na b gy nk nl l nm nn">for (let num in makeRangeIterator(1, 10, 2)) console.log(num)<br/>// 1<br/>// 3<br/>// 5<br/>// 7<br/>// 9</span></pre><p id="901e" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">你可以任意多次调用一个生成器函数。而且每次调用都会返回不同的生成器，可以单独迭代，不影响其他调用。</p><p id="d51a" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">但是，与自建迭代器不同，我们不能定制生成器遍历。每个生成器只能浏览一次，每个值只能浏览一次。当然，我们可以多次调用生成器函数，但每次调用只能浏览一次。</p><p id="c556" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">由于我们的优势，我们可以考虑使用生成器，而不是需要手动构建的可迭代迭代器。因为很明显，使用发电机更方便也更安全。</p><p id="5662" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated"><strong class="mf ir">生成器生成另一个生成器<br/> </strong>这是一个生成器的特殊方法，我们可以将这个生成器“嵌入”到另一个生成器中。然后，我们需要一个特殊的语法:<code class="fe mx my mz na b">yield*</code>:</p><pre class="lc ld le lf gt ng na nh ni aw nj bi"><span id="1fbe" class="kf kg iq na b gy nk nl l nm nn">function* generateSequence(start, end) {<br/>    for (let i = start; i &lt;= end; i++) yield i;<br/>}<br/><br/>function* generatePasswordCodes() {<br/><br/>    // 0..9<br/>    yield* generateSequence(48, 57);<br/><br/>    // A..Z<br/>    yield* generateSequence(65, 90);<br/><br/>    // a..z<br/>    yield* generateSequence(97, 122);<br/><br/>}<br/><br/>let str = '';<br/><br/>for(let code of generatePasswordCodes()) {<br/>    str += String.fromCharCode(code);<br/>}<br/>console.log(str):<br/>// 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</span></pre><p id="09e9" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">上面的<code class="fe mx my mz na b">yield*</code>语法允许我们调用另一个生成器，并在执行下一个计算之前等待该生成器完成。如果不使用这种方法，我们必须构建一个更复杂的生成器，如下所示:</p><pre class="lc ld le lf gt ng na nh ni aw nj bi"><span id="28d0" class="kf kg iq na b gy nk nl l nm nn">function* generateSequence(start, end) {<br/>    for (let i = start; i &lt;= end; i++) yield i;<br/>}<br/><br/>function* generateAlphaNum() {<br/><br/>    // yield* generateSequence(48, 57);<br/>    for (let i = 48; i &lt;= 57; i++) yield i;<br/><br/>    // yield* generateSequence(65, 90);<br/>    for (let i = 65; i &lt;= 90; i++) yield i;<br/><br/>    // yield* generateSequence(97, 122);<br/>    for (let i = 97; i &lt;= 122; i++) yield i;<br/><br/>}<br/><br/>let str = '';<br/><br/>for(let code of generateAlphaNum()) {<br/>    str += String.fromCharCode(code);<br/>}<br/>console.log(str);<br/>// 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz</span></pre><p id="7859" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">另一个生成器的yield给了我们一个更简单的方法，把一个生成器嵌入到一个生成器中。</p><p id="da32" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated"><strong class="mf ir">为产量赋值</strong></p><p id="1553" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">从一开始，我们仍然以非常自然的方式使用生成器，进而<code class="fe mx my mz na b">yield</code>生成器的每个值。许多人也在做同样的事情。但是生成器非常灵活，允许我们做更多的事情。</p><p id="9108" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">那个yield也能从外部认识到价值，而不是在返回价值的土丘。考虑下面一个简单的例子，我们使用这个技巧从头开始重置字符串:</p><pre class="lc ld le lf gt ng na nh ni aw nj bi"><span id="2d2f" class="kf kg iq na b gy nk nl l nm nn">function* foo() {<br/>    let index = 0;<br/>    while (true) {<br/>        const result = yield index++;<br/>        if (result) {<br/>            index = 0;<br/>        }<br/>    }<br/>}<br/><br/>const bar = foo();<br/><br/>console.log(bar.next())<br/>// {value: 0, done: false}<br/>console.log(bar.next())<br/>// {value: 1, done: false}<br/>console.log(bar.next(true))<br/>// {value: 0, done: false}<br/>console.log(bar.next())<br/>// {value: 1, done: false}</span></pre><p id="924e" class="pw-post-body-paragraph md me iq mf b mg nb jr mi mj nc ju ml ko nd mn mo ks ne mq mr kw nf mt mu mv ij bi translated">Generator还有一个非常大的应用程序，它是带有<code class="fe mx my mz na b"><a class="ae lr" href="https://manhhomienbienthuy.github.io/2018/Jul/17/javascript-asyncawait.html" rel="noopener ugc nofollow" target="_blank">async/await</a></code>关键字的异步代码的基础。</p><h1 id="f442" class="ls kg iq bd kh lt lu lv kk lw lx ly kn jw lz jx kr jz ma ka kv kc mb kd kz mc bi translated">总结</h1><p id="1380" class="pw-post-body-paragraph md me iq mf b mg mh jr mi mj mk ju ml ko mm mn mo ks mp mq mr kw ms mt mu mv ij bi translated">迭代器和生成器是JavaScript中非常重要的概念。希望这篇文章能提供有用的信息，帮助你更好地掌握JavaScript代码。👏</p></div></div>    
</body>
</html>