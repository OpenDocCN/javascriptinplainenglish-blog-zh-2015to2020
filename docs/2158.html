<html>
<head>
<title>JavaScript Best Practices — Imports, Symbols, and Constructors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—导入、符号和构造函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-imports-symbols-and-constructors-e78ce6ab8e3d?source=collection_archive---------6-----------------------#2020-05-25">https://javascript.plainenglish.io/javascript-best-practices-imports-symbols-and-constructors-e78ce6ab8e3d?source=collection_archive---------6-----------------------#2020-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ca643a669cb23df56c7d3a340e7c9b49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cWGzOk2mMQDEO71b"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e276" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="4ca6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看导入模块的正确方法，使用<code class="fe lb lc ld le b">Symbol </code>构造函数，在子类的构造函数中引用<code class="fe lb lc ld le b">this</code>之前调用<code class="fe lb lc ld le b">super</code>。</p><h1 id="8829" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">没有重复的导入</h1><p id="ce24" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">绝对不应该添加重复的导入。如果我们从同一个模块中导入多个项目，那么我们应该把它们都放在一个语句中。</p><p id="2165" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想要导入多个项目，我们不应该编写如下内容:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2c00" class="mq lg iq le b gy mr ms l mt mu">import { foo } from "./module";<br/>import { bar } from "./module";</span></pre><p id="d884" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以通过编写以下代码来节省一些空间:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0cdb" class="mq lg iq le b gy mr ms l mt mu">import { foo, bar } from "./module";</span></pre><p id="fd40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们从同一个模块导入多个成员，我们导入的越多，通过将所有的导入合并到一个语句中节省的空间就越多。</p><h1 id="9ca0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">不要将符号用作构造函数</h1><p id="24a4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在JavaScript中，符号被用作对象和类中方法的唯一标识符。</p><p id="0fd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个符号都是独一无二的，即使它们有相同的名字。例如，如果我们有以下代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="b8fa" class="mq lg iq le b gy mr ms l mt mu">const foo1 = Symbol('foo');<br/>const foo2 = Symbol('foo');<br/>console.log(foo1 === foo2);</span></pre><p id="29c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后控制台批量输出记录<code class="fe lb lc ld le b">false</code>，因为由<code class="fe lb lc ld le b">Symbol</code>函数返回的每个符号都是它们自己的实例。</p><p id="c5cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Symbol</code>函数不是构造函数。因此，我们不应该使用<code class="fe lb lc ld le b">new</code>操作符。</p><p id="67e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该编写类似下面这样的代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="9de8" class="mq lg iq le b gy mr ms l mt mu">const a = new Symbol("a");</span></pre><p id="6bf6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行它，那么我们将得到错误消息‘未捕获的类型错误:符号不是构造函数’。</p><p id="14b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该直接调用它，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ae89" class="mq lg iq le b gy mr ms l mt mu">const a = Symbol("a");</span></pre><p id="a35c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Symbol</code>函数应该作为函数直接调用。</p><h1 id="7268" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在构造函数中调用<code class="fe lb lc ld le b">super()</code>之前不要使用<code class="fe lb lc ld le b">this or super</code></h1><p id="2516" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在JavaScript中，如果我们创建一个使用<code class="fe lb lc ld le b">extends</code>关键字扩展另一个类的类，那么我们必须调用<code class="fe lb lc ld le b">super</code>来调用子类中父类的构造函数。</p><p id="c0d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在调用<code class="fe lb lc ld le b">super</code>之前引用<code class="fe lb lc ld le b">this</code>，那么我们会得到一个ReferenceError。</p><p id="1102" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下类:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="b15b" class="mq lg iq le b gy mr ms l mt mu">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="1309" class="mq lg iq le b gy mv ms l mt mu">class Cat extends Animal {<br/>  constructor(name, breed) {<br/>    this.breed = breed;<br/>    super(name);<br/>  }<br/>}</span><span id="fadd" class="mq lg iq le b gy mv ms l mt mu">const cat = new Cat('jane', 'black')</span></pre><p id="1ea2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们将得到错误消息“未捕获的ReferenceError:在访问“this”或从派生的构造函数返回之前，必须调用派生类中的<code class="fe lb lc ld le b">super</code>构造函数”。</p><p id="1034" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为我们必须调用<code class="fe lb lc ld le b">super</code>来定义<code class="fe lb lc ld le b">this</code>。在子类开始配置<code class="fe lb lc ld le b">this</code>之前，必须首先调用父构造函数来完成<code class="fe lb lc ld le b">this</code>的配置。</p><p id="9001" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">超类不知道子类，所以超类必须先实例化。</p><p id="1aab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们需要在运行任何引用<code class="fe lb lc ld le b">this</code>的代码之前调用<code class="fe lb lc ld le b">super</code>，这样我们就不会出现这个错误。</p><p id="399d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">必须修改<code class="fe lb lc ld le b">Cat</code>类，这样任何引用<code class="fe lb lc ld le b">this</code>的代码都必须移到<code class="fe lb lc ld le b">super</code>函数调用的下面。</p><p id="57ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该改为写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="846c" class="mq lg iq le b gy mr ms l mt mu">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="21bb" class="mq lg iq le b gy mv ms l mt mu">class Cat extends Animal {<br/>  constructor(name, breed) {<br/>    super(name);<br/>    this.breed = breed;<br/>  }<br/>}</span><span id="fd1a" class="mq lg iq le b gy mv ms l mt mu">const cat = new Cat('jane', 'black')</span></pre><p id="61e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有在<code class="fe lb lc ld le b">constructor</code>方法中的<code class="fe lb lc ld le b"> this.breed = breed;</code>之前的<code class="fe lb lc ld le b">super</code>调用。</p><p id="d812" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们运行代码时，不会出现任何错误。</p><p id="ab6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，在任何其他方法中引用<code class="fe lb lc ld le b">this</code>的代码可以在任何地方。例如，如果我们有以下代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f5eb" class="mq lg iq le b gy mr ms l mt mu">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="7f75" class="mq lg iq le b gy mv ms l mt mu">  speak() {}<br/>}</span><span id="5b24" class="mq lg iq le b gy mv ms l mt mu">class Cat extends Animal {<br/>  constructor(name, breed) {<br/>    super(name);<br/>    this.breed = breed;<br/>  }</span><span id="46b0" class="mq lg iq le b gy mv ms l mt mu">  meow() {<br/>    console.log(this.name);<br/>    super.speak();<br/>  }<br/>}<br/>const cat = new Cat('jane', 'black')<br/>cat.meow();</span></pre><p id="52fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们在<code class="fe lb lc ld le b">Animal</code>类中有<code class="fe lb lc ld le b">speak</code>方法。在<code class="fe lb lc ld le b">Cat</code>类中，我们有在从父<code class="fe lb lc ld le b">Animal</code>类调用方法之前引用<code class="fe lb lc ld le b">this.name</code>的<code class="fe lb lc ld le b">meow</code>方法。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/c96d152904d716264170a857eb3a783d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ixfTylvk7XbL8Twj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@alschim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alexander Schimmeck</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="991e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="8b88" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果我们从同一个模块中导入多个成员，那么我们应该把它们都放在一个语句中以节省空间。</p><p id="d642" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">Symbol</code>函数不是构造函数。要创建一个新的符号，我们应该通过调用<code class="fe lb lc ld le b">Symbol</code>函数来创建它。</p><p id="f5b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了确保我们的父类实例配置正确，我们应该首先调用子类的构造函数中的<code class="fe lb lc ld le b">super</code>，然后运行任何引用<code class="fe lb lc ld le b">this</code>的代码。</p><h1 id="9a29" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">简明英语笔记</strong></h1><p id="9eb6" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">plain English . io</strong></a>上找到所有这些——关注我们的出版物并<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>