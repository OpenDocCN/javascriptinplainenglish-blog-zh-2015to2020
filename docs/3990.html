<html>
<head>
<title>Commons Mistakes with React useEffect hook and How to Prevent them.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React useEffect hook的常见错误及其预防。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/commons-mistakes-with-react-useeffect-hook-and-how-to-prevent-them-d0ca253fb1f7?source=collection_archive---------1-----------------------#2020-11-09">https://javascript.plainenglish.io/commons-mistakes-with-react-useeffect-hook-and-how-to-prevent-them-d0ca253fb1f7?source=collection_archive---------1-----------------------#2020-11-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="2c8a" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">技术提示</h2><div class=""/><div class=""><h2 id="3e00" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">我在使用<code class="fe ko kp kq kr b">useEffect</code>时遇到了一些问题，我会试着给你一些快速的模式，让你不会陷入同样令人失望的状态。</h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/b0ad4c25fcb3cc8e1dead30b824a38fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FaBNOnuJkIzIwXo410FNow.png"/></div></div></figure><p id="0440" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated"><code class="fe ko kp kq kr b">useEffect</code>是一个强大的工具，但你需要在清楚了解它如何工作的情况下使用它。否则，您可能会陷入令人失望的境地，出现一些难以调试的意外错误。</p><h1 id="2f44" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">在<code class="fe ko kp kq kr b">useEffect</code>返回一个承诺而不是一个函数</h1><p id="f33b" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">我想说的第一个错误是<code class="fe ko kp kq kr b">useEffect</code>期望你返回<code class="fe ko kp kq kr b">undefined</code>或者一个<code class="fe ko kp kq kr b">cleanup function</code>。但是如果你使用了一个<code class="fe ko kp kq kr b">async</code>函数，你实际上是在一个期望函数的地方返回了一个承诺(有时是一个解析为函数的承诺)，这解释了为什么你的清理没有工作。</p><p id="1a5b" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">这是如何发生的完美例子，以后我们会看到处理这种情况的正确方法:</p><pre class="kt ku kv kw gt mx kr my mz aw na bi"><span id="104a" class="nb mb iq kr b gy nc nd l ne nf">const App = () =&gt; {   <br/>  useEffect(async () =&gt; {<br/>    const unsubsribe = await dummySubscriber();</span><span id="bf0e" class="nb mb iq kr b gy ng nd l ne nf">    return () =&gt; {<br/>       unsubscribe()<br/>     }<br/>   }, [])</span><span id="beab" class="nb mb iq kr b gy ng nd l ne nf">  return null<br/>}</span></pre><p id="c98e" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">上面的例子是错误的，因为在闭包生成的时候，unsubscribe函数是未定义的。</p><p id="a66f" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我已经在下面的文章中解释了如何处理异步代码:</p><div class="nh ni gp gr nj nk"><a href="https://medium.com/javascript-in-plain-english/how-to-use-async-function-in-react-hook-useeffect-typescript-js-6204a788a435" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ja gy z fp np fr fs nq fu fw iz bi translated">如何在React hook use effect(Typescript/JS)中使用异步函数？</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">💡默认情况下，react的useEffect挂钩不支持异步函数，了解如何解决这个问题💪🏻</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">medium.com</p></div></div><div class="nt l"><div class="nu l nv nw nx nt ny lc nk"/></div></div></a></div><p id="81bc" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">还要记住，即使使用异步代码，效果也只是在触发和忘记模式下触发，而不需要等待您的异步代码。否则会有灾难性的用户界面后果。</p><h1 id="765a" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">useEffect和异步或条件订阅:如何正确清理它们？</h1><p id="e652" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">大多数人认为他们正在正确地取消订阅或附加到其节点的事件侦听器，但有时他们是错误的…</p><p id="c5a3" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">虽然当代码是同步的并且没有条件块时，一切都很简单，但当它不是同步的时，可能会变得有点棘手。</p><p id="34ed" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">考虑下面的事件订阅者，它被给定一个<code class="fe ko kp kq kr b">callback</code>并返回<code class="fe ko kp kq kr b">unsubscribe</code>函数。</p><pre class="kt ku kv kw gt mx kr my mz aw na bi"><span id="04fb" class="nb mb iq kr b gy nc nd l ne nf">function dummySubscriber(callback) {<br/>  const interval = setInterval(() =&gt; callback("ticked"), 1000);<br/>  <br/>  return function unSubscribe() {<br/>    clearInterval(interval);<br/>  };<br/>}</span></pre><p id="d163" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我已经看过太多次下面的代码，让开发人员期望取消订阅。</p><pre class="kt ku kv kw gt mx kr my mz aw na bi"><span id="c9be" class="nb mb iq kr b gy nc nd l ne nf">const App = () =&gt; {   <br/>  useEffect(() =&gt; {<br/>     let unsubscribe = () =&gt; undefined</span><span id="ac72" class="nb mb iq kr b gy ng nd l ne nf">     async function playEffect() {<br/>       await someAsyncCode()<br/>       unsubsribe = dummySubscriber()<br/>     }<br/>     playEffect()</span><span id="9126" class="nb mb iq kr b gy ng nd l ne nf">     return () =&gt; {<br/>       unsubscribe()<br/>     }<br/>   }, [])</span><span id="f73d" class="nb mb iq kr b gy ng nd l ne nf">  return null<br/>}</span></pre><p id="6fa2" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">事实是上面的代码不会退订，不会产生内存泄漏，因为在生成返回函数的那一刻，<code class="fe ko kp kq kr b">unsubscribe</code>还有<code class="fe ko kp kq kr b">() =&gt; undefined</code>值。</p><p id="aaf5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">通过在异步代码中重新分配它，我们替换了引用。这是一个比赛条件，因此有时可能不会发生，这就是为什么它很棘手，但它一点也不安全。</p><p id="0962" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">有两种方法可以克服这个问题:</p><ul class=""><li id="9ded" class="nz oa iq lg b lh li lk ll ln ob lr oc lv od lz oe of og oh bi translated">使用一个对象并修改它的一个属性，这将保持对源对象的引用。</li><li id="2a1c" class="nz oa iq lg b lh oi lk oj ln ok lr ol lv om lz oe of og oh bi translated">再次使用一个对象，但是通过使用<code class="fe ko kp kq kr b">useRef</code> hook from React。</li></ul><p id="84d6" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">两者都有相同的好处，但是使用<code class="fe ko kp kq kr b">useRef</code>允许您从其他地方编辑这段代码。</p><p id="e7d9" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">简单地说，<code class="fe ko kp kq kr b">useRef</code>用<code class="fe ko kp kq kr b">.current</code>返回一个对象，这允许我们重新赋值并保留对源对象的引用。</p><pre class="kt ku kv kw gt mx kr my mz aw na bi"><span id="dd16" class="nb mb iq kr b gy nc nd l ne nf">const App = () =&gt; {   <br/>  useEffect(() =&gt; {<br/>     const subscription = {unsubscribe: () =&gt; undefined}</span><span id="684f" class="nb mb iq kr b gy ng nd l ne nf">     async function playEffect() {<br/>       await someAsyncCode()<br/>       subscription.unsubsribe = dummySubscriber()<br/>     }<br/>     playEffect()</span><span id="f1c9" class="nb mb iq kr b gy ng nd l ne nf">     return () =&gt; {<br/>       subscription.unsubscribe()<br/>     }<br/>   }, [])</span><span id="2494" class="nb mb iq kr b gy ng nd l ne nf">  return null<br/>}</span></pre><p id="bd1a" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">或者使用反应参考</p><pre class="kt ku kv kw gt mx kr my mz aw na bi"><span id="e810" class="nb mb iq kr b gy nc nd l ne nf">const App = () =&gt; {   <br/>  const unsubscribe = useRef(() =&gt; undefined)</span><span id="3688" class="nb mb iq kr b gy ng nd l ne nf">  useEffect(() =&gt; {<br/>    async function playEffect() {<br/>       await someAsyncCode()<br/>       unsubscribe.current = dummySubscriber()<br/>     }<br/>     playEffect()</span><span id="2969" class="nb mb iq kr b gy ng nd l ne nf">    return () =&gt; {<br/>       unsubscribe.current()<br/>     }<br/>   }, [])</span><span id="b509" class="nb mb iq kr b gy ng nd l ne nf">  return null<br/>}</span></pre><p id="7861" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">现在，当生成返回函数时，它保留了一个对对象的引用，在上面的例子中，该对象的属性<code class="fe ko kp kq kr b">current</code>或<code class="fe ko kp kq kr b">unsubscribe</code>被更新。这样，我们的clean函数就被正确地调用了。</p><h1 id="fd9a" class="ma mb iq bd mc md me mf mg mh mi mj mk kf ml kg mm ki mn kj mo kl mp km mq mr bi translated">useEffect非预期触发和无限循环</h1><p id="bdd0" class="pw-post-body-paragraph le lf iq lg b lh ms ka lj lk mt kd lm ln mu lp lq lr mv lt lu lv mw lx ly lz ij bi translated">用<code class="fe ko kp kq kr b">useEffect</code>实现无限循环最简单的方法就是当一些状态改变时触发效果，当这个状态改变时，你运行一些代码触发这个相同的状态改变。</p><p id="901c" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">虽然当您只有这样的代码时，这看起来很明显:</p><pre class="kt ku kv kw gt mx kr my mz aw na bi"><span id="81bf" class="nb mb iq kr b gy nc nd l ne nf">const App = () =&gt; {<br/>   const [state, setState] = useState();</span><span id="ffc8" class="nb mb iq kr b gy ng nd l ne nf">   React.useEffect(() =&gt; {<br/>     setState(Math.random());<br/>   }, [state])<br/> }</span></pre><p id="eef5" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">当<code class="fe ko kp kq kr b">deps</code>数组有多个值时，这非常方便。我看到很多(太多)的<code class="fe ko kp kq kr b">useEffect</code>函数在做太多的事情。</p><p id="1732" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">总是倾向于使用多个<code class="fe ko kp kq kr b">useEffect</code>并保持单一责任原则的有效性。在<code class="fe ko kp kq kr b">useEffect</code>第二个参数中，依赖关系越少，出现的错误就越少。</p><p id="aa38" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">此外，如果你觉得你的效果中有太多的代码，花些时间重构并提取完成工作的函数。</p></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><p id="2396" class="pw-post-body-paragraph le lf iq lg b lh li ka lj lk ll kd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ij bi translated">我已经为<code class="fe ko kp kq kr b">useState</code>钩子写了一篇类似的文章，你可能会感兴趣。</p><div class="nh ni gp gr nj nk"><a href="https://medium.com/javascript-in-plain-english/commons-mistakes-with-react-usestate-hook-and-how-to-prevent-them-43c811ca7451" rel="noopener follow" target="_blank"><div class="nl ab fo"><div class="nm ab nn cl cj no"><h2 class="bd ja gy z fp np fr fs nq fu fw iz bi translated">React useState钩子的常见错误以及如何防止它们。</h2><div class="nr l"><h3 class="bd b gy z fp np fr fs nq fu fw dk translated">我在各种react项目中看到了一系列棘手的错误，而开发人员没有意识到这些错误可能会破坏他们的整个…</h3></div><div class="ns l"><p class="bd b dl z fp np fr fs nq fu fw dk translated">medium.com</p></div></div><div class="nt l"><div class="ou l nv nw nx nt ny lc nk"/></div></div></a></div></div><div class="ab cl on oo hu op" role="separator"><span class="oq bw bk or os ot"/><span class="oq bw bk or os ot"/><span class="oq bw bk or os"/></div><div class="ij ik il im in"><h2 id="aa4e" class="nb mb iq bd mc ov ow dn mg ox oy dp mk ln oz pa mm lr pb pc mo lv pd pe mq iw bi translated"><a class="ae pf" href="https://codingspark.io/?referral=medium" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> 🇫🇷为法国人🥖</strong>我提议将⚡️ <strong class="ak">编码Spark </strong>并以简讯的形式发布，以获得相关技术的报酬！</a></h2></div></div>    
</body>
</html>