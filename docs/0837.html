<html>
<head>
<title>Lazy evaluation in a strict language</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">严格语言中的懒惰评估</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lazy-evaluation-in-a-strict-language-a8f938870a7a?source=collection_archive---------4-----------------------#2019-12-19">https://javascript.plainenglish.io/lazy-evaluation-in-a-strict-language-a8f938870a7a?source=collection_archive---------4-----------------------#2019-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/284357d476a8509dd348b9f1e85bbfe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mSbDJ-ITGLKocM4sZ6rSNg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Translating from a language using lazy evaluation (left) to JavaScript (right)</figcaption></figure><div class=""/><div class=""><h2 id="d49e" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">用lambdas产生弱头范式</h2></div><p id="db57" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在这篇文章中，我假设你知道<em class="lq">懒惰评估</em>和<em class="lq">严格/急切评估</em>的区别，但是这里有一个快速总结。如果你关心的只是如何操作，跳过这一步。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="156c" class="ma mb jf lw b gy mc md l me mf">x = 3 + 4    // &lt;- does the addition happen here?<br/>print x      // &lt;- or here?<br/>print x      // &lt;- or even here?</span></pre><p id="1c0f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">不管你的编程背景和经验是什么，不管它是什么语言，你都有一个关于上面这段代码做什么的心智模型。我们可能都会猜测它会打印“7”两次。</p><p id="60ff" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">但是根据我们的背景，当 <em class="lq">确切地说</em> <code class="fe mg mh mi lw b">x</code>被“评估”为一个值时，即当3和4相加时，我们将对<em class="lq">做出不同的假设。在大多数命令式语言(C、C++、C#、Java、JavaScript等)中，它发生在第一行，即作为赋值的一部分——通常，赋值操作符计算它的右边。<em class="lq">那就是严格评价。</em>另一方面，如果代码片段是Haskell，那么赋值实际上只是给一个表达式赋值，而不是给<code class="fe mg mh mi lw b">x</code>赋值。它只在需要的时候被评估，这在第二行:为了打印<code class="fe mg mh mi lw b">x</code>，我们需要知道它的值。<em class="lq">那是懒评价。</em> <strong class="kw jg"> </strong>这是否意味着表达式在第三行再次求值？那会让懒惰的评价相当无效！答案是否定的(在Haskell中)，从某种意义上来说<code class="fe mg mh mi lw b">x</code>代表了它一旦被评估后的价值，因此后续的消费者可以直接使用那个价值，而不用再次评估。这个重要的概念被称为<strong class="kw jg"> </strong> <em class="lq">共享</em>。我不会在这里讨论懒惰评估的好处/缺点，但是你可以<a class="ae mj" href="https://www.tutorialspoint.com/functional_programming/functional_programming_lazy_evaluation.htm" rel="noopener ugc nofollow" target="_blank">阅读这里</a>。</em></p><p id="5edb" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现实世界是混合的。否则这篇文章的标题将毫无意义。实际上，编程语言在某种程度上支持严格求值和懒惰求值，它们只是有一种“默认味道”,使一种感觉比另一种更自然、更容易编写。Haskell支持严格评估。大多数命令式语言都支持惰性求值的常见用例，例如生成器/迭代器(一个潜在的无限“列表”，只要你要求它，它就会实现)。或者在. NET中输入<code class="fe mg mh mi lw b">Lazy&lt;T&gt;</code>。也许你以前在一个无参数函数上实现过记忆化。</p><p id="c534" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">但是到目前为止我还没有看到一个完整的<em class="lq">策略</em>将代码利用惰性求值嵌入到一个严格的语言中。</strong>上面的例子都是特例(可以说有很棒的语言支持)，但是有没有更通用的方法将懒惰代码嵌入到严格代码中呢？使用这种策略从一开始就将示例片段嵌入到JavaScript中，应该会产生前面描述的延迟求值(带共享)的确切行为。</p><p id="12bd" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这不是为一种懒惰的语言写一个解释器。显然，如果你用C++为Haskell构建一个完整的解释器，那么这是一种将懒惰代码嵌入严格代码的策略。我想讨论一下将懒惰代码<em class="lq">直接</em>嵌入严格代码的<em class="lq">极小</em>方式。</p><p id="21a0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">宿主语言。我的策略假设在严格的宿主语言中存在lambdas，这允许轻量级符号。我将使用JavaScript编写示例，这样您可以使用Node轻松地使用它们。JS或者你的浏览器。</strong></p><h1 id="3923" class="mk mb jf bd ml mm mn mo mp mq mr ms mt kl mu km mv ko mw kp mx kr my ks mz na bi translated">嵌入</h1><p id="f13c" class="pw-post-body-paragraph ku kv jf kw b kx nb kg kz la nc kj lc ld nd lf lg lh ne lj lk ll nf ln lo lp ij bi translated">让我们从另一个懒惰代码的示例片段开始，它将引导我们完成这个旅程:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="0423" class="ma mb jf lw b gy mc md l me mf">a = 3<br/>b = 4<br/>x = a * b<br/>twice = \v -&gt; v + v<br/>y = twice x<br/>print y</span></pre><p id="fd2d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在本节中，我们将对以下(错误的)JavaScript翻译进行改进:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="ccb4" class="ma mb jf lw b gy mc md l me mf">a = 3<br/>b = 4<br/>x = a * b<br/>twice = v =&gt; v + v<br/>y = twice(x)<br/>console.log(y)</span></pre><p id="cec4" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在引言中，我们已经讨论了当把一个表达式赋给一个变量时，惰性求值和严格求值是如何不同的！我们必须防止右手边的评价:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="f49e" class="ma mb jf lw b gy mc md l me mf">a = () =&gt; 3<br/>b = () =&gt; 4<br/>x = () =&gt; a() * b()<br/>twice = () =&gt; v =&gt; v + v<br/>y = () =&gt; twice()(x())<br/>console.log(y())</span></pre><p id="3475" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">请注意，现在所有五个变量都指向调用后将返回值的函数。所以<strong class="kw jg">我们使用无参数函数</strong>来表示懒惰值。但是等等，这个应该还包括<em class="lq">函数参数</em>:一个函数体可能不需要参数的值，所以在进行调用之前应该不需要对参数求值。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="9e8f" class="ma mb jf lw b gy mc md l me mf">a = () =&gt; 3<br/>b = () =&gt; 4<br/>x = () =&gt; a() * b()<br/>twice = () =&gt; v =&gt; v() + v()  // evaluate here...<br/>y = () =&gt; twice()(x)          // ...instead of here<br/>console.log(y())</span></pre><p id="bc4a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">现在只对“内置”的参数<code class="fe mg mh mi lw b">*</code>和<code class="fe mg mh mi lw b">console.log</code>求值，但这没关系，因为它们<em class="lq">需要它们的参数值。或者他们有吗？</em></p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="fe5d" class="ma mb jf lw b gy mc md l me mf">a = () =&gt; 3<br/>b = () =&gt; 4<br/>x = () =&gt; a() === 0 ? 0 : a() * b()      // maybe we don't need b!<br/>twice = () =&gt; v =&gt; v() + v()<br/>y = () =&gt; twice()(x)<br/>console.log(y())</span></pre><p id="83e5" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">惰性求值的一个优点是不会在不必要的时候计算可能很昂贵的表达式。<code class="fe mg mh mi lw b">b</code>这里的计算成本很低，但是请记住，这只是一个总体策略。</p><p id="7fa2" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">就懒惰而言，我们现在已经步入正轨，但还缺少重要的一块:<em class="lq">分享</em>。显式的函数调用语法让人痛苦地明白，我们在这里调用函数，并且多次调用相同的函数(<code class="fe mg mh mi lw b">a</code>和<code class="fe mg mh mi lw b">v</code>)。要查看效果，请将第一行修改为:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="0b76" class="ma mb jf lw b gy mc md l me mf">a = () =&gt; (console.count(), 3)</span></pre><p id="6aa4" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">你会看到这个函数现在被调用了4次！对于这样一个玩具例子来说，这不是问题，但是如果<code class="fe mg mh mi lw b">a</code>的评估成本很高，这就是一个大问题。更重要的是，这根本不是我们想要在这里模仿的语义。为了实现共享，我们需要记忆至少一些无参数函数的结果:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="bb7a" class="ma mb jf lw b gy mc md l me mf">function share(lazyVal) { // in .NET we could use Lazy&lt;T&gt;<br/>  let cache;<br/>  let evaled = false;<br/>  return () =&gt; evaled<br/>     ? cache<br/>     : (cache = (evaled = true, lazyVal()));<br/>}</span><span id="a600" class="ma mb jf lw b gy ng md l me mf">a = () =&gt; 3<br/>b = () =&gt; 4<br/>x = share(() =&gt; a() === 0 ? 0 : a() * b())<br/>twice = () =&gt; v =&gt; v() + v()<br/>y = share(() =&gt; twice()(x))<br/>console.log(y())</span></pre><p id="b673" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">懒惰和分享是不可观察的，以防被评估的表达式从一开始就是不可约的。这里的<code class="fe mg mh mi lw b">a</code>、<code class="fe mg mh mi lw b">b</code>和<code class="fe mg mh mi lw b">twice</code>就是这种情况，因为它们分别被定义为常数和λ。一般来说，在没有任何函数应用(或运算符应用)发生的情况下，可以省略<code class="fe mg mh mi lw b">share</code>的使用，因为<code class="fe mg mh mi lw b">cache</code>将只包含一个已经在代码中直接写出的值，因此可以在恒定时间内“获得”。</p><h1 id="aeaf" class="mk mb jf bd ml mm mn mo mp mq mr ms mt kl mu km mv ko mw kp mx kr my ks mz na bi translated">形式化</h1><p id="2fcc" class="pw-post-body-paragraph ku kv jf kw b kx nb kg kz la nc kj lc ld nd lf lg lh ne lj lk ll nf ln lo lp ij bi translated"><strong class="kw jg">语法。我们懒惰的玩具语言的表达有以下语法:</strong></p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="48a5" class="ma mb jf lw b gy mc md l me mf">E ::= val | name | E E | \name -&gt; E</span></pre><p id="5b8a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">值<code class="fe mg mh mi lw b">val</code>是已经完全评估过的内置常量。名字<code class="fe mg mh mi lw b">name</code>指的是一个表达式。它们可以引用先前定义的变量或lambda的形参。剩下的两种情况是函数应用和lambdas。</p><p id="f9b7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">语义学。</strong>当我们说“<code class="fe mg mh mi lw b">E</code>正在被求值”时，我们的意思是<code class="fe mg mh mi lw b">E</code>被简化成弱头范式(WHNF)。这意味着，例如，<code class="fe mg mh mi lw b">\name -&gt; E</code>中的<code class="fe mg mh mi lw b">E</code>是<em class="lq">而不是</em>缩减的，直到lambda被应用于一个参数。</p><p id="4248" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">旁注:在大多数带有lambdas的命令式编程语言中也是如此。想象一下，如果在调用<em class="lq"> </em> <code class="fe mg mh mi lw b">someFunc</code>之前，<code class="fe mg mh mi lw b">someFunc = arg =&gt; { console.log("Hello World"); return arg; }</code>行将立即打印“Hello World”。所以在某种意义上，一种将表达式简化为比WHNF更严格的范式的语言，比我们认为“严格”的大多数主流语言都更严格。</p><p id="4cee" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">“价值”在WHNF是一种表达方式。任何<code class="fe mg mh mi lw b">val</code>都是一个值。一个<code class="fe mg mh mi lw b">name</code>是一个值，如果它所引用的任何东西都可以通过评估它所引用的任何东西来评估。函数应用<code class="fe mg mh mi lw b">E E</code>不是一个值(为了这篇文章，我们假设第一个<code class="fe mg mh mi lw b">E</code>总是接受一个参数),可以使用“普通的”函数应用规则来简化。抽象<code class="fe mg mh mi lw b">\name -&gt; E</code>是一个值。</p><p id="c92b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">翻译尝试1。在严格的命令式语言(这里是JavaScript)中，我们需要明确区分值和表达式。值是我们可以传递给内置操作符或函数的东西，然而表达式是由返回一个值的无参数lambdas表示的。所以我们需要把<code class="fe mg mh mi lw b">E</code>翻译成后者:</strong></p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="634b" class="ma mb jf lw b gy mc md l me mf">L[val]        = () =&gt; val<br/>L[name]       = name<br/>L[E1 E2]      = share(() =&gt; L[E1]()(L[E2])())<br/>L[\name -&gt; E] = () =&gt; name =&gt; L[E]</span></pre><p id="f78e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这种转换是可行的，因为:值<code class="fe mg mh mi lw b">val</code>需要被包装，以符合“将返回值的无参数lambdas”类型。不需要用<code class="fe mg mh mi lw b">share</code>包装，因为检索已经花费了恒定的时间。Names <code class="fe mg mh mi lw b">name</code>引用了另一个表达式，根据定义，它具有预期的类型。函数应用<code class="fe mg mh mi lw b">E1 E2</code>更令人兴奋:它的结果被缓存，因为计算起来可能很昂贵。为了计算它，对<code class="fe mg mh mi lw b">L[E1]</code>进行了评估。我们期望得到的值是一个JavaScript函数，它接受一个表达式并返回一个表达式，所以我们可以直接传递<code class="fe mg mh mi lw b">L[E2]</code>并评估结果，因为我们期望<code class="fe mg mh mi lw b"> () =&gt; L[E1]()(L[E2])()</code>返回一个<em class="lq">值</em>。lambda抽象的翻译再次变得简单明了。<code class="fe mg mh mi lw b">name =&gt; L[E]</code>是一个原语，所以使用<code class="fe mg mh mi lw b">share</code>没有意义。我们希望它接受一个表达式并返回一个表达式，在给定所有其他定义的情况下，它确实这样做了。</p><p id="b210" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们使用前面的示例片段来测试一下:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="7a6e" class="ma mb jf lw b gy mc md l me mf">a = () =&gt; 3<br/>b = () =&gt; 4<br/>x = share(() =&gt; share(() =&gt; mul()(a)())()(b)())<br/>twice = () =&gt; v =&gt; share(() =&gt; share(() =&gt; add()(v)())()(v)())<br/>y = share(() =&gt; twice()(x)())<br/>console.log(y())</span><span id="1196" class="ma mb jf lw b gy ng md l me mf">// This assumes "mul" is a function behaving like "*",<br/>// but translated into the format expected by our embedding<br/>mul = () =&gt; a =&gt; () =&gt; b =&gt; share(() =&gt; a() * b())<br/>// Analogously for "add"</span></pre><p id="53f3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">哇，括号真多。不知何故，这不是我们之前用手想出来的翻译。</p><p id="5575" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">翻译尝试2。</strong>简化为WHNF有一个有用的特性:假设我们正在处理某个表达式<code class="fe mg mh mi lw b">E</code>，它有某个子表达式<code class="fe mg mh mi lw b">S</code>。当将<code class="fe mg mh mi lw b">E</code>简化为WHNF时，<code class="fe mg mh mi lw b">S</code>要么根本不被触及(可能已经被丢弃，或者可能“隐藏”在一个lambda抽象中)，要么也被简化为WHNF。没有介于两者之间的东西。</p><p id="edb1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这意味着，当我们发现自己处于将函数应用于参数的情况时，我们想要结果的<em class="lq">值</em>，而不是另一个表达式。您也可以在我们之前的规则中清楚地看到这一点:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="799b" class="ma mb jf lw b gy mc md l me mf">L[E1 E2] = share(() =&gt; L[E1]()(L[E2])())<br/>                                     ^^ Here!</span></pre><p id="c10a" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这是应用函数的唯一规则，它显然需要一个结果值。那么为什么不在惰性语言中嵌入函数作为<em class="lq">函数，首先接受一个表达式并返回值</em>(而不是表达式)<em class="lq"> </em>？让我们调整规则:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="fe3e" class="ma mb jf lw b gy mc md l me mf">L[E1 E2] = share(() =&gt; L[E1]()(L[E2]))<br/>L[\name -&gt; E] = () =&gt; name =&gt; L[E]()</span></pre><p id="c6d8" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">紧接着括号就少了(我在之前有<code class="fe mg mh mi lw b">()</code>的地方留下了空格，唯一增加的代码是粗体的):</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="c5ac" class="ma mb jf lw b gy mc md l me mf">a = () =&gt; 3<br/>b = () =&gt; 4<br/>x = share(() =&gt; share(() =&gt; mul()(a)  )()(b)  )<br/>twice = () =&gt; v =&gt; share(() =&gt; share(() =&gt; add()(v)  )()(v)  )<strong class="lw jg">()</strong><br/>y = share(() =&gt; twice()(x)  )<br/>console.log(y())</span><span id="e837" class="ma mb jf lw b gy ng md l me mf">// This assumes "mul" is a function behaving like "*",<br/>// but translated into the format expected by our embedding<br/>mul = () =&gt; a =&gt; b =&gt; a() * b()<br/>// Analogously for "add"</span></pre><p id="76a0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">但是仍然有很多噪音，一些圆括号显然是无用的，例如在<code class="fe mg mh mi lw b">share(() =&gt; share(() =&gt; add()(v))()(v))()</code>中，我们在定义了一个无参数函数之后就调用它。类似于前面的推理，我们保证要么根本不执行这个代码，要么两个都发生，一个函数被定义，只是被立即调用。该函数永远不会被传递到另一个位置，所以没有理由在一开始就定义它。</p><p id="eb30" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">翻译尝试3。</strong>为了防止无用的函数定义，我们再仔细看看之前提炼的翻译规则:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="f733" class="ma mb jf lw b gy mc md l me mf">L[E1 E2] = share(() =&gt; <strong class="lw jg">L[E1]()</strong>(L[E2]))<br/>L[\name -&gt; E] = () =&gt; name =&gt; <strong class="lw jg">L[E]()</strong></span></pre><p id="25e3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">请注意，现在有两个位置可以立即调用翻译的结果(side node:只有一个这样的位置有未细化的规则，因此细化对于下面的操作至关重要)。</p><p id="d83d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们的翻译操作符<code class="fe mg mh mi lw b">L</code>总是产生一个表达式，即使在某些情况下可能一个值更合适。因此，我们定义了第二个操作符<code class="fe mg mh mi lw b">S</code>，它将产生一个值:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="6153" class="ma mb jf lw b gy mc md l me mf">L[val] = () =&gt; val<br/>L[name] = name<br/>L[E1 E2] = share(() =&gt; <strong class="lw jg">S[E1]</strong>(L[E2]))<br/>L[\name -&gt; E] = () =&gt; name =&gt; <strong class="lw jg">S[E]</strong></span><span id="a77e" class="ma mb jf lw b gy ng md l me mf">S[val] = val<br/>S[name] = name()<br/>S[E1 E2] = S[E1](L[E2])<br/>S[\name -&gt; E] = name =&gt; S[E]</span></pre><p id="cb04" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">得到的翻译是:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="9a81" class="ma mb jf lw b gy mc md l me mf">a = () =&gt; 3<br/>b = () =&gt; 4<br/>x = share(() =&gt; mul()(a)(b))<br/>twice = () =&gt; v =&gt; add()(v)(v)<br/>y = share(() =&gt; twice()(x))<br/>console.log(y())</span><span id="4640" class="ma mb jf lw b gy ng md l me mf">// This assumes "mul" is a function behaving like "*",<br/>// but translated into the format expected by our embedding<br/>mul = () =&gt; a =&gt; b =&gt; a() * b()<br/>// Analogously for "add"</span></pre><p id="c1bc" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这是我们手动想出来的！我们内联了<code class="fe mg mh mi lw b">mul</code>和<code class="fe mg mh mi lw b">add</code>，但是在这一点上应该很容易看出代码是等价的。</p><h1 id="ca66" class="mk mb jf bd ml mm mn mo mp mq mr ms mt kl mu km mv ko mw kp mx kr my ks mz na bi translated">摘要</h1><p id="3605" class="pw-post-body-paragraph ku kv jf kw b kx nb kg kz la nc kj lc ld nd lf lg lh ne lj lk ll nf ln lo lp ij bi translated">考虑一种玩具语言，它具有惰性求值语义，将WHNF语中的术语视为“值”，并具有以下语法:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="530e" class="ma mb jf lw b gy mc md l me mf">E ::= val | name | E E | \name -&gt; E</span></pre><p id="f28d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们可以使用操作符<code class="fe mg mh mi lw b">L</code>将这种语言中的术语翻译成JavaScript表达式(返回值的无参数函数)，或者使用操作符<code class="fe mg mh mi lw b">S</code>将JavaScript值翻译成:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="a7b4" class="ma mb jf lw b gy mc md l me mf">L[val] = () =&gt; S[val]<br/>L[name] = name<br/>L[E1 E2] = share(() =&gt; S[E1 E2])<br/>L[\name -&gt; E] = () =&gt; S[\name -&gt; E]</span><span id="c149" class="ma mb jf lw b gy ng md l me mf">S[val] = val<br/>S[name] = L[name]()<br/>S[E1 E2] = S[E1](L[E2])<br/>S[\name -&gt; E] = name =&gt; S[E]</span></pre><p id="cfc7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">toy语言中的Lambdas对应于JavaScript中接受表达式并返回值的函数。</p><h1 id="9eef" class="mk mb jf bd ml mm mn mo mp mq mr ms mt kl mu km mv ko mw kp mx kr my ks mz na bi translated">现在怎么办？</h1><p id="6e34" class="pw-post-body-paragraph ku kv jf kw b kx nb kg kz la nc kj lc ld nd lf lg lh ne lj lk ll nf ln lo lp ij bi translated">像<code class="fe mg mh mi lw b">Lazy&lt;T&gt;</code>这样的结构只是上述翻译的一个特例。甚至迭代器也只是这种情况的一个实例:当在lambda演算中对列表进行编码(例如Scott-encoding)并使用上述方法进行翻译时，最终得到的是迭代器数据类型。</p><p id="65f1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这种翻译策略可能不会让你做一些你用熟悉的结构已经做不到的事情，但我希望它能提供一些关于懒惰和严格评估之间的基本关系的见解，并代表<a class="ae mj" href="https://www.fpcomplete.com/blog/2017/09/all-about-strictness" rel="noopener ugc nofollow" target="_blank"> Haskell的bang运算符</a>的逆运算。</p><p id="40c1" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我知道你的想法，或者如果你觉得这对你正在做的事情有用的话！:-)</p></div></div>    
</body>
</html>