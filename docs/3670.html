<html>
<head>
<title>Creating a Shared State Library for Micro-Frontends Using Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Redux为微前端创建共享状态库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-a-shared-state-library-for-micro-frontends-using-redux-7776bff18ef1?source=collection_archive---------5-----------------------#2020-10-16">https://javascript.plainenglish.io/creating-a-shared-state-library-for-micro-frontends-using-redux-7776bff18ef1?source=collection_archive---------5-----------------------#2020-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1724689da1c97b84ce59b33cb33629d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b2akbdgZiA7IpXdXjtWnUA.jpeg"/></div></div></figure><p id="d01f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的开发团队最近开始使用React为电子商务网站构建微前端。在构建了第二个站点之后，我们注意到在redux操作以及它们如何处理常见的后端交互之间有很多重复。例如，用户向购物车添加商品或登录在不同的应用程序中是完全一样的。</p><p id="8652" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不可避免地，我们发现了一个影响carts操作的bug，并最终对两个站点上的reducers应用了一个修复……虽然跨两个站点复制和粘贴一个修复是微不足道的，但我们只能想象这个问题会跨越几十个站点。重构呢？这是不可持续的。有很多关于创建共享组件库的文章和观点，但是共享状态管理库呢？</p><p id="c7cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们知道我们需要创建一个NPM包，我们当前和未来的网站都可以利用，但问题是如何协调我们希望redux处理的特定于应用程序的逻辑。例如，如果站点A需要一个reducer来处理一些特定的逻辑，而这些逻辑的范围仅限于该站点，那该怎么办呢？一种方法是在React应用程序中使用2个商店。这种方法很快被证明是容易出错的，并且可能会给开发人员带来很大的认知负担。</p><p id="6f88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用2个商店的问题是你需要使用额外的样板代码来使<code class="fe kw kx ky kz b">useDispatch</code>或<code class="fe kw kx ky kz b">useSelector</code>工作。在下面的例子中，我们将上下文传递给redux挂钩，以识别要访问哪个存储。有两家店意味着两套<code class="fe kw kx ky kz b">dispatch</code>T3等等</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="d7a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我已经能感觉到这种方法酝酿的混乱。我们想要的很简单；使用外部减速器和动作的灵活性，无需多个存储🤔。</p><p id="0273" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">答案，现在看起来很明显，是通过<code class="fe kw kx ky kz b">combineReducers</code>使用还原剂组合，如果我们选择，允许我们从无数不同的来源组合我们的还原剂。</p><p id="de79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个NPM包，简单地公开我们已经写好(两次)的reducers和actions，是一个简单的复制粘贴工作。有趣的工作是在我们的捆绑和发布中让我们的库工作，并允许在消费前端轻松导入。</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="le lf l"/></div></figure><p id="36ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的webpack配置中，我们给<code class="fe kw kx ky kz b">entry</code>点起了别名，以使开发人员更容易使用他们需要的特定reducer，而不必编写/some/long/path/to/a/reducer。</p><p id="da75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的<code class="fe kw kx ky kz b">externals</code>包含了我们前端已经有的包，因此它们不会被重复包含，并将减少包的大小。您可以在消费文件<code class="fe kw kx ky kz b">frontEndStore.js</code>中看到，我们简单地导入我们想要的缩减器，并将它们与任何本地缩减器组合在一起。瞧。现在我们不需要担心支持多个商店！</p><p id="9ccc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是出版呢？很高兴你问了。发布到NPM只是一个命令，但是我们也希望在git repo中保留标记的历史，以防我们需要在某个标记处签出库，也许是为了创建特定版本的修补程序或比较版本。以下是使版本控制和git标签变得简单的命令:</p><pre class="la lb lc ld gt lg kz lh li aw lj bi"><span id="72b1" class="lk ll iq kz b gy lm ln l lo lp">//package.json</span><span id="e2df" class="lk ll iq kz b gy lq ln l lo lp">"scripts": {<br/>  "preversion": "npm test &amp;&amp; npm run build",<br/>  "version": "npm run build &amp;&amp; git add .",<br/>  "postversion": "git push &amp;&amp; git push --tags",<br/>  "test": "jest",<br/>  "analyze": "NODE_ENV=production PROFILER=1 npx webpack",<br/>  "build": "NODE_ENV=production npx webpack",<br/>  "start": "NODE_ENV=development npx webpack --progress --color --watch"<br/>}</span></pre><p id="f386" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，开发人员需要做的就是运行<code class="fe kw kx ky kz b">npm version minor</code>来更新package.json版本，添加标签并创建一个生产版本。<code class="fe kw kx ky kz b">npm publish</code>将为你的崇拜者开放图书馆！</p><p id="f033" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然这种解决方案似乎符合我们的需求和特定场景，但对于微前端架构肯定有很多强烈的意见，我们仍在学习之旅中。希望这将使您创建共享redux库的尝试变得更加容易。</p><p id="6830" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae lr" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="ka ir">！</strong></p></div></div>    
</body>
</html>