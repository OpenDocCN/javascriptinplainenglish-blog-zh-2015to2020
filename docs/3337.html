<html>
<head>
<title>Best Features of ES2017 — Async Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2017的最佳特性—异步功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-features-of-es2017-async-functions-2a18cb7e9140?source=collection_archive---------7-----------------------#2020-09-20">https://javascript.plainenglish.io/best-features-of-es2017-async-functions-2a18cb7e9140?source=collection_archive---------7-----------------------#2020-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/31588c03c11cc4802da97f80d57eb5c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CuJJDV9fIuBvtVWG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@zoltantasi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zoltan Tasi</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5b39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解ES2017的最佳特性。</p><h1 id="32ce" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步函数</h1><p id="35dd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">异步功能是ES2017发布的一大功能。</p><p id="fceb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是<code class="fe me mf mg mh b">then</code>方法的一个有用的简写。</p><p id="7c70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用以下方式声明异步函数:</p><ul class=""><li id="66cc" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated">异步函数声明:<code class="fe me mf mg mh b">async function foo() {}</code></li><li id="2974" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">异步函数表达式:<code class="fe me mf mg mh b">const foo = async function () {};</code></li><li id="94a5" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">异步方法定义:<code class="fe me mf mg mh b">let obj = { async foo() {} }</code></li><li id="c3c6" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">异步箭头功能:<code class="fe me mf mg mh b">const foo = async () =&gt; {};</code></li></ul><p id="dc1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">异步函数总是返回承诺。</p><p id="a8ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="349e" class="ne lc iq mh b gy nf ng l nh ni">async function asyncFunc() {<br/>  return 'foo';<br/>}</span></pre><p id="d883" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe me mf mg mh b">asyncFunc</code>返回解析到<code class="fe me mf mg mh b">'foo'</code>的承诺。</p><p id="3c8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="3cb8" class="ne lc iq mh b gy nf ng l nh ni">asyncFunc()<br/>  .then(x =&gt; console.log(x));</span></pre><p id="eb7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了拒绝一个承诺，我们抛出一个错误:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="d8c8" class="ne lc iq mh b gy nf ng l nh ni">async function asyncFunc() {<br/>  throw new Error('error');<br/>}</span></pre><p id="84a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过编写以下内容来捕捉错误:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="b207" class="ne lc iq mh b gy nf ng l nh ni">asyncFunc()<br/>  .catch(x =&gt; console.log(x));</span></pre><p id="9ef7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">await</code>处理承诺的结果和错误。</p><p id="aae9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">await</code>运算符只允许在异步函数中使用。</p><p id="bc69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它等待它的操作数，这总是一个要解决的承诺。</p><p id="d069" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果承诺实现了，那么<code class="fe me mf mg mh b">await</code>的结果就是它的实现值。</p><p id="2b5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果承诺被拒绝，那么<code class="fe me mf mg mh b">await</code>抛出拒绝值。</p><p id="1d95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="13a7" class="ne lc iq mh b gy nf ng l nh ni">async function asyncFunc() {<br/>  const result = await promise;<br/>  console.log(result);<br/>}</span></pre><p id="3f7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">promise</code>是我们等待结果的承诺。</p><p id="56ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这等同于:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="8cdb" class="ne lc iq mh b gy nf ng l nh ni">async function asyncFunc() {<br/>  return promise<br/>    .then(result =&gt; {<br/>      console.log(result);<br/>    });<br/>}</span></pre><p id="01db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种语法的好处是我们可以用更短的方式处理多个承诺。</p><p id="403b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="df15" class="ne lc iq mh b gy nf ng l nh ni">async function asyncFunc() {<br/>  const result1 = await promise1();<br/>  console.log(result1);<br/>  const result2 = await promise2();<br/>  console.log(result2);<br/>}</span></pre><p id="8c4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这等同于:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="c057" class="ne lc iq mh b gy nf ng l nh ni">function asyncFunc() {<br/>  return promise1()<br/>    .then(result1 =&gt; {<br/>      console.log(result1);<br/>      return promise2();<br/>    })<br/>    .then(result2 =&gt; {<br/>      console.log(result2);<br/>    });<br/>}</span></pre><p id="26a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如我们所见，它要短得多。</p><p id="4708" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要并行运行多个承诺，我们可以使用<code class="fe me mf mg mh b">Promise.all</code>:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="d1bc" class="ne lc iq mh b gy nf ng l nh ni">async function asyncFunc() {<br/>  const [result1, result2] = await Promise.all([<br/>    promise1(),<br/>    promise2(),<br/>  ]);<br/>  console.log(result1, result2);<br/>}</span></pre><p id="f9a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与以下内容相同:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="ccd9" class="ne lc iq mh b gy nf ng l nh ni">async function asyncFunc() {<br/>  return Promise.all([<br/>      promise1(),<br/>      promise2(),<br/>    ])<br/>    .then(([result1, result2]) =&gt; {<br/>      console.log(result1, result2);<br/>    });<br/>}</span></pre><p id="7d4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了处理错误，我们像处理同步函数一样使用try-catch:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="343a" class="ne lc iq mh b gy nf ng l nh ni">async function asyncFunc() {<br/>  try {<br/>    await promiseFunc();<br/>  } catch (err) {<br/>    console.error(err);<br/>  }<br/>}</span></pre><p id="38ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与以下内容相同:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="199f" class="ne lc iq mh b gy nf ng l nh ni">function asyncFunc() {<br/>  return promiseFunc()<br/>    .catch(err =&gt; {<br/>      console.error(err);<br/>    });<br/>}</span></pre><p id="1efe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">异步函数通过使用生成器来等待结果，直到它继续执行。</p><p id="c561" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次添加<code class="fe me mf mg mh b">await</code>操作符时，它都会等待结果。</p><p id="dc34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦承诺兑现，那么异步函数将继续运行。</p><p id="0f43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">异步函数同步启动，异步结算。</p><p id="f98f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">异步函数的结果总是一个承诺。</p><p id="3862" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺是在异步函数启动时创建的。</p><p id="0010" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后运行它的主体。</p><p id="062d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可能以<code class="fe me mf mg mh b">return</code>或<code class="fe me mf mg mh b">throw</code>结束。</p><p id="5164" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者可以用<code class="fe me mf mg mh b">await</code>暂停，一旦获得结果就继续。</p><p id="73c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后最后，诺言被归还。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/ebf0b78b6512796e5fa36f43b454ee7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PVQWmcGVvhjlvAjj"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@freetousesoundscom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Free To Use Sounds</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e900" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="380c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">异步函数是编写promise代码的一种很好的速记方式。</p><p id="cd5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些函数总是返回承诺。</p><h2 id="377a" class="ne lc iq bd ld nk nl dn lh nm nn dp ll ko no np lp ks nq nr lt kw ns nt lx nu bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="8cb8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>