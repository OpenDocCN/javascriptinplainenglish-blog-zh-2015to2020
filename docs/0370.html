<html>
<head>
<title>Binary Search Trees in Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代码中的二分搜索法树</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/binary-search-trees-in-code-79c2ba7e72f3?source=collection_archive---------0-----------------------#2019-09-27">https://javascript.plainenglish.io/binary-search-trees-in-code-79c2ba7e72f3?source=collection_archive---------0-----------------------#2019-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a0f41ce96fbf8548f8a094db8ad8c271.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LLVTAY089oPKsYlxs_Ailg.jpeg"/></div></div></figure><div class=""/><p id="02bd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上周，我们看了看二分搜索法树背后的理论，以及它们是如何工作的(如果你错过了，请在这里阅读<a class="ae kw" href="https://medium.com/javascript-in-plain-english/binary-search-trees-how-they-work-9c64029eedb7" rel="noopener">。本周，我们将使用JavaScript以编程方式创建和操作二叉查找树。</a></p><p id="399c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">提醒一下，<strong class="ka jc">二叉树</strong>是计算机科学中的一种树形数据结构，其中每个节点最多只能有两个孩子。子节点通常被称为左节点和右节点。一个<strong class="ka jc">二叉查找树</strong>是一种特定类型的二叉树，其中节点按照它们在树中的排列进行排序。每个节点仍然最多只能有两个子节点，但是在二叉查找树中，<strong class="ka jc">左边的子节点</strong> <strong class="ka jc">将<em class="kx">始终</em>小于根节点的值</strong>，右边的子节点<strong class="ka jc">将<em class="kx">始终</em>大于它的值</strong>。</p><h1 id="b949" class="ky kz jb bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">JavaScript中的二叉查找树</h1><p id="db70" class="pw-post-body-paragraph jy jz jb ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">我们如何在JavaScript中以编程方式表示二叉查找树？实际上，这很简单。事实上比表示一个<a class="ae kw" href="https://medium.com/swlh/bfs-and-dfs-in-code-ba3f01c16156" rel="noopener">图</a>简单多了。JavaScript对象是表示树中每个节点的完美数据结构，因为它允许我们存储每个节点左右子节点的关系数据。</p><p id="9785" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，假设我们有以下一组数字，并希望将其排列成二叉查找树:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="eb8b" class="mk kz jb mg b gy ml mm l mn mo">let numbers = [9, 4, 12, 15, 72, 21, 36, 2, 10, 14, 8, 19]</span></pre><p id="b1e4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从9开始，我们可以将9表示为根节点，如下所示:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="b130" class="mk kz jb mg b gy ml mm l mn mo">let rootNode = {element: 9, rightChild: null, leftChild: null}</span></pre><p id="4453" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">转到列表中的下一个数字4，我们看到4小于9，因此是它的左孩子。我们用JS对象表示4，并更新rootNode:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="5c39" class="mk kz jb mg b gy ml mm l mn mo"><strong class="mg jc">let nodeA = {element: 4, rightChild: null, leftChild: null}<br/></strong></span><span id="7d5f" class="mk kz jb mg b gy mp mm l mn mo">let rootNode = {element: 9, rightChild: null, <strong class="mg jc">leftChild: nodeA</strong>}</span></pre><p id="3bac" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们移动到数组中的第三个元素，即12。12大于9，所以将被添加为根节点的右子节点:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="46bb" class="mk kz jb mg b gy ml mm l mn mo"><strong class="mg jc">let nodeB = {element: 12, rightChild: null, leftChild: null}</strong></span><span id="a057" class="mk kz jb mg b gy mp mm l mn mo">let nodeA = {element: 4, rightChild: null, leftChild: null}<br/></span><span id="cef0" class="mk kz jb mg b gy mp mm l mn mo">let rootNode = {element: 9, <strong class="mg jc">rightChild: nodeB, </strong>leftChild: nodeA}</span></pre><p id="ff77" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这一过程贯穿初始数字集合中的每一个元素，直到我们到达最后一个。12之后，我们代表15。我们知道它大于9，所以向右移动。我们知道它大于12，所以向右移动。然后我们看到还没有合适的孩子，所以15成为合适的孩子，以此类推。我们现在有了完整的二叉查找树，并且可以有效地遍历它，因为我们知道每个被访问的节点都不需要访问它的兄弟节点或它的任何后代节点。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="9483" class="mk kz jb mg b gy ml mm l mn mo">let nodeK = {element: 19, rightChild: null, leftChild: null}</span><span id="ab1a" class="mk kz jb mg b gy mp mm l mn mo">let nodeJ = {element: 8, rightChild: null, leftChild: null}</span><span id="1695" class="mk kz jb mg b gy mp mm l mn mo">let nodeI = {element: 14, rightChild: null, leftChild: null}</span><span id="67a8" class="mk kz jb mg b gy mp mm l mn mo">let nodeH = {element: 10, rightChild: null, leftChild: null}</span><span id="22ae" class="mk kz jb mg b gy mp mm l mn mo">let nodeG = {element: 2, rightChild: null, leftChild: null}</span><span id="1871" class="mk kz jb mg b gy mp mm l mn mo">let nodeF = {element: 36, rightChild: null, leftChild: null}</span><span id="21b5" class="mk kz jb mg b gy mp mm l mn mo">let nodeE = {element: 21, rightChild: nodeF, leftChild: nodeK}</span><span id="d792" class="mk kz jb mg b gy mp mm l mn mo">let nodeD = {element: 72, rightChild: null, leftChild: nodeE}</span><span id="143f" class="mk kz jb mg b gy mp mm l mn mo">let nodeC = {element: 15, rightChild: nodeD, leftChild: nodeI}</span><span id="d9cf" class="mk kz jb mg b gy mp mm l mn mo">let nodeB = {element: 12, rightChild: nodeC, leftChild: nodeH}</span><span id="25c7" class="mk kz jb mg b gy mp mm l mn mo">let nodeA = {element: 4, rightChild: nodeJ, leftChild: nodeG}</span><span id="a4fa" class="mk kz jb mg b gy mp mm l mn mo">let rootNode = {element: 9, rightChild: nodeB, leftChild: nodeA}</span></pre><p id="6ce0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码相当于下面的树:</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="5b8b" class="mk kz jb mg b gy ml mm l mn mo">                                 9</span><span id="b386" class="mk kz jb mg b gy mp mm l mn mo">                              /      \</span><span id="7890" class="mk kz jb mg b gy mp mm l mn mo">                            4          12</span><span id="04d9" class="mk kz jb mg b gy mp mm l mn mo">                          /   \       /   \</span><span id="ff9c" class="mk kz jb mg b gy mp mm l mn mo">                        2       8   10     15</span><span id="8aba" class="mk kz jb mg b gy mp mm l mn mo">                                          /   \</span><span id="b178" class="mk kz jb mg b gy mp mm l mn mo">                                        14     72</span><span id="f975" class="mk kz jb mg b gy mp mm l mn mo">                                              /</span><span id="f07b" class="mk kz jb mg b gy mp mm l mn mo">                                            21</span><span id="7ec5" class="mk kz jb mg b gy mp mm l mn mo">                                           /  \</span><span id="db63" class="mk kz jb mg b gy mp mm l mn mo">                                         19    36</span></pre><p id="4432" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以看到，对于任何给定的节点，<em class="kx">它右边的所有</em>节点都比它大，而<em class="kx">它左边的所有</em>节点都比它小。如果我们想找到节点72，我们只需从9，到12，到15，然后到72，因为我们知道72将<em class="kx">总是</em>在9，12和15的右边。</p><p id="e843" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下周回来学习JavaScript中的递归。</p></div></div>    
</body>
</html>