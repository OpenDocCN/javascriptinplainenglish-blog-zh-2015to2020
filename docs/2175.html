<html>
<head>
<title>Everything You Need to Know About React Concurrent Mode in 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于2020年的React并发模式，你需要知道的一切</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/everything-you-need-to-know-about-react-concurrent-mode-in-2020-826af48c1f37?source=collection_archive---------0-----------------------#2020-05-27">https://javascript.plainenglish.io/everything-you-need-to-know-about-react-concurrent-mode-in-2020-826af48c1f37?source=collection_archive---------0-----------------------#2020-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bfe3" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一些激动人心的变化即将到来</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/94719c8e5ed8b9ab21ce0874144a4c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FOCJSdj-Vjdksisa.jpg"/></div></div></figure><p id="03d2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React不断发展，你必须跟上它才能在市场上有价值。在这篇文章中，我将告诉你React并发模式，这是一个尚未被采用的新特性。</p><blockquote class="ln lo lp"><p id="da0f" class="kr ks lq kt b ku kv jr kw kx ky ju kz lr lb lc ld ls lf lg lh lt lj lk ll lm ij bi translated"><em class="iq">在任何情况下都不要将本建议用于生产(截至2020年5月)。并发模式是实验性的，充满了错误，在您阅读本文时，可能会也可能不会引入突破性的变化。</em></p></blockquote><h1 id="4cee" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">什么是并发模式？</h1><p id="c9ac" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">React有一个复杂的机制来处理组件的更新。并发模式是对该算法的一系列更改，本质上是让React同时渲染多个树，中断、延迟或消除正在进行的渲染并推迟状态更新。</p><p id="dff8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以把它想象成一个版本控制系统:在任何时间点，用户都可以看到“主”分支。React在后台渲染不同的分支。一旦到了将它呈现给用户的时候，它们就被合并到“主”中。如果不再需要某个分支，它就会被拆除，永远不会被合并。</p><h1 id="ea7e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">为什么我们需要并发模式？</h1><p id="908b" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">主要还是为了用户体验。我想你们大多数人在使用React应用程序时都经历过口吃和奇怪的死机。特别是，您可以在自动完成的异步文本字段(搜索建议)中输入时注意到它。有很多方法可以解决这个问题，但直到现在都没有解决。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/262117f25506a4494849924c583f59be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*CH0e-F5hDsFwBNo9"/></div></figure><p id="76c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这张图应该会更清楚。一旦API请求返回自动完成数据(不再有效)，UI就会被阻止更新它。在React并发模式下，UI永远不会被同步操作阻塞。一旦您更改了文本字段中的值，React就会停止正在做的任何事情，并立即开始传播这些更改，而无需等待旧的自动完成调用和呈现完成。</p><p id="f0ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，这个特殊的问题可以通过去抖动和节流来解决。但是这些都不是很优雅，在网速低的情况下仍然会导致口吃。React并发模式是针对所有环境中所有类似问题的综合解决方案。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/9d235df2e98809594bcd97f8fc0873c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*9F-ZrS6zMHPP6aMK"/></div></figure><p id="41ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最重要的是，如果更多的相关数据已经到达，渲染可以中途中断。这将带来前所未有的性能提升。</p><h1 id="f74e" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">如何使用并发模式？</h1><p id="8313" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">我再次强调，不要把它用在敏感的生产项目上。尽管这些特性目前还比较稳定，但开发团队可能会随时彻底改变它们。</p><p id="f2bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前，并发模式只针对ReactDOM(传统的HTML React)实现，而不是React Native。通过使用自定义入口脚本，您可以在React Native中仅在web构建中使用它。对于常规的React，已经包含了这个脚本。您需要将行<code class="fe ms mt mu mv b">ReactDOM.render(&lt;App /&gt;, rootNode)</code>改为:</p><pre class="kg kh ki kj gt mw mv mx my aw mz bi"><span id="c4b0" class="na lv iq mv b gy nb nc l nd ne">ReactDOM.createRoot(rootNode).render(&lt;App /&gt;)</span></pre><p id="26e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样。这将为您的应用程序启用完全并发模式。但是，您应该不会立即注意到任何变化。唯一可能发生的事情是，如果您使用与并发模式不兼容的第三方依赖项，您的应用程序将不再工作。</p><p id="1d7a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，并发模式本身几乎毫无用处。为了使用，我们将参考React推出的另外两个特性以及并发模式:<code class="fe ms mt mu mv b">Suspense</code>和<code class="fe ms mt mu mv b">useTransition</code>。</p><h1 id="9ad5" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">焦虑</h1><p id="ab4c" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">悬念不仅是加快你申请速度的一种方式，而且也使申请变得更简单。“暂停”允许您等待组件完全渲染，并在渲染时显示加载器。考虑这个例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="5001" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第3行，我们<em class="lq">开始</em>从远程服务器装载汽车，假设这个调用可能需要一段时间。然后，<code class="fe ms mt mu mv b">App</code>渲染，<code class="fe ms mt mu mv b">Suspense</code>试图渲染<code class="fe ms mt mu mv b">CarDetails</code>。<code class="fe ms mt mu mv b">CarDetails</code>调用<code class="fe ms mt mu mv b">cars.read()</code>，一直阻塞到装车。<code class="fe ms mt mu mv b">Suspense</code>看到组件还不能渲染，转而渲染<code class="fe ms mt mu mv b">fallback</code>。一旦汽车数据准备就绪，<code class="fe ms mt mu mv b">Suspense</code>将用<code class="fe ms mt mu mv b">CarDetails</code>替换<code class="fe ms mt mu mv b">fallback</code>。注意，我使用的是任意的API，只是为了向您展示<code class="fe ms mt mu mv b">Suspense</code>是如何工作的。<code class="fe ms mt mu mv b">Suspense</code>需要库支持，还不能直接使用<code class="fe ms mt mu mv b">fetch</code>。脸书的GraphQL客户端，<a class="ae nh" href="https://relay.dev/" rel="noopener ugc nofollow" target="_blank"> Relay </a>，目前支持<code class="fe ms mt mu mv b">Suspense</code>。</p><h1 id="160f" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">使用过渡</h1><p id="b280" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated"><code class="fe ms mt mu mv b">useTransition</code>与<code class="fe ms mt mu mv b">Suspense</code>密切相关，但让您对过程有更多的控制。简而言之，<code class="fe ms mt mu mv b">useTransition</code>是一个钩子，如果数据还不存在，它允许您延迟状态更新。例如，在按下按钮导航到下一个屏幕后，您可能希望等待一秒钟，这样下一个页面就可以加载，而用户不会看到任何白屏或加载微调器。<code class="fe ms mt mu mv b">useTransition</code>是这样使用的:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="ec08" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，我们使用任意的API实现，非常接近中继。最初用的是<code class="fe ms mt mu mv b">initialResource</code>，没有车。用户可以通过按下按钮来装载汽车。stare会更新使用<code class="fe ms mt mu mv b">carResource</code>，<code class="fe ms mt mu mv b">CarView</code>会有一些车展示。但是，它们必须先被加载。</p><p id="9273" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是<code class="fe ms mt mu mv b">useTransition</code>发挥作用的地方。它返回两个值:一个是<code class="fe ms mt mu mv b">startTransition</code>，它是一个启动转换的函数，另一个是<code class="fe ms mt mu mv b">isPending</code>，它是一个布尔值，让您知道转换是否正在进行。在传递给<code class="fe ms mt mu mv b">useTransition</code>的配置对象中，我们指定了<code class="fe ms mt mu mv b">timeoutMs</code>属性。这是<code class="fe ms mt mu mv b">useTransition</code>可以等待延迟状态更新的最大时间。如果1秒钟后数据仍不存在，状态将被更新，并且<code class="fe ms mt mu mv b">CarView</code>将重新出现在主屏幕上。</p><p id="9cc2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在第9行你可以看到<code class="fe ms mt mu mv b">startTransition</code>的用法。我们传递一个更新状态的函数来使用<code class="fe ms mt mu mv b">carResource</code>。React将制作一个<code class="fe ms mt mu mv b">CarView</code>的副本，传入更新后的<code class="fe ms mt mu mv b">resource</code>并等待它重新呈现。如果在一秒钟内获取数据，<code class="fe ms mt mu mv b">CarView</code>将完成渲染，React】将合并到主UI树中。如果1秒钟后它不存在，React仍然会合并它，所以您需要自己在<code class="fe ms mt mu mv b">CarView</code>中实现一个加载微调器。</p><h1 id="b6ad" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">结束语</h1><p id="b9a8" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">感谢您的阅读，我希望您和我一样对并发模式感兴趣。敬请关注更多文章！</p><h1 id="4b14" class="lu lv iq bd lw lx ly lz ma mb mc md me jw mf jx mg jz mh ka mi kc mj kd mk ml bi translated">资源</h1><ul class=""><li id="5238" class="ni nj iq kt b ku mm kx mn la nk le nl li nm lm nn no np nq bi translated"><a class="ae nh" href="https://reactjs.org/docs/concurrent-mode-adoption.html" rel="noopener ugc nofollow" target="_blank">采用并发模式</a></li><li id="75d1" class="ni nj iq kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated"><a class="ae nh" href="https://relay.dev/" rel="noopener ugc nofollow" target="_blank">继电器</a></li><li id="3a6e" class="ni nj iq kt b ku nr kx ns la nt le nu li nv lm nn no np nq bi translated"><a class="ae nh" href="https://everyday.codes/javascript/how-react-reconciliation-algorithm-works/" rel="noopener ugc nofollow" target="_blank"> React对账算法</a></li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="http://eepurl.com/gYiA29"><div class="gh gi nw"><img src="../Images/446049aa060bbaea15a64e1a907b1030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*zWeFS3E1gbkEuBmpbvm6Rg.jpeg"/></div></a></figure><h2 id="97b0" class="na lv iq bd lw nx ny dn ma nz oa dp me la ob oc mg le od oe mi li of og mk oh bi translated"><strong class="ak">简明英语团队的笔记</strong></h2><p id="b652" class="pw-post-body-paragraph kr ks iq kt b ku mm jr kw kx mn ju kz la mo lc ld le mp lg lh li mq lk ll lm ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae nh" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kt ir">JavaScript in Plain English</strong></a><a class="ae nh" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kt ir">AI in Plain English</strong></a><a class="ae nh" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kt ir">UX in Plain English</strong></a><a class="ae nh" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kt ir">Python in Plain English</strong><strong class="kt ir"/>—谢谢，继续学习！</a></p><p id="137a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还推出了一个YouTube，希望你们支持我们，通过<a class="ae nh" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">订阅我们的简明英语频道</strong> </a></p><p id="7e8a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一如既往,“简明英语”希望帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae nh" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">submissions @ plain English . io</strong></a><strong class="kt ir"/>并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>