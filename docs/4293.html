<html>
<head>
<title>Restify — Content Negotiation and Errors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">重新定义—内容协商和错误</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/restify-content-negotiation-and-errors-250d41585709?source=collection_archive---------18-----------------------#2020-11-30">https://javascript.plainenglish.io/restify-content-negotiation-and-errors-250d41585709?source=collection_archive---------18-----------------------#2020-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4986e42a290adab9ec3992cec8b0bf5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QsT85rHdMPKDHXVJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@willfrancis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Will Francis</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3622" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Restify是一个简单的节点后端框架。</p><p id="dd41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何使用Restify处理内容协商和错误。</p><h1 id="cc79" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">内容协商和格式化</h1><p id="fa38" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Restify将按照从高到低的优先级来确定响应的<code class="fe me mf mg mh b">content-type</code>。</p><p id="a85d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果存在的话，它将使用<code class="fe me mf mg mh b">res.contentType</code>。</p><p id="ccfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果设置了<code class="fe me mf mg mh b">Content-Type</code>响应头。</p><p id="9864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果body是一个对象而不是一个<code class="fe me mf mg mh b">Buffer</code>实例，将返回<code class="fe me mf mg mh b">application/json</code>。</p><p id="b087" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，它通过将可用的格式化程序与请求的<code class="fe me mf mg mh b">accept</code>头匹配来协商<code class="fe me mf mg mh b">content-type</code>。</p><p id="1cb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果不能确定一个<code class="fe me mf mg mh b">content-type</code>，那么Restify将响应一个错误。</p><p id="1092" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果可以协商一个<code class="fe me mf mg mh b">content-type</code>，那么它将决定使用什么格式化程序来格式化响应的内容。</p><p id="9558" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果找不到与<code class="fe me mf mg mh b">content-type</code>匹配的格式化程序，那么Restify将覆盖响应的<code class="fe me mf mg mh b">content-type</code>到<code class="fe me mf mg mh b">'application/octet-stream'</code>，如果找不到该<code class="fe me mf mg mh b">content-type</code>的格式化程序，则出错。</p><p id="06fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建Restify服务器实例时，可以通过传递<code class="fe me mf mg mh b">strictFormatters: false</code>属性来更改默认行为。</p><p id="f067" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有为<code class="fe me mf mg mh b">content-type</code>找到格式化程序，则刷新响应而不应用任何格式化程序。</p><p id="b746" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe me mf mg mh b">application/json</code>、<code class="fe me mf mg mh b">text/plain</code>和<code class="fe me mf mg mh b">application/octet-stream</code>格式化器对船只进行重新格式化。</p><p id="d104" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在创建服务器时，我们可以通过传递内容类型和解析器的散列来添加额外的格式化程序。</p><p id="c380" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8388" class="mq lc iq mh b gy mr ms l mt mu">var restify = require('restify');<br/>const util = require('util');</span><span id="3486" class="mq lc iq mh b gy mv ms l mt mu">function respond(req, res, next) {<br/>  res.send('hello');<br/>  next();<br/>}</span><span id="efa8" class="mq lc iq mh b gy mv ms l mt mu">var server = restify.createServer({<br/>  formatters: {<br/>    ['application/foo'](req, res, body) {<br/>      if (body instanceof Error)<br/>        return body.stack;</span><span id="85d7" class="mq lc iq mh b gy mv ms l mt mu">      if (Buffer.isBuffer(body))<br/>        return body.toString('base64');</span><span id="ccca" class="mq lc iq mh b gy mv ms l mt mu">      return util.inspect(body);<br/>    }<br/>  }<br/>});</span><span id="c1a7" class="mq lc iq mh b gy mv ms l mt mu">server.get('/hello', respond);<br/>server.head('/hello', respond);</span><span id="9175" class="mq lc iq mh b gy mv ms l mt mu">server.listen(8080);</span></pre><p id="de2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有用于<code class="fe me mf mg mh b">application/foo</code>内容类型的<code class="fe me mf mg mh b">formatters</code>对象。</p><p id="9dc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果主体是一个缓冲区，那么我们返回一个base64字符串。</p><p id="aab0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以在我们的格式化程序定义中添加一个<code class="fe me mf mg mh b">q-value</code>来改变格式化程序的优先级:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8866" class="mq lc iq mh b gy mr ms l mt mu">var restify = require('restify');<br/>const util = require('util');<br/>function respond(req, res, next) {<br/>  res.send('hello');<br/>  next();<br/>}<br/>var server = restify.createServer({<br/>  formatters: {<br/>    ['application/foo q=0.9'](req, res, body) {<br/>      if (body instanceof Error)<br/>        return body.stack;<br/>      if (Buffer.isBuffer(body))<br/>        return body.toString('base64');<br/>      return util.inspect(body);<br/>    }<br/>  }<br/>});<br/>server.get('/hello', respond);<br/>server.head('/hello', respond);<br/>server.listen(8080);</span></pre><p id="9896" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用默认格式化程序重新格式化。</p><p id="5d4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当用<code class="fe me mf mg mh b">createServer</code>传递格式化程序选项时，它可以被覆盖:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b9f3" class="mq lc iq mh b gy mr ms l mt mu">var restify = require('restify');<br/><br/>function respond(req, res, next) {<br/>  const body = 'hello world';<br/>  res.writeHead(200, {<br/>    'Content-Length': Buffer.byteLength(body),<br/>    'Content-Type': 'text/plain'<br/>  });<br/>  res.write(body);<br/>  res.end();    <br/>}<br/>var server = restify.createServer();<br/>server.get('/hello', respond);<br/>server.head('/hello', respond);<br/>server.listen(8080);</span></pre><p id="4629" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一个对象调用了<code class="fe me mf mg mh b">writeHead</code>方法，该对象带有我们希望在头中返回的<code class="fe me mf mg mh b">content-type</code>选项。</p><h1 id="1227" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">错误处理</h1><p id="a1e1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过用<code class="fe me mf mg mh b">next</code>函数传递一个错误对象来处理错误情况。</p><p id="7a8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fd2a" class="mq lc iq mh b gy mr ms l mt mu">var restify = require('restify');<br/>var errors = require('restify-errors');</span><span id="a726" class="mq lc iq mh b gy mv ms l mt mu">var server = restify.createServer();</span><span id="801b" class="mq lc iq mh b gy mv ms l mt mu">server.get('/hello/:foo', function(req, res, next) {<br/>  var err = new errors.NotFoundError('not found');<br/>  return next(err);<br/>});</span><span id="e473" class="mq lc iq mh b gy mv ms l mt mu">server.on('NotFound', function (req, res, err, cb) {<br/>  return cb();<br/>});</span><span id="357b" class="mq lc iq mh b gy mv ms l mt mu">server.listen(8080);</span></pre><p id="4500" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe me mf mg mh b">NotFound</code>处理程序来记录日志或收集数据。</p><p id="a081" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">NotFoundError</code>构造函数在<code class="fe me mf mg mh b">restify-errors</code>模块中。</p><p id="8e9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该在<code class="fe me mf mg mh b">NotFound</code>处理程序中调用<code class="fe me mf mg mh b">res.send</code>，因为它在不同的错误上下文中。</p><h1 id="6e30" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="c575" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用同样的方式格式化我们的数据并进行内容协商。</p><p id="2590" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们用<code class="fe me mf mg mh b">restify-errors</code>模块创建错误对象。</p><p id="da91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>