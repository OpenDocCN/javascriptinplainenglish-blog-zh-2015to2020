<html>
<head>
<title>React context API (Part 1) — Passing state to child components made easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React上下文API(第1部分)——将状态传递给子组件变得更加容易</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-context-api-part-1-passing-state-to-child-components-made-easy-5152001e1988?source=collection_archive---------0-----------------------#2019-07-13">https://javascript.plainenglish.io/react-context-api-part-1-passing-state-to-child-components-made-easy-5152001e1988?source=collection_archive---------0-----------------------#2019-07-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e7bf" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">所以，你听说过React的上下文API，但是因为Redux的复杂性而不敢接近它。好吧，我的朋友，这是一个简单的教程，让你开始感受背景之美。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/949f7c7f21d8cf303c2828b30a1081da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUk_mC8ojHhStMEURjbI8g.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@oskaryil?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Oskar Yildiz</a> on <a class="ae ks" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4a6c" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">什么是语境？</h1><p id="0d4d" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">React的上下文API旨在使向组件传递数据变得更加容易。这可以通过一种叫做支柱钻孔的方法来完成。这里是肯特·c·多兹写的一篇关于支柱钻井的非常好的文章。支柱钻孔仍然是一种好方法，但是，对于较大的应用来说，它不是很实用。</p><p id="d37f" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">许多人也求助于一个叫做<a class="ae ks" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>的工具。Redux很棒，它的实现和你使用上下文的方式非常相似。不幸的是，学习曲线非常陡峭，对于大多数应用程序来说，Redux简直是大材小用。</p><p id="1c56" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">那么，回到<em class="mm">什么是语境？</em>上下文允许状态数据通过<em class="mm">提供者</em>在组件树中从父节点传递到子节点。每个子组件可以有一个<em class="mm">消费者</em>，该消费者将从父组件订阅状态变化。太棒了。功能子组件可以订阅父组件的状态。</p><h1 id="09a9" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">为什么语境有用？</h1><p id="9b5c" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">上下文允许数据在组件树中作为<em class="mm">全局</em>数据共享。这使得代码可读性更好。无论子组件位于组件树中的哪个位置，子组件都直接订阅顶层组件状态。</p><p id="9e43" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">还记得道具钻吗？嗯，随着组件树变得越来越大，顶层状态必须钻透的层变得相当复杂。通常很难找到组件树中包含bug的地方。对于上下文，每个子组件只是订阅顶层状态。在这种情况下，通过层转发道具不会成为问题。</p><h1 id="6fe7" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">简单教程</h1><p id="12bb" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><em class="mm">已经有例子了吗？不要担心。接下来就是了！</em></p><p id="4c56" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io">创建上下文。</strong>让我们创建一个Context.js文件。它将为我们创造提供者和消费者。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="ad86" class="ms ku in mo b gy mt mu l mv mw">import { createContext } from "react"</span><span id="9aef" class="ms ku in mo b gy mx mu l mv mw">const { Provider, Consumer } = createContext()</span><span id="a123" class="ms ku in mo b gy mx mu l mv mw">export { Provider, Consumer }</span></pre><p id="a107" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">首先，我们需要从react导入<em class="mm"> createContext </em>。这将允许我们创建上下文对象。然后，我们将创建<em class="mm">提供者</em>和<em class="mm">消费者</em>。这很重要。提供者将向消费者提供(没有双关的意思……嗯，有点)状态。每个消费者将订阅来自提供商的更新。</p><p id="e360" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io">父。</strong>接下来，我们将创建<em class="mm">父</em>组件。该组件将包含提供者和状态。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="1f50" class="ms ku in mo b gy mt mu l mv mw">import React, { Component } from "react"<br/>import { Provider } from "./Context"<br/>import Child from "./Child"<br/>class Parent extends Component {<br/>  state = {<br/>    people: [<br/>      { id: 0, name: "Bob", age: 24 },<br/>      { id: 1, name: "Jack", age: 22 },<br/>      { id: 2, name: "Jill", age: 26 },<br/>    ],<br/>  }</span><span id="54a0" class="ms ku in mo b gy mx mu l mv mw">  render() {<br/>    return (<br/>      &lt;Provider value={this.state}&gt;<br/>        &lt;Child /&gt;<br/>      &lt;/Provider&gt;<br/>    )<br/>  }<br/>}</span><span id="c90d" class="ms ku in mo b gy mx mu l mv mw">export default Parent</span></pre><p id="3ac0" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><em class="mm">状态</em>声明为<em class="mm">人</em>。人们有三个项目。然后，<em class="mm">提供者</em>上下文对象被包装在一个<em class="mm">子</em>组件周围。注意提供商。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="afc1" class="ms ku in mo b gy mt mu l mv mw">&lt;Provider value={this.state}&gt;<br/>  &lt;Child /&gt;<br/>&lt;/Provider&gt;</span></pre><p id="5d6b" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">在提供者组件中，值被设置为<code class="fe my mz na mo b">{this.state}</code>。在<em class="mm">子</em>组件中，有一个<em class="mm">消费者</em>将订阅由提供者提供的值。在这种情况下，值就是状态。<strong class="ln io">注意:提供者总是要包装消费者。如果有消费者的组件没有提供者，它将不起作用。</strong></p><p id="cee8" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io">孩子。</strong>接下来，我们将创建<em class="mm">子组件</em>。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="7c28" class="ms ku in mo b gy mt mu l mv mw">import React from "react"<br/>import { Consumer } from "./Context"<br/>import Grandchild from "./GrandChild"</span><span id="924c" class="ms ku in mo b gy mx mu l mv mw">function Child() {<br/>  return (<br/>    &lt;Consumer&gt;<br/>      {context =&gt; (<br/>        &lt;div&gt;<br/>          &lt;h1&gt;Child Component&lt;/h1&gt;<br/>          {context.people.map(person =&gt; {<br/>            return (<br/>              &lt;p key={person.id}&gt;<br/>                Hi, I am {person.name} and I am {person.age}<br/>                years old.<br/>              &lt;/p&gt;<br/>            )<br/>          })}</span><span id="3a86" class="ms ku in mo b gy mx mu l mv mw">          &lt;GrandChild /&gt;<br/>        &lt;/div&gt;<br/>      )}<br/>    &lt;/Consumer&gt;<br/>  )<br/>}</span><span id="e857" class="ms ku in mo b gy mx mu l mv mw">export default Child</span></pre><p id="7290" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">好吧，发生了不少事。我们来分解一下。首先，导入<em class="mm">消费者</em>上下文对象。接下来，整个组件由消费者上下文对象包装。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="68ea" class="ms ku in mo b gy mt mu l mv mw">&lt;Consumer&gt;<br/>  {context =&gt; (<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Child Component&lt;/h1&gt;<br/>      {context.people.map(person =&gt; {<br/>        return (<br/>          &lt;p key={person.id}&gt;<br/>            Hi, I am {person.name} and I am {person.age} years old.<br/>          &lt;/p&gt;<br/>        )<br/>      })}</span><span id="9153" class="ms ku in mo b gy mx mu l mv mw">      &lt;GrandChild /&gt;<br/>    &lt;/div&gt;<br/>  )}<br/>&lt;/Consumer&gt;</span></pre><p id="5eeb" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">消费者内部是<code class="fe my mz na mo b">{context =&gt; ( ... )}</code>。还记得供应商的<code class="fe my mz na mo b">value=this.state</code>吗？消费者的背景与价值直接相关。这是因为它已经订阅了它。让我们仔细看看消费者是如何使用上下文的。<strong class="ln io">注意:“上下文”是一个任意的名称。可能是数据，狗，等等。</strong></p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="5855" class="ms ku in mo b gy mt mu l mv mw">{<br/>  context.people.map(person =&gt; {<br/>    return (<br/>      &lt;p key={person.id}&gt;<br/>        Hi, I am {person.name} and I am {person.age} years old.<br/>      &lt;/p&gt;<br/>    )<br/>  })<br/>}</span></pre><p id="26e8" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">因为<em class="mm">上下文</em>是通过消费者传递的，并且<em class="mm">上下文</em>订阅了父节点的状态，所以我们可以访问<em class="mm">人</em>！要获取内容，我们所要做的就是执行<strong class="ln io"> context.people </strong>这里所发生的是子组件通过people中的每一项进行映射。然后它会显示一个句子，使用每个<em class="mm">人</em>项的姓名和年龄。</p><p id="c7b0" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">让我绕个小弯，希望能帮你解决一些头疼的问题。让我们再来看看提供者。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="1224" class="ms ku in mo b gy mt mu l mv mw">&lt;Provider value={state: this.state}&gt;<br/>  &lt;Child /&gt;<br/>&lt;/Provider&gt;</span></pre><p id="5184" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">注意到什么不同了吗？不再是T3，而是现在的T4。你绝对能做到。事实上，在本系列的第2部分中，我们将会这样做。如果您想从提供者向消费者传递多个值(比如状态和函数)，那么消费者调用该项的方式是不同的。</p><p id="90c5" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">如果提供者以上述方式传递状态，子组件看起来会是这样。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="a33e" class="ms ku in mo b gy mt mu l mv mw">{<br/>  context.state.people.map(person =&gt; {    return (<br/>      &lt;p key={person.id}&gt;<br/>        Hi, I am {person.name} and I am {person.age} years old.<br/>      &lt;/p&gt;<br/>    )<br/>  })<br/>}</span></pre><p id="772f" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">注意，现在要使用来自提供者的值，我们必须说<code class="fe my mz na mo b">context.state.people</code>。我花了很长时间才明白。但是，希望这有所帮助！</p><p id="ae2a" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">好了，我们来看看<strong class="ln io"> <em class="mm">孙儿</em> </strong>组件。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="1112" class="ms ku in mo b gy mt mu l mv mw">import React from "react"<br/>import { Consumer } from "./Context"</span><span id="5a05" class="ms ku in mo b gy mx mu l mv mw">function GrandChild() {<br/>  return (<br/>    &lt;Consumer&gt;<br/>      {context =&gt; (<br/>        &lt;div&gt;<br/>          &lt;h1&gt;Grandchild Component&lt;/h1&gt;<br/>          {context.people.map(person =&gt; {<br/>            return (<br/>              &lt;p key={person.id}&gt;<br/>                Hi, I am {person.name} and I am {person.age} years old                                            <!-- --> </span><span id="1209" class="ms ku in mo b gy mx mu l mv mw">              &lt;/p&gt; <br/>            )<br/>          })}<br/>        &lt;/div&gt;<br/>      )}<br/>    &lt;/Consumer&gt;<br/>  )<br/>}</span><span id="a492" class="ms ku in mo b gy mx mu l mv mw">export default GrandChild</span></pre><p id="9755" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><strong class="ln io">孙儿。</strong>嗯……看着眼熟。就功能而言，它与<em class="mm">子组件</em>非常相似。整个组件仍然包裹着<em class="mm">消费者</em>。这允许来自<em class="mm">父</em>的状态被传递下去。</p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="ebab" class="ms ku in mo b gy mt mu l mv mw">&lt;Provider value={this.state}&gt;<br/>  &lt;Child /&gt;<br/>&lt;/Provider&gt;</span></pre><p id="4816" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">还记得这个吗？这是在父组件中。提供者包装<strong class="ln io"> <em class="mm">子</em> </strong>。内子是<strong class="ln io"> <em class="mm">孙儿</em> </strong>。这意味着孙子可以订阅提供者给定的值。这就是它能够访问状态的原因。</p><p id="fb9b" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><em class="mm">但是，如果我不想嵌套它们呢？如果我只想让两个组件独立访问父状态呢？没问题。查看下面的代码。</em></p><pre class="kd ke kf kg gt mn mo mp mq aw mr bi"><span id="5b76" class="ms ku in mo b gy mt mu l mv mw">&lt;Provider value={this.state}&gt;<br/>  &lt;ComponentOne /&gt;<br/>  &lt;ComponentTwo /&gt;<br/>&lt;/Provider&gt;</span></pre><p id="829e" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">然后，只需用消费者包装每个组件中的内容，就万事俱备了。</p><p id="ab17" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">好了，我们终于可以运行我们的应用程序了。这是它看起来的样子。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/6153769394b562cd26d2636d628a2cfa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/0*ykFEfM2M2TLsYnNX.png"/></div></figure><p id="642e" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">子组件是从上下文提供者接收状态的第一个组件。然后，它继续将状态传递给孙代。如您所见，即使包装在子组件中的孙组件也可以访问父状态。</p><h1 id="8db7" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">结论</h1><p id="0829" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">因此，我们已经了解了如何通过一个简单的应用程序使用React的上下文API。父节点的状态通过提供者传递给子节点。消费者在子组件中被用来<em class="mm">订阅</em>提供者中传递的值。没那么糟吧？查看<a class="ae ks" href="https://medium.com/@valdezalex31/react-context-api-part-2-updating-state-through-a-consumer-7be723b54d7b" rel="noopener"> <strong class="ln io"> <em class="mm">第2部分</em> </strong> </a>，我将向您展示如何用一个消费者更新父消费者的状态。</p><h1 id="7a7d" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">资源</h1><ul class=""><li id="1832" class="nc nd in ln b lo lp lr ls lu ne ly nf mc ng mg nh ni nj nk bi translated"><a class="ae ks" href="https://github.com/arevaldez/simple-context-app" rel="noopener ugc nofollow" target="_blank">我的知识库</a></li><li id="e48d" class="nc nd in ln b lo nl lr nm lu nn ly no mc np mg nh ni nj nk bi translated">肯特·c·多兹的支柱钻探</li><li id="4777" class="nc nd in ln b lo nl lr nm lu nn ly no mc np mg nh ni nj nk bi translated"><a class="ae ks" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">上下文文档</a></li></ul></div><div class="ab cl nq nr hr ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ig ih ii ij ik"><p id="bcfa" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated"><em class="mm">原载于</em><a class="ae ks" href="https://techflip.netlify.com/react-context-api-passing-state-to-child-components-made-easy/" rel="noopener ugc nofollow" target="_blank"><em class="mm">https://techflip.netlify.com</em></a><em class="mm">。</em></p></div></div>    
</body>
</html>