<html>
<head>
<title>The Anatomy of Decorators in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">棱角分明的装饰家剖析</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-anatomy-of-decorators-in-angular-d7972bf9e865?source=collection_archive---------3-----------------------#2020-07-13">https://javascript.plainenglish.io/the-anatomy-of-decorators-in-angular-d7972bf9e865?source=collection_archive---------3-----------------------#2020-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4e9c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一个深入指导装修在角</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e35b3f102c433cd4671ac65f4c8cb990.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OBXc2NIUnVM7WuKFyTQtug.jpeg"/></div></div></figure><h1 id="b333" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">介绍</h1><p id="0416" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Angular的潜在机制绝对值得探索。当我们开始使用Angular时，你不可避免地会遇到装饰者，因为他们在Angular框架的生态系统中扮演着至关重要的角色。在很大程度上，装饰者是内置的，你不需要做太多。但是最终，随着你深入框架，你会想要解释decorators来利用它的能力来增强你的开发体验，提高可读性，除此之外，最重要的因素之一是<a class="ae mf" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir">关注点分离</strong> </a>。</p><p id="e19e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir">关注点分离</strong>是一种流行的软件设计模式，用于<strong class="ll ir">将一个计算机程序</strong>分成不同的部分，这样每个部分处理一个单独的<strong class="ll ir">关注点。Angular已经在文件结构层次上实现了这种模式，因为Html、CSS和ts有单独的文件，但是我们可以通过使用decorators来分离类、属性或方法关注点，从而更深入地实现这种模式。</strong></p><p id="2ce4" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">到本文结束时，您将有望不仅理解装饰者如何在幕后工作，而且理解如何有效和高效地利用他们。</p><p id="c9bc" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">让我们开始吧。</p><h1 id="6075" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">定义</h1><p id="6c7f" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">根据角度文件:</p><blockquote class="ml mm mn"><p id="7d22" class="lj lk mo ll b lm mg jr lo lp mh ju lr mp mi lu lv mq mj ly lz mr mk mc md me ij bi translated"><strong class="ll ir">decorator</strong>是一种设计模式，用于在不修改原始源代码的情况下，对一个类进行单独的修改或修饰。</p></blockquote><p id="da33" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">简单地说，有了<strong class="ll ir">decorator，</strong>我们可以在设计时配置和定制我们的类。它们只是函数，可以用来添加元数据、属性或函数到它们所附加的东西上，因此它们没有什么可怕的。</p><p id="6ed5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><strong class="ll ir"> Decorators的</strong>函数被调用时带有前缀@符号，后面紧跟着一个类、参数、方法或属性。<strong class="ll ir"> decorator </strong>函数被提供了关于类、参数或方法的信息，而<strong class="ll ir"> decorator </strong>函数在其位置返回一些东西或以某种方式操纵其目标。</p><h1 id="9a0e" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">装饰者的结构</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/44076e0ee026c53a006dbdfaffc2b13f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UFXC2sUhbb8W_hZePguVjQ.png"/></div></div><figcaption class="mt mu gj gh gi mv mw bd b be z dk">Angular decorator structure</figcaption></figure><p id="da02" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">上图描述了decorators是如何在angular中实现的。实现装饰器的底层因素是通过利用TypeScript的<a class="ae mf" href="https://github.com/rbuckton/reflect-metadata" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir">反射元数据API </strong> </a> <strong class="ll ir">。</strong></p><p id="b060" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">反射元数据Api在Angular中处理装饰器和元数据。浏览器不支持，所以Angular使用了TypeScript编译器来使用decorators。它是在angular-polyfills.js文件中导入的。只有在早期版本的Angular中才需要此依赖性。在Angular 6之后，从聚合填充中移除了这种依赖性，从而实现了反射元数据过程的自动化。</p><h1 id="2d42" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">元数据条目</h1><p id="0165" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Angular为此元数据使用了几个条目:</p><ul class=""><li id="fa9f" class="nb nc iq ll b lm mg lp mh ls nd lw ne ma nf me ng nh ni nj bi translated"><strong class="ll ir">注释</strong>。这对应于decorators在类级别设置的元数据。这是一个数组，因为你可以在这个层次上应用几个装饰器。比如<strong class="ll ir">@组件</strong>和<strong class="ll ir">@路由</strong>。</li><li id="abbe" class="nb nc iq ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><strong class="ll ir">设计:</strong> <code class="fe mx my mz na b"><strong class="ll ir">paramtypes</strong></code>。这对应于构造函数参数的类型。它只适用于TypeScript，因为在ES6中，不支持这样的参数。使用这种语言，您需要为<strong class="ll ir">参数</strong>属性提供一个静态getter。</li><li id="4642" class="nb nc iq ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><strong class="ll ir">prop元数据</strong>。这对应于decorators在类属性级别设置的元数据。它是一个对象，每个条目名都是属性名。每个条目包含一个数组，因为也可以在一个属性上定义几个装饰器。</li><li id="8b32" class="nb nc iq ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><strong class="ll ir">参数</strong>。这对应于decorators在构造函数参数级别设置的元数据。这是一个数组的数组，因为在一个参数上定义几个装饰符总是可能的。</li></ul><p id="329e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">注意，依赖注入使用设计:<code class="fe mx my mz na b">paramtypes</code>和参数来决定注入什么。</p><h1 id="0b3e" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">装饰者的类型</h1><p id="35f1" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Angular中有几种类型的装饰器。让我们一个一个来看。</p><ul class=""><li id="bb4a" class="nb nc iq ll b lm mg lp mh ls nd lw ne ma nf me ng nh ni nj bi translated">装饰类，例如<code class="fe mx my mz na b">@Component</code>和<code class="fe mx my mz na b">@NgModule</code></li><li id="90e4" class="nb nc iq ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated">类内属性的属性装饰器，例如<code class="fe mx my mz na b">@Input</code>和<code class="fe mx my mz na b">@Output</code></li><li id="4459" class="nb nc iq ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated">类内方法的方法装饰器，例如<code class="fe mx my mz na b">@HostListener</code></li><li id="666a" class="nb nc iq ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated">类构造函数内部参数的参数装饰器，例如<code class="fe mx my mz na b">@Inject</code></li></ul><p id="0b0a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">每个装饰器都有自己的用途，并且在整个框架中被过度使用。下面我们来详细看看。</p><h2 id="82ed" class="np ks iq bd kt nq nr dn kx ns nt dp lb ls nu nv ld lw nw nx lf ma ny nz lh oa bi translated">1.班级装饰者</h2><p id="d6f1" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">类装饰器，也称为顶级装饰器，用于通知Angular某个特定的类是一个组件或模块。顶级装饰者包括<code class="fe mx my mz na b">@Component</code>和<code class="fe mx my mz na b">@NgModule</code>。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="1e06" class="np ks iq na b gy of og l oh oi">import { NgModule, Component } from '@angular/core';</span><span id="3c37" class="np ks iq na b gy oj og l oh oi">@Component({<br/>selector: 'example-component',<br/>template: '&lt;div&gt;Woo a component!&lt;/div&gt;',<br/>})</span><span id="572a" class="np ks iq na b gy oj og l oh oi">export <em class="mo">class</em> ExampleComponent {</span><span id="62b6" class="np ks iq na b gy oj og l oh oi"><em class="mo">constructor</em>() {<br/>   console.log('Hi I am a component!');<br/> }<br/>}</span><span id="83de" class="np ks iq na b gy oj og l oh oi">@NgModule({<br/>imports: [],<br/>declarations: []<br/>})</span><span id="803a" class="np ks iq na b gy oj og l oh oi">export <em class="mo">class</em> ExampleModule {</span><span id="4bf8" class="np ks iq na b gy oj og l oh oi"><em class="mo">constructor</em>() {<br/>   console.log('Hi I am a module!');<br/> }<br/>}</span></pre><p id="5da6" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果您观察上面的代码，您会注意到两个类的结构是相同的。唯一的区别是装潢师。类本身不需要额外的代码来通知Angular它是一个组件或模块。装饰者为我们做工作，Angular处理剩下的。</p><h2 id="6358" class="np ks iq bd kt nq nr dn kx ns nt dp lb ls nu nv ld lw nw nx lf ma ny nz lh oa bi translated">2.财产装饰者</h2><p id="c4fc" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">当需要组件通信时，就需要使用属性装饰器。属性装饰器处理父组件和子组件之间的通信。有各种类型的属性装饰器。一些最常用的是:</p><ul class=""><li id="1714" class="nb nc iq ll b lm mg lp mh ls nd lw ne ma nf me ng nh ni nj bi translated"><a class="ae mf" href="https://angular.io/api/core/Input" rel="noopener ugc nofollow" target="_blank">@输入</a></li><li id="a99e" class="nb nc iq ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><a class="ae mf" href="https://angular.io/api/core/Output" rel="noopener ugc nofollow" target="_blank">@输出</a></li><li id="d9f9" class="nb nc iq ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated"><a class="ae mf" href="https://angular.io/api/core/ViewChild" rel="noopener ugc nofollow" target="_blank"> @ViewChild </a></li></ul><p id="ddaa" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">比方说，你有一辆车和一辆车。如果我们想从父类vehicle向子类car传递一些数据，我们只需使用带有子类属性的<code class="fe mx my mz na b">@input</code> decorator来告诉Angular这是一个子组件，它将接受来自父类的输入。然后Angular的编译器会自动从输入名创建一个输入属性绑定。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="c14f" class="np ks iq na b gy of og l oh oi">import { Component, Input } from '@angular/core';</span><span id="cb7d" class="np ks iq na b gy oj og l oh oi">@Component({<br/>  selector: 'example-component',<br/>  template: '&lt;div&gt;I am a component!&lt;/div&gt;'<br/>})</span><span id="b4b1" class="np ks iq na b gy oj og l oh oi">export <em class="mo">class</em> ExampleComponent {<br/>  @Input()<br/>  exampleProperty: <em class="mo">string</em>; <strong class="na ir">//====&gt; Property Binding</strong><br/>}</span></pre><p id="d390" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">接下来，通过组件属性传递输入绑定。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="ed74" class="np ks iq na b gy of og l oh oi">&lt;example-component</span><span id="02c1" class="np ks iq na b gy oj og l oh oi">[exampleProperty]="exampleData"&gt;</span><span id="286d" class="np ks iq na b gy oj og l oh oi">&lt;/example-component&gt;</span></pre><p id="063e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">类似地，对于<code class="fe mx my mz na b">@output</code> decorator，我们将添加decorator并用事件发射器初始化它，并使用emit方法发送事件。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="8a79" class="np ks iq na b gy of og l oh oi">import { Component, Input } from '@angular/core';</span><span id="e556" class="np ks iq na b gy oj og l oh oi">@Component({<br/>  selector: 'example-component',<br/>  template: '&lt;div&gt;I am a component!&lt;/div&gt;'<br/>})</span><span id="6649" class="np ks iq na b gy oj og l oh oi">export <em class="mo">class</em> ExampleComponent {<br/>  @output()<br/>  examplePropertyOutput = new EventEmitter();<strong class="na ir">//====&gt; Property      Binding</strong></span><span id="0ea4" class="np ks iq na b gy oj og l oh oi">sendOutput(){<br/>    this.examplePropertyOutput.emit('Hello from child');<br/>  }<br/>}</span></pre><p id="2f89" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">并简单地添加属性绑定。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="ed98" class="np ks iq na b gy of og l oh oi">&lt;example-component</span><span id="6bbb" class="np ks iq na b gy oj og l oh oi">(examplePropertyOutput)=”fetchOutput($event)”&gt;</span><span id="1f24" class="np ks iq na b gy oj og l oh oi">&lt;/example-component&gt;</span></pre><h2 id="effe" class="np ks iq bd kt nq nr dn kx ns nt dp lb ls nu nv ld lw nw nx lf ma ny nz lh oa bi translated">3.方法装饰者</h2><p id="d2ee" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">方法装饰器允许利用特殊的装饰器函数。例如<code class="fe mx my mz na b">@hostListener</code> decorator观察事件，并允许我们告诉Angular在事件被触发时调用decorator方法。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="53ea" class="np ks iq na b gy of og l oh oi">import { Component, HostListener } from '@angular/core';</span><span id="3914" class="np ks iq na b gy oj og l oh oi">@Component({<br/>  selector: 'example-component',<br/>  template: 'I am a component!'<br/>})</span><span id="3697" class="np ks iq na b gy oj og l oh oi">export <em class="mo">class</em> ExampleComponent {<br/>  @HostListener('click', ['$event']) // ==&gt; Method Decorator<br/>  onHostClick(<em class="mo">event</em>: <em class="mo">Event</em>) {<br/>     // call when click event triggered<br/>  }<br/>}</span></pre><h2 id="5d40" class="np ks iq bd kt nq nr dn kx ns nt dp lb ls nu nv ld lw nw nx lf ma ny nz lh oa bi translated">4.参数装饰器</h2><p id="dd37" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">当我们需要告诉Angular在构造函数中注入一个特定的提供者时，就要用到参数装饰器。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="0e89" class="np ks iq na b gy of og l oh oi">function logPosition(target: any, propertyKey: string,   parameterIndex: number) {<br/>  console.log(parameterIndex);<br/>}</span><span id="ed72" class="np ks iq na b gy oj og l oh oi">class Cow {<br/>  say(b: string, @logPosition c: boolean) { //==&gt; Paramter Decorator<br/>    console.log(b);<br/>  }<br/>}</span><span id="d17c" class="np ks iq na b gy oj og l oh oi">new Cow().say('hello', false); // outputs 1 (newline) hello</span></pre><p id="f590" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">另一个例子是@inject() decorator。这个装饰器允许我们装饰我们的类构造函数。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="441e" class="np ks iq na b gy of og l oh oi">import { Component, Inject } from '@angular/core'; <br/>import { MyService } from './my-service';</span><span id="fd03" class="np ks iq na b gy oj og l oh oi">@Component({   <br/>  selector: 'simple-component',   <br/>  template: 'Woo a component!' <br/>}) <br/>export class SimpleComponent {   <br/>  constructor(@Inject(MyService) myService) {               <br/>    console.log(myService); // MyService  <br/>  } <br/>}</span></pre><p id="a3c9" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">但是由于TypeScript，我们不必自己添加服务，因为TypeScript会为我们处理它。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="9167" class="np ks iq na b gy of og l oh oi">import { Component } from '@angular/core';<br/>import { MyService } from './my-service';</span><span id="387e" class="np ks iq na b gy oj og l oh oi">@Component({<br/>selector: 'simple-component',<br/>template: 'Woo a component!'<br/>})</span><span id="4abe" class="np ks iq na b gy oj og l oh oi">export <em class="mo">class</em> SimpleComponent {<br/>  <em class="mo">constructor</em>(<em class="mo">myService</em>: MyService) {<br/>    console.log(myService); // MyService<br/>  }<br/>}</span></pre></div><div class="ab cl ok ol hu om" role="separator"><span class="on bw bk oo op oq"/><span class="on bw bk oo op oq"/><span class="on bw bk oo op"/></div><div class="ij ik il im in"><h1 id="4bc2" class="kr ks iq bd kt ku or kw kx ky os la lb jw ot jx ld jz ou ka lf kc ov kd lh li bi translated">创建自定义装饰器</h1><p id="2f62" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">既然我们已经理解了什么是装饰者，那么我们就更容易理解定制装饰者了。让我们开始吧。</p><p id="9e16" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">装饰者有四种不同的函数签名:</p><ul class=""><li id="199b" class="nb nc iq ll b lm mg lp mh ls nd lw ne ma nf me ng nh ni nj bi translated">类别:<code class="fe mx my mz na b">declare type ClassDecorator = &lt;TFunction extends Function&gt;(target: TFunction) =&gt; TFunction | void;</code></li><li id="67ef" class="nb nc iq ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated">财产:<code class="fe mx my mz na b">declare type PropertyDecorator = (target: Object, propertyKey: string | symbol) =&gt; void;</code></li><li id="7f7e" class="nb nc iq ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated">方法:<code class="fe mx my mz na b">declare type MethodDecorator = &lt;T&gt;(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | void;</code></li><li id="4172" class="nb nc iq ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated">参数:<code class="fe mx my mz na b">declare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) =&gt; void;</code></li></ul><p id="f7fa" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">每当我们需要定义一个组件时，我们就使用<code class="fe mx my mz na b">@component</code>装饰器。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="3227" class="np ks iq na b gy of og l oh oi">@Component({<br/>   selector: 'my-app',<br/>   template: '&lt;span&gt;I am a component&lt;/span&gt;',<br/>})</span><span id="b9c5" class="np ks iq na b gy oj og l oh oi">export <em class="mo">class</em> AppComponent {<br/>   name = 'Angular';<br/>}</span></pre><p id="e799" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">decorator的语法计算出一个函数，该函数接受目标、名称和decorator描述符的参数。有两种装饰函数。</p><ul class=""><li id="715d" class="nb nc iq ll b lm mg lp mh ls nd lw ne ma nf me ng nh ni nj bi translated">无返回类型</li><li id="70c2" class="nb nc iq ll b lm nk lp nl ls nm lw nn ma no me ng nh ni nj bi translated">带有返回类型(装饰工厂函数)</li></ul><h2 id="f914" class="np ks iq bd kt nq nr dn kx ns nt dp lb ls nu nv ld lw nw nx lf ma ny nz lh oa bi translated">无返回类型</h2><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="78ce" class="np ks iq na b gy of og l oh oi">@isTestable <br/>class MyClass { }</span><span id="f9c7" class="np ks iq na b gy oj og l oh oi">function isTestable(target) {    <br/>   target.isTestable = true; <br/>}</span></pre><h2 id="2565" class="np ks iq bd kt nq nr dn kx ns nt dp lb ls nu nv ld lw nw nx lf ma ny nz lh oa bi translated">带有返回类型(装饰工厂函数)</h2><p id="0c57" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">比方说，我们有一台笔记本电脑，我们想用贴纸装饰它。首先，我们将创建一个带有函数的装饰文件。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="848b" class="np ks iq na b gy of og l oh oi">export <em class="mo">function</em> Sticker(<em class="mo">value</em>) {<br/>  return <em class="mo">function</em> decorator(<em class="mo">target</em>) {<br/>    <em class="mo">target</em>.prototype.sticker = <em class="mo">value</em>;<br/>    console.log('Our decorated class:', <em class="mo">target</em>);<br/>  }<br/>}</span></pre><p id="b033" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">接下来，创建一个laptop类，并通过导入使用其中的装饰器。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="0f39" class="np ks iq na b gy of og l oh oi">import { Sticker } from './sticker.decorator';</span><span id="c764" class="np ks iq na b gy oj og l oh oi">@Sticker('Google')  //=====&gt; added decorator with sticker 'Google'<br/>export <em class="mo">class</em> Laptop {<br/>   model: <em class="mo">string</em>  = "Notebook";<br/>}</span></pre><p id="beb5" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在，在app组件中导入laptop类，并简单地打印装饰器中定义的属性。“”无法访问该属性语法因为这个属性是由装饰器定义的，所以它可以通过数组语法访问。</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="2012" class="np ks iq na b gy of og l oh oi">export <em class="mo">class</em> AppComponent {<br/>   title = 'angular-decorators';<br/>   <em class="mo">constructor</em>(){<br/>    <em class="mo">let</em> laptop = new Laptop();<br/>    console.log('Sticker:',laptop['sticker'])<br/>  }<br/>}</span></pre><p id="cc89" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果您查看控制台，您会看到属性被添加到类中，并且正在打印google。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/3e4e4c6cbc8d60d84074bc1ef543b8cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*Ty83Zctx8dsO6W7wAi-SMA.png"/></div></figure><p id="5942" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">所有角度装饰器都使用工厂函数的第二种方法。大多数angular decorators的核心功能是将元数据附加到类上。然后，编译器使用这些元数据来构造各种工厂。</p><h1 id="75f1" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">打字稿如何传送装饰者</h1><p id="4990" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我们已经知道装饰器在JavaScript中还不可用。只有Angular有能力通过打字稿阅读它们。因此，为了检查TypeScript如何处理它，我们必须检查编译后的代码。</p><p id="f18e" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">普通类型脚本类:</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="5514" class="np ks iq na b gy of og l oh oi">class SimpleClass {   <br/>  constructor() {     <br/>    console.log('Hello!');   <br/>  } <br/>}</span></pre><p id="4c8c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">然后TypeScript会将它转换成JavaScript:</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="81ae" class="np ks iq na b gy of og l oh oi">var SimpleClass = (function() {   <br/>  function SimpleClass() {     <br/>    console.log('Yo!');   <br/>  }  <br/>  return SimpleClass; <br/>})();</span></pre><p id="983c" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">现在让我们来装饰我们的班级:</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="89f9" class="np ks iq na b gy of og l oh oi">@ConsoleGroup('SimpleClass') <br/>class SimpleClass {   <br/>  constructor() {     <br/>    console.log('Hello!');   <br/>  } <br/>}</span></pre><p id="919a" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">然后把它转换成JavaScript:</p><pre class="kg kh ki kj gt ob na oc od aw oe bi"><span id="d3d2" class="np ks iq na b gy of og l oh oi">var SimpleClass = (function() {   <br/>  function SimpleClass() {     <br/>    console.log('Yo!');   <br/>  }   <br/>  return SimpleClass; <br/>})(); <br/>SimpleClass = __decorate([ConsoleGroup('SimpleClass')],SimpleClass);</span></pre><p id="2f49" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated"><code class="fe mx my mz na b"><a class="ae mf" href="https://books.google.com.pk/books?id=yc7cDgAAQBAJ&amp;pg=PA234&amp;lpg=PA234&amp;dq=__decorate&amp;source=bl&amp;ots=XvR01YTm7K&amp;sig=ACfU3U2Jd6OKg21gU8eACAukGmiWO0D3gw&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwjPkYyB_sfqAhV95eAKHSaQA7YQ6AEwBnoECAkQAQ#v=onepage&amp;q=__decorate&amp;f=false" rel="noopener ugc nofollow" target="_blank">__decorate</a></code>是装饰者的助手函数，它将装饰者应用到我们的类中。</p><h1 id="7e6c" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">结论🎉</h1><p id="20c9" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">简而言之，Angular中的Decorators为我们提供了进一步扩展关注点分离设计原则的能力，并使其更加简洁高效。我希望这篇文章对你有帮助，如果你有，请在 <a class="ae mf" href="https://medium.com/@mrahmedkhan019" rel="noopener"> <strong class="ll ir"> Medium </strong> </a> <strong class="ll ir">和</strong><a class="ae mf" href="https://twitter.com/50shadeofkhan" rel="noopener ugc nofollow" target="_blank"><strong class="ll ir">Twitter</strong></a><strong class="ll ir">上关注我，获取更多关于软件开发文章的通知</strong>。终于！感谢阅读，快乐学习！</p><div class="ox oy gp gr oz pa"><a href="https://medium.com/javascript-in-plain-english/containerize-your-angular-apps-with-dockers-40cb231bb990" rel="noopener follow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd ir gy z fp pf fr fs pg fu fw ip bi translated">用Dockers容器化你的Angular应用</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">了解如何为Angular ⛴构建轻量级和可移植的软件容器</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">medium.com</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po kp pa"/></div></div></a></div><div class="ox oy gp gr oz pa"><a href="https://medium.com/javascript-in-plain-english/angular-regime-series-a-guide-to-change-detection-strategy-2a8a4da46c5c" rel="noopener follow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd ir gy z fp pf fr fs pg fu fw ip bi translated">角度范围系列:变化检测策略指南</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">开发可持续变化的应用程序</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">medium.com</p></div></div><div class="pj l"><div class="pp l pl pm pn pj po kp pa"/></div></div></a></div><div class="ox oy gp gr oz pa"><a href="https://medium.com/javascript-in-plain-english/angular-regime-series-tree-shaking-technique-3dc07f5e85a1" rel="noopener follow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd ir gy z fp pf fr fs pg fu fw ip bi translated">树木倾斜地摇晃着</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">用温柔的方式，你可以撼动世界！</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">medium.com</p></div></div><div class="pj l"><div class="pq l pl pm pn pj po kp pa"/></div></div></a></div><h2 id="f3f2" class="np ks iq bd kt nq nr dn kx ns nt dp lb ls nu nv ld lw nw nx lf ma ny nz lh oa bi translated">简单英语的JavaScript</h2><p id="e835" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae mf" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ll ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="ll ir">！</strong></p></div></div>    
</body>
</html>