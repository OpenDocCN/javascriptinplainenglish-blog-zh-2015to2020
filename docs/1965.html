<html>
<head>
<title>Object and Array methods to learn before JavaScript frameworks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">对象和数组方法，然后再学习JavaScript框架</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-and-array-methods-to-learn-before-javascript-frameworks-59728dcea306?source=collection_archive---------2-----------------------#2020-05-08">https://javascript.plainenglish.io/object-and-array-methods-to-learn-before-javascript-frameworks-59728dcea306?source=collection_archive---------2-----------------------#2020-05-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/1f771c0c77117cf099b772feec88ffe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xBE4yUAAaS1uer8vdWebxQ.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Source: <a class="ae ja" href="https://miro.medium.com/max/4096/1*JinuD4VWgK0Iw0hXcALATA.jpeg" rel="noopener">https://miro.medium.com/max/4096/1*JinuD4VWgK0Iw0hXcALATA.jpeg</a></figcaption></figure><div class=""/><p id="02d1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本系列中，我们将涵盖以下主题:</p><ol class=""><li id="f49c" class="ky kz jd kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated"><a class="ae ja" href="https://medium.com/javascript-in-plain-english/things-to-learn-before-learning-a-javascript-framework-b7baec310247" rel="noopener">ES6的重要特性</a></li><li id="2b68" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated">对象和数组方法(本文)</li><li id="48c3" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><a class="ae ja" href="https://medium.com/javascript-in-plain-english/asynchronous-javascript-to-learn-before-javascript-frameworks-9b63972290c2" rel="noopener">异步JavaScript和获取API </a></li><li id="444f" class="ky kz jd kc b kd lh kh li kl lj kp lk kt ll kx ld le lf lg bi translated"><a class="ae ja" href="https://medium.com/javascript-in-plain-english/how-to-use-npm-and-import-export-modules-in-javascript-31a7f66a2064" rel="noopener">JavaScript中的NPM和导入/导出模块</a></li></ol><p id="ecbc" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本系列的最后一篇文章<strong class="kc je">“学习JavaScript框架之前要学的东西”</strong>、<strong class="kc je">、</strong>中，我们了解了在任何JavaScript框架中经常使用的<strong class="kc je">重要的ES6特性</strong>。现在，在本文中，我们将介绍该系列的第二部分，即<strong class="kc je">对象和数组方法</strong>。</p><p id="2b3e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们将讨论JavaScript中可以应用于对象和数组的不同类型的方法。</p><p id="3fa9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">先说对象和对象方法:</p><h1 id="a31c" class="lm ln jd bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">目标</h1><p id="9b47" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">一个<code class="fe mp mq mr ms b">Object</code>可以被定义为以<strong class="kc je">“key:value”</strong>对的形式存储的数据的无序集合。我们可以通过以下方式访问<code class="fe mp mq mr ms b">Object</code>的属性和方法:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="34db" class="lm ln jd bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">对象方法</h1><p id="7ba0" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated"><code class="fe mp mq mr ms b">Object Methods</code>是可以在JavaScript对象上执行的操作。我们可以使用下面的语法访问一个<code class="fe mp mq mr ms b">Object's</code>静态方法:</p><pre class="mt mu mv mw gt mz ms na nb aw nc bi"><span id="95f9" class="nd ln jd ms b gy ne nf l ng nh">Object.methodName(someObject);</span></pre><p id="5997" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript中有许多不同类型的对象方法，在这篇文章中，我们将讨论一些最有用的对象方法，它们在语言中可以使我们的生活变得轻松。</p><p id="435a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">先说<code class="fe mp mq mr ms b">Object.assign()</code>:</p><h2 id="81f1" class="nd ln jd bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">对象.分配()</h2><p id="ecc5" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">此方法可用于将一个对象复制到另一个对象。</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8142" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它还可以用来合并多个对象，形成一个新的<code class="fe mp mq mr ms b">object</code>。</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="2e84" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上一篇文章中，我们讨论了也可以用来合并对象的<code class="fe mp mq mr ms b">spread operator</code>。让我们看看这是如何实现的:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8ed9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们使用这两种方法得到了相同的结果，所以我们可以使用任何一种方法来合并对象。但是由于<code class="fe mp mq mr ms b">Object.assign()</code>方法会改变第一个<code class="fe mp mq mr ms b">object</code>方法，因此，我更喜欢使用第二种方法，因为它不会改变任何传递的对象。</p><h2 id="82cd" class="nd ln jd bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">Object.create()</h2><p id="6dd7" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated"><code class="fe mp mq mr ms b">Object.create()</code>方法创建一个新对象，使用一个现有对象作为新创建对象的原型。</p><p id="f7d2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们考虑一下<code class="fe mp mq mr ms b">person</code>对象来理解这一点:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="855b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，对象<code class="fe mp mq mr ms b">newPerson</code>只有一个属性，即<code class="fe mp mq mr ms b">firstName</code>，但是因为它是使用<code class="fe mp mq mr ms b">Object.create()</code>方法声明的，所以它可以通过原型访问所有其他属性和方法。</p><h2 id="d573" class="nd ln jd bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">Object.entries()、Object.keys()和Object.values()</h2><p id="989e" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">这三种方法彼此非常相似，所以让我们一起讨论它们。</p><p id="c0f0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mp mq mr ms b">Object.entries()</code>方法创建一个传递给这个方法的<code class="fe mp mq mr ms b">Object</code>的键/值对的数组。</p><p id="36e4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mp mq mr ms b">Object.keys()</code>方法用于创建一个<code class="fe mp mq mr ms b">Object</code>的所有<strong class="kc je">键</strong>的数组，而<code class="fe mp mq mr ms b">Object.values()</code>方法创建一个对象的所有<strong class="kc je">值</strong>的数组。</p><p id="a555" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看他们对<code class="fe mp mq mr ms b">person</code>对象的处理:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="dac8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">注:</strong></p><ol class=""><li id="89de" class="ky kz jd kc b kd ke kh ki kl la kp lb kt lc kx ld le lf lg bi translated">"这些方法返回对象实例的所有属性，而不是可以从其原型继承的任何属性."让我们理解，通过在<code class="fe mp mq mr ms b">newPerson</code>对象上应用这个方法:</li></ol><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="a1f6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们看到它只打印对象实例的属性，而不打印从原型继承的其他属性。</p><p id="829d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.这些方法<strong class="kc je"> </strong>也可以用来迭代对象的键和值。</p><p id="9ee3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">到目前为止，我们讨论的所有方法都是静态的方法。还有另一种类型的<code class="fe mp mq mr ms b">Object</code>方法，称为<code class="fe mp mq mr ms b">Object's</code> <em class="nt">实例</em>方法。让我们也讨论一下这种类型的一种方法:</p><h2 id="3337" class="nd ln jd bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">hasOwnProperty()</h2><p id="b9c7" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">该方法返回一个<code class="fe mp mq mr ms b">boolean</code>，指示<code class="fe mp mq mr ms b">object</code>是否具有指定的属性。</p><p id="b024" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们考虑<code class="fe mp mq mr ms b">person</code>对象来理解这一点:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="dcdb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">注意:</strong>该方法只能用于检查<code class="fe mp mq mr ms b">Object</code>拥有的属性，而不是它继承的属性。</p></div><div class="ab cl nu nv hr nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ig ih ii ij ik"><h1 id="83b3" class="lm ln jd bd lo lp ob lr ls lt oc lv lw lx od lz ma mb oe md me mf of mh mi mj bi translated">排列</h1><p id="2ebc" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">一个<code class="fe mp mq mr ms b">Array</code>用于在单个<code class="fe mp mq mr ms b">variable</code>中存储元素列表。让我们讨论一下JavaScript中可以应用于数组的基本操作:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><h1 id="c80b" class="lm ln jd bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">数组方法</h1><p id="9a19" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated"><code class="fe mp mq mr ms b">Array Methods</code>是可以应用于数组的动作。JavaScript为我们提供了很多方法，让我们在处理数组时更加轻松。在这里，我们将尝试把重点放在一些最有用的数组方法上。</p><p id="66bc" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们从<code class="fe mp mq mr ms b">isArray</code>方法开始:</p><h2 id="457f" class="nd ln jd bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">Array.isArray()</h2><p id="a28d" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">这个方法是一个<code class="fe mp mq mr ms b">static</code>数组方法。它用于确定传递的值是否是一个<code class="fe mp mq mr ms b">Array</code>。让我们看几个例子来理解这一点:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="4fcb" class="nd ln jd bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">地图()</h2><p id="fbdd" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">此方法通过对数组的每个元素执行提供的函数来返回一个新数组。让我们先来看看这个方法的语法:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c4b0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们注意到我们必须向这个方法传递一个函数，这个函数包含为数组的每个元素执行的代码。这里，我们将使用上一篇文章中提到的<code class="fe mp mq mr ms b">arrow functions</code>。</p><p id="392a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们来理解这种方法是如何工作的:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7841" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们观察到<code class="fe mp mq mr ms b">numbers</code>数组的每个元素的值都增加了<code class="fe mp mq mr ms b">1</code>，结果存储在新的数组<code class="fe mp mq mr ms b">incNumbers</code>中。</p><h2 id="a4b1" class="nd ln jd bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">过滤器()</h2><p id="1ab7" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">此方法返回一个新数组，该数组只包含那些通过函数中指定条件的元素。这个方法的语法类似于<code class="fe mp mq mr ms b">map</code>方法。</p><p id="b82a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们必须过滤大于3的数字:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7025" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们看到名为<strong class="kc je"> filtered </strong>的数组包含所有大于3的<strong class="kc je">数字</strong>的元素。</p><h2 id="43a1" class="nd ln jd bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">减少()</h2><p id="b012" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">顾名思义，<code class="fe mp mq mr ms b">reduce</code>方法用于将数组缩减为单个值。它为数组的每个元素执行一个函数，并将返回值存储在<code class="fe mp mq mr ms b">accumulator</code>中。<br/>该函数有两个参数，第一个称为<code class="fe mp mq mr ms b">reducer</code>函数，第二个是<code class="fe mp mq mr ms b">accumulator</code>的<code class="fe mp mq mr ms b">initialValue</code>。</p><p id="7ab0" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们通过一个简单的例子来理解这一点:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="201c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的例子中，<strong class="kc je">当</strong> <strong class="kc je">我们向</strong> <code class="fe mp mq mr ms b"><strong class="kc je">reduce</strong></code> <strong class="kc je">方法传递一个参数时，它将</strong> <code class="fe mp mq mr ms b"><strong class="kc je">array</strong></code> <strong class="kc je">的第一个元素作为</strong> <code class="fe mp mq mr ms b"><strong class="kc je">initialValue</strong></code> <strong class="kc je">并从第二个元素开始循环，但是当我们传递</strong> <code class="fe mp mq mr ms b"><strong class="kc je">initialValue</strong></code> <strong class="kc je">时，循环从第一个元素开始。</strong></p><p id="793c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们来看一个在学习<strong class="kc je"> React和Redux </strong>时经常遇到的<code class="fe mp mq mr ms b">reduce</code>方法的更现实的例子:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="1f5b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">注意:</strong><code class="fe mp mq mr ms b">reduce()</code>方法可以用来实现<code class="fe mp mq mr ms b">map()</code>和<code class="fe mp mq mr ms b">filter()</code>方法。</p><h2 id="12d6" class="nd ln jd bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">包括()</h2><p id="c316" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">该方法用于确定<code class="fe mp mq mr ms b">array</code>是否包含指定的元素。它根据结果返回一个<code class="fe mp mq mr ms b">boolean</code>。</p><p id="f1bd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看这在<code class="fe mp mq mr ms b">numbers</code>阵列上是如何工作的:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="ed9e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">注意:</strong><code class="fe mp mq mr ms b">includes()</code>方法是<strong class="kc je">区分大小写</strong>。</p><h2 id="00df" class="nd ln jd bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">加入()</h2><p id="8131" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated"><code class="fe mp mq mr ms b">join()</code>方法通过连接数组的所有元素返回一个新的<code class="fe mp mq mr ms b">string</code>。<code class="fe mp mq mr ms b">string</code>中的数组元素由逗号或指定的分隔符字符串分隔。</p><p id="ea7e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们理解这意味着什么:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="9749" class="nd ln jd bd lo ni nj dn ls nk nl dp lw kl nm nn ma kp no np me kt nq nr mi ns bi translated">排序()</h2><p id="66ff" class="pw-post-body-paragraph ka kb jd kc b kd mk kf kg kh ml kj kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">顾名思义，<code class="fe mp mq mr ms b">sort</code>方法用于对数组的元素进行排序。它通过将元素转换成字符串，然后比较它们的值来对元素进行排序。默认排序顺序为<code class="fe mp mq mr ms b">ascending</code>。</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="9677" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们注意到数组值是通过转换成<strong class="kc je">字符串</strong>来进行比较的。另外需要注意的是，原来的数组都是<strong class="kc je"> <em class="nt">变异了</em> </strong>(变了)。</p><p id="6c84" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们也可以通过一个<strong class="kc je"> <em class="nt">比较函数</em> </strong>来排序方法:</p><figure class="mt mu mv mw gt ip"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="d597" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看一个非常简单的例子来理解这些方法:</p><figure class="mt mu mv mw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi og"><img src="../Images/56a05671b1e71363d2712240c94210ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nWy9JgleGj3bw4wYyybS_Q.png"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Credits: <a class="ae ja" href="https://medium.com/@bobbyvidal" rel="noopener">Robert Vidal</a></figcaption></figure></div><div class="ab cl nu nv hr nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ig ih ii ij ik"><p id="bb2a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就把我们带到了本文的结尾，在这里我们学习了不同的对象和数组方法。如果你想了解更多关于JavaScript对象的知识，你可以阅读JavaScript<strong class="kc je"/>中的<strong class="kc je"/><a class="ae ja" href="https://www.digitalocean.com/community/tutorials/how-to-use-object-methods-in-javascript" rel="noopener ugc nofollow" target="_blank"><strong class="kc je">了解对象，如果你想熟悉数组方法，你可以看看JavaScript的<strong class="kc je"/><a class="ae ja" href="https://levelup.gitconnected.com/the-array-iterators-cheatsheet-javascript-9d0cfa03f4" rel="noopener ugc nofollow" target="_blank"><strong class="kc je">数组迭代器Cheatsheet。</strong></a><strong class="kc je"/></strong></a></p><p id="1690" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将在接下来的文章中讨论其余的主题。最后，我将留给你们一个使用这些方法的简单的<code class="fe mp mq mr ms b">React Component</code>:</p><figure class="mt mu mv mw gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi oh"><img src="../Images/ed9c921f06541fe71831bc8d7ede497a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4JN0Zra1DICVpOHiKWm-SQ.png"/></div></div></figure><p id="7691" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，请查看该系列的其他部分(如果您还没有查看):</p><div class="im in gp gr io oi"><a href="https://medium.com/javascript-in-plain-english/things-to-learn-before-learning-a-javascript-framework-b7baec310247" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd je gy z fp on fr fs oo fu fw jc bi translated">学习JavaScript框架之前需要了解的事情(第1部分)</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">因此，在这一系列的文章中，我将尝试解释一些我认为真正…</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow iu oi"/></div></div></a></div><div class="im in gp gr io oi"><a href="https://medium.com/javascript-in-plain-english/asynchronous-javascript-to-learn-before-javascript-frameworks-9b63972290c2" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd je gy z fp on fr fs oo fu fw jc bi translated">在JavaScript框架之前学习异步JavaScript(第3部分)</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">对异步javascript的理解</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow iu oi"/></div></div></a></div><div class="im in gp gr io oi"><a href="https://medium.com/javascript-in-plain-english/how-to-use-npm-and-import-export-modules-in-javascript-31a7f66a2064" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd je gy z fp on fr fs oo fu fw jc bi translated">如何在JavaScript中使用NPM(和导入/导出模块)(第4部分)</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">学习JavaScript框架之前要学习的NPM命令和导入/导出模块</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow iu oi"/></div></div></a></div><p id="0b1c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想和我联系，请点击下面的链接:</p><p id="6c93" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ja" href="https://www.linkedin.com/in/rajat-verma-39458317b/" rel="noopener ugc nofollow" target="_blank">LinkedIn</a>|<a class="ae ja" href="https://github.com/rajat2502" rel="noopener ugc nofollow" target="_blank">GitHub</a>|<a class="ae ja" href="https://twitter.com/rajatverma2502" rel="noopener ugc nofollow" target="_blank">Twitter</a></p></div></div>    
</body>
</html>