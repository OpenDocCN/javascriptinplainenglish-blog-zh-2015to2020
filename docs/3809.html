<html>
<head>
<title>Avoid Memory Leaks in Angular by Using the Async Pipe</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过使用异步管道避免Angular中的内存泄漏</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/avoid-memory-leaks-in-angular-by-using-the-async-pipe-95455470701e?source=collection_archive---------12-----------------------#2020-10-26">https://javascript.plainenglish.io/avoid-memory-leaks-in-angular-by-using-the-async-pipe-95455470701e?source=collection_archive---------12-----------------------#2020-10-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="57b6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用异步管道避免Angular中可观察到的内存泄漏</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/45fbfec134230e14db35902944374efa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gnAyxWG3R89WrH2nCDPq2w.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://www.pexels.com/photo/photo-of-gray-faucet-2339722/" rel="noopener ugc nofollow" target="_blank">Photo by Luis Quintero from Pexels</a></figcaption></figure><h1 id="50df" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="1843" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在本指南中，我将向您展示如何利用异步管道来避免由Angular应用程序中未订阅的可观测量导致的内存泄漏。</p><p id="21d1" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">async operator在订阅Observables时有几个优点，包括。</p><ul class=""><li id="f2d8" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">这很容易实现</li><li id="ff29" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">干净和</li><li id="5d2f" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">自动取消订阅可观测量</li></ul><p id="ce5b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">Rxjs可观测量很受欢迎，广泛用于角度应用。因此，知道如何避免由可观测量引起的内存泄漏是至关重要的。</p><p id="37e5" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">未订阅的可观测量导致的内存泄漏会降低应用程序的性能，甚至会导致浏览器崩溃。</p><h1 id="116f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">为什么取消订阅一个可观察的</h1><p id="abb6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">在这个阶段，你可能想知道:我真的需要退订一个可观察的吗？简单的回答是:是啊！</p><ul class=""><li id="a9b0" class="mp mq iq lq b lr mk lu ml lx mr mb ms mf mt mj mu mv mw mx bi translated">如果您有一个无限的可观察对象，那么该可观察对象的订阅者将持续监听数据更改，如果不取消订阅，这将导致内存泄漏。</li><li id="7577" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">当组件被垃圾收集器销毁时，并不是所有的订阅者都会在此过程中被销毁。这可能导致内存泄漏。</li><li id="b52a" class="mp mq iq lq b lr my lu mz lx na mb nb mf nc mj mu mv mw mx bi translated">最后，在订阅完成之前，组件可能会从DOM中删除，从而导致内存泄漏。</li></ul><h1 id="575b" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">异步管道的工作原理</h1><p id="bd63" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Angular框架提供了异步管道，用于从异步原语(如Observables或Promises)中解包数据。顾名思义，异步管道的使用方式与其他角形管道非常相似。</p><p id="42f9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">当在一些可观察类型上使用时，异步管道将订阅可观察类型并返回它的最新值。每当数据发生变化时，将检查组件的变化。</p><p id="50ef" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">异步管道最好的一点是，每当组件被销毁时，它会自动取消对可观察对象的订阅。你不必做任何额外的事情。</p><h1 id="5a88" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">异步管道入门</h1><p id="ff06" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">假设您有一个简单的服务，它通过HTTP从服务器获取一些更改日志数据。此类功能的服务类似于下面的服务:</p><p id="a67b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"><em class="nd">change-log . service . ts</em>T5】</strong></p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="8abe" class="nj kx iq nf b gy nk nl l nm nn">@Injectable({<br/>    providedIn: 'root'<br/>})</span><span id="9203" class="nj kx iq nf b gy no nl l nm nn">export class GetLogsService {</span><span id="ac15" class="nj kx iq nf b gy no nl l nm nn">    constructor(private httpClient: HttpClient ) { }<br/>    private urlEndPoint: string = 'http://localhost:3000/api/change-log';</span><span id="a637" class="nj kx iq nf b gy no nl l nm nn">    public getLogs(): Observable&lt;any&gt;{<br/>         return this.httpClient.get(this.urlEndPoint);<br/>    }</span><span id="4e40" class="nj kx iq nf b gy no nl l nm nn">}</span></pre><p id="7ea7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了让HTTP调用返回的数据进入组件，我们可以简单地创建一个Observable类型的属性。然后，在组件初始化时，使用服务方法调用分配Observable属性，如下所示:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="ac83" class="nj kx iq nf b gy nk nl l nm nn">import { Component, <strong class="nf ir">OnInit</strong> } from '@angular/core';<br/><strong class="nf ir">import { Observable } from 'rxjs';</strong><br/><strong class="nf ir">import { GetLogsService } from './get-logs.service';</strong></span><span id="7405" class="nj kx iq nf b gy no nl l nm nn">@Component({<br/>    selector: 'app-root',<br/>    templateUrl: './app.component.html',<br/>    styleUrls: ['./app.component.scss']<br/>})</span><span id="0621" class="nj kx iq nf b gy no nl l nm nn">export class AppComponent <strong class="nf ir">implements OnInit </strong>{<br/>    title = 'rxjs-observables';</span><span id="b739" class="nj kx iq nf b gy no nl l nm nn">   <strong class="nf ir"> constructor(private getLogsService: GetLogsService){}</strong></span><span id="de93" class="nj kx iq nf b gy no nl l nm nn">    <strong class="nf ir">public logs$: Observable&lt;any&gt;;<br/>    <br/>    ngOnInit(): void {<br/>        this.logs$ = this.getLogsService.getLogs();<br/>    }</strong><br/>}</span></pre><h2 id="05ee" class="nj kx iq bd ky np nq dn lc nr ns dp lg lx nt nu li mb nv nw lk mf nx ny lm nz bi translated">如何使用异步管道</h2><p id="0739" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">和所有其他角度管道一样，异步管道主要用在HTML模板中。</p><p id="cdf0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">为了显示所有数据，我们可以将它与ngFor循环一起使用，如下所示。其中，用户、日期和描述是返回数据的属性。</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="4000" class="nj kx iq nf b gy nk nl l nm nn">&lt;div *ngFor="let log of logs$ | async "&gt;<br/>    {{ log.user }}<br/>    {{ log.date }}<br/>    {{ log.description }}<br/>&lt;/div&gt;</span></pre><p id="67b8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">或者，我们可以结合json管道使用异步管道将所有原始数据输出到模板，如下所示:</p><pre class="kg kh ki kj gt ne nf ng nh aw ni bi"><span id="2cff" class="nj kx iq nf b gy nk nl l nm nn">&lt;div&gt;<br/>    {{ logs$ | async | json }<br/>&lt;/div&gt;</span></pre><h1 id="c4b3" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">最后的想法</h1><p id="f384" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">异步管道是订阅和获取可观察数据的一个很好的选择，而不用担心内存泄漏。</p><p id="c03b" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">内存泄漏会导致应用程序运行缓慢、无响应，甚至浏览器崩溃。</p><p id="5f5d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">能够优雅地取消订阅Observables对于拥有高性能和高质量的应用程序非常重要。</p></div></div>    
</body>
</html>