<html>
<head>
<title>Authentication Using Passport.js in a Node.js Backend API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js后端API中使用Passport.js进行身份验证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/authentication-using-passport-js-in-a-node-js-backend-api-51e9946549cb?source=collection_archive---------0-----------------------#2020-05-10">https://javascript.plainenglish.io/authentication-using-passport-js-in-a-node-js-backend-api-51e9946549cb?source=collection_archive---------0-----------------------#2020-05-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0d4463e72842b0bd17f76b8ff186f865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-oiJ7DHX86lrL3tD"/></div></div></figure><p id="b888" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于我们的web应用程序、API和移动应用程序来说，安全性是软件开发的一个重要方面。我们要么从头开始实现我们的身份验证，要么使用现有的库。大多数框架都有内置的安全模块。身份验证需要将用户凭证与文件或数据库进行匹配，这些文件或数据库可能位于本地文件系统或身份验证服务器中，如果它们存在，则允许它们访问受保护的资源。</p><h2 id="b5e8" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">护照</h2><p id="bd3e" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">Passport是Node.js应用程序最流行的用户验证外部库。它目前在GitHub上有17.4k颗星，并为超过480种策略提供中间件，如简单的用户名和密码，社交媒体登录，如facebook，twitter，google等等。</p><div class="lu lv gp gr lw lx"><a href="https://github.com/jaredhanson/passport" rel="noopener  ugc nofollow" target="_blank"><div class="ly ab fo"><div class="lz ab ma cl cj mb"><h2 class="bd ir gy z fp mc fr fs md fu fw ip bi translated">Jared Hanson/护照</h2><div class="me l"><h3 class="bd b gy z fp mc fr fs md fu fw dk translated">Passport是Node.js的Express兼容认证中间件。Passport的唯一目的是认证…</h3></div><div class="mf l"><p class="bd b dl z fp mc fr fs md fu fw dk translated">github.com</p></div></div><div class="mg l"><div class="mh l mi mj mk mg ml jw lx"/></div></div></a></div><p id="fdbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在使用Express framework开发的最小后端API中，我使用Passport通过不同策略的组合来保护后端。然而，为了实现无状态认证，使用了JWT技术。JSON Web令牌(JWT)为我们提供了无状态形式的身份验证，因为服务器不需要维护状态，令牌用于确定用户身份验证是否仍然有效。发送到客户端(用户)的令牌使用数字签名(如RSA)和给定的到期时间进行签名。客户端发送令牌，服务器调用中间件(在本例中为Passport)来验证令牌是否有效且未过期。</p><p id="e581" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据<a class="ae mm" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank">官方文档</a>，JWT也可用于信息交换而不仅仅是认证，它由三部分组成:报头、有效载荷和签名，这转化为这种形式的令牌</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="c3e9" class="kw kx iq ms b gy mw mx l my mz">xxxxx.yyyyy.zzzzz</span></pre><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi na"><img src="../Images/c14f53831692a92417ca1f6cb3d66e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*q3FLL9-_0t6VIxor.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Source:<a class="ae mm" href="https://jwt.io/introduction/" rel="noopener ugc nofollow" target="_blank">https://jwt.io/introduction/</a></figcaption></figure><h2 id="f9b5" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">配置</h2><p id="49a6" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">Passport的配置是在我们的应用程序的引导文件中完成的，在这里是Express服务器上的<strong class="ka ir"> src/index.js </strong>文件。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="1808" class="kw kx iq ms b gy mw mx l my mz">const passport = require(‘passport’); //require passport</span><span id="48cd" class="kw kx iq ms b gy nf mx l my mz">app.use(passport.initialize());//initializes passport configuration     </span><span id="4962" class="kw kx iq ms b gy nf mx l my mz">//in package.json</span><span id="b7a0" class="kw kx iq ms b gy nf mx l my mz">...<br/>"passport": "^0.4.0", <br/>"passport-facebook-token": "^3.3.0",  <br/>"passport-jwt": "^4.0.0",  <br/>"passport-local": "^1.0.0",<br/>...</span></pre><h2 id="015d" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated"><strong class="ak">中间件</strong></h2><p id="6082" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">Passport中间件是拦截器，它询问我们的请求和响应对象，验证用户，并将处理传递给下一个中间件。我们使用三种身份验证策略:</p><ol class=""><li id="845b" class="ng nh iq ka b kb kc kf kg kj ni kn nj kr nk kv nl nm nn no bi translated">本地策略(相当于用户名和密码)—用于用户登录和注销。</li><li id="653f" class="ng nh iq ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated">JWT策略—用于模拟用户会话。验证用户是否已经登录。</li><li id="c658" class="ng nh iq ka b kb np kf nq kj nr kn ns kr nt kv nl nm nn no bi translated">脸书令牌策略—授权给<a class="ae mm" href="http://oauth.net/" rel="noopener ugc nofollow" target="_blank"> OAuth </a>的社交登录</li></ol><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="7ce4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的认证文件中，我们可以看到使用的各种认证策略=&gt; create(创建用户)、login(使用用户名和密码登录)、JWT(验证用户是否已经登录)和脸书社交登录。在文件的最后，我们为Passport提供了一些函数，用于将经过身份验证的用户序列化和反序列化到Passport的持久会话中，这是为了抽象出我们将用户存储在数据库或文件中的方式。护照没有限制。JWT秘密和脸书秘密被安全地保存在一个.<strong class="ka ir"> env </strong>文件和<strong class="ka ir">中。dotenv </strong>用于访问它们。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="349b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">保护端点</strong></p><p id="4669" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在需要的是将Passport中间件应用于我们的端点路由。我们还可以看到应用的验证，但这些不是针对Passport的。他们只是确保发送的数据遵循特定的模式，例如在将身份验证处理传递给Passport之前验证电子邮件是否已收到。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="49ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了创建客户或用户(v1/api/customers)，在create方法中创建令牌并发送给客户端。</p><figure class="mn mo mp mq gt jr"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="f3ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Passport身份验证方法采用第二个参数<em class="nw"> options </em>，其中我们指出我们要求我们的服务器是无状态的，这是JWT身份验证所需要的。这可以在getCustomer配置文件端点中看到。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="6d02" class="kw kx iq ms b gy mw mx l my mz">passport.authenticate('jwt', { session: false }, callback);</span></pre><p id="9b3c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本教程的Node.js Express后端可以在github上找到<a class="ae mm" href="https://github.com/tksilicon/backend_challenge_template_master" rel="noopener ugc nofollow" target="_blank">。查看所有的策略是如何使用的。</a></p><h2 id="4584" class="kw kx iq bd ky kz la dn lb lc ld dp le kj lf lg lh kn li lj lk kr ll lm ln lo bi translated">结论</h2><p id="d20d" class="pw-post-body-paragraph jy jz iq ka b kb lp kd ke kf lq kh ki kj lr kl km kn ls kp kq kr lt kt ku kv ij bi translated">有了Passport，我们可以在开始更复杂、更严格的身份验证之前，最大限度地保护我们的web应用程序。在大规模项目中，我们通常会求助于构建自己的认证库来避免依赖性。</p></div></div>    
</body>
</html>