<html>
<head>
<title>How To Boost JavaScript Runtime Performance</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何提升JavaScript运行时性能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/improving-javascript-runtime-and-load-performance-5062dded907a?source=collection_archive---------4-----------------------#2020-10-06">https://javascript.plainenglish.io/improving-javascript-runtime-and-load-performance-5062dded907a?source=collection_archive---------4-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f27b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分:减少应用程序启动时间的高级策略</h2></div><p id="918b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有很多建议，但当涉及到高级性能策略时，建议似乎越来越少。我读了那些文章，但不是太模糊，就是太宽泛，或者只是我已经做过的基本东西。关于性能的更高级的文章在哪里，最重要的是，为什么我们不将技术结合起来，谈论堆叠实现？</p><p id="cc46" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我在现实世界中的经验，我使用的工具或策略。喜欢网页表现，有点痴迷。这些想法可能有点古怪或抽象，可能有更好的方法来处理perf。</p><p id="288a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说…</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="lg lh l"/></div></figure><h1 id="8d2e" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">基础知识</h1><p id="ce43" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">让我们把这些说出来，大部分是常识和典型的perf建议。</p><ul class=""><li id="cb21" class="mf mg iq kh b ki kj kl km ko mh ks mi kw mj la mk ml mm mn bi translated">使用Brotli</li><li id="ffa1" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">使用http2</li><li id="0a29" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">使用webp和可以动态调整大小并提供最有效格式的CDN</li><li id="1553" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">对您的应用进行代码拆分</li><li id="3d1b" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">利用边缘网络</li><li id="9745" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">不要预加载视频，不要自动播放视频，直到交叉点观察器被激活。</li><li id="f0c1" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">使用CSS和JS优化</li><li id="6a65" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">调整webpack分块以减少重新部署时的缓存未命中</li><li id="1a7d" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">修剪标签管理器，将真正静态的代码移入你自己的</li></ul><h2 id="b117" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated"><strong class="ak">用交叉点观察器惰性加载图像</strong></h2><p id="35ba" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">响应图像、延迟加载和交叉点观察器。</p><p id="e7fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该组件可以加快加载速度。尤其是当一个页面包含多个图像时，即使是很小的图像。图像请求会阻塞网络优先级。我尽量不延迟加载第一张图片，这取决于它在文件夹中的位置。您希望在使用交叉点观察器时留出一些余量，以便在查看之前有足够的滚动时间来加载资源</p><div class="nf ng gp gr nh ni"><a href="https://github.com/bluebill1049/react-simple-img" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">bluebill1049/react-simple-img</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">智能反应延迟加载图像与IntersectionObserver API，优先提示和动画加速初始页面加载…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw nx ni"/></div></div></a></div><p id="d776" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的是，IntersecionObserver v1不能确定不透明度或高度:0是否仍然隐藏，所以要确保显示没有折叠的内容，这些内容在技术上仍然在视图中，高度为0。这同样适用于z-index。</p><h2 id="a296" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated"><strong class="ak">针对第三方域名使用资源提示</strong></h2><p id="7d74" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">大多数生产环境中都有许多第三方标签。预连接域名和预加载关键标签通常会减少HTTP握手和RTT。HTTPS和DNS解析可能需要200毫秒。</p><p id="3c3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我很确定这个回购协议有问题。但是类似这样的东西对于动态创建资源提示非常有用。这在与其他性能策略结合时特别有用，如<a class="ae ny" href="https://medium.com/p/d03454965962" rel="noopener">门</a></p><div class="nf ng gp gr nh ni"><a href="https://github.com/ScriptedAlchemy/dynamic-resource-hints" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">ScriptedAlchemy/动态资源提示</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">按需在浏览器中注入资源提示。这个插件使你能够预连接，提督，dns预取…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="nz l nt nu nv nr nw nx ni"/></div></div></a></div><h1 id="31a0" class="li lj iq bd lk ll lm ln lo lp lq lr ls jw lt jx lu jz lv ka lw kc lx kd ly lz bi translated">先进的战术</h1><p id="fcd2" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">简要概述了一些基本的性能改进。让我们看看其他一些性能改进。</p><h2 id="c730" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated">对任何繁重的任务使用requestIdleCallback。</h2><p id="74ea" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在空闲时间执行代码是减少运行时开销的好方法。我会经常把<code class="fe oa ob oc od b">componentDidMount</code>或者<code class="fe oa ob oc od b">componentDidUpdate</code>包在<code class="fe oa ob oc od b">idleCallback</code>里。尤其是当装入的代码执行任何繁重的任务时，如objectFitImages polyfills或事件处理程序回调。</p><p id="4342" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">空闲回调将后台执行安排在不久的将来。通常在创建后的几毫秒内。这是减少长时间运行的函数时间的有效方法。一些代码可以在不阻塞事件循环的情况下运行。</p><p id="df80" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当与其他性能策略结合使用时，空闲回调非常有用，也有很多空闲回调聚合填充可以利用。</p><h2 id="b688" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated"><strong class="ak">使用网络空闲回拨</strong></h2><p id="68b8" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">当网络被确定为空闲时，运行繁重的操作，类似于TTI回调。自从TTI满足了我的大部分需求后，我就再也没有尝试过。</p><div class="nf ng gp gr nh ni"><a href="https://github.com/pastelsky/network-idle-callback" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">pastel sky/网络-空闲-回拨</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">networkIdleCallback的工作方式类似于requestIdleCallback，检测并通知您网络活动何时空闲…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="oe l nt nu nv nr nw nx ni"/></div></div></a></div><h2 id="95a0" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated"><strong class="ak">预热</strong></h2><p id="2d67" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">预热有几种方式。核心概念是将代码加载与其执行分开。在必须立即从网络、解析、编译到执行之前，给环境一个“预热”的机会。</p><pre class="lb lc ld le gt of od og oh aw oi bi"><span id="a91c" class="mt lj iq od b gy oj ok l ol om">const modulesToHeat = [<br/>      () =&gt; require("react-dom"),<br/>      ()=&gt; require('moment'),<br/>      ()=&gt;require('heavyvendor'),<br/>      ()=&gt;require('./App')<br/>    ]<br/>function getInSequence(array, asyncFunc) {<br/>  return array.reduce((previous, current) =&gt; (<br/>    previous.then(accumulator =&gt; (<br/>      asyncFunc(current).then(result =&gt; accumulator.concat(result))<br/>    ))<br/>  ), Promise.resolve([]));<br/>}</span><span id="a70d" class="mt lj iq od b gy on ok l ol om">getInSequence(modulesToHeat,(warm)=&gt;new Promise((resolve)=&gt;{<br/>  requestIdleCallback(()=&gt;{<br/>    resolve(warm())<br/>  })<br/>)).then(()=&gt;{<br/>  // you could use the library in the promise. But if App contained the mount and render function as well. <br/> const ReactDOM = require('react-dom')<br/> const App = require('./App')<br/> ReactDOM.hydrate(App,DOMNode)<br/>})</span></pre><p id="1d8d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种策略缩短了初始绘制和渲染时间，因为主线程不会立即被同一节拍的请求和执行代码所困扰。预热可以让你的绘画和渲染时间低于50毫秒。</p><p id="a2ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种策略可以改进为第三方标签。预热将使用动态资源提示，然后在<code class="fe oa ob oc od b">idleCallback</code> ticks中创建一个脚本标签。当与<a class="ae ny" href="https://medium.com/p/d03454965962" rel="noopener"> Gate </a>如何阻止解锁第三方标签结合使用时，这种机制效果最佳</p><p id="80bf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在使用<strong class="kh ir">模块联合时，我使用了类似的策略。</strong></p><pre class="lb lc ld le gt of od og oh aw oi bi"><span id="1658" class="mt lj iq od b gy oj ok l ol om">function preloadComponent(scope, module) {<br/>  return async () =&gt; {<br/>    // Initializes the share scope. This fills it with known provided modules from this build and all remotes<br/>    await __webpack_init_sharing__("default");</span><span id="9a95" class="mt lj iq od b gy on ok l ol om">    const container = window[scope]; // or get the container somewhere else<br/>    // Initialize the container, it may provide shared modules<br/>    await container.init(__webpack_share_scopes__.default);  <br/>    // the chunk is downloaded <br/>    const factory = await window[scope].get(module);</span><span id="266c" class="mt lj iq od b gy on ok l ol om">    return factory;<br/>  };<br/>}</span><span id="e2b5" class="mt lj iq od b gy on ok l ol om">const preload = preloadComponent(scope,module)</span><span id="0edc" class="mt lj iq od b gy on ok l ol om">setTimeout(()=&gt;{<br/>  preload.then(factory=&gt;{<br/>    // the factory is called, which returns module.exports</span><span id="d6da" class="mt lj iq od b gy on ok l ol om">    const Module = factory()<br/>    Module.default('someData')</span><span id="1c68" class="mt lj iq od b gy on ok l ol om">  })<br/>},100)</span></pre><p id="5141" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">IdleCallback可以实现，但是由于在这种实现下模块联合是异步的，所以您应该在应用程序生命周期中更高的地方预加载未来的模块。结合交叉点观察器，您可以在调用模块之前执行预加载。</p><h2 id="6d90" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated"><strong class="ak">重新排列第三方代码的优先级</strong></h2><div class="nf ng gp gr nh ni"><a href="https://medium.com/@ScriptedAlchemy/increase-app-performance-tame-tag-managers-and-take-back-control-from-third-parties-d03454965962" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">提高应用性能—驯服标签管理器，从第三方手中夺回控制权</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">Javascript应用程序的性能可能很棘手，即使应用程序已经针对速度进行了很好的调整——有一个很大的…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="oo l nt nu nv nr nw nx ni"/></div></div></a></div><p id="51d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">分开读一下。Gate是我见过的最大的性能改进。</p><h2 id="9ed3" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated"><strong class="ak">部分和惰性水合作用</strong></h2><p id="049c" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">您可以通过只对应用程序的一部分进行水合来显著提高内部应用程序的性能。因为你通常只需要页面的一部分是交互式的，比如在折叠内容上面。其他的都可以作为SSR的静态标记。然后，我们可以用交叉点观察器、空闲回调或根本不使用来合成附加的react组件——让标记保持静态。</p><p id="d3b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">反应水合可以是广泛操作。我们前期需要水合的越少，水合过程将完成得越快。</p><p id="4ebc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当结合闸门生命周期挂钩时，我们可以在达到TTI后对低优先级组件进行水合。</p><p id="2aa5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个好的连击是在可见或TTI计算上。TTI是通过监控性能API和CPU活动周期在客户端计算的。它也适用于所有浏览器。用户体验不会受到影响，因为水合作用会发生在组件可见之前(使用交叉点观察器)，否则，如果用户不看它，我们就没有理由在CPU持续空闲时水合应用程序的这些区域。</p><p id="5c62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TTI回调的优点是lighthouse不会测量在TTI之后执行的代码。虽然TTI本身的权重已经不重要了，但它是改进lighthouse和RUM指标的一个非常有用的方法。所以我用它来减少像react hydration这种长时间运行的功能的时间。并发模式将来可能会改善函数的执行时间。</p><div class="nf ng gp gr nh ni"><a href="https://github.com/hadeeb/react-lazy-hydration" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">hadeeb/react-lazy-水合作用</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">服务器渲染反应组件的惰性水合作用npm i反应-惰性水合作用或纱线添加反应-惰性水合作用基于…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="op l nt nu nv nr nw nx ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://github.com/LukasBombach/next-super-performance" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">LukasBombach/next-超级性能</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">使用Preact X为Next.js进行部分水合。解释:在spring，我们正在为报纸创建网站，我们…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="oq l nt nu nv nr nw nx ni"/></div></div></a></div><h2 id="d506" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated">适应性计算</h2><p id="1e4c" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">与TTI事件类似，您也可以获得设备容量和网络速度。根据网络或内存条件的不同，我可以积极地偷懒或卸载更多的供应商代码。您还可以调整图像质量和分辨率。</p><div class="nf ng gp gr nh ni"><a href="https://github.com/GoogleChromeLabs/react-adaptive-hooks" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">Google chrome labs/react-adaptive-hooks</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">提供最适合用户设备和网络限制的体验(实验性)这是一套反应…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="or l nt nu nv nr nw nx ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://medium.com/@roderickhsiao/sophisticated-adaptive-loading-strategies-7118341fcf91" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">复杂的自适应加载策略</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">性能现在是现代web应用的核心价值之一。大多数用户将网络浏览器体验从…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="os l nt nu nv nr nw nx ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://mattsnider.com/network-information-api-polyfill/" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">网络信息API poly fill MattSnider.com</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">浏览器正在慢慢实现许多新的HTML5 APIs，其中之一是网络信息API。它暴露了…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">mattsnider.com</p></div></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://github.com/Zizzamia/perfume.js" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">Zizzamia/perfume.js</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">页面速度是一个特性，为了实现它，我们需要了解许多因素和基本限制…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="ot l nt nu nv nr nw nx ni"/></div></div></a></div><h2 id="4469" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated">使用更快的环路和数据传感器。</h2><p id="8a81" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">像map、reduce、forEach、filter这样的本机循环函数对于批量操作来说很糟糕，并且不能很好地管理内存堆。</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div role="button" tabindex="0" class="ov ow di ox bf oy"><div class="gh gi ou"><img src="../Images/cf3d68412ef7faeb12c219586b7bf4da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c344VK-oRBr2tIdrxEEW1g@2x.jpeg"/></div></div></figure><p id="73b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面列出的项目非常适合更快的迭代和数据突变。它们通常优于大型数据集</p><div class="nf ng gp gr nh ni"><a href="https://github.com/jlongster/transducers.js" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">jlongster/transducers.js</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">一个用于数据通用转换的小型库(受Clojure的transducers的启发)- jlongster/transducers.js</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pa l nt nu nv nr nw nx ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://github.com/selfrefactor/rambda" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">自重构/rambda</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">Rambda是流行的函数式编程库Ramda的更小更快的替代方案。-文档您可以…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pb l nt nu nv nr nw nx ni"/></div></div></a></div><h2 id="c466" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated">使用记忆</h2><p id="f1fb" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">记忆在反应中应该被更多地使用。尤其是在必须执行大量渲染或具有大量生命周期挂钩的组件上。</p><p id="e5a8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">反应式代码库有一个坏习惯，就是在渲染周期中执行大量代码。</p><p id="2bae" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">工程师们也被吸引到最容易放置代码的地方，在render方法中。我们也经常在渲染方法中映射数组。用大量渲染来记忆一些旧的遗留代码是一个快速的解决方法。在URL解析器之类的实用函数中应用记忆化也可以节省时间，特别是如果它们被多次执行，产生相同的结果</p><div class="nf ng gp gr nh ni"><a href="https://github.com/theKashey/memoize-state" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">Kashey/memoize国家</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">缓存(也叫记忆化)是一种非常强大的优化技术——但是它只有在维护…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pc l nt nu nv nr nw nx ni"/></div></div></a></div><h2 id="62ae" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated"><strong class="ak">使用更精密的预压</strong></h2><p id="74f5" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">结合TTI的试镜。惰性预加载链接可能是有益的。</p><div class="nf ng gp gr nh ni"><a href="https://github.com/ibrahimcesar/react-quicklink" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">Ibrahim Cesar/react-快速链接</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">⚡️通过在空闲时间预取视口内链接来加快后续页面加载</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pd l nt nu nv nr nw nx ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://github.com/GoogleChromeLabs/quicklink" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">Google chrome labs/快速链接</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">通过在空闲时间预取视窗内链接来加快后续页面加载速度快速链接尝试进行导航…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pe l nt nu nv nr nw nx ni"/></div></div></a></div><h2 id="8037" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated"><strong class="ak">利用多线程</strong></h2><p id="1e91" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">以无缝方式配置工作池并不容易。</p><p id="f1ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe oa ob oc od b">workerpool</code>和<strong class="kh ir"> Webpack 5的模块联盟</strong>，我们可以在Webpack 5中使用先进的架构模式和尖端技术。</p><p id="ad22" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">联邦工作线程允许你使用主机自己的远程作为一种方式来移交和工作到另一个线程，它与MF无缝地这样做，这种方法可以工作在服务器端或客户端(稍作修改)。我将尽快写关于通用工作池的文章，因为我有动力完成它。</p><p id="9d30" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是设置的样子:</p><ol class=""><li id="5e67" class="mf mg iq kh b ki kj kl km ko mh ks mi kw mj la pf ml mm mn bi translated">我需要配置ModuleFederationPlugin</li></ol><pre class="lb lc ld le gt of od og oh aw oi bi"><span id="6220" class="mt lj iq od b gy oj ok l ol om">plugins: [<br/>  new <strong class="od ir"><em class="pg">webpack</em></strong>.<strong class="od ir"><em class="pg">container</em></strong>.ModuleFederationPlugin({<br/>    name: "dashboard",<br/>    filename: "static/runtime/remoteEntry.js",<br/>    exposes: {<br/>      "./utils": "./lighthouse/utils",<br/>    },<br/>    remotes: {<br/>      dashboard:<br/>        "dashboard@http://localhost:3000/_next/static/runtime/remoteEntry.js",<br/>    },<br/>  }),<br/>],</span></pre><p id="6126" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2.我将创建一个工人文件，只是为了更有效的移交(避免函数的序列化)</p><pre class="lb lc ld le gt of od og oh aw oi bi"><span id="5d65" class="mt lj iq od b gy oj ok l ol om">//worker.js<br/>const federatedWorkerImport = async (containerPath, shareInit) =&gt; {<br/>  const <strong class="od ir"><em class="pg">path </em></strong>= require("path");<br/><br/>  <strong class="od ir"><em class="pg">global</em></strong>.__webpack_require__ = require(<strong class="od ir"><em class="pg">path</em></strong>.join(<br/>    <strong class="od ir"><em class="pg">process</em></strong>.cwd(),<br/>    ".next/server/webpack-runtime.js"<br/>  ));<br/>  const {<br/>    initSharing: __webpack_init_sharing__,<br/>    shareScopes: __webpack_share_scopes__,<br/>  } = shareInit();<br/>  // initialize any sharing, unlikely in a worker<br/>  await __webpack_init_sharing__("default");<br/>  // require container<br/>  const container = require(containerPath).dashboard;<br/>  // Initialize the container, it may provide shared modules<br/>  await container.init(__webpack_share_scopes__.default);<br/>  return (request) =&gt; {<br/>    return container.get(request).then((factory) =&gt; factory());<br/>  };<br/>};<br/><br/>module.exports = federatedWorkerImport;</span></pre><p id="4549" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">3.我需要创建一个助手函数来生成一个工人</p><pre class="lb lc ld le gt of od og oh aw oi bi"><span id="1126" class="mt lj iq od b gy oj ok l ol om">const createWorker = async (data, request, moduleExport) =&gt; {<br/>  if (!<strong class="od ir"><em class="pg">process</em></strong>.browser) {<br/>    const path = __non_webpack_require__("path");<br/>    // could also make this an external, then just use "require"<br/>    const initRemote = __non_webpack_require__(<br/>      // needs webpack runtime to get __webpack_require__<br/>      // externally require the worker code with node.js This could be inline,<br/>      // but i decided to move the bootstapping code somewhere else. Technically if this were not next.js<br/>      // we should be able to import('dashboard/utils')<br/>      // workers/index.js was in this file, but its cleaner to just move the boilerplate<br/>      path.join(<strong class="od ir"><em class="pg">process</em></strong>.cwd(), "workers/index.js")<br/>    );<br/><br/>    // essentially do what webpack is supposed to do in a proper environment.<br/>    // attach the remote container, initialize share scopes.<br/>    // The webpack parser does something similer when you require(app1/thing), so make a RemoteModule<br/>    const federatedRequire = await initRemote(<br/>      path.join(<strong class="od ir"><em class="pg">process</em></strong>.cwd(), ".next/server/static/runtime/remoteEntry.js"),<br/>      () =&gt; ({<br/>        initSharing: __webpack_init_sharing__,<br/>        shareScopes: __webpack_share_scopes__,<br/>      })<br/>    );<br/>    // the getter, but abstracted. This async gets the module via the low-level api.<br/>    // The remote requires utils (basically this file lol) and i pull toFixed off its exports.<br/>    // alternatively i could copy paste, but MF provides me the power to import the current file as an entrypoint<br/>    const RemoteModule = await federatedRequire(request);<br/>    return RemoteModule[moduleExport](data);<br/>  }<br/>};</span></pre><p id="6540" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4.现在创建一个函数，将数据处理交给工作线程池中的一个线程</p><pre class="lb lc ld le gt of od og oh aw oi bi"><span id="eb54" class="mt lj iq od b gy oj ok l ol om">const generateScatterChartData = async (data) =&gt; {<br/>  if (!<strong class="od ir"><em class="pg">process</em></strong>.browser) {<br/>    return pool<br/>      .exec(createWorker, [data, "./utils", "generateScatterChartProcessor"])<br/>      .then(function (result) {<br/>        return result;<br/>      })<br/>      .catch(function (err) {<br/>        <strong class="od ir"><em class="pg">console</em></strong>.error(err);<br/>      })<br/>      .then(function (result) {<br/>        return result;<br/>      });<br/>  }<br/><br/>  return {};<br/>};</span></pre><p id="d7fc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">5.现在我们在<code class="fe oa ob oc od b">getInitialProps</code>中使用这个函数</p><pre class="lb lc ld le gt of od og oh aw oi bi"><span id="d004" class="mt lj iq od b gy oj ok l ol om">Report.getInitialProps = async ({ query }) =&gt; {<br/>  const { meta, ...report } = await fetch(<br/>    hostname + "api/get-report?report=" + query.report<br/>  ).then((res) =&gt; res.json());  </span><span id="eb62" class="mt lj iq od b gy on ok l ol om"> const [<br/>    scatterChartData, <br/>    whiskerChartData,<br/>    multiSeriesChartData,<br/>  ] = await <strong class="od ir"><em class="pg">Promise</em></strong>.<em class="pg">all</em>([<br/>    generateScatterChartData(report), //worker thread<br/>    generateWhiskerChartData(report), //worker thread<br/>    generateMultiSeriesChartData(report), //worker thread<br/>  ]);<br/>  return {<br/>    scatterChartData,<br/>    whiskerChartData,<br/>    multiSeriesChartData,<br/>    meta,<br/>    appKeys: <strong class="od ir"><em class="pg">Object</em></strong>.keys(report),<br/>    query,<br/>  };<br/>};</span></pre><p id="48bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我使用<code class="fe oa ob oc od b">workerpool</code>在节点和客户机上创建通用工人。</p><div class="nf ng gp gr nh ni"><a href="https://github.com/josdejong/workerpool" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">josde Jong/工人村</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">提供了一种简单的方法来创建一个工人池，用于动态卸载计算以及管理池…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="ph l nt nu nv nr nw nx ni"/></div></div></a></div><p id="346a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做让我的应用内性能和服务器响应时间提升了400%</p><p id="0a58" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他选项，我没有尝试过——比如parallel.js</p><div class="nf ng gp gr nh ni"><a href="https://github.com/parallel-js/parallel.js" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">并行-js/parallel.js</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">用Javascript Parallel.js实现简单的并行计算是一个库，用于使Javascript中的并行计算变得简单…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pi l nt nu nv nr nw nx ni"/></div></div></a></div><p id="a4ee" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还在试验从Web workers内部授予dom访问权限的方法，如果他们中的一些人能够在带有shimmed DOM API的worker内部工作，这可能会减少供应商的影响</p><div class="nf ng gp gr nh ni"><a href="https://github.com/ampproject/worker-dom" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">ampproject/worker-dom</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">相同的DOM API和框架，但是在Web Worker中。- ampproject/worker-dom</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pj l nt nu nv nr nw nx ni"/></div></div></a></div><h2 id="749a" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated"><strong class="ak">在模块级别监控性能。</strong></h2><p id="11d3" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">这种方法对于寻找应该进行代码分割或预热的重型模块非常有用。然后，您可以返回并追溯工作，以改善最糟糕的违规模块。</p><div class="nf ng gp gr nh ni"><a href="https://github.com/SinaMFE/perf-module-webpack-plugin" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">Sina mfe/perf-module-web pack-plugin</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">webpack捆绑的所有模块的插件计算时间，并显示花费自己的前N个模块的列表…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pk l nt nu nv nr nw nx ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://github.com/bfrost2893/user-timing-plus" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">BF rost 2893/用户计时加</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">增强的用户计时API。通过在GitHub上创建帐户，为bfrost2893/user-timing-plus开发做出贡献。</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pl l nt nu nv nr nw nx ni"/></div></div></a></div><h2 id="1579" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated"><strong class="ak">伟大的监控厂商</strong></h2><p id="2aad" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">虽然模块级和用户计时是有帮助的——但是建立一个Kibana仪表板来绘制所有这些数据可能需要更多的努力。尤其是朗姆酒信息。</p><p id="7fa3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae ny" href="https://www.bluetriangle.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">蓝三角</strong> </a> <strong class="kh ir">说到性能，是我最喜欢的</strong>厂商之一。我喜欢的<strong class="kh ir">核心特性有:</strong></p><ul class=""><li id="92e7" class="mf mg iq kh b ki kj kl km ko mh ks mi kw mj la mk ml mm mn bi translated">实时RUM数据</li><li id="2637" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">关于核心网络生命指标的报告</li><li id="7f0e" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">你可以运行合成样本</li><li id="ddcb" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">他们可以准确地计算出因业绩不佳而错失的收入机会</li><li id="fe35" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">与Gate类似，Blue Triangle能够在客户端用RUM计算TTI。</li><li id="a8a6" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">它有一个很棒的数据科学引擎，我用它来诊断特定互联网交换节点的特定问题。</li><li id="df12" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">它很强大</li><li id="535e" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">工作人员很好共事，并且在那里支持他们的客户。</li><li id="8ba2" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">该公司非常重视用户的意见</li></ul><p id="ee97" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">RUM信息有助于了解您的代码对用户设备的影响。多亏了blue triangle，我能够将实验性的性能增强部署到生产中。然后可以看看朗姆酒数据。在5分钟内，我通常会得到我的答案，他们要么合并到主分支，要么重新部署主分支，继续我的实验，直到我看到我预期的影响。</p><p id="b05a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以将自定义测量时间发送回BTT</p><p id="1c6e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望Blue Triangle在产品上有一些<strong class="kh ir">方面的改进</strong>。</p><ul class=""><li id="c6e9" class="mf mg iq kh b ki kj kl km ko mh ks mi kw mj la mk ml mm mn bi translated">将您的RUM测量函数公开为回调事件。<br/>因为BT已经向其服务器报告了所有这些RUM数据。如果有像<code class="fe oa ob oc od b">window.btt.events.isInteractive(myCallback</code>和<code class="fe oa ob oc od b">window.btt.networkType // returns [3G,WIFI,LTE]</code>这样的东西，那将是令人惊奇的，不仅BT能够测量朗姆酒，而且实际上提供了帮助工程师改进的回调。如果你知道一个设备的网络速度/质量，这将是一个惊人的信息。我可以建立由朗姆酒数据支持的适应性系统</li><li id="5f86" class="mf mg iq kh b ki mo kl mp ko mq ks mr kw ms la mk ml mm mn bi translated">报告标准的<code class="fe oa ob oc od b">performance.mark</code>用户计时API。我希望能够在不使用自定义标记的情况下绘制组件级性能的图形。</li></ul><p id="ae99" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae ny" href="https://sentry.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">哨兵</strong> </a> <strong class="kh ir"> </strong>是另一个值得投资的关键厂商。</p><p id="be1b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您需要知道是否存在标准回归和QA中没有发现的竞争条件。错误报告和快速部署管道让您可以更快地移动和快速回滚。</p><p id="1825" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">花时间探索sentry APIs和可用的webhook选项将是非常有价值的。我计划使用Sentry、Blue Triangle和仍在测试中的<strong class="kh ir">联邦仪表板</strong>来利用<strong class="kh ir">模块联邦</strong>和命令控制系统，这些系统将能够自动适应如何以及什么版本的联邦代码被附加到主机。我将发表一篇单独的文章，讨论一个被设计成自我修复和自我调节的架构是什么样子的。好消息是。像这样的系统并不太难制造，因为我拥有使它成为可能的工具。</p><h2 id="b01e" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated"><strong class="ak">格拉马纳和基巴纳</strong></h2><p id="8e17" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">制作图表和消费大量数据的神奇工具。<br/>这些是我在以前的公司的秘诀——拥有数据是无价的。有数据就可以卖任何主动权。</p><p id="9763" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这篇文章(与这些天的模块联合相比有点老)深入探讨了我绘制的数据，以及这些graphana仪表板如何让我们超越后端片段缓存</p><div class="nf ng gp gr nh ni"><a href="https://levelup.gitconnected.com/micro-frontend-architecture-replacing-a-monolith-from-the-inside-out-61f60d2e14c1" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">微前端架构:从内到外取代整体架构</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">如何利用微前端技术实现遗留应用的现代化</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="nr l"><div class="pm l nt nu nv nr nw nx ni"/></div></div></a></div><p id="69d6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这些仪表板工具，你可以获得大量高分辨率的数据。尤其是在前端。我使用一个代理来根据我将发送到端点的POST请求发出日志。绘制任何和所有前端指标是您保持在线和稳定的方式。</p><p id="10a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">I良好的监控策略是将事件附加到业务关键流。比如，加入购物车。通过绘制点击和成功调用的图表，您可以创建一个移动平均值，然后任何指标低于标准移动平均值，就会触发警报并向slack发送通知。</p><p id="fcb5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我依靠这个来定位糟糕的部署问题。Graphana也节省了一些可观的收入。在亚马逊更新他们的状态之前，我能够对著名的东海岸AWS中断做出反应。当AWS状态页面显示东海岸停电时。我们已经将生产转移到欧洲的备份数据中心。</p><h2 id="2727" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated"><strong class="ak">考虑使用低热量水来加快初始启动。</strong></h2><p id="98b5" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">这个方法的工作原理是用轻量级的东西替换ReactDOM。它可以帮助初始水合时间，使应用程序部分或完全互动。你也可以使用一个更小的dom库来处理最初的水合作用。然后在空闲时间用ReactDOM重新水合</p><div class="nf ng gp gr nh ni"><a href="https://github.com/dai-shi/react-hooks-worker" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">戴氏/反应钩-工人</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">React为网络工作者定制钩子。Web Workers是浏览器中主线程的另一个线程。我们可以负重奔跑…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pn l nt nu nv nr nw nx ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://github.com/alewin/useWorker" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">alewin/useWorker</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">运行昂贵的函数而不阻塞UI(显示实时gif)支持承诺模式而不是事件消息大小:…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="po l nt nu nv nr nw nx ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://github.com/LukasBombach/next-super-performance" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">LukasBombach/next-超级性能</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">使用Preact X为Next.js进行部分水合。解释:在spring，我们正在为报纸创建网站，我们…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pp l nt nu nv nr nw nx ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://github.com/jiayihu/react-tiny-dom" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">胡佳艺/反应小王国</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">react-tiny-dom是react-dom的最小实现，作为使用React 16官方渲染器API的自定义渲染器。的…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pq l nt nu nv nr nw nx ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://github.com/web-perf/react-worker-dom" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">web-perf/react-worker-dom</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">使用Web Workers的React自定义渲染器。所有虚拟DOM协调都发生在WebWorker线程中。仅节点…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pr l nt nu nv nr nw nx ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://github.com/NervJS/nerv" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">神经/神经</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">反应极快的替代产品，兼容IE8和React 16。-神经/神经</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="ps l nt nu nv nr nw nx ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://github.com/sophiebits/react-dom-mini" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">sophiebits/react-dom-mini</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">来自我的React Conf 2019 talk的玩具React渲染器，“构建自定义React渲染器”解散GitHub是超过50…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pt l nt nu nv nr nw nx ni"/></div></div></a></div><h2 id="f33c" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated">或者尝试去抖渲染hoc</h2><p id="a25e" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">这是我正在尝试的一个新技巧(现在)</p><p id="59bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我的<code class="fe oa ob oc od b">Link</code>组件慢。孩子变了，道具变了。每次我都需要解析URL并判断它是内部路由器链接还是外部超链接。</p><p id="c260" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然这不是最优化的解决方案，但在我测试的条件下非常有效。</p><p id="fc82" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">解析URL大约需要1毫秒，整个组件大约需要1-2毫秒。总的来说，这是组件花费的时间(所有链接的总和)</p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi pu"><img src="../Images/2aa9cdff0568669ebe77372bbc2832f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*jQT3-tPnwdolzYECqmw_Sw.png"/></div></figure><p id="4a7b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每次渲染大约50毫秒！哎哟！</p><p id="4f4e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为这篇文章促使我让universal workers开始运行。我决定看看如果我把URL解析移动到一个我一直使用的懒惰水合来改善时间的<code class="fe oa ob oc od b">workerpool</code>中，那么<code class="fe oa ob oc od b">link</code>会改善多少，但是我需要打开PR来启用没有包装组件的水合。</p><p id="2693" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我将URL解析转移到一个worker中，然后创建一个<code class="fe oa ob oc od b">useEffect</code>钩子，一旦worker有响应就更新超链接，这让我可以在主线程之外并行处理所有链接。这将节省大约200毫秒。</p><pre class="lb lc ld le gt of od og oh aw oi bi"><span id="e584" class="mt lj iq od b gy oj ok l ol om">const [match, setMatch] = React.useState({});<br/>React.useEffect(() =&gt; {<br/>  process.browser<br/>  &amp;&amp; requestIdleCallback(() =&gt; {<br/>    pool<br/>      .sendCommand('doesMatchRoute', [url, <strong class="od ir"><em class="pg">publicConfig</em></strong>])<br/>      .then((data) =&gt; {<br/>        setMatch(data);<br/>      })<br/>      .catch((err) =&gt; {});<br/>  });<br/>}, [url]);<br/>const { routeMatch, relativeURL } = process.browser<br/>  ? match<br/>  : doesMatchRoute(url);</span></pre><p id="ce83" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不希望发生闪烁，因为我不再拥有传递给它的子标记的属性。所以渲染可以闪烁，如果我<code class="fe oa ob oc od b">return null</code>直到工人完成。<strong class="kh ir">这是SSR </strong>所以保持最初的标记很重要。直到我回到懒惰的水化，我只是对待所有的环节是<code class="fe oa ob oc od b">&lt;a&gt;</code></p><p id="eacc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使我去掉了闪烁——那些工作人员也不得不重新计算相同的URL几次，实际上没有什么重要的变化需要立即进行50毫秒的重新渲染。这让我想到去抖组件的重新渲染周期。如果道具改变了很多次，让我们去抖反应会有多快实际重新渲染。</p><div class="nf ng gp gr nh ni"><a href="https://github.com/podefr/react-debounce-render" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">pode fr/react-去抖-渲染</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">react-debounce-render是一个高阶组件，它包装react组件并对其渲染进行去抖。这个…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="pv l nt nu nv nr nw nx ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://dev.to/botreetechnologies/how-can-we-debounce-render-a-react-component-with-example-33gj" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">如何去抖渲染一个React组件？(举例)</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">根据https://www.geeksforgeeks.org/debouncing-in-javascript/的说法，JavaScript中的去抖是一种用来…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">开发到</p></div></div><div class="nr l"><div class="pw l nt nu nv nr nw nx ni"/></div></div></a></div><pre class="lb lc ld le gt of od og oh aw oi bi"><span id="3f88" class="mt lj iq od b gy oj ok l ol om">export default (process.browser<br/>  ? debounceRender(LinkGenerator, 0.1) : LinkGenerator<br/>  : LinkGenerator);</span></pre><p id="cdef" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个相当花哨的解决方案。但是我不能否认所有这些结合在一起的结果。随着部分水化，我预计最初的渲染会有所改善，因为我仍然在打电话给<code class="fe oa ob oc od b">react.createElement</code></p><figure class="lb lc ld le gt lf gh gi paragraph-image"><div class="gh gi px"><img src="../Images/09b0bcb7f945c4bd6fc81153123f9279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*AQkS2bcKLXDPbh2T7P0kOw.png"/></div></figure><blockquote class="py"><p id="77f8" class="pz qa iq bd qb qc qd qe qf qg qh la dk translated">不管是不是黑客，那都令人印象深刻！</p></blockquote><h2 id="78e9" class="mt lj iq bd lk mu qi dn lo mw qj dp ls ko qk mz lu ks ql nb lw kw qm nd ly ne bi translated"><strong class="ak">最后的结果会是什么样子。</strong></h2><p id="168f" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">我会避免去抖。因为我还在为第一次渲染付钱。</p><p id="8ffb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终的解决方案将会是<code class="fe oa ob oc od b">react-lazy-hydration</code>，但是会有额外的修改。我想有能力在承诺的决议上水合。</p><p id="dbc9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将允许我让React完全忽略标记，直到工人用更新来响应。一个有前途的能力也将让我选择水合物反应成分的基础上TTI。我可以使用Gate，它已经在监控芯片性能并阻止供应商标签，直到压力减小。</p><p id="62e2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">工人池需要合并到一个钩子或实用函数中，最重要的是——我希望这些工人池使用模块联合(通用)。我给工人的消息将作为工人内部MF的控制器。因为远程容器只有5kb，所以worker的初始解析和启动时间要短得多。当我需要更多自己的代码库时，主机通过一个worker向远程发送消息，告诉它应该执行哪个模块，以及用什么参数来执行。</p><figure class="lb lc ld le gt lf"><div class="bz fp l di"><div class="qn lh l"/></div></figure><h2 id="8078" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated"><strong class="ak">利用GPU进行数据处理</strong></h2><p id="2a31" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">CPU能够执行任何计算任务。但是GPU在特定任务上速度更快——将工作转移到GPU可以导致更快的操作。但是GPU不像CPU那样通用，卸载随机函数可能不会产生预期的结果。因此，明智地选择并基准测试哪些应该驻留在worker中，哪些应该驻留在GPU线程中</p><div class="nf ng gp gr nh ni"><a href="https://github.com/gpujs/gpu.js" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">gpujs/gpu.js</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">js是一个JavaScript加速库，用于Web和…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="qo l nt nu nv nr nw nx ni"/></div></div></a></div><h2 id="8ec3" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated"><strong class="ak">用更好的静态分析干燥代码</strong></h2><p id="93d5" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">删除代码仍然是最好的性能策略。不看gzip大小缩减，看未压缩文件大小。您可以删除300kb的代码——当应用gzip时，它最终可能是5kb。但是浏览器仍然需要解压缩和解析完整的大小。仅仅因为它便于传输并不意味着它很容易JIT解析、编译和执行。删除代码是你最好的策略:)</p><div class="nf ng gp gr nh ni"><a href="https://github.com/rdgd/twly" rel="noopener  ugc nofollow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">rdgd/twly</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">twly(读作“towel-E”)是一个静态分析工具，它可以帮助你保持代码干燥(不要重复自己)</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">github.com</p></div></div><div class="nr l"><div class="qp l nt nu nv nr nw nx ni"/></div></div></a></div><h2 id="f9ff" class="mt lj iq bd lk mu mv dn lo mw mx dp ls ko my mz lu ks na nb lw kw nc nd ly ne bi translated">暂时就这样吧！</h2><p id="3019" class="pw-post-body-paragraph kf kg iq kh b ki ma jr kk kl mb ju kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">这篇文章太长了。我会再写一篇，因为还有很多要说的。</p><p id="812d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二部分将被推文，并添加到这个位置。</p><p id="d6c4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你知道在哪里能找到我。</p><p id="7a5a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">推特:<a class="ae ny" href="https://twitter.com/ScriptedAlchemy" rel="noopener ugc nofollow" target="_blank"> ScriptedAlchemy </a></p><p id="6d20" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Github: ScriptedAlchemy</p></div></div>    
</body>
</html>