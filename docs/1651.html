<html>
<head>
<title>Asynchronous JavaScript Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步JavaScript解释</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/asynchronous-javascript-explained-a4c1133f5544?source=collection_archive---------7-----------------------#2020-04-10">https://javascript.plainenglish.io/asynchronous-javascript-explained-a4c1133f5544?source=collection_archive---------7-----------------------#2020-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/86d77d8ec3d9599a1e69a5438056bdc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RxyQbHql-lnHcQw_.png"/></div></div></figure><p id="b086" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是对javascript，一种同步语言，是的，你没看错，是如何执行/允许软件工程师开发异步执行代码的权威性解释。</p><p id="59a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从下面的例子开始，追踪javascript是如何执行这段代码的:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="5269" class="lf lg iq lb b gy lh li l lj lk">const num = 3;<br/>function multiplyBy2 (inputNumber){<br/>    const result = inputNumber*2<br/>    return result<br/>}<br/>const output = multiplyBy2(num);<br/>const newOutput = multiplyBy2(10);</span></pre><ul class=""><li id="8235" class="ll lm iq ka b kb kc kf kg kj ln kn lo kr lp kv lq lr ls lt bi translated">第1行:我们定义一个<code class="fe lu lv lw lb b">const num</code>，在其中存储值<code class="fe lu lv lw lb b">3</code>，数据保存在<strong class="ka ir">全局内存</strong></li><li id="0013" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">第2行:我们定义一个函数<code class="fe lu lv lw lb b">multiplyBy2</code>，我们获取它的标签和里面的所有代码，然后一次性保存。</li><li id="d4f8" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">第7行:我们在<strong class="ka ir">全局内存</strong>中定义了<code class="fe lu lv lw lb b">cons output</code>，它将存储调用<code class="fe lu lv lw lb b">multiplyBy2</code>的<code class="fe lu lv lw lb b">result</code>(返回值)</li><li id="2fdf" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">当我们运行<code class="fe lu lv lw lb b">multiplyBy2</code>时会发生什么？</li><li id="9e86" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">我们新建一个<strong class="ka ir"/><strong class="ka ir"><em class="mc">执行上下文</em> </strong></li><li id="5893" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">在这个新的<strong class="ka ir">执行上下文</strong>中，在<strong class="ka ir">本地存储器</strong>中，我们:</li><li id="0f5a" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">将值<code class="fe lu lv lw lb b">3</code>存储在<code class="fe lu lv lw lb b">inputNumber</code>中</li><li id="d904" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">我们定义了<code class="fe lu lv lw lb b">const result</code>，我们在其中存储了<code class="fe lu lv lw lb b">inputNumber*2</code>的值。</li><li id="8f74" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">我们返回分配给标签<code class="fe lu lv lw lb b">result</code>的<strong class="ka ir">值</strong>，并将其存储在<code class="fe lu lv lw lb b">output</code>中。</li><li id="16df" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">再次为<code class="fe lu lv lw lb b">newOutput</code></li></ul><h2 id="f9fc" class="lf lg iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">Javascript是一种同步语言，这意味着它逐行执行代码。</h2><h2 id="b5e7" class="lf lg iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">但是，如果<code class="fe lu lv lw lb b">multiplyBy2</code>是一个与Twitter对话的功能，并且它真的很慢，会怎么样呢？这意味着，我们的代码必须暂停，等待函数与Twitter完成对话，然后继续运行我们的程序。</h2><h2 id="b26a" class="lf lg iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">那太糟糕了。</h2><h1 id="8dbb" class="mu lg iq bd md mv mw mx mg my mz na mj nb nc nd mm ne nf ng mp nh ni nj ms nk bi translated">异步JS来拯救。</h1><p id="1e4a" class="pw-post-body-paragraph jy jz iq ka b kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv ij bi translated">我们的核心Javascript引擎有三个主要部分，<strong class="ka ir">执行线程</strong>，<strong class="ka ir">变量环境和调用栈</strong>。</p><p id="4d5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此它不支持异步行为。我们必须添加新的组件:</p><ul class=""><li id="02a7" class="ll lm iq ka b kb kc kf kg kj ln kn lo kr lp kv lq lr ls lt bi translated">网络浏览器功能</li><li id="dba2" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">承诺——本博客中没有提到</li><li id="2cdc" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">事件循环</li><li id="588b" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">回拨/任务队列</li><li id="5c0c" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">微任务队列——本博客中没有提到</li></ul><p id="4463" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要添加这些成分来解释到底发生了什么。</p><h2 id="9c10" class="lf lg iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">Javascript在浏览器中运行</h2><p id="c6ea" class="pw-post-body-paragraph jy jz iq ka b kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv ij bi translated">浏览器有很多特性，Javascript引擎是其中的一部分。该浏览器的一些功能包括:</p><ul class=""><li id="cacf" class="ll lm iq ka b kb kc kf kg kj ln kn lo kr lp kv lq lr ls lt bi translated">Javascript引擎</li><li id="edb5" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">Web套接字</li><li id="e9ca" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">开发工具+控制台</li><li id="a770" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">网络请求</li><li id="79c8" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">HTML DOM</li><li id="4b3a" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">计时器</li></ul><p id="f3a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并且<strong class="ka ir"> Javascript </strong>允许我们使用/接口浏览器的这些功能！</p><p id="ee40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有些<strong class="ka ir"> facade </strong>函数看起来像是javascript，但实际上是用C++(针对谷歌Chrome)或其他语言编写的网络浏览器功能的facade。</p><p id="470b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些外观功能包括:</p><p id="c8da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lb b">console</code> - &gt;控制台</p><p id="7ec4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lb b">xhr</code> / <code class="fe lu lv lw lb b">fetch</code> - &gt;网络请求</p><p id="57d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lb b">document</code> - &gt; HTML DOM</p><p id="9008" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lu lv lw lb b">setTimeout</code> - &gt;计时器</p><p id="4ce8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们通过下面的例子来理解JavaScript是如何使用浏览器特性的，并学习它是如何将浏览器特性转换成可工作的代码的。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="2136" class="lf lg iq lb b gy lh li l lj lk">function printHello(){ console.log("Hello") }<br/>​<br/>setTimeout(printHello, 1000)<br/>​<br/>console.log("Me first!")</span></pre><ul class=""><li id="697e" class="ll lm iq ka b kb kc kf kg kj ln kn lo kr lp kv lq lr ls lt bi translated">第1行-&gt;我们定义一个<code class="fe lu lv lw lb b">function printHello</code></li><li id="ec27" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">第2行-&gt;调用一个<code class="fe lu lv lw lb b">setTimeout</code></li><li id="19f7" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">我们在<strong class="ka ir">网络浏览器</strong>中设置了一个计时器</li><li id="6d71" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">我们向它传递一个在完成时执行的回调和以毫秒为单位的持续时间。</li><li id="4e91" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">浏览器计时器有一个完整的？<code class="fe lu lv lw lb b">boolean</code>，其中if <code class="fe lu lv lw lb b">true</code>，运行回调。</li><li id="9a40" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">所以在0毫秒，完成？是<code class="fe lu lv lw lb b">false</code>，所以什么也没发生</li><li id="12aa" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">此时，<strong class="ka ir"> Javascript引擎</strong>已经完成了在浏览器中设置计时器的工作，并且可以继续执行下一行代码。</li><li id="a61e" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">第3行-&gt; <code class="fe lu lv lw lb b">console.log("Me first!")</code>被执行。</li><li id="aad4" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">至此，<strong class="ka ir"> Javascript引擎</strong>完成，但在后台，浏览器中有一个定时器。</li><li id="b9c5" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">滴答声</li><li id="eaf0" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">托科鸟</li><li id="27c7" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">1000 ms过去了-&gt;完成？<strong class="ka ir">是否为真</strong>，该函数将直接返回到<strong class="ka ir"> Javascript引擎</strong>，将其添加到调用堆栈中，并执行它。</li></ul><h2 id="bd10" class="lf lg iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">话虽如此，许多问题还是出现了，比如:</h2><ul class=""><li id="ac32" class="ll lm iq ka b kb nl kf nm kj nq kn nr kr ns kv lq lr ls lt bi translated">既然<code class="fe lu lv lw lb b">setTimeout</code>已经完成，那么<strong class="ka ir">网络浏览器</strong>将在稍后阶段影响堆栈？</li><li id="22ce" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">比如，如果栈里有东西呢？在这段时间内是否正在执行某项功能？浏览器推送的功能是否会覆盖已经运行的功能？</li></ul><p id="1320" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很明显，我们需要一些规则来决定浏览器何时允许这个功能，在我们的例子中<code class="fe lu lv lw lb b">printHello</code>回到Javascript。</p><h2 id="b6bb" class="lf lg iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">我们需要一些非常严格的规则，使我们的代码超级可预测，如果我们知道这些核心规则，我们将从根本上知道它会如何表现。</h2><p id="fb82" class="pw-post-body-paragraph jy jz iq ka b kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv ij bi translated">让我们试着理解什么时候允许回调。</p><p id="5681" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了做到/模拟这一点，我们将让调用堆栈在浏览器试图向<strong class="ka ir"> Javascript引擎</strong>发送回调时处于忙碌状态。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="4075" class="lf lg iq lb b gy lh li l lj lk">function printHello(){ console.log("Hello") } <br/>function blockFor1Sec(){     <br/>    // Blocks the Javascript thread for 1 second        <br/>    for(i=0; i &lt; 50000; i++){         <br/>        console.log("i is: ", i)     <br/>    } <br/>}  <br/>setTimeout(printHello, 10); <br/>blockFor1Sec(); <br/>console.log("Me First")</span></pre><h2 id="d89b" class="lf lg iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">在我们继续之前，我们必须引入回调队列，它是传递给浏览器的回调队列。不要与传递给传统高阶函数的回调混淆。这些只是传递给浏览器并返回给Javascript引擎的回调。</h2><ul class=""><li id="9bba" class="ll lm iq ka b kb nl kf nm kj nq kn nr kr ns kv lq lr ls lt bi translated">0毫秒:<code class="fe lu lv lw lb b">setTimeout</code>被放入调用堆栈。</li><li id="49ce" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">浏览器中启动一个定时器，当定时器结束时，传递<code class="fe lu lv lw lb b">printHello</code>到回调队列。</li><li id="03d5" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">1 ms:进入<code class="fe lu lv lw lb b">blockFor1Sec</code>的<strong class="ka ir">执行上下文</strong></li><li id="243f" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">这需要1000毫秒才能完成</li><li id="c35f" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">10 ms: <code class="fe lu lv lw lb b">printHello</code>被推送到回调队列。</li><li id="50cc" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">1001 ms: <code class="fe lu lv lw lb b">console.log("Me First")</code>被执行死刑</li><li id="7d9f" class="ll lm iq ka b kb lx kf ly kj lz kn ma kr mb kv lq lr ls lt bi translated">1002 ms: <code class="fe lu lv lw lb b">printHello</code>从回调队列中弹出，放入调用栈，执行。</li></ul><p id="9d16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们知道传递给<code class="fe lu lv lw lb b">setTimeout</code>的回调是在线程执行完成后的1002ms执行的。</p><h2 id="b829" class="lf lg iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">所以规则是:</h2><h2 id="7840" class="lf lg iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">所有同步代码必须在回调队列弹出其内容之前完成。</h2><h2 id="dbf7" class="lf lg iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated">所有常规代码将首先运行，直到Javascript触及队列中的任何内容。</h2><h1 id="a8f9" class="mu lg iq bd md mv mw mx mg my mz na mj nb nc nd mm ne nf ng mp nh ni nj ms nk bi translated">javascript是如何做到的？</h1><p id="b294" class="pw-post-body-paragraph jy jz iq ka b kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv ij bi translated">它有一个检查调用栈是否为空的特性，如果是，那么从队列中获取一些东西。</p><p id="7a98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个特性被称为<strong class="ka ir">事件循环。</strong></p><p id="6856" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是全部了。</p><p id="a1cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的阅读。</p><p id="d2e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您看到错误、不完整的解释或遗漏的部分，请指出来。</p><p id="b473" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">博客灵感来源于<a class="ae nt" href="https://frontendmasters.com/" rel="noopener ugc nofollow" target="_blank">前端大师</a> / <a class="nu nv ep" href="https://medium.com/u/1b199ed2dfd?source=post_page-----a4c1133f5544--------------------------------" rel="noopener" target="_blank">前端大师</a>，<a class="nu nv ep" href="https://medium.com/u/c211a09475?source=post_page-----a4c1133f5544--------------------------------" rel="noopener" target="_blank">教授的JavaScript:难的部分v2将会提交一份清单</a>，这篇文章就是由此而来。对于那些想大幅增加他们的前端编程知识的人来说，这是一个惊人的资源。</p><h2 id="f292" class="lf lg iq bd md me mf dn mg mh mi dp mj kj mk ml mm kn mn mo mp kr mq mr ms mt bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="4eee" class="pw-post-body-paragraph jy jz iq ka b kb nl kd ke kf nm kh ki kj nn kl km kn no kp kq kr np kt ku kv ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae nt" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ka ir">AI in Plain English</strong></a><a class="ae nt" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ka ir">UX in Plain English</strong></a><a class="ae nt" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ka ir">Python in Plain English</strong></a><strong class="ka ir"/>——谢谢，继续学习！</p><p id="ee00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也一直对帮助推广高质量内容感兴趣。如果您有一篇文章想提交给我们的任何出版物，请用您的中用户名在<a class="ae nt" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">submissions @ plain English . io</strong></a><strong class="ka ir"/>发邮件给我们，我们会将您添加为作家。另外，请告诉我们您想添加到哪个出版物中。</p></div></div>    
</body>
</html>