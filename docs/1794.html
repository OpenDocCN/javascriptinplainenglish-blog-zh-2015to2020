<html>
<head>
<title>Making More Complex Requests with the Angular HTTP Client</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Angular HTTP客户端发出更复杂的请求</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/making-more-complex-requests-with-the-angular-http-client-2ff621b5c61?source=collection_archive---------4-----------------------#2020-04-23">https://javascript.plainenglish.io/making-more-complex-requests-with-the-angular-http-client-2ff621b5c61?source=collection_archive---------4-----------------------#2020-04-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/92278069eb258d5d2caa7b3d95999944.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0FOLw5iFaElAZjQE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@aa_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrew Alexander</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4c6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular是Google制作的一个流行的前端框架。像其他流行的前端框架一样，它使用基于组件的架构来构建应用程序。</p><p id="712d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何使用Angular的HTTP客户端发出更复杂的HTTP请求。</p><h1 id="2c21" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">请求非JSON数据</h1><p id="022b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用Angular的HTTP客户端请求非JSON数据。</p><p id="6096" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们将<code class="fe me mf mg mh b">responseType</code>选项设置为<code class="fe me mf mg mh b">'text'</code>。我们可以这样做:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="692d" class="mq lc iq mh b gy mr ms l mt mu">import { Component } from "@angular/core";<br/>import { HttpClient } from "@angular/common/http";<br/>import { tap } from "rxjs/operators";</span><span id="e09f" class="mq lc iq mh b gy mv ms l mt mu">@Component({<br/>  selector: "app-root",<br/>  templateUrl: "./app.component.html",<br/>  styleUrls: ["./app.component.css"]<br/>})<br/>export class AppComponent {<br/>  constructor(private http: HttpClient) { }</span><span id="e20d" class="mq lc iq mh b gy mv ms l mt mu">  ngOnInit() {<br/>    this.getText();<br/>  }</span><span id="5bb6" class="mq lc iq mh b gy mv ms l mt mu">  getText() {<br/>    this.http<br/>      .get("https://www.w3.org/TR/PNG/iso_8859-1.txt", { responseType: "text" })<br/>      .pipe(tap(data =&gt; console.log(data), error =&gt; console.log(error)))<br/>      .subscribe(res =&gt; console.log(res));<br/>  }<br/>}</span></pre><p id="2a0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们传入了一个将<code class="fe me mf mg mh b">responseType</code>设置为<code class="fe me mf mg mh b">'text'</code>的对象。</p><p id="557c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe me mf mg mh b">tap</code>操作符来查看得到的响应。</p><p id="27e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">subscribe</code>来获得响应并再次记录。</p><h1 id="87ca" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">错误处理</h1><p id="8177" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果有任何问题，我们可以处理由HTTP请求引起的错误。</p><p id="9366" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们将一个错误处理程序作为第二个参数传递给<code class="fe me mf mg mh b">subscribe</code>，如下所示:</p><p id="22bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">app.component.html</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cd3d" class="mq lc iq mh b gy mr ms l mt mu">import { Component } from "@angular/core";<br/>import { HttpClient } from "@angular/common/http";<br/>@Component({<br/>  selector: "app-root",<br/>  templateUrl: "./app.component.html",<br/>  styleUrls: ["./app.component.css"]<br/>})<br/>export class AppComponent {<br/>  constructor(private http: HttpClient) { }<br/>  ngOnInit() {<br/>    this.getPost();<br/>  }</span><span id="fdb7" class="mq lc iq mh b gy mv ms l mt mu">  getPost() {<br/>    this.http<br/>      .get("https://jsonplaceholder.typicode.com/posts/1")<br/>      .subscribe(res =&gt; console.log(res), err =&gt; console.log(err));<br/>  }<br/>}</span></pre><h1 id="12f2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取错误详细信息</h1><p id="62c3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过创建一个错误处理程序来获得错误的细节，然后将它传递给<code class="fe me mf mg mh b">catchError</code>操作符，如下所示:</p><p id="ac50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">app.component.ts</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="495e" class="mq lc iq mh b gy mr ms l mt mu">import { Component } from "@angular/core";<br/>import { HttpClient, HttpErrorResponse } from "@angular/common/http";<br/>import { catchError } from "rxjs/operators";<br/>import { throwError } from 'rxjs';</span><span id="2ce6" class="mq lc iq mh b gy mv ms l mt mu">@Component({<br/>  selector: "app-root",<br/>  templateUrl: "./app.component.html",<br/>  styleUrls: ["./app.component.css"]<br/>})<br/>export class AppComponent {<br/>  constructor(private http: HttpClient) { }<br/>  ngOnInit() {<br/>    this.getPost();<br/>  }<br/>  getPost() {<br/>    this.http<br/>      .get("https://jsonplaceholder.typicode.com/posts/1")<br/>      .pipe(<br/>        catchError(this.handleError)<br/>      );<br/>  }</span><span id="6967" class="mq lc iq mh b gy mv ms l mt mu">  private handleError(error: HttpErrorResponse) {<br/>    if (error.error instanceof ErrorEvent) {<br/>      console.error('An error occurred:', error.error.message);<br/>    }<br/>    else {<br/>      console.error(<br/>        `${error.status} ${error.error}`);<br/>    }<br/>    return throwError('error');<br/>  }<br/>}</span></pre><p id="e9a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有一个<code class="fe me mf mg mh b">handleError</code>方法，它接受一个<code class="fe me mf mg mh b">HttpErrorResponse</code>对象。</p><p id="e73f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从中我们可以检查<code class="fe me mf mg mh b">error</code>的<code class="fe me mf mg mh b">error</code>属性是否是<code class="fe me mf mg mh b">ErrorEvent</code>的实例。</p><p id="6ce9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是，那么我们记录消息。</p><p id="00b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们记录状态代码和错误。在每种情况下，我们用<code class="fe me mf mg mh b">throwError</code>再次抛出错误。</p><h1 id="adc6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">再试</h1><p id="58cf" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用可观测量的好处之一是我们可以重试它们。</p><p id="87b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以使用Rxjs <code class="fe me mf mg mh b">retry</code>运算符，如下所示:</p><p id="7603" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">app.component.ts</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7760" class="mq lc iq mh b gy mr ms l mt mu">import { Component } from "@angular/core";<br/>import { HttpClient, HttpErrorResponse } from "@angular/common/http";<br/>import { catchError, retry } from "rxjs/operators";<br/>import { throwError } from 'rxjs';</span><span id="0b9f" class="mq lc iq mh b gy mv ms l mt mu">@Component({<br/>  selector: "app-root",<br/>  templateUrl: "./app.component.html",<br/>  styleUrls: ["./app.component.css"]<br/>})<br/>export class AppComponent {<br/>  constructor(private http: HttpClient) { }<br/>  ngOnInit() {<br/>    this.getPost();<br/>  }<br/>  getPost() {<br/>    this.http<br/>      .get("https://jsonplaceholder.typicode.com/posts/1")<br/>      .pipe(<br/>        retry(3),<br/>        catchError(this.handleError)<br/>      );<br/>  }</span><span id="ae8b" class="mq lc iq mh b gy mv ms l mt mu">  private handleError(error: HttpErrorResponse) {<br/>    if (error.error instanceof ErrorEvent) {<br/>      console.error('An error occurred:', error.error.message);<br/>    }<br/>    else {<br/>      console.error(<br/>        `${error.status} ${error.error}`);<br/>    }<br/>    return throwError('error');<br/>  }<br/>}</span></pre><p id="49b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们添加了<code class="fe me mf mg mh b">retry</code>操作符，并将重试次数作为参数传递给函数。</p><p id="c1f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当请求失败时，它最多会重试3次。</p><h1 id="63b0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">HTTP标题</h1><p id="5f68" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">HttpHeaders</code>构造函数发送消息头。</p><p id="e0e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用它，我们只需传入一个带有标题键和值的对象。我们可以如下使用它:</p><p id="7b5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">app.component.ts</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3ff2" class="mq lc iq mh b gy mr ms l mt mu">import { Component } from "@angular/core";<br/>import { HttpClient, HttpHeaders } from "@angular/common/http";</span><span id="8a72" class="mq lc iq mh b gy mv ms l mt mu">@Component({<br/>  selector: "app-root",<br/>  templateUrl: "./app.component.html",<br/>  styleUrls: ["./app.component.css"]<br/>})<br/>export class AppComponent {<br/>  constructor(private http: HttpClient) { }</span><span id="8451" class="mq lc iq mh b gy mv ms l mt mu">  ngOnInit() {<br/>    this.getPost();<br/>  }</span><span id="58ec" class="mq lc iq mh b gy mv ms l mt mu">  getPost() {<br/>    const httpOptions = {<br/>      headers: new HttpHeaders({<br/>        "Content-Type": "application/json"<br/>      })<br/>    };</span><span id="73f2" class="mq lc iq mh b gy mv ms l mt mu">    this.http<br/>      .get("https://jsonplaceholder.typicode.com/posts/1", httpOptions)<br/>      .subscribe(res =&gt; console.log(res));<br/>  }<br/>}</span></pre><p id="be96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们通过传递一个带有我们想要发送的请求头的对象来创建<code class="fe me mf mg mh b">HttpHeaders</code>对象。然后我们用object作为值设置<code class="fe me mf mg mh b">headers</code>属性。</p><p id="0c4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe me mf mg mh b">httpOptions</code>作为<code class="fe me mf mg mh b">get</code>方法的第二个参数传入。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/9a28425ee4f9186f74b11314104b00eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gEer2qywiDrZUhjF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@tinamosquito?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kristina Tripkovic</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a337" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">提出发布请求</h1><p id="c273" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用与GET请求相似的方式发出POST请求。<code class="fe me mf mg mh b">post</code>方法将URL作为第一个参数，将请求体作为第二个参数，将其他请求选项作为第三个参数。</p><p id="d82d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码来发出请求:</p><p id="cfcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">app.component.ts</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a0f3" class="mq lc iq mh b gy mr ms l mt mu">import { Component } from "@angular/core";<br/>import { HttpClient, HttpHeaders } from "@angular/common/http";<br/>import { Post } from "./post";</span><span id="8cf6" class="mq lc iq mh b gy mv ms l mt mu">@Component({<br/>  selector: "app-root",<br/>  templateUrl: "./app.component.html",<br/>  styleUrls: ["./app.component.css"]<br/>})<br/>export class AppComponent {<br/>  constructor(private http: HttpClient) {}<br/>  ngOnInit() {<br/>    this.addPost();<br/>  }</span><span id="f488" class="mq lc iq mh b gy mv ms l mt mu">  addPost() {<br/>    const body = {<br/>      userId: 1,<br/>      title: "title",<br/>      body: "body"<br/>    };</span><span id="8773" class="mq lc iq mh b gy mv ms l mt mu">    const httpOptions = {<br/>      headers: new HttpHeaders({<br/>        "Content-Type": "application/json"<br/>      })<br/>    };</span><span id="e845" class="mq lc iq mh b gy mv ms l mt mu">    this.http<br/>      .post&lt;Post&gt;(<br/>        "https://jsonplaceholder.typicode.com/posts/",<br/>        body,<br/>        httpOptions<br/>      )<br/>      .subscribe(res =&gt; console.log(res));<br/>  }<br/>}</span></pre><p id="30ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有<code class="fe me mf mg mh b">body</code>对象，它作为第二个参数传入，是POST请求的请求体。</p><p id="7e90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么第三个参数是带有<code class="fe me mf mg mh b">headers</code>的<code class="fe me mf mg mh b">httpOptions</code>。</p><h1 id="6978" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="5c1b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过将<code class="fe me mf mg mh b">responseType</code>选项设置为<code class="fe me mf mg mh b">true</code>来获取非JSON数据。</p><p id="9fea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了处理错误，我们可以向<code class="fe me mf mg mh b">subscribe</code>方法传递一个错误处理程序。</p><p id="d383" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了获得错误的细节，我们可以使用带有回调函数的<code class="fe me mf mg mh b">catchError</code>操作符，该回调函数接受<code class="fe me mf mg mh b">error</code>对象，然后我们可以对它做任何我们想做的事情。</p><p id="ff89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过创建一个<code class="fe me mf mg mh b">HttpHeaders</code>对象并将它作为一个选项传入来为请求添加请求头。</p><p id="61b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">发出POST请求类似于GET请求。唯一的区别是我们将一个body对象作为第二个参数传入。请求选项作为第三个参数传递给<code class="fe me mf mg mh b">post</code>方法。</p><h2 id="5230" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="fe09" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="ff81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>