<html>
<head>
<title>5 JavaScript Functional Programming Concepts that You Should Know</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你应该知道的5个JavaScript函数式编程概念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-javascript-functional-programming-concepts-that-you-should-know-c96f14b02a87?source=collection_archive---------5-----------------------#2020-11-11">https://javascript.plainenglish.io/5-javascript-functional-programming-concepts-that-you-should-know-c96f14b02a87?source=collection_archive---------5-----------------------#2020-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f8a9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">带有实际例子的函数式编程概念</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7078a52f6a366a02a410970fd5d99d2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*11YvaHabAYevtUv1"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@thisisengineering?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">ThisisEngineering RAEng</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d4fa" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是函数式编程？</h1><p id="00f0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">函数式编程是一种基于在程序中使用函数的编码风格。它是一种基于功能评估的软件开发方法。它将程序分成小的、可测试的部分。你可以用多种方式组合基本功能来构建越来越复杂的程序。</p><p id="2b53" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">函数式编程遵循几个核心原则，其中一个原则是函数独立于程序的状态或全局变量。它们依赖于传递给它们的参数。函数式编程的另一个原则是函数在程序中的副作用最小。除此之外，他们试图限制对程序状态的任何更改，避免对保存数据的全局对象的更改。</p><p id="9bd7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本文中，我们将探索JavaScript中一些有用的函数式编程概念。让我们开始吧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/a66bcd345461e3a0c372dba7d49395c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OrA0skba2HN6lvI1Pu8SsA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image Created With❤️️ By Mehdi Aoussiad.</figcaption></figure><h1 id="1cf1" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">1.纯函数</h1><p id="9adb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">纯函数是这样一种函数，它对于输入返回相同的输出，而不修改超出其范围的任何内容。看看下面的例子:</p><p id="cdcc" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第一版:</strong></p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="bcc8" class="mv kx iq mr b gy mw mx l my mz">let age = 19<br/><br/>function getMyAge() {<br/>  console.log(`I'm ${age} years old.`)<br/>}<br/><br/>getMyAge(age) //Returns: <!-- -->I'm 19 years old.<br/>age = 20<br/>getMyAge(age) //Returns: <!-- -->I'm 20 years old.</span></pre><p id="caef" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">第二版:</strong></p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7c4e" class="mv kx iq mr b gy mw mx l my mz">function getMyAge(age) {<br/>  return `I'm ${age} years old.`<br/>}<br/><br/>getMyAge(19) //Returns: <!-- -->I'm 19 years old.<br/>getMyAge(20) //Returns: <!-- -->I'm 20 years old.</span></pre><p id="8139" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在第一个版本中，函数在你的范围之外寻找一个变量，以某种方式改变世界。在这种情况下，输出，理想的是只返回值，如果我们调用函数，用相同的参数(甚至没有参数)，我们得到一个不同的值。在一个纯函数中，这种情况不会发生，因为它只依赖于它的输入和参数。</p><h1 id="33e5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">2.副作用</h1><p id="d233" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">副作用是在计算过程中发生的与外界的任何相互作用，这在纯函数中是不会发生的。我们的代码可以更加可预测，因为结果只取决于他们的输入。如果我们知道我们的函数看起来如何，以及它接收哪些输入，我们就可以预测结果。看看下面的例子:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="cb40" class="mv kx iq mr b gy mw mx l my mz">var double = function(value){<br/>    return value * 2;<br/>}</span><span id="ed34" class="mv kx iq mr b gy na mx l my mz">var initialValue = 30;<br/>double(initialValue); // 60</span><span id="c14e" class="mv kx iq mr b gy na mx l my mz">initialValue; // Still 30.</span></pre><h1 id="ca36" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">3.易变性</h1><p id="a01d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">突变是关于事物是可变的。在函数式编程中，不鼓励可变性。当我们有不可变的数据时，它的状态在你创建它之后不能改变。如果你需要改变什么，你就必须创造新的价值。</p><p id="30d6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">易变的例子:</strong></p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="3232" class="mv kx iq mr b gy mw mx l my mz">function changeFirstElem(array) {<br/>  array[0] = 'Lose yourself to dance'<br/>}<br/><br/>const daftPunkPopSongs = ['Instant Crush', 'Get Lucky', 'One More Time'];<br/>changeFirstElem(daftPunkPopSongs);<br/>console.log(daftPunkPopSongs); // <!-- -->["Lose yourself to dance", "Get Lucky", "One More Time"].</span></pre><p id="ff79" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">不可变的例子:</strong></p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="de79" class="mv kx iq mr b gy mw mx l my mz">function changeFirstElem(array) {<br/>  const modifiedArray = ['Lose yourself to dance', ...array];<br/>  return modifiedArray;<br/>}<br/><br/>const daftPunkPopSongs = ['Instant Crush', 'Get Lucky', 'One More Time'];<br/>const modifiedArray = changeFirstElem(daftPunkPopSongs);</span><span id="c405" class="mv kx iq mr b gy na mx l my mz">Console.log(<!-- -->daftPunkPopSongs); // Returns: ['Instant Crush', 'Get Lucky', 'One More Time'].</span></pre><p id="774a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这太棒了。在第二个例子中，我们让事情变得更安全，更难在代码中找到bug。如果输出是错误的，我们肯定问题出在我们的函数上，而不是因为随机的交互。这将使调试我们的代码更加容易。</p><h1 id="4b8f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">4.高阶函数</h1><p id="98d8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">任何以另一个函数为自变量的函数都称为<strong class="lq ir">高阶函数。JavaScript提供了一些有用的高阶函数来以一种简单的方式操作数据。</strong></p><p id="c347" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">以下是一些你应该知道的重要功能:</p><p id="117d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"> map </strong>方法有助于传递一个函数来转换数组中的每一项。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="d46d" class="mv kx iq mr b gy mw mx l my mz">const numbers = [1, 2, 3];<br/>const doubles = numbers.map(num =&gt; num * 2) //[2, 4, 6]</span></pre><p id="743e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">过滤器</strong>接收一个数据集合，您可以传递一个返回集合子集的条件函数。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="77f1" class="mv kx iq mr b gy mw mx l my mz">const numbers = [1, 2, 3];<br/>const isGreaterThanOne = numbers.filter(num =&gt; num &gt; 1) //[2, 3]</span></pre><p id="e21a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir"> reduce </strong>方法采用一个带有两个参数(累加器和项)的函数。我们还可以使用reduce方法返回所有数组项的总数，如下例所示。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="249f" class="mv kx iq mr b gy mw mx l my mz">const numbers = [1, 2, 3];<br/>const mySum = numbers.reduce((accumulator, num) =&gt; accumulator + num) // returns: 6.</span></pre><h1 id="9d3c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">5.固化和局部应用</h1><p id="6326" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">Currying一个函数意味着把它从一个有几个参数的函数转换成几个只有一个参数的函数。看看下面的例子:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b308" class="mv kx iq mr b gy mw mx l my mz">//Un-curried function<br/>function unCurried(x, y) {<br/>  return x + y;<br/>}<br/><br/>//Curried function<br/>function curried(x) {<br/>  return function(y) {<br/>    return x + y;<br/>  }<br/>}<br/>//Alternative using ES6<br/>const curried = x =&gt; y =&gt; x + y<br/><br/>curried(1)(2) // Returns 3</span></pre><p id="e380" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果你不能一次给一个函数提供所有的参数，Currying在你的程序中是有用的。</p><p id="12cb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">现在我们来看一下<strong class="lq ir">部分应用</strong>，可以描述为一次对一个函数应用几个参数，返回另一个应用到更多参数的函数。这里有一个例子:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="0f12" class="mv kx iq mr b gy mw mx l my mz">//Impartial function<br/>function impartial(x, y, z) {<br/>  return x + y + z;<br/>}<br/>var partialFn = impartial.bind(this, 1, 2);<br/>partialFn(10); // Returns 13</span></pre><h1 id="3d2c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="ede5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">函数式编程是一个好习惯。它使您的代码易于管理，并使您免于偷偷摸摸的错误。当使用JavaScript或其他编程语言时，这是一种强大的方法。</p><p id="a9a9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢您阅读本文，希望您觉得有用。如果有，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="lq ir">！</strong></p><h1 id="e6a9" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">更多阅读</h1><div class="nb nc gp gr nd ne"><a href="https://medium.com/javascript-in-plain-english/5-fun-apis-for-your-next-javascript-projects-1834626864c" rel="noopener follow" target="_blank"><div class="nf ab fo"><div class="ng ab nh cl cj ni"><h2 class="bd ir gy z fp nj fr fs nk fu fw ip bi translated">为您的下一个JavaScript项目准备的5个有趣的API</h2><div class="nl l"><h3 class="bd b gy z fp nj fr fs nk fu fw dk translated">您可以在JavaScript项目中使用的5个有用的API</h3></div><div class="nm l"><p class="bd b dl z fp nj fr fs nk fu fw dk translated">medium.com</p></div></div><div class="nn l"><div class="no l np nq nr nn ns kp ne"/></div></div></a></div></div></div>    
</body>
</html>