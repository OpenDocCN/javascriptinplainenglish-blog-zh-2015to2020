<html>
<head>
<title>Let’s Build a MongoDB + Express + React + GraphQL + Relay Modern Full Stack Web App (From Scratch!) — Front End Part</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们构建一个MongoDB+Express+React+graph QL+Relay Modern全栈Web App(从零开始！)—前端部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-build-a-mongodb-express-react-graphql-relay-modern-full-stack-web-app-from-scratch-d41b5091d41d?source=collection_archive---------1-----------------------#2020-01-28">https://javascript.plainenglish.io/lets-build-a-mongodb-express-react-graphql-relay-modern-full-stack-web-app-from-scratch-d41b5091d41d?source=collection_archive---------1-----------------------#2020-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/f9a0b8a0894f4922c372d7e490ecccb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*RG2n787iuQVANYUwQrp3qw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">React x Relay x GraphQL</figcaption></figure><blockquote class="jy jz ka"><p id="6528" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">欢迎回到这篇完整的web stack文章的第二部分。你可以在下面的链接中找到第一个。</p><p id="842c" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://medium.com/javascript-in-plain-english/lets-build-a-mongodb-express-react-graphql-relay-modern-full-stack-web-app-from-scratch-a4ae3aaf212" rel="noopener">本文第一部分。使用Graphql + Express </a>设置后端。</p></blockquote></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><blockquote class="jy jz ka"><p id="6984" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我使用Heroku部署了web应用程序<a class="ae la" href="http://medium-front-end-client.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">的最终版本。加载web app时请耐心等待。当网站闲置一段时间后，Heroku会启动服务器。和平！:-)</a></p></blockquote><h2 id="e899" class="li lj iq bd lk ll lm dn ln lo lp dp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">我们开始吧</h2><p id="62d0" class="pw-post-body-paragraph kb kc iq ke b kf me kh ki kj mf kl km lr mg kp kq lv mh kt ku lz mi kx ky kz ij bi translated">现在我们的后端已经可以使用了，让我们开始使用React和Relay Modern配置我们的前端应用程序。</p><p id="9881" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">第一步是使用<a class="ae la" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank"> create-react-app </a>创建我们的应用程序。找到您希望我们的前端存在的目录，并在命令行中键入以下内容。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="f4e9" class="li lj iq mo b gy ms mt l mu mv">npx create-react-app notes-frontend<br/>cd notes-frontend<br/>git init</span></pre><p id="a80e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">现在，我要你在开始之前删除一些文件和代码行。这只是为了去掉一些我们在本文中不需要的东西。为了做到这一点，像这样构造前端目录。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/aa9e74c494d3536c539a7d9f256fe34f.png" data-original-src="https://miro.medium.com/v2/resize:fit:728/format:webp/1*f2vuAqULZkcnbSApwv3XAw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">front end folder structure</figcaption></figure><p id="87a8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">然后，从App.js和index.js中删除一些导入，使它们看起来像这样。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi mx"><img src="../Images/e925872ff340a581c623f3b06d773a9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZXBSTW7bL3PA_oIdxBSzog.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">src/index.js</figcaption></figure><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/35863bfa2d80e20bedc9a2b474168dba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1332/format:webp/1*Wk2vuiMxaC9putmFVi9a0w.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">src/App.js</figcaption></figure><p id="5cfa" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">现在，通过运行yarn start we并在浏览器中键入localhost:3000，我们可以看到我们的前端已经准备好进行一些编码了！下一步是退出我们的应用程序，这样我们就可以配置babel和webpack，这样它就可以将我们的graphQL和中继代码转换成JavaScript。要做到这一点，请运行以下命令。我们只需提交我们最近的更改，以便退出应用程序。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="e103" class="li lj iq mo b gy ms mt l mu mv">git add . <br/>git commit -m "initial commit"<br/>yarn run eject <br/>y</span></pre><p id="2394" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">弹出应用程序后，让我们安装所需的依赖项，以便将relay和graphQL集成到react应用程序中。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="7dcc" class="li lj iq mo b gy ms mt l mu mv">yarn add babel-plugin-relay graphql relay-config relay-compiler</span></pre><p id="f45c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">然后，在我们app的根目录下。创建一个名为<code class="fe nd ne nf mo b">relay.config.js</code>的文件，将以下代码放入该文件中。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="9e47" class="li lj iq mo b gy ms mt l mu mv">// relay.config.js </span><span id="c8e8" class="li lj iq mo b gy ng mt l mu mv">module.exports = {   <br/>    src: "./src",   <br/>    schema: "./data/schema.graphql",   <br/>    exclude: ["**/node_modules/**", "**/__mocks__/**",<br/>        "**/__generated__/**"], <br/>    }</span></pre><p id="5b3b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">然后去我们app的<code class="fe nd ne nf mo b">package.json</code>。找到package.json中的babel键，然后将其改为下面的代码。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/507e1474e4b911083c514750c2b7d611.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*2x2BHbjR3N75ytEpptQ0cg.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">package.json babel</figcaption></figure><p id="0ea3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">既然这部分已经完成了，我将解释一些事情，关于我们为什么这样配置我们的代码。这只是将我们的relay和graphQL转换成浏览器能够理解的代码。Babel和webpack就是这样做的，这样我们的开发人员就不需要花太多时间配置太多样板文件，我们就可以专注于我们应用程序的编码功能。</p><p id="2bb7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">您可能已经注意到，为了继续，我们需要一个<code class="fe nd ne nf mo b">schema.graphql</code>文件。这个文件是我们前端数据的表示，这就是为什么relay比大多数数据管理库都要快，因为它已经知道了它所期望的数据。这是我们在前一篇文章中创建的服务器上的模式副本。将它复制并粘贴到一个名为<code class="fe nd ne nf mo b">schema.graphql</code>的文件中，并放在我们应用程序根目录下一个名为<code class="fe nd ne nf mo b">data</code>的文件夹中。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/916aac09053afa9277467f4253139fb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:708/format:webp/1*2nKamy5gF9i6gaBf9s6Zsg.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">schema.graphql in data</figcaption></figure><p id="afc4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">如果您想知道我是如何从我们的服务器获得模式的，请到github 中我们的<a class="ae la" href="https://github.com/jelorivera08/MERG-BE" rel="noopener ugc nofollow" target="_blank">后端的repo，查看一下config目录中的printSchema.js文件。</a></p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">schema.graphql</figcaption></figure><p id="a4e4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">然后，每当我们修改graphql查询时，我们需要手动重新编译我们的前端。像这样修改package.json中的脚本。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi nl"><img src="../Images/58f9e1dd8931239359ffc350ff9ca608.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q_V1fPo1-liLIkyQ2IytAA.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">scrips in package.json</figcaption></figure><h1 id="b2c3" class="nm lj iq bd lk nn no np ln nq nr ns lq nt nu nv lu nw nx ny ly nz oa ob mc oc bi translated">为服务器查询设置我们的graphQL</h1><p id="5a6b" class="pw-post-body-paragraph kb kc iq ke b kf me kh ki kj mf kl km lr mg kp kq lv mh kt ku lz mi kx ky kz ij bi translated">是时候设置一些代码了，这样我们就可以发送和接收来自服务器的查询。继电器需要一个“环境”设置，以做到这一点和更多。在我们的应用程序的src目录中创建一个名为<code class="fe nd ne nf mo b">environment.js</code>的文件，然后将下面的代码粘贴到该文件中。</p><figure class="mj mk ml mm gt jr"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">src/environment.js</figcaption></figure><p id="05b3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">然后让我们把我们的<code class="fe nd ne nf mo b">App.js</code>移动到一个名为App的目录中，其文件夹结构如下。创建在下面的文件夹结构中陈述的文件，然后使用我将为下面的文件链接的要点分别键入代码。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/86f0585ef0e188ce7603e81d9c6413eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1096/format:webp/1*fCgh5mj6jw4xou67dXN3ng.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">folder structure for App</figcaption></figure><ul class=""><li id="7397" class="oe of iq ke b kf kg kj kk lr og lv oh lz oi kz oj ok ol om bi translated"><a class="ae la" href="https://gist.github.com/jelorivera08/f2c480c20fdabf7fadacda982c8f7ca8" rel="noopener ugc nofollow" target="_blank"> src/App/App.js </a></li><li id="b2ee" class="oe of iq ke b kf on kj oo lr op lv oq lz or kz oj ok ol om bi translated"><a class="ae la" href="https://gist.github.com/jelorivera08/393c98f71cd534f965e6a34f4451075e" rel="noopener ugc nofollow" target="_blank">src/containers/main page/index . js</a></li><li id="e5aa" class="oe of iq ke b kf on kj oo lr op lv oq lz or kz oj ok ol om bi translated"><a class="ae la" href="https://gist.github.com/jelorivera08/51514d05d39fbaf289c58cf692cf9fb1" rel="noopener ugc nofollow" target="_blank">src/containers/main page/mutations/create note . js</a></li><li id="2263" class="oe of iq ke b kf on kj oo lr op lv oq lz or kz oj ok ol om bi translated"><a class="ae la" href="https://gist.github.com/jelorivera08/cba7496ad28a7cbc7a715f772dfc7353" rel="noopener ugc nofollow" target="_blank">src/containers/main page/mutations/update note . js</a></li><li id="7cc1" class="oe of iq ke b kf on kj oo lr op lv oq lz or kz oj ok ol om bi translated"><a class="ae la" href="https://gist.github.com/jelorivera08/b41b496b367c7e4f127d3bfc947cadd6" rel="noopener ugc nofollow" target="_blank">src/containers/main page/mutations/delete note . js</a></li></ul><p id="bbd1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">这样做之后，将根目录下的index.js中的导入代码更改为以下代码。</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="16e8" class="li lj iq mo b gy ms mt l mu mv">...<br/>import App from "./App/App";<br/>...</span></pre><p id="5857" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">搞定了。当您使用运行我们的应用程序时</p><pre class="mj mk ml mm gt mn mo mp mq aw mr bi"><span id="6132" class="li lj iq mo b gy ms mt l mu mv">yarn run relay<br/>yarn run start</span></pre><p id="6626" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">您应该已经看到了在localhost:3000上运行的应用程序。</p><p id="7b0d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">现在，我将简要解释一下您刚才在突变和查询中键入的一些代码。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi os"><img src="../Images/f67efd6fc9c31a9981d87e2beeb34936.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P7ESxodV7pp9ZLiCWypiCQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Query using Relay</figcaption></figure><p id="5e39" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">您可以在QueryRenderer组件的查询属性中找到graphQL查询。在这里，我们在数据库中查询我们的笔记。一旦数据准备好了，我们就把数据传递给主页组件，让它处理渲染。主页应用程序只有基本的react组件，所以我不会深入讨论。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="my mz di na bf nb"><div class="gh gi ot"><img src="../Images/c4f21c11d86721964d7a5a2358c3f71d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h7iRZo937TtQmjcclLrPkw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Relay Mutations</figcaption></figure><p id="8233" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">这是我希望我们关注的。使用中继的变异使用提交变异。通过使用我们的服务器<code class="fe nd ne nf mo b">createNote</code>创建的graphQL变异，我们将它与所有变量一起传递到commitMutation API，然后我们传递一个updater函数，在其中更新我们应用程序的本地状态。这里，我们将新创建的注释添加到中继存储的本地状态中，这样当我们成功创建一个注释时就可以显示它。</p><p id="3f5d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lr ko kp kq lv ks kt ku lz kw kx ky kz ij bi translated">updateNoteMutation和deleteNoteMutation的功能相同。我会把这些留给你。只要你继续阅读graphQL和Relay的文档，这将是小菜一碟。</p><h1 id="3481" class="nm lj iq bd lk nn no np ln nq nr ns lq nt nu nv lu nw nx ny ly nz oa ob mc oc bi translated">搞定了。</h1><p id="35ed" class="pw-post-body-paragraph kb kc iq ke b kf me kh ki kj mf kl km lr mg kp kq lv mh kt ku lz mi kx ky kz ij bi translated">我希望这篇文章能帮助你理解这些新技术试图传达的不同思想。我将把前端的git repo链接留给你，这样如果你在阅读本文时遇到问题，你可以试着运行它，<a class="ae la" href="https://github.com/jelorivera08/MERG-FE" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><blockquote class="jy jz ka"><p id="6aed" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">谢谢你。</p></blockquote></div></div>    
</body>
</html>