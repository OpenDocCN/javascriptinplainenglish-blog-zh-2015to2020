<html>
<head>
<title>Node Application Directory Structure</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">节点应用程序目录结构</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-application-directory-structure-dfe1ae97891d?source=collection_archive---------4-----------------------#2020-08-06">https://javascript.plainenglish.io/node-application-directory-structure-dfe1ae97891d?source=collection_archive---------4-----------------------#2020-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d25a1ae13d913571f9102289dbf17d95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3lB0tzE2NuMJlbYp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="589b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建最初几个基于节点的应用程序时，面临的挑战之一是确定将代码所在的文件放在哪里。这是一个挑战，因为很少有“这样做”的说法。取而代之的是一些建议和指导方针，或者教程以某种特定的方式去做而不解释为什么。</p><p id="3d7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Node的特点是它实际上更喜欢软件的<a class="ae kc" href="https://en.wikipedia.org/wiki/Software_design_pattern" rel="noopener ugc nofollow" target="_blank">设计模式</a>和<a class="ae kc" href="https://en.wikipedia.org/wiki/Category:Programming_principles" rel="noopener ugc nofollow" target="_blank">设计原则</a>。将这些模式和原则应用到我们自己的应用程序中也是一个好主意。我发现，当我偏离了已被证实的原则(在这些原则适用的地方)，我的代码往往会很快变得“丑陋”(更复杂、更难操作、更难维护，等等)。)</p><p id="f949" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你选择使用的模块也可能建议一种组织文件的方法。例如，使用<a class="ae kc" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Express </strong> </a>创建一个重要的应用程序几乎总是以“routes”文件夹结束。使用<a class="ae kc" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> Knex。JS </strong> </a>经常会产生一个“模型”和“迁移”文件夹。这些模块能够与通用设计模式和谐地工作，正是因为它们被广泛地使用和改进。</p><p id="bab7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们开始时，我们需要的唯一“真正的”文件夹是一个项目目录。这是我们放置<code class="fe lb lc ld le b">package.json</code>文件和应用程序的任何其他文件的地方。我们经常看到用如下命令创建的基本结构:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="25d0" class="ln lo iq le b gy lp lq l lr ls">mkdir myProject<br/>cd myProject<br/>npm init -y</span></pre><p id="86d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">惯例在这里也起了作用。大多数节点项目在<code class="fe lb lc ld le b">project.json</code>文件旁边会有一个<code class="fe lb lc ld le b">src</code>目录。很多库和工具都希望这样，但是Node本身并没有说这是绝对必需的。惯例可能是一件好事——它带来了共同的理解，使思想交流更加容易。在某些情况下，它可以让“魔法”发生，但只有以特定的方式。但是约定有时会与应用程序需求甚至其他需要的模块发生冲突。</p><p id="ca7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lt">“标准的好处是你有太多的选择”——安德鲁·塔宁鲍姆</em></p><p id="1398" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于Node，我们经常使用模块。一个模块<em class="lt">根据需要需要</em>其他模块。所需的模块要么是已安装的模块— <code class="fe lb lc ld le b">require('express')</code>要么是我们系统中的一个路径，当第一个字符是点<code class="fe lb lc ld le b">require('../models/widget.js')</code>时被识别。所需模块的路径是相对于当前模块的。在需要的地方，可以使用内置路径模块来确保使用正确的路径(以及跨平台的路径)。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="8b46" class="ln lo iq le b gy lp lq l lr ls">const path = require('path')<br/>const WidgetModel = require(path.resolve(__dirname, '../models/widget.js'))</span></pre><p id="31e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们指定了模块的路径，所以我们选择的目录结构几乎是我们想要的。为了避免混乱，我们应用设计原则和一些常识来建议一个合理的目录结构。</p><p id="bb96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，当我创建一个需要数据访问模型的基于Express的API时，我可能会得到这样的结构:</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/bdfcd32877b36b24585469b8bc4c1b6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:462/format:webp/1*DprbkcFhL76oeDkKTseNcA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Possible directory structure. (this is probably incomplete)</figcaption></figure><p id="bda5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里我有一个<strong class="kf ir">路由</strong>和<strong class="kf ir">中间件</strong>文件夹，用来存储一些Express的特定模块。然后我有一个<strong class="kf ir"> models </strong>目录来存储我的数据访问文件。最后，我有<strong class="kf ir">服务</strong>目录来存储我的业务逻辑。短语“服务”可以有其他的名称——“逻辑”、“商业智能”等等。但“服务”似乎是一个很好的收藏短语，并被业界广泛采用。</p><p id="cd2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的关键是使目录结构与应用程序的需求相匹配。你最了解这些需求，所以你可能会选择一些有意义的东西。尽可能应用设计原则也有助于定义所需的结构。最后，定义公共应用程序层也有助于确定需要什么文件夹。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/5cf792eeacc52723898cf379ba24c47d.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*hoRKO5TC-yE2t5Z1G_K6iA.png"/></div></figure><p id="97ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在你建立了一些应用程序之后，你需要的目录结构将会出现，这只是你没有真正考虑过的事情之一。当您使用其他项目或框架时，您会注意到一些有意义的约定或建议，您会尽可能地采用它们。(例如，我的数据访问模型受到了<a class="ae kc" href="https://laravel.com/" rel="noopener ugc nofollow" target="_blank"> Laravel </a>模型系统的影响。但那是不同的话题。)</p><p id="3156" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个高层次的讨论，但这里希望它能帮助你一些。如果我能澄清/纠正什么，请随时给我留言。</p><h2 id="d332" class="ln lo iq bd lw lx ly dn lz ma mb dp mc ko md me mf ks mg mh mi kw mj mk ml mm bi translated">简单英语的JavaScript</h2><p id="a1c6" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>