<html>
<head>
<title>Create a Parallax Background with Floating Cards using React &amp; Styled Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用反应和风格化组件创建带有浮动卡的视差背景</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-a-parallax-background-with-floating-cards-using-react-styled-components-69ccddb2515e?source=collection_archive---------4-----------------------#2020-12-07">https://javascript.plainenglish.io/create-a-parallax-background-with-floating-cards-using-react-styled-components-69ccddb2515e?source=collection_archive---------4-----------------------#2020-12-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/11b66feadd5e8e779f426550ff1a65e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EvyVBtr24-FMTeqM2B3M-g.png"/></div></div></figure><h2 id="baaf" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">我们将创造什么</strong></h2><p id="4780" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">这是成品的视频。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="b2fa" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">基本，但展示了一些很酷的东西。你有视差滚动效果，以及一些像浮动卡一样的奖励。</p><p id="de93" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">注意:本教程中使用的所有图像都可以在文章末尾找到。</p><h2 id="ba00" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">本教程的步骤</strong></h2><ol class=""><li id="fed0" class="ma mb iq kw b kx ky lb lc kh mc kl md kp me lo mf mg mh mi bi translated">在我们开始之前</li><li id="ace5" class="ma mb iq kw b kx mj lb mk kh ml kl mm kp mn lo mf mg mh mi bi translated">使用样式化组件创建全局样式</li><li id="f0b0" class="ma mb iq kw b kx mj lb mk kh ml kl mm kp mn lo mf mg mh mi bi translated">创建视差组件</li><li id="177a" class="ma mb iq kw b kx mj lb mk kh ml kl mm kp mn lo mf mg mh mi bi translated">创建卡组件</li></ol><p id="d22c" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated"><strong class="kw ir">开始前</strong></p><p id="ebad" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">确保你有一个安装了样式化组件库的基本的react应用程序。最简单的方法是打开一个终端并运行:</p><p id="a1d4" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated"><code class="fe mo mp mq mr b">npx create-react-app parallax</code></p><p id="141c" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">然后导航到新创建的<code class="fe mo mp mq mr b">parallax</code>文件夹并运行:</p><p id="0a3b" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated"><code class="fe mo mp mq mr b">npm i styled-components</code></p><p id="aeae" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">您可以通过直接CSS来实现，但是本教程将使用样式化的组件。</p><h2 id="9566" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">使用样式化组件创建全局样式</strong></h2><p id="7e29" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">现在，我们的应用程序可能已经应用了一些样式，即默认边距和填充应用于所有html文档。我们可以使用<code class="fe mo mp mq mr b">styled-components</code>中的<code class="fe mo mp mq mr b">createGlobalStyle</code>功能将其关闭。</p><p id="92e4" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">在您的顶级组件(我的是<code class="fe mo mp mq mr b">App.jsx</code>)中，写下以下内容:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="ms lu l"/></div></figure><p id="bd89" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">现在<code class="fe mo mp mq mr b">createGlobalStyle</code>中定义的样式将应用于整个文档。</p><h2 id="5959" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">创建视差组件</strong></h2><p id="7351" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">讽刺的是，视差部分可能是最简单的部分。我们甚至不需要为它创建适当的反应组件。相反，我们只使用一个基本样式的组件。</p><p id="c275" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">在我的项目中，我通常创建一个<code class="fe mo mp mq mr b">components</code>文件夹，然后在里面创建一个<code class="fe mo mp mq mr b">styled.js</code>文件来保存所有样式化的组件。因此，添加了视差组件后，<code class="fe mo mp mq mr b">components/styled.js</code>如下所示:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="ms lu l"/></div></figure><p id="2203" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">我们在第1行导入<code class="fe mo mp mq mr b">styled-components</code>库。然后，我们在第3行创建视差样式的组件，并使其成为<code class="fe mo mp mq mr b">div</code>。</p><p id="0141" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">在第4行，我们将视差组件的背景设置为图像。您可以在本文底部的参考资料部分找到我使用的背景图像。我把我的放在<code class="fe mo mp mq mr b">img</code>文件夹里。</p><p id="02a8" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">在第5行和第6行，我们告诉背景覆盖div的整个大小，然后告诉它不要滚动文档的其余部分。<code class="fe mo mp mq mr b">background-attachment: fixed</code>就是这么做的。</p><p id="4e85" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">然后，我们只需使div与视口的宽度相同。</p><p id="1efc" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">确保在<code class="fe mo mp mq mr b">App.jsx</code>中渲染你的新视差组件。我的现在看起来像这样。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="ms lu l"/></div></figure><p id="eccb" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">您不会看到太多，因为视差组件中没有任何内容。</p><h2 id="53cc" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><strong class="ak">创建卡片组件</strong></h2><p id="3a8f" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">Card组件负责呈现您在本文开头的演示视频中看到的盒子和图像。和以前一样，这一部分需要的所有图片都在下面的参考资料部分。</p><p id="c2e7" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">卡组件本身并不复杂。我已经存到<code class="fe mo mp mq mr b">components/Card/index.jsx</code>里了。看起来是这样的:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="ms lu l"/></div></figure><p id="9cb9" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">第2行的导入是我们稍后将创建的样式化组件。</p><p id="2057" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">道具是<code class="fe mo mp mq mr b">children</code>(这是我们将在卡片上看到的文本)，<code class="fe mo mp mq mr b">alignment</code>决定卡片将出现在页面的哪一面，<code class="fe mo mp mq mr b">img</code>是卡片应该使用的图像的路径。</p><p id="ded0" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">卡片组件的其余部分是样式，位于<code class="fe mo mp mq mr b">components/Card/styles.js</code>。这是:</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="ms lu l"/></div></figure><p id="5b5c" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">这里有很多，我们可以一点一点来。</p><h2 id="ac19" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><em class="mt">卡片容器</em></h2><p id="d8c3" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">组件是一个透明的div，作为卡片本身的包装器。这里有一张来自Chrome devtools的图片，应该会让它看起来更清楚。</p><figure class="lp lq lr ls gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mu"><img src="../Images/685e3d6540642ca22d9a513c670a62ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pK2KpuhCg67XaupZbraW-Q.png"/></div></div></figure><p id="5028" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">由于窗口的宽度，这张截图中的牌叠得更多。但是，正如你所希望看到的，<code class="fe mo mp mq mr b">CardContainer</code>只是创造了一个空间来容纳卡片，并通过一些填充将其与其他卡片分开。它也有<code class="fe mo mp mq mr b">position:relative</code>，所以我们可以使用css属性如<code class="fe mo mp mq mr b">left</code>和<code class="fe mo mp mq mr b">right</code>在里面放置卡片。</p><h2 id="1b2b" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><em class="mt">卡片内容</em></h2><p id="729c" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated"><code class="fe mo mp mq mr b">CardContent</code>样式的组件是渲染实际卡片本身的组件。我们从一些基本的东西开始，比如填充、背景色、宽度和高度。我们还设置了<code class="fe mo mp mq mr b">position:absolute</code>，这样我们就可以用<code class="fe mo mp mq mr b">left</code>和<code class="fe mo mp mq mr b">right</code>对其进行定位。然后我们给它一个指针，这样它就像一个链接。</p><p id="995b" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">在第19行，我们使用<em class="mv">插值</em>来获得我们传递给<code class="fe mo mp mq mr b">CardContent</code>组件的道具。这与在javscript字符串中插入变量是一样的，就像so <code class="fe mo mp mq mr b">${someVar}</code>一样，只是我们传入的不是变量，而是一个回调函数。这个回调访问我们传递给组件的道具，这就是为什么我们可以取出<code class="fe mo mp mq mr b">img</code>道具。然后我们从回调函数中返回我们想要的东西，这是图像的路径。总之，第19行将被编译成<code class="fe mo mp mq mr b">background: url(img/photography.jpg);</code>或我们传递给它的任何其他图像路径。</p><p id="550f" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">我们在第22行做了类似的事情，只是稍微复杂一点。我们抢的是<code class="fe mo mp mq mr b">alignment</code>道具，不是<code class="fe mo mp mq mr b">left</code>就是<code class="fe mo mp mq mr b">right</code>。然后，我们使用一个三元表达式来管理我们返回的css。如果对齐方式是“右对齐”，我们要确保返回的css将卡片定位在屏幕的右侧，并将其正向旋转15度。如果道具是“左”，我们做相反的事情。</p><p id="2447" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">最后，每当我们将鼠标悬停在卡片上时，我们就在卡片上设置一个边框。</p><h2 id="7969" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated"><em class="mt">卡片正文</em></h2><p id="8b60" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">CardText组件负责在卡片上呈现带有白色文本的黑色横幅。这里的CSS非常简单。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="c3d0" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">随着卡组件的创建，我们可以将它添加到我们的<code class="fe mo mp mq mr b">App.jsx</code>文件中。我们还想用一些卡片对象创建一个数组，这样卡片就可以呈现出来了。</p><p id="f6d9" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">这就是<code class="fe mo mp mq mr b">App.jsx</code>现在的样子。</p><figure class="lp lq lr ls gt jr"><div class="bz fp l di"><div class="ms lu l"/></div></figure><p id="e601" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">注意，我们正在导入Card组件，并且在第18行创建了一个<code class="fe mo mp mq mr b">cards</code>数组。</p><p id="3fb8" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">我们覆盖了第37行的<code class="fe mo mp mq mr b">map</code>数组，每次都创建一个新的<code class="fe mo mp mq mr b">Card</code>组件。我们使用三元组来计算对齐属性，如果索引变量被2整除(偶数)或不能整除(奇数),三元组将返回“left”。这具有在地图的每次迭代中在<code class="fe mo mp mq mr b">left</code>和<code class="fe mo mp mq mr b">right</code>之间交替的效果。</p><p id="7259" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">完成所有这些后，您应该能够启动您的应用程序，并看到与演示视频中几乎相同的内容(除了标题，但我将省略这一部分，因为它只是一个基本组件)。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="c03e" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">这篇文章是基础的，但是提供了一个起点，从这里你可以通过分层视差背景或者将它们与CSS动画结合来创建更复杂的效果。积木很简单，但是通过把它们放在一起，你可以创造出一些非常酷的东西。</p><p id="d46f" class="pw-post-body-paragraph ku kv iq kw b kx lv kz la lb lw ld le kh lx lg lh kl ly lj lk kp lz lm ln lo ij bi translated">感谢阅读。</p></div></div>    
</body>
</html>