<html>
<head>
<title>Why I love styled-components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我喜欢样式组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-i-love-styled-components-ffec043293bb?source=collection_archive---------5-----------------------#2020-08-24">https://javascript.plainenglish.io/why-i-love-styled-components-ffec043293bb?source=collection_archive---------5-----------------------#2020-08-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2d0f23dcdb281e6cf86224b725715fca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Wi-Lhb-sno0CwyAE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@aridley88?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrew Ridley</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2e55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在每个人都可能听说过它们，尽管许多人可能已经被“JS中的CSS”这个词吓跑了。我不会责怪他们，当我第一次听到组合这个词时，我非常悲观。</p><p id="04e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果把<code class="fe lb lc ld le b">css</code>放在<code class="fe lb lc ld le b">HTML</code>被认为是不好的做法，为什么把它放在<code class="fe lb lc ld le b">js</code>会更好呢，对吗？我们有我们的<code class="fe lb lc ld le b">HTML</code>、<code class="fe lb lc ld le b">JS</code>和<code class="fe lb lc ld le b">CSS</code>文件，完美的平衡，就像一切一样，尽管在<code class="fe lb lc ld le b">React</code>的情况下，我们的组件由返回<code class="fe lb lc ld le b">JSX</code>的函数组成，我们的<code class="fe lb lc ld le b">HTML</code>基本上是最小的，带有一个div供<code class="fe lb lc ld le b">React</code>挂载。</p><p id="fec1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或许<code class="fe lb lc ld le b">js</code>中的<code class="fe lb lc ld le b">css</code>终究不是某种异端？</p><h1 id="8910" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">一个有点简单的例子</h1><p id="e3b9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">为了让它更有趣一点，让我们使用不同的方法重新创建相同的组件:普通的<code class="fe lb lc ld le b">css</code>、<code class="fe lb lc ld le b">css</code>和最后的<code class="fe lb lc ld le b">styled-components</code>。</p><figure class="mj mk ml mm gt jr gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/62e36c1eaa3d5d28e532ed83e23d8dc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/1*AKqtTQxoK7XGRlP326GEGg.gif"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">love those shades of beige</figcaption></figure><h1 id="726c" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">普通CSS</h1><p id="211e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">让我们看看输入字段的样式在不使用任何花哨工具的情况下会是什么样子——会有多糟糕呢？</p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="715c" class="mr lg iq le b gy ms mt l mu mv">.input {<br/>  padding: 23px;<br/>  font-size: 16px;<br/>  width: 100%;<br/>  box-sizing: border-box;<br/>  outline: none;<br/>  border: none;<br/>}</span><span id="a8fc" class="mr lg iq le b gy mw mt l mu mv">.input-label {<br/>  position: absolute;<br/>  top: 22px;<br/>  left: 20px;<br/>}</span><span id="2768" class="mr lg iq le b gy mw mt l mu mv">.input:focus + .input-label {<br/>  color: crimson;<br/>  transition: ease-in-out 0.3s;<br/>  top: 3px;<br/>  left: 23px;<br/>  font-size: 14px;<br/>  font-weight: 600;<br/>}</span><span id="4a7b" class="mr lg iq le b gy mw mt l mu mv">.name-input:hover ~ .info-box::after {<br/>  content: "hello";<br/>  font-weight: bold;<br/>  transition: ease-in-out 0.2s;<br/>}</span><span id="c49d" class="mr lg iq le b gy mw mt l mu mv">.surname-input:hover ~ .info-box::after {<br/>  content: "almost done";<br/>  font-weight: bold;<br/>  transition: ease-in-out 0.2s;<br/>}</span></pre><p id="7461" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来很棒，对吧？是的，当然，但是使用普通香草也有明显的缺点:</p><ul class=""><li id="919f" class="mx my iq kf b kg kh kk kl ko mz ks na kw nb la nc nd ne nf bi translated">类是全局的，这意味着你可以有意地继承或覆盖某些东西，这可能并不明显。</li><li id="eec6" class="mx my iq kf b kg ng kk nh ko ni ks nj kw nk la nc nd ne nf bi translated">没有嵌套，选择器是独立的代码块，这本身不是问题，但是它需要额外的脑力来处理，而且一些同事可能不会将与一个类相关的所有内容按顺序放置——这为人为错误留出了空间</li></ul><h1 id="7c4e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">带有预处理器</h1><p id="dc07" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">顾名思义，当使用<code class="fe lb lc ld le b">css</code>预处理程序时，你的样式表在被浏览器理解之前必须被处理。它们有很多不错的特性:混合、继承、变量，最重要的是——嵌套。让我们看看使用<code class="fe lb lc ld le b">Sass</code>预处理器时的代码:</p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="9999" class="mr lg iq le b gy ms mt l mu mv">.input {<br/>  padding: 23px;<br/>  font-size: 16px;<br/>  width: 100%;<br/>  box-sizing: border-box;<br/>  outline: none;<br/>  border: none;</span><span id="c132" class="mr lg iq le b gy mw mt l mu mv">  &amp;:focus + .input-label {<br/>    color: crimson;<br/>    transition: ease-in-out 0.3s;<br/>    top: 3px;<br/>    left: 23px;<br/>    font-size: 14px;<br/>    font-weight: 600;<br/>  }<br/>}</span><span id="1581" class="mr lg iq le b gy mw mt l mu mv">.input-label {<br/>  position: absolute;<br/>  top: 22px;<br/>  left: 20px;<br/>}</span><span id="37d5" class="mr lg iq le b gy mw mt l mu mv">.name-input {<br/>  &amp;:hover ~ .info-box {<br/>    &amp;::after {<br/>      content: "hello";<br/>      font-weight: bold;<br/>      transition: ease-in-out 0.2s;<br/>    }<br/>  }<br/>}</span><span id="7333" class="mr lg iq le b gy mw mt l mu mv">.surname-input {<br/>  &amp;:hover ~ .pre-info-box {<br/>    &amp;::after {<br/>      content: "almost done";<br/>      font-weight: bold;<br/>      transition: ease-in-out 0.2s;<br/>    }<br/>  }<br/>}</span></pre><p id="429d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于我们现在在<code class="fe lb lc ld le b">css</code>中有了嵌套，理解这里发生的事情变得更加容易，所以我们已经解决了一个问题——全局类名仍然存在。</p><h2 id="5d32" class="mr lg iq bd lh nl nm dn ll nn no dp lp ko np nq lt ks nr ns lx kw nt nu mb nv bi translated">中断</h2><p id="c62a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们已经用香草解决了一个主要的问题，那么第二个呢？好吧，这可以很容易地通过使用<code class="fe lb lc ld le b">css-modules</code>来解决，这将使所有的类都在一个给定的文件范围内，<code class="fe lb lc ld le b">create-react-app</code>附带了对这个的支持，你只需要给你的文件命名<code class="fe lb lc ld le b">xyz.module.scss</code>，它甚至对普通的<code class="fe lb lc ld le b">css</code>有效！</p><p id="f786" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">等等，看起来我们已经解决了所有问题——为什么还要继续呢？因为有更多的收获:)</p><h1 id="3b3e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用样式化组件</h1><p id="5356" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">他们也解决了上面提到的问题，否则我不会爱上他们。无论如何，我们的输入风格是:</p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="3929" class="mr lg iq le b gy ms mt l mu mv">const LabelElement = styled.label`<br/>    position: absolute;<br/>    top: 22px;<br/>    left: 20px;<br/>`;</span><span id="94a3" class="mr lg iq le b gy mw mt l mu mv">const InputElement = styled.input`<br/>  padding: 23px;<br/>  font-size: 16px;<br/>  width: 100%;<br/>  box-sizing: border-box;<br/>  outline: none;<br/>  border: none;</span><span id="40f0" class="mr lg iq le b gy mw mt l mu mv">  :focus + ${LabelElement} {<br/>    color: crimson;<br/>    transition: ease-in-out 0.3s;<br/>    top: 3px;<br/>    left: 23px;<br/>    font-size: 14px;<br/>    font-weight: 600;<br/>  }<br/>`;</span></pre><p id="9d0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与使用<code class="fe lb lc ld le b">scss</code>的行数大致相同，但这存在于我们的<code class="fe lb lc ld le b">JS</code>文件中，嘘呼，没什么大不了的。有些人可能已经注意到，我们没有代码来更改悬停在这里的信息框，这是因为我们现在可以在使用这些代码来更改信息框时，通过扩展我们的基本组件来放置这些代码:</p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="4ce3" class="mr lg iq le b gy ms mt l mu mv">const NameInput = styled(Input)`<br/>  grid-column: 1/3;</span><span id="7d85" class="mr lg iq le b gy mw mt l mu mv">  :hover ~ ${InfoBox}::after {<br/>    content: "hello";<br/>    font-weight: bold;<br/>    transition: ease-in-out 0.2s;<br/>  }<br/>`;</span><span id="6563" class="mr lg iq le b gy mw mt l mu mv">const SurnameInput = styled(Input)`<br/>  grid-column: 1/3;</span><span id="f612" class="mr lg iq le b gy mw mt l mu mv">  :hover ~ ${InfoBox}::after {<br/>    content: "almost done";<br/>    font-weight: bold;<br/>    transition: ease-in-out 0.2s;<br/>  }<br/>`;</span></pre><p id="14f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用这种方法来定位它们，这很简单，但是我甚至还没有触及主要的原因——代码看起来怎么样，是时候这样做了。</p><h1 id="0fdd" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">javascript</h1><p id="d751" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">有了香草<code class="fe lb lc ld le b">css</code>和预处理<code class="fe lb lc ld le b">css</code>，我们的主要javascript组件看起来如下:</p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="b100" class="mr lg iq le b gy ms mt l mu mv">&lt;div className="vanilla"&gt;<br/>  &lt;div className="simple-form"&gt;<br/>    &lt;Input className="both-columns name-input" label="name" /&gt;<br/>    &lt;Input className="both-columns surname-input" label="surname" /&gt;<br/>    &lt;Button clasName="left-button" label="accept" variant="primary" /&gt;<br/>    &lt;Button clasName="right-button" label="cancel" variant="secondary" /&gt;<br/>    &lt;div className="info-box both-columns"&gt;&lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="6ba8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe lb lc ld le b">div’s</code>类，类名与React组件捆绑在一起，没有快速的方法来检查给定<code class="fe lb lc ld le b">css</code>类的代码，总的来说，它看起来确实很吵，但是我们已经习惯了，接受它作为一个生活的事实，但是当我们看着<code class="fe lb lc ld le b">styled-components</code> <code class="fe lb lc ld le b">js</code>看起来是什么样子的时候，它让我窒息:</p><pre class="mj mk ml mm gt mn le mo mp aw mq bi"><span id="fe41" class="mr lg iq le b gy ms mt l mu mv">&lt;Container&gt;<br/>  &lt;Form&gt;<br/>    &lt;NameInput label="name" /&gt;<br/>    &lt;SurnameInput label="surname" /&gt;<br/>    &lt;Primary label="accept" /&gt;<br/>    &lt;Secondary label="cancel" /&gt;<br/>    &lt;ThisInfoBox /&gt;<br/>  &lt;/Form&gt;<br/>&lt;/Container&gt;</span></pre><p id="eb4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如此简洁，如此干净。没有类名被传来传去，没有草皮漂浮，看着这个纯粹的快乐。我不认为自己会回去..</p><p id="3ede" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">干杯。</p><p id="f59d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nw">所有三种实现的完整代码都可以在这里找到:</em><a class="ae kc" href="https://github.com/MustSeeMelons/css-playground" rel="noopener ugc nofollow" target="_blank"><em class="nw">https://github.com/MustSeeMelons/css-playground</em></a></p><h2 id="1451" class="mr lg iq bd lh nl nm dn ll nn no dp lp ko np nq lt ks nr ns lx kw nt nu mb nv bi translated"><strong class="ak">简单明了的JavaScript</strong></h2><p id="4afa" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">你知道我们有三个出版物和一个YouTube频道吗？在<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">找到所有东西的链接！</strong></a></p></div></div>    
</body>
</html>