# 使用打开/关闭原则编写干净的模块化 React 代码

> 原文：<https://javascript.plainenglish.io/how-to-use-open-close-principles-in-react-to-write-clean-modular-code-61e2a03d31b9?source=collection_archive---------4----------------------->

![](img/892aaa7e75a86cea0643762ecffa1ba9.png)

Photo by [Pankaj Patel](https://unsplash.com/@pankajpatel?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/code?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

在本文中，我将向您展示如何将**开/关原则** ( *软件架构中一个众所周知的概念*)应用到您的 React 组件中，并轻松编写干净、可重用和模块化的代码。

## **什么是开/关原理？**

在面向对象编程中，开放/封闭原则陈述了“软件实体(类、模块、函数等)”。)应该对扩展开放，但对修改关闭”；也就是说，这样的实体可以允许其行为被扩展，而无需修改其源代码。

## **但是这在 React 应用中有什么用呢？**

为了理解这在 React 应用程序中是如何有用的，让我们从一个实际问题开始。假设我们正在构建一个仓库应用程序。在这个应用程序中，我们有一个名为`OrderReport`的组件，它负责处理用户订单。

下面是我们的代码如何寻找这个样本组件

现在，假设我们的业务规则发生了变化。管理层已经决定，现在我们的仓库公司将处理三种类型的订单。一些客户可以选择特殊递送选项或快速递送选项。

下面是新客户数据的样子。

```
const customerB = {
    name: "Company B",
    address: "410 Ramsy St",
    total: 1000,
    isFastTracked: true
};
const customerC = {
    name: "Company C",
    address: "123 Abram Ave",
    total: 1010,
    specialDelivery: true
};
```

管理层给了我们一个要求，我们仍然需要支持所有的老客户对象。然而，如果一个客户对象有一个`isFastTracked`标志或者一个`specialDelivery`标志，那么我们将需要执行一些额外的逻辑，例如我们需要进行一个额外的 api 调用和呈现额外的信息。

从开发人员的角度来看，这似乎是一个简单的实现。我们可以将这些额外的逻辑实现到现有的`OrderReport`组件中，如下所示。

正如您所看到的，组件在这里开始变得嘈杂。我们将太多的职责分配给了这个单一的组件。此外，这个组件很难测试，不太容易重用。现在，如果大约一周之后，我们的业务需要添加五种新类型的交付选项，并且业务逻辑略有不同，该怎么办呢？现在我们有一个问题，更新这个组件将是一个繁琐和容易出错的任务。当我们设计单个软件组件/模块时，软件更容易维护，因为扩展是开放的，修改是封闭的。这就是开/闭原理。我们希望避免对我们的核心`OrderReport`进行重大修改，同时使其可扩展，以便其功能可以用于其他组件。

在经典的面向对象编程中，这是通过继承来实现的。在像 ***Java、C#*** 和 ***Python*** 这样的语言中，我们可以扩展现有的类来为代码添加额外的功能。然而，在 **JavaScript** 中，我们可以简单地通过一个函数组合来实现。让我们来看看如何应用它。在下面的例子中，我创建了一个新的高阶组件，它只负责处理快速跟踪订单

如您所见，它接收一个基本组件作为参数，并向其添加额外的功能。在这个场景中，我们的基本组件是旧的`OrderReport`组件。我们可以回到最简单的`OrderReport`组件，如下所示。

在我们的`App`组件中，每当我们发现一个快速跟踪订单时，我们可以用`withFastTrackedOrder`更高的订单组件来组合它。

同样，我们可以为特殊订单创建一个高阶组件。

并更改我们的应用程序组件来反映这些变化，如下所示

这比我们想出的第一个解决方案要干净得多。现在我们所有组件都可以扩展了。我们可以很容易地创建更多的 **HOC** ( *高阶组件)*来扩展这些组件中每一个的功能，并且我们不必修改核心功能。这样，我们的应用程序对未来的变化更加敏捷。

此外，这些更小的组件负责一个特定的任务，这使得它们更容易维护，如果我们想在应用程序的不同部分重用，并且更容易编写单元测试。

今天到此为止😀，希望你喜欢这篇文章。