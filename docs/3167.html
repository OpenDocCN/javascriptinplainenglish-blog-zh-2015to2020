<html>
<head>
<title>Node.js Best Practices — Exceptions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—例外</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-best-practices-exceptions-3763f1a70fbf?source=collection_archive---------9-----------------------#2020-09-05">https://javascript.plainenglish.io/node-js-best-practices-exceptions-3763f1a70fbf?source=collection_archive---------9-----------------------#2020-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1d996c11dd7d862872c28aad8154b361.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZX9CaSjjniiGjDYF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@napr0tiv?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Vasily Koloda</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fc31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写节点应用程序时应该遵循的一些最佳实践。</p><h1 id="2e74" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用异步错误处理的承诺</h1><p id="e038" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使用异步错误处理的承诺。</p><p id="6b0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有许多嵌套的回调函数，那么用回调函数的方式处理异步错误将会很糟糕。</p><p id="b71f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">节点风格的回调不允许我们在没有嵌套的情况下链接异步调用。</p><p id="5c1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免这种情况，我们应该确保使用承诺。</p><p id="363b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不要写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4181" class="mn lc iq mj b gy mo mp l mq mr">getData(someParameter, function(err, result){<br/>    if(err !== null &amp;&amp; err !== undefined)<br/>    getMoreData(a, function(err, result){<br/>          if(err !== null &amp;&amp; err !== undefined)<br/>        getMoreData(b, function(c){ <br/>                getMoreData(d, function(e){ <br/>                    //...<br/>                });<br/>            });<br/>        });<br/>    });<br/>});</span></pre><p id="d2cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有4个嵌套的回调函数，即使我们省略了逻辑代码，也很难读懂。</p><p id="266a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0ddb" class="mn lc iq mj b gy mo mp l mq mr">doWork()<br/>  .then(doWork)<br/>  .then(doMoreWork)<br/>  .then(doWork)<br/>  .catch(errorHandler)<br/>  .then(verify);</span></pre><p id="7dd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以把它变成一个更长的cleaner，因为promises有一个可以传递回调的<code class="fe ms mt mu mj b">then</code>方法。</p><p id="c4f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想捕捉错误，我们使用<code class="fe ms mt mu mj b">catch</code>方法。</p><p id="dbbf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用async和await语法来改变承诺，并使用try-catch来捕捉错误。</p><p id="2509" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="25f5" class="mn lc iq mj b gy mo mp l mq mr">const work = async () =&gt;<br/>  try {<br/>    const r1 = await doWork();<br/>    const r2 = await doMoreWork();<br/>    const r3 = await doWork();<br/>    const r4 = await verify();<br/>  }<br/>  catch (e) {<br/>    <!-- -->errorHandler(e)<br/>  }<br/>}</span></pre><p id="a9c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个<code class="fe ms mt mu mj b">then</code>回调都返回一个承诺，所以我们可以对它们使用<code class="fe ms mt mu mj b">await</code>。</p><h1 id="f09a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">仅使用内置的错误对象</h1><p id="09b2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">内置的错误构造函数应该用于创建错误。</p><p id="b2a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">Error</code>构造函数有错误消息和堆栈跟踪。</p><p id="66fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们对于解决问题很有用，如果我们扔掉其他东西，这些问题就会丢失</p><p id="a816" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不要写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9213" class="mn lc iq mj b gy mo mp l mq mr">throw 'error';</span></pre><p id="29dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4df0" class="mn lc iq mj b gy mo mp l mq mr">throw new Error("error");</span></pre><p id="2197" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它会让堆栈跟踪到抛出错误的地方。</p><h1 id="1511" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">区分操作错误和程序员错误</h1><p id="f208" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该区分操作错误和程序员错误。</p><p id="d4bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">操作错误是指错误的影响被完全理解并且可以被处理的错误。</p><p id="b72c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">程序员错误是指未知的代码失败，我们需要优雅地重启应用程序。</p><p id="cea7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于我们可以处理的错误，我们应该能够处理它们，避免重复我们的应用程序。</p><p id="fc2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以抛出错误，通过写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="edec" class="mn lc iq mj b gy mo mp l mq mr">if(!product) {<br/>  throw new Error("no product selected");<br/>}</span><span id="6ac8" class="mn lc iq mj b gy mv mp l mq mr">const myEmitter = new MyEmitter();<br/>myEmitter.emit('error', new Error('error'));</span></pre><p id="0a60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在同步代码和事件发射器中抛出错误。</p><p id="863d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在承诺中抛出一个错误:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="81ec" class="mn lc iq mj b gy mo mp l mq mr">new Promise((resolve, reject) =&gt; {<br/>  DAL.getProduct(productToAdd)<br/>    .then((product) =&gt;{<br/>       if(!product)<br/>         return reject(new Error("no product added"));<br/>       }<br/>    })<br/>});</span></pre><p id="3389" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们承诺用一个<code class="fe ms mt mu mj b">Error</code>实例调用<code class="fe ms mt mu mj b">reject</code>来抛出错误。</p><p id="b998" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些是抛出错误的正确方法。</p><p id="1687" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他途径包括收听<code class="fe ms mt mu mj b">uncaughtException</code>事件:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="60eb" class="mn lc iq mj b gy mo mp l mq mr">process.on('uncaughtException', (error) =&gt; {<br/>  if (!error.isOperational)<br/>    process.exit(1);<br/>});</span></pre><p id="f10b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">监听<code class="fe ms mt mu mj b">uncaughtException</code>事件会改变事件的行为，因此它不应该被监听。</p><p id="2927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">process.exit</code>也是一种不好的结束程序的方式，因为它会突然结束程序。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/84afb06b9b7624d81d47b219cbd27416.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QOe4TEtE-95xwpw3"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f5f9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="8a20" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该以正确的方式抛出和捕捉错误。</p><p id="dff2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们的应用程序将优雅地处理它们。</p><h2 id="4e1b" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="7d4b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有三份出版物和一个YouTube频道吗？在<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">寻找一切的链接plainenglish.io </strong> </a>！</p></div></div>    
</body>
</html>