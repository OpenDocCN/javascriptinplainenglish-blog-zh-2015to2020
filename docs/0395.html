<html>
<head>
<title>Here We Go Again: An Introduction to Recursion and How to Use It in Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">又来了:递归介绍以及如何在代码中使用递归</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/recursion-what-it-is-and-how-you-use-it-302d85e6577e?source=collection_archive---------4-----------------------#2019-10-04">https://javascript.plainenglish.io/recursion-what-it-is-and-how-you-use-it-302d85e6577e?source=collection_archive---------4-----------------------#2019-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/53c094ec0de876cc2f45206b38d774ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9H5rmyp3MgrcA8i1emsJPg.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@tine999?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Tine Ivanič</a> on <a class="ae jd" href="https://unsplash.com/s/photos/loop?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><h1 id="0528" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是递归？</h1><p id="8032" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">用最简单的术语来说，<strong class="ld jh">递归函数是一个自称为</strong>的函数。递归是解决类似迭代解决的问题的工具，但是如果可能的话，迭代是更好的选择。但是在有些情况下，迭代并没有给我们所需要的东西，这就是递归的用武之地。</p><p id="8bff" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">值得注意的是，递归函数需要一个<strong class="ld jh">基础用例</strong>，或者停止点，这样它们就不会永远继续调用自己。</p><h1 id="fe43" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">我们什么时候使用递归函数？</h1><p id="0416" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">当你遍历一个对象，你需要调用正在执行迭代的函数时，递归是必要的。</p><p id="1737" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">合并排序和快速排序都是递归函数。例如，Merge sort通过将长度为<em class="me"> n </em>的数组分成<em class="me"> n </em>个不同的子数组来对数组进行排序。它将原始数组一分为二，然后将每个子数组一分为二，再将每个子数组一分为二，以此类推，直到子数组的长度为1。</p><p id="b9be" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">假设我们有以下长度为8的数组:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="8f62" class="mo ke jg mk b gy mp mq l mr ms">let array = [19, 42, 36, 11, 16, 91, 84, 2]</span></pre><p id="eb5b" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">将数组传递到我们的合并排序函数中，我们希望将该数组一分为二，因此我们有以下子数组:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="438c" class="mo ke jg mk b gy mp mq l mr ms">let firstSubArray = [19, 42, 36, 11]<br/>let secondSubArray = [16, 91, 84, 2]</span></pre><p id="7cd0" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在，我们真正想做的是将这些子数组中的每一个也传递到我们的合并排序函数中，这样每个子数组都被分成两半。这就是递归的用武之地，因为我们需要从合并排序函数中调用合并排序函数。</p><p id="0751" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这篇文章是关于递归的，而不是具体的合并排序，但是对于那些不熟悉合并排序的人，我将用简单的英语很快地讲述接下来会发生什么。</p><p id="c489" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">一旦您的递归调用返回了长度都为1的<em class="me"> n </em>子数组，merge sort就会一次比较2个数组，并按排序后的顺序连接它们。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="9246" class="mo ke jg mk b gy mp mq l mr ms">[19] [42] [36] [11] [16] [91] [84] [2]</span></pre><p id="1127" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">给定上面的子数组集，merge sort将比较并连接19和42、36和11、16和91以及84和2，返回如下结果:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="caaf" class="mo ke jg mk b gy mp mq l mr ms">[19, 42] [11, 36] [16, 91] [2, 84]</span></pre><p id="b7e3" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">接下来的合并排序将会比较前两个数组和后两个数组。它将从比较第一个数组的第一个元素和第二个数组的第一个元素开始，所以19和11。11较小，所以添加11作为组合数组的第一个元素。然后将19与第二个数组中的第二项36进行比较，19较小，因此将其添加到组合数组中。然后比较42和36，36比36小，所以加到组合数组中，然后加42。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="2e47" class="mo ke jg mk b gy mp mq l mr ms">[11, 19, 36, 42] [16, 91] [2, 84]</span></pre><p id="72d8" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">对另外两个数组做同样的事情。2小于16所以添加为它们组合数组的第一个元素，16小于84所以添加，84小于91所以添加，然后91添加。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="7a02" class="mo ke jg mk b gy mp mq l mr ms">[11, 19, 36, 42] [2, 16, 84, 91]</span></pre><p id="9860" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们现在只剩下两个数组，它们都是已排序的，我们需要合并它们。2小于11，所以加2。11小于16，所以加11。16小于19，所以加16。19小于84，所以加19。36小于84，42也小于84，所以加36再加42。最后添加84和91。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="25b6" class="mo ke jg mk b gy mp mq l mr ms">[2, 11, 16, 19, 36, 42, 84, 91]</span></pre><p id="b4b6" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">就这样，我们有了排序后的数组。</p><h1 id="a275" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">JavaScript中的递归是什么样子的？</h1><p id="8681" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一个合适的合并排序函数应该包括将原始数组减半为长度为1的子数组、子数组元素的比较以及子数组的连接，但是今天我们只想关注递归，所以我们将只构建JavaScript中的减半函数。</p><p id="d188" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">在这个例子中，我们将坚持使用我们的原始数组。我们从以下方面着手:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="4e48" class="mo ke jg mk b gy mp mq l mr ms">let array = [19, 42, 36, 11, 16, 91, 84, 2]</span></pre><p id="2192" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们希望我们的功能产生:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6303" class="mo ke jg mk b gy mp mq l mr ms">[19] [42] [36] [11] [16] [91] [84] [2]</span></pre><p id="284b" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">我们将从编写我们的函数开始，我们称之为减半，并将数组传递给它。因为我们将数组减半的能力依赖于知道长度，我们将从获得长度开始，将它一分为二，然后基于这个中点将数组一分为二。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="60d3" class="mo ke jg mk b gy mp mq l mr ms">function halving(array) {<br/>     let length = array.length;<br/>     let half = length / 2;<br/>     let firstSubArray = array.slice(0, half;<br/>     let secondSubArray = array.slice(half, length);<br/>}</span></pre><p id="47db" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">现在递归开始了。我们有第一个子数组和第二个子数组，正如我们之前说过的，我们真正想做的是将这些数组中的每一个传递给减半函数，<em class="me">，我们想将它们的每个子数组传递给减半函数，直到子数组的长度为1</em>。我们通过使用条件语句来确定长度，如果子数组的长度不等于1，我们就从函数内部再次调用halving函数，并将子数组传入。这种从halving(array)内部调用halving(array)，就是递归。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="43e6" class="mo ke jg mk b gy mp mq l mr ms">function halving(array) {<br/>     let length = array.length;<br/>     let half = length / 2;<br/>     let firstSubArray = array.slice(0, half;<br/>     let secondSubArray = array.slice(half, length);<br/>     </span><span id="6e02" class="mo ke jg mk b gy mt mq l mr ms">     if (firstSubArray.length === 1) {<br/>          console.log(firstSubArray)<br/>     } else {<br/>          halving(firstSubArray);<br/>     }<br/></span><span id="e004" class="mo ke jg mk b gy mt mq l mr ms">     if (secondSubArray.length === 1) {<br/>         console.log(secondSubArray)<br/>     } else {<br/>          halving(secondSubArray);<br/>     }<br/>}</span></pre><p id="c485" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果运行此代码，您将在控制台上看到以下输出:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="c8c2" class="mo ke jg mk b gy mp mq l mr ms">[ 19 ]<br/>[ 42 ]<br/>[ 36 ]<br/>[ 11 ]<br/>[ 16 ]<br/>[ 91 ]<br/>[ 84 ]<br/>[ 2 ]</span></pre><p id="0bd2" class="pw-post-body-paragraph lb lc jg ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">这大概就是递归的内容了。下周回来学习堆背后的理论，以及如何使用JavaScript构建一个堆。</p></div></div>    
</body>
</html>