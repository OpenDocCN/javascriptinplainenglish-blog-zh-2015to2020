<html>
<head>
<title>What is The Event Loop in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的事件循环是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/explaining-the-event-loop-to-hamsters-f18be93956d6?source=collection_archive---------3-----------------------#2019-10-25">https://javascript.plainenglish.io/explaining-the-event-loop-to-hamsters-f18be93956d6?source=collection_archive---------3-----------------------#2019-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e3fd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过setTimeout的例子解释事件循环</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://www.webtips.dev/what-is-the-event-loop-in-javascript"><div class="gh gi kf"><img src="../Images/a31ecb027df04bb23f0873c2ef475cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mR7EXlwL3ussm8fG"/></div></a><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Photo by <a class="ae kr" href="https://unsplash.com/@tine999?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tine Ivanič</a> on <a class="ae kr" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://www.webtips.dev/what-is-the-event-loop-in-javascript"><div class="gh gi ks"><img src="../Images/c19cb3069af1beba3c93258d9fcfe139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*-PVzecNs3s4ZbJsdsgIsGA.png"/></div></a></figure><p id="e664" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">你可能听说过JavaScript有个东西叫“<em class="lp">事件循环</em>”。但是它实际上是什么，它真正的含义是什么？为什么了解它很重要，了解它有什么好处？在本教程中，我们将探讨这些问题，并简化一个看似复杂的想法。</p><p id="57e7" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated"><strong class="kv ir">用一句话来定义什么是事件循环:</strong></p><blockquote class="lq"><p id="5ce6" class="lr ls iq bd lt lu lv lw lx ly lz lo dk translated">将事件从任务队列移动到调用堆栈被称为“事件循环”</p></blockquote><p id="13b2" class="pw-post-body-paragraph kt ku iq kv b kw ma jr ky kz mb ju lb lc mc le lf lg md li lj lk me lm ln lo ij bi translated">那么这个<strong class="kv ir">任务队列</strong>和<strong class="kv ir">调用栈</strong>是什么呢？它们是如何发挥作用的？让我们来看看浏览器架构的简化版本，以便更深入地理解执行JavaScript代码时会发生什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mf"><img src="../Images/cf60e4927c8ddbd235f92c5b1e92a864.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AkCusjggeTf2XhEjgNjz9w.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">A simplified representation of a browser’s architecture</figcaption></figure><p id="c54d" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">在浏览器中，我们有四个主要组件。我们感兴趣的是事件循环。但是为了理解事件循环的工作，我们需要澄清其他三个方面的迷雾:调用堆栈、web API线程和任务队列。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="9355" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">调用堆栈</h1><p id="b23b" class="pw-post-body-paragraph kt ku iq kv b kw nj jr ky kz nk ju lb lc nl le lf lg nm li lj lk nn lm ln lo ij bi translated">您可能已经知道，JavaScript是一种单线程语言，这意味着它只有一个调用栈，不像其他多线程语言。这也意味着它一次只能执行一个代码。这段代码的执行顺序由调用堆栈处理。它保存了关于我们现在在代码中执行顺序的信息。为了充分理解它的工作原理，让我们通过一个例子来演示它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="15ac" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">我们都知道会发生什么，我们将在控制台中看到<code class="fe nq nr ns nt b">Learning About The Event Loop</code>。但是调用栈内部会发生什么呢？让我们一行一行地分析它是如何处理的:</p><ul class=""><li id="7187" class="nu nv iq kv b kw kx kz la lc nw lg nx lk ny lo nz oa ob oc bi translated">我们从第1行开始；我们将<code class="fe nq nr ns nt b">console.log</code>推到调用堆栈的顶部，并在隐式返回时立即弹出它。</li><li id="95c4" class="nu nv iq kv b kw od kz oe lc of lg og lk oh lo nz oa ob oc bi translated">我们也为其他两条线这样做。我们将<code class="fe nq nr ns nt b">console.log</code>推到堆栈上，一旦执行完毕就弹出它。</li></ul><p id="3b7f" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">我们再看一个例子，你觉得会发生什么？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="7393" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">我们定义了一个名为<code class="fe nq nr ns nt b">recursion</code>的函数，我们在第5行调用它。然后在函数内部，我们一次又一次地调用它…这会给我们一个错误:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi oi"><img src="../Images/fda29b29c3610513f5f62dbbcd8e3326.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J64FwMjdkytZ53CQQF6T9g.png"/></div></div><figcaption class="kn ko gj gh gi kp kq bd b be z dk">Chrome throws an error when the maximum call stack size is exceeded</figcaption></figure><p id="1c24" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">我们一直将<code class="fe nq nr ns nt b">recursion</code>压入堆栈，从未弹出一个项目，导致<code class="fe nq nr ns nt b">RangeError</code>，这防止了浏览器崩溃。</p><p id="849b" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">您还可以在错误消息下面看到堆栈跟踪信息，即代码执行的顺序。</p><p id="8f75" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">这就是调用栈所做的一切。它将代码推到堆栈上，并在代码执行后弹出。它基本上是我们程序当前状态的快照；当JavaScript引擎执行我们的代码时我们在哪里。</p><p id="a114" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">那么，如果JavaScript是单线程的，我们一次只能运行一段代码，那么我们怎么会有异步功能呢？—意味着我们没有阻塞。这就是<strong class="kv ir">浏览器或web API</strong>发挥作用的地方。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="1587" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">Web API线程</h1><p id="2123" class="pw-post-body-paragraph kt ku iq kv b kw nj jr ky kz nk ju lb lc nl le lf lg nm li lj lk nn lm ln lo ij bi translated">现在让我们来看看下面的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="a51c" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">您认为上述代码示例的输出会是什么样的？如果你猜到了:</p><pre class="kg kh ki kj gt oj nt ok ol aw om bi"><span id="f593" class="on ms iq nt b gy oo op l oq or">🐹<br/>🐹🐹🐹<br/>🐹🐹</span></pre><p id="81fd" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">你要么是通过艰难的方式学会的，要么是你已经知道事件循环是如何工作的。也许两者都有。但是为什么不呢:</p><pre class="kg kh ki kj gt oj nt ok ol aw om bi"><span id="57a1" class="on ms iq nt b gy oo op l oq or">🐹<br/>🐹🐹<br/>🐹🐹🐹</span></pre><p id="2910" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">即使我们用0毫秒调用<code class="fe nq nr ns nt b">setTimeout</code>，它仍然被作为最后一件事执行。让我们再一次快速浏览一下调用堆栈是如何处理上面的代码的:</p><ul class=""><li id="c8e6" class="nu nv iq kv b kw kx kz la lc nw lg nx lk ny lo nz oa ob oc bi translated">我们从第1行开始，我们将<code class="fe nq nr ns nt b">console.log</code>推入调用堆栈，并立即将其弹出，这样我们就有了🐹在控制台里。</li><li id="1ad7" class="nu nv iq kv b kw od kz oe lc of lg og lk oh lo nz oa ob oc bi translated">我们到达第3行，我们将<code class="fe nq nr ns nt b">setTimeout</code>推入堆栈，但是我们不能执行它，因为<code class="fe nq nr ns nt b">setTimeout</code>不是V8引擎的一部分。不是核心JavaScript函数，是浏览器API。它通过浏览器添加到JavaScript中。这就是你需要填充浏览器提供的<code class="fe nq nr ns nt b">Promise</code>对象或DOM内部节点的原因。这些API调用是在不同的线程中处理的，所以我们发起对web API线程的调用，并从堆栈中弹出<code class="fe nq nr ns nt b">setTimeout</code>。这将在JavaScript世界之外的另一个线程池中启动一个计时器。</li><li id="a167" class="nu nv iq kv b kw od kz oe lc of lg og lk oh lo nz oa ob oc bi translated">我们继续执行，将line:5上的另一个<code class="fe nq nr ns nt b">console.log</code>推到堆栈上，然后弹出它，所以现在我们有了🐹🐹🐹'</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mf"><img src="../Images/2c3342fef10fcbc8eff1e6c77f4dee86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*42pFpGdKYSKJeo3xqZP-KA.png"/></div></div></figure><p id="e823" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">这是我们浏览器的当前状态。我们有一个空的调用堆栈，但是我们有一个项目等待在处理web API调用的线程中执行。这是我们最后的<code class="fe nq nr ns nt b">console.log</code>。</p><p id="f6bf" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">现在，每当对<code class="fe nq nr ns nt b">setTimeout</code>的调用完成时(<em class="lp">在本例中是瞬时的，因为我们用了0毫秒</em>)，我们就想执行它。为此，我们需要将它移回堆栈。因为这可以在未来的任何时候完成，但我们不知道什么时候，我们不能只是把它推到堆栈上，因为这将意味着我们的代码是不确定的。它会在某个时间点随机出现。</p><p id="8ba8" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">想象一个网络请求。它可以在300毫秒内完成，或者从不完成，或者介于两者之间。因此，取而代之的是，它被推入<strong class="kv ir">任务队列</strong>。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="7347" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">任务队列</h1><p id="143d" class="pw-post-body-paragraph kt ku iq kv b kw nj jr ky kz nk ju lb lc nl le lf lg nm li lj lk nn lm ln lo ij bi translated">任务队列<em class="lp">通常称为回调队列或事件队列</em>，负责收集每个成功执行的web API调用的返回值。</p><p id="fb65" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">每当我们的<code class="fe nq nr ns nt b">setTimeout</code>完成时，它的回调就被移入任务队列。在我们的例子中，最后一个<code class="fe nq nr ns nt b">console.log</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="mg mh di mi bf mj"><div class="gh gi mf"><img src="../Images/4e495dbd9d3e2220fa0183f2aef6bc10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d8q3JOuvrSXrCXJJhPUCmw.png"/></div></div></figure><p id="3973" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">所以现在我们有一个空的调用堆栈和一个空的web API线程。但是我们有<code class="fe nq nr ns nt b">console.log</code>在任务队列中等待。如果我们有多个web API调用，我们会将它们一个接一个地推入任务队列。</p><p id="a164" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">那么我们如何将任务队列中的事件放入调用堆栈呢？这就是<strong class="kv ir">事件循环</strong>出现的地方，文章的主角。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="d344" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">事件循环</h1><p id="61a7" class="pw-post-body-paragraph kt ku iq kv b kw nj jr ky kz nk ju lb lc nl le lf lg nm li lj lk nn lm ln lo ij bi translated">综上所述，事件循环可能是整个架构中最简单的部分:它的工作是查看任务队列和调用堆栈；</p><p id="bc64" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">如果调用堆栈为空，并且任务队列中有等待执行的事件，它会将任务队列中的第一个事件推回到调用堆栈中。并且一直持续到任务队列为空。这就是事件循环所做的全部工作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="no np l"/></div></figure><p id="07ba" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">因此，现在我们的最后一个<code class="fe nq nr ns nt b">console.log</code>被推回到调用堆栈中，再次被执行，因此我们得到:</p><pre class="kg kh ki kj gt oj nt ok ol aw om bi"><span id="90b2" class="on ms iq nt b gy oo op l oq or">🐹<br/>🐹🐹🐹<br/>🐹🐹</span></pre><p id="bfd1" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">对于0毫秒的<code class="fe nq nr ns nt b">setTimeout</code>，我们实际上是告诉JavaScript推迟调用，直到堆栈为空。</p><p id="9a37" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">所以下次你参加面试时，面试官会问你这样的问题:什么是事件循环？或者说JavaScript怎么可能同时是异步和单线程的呢？—希望你回答这些问题没有问题。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="bf91" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">建议</h1><p id="409a" class="pw-post-body-paragraph kt ku iq kv b kw nj jr ky kz nk ju lb lc nl le lf lg nm li lj lk nn lm ln lo ij bi translated">如果你仍然有疑问，但是这个教程对你没有任何意义，我真的不擅长分享知识。在任何情况下，如果你想更深入地研究上面提到的东西，并且你是视觉型的，我可以强烈推荐<a class="ae kr" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank">菲利普·罗伯茨的</a>到底是什么事件循环。</p><p id="44a0" class="pw-post-body-paragraph kt ku iq kv b kw kx jr ky kz la ju lb lc ld le lf lg lh li lj lk ll lm ln lo ij bi translated">他帮助我一劳永逸地理解了事件循环。这篇文章可能很大程度上反映了他的教导，因为他以这样一种可以理解的方式解释了它。他深入细致地解释了JavaScript运行时的内部工作方式，这种方式非常简单，即使是仓鼠也能很容易理解。🐹</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://medium.com/@ferencalmasi/membership"><div class="gh gi os"><img src="../Images/e66c4cd6d9849ac0bd245f3fc39b65c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZ9xuLqLkbqUG65sgVB3gg.png"/></div></a></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="http://webtips.dev/"><div class="gh gi ks"><img src="../Images/b0d8e0a0c2689a59aa62a677429b83b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*_QOx8lB1bc1rVmMjWQ3Yfw.png"/></div></a></figure></div></div>    
</body>
</html>