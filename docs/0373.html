<html>
<head>
<title>@ViewChild and @ViewChildren in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度中的@ViewChild和@ViewChildren</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/viewchild-and-viewchildren-in-angular-6dc0934d2cf9?source=collection_archive---------2-----------------------#2019-09-28">https://javascript.plainenglish.io/viewchild-and-viewchildren-in-angular-6dc0934d2cf9?source=collection_archive---------2-----------------------#2019-09-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="c581" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki"> @ViewChild </em>和<em class="ki">@ view child</em>是配置视图查询的属性装饰器。在这两种情况下，视图查询都是在调用<strong class="jm io">ngafterview it</strong>回调之前设置的。</p><p id="a406" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">@ViewChild 提供对视图DOM中匹配选择器的第一个元素或指令的访问。这个装饰器可以接受下面提到的三个元数据属性:</p><blockquote class="kj kk kl"><p id="6ffb" class="jk jl ki jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">选择器</strong> —用于查询的指令类型或名称。</p><p id="e22f" class="jk jl ki jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io"> read </strong> — True从查询的元素中读取不同的标记。</p><p id="4b9a" class="jk jl ki jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated"><strong class="jm io">静态</strong> — True表示在变更检测运行之前解析查询结果</p></blockquote><p id="a79c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> @ViewChildren </strong>提供来自视图DOM的元素或指令的<strong class="jm io"> QueryList </strong>。@ViewChildren只能取前两个元数据属性，即<strong class="jm io">选择器</strong>和<strong class="jm io">读取</strong>。</p><p id="d93e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在下面的代码图中，我们使用两个装饰器属性从父组件访问子组件/元素。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi kp"><img src="../Images/c6eb0a67fe5b7111077bd5bc29206c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*UFBm42Zu7Y90ESc0QLAzRA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">child.component.ts</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/570371d044c020155672e6aae6ebb7d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*qM-2yVj9RJdHTjW1EJn9FA.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">app.component.ts with @ViewChild example</figcaption></figure><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div class="gh gi lc"><img src="../Images/6bcfe3e2dab249e4a7fcef67aa700cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1366/format:webp/1*QhgYjMbsw-yecsenWQBe1Q.png"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">app.component.ts with @ViewChildren example</figcaption></figure><p id="586f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">就这样，我们结束了！！！:)</p></div></div>    
</body>
</html>