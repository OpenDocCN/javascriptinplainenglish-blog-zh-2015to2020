# 如何在 JavaScript 中遍历 DOM

> 原文：<https://javascript.plainenglish.io/how-to-traverse-the-dom-in-javascript-d6555c335b4e?source=collection_archive---------0----------------------->

![](img/41f951c6f2d89bf21d537bd55d3f3e95.png)

“pink sakura tree at day time” by [Faye Cornish](https://unsplash.com/@fcornish?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

文档对象模型，简称 DOM，是浏览器在网页上放置元素时的参考。元素在 DOM 中放置的位置叫做`Nodes`，在网页上，并不是只有 HTML 元素才有它们的节点，HTML 元素的属性也有它们的节点(`attribute nodes`)，每一段文本都有它的节点(`text nodes`)，还有很多其他的节点类型。这些节点的结构关系反映了 HTML 文档的结构。因此，我们可以将页面上元素之间的关系定义为它们在 DOM 中的节点之间的关系。

当我们用编程语言(比如 JavaScript)操作网页上的元素时，我们是通过它们的 DOM 节点来完成的。通过访问给定元素的 DOM 节点，我们可以操纵它的属性，比如位置、外观、内容、行为等。通常，我们希望在元素之间有某种关系的元素上执行操作，这种关系称为相关节点。为了做到这一点，我们必须有一种从一个节点移动到另一个节点的方法，也就是遍历 DOM 的方法。

有了对 DOM 中某个节点的访问权，就有了使用相关节点遍历 DOM 的方法。我们可以在 DOM 树中上下移动，也可以在同一 DOM 级别上横向移动。在本文中，我们将了解如何使用 JavaScript 编程语言访问相关的 DOM 节点。

# DOM 节点之间的关系

首先，让我们看看元素之间存在什么关系，以便我们以后能够更好地理解访问它们所使用的技术。HTML 元素相互嵌套，形成树状结构。嵌套元素可能有很多层，所有这些都反映在元素节点的 DOM 树中。

## 后代和祖先元素

这个关系没有实际用途，但是它将帮助我们更清楚地表达一些元素关系。

一个元素下可能嵌套了许多层的其他元素，所有嵌套层中的所有嵌套元素都被称为起始元素的**后代**元素。例如，让我们用一个`main`元素作为页面的主要内容，其内容如下:

在嵌套的第一层有`<h1>`元素和两个<文章>元素。然后，在第二嵌套层次我们有`<h2>`和`<section>`元素，最后在第三层次有`<p>`元素在`<section>`元素里面。所有这些元素都是`<main>`元素的后代。

也就是说，`<main>`元素是它们的**祖先**元素，也就是它们在 DOM 树中所属的元素。

但是在这个例子中，在其他元素之间也可以看到后代/祖先关系。例如，`<article>`元素是它们嵌套的`<h2>`、`<section>`和`<p>`元素的祖先，而这些元素又是它的后代元素。同样的关系也适用于`<section>`和`<p>`元件。

在这里，我们必须指出一个重要的事情。例如，标题“如何种植盆景”不是`<article id=”article-1">`的后代，那篇文章也不是提到的标题的祖先。这是因为“如何种植盆景”的标题并不在第一篇文章中，而是在第二篇文章中。因此，它们之间没有后代/祖先关系。这同样适用于`<section>`和`<p>`元素，它们是嵌套它们的 article 元素的后代，而 article 元素是它们的祖先。

## 父和子元素

特殊且非常有用的后代/祖先关系是元素是给定节点的直接后代或祖先的情况。“直接”意味着它们离给定的节点只有一个嵌套层次。

**父节点**(元素)是给定元素最接近的祖先元素。如果我们选择标题“如何种植盆景”，第一个祖先元素(向上一级)是`<article id=”article-2">`元素，我们称它为给定标题的父元素。`<article>`元素共享同一个父元素，它们都嵌套在作为其父元素的`<main>`元素下。注意`<h1>`也有`<main>`元素作为其父元素。“我们现在做什么！?"第一个项目元素下有`<section>`元素作为其父元素。

与父元素相对的是**子元素**，但是虽然该元素只能有一个父元素，但是它下面可以有多个子元素。子元素是给定元素的所有直接后代元素(向下一级)。`<main>`元素的子元素是`<h1>`和`<article>`元素，没有其他元素。第二篇文章的子元素是“如何种植盆景”标题和嵌套在它下面的`<section>`。该部分中的段落不是第二个文章元素的子元素，而是`<section>`元素的子元素。

这里需要注意的另一件重要的事情是，HTML 中的每一位文本在 DOM 中都有一个**文本节点**。鉴于此，第一篇文章中的标题有一个文本节点作为其子节点，该节点包含文本“人类历史上第一次接触外星生物”，并且标题元素是该文本节点的父节点，第二篇文章中的标题是文本为“如何种植盆景”的子文本节点的父节点。

## 同级元素

如果两个或多个元素的父元素相同，则它们是同级元素。在我们的示例中，`<h1>`和两个`<article>`元素是同级的，因为它们有相同的父元素，即`<main>`元素。第一篇文章中的`<p>`元素是同级元素，因为它们的父元素是第一篇文章中的`<section>`元素。但是第二篇文章中的`<p>`元素不是第一篇文章中的`<p>`元素的同级，因为它们并不共享同一个父元素，即使它们处于相同的嵌套级别。

# 通过相关节点遍历 DOM

最后，我们将看到如何使用节点之间的关系来遍历 DOM 树。DOM 树中的一个节点用一个 node 对象表示，Node 对象具有允许我们访问给定节点的相关节点的属性。

我们将在示例 HTML 中添加一些 id 和类，以便更好地访问 DOM 树中的元素:

## 查找给定节点的父节点

如果我们有一个 Node 对象，它是对 DOM 中的一个`node`的引用，为了获得它的父节点，我们可以使用`node`上的`parentNode`属性。由于`node`是一个对象，`parentNode`是一个属性，我们可以使用‘点’符号来访问`node`的父元素，如下所示:

```
const parent = node.parentNode;
```

让我们在示例 HTML 中找到第一个文章节点的父节点。

现在，让我们找到标题“如何种植盆景”的父代。

我们可以使用给定节点的父节点来获取 DOM 树中给定节点的所有祖先。例如:

也可以通过在`bonsai`节点上链接 parentNode `property`来获得`grandParent`节点:

```
const grandParent = bonsai.parentNode.parentNode;
```

`parentNode`通常用于从 DOM 中移除给定的节点。假设我们想从文档中删除第一篇文章，因为它太令人苦恼了。我们会这样做:

HTML 元素的父元素可以是元素节点、文档节点或文档片段节点。在应用于 Document 和 DocumentFragment 节点的情况下，节点的`parentNode`属性可以返回`null`，因为它们永远不会有父节点。如果刚刚创建了一个节点，但是它没有附加到 DOM，那么对它应用`parenNode`也会返回`null`。

还有一点需要注意的是,`parentNode`属性是一个只读属性，这意味着不可能做这样的事情:

## 查找给定节点的子节点

要获得一个`node`的所有子节点，我们可以使用它的`childNodes`属性。例如:

```
const children = node.childNodes;
```

结果是一个节点列表，每个对象代表我们的`node`的一个子节点。节点列表在某种程度上类似于数组，可以使用数组索引遍历列表。例如，让我们打印一个节点列表中所有子节点的`nodeName`属性。

让我们用一个不同的 HTML 来解释使用`childNodes`属性的一些重要含义:

如果我们应用前面的 javascript 代码打印出来自`<ul>`元素的子节点的节点名，我们将得到这样的结果:

不完全如人们所料。您可能认为只会打印出六个`li`元素名称，但是我们得到了七个以上的文本节点。

这是因为节点列表还包含文本节点和注释节点，所以我们在使用该属性时必须小心。发生这种情况是因为在 HTML 中，新的一行被视为空白，即文本节点。因此，HTML 标记之间的换行符和空白将文本节点添加到子节点列表中。

为了避免这种情况，我们可以像这样重新组织我们的 HTML 结构:

现在我们得到了预期的输出:

节点列表是节点的动态列表。这意味着在`node`中添加或删除子元素会更新列表，我们不必再次获取它。这也意味着，如果节点列表中的元素数量发生变化，像这样使用的`for`循环将会失败:

这段代码将在第六次迭代时导致错误:`TypeError: children[i] is undefined`。这是因为`children`节点列表随着删除第三项而改变。为了避免这种情况，我们应该在每次迭代中更新`len`变量，或者更好的是，在循环条件中使用`children.length`而不是我们所做的`len`。

如果我们只想获得 HTML 元素作为`node`的子元素，我们可以使用`children`属性而不是`childNodes`属性:

```
const childElements = list.children;
```

## “特殊”儿童

嗯，通常在家庭中，孩子们中有最喜欢的，那些“特别”的。node 家族也是如此，有些孩子很特别。那些是什么孩子？—你可能会问。你可能猜到了，这是第一个也是最后一个。:)

这个类比不是一个毫无意义的笑话。在 DOM 树中，具有子节点的节点已经定义了属性`firstChild`和`lastChild`。它们用于快速查找给定节点下的第一个和最后一个子节点。在我们的例子中，第一个孩子对应于第一个列表项，最后一个孩子对应于第六个列表项。下面是我们获取这些元素的方法:

需要注意的是，`firstChild`和`lastChild`也将换行符视为文本节点，在我们的第一个列表(带有换行符的列表)中，它们会产生文本节点，而不是列表项。

## 查找节点的兄弟节点

当我们可以访问一个`node`时，我们可以使用`nextSibling`和`previousSibling`属性访问它的兄弟节点。

属性`nextSibling`将获得紧跟在给定的`node`之后的兄弟节点。语法如下:

```
const next = node.nextSibling;
```

让我们找到带有`id=”three”`的条目的下一个兄弟条目:

现在，我们可以一步一步地浏览下面的兄弟姐妹:

当我们到达父节点中的最后一个兄弟节点时，使用`nextSibling`将返回`null`，因为在最后一个子节点之后不再有兄弟节点:

属性`previousSibling`将获得紧接在给定`node`之前的兄弟节点。该语法类似于`nextSibling`的语法:

```
const previous = node.previousSibling;
```

让我们找到带有`id=”three”`的条目的前一个兄弟条目:

我们现在可以一步一步地检查其他以前的兄弟姐妹:

当我们到达父节点中的第一个兄弟节点时，使用`previousSibling`将返回`null`，因为在第一个子节点之前没有兄弟节点:

# 最后一个例子

现在，让我们做一个例子，这个例子需要比我们之前的例子更复杂的遍历。让我们再次使用第一个 HTML 示例结构:

假设我们可以访问第一篇文章的标题(`<h2 class=”sensations”>`)，我们想阅读下一篇文章的标题文本。

糟糕，错误的节点！请记住，换行符被视为空白，并且空白与文本节点一起呈现。那么，如何才能避免这种情况呢？

我们可以使用一个循环，遍历下一个兄弟节点，检查节点是否是元素节点，而不是文本或任何其他节点。为了检查一个`node`是否是一个元素节点，我们可以检查一个叫做`nodeType`的节点属性。元素节点的`nodeType`属性将具有值`ELEMENT_NODE`，该值被称为常量，或者它可以具有数值`1`，您可以检查其中任何一个。要查看所有其他节点类型及其值，您可以查看[这篇文章](https://developer.mozilla.org/en/docs/Web/API/Node/nodeType)。

这个任务最好使用`while`循环。让我们更改前面的代码，添加一个 while 循环并检查节点类型。

现在我们已经找到了下一篇文章。最后，我们希望得到它下面的标题。因为我们知道标题是文章节点下的第一个元素节点，所以我们可以考虑在`nextNode`节点上使用`firstChild`属性，但是文本节点的问题会再次出现。为了避免这种情况，我们可以再次使用循环来检查节点的类型，或者我们可以使用`nextNode`上的`querySelector`来获取第一个`h2`元素，并且，第二种方法可能是最安全的。但是，为了便于实践，让我们使用前面简单提到的`node`对象的`children`属性。

属性将返回列表子元素节点，然后我们可以从列表中选择第一个。以下是完整的代码:

# 结论

仔细看看最后一个例子，有人可能会问，当我们可以像这样做一个简单的查询时，为什么还要遍历所有相关的节点呢？

```
const secondH2 = document.querySelector('.horticulture');
```

虽然在这个简单的例子中确实如此，但是请记住，我们明确地想要到达下一篇文章的标题，并且在一个真实的网站中，页面可以大得多，内容可以嵌套得更深。此外，内容可以自动生成，我们不知道什么类将对我们可用。因此，我们必须对每个下一个标题进行完整的 DOM 查询。但是通过使用相关的兄弟节点，我们能够在我们感兴趣的节点周围，而不是每次都查询整个 DOM 树，因此当我们有一个非常大的网页时，可以提高性能。

为了在包含许多文章的大型 web 页面上有效地使用这一点，我们可以将其全部封装到一个函数中，该函数接受当前节点作为参数:

请注意，我们在 while 循环条件中增加了一个检查`nextNode.nodeName === ‘ARTICLE’`,只是为了确保我们得到了正确的元素类型，因为可能会发生这样的情况，即 article 元素的其他兄弟元素不是 article。

现在，我们可以在第二个标题上调用函数`nextHeading`,尝试从下一篇文章中获取标题:

有许多用例可以使用相关节点来遍历 DOM。您将使用的方法取决于 HTML 结构和您的想象力。所以，好好了解节点家族和它们之间的关系，它们会对你的 DOM 相关任务有很大帮助。

感谢您的阅读，并祝您在 DOM 中找到自己的路！