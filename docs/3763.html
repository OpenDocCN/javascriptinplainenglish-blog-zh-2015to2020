<html>
<head>
<title>React State Management In 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2020年反应状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-state-management-in-2020-4186766426da?source=collection_archive---------3-----------------------#2020-10-23">https://javascript.plainenglish.io/react-state-management-in-2020-4186766426da?source=collection_archive---------3-----------------------#2020-10-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8f8cffc0aae70172edc255f6f12d6140.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9nUzMbYAJTDPK-ypIdorkg.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@martinsanchez?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Martin Sanchez</a> on <a class="ae jd" href="https://unsplash.com/s/photos/stack?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="7828" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">如果您正在使用React或React Native构建web或移动应用程序，您可能知道管理应用程序的状态是关键，如果有数百个甚至数千个组件，它会很快变成一个复杂的难题。那么目前使用的不同方法是什么，它们的优缺点是什么？</em></p><h1 id="5512" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">老类组件方式</strong></h1><p id="9a0a" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">React有两种类型的组件:类和函数。函数组件最初是“哑”的，不包含任何状态，而状态是存储在类组件中的。状态值在<code class="fe mf mg mh mi b">state</code>对象中初始化，并通过<code class="fe mf mg mh mi b">this.setState()</code>进行更新，后者把要更新的值作为参数，例如<code class="fe mf mg mh mi b">this.setState({ counter: 1 })</code>会把名为counter的状态变量的值设置为1。</p><p id="de18" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">语法遵循javascript类的规则，但是在React组件的上下文中，它很快变得相当沉重:到处都有许多<code class="fe mf mg mh mi b">this.</code>和<code class="fe mf mg mh mi b">this.state</code>。</p><p id="5f5b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，它逐渐被抛弃，转而支持函数组件中使用的React挂钩。</p><h1 id="2ed0" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">新反应钩道</h1><p id="a808" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在2018年10月的<a class="ae jd" href="https://www.youtube.com/watch?v=dpw9EHDh2bM" rel="noopener ugc nofollow" target="_blank"> React Conf </a>期间推出，承诺让我们的组件逻辑更清晰，通过功能组件处理状态和生命周期方法。</p><p id="0488" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用钩子<code class="fe mf mg mh mi b">useState</code>而不是将所有状态变量存储在同一个对象中，例如:</p><p id="bb67" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mf mg mh mi b">const [counter, setCounter] = useState(0)</code></p><p id="c681" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们声明了一个变量<code class="fe mf mg mh mi b">counter</code>，提供了一个初始值<code class="fe mf mg mh mi b">0</code>，还声明了一个特定的setter。对于改变计数器的值，语句<code class="fe mf mg mh mi b">setCounter(1)</code>就足够了，不需要更多的<code class="fe mf mg mh mi b">this.state</code>，我们只调用<code class="fe mf mg mh mi b">counter</code>。</p><p id="87fe" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">语法上的这一重大改进使得React挂钩流行起来，构建类组件的需求也逐渐减少。</p><p id="54ef" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">状态很容易通过props沿着组件树向下移动，但是反过来需要一些状态提升。</p><h1 id="ebb2" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">提升状态</h1><p id="a942" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">在React中，当数据通过props传递时，它总是沿着组件树向下流动，但是由于我们经常需要将数据向上移动到组件，React应用程序经常需要所谓的“状态提升”。对于类组件和钩子来说都是如此。</p><p id="2dc4" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要解除状态:</p><ul class=""><li id="b41e" class="mj mk jg kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">函数在父组件中声明或赋值</li><li id="bdc4" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">它通过props传递给子组件(或更高)</li><li id="f9f4" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">该函数的执行导致状态更新</li><li id="b8be" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">当该函数沿树向下执行时，它可以将数据作为参数，然后将其提升到父组件状态</li></ul><p id="2a02" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是一个非常简单的例子，使用React钩子:</p><pre class="mx my mz na gt nb mi nc nd aw ne bi"><span id="3b97" class="nf ld jg mi b gy ng nh l ni nj">// This component executes the function that results in state update</span><span id="9b5a" class="nf ld jg mi b gy nk nh l ni nj">const ChildComponent = ({incrementCounter}) =&gt; {</span><span id="ecf7" class="nf ld jg mi b gy nk nh l ni nj">   return (<br/>      &lt;React.Fragment&gt;<br/>         &lt;Button onClick={incrementCounter}<br/>      &lt;/React.Fragment&gt;<br/>   )<br/>}</span><span id="b172" class="nf ld jg mi b gy nk nh l ni nj">// This component receives the state</span><span id="ee80" class="nf ld jg mi b gy nk nh l ni nj">const ParentComponent = () =&gt; {<br/>   const [counter, setCounter] = useState(0)<br/>   const incrementCounter = () =&gt; {<br/>      setCounter(counter+1)<br/>   }</span><span id="127b" class="nf ld jg mi b gy nk nh l ni nj">   return (<br/>      &lt;React.Fragment&gt;<br/>         &lt;p&gt;Counter is at value: {counter}&lt;/p&gt;<br/>         &lt;ChildComponent incrementCounter={incrementCounter}/&gt;<br/>      &lt;/React.Fragment&gt;<br/>   )<br/>};</span></pre><p id="ee91" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里子组件没有给出数据，但是状态更新的动作是通过按钮触发的。如果我们直接传递<code class="fe mf mg mh mi b">setCounter</code>,我们也可以用来自子组件的任何值来填充它，它将再次被提升到父组件。</p><p id="bce5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我不会深入细节，而是链接到更多的<a class="ae jd" href="https://medium.com/javascript-in-plain-english/react-components-lifting-state-up-59175b9efc9e" rel="noopener">复杂例子</a>以及<a class="ae jd" href="https://dev.to/aryanjnyc/freecodecamp-pomodoro-clock-02-lifting-state-up-and-react-props-1bp0" rel="noopener ugc nofollow" target="_blank">教程</a>。几乎所有React应用程序都使用状态提升，优点是:</p><ul class=""><li id="7cb3" class="mj mk jg kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">易于实施</li><li id="f98b" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">状态保留在使用它的组件中</li><li id="4d0c" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">不需要额外的依赖</li></ul><p id="1b53" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，如果我们看看不利的一面:</p><ul class=""><li id="b4b1" class="mj mk jg kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated">当许多变量需要提升时，很快变得混乱</li><li id="1960" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">当国家需要跨越许多层面时，很难理解</li><li id="a773" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated">大量额外的代码</li></ul><p id="e12b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">直截了当地说，在一个像样的应用程序中，仅仅使用状态提升通常不足以解决状态管理问题。不过好在有些库，其中著名的<a class="ae jd" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>带来了不同的解决方案。</p><figure class="mx my mz na gt is gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/94ad7605905dce386065ffb7e4e904a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*do7-mf1ZAelHy4UibdcfhA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">credits to <a class="ae jd" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank">https://redux.js.org/</a>, obviously</figcaption></figure><h1 id="6cc4" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">Redux方式</h1><p id="1952" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">Redux可以与React一起使用，也可以与Angular、Vue.js等一起使用，通过所谓的“Redux Store”为状态管理提供集中和灵活的解决方案，Redux Store充当全局状态管理工具，可以存储整个应用程序的状态。</p><p id="cb41" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">听起来不错，不是吗？全局管理状态确实非常方便。Redux与其他状态管理方法兼容，与React挂钩兼容，并附带一套Chrome开发工具，您可以在其中检查您的应用程序。中型web应用程序实际上也使用Redux。</p><p id="a3bb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它围绕以下要素工作:</p><ul class=""><li id="d83d" class="mj mk jg kf b kg kh kk kl ko ml ks mm kw mn la mo mp mq mr bi translated"><strong class="kf jh">Store:</strong>顾名思义，存储全局状态。它通过<code class="fe mf mg mh mi b">createStore</code>启动，并以一个减速器作为参数。</li><li id="2184" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated"><strong class="kf jh">动作:</strong>返回一个对象的函数，该对象包含一个或多个要执行的动作的名称。这些名称将被缩减器使用。</li><li id="e93e" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated"><strong class="kf jh">减速器:</strong>取初始状态和一组作用于该状态的动作。当一个动作发生时，状态会根据reducer中的描述进行更新。它可以比作<code class="fe mf mg mh mi b">setState</code>功能。</li><li id="8b9e" class="mj mk jg kf b kg ms kk mt ko mu ks mv kw mw la mo mp mq mr bi translated"><strong class="kf jh">分派:</strong>采取行动并执行。</li></ul><p id="374b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">起初这看起来有点混乱，事实上，完全掌握Redux的学习曲线相当陡峭。该库有时会被许多人批评引入了太多的复杂性和太多的样板文件:从代码youtubers <a class="ae jd" href="https://www.youtube.com/watch?v=CVpUuw9XSjY&amp;t=1648" rel="noopener ugc nofollow" target="_blank">在他们的Redux教程中抱怨它的</a>，到Reddit 上的社区或联合创建者Dan abra mov——他自己在<a class="ae jd" href="https://twitter.com/dan_abramov/status/1039570011986321408" rel="noopener ugc nofollow" target="_blank"> Twitter </a>上承认他<em class="lb">“采取了错误的方法来解释它”</em>。</p><p id="f663" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也就是说，Redux仍然是大型应用中复杂状态管理的一个非常好的解决方案。</p><p id="ddd2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几个备选库可以帮助您处理同一个问题:<a class="ae jd" href="https://mobx.js.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kf jh">Mobx</strong></a><strong class="kf jh"/>是<strong class="kf jh"> </strong>的热门挑战者，尽管只有Redux的十分之一，<strong class="kf jh"> Apollo GraphQL </strong>在某种程度上，因为本地状态可以存储在<a class="ae jd" href="https://www.apollographql.com/docs/tutorial/local-state/" rel="noopener ugc nofollow" target="_blank"> Apollo cache </a>或vey small challenger<a class="ae jd" href="https://www.npmjs.com/package/pullstate" rel="noopener ugc nofollow" target="_blank"><strong class="kf jh">pull state</strong></a>中，受益于不断增长的人气。</p><p id="af08" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我想关注的是React: Context中自带的API。</p><h1 id="99da" class="lc ld jg bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">反应上下文方式</h1><p id="f425" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">如果我们可以采取一种类似Redux的方法，同时去掉所有不必要的复杂性，会怎么样呢？2018年React版本16.3.0首次引入了上下文来解决这个问题，并由于其实现通过挂钩<code class="fe mf mg mh mi b">useContext</code>和<code class="fe mf mg mh mi b">useReducer</code>变得非常容易而逐渐变得流行。</p><p id="7a42" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上下文的原则是有一个<code class="fe mf mg mh mi b">Provider</code>，它存储状态，包装你的整个应用，并通过<code class="fe mf mg mh mi b">Reducers</code>调用状态更新。任何需要消耗状态的组件都称为<code class="fe mf mg mh mi b">useContext</code>。</p><p id="b5d6" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具体细节我就不赘述了，可以推荐以下2个教程来详细了解实现:<a class="ae jd" href="https://medium.com/javascript-in-plain-english/how-to-use-react-context-api-with-functional-component-472f1d5e0851" rel="noopener">号1 </a>和<a class="ae jd" href="https://dev.to/ibrahima92/redux-vs-react-context-which-one-should-you-choose-2hhh" rel="noopener ugc nofollow" target="_blank">号2 </a>。</p><p id="29eb" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然它与Redux有相似之处，但我个人认为React Context很容易上手，非常灵活，并且它有一个很大的优势，即不需要额外的外部库。</p><p id="eadc" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，不利的一面是，需要注意的是，当状态更新时，任何使用上下文的组件都将重新呈现，这对于性能至关重要的大型应用程序来说是一个很大的警告。然而，这个问题可以通过引入多个上下文，限制重新渲染的次数来解决。</p></div><div class="ab cl nm nn hu no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ij ik il im in"><h1 id="909c" class="lc ld jg bd le lf nt lh li lj nu ll lm ln nv lp lq lr nw lt lu lv nx lx ly lz bi translated">最后的想法</h1><p id="4c49" class="pw-post-body-paragraph kd ke jg kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">管理每个React应用程序的状态没有一个完美的解决方案，而是一组提供不同灵活性、速度或简单性的技术。</p><p id="c521" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应用程序的理想状态管理是几种最适合您需求的技术的完美结合。</p></div></div>    
</body>
</html>