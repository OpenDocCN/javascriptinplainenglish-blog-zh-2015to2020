<html>
<head>
<title>Maintainable JavaScript — App Logic and Primitive Value Checks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可维护的JavaScript —应用程序逻辑和原始值检查</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/maintainable-javascript-app-logic-and-primitive-value-check-5f15f68a5767?source=collection_archive---------12-----------------------#2020-09-24">https://javascript.plainenglish.io/maintainable-javascript-app-logic-and-primitive-value-check-5f15f68a5767?source=collection_archive---------12-----------------------#2020-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d1087d5e85511a4620b84cf02e97a6e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SkQJwBAS6I0EyxFZ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mangofantasy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tim Johnson</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7e8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果想继续使用代码，创建可维护的JavaScript代码很重要。</p><p id="9221" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将通过将应用程序逻辑与事件处理分离来了解创建可维护的JavaScript代码的基础。</p><p id="4014" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们看看如何检查原始值。</p><h1 id="f7a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">事件对象</h1><p id="3f24" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们处理事件时，我们应该只在事件处理程序中保存<code class="fe me mf mg mh b">event</code>对象。</p><p id="2f97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将减少代码中的耦合。</p><p id="e30d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们需要使用来自<code class="fe me mf mg mh b">event</code>对象的东西，我们将它们保存在事件处理程序中。</p><p id="80d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b74d" class="mq lc iq mh b gy mr ms l mt mu">function onclick(event) {<br/>  const {<br/>    clientX,<br/>    clienty,<br/>    preventDefault,<br/>    stopPropagation<br/>  } = event;<br/>  <br/>  preventDefault();<br/>  stopPropagation();<br/>  showPopup(clientX, clienty);<br/>}</span><span id="ea81" class="mq lc iq mh b gy mv ms l mt mu">function showPopup(x, y) {<br/>  const popup = document.getElementById("popup");<br/>  popup.style.left = `${x}px`;<br/>  popup.style.top = `${y}px`;<br/>  popup.className = "popup";<br/>}</span><span id="a7b1" class="mq lc iq mh b gy mv ms l mt mu">const button = document.querySelector('button');<br/>button.addEventListener('click', onClick);</span></pre><p id="2328" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从事件处理程序中的<code class="fe me mf mg mh b">event</code>对象调用了<code class="fe me mf mg mh b">preventDefault</code>和<code class="fe me mf mg mh b">stopPropagation</code>方法。</p><p id="5f44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比传递<code class="fe me mf mg mh b">event</code>对象并在那个函数中调用它要好得多。</p><p id="cf3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不希望我们的应用程序逻辑代码和事件处理代码混淆。</p><p id="4286" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以独立地更改应用程序逻辑和事件处理代码。</p><p id="00a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而且我们可以直接调用app逻辑代码。</p><p id="1908" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fe5b" class="mq lc iq mh b gy mr ms l mt mu">showPopup(10, 10);</span></pre><p id="1962" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也使得测试更加容易，因为我们可以直接调用<code class="fe me mf mg mh b">showPopup</code>来测试它。</p><h1 id="dcdc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免空值比较</h1><p id="6513" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript代码中一个常见的问题模式是根据<code class="fe me mf mg mh b">null</code>测试变量。</p><p id="849f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可能有这样的代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d8a9" class="mq lc iq mh b gy mr ms l mt mu">function process(items) {<br/>   if (items !== null) {<br/>     items.sort();<br/>     items.forEach((item) =&gt; {<br/>       //...<br/>     });<br/>   }<br/> }</span></pre><p id="70b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个<code class="fe me mf mg mh b">process</code>函数，它根据<code class="fe me mf mg mh b">null</code>来检查<code class="fe me mf mg mh b">items</code>。</p><p id="9613" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们假设<code class="fe me mf mg mh b">items</code>是一个数组，并对其调用<code class="fe me mf mg mh b">sort</code>和<code class="fe me mf mg mh b">forEach</code>。</p><p id="590f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与<code class="fe me mf mg mh b">null</code>比较并不意味着我们确定它是一个数组。</p><p id="372f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只知道不是<code class="fe me mf mg mh b">null</code>。</p><p id="c3cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以改进我们的价值比较，这样我们就可以真正检查我们想要什么。</p><h1 id="b1cf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检测原始值</h1><p id="c8fe" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript中有几种原始值。</p><p id="7e96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们包括bigints、strings、numbers、booleans、<code class="fe me mf mg mh b">null</code>和<code class="fe me mf mg mh b">undefined</code>。</p><p id="c257" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">typeof</code>操作符是检查原始值类型的最佳操作符。</p><p id="317b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需要把想要检查的表达式作为操作数传入。</p><p id="f8cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于字符串，<code class="fe me mf mg mh b">typeof</code>返回<code class="fe me mf mg mh b">'string'</code>。</p><p id="332d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于数字，<code class="fe me mf mg mh b">typeof</code>返回<code class="fe me mf mg mh b">'number'</code>。</p><p id="3dc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于布尔值，<code class="fe me mf mg mh b">typeof</code>返回<code class="fe me mf mg mh b">'boolean'</code>。</p><p id="b9d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于bigints，<code class="fe me mf mg mh b">typeof</code>返回<code class="fe me mf mg mh b">'bigint'</code>。</p><p id="0b5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而对于<code class="fe me mf mg mh b">undefined</code>，<code class="fe me mf mg mh b">typeof</code>返回<code class="fe me mf mg mh b">'undefined'</code>。</p><p id="3888" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">typeof</code>的基本语法是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="530d" class="mq lc iq mh b gy mr ms l mt mu">typeof variable</span></pre><p id="c991" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0731" class="mq lc iq mh b gy mr ms l mt mu">typeof(variable)</span></pre><p id="8217" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，第二种方法使<code class="fe me mf mg mh b">tyepof</code>看起来像一个函数。</p><p id="81a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该不用括号。</p><p id="5515" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">tupeof</code>操作符来检查表达式值的类型，从而编写防御性的bu代码。</p><p id="11c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bf24" class="mq lc iq mh b gy mr ms l mt mu">if (typeof name === "string") {<br/>  let part = name.substring(3);<br/>}</span></pre><p id="2108" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查字符串。</p><p id="9739" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="db7d" class="mq lc iq mh b gy mr ms l mt mu">if (typeof count === "number") {<br/>  setCount(count);<br/>}</span></pre><p id="27f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查并设定一个数字。</p><p id="f231" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="229f" class="mq lc iq mh b gy mr ms l mt mu">if (typeof canShowMessage === "boolean" &amp;&amp; canShowMessage) {<br/>  showMessage("hello");<br/>}</span></pre><p id="3bb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查布尔值以及它是否是<code class="fe me mf mg mh b">true</code>。</p><p id="b141" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="467b" class="mq lc iq mh b gy mr ms l mt mu">if (typeof app === "undefined") {<br/>  app = {<br/>    // ....<br/>  };<br/>}</span></pre><p id="f8c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来检查<code class="fe me mf mg mh b">undefined</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/cc10982fdaabf438e495c967a603e5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GY_yy0CN6YZih9WF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rami_alzayat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rami Al-zayat</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3cd4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="bf68" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该让我们的应用程序逻辑依赖于<code class="fe me mf mg mh b">event</code>对象。</p><p id="e1f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，检查<code class="fe me mf mg mh b">null</code>并不足以检查大多数类型的数据。</p></div></div>    
</body>
</html>