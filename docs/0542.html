<html>
<head>
<title>Upload to Azure Blob Storage with Angular 8</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Angular 8上传到Azure Blob存储</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/upload-to-azure-blob-storage-with-angular-8-2ed80dfc6672?source=collection_archive---------0-----------------------#2019-11-06">https://javascript.plainenglish.io/upload-to-azure-blob-storage-with-angular-8-2ed80dfc6672?source=collection_archive---------0-----------------------#2019-11-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3284" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何使用从您的后端生成的<em class="kc">共享访问签名</em> (SAS)令牌将多个文件上传到浏览器中的blob存储。</h2></div><blockquote class="kd ke kf"><p id="064d" class="kg kh ki kj b kk kl jo km kn ko jr kp kq kr ks kt ku kv kw kx ky kz la lb lc ig bi translated">注意:这是对我之前文章的更新，我之前的文章使用的是Azure Storage js库的旧版本。<a class="ae ld" href="https://medium.com/@stuarttottle/upload-to-azure-blob-storage-with-angular-7977e979496a" rel="noopener">https://medium . com/@ stuarttotle/upload-to-azure-blob-storage-with-angular-7977 e 979496 a</a></p></blockquote><p id="5a71" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">我们将使用Angular 8和<a class="ae ld" href="https://www.npmjs.com/package/@azure/storage-blob" rel="noopener ugc nofollow" target="_blank"> @azure/storage-blob </a>库来上传文件。</p><p id="b765" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">最终代码在<a class="ae ld" href="https://github.com/stottle-uk/stottle-angular-blob-storage" rel="noopener ugc nofollow" target="_blank"> Github </a>上，其中还包含了列出容器、blob项目以及删除和下载blob项目的示例。</p><figure class="li lj lk ll gt lm gh gi paragraph-image"><div role="button" tabindex="0" class="ln lo di lp bf lq"><div class="gh gi lh"><img src="../Images/8a554496e5df623e5ca641de9855e937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*cWjUUKOJ9Hpjw-gV.png"/></div></div></figure><p id="dc3f" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">我们会过去的</p><ul class=""><li id="bdd9" class="lt lu in kj b kk kl kn ko le lv lf lw lg lx lc ly lz ma mb bi translated">创建用于选择和上传文件的组件</li><li id="dd43" class="lt lu in kj b kk mc kn md le me lf mf lg mg lc ly lz ma mb bi translated">创建服务来管理上载的视图状态</li><li id="4cb2" class="lt lu in kj b kk mc kn md le me lf mf lg mg lc ly lz ma mb bi translated">使用SAS令牌保护到Blob存储的上传</li><li id="8d83" class="lt lu in kj b kk mc kn md le me lf mf lg mg lc ly lz ma mb bi translated">创建一个服务来包装@azure/storage-blob库中的<code class="fe mh mi mj mk b">uploadBrowserData</code>方法，以将文件上传到blob存储</li><li id="c926" class="lt lu in kj b kk mc kn md le me lf mf lg mg lc ly lz ma mb bi translated">创建显示上传进度的组件</li></ul><h1 id="f803" class="ml mm in bd mn mo mp mq mr ms mt mu mv jt mw ju mx jw my jx mz jz na ka nb nc bi translated">创建文件上传组件</h1><p id="1c28" class="pw-post-body-paragraph kg kh in kj b kk nd jo km kn ne jr kp le nf ks kt lf ng kw kx lg nh la lb lc ig bi translated"><code class="fe mh mi mj mk b">InputFileComponent</code>组件允许用户选择一个或多个文件进行上传</p><p id="f796" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">我们会掩护</p><ol class=""><li id="4d5c" class="lt lu in kj b kk kl kn ko le lv lf lw lg lx lc ni lz ma mb bi translated">选择一个或多个要上传的文件</li><li id="144e" class="lt lu in kj b kk mc kn md le me lf mf lg mg lc ni lz ma mb bi translated">调用视图状态服务上的方法以开始上载</li></ol><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="8fb8" class="nl mm in bd mn nm nn dn mr no np dp mv le nq nr mx lf ns nt mz lg nu nv nb nw bi translated">发生了什么事？</h2><p id="812c" class="pw-post-body-paragraph kg kh in kj b kk nd jo km kn ne jr kp le nf ks kt lf ng kw kx lg nh la lb lc ig bi translated">我们隐藏了输入，文件对话框用按钮打开。当用户选择文件时，在<code class="fe mh mi mj mk b">BlobUploadsViewStateService</code>上调用<code class="fe mh mi mj mk b">uploadItems</code>方法。我们可以在这里添加一些验证，但对我来说，在视图状态服务中进行验证更有意义。</p><h1 id="004a" class="ml mm in bd mn mo mp mq mr ms mt mu mv jt mw ju mx jw my jx mz jz na ka nb nc bi translated">创建上传视图状态服务</h1><p id="c22a" class="pw-post-body-paragraph kg kh in kj b kk nd jo km kn ne jr kp le nf ks kt lf ng kw kx lg nh la lb lc ig bi translated"><code class="fe mh mi mj mk b">BlobUploadsViewStateService</code>服务管理组件的共享视图状态。我非常熟悉NGRX和redux模式，所以我创建了一个服务，您可以向其中提供项目来触发操作，并让observables监听更改。这也意味着我们可以将业务逻辑从组件中分离出来，组件通常只有一个职责。</p><p id="5a7a" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">我们会掩护</p><ol class=""><li id="fbc3" class="lt lu in kj b kk kl kn ko le lv lf lw lg lx lc ni lz ma mb bi translated">向可观察对象列表以触发上传</li><li id="4df3" class="lt lu in kj b kk mc kn md le me lf mf lg mg lc ni lz ma mb bi translated">获取SAS令牌</li><li id="9e27" class="lt lu in kj b kk mc kn md le me lf mf lg mg lc ni lz ma mb bi translated">将文件上传到blob存储</li><li id="f987" class="lt lu in kj b kk mc kn md le me lf mf lg mg lc ni lz ma mb bi translated">在视图状态中保留所有上载进度的列表</li></ol><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="50d4" class="nl mm in bd mn nm nn dn mr no np dp mv le nq nr mx lf ns nt mz lg nu nv nb nw bi translated">发生什么事了？</h2><p id="9c55" class="pw-post-body-paragraph kg kh in kj b kk nd jo km kn ne jr kp le nf ks kt lf ng kw kx lg nh la lb lc ig bi translated">public <code class="fe mh mi mj mk b">uploadItems</code>方法接受一个文件列表，并调用关于<code class="fe mh mi mj mk b">uploadQueueInner$</code>主题的<code class="fe mh mi mj mk b">next</code>方法。<code class="fe mh mi mj mk b">uploadQueue$</code> getter将主题作为一个可观察对象进行监听，并将文件列表中的每个文件作为一个单独的项目发出。这是一个可以验证文件的地方。</p><p id="0d48" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">属性<code class="fe mh mi mj mk b">uploadedItems$</code>正在监听<code class="fe mh mi mj mk b">uploadQueue$</code>，并将为每个发出的文件项调用服务中的<code class="fe mh mi mj mk b">uploadFile</code>方法。需要订阅<code class="fe mh mi mj mk b">uploadedItems$</code>来开始上传并显示上传进度(我们将在下面的上传进度组件中介绍)</p><p id="04c3" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated"><code class="fe mh mi mj mk b">uploadFile</code>方法获取最新的SAS令牌，并使用令牌和文件细节调用Blob存储包装服务上的<code class="fe mh mi mj mk b">uploadToBlobStorage</code>(我们将在下面介绍)。</p><p id="5d01" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated"><code class="fe mh mi mj mk b">uploadToBlobStorage</code>方法返回一个observable，该observable在每次改变时发出loadedBtyes，并可用于跟踪上传进度。</p><p id="8678" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">然后，我们将上传响应映射到<code class="fe mh mi mj mk b">mapUploadResponse</code>方法中的一个百分比，并包含额外的细节。该方法还有一个<code class="fe mh mi mj mk b">startWith</code>操作符，这样任何订阅者都会在上传开始时得到通知，而不是等待进度发出。</p><p id="db39" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">然后，当上传完成时，我们调用finalise方法来刷新blob容器中的项目。</p><p id="ab05" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">然后，来自<code class="fe mh mi mj mk b">uploadFile</code>方法的映射响应被传送到一个定制的<code class="fe mh mi mj mk b">scan</code>操作符函数中，以将发出的值减少到一个数组中。这允许我们存储所有正在进行的上传，并在上传已经在进行时添加更多的上传。</p><h1 id="4212" class="ml mm in bd mn mo mp mq mr ms mt mu mv jt mw ju mx jw my jx mz jz na ka nb nc bi translated">使用SAS令牌保护上传</h1><p id="92e4" class="pw-post-body-paragraph kg kh in kj b kk nd jo km kn ne jr kp le nf ks kt lf ng kw kx lg nh la lb lc ig bi translated">上面的服务在每次从服务上传之前调用一个方法来获取一个SAS。该代码示例中的方法返回我在Azure门户中生成的硬编码SAS令牌，但在现实世界中，您将调用API来生成并返回SAS令牌。这是一个使用Azure的C#的基本例子。Storage.Blobs (v12.0.0)包来生成一个可以用于许多操作的帐户SAS。当您希望/需要更细粒度时，您还可以为特定的blob项目或容器创建SAS令牌。</p><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="a599" class="ml mm in bd mn mo mp mq mr ms mt mu mv jt mw ju mx jw my jx mz jz na ka nb nc bi translated">将uploadBrowserData方法包装在@azure/storage-blob库中</h1><p id="073e" class="pw-post-body-paragraph kg kh in kj b kk nd jo km kn ne jr kp le nf ks kt lf ng kw kx lg nh la lb lc ig bi translated">我们包装@azure/storage-blob库来返回observables而不是promises，因为它在发出进度事件时工作得很好。</p><p id="e4e6" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">我们会掩护</p><ol class=""><li id="9140" class="lt lu in kj b kk kl kn ko le lv lf lw lg lx lc ni lz ma mb bi translated">创建一个注入令牌，从@azure/storage-blob库中获取blobServiceClient，使我们的服务可测试</li><li id="5364" class="lt lu in kj b kk mc kn md le me lf mf lg mg lc ni lz ma mb bi translated">调用<code class="fe mh mi mj mk b">uploadBrowserData</code>方法并返回loadedBytes的可观察值</li></ol><p id="2726" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">以下是来自<a class="ae ld" href="https://github.com/stottle-uk/stottle-angular-blob-storage/blob/master/src/app/azure-storage/services/blob-storage.service.ts" rel="noopener ugc nofollow" target="_blank">全面服务</a>的片段</p><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="0cd6" class="nl mm in bd mn nm nn dn mr no np dp mv le nq nr mx lf ns nt mz lg nu nv nb nw bi translated">发生什么事了？</h2><p id="b040" class="pw-post-body-paragraph kg kh in kj b kk nd jo km kn ne jr kp le nf ks kt lf ng kw kx lg nh la lb lc ig bi translated">包装器服务中的<code class="fe mh mi mj mk b">uploadToBlobStorage</code>方法接受要上传的文件和带有SAS令牌的对象。它调用一个方法，该方法将使用注入的令牌服务返回使用连接字符串创建的<code class="fe mh mi mj mk b">blobServiceClient</code>。</p><p id="0108" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">然后，我们将使用<code class="fe mh mi mj mk b">blobServiceClient</code>创建的<code class="fe mh mi mj mk b">BlockBlobClient</code>和文件传递给包装了<code class="fe mh mi mj mk b">uploadBrowserData</code>方法的<code class="fe mh mi mj mk b">uploadFile</code>方法。我们监听<code class="fe mh mi mj mk b">onProgress</code>事件，并在每次进度改变时发出值。然后，当上传完成时，我们发出文件大小并完成观察。</p><h1 id="e477" class="ml mm in bd mn mo mp mq mr ms mt mu mv jt mw ju mx jw my jx mz jz na ka nb nc bi translated">创建一个组件来显示上传进度</h1><p id="e831" class="pw-post-body-paragraph kg kh in kj b kk nd jo km kn ne jr kp le nf ks kt lf ng kw kx lg nh la lb lc ig bi translated">在此代码示例中，视图状态服务管理共享数据，组件显示数据。这个良好的实践允许我们将文件输入和上传进度组件分开，并且保持我们的组件小，职责少(希望只有一个)。</p><figure class="li lj lk ll gt lm"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h2 id="9537" class="nl mm in bd mn nm nn dn mr no np dp mv le nq nr mx lf ns nt mz lg nu nv nb nw bi translated">发生什么事了？</h2><p id="af9f" class="pw-post-body-paragraph kg kh in kj b kk nd jo km kn ne jr kp le nf ks kt lf ng kw kx lg nh la lb lc ig bi translated">从我们上面提到的<code class="fe mh mi mj mk b">BlobUploadsViewStateService</code>服务的<code class="fe mh mi mj mk b">uploadedItems$</code>属性中为<code class="fe mh mi mj mk b">uploads$</code>属性赋值。</p><p id="c193" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">然后，我们使用<code class="fe mh mi mj mk b">async</code>管道订阅可观察对象，并显示数组中的每一项。</p><h1 id="42c5" class="ml mm in bd mn mo mp mq mr ms mt mu mv jt mw ju mx jw my jx mz jz na ka nb nc bi translated">结论</h1><p id="772e" class="pw-post-body-paragraph kg kh in kj b kk nd jo km kn ne jr kp le nf ks kt lf ng kw kx lg nh la lb lc ig bi translated">这是上传到Azure blob存储的一种实现方式，我已经尝试演示了这种方式的基本架构，并给出了示例代码。</p><p id="b014" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">我们可以通过在上传前对文件进行验证并计算上传速度来改进解决方案。我们也没有很好地处理错误。</p><p id="0a1f" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">我们可以将NGRX与效果和选择器一起用于更大的应用程序，而不是视图状态服务</p><p id="76ad" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">组件还可以分为智能组件和非智能组件，其中智能组件获取数据并调用视图状态服务上的函数，非智能组件(具有输入和输出)显示数据。</p><p id="20e8" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">您还可以在这里看到解决方案<a class="ae ld" href="https://stottle-blob-storage-angular.azurewebsites.net/" rel="noopener ugc nofollow" target="_blank">的工作示例。为缺乏风格道歉。</a></p><p id="c4a5" class="pw-post-body-paragraph kg kh in kj b kk kl jo km kn ko jr kp le kr ks kt lf kv kw kx lg kz la lb lc ig bi translated">如果您对下面的文章有任何意见或建议，请告诉我，但是请在Github repo上提出任何代码问题</p><div class="nx ny gp gr nz oa"><a href="https://github.com/stottle-uk/stottle-angular-blob-storage" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd io gy z fp of fr fs og fu fw im bi translated">stottle-uk/stottle-angular-blob-storage</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">该项目是使用Angular CLI版本8.3.17生成的。为开发服务器运行ng服务。导航到…</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">github.com</p></div></div><div class="oj l"><div class="ok l ol om on oj oo lr oa"/></div></div></a></div></div></div>    
</body>
</html>