<html>
<head>
<title>What’s coming with TypeScript 4.0 — Language features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript 4.0带来了什么—语言特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/whats-coming-with-typescript-4-0-language-features-3a98fc8db48f?source=collection_archive---------2-----------------------#2020-05-17">https://javascript.plainenglish.io/whats-coming-with-typescript-4-0-language-features-3a98fc8db48f?source=collection_archive---------2-----------------------#2020-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="238f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://medium.com/@dSebastien/whats-new-with-typescript-3-9-9095ff9f68a5" rel="noopener"> TypeScript 3.9 </a>刚刚<a class="ae kl" href="https://medium.com/@dSebastien/whats-new-with-typescript-3-9-9095ff9f68a5" rel="noopener">发布</a>，自然要看看接下来的内容了！好消息是，由于TypeScript是公开开发的，所有人都可以看到这些计划。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi km"><img src="../Images/b110b79b2c5820c3801ed3d0f2cd6af8.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*ts3lYA8TB3a6qWmDknphoQ.png"/></div></figure><p id="a143" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇文章中，我将尝试总结我通过查看<a class="ae kl" href="https://github.com/microsoft/TypeScript/issues/38510" rel="noopener ugc nofollow" target="_blank"> 4.0迭代计划</a>所能发现的内容。我将只讨论语言特性。我可能会写一些额外的帖子来涵盖编辑器的生产力、性能和错误修复。</p><p id="fa15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请记住，本文是基于路线图，并不意味着一切都将成为4.0的一部分，甚至实际上已经实现！；-) </p><h1 id="8e4b" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">从构造函数推断类属性</h1><p id="7f7a" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">目前，当tsc配置为<code class="fe lx ly lz ma b">noImplicitAny</code>模式时，以下TS代码不会编译:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="2192" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在<a class="ae kl" href="https://github.com/microsoft/TypeScript/pull/37920" rel="noopener ugc nofollow" target="_blank">这个PR </a>已经被合并，因此从TS 4.0开始，<em class="md">上面的代码将</em>编译，TypeScript将推断出<code class="fe lx ly lz ma b">x</code>的类型为<code class="fe lx ly lz ma b">string | boolean</code>。</p><p id="8a58" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是TypeScript的类型推断将帮助我们的又一个例子！</p><h1 id="3d8f" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">短路赋值运算符</h1><p id="101d" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">Daniel Rentz介绍的这个<a class="ae kl" href="https://github.com/microsoft/TypeScript/issues/37255" rel="noopener ugc nofollow" target="_blank">提案</a>对应的是一个<a class="ae kl" href="https://github.com/tc39/proposal-logical-assignment" rel="noopener ugc nofollow" target="_blank"> TC39提案，名为“提案-逻辑-分配”</a>，目前处于第3阶段(即<a class="ae kl" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank">基本就绪</a>)！).</p><p id="924c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它旨在结合逻辑运算符和赋值表达式。结合从TS 3.7开始我们就有的<a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing" rel="noopener ugc nofollow" target="_blank"> nullish合并</a>，我们将能够编写更精简的代码。</p><p id="e78d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是提案中给出的一个例子:</p><pre class="kn ko kp kq gt me ma mf mg aw mh bi"><span id="ed4c" class="mi kv iq ma b gy mj mk l ml mm">obj1.obj2.obj3.x ??= 42;</span></pre><p id="6496" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">没有这些新的短路操作符的相同代码:</p><pre class="kn ko kp kq gt me ma mf mg aw mh bi"><span id="2128" class="mi kv iq ma b gy mj mk l ml mm">obj1.obj2.obj3.x = obj1.obj2.obj3.x ?? 42;</span></pre><p id="e448" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如你所见，有了这种支持，我们将拥有一种更具表达力的语言，我们将能够结合检查和赋值，这将是非常棒的。</p><p id="8993" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如Daniel Rosenwasser所提到的，我们会为每个逻辑运算符设置一个这样的运算符，因此:</p><pre class="kn ko kp kq gt me ma mf mg aw mh bi"><span id="92c7" class="mi kv iq ma b gy mj mk l ml mm"><em class="md">LeftHandSideExpression</em> <!-- -->&amp;&amp;=<!-- --> <em class="md">AssignmentExpression</em></span><span id="b8d4" class="mi kv iq ma b gy mn mk l ml mm"><em class="md">LeftHandSideExpression</em> <!-- -->||=<!-- --> <em class="md">AssignmentExpression</em></span><span id="fefd" class="mi kv iq ma b gy mn mk l ml mm"><em class="md">LeftHandSideExpression</em> <!-- -->??=<!-- --> <em class="md">AssignmentExpression</em></span></pre><p id="6d70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对应于我们目前可以做的事情:</p><pre class="kn ko kp kq gt me ma mf mg aw mh bi"><span id="6c9a" class="mi kv iq ma b gy mj mk l ml mm"><em class="md">LeftHandSideExpression</em> <!-- -->&amp;&amp;<!-- --> (<em class="md">LeftHandSideExpression</em> <!-- -->=<!-- --> <em class="md">AssignmentExpression</em>)</span><span id="bef4" class="mi kv iq ma b gy mn mk l ml mm"><em class="md">LeftHandSideExpression</em> <!-- -->||<!-- --> (<em class="md">LeftHandSideExpression</em> <!-- -->=<!-- --> <em class="md">AssignmentExpression</em>)</span><span id="747e" class="mi kv iq ma b gy mn mk l ml mm"><em class="md">LeftHandSideExpression</em> <!-- -->??<!-- --> (<em class="md">LeftHandSideExpression</em> <!-- -->=<!-- --> <em class="md">AssignmentExpression</em>)</span></pre><p id="068f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">鉴于相应的提案已经进入第三阶段，我敢打赌这将是TS 4.0的一部分，这将是一个伟大的，因为这是一个非常好的功能。</p><h1 id="2286" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">允许未知的catch子句绑定</h1><p id="57fa" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">目前，如果您尝试向catch子句添加类型注释，编译器会报错:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="39e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">上面的代码无法编译，并引发以下错误:<code class="fe lx ly lz ma b">TS1196: Catch clause variable cannot have a type annotation</code></p><p id="823d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，我们根本不能向catch子句添加类型注释，从类型安全的角度来看，这是相当可悲的。问题是错误总是被认为是<code class="fe lx ly lz ma b">any</code>，它允许我们在catch块中对对象做任何事情。</p><p id="d0b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种行为仅仅是因为，最初，<code class="fe lx ly lz ma b">unknown</code>关键字并不存在。但是现在，在这里使用它会更有意义。</p><p id="11cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如这个提案的<a class="ae kl" href="https://github.com/microsoft/TypeScript/issues/36775" rel="noopener ugc nofollow" target="_blank">的评论中指出的，我们可以得到一个新的严格标志，让我们在默认情况下强制执行这个(即，让所有的catch子句错误成为未知类型)。这将迫使我们在块中使用它之前正确地检查类型。</a></p><p id="dca5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我真正感兴趣的一项改进！</p><h1 id="98b8" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">标记元组元素</h1><p id="c1c7" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">另一个<a class="ae kl" href="https://github.com/Microsoft/TypeScript/issues/28259" rel="noopener ugc nofollow" target="_blank">提议</a>，由Brian Kim提出，旨在给我们定义元组元素标签的能力。我不是元组的最大粉丝(我通常更喜欢对象/自定义类型)，但有时它们确实很有用，例如在编写测试时(或者像React :p这样奇怪的库的类型定义)。</p><p id="f001" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">目前，元组是这样声明的:</p><pre class="kn ko kp kq gt me ma mf mg aw mh bi"><span id="8129" class="mi kv iq ma b gy mj mk l ml mm">// length, count<br/>type Segment = [number, number];</span></pre><p id="26ac" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为我们不能给元组元素分配标签，所以最简单(但是很难看)的解决方案是依靠注释来提醒我们每个元素对应什么。</p><p id="8f34" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一个解决方案(更干净)是使用具有更有用名称的自定义类型。尽管如此，仍有改进的空间。</p><p id="d13c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一些语言如c#<a class="ae kl" href="https://docs.microsoft.com/en-us/dotnet/csharp/tuples#named-and-unnamed-tuples" rel="noopener ugc nofollow" target="_blank">和Python支持这一点。</a></p><p id="484b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这被添加到语言中，那么我们将能够更简单地创建更具表达力的元组:</p><pre class="kn ko kp kq gt me ma mf mg aw mh bi"><span id="9146" class="mi kv iq ma b gy mj mk l ml mm">type Segment = [length: number, count: number];</span></pre><p id="f6ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里，通过查看元组，我们可以直接知道每个数字对应于什么。</p><p id="ad8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对于清楚地理解元组是由什么组成的非常有用。此外，正如提案中提到的，它还将为操纵/返回元组的API增加更多的表达能力。</p><p id="3376" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如Daniel Rosenwasser所说，元组元素名称不会在类型系统中强制任何东西；它们的存在纯粹是为了传达意图。</p><h1 id="fcdc" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">远期申报</h1><p id="b9bb" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">正如<a class="ae kl" href="https://github.com/microsoft/TypeScript/issues/31894" rel="noopener ugc nofollow" target="_blank"> Daniel Rosenwasser解释的</a>，有时候我们需要告诉TypeScript一个类型<em class="md">可能</em>存在，这取决于代码执行的环境。</p><p id="2f5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当出现这种情况时，我们可以利用<a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html" rel="noopener ugc nofollow" target="_blank">声明合并</a>。这是可行的，但是有一些问题，特别是当不同的环境有冲突的类型时。此外，它只适用于自定义类型和接口。</p><p id="11d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个<a class="ae kl" href="https://github.com/microsoft/TypeScript/issues/31894" rel="noopener ugc nofollow" target="_blank">新提议</a>，TypeScript将通过让我们定义占位符类型来为我们提供正确处理这种情况的方法，占位符类型将在实现可用之前充当占位符。此时，TypeScript将表现为占位符类型不再存在。</p><p id="7823" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是提案中的一个例子:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="9d53" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">(提议的)新的<code class="fe lx ly lz ma b">exists</code>关键字将让我们定义那些占位符类型。</p><p id="b3ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，当引入实际的实现类型时，TS编译器将确保实现遵守占位符定义的约束:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="854a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果实现类型不考虑占位符类型约束，那么编译器将退出:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="09cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，<code class="fe lx ly lz ma b">exists</code>关键字只是建议中的一个，还没有确定的选择。</p><p id="d3be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">查看<a class="ae kl" href="https://github.com/microsoft/TypeScript/issues/31894" rel="noopener ugc nofollow" target="_blank">提案</a>了解更多详情。</p><h1 id="a60b" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">更好地支持承诺和等待</h1><p id="2596" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在TS 3.9的发行说明中，有一个最初我不理解的关于潜在的“等待”关键字的说明<a class="ae kl" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html#what-about-the-awaited-type" rel="noopener ugc nofollow" target="_blank">，声明它还没有准备好进入黄金时段。</a></p><p id="71e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自从我在2016年爱上Rx和Observables(哈哈)以来，我就不是一个承诺的超级粉丝，但在看了TS 4.0的计划后，我偶然发现了这个<a class="ae kl" href="https://github.com/microsoft/TypeScript/issues/27711" rel="noopener ugc nofollow" target="_blank"> bug报告</a>，它帮助我理解了这是怎么回事。</p><p id="0809" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在JavaScript中，嵌套的承诺总是打开的；它们会自动变平。这里有一个例子来说明我的意思:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="3de8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无论一个承诺被包装了多少次，它都会自动为我们打开。这在现实世界中也是可行的。如果你把礼物包在盒子里的盒子里的盒子里，然后给孩子们，你会看到它是如何工作的；-)</p><p id="3011" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是在TypeScript中，JavaScript的这种正常行为目前并没有正常工作。以下代码编译正常，但类型不正确:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mb mc l"/></div></figure><p id="2f8b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于上面的代码，编译器应该会抱怨，因为<code class="fe lx ly lz ma b">p1</code>承诺实际上是一个<code class="fe lx ly lz ma b">Promise&lt;number&gt;</code>而不是一个<code class="fe lx ly lz ma b">Promise&lt;Promise&lt;number&gt;&gt;</code>。</p><p id="f879" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实际上，在TypeScript中还有一些关于承诺和await关键字的其他问题，正如在<a class="ae kl" href="https://github.com/microsoft/TypeScript/pull/17077" rel="noopener ugc nofollow" target="_blank">这篇文章</a>中所解释的。TypeScript目前很难找到用于复杂承诺链的正确返回类型。此外，TS也很难正确识别类型变量的“等待类型”。</p><p id="1005" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TypeScript团队打算引入一个<code class="fe lx ly lz ma b">awaited T</code>操作符来明确定义“等待类型”。这旨在正确地模仿JavaScript的运行时行为，但它没有涵盖上面的承诺解包问题。</p><p id="f3cb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于这仍在不断变化，还不清楚这将如何演变，以及4.0中将会有什么。不过有一点是肯定的:TypeScript团队肯定会在即将到来的版本中改善TS中承诺的现状；-)</p><h1 id="182a" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">调整TypeScript对React的支持</h1><p id="c79c" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">就像TypeScript一样，React移动速度非常快。</p><p id="c481" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自从我出版了关于TypeScript、React、Angular和Vue的书之后，事情一直在发展。我关于React的章节仍然相关，但是React.createElement API正在<a class="ae kl" href="https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md" rel="noopener ugc nofollow" target="_blank">改变</a>。</p><p id="c8a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于TypeScript支持JSX，它确实需要遵循这些发展。这在<a class="ae kl" href="https://github.com/microsoft/TypeScript/issues/34547" rel="noopener ugc nofollow" target="_blank">本期</a>有追踪。</p><h1 id="a545" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="4503" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">在本文中，我已经分享了我到目前为止所发现的关于TypeScript 4.0中可能出现的内容。</p><p id="52da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我等不及要看我们会得到什么了！</p><h1 id="b800" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">喜欢这篇文章吗？点击下面“喜欢”按钮查看更多内容，并确保其他人也能看到！</h1><p id="b130" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">PS:如果你想学习大量关于软件/Web开发、TypeScript、Angular、React、Vue、Kotlin、Java、Docker/Kubernetes和其他很酷的主题的其他很酷的东西，那么不要犹豫<a class="ae kl" href="https://www.amazon.com/Learn-TypeScript-Building-Applications-understanding-ebook/dp/B081FB89BL" rel="noopener ugc nofollow" target="_blank">去拿一本我的书</a>并订阅<a class="ae kl" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">我的简讯</a>！</p><h1 id="7e3f" class="ku kv iq bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">简明英语笔记</strong></h1><p id="82a6" class="pw-post-body-paragraph jn jo iq jp b jq ls js jt ju lt jw jx jy lu ka kb kc lv ke kf kg lw ki kj kk ij bi translated">你知道我们推出了一个YouTube频道吗？我们制作的每个视频都旨在教给你一些新的东西。点击此处 查看我们，并确保<strong class="jp ir">订阅频道</strong>😎</p></div></div>    
</body>
</html>