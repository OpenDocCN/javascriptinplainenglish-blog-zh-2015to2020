<html>
<head>
<title>Understanding JavaScript Proxies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解JavaScript代理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-javascript-proxies-69d07f812666?source=collection_archive---------6-----------------------#2020-04-13">https://javascript.plainenglish.io/understanding-javascript-proxies-69d07f812666?source=collection_archive---------6-----------------------#2020-04-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2bf5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript ES6代理和可撤销代理的快速介绍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6b9057b11f2353f6948638498c4c16b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jp9unXkAM9-aSxKBQwMmyQ.jpeg"/></div></div></figure><p id="907d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">代理是ES6包含的特性之一，虽然不太为人所知，但它非常强大。代理是我们创建的一种特殊的对象，它“包装”了另一个对象。我们可以在代理对象上注册特殊的处理程序，当针对代理执行各种操作时会调用这些处理程序。</p><p id="f056" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">代理允许您进行元编程操作，例如拦截检查或更改对象属性的调用。简单地说，代理就像超级维生素化的“getters”和“setters ”,它们拦截对属性的调用并执行动作。</p><p id="1b6d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">多亏了代理，我们可以做这样的事情:</p><ul class=""><li id="5095" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">拦截对属性的调用</li><li id="7f84" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">动态验证</li><li id="bd73" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi">…</li></ul><p id="df3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">代理构造函数接受两个参数:源对象和充当源对象处理程序的对象。处理程序对象包含称为陷阱的方法。</p><p id="b60d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，traps(<a class="ae mb" href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Proxy#M%C3%A9todos_del_objeto_handler" rel="noopener ugc nofollow" target="_blank">Complete list</a>)“get”和“set”分别拦截对属性的调用以获取和设置值，允许我们在这个过程之前和过程中设置逻辑。</p><p id="b96f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看一个没有使用代理和使用代理的例子，其中我们将获得用大写字母格式化的对象的属性值，并且我们将验证电子邮件到用户对象的分配。</p><p id="077f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">没有代理:</p><pre class="kg kh ki kj gt mc md me mf aw mg bi"><span id="d530" class="mh mi iq md b gy mj mk l ml mm">const user = {<br/> _name : "Templeton",<br/> _email : "<a class="ae mb" href="mailto:faceman@gmail.com" rel="noopener ugc nofollow" target="_blank">faceman@gmail.com</a>",</span><span id="c920" class="mh mi iq md b gy mn mk l ml mm">get name() {<br/>    return this._name.toUpperCase();<br/> },</span><span id="aa61" class="mh mi iq md b gy mn mk l ml mm">get email() {<br/>  return this._email.toUpperCase();;<br/> },</span><span id="5802" class="mh mi iq md b gy mn mk l ml mm">set name(newName) {<br/>    //Apply some validations<br/>    //...<br/>    console.log("new name: "   <br/>    +newName);<br/>    this._name= newName;<br/>  },</span><span id="8044" class="mh mi iq md b gy mn mk l ml mm">set email(newEmail) {<br/>    console.log("new email: " <br/>    + newEmail);    <br/>    if(!newEmail.includes('@')){<br/>      console.log("Incorrect mail.  <br/>      Nothing has been assigned!");    <br/>    }else{   <br/>      this._email = newEmail;<br/>    }<br/>  }<br/>}</span><span id="c2e6" class="mh mi iq md b gy mn mk l ml mm">//GETTERS<br/>user.name; //TEMPLETON<br/>user.email; //<a class="ae mb" href="mailto:FACEMAN@GMAIL.COM" rel="noopener ugc nofollow" target="_blank">FACEMAN@GMAIL.COM</a><br/>user.otherProperty; //undefined !!</span><span id="4125" class="mh mi iq md b gy mn mk l ml mm">//SETTERS<br/>user.email ="bademail#gmail.com"<br/>// Incorrect mail. Nothing has been assigned!</span><span id="2bc0" class="mh mi iq md b gy mn mk l ml mm">user.email; //<a class="ae mb" href="mailto:FACEMAN@GMAIL.COM" rel="noopener ugc nofollow" target="_blank">FACEMAN@GMAIL.COM</a><br/>user.email = "<a class="ae mb" href="mailto:ateam@gmail.com" rel="noopener ugc nofollow" target="_blank">ateam@gmail.com</a>"<br/>user.email //<a class="ae mb" href="mailto:ATEAM@GMAIL.COM" rel="noopener ugc nofollow" target="_blank">ATEAM@GMAIL.COM</a></span></pre><p id="d09c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们将看到相同的使用情形，但使用代理:</p><pre class="kg kh ki kj gt mc md me mf aw mg bi"><span id="70ea" class="mh mi iq md b gy mj mk l ml mm">const user = {<br/>  name :"Templeton",<br/>  email : "<a class="ae mb" href="mailto:faceman@gmail.com" rel="noopener ugc nofollow" target="_blank">faceman@gmail.com</a>"<br/>}</span><span id="d06b" class="mh mi iq md b gy mn mk l ml mm">const handler = {<br/>  get: (target, name) =&gt; {<br/>    return name in target ?<br/>      target[name].toUpperCase() :<br/>      console.log('The property not exists');<br/>  },</span><span id="4c7d" class="mh mi iq md b gy mn mk l ml mm">set: (target, name, newValue) =&gt; {<br/>    if(name ==='email'){<br/>      if(!newValue.includes('@')){  <br/>       console.log("Incorrect mail. Nothing has been assigned!");<br/>      }else{target[name] = newValue}<br/>    }else if(name != email){<br/>      target[name] = newValue;<br/>    }    <br/>  }<br/>}</span><span id="43f1" class="mh mi iq md b gy mn mk l ml mm">const userProxy = new Proxy(user, handler);</span><span id="499c" class="mh mi iq md b gy mn mk l ml mm">//GETTERS<br/>userProxy.name; //TEMPLETON<br/>userProxy.email; //<a class="ae mb" href="mailto:FACEMAN@GMAIL.COM" rel="noopener ugc nofollow" target="_blank">FACEMAN@GMAIL.COM</a><br/>userProxy.otherProperty; //The property not exist</span><span id="eaf4" class="mh mi iq md b gy mn mk l ml mm">//SETTERS<br/>userProxy.email ="bademail#gmail.com"<br/>//Incorrect mail. Nothing has been assigned!</span><span id="cd58" class="mh mi iq md b gy mn mk l ml mm">userProxy.email; //<a class="ae mb" href="mailto:FACEMAN@GMAIL.COM" rel="noopener ugc nofollow" target="_blank">FACEMAN@GMAIL.COM</a><br/>userProxy.email ="<a class="ae mb" href="mailto:ateam@gmail.com" rel="noopener ugc nofollow" target="_blank">ateam@gmail.com</a>"<br/>userProxy.email //<a class="ae mb" href="mailto:ATEAM@GMAIL.COM" rel="noopener ugc nofollow" target="_blank">ATEAM@GMAIL.COM</a></span></pre><p id="36a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们在最后一个使用代理的例子中看到的，我们不需要为用户对象中的每个属性定义一个getter或setter，如果属性不存在，我们也不会获得undefined。</p><h2 id="ec85" class="mh mi iq bd mo mp mq dn mr ms mt dp mu la mv mw mx le my mz na li nb nc nd ne bi translated">可撤销的代理</h2><p id="2492" class="pw-post-body-paragraph kr ks iq kt b ku nf jr kw kx ng ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">常规代理在创建后不能修改；但是，在某些情况下，我们可能希望创建一个可以被禁用的代理。为此，我们可以创建一个可撤销的代理:</p><p id="1948" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以用Proxy.revocable(..)，这是一个常规函数，而不是Proxy之类的构造函数(..).采用与常规“代理”相同的两个参数，并返回一个具有两个属性的对象:proxy和revoke。</p><pre class="kg kh ki kj gt mc md me mf aw mg bi"><span id="a3f3" class="mh mi iq md b gy mj mk l ml mm">const user = {<br/>  name :"Templeton",<br/>  email : "<a class="ae mb" href="mailto:faceman@gmail.com" rel="noopener ugc nofollow" target="_blank">faceman@gmail.com</a>"<br/>}</span><span id="731a" class="mh mi iq md b gy mn mk l ml mm">const handler = {<br/>  <br/> get: (target, name) =&gt; {<br/>    return name in target ?<br/>      target[name].toUpperCase() :<br/>      console.log('The property not exists');<br/> },</span><span id="cf2e" class="mh mi iq md b gy mn mk l ml mm">set: (target, name, newValue) =&gt; {<br/>    if(name ==='email'){<br/>      if(!newValue.includes('@')){  <br/>       console.log("Incorrect mail.  <br/>       Nothing has been assigned!");<br/>      }else{target[name] = newValue}<br/>    }else if(name != email){<br/>      target[name] = newValue;<br/>    }    <br/>  }<br/>}</span><span id="0090" class="mh mi iq md b gy mn mk l ml mm">const revocableUserProxy = Proxy.revocable(user, handler);</span><span id="4b00" class="mh mi iq md b gy mn mk l ml mm">//GETTERS<br/>user.name; //TEMPLETON<br/>revocableUserProxy.revoke();<br/>user.name; //Templeton</span></pre><p id="55e0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在前面的示例中，当我们访问user.name属性时，代理被调用，我们获得大写字母的属性值，然后，如果我们调用代理的revoke方法并再次访问user.name属性，我们获得user.name属性的原始值。</p><h2 id="27a0" class="mh mi iq bd mo mp mq dn mr ms mt dp mu la mv mw mx le my mz na li nb nc nd ne bi translated">结论</h2><p id="3c54" class="pw-post-body-paragraph kr ks iq kt b ku nf jr kw kx ng ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">代理的能力可能不明显，但是它们提供了强大的元编程机会。所有当前的浏览器和节点都支持代理特性，因此我们可以在开发中使用它来获得更干净、更简洁的代码。</p><p id="2a39" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑到并非所有的浏览器都支持所有的陷阱，这一点也很重要。我们可以在MDN代理页面上查看trap <a class="ae mb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#Browser_compatibility" rel="noopener ugc nofollow" target="_blank">兼容性表</a>。另一个缺点是，由于ES5的限制，代理不能被传输(例如，用<a class="ae mb" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank">巴别塔</a>)或聚合填充。</p><p id="2055" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">非常感谢您阅读这篇文章——希望您觉得有用！</p><h2 id="3094" class="mh mi iq bd mo mp mq dn mr ms mt dp mu la mv mw mx le my mz na li nb nc nd ne bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="4445" class="pw-post-body-paragraph kr ks iq kt b ku nf jr kw kx ng ju kz la nh lc ld le ni lg lh li nj lk ll lm ij bi translated">我们总是有兴趣帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的中级用户名发邮件到<a class="ae mb" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">submissions@javascriptinplainenglish.com</strong></a>给我们，我们会把你添加为作者。</p><p id="7dc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还推出了三种新的出版物！请关注我们的新出版物，表达对它们的爱:<a class="ae mb" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kt ir"/></a><a class="ae mb" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kt ir">UX</strong></a><a class="ae mb" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kt ir">Python</strong></a><strong class="kt ir"/>——谢谢，继续学习！</p></div></div>    
</body>
</html>