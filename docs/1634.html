<html>
<head>
<title>Why you should not remove all the elements of array by reassigning it to []</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么不应该通过将数组重新分配给[]来删除数组的所有元素</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-you-should-not-use-array-to-remove-all-the-elements-of-array-42ad2951d47e?source=collection_archive---------1-----------------------#2020-04-09">https://javascript.plainenglish.io/why-you-should-not-use-array-to-remove-all-the-elements-of-array-42ad2951d47e?source=collection_archive---------1-----------------------#2020-04-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7099" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解使数组为空时的棘手行为，并学习如何修复它。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f9ee179ae5bd7ae51494c3b3136dfcbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Hd3afx4A2U-JsDrF"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@sapegin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Artem Sapegin</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c4cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很多时候，当我们想删除数组中的所有元素时，也许我们有一个todo列表，我们想一次删除所有的todo。</p><p id="3b37" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑一下，我们有一个项目列表</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="62e1" class="lx ly iq lt b gy lz ma l mb mc">let items = ["tea", "coffee", "milk"];</span></pre><p id="1f1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后从数组中移除所有的元素，我们把它设置成一个空数组，就像这样</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="e2c0" class="lx ly iq lt b gy lz ma l mb mc">items = []</span></pre><p id="52c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这非常有效，你会发现它一直在被使用。但是这有一个问题。</p><p id="6c98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑一下，在代码下面</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="e195" class="lx ly iq lt b gy lz ma l mb mc">let items = ["tea", "coffee", "milk"];</span><span id="b34a" class="lx ly iq lt b gy md ma l mb mc">let copy = items;</span></pre><p id="6942" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们创建了一个<code class="fe me mf mg lt b">copy</code>变量，并赋予它一个<code class="fe me mf mg lt b">items</code>数组的引用，因此<code class="fe me mf mg lt b">copy</code>实际上指向了<code class="fe me mf mg lt b">items</code>数组。</p><p id="12b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，让我们检查一下它们各自的值</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="ae02" class="lx ly iq lt b gy lz ma l mb mc">console.log(items); // ["tea", "coffee", "milk"]</span><span id="b7d2" class="lx ly iq lt b gy md ma l mb mc">console.log(copy); // ["tea", "coffee", "milk"]</span></pre><p id="00ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是意料之中的。</p><p id="2c51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们改变其中的任何一个，它会修改原始数组本身，因为它只是一个引用，而不是一个精确的副本。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="807b" class="lx ly iq lt b gy lz ma l mb mc">copy[2] = "oranges";</span><span id="94d3" class="lx ly iq lt b gy md ma l mb mc">console.log(items); // ["tea", "coffee", "oranges"]</span><span id="18a8" class="lx ly iq lt b gy md ma l mb mc">console.log(copy); // ["tea", "coffee", "oranges"]</span></pre><p id="fe89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果我们想删除项目数组的所有元素，我们这样做</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="8d30" class="lx ly iq lt b gy lz ma l mb mc">items = [];</span></pre><p id="b2e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们再次检查<code class="fe me mf mg lt b">items</code>和<code class="fe me mf mg lt b">copy</code>。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="a341" class="lx ly iq lt b gy lz ma l mb mc">console.log(items); // []</span><span id="e847" class="lx ly iq lt b gy md ma l mb mc">console.log(copy); // ["tea", "coffee", "oranges"]</span></pre><p id="fdc9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，<code class="fe me mf mg lt b">items</code>数组是空的，但是<code class="fe me mf mg lt b">copy</code>仍然包含原始数组，并且没有被清除。</p><p id="9e95" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为当我们说，<code class="fe me mf mg lt b">items = []</code>时，它实际上创建了一个新的空数组，并将其赋给<code class="fe me mf mg lt b">items</code>，因此<code class="fe me mf mg lt b">copy</code>变量不受影响。</p><p id="71b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于像<code class="fe me mf mg lt b">array</code>、<code class="fe me mf mg lt b">objects</code>这样的非原语类型，当我们赋值时，不是实际的值被赋值，而是被分配的内存地址的唯一引用被存储在那个变量中。</p><p id="dde5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以当我们说，array = []，[]只是在内存中分配一些空间的一种简便方法，其中没有数据，所以数组将只包含已分配内存空间的引用。</p><p id="5efd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对象也是如此。当我们说<code class="fe me mf mg lt b">obj = { name: 'David'}</code>时，obj变量并不包含对象本身，而只是引用分配的内存空间，在那个内存空间中，实际的对象被存储。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="9640" class="lx ly iq lt b gy lz ma l mb mc">let obj = { name: 'David' };<br/>let newObj = obj;</span><span id="4904" class="lx ly iq lt b gy md ma l mb mc">console.log(obj); // { name: 'David' }<br/>console.log(newObj); // { name: 'David' }</span><span id="de57" class="lx ly iq lt b gy md ma l mb mc">obj = null;</span><span id="8838" class="lx ly iq lt b gy md ma l mb mc">console.log(obj); // null<br/>console.log(newObj); // { name: 'David' }</span></pre><p id="fd47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以有两种方法可以解决这个问题。</p><ol class=""><li id="88c8" class="mh mi iq ky b kz la lc ld lf mj lj mk ln ml lr mm mn mo mp bi translated"><strong class="ky ir">将数组长度设置为0: </strong></li></ol><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="451e" class="lx ly iq lt b gy lz ma l mb mc">let items = ["tea", "coffee", "milk"];</span><span id="b714" class="lx ly iq lt b gy md ma l mb mc">let copy = items;<br/>console.log(items); // ["tea", "coffee", "milk"]<br/>console.log(copy); // ["tea", "coffee", "milk"]</span><span id="e1f2" class="lx ly iq lt b gy md ma l mb mc">items.length = 0;</span><span id="db80" class="lx ly iq lt b gy md ma l mb mc">console.log(items); // []<br/>console.log(copy); // []</span></pre><p id="6db8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.<strong class="ky ir">使用数组拼接方法:</strong></p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="0a34" class="lx ly iq lt b gy lz ma l mb mc">let items = ["tea", "coffee", "milk"];</span><span id="4a81" class="lx ly iq lt b gy md ma l mb mc">let copy = items;<br/>console.log(items); // ["tea", "coffee", "milk"]<br/>console.log(copy); // ["tea", "coffee", "milk"]</span><span id="c5c6" class="lx ly iq lt b gy md ma l mb mc">// remove elements of items array starting from position 0 till length of array<br/>items.splice(0, items.length);</span><span id="fb2f" class="lx ly iq lt b gy md ma l mb mc">console.log(items); // []<br/>console.log(copy); // []</span></pre><p id="d19b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些修复之所以有效，是因为它们实际上改变了原始数组，而不只是像items = []那样改变了项的引用</p><p id="b406" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">结论:</strong></p><p id="1840" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们不应该为数组或对象创建额外的引用，因为这可能会产生不希望的结果，如果你确定没有对原始数组的引用需要清空，那么你应该使用<code class="fe me mf mg lt b">array = []</code>来清空它，否则使用上述两种方法中的任何一种来清空数组。</p><p id="8be7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天到此为止。我希望你学到了新东西。</p><p id="0e30" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">别忘了直接在你的收件箱</strong> <a class="ae kv" href="https://yogeshchavan.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅我的每周简讯，里面有惊人的技巧、诀窍和文章。</strong> </a></p></div></div>    
</body>
</html>