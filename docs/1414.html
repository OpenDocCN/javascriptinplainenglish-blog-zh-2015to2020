<html>
<head>
<title>Retaining ag-Grid Filters Using Query Parameters</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用查询参数保留ag-Grid过滤器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/retaining-ag-grid-filters-using-query-parameters-55167be07a20?source=collection_archive---------3-----------------------#2020-03-13">https://javascript.plainenglish.io/retaining-ag-grid-filters-using-query-parameters-55167be07a20?source=collection_archive---------3-----------------------#2020-03-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/77b2c64888a287e088f4ffdcfe741be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TU1oSlgg4HbYyUIpqwEj4A.png"/></div></div></figure><p id="3d9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ag-Grid(<a class="ae kw" href="https://www.ag-grid.com/" rel="noopener ugc nofollow" target="_blank">https://www.ag-grid.com/</a>)库提供了世界上最好的网格功能。它的一个有用特性是<a class="ae kw" href="https://www.ag-grid.com/javascript-grid-filtering/" rel="noopener ugc nofollow" target="_blank">列过滤</a>，它允许用户在列级别设置过滤器，这样网格将根据一列或多列的过滤器选项和值显示过滤后的数据行。</p><p id="8ade" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ag-Grid有几个内置滤波器(<a class="ae kw" href="https://www.ag-grid.com/javascript-grid-filter-provided-simple/" rel="noopener ugc nofollow" target="_blank">简单滤波器</a>)，包括<code class="fe kx ky kz la b">TextFilter</code>、<code class="fe kx ky kz la b">NumberFilter</code>和<code class="fe kx ky kz la b">DateFilter</code>。对于每个列过滤器，我们可以选择组合两个条件来过滤行结果。一个组合过滤器由两个简单的过滤器组成，由一个布尔运算符连接(或者是<code class="fe kx ky kz la b">AND</code>或者是<code class="fe kx ky kz la b">OR</code>)。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lb"><img src="../Images/43916300a3c45a8953a47507b71339e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8MRX64RK7DM5LTsCoR95hA.png"/></div></div></figure><p id="b88c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个常见的用户故事如下。用户根据某些条件过滤数据网格，并选择一行来打开详细信息页面。在查看详细信息页面后，用户导航回网格页面，希望保留之前的过滤器，以便他/她可以从过滤的结果中选择另一行。如果没有过滤器，那么用户必须再次过滤数据网格，以获得之前过滤的数据行。问题:<em class="lg">如何保留之前的滤镜？</em></p><p id="af03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇博文中，我们将使用Angular中的路径查询参数实现一种简单的方法来保留ag-Grid过滤器。你可以从<a class="ae kw" href="https://changhuixu.github.io/retaining-filters-in-ag-grid/" rel="noopener ugc nofollow" target="_blank">这个网站</a>查看演示，完整的源代码在<a class="ae kw" href="https://github.com/changhuixu/retaining-filters-in-ag-grid" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>里。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="e6c9" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">实施计划</h1><p id="4c9b" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">目标是保持ag-Grid中的过滤器模型和URL中的查询参数同步。因此，我们制定了如下总体实施计划:</p><ol class=""><li id="c5ba" class="mr ms iq ka b kb kc kf kg kj mt kn mu kr mv kv mw mx my mz bi translated">设置一个事件处理程序(<code class="fe kx ky kz la b">filterChanged(event: FilterChangedEvent)</code>)来监听ag-Grid中任何过滤器更新时的<code class="fe kx ky kz la b">onFilterChanged</code>事件。<code class="fe kx ky kz la b">filterChanged</code>事件处理程序将更新路由查询参数，以反映当前的过滤器。</li><li id="41fd" class="mr ms iq ka b kb na kf nb kj nc kn nd kr ne kv mw mx my mz bi translated">设置<code class="fe kx ky kz la b">onGridReady()</code>事件处理程序来解析过滤器模型对象的查询参数，并使用网格API <code class="fe kx ky kz la b">setFilterModel()</code>来设置过滤器，这样每当网格初始化时，过滤器选项和值都会根据URL中的查询参数正确设置。</li></ol><p id="4aae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当用户从网格页面导航到另一个页面时，过滤器模型和查询参数将被丢弃，除非它们被保存在存储中并在改变时被更新。通过跟踪过滤器模型或存储中的查询参数，我们能够将网格过滤器设置为其以前的状态。我们的计划是将过滤器模型保存在一个存储中，这样，当用户离开网格页面，然后又回到网格页面时，网格页面组件将查询保存的过滤器模型，并将其应用到网格中，这样，网格就会显示以前过滤过的数据行。</p><p id="78c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的屏幕录制图像显示了所需的效果。请注意，您可以在网格中过滤任意多的列，URL参数将存储网格的状态。</p><figure class="lc ld le lf gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/51164719ee78454dd74da1b9baae0eda.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ihOEB4nEWNFQe97KHUFdbQ.gif"/></div></div></figure></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h1 id="5a8c" class="lo lp iq bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">履行</h1><p id="69a8" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">这个演示使用一个网格来显示一系列虚假的员工或应用程序用户数据。网格中显示的app用户信息包括以下几列:<code class="fe kx ky kz la b">username</code>(字符串)<code class="fe kx ky kz la b">name</code>(字符串)<code class="fe kx ky kz la b">dob</code>(日期)<code class="fe kx ky kz la b">gender</code>(字符串)<code class="fe kx ky kz la b">seniority</code>(数字)。我们可以用不同的条件过滤这五列。</p><p id="8f08" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在每个数据行的前面，有一个用户详细信息页面的链接，它显示了每个用户的更多数据。在用户详细信息页面中，有一个按钮样式的链接可以重定向回网格页面。</p><p id="aae5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇博文中，我将省略网格显示、路由到细节页面等的基本实现。让我们假设所有的基础工作都准备好了。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="0d92" class="ng lp iq bd lq nh ni dn lu nj nk dp ly kj nl nm mc kn nn no mg kr np nq mk nr bi translated">用户-网格-过滤器.服务. ts</h2><p id="6e33" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">首先，我们将实现一个用于跟踪过滤器模型的存储。有许多方法可以在组件之间共享数据，例如，使用状态管理存储，或将数据保存到浏览器中的本地存储。在这个演示中，为了简单起见，我将使用一个“属性包”服务来保存过滤器模型对象。下面的代码片段展示了一个示例服务<code class="fe kx ky kz la b">UsersGridFilterService</code>，它有一个名为<code class="fe kx ky kz la b">filters</code>的属性来保存值。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk">grid-filter service: Property Bag (<a class="ae kw" href="https://gist.github.com/changhuixu/441a19b73bdff9a825bc2a7562ca6f37" rel="noopener ugc nofollow" target="_blank">gist link</a>)</figcaption></figure><p id="8637" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe kx ky kz la b">users-grid-filter.service.ts</code>文件中，为了打字稿<a class="ae kw" href="https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html" rel="noopener ugc nofollow" target="_blank">类型检查</a>，我定义了两个接口(<code class="fe kx ky kz la b">UsersGridFilters</code>和<code class="fe kx ky kz la b">UsersGridFiltersParams</code>)。<code class="fe kx ky kz la b">UsersGridFilters</code>接口代表网格过滤器模型的对象类型；<code class="fe kx ky kz la b">UsersGridFiltersParams</code>接口代表URL查询参数的对象类型。这两个接口中的属性和数据类型由它们的网格列决定。</p><p id="a1a5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意:</strong>界面中每个属性的名称必须与其<a class="ae kw" href="https://www.ag-grid.com/javascript-grid-column-definitions/#column-ids" rel="noopener ugc nofollow" target="_blank">网格列ID </a> <code class="fe kx ky kz la b">colId</code>匹配(如果没有定义<code class="fe kx ky kz la b">colId</code>，则<code class="fe kx ky kz la b">field</code>为默认值)。需要一对一的关系来生成正确的过滤器模型对象供ag-Grid使用。出于演示的目的，我用<code class="fe kx ky kz la b">colId: 'name'</code>和它的值<code class="fe kx ky kz la b">first + ' ' + last</code>配置了一个列<code class="fe kx ky kz la b">Display Name</code>。那么在这种情况下，ag-Grid使用<code class="fe kx ky kz la b">'name'</code>作为对该列应用过滤器的键，我们需要使用<code class="fe kx ky kz la b">'name'</code>作为<code class="fe kx ky kz la b">UsersGridFilters</code>接口中的属性名。</p><p id="0ccc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b">UsersGridFilterService</code>类有一个公共属性<code class="fe kx ky kz la b">filters</code>和一个方法<code class="fe kx ky kz la b">persistFilters(filters: UsersGridFilters)</code>来保存该类中<code class="fe kx ky kz la b">filters</code>对象的副本。现在，这个<code class="fe kx ky kz la b">UsersGridFilterService</code>类充当了一个“属性包”，它的属性<code class="fe kx ky kz la b">filters</code>保存了网格过滤器模型的值。</p><p id="4d45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后，在同一个服务类中，我们将添加两个与过滤器模型和查询参数之间的转换相关的方法。下面的代码片段显示了一个示例实现。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk">conversions between filter model and URL query params (<a class="ae kw" href="https://gist.github.com/changhuixu/1f38e65da83da66c71ceaafd33887813" rel="noopener ugc nofollow" target="_blank">gist link</a>)</figcaption></figure><p id="bee5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">两个方法<code class="fe kx ky kz la b">getFiltersFromQueryParams</code>和<code class="fe kx ky kz la b">getQueryParamsFromFilters</code>几乎是对称的，它们的实现是不言自明的。这两种方法利用了两套实用程序，<code class="fe kx ky kz la b">JSON.parse</code> / <code class="fe kx ky kz la b">JSON.stringify</code>和<code class="fe kx ky kz la b">decodeURIComponent</code> / <code class="fe kx ky kz la b">encodeURIComponent</code>，在字符串和JavaScript对象之间进行转换。值得一提的是，第20到26行需要列出所有可能的字段，并将其设置为<code class="fe kx ky kz la b">null</code>，以便返回一个空的查询参数对象，这样当网格过滤器被清除时，Angular将所有查询参数与原始查询参数合并时，这些参数将被删除。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="89b8" class="ng lp iq bd lq nh ni dn lu nj nk dp ly kj nl nm mc kn nn no mg kr np nq mk nr bi translated">用户-列表.组件. ts</h2><p id="a2bf" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">现在，我们准备连接使用ag-Grid的组件中的点。以下代码片段是一个示例实现，只是我省略了不相关的代码行。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk">users list component using ag-Grid (<a class="ae kw" href="https://gist.github.com/changhuixu/68137a9878f39f7e1a907e38bfa6c71c" rel="noopener ugc nofollow" target="_blank">gist link</a>)</figcaption></figure><p id="f20c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的代码中，第8到13行定义了<code class="fe kx ky kz la b">UsersListComponent</code>的构造函数。我们传入一个<code class="fe kx ky kz la b">UsersGridFilterService</code>的实例，它已经在上一节中介绍过了。我们还需要将<code class="fe kx ky kz la b">ActivatedRoute</code>和<code class="fe kx ky kz la b">Router</code>注入到组件构造函数中，以便读取和更新URL查询参数。</p><p id="ae89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第4行注册了<code class="fe kx ky kz la b">filterChanged</code>事件处理程序，第19到28行是实现。事件处理器从ag-Grid获取过滤器模型，并将其值保存在<code class="fe kx ky kz la b">UsersGridFilterService</code>中。然后<code class="fe kx ky kz la b">filterChanged</code>事件处理程序更新URL查询参数以保持状态同步。另一方面，第34到40行将URL查询参数与过滤器模型同步。</p><p id="03e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第30到32行设置了一个单击清除所有列过滤器的方法。在本演示中，它是可选的。</p><p id="f9a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，如果我们设置ag-Grid列过滤器，那么URL将相应地更新。同样，如果我们修改URL查询参数并刷新页面，那么过滤条件也会更新。</p></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><h2 id="b3bc" class="ng lp iq bd lq nh ni dn lu nj nk dp ly kj nl nm mc kn nn no mg kr np nq mk nr bi translated">用户详细信息.组件. ts</h2><p id="0fa2" class="pw-post-body-paragraph jy jz iq ka b kb mm kd ke kf mn kh ki kj mo kl km kn mp kp kq kr mq kt ku kv ij bi translated">现在让我们假设一个最终用户离开用户网格页面，查看用户详细信息页面。最好有一个链接，引用回主网格页面。在这个场景中，我们需要将<code class="fe kx ky kz la b">queryParams</code>传递给链接，以便过滤器查询参数可以合并到路由中。一个链接元素的例子如下。</p><pre class="lc ld le lf gt ny la nz oa aw ob bi"><span id="ddc3" class="ng lp iq la b gy oc od l oe of">&lt;a class="button" routerLink=".." [queryParams]="filtersParams"&gt;<br/>  Back to Users List<br/>&lt;/a&gt;</span></pre><p id="7666" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">唯一的技巧是获取过滤器查询参数。幸运的是，这很容易，因为我们已经在<code class="fe kx ky kz la b">UsersGridFilterService</code>中实现了这个方法。下面的代码片段显示了一个带有过滤器参数的示例组件。</p><figure class="lc ld le lf gt jr"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="nu nv gj gh gi nw nx bd b be z dk">(<a class="ae kw" href="https://gist.github.com/changhuixu/c7a0f7c710fbb1775ae9f47a014ee018" rel="noopener ugc nofollow" target="_blank">gist link</a>)</figcaption></figure></div><div class="ab cl lh li hu lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ij ik il im in"><p id="7736" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">全部完成！我们实现了一种使用URL查询参数来保留过滤器的方法。我们可以用我们想要的过滤器复制一个URL，并将链接发送给另一个人。那么使用我们URL的人将会看到我们看到的相同的过滤行。这样，URL可以唯一地标识网格的状态。</p><p id="5553" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇博文中描述的方法也可以用来存储URL查询参数中的其他状态。</p><p id="7832" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">今天到此为止。你可以从<a class="ae kw" href="https://changhuixu.github.io/retaining-filters-in-ag-grid/" rel="noopener ugc nofollow" target="_blank">这个网站</a>查看演示，完整的源代码在<a class="ae kw" href="https://github.com/changhuixu/retaining-filters-in-ag-grid" rel="noopener ugc nofollow" target="_blank">这个GitHub库</a>里。请在下面留下评论并与他人分享。谢谢你。</p></div></div>    
</body>
</html>