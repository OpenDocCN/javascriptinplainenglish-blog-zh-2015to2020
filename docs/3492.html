<html>
<head>
<title>Basic Middleware Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的基本中间件模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/basic-middleware-pattern-in-javascript-ef8756a75cb1?source=collection_archive---------0-----------------------#2020-10-04">https://javascript.plainenglish.io/basic-middleware-pattern-in-javascript-ef8756a75cb1?source=collection_archive---------0-----------------------#2020-10-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/fdde0d9df9d1246c30bec430dc6bad97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*e-kv2k5VP88W7p_r"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="110d" class="ka kb in bd kc kd ke dn kf kg kh dp ki kj kk kl km kn ko kp kq kr ks kt ku kv bi translated">想知道流行的web框架中的中间件是如何工作的吗，例如<a class="ae jz" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>或<a class="ae jz" href="https://koajs.com/" rel="noopener ugc nofollow" target="_blank"> Koa </a>？</h2><p id="2a48" class="pw-post-body-paragraph kw kx in ky b kz la lb lc ld le lf lg kj lh li lj kn lk ll lm kr ln lo lp lq ig bi translated">在Express中，我们的中间件功能具有以下特征:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="a420" class="ka kb in lw b gy ma mb l mc md">const middleare = (req, res, next) =&gt; {<br/> // do stuffs<br/> next()<br/>}</span></pre><p id="abaa" class="pw-post-body-paragraph kw kx in ky b kz me lb lc ld mf lf lg kj mg li lj kn mh ll lm kr mi lo lp lq ig bi translated">在Koa，我们有这个:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="c407" class="ka kb in lw b gy ma mb l mc md">const middleware = (ctx, next) =&gt; {<br/>  // do stuffs<br/>  next()<br/>}</span></pre><p id="5f5d" class="pw-post-body-paragraph kw kx in ky b kz me lb lc ld mf lf lg kj mg li lj kn mh ll lm kr mi lo lp lq ig bi translated">基本上，您有一些对象(<code class="fe mj mk ml lw b">req</code>、<code class="fe mj mk ml lw b">res</code>表示Express或<code class="fe mj mk ml lw b">ctx</code>表示Koa)和一个<code class="fe mj mk ml lw b">next()</code>函数作为中间件函数的参数。当<code class="fe mj mk ml lw b">next()</code>被调用时，下一个中间件功能被调用。如果你修改了当前中间件函数中的参数对象，下一个中间件将会收到这些修改后的对象。例如:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="6a91" class="ka kb in lw b gy ma mb l mc md">// Middleware usage in Koa<br/><br/>app.use((ctx, next) =&gt; {<br/>  ctx.name = 'Doe'<br/>  next()<br/>})<br/><br/>app.use((ctx, next) =&gt; {<br/>  console.log(ctx.name) // will log `Doe`<br/>})<br/><br/>app.use((ctx, next) =&gt; {<br/>  // this will not get invoked<br/>})</span></pre><p id="df65" class="pw-post-body-paragraph kw kx in ky b kz me lb lc ld mf lf lg kj mg li lj kn mh ll lm kr mi lo lp lq ig bi translated">而如果不调用<code class="fe mj mk ml lw b">next()</code>函数，执行就停止在那里，下一个中间件函数不会被调用。</p><h1 id="1b83" class="mm kb in bd kc mn mo mp kf mq mr ms ki mt mu mv km mw mx my kq mz na nb ku nc bi translated">履行</h1><p id="aa54" class="pw-post-body-paragraph kw kx in ky b kz la lb lc ld le lf lg kj lh li lj kn lk ll lm kr ln lo lp lq ig bi translated">那么，如何实现这样的模式呢？用30行JavaScript代码:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="7005" class="ka kb in lw b gy ma mb l mc md">function Pipeline(...middlewares) {<br/>  const stack = middlewares<br/><br/>  const push = (...middlewares) =&gt; {<br/>    stack.push(...middlewares)<br/>  }<br/><br/>  const execute = async (context) =&gt; {<br/>    let prevIndex = -1<br/><br/>    const runner = async (index) =&gt; {<br/>      if (index === prevIndex) {<br/>        throw new Error('next() called multiple times')<br/>      }<br/><br/>      prevIndex = index<br/><br/>      const middleware = stack[index]<br/><br/>      if (middleware) {<br/>        await middleware(context, () =&gt; {<br/>          return runner(index + 1)<br/>        })<br/>      }<br/>    }<br/><br/>    await runner(0)<br/>  }<br/><br/>  return { push, execute }<br/>}</span></pre><p id="58a5" class="pw-post-body-paragraph kw kx in ky b kz me lb lc ld mf lf lg kj mg li lj kn mh ll lm kr mi lo lp lq ig bi translated">这种中间件模式的实现几乎和Koa一样。如果你想看看Koa是怎么做的，可以查看一下<code class="fe mj mk ml lw b"><a class="ae jz" href="https://github.com/koajs/compose/blob/master/index.js#L31-L47" rel="noopener ugc nofollow" target="_blank">koa-compose</a></code>包的源代码。</p><h1 id="7f9c" class="mm kb in bd kc mn mo mp kf mq mr ms ki mt mu mv km mw mx my kq mz na nb ku nc bi translated">使用</h1><p id="1ef1" class="pw-post-body-paragraph kw kx in ky b kz la lb lc ld le lf lg kj lh li lj kn lk ll lm kr ln lo lp lq ig bi translated">让我们看一个使用它的例子:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="87c0" class="ka kb in lw b gy ma mb l mc md">// create a middleware pipeline<br/>const pipeline = Pipeline(<br/>  // with an initial middleware<br/>  (ctx, next) =&gt; {<br/>    console.log(ctx)<br/>    next()<br/>  }<br/>)<br/><br/>// add some more middlewares<br/>pipeline.push(<br/>  (ctx, next) =&gt; {<br/>    ctx.value = ctx.value + 21<br/>    next()<br/>  },<br/>  (ctx, next) =&gt; {<br/>    ctx.value = ctx.value * 2<br/>    next()<br/>  }<br/>)<br/><br/>// add the terminating middleware<br/>pipeline.push((ctx, next) =&gt; {<br/>  console.log(ctx)<br/>  // not calling `next()`<br/>})<br/><br/>// add another one for fun ¯\_(ツ)_/¯<br/>pipeline.push((ctx, next) =&gt; {<br/>  console.log('this will not be logged')<br/>})<br/><br/>// execute the pipeline with initial value of `ctx`<br/>pipeline.execute({ value: 0 })</span></pre><p id="28a5" class="pw-post-body-paragraph kw kx in ky b kz me lb lc ld mf lf lg kj mg li lj kn mh ll lm kr mi lo lp lq ig bi translated">如果您运行这段代码，您能猜到输出是什么吗？是的，你猜对了:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="07e6" class="ka kb in lw b gy ma mb l mc md">{ value: 0 }<br/>{ value: 42 }</span></pre><p id="1574" class="pw-post-body-paragraph kw kx in ky b kz me lb lc ld mf lf lg kj mg li lj kn mh ll lm kr mi lo lp lq ig bi translated">顺便说一句，这也绝对适用于异步中间件功能。</p><h1 id="29dc" class="mm kb in bd kc mn mo mp kf mq mr ms ki mt mu mv km mw mx my kq mz na nb ku nc bi translated">以打字打的文件</h1><p id="5869" class="pw-post-body-paragraph kw kx in ky b kz la lb lc ld le lf lg kj lh li lj kn lk ll lm kr ln lo lp lq ig bi translated">现在，给它一些打字稿的爱怎么样？</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="17d4" class="ka kb in lw b gy ma mb l mc md">type Next = () =&gt; Promise&lt;void&gt; | void<br/><br/>type Middleware&lt;T&gt; = (context: T, next: Next) =&gt; Promise&lt;void&gt; | void<br/><br/>type Pipeline&lt;T&gt; = {<br/>  push: (...middlewares: Middleware&lt;T&gt;[]) =&gt; void<br/>  execute: (context: T) =&gt; Promise&lt;void&gt;<br/>}<br/><br/>function Pipeline&lt;T&gt;(...middlewares: Middleware&lt;T&gt;[]): Pipeline&lt;T&gt; {<br/>  const stack: Middleware&lt;T&gt;[] = middlewares<br/><br/>  const push: Pipeline&lt;T&gt;['push'] = (...middlewares) =&gt; {<br/>    stack.push(...middlewares)<br/>  }<br/><br/>  const execute: Pipeline&lt;T&gt;['execute'] = async (context) =&gt; {<br/>    let prevIndex = -1<br/><br/>    const runner = async (index: number): Promise&lt;void&gt; =&gt; {<br/>      if (index === prevIndex) {<br/>        throw new Error('next() called multiple times')<br/>      }<br/><br/>      prevIndex = index<br/><br/>      const middleware = stack[index]<br/><br/>      if (middleware) {<br/>        await middleware(context, () =&gt; {<br/>          return runner(index + 1)<br/>        })<br/>      }<br/>    }<br/><br/>    await runner(0)<br/>  }<br/><br/>  return { push, execute }<br/>}</span></pre><p id="f91f" class="pw-post-body-paragraph kw kx in ky b kz me lb lc ld mf lf lg kj mg li lj kn mh ll lm kr mi lo lp lq ig bi translated">随着一切都被类型化，现在您可以为特定的中间件管道声明上下文对象的类型，如下所示:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="2c20" class="ka kb in lw b gy ma mb l mc md">type Context = {<br/>  value: number<br/>}<br/><br/>const pipeline = Pipeline&lt;Context&gt;()</span></pre><p id="d5ef" class="pw-post-body-paragraph kw kx in ky b kz me lb lc ld mf lf lg kj mg li lj kn mh ll lm kr mi lo lp lq ig bi translated">好了，暂时就这些了。</p><p id="ba23" class="pw-post-body-paragraph kw kx in ky b kz me lb lc ld mf lf lg kj mg li lj kn mh ll lm kr mi lo lp lq ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky io">订阅解码，我们的YouTube频道</strong> </a> <strong class="ky io">获取更多类似内容！</strong></p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><p id="a52e" class="pw-post-body-paragraph kw kx in ky b kz me lb lc ld mf lf lg kj mg li lj kn mh ll lm kr mi lo lp lq ig bi translated"><em class="nk">原载于2020年10月4日</em><a class="ae jz" href="https://muniftanjim.dev/blog/basic-middleware-pattern-in-javascript/" rel="noopener ugc nofollow" target="_blank"><em class="nk">https://muniftanjim . dev</em></a><em class="nk">。</em></p></div></div>    
</body>
</html>