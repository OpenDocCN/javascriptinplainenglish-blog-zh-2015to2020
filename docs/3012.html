<html>
<head>
<title>Building a gRPC service with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node.js构建gRPC服务</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-a-grpc-service-with-node-js-370b576d3809?source=collection_archive---------2-----------------------#2020-08-18">https://javascript.plainenglish.io/building-a-grpc-service-with-node-js-370b576d3809?source=collection_archive---------2-----------------------#2020-08-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cfe548a8fb3354523c4f7db3fc2ed4b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IMQ7jyacFtBIMQbNGvXGTQ.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@mr_vero?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Irvan Smith</a> on <a class="ae jz" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dadd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了gRPC，客户机应用程序可以更容易地直接调用不同机器上的服务器应用程序，就像它是一个本地对象一样。gRPC的思想是用Protobuf文件中的方法定义服务，然后服务器需要实现定义的方法，这样客户端应用程序就能够通过使用定义的方法来调用这些服务。</p><h1 id="ed5d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么gRPC比REST好？</h1><h2 id="dc88" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">数据序列化</h2><p id="d42a" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">GRPC的数据传输采用二进制格式，而其他地方则采用文本格式。GRPC使用协议缓冲区来序列化数据。与REST相比，它可以帮助数据变得更小更快，因为REST使用的是可能很大的纯文本。</p><h2 id="239c" class="lw kz in bd la lx ly dn le lz ma dp li kl mb mc lm kp md me lq kt mf mg lu mh bi translated">与HTTP/1相比，使用HTTP/2</h2><p id="22f3" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">虽然REST可以支持HTTP/2，但是我们需要使它能够与只能支持HTTP/2的GRPC相比较。众所周知，HTTP/2的性能比HTTP/1好得多，因为它可以通过一个TCP连接并行发送多个数据请求。</p><h1 id="ea59" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">原蟾蜍</h1><p id="9983" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated"><strong class="kc io">支付</strong>服务有两种方法，分别是<strong class="kc io">创建令牌</strong>和<strong class="kc io">删除令牌</strong>。这些方法中的每一个都提供了请求和响应类型。</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="986a" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">计算机网络服务器</h1><p id="43d2" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">服务器接收来自客户端的请求，并做出相应的响应。它已经实现了支付服务定义，并开始在端口号为50051的本地主机上运行服务器。</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="10b2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">客户</h1><p id="d4b3" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">客户端发送请求并接收响应。它解释了如何与服务器通信。首先，它通过使用端口50051拨号到本地主机来建立与服务器的连接。一旦连接建立，它就开始调用像CreateToken和DeleteToken这样的RPC方法。</p><figure class="mn mo mp mq gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><h1 id="3bfa" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="fb1e" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated">用JavaScript实现Protobuf并不是特别困难。事实证明，gRPC比REST更快，因为gRPC提供了所有的优势，比如数据序列化和HTTP/2。</p><p id="52f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">总之，这将使gRPC的性能优于REST。</p><h1 id="3f4e" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">参考</h1><p id="e842" class="pw-post-body-paragraph ka kb in kc b kd mi kf kg kh mj kj kk kl mk kn ko kp ml kr ks kt mm kv kw kx ig bi translated"><a class="ae jz" href="https://grpc.io/docs/languages/node/basics/" rel="noopener ugc nofollow" target="_blank">https://grpc.io/docs/languages/node/basics/</a></p><p id="3153" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://www.yonego.com/nl/why-milliseconds-matter/#gref" rel="noopener ugc nofollow" target="_blank">https://www.yonego.com/nl/why-milliseconds-matter/#gref</a></p></div></div>    
</body>
</html>