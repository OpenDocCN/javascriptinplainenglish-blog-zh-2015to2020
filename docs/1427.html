<html>
<head>
<title>In JavaScript, is undefined actually undefined?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中，undefined实际上是未定义的吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/is-undefined-actually-undefined-e836e4bde871?source=collection_archive---------3-----------------------#2020-03-14">https://javascript.plainenglish.io/is-undefined-actually-undefined-e836e4bde871?source=collection_archive---------3-----------------------#2020-03-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="59ad" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如果我们给它设定一个值会发生什么？</h2></div><p id="212d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">应该是，但原来“<em class="ky">未定义”</em>是一个变量。那么如果我们给它设置一个值会发生什么呢？JavaScript的怪异世界…</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/580b3ae6058ba67996ee83e4e31654ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t0ebm5qG0t6z7vVDh2NX4A.jpeg"/></div></figure><p id="27bb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">TL；DR undefined不是一个受限制的关键字，所以我们可能会错误地将变量命名为“undefined ”,并为其设置一个值，这将在运行时导致错误。使用棉绒来防止它发生。</em></p><p id="42f6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在你的<em class="ky"> if </em>语句中使用<em class="ky"> void </em>关键字而不是<em class="ky"> undefined </em>有一个很好的理由，这是因为未定义的变量实际上可能被定义。背后的原因并不是一个受限制的关键词。Undefined是全局对象的一个属性，所以它是全局范围内的一个变量。继续在你的浏览器控制台中键入<em class="ky">窗口</em>——你会在<em class="ky">窗口</em>对象中找到<em class="ky">未定义的</em>属性。所以:</p><pre class="la lb lc ld gt lh li lj lk aw ll bi"><span id="71fc" class="lm ln in li b gy lo lp l lq lr">window.undefined === undefined; // returns true</span></pre><h1 id="cbc4" class="ls ln in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">JavaScript中的“void”是什么？</h1><p id="cdd8" class="pw-post-body-paragraph kc kd in ke b kf mj jo kh ki mk jr kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">简单来说:JS中的void是一个用来返回“未定义”值的运算符。</p><pre class="la lb lc ld gt lh li lj lk aw ll bi"><span id="0148" class="lm ln in li b gy lo lp l lq lr">void 0 == void(0); //true because void 0 is equal to void(0)<br/>void 1 == void(0); //true<br/>void 0 == undefined; //true<br/>void 0 === undefined; //true<br/>void 1241 === void "everything can go here" //true</span></pre><p id="090c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码表明，在检查变量的未定义值时，void关键字是最佳选择。</p><blockquote class="mo mp mq"><p id="1c83" class="kc kd ky ke b kf kg jo kh ki kj jr kk mr km kn ko ms kq kr ks mt ku kv kw kx ig bi translated"><strong class="ke io">免责声明:</strong>在文章开头我写了未定义的可能被定义。这意味着在某些情况下“void 0 === undefined”可能会返回false。我们将很快回到这个问题。</p></blockquote><h1 id="89d3" class="ls ln in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">如果我定义了“未定义”会发生什么？</h1><p id="5a29" class="pw-post-body-paragraph kc kd in ke b kf mj jo kh ki mk jr kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">在支持2009年ECMA-262第五版(也称为ES5)的现代浏览器(包括IE11)中，这样的变量仍然是未定义的，因为它是只读的。</p><pre class="la lb lc ld gt lh li lj lk aw ll bi"><span id="ae13" class="lm ln in li b gy lo lp l lq lr">15.1 The Global Object<br/>The unique global object is created before control enters any execution context.</span><span id="fbd5" class="lm ln in li b gy mu lp l lq lr">Unless otherwise specified, the standard built-in properties of the global object have attributes {[[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.</span><span id="41fe" class="lm ln in li b gy mu lp l lq lr">[...]</span><span id="4073" class="lm ln in li b gy mu lp l lq lr">15.1.1.3 undefined</span><span id="1d83" class="lm ln in li b gy mu lp l lq lr">The value of undefined is undefined (see 8.1). This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</span></pre><p id="7b3d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">来源</strong> : <a class="ae mv" href="https://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262%205th%20edition%20December%202009.pdf" rel="noopener ugc nofollow" target="_blank"> ECMAScript语言规范</a></p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/568d2ce31f7fa2b6b9ee4c0a5397baef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qOWGmx1OagOy-ZvTObN8Cw.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Defining the “undefined” variable using the “var” keyword.</figcaption></figure><p id="73c7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你像我一样习惯用<em class="ky">让</em>，你会得到不一样的东西:</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi nf"><img src="../Images/8279803548b6bdcf368e66217f37f807.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3Yz1FVkn9HuTLjMJDLz7fg.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Defining the “undefined” variable using the “let” keyword.</figcaption></figure><p id="b8ac" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们得到“标识符‘undefined’已经被声明”,因为它是在窗口对象中定义的。但是无论如何我们使用<em class="ky"> var </em>的时候不应该得到一个错误吗？我们应该！这就是为什么在每一个的开头输入是好的。js文件:</p><pre class="la lb lc ld gt lh li lj lk aw ll bi"><span id="ba0b" class="lm ln in li b gy lo lp l lq lr">"use strict";</span></pre><p id="22b2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">严格模式将阻止我们定义<em class="ky">未定义:</em></p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi ng"><img src="../Images/9be6a61a42898b68ee9df433b2dea93e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lvXKVNIEVHUvFD8KzDf8jA.png"/></div></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">Way better :)</figcaption></figure><h1 id="2a48" class="ls ln in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">不管怎样，我想把我的变量命名为“未定义的”。</h1><p id="7b63" class="pw-post-body-paragraph kc kd in ke b kf mj jo kh ki mk jr kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">有一个窍门。15.1.1.3<strong class="ke io">中指定的上述规则仅适用于全局对象。</strong>局部范围不同:</p><pre class="la lb lc ld gt lh li lj lk aw ll bi"><span id="c5db" class="lm ln in li b gy lo lp l lq lr">function someFunction() {<br/>   let undefined = 10;<br/>   console.log(undefined);<br/>}</span><span id="d3cb" class="lm ln in li b gy mu lp l lq lr">someFunction(); //logs 10</span></pre><p id="d787" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">ES6标准引入了新的<em class="ky"> let </em>和<em class="ky"> const </em>关键字。由<code class="fe nh ni nj li b">var</code>关键字声明的变量的作用域是直接函数体(因此是函数作用域),而<code class="fe nh ni nj li b">let</code>变量的作用域是直接<em class="ky">包围由<code class="fe nh ni nj li b">{ }</code>表示的</em>块。来源:<a class="ae mv" href="https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var" rel="noopener ugc nofollow" target="_blank">用“let”和“var”有什么区别？但是有一个小缺点:</a></p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/2b6f3df30ab5d2b8c87ca1127364b78e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*L_m8qSwT1BqA8aG_wzilrQ.png"/></div><figcaption class="nb nc gj gh gi nd ne bd b be z dk">In this example, we can see that strict mode won’t prevent us from setting the undefined variable!</figcaption></figure><p id="801d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">编辑</strong>:设置一个值为未定义是有原因的。在jQuery <em class="ky">中，未定义的</em>被指定为一个参数，以确保它之前没有被定义，例如在其他包含在项目脚本中:</p><div class="nl nm gp gr nn no"><a href="https://github.com/jquery-boilerplate/jquery-boilerplate/blob/a270f97ba531ecf52de280bdb3ea56d3c8c0122b/src/jquery.boilerplate.js" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd io gy z fp nt fr fs nu fu fw im bi translated">jquery-样板/jquery-样板</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">jQuery插件开发的起点。通过…为jquery-boilerplate/jquery-boilerplate开发做出贡献</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">github.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc lf no"/></div></div></a></div><pre class="la lb lc ld gt lh li lj lk aw ll bi"><span id="d75c" class="lm ln in li b gy lo lp l lq lr">;( function( $, window, document, undefined ) { ... }</span></pre><blockquote class="mo mp mq"><p id="31f8" class="kc kd ky ke b kf kg jo kh ki kj jr kk mr km kn ko ms kq kr ks mt ku kv kw kx ig bi translated">undefined并没有真正被传入，所以我们可以确保它的值确实是undefined。在ES5中，undefined不能再被修改。</p></blockquote><h2 id="8ab4" class="lm ln in bd lt od oe dn lx of og dp mb kl oh oi md kp oj ok mf kt ol om mh on bi translated">Node.js怎么样？</h2><p id="86b6" class="pw-post-body-paragraph kc kd in ke b kf mj jo kh ki mk jr kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated"><strong class="ke io">原来我们也可以在node.js环境中为<em class="ky">未定义的</em>设置一个值。</strong>但是Node.js支持ES5那么这是怎么回事呢？</p><p id="5ab1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">答案可以在Node.js官方文档中找到:</p><pre class="la lb lc ld gt lh li lj lk aw ll bi"><span id="c354" class="lm ln in li b gy lo lp l lq lr">In browsers, the top-level scope is the global scope. This means that within the browser <!-- -->var something<!-- --> will define a new global variable. In Node.js this is different. <strong class="li io">The top-level scope is not the global scope;</strong> <!-- -->var something<!-- --> inside a Node.js module will be local to that module.</span></pre><p id="2612" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">来源:</strong> <a class="ae mv" href="https://nodejs.org/api/globals.html#globals_global_objects" rel="noopener ugc nofollow" target="_blank"> Node.js v13.11.0文档</a></p><p id="7373" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个巨大的问题。当你像这样写if语句时:</p><pre class="la lb lc ld gt lh li lj lk aw ll bi"><span id="afb1" class="lm ln in li b gy lo lp l lq lr">if (myVariable === undefined) {...}</span></pre><p id="3c3d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">…你不能确定你的变量是否是未定义的，因为有人可能在几十行之前错误地命名了一个“未定义”的变量。</p><h1 id="67f2" class="ls ln in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">那么如何确定变量是否未定义呢？</h1><p id="4c27" class="pw-post-body-paragraph kc kd in ke b kf mj jo kh ki mk jr kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">有多种方法可以做到这一点:</p><ol class=""><li id="a09a" class="oo op in ke b kf kg ki kj kl oq kp or kt os kx ot ou ov ow bi translated">使用null</li></ol><pre class="la lb lc ld gt lh li lj lk aw ll bi"><span id="5c6e" class="lm ln in li b gy lo lp l lq lr">var something;</span><span id="12b6" class="lm ln in li b gy mu lp l lq lr">something == null; // true<br/>something === null; // false</span></pre><p id="c7c9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我不喜欢这种方式，因为null在JavaScript中不是null，而是一个对象，你必须记住使用==，而不是===现在不推荐或不典型的。</p><p id="d699" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.类型of</p><pre class="la lb lc ld gt lh li lj lk aw ll bi"><span id="11be" class="lm ln in li b gy lo lp l lq lr">var something;</span><span id="4c86" class="lm ln in li b gy mu lp l lq lr">typeof something === 'undefined'; // true<br/>typeof something === undefined; // false</span></pre><p id="00e6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Typeof总是返回一个字符串。回到我刚开始学习JavaScript的时候，在编写第一行代码时，我并不清楚为什么要用一个字符串来检查undefined。出于这个原因，我不喜欢这样做，但ESLint推荐这样做，所以这也是一个选项。</p><p id="5b7a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.检查变量是否有值</p><pre class="la lb lc ld gt lh li lj lk aw ll bi"><span id="99ba" class="lm ln in li b gy lo lp l lq lr">var something;</span><span id="6c20" class="lm ln in li b gy mu lp l lq lr">if(something) console.log("is not undefined");</span></pre><p id="e452" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然它可以工作，但我不推荐它，因为变量<em class="ky"> something </em>可能被设置为false，这意味着它有一个值，不再是未定义的。</p><p id="7b15" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">4.void 0</p><pre class="la lb lc ld gt lh li lj lk aw ll bi"><span id="811f" class="lm ln in li b gy lo lp l lq lr">var something;</span><span id="0cff" class="lm ln in li b gy mu lp l lq lr">void 0 == something; // true<br/>void 0 === something; // true</span></pre><p id="ba4d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我认为这是最好的方法。没有太多需要记住的，因为void 0总是未定义的。它看起来不寻常，但它的工作，很容易打字。</p><h1 id="75ca" class="ls ln in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">ESLint中无未定义/无阴影限制的名称</h1><p id="b97c" class="pw-post-body-paragraph kc kd in ke b kf mj jo kh ki mk jr kk kl ml kn ko kp mm kr ks kt mn kv kw kx ig bi translated">ESLinter附带了无未定义和无阴影限制名称规则，这迫使我们不要在任何地方使用<em class="ky">未定义的</em>。由于这个原因(不仅仅是这个原因),使用代码棉条是有好处的。你可以在这里阅读更多关于这些规则的内容:</p><div class="nl nm gp gr nn no"><a href="https://eslint.org/docs/rules/no-undefined" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd io gy z fp nt fr fs nu fu fw im bi translated">无-未定义-规则</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">JavaScript中未定义的变量是全局对象的属性。因此，在ECMAScript 3中，它是…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">eslint.org</p></div></div><div class="nx l"><div class="ox l nz oa ob nx oc lf no"/></div></div></a></div><div class="nl nm gp gr nn no"><a href="https://eslint.org/docs/rules/no-shadow-restricted-names" rel="noopener  ugc nofollow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd io gy z fp nt fr fs nu fu fw im bi translated">无阴影限制名称-规则</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">配置文件中的" extends": "eslint:recommended "属性启用此规则。ES5 15.1.1价值属性…</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">eslint.org</p></div></div><div class="nx l"><div class="oy l nz oa ob nx oc lf no"/></div></div></a></div><h1 id="3321" class="ls ln in bd lt lu lv lw lx ly lz ma mb jt mc ju md jw me jx mf jz mg ka mh mi bi translated">摘要</h1><ol class=""><li id="1d95" class="oo op in ke b kf mj ki mk kl oz kp pa kt pb kx ot ou ov ow bi translated">尽量不要使用<em class="ky">未定义的</em>关键字。不建议这么做。</li><li id="0e9c" class="oo op in ke b kf pc ki pd kl pe kp pf kt pg kx ot ou ov ow bi translated"><em class="ky"> Void 0 </em>很好，因为这是确定变量是否未定义的最可靠、最简单的方法。Typeof也可以。你更喜欢哪个选项完全取决于你。</li><li id="ff75" class="oo op in ke b kf pc ki pd kl pe kp pf kt pg kx ot ou ov ow bi translated">使用linters(例如ESLint)将防止您将值设置为undefined，所以您不必担心这一点。</li><li id="cd69" class="oo op in ke b kf pc ki pd kl pe kp pf kt pg kx ot ou ov ow bi translated">在边缘情况下，您可能需要设置undefined以确保它是未定义的。</li></ol></div></div>    
</body>
</html>