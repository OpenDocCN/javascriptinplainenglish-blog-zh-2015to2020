<html>
<head>
<title>Introduction to TypeScript Classes— Access Modifiers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">类型脚本类简介—访问修饰符</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-typescript-classes-access-modifiers-c7592d7b33b9?source=collection_archive---------6-----------------------#2020-01-30">https://javascript.plainenglish.io/introduction-to-typescript-classes-access-modifiers-c7592d7b33b9?source=collection_archive---------6-----------------------#2020-01-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4981c2cf7a395527233d20941e546788.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E3WXRh3z9bXTsm7C"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@freestocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">freestocks.org</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dde2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与JavaScript一样，TypeScript中的类是其原型继承模型的特殊语法，这是基于类的面向对象语言中的类似继承。类只是添加到ES6中的特殊函数，用来模仿其他语言中的关键字<code class="fe lb lc ld le b">class</code>。在JavaScript中，我们可以有<code class="fe lb lc ld le b">class</code>声明和<code class="fe lb lc ld le b">class</code>表达式，因为它们只是函数。所以像所有其他函数一样，有函数声明和函数表达式。TypeScript也是如此。类充当创建新对象的模板。TypeScript扩展了JavaScript类的语法，然后添加了自己的变体。在本文中，我们将研究如何定义TypeScript类以及它们如何相互继承。在本文中，我们将研究TypeScript中类成员的访问修饰符。</p><h1 id="28f9" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">公共、私有和受保护修饰符</h1><h2 id="0574" class="md lg iq bd lh me mf dn ll mg mh dp lp ko mi mj lt ks mk ml lx kw mm mn mb mo bi translated">公共</h2><p id="cc32" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">在TypeScript中，类成员可以添加访问修饰符。这让我们可以控制定义类成员的类之外的程序的不同部分对类成员的访问。TypeScript中类成员的默认访问修饰符是<code class="fe lb lc ld le b">public</code>。这意味着没有访问修饰符的类成员将被指定为公共成员。例如，我们可以在下面的代码中使用<code class="fe lb lc ld le b">public</code>修饰符:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="b647" class="md lg iq le b gy nc nd l ne nf">class Person {<br/>  public name: string;<br/>  public constructor(name: string) {<br/>    this.name = name;<br/>  }</span><span id="4175" class="md lg iq le b gy ng nd l ne nf">  public getName(): string{<br/>    return this.name;<br/>  }<br/>}</span><span id="1a11" class="md lg iq le b gy ng nd l ne nf">const person = new Person('Jane');<br/>console.log(person.getName());<br/>console.log(person.name);</span></pre><p id="483a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们将<code class="fe lb lc ld le b">Person</code>类中的所有成员指定为<code class="fe lb lc ld le b">public</code>，这样我们就可以在<code class="fe lb lc ld le b">Person</code>类之外访问它们。我们可以在<code class="fe lb lc ld le b">Person</code>实例上调用<code class="fe lb lc ld le b">getName</code>方法，也可以直接从类外部获取<code class="fe lb lc ld le b">name</code>字段。<code class="fe lb lc ld le b">constructor</code>方法上的<code class="fe lb lc ld le b">public</code>访问修饰符是额外的，因为<code class="fe lb lc ld le b">constructor</code>应该总是公共的，所以我们可以用它实例化这个类。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/e950689c05716c3a6b0880bffd40db56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ixuodRZRJvkF_bAW"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@dtopkin1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dayne Topkin</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="5eee" class="md lg iq bd lh me mf dn ll mg mh dp lp ko mi mj lt ks mk ml lx kw mm mn mb mo bi translated">私人和受保护的</h2><p id="3c1f" class="pw-post-body-paragraph kd ke iq kf b kg mp ki kj kk mq km kn ko mr kq kr ks ms ku kv kw mt ky kz la ij bi translated">当一个类的成员被标记为<code class="fe lb lc ld le b">private</code>时，它就不能在包含它的类之外被访问。受保护成员仅在具有受保护成员的类的子类中和具有该成员并标有关键字<code class="fe lb lc ld le b">protected</code>的类中可用。例如，如果我们的类中有一个<code class="fe lb lc ld le b">private</code>成员，如下所示:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="e80b" class="md lg iq le b gy nc nd l ne nf">class Person {<br/>  private name: string;<br/>  constructor(name: string) {<br/>    this.name = name;<br/>  }</span><span id="da9f" class="md lg iq le b gy ng nd l ne nf">  public getName(): string{<br/>    return this.name;<br/>  }<br/>}</span><span id="b253" class="md lg iq le b gy ng nd l ne nf">const person = new Person('Jane');<br/>console.log(person.getName());<br/>console.log(person.name);</span></pre><p id="0310" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们试图访问它时，就像我们对上面的<code class="fe lb lc ld le b">Person</code>类中的成员<code class="fe lb lc ld le b">name</code>所做的那样，我们会得到一个错误。如果我们尝试编译并运行上面的代码，TypeScript编译器将不会编译该代码，并给出错误消息“Property 'name '是私有的，只能在类' Person '中访问。(2341)“就像我们对私人成员的期望一样。</p><p id="3b08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript通过公共成员的结构来比较类型。如果这两种类型列出了相同的公共成员，则它们被TypeScript标记为兼容。然而，对于私有和受保护的成员，情况并非如此。对于私有成员和受保护成员，如果两个类被认为是相等的，那么这两个类必须具有来自同一来源的相同私有成员和受保护成员，它们才能被认为是同一类型。例如，如果我们有以下代码:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="cc1d" class="md lg iq le b gy nc nd l ne nf">class Person {<br/>  private name: string;<br/>  constructor(name: string) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="171c" class="md lg iq le b gy ng nd l ne nf">class Human {<br/>  private name: string;<br/>  constructor(name: string) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="b02c" class="md lg iq le b gy ng nd l ne nf">const human: Human = new Person('Jane');</span></pre><p id="3c04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们将得到错误“类型‘Person’不可赋给类型‘Human’。类型有单独的私有属性“name”声明。(2322)".这意味着因为<code class="fe lb lc ld le b">Person</code>和<code class="fe lb lc ld le b">Human</code>有相同的私有成员<code class="fe lb lc ld le b">name</code>，所以它们不能被认为是相同的类型，所以我们不能将<code class="fe lb lc ld le b">Person</code>的实例赋给类型为<code class="fe lb lc ld le b">Human</code>的变量。这对于受保护的成员也是一样的，所以如果我们有下面的代码:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="d7be" class="md lg iq le b gy nc nd l ne nf">class Person {<br/>  protected name: string;<br/>  constructor(name: string) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="0cfb" class="md lg iq le b gy ng nd l ne nf">class Human {<br/>  protected name: string;<br/>  constructor(name: string) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="f4c5" class="md lg iq le b gy ng nd l ne nf">const human: Human = new Person('Jane');</span></pre><p id="d931" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会得到同样的错误。但是如果我们像下面的代码那样将<code class="fe lb lc ld le b">protected</code>改为<code class="fe lb lc ld le b">public</code>，那么它将会工作:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="62ef" class="md lg iq le b gy nc nd l ne nf">class Person {<br/>  public name: string;<br/>  constructor(name: string) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="561d" class="md lg iq le b gy ng nd l ne nf">class Human {<br/>  public name: string;<br/>  constructor(name: string) {<br/>    this.name = name;<br/>  }<br/>}</span><span id="79ed" class="md lg iq le b gy ng nd l ne nf">const human: Human = new Person('Jane');<br/>console.log(human.name);</span></pre><p id="1513" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行上面的代码，我们会在最后一行看到从<code class="fe lb lc ld le b">console.log</code>语句记录的‘Jane’。</p><p id="1eb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们的类中有私有成员，那么它们必须在两个类的超类中才能被认为是平等的。例如，我们可以编写以下代码，使<code class="fe lb lc ld le b">Person</code>和<code class="fe lb lc ld le b">Human</code>类被认为是相同的，同时每个类都有一个公共私有成员<code class="fe lb lc ld le b">name</code>:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="0fb3" class="md lg iq le b gy nc nd l ne nf">class Animal {<br/>  private name: string;<br/>  constructor(name: string) {<br/>    this.name = name;      <br/>  }<br/>}</span><span id="b3ab" class="md lg iq le b gy ng nd l ne nf">class Person extends Animal{<br/>  constructor(name: string) {<br/>    super(name);    <br/>  }<br/>}</span><span id="e201" class="md lg iq le b gy ng nd l ne nf">class Human extends Animal{<br/>  constructor(name: string) {<br/>    super(name);    <br/>  }<br/>}</span><span id="e649" class="md lg iq le b gy ng nd l ne nf">const human: Human = new Person('Jane');<br/>console.log(human);</span></pre><p id="b895" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有私有<code class="fe lb lc ld le b">name</code>成员的<code class="fe lb lc ld le b">Animal</code>类，并且<code class="fe lb lc ld le b">Person</code>和<code class="fe lb lc ld le b">Human</code>类都扩展了<code class="fe lb lc ld le b">Animal</code>类，因此<code class="fe lb lc ld le b">Human</code>和<code class="fe lb lc ld le b">Person</code>将被认为是相等的，因为它们没有私有成员<code class="fe lb lc ld le b">name</code>的单独实现，而是在<code class="fe lb lc ld le b">Animal</code>类中有一个公共的<code class="fe lb lc ld le b">name</code>成员，它们都继承自这个成员。当我们在最后一行的<code class="fe lb lc ld le b">human</code>上运行<code class="fe lb lc ld le b">console.log</code>时，我们会看到<code class="fe lb lc ld le b">Person</code>对象被记录。</p><p id="b50c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，对于受保护的成员，我们可以在下面的代码中做类似的事情:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="be8a" class="md lg iq le b gy nc nd l ne nf">class Animal {<br/>  protected name: string;<br/>  constructor(name: string) {<br/>    this.name = name;      <br/>  }<br/>}</span><span id="b838" class="md lg iq le b gy ng nd l ne nf">class Person extends Animal{<br/>  constructor(name: string) {<br/>    super(name);    <br/>  }</span><span id="0f92" class="md lg iq le b gy ng nd l ne nf">  getName() {<br/>    return this.name;<br/>  }<br/>}</span><span id="44e4" class="md lg iq le b gy ng nd l ne nf">class Human extends Animal{<br/>  constructor(name: string) {<br/>    super(name);    <br/>  }</span><span id="c5ae" class="md lg iq le b gy ng nd l ne nf">  getName() {<br/>    return this.name;<br/>  }<br/>}</span><span id="c495" class="md lg iq le b gy ng nd l ne nf">const human: Human = new Person('Jane');<br/>console.log(human.getName());</span></pre><p id="9664" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有受保护的成员<code class="fe lb lc ld le b">name</code>，它可以被它的子类<code class="fe lb lc ld le b">Human</code>和<code class="fe lb lc ld le b">Person</code>访问，所以我们可以用每个类上的<code class="fe lb lc ld le b">getName</code>方法返回<code class="fe lb lc ld le b">name</code>成员的值和<code class="fe lb lc ld le b">Animal</code>类中<code class="fe lb lc ld le b">name</code>成员的值。我们需要这个方法，因为受保护的成员只能在拥有受保护成员的类和拥有该成员的类的子类中使用。如果我们运行上面的代码，我们将从上面代码最后一行的<code class="fe lb lc ld le b">console.log</code>输出中得到‘Jane’。</p><p id="76f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在TypeScript中，类成员可以应用访问修饰符。如果未指定任何内容，Public是成员的默认访问修饰符。如果两个类都具有相同的公共成员，或者它们从相同的源继承受保护成员和私有成员并具有相同的公共成员，则认为它们是相等的。</p></div></div>    
</body>
</html>