<html>
<head>
<title>Testing in React, Part 3: Jest &amp; Jest-Dom</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的测试，第3部分:Jest &amp; Jest-Dom</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/testing-in-react-part-3-jest-jest-dom-7a8a03ae60b?source=collection_archive---------1-----------------------#2020-07-30">https://javascript.plainenglish.io/testing-in-react-part-3-jest-jest-dom-7a8a03ae60b?source=collection_archive---------1-----------------------#2020-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/f36da603f8dc690412d4833e99231170.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eUX1QquA4lQXNzWRS0GlvA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@hi_i_am_steph?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Stephane Coudassot-Berducou</a> on <a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><blockquote class="kk kl km"><p id="6d55" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">本文是React中测试系列的一部分:</p><p id="0e47" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-1-types-tools-244107abf0c6" rel="noopener">React中的测试，第1部分:类型&amp;工具</a></p><p id="90ab" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-2-react-testing-library-f32432b93c6c" rel="noopener">React中的测试，第2部分:React测试库</a></p><p id="1683" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="kq jh">React的测试，第3部分:Jest &amp; Jest-Dom </strong></p><p id="9369" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-4-enzyme-9b030ad616ae" rel="noopener">React中的测试，第4部分:酶</a></p><p id="5c1e" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/@bryn.bennett/testing-in-react-part-5-end-to-end-testing-with-cypress-bd2bf8d3385f" rel="noopener">React中的测试，第5部分:使用Cypress的端到端测试</a></p><p id="b478" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-6-real-world-testing-with-react-testing-library-jest-enzyme-and-cypress-9c73436d95d8" rel="noopener">React中的测试，第6部分:React测试库、Jest、Enzyme和Cypress的真实测试</a></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="e550" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">到目前为止，在本系列中，我们已经介绍了React的各种类型的测试和工具，以及最流行的测试库之一，<a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-2-react-testing-library-f32432b93c6c" rel="noopener"> React测试库</a>。如果你还没有读过这些，我建议你读一读。Jest与React测试库一起使用，为了理解通过渲染组件树进行测试，理解这两者是很重要的。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="9314" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">快速回顾一下</h1><p id="5cdb" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">用Jest和React测试库测试渲染组件树完全是为了测试用户体验。它是从用户的角度测试应用程序的行为，而不是测试代码的实现。</p><p id="f593" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">为了做到这一点，您必须有两个基本部分——在其上执行测试的呈现元素(即组件),以及要测试的DOM节点的特定质量或属性(即组件中按钮的存在)。</p><p id="1931" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">考虑React测试库和Jest的一个简单方法是，React测试库处理元素的呈现，Jest处理DOM节点的测试。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="5b38" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">笑话世界</h1><p id="b9d6" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">现在<em class="kp">在技术上，</em> React测试库也通过一个叫做<a class="ae jd" href="https://testing-library.com/docs/ecosystem-jest-dom" rel="noopener ugc nofollow" target="_blank"> Jest-Dom </a>的东西提供了一些测试功能。文档将Jest-Dom描述为:</p><blockquote class="kk kl km"><p id="5e65" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe ms mt mu mv b">React Testing Library</code>的配套库，为Jest提供定制的DOM元素匹配器。</p></blockquote><p id="82db" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">简单地说，匹配器是测试的元素，表示类似<code class="fe ms mt mu mv b">.toEqual()</code>或<code class="fe ms mt mu mv b">.toBeVisible</code>的东西。我们将简要介绍Jest-Dom，但实际上它只是一个扩展列表，提供了更多不同属性的选项供测试。重要的是要知道，它会在你需要的时候出现，如果你在Jest的匹配器里找不到你想要的，Jest-Dom可能就有你想要的。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="bdb1" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">玩笑</h1><p id="0b75" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">我认为Jest是创建测试环境的工具。它提供了呈现用于测试的组件的上下文，并创建了测试套件和测试块。</p><p id="dd39" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">Jest可以在您的<code class="fe ms mt mu mv b">package.json</code>文件、<code class="fe ms mt mu mv b">jest.config.js</code>文件或<code class="fe ms mt mu mv b">—-config &lt;path/to/file.js|cjs|mjs|json&gt;</code>选项中配置。您可以在这里了解更多关于配置<a class="ae jd" href="https://jestjs.io/docs/en/next/configuration" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="a0b0" class="mw lq jg bd lr mx my dn lv mz na dp lz lm nb nc md ln nd ne mh lo nf ng ml nh bi translated">测试套件</h2><p id="96f2" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">测试套件将相关测试分组在一起。它们是使用<code class="fe ms mt mu mv b">describe </code>功能创建的。<code class="fe ms mt mu mv b">describe</code>接受字符串名称/描述和函数作为参数:<code class="fe ms mt mu mv b">describe(name, fn)</code>。</p><h2 id="f38b" class="mw lq jg bd lr mx my dn lv mz na dp lz lm nb nc md ln nd ne mh lo nf ng ml nh bi translated">测试用例</h2><p id="9cd7" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">测试用例是由测试套件分组的实际测试。它们是使用<code class="fe ms mt mu mv b">test</code>方法编写的，该方法接受名称、函数和可选超时:<code class="fe ms mt mu mv b">test(name, fn, timeout)</code>。</p><p id="30d5" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">例如，您可以写道:</p><pre class="ni nj nk nl gt nm mv nn no aw np bi"><span id="92a2" class="mw lq jg mv b gy nq nr l ns nt">const isTruthy = true;</span><span id="1b30" class="mw lq jg mv b gy nu nr l ns nt">describe('isTruthy variable', () =&gt; {<br/>  test('is true', () =&gt; {<br/>    expect(isTruthy).toBe(true);<br/>  });<br/>  <br/>  test('is not false', () =&gt; {<br/>    expect(isTruthy).not.toBe(false);<br/>  })<br/>})</span></pre></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="8aed" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">火柴人</h1><p id="11d7" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">上面的<code class="fe ms mt mu mv b">.toBe()</code>叫做匹配器——这就是我们前面提到的东西，其中的React Testing Library也通过Jest-Dom提供了一些。可用的匹配器有很长的列表，从验证真与假(如<code class="fe ms mt mu mv b">.toBeNull()</code>和<code class="fe ms mt mu mv b">.toBeDefined()</code>)到验证数字量(如<code class="fe ms mt mu mv b">.toBeGreaterThan()</code>和<code class="fe ms mt mu mv b">.toBeCloseTo()</code>),到用于字符串匹配的<code class="fe ms mt mu mv b">.toMatch()</code>、用于数组的<code class="fe ms mt mu mv b">.toContain()</code>和用于错误处理的<code class="fe ms mt mu mv b">.toThrow()</code>。</p><p id="b165" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">您可以在这里找到Jest <a class="ae jd" href="https://jestjs.io/docs/en/expect" rel="noopener ugc nofollow" target="_blank">提供的媒人完整列表，在这里</a>找到Jest-Dom <a class="ae jd" href="https://github.com/testing-library/jest-dom#custom-matchers" rel="noopener ugc nofollow" target="_blank">提供的媒人完整列表。</a></p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h1 id="2885" class="lp lq jg bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">异步测试</h1><p id="9052" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">像React测试库一样，Jest为JavaScript中异步运行的代码提供测试。具体来说，您可以测试回调、承诺和异步/等待。</p><h2 id="0046" class="mw lq jg bd lr mx my dn lv mz na dp lz lm nb nc md ln nd ne mh lo nf ng ml nh bi translated">复试</h2><p id="7264" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">可以通过简单地将<code class="fe ms mt mu mv b">done</code>参数传递给测试函数来测试回调，而不是传递一个空参数。使用上面的例子，它看起来像这样:</p><pre class="ni nj nk nl gt nm mv nn no aw np bi"><span id="3c10" class="mw lq jg mv b gy nq nr l ns nt">const isTruthy = true;</span><span id="88ab" class="mw lq jg mv b gy nu nr l ns nt">describe('isTruthy variable', done =&gt; {<br/>  test('is true', () =&gt; {<br/>    expect(isTruthy).toBe(true);<br/>  });<br/>  <br/>  test('is not false', done =&gt; {<br/>    expect(isTruthy).not.toBe(false);<br/>  })<br/>})</span></pre><p id="8f17" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">现在这是没有用的，因为我们在这里没有使用<code class="fe ms mt mu mv b">done</code>，但这就是它看起来的样子。我将借用文档中的例子，因为没有更好的方法来解释它。下面是一个例子，其中<code class="fe ms mt mu mv b">fetchData() </code>调用一个回调函数<code class="fe ms mt mu mv b">callback()</code>，期望数据等于“花生酱”。你的第一反应可能是这样测试它:</p><pre class="ni nj nk nl gt nm mv nn no aw np bi"><span id="299f" class="mw lq jg mv b gy nq nr l ns nt">test('the data is peanut butter', () =&gt; {<br/>  <strong class="mv jh">function</strong> <strong class="mv jh">callback</strong>(data) {<br/>    expect(data).toBe('peanut butter');<br/>  }</span><span id="2476" class="mw lq jg mv b gy nu nr l ns nt">  fetchData(callback);<br/>});</span></pre><p id="8232" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">但是这个不行。这就是你可以使用<code class="fe ms mt mu mv b">done()</code>回调的地方。Jest知道要等到<code class="fe ms mt mu mv b">done()</code>完成后才能完成测试。</p><pre class="ni nj nk nl gt nm mv nn no aw np bi"><span id="3d50" class="mw lq jg mv b gy nq nr l ns nt">test('the data is peanut butter', done =&gt; {<br/>  <strong class="mv jh">function</strong> <strong class="mv jh">callback</strong>(data) {     <br/>    <strong class="mv jh">try</strong> {       <br/>      expect(data).toBe('peanut butter');       <br/>      done();     <br/>    } <strong class="mv jh">catch</strong> (error) {       <br/>      done(error);     <br/>    }<br/>  }   <br/>  <br/>  fetchData(callback);<br/>});</span></pre><h2 id="5fd7" class="mw lq jg bd lr mx my dn lv mz na dp lz lm nb nc md ln nd ne mh lo nf ng ml nh bi translated">承诺</h2><p id="6d96" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">只要您的测试返回一个承诺，Jest就会知道在完成测试之前等待承诺解决。如果承诺被拒绝，测试就会失败。上面的例子是用promise写成的，看起来像这样:</p><pre class="ni nj nk nl gt nm mv nn no aw np bi"><span id="62ad" class="mw lq jg mv b gy nq nr l ns nt">test('the data is peanut butter', () =&gt; {   <br/>  <strong class="mv jh">return</strong> fetchData().then(data =&gt; {    <br/>    expect(data).toBe('peanut butter');   <br/>  }); <br/>});</span></pre><h2 id="eaf1" class="mw lq jg bd lr mx my dn lv mz na dp lz lm nb nc md ln nd ne mh lo nf ng ml nh bi translated">异步/等待</h2><p id="7a9f" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">只要<code class="fe ms mt mu mv b">async</code>在函数之前，就可以在测试中使用<code class="fe ms mt mu mv b">try</code> / <code class="fe ms mt mu mv b">catch</code>和/或<code class="fe ms mt mu mv b">await</code>。与promises实现一样，这个实现与您在代码中实际使用async/await的方式非常相似。“花生酱”的例子应该是这样的:</p><pre class="ni nj nk nl gt nm mv nn no aw np bi"><span id="11bc" class="mw lq jg mv b gy nq nr l ns nt">test('the data is peanut butter', <strong class="mv jh">async</strong> () =&gt; {   <br/>  <strong class="mv jh">const</strong> data = <strong class="mv jh">await</strong> fetchData();   <br/>  expect(data).toBe('peanut butter'); <br/>});  </span><span id="3c11" class="mw lq jg mv b gy nu nr l ns nt">test('the fetch fails with an error', <strong class="mv jh">async</strong> () =&gt; {  <br/>  expect.assertions(1); </span><span id="a5ee" class="mw lq jg mv b gy nu nr l ns nt">  <strong class="mv jh">try</strong> {     <br/>    <strong class="mv jh">await</strong> fetchData();   <br/>  } <strong class="mv jh">catch</strong> (e) {         <br/>    expect(e).toMatch('error');   <br/>  } <br/>});</span></pre><h1 id="3110" class="lp lq jg bd lr ls nv lu lv lw nw ly lz ma nx mc md me ny mg mh mi nz mk ml mm bi translated">附加功能</h1><p id="4da4" class="pw-post-body-paragraph kn ko jg kq b kr mn kt ku kv mo kx ky lm mp lb lc ln mq lf lg lo mr lj lk ll ij bi translated">我们将关注上面描述的测试——创建包含使用匹配器测试值的测试用例的测试套件。在以后的文章中，在介绍完Cypress之后，我们将讨论如何在这些测试中使用React测试库来测试DOM节点。尽管我们不会全面介绍Jest，但我想指出Jest提供的一些额外功能。</p><h2 id="54a8" class="mw lq jg bd lr mx my dn lv mz na dp lz lm nb nc md ln nd ne mh lo nf ng ml nh bi translated">快照</h2><blockquote class="kk kl km"><p id="c1db" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一个典型的移动应用程序快照测试用例呈现一个UI组件，获取一个快照，然后将其与测试中存储的参考快照文件进行比较。如果两个快照不匹配，测试将失败:要么是意外的更改，要么是引用快照需要更新到UI组件的新版本。</p></blockquote><p id="3adc" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">以上来自Jest文档。正如它所描述的那样，快照用于测试UI没有发生意外的变化。在React中，这通常涉及到创建和存储React树的序列化版本的快照，然后可以与该树的未来序列化版本进行比较。</p><p id="3cef" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">你可以在这里了解更多关于快照测试<a class="ae jd" href="https://jestjs.io/docs/en/snapshot-testing" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><h2 id="077d" class="mw lq jg bd lr mx my dn lv mz na dp lz lm nb nc md ln nd ne mh lo nf ng ml nh bi translated">安装和拆卸</h2><blockquote class="kk kl km"><p id="4aa5" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">通常，在编写测试时，您有一些设置工作需要在测试运行之前进行，您还有一些完成工作需要在测试运行之后进行。Jest提供了帮助函数来处理这个问题。</p></blockquote><p id="5371" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">Jest提供了一组函数来处理测试运行所需的操作，例如创建测试数据和清除测试数据。</p><p id="4b5b" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">您可以在这里了解更多关于设置和拆卸测试<a class="ae jd" href="https://jestjs.io/docs/en/setup-teardown" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="3a03" class="mw lq jg bd lr mx my dn lv mz na dp lz lm nb nc md ln nd ne mh lo nf ng ml nh bi translated">嘲弄的</h2><blockquote class="kk kl km"><p id="4d31" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">模拟函数允许您通过擦除函数的实际实现、捕获对函数的调用(以及在这些调用中传递的参数)、在用<code class="fe ms mt mu mv b">new</code>实例化时捕获构造函数的实例以及允许在测试时配置返回值来测试代码之间的链接。</p></blockquote><p id="500b" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">在Jest中，您可以模拟返回值、函数实现或整个模块，例如Axios。嘲笑的核心是在更大的范围内隔离不同的元素，并测试它们。</p><p id="8712" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">您可以在这里了解更多关于嘲笑<a class="ae jd" href="https://jestjs.io/docs/en/mock-functions" rel="noopener ugc nofollow" target="_blank">的信息。</a></p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><p id="c639" class="pw-post-body-paragraph kn ko jg kq b kr ks kt ku kv kw kx ky lm la lb lc ln le lf lg lo li lj lk ll ij bi translated">接下来，我们将介绍一种不同类型的测试——使用Cypress进行端到端测试。在那之后，我们将回到Jest和React Testing Library，通过编写并使用这三种工具实现真实世界的测试。</p></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><blockquote class="kk kl km"><p id="b014" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="kq jh">先前的</strong> : <a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-2-react-testing-library-f32432b93c6c" rel="noopener">反应中测试，第2部分:反应测试库</a></p><p id="732c" class="kn ko kp kq b kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="kq jh">下一步</strong> : <a class="ae jd" href="https://medium.com/javascript-in-plain-english/testing-in-react-part-4-enzyme-9b030ad616ae" rel="noopener">反应中检测，第4部分:酶</a></p></blockquote></div><div class="ab cl kd ke hu kf" role="separator"><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki kj"/><span class="kg bw bk kh ki"/></div><div class="ij ik il im in"><h2 id="3723" class="mw lq jg bd lr mx my dn lv mz na dp lz lm nb nc md ln nd ne mh lo nf ng ml nh bi translated">资源</h2><ul class=""><li id="b90f" class="oa ob jg kq b kr mn kv mo lm oc ln od lo oe ll of og oh oi bi translated"><a class="ae jd" href="https://jestjs.io/docs/en/getting-started" rel="noopener ugc nofollow" target="_blank">玩笑官方文件</a></li><li id="5f66" class="oa ob jg kq b kr oj kv ok lm ol ln om lo on ll of og oh oi bi translated"><a class="ae jd" href="https://github.com/testing-library/jest-dom" rel="noopener ugc nofollow" target="_blank"> Jest-Dom官方文件</a></li></ul></div></div>    
</body>
</html>