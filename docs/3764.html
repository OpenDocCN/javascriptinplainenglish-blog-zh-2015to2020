<html>
<head>
<title>Advanced Reactivity: combining and chaining observables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高级反应性:结合和链接可观测量</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/chaining-svelte-js-stores-df781a1fb1b?source=collection_archive---------4-----------------------#2020-10-23">https://javascript.plainenglish.io/chaining-svelte-js-stores-df781a1fb1b?source=collection_archive---------4-----------------------#2020-10-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9fce59d4daa038c83cada34e842c0e04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vpSWhily4GMSpsNj"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@maxvdo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Max van den Oetelaar</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d61d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的<a class="ae jz" href="https://medium.com/@mikael.castellani/choosing-svelte-js-for-production-abc1d3d1ef7c" rel="noopener">上一篇文章</a>中，我解释了我们为我们的制作网站推进Svelte.js的决定。在本文中，我将深入探讨我们必须为应用程序构建的技术细节:连锁商店。Svelte的开发者体验是围绕反应式商店构建的:在UI中使用动态值的可观察模式。这意味着一旦值发生变化，依赖于它的UI就会更新以反映DOM中的新值。</p><p id="918f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我所说的连锁商店是指需要第一家商店的价值才能存在的商店。例如，第一个存储定义用户id，第二个存储需要指向用户的某些属性。如果用户id改变，我们需要更新第二个商店。</p><p id="3250" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将首先提醒svelte.js中存在的模式:商店和衍生商店，然后深入研究一个现实生活中的连锁商店的例子。</p><p id="3231" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然我关注的是苗条商店，一个简单的<a class="ae jz" href="https://svelte.dev/docs#svelte_store" rel="noopener ugc nofollow" target="_blank"/><a class="ae jz" href="https://github.com/sveltejs/svelte/blob/master/src/runtime/store/index.ts" rel="noopener ugc nofollow" target="_blank">observables的实现</a>，但是这些概念可以很容易地转换成适合其他实现。</p><h1 id="1126" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Svelte.js的商店</h1><p id="c13e" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Svelte.js中的一个store基本上就是一个实现<a class="ae jz" href="https://github.com/tc39/proposal-observable" rel="noopener ugc nofollow" target="_blank">可观察接口</a>的对象:有一个subscribe方法，懒于求值，订阅时返回一个unsubscribe方法。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ca"><img src="../Images/09c6eafd4386c35aa205f38af0b6aebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPwWCG9AJZHB-W3kBUmr9g.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Store example code, from Svelte’s own documentation</figcaption></figure><p id="1dae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当在UI组件中使用存储时，svelte开发人员体验的美妙之处就显现出来了，对存储的订阅和取消订阅由编译器处理:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/6c6333faa5f887a46d2a71f8f3a2b933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w4Hpte6GTu_3hAL_LYXW0A.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Using stores in components, with subscription and unsubscription handled automatically</figcaption></figure><p id="0eb0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意我们导入的变量前面的' $ '字符:这是让编译器知道我们正在使用存储的技巧，当组件被安装和卸载时，它将处理订阅/取消订阅。就凭这一点，你就可以像使用一个变量一样使用存储！(只要你在<a class="ae jz" href="https://svelte.dev/tutorial/reactive-declarations" rel="noopener ugc nofollow" target="_blank">一个“反应性声明”里面使用它，在教程</a>里会有更多的说明)。我发现这是一个很棒的开发者体验Svelte.js就是这么回事。</p><p id="07ce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在这个https://svelte.dev/repl/1d1d4f0beb4240848fa04be97ffbdf6c? REPL<a class="ae jz" href="https://svelte.dev/repl/1d1d4f0beb4240848fa04be97ffbdf6c?version=3.29.4" rel="noopener ugc nofollow" target="_blank">里玩这个代码版本=3.29.4 </a></p><h1 id="83c8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">衍生商店</h1><p id="3206" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">一个常见的模式也是导出数据。就像上面提供的例子一样，您有时需要原始值，有时需要格式化值。派生存储是分解转换代码的简单方法。派生存储还允许将多个值合并为一个值。例如，在这个例子中，我是如何从正在填写的表单的值中创建“progressStore”的:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/0d0d83246ac82953a41afb2dfb20833c.png" data-original-src="https://miro.medium.com/v2/resize:fit:716/1*zoalBXahLovrVOS2hzaOnA.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Using a derived store to implement progress</figcaption></figure><p id="96fd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个进度存储的代码非常简单:</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/94b994ced1f980480aeda54242252ac4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4Yyekf4SoRSkCd-QwMWoA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Code of the progress store for checkboxes</figcaption></figure><p id="f6e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">提醒一下，当且仅当:</p><ul class=""><li id="e041" class="mi mj in kc b kd ke kh ki kl mk kp ml kt mm kx mn mo mp mq bi translated">商店至少有一个订户。</li><li id="a109" class="mi mj in kc b kd mr kh ms kl mt kp mu kt mv kx mn mo mp mq bi translated">原始存储中的一个值发生了变化。</li></ul><p id="e6d7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">性能问题到此为止！我们的代码只有在用户屏幕上显示进度条时才会运行。</p><p id="eb3c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://svelte.dev/repl/ea03956ee4374c8cbe078dcaed40d5bf?version=3.29.4" rel="noopener ugc nofollow" target="_blank">https://svelte.dev/repl/ea03956ee4374c8cbe078dcaed40d5bf?这里是REPL版本=3.29.4 </a></p><h1 id="1228" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">当这还不够时</h1><p id="e1ee" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">Svelte.js提供的可写、可读和派生的存储提供了很大的灵活性。当创建它们时，通过它们简单的初始化和取消订阅接口，以及异步处理，您将能够将许多不同的数据源无缝地插入到您的应用程序中。例如，一个web套接字、一个轮询机制、一个定制的或开源的库……所有这些都将作为一个商店向您的应用程序公开，并与其余的很好地集成。</p><p id="3fb0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，我们仍然很快遇到了一个不容易处理的用例，这也是本文的中心。</p><p id="73b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我在以前的文章中提到的，<a class="ae jz" href="https://strollyn.com" rel="noopener ugc nofollow" target="_blank">https://strollyn.com</a>使用Google Firebase作为后台，以及主机。Cloud Firestore，即数据库，是一个无sql、面向文档的数据库。因此，我们选择对数据模型进行反规范化，结果如下所示，一个用户可以拥有几个家庭:</p><pre class="mb mc md me gt mw mx my mz aw na bi"><span id="c186" class="nb kz in mx b gy nc nd l ne nf">{<br/>  "user": {<br/>    "user1-id": {<br/>      "uid": "user1-id",<br/>      "homes": [<br/>        {"homeid": “home1-id”},<br/>        {“homeid”: “home2-id”}<br/>      ]<br/>    }<br/>  },<br/>  "home": {<br/>    "home1-id": {<br/>      "homeid": "home1-id",<br/>      "type": "apartment",<br/>      "pictures": [...]<br/>     }<br/>    },<br/>    "home2-id": {<br/>      "homeid": "home2-id",<br/>      "type": "villa",<br/>      "pictures": [...]<br/>    }<br/>  }<br/>}</span></pre><p id="3830" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当用户第一次登录时，我们得到他的uid。为了获得他的home并将其公开为一个商店，我们必须首先查看用户文档的内容以获得homeid，然后订阅适当的home文档。换句话说，我们必须等到uid已知后才能创建主存储。这就是<code class="fe ng nh ni mx b">derived</code>方法的不足之处:它只能用于声明时已经存在的存储。</p><h1 id="3831" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">进入连锁商店</h1><p id="bec6" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">有几种方法可以解决这个问题，但是我们选择了一种方法，这种方法尊重链接函数调用的函数方式。我们把它命名为<code class="fe ng nh ni mx b">chainReadableStore</code>，这就是它的用法。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nj"><img src="../Images/80519cddc4026bc2e2bb30055fd27711.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HAd3q2opLO0CJvetFYtK9w.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The uidStore, getting its value from the Firebase SDK</figcaption></figure><p id="1657" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，让我们创建我们的uidStore，它在用户登录时被填充。</p><p id="b890" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">值得注意的主要事情是，一旦用户对象可用，就调用第7行的<code class="fe ng nh ni mx b">set(user.uid)</code>。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nk"><img src="../Images/5feba0f13666b9053f89a5430c093cec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zXaw7N1sxsDH2cK3pgnSaQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The homeidStore, chained from the uidStore</figcaption></figure><p id="2924" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我们希望创建一个返回第一个家的homeid的存储，但是只有在uid已知的情况下！</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nl"><img src="../Images/4d9b72a794302b2b32b6ea93f1c524e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Pejwugg1NDhwLFk4EL2hA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The homeStore is chained from the previously chained homeidStore</figcaption></figure><p id="d507" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们希望再次链接该值，以便在其余部分可用时尽快获得主文档！</p><p id="8155" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在UI端，所有的复杂性都被隐藏了。商店可以像教程开始时一样使用，例如显示一个家的图片，我们可以无缝地“等待”来自服务器的信息。</p><h2 id="78f8" class="nb kz in bd la nm nn dn le no np dp li kl nq nr lm kp ns nt lq kt nu nv lu nw bi translated">chainReadableStore</h2><figure class="mb mc md me gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nx"><img src="../Images/a2a64e2de201eb69d1e5cd0f7ba3b6d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6mN2Tx-R0nLzmU9Abq2Itw.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">The code of the `chainReadableStore` function</figcaption></figure><p id="5287" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">评论:</p><ul class=""><li id="54c7" class="mi mj in kc b kd ke kh ki kl mk kp ml kt mm kx mn mo mp mq bi translated">此函数创建一个订阅初始存储的可读存储</li><li id="4c6e" class="mi mj in kc b kd mr kh ms kl mt kp mu kt mv kx mn mo mp mq bi translated">当初始存储值不同于<code class="fe ng nh ni mx b">undefined</code>时，它将调用回调函数来创建链式存储，这是短暂的。</li><li id="366e" class="mi mj in kc b kd mr kh ms kl mt kp mu kt mv kx mn mo mp mq bi translated">当初始存储的值改变时，它将取消订阅(并因此销毁)临时链接的存储，然后使用新值创建一个新的存储。</li><li id="2bbb" class="mi mj in kc b kd mr kh ms kl mt kp mu kt mv kx mn mo mp mq bi translated">当存储不再有订阅者时，它将销毁其订阅以及临时链接的存储。</li></ul><p id="3253" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在前面的用户和家庭示例中，chaining函数用于创建2个新商店。当uid第一次被知道时，它允许获取homeid(虽然不是马上，但是在一些隐藏的服务器请求之后)。一旦知道了homeid，我们就知道从哪里获取home文档。因为瘦存储仅在值实际改变时通知订户(如果有疑问，请参见<a class="ae jz" href="https://svelte.dev/repl/5903fbd16da740c49f75a24c236e5760?version=3.29.4" rel="noopener ugc nofollow" target="_blank">这个REPL </a>)，我们的函数仅在需要时运行:当uid或homeid改变时，并且仅当最终存储的订阅存在时。</p><h1 id="47cf" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结果呢</h1><p id="bb13" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">多亏了连锁商店，我们有了一种非常简单灵活的方式来定义依赖关系。在处理应用程序的加载时，它可以提供很大的帮助。在代码的UI端，由于store API，它集成得非常好。</p><figure class="mb mc md me gt jo gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/51a096976fbe1bf245d414b1e2a008d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/1*l_df_auZJFAHqxia72w1kw.gif"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Progressive loading of the application, with chained stores</figcaption></figure><p id="1777" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在REPL 的<a class="ae jz" href="https://svelte.dev/repl/fbec6544d9fa450aad501de11f81195a?version=3.29.4" rel="noopener ugc nofollow" target="_blank">里摆弄它。</a></p><h1 id="78d0" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">一句警告</h1><p id="56e2" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">尽管苗条的商店使事情变得相当安全(懒惰评估，<a class="ae jz" href="https://svelte.dev/repl/5903fbd16da740c49f75a24c236e5760?version=3.29.4" rel="noopener ugc nofollow" target="_blank">仅在值实际改变时通知</a>)，请记住，连锁店意味着每次初始商店有新值时，取消/订阅的循环。在一行中有几个链接的情况下，它可以创建许多操作。我发现它特别适合应用程序初始化，但需要给出一个警告:不要在热代码路径中使用它，或者用于定期更改值的存储。当商店之间没有依赖关系时，坚持使用衍生商店。</p></div></div>    
</body>
</html>