<html>
<head>
<title>JavaScript and the Fetch API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript和获取API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-and-the-fetch-api-98fdad173b85?source=collection_archive---------7-----------------------#2020-09-21">https://javascript.plainenglish.io/javascript-and-the-fetch-api-98fdad173b85?source=collection_archive---------7-----------------------#2020-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="0ada" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最近我一直在学习JavaScript和React，我不得不使用<a class="ae kl" href="https://fetch.spec.whatwg.org/" rel="noopener ugc nofollow" target="_blank">获取API </a>。我意识到我并没有很好地理解我正在使用的工具，并决定我需要挖掘得更深一点。在<a class="ae kl" href="https://medium.com/@reginafurness/javascript-promises-c89572ea034f" rel="noopener">我之前的博文</a>中，我回顾了<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank">承诺</a>，它们是Fetch API的基本构件。在我解释Fetch API的时候，我假设你已经很好地理解了承诺。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="kr ks l"/></div></figure><h1 id="a3e8" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是Fetch API？</h1><p id="e242" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">来自<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#:~:text=The%20Fetch%20API%20provides%20a,resources%20asynchronously%20across%20the%20network." rel="noopener ugc nofollow" target="_blank"> MDN </a>:</p><blockquote class="lw lx ly"><p id="1ade" class="jn jo lz jp b jq jr js jt ju jv jw jx ma jz ka kb mb kd ke kf mc kh ki kj kk ij bi translated"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> Fetch API </a>提供了一个JavaScript接口，用于访问和操作HTTP管道的各个部分，比如请求和响应。它还提供了一个全局的<code class="fe md me mf mg b"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch" rel="noopener ugc nofollow" target="_blank">fetch()</a></code>方法，该方法提供了一种简单、逻辑的方式来通过网络异步获取资源</p></blockquote><p id="b8a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">简而言之，Fetch API为我们提供了一个干净的接口，用于发送HTTP请求和接收它们的后续响应。<code class="fe md me mf mg b">.fetch()</code>是它提供的发出这些请求的方法。关于<code class="fe md me mf mg b">.fetch()</code>的几件事:</p><ul class=""><li id="2ae0" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated">它返回一个承诺，该承诺解析为一个<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Response" rel="noopener ugc nofollow" target="_blank">响应</a>对象。</li><li id="345d" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">它需要至少一个参数，要么是我们获取的资源的URL，要么是一个<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request" rel="noopener ugc nofollow" target="_blank">请求</a>对象。</li><li id="dd94" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">当给定一个URL作为第一个参数时，还可以提供可选参数的第二个参数。比如<a class="ae kl" href="https://pokeapi.co/api/v2/pokemon/1" rel="noopener ugc nofollow" target="_blank"> HTTP方法</a>，头或者体。</li></ul><p id="80ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:<code class="fe md me mf mg b">.fetch()</code>的URL和可选参数与给请求构造函数的参数完全相同。这就是为什么我们可以给<code class="fe md me mf mg b">.fetch() </code>一个请求对象作为参数。</p><h1 id="23c8" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">响应对象</h1><p id="bf1a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">响应对象有一些属性，包括<code class="fe md me mf mg b">Response.ok</code>，它返回一个布尔值，指示响应是否成功。以及返回响应的<a class="ae kl" href="https://www.restapitutorial.com/httpstatuscodes.html" rel="noopener ugc nofollow" target="_blank">状态码</a>的<code class="fe md me mf mg b">Response.status</code>。您可以在这里找到响应对象属性的完整列表<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Response" rel="noopener ugc nofollow" target="_blank">，但是对于这个博客来说，响应的状态/状态代码是最重要的。这是因为从<code class="fe md me mf mg b">.fetch()</code>返回的承诺不会以HTTP错误状态拒绝。这意味着即使响应的状态为404，它也不会触发<code class="fe md me mf mg b">.catch()</code>或拒绝回调。</a></p><p id="e5dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回应也伴随着身体。您可以将正文视为响应中返回的内容。响应体附带了一些解析内容的方法。每个方法都返回一个解析为相应格式的承诺。这些方法是:</p><ul class=""><li id="6ed3" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><code class="fe md me mf mg b">Body.json()</code></li><li id="4c17" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe md me mf mg b">Body.text()</code></li><li id="2a89" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe md me mf mg b">Body.formData()</code></li><li id="a559" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe md me mf mg b">Body.arrayBuffer()</code></li><li id="740c" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe md me mf mg b">Body.blob()</code></li></ul><p id="cd86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们知道了如何访问和解析在响应对象中接收的数据。我们需要想出如何发出请求。</p><h1 id="6e56" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">发送请求</h1><p id="508b" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">发出获取请求的最简单方法是只提供一个URL。</p><pre class="km kn ko kp gt mv mg mw mx aw my bi"><span id="9ce5" class="mz ku iq mg b gy na nb l nc nd">fetch('<a class="ae kl" href="https://pokeapi.co/api/v2/pokemon/1" rel="noopener ugc nofollow" target="_blank">https://pokeapi.co/api/v2/pokemon/1</a>')</span></pre><p id="ccf8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为<code class="fe md me mf mg b">.fetch()</code>带有默认参数，这相当于向<a class="ae kl" href="https://pokeapi.co/api/v2/pokemon/1" rel="noopener ugc nofollow" target="_blank">https://pokeapi.co/api/v2/pokemon/1</a>发送一个<code class="fe md me mf mg b">GET</code>请求。让我们看看写出默认参数后的fetch请求是什么样子的:</p><pre class="km kn ko kp gt mv mg mw mx aw my bi"><span id="2e95" class="mz ku iq mg b gy na nb l nc nd">//note: you can write this inline<br/>let options = <!-- -->{<br/>    method: 'GET',<br/>    mode: 'cors',<br/>    cache: 'default',<br/>    credentials: 'same-origin',<br/>    headers: {<br/>      'Content-Type': 'application/json'<br/>   },<br/>    redirect: 'follow',<br/>    referrerPolicy: 'no-referrer'<br/>}</span><span id="4f43" class="mz ku iq mg b gy ne nb l nc nd">fetch('<a class="ae kl" href="https://pokeapi.co/api/v2/pokemon/1" rel="noopener ugc nofollow" target="_blank">https://pokeapi.co/api/v2/pokemon/1</a>', options)</span></pre><p id="e8a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到<code class="fe md me mf mg b">.fetch()</code>的简单可以掩饰很多幕后发生的事情。让我们花点时间来分解这些可选参数。</p><h2 id="d2d9" class="mz ku iq bd kv nf ng dn kz nh ni dp ld jy nj nk lh kc nl nm ll kg nn no lp np bi translated">方法</h2><p id="0e30" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><code class="fe md me mf mg b">method</code>是请求的HTTP方法。你可以在这里阅读HTTP请求方法<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="8f69" class="mz ku iq bd kv nf ng dn kz nh ni dp ld jy nj nk lh kc nl nm ll kg nn no lp np bi translated">方式</h2><p id="ea35" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><code class="fe md me mf mg b">mode</code>用于确定跨来源响应是否有效，以及响应的哪些方面是可读的。为了更好地理解这个话题，你可能需要阅读一下跨来源资源共享(<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>)。模式选项包括:</p><ul class=""><li id="c989" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><code class="fe md me mf mg b">same-origin</code>不允许外部来源的请求。</li><li id="19ab" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe md me mf mg b">no-cors</code>限于<code class="fe md me mf mg b">HEAD</code>、<code class="fe md me mf mg b">GET</code>或<code class="fe md me mf mg b">POST</code>。将集管限制为<code class="fe md me mf mg b">Accept</code>、<code class="fe md me mf mg b">Accept-Language</code>、<code class="fe md me mf mg b">Content-Language</code>和<code class="fe md me mf mg b">Content-Type</code>。无法使用JavaScript访问响应。</li><li id="9231" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe md me mf mg b">cors</code>允许跨来源请求，且正文可读。</li></ul><h2 id="423b" class="mz ku iq bd kv nf ng dn kz nh ni dp ld jy nj nk lh kc nl nm ll kg nn no lp np bi translated">隐藏物</h2><p id="bf08" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><code class="fe md me mf mg b">cache </code>确定请求与浏览器缓存的交互方式。如果您想了解更多，我建议您阅读<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/Request/cache" rel="noopener ugc nofollow" target="_blank"> MDN文档</a>。请求的这个属性在模式上有很多微妙的不同。</p><h2 id="2f25" class="mz ku iq bd kv nf ng dn kz nh ni dp ld jy nj nk lh kc nl nm ll kg nn no lp np bi translated">资格证书</h2><p id="bfec" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><code class="fe md me mf mg b">credentials</code>确定请求将如何处理cookies。不同的选项有:</p><ul class=""><li id="34a6" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><code class="fe md me mf mg b">omit</code>不要发送或接收饼干。</li><li id="3f7c" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe md me mf mg b">same-origin</code>如果请求是针对同一来源的网址，则包括cookies。</li><li id="cc1f" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe md me mf mg b">include</code>包括cookies，即使是跨来源请求。</li></ul><h2 id="72d7" class="mz ku iq bd kv nf ng dn kz nh ni dp ld jy nj nk lh kc nl nm ll kg nn no lp np bi translated">再直接的</h2><p id="b225" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><code class="fe md me mf mg b">redirect</code>顾名思义，决定您的请求如何处理重定向。三种不同的方案是:</p><ul class=""><li id="d18e" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><code class="fe md me mf mg b">follow</code>您的请求将遵循重定向。</li><li id="2f18" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe md me mf mg b">error</code>重定向时会返回错误。</li><li id="ecd9" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe md me mf mg b">manual</code>返回重定向的网址，响应的重定向属性为真。如其所示，允许您手动处理重定向。</li></ul><h2 id="4cff" class="mz ku iq bd kv nf ng dn kz nh ni dp ld jy nj nk lh kc nl nm ll kg nn no lp np bi translated">referenrerpolicy</h2><p id="ddfb" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated"><code class="fe md me mf mg b">referrerPolicy</code> / <code class="fe md me mf mg b">referrer </code>将决定您的请求如何处理它的“引用者”头。这通常设置为发出请求的URL。它可以更改为空字符串(<code class="fe md me mf mg b">''</code>)或当前来源中的另一个URL。您可以在这里更多的了解这个<a class="ae kl" href="https://javascript.info/fetch-api#referrer-referrerpolicy" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="6393" class="mz ku iq bd kv nf ng dn kz nh ni dp ld jy nj nk lh kc nl nm ll kg nn no lp np bi translated">头球</h2><p id="1d82" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">最后但同样重要的是<code class="fe md me mf mg b">headers</code>。类似于响应和请求，有一个带有构造函数的Headers对象。如果需要，您可以提供自己唯一的标题。您也可以在这里设置几个重要的标题。例如:</p><ul class=""><li id="287f" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><code class="fe md me mf mg b">content-type</code>用于指示响应体中内容的类型。因此，如果你正在发送JSON，你可以将其设置为<code class="fe md me mf mg b">content-type: 'application/json'.</code></li><li id="54b9" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe md me mf mg b">accepts</code>解释客户端将接受哪种内容类型。</li><li id="eac1" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe md me mf mg b">Authorization</code>应该包含授权用户的凭证。</li></ul><p id="af8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以在这里了解更多类型的标题。</p><h2 id="4ffa" class="mz ku iq bd kv nf ng dn kz nh ni dp ld jy nj nk lh kc nl nm ll kg nn no lp np bi translated">请求正文</h2><p id="96f3" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">所以我们查看了一个<code class="fe md me mf mg b">GET </code>请求，但是如果我们正在发出一个<code class="fe md me mf mg b">POST</code>、<code class="fe md me mf mg b">PATCH</code>或<code class="fe md me mf mg b">PUT</code>请求呢？这就是请求体出现的地方。您使用请求主体通过请求发送内容/数据，类似于使用主体从响应接收内容/数据。通过身体，我们能够发送:</p><ul class=""><li id="e681" class="mh mi iq jp b jq jr ju jv jy mj kc mk kg ml kk mm mn mo mp bi translated"><code class="fe md me mf mg b">formData</code> —用于发送文件。</li><li id="ea3a" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe md me mf mg b">Blob</code> —用于发送二进制数据。</li><li id="ff38" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated">一根绳子</li><li id="faed" class="mh mi iq jp b jq mq ju mr jy ms kc mt kg mu kk mm mn mo mp bi translated"><code class="fe md me mf mg b"><a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" rel="noopener ugc nofollow" target="_blank">URLSearchParams</a></code></li></ul><p id="9481" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">值得注意的是，字符串、<code class="fe md me mf mg b">formData</code>和<code class="fe md me mf mg b">Blob</code>会自动设置<code class="fe md me mf mg b">content-type</code>头。当发送JSON时，您需要首先对它进行字符串化，因为您不能通过fetch请求发送JSON。</p><h1 id="7859" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">把所有的放在一起</h1><p id="2053" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">我们已经看到了如何发出请求和处理响应。是时候把它们放在一起，实际发出一些获取请求，并解析这些请求的响应了！有两种方法来处理获取请求。我们可以使用<code class="fe md me mf mg b">await</code>或<code class="fe md me mf mg b">.then()</code>。让我们分别执行一个<code class="fe md me mf mg b">GET</code>请求。</p><h2 id="5315" class="mz ku iq bd kv nf ng dn kz nh ni dp ld jy nj nk lh kc nl nm ll kg nn no lp np bi translated">等待</h2><pre class="km kn ko kp gt mv mg mw mx aw my bi"><span id="5f56" class="mz ku iq mg b gy na nb l nc nd">let response = await fetch('<a class="ae kl" href="https://pokeapi.co/api/v2/pokemon/1'" rel="noopener ugc nofollow" target="_blank">https://pokeapi.co/api/v2/pokemon/1'</a>)</span><span id="5706" class="mz ku iq mg b gy ne nb l nc nd">response.headers.get('content-type') =&gt; "application/json; charset=utf-8"</span><span id="1f5e" class="mz ku iq mg b gy ne nb l nc nd">let pokemon = await response.json()<br/>pokemon.name =&gt; 'bulbasaur'</span></pre><p id="6e1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，我们来分析一下。首先，我们声明一个变量response，作为对<code class="fe md me mf mg b">GET 'https://pokeapi.co/api/v2/pokemon/1'</code>请求的返回值。我们知道<code class="fe md me mf mg b">.fetch()</code>请求返回一个承诺，该承诺解析为一个响应对象，该响应对象的主体包含我们请求的内容。为了访问这个主体，我们需要调用一个方法来将它解析成我们可以使用的东西。您可以看到，当我们从响应对象获得<code class="fe md me mf mg b">content-type</code>头时，它是<code class="fe md me mf mg b">application/json</code>，因此我们可以调用<code class="fe md me mf mg b">.json()</code>将主体数据转换成JSON。在那里，我可以看到解析后的JSON响应主体数据中的name属性。</p><h2 id="9283" class="mz ku iq bd kv nf ng dn kz nh ni dp ld jy nj nk lh kc nl nm ll kg nn no lp np bi translated">。然后()</h2><pre class="km kn ko kp gt mv mg mw mx aw my bi"><span id="7d3b" class="mz ku iq mg b gy na nb l nc nd">let pokemon</span><span id="39a1" class="mz ku iq mg b gy ne nb l nc nd">fetch('<a class="ae kl" href="https://pokeapi.co/api/v2/pokemon/1'" rel="noopener ugc nofollow" target="_blank">https://pokeapi.co/api/v2/pokemon/1'</a>)<br/>.then(resp =&gt; resp.json()<!-- -->)<br/>.then(json =&gt; pokemon = json)</span><span id="4e74" class="mz ku iq mg b gy ne nb l nc nd">pokemon.name =&gt; "bulbasaur"</span></pre><p id="2258" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看如何发出一个<code class="fe md me mf mg b">POST</code>请求。</p><h2 id="5984" class="mz ku iq bd kv nf ng dn kz nh ni dp ld jy nj nk lh kc nl nm ll kg nn no lp np bi translated">等待发布请求</h2><pre class="km kn ko kp gt mv mg mw mx aw my bi"><span id="119a" class="mz ku iq mg b gy na nb l nc nd">let pokemonObj = {name: 'pikachu', type: 'electric'}</span><span id="ba02" class="mz ku iq mg b gy ne nb l nc nd">let options = {<br/>  method: "POST",<br/>  <!-- -->headers: {<br/>      'Accept': 'application/json',<br/>      'Content-Type': 'application/json'<br/>    }<!-- -->,<br/>  body: JSON.stringify(pokemonObj)<br/>}</span><span id="2219" class="mz ku iq mg b gy ne nb l nc nd">let response = await fetch('http://localhost:3000/pokemon', options)<br/>let pokemon = await response.json()<br/>pokemon.name =&gt; 'pikachu'</span></pre><p id="89ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以看到我们已经包括了我们的<code class="fe md me mf mg b">method</code>，和一些<code class="fe md me mf mg b">headers</code>。因为我们发送的是字符串化的JSON，所以我们需要包含<code class="fe md me mf mg b">content-type</code>头。我还包含了<code class="fe md me mf mg b">accept</code>头文件，表明我期待JSON的回归。</p><h2 id="ef33" class="mz ku iq bd kv nf ng dn kz nh ni dp ld jy nj nk lh kc nl nm ll kg nn no lp np bi translated">。then()发布请求</h2><pre class="km kn ko kp gt mv mg mw mx aw my bi"><span id="56ae" class="mz ku iq mg b gy na nb l nc nd">let pokemon<br/>let pokemonObj = {name: 'pikachu', type: 'electric'}</span><span id="bc87" class="mz ku iq mg b gy ne nb l nc nd">let options = {<br/>  method: "POST",<br/>  <!-- -->headers: {<br/>      'Accept': 'application/json',<br/>      'Content-Type': 'application/json'<br/>    }<!-- -->,<br/>  body: JSON.stringify(pokemonObj)<br/>}</span><span id="0853" class="mz ku iq mg b gy ne nb l nc nd">fetch('http://localhost:3000/pokemon', options)<br/>.then(resp =&gt; resp.json())<br/>.then(json =&gt; pokemon = json)</span><span id="3c53" class="mz ku iq mg b gy ne nb l nc nd">pokemon.name =&gt; 'pikachu'</span></pre><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="nq ks l"/></div></figure><h1 id="4fba" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">最后的想法</h1><p id="3ecd" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Fetch API使得通过异步网络请求发送和接收数据变得非常简单。以至于一开始我没有意识到正在发生的一切。关于<code class="fe md me mf mg b">.fetch()</code>、异步JavaScript、网络请求等等，还有很多东西需要学习。然而，我觉得在深入研究之后，我可以更自信地在我的代码中使用这些工具。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/787be6c671be8d345dc786dad8729ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-sOyyG8NoRbKpCG_y4Cmw@2x.png"/></div></div><figcaption class="ny nz gj gh gi oa ob bd b be z dk"><a class="ae kl" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank">Subscribe to Decoded, our official YouTube channel!</a></figcaption></figure></div></div>    
</body>
</html>