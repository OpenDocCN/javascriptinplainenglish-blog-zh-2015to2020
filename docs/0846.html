<html>
<head>
<title>What exactly is GraphQL?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL到底是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-exactly-is-graphql-7a4fc930eae7?source=collection_archive---------6-----------------------#2019-12-20">https://javascript.plainenglish.io/what-exactly-is-graphql-7a4fc930eae7?source=collection_archive---------6-----------------------#2019-12-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/8ea7f2bf45e1697624334a1631f34327.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*RcXuFeA0FfbW17ch.png"/></div></div></figure><p id="3cfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">脸书于2012年开始开发GraphQL，并于2015年发布。从2018年开始，Linux基金会负责该项目。GraphQL的目的是为数据获取和操作提供一种查询语言。它不完全是SQL，也不是REST。它介于两者之间，允许开发人员以直观和安全的方式查询、改变和组织数据。</p><h1 id="6b94" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">替代方案:休息</h1><p id="c875" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">要理解什么是GraphQL，首先要理解什么是graph SQL<strong class="ka ir">不是</strong>。首先，这不是休息。REST代表表述性状态转移，多年来它一直是API开发的行业标准。REST允许您使用HTTP请求的子集执行客户机/服务器通信。此外，它还提供了如何组织和命名这些请求的规则和一般原理。最常见的是，JSON (JavaScript对象符号)用于发送数据。</p><p id="1b98" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，休息有什么不好呢？很多事情。一个主要原因是服务器和客户端之间没有强有力的契约协议。这意味着不能保证您将收到的数据的类型或结构。此外，不同HTTP状态代码之间的模糊性。例如，您应该因为请求成功而返回200，还是因为创建了一个项目而返回201？</p><h1 id="2eb5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">肥皂</h1><p id="9097" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">SOAP(简单对象访问协议)通常在REST之前使用。与REST不同，SOAP是一个标准化的协议，由微软开发，W3C批准。它使用XML符号来发送和接收数据。SOAP后来被扩展并应用于支持远程过程调用。它也不仅限于HTTP。SOAP消息可以通过其他协议发送，比如SMTP，也可以直接通过TCP发送。</p><p id="06c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然SOAP非常健壮，但它被批评为过于冗长和缓慢。这就是为什么开发人员转向更底层的协议，比如REST。</p><h1 id="6eae" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结构化查询语言</h1><p id="2748" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">SQL代表结构化查询语言。它主要用于数据库环境中。虽然它与API和客户机/服务器通信无关，但它非常值得注意，因为它与GraphQL有许多共同之处。</p><p id="2d58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它们都提供了合同协议和定义明确的规范。SQL和GraphQL的主要目标都是查询和操作数据。不同之处在于，SQL是为处理关系数据库而设计的，而GraphQL是为NoSQL解决方案而开发的。GraphQL还指定了双方应该如何通过网络进行通信，而SQL没有做这样的假设。</p><p id="b0c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你也可以说SQL比GraphQL有更丰富的特性。它支持对数据的更多操作，以及通常为编程语言保留的函数和其他方面。</p><h1 id="3943" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">核心概念</h1><p id="a43c" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">有了替代方案，我们可以开始研究GraphQL了。为了能够有效地使用GraphQL，理解它的一些核心概念是很重要的。</p><h2 id="8e35" class="lz kx iq bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">(计划或理论的)纲要</h2><p id="ece1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">GraphQL API的基础是一个<strong class="ka ir">模式</strong>。模式是API可以处理的所有可能数据以及这些数据的类型的定义。它通常位于服务器端，所有传入的查询首先根据模式进行验证。</p><h2 id="b1e6" class="lz kx iq bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">田</h2><p id="038f" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">正如GraphQL官方文档所说，“[GraphQL]基本上是关于选择对象上的字段”。字段是你可以从API请求的最基本的数据单元。它还必须是标量，这意味着没有关系或复杂性。</p><h2 id="3698" class="lz kx iq bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">履行</h2><p id="0ed9" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">GraphQL中的<strong class="ka ir">实现</strong>就像OOP中的继承。它允许您定义一些将在不同对象间共享的公共字段。</p><h2 id="cc9e" class="lz kx iq bd ky ma mb dn lc mc md dp lg kj me mf lk kn mg mh lo kr mi mj ls mk bi translated">关系</h2><p id="37c1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated"><strong class="ka ir">连接</strong>就是GraphQL中的图的来源。它让您可以将不同的对象相互连接起来，就像图表中的节点一样。这些连接让您可以在一次调用中查询多个对象，而在其他情况下，您可能需要多次调用。</p><h1 id="1997" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">例子</h1><p id="a812" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">现在让我们看一些GraphQL的例子。我们从定义一个类型开始。它是用SDL(模式定义语言)编写的:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/6709b32d5c018348ff5c7b922a693fc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*DfexjL-D4I7OEOgT"/></div></figure><p id="b8d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以看到它的名字是<code class="fe mq mr ms mt b">Car</code>，它有字段<code class="fe mq mr ms mt b">make</code>、<code class="fe mq mr ms mt b">year</code>和<code class="fe mq mr ms mt b">turbocharged</code>。每个字段都有特定的类型。此外，感叹号表示该字段是必填的。</p><p id="1b58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是要真正探索GraphQL的思想，我们需要引入一些关系。让我们定义另一种类型，并将它与<code class="fe mq mr ms mt b">Car</code>联系起来:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/a1c57ccfa8c590c3e39f7cccf8cb4675.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*Npi0c7gZGRMMX4aO"/></div></figure><p id="8ba1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到<code class="fe mq mr ms mt b">Car</code>现在通过<code class="fe mq mr ms mt b">owner</code>字段引用了<code class="fe mq mr ms mt b">Person</code>，并且<code class="fe mq mr ms mt b">Person</code>在<code class="fe mq mr ms mt b">cars</code>字段中保存了一个<code class="fe mq mr ms mt b">Car</code>列表。</p><h1 id="1ab5" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">问题</h1><p id="f5d1" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">为了能够查询汽车和人员，我们现在需要定义一些<code class="fe mq mr ms mt b">Queries</code>:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/722e10d76944a66235e8e8d6380a5cb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*pDM2vET38xA-CApJ"/></div></figure><p id="7a0a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以看到我们已经定义了3个查询。<code class="fe mq mr ms mt b">allCars</code>不接受任何参数，返回汽车列表。<code class="fe mq mr ms mt b">carsByMake</code>取一串，通过<code class="fe mq mr ms mt b">make</code>过滤汽车。最后，<code class="fe mq mr ms mt b">allPersons</code>将返回一个<code class="fe mq mr ms mt b">Person</code>的列表。</p><p id="ae61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以向API发送查询，并得到如下结果:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/5cb3424a470678fd554a1b0f6c63409a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*f-jakFq3HzcVavww"/></div></figure><p id="973f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将变量传递给查询:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/8d79562ee613c3f97577a595183a9cea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*ldVHlZi5Oaoa6PkS"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><em class="my">n December 20, 2019.</em></figcaption></figure><h1 id="2bed" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">突变</h1><p id="4b07" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">查询数据很好，但是我们首先还需要一种创建数据的方法。GraphQL使用<strong class="ka ir">突变</strong>来做到这一点。您可以像查询一样定义突变:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/42130113aedad92e31447e17f465c629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*mfysvoJxhqTulXHB"/></div></figure><p id="6e5d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个接受数据并创建一个<code class="fe mq mr ms mt b">Car</code>对象的变异的例子。你可以这样称呼它:</p><figure class="mm mn mo mp gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/6befdcc13cc2dbdfbe93b1d4d63295c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1360/0*6URXHqxVjaG9fwZo"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk"><em class="my">n December 20, 2019.</em></figcaption></figure><h1 id="d15d" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">履行</h1><p id="1862" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">GraphQL本身不是一个库或框架:它仅仅是一个规范。不同语言的许多库都实现了这个规范，允许您使用GraphQL支持来构建自己的API。以下是其中的一些:</p><ul class=""><li id="5df7" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated"><strong class="ka ir">JavaScipt:</strong><a class="ae ni" href="https://github.com/graphql/graphql-js/" rel="noopener ugc nofollow" target="_blank">graph QL</a>和<a class="ae ni" href="https://github.com/graphql/express-graphql" rel="noopener ugc nofollow" target="_blank"> express-graphql </a></li><li id="d946" class="mz na iq ka b kb nj kf nk kj nl kn nm kr nn kv ne nf ng nh bi translated"><strong class="ka ir">Java</strong>:<a class="ae ni" href="https://github.com/graphql-java/graphql-java" rel="noopener ugc nofollow" target="_blank">graph QL-Java</a></li><li id="156d" class="mz na iq ka b kb nj kf nk kj nl kn nm kr nn kv ne nf ng nh bi translated"><strong class="ka ir"> Python </strong> : <a class="ae ni" href="https://github.com/graphql-python/graphene" rel="noopener ugc nofollow" target="_blank">石墨烯</a></li></ul><p id="c8c6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于前端来说，<a class="ae ni" href="https://github.com/apollographql/apollo-client" rel="noopener ugc nofollow" target="_blank"> Apollo </a>库最为常见。</p><h1 id="3c63" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">利弊</h1><p id="34ec" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">那么，为什么应该使用GraphQL，为什么要避免使用它呢？以下是支持GraphQL的一些理由:</p><ul class=""><li id="f569" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated"><strong class="ka ir">强合同约定</strong> —你再也不用去猜测服务器会给你发什么样的数据了。使用GraphQL，您可以得到您想要的东西</li><li id="c62e" class="mz na iq ka b kb nj kf nk kj nl kn nm kr nn kv ne nf ng nh bi translated"><strong class="ka ir">更少的请求— </strong>与REST或SOAP相比，GraphQL可以用更少的请求来做事情</li><li id="3ebc" class="mz na iq ka b kb nj kf nk kj nl kn nm kr nn kv ne nf ng nh bi translated">直观的 — GraphQL比REST或SOAP更直观、更易于使用。</li></ul><p id="992d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是GraphQL并不完美。以下是GraphQL的缺点:</p><ul class=""><li id="0815" class="mz na iq ka b kb kc kf kg kj nb kn nc kr nd kv ne nf ng nh bi translated"><strong class="ka ir">开销</strong>——graph QL附带了相当多的设置，这对于小项目来说可能效率不高</li><li id="8f15" class="mz na iq ka b kb nj kf nk kj nl kn nm kr nn kv ne nf ng nh bi translated"><strong class="ka ir">年龄</strong> — GraphQL比REST或SOAP年轻得多，这意味着它的学习材料和最佳实践更少</li></ul><p id="a8cb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望现在您对GraphQL是什么以及它能解决什么问题有了一个坚实的理解。感谢您的阅读，请在评论中告诉我您对GraphQL的看法！</p></div></div>    
</body>
</html>