<html>
<head>
<title>Redux Immutable Update Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux不可变更新模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/redux-immutable-update-patterns-a6801d49f160?source=collection_archive---------6-----------------------#2020-04-18">https://javascript.plainenglish.io/redux-immutable-update-patterns-a6801d49f160?source=collection_archive---------6-----------------------#2020-04-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a1325d6aa1f2b43f3a928499fb5fbadf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oxGOHKM__99W659JhC4neQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source: <a class="ae kc" href="https://linguinecode.com/" rel="noopener ugc nofollow" target="_blank">https://linguinecode.com/</a></figcaption></figure><p id="dd86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我认为您正在阅读一篇关于<a class="ae kc" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>的文章的主要原因之一是，您正在开发的应用程序正处于成长阶段，可能会变得越来越复杂。您正在获得新的业务逻辑需求，这些需求要求您处理不同的域，并且需要一种一致且可调试的方式来处理应用程序状态。</p><p id="20a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你是一个开发简单应用程序的开发人员(或者刚刚开始学习一个新的前端框架，如<a class="ae kc" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>，我们在本文中以此为例)，我打赌你可能不需要Redux除非你把这当成一个学习的机会。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><p id="21db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Redux使您的应用程序变得更加复杂，但这是一件好事。这种复杂性为大规模状态管理带来了简单性。</p><ul class=""><li id="bb1a" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">当你有一些独立的组件不需要相互通信，并且想要维护简单的UI或业务逻辑时，尽一切可能使用<a class="ae kc" href="https://reactjs.org/docs/state-and-lifecycle.html#adding-local-state-to-a-class" rel="noopener ugc nofollow" target="_blank">本地状态</a></li><li id="350b" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">如果您有几个组件需要订阅以获得相同类型的数据，那么作为反应，调度通知、更改或事件<a class="ae kc" href="https://blog.logrocket.com/component-state-local-state-redux-store-and-loaders/" rel="noopener ugc nofollow" target="_blank">加载器</a>可能是您最好的朋友</li><li id="fa08" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">但是，如果您有几个组件(如下图所示)需要与其他组件<a class="ae kc" href="https://blog.codecentric.de/en/2017/12/developing-modern-offline-apps-reactjs-redux-electron-part-3-reactjs-redux-basics/" rel="noopener ugc nofollow" target="_blank">共享某种状态，而没有直接的父子关系</a>，那么Redux是一个完美的解决方案</li></ul><p id="ee23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有Redux，每个组件都需要以某种形式将状态传递给可能需要它的其他组件，并处理相应的命令或事件调度。大规模维护、测试和调试这样的系统很容易成为一场噩梦。然而，在Redux的帮助下，任何组件都不需要持有任何关于管理内部状态的逻辑。他们所要做的就是订阅Redux来获得他们需要的状态，并在需要时向它发送动作。</p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lw"><img src="../Images/b7f91249b0b81fd8abe836ad8552b27b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*TupgphMSMMAbwf0a.png"/></div></div></figure><p id="69f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Redux支持状态管理的核心部分是<a class="ae kc" href="https://redux.js.org/api/store/" rel="noopener ugc nofollow" target="_blank"> Store </a>，它将应用程序的逻辑保存为一个状态对象。该对象公开了一些方法，这些方法支持获取、更新和侦听状态及其变化。在本文中，我们将只关注更新状态。这是使用dispatch(action)方法完成的。这是修改以这种形式发生的<a class="ae kc" href="https://redux.js.org/api/store/#dispatchaction" rel="noopener ugc nofollow" target="_blank">状态的唯一方法。</a></p><p id="fdb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“商店的归约函数将与当前的<a class="ae kc" href="https://redux.js.org/api/store/#getState" rel="noopener ugc nofollow" target="_blank"> getState() </a>结果和给定的动作同步调用。它的返回值将被认为是下一个状态。从现在开始，它将从<a class="ae kc" href="https://redux.js.org/api/store/#getState" rel="noopener ugc nofollow" target="_blank"> getState() </a>返回，并且将立即通知更改监听器”</p><p id="4b3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要记住的首要事情是，状态的任何更新都应该以不可变的方式发生。但是为什么呢？</p><h1 id="6ccd" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">为什么是不可变更新？</h1><p id="dbe2" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">假设您正在开发一个电子商务应用程序，初始状态如下:</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="3ee8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们这里有各种各样的数据类型——字符串、布尔、数组和对象。为了响应应用程序事件，这些状态对象参数需要更新，但是以不可变的方式。换句话说:</p><p id="8a0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://redux.js.org/recipes/structuring-reducers/immutable-update-patterns/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">原始状态或其参数不会改变(或突变)；但是需要通过复制原始值并修改它们来返回新值。</strong>T11】</a></p><p id="a0be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中:</p><ul class=""><li id="5978" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">默认情况下，字符串和布尔值(以及数字或符号等其他原语)是不可变的。下面是字符串不变性的一个例子:</li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><ul class=""><li id="42de" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">对象是可变的，但是可以被<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" rel="noopener ugc nofollow" target="_blank">冻结</a>:</li></ul><p id="91ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的例子中，我们看到了这一点。我们还看到，当我们创建一个新的对象，将它指向一个现有的对象，然后改变新对象的属性，这将导致两个对象的属性都发生变化。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="d477" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想完成对对象的不可变更新，我们有几个选择，比如使用Object.assign或spread操作符。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><ul class=""><li id="9d3f" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">数组有可变和不可变的方法:</li></ul><p id="0fda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记住哪些数组方法是哪些方法是很重要的。这里有几个案例:</p><ul class=""><li id="596e" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">不可变方法:<strong class="kf ir"> concat、filter、map、reduce、reduceRight和reduceRight </strong></li><li id="39c8" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">可变方法:<strong class="kf ir">推送、弹出、移位、取消移位、排序、反转、拼接和删除</strong></li></ul><p id="bcd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请记住，spread运算符也适用于数组，并且可以使不可变的更新变得更加容易。让我们看一些可变和不可变的更新作为例子:</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="2d65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以在一个真实的例子中，如果我们需要更新状态的error属性，我们需要向reducer发送一个动作。Redux reducers是<a class="ae kc" href="https://hackernoon.com/functional-programming-concepts-pure-functions-cafa2983f757" rel="noopener ugc nofollow" target="_blank">纯函数</a>，这意味着:</p><ul class=""><li id="6304" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">它们总是基于相同的输入(即状态和动作)返回相同的值</li><li id="0b41" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">它们不会产生任何副作用，比如进行API调用</li></ul><p id="4b2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这要求我们以不可变的方式处理reducers中的状态更新，这有几个优点:</p><ul class=""><li id="4ba0" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">更容易测试减速器，因为输入和输出总是可预测的</li><li id="b5a1" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">调试和时间旅行，所以你可以看到历史的变化，而不仅仅是结果</li></ul><p id="81f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是最大的好处是保护我们的应用程序不会出现渲染问题。</p><p id="2d07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在像React这样依赖状态来更新<a class="ae kc" href="https://reactjs.org/docs/faq-internals.html" rel="noopener ugc nofollow" target="_blank">虚拟DOM </a>的框架中，拥有正确的状态是必须的。这样，React可以通过比较引用(具有1 的<a class="ae kc" href="https://yourbasic.org/algorithms/big-o-notation-explained/#constant-time" rel="noopener ugc nofollow" target="_blank">大O符号表示快得多)而不是递归比较对象(具有n </a>的<a class="ae kc" href="https://yourbasic.org/algorithms/big-o-notation-explained/#linear-time" rel="noopener ugc nofollow" target="_blank">大O符号表示慢得多)来意识到状态是否已经改变。</a></p><figure class="lx ly lz ma gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/2d964f93f21be227426e3a886edc9f4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8DlYFZZRyxbwyFk_.jpeg"/></div></div></figure><p id="c6dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们分派HANDLE_ERROR动作之后，通知reducer我们需要更新状态，下面是发生的情况:</p><ul class=""><li id="7ac6" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">作为第一步，它使用spread操作符复制stat对象</li><li id="0106" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">第二步，它必须更新错误属性并返回新状态</li><li id="8e42" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">订阅store的所有组件都会收到关于这个新状态的通知，并在需要时重新呈现</li></ul><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><p id="04fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">到目前为止，我们已经以不变的方式介绍了Redux更新模式的基础知识。然而，有些类型的更新可能比其他类型的更新更棘手，比如删除或更新嵌套数据。让我们一起来看看这些案例:</p><h1 id="8567" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">在数组中添加项目</h1><p id="04df" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">如前所述，unshift、push和splice等几种数组方法是可变的。如果我们要就地更新阵列，我们希望远离它们。</p><p id="f6d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论我们是想将项目添加到数组的开头还是结尾，我们都可以简单地使用spread操作符返回一个包含所添加项目的新数组。如果我们打算在某个索引处添加项，我们可以使用一个拼接，只要先制作一个状态副本，然后就可以安全地改变任何属性:</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="b038" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">在嵌套对象的数组中添加项</h1><p id="58ef" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">更新嵌套数据变得有点棘手。对于<strong class="kf ir">嵌套属性中的更新，要记住的主要事情是正确地更新每一层数据并正确地执行更新。</strong>让我们看一个向位于嵌套对象中的数组添加项目的例子。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="b780" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">移除数组中的项目</h1><p id="a4a8" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">以不可变的方式移除项目可以通过几种方式来执行。例如，我们可以使用像filter这样的不可变方法，它返回一个新数组。：</p><pre class="lx ly lz ma gt nh ni nj nk aw nl bi"><span id="9561" class="nm mc iq ni b gy nn no l np nq">function removeItemFiter(array, action) {</span><span id="8751" class="nm mc iq ni b gy nr no l np nq">    return array.filter((item, index) =&gt; index !== action.index)</span><span id="f06b" class="nm mc iq ni b gy nr no l np nq">}</span></pre><p id="db27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以先复制一个数组，然后使用splice来删除数组中某个索引中的一项:</p><pre class="lx ly lz ma gt nh ni nj nk aw nl bi"><span id="2b8c" class="nm mc iq ni b gy nn no l np nq">function removeItemSplice(array, action) {</span><span id="539a" class="nm mc iq ni b gy nr no l np nq">    let newArray = array.slice()</span><span id="0ceb" class="nm mc iq ni b gy nr no l np nq">    newArray.splice(action.index, 1)</span><span id="cfe9" class="nm mc iq ni b gy nr no l np nq">    return newArray</span><span id="64ac" class="nm mc iq ni b gy nr no l np nq">}</span></pre><p id="3574" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的例子展示了在reducer中使用这些不变性概念来返回正确的状态:</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="f451" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">移除嵌套对象内数组中的项目</h1><p id="e7a0" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">最后，我们要移除一个嵌套对象中的数组项。非常类似于添加一个条目，但是在这个例子中，我们将过滤掉嵌套数据中的条目。</p><figure class="lx ly lz ma gt jr"><div class="bz fp l di"><div class="ne nf l"/></div></figure><h1 id="7788" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">结论</h1><p id="842b" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated">让我们一起回顾一下我们学到了什么:</p><ul class=""><li id="b256" class="li lj iq kf b kg kh kk kl ko lk ks ll kw lm la ln lo lp lq bi translated">为什么以及何时我们可能需要像Redux这样的状态管理工具</li><li id="4aa5" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">Redux状态管理和更新如何工作</li><li id="36b0" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">为什么不可变更新很重要</li><li id="86e9" class="li lj iq kf b kg lr kk ls ko lt ks lu kw lv la ln lo lp lq bi translated">如何处理棘手的更新，如在嵌套对象中添加或删除项目</li></ul><p id="ff6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请使用下面的参考列表来获得更多关于这个主题的信息。在本文中，我们打算学习Redux中手动不可变更新模式的基础知识。然而，有一组不可变的库，如<a class="ae kc" href="https://immutable-js.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank"> ImmutableJS </a>或<a class="ae kc" href="https://github.com/immerjs/immer" rel="noopener ugc nofollow" target="_blank"> Immer </a>，可以让你的状态更新更少冗长，更可预测。</p></div><div class="ab cl lb lc hu ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ij ik il im in"><h1 id="d6d6" class="mb mc iq bd md me ns mg mh mi nt mk ml mm nu mo mp mq nv ms mt mu nw mw mx my bi translated">参考资料:</h1><p id="4f5f" class="pw-post-body-paragraph kd ke iq kf b kg mz ki kj kk na km kn ko nb kq kr ks nc ku kv kw nd ky kz la ij bi translated"><a class="ae kc" href="https://medium.com/dailyjs/redux-immutable-data-modification-patterns-614ff394da7f" rel="noopener">https://medium . com/daily js/redux-immutable-data-modification-patterns-614 ff 394 da7f</a></p><p id="1d5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://dev.to/dceddia/immutable-updates-in-react-and-redux-kg" rel="noopener ugc nofollow" target="_blank">https://dev . to/dced dia/immutable-updates-in-react-and-redux-kg</a></p><p id="cecd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://blog.codecentric.de/en/2017/12/developing-modern-offline-apps-reactjs-redux-electron-part-3-reactjs-redux-basics/" rel="noopener ugc nofollow" target="_blank">https://blog . code centric . de/en/2017/12/developing-modern-offline-apps-react js-redux-electronic-part-3-react js-redux-basics/</a></p><p id="11ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://cogent.co/blog/the-internet-says-you-may-not-need-redux/" rel="noopener ugc nofollow" target="_blank">https://cogent . co/blog/the-internet-says-you-may-not-need-redux/</a></p><p id="c0ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://blog.logrocket.com/component-state-local-state-redux-store-and-loaders/" rel="noopener ugc nofollow" target="_blank">https://blog . log rocket . com/component-state-local-state-redux-store-and-loaders/</a></p><p id="1183" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://daveceddia.com/react-redux-immutability-guide/" rel="noopener ugc nofollow" target="_blank">https://daveceddia.com/react-redux-immutability-guide/</a></p><p id="da5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://www.toptal.com/javascript/immutability-in-javascript-using-redux" rel="noopener ugc nofollow" target="_blank">https://www . top tal . com/JavaScript/immutanbility-in-JavaScript-using-redux</a></p><p id="9160" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://vincent.billey.me/pure-javascript-immutable-array/#unshift" rel="noopener ugc nofollow" target="_blank">https://Vincent . billey . me/pure-JavaScript-immutable-array/# un shift</a></p><p id="e41f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://redux.js.org/recipes/structuring-reducers/immutable-update-patterns/" rel="noopener ugc nofollow" target="_blank">https://redux . js . org/recipes/structuring-reducers/immutable-update-patterns/</a></p><p id="3980" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367" rel="noopener">https://medium . com/@ Dan _ abra mov/you-may-not-need-redux-be 46360 cf 367</a></p><p id="3e22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="nx">更多内容看</em> <a class="ae kc" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="nx">说白了。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="nx">免费周报</em> </strong> </a> <em class="nx">。在我们的</em> <a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="nx">社区不和谐</em> </strong> </a> <em class="nx">获得独家获取写作机会和建议。</em></strong></a></p></div></div>    
</body>
</html>