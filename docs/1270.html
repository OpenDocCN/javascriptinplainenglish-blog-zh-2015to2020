<html>
<head>
<title>JavaScript Type Checking with Flow — Type Casting</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用流类型转换的JavaScript类型检查</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-type-checking-with-flow-type-casting-bbceb5d4221f?source=collection_archive---------1-----------------------#2020-02-22">https://javascript.plainenglish.io/javascript-type-checking-with-flow-type-casting-bbceb5d4221f?source=collection_archive---------1-----------------------#2020-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/df18a4f61d8a87a6a9e328a78f5d2989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lZW8MHmICJXZ8cc0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David Clode</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="99dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Flow是一个由脸书开发的类型检查器，用于检查JavaScript数据类型。它有许多内置的数据类型，我们可以用它们来注释变量和函数参数的类型。</p><p id="03af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何将值从一种类型转换为另一种类型。</p><h1 id="d933" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">句法</h1><p id="d833" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要将值赋给给定的类型，我们可以使用以下语法:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="be95" class="mn lc iq mj b gy mo mp l mq mr">(value: Type)</span></pre><p id="8cee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它可以用在变量、对象或数组中。在变量赋值中，它可以如下使用:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dc95" class="mn lc iq mj b gy mo mp l mq mr">let foo = (value: Type);</span></pre><p id="35ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于对象，我们可以通过编写以下内容来转换属性值:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c744" class="mn lc iq mj b gy mo mp l mq mr">let obj = { prop: (value: Type) };</span></pre><p id="ab13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以通过编写以下内容来转换数组条目:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4e42" class="mn lc iq mj b gy mo mp l mq mr">let arr = ([(value: Type), (value: Type)]: Array&lt;Type&gt;);</span></pre><p id="eefe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以将表达式转换成类型。例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5c22" class="mn lc iq mj b gy mo mp l mq mr">(1 + 1: number);</span></pre><p id="00d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来抛数字。</p><h1 id="29b1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类型断言</h1><p id="0441" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们只能在类型有意义的时候对它们进行造型。例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1d74" class="mn lc iq mj b gy mo mp l mq mr">let x = 1;</span></pre><p id="edb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4701" class="mn lc iq mj b gy mo mp l mq mr">(x: 1);</span></pre><p id="a070" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5194" class="mn lc iq mj b gy mo mp l mq mr">(x: number);</span></pre><p id="db32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe ms mt mu mj b">x</code>是具有值<code class="fe ms mt mu mj b">1</code>的数字。转换为不是该值类型的类型将会失败。因此，将变量<code class="fe ms mt mu mj b">x</code>转换为s字符串的方法是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7f37" class="mn lc iq mj b gy mo mp l mq mr">(x: string)</span></pre><p id="2e8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">会给出一个错误，因为<code class="fe ms mt mu mj b">x</code>是一个数字。</p><h1 id="6599" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">铅字铸造</h1><p id="901b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将一个值转换成比变量的原始类型更广泛的类型。例如，如果我们有一个数字变量:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9d17" class="mn lc iq mj b gy mo mp l mq mr">let x = 1;</span></pre><p id="f94b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以将<code class="fe ms mt mu mj b">x</code>转换为<code class="fe ms mt mu mj b">1</code>文字类型或<code class="fe ms mt mu mj b">number</code>类型，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ca99" class="mn lc iq mj b gy mo mp l mq mr">(x: 1); <br/>(x: number);</span></pre><p id="5775" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们把一个变量赋给一个新的变量时，我们也可以把它转换成同样广泛的类型:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dd86" class="mn lc iq mj b gy mo mp l mq mr">let y = (x: number);</span></pre><p id="c852" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是将其转换为更窄的类型会失败，所以如果我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0fce" class="mn lc iq mj b gy mo mp l mq mr">(y: 1);</span></pre><p id="2502" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会得到一个错误，因为<code class="fe ms mt mu mj b">y</code>应该是一个不确定值的<code class="fe ms mt mu mj b">number</code>。</p><h1 id="668c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类型铸造通过任何</h1><p id="a254" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将任何东西投射到<code class="fe ms mt mu mj b">any</code>，然后让我们将它投射到其他任何东西。</p><p id="8843" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想把一个数字转换成一个字符串，我们可以从上面的例子中看到我们不能直接这样做，因为我们不能把任何东西转换成一个不相关的类型。</p><p id="19d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们可以通过先将它造型为<code class="fe ms mt mu mj b">any</code>来绕过它，然后我们可以将它造型为我们想要的任何类型。</p><p id="1f66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e4a9" class="mn lc iq mj b gy mo mp l mq mr">let x = 1;<br/>(x: 1); <br/>(x: number);<br/>let y = ((x: any): string);<br/>(y: string);</span></pre><p id="8338" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不建议这样做，但是在某些情况下，当我们需要将一种类型的东西转换成不相关的类型时，这样做可能会很方便。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/e76e2b0cd81990a81bdc5689349e63d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kqBtsFZp4BzLSizJ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@wbayreuther?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">William Bayreuther</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c369" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类型断言</h1><p id="edff" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们在函数中对对象进行操作时，我们可以通过强制转换对象的类型来设置对象的类型。例如，如果我们有一个克隆对象的函数，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e5e7" class="mn lc iq mj b gy mo mp l mq mr">function foo(obj) {<br/>  const cloneObj = {...(obj: { [key: string]: mixed })};<br/>  return cloneObj;<br/>}</span></pre><p id="b78b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当我们调用它时，Flow足够智能地确定属性的类型:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="43d1" class="mn lc iq mj b gy mo mp l mq mr">let cloneObj = foo({<br/>  a: 1,<br/>  b: true,<br/>  c: 'three'<br/>})<br/>(cloneObj.a: 1);<br/>(cloneObj.b: true);<br/>(cloneObj.c: 'three');</span></pre><p id="0ab2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比将类型放在参数中更有用:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a274" class="mn lc iq mj b gy mo mp l mq mr">function foo(obj: { [key: string]: mixed }) {<br/>  const cloneObj = {...obj};<br/>  return cloneObj;<br/>}</span></pre><p id="3409" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然流不会这样知道<code class="fe ms mt mu mj b">cloneObj</code>的结构。</p><p id="3c2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用带有<code class="fe ms mt mu mj b">$Shape</code>关键字的泛型来断言<code class="fe ms mt mu mj b">obj</code>参数的类型，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4873" class="mn lc iq mj b gy mo mp l mq mr">function foo&lt;T: { [key: string]: mixed }&gt;(obj: T): $Shape&lt;T&gt; {<br/>  const cloneObj = {...obj};<br/>  return cloneObj;  <br/>}</span></pre><p id="f22e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">代码<code class="fe ms mt mu mj b">&lt;T: { [key: string]: mixed }&gt;</code>将让Flow知道<code class="fe ms mt mu mj b">obj</code>参数接受一个对象。</p><p id="a5b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Flow，我们可以通过使用<code class="fe ms mt mu mj b">:</code>和其后的类型标识符，将类型转换为给定对象值的相关类型。</p><p id="537d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以通过先将某个东西转换为<code class="fe ms mt mu mj b">any</code>来将其转换为不相关的类型。</p><p id="2816" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，为了让流程知道变量或参数是一个动态对象，我们可以使用<code class="fe ms mt mu mj b">&lt;T: { [key: string]: mixed }&gt;</code>和<code class="fe ms mt mu mj b">(obj: T)</code>签名来确保参数是一个动态对象。</p><p id="0064" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将<code class="fe ms mt mu mj b">$Shape&lt;T&gt;</code>设置为返回类型，以强制该函数返回的对象类型是一个动态对象。</p></div></div>    
</body>
</html>