<html>
<head>
<title>What is Redis and How to Use it with Nest.JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Redis，如何与Nest配合使用？射流研究…</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-redis-and-how-to-use-it-with-nest-js-3cd1de0fe13b?source=collection_archive---------1-----------------------#2020-12-20">https://javascript.plainenglish.io/what-is-redis-and-how-to-use-it-with-nest-js-3cd1de0fe13b?source=collection_archive---------1-----------------------#2020-12-20</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="a146" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">使用码头集装箱化</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gi gj kg"><img src="../Images/804967fcc41d241d166e246515b10151.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hcKZe4hkZyfRbDcQlEgogw.jpeg"/></div></div><figcaption class="ks kt gk gi gj ku kv bd b be z dk">Photo by <a class="ae kw" href="https://unsplash.com/@jankolar?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jan Antonin Kolar</a> on <a class="ae kw" href="https://unsplash.com/s/photos/database?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0347" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">今天我们将谈论Redis。一个非常强大和易于使用的数据库。它在缓存方面非常流行。</p><h2 id="9ab4" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">先决条件</h2><ul class=""><li id="f445" class="mm mn ir kz b la mo ld mp lg mq lk mr lo ms ls mt mu mv mw bi translated">对缓存的基本理解</li><li id="3ee5" class="mm mn ir kz b la mx ld my lg mz lk na lo nb ls mt mu mv mw bi translated">NestJS的经验</li></ul><h2 id="4434" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">问题是</h2><p id="4710" class="pw-post-body-paragraph kx ky ir kz b la mo js lc ld mp jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">我们公司正在构建一个物业管理解决方案，我们必须维护许多用户，他们可以根据自己的角色拥有不同的权限。</p><p id="3b4d" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因此，每次成功登录后，客户端都会请求获取用户的详细资料以及权限。由于查询非常复杂，需要连接多个表，因此需要很长时间才能加载。</p><p id="a010" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">并且用户必须等待很长时间才能在他们的屏幕上看到任何东西，这是非常糟糕的用户体验。</p><h2 id="cad7" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">解决方案</h2><p id="eb25" class="pw-post-body-paragraph kx ky ir kz b la mo js lc ld mp jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">因此，在挖掘了一些可能的解决方案后，我们发现<strong class="kz is">缓存</strong>是我们的答案。主要因为2个原因</p><ul class=""><li id="d0c2" class="mm mn ir kz b la lb ld le lg nf lk ng lo nh ls mt mu mv mw bi translated">这个API被调用的非常频繁。</li><li id="d2f5" class="mm mn ir kz b la mx ld my lg mz lk na lo nb ls mt mu mv mw bi translated">用户权限不会经常改变</li></ul><p id="cf69" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">因此，经过一番挖掘，很明显Redis可能是我们的最佳选择。并且<strong class="kz is"> Redis </strong>是缓存的好选择</p><h2 id="c8e5" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">那么为什么是Redis呢？</h2><ul class=""><li id="f2a8" class="mm mn ir kz b la mo ld mp lg mq lk mr lo ms ls mt mu mv mw bi translated">Redis真的真的很快。它是用C语言写的，所以非常高效。</li><li id="ecfe" class="mm mn ir kz b la mx ld my lg mz lk na lo nb ls mt mu mv mw bi translated">非常好用。它几乎就像我们浏览器的本地存储，但功能更强大。您只需用一个键设置一些数据，然后用同一个键取回这些数据。</li><li id="5056" class="mm mn ir kz b la mx ld my lg mz lk na lo nb ls mt mu mv mw bi translated">所有主流语言/框架都支持Redis。</li><li id="4f02" class="mm mn ir kz b la mx ld my lg mz lk na lo nb ls mt mu mv mw bi translated">它非常受欢迎，被许多大公司使用，所以稳定性根本不是问题</li></ul><p id="f67f" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">NestJS使得使用Redis变得非常容易。现在我们来看看如何使用它。</p><h2 id="17af" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">第一步。安装依赖项</h2><p id="7ce2" class="pw-post-body-paragraph kx ky ir kz b la mo js lc ld mp jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">安装以下依赖项</p><pre class="kh ki kj kk gu ni nj nk nl aw nm bi"><span id="7ec8" class="lt lu ir nj b gz nn no l np nq">yarn add cache-manager cache-manager-redis-store</span></pre><h2 id="9610" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">第二步。添加缓存模块</h2><p id="d462" class="pw-post-body-paragraph kx ky ir kz b la mo js lc ld mp jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">然后创建一个用于缓存的模块</p><pre class="kh ki kj kk gu ni nj nk nl aw nm bi"><span id="1097" class="lt lu ir nj b gz nn no l np nq">nest g module redis-cache</span></pre><p id="5591" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然后将下面的代码添加到您的<code class="fe nr ns nt nj b">redis-cache.module.ts</code>文件中</p><pre class="kh ki kj kk gu ni nj nk nl aw nm bi"><span id="4e7a" class="lt lu ir nj b gz nn no l np nq">import { CacheModule, Module } from '@nestjs/common';<br/>import { RedisCacheService } from './redis-cache.service';<br/>import { ConfigModule, ConfigService } from '@nestjs/config';<br/>import * as redisStore from 'cache-manager-redis-store';<br/><br/>@Module({<br/>    imports: [<br/>        CacheModule.<em class="nu">registerAsync</em>({<br/>            imports: [ConfigModule],<br/>            inject: [ConfigService],<br/>            useFactory: async (configService: ConfigService) =&gt; ({<br/>                store: redisStore,<br/>                host: configService.get('REDIS_HOST'),<br/>                port: configService.get('REDIS_PORT'),<br/>                ttl: configService.get('CACHE_TTL'),<br/>                max: configService.get('MAX_ITEM_IN_CACHE')<br/>            })<br/>        })<br/>    ],<br/>    providers: [RedisCacheService],<br/>    exports: [RedisCacheService]<br/>})<br/>export class RedisCacheModule {}</span></pre><p id="be77" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这里需要注意一些事情…</p><p id="bc39" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe nr ns nt nj b">REDIS_HOST</code>:指定我们Redis数据库的主机(例如:localhost)</p><p id="ff99" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe nr ns nt nj b">REDIS_PORT</code>:默认端口值为6479</p><p id="a88b" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe nr ns nt nj b">CACHE_TTL</code>:指定一个值失效前的时间(秒)</p><p id="e22e" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><code class="fe nr ns nt nj b">MAX_ITEM_IN_CACHE</code>:指定缓存中应该保存的最大项数。</p><h2 id="5540" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">第三步。创建服务</h2><p id="a898" class="pw-post-body-paragraph kx ky ir kz b la mo js lc ld mp jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">创建新的缓存服务</p><pre class="kh ki kj kk gu ni nj nk nl aw nm bi"><span id="94d5" class="lt lu ir nj b gz nn no l np nq">nest g service redis-cache</span></pre><p id="14da" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然后在<code class="fe nr ns nt nj b">redis-cache.service.ts</code>文件中添加以下代码</p><pre class="kh ki kj kk gu ni nj nk nl aw nm bi"><span id="72ed" class="lt lu ir nj b gz nn no l np nq">import { <strong class="nj is"><em class="nu">CACHE_MANAGER</em></strong>, Inject, Injectable } from '@nestjs/common';<br/>import { Cache } from 'cache-manager';<br/><br/>@Injectable()<br/>export class SomeService {<br/>    constructor(@Inject(<strong class="nj is"><em class="nu">CACHE_MANAGER</em></strong>) private readonly cache: Cache) {}<br/><br/>    async get(key): Promise&lt;any&gt; {<br/>        return await this.cache.get(key);<br/>    }<br/><br/>    async set(key, value) {<br/>        await this.cache.set(key, value, 1000);<br/>    }<br/><br/>    async reset() {<br/>        await this.cache.reset();<br/>    }<br/><br/>    async del(key) {<br/>        await this.cache.del(key);<br/>    }<br/>}</span></pre><p id="35d3" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这些是使用缓存的实用函数。</p><h2 id="a6b7" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">第四步。使用缓存服务</h2><p id="404b" class="pw-post-body-paragraph kx ky ir kz b la mo js lc ld mp jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">在任何服务内部，现在都可以将RedisCacheModule导入到不同的模块中。</p><pre class="kh ki kj kk gu ni nj nk nl aw nm bi"><span id="7a1f" class="lt lu ir nj b gz nn no l np nq">@Module({<br/>    imports: [RedisCacheModule],<br/>    controllers: [UserController],<br/>    providers: [UserService],<br/>    exports: [UserService]<br/>})<br/>export class SomeModule {}</span></pre><p id="84ce" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">然后在该模块内的任何服务中使用它</p><pre class="kh ki kj kk gu ni nj nk nl aw nm bi"><span id="9d77" class="lt lu ir nj b gz nn no l np nq">@Injectable()<br/>export class UserService {<br/>    constructor(private cacheManager: RedisCacheService) {}</span><span id="8ea7" class="lt lu ir nj b gz nv no l np nq">   async setSomeValue(KEY , value){<br/>      await this.cacheManager.set(KEY , value);<br/>   }</span><span id="dc49" class="lt lu ir nj b gz nv no l np nq">   async getSomeValue(KEY){<br/>      await this.cacheManager.get(KEY);<br/>   }</span><span id="724c" class="lt lu ir nj b gz nv no l np nq">}</span></pre><h2 id="9b87" class="lt lu ir bd lv lw lx dn ly lz ma dp mb lg mc md me lk mf mg mh lo mi mj mk ml bi translated">额外收获:将整个申请归档</h2><p id="7893" class="pw-post-body-paragraph kx ky ir kz b la mo js lc ld mp jv lf lg nc li lj lk nd lm ln lo ne lq lr ls ik bi translated">如果您现在运行您的应用程序，您将遇到一个错误，因为您没有启动和运行Redis数据库。你有两个选择</p><ul class=""><li id="3095" class="mm mn ir kz b la lb ld le lg nf lk ng lo nh ls mt mu mv mw bi translated">在本地机器上安装并运行Redis</li><li id="bd0f" class="mm mn ir kz b la mx ld my lg mz lk na lo nb ls mt mu mv mw bi translated">使用docker从docker hub中提取Redis映像。</li></ul><p id="c128" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在我们将看看以后如何做。</p><p id="e402" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">主docker文件是任何nodeJS应用程序的典型文件</p><pre class="kh ki kj kk gu ni nj nk nl aw nm bi"><span id="adf7" class="lt lu ir nj b gz nn no l np nq">FROM node:12-alpine<br/>WORKDIR /app<br/>ADD package.json /app/package.json<br/>RUN yarn install<br/>ADD . /app<br/>EXPOSE 3000<br/>CMD ["yarn", "start"]</span></pre><p id="1a72" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">我们必须添加另一个和<code class="fe nr ns nt nj b">docker-compose.yml</code>文件</p><pre class="kh ki kj kk gu ni nj nk nl aw nm bi"><span id="3006" class="lt lu ir nj b gz nn no l np nq">version: '3'<br/>services:<br/>  redis:<br/>    image: 'redis:alpine'<br/>  node-app:<br/>    build: .<br/>    ports:<br/>      - "3000:3000"</span></pre><p id="5a62" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">这里，我们从docker hub中提取官方的Redis映像并运行它，以便我们的应用程序可以访问它。</p><blockquote class="nw nx ny"><p id="504d" class="kx ky nu kz b la lb js lc ld le jv lf nz lh li lj oa ll lm ln ob lp lq lr ls ik bi translated">如果你从docker镜像运行Redis，你必须将<code class="fe nr ns nt nj b">REDIS_HOST</code>值(在步骤2中使用)改为<code class="fe nr ns nt nj b">redis</code>(在docker-compose文件中使用)</p></blockquote><p id="cbf1" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">现在您应该对在您的下一个项目中使用Redis更加熟悉了。这确实是一个非常有用的工具，可以放在开发人员的腰带下面。</p><p id="b37a" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated">今天到此为止。编码快乐！:D</p><p id="2744" class="pw-post-body-paragraph kx ky ir kz b la lb js lc ld le jv lf lg lh li lj lk ll lm ln lo lp lq lr ls ik bi translated"><strong class="kz is">通过</strong> <a class="ae kw" href="https://www.linkedin.com/in/56faisal/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz is"> LinkedIn </strong> </a> <strong class="kz is">或我的</strong> <a class="ae kw" href="https://www.mohammadfaisal.dev/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz is">个人网站</strong> </a> <strong class="kz is">与我取得联系。</strong></p></div></div>    
</body>
</html>