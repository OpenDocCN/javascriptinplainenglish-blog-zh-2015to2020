<html>
<head>
<title>Handling user registration in Nest.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Nest.js中处理用户注册</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/handling-user-registration-19d5bd3c5995?source=collection_archive---------1-----------------------#2020-09-22">https://javascript.plainenglish.io/handling-user-registration-19d5bd3c5995?source=collection_archive---------1-----------------------#2020-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="52af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在前面的文章中，用户样本数据在一个观察<code class="fe kl km kn ko b">OnMoudleInit</code>事件的服务中初始化。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/155e8ffce096399e46512b1f870809aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*_wOuvejbBpDziXq7.jpg"/></div></div></figure><p id="7024" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本帖中，我们将添加一个端点来处理用户注册请求，包括:</p><ul class=""><li id="7495" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">添加一个端点<em class="lk">/注册</em>来处理用户注册进程</li><li id="6d60" class="lb lc iq jp b jq ll ju lm jy ln kc lo kg lp kk lg lh li lj bi translated">用bcrypt散列密码</li><li id="4e41" class="lb lc iq jp b jq ll ju lm jy ln kc lo kg lp kk lg lh li lj bi translated">通过SendGrid邮件服务发送通知</li></ul></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="6212" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">注册新用户</h1><p id="0e7b" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">生成寄存器控制器。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="12a8" class="ne ly iq ko b gy nf ng l nh ni">nest g controller user/register --flat</span></pre><p id="ac06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将以下内容填入<code class="fe kl km kn ko b">RegisterController</code>。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="f087" class="ne ly iq ko b gy nf ng l nh ni">// user/register.controller.ts</span><span id="4ee2" class="ne ly iq ko b gy nj ng l nh ni">@Controller('register')<br/>export class RegisterController {<br/>    constructor(private userService: UserService) { }</span><span id="605c" class="ne ly iq ko b gy nj ng l nh ni">    @Post()<br/>    register(<br/>        @Body() registerDto: RegisterDto,<br/>        @Res() res: Response): Observable&lt;Response&gt; {<br/>        const username = registerDto.username;</span><span id="6f93" class="ne ly iq ko b gy nj ng l nh ni">        return this.userService.existsByUsername(username).pipe(<br/>            flatMap(exists =&gt; {<br/>                if (exists) {<br/>                    throw new ConflictException(`username:${username} is existed`)<br/>                }<br/>                else {<br/>                    const email = registerDto.email;<br/>                    return this.userService.existsByEmail(email).pipe(<br/>                        flatMap(exists =&gt; {<br/>                            if (exists) {<br/>                                throw new ConflictException(`email:${email} is existed`)<br/>                            }<br/>                            else {<br/>                                return this.userService.register(registerDto).pipe(<br/>                                    map(user =&gt;<br/>                                        res.location('/users/' + user.id)<br/>                                            .status(201)<br/>                                            .send()<br/>                                    )<br/>                                );<br/>                            }<br/>                        })<br/>                    );<br/>                }<br/>            })<br/>        );<br/>    }<br/>}</span></pre><p id="7bb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的代码中，我们将分别通过用户名和电子邮件检查用户是否存在，然后将用户数据保存到MongoDB数据库中。</p><p id="e1bf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe kl km kn ko b">UserService</code>中，添加缺少的方法。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="0966" class="ne ly iq ko b gy nf ng l nh ni">@Injectable()<br/>export class UserService {<br/>    <br/>  existsByUsername(username: string): Observable&lt;boolean&gt; {<br/>    return from(this.userModel.exists({ username }));<br/>  }</span><span id="d409" class="ne ly iq ko b gy nj ng l nh ni">  existsByEmail(email: string): Observable&lt;boolean&gt; {<br/>    return from(this.userModel.exists({ email }));<br/>  }</span><span id="86cc" class="ne ly iq ko b gy nj ng l nh ni">  register(data: RegisterDto): Observable&lt;User&gt; {</span><span id="9d1e" class="ne ly iq ko b gy nj ng l nh ni">    const created = this.userModel.create({<br/>      ...data,<br/>      roles: [RoleType.USER]<br/>    });</span><span id="2604" class="ne ly iq ko b gy nj ng l nh ni">    return from(created);<br/>  }<br/>  //...<br/>}</span></pre><p id="94c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个DTO类来表示用户注册请求数据。首先生成DTO骨架。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="3244" class="ne ly iq ko b gy nf ng l nh ni">nest g class user/register.dto --flat</span></pre><p id="eeba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">并填写以下内容。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="a8c2" class="ne ly iq ko b gy nf ng l nh ni">import { IsEmail, IsNotEmpty, MaxLength, MinLength } from "class-validator";</span><span id="2c15" class="ne ly iq ko b gy nj ng l nh ni">export class RegisterDto {<br/>    @IsNotEmpty()<br/>    readonly username: string;</span><span id="981c" class="ne ly iq ko b gy nj ng l nh ni">    @IsNotEmpty()<br/>    @IsEmail()<br/>    readonly email: string;</span><span id="31ba" class="ne ly iq ko b gy nj ng l nh ni">    @IsNotEmpty()<br/>    @MinLength(8, { message: " The min length of password is 8 " })<br/>    @MaxLength(20, { message: " The password can't accept more than 20 characters " })<br/>    // @Matches(/^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[0-9a-zA-Z]{8,20}$/,<br/>    //     { message: " A password at least contains one numeric digit, one supercase char and one lowercase char" }<br/>    // )<br/>    readonly password: string;</span><span id="a97b" class="ne ly iq ko b gy nj ng l nh ni">    @IsNotEmpty()<br/>    readonly firstName?: string;</span><span id="0efb" class="ne ly iq ko b gy nj ng l nh ni">    @IsNotEmpty()<br/>    readonly lastName?: string;<br/>}</span></pre><p id="29fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上代码中的<code class="fe kl km kn ko b">@IsNotEmpty()</code>、<code class="fe kl km kn ko b">@IsEmail</code>、<code class="fe kl km kn ko b">@MinLength()</code>、<code class="fe kl km kn ko b">@MaxLength()</code>、<code class="fe kl km kn ko b">@Matches()</code>均出自<code class="fe kl km kn ko b">class-validator</code>。如果您有一些Java EE/Jakarta EE Bean验证或Hibernate验证的经验，这些注释很容易理解。</p><ul class=""><li id="14bd" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated"><code class="fe kl km kn ko b">@IsNotEmpty()</code>检查给定值是否为空</li><li id="aff9" class="lb lc iq jp b jq ll ju lm jy ln kc lo kg lp kk lg lh li lj bi translated"><code class="fe kl km kn ko b">@IsEmail</code>验证输入字符串是否是有效的电子邮件格式</li><li id="4105" class="lb lc iq jp b jq ll ju lm jy ln kc lo kg lp kk lg lh li lj bi translated"><code class="fe kl km kn ko b">@MinLength()</code>和<code class="fe kl km kn ko b">@MaxLength()</code>用于限制输入值的长度范围</li><li id="88a4" class="lb lc iq jp b jq ll ju lm jy ln kc lo kg lp kk lg lh li lj bi translated"><code class="fe kl km kn ko b">@Matches()</code>对于自定义正则表达式匹配是灵活的。</li></ul><blockquote class="nk nl nm"><p id="fbb2" class="jn jo lk jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated"><em class="iq">更多关于类验证器用法的信息，查看项目</em><a class="ae nq" href="https://github.com/typestack/class-validator" rel="noopener ugc nofollow" target="_blank"><em class="iq">typestack/类验证器</em> </a> <em class="iq">的详细信息。</em></p></blockquote><p id="f78a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在之前的文章中，我们已经在<code class="fe kl km kn ko b">main.ts</code>条目文件的<code class="fe kl km kn ko b">bootstrap</code>函数中应用了一个全局<code class="fe kl km kn ko b">ValidationPipe</code>。当用无效数据注册时，它将返回404错误。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="6687" class="ne ly iq ko b gy nf ng l nh ni">$ curl <a class="ae nq" href="http://localhost:3000/register" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/register</a> -d "{}" {"statusCode":400,"message":["username should not be empty","email must be an em ail","email should not be empty"," The password can't accept more than 20 charac ters "," The min length of password is 8 ","password should not be empty","first Name should not be empty","lastName should not be empty"],"error":"Bad Request"}</span></pre><p id="749e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为<code class="fe kl km kn ko b">RegisterController</code>添加一个测试。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="1ade" class="ne ly iq ko b gy nf ng l nh ni">describe('Register Controller', () =&gt; {<br/>  let controller: RegisterController;<br/>  let service: UserService;</span><span id="20f6" class="ne ly iq ko b gy nj ng l nh ni">  beforeEach(async () =&gt; {<br/>    const module: TestingModule = await Test.createTestingModule({<br/>      controllers: [RegisterController],<br/>      providers: [<br/>        {<br/>          provide: UserService,<br/>          useValue: {<br/>            register: jest.fn(),<br/>            existsByUsername: jest.fn(),<br/>            existsByEmail: jest.fn()<br/>          },<br/>        },<br/>      ]<br/>    }).compile();</span><span id="c92d" class="ne ly iq ko b gy nj ng l nh ni">    controller = module.get&lt;RegisterController&gt;(RegisterController);<br/>    service = module.get&lt;UserService&gt;(UserService);<br/>  });</span><span id="b561" class="ne ly iq ko b gy nj ng l nh ni">  it('should be defined', () =&gt; {<br/>    expect(controller).toBeDefined();<br/>  });</span><span id="3161" class="ne ly iq ko b gy nj ng l nh ni">  describe('register', () =&gt; {<br/>    it('should throw ConflictException when username is existed ', async () =&gt; {<br/>      const existsByUsernameSpy = jest.spyOn(service, 'existsByUsername').mockReturnValue(of(true));<br/>      const existsByEmailSpy = jest.spyOn(service, 'existsByEmail').mockReturnValue(of(true));<br/>      const saveSpy = jest.spyOn(service, 'register').mockReturnValue(of({} as User));</span><span id="b90b" class="ne ly iq ko b gy nj ng l nh ni">      const responseMock = {<br/>        location: jest.fn().mockReturnThis(),<br/>        json: jest.fn().mockReturnThis(),<br/>        send: jest.fn().mockReturnThis()<br/>      } as any;<br/>      try {<br/>        await controller.register({ username: 'hantsy' } as RegisterDto, responseMock).toPromise();<br/>      } catch (e) {<br/>        expect(e).toBeDefined();<br/>        expect(existsByUsernameSpy).toBeCalledWith('hantsy');<br/>        expect(existsByEmailSpy).toBeCalledTimes(0);<br/>        expect(saveSpy).toBeCalledTimes(0)<br/>      }<br/>    });</span><span id="09e3" class="ne ly iq ko b gy nj ng l nh ni">    it('should throw ConflictException when email is existed ', async () =&gt; {<br/>      const existsByUsernameSpy = jest.spyOn(service, 'existsByUsername').mockReturnValue(of(false));<br/>      const existsByEmailSpy = jest.spyOn(service, 'existsByEmail').mockReturnValue(of(true));<br/>      const saveSpy = jest.spyOn(service, 'register').mockReturnValue(of({} as User));</span><span id="3404" class="ne ly iq ko b gy nj ng l nh ni">      const responseMock = {<br/>        location: jest.fn().mockReturnThis(),<br/>        json: jest.fn().mockReturnThis(),<br/>        send: jest.fn().mockReturnThis()<br/>      } as any;<br/>      try {<br/>        await controller.register({ username: 'hantsy', email: 'hantsy@example.com' } as RegisterDto, responseMock).toPromise();<br/>      } catch (e) {<br/>        expect(e).toBeDefined();<br/>        expect(existsByUsernameSpy).toBeCalledWith('hantsy');<br/>        expect(existsByEmailSpy).toBeCalledWith('hantsy@example.com');<br/>        expect(saveSpy).toBeCalledTimes(0)<br/>      }<br/>    });</span><span id="8ebb" class="ne ly iq ko b gy nj ng l nh ni">    it('should save when username and email are available ', async () =&gt; {<br/>      const existsByUsernameSpy = jest.spyOn(service, 'existsByUsername').mockReturnValue(of(false));<br/>      const existsByEmailSpy = jest.spyOn(service, 'existsByEmail').mockReturnValue(of(false));<br/>      const saveSpy = jest.spyOn(service, 'register').mockReturnValue(of({ _id: '123' } as User));</span><span id="082a" class="ne ly iq ko b gy nj ng l nh ni">      const responseMock = {<br/>        location: jest.fn().mockReturnThis(),<br/>        status: jest.fn().mockReturnThis(),<br/>        send: jest.fn().mockReturnThis()<br/>      } as any;</span><span id="2cbc" class="ne ly iq ko b gy nj ng l nh ni">      const locationSpy = jest.spyOn(responseMock, 'location');<br/>      const statusSpy = jest.spyOn(responseMock, 'status');<br/>      const sendSpy = jest.spyOn(responseMock, 'send');</span><span id="a590" class="ne ly iq ko b gy nj ng l nh ni">      await controller.register({ username: 'hantsy', email: 'hantsy@example.com' } as RegisterDto, responseMock).toPromise();</span><span id="b27a" class="ne ly iq ko b gy nj ng l nh ni">      expect(existsByUsernameSpy).toBeCalledWith('hantsy');<br/>      expect(existsByEmailSpy).toBeCalledWith('hantsy@example.com');<br/>      expect(saveSpy).toBeCalledTimes(1);<br/>      expect(locationSpy).toBeCalled();<br/>      expect(statusSpy).toBeCalled();<br/>      expect(sendSpy).toBeCalled();</span><span id="1718" class="ne ly iq ko b gy nj ng l nh ni">    });<br/>  });<br/>});</span></pre><p id="6ca9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上述测试代码中，我们检查了所有条件，并确保命中了<code class="fe kl km kn ko b">RegisterController</code>中的所有代码块。</p><p id="3bf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于<code class="fe kl km kn ko b">UserService</code>中新增的方法，相应增加测试。这里我跳过测试代码，请自行检查<a class="ae nq" href="https://github.com/hantsy/nestjs-sample/tree/feat/user" rel="noopener ugc nofollow" target="_blank">源代码</a>。</p></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="dcf9" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">哈希密码</h1><p id="b5fc" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">在以前的文章中，我们使用纯文本来存储用户文档中的密码字段。在实际应用中，出于安全考虑，我们应该选择哈希算法来编码普通密码。</p><p id="8686" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Bcrypt是非常流行的散列密码。</p><p id="8e66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先安装<code class="fe kl km kn ko b">bcypt</code>。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="6215" class="ne ly iq ko b gy nf ng l nh ni">npm install --save bcrypt</span></pre><p id="2466" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当保存一个新用户，散列密码，然后保存它。在<code class="fe kl km kn ko b">User</code>型号中添加一个预保存挂钩。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="a3af" class="ne ly iq ko b gy nf ng l nh ni">async function preSaveHook(next) {</span><span id="0686" class="ne ly iq ko b gy nj ng l nh ni">  // Only run this function if password was modified<br/>  if (!this.isModified('password')) return next();</span><span id="9090" class="ne ly iq ko b gy nj ng l nh ni">  // Hash the password<br/>  const password = await hash(this.password, 12);<br/>  this.set('password', password);</span><span id="6362" class="ne ly iq ko b gy nj ng l nh ni">  next();<br/>}</span><span id="8940" class="ne ly iq ko b gy nj ng l nh ni">UserSchema.pre&lt;User&gt;('save', preSaveHook);</span></pre><p id="1eb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在新用户数据被持久化到MongoDB之前，将调用<code class="fe kl km kn ko b">preSave</code>钩子。</p><p id="0c7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当用户试图通过用户名和密码对登录时，应该检查密码是否与数据库中的密码匹配。</p><p id="3cf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">向<code class="fe kl km kn ko b">User</code>模型添加一个方法。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="d653" class="ne ly iq ko b gy nf ng l nh ni">function comparePasswordMethod(password: string): Observable&lt;boolean&gt; {<br/>  return from(compare(password, this.password));<br/>}</span><span id="2886" class="ne ly iq ko b gy nj ng l nh ni">UserSchema.methods.comparePassword = comparePasswordMethod;</span></pre><p id="8486" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">改变<code class="fe kl km kn ko b">AuthService</code>的<code class="fe kl km kn ko b">validateUser</code>方法，检查密码是否匹配。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="0a7f" class="ne ly iq ko b gy nf ng l nh ni">flatMap((user) =&gt; {<br/>    const { _id, password, username, email, roles } = user;<br/>    return user.comparePassword(pass).pipe(map(m =&gt; {<br/>        if (m) {<br/>            return { id: _id, username, email, roles } as UserPrincipal;<br/>        }else {<br/>            throw new UnauthorizedException('username or password is not matched')<br/>        }<br/>    }))</span></pre><p id="6f81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试<code class="fe kl km kn ko b">User</code>模型的挂钩有点困难，为了简化测试工作，这里我将挂钩提取到独立的函数，并在测试中模拟调用上下文。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="3f74" class="ne ly iq ko b gy nf ng l nh ni">// see: <a class="ae nq" href="https://stackoverflow.com/questions/58701700/how-do-i-test-if-statement-inside-my-mongoose-pre-save-hook" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/questions/58701700/how-do-i-test-if-statement-inside-my-mongoose-pre-save-hook</a><br/>describe('preSaveHook', () =&gt; {<br/>    test('should execute next middleware when password is not modified', async () =&gt; {<br/>        const nextMock = jest.fn();<br/>        const contextMock = {<br/>            isModified: jest.fn()<br/>        };<br/>        contextMock.isModified.mockReturnValueOnce(false);<br/>        await preSaveHook.call(contextMock, nextMock);<br/>        expect(contextMock.isModified).toBeCalledWith('password');<br/>        expect(nextMock).toBeCalledTimes(1);<br/>    });</span><span id="2016" class="ne ly iq ko b gy nj ng l nh ni">    test('should set password when password is modified', async () =&gt; {<br/>        const nextMock = jest.fn();<br/>        const contextMock = {<br/>            isModified: jest.fn(),<br/>            set: jest.fn(),<br/>            password: '123456'<br/>        };<br/>        contextMock.isModified.mockReturnValueOnce(true);<br/>        await preSaveHook.call(contextMock, nextMock);<br/>        expect(contextMock.isModified).toBeCalledWith('password');<br/>        expect(nextMock).toBeCalledTimes(1);<br/>        expect(contextMock.set).toBeCalledTimes(1);<br/>    });<br/>});</span></pre><p id="f9b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<a class="ae nq" href="https://github.com/hantsy/nestjs-sample/blob/master/src/database/user.mdoel.spec.ts" rel="noopener ugc nofollow" target="_blank"> user.mdoel.sepc.ts </a>中探索<code class="fe kl km kn ko b">comparePasswordMethod</code>等的其他测试。</p><p id="0591" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在运行应用程序，查看控制台中关于用户初始化的日志，因为您看到存储在MongoDB中的密码被散列。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="1f36" class="ne ly iq ko b gy nf ng l nh ni">(UserModule) is initialized...<br/>[<br/>  {<br/>    roles: [ 'USER' ],<br/>    _id: 5f477055fb9a2b3fa4cb1c21,<br/>    username: 'hantsy',<br/>    password: '$2b$12$/spjKM3Vdf5vRJE9u2cHaulIAWzKMbNVSyHjMp9E9PifbSEHTQrJy',<br/>    email: 'hantsy@example.com',<br/>    createdAt: 2020-08-27T08:35:33.800Z,<br/>    updatedAt: 2020-08-27T08:35:33.800Z,<br/>    __v: 0<br/>  },<br/>  {<br/>    roles: [ 'ADMIN' ],<br/>    _id: 5f477055fb9a2b3fa4cb1c22,<br/>    username: 'admin',<br/>    password: '$2b$12$kFhASRJPkb/WD99J4uZrf.ZkkeKghpvf/6pgVGQArGiIgXu5aNMe.',<br/>    email: 'admin@example.com',<br/>    createdAt: 2020-08-27T08:35:33.801Z,<br/>    updatedAt: 2020-08-27T08:35:33.801Z,<br/>    __v: 0<br/>  }<br/>]</span></pre></div><div class="ab cl lq lr hu ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ij ik il im in"><h1 id="f100" class="lx ly iq bd lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu bi translated">注册欢迎通知</h1><p id="6b96" class="pw-post-body-paragraph jn jo iq jp b jq mv js jt ju mw jw jx jy mx ka kb kc my ke kf kg mz ki kj kk ij bi translated">通常，在真实的应用程序中，当注册成功完成时，应该向新注册的用户发送一封欢迎电子邮件。</p><p id="1abe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">NodeJS应用中有几个模块可以用来发送邮件，例如<code class="fe kl km kn ko b">nodemailer</code>等。还有一些邮件的云服务，比如<a class="ae nq" href="https://sendgrid.com/" rel="noopener ugc nofollow" target="_blank"> SendGrid </a>。有一个现有的Nestjs模块将SendGrid集成到Nestjs中，请检查<a class="ae nq" href="https://github.com/ntegral/nestjs-sendgrid" rel="noopener ugc nofollow" target="_blank">ntegral/Nestjs-send grid</a>项目。</p><p id="2f88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个示例中，我们将不使用现有的模块，而是为这个应用程序创建一个新的家用模块。</p><p id="2a19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先安装sendgrid npm包。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="8bd2" class="ne ly iq ko b gy nf ng l nh ni">npm i @sendgrid/mail</span></pre><p id="6f43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">生成sendgrid模块和sendgrid服务。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="5fcb" class="ne ly iq ko b gy nf ng l nh ni">nest g mo sendgrid<br/>nest g s sendgrid</span></pre><p id="3f85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将以下内容添加到<code class="fe kl km kn ko b">SendgridService</code>中。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="4043" class="ne ly iq ko b gy nf ng l nh ni">@Injectable()<br/>export class SendgridService {</span><span id="c232" class="ne ly iq ko b gy nj ng l nh ni">    constructor(@Inject(SENDGRID_MAIL) private mailService: MailService) { }</span><span id="0109" class="ne ly iq ko b gy nj ng l nh ni">    send(data: MailDataRequired): Observable&lt;any&gt;{<br/>        //console.log(this.mailService)<br/>        return from(this.mailService.send(data, false))<br/>    }</span><span id="3c55" class="ne ly iq ko b gy nj ng l nh ni">}</span></pre><p id="5648" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">创建一个提供者来公开来自<code class="fe kl km kn ko b">@sendgrid/mail</code>包的<code class="fe kl km kn ko b">MailService</code>。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="8843" class="ne ly iq ko b gy nf ng l nh ni">export const sendgridProviders = [<br/>    {<br/>      provide: SENDGRID_MAIL,<br/>      useFactory: (config: ConfigType&lt;typeof sendgridConfig&gt;): MailService =&gt;<br/>        {<br/>            const mail = new MailService();<br/>            mail.setApiKey(config.apiKey);<br/>            mail.setTimeout(5000);<br/>            //mail.setTwilioEmailAuth(username, password)<br/>            return mail;<br/>        },<br/>      inject: [sendgridConfig.KEY],<br/>    }<br/>  ];</span></pre><p id="b783" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相应地，为sendgrid添加一个配置。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="b6d7" class="ne ly iq ko b gy nf ng l nh ni">//config/sendgrid.config.ts<br/>export default registerAs('sendgrid', () =&gt; ({<br/>  apiKey: process.env.SENDGRID_API_KEY || 'SG.test',<br/>}));</span></pre><blockquote class="nk nl nm"><p id="e715" class="jn jo lk jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated"><em class="iq">注册SendGrid并为您的应用程序生成一个API密匙来发送电子邮件。</em></p></blockquote><p id="8040" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe kl km kn ko b">SendgridModule</code>中声明与sendgrid相关的配置、提供商和服务。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="213f" class="ne ly iq ko b gy nf ng l nh ni">@Module({<br/>  imports: [ConfigModule.forFeature(sendgridConfig)],<br/>  providers: [...sendgridProviders, SendgridService],<br/>  exports: [...sendgridProviders, SendgridService]<br/>})<br/>export class SendgridModule { }</span></pre><p id="a257" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">改变<code class="fe kl km kn ko b">UserService</code>中的寄存器功能。</p><pre class="kq kr ks kt gt na ko nb nc aw nd bi"><span id="afc6" class="ne ly iq ko b gy nf ng l nh ni">const msg = {<br/>      from: 'hantsy@gmail.com', // Use the email address or domain you verified above<br/>      subject: 'Welcome to Nestjs Sample',<br/>      templateId: "d-cc6080999ac04a558d632acf2d5d0b7a",<br/>      personalizations: [<br/>        {<br/>          to: data.email,<br/>          dynamicTemplateData: { name: data.firstName + ' ' + data.lastName },<br/>        }<br/>      ]</span><span id="467c" class="ne ly iq ko b gy nj ng l nh ni">    };<br/>    return this.sendgridService.send(msg).pipe(<br/>      catchError(err=&gt;of(`sending email failed:${err}`)),<br/>      tap(data =&gt; console.log(data)),<br/>      flatMap(data =&gt; from(created)),<br/>    );</span></pre><blockquote class="nk nl nm"><p id="825b" class="jn jo lk jp b jq jr js jt ju jv jw jx nn jz ka kb no kd ke kf np kh ki kj kk ij bi translated"><em class="iq">template Id是SendGrid管理的模板的id。SendGrid有很棒的web UI，可以让你编写和管理电子邮件模板。</em></p></blockquote><p id="9bc8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">理想情况下，用户注册过程应该分为两个步骤。</p><ul class=""><li id="f988" class="lb lc iq jp b jq jr ju jv jy ld kc le kg lf kk lg lh li lj bi translated">验证注册表单中的用户输入数据，并将其持久化到MongoDB中，然后发送一个验证号来验证注册的电话号码、电子邮件等。在此阶段，用户帐户将被暂停验证。</li><li id="f610" class="lb lc iq jp b jq ll ju lm jy ln kc lo kg lp kk lg lh li lj bi translated">注册用户收到电子邮件中的验证号码或链接，在验证页面中提供或直接点击电子邮件中的链接，并得到验证。在此阶段，用户帐户将被激活。</li></ul><p id="c58a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从我的github 中抓取<a class="ae nq" href="https://github.com/hantsy/nestjs-sample" rel="noopener ugc nofollow" target="_blank">源代码，切换到分支</a><a class="ae nq" href="https://github.com/hantsy/nestjs-sample/blob/feat/user" rel="noopener ugc nofollow" target="_blank">专长/用户</a>。</p></div></div>    
</body>
</html>