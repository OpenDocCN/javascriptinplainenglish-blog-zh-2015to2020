<html>
<head>
<title>Navigating your React app with the useHistory hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用useHistory挂钩导航React应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/navigating-your-react-app-with-the-usehistory-hook-c7c465bfc6f6?source=collection_archive---------2-----------------------#2020-10-14">https://javascript.plainenglish.io/navigating-your-react-app-with-the-usehistory-hook-c7c465bfc6f6?source=collection_archive---------2-----------------------#2020-10-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/08436d3fbb347d7030e754f262393cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cmxvd9fppdAT-G6WELg8jA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@rocinante_11?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Mick Haupt</a> on <a class="ae jz" href="https://unsplash.com/s/photos/navigation?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="30c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们开始之前，请记住，只有当您使用React 16.8(2019年2月发布)或更高版本，并试图在组件内部实现这一点时，<code class="fe ky kz la lb b">useHistory</code>钩子才会起作用。如果不是这样，请看我的另一篇文章，<a class="ae jz" href="https://medium.com/@bcantello/using-history-to-navigate-your-react-app-from-outside-a-component-40ea74ba4402" rel="noopener">使用“历史”从组件外部导航React应用程序</a>。</p><p id="539e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你在React中做过任何编程，你可能对使用<code class="fe ky kz la lb b">&lt;Switch&gt;</code>、<code class="fe ky kz la lb b">&lt;Route&gt;</code>和<code class="fe ky kz la lb b">&lt;Link&gt;</code>的基本路由很熟悉。为此，我们从<code class="fe ky kz la lb b">react-router-dom</code>导入<code class="fe ky kz la lb b">BrowserRouter</code>、<code class="fe ky kz la lb b">HashRouter</code>、<code class="fe ky kz la lb b">MemoryRouter</code>或<code class="fe ky kz la lb b">NativeRouter</code>，然后在<code class="fe ky kz la lb b">index.js</code>中将<code class="fe ky kz la lb b">&lt;App /&gt;</code>组件包装在我们选择的路由器中。这看起来会像这样:</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="0280" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以在应用程序中的任何地方自由使用上述标记。然而，您可能不知道的是，每当我们使用上面列出的任何路由器时，React也会创建一个<code class="fe ky kz la lb b">history</code>对象供我们使用，并在默认的props中传递该对象。例如，假设没有向登录组件传递任何属性。登录仍然可以接受默认属性，并以这种方式利用历史对象:</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="8a9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们显然希望在其中加入一些额外的逻辑，但关键是我们可以通过<code class="fe ky kz la lb b">props</code>访问历史对象，即使没有向<code class="fe ky kz la lb b">Login</code>传递任何属性，并使用<code class="fe ky kz la lb b">history.push</code>将新条目推送到历史堆栈中。基于上面的例子，这将把用户路由到与<code class="fe ky kz la lb b">/home</code> url相关联的组件。那很简单！</p><blockquote class="li lj lk"><p id="ab68" class="ka kb ll kc b kd ke kf kg kh ki kj kk lm km kn ko ln kq kr ks lo ku kv kw kx ig bi translated"><em class="in">但是如果我们真的将道具传递给</em> <code class="fe ky kz la lb b"><em class="in">Login</em></code> <em class="in">，从而覆盖了包含历史对象的默认道具，会发生什么呢？或者尝试从组件外部访问历史对象呢？</em></p></blockquote><p id="9234" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这些情况下，上述方法不起作用。如果你试图在组件<strong class="kc io">中使用来自<strong class="kc io">的历史，并且你正在使用React 16.8或更高版本</strong>，那么你可以使用<code class="fe ky kz la lb b">useHistory</code>钩子！我将在本文中介绍如何做到这一点。但是，如果您试图从组件外部使用历史，或者您正在使用React的旧版本，您将需要创建自己的历史对象。关于如何做到这一点的文章可以在<a class="ae jz" href="https://medium.com/@bcantello/using-history-to-navigate-your-react-app-from-outside-a-component-40ea74ba4402" rel="noopener">这里</a>找到。</strong></p><p id="3ec4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React Router附带了<code class="fe ky kz la lb b">useHistory</code>钩子，它允许我们访问路由器的状态，以便从组件内部进行导航。钩子必须在组件内部使用。这就是他们的工作方式。只要您符合这个标准，您就可以导入<code class="fe ky kz la lb b">useHistory</code>钩子并使用它来导航，如下例所示。</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="5a70" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样！在这个例子中，我们使用一个文字按钮将<code class="fe ky kz la lb b">/home</code>推入历史堆栈。你不必使用按钮或者让用户直接与你的应用程序交互。也许您有一个登录页面，并希望在预定的时间后自动转到主页。将<code class="fe ky kz la lb b">setTimeout</code>与历史结合起来！</p><figure class="lc ld le lf gt jo"><div class="bz fp l di"><div class="lg lh l"/></div></figure><p id="7c63" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">历史对象中通常包含许多其他属性。在本例中，我们使用了<code class="fe ky kz la lb b">history.push</code>，但是您也可以使用:</p><ul class=""><li id="965d" class="lp lq in kc b kd ke kh ki kl lr kp ls kt lt kx lu lv lw lx bi translated"><code class="fe ky kz la lb b">length</code> -(数字)历史堆栈中条目的数量</li><li id="03ed" class="lp lq in kc b kd ly kh lz kl ma kp mb kt mc kx lu lv lw lx bi translated"><code class="fe ky kz la lb b">action</code> -(字符串)当前动作(<code class="fe ky kz la lb b">PUSH</code>、<code class="fe ky kz la lb b">REPLACE</code>或<code class="fe ky kz la lb b">POP</code>)</li><li id="cf5a" class="lp lq in kc b kd ly kh lz kl ma kp mb kt mc kx lu lv lw lx bi translated"><code class="fe ky kz la lb b">push(path, [state])</code> -(函数)将新条目推入历史堆栈</li><li id="c97d" class="lp lq in kc b kd ly kh lz kl ma kp mb kt mc kx lu lv lw lx bi translated"><code class="fe ky kz la lb b">replace(path, [state])</code> -(函数)替换历史堆栈中的当前条目</li><li id="0f1a" class="lp lq in kc b kd ly kh lz kl ma kp mb kt mc kx lu lv lw lx bi translated"><code class="fe ky kz la lb b">go(n)</code> -(函数)通过<code class="fe ky kz la lb b">n</code>条目移动历史堆栈中的指针</li><li id="4de7" class="lp lq in kc b kd ly kh lz kl ma kp mb kt mc kx lu lv lw lx bi translated"><code class="fe ky kz la lb b">goBack()</code> -(功能)相当于<code class="fe ky kz la lb b">go(-1)</code></li><li id="9b19" class="lp lq in kc b kd ly kh lz kl ma kp mb kt mc kx lu lv lw lx bi translated"><code class="fe ky kz la lb b">goForward()</code> -(功能)相当于<code class="fe ky kz la lb b">go(1)</code></li><li id="a51e" class="lp lq in kc b kd ly kh lz kl ma kp mb kt mc kx lu lv lw lx bi translated"><code class="fe ky kz la lb b">block(prompt)</code> -(功能)阻止导航</li></ul><p id="5bec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个列表并不详尽，所以我鼓励你自己更深入地挖掘一下<code class="fe ky kz la lb b">history</code>！如果这种方法不适合您，请确保您使用的是React 16.8或更高版本，并且在组件内部。如果没有，请看我的另一篇关于使用“历史”从组件外部导航React应用的文章。</p></div></div>    
</body>
</html>