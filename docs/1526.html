<html>
<head>
<title>Redux vs. Storeon: An App to App Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Redux与Storeon:应用程序之间的比较</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/redux-vs-storeon-an-app-to-app-comparison-8066c63ad97f?source=collection_archive---------4-----------------------#2020-03-27">https://javascript.plainenglish.io/redux-vs-storeon-an-app-to-app-comparison-8066c63ad97f?source=collection_archive---------4-----------------------#2020-03-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/903e142f8372ade2b702611e80d1e5bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1CkF-ude-7Ydi04V8WXDIg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">An app to app comparison</figcaption></figure><p id="e02c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">长期以来，Redux一直是React应用程序的状态管理库。它可靠、可扩展，而且资源无处不在。</p><p id="6928" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，众所周知，Redux设置往往非常臃肿。编写一个新的action + action creator + reducer三重奏需要大量的代码。</p><p id="c30e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">即使你正确地组织了你的动作和reducers，大量的文件跳转也是正常的。</p><h1 id="667a" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">Storeon: Redux的性感表妹</h1><p id="f62c" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">如果你一直在纠结Redux但是还没有结账离开Storeon，<a class="ae md" href="https://evilmartians.com/chronicles/storeon-redux-in-173-bytes" rel="noopener ugc nofollow" target="_blank"> <em class="me">请阅读这篇文章</em> </a> <em class="me">。</em></p><p id="6605" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Storeon是Redux的更瘦、更快、更简单的表亲。总结一下好处:</p><ul class=""><li id="914b" class="mf mg iq ke b kf kg kj kk kn mh kr mi kv mj kz mk ml mm mn bi translated"><strong class="ke ir">只有173字节</strong>。</li><li id="fa55" class="mf mg iq ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke ir">异步动作内置于</strong>中。</li><li id="d451" class="mf mg iq ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke ir">没有选择器功能要处理。</strong>它只重新呈现订阅了已更改状态的组件。</li><li id="aab7" class="mf mg iq ke b kf mo kj mp kn mq kr mr kv ms kz mk ml mm mn bi translated"><strong class="ke ir">没有将“还原者”和“动作”分开。你可以把所有东西都放在一个地方，同时保持可读性。</strong></li></ul><h1 id="7239" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">基准React应用程序</h1><div class="mt mu mv mw gt ab cb"><figure class="mx jr my mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/6029faf7cacc3b2d9f177cf08116c08b.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*pxvJ6KXiWCj2UTWFqFAitA.png"/></div></figure><figure class="mx jr nd mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/be284aa289f83010295a80bf09224052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*BKYZQastLtx-H_nFkPsrkg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk ne di nf ng">Our Basic Counter App</figcaption></figure></div><p id="f88d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我构建了两次相同的React应用程序:一次由Redux支持，一次由Storeon支持。该应用程序是一个简单的计数器。计数器的每次更新都会遇到一个假api (setTimeout为1秒)，设置按钮的加载状态，更新计数器，然后在“动作历史”列表中记录递减或递增。</p><p id="3cf5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae md" href="https://codesandbox.io/s/react-redux-letkp" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="me">下面是Redux项目</em> </strong> </a>的链接</p><p id="5ff6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae md" href="https://codesandbox.io/s/react-storeon-counter-e5zyo" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="me">这里是Storeon项目的链接</em> </strong> </a></p><h1 id="fca5" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">文件夹结构</h1><p id="d9bc" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我知道这因项目而异，所以您的体验可能会有所不同。有了Redux，把你的动作和reducers组织到文件夹里也不失为一个好主意。</p><p id="a873" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们有一个reducer负责保持计数，<code class="fe nh ni nj nk b">count.js</code>，另一个负责记录历史，<code class="fe nh ni nj nk b">history.js</code>。然后我们将这些减速器组合到我们的<code class="fe nh ni nj nk b">index.js</code>文件中。</p><p id="4ee3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Storeon，正如你将在后面看到的，并不真正需要“动作”和“还原”的分离。使用Storeon，您可以将数据分解到独立的模块中，由于它们的编写方式，您可以拥有一个整洁的文件夹结构。</p><p id="1597" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面是Storeon的文件夹结构与Redux的对比:</p><div class="mt mu mv mw gt ab cb"><figure class="mx jr nl mz na nb nc paragraph-image"><img src="../Images/d7dda9069ecfed0bd43d0c4642d298d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1052/format:webp/1*V6lf6prc4uJ-f35QeQc8eg.png"/></figure><figure class="mx jr nm mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/5605bd8c390f79d7d1aad1b411d1973f.png" data-original-src="https://miro.medium.com/v2/resize:fit:654/format:webp/1*wltXi0KIrukvgotjBaLQCA.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk nn di no ng">Storeon vs. Redux (folder structure)</figcaption></figure></div><p id="84d8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用Storeon，一个模块负责计数，另一个负责历史记录。文件夹结构简单，不言自明。即使你以前从未使用过Storeon，你也可以很快地解决问题。另一方面，Redux在理解文件夹结构之前，需要关于什么构成了一个动作和一个缩减器的上下文。</p><h1 id="6694" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">创建商店</h1><p id="2cd1" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">使用Redux，创建一个包含所有我们想要的东西的存储有点冗长。有了Storeon，事情就简单多了。让我们一起来看看:</p><div class="mt mu mv mw gt ab cb"><figure class="mx jr np mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/323b54d6a5382c9f169bbd54d4b5630c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*QNDK2z4Lp7Tt3hkdIEPVRA.png"/></div></figure><figure class="mx jr nq mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/2cf66e97a685e93068d8b33ec16be221.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*cuW8RawOHIhK48kQAjssvg.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk nr di ns ng">store.js (left: Redux, right: Storeon)</figcaption></figure></div><p id="77d2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Redux中，如果我们想使用redux dev扩展，我们需要<code class="fe nh ni nj nk b">composeWithDevTools</code>和<code class="fe nh ni nj nk b">composeEnhancers</code>。如果我们想要thunk，loggers，analytics middleware等，就需要<code class="fe nh ni nj nk b">applyMiddleware</code>函数。</p><p id="c093" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们从调用<code class="fe nh ni nj nk b">combineReducers</code>的<code class="fe nh ni nj nk b">reducers/index.js</code>导入我们的“根”减速器，以便构建这个单根减速器。它看起来是这样的:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/5b6cf0bdfff2437db489456d53083f1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cLbJ9UOFaP8Y66-vGfS3Ow.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">reducers/index.js</figcaption></figure><p id="7349" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为Storeon处理模块，所以你提供给<code class="fe nh ni nj nk b">createStore</code>的所有东西，包括中间件，都只是一个模块数组！</p><p id="2415" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">此外，Redux dev tools与Storeon一起开箱即用。只需安装redux devtools扩展，并像任何其他模块一样添加devtools中间件。</p><p id="66f5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Storeon的另一个好处是，如果您的模块列表开始变长，您可以通过下面的例子轻松实现自动化(假设您使用的是Webpack):</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/390781d3ff8e1674bd5ce0a2c81400b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HT1BuxEnsNhOR92IAeDi5w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">easy module resolver (assumes modules live in same folder as this function)</figcaption></figure><p id="0bc9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">只要您遵循命名约定<code class="fe nh ni nj nk b">[name].module.js</code>，您就再也不用担心将您的模块连接到您的商店了！</p><p id="3dcf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">一个很好的好处是，我们可以使用redux开发工具扩展和Storeon开箱即用。我们的商店已经设置好，可以由商店提供商使用了。</p><h1 id="1b60" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">商店提供商</h1><p id="8456" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">这里没有明显的区别。</p><div class="mt mu mv mw gt ab cb"><figure class="mx jr nv mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/f2598d644cc0410ffc4b6c09a52a1adc.png" data-original-src="https://miro.medium.com/v2/resize:fit:828/format:webp/1*iA2QblspSoIih87dIR64WA.png"/></div></figure><figure class="mx jr nw mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/9d98dae8fe4bf7ad8e05a3fdccfa2ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*j7OYlIxvPLrIqnHKIZ3xdw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk nx di ny ng">Redux on the left, Storeon on the right</figcaption></figure></div><h1 id="8370" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">动作和减少器(Redux)</h1><p id="20b9" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">正如我们前面在文件夹级别看到的，使用Redux，我们将我们的reducers拆分成单独的文件，然后将它们合并到<code class="fe nh ni nj nk b">/reducers</code>下的<code class="fe nh ni nj nk b">index.js</code>文件中，并导出结果供我们的商店使用。</p><p id="531b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们仔细看看Redux中用于计数的缩减器是如何设置的:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/cb150147c6a81bd501fe8fb41c102a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RzgXYcpdTMoHyevLAg9NSA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">count.js (Redux reducer for our counting state)</figcaption></figure><p id="9a1c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">给你一些上下文，我们基本上只有一些增加和减少计数器的动作，以及一个让UI知道计数器何时“加载”的动作。</p><p id="0408" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Storeon的减速器是什么样子的？</p><p id="7494" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">嗯…如果我向您展示，它会破坏一切，所以请耐心听我展示Redux操作创建器来更新计数器:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/d9a3a1177f6923550ea042f75f65244c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z0BI7g9vUePXH66wAuXP0w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">async action creators (Redux)</figcaption></figure><p id="0682" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你熟悉Thunk中间件，这没什么特别的。</p><ol class=""><li id="1a9c" class="mf mg iq ke b kf kg kj kk kn mh kr mi kv mj kz ob ml mm mn bi translated">我们分派名为<code class="fe nh ni nj nk b">INCREASING</code>和<code class="fe nh ni nj nk b">DECREASING</code>的“加载”动作。</li><li id="da11" class="mf mg iq ke b kf mo kj mp kn mq kr mr kv ms kz ob ml mm mn bi translated">然后我们调用我们的假api(传入等待的秒数),并在承诺完成时分派我们的<code class="fe nh ni nj nk b">INCREMENT</code>或<code class="fe nh ni nj nk b">DECREMENT</code>动作。</li><li id="ebd4" class="mf mg iq ke b kf mo kj mp kn mq kr mr kv ms kz ob ml mm mn bi translated">然后我们调用一个叫做<code class="fe nh ni nj nk b">LOG_HISTORY</code>的动作，我们很快就会看到。</li></ol><p id="319e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您习惯于Redux，这似乎是一个足够简单过程。</p><h1 id="6a72" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">事件和模块(Storeon)</h1><p id="06eb" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">Storeon对你们中的许多人来说是新的，所以我将把它分成小块。我们将首先创建一个模块来处理我们的计数器状态。</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/b0fd8b2e2ef1af102fa80211e8e33fa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRt_lqlUia9R1tHD8Bqe1Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">basic module and state initialization</figcaption></figure><p id="3f80" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用Storeon时，您可以使用事件和模块。模块是我们如何组织状态逻辑的不同部分，我们在这些模块中设置的事件定义了我们如何与外部世界的状态进行交互。</p><ol class=""><li id="de8d" class="mf mg iq ke b kf kg kj kk kn mh kr mi kv mj kz ob ml mm mn bi translated">我们首先创建并导出名为<code class="fe nh ni nj nk b">countModule</code>的模块。Storeon将把存储对象传递给我们传递给<code class="fe nh ni nj nk b">createStore</code>的每个模块，就像我前面展示的那样。</li><li id="e25e" class="mf mg iq ke b kf mo kj mp kn mq kr mr kv ms kz ob ml mm mn bi translated">store对象是我们设置事件和分派动作的方式。Storeon有一些内置事件，比如<code class="fe nh ni nj nk b">@init</code>，这是我们设置初始状态的地方。<a class="ae md" href="https://github.com/storeon/storeon#events" rel="noopener ugc nofollow" target="_blank">查看文档，了解其他内置事件。</a></li></ol><p id="41d3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好了，现在还没有足够的证据来对Redux和Storeon进行比较。让我们添加几个事件，它们将作为Redux术语中的“reducers ”:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nt"><img src="../Images/9a9609138f36b1ca35c590e156036c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vi4729TBtAMlDB6kHu-TlQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Our first action events!</figcaption></figure><p id="62b0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在初始化事件的正下方，我们创建了两个名为<code class="fe nh ni nj nk b">count/increasing</code>和<code class="fe nh ni nj nk b">count/increase</code>的新事件。基本上，这就像我们的“加载与已加载”行为。我们使用路径命名约定<code class="fe nh ni nj nk b">[module-name]/[event-name]</code>来避免名称冲突，因为storeon通过唯一的字符串引用事件(比如Redux reducers)。</p><p id="3e11" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">您可能已经注意到，在Redux的意义上，没有任何“reducers”和“actions”。在Storeon中，我们在Redux中使用它们的方式并没有严格区分这两者。</p><p id="d147" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们的UI中，如果我们调用<code class="fe nh ni nj nk b">store.dispatch('count/increase')</code>，我们的事件将被触发，状态将被更新。</p><p id="f6b5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这太棒了，因为现在我们在一个地方既有我们的“行动”又有“缩减者”，这使得它更容易遵循！</p><h1 id="61ab" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">事件与动作创建者</h1><p id="4483" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">让我们创建一个事件，调用我们刚刚创建的这些“reducer”类事件，然后调用一个api，最后更新我们的计数器。这里有一个截图，左边是我们的Storeon事件，右边是我们的Redux动作创建器:</p><div class="mt mu mv mw gt ab cb"><figure class="mx jr od mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/66a0cedb0fac8a7da190ca6169268d28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1118/format:webp/1*1UEmWVmR_d7bz4jhLKvaig.png"/></div></figure><figure class="mx jr oe mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/c69cc49f6c69ac3f5534d2c4ef538a86.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*OPr7Z7JnlFhSETGKEjIpjw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk of di og ng">Async actions: Storeon vs. Redux</figcaption></figure></div><p id="a3ee" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你觉得哪个看起来更容易理解？Storeon内置了异步事件。不需要中间件。因为我们的事件是在我们的模块中定义的，我们已经在范围中有了<code class="fe nh ni nj nk b">store</code>。</p><p id="c6fe" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">你可能也注意到了，我们不需要用Storeon返回state。我们可以分派负责更新状态的其他事件。同样，所有这些都是现成的。</p><p id="0428" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在第<code class="fe nh ni nj nk b">store.dispatch('history/log', true)</code>行中，我们传递了一个“有效载荷”值，让历史记录器(我们稍后会看到)知道我们增加了一个值，而不是减少了。如果我们愿意，我们可以传递一个数字、一个字符串或一个对象。</p><p id="508d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请记住，Redux操作是完全独立于reducer定义的。我们的行动住在<code class="fe nh ni nj nk b">actions/index.js </code>而我们的缩减者住在<code class="fe nh ni nj nk b">reducers/count.js</code>。这不一定是Redux的要求，但是这个结构让人感觉很受鼓励。另一方面，有了Storeon，我们可以将所有的逻辑放在<code class="fe nh ni nj nk b">count.js</code>中，同时仍然保持所有内容的可读性。</p><h1 id="211f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">模块与减速器</h1><p id="2709" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">我们的<code class="fe nh ni nj nk b">count.js</code>文件有点长，所以我将向您展示一个与<code class="fe nh ni nj nk b">history.js</code>文件并排的文件，这样您可以更好地比较Storeon模块和Redux reducer:</p><div class="mt mu mv mw gt ab cb"><figure class="mx jr oh mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/24f86569a3873e74dd5b198754c37a55.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*UqUy7myQ3e77mO6STok4cA.png"/></div></figure><figure class="mx jr oi mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/1b06f945d3ea75e75e5d55ba43dfd94e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*ftx4LRgMRqDKh4XWhnHppw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk oj di ok ng">history.js (left: Storeon, right: Redux)</figcaption></figure></div><p id="c874" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在直接对比这两个文件也不是100%准确。尽管我们只是在我们的<code class="fe nh ni nj nk b">history/log</code>事件中更新状态，就像Redux中的<code class="fe nh ni nj nk b">LOG_HISTORY</code>动作一样，但我们并不局限于此。我们可以很容易地在我们的<code class="fe nh ni nj nk b">history/log</code>事件下面添加一个触发其他事件的异步事件:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ol"><img src="../Images/6a6660cd72372fd1462e7a03f0a27fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-x9B_mCMW18_nv53Jsc3ZA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Storeon async event (note: this is not apart of the benchmark app)</figcaption></figure><p id="7c1b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用Redux，我们不会这样做。我们的减速器就是我们的减速器，就是这样。因此，当我们需要一些异步功能和多个触发动作时，我们必须在其他地方创建一个thunk。</p><h1 id="a74d" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">选择状态和调度操作</h1><p id="2617" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">幸运的是，React Redux引入了钩子，所以实际上获取状态和分派动作真的不是问题。这是Storeon和Redux的并排图:</p><div class="mt mu mv mw gt ab cb"><figure class="mx jr om mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/2f93ece06d7e0820396e335688e6387c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1086/format:webp/1*XKlMNBSJb8VW8ETGznTY7A.png"/></div></figure><figure class="mx jr on mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/6a821ae021ad5f8c8798597435744352.png" data-original-src="https://miro.medium.com/v2/resize:fit:916/format:webp/1*YiIHf_w79eq0txIyD4120Q.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk oo di op ng">Storeon vs. Redux</figcaption></figure></div><p id="9841" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Storeon在左边，我们只需要指定从state中提取的变量的名称。这让Storeon知道组件需要监听状态的哪一部分进行更新，同时也防止了不必要的重新呈现。我们也可以直接从<code class="fe nh ni nj nk b">useStoreon</code>中拉出调度功能。</p><p id="a324" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">redux在右边，我们进行一个单独的<code class="fe nh ni nj nk b">useDispatch</code>调用来获得调度函数。我们还需要一个选择器函数来确定返回哪个状态片段。这需要一些小心的处理来确保我们没有订阅我们不需要的状态。我们还可以传递一个比较函数，在本例中是<code class="fe nh ni nj nk b">shallowEqual</code>。</p><div class="mt mu mv mw gt ab cb"><figure class="mx jr oq mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/d5d6b4e6e5421d7dd446478111887a40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/format:webp/1*d9nQwFFYfVtPm6icsJwKCQ.png"/></div></figure><figure class="mx jr or mz na nb nc paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/94f361c1ba93af807eccac73b2cba0d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:962/format:webp/1*AWhglHZniLm8M0yhYH2m6w.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk os di ot ng">The button to increment our counter</figcaption></figure></div><p id="c86c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这里很相似。Storeon的一个好处是我们不需要像Redux版本那样导入任何东西。我们通过它的事件名来调度它，传递我们需要的任何值，就这样。</p><p id="dc99" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">也就是说，您可能希望至少从您的模块中导出事件名称，这样您就不必在每次更改名称时都更新引用。</p><h1 id="6c07" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">资源和文档</h1><p id="6f66" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">没有可比性。你所有的冗余问题可能都已经被问过和回答过了。文档非常丰富。另一方面，Storeon除了它的Github文档、一些Github问题和几篇文章(不包括这篇文章)之外没有更多的东西。</p><h1 id="56ad" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">以打字打的文件</h1><p id="8b56" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">Storeon附带了TypeScript声明！由于Storeon的简单性，为模块和状态创建类型比用TS编写的典型Redux应用程序要少得多。</p><h1 id="e5b1" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">哪个更好？</h1><p id="a883" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">你可以看出我非常倾向于Storeon。它是轻量级的，很容易上手，可读性很强，很容易组织，并且解决了Redux普遍存在的许多问题。</p><p id="5e41" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">也就是说，我意识到我用一个玩具应用程序来比较这两者。</p><p id="f95a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于需要细粒度性能调优、良好支持的库以及大量学习资源、扩展和开发人员的大规模应用程序，Redux显然是赢家。</p><p id="3ccd" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Storeon在大型应用程序上测试之前，很难确切地说出它与Redux相比有多有限(或多强大)。</p><p id="9941" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然而，如果您厌倦了在构建中小型应用程序时使用Redux带来的麻烦，Storeon可能是您一直在寻找的金矿。</p><p id="c197" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">这是判决结果</strong></p><p id="cc72" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="me">这取决于你的项目！如果你有一个中小型的网络应用，试试Storeon吧。你不会后悔的。如果您正在从事一个大型项目，Redux可能是目前更安全的选择。</em></p><h1 id="a2e5" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">最后的话</h1><p id="5e7b" class="pw-post-body-paragraph kc kd iq ke b kf ly kh ki kj lz kl km kn ma kp kq kr mb kt ku kv mc kx ky kz ij bi translated">随着我对Storeon越来越熟悉，以后我会写更多关于它的内容。我在当前的项目中使用这两个状态管理库，到目前为止，我还没有找到一个理由<em class="me">不</em>切换到Storeon。</p></div><div class="ab cl ou ov hu ow" role="separator"><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz pa"/><span class="ox bw bk oy oz"/></div><div class="ij ik il im in"><p id="2edf" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你喜欢这样的文章，请分享给你的开发者朋友！也可以<a class="ae md" href="https://www.instagram.com/krisguzman_dev/" rel="noopener ugc nofollow" target="_blank">在instagram上找我。</a></p></div></div>    
</body>
</html>