<html>
<head>
<title>5 Tips to Perfect React Testing Library Queries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">完善反应测试库查询的5个技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-tips-to-perfect-react-testing-library-queries-ae4e49f27858?source=collection_archive---------2-----------------------#2020-11-04">https://javascript.plainenglish.io/5-tips-to-perfect-react-testing-library-queries-ae4e49f27858?source=collection_archive---------2-----------------------#2020-11-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="21cd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我的策略是用测试库API检索任何元素</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/0ca495117734a5ff56a4968cf3fb7fea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vjv7tY-ywCQ5uyVO"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@kmitchhodge?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">K. Mitch Hodge</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e1f7" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">我的旅程</h1><p id="e9e8" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在我开始用测试库测试组件交互之后，我很快意识到最困难的任务是检索正确的DOM元素。这是测试的关键途径。毕竟，如果你不能查询你想测试的东西，你就不能测试它！我学到的第一件事是<code class="fe mh mi mj mk b">getByText</code>并且它覆盖了大量的测试用例。但是很快，当我继续测试更复杂的组件时，还不够好。通过我所有的考验和磨难，这已经成为我的查询策略。</p><h1 id="74a8" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">1.屏幕调试</h1><p id="1d22" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">测试库的<code class="fe mh mi mj mk b">screen.debug</code>是我提出查询的工具。我可以使用Testing Library的日志记录工具，立即在控制台中记录一个美化的DOM树，其中包含所有元素属性，而不是看代码并想象它是如何在我的大脑中的DOM上表示的。直观地看到这一切，有助于我快速制定查询策略。默认情况下，它将记录<code class="fe mh mi mj mk b">document.body</code>。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="3606" class="mp ku in mk b gy mq mr l ms mt">import { render, screen } from '<a class="ae ks" href="http://twitter.com/testing" rel="noopener ugc nofollow" target="_blank">@testing</a>-library/react';</span><span id="61fe" class="mp ku in mk b gy mu mr l ms mt">test('screen debug default', () =&gt; {<br/>  render(<br/>    &lt;div role="group"&gt;<br/>      &lt;button className="secondary"&gt;Secondary&lt;/button&gt;<br/>      &lt;button className="primary"&gt;Primary&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>  screen.debug();<br/>  // output:<br/>  //   &lt;body&gt;<br/>  //     &lt;div&gt;<br/>  //       &lt;div role="group"&gt;<br/>  //         &lt;button className="secondary"&gt;<br/>  //           Secondary<br/>  //         &lt;/button&gt;<br/>  //         &lt;button className="primary"&gt;<br/>  //           Primary<br/>  //         &lt;/button&gt;<br/>  //       &lt;/div&gt;<br/>  //     &lt;/div&gt;<br/>  //   &lt;/body&gt;<br/>});</span></pre><p id="ac13" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><code class="fe mh mi mj mk b">screen.debug</code>还接受一个DOM元素来专门记录该元素。这对于快速验证查询是否如预期那样工作非常有用。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="5f0f" class="mp ku in mk b gy mq mr l ms mt">test('screen debug element', () =&gt; {<br/>  render(<br/>    &lt;div role="group"&gt;<br/>      &lt;button className="secondary"&gt;Secondary&lt;/button&gt;<br/>      &lt;button className="primary"&gt;Primary&lt;/button&gt;<br/>    &lt;/div&gt;<br/>  );<br/>  screen.debug(document.querySelector('.primary'));<br/>  // output:<br/>  //   &lt;button className="primary"&gt;<br/>  //     Primary<br/>  //   &lt;/button&gt;<br/>});</span></pre><h1 id="dbcc" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">2.按文本查询</h1><p id="b541" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">按文本查询返回一个基于文本内容的元素，这是我最常用的查询。它是我默认的查询方法，不仅因为它易于理解和使用，还因为它非常接近地模拟了web应用程序上的实际用户行为和交互。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="4a47" class="mp ku in mk b gy mq mr l ms mt">import { render } from '@testing-library/react';</span><span id="18e1" class="mp ku in mk b gy mu mr l ms mt">test('should return element based on its text', () =&gt; {<br/>  const { getByText } = render(&lt;button&gt;Button&lt;/button&gt;);<br/>  expect(getByText('Button')).toMatchInlineSnapshot(`<br/>    &lt;button&gt;<br/>      Button<br/>    &lt;/button&gt;<br/>  `);<br/>});</span></pre><h1 id="bdf5" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">3.按标签文本查询</h1><p id="3a13" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">按标签文本查询返回基于相关标签元素文本内容或<code class="fe mh mi mj mk b">aria-label</code>属性的元素。这个查询方法实际上依赖于实现，因为它需要一个幕后关联。它将根据其文本内容找到一个标签元素(类似于通过文本进行查询)，找到与该标签相关联的输入元素，并返回该输入元素。这种关联可以通过嵌套来完成</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="b04a" class="mp ku in mk b gy mq mr l ms mt">test('should return element based label nesting', () =&gt; {<br/>  const { getByLabelText } = render(<br/>    &lt;label&gt;<br/>     Field<br/>     &lt;input /&gt;<br/>   &lt;/label&gt;<br/> );<br/> expect(getByLabelText('Field')).toMatchInlineSnapshot(`&lt;input /&gt;`);<br/>});</span></pre><p id="2907" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">通过<code class="fe mh mi mj mk b">htmlFor</code></p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="d1a9" class="mp ku in mk b gy mq mr l ms mt">test('should return element based on label htmlFor', () =&gt; {<br/>  const { getByLabelText } = render(<br/>   &lt;&gt;<br/>    &lt;label htmlFor="field"&gt;Field&lt;/label&gt;<br/>    &lt;input id="field" /&gt;<br/>   &lt;/&gt;<br/> );<br/> expect(getByLabelText('Field')).toMatchInlineSnapshot(`<br/>   &lt;input<br/>     id="field"<br/>   /&gt;<br/>  `);<br/>});</span></pre><p id="9447" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">或通过<code class="fe mh mi mj mk b">aria-labelledby</code>。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="4312" class="mp ku in mk b gy mq mr l ms mt">test('should return element based on label aria-labelledby', () =&gt; {<br/>  const { getByLabelText } = render(<br/>   &lt;&gt;<br/>     &lt;label id="field"&gt;Field&lt;/label&gt;<br/>     &lt;input aria-labelledby="field" /&gt;<br/>   &lt;/&gt;<br/> );<br/> expect(getByLabelText('Field')).toMatchInlineSnapshot(`<br/>    &lt;input<br/>      aria-labelledby="field"<br/>    /&gt;<br/>  `);<br/>});</span></pre><p id="f52d" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">由于这种特定的实现需求，使用起来有点困难。但这是我的第二个直接查询方法的真正原因是因为它也可以基于<code class="fe mh mi mj mk b">aria-label</code>属性进行查询，这可以是您想要的任何属性(当然在合理的范围内)。这不仅使测试查询更容易，而且有助于可访问性。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="6ab2" class="mp ku in mk b gy mq mr l ms mt">test('should return element based on its aria-label', () =&gt; {<br/>  const { getByLabelText } = render(&lt;div aria-label="label" /&gt;);<br/>  expect(getByLabelText('label')).toMatchInlineSnapshot(`<br/>    &lt;div<br/>      aria-label="label"<br/>    /&gt;<br/> `);<br/>});</span></pre><h1 id="6b5f" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">4.按角色查询</h1><p id="6e94" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">这会根据元素的<code class="fe mh mi mj mk b">role</code>属性返回一个元素。像通过<code class="fe mh mi mj mk b">aria-label</code>查询一样，通过角色查询有助于测试和可访问性。唯一的区别是，角色有相当<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques" rel="noopener ugc nofollow" target="_blank">明确定义的价值观</a>，因此不太灵活。尽管如此，它是我的下一个首选查询方法，因为它在测试和可访问性方面有双重作用。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="a467" class="mp ku in mk b gy mq mr l ms mt">test('should return element based on its role', () =&gt; {<br/> const { getByRole } = render(&lt;div role="button" /&gt;);<br/> expect(getByRole('button')).toMatchInlineSnapshot(`<br/>   &lt;div<br/>     role="button"<br/>   /&gt;<br/> `);<br/>});</span></pre><h1 id="6b0b" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">5.在…之内</h1><p id="7eb8" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">测试库的<code class="fe mh mi mj mk b">within</code>允许你使用嵌套查询。如果给定查询返回多个元素，这将非常有用。您不是立即查询想要测试的元素，而是将它分解成多个查询，每个查询都建立在前一个查询的基础上，直到您可以唯一地查询所需的元素。<code class="fe mh mi mj mk b">within</code>将测试库查询绑定到一个DOM元素，这样您就可以执行子查询。</p><pre class="kd ke kf kg gt ml mk mm mn aw mo bi"><span id="c9c5" class="mp ku in mk b gy mq mr l ms mt">import { render, within } from '@testing-library/react';</span><span id="ff57" class="mp ku in mk b gy mu mr l ms mt">test('should return element based on its role', () =&gt; {<br/>  const { getAllByRole } = render(<br/>    &lt;table&gt;<br/>      &lt;tbody&gt;<br/>        &lt;tr role="row"&gt;<br/>          &lt;td&gt;Cell&lt;/td&gt;<br/>        &lt;/tr&gt;<br/>        &lt;tr role="row"&gt;<br/>          &lt;td&gt;Cell&lt;/td&gt;<br/>        &lt;/tr&gt;<br/>        &lt;tr role="row"&gt;<br/>          &lt;td&gt;Else&lt;/td&gt;<br/>        &lt;/tr&gt;<br/>      &lt;/tbody&gt;<br/>    &lt;/table&gt;<br/>  );<br/>  const [row1, row2, row3] = getAllByRole('row');<br/>  expect(within(row1).getByText('Cell')).toBeTruthy();<br/>  expect(within(row2).getByText('Cell')).toBeTruthy();<br/>  expect(within(row3).queryByText('Cell')).toBeNull();<br/>});</span></pre><h1 id="e87e" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">额外收获:Chrome扩展</h1><p id="2d88" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">为了使查询更加容易，chrome有几个扩展可以自动完成这项工作。</p><p id="6614" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><a class="ae ks" href="https://chrome.google.com/webstore/detail/testing-library-which-que/olmmagdolfehlpjmbkmondggbebeimoh/related?hl=en-US" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io">测试库:哪个查询</strong> </a>是chrome扩展，当你通过右键菜单或者元素检查器工具选择一个元素时，会自动生成基本查询。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/828b77f0055cb90cb99387f308745c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YdBG2xOneboaRi2hEp0ACQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Testing Library: which query Chrome Extension</figcaption></figure><p id="84d1" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated"><a class="ae ks" href="https://chrome.google.com/webstore/detail/testing-playground/hejbmebodbijjdhflfknehhcgaklhano" rel="noopener ugc nofollow" target="_blank"><strong class="ln io">Testing Playground</strong></a>是chrome的另一个扩展，它做了类似的事情，但通过显示额外的数据来增强查询构建过程，这些数据可以帮助您更好地理解查询，例如美化的DOM树、有用的可查询属性以及针对所选元素的更好的查询建议。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nb"><img src="../Images/e675ccbac6582fd2fbbdb33a87fe6529.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V9Q8ODTFPlhrEVN9Ac3Dkg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Testing Playground Chrome Extension</figcaption></figure><p id="33e7" class="pw-post-body-paragraph ll lm in ln b lo mv jo lq lr mw jr lt lu mx lw lx ly my ma mb mc mz me mf mg ig bi translated">当然，一定要验证这些生成的查询，以确保它们完全按照预期工作！</p></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><h1 id="fd1f" class="kt ku in bd kv kw nj ky kz la nk lc ld jt nl ju lf jw nm jx lh jz nn ka lj lk bi translated">最后的想法</h1><p id="41ee" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">测试库是一个非常棒的组件交互测试库，它让测试变得更加容易和容易。即便如此，查询要测试的正确元素仍然具有挑战性。根据我的经验，这五个策略可以帮助您为任何可能的场景生成查询。最重要的是，你可以使用chrome扩展来自动完成大部分工作。现在去测试吧——你再也没有借口了！</p></div><div class="ab cl nc nd hr ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ig ih ii ij ik"><h1 id="fa97" class="kt ku in bd kv kw nj ky kz la nk lc ld jt nl ju lf jw nm jx lh jz nn ka lj lk bi translated">资源</h1><ul class=""><li id="0172" class="no np in ln b lo lp lr ls lu nq ly nr mc ns mg nt nu nv nw bi translated"><a class="ae ks" href="https://testing-library.com/docs/intro" rel="noopener ugc nofollow" target="_blank">官方测试库文档</a></li><li id="8940" class="no np in ln b lo nx lr ny lu nz ly oa mc ob mg nt nu nv nw bi translated"><a class="ae ks" href="https://medium.com/javascript-in-plain-english/interaction-testing-with-react-testing-library-d824f74ce48a" rel="noopener">交互测试指南</a></li><li id="17e4" class="no np in ln b lo nx lr ny lu nz ly oa mc ob mg nt nu nv nw bi translated"><a class="ae ks" href="https://github.com/mjchang/medium/tree/master/testing-library-queries" rel="noopener ugc nofollow" target="_blank"> Github回购本文</a></li><li id="cdcf" class="no np in ln b lo nx lr ny lu nz ly oa mc ob mg nt nu nv nw bi translated"><a class="ae ks" href="https://codesandbox.io/s/github/mjchang/medium/tree/master/testing-library-queries?file=/src/demo.test.js" rel="noopener ugc nofollow" target="_blank">本文的CodeSandbox】</a></li></ul></div></div>    
</body>
</html>