<html>
<head>
<title>Best of Modern JavaScript — New Data Structures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华—新的数据结构</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-new-data-structures-bb7b722c8fd3?source=collection_archive---------9-----------------------#2020-10-27">https://javascript.plainenglish.io/best-of-modern-javascript-new-data-structures-bb7b722c8fd3?source=collection_archive---------9-----------------------#2020-10-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/43ea14a12682638a53d7ad64c2c70348.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IQJCHHMYR2vsoloz"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@siora18?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Siora Photography</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="403b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何控制数组、贴图和集合的可扩展性。</p><h1 id="f14e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">Symbol.isConcatSpreadable</code></h1><p id="6db0" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">Symbol.isConcatSpreadable</code>不是ES6标准库中任何对象的一部分。</p><p id="5306" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种机制纯粹是为浏览器API和用户代码而存在的。</p><p id="8d19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着默认情况下<code class="fe lz ma mb mc b">Array</code>的子类是分散的。</p><p id="f693" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Array</code>的子类可以通过将<code class="fe lz ma mb mc b">Symbol.isConcatSpreadable</code>设置为<code class="fe lz ma mb mc b">fale</code>来防止实例传播。</p><p id="1cc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该属性可以是实例或原型属性。</p><p id="39cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe lz ma mb mc b">Symbol.isConcatSpreadable</code>为<code class="fe lz ma mb mc b">true</code>，则其他数组状对象按<code class="fe lz ma mb mc b">concat</code>展开。</p><p id="e4d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们可以为一些类似数组的对象打开扩散。</p><p id="8f95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类型化数组不是分散的，它们没有<code class="fe lz ma mb mc b">concat</code>实例方法。</p><h1 id="1d90" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">数组索引的范围</h1><p id="541a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">对于数组索引范围，ES6遵循与ES5相同的规则。</p><p id="8412" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">长度在0和<code class="fe lz ma mb mc b">2 ** 32 — 1</code>之间。</p><p id="19c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">索引在0和<code class="fe lz ma mb mc b">2 ** 32 — 1</code>之间。</p><p id="30e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">字符串和类型化数组的索引范围更大。</p><p id="44a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">范围的上限是因为<code class="fe lz ma mb mc b">2 ** 53 — 1</code>是JavaScript幸灾乐祸点数可以安全表示的最大整数。</p><h1 id="32c5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">地图和集合</h1><p id="9007" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">地图和集合是ES6引入的新数据结构。</p><p id="de6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">地图可以有任意值。它们被存储为键值对。</p><p id="04a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用具有<code class="fe lz ma mb mc b">[key, value]</code>对的条目的<code class="fe lz ma mb mc b">Array</code>来设置初始数据。</p><p id="9231" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="61c7" class="mq lc iq mc b gy mr ms l mt mu">const map = new Map([<br/>  [1, 'foo'],<br/>  [2, 'bar'],<br/>  [3, 'baz'],<br/>]);</span></pre><p id="b5a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将一个键值对数组传递给<code class="fe lz ma mb mc b">Map</code>构造函数来创建我们的映射。</p><p id="eddf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">集合是唯一元素的集合。</p><p id="963f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe lz ma mb mc b">Set</code>构造函数创建一个集合。</p><p id="c9a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3091" class="mq lc iq mc b gy mr ms l mt mu">const arr = [2, 3, 5, 6, 6, 6, 2];<br/>const unique = [...new Set(arr)];</span></pre><p id="ef71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe lz ma mb mc b">unique</code>是数组<code class="fe lz ma mb mc b">[2, 3, 5, 6]</code>。</p><p id="cc24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于删除数组中的重复元素很有用。</p><p id="3869" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">弱映射是不阻止其键被垃圾收集的映射。</p><p id="e222" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们在使用它时将不必担心内存泄漏。</p><h1 id="b8c9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">地图</h1><p id="f3f3" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">用ES5或更早的版本没有好的方法来创建键值对对象。</p><p id="9460" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的方法是创建一个对象文字，并将其用作映射。</p><p id="87f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于ES6，我们有了<code class="fe lz ma mb mc b">Map</code>构造函数。</p><p id="eb82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建地图，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="6193" class="mq lc iq mc b gy mr ms l mt mu">const map = new Map();<br/>map.set('foo', 'bar');</span></pre><p id="c7b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe lz ma mb mc b">Map</code>构造函数创建地图。</p><p id="5994" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe lz ma mb mc b">set</code>方法，将键和值作为参数，用条目添加或更新映射。</p><p id="7e79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果带有该键的条目已经存在，它将被覆盖。</p><p id="45a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">get</code>方法让我们在给定键的情况下获取项目。</p><p id="a835" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="1c52" class="mq lc iq mc b gy mr ms l mt mu">const foo = map.get('foo');</span></pre><p id="9786" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了<code class="fe lz ma mb mc b">'bar'</code>。</p><p id="a584" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">has</code>方法让我们检查具有给定键的条目是否存在。</p><p id="415a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="e2ab" class="mq lc iq mc b gy mr ms l mt mu">const hasFoo = map.has('foo');</span></pre><p id="f446" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe lz ma mb mc b">hasFoo</code>就是<code class="fe lz ma mb mc b">true</code>。</p><p id="f028" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">delete</code>方法让我们删除带有给定键的条目，</p><p id="6d38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="43de" class="mq lc iq mc b gy mr ms l mt mu">map.delete('foo')</span></pre><p id="2eb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用键<code class="fe lz ma mb mc b">'foo'</code>删除条目。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/cd723a5ab6bdddf8a7985d2fbc616317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ArsG6PzEYcwDScIY"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@srinii?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Srinivasan Venkataraman</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a668" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="103d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以控制一个对象是否可以用带有<code class="fe lz ma mb mc b">Symbol.isConcatSpreadable</code>属性的<code class="fe lz ma mb mc b">Array.prototype.concat</code>方法扩展。</p><p id="f667" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">映射和集合是ES6引入的有用的数据结构。</p><p id="5536" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>