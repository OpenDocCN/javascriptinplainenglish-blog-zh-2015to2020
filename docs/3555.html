<html>
<head>
<title>How to use Vue Lifecycle Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Vue生命周期挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/vue-lifecycle-hooks-75d296e7ef8?source=collection_archive---------5-----------------------#2020-10-08">https://javascript.plainenglish.io/vue-lifecycle-hooks-75d296e7ef8?source=collection_archive---------5-----------------------#2020-10-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c991" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第1部分:创建前、装载前、更新前、卸载前</h2></div><h1 id="7699" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated"><strong class="ak">简介</strong></h1><p id="68dc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">根据最新的<a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#lifecycle-hooks" rel="noopener ugc nofollow" target="_blank">Vue官方文档</a>显示<strong class="kw io"> Vue的生命周期挂钩</strong>有<strong class="kw io"> 13 </strong>。创建的每个Vue实例都将经历生命周期挂钩。以下是本文将解释的Vue的生命周期挂钩:</p><ul class=""><li id="7ff2" class="lr ls in kw b kx lt la lu ld lv lh lw ll lx lp ly lz ma mb bi translated">创建前和创建后</li><li id="b196" class="lr ls in kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">安装前和安装后</li><li id="d77f" class="lr ls in kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">更新前和更新后</li><li id="1488" class="lr ls in kw b kx mc la md ld me lh mf ll mg lp ly lz ma mb bi translated">卸载前和卸载后</li></ul><p id="1666" class="pw-post-body-paragraph ku kv in kw b kx lt jo kz la lu jr lc ld mh lf lg lh mi lj lk ll mj ln lo lp ig bi translated"><code class="fe mk ml mm mn b"><em class="mo">destroyed</em></code><em class="mo"/><code class="fe mk ml mm mn b"><em class="mo">beforeDestroy</em></code><em class="mo">生命周期钩子(Vue.js 3.0.0+中)已弃用。</em></p><p id="247f" class="pw-post-body-paragraph ku kv in kw b kx lt jo kz la lu jr lc ld mh lf lg lh mi lj lk ll mj ln lo lp ig bi translated">在<a class="ae lq" href="https://medium.com/@eng5128/vue-lifecycle-hooks-part-2-16ccfd2516de" rel="noopener"> <strong class="kw io">第二部分</strong> </a> <strong class="kw io"> </strong>中解释了另外5个<strong class="kw io"> Vue的生命周期</strong>钩子，其中包括激活、停用、错误捕获、渲染跟踪和渲染触发<strong class="kw io">。</strong></p><h2 id="6b9c" class="mp kd in bd ke mq mr dn ki ms mt dp km ld mu mv ko lh mw mx kq ll my mz ks na bi translated"><strong class="ak">创建前和创建后</strong></h2><p id="4932" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">Vue在这两个阶段声明并知道数据属性。在渲染Vue组件之前，我们可以在<code class="fe mk ml mm mn b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#created" rel="noopener ugc nofollow" target="_blank">created</a></code>钩子中从服务器端获取数据。区别在于<code class="fe mk ml mm mn b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#beforecreate" rel="noopener ugc nofollow" target="_blank">beforeCreated</a></code>钩子是在实例完全初始化之前，而<code class="fe mk ml mm mn b">created</code>钩子是在实例创建之后。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/177f619b62fc7094569ce2a0c7b8f047.png" data-original-src="https://miro.medium.com/v2/resize:fit:946/format:webp/1*GUBwv1H2S3dbdBcRcJh29Q.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">beforeCreate and created</figcaption></figure><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/38b2c62cb20b8cf7a29870ed65043bdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1140/format:webp/1*0tRGuSGgXxtxR3dsyedZTw.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Output in the browser</figcaption></figure><h2 id="1d19" class="mp kd in bd ke mq mr dn ki ms mt dp km ld mu mv ko lh mw mx kq ll my mz ks na bi translated"><strong class="ak">安装前和安装后</strong></h2><p id="3335" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe mk ml mm mn b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#beforemount" rel="noopener ugc nofollow" target="_blank">beforeMount</a></code> hook开始编译并渲染HTML模板。Vue基于我们的HTML代码结合数据属性创建一个模板，并使用这个模板创建真正的HTML代码，然后在<code class="fe mk ml mm mn b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#mounted" rel="noopener ugc nofollow" target="_blank">mounted</a></code>钩子中呈现为DOM。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi no"><img src="../Images/26842b329120cb8648fdd627631f6c0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*_iYYpUzYavXCyZBGuUIt4Q.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">beforeMount and mounted</figcaption></figure><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi np"><img src="../Images/3b83afdcda88643618661898c0b81f9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*AwoIGWkXBGZZxhHQG1vk6w.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Output in the browser</figcaption></figure><h2 id="d487" class="mp kd in bd ke mq mr dn ki ms mt dp km ld mu mv ko lh mw mx kq ll my mz ks na bi translated">更新前和更新后</h2><p id="b6fb" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">某个时间点的数据更改将触发新的生命周期。我们可以在<code class="fe mk ml mm mn b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#beforeupdate" rel="noopener ugc nofollow" target="_blank">beforeUpdate</a></code>钩子中的任何更新之前访问旧的DOM，并在<code class="fe mk ml mm mn b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#updated" rel="noopener ugc nofollow" target="_blank">updated</a></code>钩子中显示最终的变化。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/13c8214072611cf05b2e490921ca01f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:798/format:webp/1*U0cvO9RgQk7TMgnbH03u2Q.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">beforeUpdate and updated</figcaption></figure><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/1353ba33031d8b5e9460f0e83e7ee7fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1156/format:webp/1*JQImt_lUh_aXAHSBLzCrOA.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Output in the browser</figcaption></figure><p id="b634" class="pw-post-body-paragraph ku kv in kw b kx lt jo kz la lu jr lc ld mh lf lg lh mi lj lk ll mj ln lo lp ig bi translated"><em class="mo">为什么</em> <strong class="kw io"> <em class="mo">这个。$el.wholeText </em> </strong> <em class="mo">是否使用？</em> <strong class="kw io"> <em class="mo">这个。$el </em> </strong> <em class="mo">已经变成了</em> <strong class="kw io"> <em class="mo">文本</em> </strong> <em class="mo">对象，因为按钮元素被添加到了DOM中。</em></p><h2 id="733b" class="mp kd in bd ke mq mr dn ki ms mt dp km ld mu mv ko lh mw mx kq ll my mz ks na bi translated">卸载前和卸载后</h2><p id="3af9" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">使用<code class="fe mk ml mm mn b">vm.unmount('#app')</code>时，Vue会触发另外两个新的生命周期。我们仍然可以在<code class="fe mk ml mm mn b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#beforeunmount" rel="noopener ugc nofollow" target="_blank">beforeUnmount</a></code>钩子上访问DOM。当到达<code class="fe mk ml mm mn b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#unmounted" rel="noopener ugc nofollow" target="_blank">unmounted</a></code>钩子时，Vue将删除实例，DOM在浏览器中消失，包括子组件。但是，数据属性仍然存在，但无法访问。</p><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/8e948cc2ec27511f344df8371a09bd9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:838/format:webp/1*r2kNdFrSxNnBj5mgHOVfhg.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">beforeUnmount and unmounted</figcaption></figure><figure class="nc nd ne nf gt ng gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/6d1694e5cafa2c2c3f33bed16fbd5b27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1150/format:webp/1*n-qKLpxL_DdaM20hM1lEDQ.png"/></div><figcaption class="nj nk gj gh gi nl nm bd b be z dk">Output in the browser after 3 seconds</figcaption></figure><h1 id="9b41" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">结论</h1><p id="69bc" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">当到达每个生命周期挂钩时，我们可以使用断点来暂停代码。一些生命周期挂钩对于代码开发来说不是必需的，但是对它有一个基本的理解是很重要的。</p><p id="4f4f" class="pw-post-body-paragraph ku kv in kw b kx lt jo kz la lu jr lc ld mh lf lg lh mi lj lk ll mj ln lo lp ig bi translated">在<a class="ae lq" href="https://medium.com/@eng5128/vue-lifecycle-hooks-part-2-16ccfd2516de" rel="noopener"> <strong class="kw io">第2部分</strong> </a> <strong class="kw io"> </strong>中解释了另外5个<strong class="kw io"> Vue的生命周期</strong>钩子，包括激活、停用、错误捕获、渲染跟踪和渲染触发<strong class="kw io">。</strong></p><p id="07f2" class="pw-post-body-paragraph ku kv in kw b kx lt jo kz la lu jr lc ld mh lf lg lh mi lj lk ll mj ln lo lp ig bi translated">谢谢你。</p></div></div>    
</body>
</html>