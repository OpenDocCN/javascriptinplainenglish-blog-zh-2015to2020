<html>
<head>
<title>JavaScript Best Practices for Writing More Robust Code — Good and Bad Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更健壮代码的JavaScript最佳实践——好的和不好的特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-for-writing-more-robust-code-good-and-bad-features-b5bd0e7a5126?source=collection_archive---------14-----------------------#2020-05-02">https://javascript.plainenglish.io/javascript-best-practices-for-writing-more-robust-code-good-and-bad-features-b5bd0e7a5126?source=collection_archive---------14-----------------------#2020-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f6506774b81764d882a79c1bb80fc1be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vrgqkkrJOlH6sGkW"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@zmachacek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zdeněk Macháček</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5561" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="d508" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看JavaScript的一些好特性，我们应该用它们来编写健壮的JavaScript代码。</p><h1 id="2cbc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用===代替==</h1><p id="c650" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在JavaScript中，有用于确定两个实体相等的<code class="fe me mf mg mh b">===</code>和<code class="fe me mf mg mh b">==</code>操作符。</p><p id="d787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">==</code>在对类型的两个操作数进行比较之前，通过遵循一长串规则来强制类型。</p><p id="8003" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，<code class="fe me mf mg mh b">===</code>在比较操作数之前不做任何数据类型强制。</p><p id="5234" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得<code class="fe me mf mg mh b">===</code>变得更好，因为JavaScript的数据类型强制会产生我们意想不到的奇怪结果。</p><p id="2eb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">==</code>操作符会导致类似于<code class="fe me mf mg mh b">0 == false</code>返回<code class="fe me mf mg mh b">true</code>的表达式。</p><p id="19c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不想因为在代码中保存一个字符而使事情变得更加困难，所以我们应该总是使用<code class="fe me mf mg mh b">===</code>来进行相等比较。</p><p id="1797" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，为了检查不相等性，我们应该使用<code class="fe me mf mg mh b">!==</code>操作符，在比较其操作数的不相等性之前，它也不进行任何数据类型强制。</p><h1 id="6a52" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从不使用Eval</h1><p id="d62c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">eval</code>让我们运行嵌入在字符串中的代码。这意味着理论上，任何用户都可以运行任何东西，只要他们可以设置我们传递给<code class="fe me mf mg mh b">eval</code>的字符串的值。</p><p id="020e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">eval</code>中的代码在全局范围内运行，所以如果我们让任何东西用<code class="fe me mf mg mh b">eval</code>运行，它会产生很大的影响。</p><p id="6567" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该不惜一切代价避免这种情况。此外，它降低了我们的应用程序的性能，因为从字符串运行代码意味着JavaScript解释器不能事先进行任何性能优化。</p><h1 id="9002" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">永远不要使用函数构造函数</h1><p id="4f63" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">Function</code>构造器类似于<code class="fe me mf mg mh b">eval</code>。它让我们通过传递想要在函数内部运行的代码来定义函数。</p><p id="ef59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下代码将参数名和函数体作为字符串传递:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3571" class="mq lc iq mh b gy mr ms l mt mu">const add = new Function('x', 'y', 'return x + y');</span></pre><p id="c204" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们用参数名<code class="fe me mf mg mh b">'x'</code>和<code class="fe me mf mg mh b">'y'</code>字符串调用了<code class="fe me mf mg mh b">Function</code>构造函数。然后我们用<code class="fe me mf mg mh b">'return x + y'</code>作为第三个参数来返回<code class="fe me mf mg mh b">x</code>和<code class="fe me mf mg mh b">y</code>的和。</p><p id="358a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以如下运行我们的函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0ccb" class="mq lc iq mh b gy mr ms l mt mu">const sum = add(1, 2);</span></pre><p id="fb90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像<code class="fe me mf mg mh b">eval</code>一样，我们动态地传入字符串来编写代码。它还在全局范围内运行一切，并像<code class="fe me mf mg mh b">eval</code>一样阻止优化。</p><p id="82f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也有和<code class="fe me mf mg mh b">eval</code>一样的安全问题，因为我们仍然通过字符串来定义我们的函数。</p><p id="db99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们也不应该用这个来定义我们的函数。</p><h1 id="a83c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要在setTimeout和setInterval中将字符串作为代码传入</h1><p id="2df8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">setTimeout</code>和<code class="fe me mf mg mh b">setInterval</code>功能分别允许我们延迟一段时间后运行代码和在指定的时间间隔内运行代码。</p><p id="30cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该在它们中使用的一个特性是向它们传递字符串来运行代码。</p><p id="9a28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该像下面这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="db85" class="mq lc iq mh b gy mr ms l mt mu">setTimeout('console.log("foo")', 100)</span></pre><p id="e4ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将在100毫秒后运行<code class="fe me mf mg mh b">console.log("foo")</code>,但是我们不应该这样做，因为我们再次从一个字符串中运行代码，这与我们从一个字符串中运行代码的其他情况存在相同的安全和性能问题。</p><p id="04ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该始终运行用代码而不是字符串定义的代码，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="44dc" class="mq lc iq mh b gy mr ms l mt mu">setTimeout(() =&gt; console.log("foo"), 100)</span></pre><p id="7544" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码像处理字符串一样运行<code class="fe me mf mg mh b">console.log</code>,但是JavaScript解释器可以优化代码，并且没有安全问题，因为没有攻击者将代码作为字符串注入我们的应用程序的风险。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/271823d516bc858ec05c30fa4cc5c8b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SIt2hDaFMkbwk83W"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mobography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Paul M</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="fd53" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">总是添加分号和括号</h1><p id="c5ea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">应该总是添加分号，以使我们的代码尽可能清晰。当我们自己不插入分号时，JavaScript可以自动插入分号。对于单行<code class="fe me mf mg mh b">if</code>块，括号也是可选的。</p><p id="06e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当它认为它应该是一个新行时，它会插入它，就像在它发现的任何逻辑中断中。</p><p id="3fc4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，这往往会导致混乱。如果我们写下如下内容:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3d41" class="mq lc iq mh b gy mr ms l mt mu">if (foo)<br/>  x = false<br/>  bar();</span></pre><p id="f04c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可能会认为，如果<code class="fe me mf mg mh b">foo</code>是<code class="fe me mf mg mh b">true</code>，那么两条线都在运行。但事实并非如此。</p><p id="643a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript解释器会认为只有<code class="fe me mf mg mh b">x = false</code>是<code class="fe me mf mg mh b">if</code>块的一部分，而<code class="fe me mf mg mh b">bar()</code>是独立的。</p><p id="5f09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们想消除这样令人困惑的代码，我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="53cd" class="mq lc iq mh b gy mr ms l mt mu">if (foo) {<br/>  x = false;<br/>  bar();<br/>}</span></pre><p id="3eaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用分号和括号分隔我们的行和块。</p><p id="4767" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们知道如果<code class="fe me mf mg mh b">foo</code>是<code class="fe me mf mg mh b">true</code>，它们都会运行。</p><h1 id="0397" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="e71a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于相等和不相等的比较，<code class="fe me mf mg mh b">===</code>和<code class="fe me mf mg mh b">!==</code>总是比<code class="fe me mf mg mh b">==</code>和<code class="fe me mf mg mh b">!=</code>好。</p><p id="46bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不应该从带有<code class="fe me mf mg mh b">eval</code>、<code class="fe me mf mg mh b">Function</code>构造函数、<code class="fe me mf mg mh b">setTimeout</code>、<code class="fe me mf mg mh b">setInterval</code>的字符串或者任何其他允许我们这样做的地方运行代码。</p><p id="8f56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们应该添加分号和括号来分隔代码块。</p><h2 id="d26a" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="d2ef" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"> <strong class="kf ir"> AI in Plain English </strong> </a>，<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="3a41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>