<html>
<head>
<title>How Tree-shaking in JavaScript Bundlers work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript绑定器中的树抖动是如何工作的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/tree-shaking-in-javascript-bundlers-cf5c9583b13d?source=collection_archive---------6-----------------------#2019-11-18">https://javascript.plainenglish.io/tree-shaking-in-javascript-bundlers-cf5c9583b13d?source=collection_archive---------6-----------------------#2019-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ad2e448cd055f56076acbc73fc510be0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kdI3LyueVUApUcsmVD24nA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Timeline of Tree-shaking Process</figcaption></figure><p id="f7dc" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">树抖动是在<strong class="ke ir">死代码消除</strong>中使用的一种技术，旨在通过移除未使用的函数、导入和语句来减少包的大小。它也被称为<strong class="ke ir">活代码包含</strong>。它是由RollupJS推广的，但是这个想法来自于20世纪90年代的LISP。</p><h2 id="3d2b" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">定义问题</h2><p id="5486" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">由于JavaScript等动态脚本的性质，在语句级或文件级找到未使用的代码块一直是一个挑战。您可以在运行时动态地更改应用程序的流程，这会影响全局范围，这可以通过CommonJS的特性来实现。</p><p id="711f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">…这意味着什么？摇树不能应用到CommonJS吗？</p><p id="e0f4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">是的，它也可以应用于CommonJS，但是很难找到未使用的代码块而不是ES6模块，所以树摇不如ES6模块好。</p><p id="5473" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">…但是为什么呢？</p><p id="af19" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">ES6模块导入和导出是静态的，您不能有条件地导入文件。我们来举个例子；</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="d952" class="la lb iq md b gy mh mi l mj mk">// CommonJS require which is a valid statement<br/>if(smth === 61){<br/> var lodash = require(‘lodash’);<br/> lodash.difference();<br/>}</span><span id="e569" class="la lb iq md b gy ml mi l mj mk">// ES6 import which will give error<br/>if(smth === 61){<br/> import {difference} from ‘lodash’;<br/> difference();<br/>}</span></pre><p id="d3a2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上面的代码块中，当CommonJS实现有效时，ES6实现将抛出错误。如果您可以动态导入某个东西，您如何确定该文件是否被使用？首先，您必须确信if语句(第2行)不会在任何时候执行。如果你能确定这一点，那么你就可以安全地从整个If块中移除。然而，要对if语句做出决定并不容易。</p><p id="450c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当您能够动态导入文件时，这是确定未使用的导入时最难的一点，这就是为什么ES6模块是树抖动的，因为您不能动态导入文件。</p><h2 id="dc7b" class="la lb iq bd lc ld le dn lf lg lh dp li kn lj lk ll kr lm ln lo kv lp lq lr ls bi translated">它是如何工作的</h2><p id="3fa9" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">正如我上面提到的，根据ES6的本质，通过分析更容易找到未使用的代码块。摇树过程从一个<strong class="ke ir">切入点</strong>开始。每个导入语句都被添加为一个树的叶子，包括它的依赖项以及它的“依赖项”依赖项。每一片有参考的叶子都被标记为绿色，没用的被标记为灰色，然后剪掉灰色的就可以食用了。</p><p id="039d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们尝试为Rollup、Webpack和package配置树抖动。</p><p id="85da" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">知识库:<a class="ae mm" href="https://github.com/muratcatal/tree-shaking-comparision" rel="noopener ugc nofollow" target="_blank">https://github.com/muratcatal/tree-shaking-comparision</a></p><p id="fc36" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面的代码是我们示例的入口点，它在ES6模块和CommonJS类型中导入。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="7a23" class="la lb iq md b gy mh mi l mj mk">// index.js</span><span id="c26d" class="la lb iq md b gy ml mi l mj mk">import * as math from "./math";<br/>import * as lodash from "./lodash";<br/>import { concat } from "./helper";</span><span id="3eec" class="la lb iq md b gy ml mi l mj mk">require("./cmn");</span><span id="d519" class="la lb iq md b gy ml mi l mj mk">concat("Hello");<br/>lodash.difference([1, 2, 3]);<br/>const helloVar = "hello-var";<br/>console.log('Hello world!');</span></pre><h1 id="db36" class="mn lb iq bd lc mo mp mq lf mr ms mt li mu mv mw ll mx my mz lo na nb nc lr nd bi translated">卷曲</h1><p id="dfe9" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">RollupJS的创建者Rich Harris写了一篇关于其新项目Rollup的博客，并提到了其令人敬畏的功能树摇动。它还提到了移除动态语言中未使用的代码块有多困难，以及树抖动中的一些特性的缺乏，但它是第一个实现树抖动思想的bundler，所以其他库如Webpack也受到了启发。</p><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/99b1bc3bfd10744e865dfb71cacbe65d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KYzRUDaQ-eyly8MgAxADfw.png"/></div></div></figure><blockquote class="nf ng nh"><p id="1f5a" class="kc kd ni ke b kf kg kh ki kj kk kl km nj ko kp kq nk ks kt ku nl kw kx ky kz ij bi translated">要在Rollup中启用树抖动，我们必须将输出格式设置为ESM</p></blockquote><p id="8cfb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">让我们配置我们的汇总；</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="297d" class="la lb iq md b gy mh mi l mj mk">import resolve from 'rollup-plugin-node-resolve';</span><span id="b8e8" class="la lb iq md b gy ml mi l mj mk">export default {<br/>    input: './index.js',<br/>    output: {<br/>        file: './dist/rollup-main.js',<br/>        format: 'esm'<br/>    },<br/>    plugins: [<br/>        resolve()<br/>    ]<br/>};</span></pre><p id="4bf4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这就是你必须做的全部工作。除非您使用CommonJS，否则您的代码将被导入到树抖动过程中，并且您将得到一个很好的输出。</p><blockquote class="nf ng nh"><p id="f163" class="kc kd ni ke b kf kg kh ki kj kk kl km nj ko kp kq nk ks kt ku nl kw kx ky kz ij bi translated">在该示例中，我将节点模块捆绑到应用程序中，并让Rollup如何操作节点模块由rollup-plugin-node-resolve插件管理。</p></blockquote><p id="d289" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我运行<strong class="ke ir"> yarn build:rollup </strong>时，它按预期完成工作，所有未使用的导入和语句都将从bundle中移除，require()语句除外。</p><h1 id="3e16" class="mn lb iq bd lc mo mp mq lf mr ms mt li mu mv mw ll mx my mz lo na nb nc lr nd bi translated">网络包</h1><p id="6665" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">在Webpack的2.2版本中实现了摇树功能，并在版本4中进行了改进。与Rollup不同，你必须在<strong class="ke ir">生产</strong>模式下运行Webpack，让它对你的代码进行树抖动。除此之外；您可以使用以下两个配置标志来覆盖三次摇动过程的行为方式。</p><p id="b1c4" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">默认情况下，当webpack在生产模式下运行时，sideEffects和usedExports在默认情况下都为true。因为usedExports是真的，您的webpack将收集关于您未使用的导出的数据，并将该信息提供给terser或任何其他tree-shake插件。通常，对于生产配置，您不需要将其设置为true。</p><blockquote class="nf ng nh"><p id="0efb" class="kc kd ni ke b kf kg kh ki kj kk kl km nj ko kp kq nk ks kt ku nl kw kx ky kz ij bi translated">当你用<strong class="ke ir"> — display-used-exports </strong>运行你的Webpack时，它会给你一个很好的输出，显示关于import语句的信息</p></blockquote><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/d410a31fd31f2c6ede64816a675f7e4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_x00A9ITg-cIrUqns8i12A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">— display-used-exports output</figcaption></figure><p id="1b32" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">副作用</strong></p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="3456" class="la lb iq md b gy mh mi l mj mk">import 'math.js';</span></pre><p id="9714" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上面的例子中，我只是导入了一个math.js文件，并没有在任何地方使用它，但是你能保证它不会对你的项目或者导入它的javascript文件产生任何副作用吗？</p><p id="6927" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了说明Webpack未使用的导出没有副作用，并且如果不使用它们，它们可以安全地从树中移除，使用了sideEffects标志。您可以在package.json文件中将它设置为false，以便在整个项目中禁用它，或者您可以给出一个数组来指示哪些文件有副作用。</p><p id="7549" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将sideEffects设置为false将会增加你的构建过程，但是你将会获得树抖动，这将会减少你的包的大小。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="62b4" class="la lb iq md b gy mh mi l mj mk">// package.json <br/>{<br/>  sideEffects: false,<br/>  sideEffects: ['./math']<br/>}</span></pre><blockquote class="nf ng nh"><p id="0cf9" class="kc kd ni ke b kf kg kh ki kj kk kl km nj ko kp kq nk ks kt ku nl kw kx ky kz ij bi translated">使用其中一个用例。你可以说你的bundler不要接触数学库，因为它有副作用，或者你可以说你的bundler项目没有副作用，所以它可以安全地删除未使用的导出</p></blockquote><p id="3a61" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">使用导出</strong></p><p id="7a45" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这有助于删除未使用的语句，并依靠terser来检测未使用的语句。您可以在webpack的配置中启用它。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="0f1b" class="la lb iq md b gy mh mi l mj mk">module.exports = {<br/>  //...<br/>  optimization: {<br/>    usedExports: true<br/>  }<br/>};</span></pre><blockquote class="nf ng nh"><p id="cd0a" class="kc kd ni ke b kf kg kh ki kj kk kl km nj ko kp kq nk ks kt ku nl kw kx ky kz ij bi translated">sideEffects更有效，因为它跳过了整个导入文件。</p></blockquote><p id="6650" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">利用Webpack中的树抖动；</p><ul class=""><li id="368a" class="nn no iq ke b kf kg kj kk kn np kr nq kv nr kz ns nt nu nv bi translated">在生产模式下构建代码</li><li id="0f4c" class="nn no iq ke b kf nw kj nx kn ny kr nz kv oa kz ns nt nu nv bi translated">使用ES6模块(导入和导出)</li><li id="b115" class="nn no iq ke b kf nw kj nx kn ny kr nz kv oa kz ns nt nu nv bi translated">如果你使用babel的@babel/preset-env，它会把你的ES6转换成CommonJS，这样就不可能使用树抖动了。但是你可以给你的宝贝一个支持ESM的选项。</li></ul><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="71cc" class="la lb iq md b gy mh mi l mj mk">{<br/>  "presets": [<br/>    [<br/>      "<a class="ae mm" href="http://twitter.com/babel/preset-env" rel="noopener ugc nofollow" target="_blank">@babel/preset-env</a>",<br/>      {<br/>        "targets": {<br/>          "esmodules": true<br/>        }<br/>      }<br/>    ]<br/>  ]<br/>}<br/>// alternative way to tell babel not to transpile ESM modules into CommonJS</span><span id="1f5b" class="la lb iq md b gy ml mi l mj mk">{<br/>  "presets": [<br/>    ["env",<br/>      {<br/>        "modules": false<br/>      }<br/>    ]<br/>  ]<br/>}</span></pre><p id="9251" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我运行<strong class="ke ir"> yarn build:webpack </strong>时，结果将类似于Rollup。</p><h1 id="ed72" class="mn lb iq bd lc mo mp mq lf mr ms mt li mu mv mw ll mx my mz lo na nb nc lr nd bi translated">帕塞尔</h1><figure class="ly lz ma mb gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/26e85d4c6e230c0b5db3c2b94028d01e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KGksi3L7U8TSCl6m4dAajw.png"/></div></div></figure><p id="e698" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Parsel基于零配置bundler，这使得采用您的项目变得非常容易。1.9版本中提供了树抖动功能，但是它仍然是一个实验性的特性，所以在构建项目时，您必须使用flag来让Parsel运行它的树抖动算法。</p><pre class="ly lz ma mb gt mc md me mf aw mg bi"><span id="7633" class="la lb iq md b gy mh mi l mj mk">parcel build index.js --experimental-scope-hoisting</span></pre><blockquote class="nf ng nh"><p id="2c54" class="kc kd ni ke b kf kg kh ki kj kk kl km nj ko kp kq nk ks kt ku nl kw kx ky kz ij bi translated">正如在第一节中提到的，CommonJS模块的树抖动真的很难，但是Parcel内置了这个很好的特性。</p></blockquote><p id="1309" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">当我运行yarn build:parcel时，它显示了它的差异，并且<strong class="ke ir"> console.log </strong>语句和<strong class="ke ir"> concat('Hello') </strong>将被删除。然而，每当我将concat('Hello ')赋给一个变量时，parcel就会将它包含到包中。</p><h1 id="8cf4" class="mn lb iq bd lc mo mp mq lf mr ms mt li mu mv mw ll mx my mz lo na nb nc lr nd bi translated">那么下一步是什么？</h1><p id="ad13" class="pw-post-body-paragraph kc kd iq ke b kf lt kh ki kj lu kl km kn lv kp kq kr lw kt ku kv lx kx ky kz ij bi translated">树抖动是一个很好的强大的特性，只要它被有效地使用，因为它减少了你的包的大小，也节省了你意想不到的代码运行。(您可以考虑该语句是否不可达，以及在这种状态下应用程序流如何下降，但不要忽略您的JavaScript可以在客户端未经您的允许由外部对等方运行)</p><p id="d1e7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在不同的捆绑器中，处理树抖动的过程是不同的，但是最终你如何编写你的代码会显著地影响这个过程。</p><h1 id="c78c" class="mn lb iq bd lc mo mp mq lf mr ms mt li mu mv mw ll mx my mz lo na nb nc lr nd bi translated">参考</h1><ul class=""><li id="96b3" class="nn no iq ke b kf lt kj lu kn oc kr od kv oe kz ns nt nu nv bi translated"><a class="ae mm" href="https://medium.com/@Rich_Harris/tree-shaking-versus-dead-code-elimination-d3765df85c80" rel="noopener">https://medium . com/@ Rich _ Harris/tree-shaking-vs . dead-code-elimination-d 3765 df 85 c 80</a></li><li id="1153" class="nn no iq ke b kf nw kj nx kn ny kr nz kv oa kz ns nt nu nv bi translated"><a class="ae mm" href="https://medium.com/webpack/webpack-and-rollup-the-same-but-different-a41ad427058c" rel="noopener">https://medium . com/web pack/web pack-and-roll up-the-same-but-different-a41ad 427058 c</a></li><li id="0f8a" class="nn no iq ke b kf nw kj nx kn ny kr nz kv oa kz ns nt nu nv bi translated"><a class="ae mm" href="https://medium.com/@devongovett/parcel-v1-9-0-tree-shaking-2x-faster-watcher-and-more-87f2e1a70f79" rel="noopener">https://medium . com/@ devongovett/parcel-v1-9-0-tree-shaking-2x-fast-watcher-and-more-87 F2 E1 a 70 f 79</a></li><li id="8dc5" class="nn no iq ke b kf nw kj nx kn ny kr nz kv oa kz ns nt nu nv bi translated"><a class="ae mm" href="https://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking" rel="noopener ugc nofollow" target="_blank">https://developers . Google . com/web/fundamentals/performance/optimizing-JavaScript/tree-shaking</a></li><li id="9833" class="nn no iq ke b kf nw kj nx kn ny kr nz kv oa kz ns nt nu nv bi translated"><a class="ae mm" href="https://blog.jakoblind.no/how-webpack-decides-what-to-bundle/" rel="noopener ugc nofollow" target="_blank">https://blog . jakoblind . no/how-web pack-decision-what-to-bundle/</a></li></ul></div></div>    
</body>
</html>