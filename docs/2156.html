<html>
<head>
<title>Cheat Sheet For Cloning Arrays In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中克隆数组的备忘单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/cheat-sheet-for-cloning-arrays-in-javascript-1058ce3c351c?source=collection_archive---------4-----------------------#2020-05-25">https://javascript.plainenglish.io/cheat-sheet-for-cloning-arrays-in-javascript-1058ce3c351c?source=collection_archive---------4-----------------------#2020-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1ae2" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在浅层和深层克隆中生存</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/77e567bb7d634decb61c66e8c7f15a52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C7pvjQ07XhjHjrf8_5u6uw.png"/></div></div></figure><p id="e3c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在JavaScript 中有10种方法。而且，大多数时候，他们的一部分是错的。比如使用<code class="fe ln lo lp lq b">=</code>符号复制数组。</p><p id="6fc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是为什么呢？因为JavaScript中的数组是<a class="ae lr" href="https://itnext.io/javascript-interview-prep-primitive-vs-reference-types-62eef165bec8" rel="noopener ugc nofollow" target="_blank"> <em class="ls">引用类型</em> </a>。这意味着试图用<code class="fe ln lo lp lq b">=</code>复制它们只会复制对原始数组的引用<strong class="kt ir">。</strong></p><p id="d913" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不相信我？尝试在您的控制台中运行这样一个示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lt"><img src="../Images/50382fdae050e96e0f41ebe74c002c5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XGJjraB2BlQfprL1wWv_Rg.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Arrays here are copied by reference</figcaption></figure><p id="40d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你能想象现在我们通过引用复制这些数组会发生什么吗？因为我们指向内存中的同一个位置，所以对<code class="fe ln lo lp lq b">fakeBurgers</code>的每次修改也会修改<code class="fe ln lo lp lq b">burgers</code>，反之亦然。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/e2a3df40edb0f23c14a74801acdf3a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PFfzuX2XsdgDkQaTDpmu8w.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Modifying one array will also modify the other.</figcaption></figure><h2 id="2bb5" class="lz ma iq bd mb mc md dn me mf mg dp mh la mi mj mk le ml mm mn li mo mp mq mr bi translated">这个怎么解决？</h2><p id="abd7" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">很明显，您应该真正理解如何正确地<strong class="kt ir">克隆两个阵列</strong>。想象一下，你在没有意识到的情况下，执行了如上所述的参考复制。对一个实体的每次修改也会修改一个或多个其他实体。当比较它们时导致“<em class="ls">脏检查</em>”。</p><p id="b68c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您不需要创建一个新的数组，并在原来的数组上迭代，将每个值复制到新生成的容器中。这是执行这项任务的老方法。试试这些更简单的方法:</p><h2 id="dc08" class="lz ma iq bd mb mc md dn me mf mg dp mh la mi mj mk le ml mm mn li mo mp mq mr bi translated"><strong class="ak"> 1)展开操作员</strong></h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/9b6518c851461cea0ca945eafeae8012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j6k7SooY-VYAZM9CdrIGCw.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Cloning two arrays using the spread operator</figcaption></figure><h2 id="1a99" class="lz ma iq bd mb mc md dn me mf mg dp mh la mi mj mk le ml mm mn li mo mp mq mr bi translated">2)串联</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/f764a8ad028fa6a5f72e8e226b50bbf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u6YJEvBIBdVqwLGxLK3wmw.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Using concat to clone two arrays</figcaption></figure><h2 id="034d" class="lz ma iq bd mb mc md dn me mf mg dp mh la mi mj mk le ml mm mn li mo mp mq mr bi translated">3)切片</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/297cc661482151632cac86ba36318deb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Laixs2XdhQScPGWz5R0IMw.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Using slice to clone two arrays</figcaption></figure><h2 id="cfa3" class="lz ma iq bd mb mc md dn me mf mg dp mh la mi mj mk le ml mm mn li mo mp mq mr bi translated">4) Array.from()</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/904f8af51b3ee92cfaa020c47c6dd37d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qP6HLgMnzEHT7eQrxgWldg.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Cloning two arrays using Array.from</figcaption></figure><h2 id="aa01" class="lz ma iq bd mb mc md dn me mf mg dp mh la mi mj mk le ml mm mn li mo mp mq mr bi translated">小心点！</h2><p id="12b2" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">因为你刚才看到的对<a class="ae lr" href="https://levelup.gitconnected.com/difference-between-shallow-and-deep-copy-c0a968e89c44" rel="noopener ugc nofollow" target="_blank"> <em class="ls">深度抄袭</em> </a>不起作用。这意味着<strong class="kt ir">多维数组将只在第一层</strong>被复制。或者，在“<em class="ls">面</em>上，如果你愿意的话。更深的层次将简单地通过引用复制，如上所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/6b21a786d30c4439bdf8a319e43a8eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pRFK-zzvRK0LtnYfUs9IZw.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">The provided solutions won’t work for nested arrays</figcaption></figure><p id="65bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个只在第一级复制数组的过程叫做“<em class="ls">浅复制</em>”。你主要有两个选择来解决这个问题:</p><h2 id="4abb" class="lz ma iq bd mb mc md dn me mf mg dp mh la mi mj mk le ml mm mn li mo mp mq mr bi translated">1) JSON.parse</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/5a5da2a44e1d7714d93b96adf81e93b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pHg8HMiiSWAnmEPOu9njcQ.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Deep cloning using JSON.parse()</figcaption></figure><h2 id="8556" class="lz ma iq bd mb mc md dn me mf mg dp mh la mi mj mk le ml mm mn li mo mp mq mr bi translated">2) Lodash _。克隆深度睡眠</h2><p id="9876" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">JavaScript用户的最佳方法集怎么可能不考虑这种情况呢？只需使用<a class="ae lr" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> Lodash </a>(建议的解决方案)并深度克隆您的阵列。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/c33a4581d1f56eed09c1cf75d4d59e5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ys1AdgMMLFYHUrCDGlfvfA.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Deep cloning using Lodash</figcaption></figure><p id="26b9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为什么这是我建议的解决方案？因为</p><ul class=""><li id="bdf8" class="nc nd iq kt b ku kv kx ky la ne le nf li ng lm nh ni nj nk bi translated">你想做什么就更清楚了。</li><li id="ced2" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated">项目已经使用Lodash的可能性更高。</li><li id="7c7d" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated"><code class="fe ln lo lp lq b">JSON.parse()</code>会引起事端。因为它只能处理数字、字符串和对象文字。所以它不支持函数或符号属性。</li></ul><p id="803e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">请注意:</strong>功能和符号在使用<code class="fe ln lo lp lq b">_.cloneDeep</code>时被参照复制</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/2ecbe6429780bd961a4ed7d0a7b9089b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cfbuDTnzgR0o88vmPJA37w.png"/></div></div></figure><h2 id="4bf6" class="lz ma iq bd mb mc md dn me mf mg dp mh la mi mj mk le ml mm mn li mo mp mq mr bi translated">结论</h2><p id="a3cd" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">正如本文开头所说，在JavaScript中有很多方法可以做任何事情。您只需克隆两个阵列就可以证明这一点。希望这篇文章揭示了克隆的过程以及如何确保你做得正确。</p><p id="7d9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">— <em class="ls">皮耶罗</em></p><h2 id="f511" class="lz ma iq bd mb mc md dn me mf mg dp mh la mi mj mk le ml mm mn li mo mp mq mr bi translated"><strong class="ak">简明英语笔记</strong></h2><p id="7377" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae lr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> plainenglish.io </strong> </a>找到所有这些内容——关注我们的出版物并<a class="ae lr" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">订阅我们的YouTube频道</strong> </a> <strong class="kt ir">来表达你的爱吧！</strong></p><h2 id="a3b9" class="lz ma iq bd mb mc md dn me mf mg dp mh la mi mj mk le ml mm mn li mo mp mq mr bi translated">资源</h2><ul class=""><li id="1e7d" class="nc nd iq kt b ku ms kx mt la nr le ns li nt lm nh ni nj nk bi translated"><a class="ae lr" href="https://itnext.io/javascript-interview-prep-primitive-vs-reference-types-62eef165bec8" rel="noopener ugc nofollow" target="_blank">原语与引用类型</a>。</li><li id="784c" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated"><a class="ae lr" href="https://levelup.gitconnected.com/difference-between-shallow-and-deep-copy-c0a968e89c44" rel="noopener ugc nofollow" target="_blank"> <em class="ls">深度克隆</em> </a> <em class="ls">。</em></li><li id="476d" class="nc nd iq kt b ku nl kx nm la nn le no li np lm nh ni nj nk bi translated"><a class="ae lr" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank">洛达什</a>。</li></ul></div></div>    
</body>
</html>