<html>
<head>
<title>Asynchronous JavaScript: Introducing async and await</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步JavaScript:引入异步和等待</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/asynchronous-javascript-introducing-async-and-await-5b15e971b43a?source=collection_archive---------7-----------------------#2020-09-28">https://javascript.plainenglish.io/asynchronous-javascript-introducing-async-and-await-5b15e971b43a?source=collection_archive---------7-----------------------#2020-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b8006d85a35f9ad5a5d4d9c643d6bb03.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fBoo2YFrIl_sEODf.png"/></div></div></figure><p id="bd0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">异步处理是JavaScript语言最重要的方面之一。JavaScript是一种单线程语言，因此它需要一种机制来处理一些动作，比如执行耗时且可能不可靠的活动，比如调用REST API、从磁盘读取文件或与用户输入交互。</p><p id="a578" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在JavaScript中，使用的机制是一个<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop#Event_loop" rel="noopener ugc nofollow" target="_blank">事件循环</a>，它按照从最旧到最新的顺序处理回调队列。队列中的每一项都是一条消息，在进入下一条消息之前会被完全处理。每条消息都是一个函数，它返回对应用程序中其他地方的代码的响应。这样使用的函数叫做<em class="kx">回调</em>函数。</p><p id="984a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为有了回调，JavaScript可以使用多种技术绕过它的单线程特性来实现异步处理。不幸的是，其中一些技术，JavaScript Promises和RxJS Observables，迫使您在代码中至少引入一个嵌套层次。这会降低代码的可读性和可维护性。</p><p id="d182" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，最近的JavaScript版本增加了一项处理异步代码的技术:<em class="kx">异步</em>和<em class="kx">等待</em>。当您希望程序在执行某些异步操作时同步阻塞，然后在该操作完成后继续工作时，这是一个完美的选择。</p><p id="6f59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这篇文章将向你介绍<em class="kx">异步</em>和<em class="kx">等待</em>的基本原理，并向你展示具体的例子。然后，您将有机会创建一个使用<em class="kx">异步</em>和<em class="kx">等待</em>来执行异步处理的真实应用程序。</p><h1 id="a224" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">在async和await之前了解异步JavaScript</h1><p id="28b6" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在开始使用<em class="kx"> async </em>和<em class="kx"> await </em>之前，理解回调是很有帮助的，它是所有JavaScript异步处理基础的一部分。理解承诺也很重要，它为事件循环和回调过程增加了功能。承诺与<em class="kx">异步</em>和<em class="kx">等待</em>功能紧密配合使用。</p><h1 id="d884" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">复试</h1><p id="7d0d" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">回调是异步运行JavaScript代码的最古老、最基本的技术。<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Glossary/Callback_function" rel="noopener ugc nofollow" target="_blank">回调</a>是“一个函数作为参数传递给另一个函数，然后在外部函数中被调用以完成某种例程或动作。”(<a class="ae kw" href="https://developer.mozilla.org/en-US/" rel="noopener ugc nofollow" target="_blank"> MDN </a>)</p><p id="2288" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当它们同步运行时，回调有一个相当大的缺点:它们阻塞事件循环，直到它们结束，从而可能导致程序变得没有响应，看起来“冻结”。在使用<a class="ae kw" href="https://www.npmjs.com/package/sync-request" rel="noopener ugc nofollow" target="_blank">同步请求</a>库的函数中可以看到这样一个例子，它是同步执行的。</p><p id="57f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以按以下方式编写使用回调的函数:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="ab02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">getStatusCodeCB</code>函数有一个<code class="fe mh mi mj mk b">url</code>参数，它是一个包含URL的字符串，您希望对该URL执行HTTP请求并从响应中获取状态代码。第二个参数是<code class="fe mh mi mj mk b">callback</code>，这是一个一旦检索到状态代码就应该执行的函数。</p><p id="3db0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数使用<a class="ae kw" href="https://nodejs.org/api/timers.html#timers_scheduling_timers" rel="noopener ugc nofollow" target="_blank"> setTimeout </a> API在<code class="fe mh mi mj mk b">setTimeout</code>的第二个参数指定的时间后将<code class="fe mh mi mj mk b">request()</code>调用和<code class="fe mh mi mj mk b">callback</code>函数调用放入回调队列。因为<code class="fe mh mi mj mk b">setTimeout</code>是<a class="ae kw" href="https://nodejs.org/en/docs/guides/timers-in-node/" rel="noopener ugc nofollow" target="_blank">异步</a>，所以<code class="fe mh mi mj mk b">getStatusCodeCB</code>函数体异步执行，不阻塞JavaScript栈，同步执行。</p><h1 id="9089" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">承诺</h1><p id="cf99" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">JavaScript中异步执行代码的另一种方式是使用承诺。<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" rel="noopener ugc nofollow" target="_blank"> Promise </a>是一个对象，它提供了一个值的代理，该值将基于稍后发生的异步操作的结果(如果有的话)来确定。承诺也有一个状态，表示操作的状态。</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="f53d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码定义了一个返回Promise对象的<code class="fe mh mi mj mk b">getStatusCodePromise</code>函数。当<code class="fe mh mi mj mk b">getStatusCodePromise</code>函数<em class="kx">返回的承诺解析</em>时，它将请求的响应代码返回到<code class="fe mh mi mj mk b">url</code>参数<em class="kx">中指定的地址。</em>Promise对象的<code class="fe mh mi mj mk b">.then()</code>方法指定了解析Promise时要做什么。</p><p id="3961" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两种解决方案都很好，当您想要使用外部API(如<code class="fe mh mi mj mk b">setTimeout</code>、<code class="fe mh mi mj mk b">setInterval</code>或<code class="fe mh mi mj mk b">fetch</code>)异步运行一个动作时，这两种解决方案是等效的。不幸的是，这些解决方案不能很好地处理依赖于其他动作的异步动作，比如在根据输入的数据执行一些条件逻辑之前等待用户输入。</p><p id="4422" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">注意:</em>如果您想了解更多关于回调、承诺、事件循环或其他异步JavaScript特性的信息，请查看下面的<em class="kx">附加资源</em>部分中列出的帖子。它们是异步JavaScript教程综合库的一部分。</p><h1 id="f578" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">了解async和await关键字</h1><p id="1610" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> async </a>和<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await" rel="noopener ugc nofollow" target="_blank"> await </a>关键字被添加到了第八版规范<a class="ae kw" href="https://www.ecma-international.org/ecma-262/8.0/index.html" rel="noopener ugc nofollow" target="_blank"> ECMAScript 2017 </a>版本的JavaScript规范中。这是JavaScript异步编程能力的重大改进，受到了各地开发人员的欢迎。</p><p id="c0e1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第9个版本中，<a class="ae kw" href="https://www.ecma-international.org/ecma-262/9.0/index.html" rel="noopener ugc nofollow" target="_blank"> ECMAScript 2018 </a>，引入了异步迭代器。这个新特性使得在<code class="fe mh mi mj mk b">for…of</code>循环中使用<code class="fe mh mi mj mk b">await</code>关键字成为可能。</p><h2 id="600f" class="ml kz iq bd la mm mn dn le mo mp dp li kj mq mr lm kn ms mt lq kr mu mv lu mw bi translated">异步ˌ非同步(asynchronous)</h2><p id="dee0" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated"><code class="fe mh mi mj mk b">async</code>关键字只能用于函数声明。它告诉JavaScript运行时环境(<a class="ae kw" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank"> V8 </a>、<a class="ae kw" href="https://nodejs.org/en/docs/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>或<a class="ae kw" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank"> Deno </a>)它应该将函数体包装在一个承诺中。承诺将由函数返回，而不是返回语句值；返回值将用于异步解析承诺。</p><p id="ec69" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下两个函数返回等效的输出:一个Promise对象，该对象通过对<code class="fe mh mi mj mk b">url</code>参数中提供的地址的GET请求的状态代码进行解析:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5d09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您希望由<code class="fe mh mi mj mk b">async</code>函数返回的<code class="fe mh mi mj mk b">Promise</code>被拒绝，请使用<code class="fe mh mi mj mk b">throw</code>语句:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="9987" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<code class="fe mh mi mj mk b">async</code>函数不需要返回值；它可以返回<em class="kx"> void </em>。当它这样做时，它相当于没有值的<code class="fe mh mi mj mk b">Promise</code>解析:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="13a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">postDataAsync</code>功能在其承诺解决时<em class="kx">不会发出</em>任何数据，但承诺<em class="kx">状态</em>会变为<em class="kx">履行</em>或<em class="kx">拒绝</em>。通过检查承诺状态，程序可以确定异步操作是否成功。</p><h2 id="a994" class="ml kz iq bd la mm mn dn le mo mp dp li kj mq mr lm kn ms mt lq kr mu mv lu mw bi translated">等待</h2><p id="ac21" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated"><code class="fe mh mi mj mk b">await</code>关键字只能用于Promise对象。它通知JavaScript运行时环境应该暂停程序执行，直到相关的承诺解决。另一个约束是<code class="fe mh mi mj mk b">await</code>只能在<code class="fe mh mi mj mk b">async</code>函数内部使用。</p><p id="07be" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要强制JavaScript运行时暂停程序执行，直到Promise解析并提供一个值，请在Promise调用之前插入关键字<code class="fe mh mi mj mk b">await</code>:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="49a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要处理承诺拒绝，请将<code class="fe mh mi mj mk b">await</code>语句放在<code class="fe mh mi mj mk b">try…catch</code>块中:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="a579" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">声明逻辑所在的异步函数的另一种方法是在初始化之后调用它。例如，您可以将代码包装在一个匿名异步函数中，并立即调用它:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="3d61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，您已经快速复习了JavaScript中异步处理的工作原理，并了解了<code class="fe mh mi mj mk b">async</code>和<code class="fe mh mi mj mk b">await</code>关键字，您可以获得一些在实际场景中使用这些工具的经验。</p><h1 id="c5f5" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">了解教程项目</h1><p id="4ea7" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在本教程中，您将创建一个带有交互式命令行菜单的控制台应用程序。它是您可以在控制台项目中重用的代码，比如命令行界面(CLI)工具。</p><p id="f1a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当你构建菜单应用程序时，本教程将向你展示<code class="fe mh mi mj mk b">async</code>和<code class="fe mh mi mj mk b">await</code>关键字的方方面面。您将使用它们来创建返回承诺的函数，并调用同步等待承诺解决。</p><p id="b6c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文中的代码使用了<a class="ae kw" href="https://www.npmjs.com/package/readline-promise" rel="noopener ugc nofollow" target="_blank"> readline-promise </a>库来读取命令行输入，因此您也将获得一些使用经验。这个库通过添加异步迭代器和其他特性来扩展Node.js <a class="ae kw" href="https://nodejs.org/api/readline.html#readline_readline" rel="noopener ugc nofollow" target="_blank"> readline </a>模块。</p><h1 id="7bbe" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">先决条件</h1><p id="4a6f" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">要完成本教程中的任务，您需要以下工具:</p><ul class=""><li id="24ab" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nc nd ne nf bi translated"><a class="ae kw" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> Node.js和npm</a>(node . js安装也将安装NPM。)</li><li id="9d16" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated"><a class="ae kw" href="https://git-scm.com/downloads" rel="noopener ugc nofollow" target="_blank">吉特</a></li><li id="e0bf" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nc nd ne nf bi translated"><a class="ae kw" href="https://code.visualstudio.com/download" rel="noopener ugc nofollow" target="_blank"> Visual Studio代码</a>(或其他IDE或代码编辑器)</li></ul><p id="07df" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了充分利用这篇文章，你还应该具备JavaScript的基本工作知识。</p><p id="b7d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有一个<a class="ae kw" href="https://github.com/maciejtreder/asynchronous-javascript" rel="noopener ugc nofollow" target="_blank">配套库</a>包含GitHub上提供的项目的完整源代码。</p><p id="b88a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="http://www.twilio.com/referral/78mKcI" rel="noopener ugc nofollow" target="_blank"> Twilio账户</a>——虽然本教程并不要求这样做，但如果您使用此链接注册Twilio账户，您账户还可获得10美元的信用额度。</p><h1 id="ab32" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">设置项目</h1><p id="4cd9" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在本教程中，您有两个选项来设置Node.js项目。您可以:</p><ol class=""><li id="34c4" class="mx my iq ka b kb kc kf kg kj mz kn na kr nb kv nl nd ne nf bi translated">使用配套存储库中的代码，其中还包括本系列前面关于异步JavaScript文章的代码</li><li id="1359" class="mx my iq ka b kb ng kf nh kj ni kn nj kr nk kv nl nd ne nf bi translated">从头开始，这样您的项目只包含本教程中的代码</li></ol><p id="20ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要克隆伴随存储库，请在要创建项目根目录的目录中执行以下命令行说明:</p><pre class="mb mc md me gt nm mk nn no aw np bi"><span id="0984" class="ml kz iq mk b gy nq nr l ns nt">git clone <a class="ae kw" href="https://github.com/maciejtreder/asynchronous-javascript.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/asynchronous-javascript.git</a><br/>cd asynchronous-javascript<br/>git checkout step16<br/>npm install<br/>mkdir async-await<br/>cd async-await</span></pre><p id="d5bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码包括许多分支，这些分支提供了说明如何使用JavaScript回调、Promises、RxJS Observables和其他JavaScript特性的代码。</p><p id="83db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要从头开始命令行菜单项目，请在要放置项目根目录的目录中执行以下命令行指令:</p><pre class="mb mc md me gt nm mk nn no aw np bi"><span id="1e6f" class="ml kz iq mk b gy nq nr l ns nt">mkdir async-await<br/>cd async-await<br/>git init<br/>npx license mit &gt; LICENSE<br/>npx gitignore node<br/>npm init -y<br/>git add -A<br/>git commit -m "Initial commit"<br/>npm install esm</span></pre><p id="dd75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在Twilio的Phil Nash的<a class="ae kw" href="https://philna.sh/blog/2019/01/10/how-to-start-a-node-js-project/" rel="noopener ugc nofollow" target="_blank">帖子</a>中了解更多关于初始化Node.js项目的信息。</p><p id="084e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用以下命令在项目根目录或以下安装<code class="fe mh mi mj mk b">readline-promise</code>库:</p><pre class="mb mc md me gt nm mk nn no aw np bi"><span id="74f7" class="ml kz iq mk b gy nq nr l ns nt">npm install readline-promise</span></pre><h1 id="faa5" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">构建应用程序</h1><p id="5213" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">在您选择的IDE或代码编辑器中打开项目。</p><h2 id="37f5" class="ml kz iq bd la mm mn dn le mo mp dp li kj mq mr lm kn ms mt lq kr mu mv lu mw bi translated">等待用户输入</h2><p id="b71f" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">为了构建应用程序的入口点，在<em class="kx">异步等待</em>文件夹中创建一个<em class="kx"> start.js </em>文件，并将以下JavaScript代码放入其中:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="9686" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码导入了<code class="fe mh mi mj mk b">readline-promise</code>库，该库将用于收集用户的输入，并将其作为Promise对象传递给程序。常量<code class="fe mh mi mj mk b">rl</code>的声明使用一个配置设置了一个<code class="fe mh mi mj mk b">readlinePromise</code>对象的实例，该配置将输出分配给系统的标准输出，并通过标准输入监听用户输入，两者都是控制台。</p><p id="2b64" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在初始化了<code class="fe mh mi mj mk b">readline</code>对象之后，代码声明了<code class="fe mh mi mj mk b">MenuOptions</code>常量。这是一张<a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" rel="noopener ugc nofollow" target="_blank">地图</a>，代表菜单中显示的可用程序选项。迄今为止，只有一个:“退出”。在编写应用程序的过程中，您将添加更多选项。</p><p id="6fae" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">异步函数<code class="fe mh mi mj mk b">displayMenu</code>，是程序的入口点。它从清除控制台开始。然后，它遍历<code class="fe mh mi mj mk b">MenuOptions</code>地图的元素，并在控制台中显示可用的选项。一旦完成，就该等待用户输入了。</p><p id="8ae5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mh mi mj mk b">chosenOption</code>常量的声明中，代码要求用户使用<code class="fe mh mi mj mk b">rl.questionAsync</code>方法进行交互。这个方法返回一个承诺，当用户输入时，这个承诺被解析。</p><p id="4701" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以将<code class="fe mh mi mj mk b">await</code>关键字与该方法调用一起使用，这将导致同步等待用户输入，并将用户输入放入<code class="fe mh mi mj mk b">chosenOption</code>常量中。这在这里很有用，因为直到你从用户那里得到信息，你才知道下一步该做什么。</p><p id="d9b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用<code class="fe mh mi mj mk b">await</code>关键字，您可以避免在嵌套层次中使用Promise对象的<code class="fe mh mi mj mk b">then()</code>方法。您能够避免额外的调用，因为您已经使用<code class="fe mh mi mj mk b">async</code>关键字声明了<code class="fe mh mi mj mk b">displayMenu</code>函数。</p><p id="1c86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用户输入是一个<code class="fe mh mi mj mk b">string</code>值，因此<code class="fe mh mi mj mk b">parseInt</code>方法在将它赋给<code class="fe mh mi mj mk b">chosenOption</code>常量之前将其转换为一个整数。在函数结束时，在<code class="fe mh mi mj mk b">switch</code>语句中使用<code class="fe mh mi mj mk b">chosenOption</code>的值来确定要执行的动作。到目前为止，有两个:</p><p id="484c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">case 4</code>通过调用<code class="fe mh mi mj mk b">rl</code>对象的close方法结束程序，该方法清除回调队列并释放节点。<code class="fe mh mi mj mk b">js</code>退出。</p><p id="c2ce" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">default</code>处理非法输入。如果用户输入一个超出范围的数字或任何其他无效输入，该函数会在控制台中显示一个通知。然后程序等待用户的确认，并递归调用displayMenu函数。</p><h2 id="87a7" class="ml kz iq bd la mm mn dn le mo mp dp li kj mq mr lm kn ms mt lq kr mu mv lu mw bi translated">测试基本功能</h2><p id="fedb" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">这是查看一切是否正常工作的好时机。</p><p id="a74f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在<em class="kx"> async-await </em>目录中输入以下Node.js CLI命令来运行程序:</p><pre class="mb mc md me gt nm mk nn no aw np bi"><span id="878c" class="ml kz iq mk b gy nq nr l ns nt">node -r esm start.js</span></pre><p id="d020" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您应该会在控制台窗口中看到以下输出:</p><pre class="mb mc md me gt nm mk nn no aw np bi"><span id="7773" class="ml kz iq mk b gy nq nr l ns nt">Choose an option and press Enter</span><span id="8c70" class="ml kz iq mk b gy nu nr l ns nt">(4) Exit</span><span id="dc15" class="ml kz iq mk b gy nu nr l ns nt">Your choice:</span></pre><p id="8432" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">输入“4”选择选项4并按下<strong class="ka ir">确认选择后，输入</strong>程序将退出。</p><p id="ec59" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您没有按照编码进行，并且希望使用GitHub存储库中的代码赶上这一步，请在您想要创建项目目录的目录中执行以下命令:</p><pre class="mb mc md me gt nm mk nn no aw np bi"><span id="29a2" class="ml kz iq mk b gy nq nr l ns nt">git clone <a class="ae kw" href="https://github.com/maciejtreder/asynchronous-javascript.git" rel="noopener ugc nofollow" target="_blank">https://github.com/maciejtreder/asynchronous-javascript.git</a><br/>cd asynchronous-javascript<br/>git checkout step17<br/>npm install<br/>cd async-await</span></pre><h1 id="c978" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">增强计划</h1><p id="3acb" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">当然，你不希望你的程序只有一个选项:“退出”。</p><p id="5749" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在项目根目录下创建一个<em class="kx"> sum.js </em>文件，并插入以下JavaScript代码:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="04d0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码介绍了异步函数<code class="fe mh mi mj mk b">getOperand</code>。该函数返回一个<code class="fe mh mi mj mk b">Promise&lt;number&gt;</code>对象，它用一个从0到10的随机生成的数字进行解析。</p><p id="191c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是，为什么这个函数返回一个<code class="fe mh mi mj mk b">Promise</code>而<code class="fe mh mi mj mk b">return</code>语句调用返回整数的方法？这就是<code class="fe mh mi mj mk b">async</code>关键字的神奇之处:它告诉JavaScript运行时将函数体包装在一个<code class="fe mh mi mj mk b">Promise</code>中，后者用来自<code class="fe mh mi mj mk b">return</code>语句的值进行解析。</p><p id="aeb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第二个函数<code class="fe mh mi mj mk b">addTwoNumbers</code>是从文件中导出的，因此您将能够在<em class="kx"> start.js </em>文件中使用它，程序入口点就驻留在这个文件中。该函数清除控制台，等待随机数的生成，并添加它们。在函数返回之前，它显示操作数和它们的总和。</p><p id="b6a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，<code class="fe mh mi mj mk b">addTwoNumbers</code>函数声明的前面是<code class="fe mh mi mj mk b">async</code>关键字，因此您可以在其中使用<code class="fe mh mi mj mk b">await</code>,来“解开”由<code class="fe mh mi mj mk b">getOperand</code>函数返回的Promise对象。如果你不使用<code class="fe mh mi mj mk b">await</code>，你会得到一个Promise对象，在这个对象上你仍然需要调用<code class="fe mh mi mj mk b">then</code>方法来获取值。</p><p id="82e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，<code class="fe mh mi mj mk b">addTwoNumbers</code>函数没有<code class="fe mh mi mj mk b">return</code>语句。这与声明中的<code class="fe mh mi mj mk b">async</code>一起表明函数的返回类型是<code class="fe mh mi mj mk b">Promise&lt;void&gt;</code>，这是一个承诺，通知调用者一些异步操作已经完成，而没有提供该操作的任何输出。</p><p id="e50d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="kx"> start.js </em>文件的开头添加以下<code class="fe mh mi mj mk b">import</code>语句:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2304" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过用以下内容替换当前的<code class="fe mh mi mj mk b">MenuOptions</code>声明，向菜单添加一个新选项:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="574e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将新的<code class="fe mh mi mj mk b">case</code>添加到<code class="fe mh mi mj mk b">displayMenu</code>函数内的<code class="fe mh mi mj mk b">switch</code>语句中:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="3018" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，每当用户从菜单中选择“1”时，程序就会调用<code class="fe mh mi mj mk b">addTwoNumbers</code>函数，等待它用<code class="fe mh mi mj mk b">await</code>结束，并要求用户按回车键返回菜单。一旦用户执行该操作，<code class="fe mh mi mj mk b">displayMenu</code>功能将被递归调用。</p><p id="c9b6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这些修改之后，你的<em class="kx"> start.js </em>文件应该看起来像同伴库中的<a class="ae kw" href="https://github.com/maciejtreder/asynchronous-javascript/blob/step18/async-await/start.js" rel="noopener ugc nofollow" target="_blank"> this file </a>。</p><h2 id="9d46" class="ml kz iq bd la mm mn dn le mo mp dp li kj mq mr lm kn ms mt lq kr mu mv lu mw bi translated">测试增强型应用程序</h2><p id="a473" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">现在您已经为应用程序添加了一些功能，您可以进行一些有价值的测试了。</p><p id="f0ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用以下Node.js命令运行程序:</p><pre class="mb mc md me gt nm mk nn no aw np bi"><span id="3b44" class="ml kz iq mk b gy nq nr l ns nt">node -r esm start.js</span></pre><p id="4694" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从菜单中选择选项1，并验证它是否按预期工作。您的输出应该类似于以下内容，操作数和sum的值随着大多数迭代而变化:</p><pre class="mb mc md me gt nm mk nn no aw np bi"><span id="a3d0" class="ml kz iq mk b gy nq nr l ns nt">First operand: 3<br/>Second operand: 1<br/>Sum: 4<br/>Press Enter to get back to the menu</span></pre><p id="4d6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要关闭程序，请按回车键返回菜单并选择选项“4”。</p><p id="2565" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止的代码在伙伴库的分支<a class="ae kw" href="https://github.com/maciejtreder/asynchronous-javascript/tree/step18/async-await" rel="noopener ugc nofollow" target="_blank">步骤18 </a>中。</p><h1 id="20c1" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">了解等待性能陷阱</h1><p id="e138" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">您已经掌握了async-await，但是还有一点需要注意。正如你已经知道的，<code class="fe mh mi mj mk b">await</code> <em class="kx">同步</em>等待一个<code class="fe mh mi mj mk b">Promise</code>来解决。它真的做到了，毫不留情。有时候可能会疼。</p><p id="886f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建一个名为<em class="kx"> sumSlow.js </em>的新文件，并将以下JavaScript代码放入其中:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="7bac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数返回一个承诺，它在3秒钟后用一个随机生成的数字解决。为了延迟输出，代码使用了<code class="fe mh mi mj mk b">setTimeout</code>函数，这是异步的。</p><p id="d8f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将以下函数添加到<em class="kx"> sumSlow.js </em>文件的底部:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="7b05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数与您之前实现的非常相似。唯一附加的逻辑是使用<code class="fe mh mi mj mk b">console.time</code>和<code class="fe mh mi mj mk b">console.timeEnd</code>来测量这个函数运行的速度。</p><p id="ad81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过在文件顶部添加以下语句，将<code class="fe mh mi mj mk b">addTwoNumbersSlow</code>函数导入到<em class="kx"> start.js </em>文件中:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5e39" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">向<code class="fe mh mi mj mk b">MenuOptions</code>地图添加一个新条目:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="9bac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mh mi mj mk b">displayMenu</code>函数内的<code class="fe mh mi mj mk b">switch</code>语句中添加了一个新的<code class="fe mh mi mj mk b">case</code>，用于控制程序流程:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="6724" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行程序并从菜单中选择选项“2”。检查该函数需要返回多少时间:</p><pre class="mb mc md me gt nm mk nn no aw np bi"><span id="60c7" class="ml kz iq mk b gy nq nr l ns nt">First operand: 2<br/>Second operand: 0<br/>Sum: 2<br/>Time elapsed: 6006.825ms<br/>Press Enter to get back to the menu</span></pre><p id="4e7f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如你所看到的，这个功能需要6秒钟才能完成。为什么？原因是您在<code class="fe mh mi mj mk b">addTwoNumbersSlow</code>功能中使用<code class="fe mh mi mj mk b">await</code>的方式:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="2287" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在检索第一个操作数的过程中，你已经用关键字<code class="fe mh mi mj mk b">await</code>同步阻塞了程序。因此，第二个呼叫在3秒后被初始化，又花了3秒才解决。</p><p id="4341" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很容易解决。将以下函数添加到<em class="kx"> sumSlow.js </em>文件的底部:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="4bbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mh mi mj mk b">addTwoNumbersSlow</code>和<code class="fe mh mi mj mk b">addTwoNumbersFaster</code>的区别在于你如何称呼承诺:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="5c18" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你同时开始了两个承诺的生命周期，之后你通过使用<code class="fe mh mi mj mk b">await</code>关键字来阻止程序等待结果。正因为如此，这些承诺并行不悖。</p><p id="c904" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这两种实现的比较如下图所示:</p><figure class="mb mc md me gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/a1d1423f0ce2e2326fed9e4a0623ef80.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Kx7bpqUsJL3HHWCB.png"/></div></div></figure><p id="3180" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从调整导入语句。/ <em class="kx"> sumSlow </em>在<em class="kx"> start.js </em>文件中添加<code class="fe mh mi mj mk b">addTwoNumbersFaster</code>使其看起来如下:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="6bfc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">向<code class="fe mh mi mj mk b">MenuOptions</code>地图添加新条目:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="c0fc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mh mi mj mk b">displayMenu</code>函数内的<code class="fe mh mi mj mk b">switch</code>语句中添加一个新的<code class="fe mh mi mj mk b">case</code>:</p><figure class="mb mc md me gt jr"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="287a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这些修改之后，你的<em class="kx"> start.js </em>文件应该看起来像<a class="ae kw" href="https://github.com/maciejtreder/asynchronous-javascript/blob/step19/async-await/start.js" rel="noopener ugc nofollow" target="_blank"> this </a>。</p><p id="45cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">运行程序，并通过从菜单中选择选项“3”来调用您刚刚实现的功能。在控制台中，您应该看到所用的时间大约是第一次实现的一半:</p><pre class="mb mc md me gt nm mk nn no aw np bi"><span id="6c60" class="ml kz iq mk b gy nq nr l ns nt">First operand: 2<br/>Second operand: 4<br/>Sum: 6<br/>Time elapsed: 3003.828ms<br/>Press Enter to return to the menu</span></pre><p id="7636" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据您的系统进行计算实际需要的时间，您的实际值应该与上面显示的数字略有不同。</p><p id="446a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">到目前为止的代码是伙伴库中的分支<a class="ae kw" href="https://github.com/maciejtreder/asynchronous-javascript/tree/step19/async-await" rel="noopener ugc nofollow" target="_blank">步骤19 </a>。</p><h1 id="58c7" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">摘要</h1><p id="71de" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">这篇文章介绍了JavaScript中异步处理的工作原理，以及回调和承诺如何提供异步功能。它向您展示了这些语言特性是如何工作的，然后描述了<code class="fe mh mi mj mk b">async</code>和<code class="fe mh mi mj mk b">await</code>关键字如何与这些特性一起工作，以提供对异步处理的更方便、更可读的访问。</p><p id="87f2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个案例研究项目中，您看到了如何使用async、await和Promises实现交互式命令行菜单系统。您还看到了如何使用<a class="ae kw" href="https://www.npmjs.com/package/readline-promise" rel="noopener ugc nofollow" target="_blank"> readline-promise </a>库。</p><h1 id="33cd" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">额外资源</h1><p id="01a1" class="pw-post-body-paragraph jy jz iq ka b kb lw kd ke kf lx kh ki kj ly kl km kn lz kp kq kr ma kt ku kv ij bi translated">要钻研与异步处理相关的JavaScript基础知识，请参阅:</p><p id="e982" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://medium.com/swlh/asynchronous-javascript-understanding-callbacks-8c288c555b23" rel="noopener">异步JavaScript:理解回调</a></p><p id="4392" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想了解更多关于JavaScript的承诺，看看下面的帖子:</p><p id="cdfe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://medium.com/better-programming/asynchronous-javascript-introduction-to-javascript-promises-3142eeea9b38" rel="noopener">异步JavaScript:JavaScript Promises简介</a> <br/> <a class="ae kw" href="https://medium.com/swlh/asynchronous-javascript-advanced-promises-with-node-js-1d4c4b82e8ce" rel="noopener">异步JavaScript:高级Promises with node . js</a><br/><a class="ae kw" href="https://medium.com/weekly-webtips/asynchronous-javascript-using-rxjs-observables-with-rest-apis-in-node-js-f31755c880b3" rel="noopener">异步JavaScript:使用RxJS Observables with REST API in node . js</a></p><p id="df66" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能还想了解RxJS(react vex JavaScript)，对于某些编程情况，它是一个更好的异步工具:</p><p id="77de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://medium.com/swlh/asynchronous-javascript-introducing-reactivex-and-rxjs-observables-2e3ef3bf3a01" rel="noopener">异步JavaScript:引入ReactiveX和RxJS观察器</a> <br/> <a class="ae kw" href="https://medium.com/weekly-webtips/asynchronous-javascript-using-rxjs-observables-with-rest-apis-in-node-js-f31755c880b3" rel="noopener">异步JavaScript:在Node.js中使用带有REST APIs的RxJS观察器</a></p><p id="d429" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有一些第三方资源是JavaScript开发人员必不可少的参考。以下是一些例子:</p><p id="cd6c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" rel="noopener ugc nofollow" target="_blank">MDN web docs:Javascript</a>—Mozilla开发者网络提供了一个全面的Javascript参考网站，包含教程和参考信息。</p><p id="69b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://nodejs.org/en/docs/" rel="noopener ugc nofollow" target="_blank"> Node.js文档</a> —如果您正在编写服务器端JavaScript，Node.js参考文档是一个必不可少的资源。</p><p id="3852" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">RxJS的学习资源和参考信息的网站，RxJS是observer、迭代器模式以及函数式集合编程的JavaScript实现。</p><p id="f987" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://xgrommx.github.io/rx-book/content/which_operator_do_i_use/index.html" rel="noopener ugc nofollow" target="_blank">我应该使用哪个运算符？</a> —为所需操作选择最佳可观察操作员的有用工具。</p><p id="b040" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">想在提高编程技能的同时找点乐子吗？试试Twilio的视频游戏:</p><p id="1444" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://www.twilio.com/quest" rel="noopener ugc nofollow" target="_blank"> TwilioQuest </a> —通过这一16位风格的冒险，击败传统系统的力量。</p></div><div class="ab cl nw nx hu ny" role="separator"><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob oc"/><span class="nz bw bk oa ob"/></div><div class="ij ik il im in"><p id="8a03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">我是Maciej Treder，通过</em><a class="ae kw" href="mailto:contact@maciejtreder.com" rel="noopener ugc nofollow" target="_blank"><em class="kx">contact@maciejtreder.com</em></a><em class="kx">、</em><a class="ae kw" href="https://www.maciejtreder.com/" rel="noopener ugc nofollow" target="_blank"><em class="kx">https://www.maciejtreder.com</em></a><em class="kx">或@ maciejtreder on</em><a class="ae kw" href="http://github.com/maciejtreder" rel="noopener ugc nofollow" target="_blank"><em class="kx">GitHub</em></a><em class="kx">、</em><a class="ae kw" href="https://twitter.com/maciejtreder" rel="noopener ugc nofollow" target="_blank"><em class="kx">Twitter</em></a><em class="kx">和</em> <a class="ae kw" href="https://www.linkedin.com/in/maciej-treder/" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> LinkedIn </em></a></p><p id="ef88" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">本帖原载于</em> <a class="ae kw" href="https://www.twilio.com/blog/asynchronous-javascript-introducing-async-and-await" rel="noopener ugc nofollow" target="_blank"> <em class="kx"> Twilio博客</em> </a> <em class="kx">。</em></p></div></div>    
</body>
</html>