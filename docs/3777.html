<html>
<head>
<title>What is a Monoid?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是幺半群？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/whats-a-monoid-c8b11bde89a3?source=collection_archive---------7-----------------------#2020-10-24">https://javascript.plainenglish.io/whats-a-monoid-c8b11bde89a3?source=collection_archive---------7-----------------------#2020-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="60bb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们封装二进制运算</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6164ec94644ee0002943c10984ac1182.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*121C9iFMpRec9xNj"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@swimstaralex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alexander Sinn</a> on <a class="ae kv" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0652" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在所有优秀的JS人员都喜欢函数式编程。我的许多读者已经知道了单子，以及它的其他函子朋友。但是，你偶尔会看到的另一个类似的词呢——幺半群。Monoid在网络上比Monad更难以捉摸。你不会找到太多关于这个话题的好材料。但是，它们仍然是计划生育范畴理论的重要组成部分。</p><blockquote class="ls"><p id="224a" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">幺半群封装一个二进制运算。</p></blockquote><p id="c8d9" class="pw-post-body-paragraph kw kx iq ky b kz mc jr lb lc md ju le lf me lh li lj mf ll lm ln mg lp lq lr ij bi translated">我喜欢认为幺半群是二进制运算的封装。您可以<em class="mh">连接</em>幺半群实例，产生一个具有合并的基础值的新幺半群。您也可以将其简化为基本值，就像Monad <em class="mh">一样。</em>让我们尝试手工滚动几个幺半群，以了解它们都是关于什么的。我们将从一个有趣的开始，它存在于有对象的语言中——这里有一个JavaScript赋值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/0db511e63be944321e8ef4988152d933.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ECLyHSnKfqQNbOpgurG46w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The Assign Monoid defined in JavaScript.</figcaption></figure><p id="5cd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Assign拿起一个物体，把它包在一个漂亮的盒子里。我总是用符号隐藏数据类型的基础值。符号对于每个符号来说都是唯一的，就像GUID一样，并且只能通过一些特殊的反射功能或者通过访问符号本身来观察(提示:不要让您的符号在代码库中面向用户)。就像我之前说的，你可以把类似幺半群的实例连接在一起。<code class="fe mj mk ml mm b">concat</code>获取相同类型的幺半群(在本例中为赋值)，并使用合并的值创建一个新的幺半群。它封装了一个二进制对象分配操作。我们必须打开提供的Monoid来完成这个操作，就像链接Monads一样。我们以后会更多地讨论单子和幺半群的关系。为了方便起见，我还包括了一个<code class="fe mj mk ml mm b">empty</code>构造函数。它们有点不同于函子——它们没有将<code class="fe mj mk ml mm b">map</code>变形到它们的容器上下文中；它们只是封装了一个二进制函数。</p><p id="b14d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意我是如何使用扩展语法将参数克隆到赋值的基础值中的。这是一个安全网，因为JavaScript中的对象是引用类型——如果您使用<code class="fe mj mk ml mm b">=</code>运算符将一个对象分配给两个不同的变量，这两个变量将<em class="mh">引用</em>同一个对象:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/e4b125c70fad1c25854426d709fdf57b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P2dc4-oXF2ARX7Hr_StWFw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Explanation of referential equality.</figcaption></figure><p id="e87c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，修改一个变量将会修改引用的对象，从而改变任何引用该对象的变量的值。这不是很好，我们想要FP中透明的不可变数据，所以为了确保我们不会变异引用，我只是把它复制到一个新的对象中，就像<code class="fe mj mk ml mm b">myObj3</code>一样，这个新的对象又会引用堆中的不同对象。</p><p id="d146" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，在我继续讲另一个幺半群之前，让我们先玩一会儿赋值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/73703ee00a126203f4d42725b1dd3d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OxoevfhoEkD6SIdWd054vA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Playing around with the Assign Monoid.</figcaption></figure><p id="2af1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们试试另一个幺半群——Max。它采用一个数值，并在连接时返回两者的最大数值:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/9b1819016615802390de776352b5abe6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u95SocY-TutQa6qQqOOLTg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The Max Monoid defined in JavaScript.</figcaption></figure><p id="e4f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你很容易想到最小值、和、乘积、商、Eq，甚至更多的幺半群。实际上任何二元运算都可以变成幺半群。</p><p id="0be8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这导致我们为幺半群定义一个接口！尽管接口在JavaScript世界中并不存在，但它是在任何编程语言中思考问题抽象的一种强有力的方式。抽象是更好编程的关键。让我们来定义这个接口:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/3fe28c7f92fd013c3620881582d66a1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3USberoKEfUSQ-bktAFtAQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The Monoid Interface.</figcaption></figure><p id="25b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mj mk ml mm b">concat</code>接受与调用者相同类型的幺半群，并返回一个相同类型的新幺半群，该幺半群表示您的二元运算的合并值。<code class="fe mj mk ml mm b">unwrap</code>让我们进入单核盒的内容，<code class="fe mj mk ml mm b">empty</code>允许我们拥有一个<em class="mh">单元</em>构造器。基本等同于那个幺半群可以表示的恒等式值。因此，Sum <code class="fe mj mk ml mm b">empty</code>将为0，乘积或商将为1，Max将为0(假设为正值)，Min将为无穷大，依此类推。<em class="mh">(注:我用</em> <code class="fe mj mk ml mm b"><em class="mh">static</em></code> <em class="mh">来表示</em> <code class="fe mj mk ml mm b"><em class="mh">empty</em></code> <em class="mh">与构造函数关联，而不是与实例关联)</em></p><p id="1645" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终，您会希望将这些链接在一起:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/debe1a5c0081479b4e3576caa888ce6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Lqlo-y__AlTp6hKHAge-8A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">One way to chain calls to concat.</figcaption></figure><p id="db22" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是看看所有散布函数调用和最后的展开。我们可以做得更好。输入<code class="fe mj mk ml mm b">mconcat</code>，和<code class="fe mj mk ml mm b">mreduce</code>。一些有趣的功能名称。它们分别意味着幺连接和幺归约。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mi"><img src="../Images/b8770e2c66a311d283d71908ac5d0cc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mRJ0TC3CX_He-leSqRzDlg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">mconcat and mreduce definitions.</figcaption></figure><p id="60b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们做的事情基本相同，但是<code class="fe mj mk ml mm b">mconcat</code>将值留在容器中，而<code class="fe mj mk ml mm b">mreduce</code>将值取出。注意我们需要空的构造函数！那个<code class="fe mj mk ml mm b">empty</code>构造函数允许我们对任何幺半群使用<code class="fe mj mk ml mm b">mconcat</code>和<code class="fe mj mk ml mm b">mreduce</code>。这就是为什么它是幺半群接口的一部分。</p><p id="a6af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到使用我们闪亮的新功能后,<code class="fe mj mk ml mm b">concat</code>的调用链看起来和感觉上都好了很多。一旦你理解了<code class="fe mj mk ml mm b">mconcat</code>和<code class="fe mj mk ml mm b">mreduce</code>的含义，它就比那些大组的连接更加易读，它们的名字是这些函数中唯一真正奇怪的部分。除此之外，他们很清楚自己要做什么。</p><blockquote class="ls"><p id="b5ff" class="lt lu iq bd lv lw lx ly lz ma mb lr dk translated">那么这和单子有什么关系呢？</p></blockquote><p id="4d3f" class="pw-post-body-paragraph kw kx iq ky b kz mc jr lb lc md ju le lf me lh li lj mf ll lm ln mg lp lq lr ij bi translated">让我们用那个让每个人都疯狂的关于单子的古老描述——“单子只是函子范畴中的幺半群。”我们现在知道了幺半群，以及它们如何封装一个二元运算，以及如何归约到它们的内部值。我们知道函子和它们的能力。嗯，等等…你怎么称呼一个可以解开其内容的函子？嘿，那是单子！这就是幺半群是函子范畴中幺半群的原因。封装的操作是容器上下文内容上的形态(函数)的应用。现在我们称它为<code class="fe mj mk ml mm b">map</code>，而不是<code class="fe mj mk ml mm b">concat</code>。我认为<code class="fe mj mk ml mm b">map</code>是合适的——它的名字暗示你可能得到一个不同类型的容器，或者从类型<code class="fe mj mk ml mm b">a</code>到类型<code class="fe mj mk ml mm b">b</code>的<em class="mh">映射</em>。</p><p id="2990" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章有助于明确什么是幺半群，以及它与幺半群的关系。下次见，FP on，朋友们！</p></div></div>    
</body>
</html>