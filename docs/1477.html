<html>
<head>
<title>Server-Side Rendering in React — ExpressJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React-express js中的服务器端渲染</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/server-side-rendering-in-react-expressjs-8a87af0edba4?source=collection_archive---------1-----------------------#2020-03-21">https://javascript.plainenglish.io/server-side-rendering-in-react-expressjs-8a87af0edba4?source=collection_archive---------1-----------------------#2020-03-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d711" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何使用ExpressJS框架将React应用程序配置为在服务器和客户机上呈现。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/899bb1cbb2354396fc4ae4aec5c5f3cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gN6le7a9wWF82XrkV18Ebg.jpeg"/></div></div></figure><p id="96b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我之前关于React中服务器端渲染的文章中，我简要描述了同构和通用应用程序的概念。我还展示了这种方法的优点和缺点。今天，我将<strong class="kt ir">进入要点</strong>并向您展示如何使用<a class="ae ln" href="https://expressjs.com" rel="noopener ugc nofollow" target="_blank"> ExpressJS </a>框架配置通用React应用程序！</p><p id="e719" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我将描述如何为客户端配置应用程序，然后我将转换它，使它也可以在服务器端工作。这将是React通用应用程序的最基本的例子。稍后，在本系列的后续问题中，我将通过使用<a class="ae ln" href="https://redux.js.org" rel="noopener ugc nofollow" target="_blank"> Redux </a>和<a class="ae ln" href="https://reacttraining.com/react-router/web/guides/quick-start" rel="noopener ugc nofollow" target="_blank"> react-router </a>来扩展我的代码。</p><h1 id="cc01" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">起点React组件示例</h1><p id="a7d3" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">如果我们正在创建一个通用的应用程序，我们必须处理两种情况:在服务器和客户端的渲染。当web浏览器请求内容时，我们的应用程序应该准备所有必要的数据，用它填充HTML代码，并将其返回给浏览器。然后，浏览器将加载包含我们的应用程序的客户端版本的所有JavaScript文件。由于这一点，与我们网站的进一步互动将成为可能。</p><p id="c409" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要实现以上目标，我们的app需要两个出发点。对于服务器，它将是<code class="fe ml mm mn mo b">server.js</code>文件，对于<code class="fe ml mm mn mo b">client.js</code>客户机，它将是文件。我们稍后将讨论这两个文件，但是首先，让我们创建主要的React组件。它可能看起来像下面这样(<code class="fe ml mm mn mo b">App.js</code>):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/c1ff3dc1bc69440b1ce1f44cbef60358.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*10ztjFEFTp0NWXcPniwUHQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">App.js</figcaption></figure><p id="5bed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，这是一个简单的组件，它从它的<code class="fe ml mm mn mo b">props</code>中获取一些初始文本，将其分配给状态，然后呈现它——我们希望它在服务器上完成<strong class="kt ir">。</strong></p><p id="ea57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，还有一个按钮可以改变州的<code class="fe ml mm mn mo b">text</code>属性的值。这种互动将在客户端上<strong class="kt ir">完成。</strong></p><h1 id="625b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">客户端渲染</h1><p id="f4f8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在我们有了一个组件，我们可以渲染它了。现在，让我们只为客户做这件事。请看下面<code class="fe ml mm mn mo b">client.js</code>文件的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/cc2f1f14ac1564745d67a352eba3d593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Md1MPF-0dFHLKUM0Ygwk3g.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">client.js</figcaption></figure><p id="a7e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您使用React已经有一段时间了，那么您应该熟悉上面的代码。多亏了<code class="fe ml mm mn mo b">ReactDOM</code>对象的<code class="fe ml mm mn mo b">render</code>方法，我们可以将<code class="fe ml mm mn mo b">App</code>组件注入到带有“app”标识符的HTML元素中。它只发生在浏览器加载了我们的JavaScript文件之后(之前呈现了一个空白页面)。请注意初始文本是如何传递到组件中的。</p><p id="10ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，如果我们想要完成所有这些工作，我们必须向我们的项目添加一些包:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/b89f53597f157250a428e5ce8af9c58e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L48gAlgFZe-ECt1x-E_Ucg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Add react and react-dom to your project</figcaption></figure><p id="0b30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，<strong class="kt ir">我在这里没有使用</strong>中的<code class="fe ml mm mn mo b">--dev</code>参数。这是因为我不仅在客户端的“捆绑包”中需要这些包，在服务器上也需要。</p><h2 id="4dff" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">客户端准备</h2><p id="8abc" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">下一步是准备<code class="fe ml mm mn mo b">index.html</code>文件。它将附加我们的客户端脚本(浏览器将在加载索引文件后加载它)。它还将有一个带有“应用程序”标识符的容器，我们的应用程序将被注入其中。要处理这一切，将使用<a class="ae ln" href="https://webpack.js.org" rel="noopener ugc nofollow" target="_blank"> webpack </a>。</p><p id="567f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们从安装所有必要的<strong class="kt ir">软件包开始:</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/63fdadcf7388519223c414d3c116fd5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*czwHfkEid2Jt-IXq9SD9bg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Add webpack, babel and html-webpack-plugin</figcaption></figure><p id="8e28" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们还需要一些巴别塔预设(预定义的巴别塔插件):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/56b1c07e78215e32495e1f6adf1e6cfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B2zKXnORNCfVz2_CKa10KQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Add Babel presets</figcaption></figure><p id="8dbb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后但同样重要的是，我们应该安装Babel polyfill包(用于客户端和服务器，因此没有<code class="fe ml mm mn mo b">--dev</code>参数):</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/caa5d64c0a0b043cafbb6600af187730.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_9Ap0aIaeZNDcdefHtHSOg.png"/></div></div></figure><p id="9883" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们为什么需要这个？嗯，Babel可以翻译JavaScript语法，但ECMAScript的后续版本引入了各种本机方法或全局对象(例如<code class="fe ml mm mn mo b">Promise</code>)。感谢<code class="fe ml mm mn mo b">babel-polyfill</code>我们可以<strong class="kt ir">模拟</strong>整个ES6+环境。</p><p id="75e3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，现在我们准备将<code class="fe ml mm mn mo b">index.html</code>文件添加到我们的项目中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/df3af6ff75bb526e72c36e6e9d4974ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T-iLmjAO2mHCkXXBVNE0SQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">index.html</figcaption></figure><p id="e7c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将使用这个文件作为应用程序的起点——至少现在是这样——当我们添加服务器端配置时，这个文件就不再需要了。请注意,“app”容器——我们的React应用程序将在这里注入。</p><p id="18d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您可能还注意到没有附加客户端脚本——这是因为它还没有准备好。它将由webpack生成，然后使用名为<code class="fe ml mm mn mo b">html-webpack-plugin</code>的webpack插件注入到索引文件中。</p><h2 id="1bc6" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">客户端部件的Webpack配置</h2><p id="37c8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在，让我们配置webpack来生成客户端的包。为此，我们必须将<code class="fe ml mm mn mo b">webpack.config.js</code>文件添加到我们的项目中。请看下面它的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/250c66195f051f14a061882a1e4325da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0pEr6oRYQgUeCgdleZ1GmQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Client-side webpack configuration</figcaption></figure><p id="6383" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于那些不熟悉配置webpack的人，让我简短地解释一下上面例子中配置的所有选项。首先，我们设置了<code class="fe ml mm mn mo b">mode</code>选项，告诉webpack使用它的内置优化。</p><p id="cc7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在<code class="fe ml mm mn mo b">entry</code>部分，我们配置包的入口点<strong class="kt ir">是什么。如您所见，目前，我们只有一个名为<code class="fe ml mm mn mo b">client</code>的入口点，它指向<code class="fe ml mm mn mo b">client.js</code>文件。请注意，在加载这个文件之前，我们还要加载<code class="fe ml mm mn mo b">babel-polyfill</code>库。</strong></p><p id="31d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，在<code class="fe ml mm mn mo b">output</code>部分，我们可以定义<strong class="kt ir">放置输出文件的位置</strong>。这里，我们将目标文件夹设置为<code class="fe ml mm mn mo b">build</code>,文件名为<code class="fe ml mm mn mo b">[name].js</code>,其中<code class="fe ml mm mn mo b">[name]</code>是一个占位符，将被入口点名称(在我们的例子中就是<code class="fe ml mm mn mo b">client</code>)替换。</p><p id="2955" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一节叫做<code class="fe ml mm mn mo b">module</code>。在这里，我们可以配置将用于转换所有指定文件类型的所有加载程序。在我们的例子中，我们使用<code class="fe ml mm mn mo b">babel-loader</code>来转换<code class="fe ml mm mn mo b">*.js</code>和<code class="fe ml mm mn mo b">*.jsx</code>文件。</p><p id="766b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们配置插件和优化。<code class="fe ml mm mn mo b">HtmlWebpackPlugin</code>插件用于将输出的捆绑JavaScript文件注入到<code class="fe ml mm mn mo b">index.html</code>文件中(我们之前讨论过)。在<code class="fe ml mm mn mo b">optimization</code>部分，我们告诉webpack将所有的供应商放到(从<code class="fe ml mm mn mo b">node_modules</code>导入的包)单独的<code class="fe ml mm mn mo b">vendor.js</code>文件中。</p><p id="0f17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，现在我们可以测试我们的配置了。我们可以通过调用下面的命令(位于项目的根文件夹中)来实现:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/3ddffbbd9bd2f0054c680f5bfa59d35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_VWcM4Ou9OLAa_Is6dD4fw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Call webpack to build the app</figcaption></figure><p id="5e10" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将创建包含所有必要文件的<code class="fe ml mm mn mo b">build</code>目录。如果你想测试它，只需进入这个文件夹并运行一些本地web服务器，例如，在Mac上你可以运行Python的简单服务器:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/1004b5dd61cd82542c69558a49aa6b0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u5HUYOFQZeHzOuq8EjsP0w.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Run some local server to test</figcaption></figure><p id="25dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在打开你的网络浏览器，打开<a class="ae ln" href="http://localhost:8000" rel="noopener ugc nofollow" target="_blank"> http://localhost:8000 </a>页面。</p><h1 id="1b92" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">服务器端渲染</h1><p id="5786" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在我刚刚描述的解决方案中，我们简单地将webpack生成的脚本注入到<code class="fe ml mm mn mo b">index.html</code>文件中。当web浏览器呈现HTML文件时，会加载注入的脚本，然后立即调用。<strong class="kt ir">这导致React的组件树被翻译成DOM元素并放在“app”容器中。</strong></p><p id="56f3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，是时候向我们的应用程序添加服务器端呈现了。我们的目标是将最后一部分(渲染并将其放入容器)移动到服务器。由于这一点，浏览器将获得已经适当完成的<code class="fe ml mm mn mo b">index.html</code>文件，用户不必等待脚本加载。</p><p id="e9fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们开始调整配置之前，我们必须安装一些依赖项。首先，是“开发”部分:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/fccb7dccd9769cebb91b314b548e196a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YwI5CsZU4IIgVAEEQsDK4Q.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Add webpack-node-externals package</figcaption></figure><p id="b890" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，两种环境的通用选项:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/5a39b06a827f4ae7856f1ca18b267c7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LEAGYFVcQtw-TntKjpTdQw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Add express package</figcaption></figure><p id="8e0a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">稍后我会解释为什么我们需要它们。</p><h2 id="a6d9" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">Html反应组件</h2><p id="6c54" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">在仅客户端方法中，为了准备<code class="fe ml mm mn mo b">index.html</code>文件，我们使用了<code class="fe ml mm mn mo b">HtmlWebpackPlugin</code>。因为现在我们想在服务器上呈现整个React组件树，<strong class="kt ir">我们必须使用更复杂的方法</strong>。这就是为什么我将介绍将取代<code class="fe ml mm mn mo b">index.html</code>文件的<code class="fe ml mm mn mo b">Html.js</code>组件。请看下面我是如何实现的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/1d653d2c626a21093908471d72e93630.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KBlcXGa01nhtX3HBfqN0Wg.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Html.js</figcaption></figure><p id="1066" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的组件呈现了与<code class="fe ml mm mn mo b">index.html</code>或多或少相同的HTML结构。它还获得两个道具:<code class="fe ml mm mn mo b">children</code>和<code class="fe ml mm mn mo b">scripts</code>。第一个的内容注入到“app”容器中。我们必须使用<code class="fe ml mm mn mo b">dangerouslySetInnerHTML</code>属性，因为<code class="fe ml mm mn mo b">children</code>包含字符串形式的HTML标记，我们不希望它被转义。</p><p id="f14c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">属性是一个URL数组。我们将它们映射成一系列的<code class="fe ml mm mn mo b">script</code>元素。这样，我们将把webpack生成的所有客户端脚本附加到我们的应用程序中。</p><p id="e2d1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们已经创建了<code class="fe ml mm mn mo b">Html.js</code>组件，我们就可以安全地删除<code class="fe ml mm mn mo b">index.html</code>文件。</p><h2 id="8c06" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">最后:在服务器上渲染</h2><p id="b862" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在我们可以转移到这篇文章最关键的部分。让我们创建<code class="fe ml mm mn mo b">server.js</code>文件。它将是应用程序的一个入口点，并将在基于<a class="ae ln" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>的服务器上被调用。为了更容易地使用它的网络功能，我们将使用<a class="ae ln" href="https://expressjs.com" rel="noopener ugc nofollow" target="_blank"> ExpressJS </a>框架(几分钟前我们将它添加到我们的项目中)。</p><p id="3522" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好的，请看一下<code class="fe ml mm mn mo b">server.js</code>文件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/ded452a75ebeafc401ccfd0eda60c7bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o03T3UBeySSYN3exWmz7cA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">server.js</figcaption></figure><p id="828a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看这里有什么…首先，请注意从<code class="fe ml mm mn mo b">react-dom/server</code>包中导入<code class="fe ml mm mn mo b">ReactDOMServer</code>。它允许我们在服务器上呈现React组件树<strong class="kt ir">。我们还导入了一些其他的包，以及我们已经创建的两个组件(<code class="fe ml mm mn mo b">Html</code>和<code class="fe ml mm mn mo b">App</code>)。</strong></p><p id="2498" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">下一件事是调用一个express方法，并将其结果赋给<code class="fe ml mm mn mo b">app</code>常量。这样，我们就初始化了ExpressJS框架。在下一行中，我们通知express，我们的静态文件(像webpack生成的脚本)放在那里。</p><p id="897d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在接下来的一行中(即<code class="fe ml mm mn mo b">app.get</code>调用),我们开始了示例中最激动人心的部分，但是我们将在稍后进行讨论。首先，让我们看看最后一行——通过调用<code class="fe ml mm mn mo b">app</code>对象的<code class="fe ml mm mn mo b">listen</code>方法，我们启动了整个应用程序——它开始监听端口3000。</p><p id="9f48" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，现在让我们回到上面提到的<code class="fe ml mm mn mo b">app.get</code>调用。这样，我们可以处理web浏览器发送的GET请求。作为调用的第一个参数，我们传递想要处理的地址。在我们的例子中是一个星号——这意味着作为调用的第二个参数传递的回调函数将被每个GET请求调用。</p><p id="9a85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">回调函数带两个参数:<code class="fe ml mm mn mo b">req</code>(请求对象)和<code class="fe ml mm mn mo b">res</code>(响应对象)。我们将在方法的最后使用其中的第二个，但是首先，会发生一些事情。</p><p id="046d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们定义一个数组，包含webpack生成的脚本的路径。我们将把它传递给<code class="fe ml mm mn mo b">Html</code>组件——您可能还记得，在那里，我们将它映射到一系列<code class="fe ml mm mn mo b">script</code>标签中。</p><p id="fc72" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其次，我们调用<code class="fe ml mm mn mo b">ReactDOMServer</code>对象的<code class="fe ml mm mn mo b">renderToString</code>方法。我们将<code class="fe ml mm mn mo b">App</code>组件作为该方法的参数传递。请注意我们分配给它的<code class="fe ml mm mn mo b">initialText</code>属性的文本。通过这种方式，我们将整个React应用程序渲染为字符串，并将其赋给常量<code class="fe ml mm mn mo b">appMarkup</code>。</p><p id="533a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第三，我们调用<code class="fe ml mm mn mo b">ReactDOMServer</code>对象的另一个方法— <code class="fe ml mm mn mo b">renderToStaticMarkup</code>。它的工作原理几乎和<code class="fe ml mm mn mo b">renderToString</code>法一样。唯一的区别是<code class="fe ml mm mn mo b">renderToStaticMarkup</code> <strong class="kt ir">省略了</strong>所有的HTML属性在渲染时都会添加到DOM中。我们将<code class="fe ml mm mn mo b">Html</code>组件作为调用的参数传递。它通过属性获取<code class="fe ml mm mn mo b">children</code>和<code class="fe ml mm mn mo b">scripts</code>数组。这样，我们包装了刚刚由HTML主体呈现的React组件树，并将其作为字符串保存在<code class="fe ml mm mn mo b">html</code>常量中。</p><p id="90f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，我们只调用<code class="fe ml mm mn mo b">res</code>对象的<code class="fe ml mm mn mo b">send</code>方法。通过这样做，我们将完整呈现的应用程序发送到浏览器。</p><h2 id="ad0b" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated">对webpack配置的更改</h2><p id="4a3e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated"><code class="fe ml mm mn mo b">server.js</code>文件导入React组件并使用ES6+语法。这就是为什么我们也必须通过webpack运行它。请看下图，修改后的<code class="fe ml mm mn mo b">webpack.config.js</code>文件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/9ecbbeb4f7490bf14309f3db2a2d02db.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9oIf1BxTIUb10lVsMQNZyw.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">webpack.config.js — final version</figcaption></figure><p id="ba7c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">长话短说，让我们只关注T21最重要的事情。</p><p id="70c4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在上面的例子中，我们现在有两种配置:<code class="fe ml mm mn mo b">clientConfig</code>用于客户机，而<code class="fe ml mm mn mo b">serverConfig</code>用于服务器。此外，我们有包含配置的共同部分的<code class="fe ml mm mn mo b">common</code>对象。请注意我们是如何在文件末尾导出配置的——使用数组，我们可以将多个设置传递给webpack。</p><p id="22db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于配置的客户端部分，几乎没有什么变化——唯一的事情是使用<code class="fe ml mm mn mo b">HtmlWebpackPlugin</code>不再是必要的<strong class="kt ir"/>。此外，还添加了<code class="fe ml mm mn mo b">node</code>属性——通过该选项，我们可以配置是多填充还是模仿特定的Node.js全局变量和模块。还请注意<code class="fe ml mm mn mo b">name</code>和<code class="fe ml mm mn mo b">target</code>属性如何定义输出的目的。</p><p id="87d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们看看配置的服务器部分。如您所见，我们将加载器配置与客户端配置(<code class="fe ml mm mn mo b">...common</code>)共享。这次<code class="fe ml mm mn mo b">target</code>属性指向“节点”。我们还添加了<code class="fe ml mm mn mo b">externals</code>选项，定义了在绑定过程中需要但在输出文件中不需要的所有依赖关系(多亏了<code class="fe ml mm mn mo b">webpack-node-externals</code>库，我们不必自己做这件事)。当然，<strong class="kt ir">最重要的</strong>是两个属性:<code class="fe ml mm mn mo b">entry</code>和<code class="fe ml mm mn mo b">output</code>。除了使用babel polyfills，我们还设置了几分钟前刚刚定义的<code class="fe ml mm mn mo b">server.js</code>文件的入口点。输出包将放在<code class="fe ml mm mn mo b">build</code>目录中。</p><h1 id="2e1e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">共享初始状态</h1><p id="1850" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">好了，现在我们已经为服务器和客户端配置了应用程序，我们可以测试它是如何工作的了。让我们删除<code class="fe ml mm mn mo b">bulild</code>文件夹(只是为了确保我们从一个干净的构建开始)，并调用以下命令:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/cebc8ae8cba198cfbcb6f68927fcd2b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7HcLJpC55PZXTDiZk--OfQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Build and run the app</figcaption></figure><p id="896d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的命令将构建服务器和客户端代码，将其放入<code class="fe ml mm mn mo b">build</code>文件夹，然后运行应用程序。现在，在web浏览器中打开<a class="ae ln" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>地址，查看结果。</p><p id="0d16" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这不是我们想要达到的目标，对吗？当浏览器加载我们的应用程序时，它首先呈现服务器端版本(您可能会看到几毫秒的“在服务器上呈现”文本)，然后运行客户端代码，将原始文本替换为“在客户端呈现”</p><p id="52ad" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这个问题，我们必须在服务器和客户端之间共享应用程序的初始状态。为此，让我们修改<code class="fe ml mm mn mo b">Html.js</code>组件代码，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/540ccfaff84a627b98ea0e5548caef68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BjcoQ4XOvQE6WVI6BZVg5w.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Modified Html.js component</figcaption></figure><p id="6834" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里增加了两点:首先，我们通过道具传递了额外的属性——<code class="fe ml mm mn mo b">initialState</code>；其次，我们添加了一个脚本，将它转换成JSON格式，并将其分配给<code class="fe ml mm mn mo b">window.APP_STATE</code>属性。</p><p id="77ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当然，我们刚刚添加的脚本会在浏览器中呈现页面后被调用，所以不用怕<code class="fe ml mm mn mo b">window</code>对象没有定义。</p><p id="23fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，也该修改<code class="fe ml mm mn mo b">server.js</code>文件了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/6f329446ad071ab59387114443291e7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PY6TeYI3vv8NljTxHrevOQ.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Modified server.js file</figcaption></figure><p id="f9b2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们快速浏览一下这里发生了什么变化…首先，引入了<code class="fe ml mm mn mo b">initialState</code>对象。其次，我们将它同时传递给了<code class="fe ml mm mn mo b">App.js</code>和<code class="fe ml mm mn mo b">Html.js</code>组件。</p><p id="c970" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可能想知道下面这句话是什么意思:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/e4eb964d174bc2bbe6505e948ce40c8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jG7FLWDgwIKtvoQeDMOung.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Passing attributes using the spread operator</figcaption></figure><p id="a724" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">spread操作符的用法就是将<code class="fe ml mm mn mo b">initialState</code>对象的所有属性作为<code class="fe ml mm mn mo b">App.js</code>组件的属性进行传递。所以上面的语句等于下面的语句:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/a0810dc6017c3a81b58fa5c9fe65d1c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GfvyH5lHKULGKajnyoJ05Q.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Passing attributes explicitly</figcaption></figure><p id="324d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们做的最后一件事是将整个<code class="fe ml mm mn mo b">initialState</code>对象传递给<code class="fe ml mm mn mo b">Html.js</code>组件。这样它将被添加到<code class="fe ml mm mn mo b">window.APP_STATE</code>属性中，如前所述。</p><p id="1074" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的项目还有最后一件事要做。我们必须在客户端代码中获取初始状态的值。我们可以通过修改<code class="fe ml mm mn mo b">client.js</code>文件来做到这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/c59f84651c3589fd55015f014030649e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D9XaB7TINJUx5Y8mJhNqgA.png"/></div></div><figcaption class="mq mr gj gh gi ms mt bd b be z dk">Modified client.js file</figcaption></figure><p id="5956" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们已经知道的，这段代码将在浏览器中被调用，所以我们可以确定<code class="fe ml mm mn mo b">window</code>对象是可用的。我们期望它定义了<code class="fe ml mm mn mo b">APP_STATE</code>属性，并使用spread操作符将其所有属性作为<code class="fe ml mm mn mo b">App.js</code>组件的属性进行传递。</p><p id="b34f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意我们在这里介绍的第二个区别。我们通过调用<code class="fe ml mm mn mo b">hydrate</code>方法替换了<code class="fe ml mm mn mo b">ReactDOM</code>对象的<code class="fe ml mm mn mo b">render</code>方法。如果我们在服务器上预渲染React代码，并希望将其与客户端React代码连接，我们必须使用<code class="fe ml mm mn mo b">hydrate</code>方法——否则我们将在控制台中得到一个错误。</p><p id="7e66" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好了，现在都准备好了！可以通过调用<code class="fe ml mm mn mo b">webpack &amp;&amp; node ./build/server.js</code>并在浏览器中打开<a class="ae ln" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>来再次测试。这一次，您将看到预期的“在服务器上呈现”文本。</p><h1 id="b037" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">摘要</h1><p id="352e" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我希望尽管这篇文章很长，我已经合理地解释了一切。我认为它非常简单，我希望你在使用它时不会有问题。</p><blockquote class="nj nk nl"><p id="a510" class="kr ks nm kt b ku kv jr kw kx ky ju kz nn lb lc ld no lf lg lh np lj lk ll lm ij bi translated">我们今天讨论的例子是在我的GitHub库中可用的<a class="ae ln" href="https://github.com/burczu/react-server-side-rendering-example" rel="noopener ugc nofollow" target="_blank">。我鼓励你克隆它，然后自己玩。</a></p></blockquote><p id="5bec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在“React中的服务器端呈现”系列的下一期中，我计划解释如何在我们的SSR示例中处理Redux。</p></div><div class="ab cl nq nr hu ns" role="separator"><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv nw"/><span class="nt bw bk nu nv"/></div><div class="ij ik il im in"><p id="4484" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章是关于使用React进行服务器端渲染的系列文章的一部分。请参见下面的系列文章列表:</p><ul class=""><li id="ac5a" class="nx ny iq kt b ku kv kx ky la nz le oa li ob lm oc od oe of bi translated"><a class="ae ln" href="https://medium.com/@bartomiejdybowski/server-side-rendering-in-react-an-introduction-55f4c7fa274b" rel="noopener">React中的服务器端渲染—简介</a></li><li id="3987" class="nx ny iq kt b ku og kx oh la oi le oj li ok lm oc od oe of bi translated"><a class="ae ln" href="https://medium.com/@bartomiejdybowski/server-side-rendering-in-react-expressjs-8a87af0edba4" rel="noopener">React-express . js中的服务器端渲染</a></li><li id="5996" class="nx ny iq kt b ku og kx oh la oi le oj li ok lm oc od oe of bi translated"><a class="ae ln" href="https://medium.com/@bartomiejdybowski/server-side-rendering-in-react-redux-8d6209fbfed" rel="noopener">React-Redux中的服务器端渲染</a></li><li id="1faf" class="nx ny iq kt b ku og kx oh la oi le oj li ok lm oc od oe of bi translated"><a class="ae ln" href="https://medium.com/@bartomiejdybowski/server-side-rendering-in-react-redux-ab0af31c9c4b" rel="noopener">React-React-router中的服务器端渲染</a></li><li id="c2ff" class="nx ny iq kt b ku og kx oh la oi le oj li ok lm oc od oe of bi translated">React中的服务器端渲染—处理真实数据</li></ul><h2 id="67ee" class="mu lp iq bd lq mv mw dn lu mx my dp ly la mz na ma le nb nc mc li nd ne me nf bi translated"><strong class="ak">用简单的英语写的JavaScript的注释:</strong></h2><p id="e4f9" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们总是有兴趣帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，请用你的Medium用户名发邮件到<a class="ae ln" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">submissions@javascriptinplainenglish.com</a>给我们，我们会把你添加为作者。</p></div></div>    
</body>
</html>