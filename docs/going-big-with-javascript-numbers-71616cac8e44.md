# 用 JavaScript 做大:数字

> 原文：<https://javascript.plainenglish.io/going-big-with-javascript-numbers-71616cac8e44?source=collection_archive---------4----------------------->

![](img/624a10baad11bd1e2ee030eacd07c3e9.png)

像所有事情一样，JavaScript 也有局限性。有趣的是，有人为的限制，也有物理的限制。我将探索这些极限，并尽可能地将它们推向真正的极限。

在 JavaScript 中，[w3schools.com](https://www.w3schools.com/js/js_numbers.asp)将数字定义为:

> 与许多其他编程语言不同，JavaScript 没有定义不同类型的数字，如整数、短整型、长整型、浮点型等。
> 
> 遵循国际 IEEE 754 标准，JavaScript 数字总是存储为双精度浮点数。
> 
> 这种格式以 64 位存储数字，其中数字(分数)存储在 0 至 51 位，指数存储在 52 至 62 位，符号存储在 63 位

这实际上意味着什么？在 JavaScript 中，可以存储的最大可能数是 1.7976931348623157e+308，或者使用**数。MAX _ VALUE**

当我们试图超越这一点时，事情开始变得奇怪。我试着运行下面的代码，期望得到“无穷大”。这并没有发生。

```
console.log(Number.MAX_VALUE+1);*1.7976931348623157e+308*
```

这与[文档](https://www.w3schools.com/jsref/jsref_max_value.asp)所说的“大于 MAX_VALUE 的数字表示为无穷大”不一致

*边注:以下测试是使用谷歌 Chrome 控制台完成的，因此其他 JS 解释器可能会产生不同的结果。*

然后我找到了一个不是无穷大的最大数。

```
console.log(Number.MAX_VALUE+999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999);*1.7976931348623157e+308*
```

如果我们添加一个额外的“1”，如下所示:

```
console.log(Number.MAX_VALUE+999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999**1**);*Infinity*
```

我们现在得到无穷大。那么发生了什么？

我们现在来谈谈[号。MAX_SAFE_INTEGER](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER) ，其定义为:

> `Number.MAX_SAFE_INTEGER`常量代表 JavaScript (2⁵ -1)中的最大安全整数。

一个实际的解释是，超过这个限制，JavaScript 解释器就不再对操作负责。

看看下面的代码:

```
console.log(Number.MAX_SAFE_INTEGER);
*900719925474099****1***console.log(Number.MAX_SAFE_INTEGER**+1**);
*900719925474099****2***let a = Number.MAX_SAFE_INTEGER+1;
let b = Number.MAX_SAFE_INTEGER+2;
console.log(a === b);
*true*
```

从上面的结果我们看到，我们绝对可以在“MAX_SAFE_INTEGER”上面走，但是任何从实用的角度想做的事情都不再起作用了。当我们知道 a 和 b 不相等时，它们被认为是相等的。

# 如果我们想超越 MAX_SAFE_INTEGER 怎么办？

JavaScript 有一个原生函数叫做 [**BigInt**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) 。正如它的名字所描述的，它处理大数字。激活起来也极其简单。在数字的末尾加一个“n ”,它会立即被转换。

```
const theBiggestInt = 9007199254740991n;
typeof theBiggestInt;
*"bigint"*
```

那么为什么不一直使用“BigInt”**呢？你可以很容易地做“1n ”,现在它是一个 BigInt，你有一个更大的数量限制。有什么问题吗？ **BigInt 不能处理小数。****

**这意味着，如果您从一个数字转换到一个 BigInt，然后再反向转换，您可能会失去精度。还有一个兼容性问题，只有现代浏览器支持它。这不是一个真正的问题，因为它很可能只在 NodeJS 中需要，这是受支持的。**

**我们现在将尝试我们之前有问题的 MAX_VALUE，并将结果**包装在** BigInt:**

```
console.log(BigInt(Number.MAX_VALUE));
*17976931348623157081452742373170435679807056752584499659891747680315726078002853876058955863276687817154045895351438246423432132688946418276846754670353751698604991057655128207624549009038932894407586850845513394230458323690322294816580855933212334827479782620414472316873817718091929988125040402618412485836****8****n*console.log(BigInt(Number.MAX_VALUE**+1**));
*17976931348623157081452742373170435679807056752584499659891747680315726078002853876058955863276687817154045895351438246423432132688946418276846754670353751698604991057655128207624549009038932894407586850845513394230458323690322294816580855933212334827479782620414472316873817718091929988125040402618412485836****8****n*
```

**上面的例子说明了这是怎么回事。当我们增加更多的数字时。MAX_VALUE，那就干脆忽略。这两个方程得出相同的答案。为什么？我不知道，这取决于 JavaScript 解释器。**

**我们现在可以做的是使用 BigInt 使**超过**数。MAX_VALUE。这一次，我们将针对 MAX_VALUE 的 BigInt 值使用增量，而不是 MAX_VALUE 的结果。**在下面，注意括号中的“+1n”相对于上面代码的位置。****

```
console.log(BigInt(Number.MAX_VALUE)**+1n**);
*17976931348623157081452742373170435679807056752584499659891747680315726078002853876058955863276687817154045895351438246423432132688946418276846754670353751698604991057655128207624549009038932894407586850845513394230458323690322294816580855933212334827479782620414472316873817718091929988125040402618412485836****9****n*
```

**正如我们在上面看到的，我们的最终数字从“8”增加到了“9”。所以 BigInt **确实如**所描述的那样工作。让我们试试我们的比较:**

```
let ab = BigInt(Number.MAX_VALUE);
let bb = BigInt(Number.MAX_VALUE)**+1n**;
console.log(ab === bb);
*false*
```

**正如我们所看到的，我们能够做高于这个数字的比较。MAX_VALUE 限制，缺点是不能使用小数位。**

**BigInt 确实有限制，但是没有任何上限的“硬限制”，甚至没有任何“软限制”。文档中没有提到它。根据其他人在 StackOverflow 上的经验，似乎这些限制是由 JavaScript 解释器和设备的内存限制决定的。当达到非常大的数字时，性能也会受到明显的影响。**

**总之，在极少数需要的情况下，超越 JavaScripts 的本地数量限制是可能的。一个例子是，如果你想找到质数，因为这些不需要小数位。**

**虽然在大多数情况下你不需要使用 BigInt，但是你会想要通过检查**数字来确保你没有超出本地限制。MAX_SAFE_INTEGER** 如果你知道你可能达到那个数字。**