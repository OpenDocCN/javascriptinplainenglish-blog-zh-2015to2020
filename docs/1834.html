<html>
<head>
<title>How to create Middleware with Express.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Express.js创建中间件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/express-js-middleware-ddcc79d98dc9?source=collection_archive---------8-----------------------#2020-04-27">https://javascript.plainenglish.io/express-js-middleware-ddcc79d98dc9?source=collection_archive---------8-----------------------#2020-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/30d36c579ddac5010e7e5ad0820778a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5dCRMucqWRXpmgXr"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Source: <a class="ae jd" href="https://www.pexels.com/photo/grayscale-photo-of-computer-laptop-near-white-notebook-and-ceramic-mug-on-table-169573/" rel="noopener ugc nofollow" target="_blank">Negative Space on pexels.com</a></figcaption></figure><div class=""/><blockquote class="kd ke kf"><p id="47f4" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">在本文中，我们将学习Express中的中间件方法。JS框架以及如何在我们的代码中应用它们</p></blockquote></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="b644" class="lm ln jg bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">基本思想:什么是中间件？</h1><p id="9c15" class="pw-post-body-paragraph kg kh jg kj b kk mk km kn ko ml kq kr mm mn ku kv mo mp ky kz mq mr lc ld le ij bi translated">通俗地说，网络服务器是<strong class="kj jh">输入请求</strong>和<strong class="kj jh">输出响应的功能。</strong>这里，中间件是在传入请求之后在中间执行的功能，然后产生输出。该输出可以是</p><ul class=""><li id="bc7b" class="ms mt jg kj b kk kl ko kp mm mu mo mv mq mw le mx my mz na bi translated">最终输出，或</li><li id="9f32" class="ms mt jg kj b kk nb ko nc mm nd mo ne mq nf le mx my mz na bi translated">由下一个中间件使用，直到周期完成。</li></ul><p id="490e" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">这反过来意味着我们可以有一个以上的中间件功能，它们将按照声明的顺序执行(<strong class="kj jh">链式顺序</strong>)</p><p id="f32b" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">因为它们是以链状顺序执行的，所以我们可以这样用图解法表示:</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ng"><img src="../Images/24946c0377d3e50fd1d3741fadc3a4b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Mq_5O-pEJJIQIx2J.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Middleware A is called first, so it will run first, then Middleware B, and so on and so forth</figcaption></figure><p id="3253" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">由于它们是<code class="fe nl nm nn no b">express</code>框架的一部分，它们可以访问请求对象(<code class="fe nl nm nn no b">req</code>)和响应对象(<code class="fe nl nm nn no b">res</code>),以及应用程序响应周期中的<code class="fe nl nm nn no b"> next</code>功能。有关在Express中处理请求的更多信息，请单击此处<a class="ae jd" href="https://medium.com/easyread/introduction-to-express-js-246191ec05f2" rel="noopener"/>。</p><p id="361f" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated"><code class="fe nl nm nn no b"> next </code>函数是Express中的一个函数，当被调用时，它执行当前中间件之后的中间件。简而言之，这意味着<code class="fe nl nm nn no b">next</code>函数将执行列表中的下一个中间件。</p><p id="93a8" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated"><strong class="kj jh">此外，请记住，Express应用程序本质上是一系列中间件调用。</strong></p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="1065" class="lm ln jg bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">中间件的基本声明</h1><p id="edb9" class="pw-post-body-paragraph kg kh jg kj b kk mk km kn ko ml kq kr mm mn ku kv mo mp ky kz mq mr lc ld le ij bi translated">为了声明一个中间件函数，</p><pre class="nh ni nj nk gt np no nq nr aw ns bi"><span id="ad9c" class="nt ln jg no b gy nu nv l nw nx">const MiddleWareFunction1 = <strong class="no jh">function(req,res,next)</strong>=&gt; {<br/>//code to be executed , main logic located here, then <br/><strong class="no jh">next()</strong><br/>})</span></pre><blockquote class="kd ke kf"><p id="75ee" class="kg kh ki kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">注意:请注意拨打<code class="fe nl nm nn no b">next()</code>。这里，这个函数调用应用程序中的下一个中间件函数。这个函数必须被调用，否则请求将被挂起。<code class="fe nl nm nn no b">next()</code>功能不是节点的一部分。JS或Express API，但这是传递给中间件函数的第三个参数。你可以随意命名这个函数，但是按照惯例它总是被命名为<code class="fe nl nm nn no b">next</code>。</p></blockquote></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="8fc8" class="lm ln jg bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">使用中间件</h1><p id="f093" class="pw-post-body-paragraph kg kh jg kj b kk mk km kn ko ml kq kr mm mn ku kv mo mp ky kz mq mr lc ld le ij bi translated">要使用它，我们将使用名为:</p><pre class="nh ni nj nk gt np no nq nr aw ns bi"><span id="8240" class="nt ln jg no b gy nu nv l nw nx">app.use(middlewareFunction)</span></pre><p id="4f5e" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">由于Express在路由方法中使用中间件，我们甚至可以像这样使用它</p><pre class="nh ni nj nk gt np no nq nr aw ns bi"><span id="3df3" class="nt ln jg no b gy nu nv l nw nx">app.use(route, middlewareFunction)</span></pre><p id="1ae6" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">这意味着如果用户导航到<code class="fe nl nm nn no b">route</code>路径，将调用<code class="fe nl nm nn no b">middlewareFunction()</code>。</p><h1 id="9a9b" class="lm ln jg bd lo lp ny lr ls lt nz lv lw lx oa lz ma mb ob md me mf oc mh mi mj bi translated">链状订单</h1><p id="659f" class="pw-post-body-paragraph kg kh jg kj b kk mk km kn ko ml kq kr mm mn ku kv mo mp ky kz mq mr lc ld le ij bi translated">如开始所讨论的，如果首先调用<code class="fe nl nm nn no b">middlewareA</code>，那么它将首先执行，然后该行中的下一个中间件函数将执行。</p><p id="fe4b" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">我们可以用这样的代码形式来写:</p><pre class="nh ni nj nk gt np no nq nr aw ns bi"><span id="d3e5" class="nt ln jg no b gy nu nv l nw nx">app.use(middlewareFunctionA) //Will run first<br/>app.use(middlewareFunctionB) //Will run second<br/>app.use(middlewareFunctionC) //Will run second in line.</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="d39c" class="lm ln jg bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">例子</h1><h2 id="9749" class="nt ln jg bd lo od oe dn ls of og dp lw mm oh oi ma mo oj ok me mq ol om mi on bi translated">1.MyLogger</h2><p id="1713" class="pw-post-body-paragraph kg kh jg kj b kk mk km kn ko ml kq kr mm mn ku kv mo mp ky kz mq mr lc ld le ij bi translated">在这里，只要有请求通过应用程序，我们就会打印“log”字样。</p><figure class="nh ni nj nk gt is"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="a880" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">要运行它，请在终端上键入:<code class="fe nl nm nn no b">node middleware-basic</code>，然后在另一个终端上键入:<code class="fe nl nm nn no b">curl localhost:3000</code>。这可能是输出:</p><p id="a51a" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">在客户端</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oq"><img src="../Images/30260287c27fb84b48bad00e82b2ace6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vG2f6paY_5u8UOd7i1Bv4g.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">client side output</figcaption></figure><p id="5552" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">在服务器端:</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi or"><img src="../Images/76bb378e1e6f645c8e07acbbb9ae0eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lzRj3uGFeKMxAP3wQ9BKAw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Server side output</figcaption></figure><h2 id="e803" class="nt ln jg bd lo od oe dn ls of og dp lw mm oh oi ma mo oj ok me mq ol om mi on bi translated">2.请求时间函数</h2><p id="b08d" class="pw-post-body-paragraph kg kh jg kj b kk mk km kn ko ml kq kr mm mn ku kv mo mp ky kz mq mr lc ld le ij bi translated">还记得我说过中间件函数可以访问<code class="fe nl nm nn no b">req</code>和<code class="fe nl nm nn no b">res</code>对象吗？我们可以给这些对象添加属性，然后将它们传递给下一个中间件，如下所示:</p><p id="cabb" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">下面是一个简单的示例，显示了发送请求的日期和时间:</p><pre class="nh ni nj nk gt np no nq nr aw ns bi"><span id="53f8" class="nt ln jg no b gy nu nv l nw nx">var requestTime= function((req,res,next)=&gt;{<br/>req.responseTime = Date.now() //add responseTime property to req<br/>next()<br/>})</span></pre><p id="a463" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">要使用该函数，请编写代码:</p><figure class="nh ni nj nk gt is"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="3c32" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated"><code class="fe nl nm nn no b">console.log</code>不习惯服务器端没有输出。在客户端(使用了<code class="fe nl nm nn no b">cURL</code>),输出为:</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi os"><img src="../Images/f47f30c598b3b28a632ab9e0addd89a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GYANntm9kcGKljJ5CGDRxA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">output at client side terminal window</figcaption></figure><h2 id="bf54" class="nt ln jg bd lo od oe dn ls of og dp lw mm oh oi ma mo oj ok me mq ol om mi on bi translated">validateAPIKey函数</h2><p id="ef60" class="pw-post-body-paragraph kg kh jg kj b kk mk km kn ko ml kq kr mm mn ku kv mo mp ky kz mq mr lc ld le ij bi translated">在这个函数中，我们将检查URL中是否存在API键。如果不是，则应用程序将关闭，否则调用<code class="fe nl nm nn no b">next</code>(应用程序继续下一步)。</p><figure class="nh ni nj nk gt is"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="0081" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">这样，我们甚至可以使用中间件来确保URL是正确的。这是中间件功能的一个常见用例。</p><p id="068e" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">要运行它，在第一个终端窗口中执行<code class="fe nl nm nn no b">node</code>命令，然后在第二个终端窗口中，像这样使用<code class="fe nl nm nn no b">curl</code>:</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi ot"><img src="../Images/a85385d4a98519923fdcb1a2d6850026.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*tC9AonJlBsmggd8iFtnP-Q.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Application proceeds only if API key is found.</figcaption></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="58a4" class="lm ln jg bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">可配置中间件</h1><p id="677c" class="pw-post-body-paragraph kg kh jg kj b kk mk km kn ko ml kq kr mm mn ku kv mo mp ky kz mq mr lc ld le ij bi translated">假设您的中间件函数占用了许多行代码。因此，您希望它在另一个模块中。可以用<code class="fe nl nm nn no b">module.exports</code>。这也使得您的中间件可配置。要了解<code class="fe nl nm nn no b">module.exports</code>，点击<a class="ae jd" href="https://medium.com/analytics-vidhya/node-js-modules-exports-80d9b1bc2acf" rel="noopener">这里</a>。</p><p id="14ac" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">这方面的一个例子可以是:</p><p id="2b6e" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">在文件<code class="fe nl nm nn no b">my-middleware.js</code>中</p><pre class="nh ni nj nk gt np no nq nr aw ns bi"><span id="163a" class="nt ln jg no b gy nu nv l nw nx">module.exports = function (options) {<br/>  return function (req, res, next) {<br/>    // Implement the middleware function based on the options object<br/>    next()<br/>  }<br/>}</span></pre><p id="ec92" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">在文件<code class="fe nl nm nn no b">main.js</code>中</p><pre class="nh ni nj nk gt np no nq nr aw ns bi"><span id="e234" class="nt ln jg no b gy nu nv l nw nx">var mw = require('./my-middleware.js')<br/><br/>app.use(mw({ option1: '1', option2: '2' }))</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="da4c" class="lm ln jg bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">中间件子栈</h1><p id="6917" class="pw-post-body-paragraph kg kh jg kj b kk mk km kn ko ml kq kr mm mn ku kv mo mp ky kz mq mr lc ld le ij bi translated">您甚至可以在<code class="fe nl nm nn no b">app.use</code>中加载多个中间件功能，以节省更多时间并使您的程序看起来不那么复杂。</p><p id="3918" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">你可以这样做:</p><figure class="nh ni nj nk gt is"><div class="bz fp l di"><div class="oo op l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Here is an example of loading a series of middleware functions at a mount point, with a mount path.</figcaption></figure><p id="9305" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">输出如下所示</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/b331351b410c7df4ecf68dc3b4804e50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1306/format:webp/1*1JnwGwLgPA2Fe4Cni9WLbw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Server side output</figcaption></figure><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/6b918c5bd78746274c5ac137230a3d7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*awmX1f-mRP0fe6DpGDb4uw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Client side output</figcaption></figure><h1 id="31d1" class="lm ln jg bd lo lp ny lr ls lt nz lv lw lx oa lz ma mb ob md me mf oc mh mi mj bi translated">中间件中的错误处理</h1><p id="148d" class="pw-post-body-paragraph kg kh jg kj b kk mk km kn ko ml kq kr mm mn ku kv mo mp ky kz mq mr lc ld le ij bi translated">与具有三个参数的普通中间件功能不同，错误处理中间件功能将具有<strong class="kj jh">四个</strong>参数:</p><pre class="nh ni nj nk gt np no nq nr aw ns bi"><span id="07ff" class="nt ln jg no b gy nu nv l nw nx">function (error, req, res, next) {</span><span id="471d" class="nt ln jg no b gy ow nv l nw nx"> console.log(error) //in case an error has occured.</span><span id="1cc9" class="nt ln jg no b gy ow nv l nw nx">next()</span><span id="2952" class="nt ln jg no b gy ow nv l nw nx">}</span></pre><p id="d6eb" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">Express API将搜索我们所有的中间件功能。如果它发现一个中间件有四个参数而不是三个。它将中间件表示为一个错误处理中间件，也就是说，它将允许您访问它之前的任何中间件抛出的任何错误。</p><h1 id="6d1d" class="lm ln jg bd lo lp ny lr ls lt nz lv lw lx oa lz ma mb ob md me mf oc mh mi mj bi translated">使用外部中间件</h1><p id="60b0" class="pw-post-body-paragraph kg kh jg kj b kk mk km kn ko ml kq kr mm mn ku kv mo mp ky kz mq mr lc ld le ij bi translated">编程社区还构建了其他类型的中间件来简化您的生产阶段或其他阶段，或者为您完成一些繁重的逻辑工作。它们被称为<strong class="kj jh">外部中间件</strong>，或<strong class="kj jh">第三方中间件</strong></p><h2 id="bb83" class="nt ln jg bd lo od oe dn ls of og dp lw mm oh oi ma mo oj ok me mq ol om mi on bi translated">正文分析器</h2><p id="e392" class="pw-post-body-paragraph kg kh jg kj b kk mk km kn ko ml kq kr mm mn ku kv mo mp ky kz mq mr lc ld le ij bi translated">其中之一就是<code class="fe nl nm nn no b">body-parser</code>。我在之前的<a class="ae jd" href="https://medium.com/easyread/introduction-to-express-js-246191ec05f2" rel="noopener">教程</a>里用过。它将请求体解析为json、url编码等。要使用它，您需要首先安装它:</p><pre class="nh ni nj nk gt np no nq nr aw ns bi"><span id="c49f" class="nt ln jg no b gy nu nv l nw nx">npm install body-parser</span></pre><p id="3f76" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">这里有一个解析<code class="fe nl nm nn no b">json</code>数据的例子</p><figure class="nh ni nj nk gt is"><div class="bz fp l di"><div class="oo op l"/></div></figure><p id="0ae0" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">首先在一个窗口运行<code class="fe nl nm nn no b">node</code>命令，然后在另一个窗口使用<code class="fe nl nm nn no b">curl</code>。输出如下所示</p><figure class="nh ni nj nk gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ox"><img src="../Images/25176dde41d089014915859804bf4481.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HQRiYHrS6neRr0viEg2QqQ.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Client side output</figcaption></figure><figure class="nh ni nj nk gt is gh gi paragraph-image"><div class="gh gi oy"><img src="../Images/c54834615781c7509b1b3125f24775ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*PEeR61MPvMFij8OT9ZGUzg.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Server side output</figcaption></figure><p id="3fb7" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated"><strong class="kj jh">注意</strong> : <code class="fe nl nm nn no b">-H</code>表示我们必须指定标题。这很重要，否则<code class="fe nl nm nn no b">req.body</code>将返回一个空体，即<code class="fe nl nm nn no b">{}</code>。因此，表示一个标题是非常重要的。</p><p id="5ae4" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">注意JSON数据是如何被<code class="fe nl nm nn no b">body-parser</code>解析的</p><p id="9b7b" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">外部中间件的另一个例子是<a class="ae jd" href="https://www.npmjs.com/package/morgan/v/1.1.1" rel="noopener ugc nofollow" target="_blank"> morgan </a>，它用于给出关于HTTP请求的简明日志。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="3563" class="lm ln jg bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">到目前为止我们所学内容的回顾</h1><ul class=""><li id="fe80" class="ms mt jg kj b kk mk ko ml mm oz mo pa mq pb le mx my mz na bi translated">要声明中间件:</li></ul><pre class="nh ni nj nk gt np no nq nr aw ns bi"><span id="1aa1" class="nt ln jg no b gy nu nv l nw nx">const myMiddleware = function(<strong class="no jh">req,res,next</strong>)=&gt;{<br/>// main logic code here<br/><strong class="no jh">next() </strong>//absolutely necessary<br/>})</span></pre><ul class=""><li id="ae45" class="ms mt jg kj b kk kl ko kp mm mu mo mv mq mw le mx my mz na bi translated">使用它</li></ul><pre class="nh ni nj nk gt np no nq nr aw ns bi"><span id="d0b2" class="nt ln jg no b gy nu nv l nw nx">app.use(myMiddleware)</span></pre><ul class=""><li id="763d" class="ms mt jg kj b kk kl ko kp mm mu mo mv mq mw le mx my mz na bi translated">链式订单可以用以下方式在代码中表示:</li></ul><pre class="nh ni nj nk gt np no nq nr aw ns bi"><span id="e9dd" class="nt ln jg no b gy nu nv l nw nx">app.use(middlewareFunction1) //will run first<br/>app.use(middlewareFunction2) //will run second<br/>app.use(middlewareFunction3) //will run third</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="8b47" class="lm ln jg bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">词汇表</h1><p id="a302" class="pw-post-body-paragraph kg kh jg kj b kk mk km kn ko ml kq kr mm mn ku kv mo mp ky kz mq mr lc ld le ij bi translated"><strong class="kj jh"> invoke- </strong>每当一个函数被调用，这意味着该函数已经被<strong class="kj jh">调用</strong>。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="d77e" class="lm ln jg bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">外部资源</h1><ul class=""><li id="d2ed" class="ms mt jg kj b kk mk ko ml mm oz mo pa mq pb le mx my mz na bi translated"><a class="ae jd" href="https://expressjs.com/en/guide/writing-middleware.html" rel="noopener ugc nofollow" target="_blank">编写中间件</a></li><li id="c244" class="ms mt jg kj b kk nb ko nc mm nd mo ne mq nf le mx my mz na bi translated"><a class="ae jd" href="https://expressjs.com/en/guide/using-middleware.html" rel="noopener ugc nofollow" target="_blank">使用快递中间件</a></li><li id="cdea" class="ms mt jg kj b kk nb ko nc mm nd mo ne mq nf le mx my mz na bi translated"><a class="ae jd" href="https://expressjs.com/en/resources/middleware.html" rel="noopener ugc nofollow" target="_blank">快递第三方中间件</a></li><li id="b63d" class="ms mt jg kj b kk nb ko nc mm nd mo ne mq nf le mx my mz na bi translated"><a class="ae jd" href="https://www.youtube.com/watch?v=MIr1oxQ3pao" rel="noopener ugc nofollow" target="_blank">express js——中间件</a>到底是什么？</li><li id="c6cd" class="ms mt jg kj b kk nb ko nc mm nd mo ne mq nf le mx my mz na bi translated"><a class="ae jd" href="https://www.tutorialspoint.com/expressjs/expressjs_middleware.htm" rel="noopener ugc nofollow" target="_blank"> ExpressJS-中间件-教程点</a></li></ul></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="fa1d" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">今天到此为止。非常感谢你坚持到最后！我希望你从这篇文章中学到了很多。祝您愉快！</p><p id="7301" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">呆在家里，注意安全。</p><h2 id="4f32" class="nt ln jg bd lo od oe dn ls of og dp lw mm oh oi ma mo oj ok me mq ol om mi on bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="3771" class="pw-post-body-paragraph kg kh jg kj b kk mk km kn ko ml kq kr mm mn ku kv mo mp ky kz mq mr lc ld le ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae jd" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kj jh">AI in Plain English</strong></a><a class="ae jd" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kj jh">UX in Plain English</strong></a><a class="ae jd" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kj jh">Python in Plain English</strong></a><strong class="kj jh"/>——谢谢，继续学习！</p><p id="dec9" class="pw-post-body-paragraph kg kh jg kj b kk kl km kn ko kp kq kr mm kt ku kv mo kx ky kz mq lb lc ld le ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae jd" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kj jh">submissions @ plain English . io</strong></a><strong class="kj jh"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>