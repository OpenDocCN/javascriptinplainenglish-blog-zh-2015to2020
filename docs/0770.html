<html>
<head>
<title>How to reverse a tree in JavaScript the Functional way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用函数的方式在JavaScript中反转一棵树</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-reverse-a-tree-in-javascript-the-functional-way-440d7106b277?source=collection_archive---------2-----------------------#2019-12-08">https://javascript.plainenglish.io/how-to-reverse-a-tree-in-javascript-the-functional-way-440d7106b277?source=collection_archive---------2-----------------------#2019-12-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/f639f64b97498e5fb4f8264c0bf8feef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kyKIISHY4nnV-AwgxXMylg.png"/></div></div></figure><div class=""/><p id="e6ab" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">树是计算机科学中唯一最重要的数据结构，仅次于列表。几乎你在编程生涯中所做的一切都与树有关。例如JSON对象、xml、html DOM都是树结构。面向对象的JavaScript开发人员在进入函数式编程领域时，会很快学会如何使用map和reduce来取代传统的for循环。他们不知道的是<strong class="jx iz">树也有一个地图和减少方法</strong>。在这篇文章中，我们将展示反转<a class="ae kt" href="https://en.wikipedia.org/wiki/Binary_tree" rel="noopener ugc nofollow" target="_blank">二叉树</a>的函数方法。</p><p id="5935" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们有一棵像这样的树</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="34b2" class="ld le iy kz b gy lf lg l lh li">     6<br/>   /   \     <br/>  3     4            <br/> / \   / \<br/>7   3 8   1</span></pre><p id="a68d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们想定义一个函数<strong class="jx iz"> Reverse </strong>，它将给出这棵树的结果</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="f513" class="ld le iy kz b gy lf lg l lh li">     6<br/>   /   \<br/>  4     3<br/> / \   / \<br/>1   8 3   7</span></pre><p id="a3ed" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将从ES6树形结构开始</p><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="lj lk l"/></div></figure><p id="31e9" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以用这样的对象来表示第一棵树:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="6ae2" class="ld le iy kz b gy lf lg l lh li">     6<br/>   /   \     <br/>  3     4            <br/> / \   / \<br/>7   3 8   1</span><span id="d656" class="ld le iy kz b gy ll lg l lh li">new Node(new Node(new Leaf(7),3,new Leaf(3)), 6, new Node(new Leaf(8),4,new Leaf(1)));</span></pre><h1 id="8028" class="lm le iy bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated"><strong class="ak">定义树上的模式匹配</strong></h1><p id="6c57" class="pw-post-body-paragraph jv jw iy jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">我们要定义的第一件事是一个非常简单的树结构上的<strong class="jx iz"> matchWith </strong>方法。</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="7d64" class="ld le iy kz b gy lf lg l lh li">class Tree {}</span><span id="eafa" class="ld le iy kz b gy ll lg l lh li">class Node extends Tree {<br/>    constructor(left, v, right) {<br/>        super()<br/>        this.v = v;<br/>        this.left = left;<br/>        this.right = right;<br/>    }<br/>    <strong class="kz iz">matchWith(</strong> pattern<strong class="kz iz">) {<br/>        return </strong> pattern<strong class="kz iz">.Node(this.left, this.v, this.right);<br/>    }</strong><br/>}</span><span id="398e" class="ld le iy kz b gy ll lg l lh li">class Leaf extends Tree {<br/>    constructor(v) {<br/>        super()<br/>        this.v = v;<br/>    }<br/>    <strong class="kz iz">matchWith(</strong> pattern<strong class="kz iz">) {<br/>        return </strong> pattern<strong class="kz iz">.Leaf(this.v);<br/>    } </strong><br/>}</span></pre><p id="d322" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将一个对象作为参数:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="188b" class="ld le iy kz b gy lf lg l lh li">pattern =({<br/>            Leaf: v =&gt; {}   ,<br/>           Node: (left, v, right) =&gt; { }<br/>        })</span></pre><p id="caef" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并允许我们区分节点和叶子[这被称为<a class="ae kt" href="https://en.wikipedia.org/wiki/Pattern_matching" rel="noopener ugc nofollow" target="_blank">模式匹配</a></p><p id="a37c" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">就这样！！！！！我们完成了。<strong class="jx iz">我们现在可以在这个树上定义任何类型的递归方法</strong>。那么我们如何递归地定义逆向？</strong></p><p id="19b6" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看看下面的小提琴</p><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="mo lk l"/></div></figure><p id="1f46" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所有的奇迹都发生在这里:</p><pre class="ku kv kw kx gt ky kz la lb aw lc bi"><span id="def1" class="ld le iy kz b gy lf lg l lh li">Tree.<strong class="kz iz">prototype.reverse</strong> = function ( ) {<br/>    return this.<strong class="kz iz">matchWith</strong>({<br/>        Leaf: v =&gt; new Leaf(v)   ,<br/>        Node: (left, v, right) =&gt; {<br/>            return new Node(<strong class="kz iz">right.reverse()</strong>,v,<strong class="kz iz">left.reverse()</strong>)<br/>        }<br/>    });<br/>}</span></pre><ol class=""><li id="8121" class="mp mq iy jx b jy jz kc kd kg mr kk ms ko mt ks mu mv mw mx bi translated">如果你在一片叶子上，只需返回叶子:<strong class="jx iz"> Leaf: v = &gt; new Leaf(v) </strong></li></ol><p id="eed1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.如果你在一个节点<strong class="jx iz">上，只需在左右节点</strong>上调用reverse，然后返回一个包含这些反转的新节点的节点:new Node(<strong class="jx iz">Right . reverse()</strong>，v，<strong class="jx iz"> left.reverse() </strong>)</p><p id="3f0a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">【顺便说一下这种递归定义的方法叫做<a class="ae kt" href="https://en.wikipedia.org/wiki/Structural_induction" rel="noopener ugc nofollow" target="_blank">结构归纳法】</a></p><p id="aed8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们再做一个例子，这样你就能认出这个模式。</p><h1 id="c74d" class="lm le iy bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">计数节点</h1><p id="9f12" class="pw-post-body-paragraph jv jw iy jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">假设我们想要计算树的节点数。我们要怎么做:</p><ol class=""><li id="6853" class="mp mq iy jx b jy jz kc kd kg mr kk ms ko mt ks mu mv mw mx bi translated">如果你在树叶上，只需返回1</li><li id="98c1" class="mp mq iy jx b jy my kc mz kg na kk nb ko nc ks mu mv mw mx bi translated">如果你在一个节点<strong class="jx iz">中，只需要调用左边和右边节点</strong>的countNodes。然后对结果求和(值节点也计为+1)。</li></ol><figure class="ku kv kw kx gt ip"><div class="bz fp l di"><div class="mo lk l"/></div></figure><p id="bd2d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结论:</p><p id="4abd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在数据结构上使用函数定义对每个开发人员的工具和技术来说都是一个有用的补充。</p></div></div>    
</body>
</html>