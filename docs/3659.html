<html>
<head>
<title>How JavaScript Code is Executed Under the Hood</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript代码是如何在幕后执行的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/an-under-the-hood-at-how-javascript-code-is-executed-2ddd5f2e9dde?source=collection_archive---------11-----------------------#2020-10-15">https://javascript.plainenglish.io/an-under-the-hood-at-how-javascript-code-is-executed-2ddd5f2e9dde?source=collection_archive---------11-----------------------#2020-10-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d61e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">白板系列第二部分。map()本机函数</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/e2f0963ec4d6b4262cb7fba9b6f3da86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YM6DRCunovvnzCwk"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@aleksowlade?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aleksander Vlad</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5499" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在我之前的博客中，我已经建立了。map()原生函数，仔细看看它是什么。这里是我写的代码的快速回顾。这段代码将用于演示JavaScript执行一段代码时会发生什么。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="db8a" class="lu lv in lq b gy lw lx l ly lz">function map(array,callback){<br/>    let newArray=[];    <br/>    for (let i=0; i&lt;array.length; i++){<br/>         newArray.push(callback(array[i]))<br/>    };   <br/> <br/>   return newArray<br/>}</span></pre></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><h2 id="1ca8" class="lu lv in bd mh mi mj dn mk ml mm dp mn lc mo mp mq lg mr ms mt lk mu mv mw mx bi translated">什么是执行上下文？</h2><p id="c539" class="pw-post-body-paragraph kt ku in kv b kw my jo ky kz mz jr lb lc na le lf lg nb li lj lk nc lm ln lo ig bi translated">根据定义，<strong class="kv io"> <em class="nd">执行上下文是JavaScript代码被执行和评估的地方</em>。我发现把它想象成一栋房子更容易。取决于你在哪个房间和你的任务的环境，你能得到的会稍微不同。除非你做的事情有点不同，否则可以肯定地说，你可能不会在浴室里给自己做一顿地道的英式早餐。JavaScript代码以同样的方式运行。它执行的地方改变了某些变量的值，比如<strong class="kv io">T5 this。 </strong></strong></p><p id="653e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一般来说，执行上下文明显有两个阶段:</p><ol class=""><li id="eb3a" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nj nk nl nm bi translated"><strong class="kv io">创建阶段</strong></li><li id="30c7" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nj nk nl nm bi translated"><strong class="kv io">执行阶段</strong></li></ol><p id="87e6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当JavaScript代码运行时，在<strong class="kv io">创建阶段</strong>，引擎(在引擎盖下)创建一个<strong class="kv io">全局执行上下文，</strong>这是执行代码的地方。其中有全局内存，用来存储变量和函数定义。在我的例子中，控制台也是可用的，以便向程序员显示值。请注意，您希望在控制台上显示的值必须在console.log()中；否则，您将无法看到您的代码是否正确运行，甚至无法看到它是否已经完全执行。下图显示了引擎盖下发生的事情的简单白板版本。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/30a115516f080f33d85748009da1fd40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QedT3KPmrDxWe_1pZ1mW5A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Simple diagram of the creation phase of the Global Execution Context</figcaption></figure><p id="d95c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<strong class="kv io">执行阶段，</strong> JavaScript代码逐行执行，遵循执行的线程。简而言之，这意味着JavaScript是一种单线程语言。前一行代码执行完毕后，它只能移动到下一行代码。在这个阶段，它分配变量并执行函数调用。注意，每次调用函数时，都会创建一个新的本地或函数级执行上下文。一旦执行了函数的求值，返回值将被发送回全局执行上下文并存储在全局内存中。<strong class="kv io">和往常一样，不要担心，我们将详细介绍上面显示的地图功能。</strong></p></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><h2 id="884c" class="lu lv in bd mh mi mj dn mk ml mm dp mn lc mo mp mq lg mr ms mt lk mu mv mw mx bi translated">JavaScript如何执行代码</h2><p id="a35b" class="pw-post-body-paragraph kt ku in kv b kw my jo ky kz mz jr lb lc na le lf lg nb li lj lk nc lm ln lo ig bi translated">出于参考目的，我将从顶部再次粘贴代码，以便我们可以更仔细地查看它。我已经对它进行了编号，所以我们可以遵循JavaScript如何运行脚本，并使它更容易被引用。</p><pre class="kd ke kf kg gt lp lq lr ls aw lt bi"><span id="dc40" class="lu lv in lq b gy lw lx l ly lz">1)function map(array,callback){<br/>      let newArray=[];    <br/>      for (let i=0; i&lt;array.length; i++){<br/>          newArray.push(callback(array[i]))<br/>      };   <br/> <br/>     return newArray<br/>  }</span><span id="7c23" class="lu lv in lq b gy nt lx l ly lz">2) map([1,2,3], function addTwo(num){num +2})</span><span id="d0f1" class="lu lv in lq b gy nt lx l ly lz">(we can always use an arrow function but for the purposes of visually demonstration this syntax is easier)</span></pre><h2 id="ebae" class="lu lv in bd mh mi mj dn mk ml mm dp mn lc mo mp mq lg mr ms mt lk mu mv mw mx bi translated">第一阶段</h2><p id="b3dc" class="pw-post-body-paragraph kt ku in kv b kw my jo ky kz mz jr lb lc na le lf lg nb li lj lk nc lm ln lo ig bi translated">当JavaScript逐行执行代码时:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/cc03938b905f028d5335c58b3b198922.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XQJHXh52LZi4sjcSFDLQQg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Function definition of map is stored in Global Memory</figcaption></figure><ul class=""><li id="3d06" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nv nk nl nm bi translated">创建具有全局存储器的全局执行上下文。</li><li id="b317" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nv nk nl nm bi translated">使用变量和函数——第一次通过时，JavaScript存储变量和函数名，并给它赋值undefined。</li><li id="cc75" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nv nk nl nm bi translated">第二次，它给变量赋值，并存储函数定义。</li></ul><h2 id="0246" class="lu lv in bd mh mi mj dn mk ml mm dp mn lc mo mp mq lg mr ms mt lk mu mv mw mx bi translated">次相</h2><p id="7d9b" class="pw-post-body-paragraph kt ku in kv b kw my jo ky kz mz jr lb lc na le lf lg nb li lj lk nc lm ln lo ig bi translated">当JavaScript到达数字2时，在上面的代码片段中，使用数组[1，2，3]调用map函数，回调函数addTwo(num){num+2}都作为参数传递。注意，初始函数定义中的(数组，回调)被称为<strong class="kv io">参数</strong>，是临时占位符。这些参数名称稍后会被重新分配，以便它们的值成为传入的参数。</p><p id="cf64" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这一点上，我们不能在不谈论<strong class="kv io">调用栈的情况下继续前进。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">A visual example of a callstack</figcaption></figure><p id="7f7b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从上图来看，<strong class="kv io">调用栈</strong>就像Gru。简而言之，他跟踪他所有的爪牙以及他们在做什么。调用栈本质上是一样的，它跟踪JavaScript当前正在执行的函数。对于我们目前正在处理的代码片段，当JavaScript到达调用map函数的那一行时，该函数将被弹出到调用堆栈中。当执行完成时，它被弹出。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/42f5ce171c79416da635ccf707cba317.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*YWLGhpGm_GtbqvK_Y7QT8g.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Think of popping off and popping on as Gru keeping track of his minions</figcaption></figure><p id="3240" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通过调用map函数，创建了新的本地或函数级执行上下文。在这个本地执行上下文中，使用实参的值重新分配参数名，并保存在本地内存中(红框突出显示了这一点)。JavaScript逐行存储变量声明及其值，函数及其定义。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nz"><img src="../Images/b002d8443fa44bf1cd8df55e2cc39466.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g4Kj9aKv5mttL7D-IqrVIA.png"/></div></div></figure><p id="a0e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本地执行上下文中，Javascript将运行for循环，每次<em class="nd"> </em> <strong class="kv io"> <em class="nd"> i </em> </strong>递增时，它将首先更新其在内存中的值，然后将其作为参数传递给回调函数。由于回调(<strong class="kv io">函数addTwo() </strong>)现在被调用，一个新的本地执行上下文被创建，一个新的堆栈被弹出到调用堆栈上。</p><h2 id="2a95" class="lu lv in bd mh mi mj dn mk ml mm dp mn lc mo mp mq lg mr ms mt lk mu mv mw mx bi translated">最后阶段</h2><p id="afd4" class="pw-post-body-paragraph kt ku in kv b kw my jo ky kz mz jr lb lc na le lf lg nb li lj lk nc lm ln lo ig bi translated">一旦函数被完全执行，它就向外部返回显式的返回值。如果执行外部的函数需要评估的结果，将使用该结果，并将该函数的返回值发送到外部。这是一个地狱循环，但幸运的是我们不必担心它，因为JavaScript为我们处理了所有这些。它将一直这样做，直到最后的返回值被发送到全局内存，全局执行上下文从调用堆栈中被删除(弹出)并且执行完成。此外，每次执行完一个函数后，它会被弹出调用堆栈并被“垃圾收集”。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oa"><img src="../Images/99da3e27f4bf38281c90ed9b365af507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M3zVWYSfjZ7co-lZgWlD5w.png"/></div></div></figure></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><h2 id="f1b3" class="lu lv in bd mh mi mj dn mk ml mm dp mn lc mo mp mq lg mr ms mt lk mu mv mw mx bi translated">结论</h2><p id="a266" class="pw-post-body-paragraph kt ku in kv b kw my jo ky kz mz jr lb lc na le lf lg nb li lj lk nc lm ln lo ig bi translated">我知道你可能通读了所有这些，这让你有点头晕。好的一面是，一旦你能够理解本机函数，以及JavaScript代码是如何运行的，它就更容易可视化和解释概念，并允许你找到编码问题的解决方案。</p><p id="f6c5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">主要要点是:</p><ul class=""><li id="13f8" class="ne nf in kv b kw kx kz la lc ng lg nh lk ni lo nv nk nl nm bi translated">JavaScript是一种单线程语言。它逐行运行代码。</li><li id="de09" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nv nk nl nm bi translated">当执行代码时，全局执行上下文被弹出到调用堆栈上并被创建。变量和函数定义存储在全局存储器中。</li><li id="fa8b" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nv nk nl nm bi translated">当一个函数被调用时，它被弹出到调用栈，并且一个本地执行上下文和一个本地内存被创建。</li><li id="7d9e" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nv nk nl nm bi translated">一旦函数执行完毕，显式返回值将被发送到它上面的本地执行，依此类推，直到最终的返回值被发送回全局内存。</li><li id="ab0a" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nv nk nl nm bi translated">每次执行完一个函数，它就会从调用堆栈中弹出，当所有代码执行完成时，全局执行上下文就会弹出。</li></ul></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><h2 id="8b17" class="lu lv in bd mh mi mj dn mk ml mm dp mn lc mo mp mq lg mr ms mt lk mu mv mw mx bi translated">额外资源</h2><ul class=""><li id="d03a" class="ne nf in kv b kw my kz mz lc ob lg oc lk od lo nv nk nl nm bi translated"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Glossary/Call_stack" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Glossary/Call _ stack</a></li><li id="f62e" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nv nk nl nm bi translated"><a class="ae ks" href="https://www.javascripttutorial.net/javascript-execution-context/" rel="noopener ugc nofollow" target="_blank">https://www . JavaScript tutorial . net/JavaScript-execution-context/</a></li><li id="94c7" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nv nk nl nm bi translated"><a class="ae ks" href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0" rel="noopener ugc nofollow" target="_blank">https://blog . bitsrc . io/understanding-execution-context-and-execution-stack-in-JavaScript-1c 9 ea 8642 DD 0</a></li><li id="2e35" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nv nk nl nm bi translated"><a class="ae ks" href="https://dev.to/steelvoltage/if-javascript-is-single-threaded-how-is-it-asynchronous-56gd" rel="noopener ugc nofollow" target="_blank">https://dev . to/steel voltage/if-JavaScript-is-single-threaded-how-it-asynchronous-56gd</a></li><li id="ba04" class="ne nf in kv b kw nn kz no lc np lg nq lk nr lo nv nk nl nm bi translated"><a class="ae ks" href="https://www.youtube.com/watch?v=exrc_rLj5iw" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=exrc_rLj5iw</a></li></ul></div></div>    
</body>
</html>