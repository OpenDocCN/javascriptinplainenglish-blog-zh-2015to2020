<html>
<head>
<title>A Node.js Developer’s Guide to Deno</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js开发人员Deno指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-nodejs-developers-guide-to-deno-562804a58a2f?source=collection_archive---------8-----------------------#2020-10-10">https://javascript.plainenglish.io/a-nodejs-developers-guide-to-deno-562804a58a2f?source=collection_archive---------8-----------------------#2020-10-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e658" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Deno炒作已经不可逾越，破坏node.js社区的安宁显然是可以理解的。</h2></div><p id="8bab" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Node.js的创始人yan Dahl为JavaScript和类型脚本开发了一个新的运行时，名为<a class="ae ky" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank"> Deno </a>。鉴于它的预览版刚刚在2020年5月12日发布，它的社区已经在相当数量上增长。Deno在一个可执行文件中完成运行时和包管理器的功能看起来很吸引人。它与Node.js形成对比，node . js具有现成的TypeScript支持，并且在默认情况下是安全的。</p><p id="3618" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我很难观看Ryan Dahl在JSConf EU 2018中发表的“<a class="ae ky" href="https://www.youtube.com/watch?v=M3BM9TB-8yA&amp;t=56s" rel="noopener ugc nofollow" target="_blank">Node.js的10件令我后悔的事情</a>”，因为他暗示Deno在几个方面比node . js更好。我已经是Node.js的粉丝很多年了，我有理由相信Node.js不会很快去任何地方。尽管如此，我还是决定给德诺一个机会。</p><p id="bcdf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在短短时间内就有68，000多名GitHub明星，Deno炒作已经变得不可逾越，破坏Node.js社区的和平显然是可以理解的。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/ff938f011fd2b6c46da99c89136ae2de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d7Emm3WNtCeo16vZWzfQXw.png"/></div></div></figure><p id="9096" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本文旨在从node.js开发人员的角度深入探讨这个问题。我将第一次使用Deno，我希望它不会让我失望。我会写下一路上我所做的和学到的一切。我们将在Deno中构建一个简单但完整的CRUD REST API服务器。我将写在打字稿，并会在最后提供项目Github回购。</p><h1 id="b19e" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">安装和基本命令</h1><p id="d508" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我刚刚上了这个Deno官方网站<a class="ae ky" href="https://deno.land/manual/getting_started/installation" rel="noopener ugc nofollow" target="_blank">链接</a>，在我的系统上安装了Deno。我在windows上，因此我在PowerShell中运行了以下命令:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="753a" class="mn lm in mj b gy mo mp l mq mr">iwr https://deno.land/x/install/install.ps1 -useb | iex</span></pre><p id="c0ec" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">出于好奇，我在安装结束后从命令行中的命令deno开始。Deno REPL(Read Eval Print Loop)开始，如果你以前有过Nodejs的经验，你可能会很熟悉。你可以在这里运行标准的JavaScript。</p><p id="176e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我所料，以下命令返回了可用命令的可用列表:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="da83" class="mn lm in mj b gy mo mp l mq mr"> deno --help</span></pre><h1 id="b9f7" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated"><strong class="ak">运行代码:</strong></h1><p id="1d4d" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">首先，我试着运行他们官方网站上的一个示例代码。</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="d8fc" class="mn lm in mj b gy mo mp l mq mr">deno run <a class="ae ky" href="https://deno.land/std/examples/welcome.ts" rel="noopener ugc nofollow" target="_blank">https://deno.land/std/examples/welcome.ts</a></span></pre><p id="6c03" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它正如我所预料的那样起作用了。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ms"><img src="../Images/4d48e12eb4193d021acc8be124c3c628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3kXor7BTIZZknRhE.jpg"/></div></div></figure><p id="0e81" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我只是在我的系统上本地尝试了一下，用下面的代码创建了一个简单的index.ts文件:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="74b6" class="mn lm in mj b gy mo mp l mq mr">console.log(“Deno the Dinasaur”)</span></pre><p id="2488" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您应该运行以下命令来执行该文件</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="303a" class="mn lm in mj b gy mo mp l mq mr">deno run index.ts</span></pre><h1 id="5f08" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated"><strong class="ak">现在让我们写一些真正的代码</strong></h1><blockquote class="mt mu mv"><p id="8aa0" class="kc kd mw ke b kf kg jo kh ki kj jr kk mx km kn ko my kq kr ks mz ku kv kw kx ig bi translated">我们将使用标准的HTTP库在Deno中制作一个简单的web服务器。</p></blockquote><p id="3237" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我刚发现Deno是用去中心化的包工作的，不像Node.js. Package.json和node_modules一直是我们的好朋友，在Node这里没有入口。deno好像会直接从一个URL下载包，加载时缓存在磁盘上。</p><p id="3978" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mw">现在让我们用Deno构建一个简单的web服务器。</em></p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ms"><img src="../Images/a12dc20594acbed852a228d2293b5e9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sEe718rWYMRY83mW.jpg"/></div></div></figure><p id="ae0b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我刚刚完成了我的第一个deno web服务器的编写。</p><p id="07e0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我首先从<a class="ae ky" href="https://deno.land/std" rel="noopener ugc nofollow" target="_blank">标准库</a>中的HTTP模块导入serve来创建一个没有任何第三方库的服务器。</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="3b7b" class="mn lm in mj b gy mo mp l mq mr">import { serve } from “https://deno.land/std/http/server.ts";</span></pre><p id="defe" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，我在端口8000上使用serve创建了一个服务器对象</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="3371" class="mn lm in mj b gy mo mp l mq mr">const server = serve({ port: 8000 });</span></pre><p id="0967" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我使用utf-8文本编码，这是使用TextEncoder.encode()方法在网页中表示Unicode文本的最广泛使用的方法。</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="6b35" class="mn lm in mj b gy mo mp l mq mr">const body = new TextEncoder().encode(“Deno is definitely impressive\n”);</span></pre><p id="e2fe" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">令人惊讶的是，我发现Deno支持第一个类await，所以我们可以在async函数之外自由使用await。我使用了语句的<em class="mw">for await…来处理异步/同步迭代，如下所示:</em></p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="84d7" class="mn lm in mj b gy mo mp l mq mr">for await (const req of server) {</span><span id="119c" class="mn lm in mj b gy na mp l mq mr">req.respond({ body });</span><span id="2eb0" class="mn lm in mj b gy na mp l mq mr">}</span></pre><p id="b012" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">服务器的index.ts文件的完整代码如下所示</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="6494" class="mn lm in mj b gy mo mp l mq mr">import { serve } from “https://deno.land/std/http/server.ts";</span><span id="e7e4" class="mn lm in mj b gy na mp l mq mr">const server = serve({ port: 8000 });</span><span id="8b63" class="mn lm in mj b gy na mp l mq mr">const body = new TextEncoder().encode(“Deno is definitely impressive\n”);</span><span id="1b24" class="mn lm in mj b gy na mp l mq mr">for await (const req of server) {</span><span id="d935" class="mn lm in mj b gy na mp l mq mr">req.respond({ body });</span><span id="34fa" class="mn lm in mj b gy na mp l mq mr">}</span></pre><p id="be88" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们运行代码:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="d717" class="mn lm in mj b gy mo mp l mq mr">deno run index.ts</span></pre><p id="cef3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哦，我弄错了。等一下。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi nb"><img src="../Images/0796600a8c9a0cec9a3e7cc9a9302092.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*nKJ9iPh8tgeEI4rN.jpg"/></div></div></figure><p id="8ea7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我想大多数人在运行代码的时候都会出错。唷！！代码没有问题。发生这种情况是因为Deno在默认情况下是安全的，我们需要显式地授予访问权限来执行系统操作。</p><p id="3a4b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个命令的帮助下，我们可以看到我们的系统正在运行:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="67f4" class="mn lm in mj b gy mo mp l mq mr">deno run --allow-net index.ts</span></pre><h1 id="d070" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated"><strong class="ak">框架</strong></h1><blockquote class="mt mu mv"><p id="6614" class="kc kd mw ke b kf kg jo kh ki kj jr kk mx km kn ko my kq kr ks mz ku kv kw kx ig bi translated">我对deno的可用框架做了一些研究。Oak框架似乎在这里很受欢迎，就像我们对node.js使用的express一样。</p></blockquote><p id="5fc8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">橡树是一种阔叶树。它们是众所周知的温带顶极植物……<em class="mw"/>哦，等一下！这是不同的橡树。抱歉浪费了你三秒钟的时间。现在，让我通过直接编写初始化应用程序的代码来掩盖这一时间。</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="6acb" class="mn lm in mj b gy mo mp l mq mr">import { Application } from “https://deno.land/x/oak/mod.ts";</span><span id="7210" class="mn lm in mj b gy na mp l mq mr">const port = 8000;</span><span id="2c04" class="mn lm in mj b gy na mp l mq mr">const app = new Application();</span><span id="0b40" class="mn lm in mj b gy na mp l mq mr">console.log(`server is running at ${port}`)</span><span id="debc" class="mn lm in mj b gy na mp l mq mr">await app.listen({ port });</span></pre><p id="0c7f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为什么看起来像快递？为什么代码不起作用？是的，我能读懂你的大部分想法。</p><p id="36ec" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这段代码在Node中运行良好，但是抛出了一个错误，指出“没有中间件来处理请求”。所以，我想我需要用中间件添加路由来处理对我们服务器的请求。再次提醒你，await是在没有async的情况下使用的，因为动作是异步的，deno似乎支持<a class="ae ky" href="https://v8.dev/features/top-level-await" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">顶级await </strong> </a> <strong class="ke io">。</strong></p><h1 id="facf" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">路线和中间件</h1><p id="adbe" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">所以首先我会从Oak导入一个路由器，然后在应用程序中使用路由。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/9f961d718ded1a1076bd7ef50378ab64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/0*b-5YDgcs6UOGiHb8"/></div></figure><p id="9aff" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是我新的启用路由器的index.ts文件:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="f8ca" class="mn lm in mj b gy mo mp l mq mr">import { Application, Router } from “https://deno.land/x/oak/mod.ts";</span><span id="bbb5" class="mn lm in mj b gy na mp l mq mr">const port = 8000;</span><span id="b216" class="mn lm in mj b gy na mp l mq mr">const app = new Application();</span><span id="ce62" class="mn lm in mj b gy na mp l mq mr">const router = new Router();</span><span id="c2d6" class="mn lm in mj b gy na mp l mq mr">app.use(router.routes());</span><span id="8c34" class="mn lm in mj b gy na mp l mq mr">app.use(router.allowedMethods());</span><span id="86bd" class="mn lm in mj b gy na mp l mq mr">console.log(`Open: <a class="ae ky" href="http://localhost:${port}/api/movies`)" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}/api/movies`)</a></span><span id="f2a1" class="mn lm in mj b gy na mp l mq mr">router.get(‘/api/movies’, ({response}: {response: any}) =&gt; {</span><span id="2c2f" class="mn lm in mj b gy na mp l mq mr">response.body = ‘This is my movie list’;</span><span id="7ed3" class="mn lm in mj b gy na mp l mq mr">});</span><span id="2625" class="mn lm in mj b gy na mp l mq mr">await app.listen({ port });</span></pre><p id="eba0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码中，我们已经使用<strong class="ke io"> app.use() </strong>初始化了我们的<strong class="ke io">中间件</strong>，以使用我们的<strong class="ke io">路由器</strong>。</p><p id="a384" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> router.allowedMethods() </strong>允许中间件<strong class="ke io">使用所有HTTP方法</strong>。另一方面，<strong class="ke io"> router.get </strong>将一个箭头函数作为第二个参数，第二个参数又将一个<strong class="ke io">对象</strong>作为参数，通常称为<strong class="ke io">上下文</strong>。</p><p id="9369" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">I <strong class="ke io">析构</strong>那个对象为{response},只取那个对象的<strong class="ke io">响应部分</strong>。我指定了“any”类型，因为我们一直在使用Typescript。在方法内部，提供了一个随机响应体。</p><p id="6972" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以向<em class="mw">localhost:8000/API/movies</em>发送请求，以接收“这是我的电影列表”的响应</p><p id="135c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经构建了最简单的服务器，我将按照惯例重构文件夹结构。它将如下</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/c20c7dcd9518cf641fa8d7c3500e9d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*QdwDLuMd8452HYXiLi-U5w.png"/></div><figcaption class="ne nf gj gh gi ng nh bd b be z dk">Project Structure</figcaption></figure><p id="03a4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是<strong class="ke io">每个</strong>单独<strong class="ke io">文件</strong>的单独代码:</p><p id="01ef" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mw">控制器/movies.ts </em></p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="b468" class="mn lm in mj b gy mo mp l mq mr">const getMovies = ({response}: {response: any}) =&gt; {</span><span id="12e6" class="mn lm in mj b gy na mp l mq mr">response.body = “This is my movie list.”;</span><span id="5d6e" class="mn lm in mj b gy na mp l mq mr">}</span><span id="459f" class="mn lm in mj b gy na mp l mq mr">export { getMovies }</span></pre><p id="5a31" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">routes/routes.ts</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="0cfe" class="mn lm in mj b gy mo mp l mq mr">import { Router } from “https://deno.land/x/oak/mod.ts";</span><span id="c066" class="mn lm in mj b gy na mp l mq mr">import { getMovies } from ‘../controllers/movies.ts’;</span><span id="473e" class="mn lm in mj b gy na mp l mq mr">const router = new Router();</span><span id="86b7" class="mn lm in mj b gy na mp l mq mr">router.get(‘/api/movies’, getMovies);</span><span id="6c66" class="mn lm in mj b gy na mp l mq mr">export default router;</span></pre><p id="9641" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">index.ts</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="6464" class="mn lm in mj b gy mo mp l mq mr">import { Application } from “https://deno.land/x/oak/mod.ts";</span><span id="9a44" class="mn lm in mj b gy na mp l mq mr">import router from ‘./routes/routes.ts’;</span><span id="1bf0" class="mn lm in mj b gy na mp l mq mr">const port = 8000;</span><span id="e728" class="mn lm in mj b gy na mp l mq mr">const app = new Application();</span><span id="a7d7" class="mn lm in mj b gy na mp l mq mr">app.use(router.routes());</span><span id="0894" class="mn lm in mj b gy na mp l mq mr">app.use(router.allowedMethods());</span><span id="bd4a" class="mn lm in mj b gy na mp l mq mr">console.log(`Open: <a class="ae ky" href="http://localhost:${port}/api/movies`)" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}/api/movies`)</a></span><span id="830f" class="mn lm in mj b gy na mp l mq mr">await app.listen({ port });</span></pre><p id="bfef" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，所有主要的服务器文件、路由和路由处理程序都已经被分离出来，并进行适当的结构化。</p><h1 id="6627" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated"><strong class="ak">在项目中做一些随机的改变</strong></h1><p id="79d6" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我刚刚完成为电影添加一点模拟数据，现在是一个硬编码的JSON对象。我在根目录中添加了一个名为<strong class="ke io"> types.ts的新文件，并导出了一个简单的<strong class="ke io"> IMovies接口</strong>，我们将在movies.ts中使用它</strong></p><p id="b400" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">types.ts</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="7a5c" class="mn lm in mj b gy mo mp l mq mr">export interface IMovies {</span><span id="c254" class="mn lm in mj b gy na mp l mq mr">id: string;</span><span id="366e" class="mn lm in mj b gy na mp l mq mr">name: string;</span><span id="5509" class="mn lm in mj b gy na mp l mq mr">genre: string;</span><span id="3c76" class="mn lm in mj b gy na mp l mq mr">}</span></pre><p id="b2d9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我的controllers/movies.ts看起来如下:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="6de8" class="mn lm in mj b gy mo mp l mq mr">import { IMovies } from “../types.ts”;</span><span id="e786" class="mn lm in mj b gy na mp l mq mr">let movies: IMovies[] = [</span><span id="5095" class="mn lm in mj b gy na mp l mq mr">{</span><span id="a482" class="mn lm in mj b gy na mp l mq mr">id: ‘1’,</span><span id="8ee1" class="mn lm in mj b gy na mp l mq mr">name: “Inception”,</span><span id="8702" class="mn lm in mj b gy na mp l mq mr">genre: “mystery”</span><span id="7d2d" class="mn lm in mj b gy na mp l mq mr">},</span><span id="14a7" class="mn lm in mj b gy na mp l mq mr">{</span><span id="e918" class="mn lm in mj b gy na mp l mq mr">id: ‘2’,</span><span id="0eed" class="mn lm in mj b gy na mp l mq mr">name: “The Dark Knight”,</span><span id="5488" class="mn lm in mj b gy na mp l mq mr">genre: “fiction”</span><span id="12eb" class="mn lm in mj b gy na mp l mq mr">},</span><span id="de52" class="mn lm in mj b gy na mp l mq mr">{</span><span id="d052" class="mn lm in mj b gy na mp l mq mr">id: ‘3’,</span><span id="b574" class="mn lm in mj b gy na mp l mq mr">name: “IO”,</span><span id="def7" class="mn lm in mj b gy na mp l mq mr">genre: “sci-fi”</span><span id="eef9" class="mn lm in mj b gy na mp l mq mr">},</span><span id="c2e4" class="mn lm in mj b gy na mp l mq mr">]</span><span id="952d" class="mn lm in mj b gy na mp l mq mr">const getMovies = ({response}: {response: any}) =&gt; {</span><span id="afff" class="mn lm in mj b gy na mp l mq mr">response.body = {</span><span id="b320" class="mn lm in mj b gy na mp l mq mr">success: true,</span><span id="a99b" class="mn lm in mj b gy na mp l mq mr">data: movies</span><span id="23f2" class="mn lm in mj b gy na mp l mq mr">};</span><span id="78a4" class="mn lm in mj b gy na mp l mq mr">}</span><span id="b4eb" class="mn lm in mj b gy na mp l mq mr">export { getMovies }</span></pre><p id="220a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我之前回了一条短信“这是我的电影列表”。现在JSON对象返回了两个属性:success和data，其中保存了我们的movies数组的值。</p><p id="c463" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以向位于<strong class="ke io"> api/movies </strong>的URL发出GET请求，以获取电影JSON。我计划添加一条路线来获得电影的具体细节。我们需要的是从<strong class="ke io"> /api/movies/:id </strong>定义另一条路径。我很快就会回来。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/e19b6ac5dca5c2130c8ff3e6534a2148.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*A0PUBWiFQ4hD29zu.jpg"/></div></figure><p id="abb2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧，没那么久。我更新后的movies.ts文件如下所示:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="64f9" class="mn lm in mj b gy mo mp l mq mr">import { IMovies } from “../types.ts”;</span><span id="0e4c" class="mn lm in mj b gy na mp l mq mr">let movies: IMovies[] = [</span><span id="85d5" class="mn lm in mj b gy na mp l mq mr">{</span><span id="7457" class="mn lm in mj b gy na mp l mq mr">id: ‘1’,</span><span id="e724" class="mn lm in mj b gy na mp l mq mr">name: “Inception”,</span><span id="0031" class="mn lm in mj b gy na mp l mq mr">genre: “mystery”</span><span id="633a" class="mn lm in mj b gy na mp l mq mr">},</span><span id="e645" class="mn lm in mj b gy na mp l mq mr">{</span><span id="1f64" class="mn lm in mj b gy na mp l mq mr">id: ‘2’,</span><span id="7421" class="mn lm in mj b gy na mp l mq mr">name: “The Dark Knight”,</span><span id="9e4e" class="mn lm in mj b gy na mp l mq mr">genre: “fiction”</span><span id="d25b" class="mn lm in mj b gy na mp l mq mr">},</span><span id="4271" class="mn lm in mj b gy na mp l mq mr">{</span><span id="2606" class="mn lm in mj b gy na mp l mq mr">id: ‘3’,</span><span id="f2f5" class="mn lm in mj b gy na mp l mq mr">name: “IO”,</span><span id="99bb" class="mn lm in mj b gy na mp l mq mr">genre: “sci-fi”</span><span id="4588" class="mn lm in mj b gy na mp l mq mr">},</span><span id="13d7" class="mn lm in mj b gy na mp l mq mr">]</span><span id="17f4" class="mn lm in mj b gy na mp l mq mr">const getMovies = ({response}: {response: any}) =&gt; {</span><span id="377a" class="mn lm in mj b gy na mp l mq mr">response.body = {</span><span id="c790" class="mn lm in mj b gy na mp l mq mr">success: true,</span><span id="f3ff" class="mn lm in mj b gy na mp l mq mr">data: movies</span><span id="0b95" class="mn lm in mj b gy na mp l mq mr">};</span><span id="74e4" class="mn lm in mj b gy na mp l mq mr">}</span><span id="f222" class="mn lm in mj b gy na mp l mq mr">const getMovie = ({ params, response }: { params: { id: string }, response: any}) =&gt; {</span><span id="ae02" class="mn lm in mj b gy na mp l mq mr">const movie: IMovies | undefined = movies.find(m =&gt; m.id === params.id);</span><span id="8d56" class="mn lm in mj b gy na mp l mq mr">if(movie) {</span><span id="63f5" class="mn lm in mj b gy na mp l mq mr">response.status = 200;</span><span id="956e" class="mn lm in mj b gy na mp l mq mr">response.body = {</span><span id="5421" class="mn lm in mj b gy na mp l mq mr">success: true,</span><span id="5315" class="mn lm in mj b gy na mp l mq mr">data: movie</span><span id="1d7a" class="mn lm in mj b gy na mp l mq mr">}</span><span id="9b3b" class="mn lm in mj b gy na mp l mq mr">} else {</span><span id="18ca" class="mn lm in mj b gy na mp l mq mr">response.status = 404;</span><span id="0e70" class="mn lm in mj b gy na mp l mq mr">response.body = {</span><span id="95ec" class="mn lm in mj b gy na mp l mq mr">success: false,</span><span id="f567" class="mn lm in mj b gy na mp l mq mr">message: “No movies found”</span><span id="4be4" class="mn lm in mj b gy na mp l mq mr">}</span><span id="ffd6" class="mn lm in mj b gy na mp l mq mr">}</span><span id="7275" class="mn lm in mj b gy na mp l mq mr">}</span><span id="101b" class="mn lm in mj b gy na mp l mq mr">export { getMovies, getMovie }</span></pre><p id="0c80" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，<strong class="ke io">与之前的代码相比唯一的区别</strong>是<strong class="ke io">的getMovie函数</strong>。它需要两个参数和响应。参数<strong class="ke io">保存路由URL参数</strong>。</p><p id="ca8f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，您可以在<strong class="ke io"> /api/movie/1 </strong>发出GET请求(我使用了POSTMAN ),这可能是您将看到的内容:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="132a" class="mn lm in mj b gy mo mp l mq mr">{</span><span id="ad06" class="mn lm in mj b gy na mp l mq mr">“success”: true,</span><span id="8320" class="mn lm in mj b gy na mp l mq mr">“data”: {</span><span id="b476" class="mn lm in mj b gy na mp l mq mr">id: ‘1’,</span><span id="f0a0" class="mn lm in mj b gy na mp l mq mr">name: “Inception”,</span><span id="02bb" class="mn lm in mj b gy na mp l mq mr">genre: “mystery”</span><span id="0644" class="mn lm in mj b gy na mp l mq mr">}</span><span id="fd92" class="mn lm in mj b gy na mp l mq mr">}</span></pre><blockquote class="mt mu mv"><p id="314b" class="kc kd mw ke b kf kg jo kh ki kj jr kk mx km kn ko my kq kr ks mz ku kv kw kx ig bi translated">让我们快速尝试将数据发送到服务器。</p></blockquote><p id="6f93" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，首先我在movies.ts中增加了一个新的函数addMovie，它需要两个参数:请求和响应。</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="a29f" class="mn lm in mj b gy mo mp l mq mr">import { v4 } from “https://deno.land/std/uuid/mod.ts";</span><span id="fac1" class="mn lm in mj b gy na mp l mq mr">…</span><span id="1e6c" class="mn lm in mj b gy na mp l mq mr">…</span><span id="7374" class="mn lm in mj b gy na mp l mq mr">…</span><span id="bb73" class="mn lm in mj b gy na mp l mq mr">const addMovie = async ({ request, response }: { request: any, response: any}) =&gt; {</span><span id="911f" class="mn lm in mj b gy na mp l mq mr">const body = await request.body()</span><span id="2d8f" class="mn lm in mj b gy na mp l mq mr">if(!request.hasBody) {</span><span id="6490" class="mn lm in mj b gy na mp l mq mr">response.status = 404;</span><span id="9949" class="mn lm in mj b gy na mp l mq mr">response.body = {</span><span id="2e84" class="mn lm in mj b gy na mp l mq mr">success: false,</span><span id="8848" class="mn lm in mj b gy na mp l mq mr">message: “No data received”</span><span id="a52a" class="mn lm in mj b gy na mp l mq mr">}</span><span id="07d5" class="mn lm in mj b gy na mp l mq mr">} else {</span><span id="da54" class="mn lm in mj b gy na mp l mq mr">const movie: IMovies = body.value;</span><span id="79e6" class="mn lm in mj b gy na mp l mq mr">movie.id = v4.generate();</span><span id="a83a" class="mn lm in mj b gy na mp l mq mr">movies.push(movie);</span><span id="8797" class="mn lm in mj b gy na mp l mq mr">response.status = 201;</span><span id="43e6" class="mn lm in mj b gy na mp l mq mr">response.body = {</span><span id="9514" class="mn lm in mj b gy na mp l mq mr">success: true,</span><span id="ff5c" class="mn lm in mj b gy na mp l mq mr">data: movie</span><span id="9092" class="mn lm in mj b gy na mp l mq mr">}</span><span id="8290" class="mn lm in mj b gy na mp l mq mr">}</span><span id="c52a" class="mn lm in mj b gy na mp l mq mr">}</span></pre><p id="2b8c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你还记得上一次，我<strong class="ke io">没有</strong>使用<strong class="ke io"> async with await </strong>，你可能会困惑为什么这次我使用了它。正如我前面提到的，await只能在Deno模块的顶层的使用<strong class="ke io">，否则，需要在异步函数中使用。</strong></p><p id="93d6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们检查<strong class="ke io">是否使用request.hasBody传递了</strong>电影细节。</p><p id="6ea9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们正在从<strong class="ke io"> uuid </strong>包中<strong class="ke io">导入v4 </strong>，以便<strong class="ke io">为每部电影生成一个唯一的id </strong>。</p><p id="24a4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们在route.ts中使用<strong class="ke io"> route.post </strong>来<strong class="ke io">创建</strong>一个post端点。</p><p id="529a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mw"> route.ts </em></p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="5f58" class="mn lm in mj b gy mo mp l mq mr">import { Router } from “https://deno.land/x/oak/mod.ts";</span><span id="3d58" class="mn lm in mj b gy na mp l mq mr">import { getMovies, getMovie, addMovie } from ‘../controllers/movies.ts’;</span><span id="ba50" class="mn lm in mj b gy na mp l mq mr">const router = new Router();</span><span id="ead6" class="mn lm in mj b gy na mp l mq mr">router.get(‘/api/movies’, getMovies)</span><span id="9cbb" class="mn lm in mj b gy na mp l mq mr">.get(‘/api/movies/:id’, getMovie)</span><span id="6e44" class="mn lm in mj b gy na mp l mq mr">.post(‘/api/movie’, addMovie )</span><span id="2d0c" class="mn lm in mj b gy na mp l mq mr">export default router;</span></pre><p id="e70a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您尝试向我们的新路由发送一个空POST请求时，您可能会看到如下内容:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="8feb" class="mn lm in mj b gy mo mp l mq mr">{</span><span id="076e" class="mn lm in mj b gy na mp l mq mr">“success”: false,</span><span id="d518" class="mn lm in mj b gy na mp l mq mr">“message”: “No data received”</span><span id="3cfe" class="mn lm in mj b gy na mp l mq mr">}</span></pre><p id="c49b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以尝试将POST请求发送到相同的路由，但其正文类似于以下内容:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="f3f5" class="mn lm in mj b gy mo mp l mq mr">{</span><span id="1b68" class="mn lm in mj b gy na mp l mq mr">“name”: “yourmoviename”,</span><span id="1191" class="mn lm in mj b gy na mp l mq mr">“genre”: “genreofyourmovie”</span><span id="f8f1" class="mn lm in mj b gy na mp l mq mr">}</span></pre><p id="9e8d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您将得到以下响应:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="e98b" class="mn lm in mj b gy mo mp l mq mr">{</span><span id="8c19" class="mn lm in mj b gy na mp l mq mr">“success”: true,</span><span id="6689" class="mn lm in mj b gy na mp l mq mr">“data”: {</span><span id="1158" class="mn lm in mj b gy na mp l mq mr">“name”: “yourmoviename”,</span><span id="7fc9" class="mn lm in mj b gy na mp l mq mr">“genre”: “genreofyourmovie”</span><span id="fced" class="mn lm in mj b gy na mp l mq mr">“id”: “randomlygenerated12–4213123fsd_312”</span><span id="659b" class="mn lm in mj b gy na mp l mq mr">}</span><span id="be8b" class="mn lm in mj b gy na mp l mq mr">}</span></pre><p id="d23c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">为了验证</strong>它已经被添加，您可以再次<strong class="ke io">向/api/movies发送一个GET </strong>请求</p><p id="4004" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然我们已经使用了<strong class="ke io"> POST </strong>和<strong class="ke io"> GET </strong>，那么让我们也为<strong class="ke io"> DEL </strong>(删除)和<strong class="ke io"> PUT </strong>(更新)快速构建两条路径。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/fd1fe36ad3c6c616ce303919e7e866b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*vrJ2qcdA2I9uYVkk.jpg"/></div></figure><p id="2ea6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，创建一个<strong class="ke io">更新函数</strong>的主要概念是给它一个<strong class="ke io"> get </strong>以及<strong class="ke io"> post的特性，因此</strong>会有一段较长的代码:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="550d" class="mn lm in mj b gy mo mp l mq mr">const updateMovie = async ({ params, request, response}: { params: { id: string}, request: any, response: any}) =&gt; {</span><span id="cd97" class="mn lm in mj b gy na mp l mq mr">const movie: IMovies | undefined = movies.find(b =&gt; b.id === params.id);</span><span id="d16c" class="mn lm in mj b gy na mp l mq mr">if(movie) {</span><span id="7f0e" class="mn lm in mj b gy na mp l mq mr">const body = await request.body()</span><span id="f964" class="mn lm in mj b gy na mp l mq mr">const updateData: { name?: string; genre?: string; } = body.value;</span><span id="05e5" class="mn lm in mj b gy na mp l mq mr">movies = movies.map(m =&gt; m.id === params.id ? {...m, ...updateData} : m);</span><span id="646b" class="mn lm in mj b gy na mp l mq mr">response.status = 200;</span><span id="9a64" class="mn lm in mj b gy na mp l mq mr">response.body = {</span><span id="844f" class="mn lm in mj b gy na mp l mq mr">success: true,</span><span id="0ae3" class="mn lm in mj b gy na mp l mq mr">data: movies</span><span id="8fcc" class="mn lm in mj b gy na mp l mq mr">}</span><span id="2a01" class="mn lm in mj b gy na mp l mq mr">} else {</span><span id="982b" class="mn lm in mj b gy na mp l mq mr">response.status = 404;</span><span id="67e1" class="mn lm in mj b gy na mp l mq mr">response.body = {</span><span id="3ab7" class="mn lm in mj b gy na mp l mq mr">success: false,</span><span id="aca2" class="mn lm in mj b gy na mp l mq mr">message: “No data received”</span><span id="c7a3" class="mn lm in mj b gy na mp l mq mr">}</span><span id="ca1b" class="mn lm in mj b gy na mp l mq mr">}</span><span id="b932" class="mn lm in mj b gy na mp l mq mr">}</span></pre><p id="d681" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">首先</strong>，我们<strong class="ke io">通过检查是否存在任何具有该id的电影来请求更新电影<strong class="ke io">的id </strong>。如果<strong class="ke io">是</strong>，我们使用request.body()，<strong class="ke io">destruct</strong>它来获取<strong class="ke io">唯一名称和流派</strong>，最后<strong class="ke io">将</strong>它存储在一个<strong class="ke io"> updateData </strong>变量中。</strong></p><p id="c0b5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能会注意到分号前面的<strong class="ke io">问号</strong>，我保留了这个问号，因为用户<strong class="ke io">可能会</strong>选择<strong class="ke io">只更新请求体的单个属性</strong>或这些属性的任意组合。</p><p id="bd95" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们<strong class="ke io">通过<strong class="ke io"> movies数组</strong>映射</strong>，并使用spread操作符更新id与params.id匹配的电影。最后，我们<strong class="ke io">向</strong>发送一个状态码200以及<strong class="ke io">更新后的数组</strong>。</p><p id="544b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在运行文件之前，不要忘记在routes.ts中添加<strong class="ke io"> PUT route </strong>，如下所示:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="9952" class="mn lm in mj b gy mo mp l mq mr">//routes.ts</span><span id="96a8" class="mn lm in mj b gy na mp l mq mr">import { Router } from “https://deno.land/x/oak/mod.ts";</span><span id="06dc" class="mn lm in mj b gy na mp l mq mr">import { getMovies, getMovie, addMovie, updateMovie} from ‘../controllers/movies.ts’;</span><span id="33e1" class="mn lm in mj b gy na mp l mq mr">const router = new Router();</span><span id="9849" class="mn lm in mj b gy na mp l mq mr">router.get(‘/api/movies’, getMovies)</span><span id="d34f" class="mn lm in mj b gy na mp l mq mr">.get(‘/api/movies/:id’, getMovie)</span><span id="94f4" class="mn lm in mj b gy na mp l mq mr">.post(‘/api/movie’, addMovie)</span><span id="ef8b" class="mn lm in mj b gy na mp l mq mr">.put(‘/api/movies/:id’, updateMovie)</span><span id="d0a8" class="mn lm in mj b gy na mp l mq mr">export default router;</span></pre><p id="8ddb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，您可以通过向URL /api/movies/1和以下主体发送PUT请求来测试它:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="a79b" class="mn lm in mj b gy mo mp l mq mr">{ “name”: “home alone” }</span></pre><p id="8d40" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在响应中，您可以看到id为1的电影更新了您的姓名。</p><blockquote class="mt mu mv"><p id="c26c" class="kc kd mw ke b kf kg jo kh ki kj jr kk mx km kn ko my kq kr ks mz ku kv kw kx ig bi translated">请注意，数据没有保存在数据库中，如果我们重新启动服务器，这些数据将被删除。</p></blockquote><p id="1757" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，<strong class="ke io">最后的任务</strong>是<strong class="ke io">删除</strong>一部特定的电影。</p><p id="e734" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有之前的代码都是一样的，你只需要<strong class="ke io">添加一个新的</strong>函数<strong class="ke io">删除电影</strong>并在以后给它分配合适的路线。</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="cbbf" class="mn lm in mj b gy mo mp l mq mr">const deleteMovie = ({ params, response}: { params: { id: string}, response: any}) =&gt; {</span><span id="1320" class="mn lm in mj b gy na mp l mq mr">const movie: IMovies | undefined = movies.find(m =&gt; m.id === params.id);</span><span id="82ee" class="mn lm in mj b gy na mp l mq mr">if(movie) {</span><span id="2c05" class="mn lm in mj b gy na mp l mq mr">movies = movies.filter(m =&gt; m.id !== params.id);</span><span id="6a77" class="mn lm in mj b gy na mp l mq mr">response.status = 200;</span><span id="5e4c" class="mn lm in mj b gy na mp l mq mr">response.body = {</span><span id="1a24" class="mn lm in mj b gy na mp l mq mr">success: true,</span><span id="07c3" class="mn lm in mj b gy na mp l mq mr">message: “Selected movie is removed”,</span><span id="dc71" class="mn lm in mj b gy na mp l mq mr">data: movies</span><span id="aea5" class="mn lm in mj b gy na mp l mq mr">}</span><span id="b01e" class="mn lm in mj b gy na mp l mq mr">} else {</span><span id="c7f8" class="mn lm in mj b gy na mp l mq mr">response.status = 404;</span><span id="d7e9" class="mn lm in mj b gy na mp l mq mr">response.body = {</span><span id="ce99" class="mn lm in mj b gy na mp l mq mr">success: false,</span><span id="6923" class="mn lm in mj b gy na mp l mq mr">message: “No movie found”</span><span id="fcb4" class="mn lm in mj b gy na mp l mq mr">}</span><span id="de56" class="mn lm in mj b gy na mp l mq mr">}</span><span id="12a1" class="mn lm in mj b gy na mp l mq mr">}</span></pre><p id="f9f5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，您可以注意到只有参数和响应，没有请求属性，因为我们不会使用请求体。</p><p id="b3b1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这种方法类似于前面的代码，我们首先通过电影的列表<strong class="ke io">来过滤</strong>，以检查是否有任何电影的id与params.id的id相匹配。</p><p id="e8f4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是您最后一次看到我们的routes.ts文件:</p><pre class="la lb lc ld gt mi mj mk ml aw mm bi"><span id="ac41" class="mn lm in mj b gy mo mp l mq mr">import { Router } from “https://deno.land/x/oak/mod.ts";</span><span id="1159" class="mn lm in mj b gy na mp l mq mr">import { getMovies, getMovie, addMovie, updateMovie, deleteMovie} from ‘../controllers/movies.ts’;</span><span id="9c46" class="mn lm in mj b gy na mp l mq mr">const router = new Router();</span><span id="3e1b" class="mn lm in mj b gy na mp l mq mr">router.get(‘/api/movies’, getMovies)</span><span id="9cc1" class="mn lm in mj b gy na mp l mq mr">.get(‘/api/movies/:id’, getMovie)</span><span id="dbb8" class="mn lm in mj b gy na mp l mq mr">.post(‘/api/movie’, addMovie)</span><span id="c1c2" class="mn lm in mj b gy na mp l mq mr">.put(‘/api/movies/:id’, updateMovie)</span><span id="306c" class="mn lm in mj b gy na mp l mq mr">.delete(‘/api/movies/:id’, deleteMovie)</span><span id="3e4a" class="mn lm in mj b gy na mp l mq mr">export default router;</span></pre><p id="6c5c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果您尝试向<strong class="ke io"> /api/movies/1 </strong>发送一个<strong class="ke io">删除</strong>请求，您将会看到id为<strong class="ke io">1的电影被从电影列表中删除</strong>。</p><p id="64ac" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，我们已经成功地用Deno和Oak创建了一个简单的CRUD REST API。我刚刚发现Oak最初是受Koa框架(Node.js)的启发，这可能是我觉得开发体验如此熟悉的另一个原因。</p><p id="98d2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，与Node.js相比，它有许多细微的差异。运行时架构及其处理模块和库的方式似乎与Node.js形成了对比，但对于以前有node.js经验的人来说，这种体验会非常友好。但是说实话，Deno看起来更安全、更轻量级，并且在这里设置模块和库似乎要快得多。因此，我称它为兄弟，而不是node.js的替代品。它似乎克服了node.js的一些缺点，但从编码的角度来看仍然是相似的，不像其他同类产品。在我未来的博客中，我会试着挖掘更多关于Deno世界的东西。</p><p id="9f45" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">项目回购的链接是:<a class="ae ky" href="https://github.com/kaylinkhanal/denoroad" rel="noopener ugc nofollow" target="_blank">https://github.com/kaylinkhanal/denoroad</a></p><p id="37ae" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编码快乐！</p><p id="050b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae ky" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="ke io">！</strong></p></div></div>    
</body>
</html>