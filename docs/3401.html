<html>
<head>
<title>Understanding Recursion by implementing the ‘Tower of Hanoi’ game in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过用JavaScript实现“汉诺塔”游戏来理解递归</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-recursion-by-implementing-the-tower-of-hanoi-in-javascript-a83a54a62f40?source=collection_archive---------2-----------------------#2020-09-26">https://javascript.plainenglish.io/understanding-recursion-by-implementing-the-tower-of-hanoi-in-javascript-a83a54a62f40?source=collection_archive---------2-----------------------#2020-09-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="43e7" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">思维程序员</h2><div class=""/><div class=""><h2 id="5c56" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">循环可能会提高程序的性能，但递归可能会提高程序员的性能</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/20b7e096ecd817bcf8691234a4183122.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZqsQL9HVlOB1QLOB"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@jentheodore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jen Theodore</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b233" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">递归是一种解决问题的技术，其中一个较大问题的解决方案是根据其自身的较小实例来定义的。你可以试着想象一个现实世界中的例子，当你在家里挖掘时，发现一个神秘地锁着的手提箱，手提箱的钥匙可能在另一个盒子里。这个盒子里有更多的盒子，这些盒子里有更多的盒子。钥匙在某个地方的盒子里。</p><h1 id="e3e1" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">如何寻找钥匙？</h1><p id="8231" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们有两种流行的方法来解决这个问题。</p><h2 id="8797" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">第一种方法</h2><p id="916c" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在这个解决方案中，我们使用了一个while-loop算法:“<em class="nj">当这堆东西不空的时候，拿起一个盒子，然后浏览它</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/09eb68d659469388f9b8dceb39fe1dc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*vIuRQAQulUxud0jZl6Z8SQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk"><em class="nl">while the pile isn’t empty, grab a box, and look through it</em></figcaption></figure><h2 id="c0da" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">第二种方法</h2><p id="01a8" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在这种方法中，我们使用递归算法:"<em class="nj">，其中函数调用自身。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/246a5d443d91aeb1da68622ba89cc5b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1042/format:webp/1*jaEoSE9H9AQcX28BTcIKOQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk"><em class="nl">where a function calls itself</em></figcaption></figure><p id="7423" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这两种解决方案达到了同样的效果，但是第二种方法似乎比第一种更容易？是的，对我来说更清楚了😁。但事实上，使用递归算法并没有性能上的好处🤣。</p><blockquote class="nm"><p id="df48" class="nn no iq bd np nq nr ns nt nu nv ma dk translated">循环可以提高程序的性能。递归可以为你的程序员带来性能上的提升。根据你的情况选择哪个更重要！利·考德威尔。</p></blockquote><p id="bd6e" class="pw-post-body-paragraph lf lg iq lh b li nw ka lk ll nx kd ln lo ny lq lr ls nz lu lv lw oa ly lz ma ij bi translated">这是JavaScript中的第二个方法。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="8e10" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因为递归调用它自己，你必须告诉它什么时候停止一切。在这种情况下，这就是我们找到钥匙的时候。</p><h1 id="543a" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">河内塔</h1><h2 id="9a85" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">游戏</h2><p id="d02e" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">这是一个在全世界都很流行的数学游戏。有3个栓钉，分别标记为S、D和E的源栓钉、目的栓钉和额外栓钉，并且有n个大小不同的盘，可以插入这三个栓钉中的任何一个。所有光盘最初按如下递减顺序(顶部最小)插入源钉。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi od"><img src="../Images/3164ca4de19c188b2656c2b6363e5783.png" data-original-src="https://miro.medium.com/v2/resize:fit:732/format:webp/1*euOUC0w0kfsTYZ5gP0w0HQ.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">The initial state</figcaption></figure><p id="dcb1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们的任务是将所有光盘从源位置移动到目标位置。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/673b0f63d8f09595641363bf57c4d530.png" data-original-src="https://miro.medium.com/v2/resize:fit:622/format:webp/1*Pmq2hUkbILPcVwdioM9Khw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">The final state</figcaption></figure><p id="c400" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">有两个限制。</p><ul class=""><li id="3841" class="of og iq lh b li lj ll lm lo oh ls oi lw oj ma ok ol om on bi translated">一次只能移动一张光盘。</li><li id="2710" class="of og iq lh b li oo ll op lo oq ls or lw os ma ok ol om on bi translated">在这个过程中的任何时候，我们都不应该将一个较大的光盘放在一个较小的光盘上。</li></ul><h2 id="0237" class="my mc iq bd md mz na dn mh nb nc dp ml lo nd ne mn ls nf ng mp lw nh ni mr iw bi translated">怎么解决？</h2><p id="ae31" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">这可能看起来是一个复杂的问题，但是如果我们递归地思考，那么这个问题可以通过三个简单的步骤来解决。</p><ul class=""><li id="7f07" class="of og iq lh b li lj ll lm lo oh ls oi lw oj ma ok ol om on bi translated">步骤1:使用d将n-1张光盘从S移动到E。</li><li id="8983" class="of og iq lh b li oo ll op lo oq ls or lw os ma ok ol om on bi translated">第二步:将第n张盘从S移到D</li><li id="2880" class="of og iq lh b li oo ll op lo oq ls or lw os ma ok ol om on bi translated">步骤3:使用S将n-1张光盘从E移动到D</li></ul><p id="eb9b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们将在JavScript中编写一个函数，该函数接受代表三个杆(S，D &amp; E)和圆盘数量(n)的字符，并打印圆盘在栓钉之间的移动，以便所有圆盘从初始状态(S内)移动到最终状态(D内)。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ob oc l"/></div></figure><p id="03c7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果我们运行3张光盘的功能:<code class="fe ot ou ov ow b">resolver_tower_of_hanoi(‘s’, ‘d’, ‘e’, 3)</code>，输出为。</p><pre class="kp kq kr ks gt ox ow oy oz aw pa bi"><span id="f20b" class="my mc iq ow b gy pb pc l pd pe">Move Disk-1 FROM s TO d<br/>Move Disk-2 FROM s TO e<br/>Move Disk-1 FROM d TO e<br/>Move Disk-3 FROM s TO d<br/>Move Disk-1 FROM e TO s<br/>Move Disk-2 FROM e TO d<br/>Move Disk-1 FROM s TO d</span></pre><p id="a93e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">很简单，对吧？</p><h1 id="20d1" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">参考</h1><p id="7662" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">[1]<a class="ae le" href="http://stackoverflow.com/a/72694/139117" rel="noopener ugc nofollow" target="_blank">http://stackoverflow.com/a/72694/139117</a></p></div></div>    
</body>
</html>