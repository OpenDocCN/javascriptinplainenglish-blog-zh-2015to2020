<html>
<head>
<title>Creating Custom Scalars with Express Apollo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Express Apollo创建自定义标量</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-custom-scalars-with-express-apollo-e82151c6ebca?source=collection_archive---------5-----------------------#2020-03-30">https://javascript.plainenglish.io/creating-custom-scalars-with-express-apollo-e82151c6ebca?source=collection_archive---------5-----------------------#2020-03-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4272a86199836bc76b7d3f920c321cf6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nlbM88TL8Bf2Xi6S"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@deandavid?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dean David</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ebd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Apollo服务器作为节点包提供。我们可以用它来创建一个接受GraphQL请求的服务器。</p><p id="dc1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何使用Express Apollo Server创建自定义标量类型。</p><h1 id="77d3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">自定义标量</h1><p id="ddd1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要创建自定义标量，我们可以使用<code class="fe me mf mg mh b">scalar</code>关键字来创建它。</p><h1 id="1153" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用包</h1><p id="3af5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过从现有的包中添加一个来添加自定义标量。</p><p id="b47b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过使用<code class="fe me mf mg mh b">graphql-type-json</code>包添加一个JSON标量类型。</p><p id="b559" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="26e5" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const { ApolloServer, gql } = require('apollo-server-express');<br/>const GraphQLJSON = require('graphql-type-json');</span><span id="be98" class="mq lc iq mh b gy mv ms l mt mu">const typeDefs = gql`<br/>  scalar JSON</span><span id="b5d7" class="mq lc iq mh b gy mv ms l mt mu">  type Foo {<br/>    aField: JSON<br/>  }</span><span id="66bb" class="mq lc iq mh b gy mv ms l mt mu">  type Query {<br/>    foo: Foo<br/>  }<br/>`;</span><span id="0ed8" class="mq lc iq mh b gy mv ms l mt mu">const resolvers = {<br/>  JSON: GraphQLJSON,<br/>  Query: {<br/>    foo() {<br/>      return { aField: { foo: 'bar' } };<br/>    }<br/>  }<br/>};</span><span id="78fb" class="mq lc iq mh b gy mv ms l mt mu">const app = express();<br/>const server = new ApolloServer({ typeDefs, resolvers });<br/>server.applyMiddleware({ app });</span><span id="9eed" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="4ffd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e40e" class="mq lc iq mh b gy mr ms l mt mu">const typeDefs = gql`<br/>  scalar JSON</span><span id="3019" class="mq lc iq mh b gy mv ms l mt mu">  type Foo {<br/>    aField: JSON<br/>  }</span><span id="1f74" class="mq lc iq mh b gy mv ms l mt mu">  type Query {<br/>    foo: Foo<br/>  }<br/>`;</span></pre><p id="56b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">定义标量JSON类型的。然后我们创建了一个有<code class="fe me mf mg mh b">aField</code>字段的<code class="fe me mf mg mh b">Foo</code>类型，然后我们有一个<code class="fe me mf mg mh b">Query</code>类型，带有一个返回<code class="fe me mf mg mh b">Foo</code>对象的<code class="fe me mf mg mh b">foo</code>查询。</p><p id="3bd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建一个<code class="fe me mf mg mh b">resolvers</code>对象，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d852" class="mq lc iq mh b gy mr ms l mt mu">const resolvers = {<br/>  JSON: GraphQLJSON,<br/>  Query: {<br/>    foo() {<br/>      return { aField: { foo: 'bar' } };<br/>    }<br/>  }<br/>};</span></pre><p id="31a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有解析为<code class="fe me mf mg mh b">GraphQLJSON</code>类型的<code class="fe me mf mg mh b">JSON</code>解析和返回<code class="fe me mf mg mh b">Foo</code>对象的<code class="fe me mf mg mh b">foo</code>查询。</p><p id="6355" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们在浏览器中转至<code class="fe me mf mg mh b">/graphql</code>并执行以下查询时:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3842" class="mq lc iq mh b gy mr ms l mt mu">{<br/>  foo {<br/>    aField <br/>  }<br/>}</span></pre><p id="4ec7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们回来了:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bb06" class="mq lc iq mh b gy mr ms l mt mu">{<br/>  "data": {<br/>    "foo": {<br/>      "aField": {<br/>        "foo": "bar"<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="de0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为回应。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/16e6bf2bfcb8992cde215fc640d61eb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3aZT5Zy5QiCU2ogL"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@lelacag?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Caglar Araz</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3308" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">自定义<code class="fe me mf mg mh b">GraphQLScalarType</code>实例</h1><p id="f0fa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们也可以使用<code class="fe me mf mg mh b">GraphQLScalarType</code>构造函数来创建我们自己的标量类型。</p><p id="a884" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f52a" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const { ApolloServer, gql } = require('apollo-server-express');<br/>const { GraphQLScalarType, Kind } = require('graphql');</span><span id="d087" class="mq lc iq mh b gy mv ms l mt mu">const CustomScalarType = new GraphQLScalarType({<br/>  name: 'CustomScalar',<br/>  description: 'Description',<br/>  serialize(value) {<br/>    return value;<br/>  },<br/>  parseValue(value) {<br/>    return value;<br/>  },<br/>  parseLiteral(ast) {<br/>    switch (ast.kind) {<br/>      case Kind.Int:<br/>        return ast.value.toString();<br/>      default:<br/>        return ast.value<br/>    }<br/>  }<br/>});</span><span id="10b2" class="mq lc iq mh b gy mv ms l mt mu">const typeDefs = gql`<br/>  scalar CustomScalar</span><span id="d4d0" class="mq lc iq mh b gy mv ms l mt mu">  type Foo {<br/>    aField: CustomScalar<br/>  }</span><span id="6a27" class="mq lc iq mh b gy mv ms l mt mu">  type Query {<br/>    foo: Foo<br/>  }<br/>`;</span><span id="9f0e" class="mq lc iq mh b gy mv ms l mt mu">const resolvers = {<br/>  CustomScalar: CustomScalarType,<br/>  Query: {<br/>    foo() {<br/>      return { aField: 123 };<br/>    }<br/>  }<br/>};</span><span id="9375" class="mq lc iq mh b gy mv ms l mt mu">const app = express();<br/>const server = new ApolloServer({ typeDefs, resolvers });<br/>server.applyMiddleware({ app });</span><span id="f585" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="305d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们编写了自己的标量类型<code class="fe me mf mg mh b">CustomScalar</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b7d2" class="mq lc iq mh b gy mr ms l mt mu">const CustomScalarType = new GraphQLScalarType({<br/>  name: 'CustomScalar',<br/>  description: 'Description',<br/>  serialize(value) {<br/>    return value;<br/>  },<br/>  parseValue(value) {<br/>    return value;<br/>  },<br/>  parseLiteral(ast) {<br/>    switch (ast.kind) {<br/>      case Kind.Int:<br/>        return ast.value.toString();<br/>      default:<br/>        return ast.value<br/>    }<br/>  }<br/>});</span></pre><p id="2a2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">name</code>属性来命名我们的标量类型，用<code class="fe me mf mg mh b">description</code>来描述我们的类型。</p><p id="bf00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们添加了一些方法来用<code class="fe me mf mg mh b">serialize</code>方法序列化类型。它通过转换返回我们想要序列化给定的<code class="fe me mf mg mh b">value</code>的任何内容。</p><p id="9d05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解析标量的值，我们添加了<code class="fe me mf mg mh b">parseValue</code>方法。我们可以随心所欲地解析<code class="fe me mf mg mh b">value</code>参数。</p><p id="756b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">parseLiteral</code>方法接受一个<code class="fe me mf mg mh b">ast</code>对象，它是抽象语法树。它为我们获取被解析的对象类型的<code class="fe me mf mg mh b">kind</code>属性。我们也解析树结构并返回我们想要的。</p><p id="da3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用自定义标量类型创建<code class="fe me mf mg mh b">typeDefs</code>常量，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b328" class="mq lc iq mh b gy mr ms l mt mu">const typeDefs = gql`<br/>  scalar CustomScalar</span><span id="c68c" class="mq lc iq mh b gy mv ms l mt mu">  type Foo {<br/>    aField: CustomScalar<br/>  }</span><span id="0353" class="mq lc iq mh b gy mv ms l mt mu">  type Query {<br/>    foo: Foo<br/>  }<br/>`;</span></pre><p id="a07e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们创建了下面的<code class="fe me mf mg mh b">resolvers</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ce06" class="mq lc iq mh b gy mr ms l mt mu">const resolvers = {<br/>  CustomScalar: CustomScalarType,<br/>  Query: {<br/>    foo() {<br/>      return { aField: 123 };<br/>    }<br/>  }<br/>};</span></pre><p id="f058" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过将自定义标量类型映射到<code class="fe me mf mg mh b">CustomScalar</code> resolve来使用它。然后我们创建一个<code class="fe me mf mg mh b">Query</code>解析器来返回我们想要的对象，它的类型是<code class="fe me mf mg mh b">Foo</code>。<code class="fe me mf mg mh b">Foo</code>有一个<code class="fe me mf mg mh b">aField</code>字段，这是我们的<code class="fe me mf mg mh b">CustomScalar</code>类型。</p><p id="224c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们转到<code class="fe me mf mg mh b">/graphql</code>页面时，我们可以运行以下查询:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="becf" class="mq lc iq mh b gy mr ms l mt mu">{<br/>  foo {<br/>    aField <br/>  }<br/>}</span></pre><p id="aa32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="df23" class="mq lc iq mh b gy mr ms l mt mu">{<br/>  "data": {<br/>    "foo": {<br/>      "aField": 123<br/>    }<br/>  }<br/>}</span></pre><h1 id="09f7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="cc42" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用GraphQL创建定制的标量类型。这让我们可以按照自己喜欢的方式序列化和解析值。</p><p id="48bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了创建一个，我们用关键字<code class="fe me mf mg mh b">scalar</code>创建我们的类型定义，以表明我们正在创建一个标量类型。</p><p id="b27e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们使用<code class="fe me mf mg mh b">GraphQLCustomScalarType</code>构造函数，并为一个对象提供解析和序列化值的方法以及我们的类型名称。</p><p id="8053" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们创建我们的<code class="fe me mf mg mh b">resolvers</code>，它包括我们的定制类型和查询数据的查询类型。</p><p id="392c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以从定制包中获得一个。</p><p id="e111" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以使用自定义类型进行查询。</p><h2 id="0042" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单的英语写的JavaScript的注释:</strong></h2><p id="35a3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们总是有兴趣帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的Medium用户名给我们发邮件到<a class="ae kc" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">submissions@javascriptinplainenglish.com</a>，我们会把你添加为作者。</p></div></div>    
</body>
</html>