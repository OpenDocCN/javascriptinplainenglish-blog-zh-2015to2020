<html>
<head>
<title>Higher Order Functions in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的高阶函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/higher-order-functions-in-javascript-8d7b3f6a261e?source=collection_archive---------6-----------------------#2020-07-23">https://javascript.plainenglish.io/higher-order-functions-in-javascript-8d7b3f6a261e?source=collection_archive---------6-----------------------#2020-07-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b07c7621a4b085ba80e9f2edfa18efc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfbXGQkOgqQ_I5P2VYkceQ.png"/></div></div></figure><p id="db96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">函数式编程是一种范式，它可以产生更干净、更简洁的代码，更易于维护，并减少难以发现的错误。函数式编程的一个中心概念是高阶函数。在JavaScript中，有多个内置的高阶函数。</p><p id="870f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据<a class="ae kt" href="https://en.wikipedia.org/wiki/Higher-order_function" rel="noopener ugc nofollow" target="_blank">维基百科</a>的说法，高阶函数会执行以下操作之一:</p><ul class=""><li id="3be2" class="ku kv in jx b jy jz kc kd kg kw kk kx ko ky ks kz la lb lc bi translated">以一个或多个函数作为自变量(即<a class="ae kt" href="https://en.wikipedia.org/wiki/Procedural_parameter" rel="noopener ugc nofollow" target="_blank">程序参数</a>)，</li><li id="78b0" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">返回一个函数作为结果。</li></ul></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="b0db" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">过滤器</h1><p id="031b" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">让我们开始吧。在企业级软件中，我们有时想要过滤可爱的狗。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0f00a329f96d01e06dcec5b33c27401a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TzeXqOiTDfkCWp8b9FHrag.png"/></div></div></figure><p id="0efe" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以为此使用for循环。我们将迭代每只狗，并根据可爱的布尔值进行过滤。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8f10f17c468360027807f9fd0073b241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y6C3vYoJxXrwSIjfZH8iWg.png"/></div></div></figure><p id="cb08" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，有一个更简单、更优雅的解决方案，那就是使用<strong class="jx io">过滤器</strong>功能。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1839847cba2d2677b87111a2d14d05e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JT-u6cgIQQlh-cv1DE4BA.png"/></div></div></figure><p id="4d39" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意这段代码有多简单。这是因为我们使用了称为滤波器的内置高阶函数。它接受一个函数作为其参数，用于过滤dogs数组中的项目。所以高阶函数就是一个在参数中包含另一个函数的函数。我们甚至可以在上面的例子中更进一步，将参数分离到它自己的函数中。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ab543858cdc2cf9b9faad5b6965ad2ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U8mebY8Y8H6b3OfEIrVf5A.png"/></div></div></figure><p id="95e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过这种方式，我们以后可以在任何我们想要的地方重用<strong class="jx io"> isCuteDog </strong>。</p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="3adf" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">地图</h1><p id="f90e" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">假设我们想通过让所有的狗都变得可爱来改进我们的企业软件。</p><p id="e011" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以通过迭代每只狗来做到这一点，并使狗变得可爱。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/0ae70a711987c2ba058a3c2f50d632ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bXznwBpg7w3Ukfr3YloyPQ.png"/></div></div></figure><p id="67bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者我们可以通过使用名为<strong class="jx io"> map的高阶函数来改进我们的代码。</strong></p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a383bab9819a7111212cf24d5d1e94b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fj5e26axj6o1hZG2kDrA3Q.png"/></div></div></figure><p id="03b5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">再次注意这段代码有多优雅。</p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="6159" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">减少</h1><p id="7402" class="pw-post-body-paragraph jv jw in jx b jy mn ka kb kc mo ke kf kg mp ki kj kk mq km kn ko mr kq kr ks ig bi translated">比方说，我们希望有许多可爱的狗和不可爱的狗。我们可以迭代每只狗，并把多少只狗可爱和不可爱放入一个对象中。或者我们可以利用reduce函数。</p><p id="efbc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是首先让我们简单介绍一下<strong class="jx io"> reduce </strong>函数，它是一个对数组的每个元素执行<strong class="jx io"> reducer </strong>函数的方法，返回一个输出。假设我们有一个想要累加的数字列表。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/852cde1bd1f569b6b3d1cf48afb0409b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CEIK8KuqnqPTugc7g8GaPg.png"/></div></div></figure><p id="2321" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">reduce函数接受一个参数，一个函数，即<strong class="jx io"> reducer </strong>，它有一个累加器(我们正在添加的值)和一个<strong class="jx io"> currentValue </strong>(数组中正在处理的当前值)。最后，我们以值8结束。<a class="ae kt" href="https://www.freecodecamp.org/news/reduce-f47a7da511a9/" rel="noopener ugc nofollow" target="_blank">这里</a>是一篇很棒的文章，如果你正在纠结这个概念的话。</p><figure class="ms mt mu mv gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9bfd575b85e642ca29a7cefc37b36233.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AVDXBoXK22nGmRo49B1QjA.png"/></div></div></figure><p id="2ad3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们回到我们的柜台。在这个例子中，我们提供了一个reducer函数，它累加一个我们称之为<strong class="jx io"> tally </strong>的对象，这是一个你可以在最后一行看到的对象，<code class="fe mw mx my mz b">{}</code>是初始值。当我们迭代每一项时，我们检查我们之前是否见过可爱或不可爱的狗，然后我们或者用1初始化该值，或者我们继续向上计数该值。最终我们会得到一个包含<code class="fe mw mx my mz b">{ false: 2, true: 2 }</code>的对象</p></div><div class="ab cl li lj hr lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ig ih ii ij ik"><h1 id="e6a0" class="lp lq in bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><ul class=""><li id="8ad7" class="ku kv in jx b jy mn kc mo kg na kk nb ko nc ks kz la lb lc bi translated">高阶函数要么是接受一个函数作为其参数，要么是返回一个函数作为其结果。</li><li id="b067" class="ku kv in jx b jy ld kc le kg lf kk lg ko lh ks kz la lb lc bi translated">它使你的代码更干净，更容易重用。</li></ul><p id="a054" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你正在使用React这样的框架，你可能会遇到<a class="ae kt" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>，它们遵循相同的模式。</p></div></div>    
</body>
</html>