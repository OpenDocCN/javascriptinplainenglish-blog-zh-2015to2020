<html>
<head>
<title>Web Components Crash Course (Shadow DOM)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web组件速成班(影子DOM)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/web-components-crash-course-shadow-dom-803183fcfabc?source=collection_archive---------4-----------------------#2019-11-21">https://javascript.plainenglish.io/web-components-crash-course-shadow-dom-803183fcfabc?source=collection_archive---------4-----------------------#2019-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0f72" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第3部分:阴影DOM</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8fd492b1726e8185071cedb29b6b3b91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*huON82ngbYi-v_BeSLLNeg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@ryoji__iwata?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Ryoji Iwata</a> on <a class="ae kv" href="https://unsplash.com/s/photos/puzzle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6ada" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是Web组件系列的第三部分，也是最后一部分。您可以通过以下链接找到第一部分和第二部分:</p><ul class=""><li id="7432" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/web-components-crash-course-7c0df961a8b7" rel="noopener">第1部分:定制元素</a></li><li id="e388" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/web-components-crash-course-b0a2feb11be1" rel="noopener">第二部分:模板</a></li></ul><p id="200b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong> <em class="mg">你可以通过从</em> <a class="ae kv" href="https://github.com/Haseeb90/web-components-crash-course" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mg">这里</em> </strong> </a> <em class="mg">克隆Git库来跟随本文中的代码示例。克隆存储库后，运行</em> <code class="fe mh mi mj mk b">npm install</code> <em class="mg">来设置项目。这个repo也包含前面部分的代码。</em></p><h1 id="a1c4" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">介绍</h1><p id="da37" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">影子DOM是Web组件的三个规范之一，它负责封装。它从页面的其余部分封装了CSS和DOM。有了它，您就可以创建完全隔离的web组件，而不会干扰它们所添加到的页面的CSS或DOM，因此您可以设计它们的样式，并使它们的外观和行为完全符合您的需要，而无需考虑或破坏页面上的其他组件。</p><h1 id="27c0" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">术语</h1><p id="0d4a" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">在我们深入研究Shadow DOM及其工作原理之前，让我们先来了解一些讨论时会听到的基本术语</p><ul class=""><li id="c4ba" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">影子根:</strong>包含单独DOM的文档片段</li><li id="ceeb" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">影子树:</strong>影子根里面的DOM</li><li id="5a93" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">影子主机:</strong>影子根/树的父节点。因为我们是从Web组件的角度来讨论这个问题的，所以这将是您创建的自定义元素。但是，它也可以是除自定义元素之外的任何其他元素。</li><li id="0c9f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir"> Shadow boundary: </strong>将它视为自定义元素内部的边界，但在shadow root之外。如果我们想从自定义元素的影子树中访问任何东西，我们必须跨越这个边界。</li></ul><p id="f778" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是它的草图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/c84bb56a991f5329664044b45c921eb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NRFI4nqk_WGt3x6ySMKb0g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Diagram of the Shadow DOM and its components</figcaption></figure><h1 id="1f64" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">影子王国</h1><p id="e93b" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">在我们看实现之前，我想澄清一件事，那就是，影子DOM并不严格绑定到web组件。您可以在您有权访问的任何元素上创建一个影子DOM。这里有一个例子，假设你有一个带<code class="fe mh mi mj mk b">id=”test”</code>的<code class="fe mh mi mj mk b">div</code>，你也可以在这个div中创建一个阴影DOM。这是你如何做的语法。</p><pre class="kg kh ki kj gt nj mk nk nl aw nm bi"><span id="ba76" class="nn mm iq mk b gy no np l nq nr">// .html file<br/>&lt;div id="test"&gt;&lt;/div&gt;</span><span id="e46c" class="nn mm iq mk b gy ns np l nq nr">// Get the shadow host<br/>const <strong class="mk ir">shadowHost</strong> = document.getElementById('test');</span><span id="7006" class="nn mm iq mk b gy ns np l nq nr">// attach shadow and get a reference to it<br/>const <strong class="mk ir">shadowRoot</strong> = shadowHost.attachShadow(<strong class="mk ir">{mode: 'open'}</strong>);</span><span id="8972" class="nn mm iq mk b gy ns np l nq nr">// create a regular element<br/>const <strong class="mk ir">shadowTreeEl</strong> = document.createElement('h1');<br/>shadowTreeEl.innerText = 'I\'m a shadow tree child';</span><span id="01ee" class="nn mm iq mk b gy ns np l nq nr">// attach the element to the shadow root<br/><strong class="mk ir">shadowRoot.appendChild</strong>(shadowTreeEl);</span></pre><p id="c837" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了更好地理解这段代码，请花点时间回过头来阅读上一节中的术语，并查看图表。现在，如果我们看一下创建的DOM，我们会看到类似这样的内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/242dd1c099c718253fdafb54fbbc2e35.png" data-original-src="https://miro.medium.com/v2/resize:fit:624/format:webp/1*Pj-gX8E3S53ib4pvJG0-wA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Inspection of the DOM shows the Shadow Root</figcaption></figure><p id="0f7e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们一步一步地看代码，但是请记住，我们仍然在讨论Shadow DOM规范，并且还没有在我们的自定义元素中实现它。</p><ul class=""><li id="61ef" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">首先，我们得到一个元素的引用，我们希望它成为我们的影子根的宿主。</li><li id="84ff" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">然后，我们使用参数<code class="fe mh mi mj mk b">{mode: 'open'}</code> <strong class="ky ir"> </strong>将影子根连接到我们的主机。我们将在这篇文章的后面更详细地讨论这个问题，但是现在，只需要知道它是一个必需的参数，并且<code class="fe mh mi mj mk b">mode</code>的值可以是<code class="fe mh mi mj mk b">'open'</code>或者<code class="fe mh mi mj mk b">'closed'</code>。</li><li id="0935" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们使用<code class="fe mh mi mj mk b">createElement</code> API创建一个元素，并将它附加到我们的影子根。请注意，这很可能是我们正在添加到影子根的模板的内容。</li></ul><h2 id="5a87" class="nn mm iq bd mn nu nv dn mr nw nx dp mv lf ny nz mx lj oa ob mz ln oc od nb oe bi translated">好吧，但什么是真正的？</h2><p id="7890" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">如果你还记得第2部分的<a class="ae kv" href="https://medium.com/javascript-in-plain-english/web-components-crash-course-b0a2feb11be1" rel="noopener">，在那里我们讨论了模板</a>，我们讨论了任何模板的基础都是一个<code class="fe mh mi mj mk b">document-fragment</code>，它是一个完全独立的DOM。嗯，影子根也是一个文档片段，这意味着影子根也是一个单独的DOM。它与页面的其余部分不是同一个DOM。从所有这些中得到的重要收获是，您在文档片段中处理一个新的DOM。但是，与我们用模板讨论的文档片段不同，这个片段被呈现到DOM中。</p><h2 id="89ec" class="nn mm iq bd mn nu nv dn mr nw nx dp mv lf ny nz mx lj oa ob mz ln oc od nb oe bi translated">使用带有自定义元素的阴影DOM</h2><p id="9df9" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">说了这么多，做了这么多，让我们看看如何将它添加到我们的自定义元素中。</p><pre class="kg kh ki kj gt nj mk nk nl aw nm bi"><span id="2b7e" class="nn mm iq mk b gy no np l nq nr">export default class AppToolbar extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    <strong class="mk ir">this.attachShadow({ mode: 'open' });</strong><br/>  }<br/>}</span></pre><p id="89d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">仅此而已！很简单，对吧？如果您还记得<a class="ae kv" href="https://medium.com/javascript-in-plain-english/web-components-crash-course-7c0df961a8b7" rel="noopener">第1部分，其中我们讨论了定制元素，</a>所指的是元素本身，因此我们不必像在前面的例子中那样单独获取对影子主机的引用。突出显示的代码做了几件事:</p><ul class=""><li id="dd07" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">它在您的定制元素中创建一个<em class="mg">影子根</em>，使您的定制元素成为<em class="mg">影子宿主</em></li><li id="c46c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">它还会在您的类中自动创建一个名为<code class="fe mh mi mj mk b"><strong class="ky ir">this.shadowRoot</strong></code>的新属性</li></ul><p id="0127" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦创建完毕，我们可以使用<code class="fe mh mi mj mk b">this.shadowRoot</code>来访问我们的元素属性，就像<code class="fe mh mi mj mk b">innerHTML</code>一样</p><pre class="kg kh ki kj gt nj mk nk nl aw nm bi"><span id="c612" class="nn mm iq mk b gy no np l nq nr">export default class AppToolbar extends HTMLElement {<br/>  constructor() {<br/>    super();<br/>    this.attachShadow({ mode: 'open' });<br/>  }<br/>  <br/>  <strong class="mk ir">connectedCallback() {<br/>    this.shadowRoot.innerHTML = `<br/>      &lt;h1&gt;<br/>        Im a shadow root child!<br/>      &lt;/h1&gt;<br/>    `;<br/>  }</strong><br/>}</span></pre><p id="43ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们检查一下DOM，看看我们得到了什么:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/fdcbcca20af728770a1b0f7048c5f644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6h14tuPyOQF6tJ8w7cQYRg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">With this change we’ve encapsulated our DOM and made it independent.</figcaption></figure><p id="b923" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过这一更改，我们现在已经封装了自定义元素的DOM，并使其独立。现在，如果我们尝试查询我们的<code class="fe mh mi mj mk b">h1</code>标签，我们会得到一个错误。大概是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/5171f6cf0d08dc406da5389f745e56d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxB0BFKT_RWUplROGhmdDQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Access to the shadow tree directly is denied. We have to access the shadow tree elements through the shadow root</figcaption></figure><p id="3a1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不允许直接访问影像树元素。为了访问影子树元素，我们必须通过影子根。<strong class="ky ir">影根的内部元素和风格就是这样封装的，不受外界影响。</strong></p><h2 id="db15" class="nn mm iq bd mn nu nv dn mr nw nx dp mv lf ny nz mx lj oa ob mz ln oc od nb oe bi translated">关闭模式({ mode: 'closed' })</h2><p id="8d0f" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">我不打算详细说明这一点，主要是因为你不应该也不会使用它。如果你对为什么不应该感到好奇，我认为谷歌在解释为什么不应该使用封闭模式方面做得更好。以下是他们在这个链接中给出的总结:</p><ul class=""><li id="f59a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">人为的安全感。</li><li id="6066" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">封闭模式<strong class="ky ir">阻止你的定制元素代码访问它自己的影子DOM </strong>。</li><li id="f7a8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">对于最终用户来说，封闭模式降低了组件的灵活性</strong>。</li></ul><p id="2d41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你浏览了那个链接，现在应该很清楚了，封闭模式在大多数情况下是不值得麻烦的。</p><h1 id="3d5a" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">阴影DOM和<slot>标签</slot></h1><p id="0dcc" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated"><strong class="ky ir">注意:</strong><em class="mg"/><code class="fe mh mi mj mk b">&lt;slot&gt;</code><em class="mg">标签只对</em> <strong class="ky ir"> <em class="mg">阴影DOM </em> </strong> <em class="mg">有效。</em></p><p id="5c18" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mh mi mj mk b">&lt;slot&gt;</code>标签在某种意义上类似于<code class="fe mh mi mj mk b">&lt;template&gt;</code>标签，它不会被呈现到DOM中。它允许我们有一个放置内容的占位符，所以我们不是从它那里复制内容，而是自动将内容放入其中。他们是替换里面内容的目标。</p><p id="9c64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong> <em class="mg">如果您正在跟踪并克隆了回购，请切换到分支</em> <code class="fe mh mi mj mk b"><strong class="ky ir">shadow-dom-slots</strong></code> <em class="mg">来看看这是如何工作的。不要忘记运行</em> <code class="fe mh mi mj mk b"><strong class="ky ir">npm run serve</strong></code> <em class="mg">在你的浏览器中查看作品。</em></p><h2 id="2326" class="nn mm iq bd mn nu nv dn mr nw nx dp mv lf ny nz mx lj oa ob mz ln oc od nb oe bi translated">具有名称属性的插槽</h2><p id="3b09" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">属性是我们如何引用任何给定的槽。假设您有一个模板，您想在其中放置插槽，它看起来是这样的:</p><pre class="kg kh ki kj gt nj mk nk nl aw nm bi"><span id="bb7e" class="nn mm iq mk b gy no np l nq nr">&lt;template id="unique"&gt;<br/>  &lt;div class="container"&gt;<br/>    &lt;div class="circle"&gt;<br/>      <strong class="mk ir">&lt;slot name="image"&gt;image&lt;/slot&gt;</strong><br/>    &lt;/div&gt;<br/>    &lt;div class="name-container"&gt;<br/>      <strong class="mk ir">&lt;slot name="fullName"&gt;Full name goes here&lt;/slot&gt;<br/>      &lt;slot name="email"&gt;User email goes here&lt;/slot&gt;</strong><br/>    &lt;/div&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="9c1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，我们如何将内容插入到<code class="fe mh mi mj mk b"><strong class="ky ir">&lt;slot&gt;</strong></code>标签中呢？由于插槽只适用于影子DOM，我们首先必须创建影子根。如果你跟着做，这些变化可以在<code class="fe mh mi mj mk b"><strong class="ky ir">toolbar.component.js</strong></code>中找到。</p><pre class="kg kh ki kj gt nj mk nk nl aw nm bi"><span id="4ba6" class="nn mm iq mk b gy no np l nq nr">export default class AppToolbar extends HTMLElement {<br/>  <br/>  constructor() {<br/>    super();<br/>    <strong class="mk ir">this.attachShadow({ mode: 'open' });</strong><br/>  }</span><span id="b255" class="nn mm iq mk b gy ns np l nq nr">  connectedCallback() {<br/>    const template = document.getElementById('unique');<br/>    const templateClone = template.content.cloneNode(true);<br/>    <strong class="mk ir">this.shadowRoot.appendChild(templateClone);</strong><br/>  }<br/>}</span></pre><p id="6230" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的代码中，</p><ul class=""><li id="3e53" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">我们将一个阴影根附加到我们的自定义元素上。请记住，当我们以这种方式附加阴影DOM时，它会自动在我们的自定义元素上创建一个名为<code class="fe mh mi mj mk b"><strong class="ky ir">shadowRoot</strong></code>的新属性</li><li id="7353" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们正在获取模板的内容并克隆它</li><li id="8d1d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">然后使用自动创建的属性<code class="fe mh mi mj mk b"><strong class="ky ir">this.shadowRoot</strong></code>将该模板附加到我们的影子根</li></ul><p id="07c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看不做任何其他事情会是什么样子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/ac93c7f14a0c6ab6f1167d4ae52ebe2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F84AvGTVO3T9n1_Z261iEA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Without defining the content that goes into the slots, the default content is rendered.</figcaption></figure><p id="fcf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在没有定义进入插槽的内容的情况下，呈现默认内容。但是还记得我之前提到的吗？插槽允许我们在它们的位置插入内容，我们可以通过它的<code class="fe mh mi mj mk b"><strong class="ky ir">name</strong></code>属性引用任何给定的插槽。只需在自定义元素标记中添加标记就可以做到这一点。为此，打开<code class="fe mh mi mj mk b"><strong class="ky ir">index.html</strong></code>并执行以下操作。</p><pre class="kg kh ki kj gt nj mk nk nl aw nm bi"><span id="8192" class="nn mm iq mk b gy no np l nq nr">...<br/><strong class="mk ir">&lt;app-toolbar&gt;</strong><br/>  &lt;img <strong class="mk ir">slot="image"</strong><br/>  src="https://images.unsplash.com/photo-1509281373149-e957c6296406?ixlib=rb-1.2.1&amp;dpr=2&amp;auto=format&amp;fit=crop&amp;w=416&amp;h=312&amp;q=60"<br/>  width="200px"&gt;<br/>  &lt;/img&gt;</span><span id="8d01" class="nn mm iq mk b gy ns np l nq nr">  &lt;p <strong class="mk ir">slot="fullName"</strong>&gt;Billy Bob Jenkins&lt;/p&gt;<br/>  &lt;p <strong class="mk ir">slot="email"</strong>&gt;email@email.com&lt;/p&gt;<br/><strong class="mk ir">&lt;/app-toolbar&gt;</strong><br/>...</span></pre><p id="d9b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们的自定义元素标签中，我们添加了标记，并告诉每个元素应该呈现在哪个槽中。让我们看看它现在是什么样子</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/8cc49484408c5be260318abaffeb7a75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vkTUI77FeYZeD7_5fyLwNw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The contents of the slot get replaced with the tags we defined.</figcaption></figure><p id="d1a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">槽get <em class="mg">的内容被我们定义的标签</em>替换，即<em class="mg">标签被插入到槽</em>中。我们通过将<em class="mg">插槽属性</em>添加到每个标签并将值设置为我们之前定义的<em class="mg">插槽名称</em>来告知应该在哪里呈现哪个标签。</p><h2 id="1a4e" class="nn mm iq bd mn nu nv dn mr nw nx dp mv lf ny nz mx lj oa ob mz ln oc od nb oe bi translated">没有名称的插槽</h2><p id="a026" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">具有名称属性的槽<em class="mg">是您想要呈现特定内容的特定位置，没有名称属性</em>的槽<em class="mg">充当一个总括位置。</em></p><p id="eca9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设您有一个模板，您想在其中一致地显示某些内容，而其余的内容是在某个动作时动态加载的。有许多方法可以做到这一点，但一种方法是使用插槽<em class="mg">(没有名称标签)</em>。让我们通过修改前面的例子来更深入地了解这一点</p><pre class="kg kh ki kj gt nj mk nk nl aw nm bi"><span id="0926" class="nn mm iq mk b gy no np l nq nr">&lt;template id="unique"&gt;<br/>  &lt;div class="container"&gt;<br/>    <strong class="mk ir">&lt;h3&gt;This heading will always be displayed&lt;/h3&gt;</strong><br/>    &lt;div class="circle"&gt;<br/>      <strong class="mk ir">&lt;slot name="image"&gt;image&lt;/slot&gt;</strong><br/>    &lt;/div&gt;<br/>    <strong class="mk ir">&lt;slot class="content-container"&gt;&lt;/slot&gt;</strong><br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="b642" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我们使用两种类型的插槽来演示两者可以协同工作。第一个标签为<code class="fe mh mi mj mk b"><strong class="ky ir">name="image"</strong></code>的槽我们已经讲过了。然而，第二个slot标记没有name属性，所以它将作为我们在自定义元素标记中放置的所有内容的集合。<code class="fe mh mi mj mk b"><strong class="ky ir">h3</strong></code>是为了证明槽外的内容不会改变。</p><p id="feef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们对我们的自定义元素进行更改，然后看看更改是什么样子的:</p><pre class="kg kh ki kj gt nj mk nk nl aw nm bi"><span id="9687" class="nn mm iq mk b gy no np l nq nr">...<br/>&lt;app-toolbar&gt;<br/>  &lt;img <strong class="mk ir">slot="image"</strong><br/>  src="https://images.unsplash.com/photo-1509281373149-e957c6296406?ixlib=rb-1.2.1&amp;dpr=2&amp;auto=format&amp;fit=crop&amp;w=416&amp;h=312&amp;q=60"<br/>  width="200px"&gt;<br/>  &lt;/img&gt;</span><span id="a0d1" class="nn mm iq mk b gy ns np l nq nr">  <strong class="mk ir">&lt;p&gt;Billy Bob Jenkins&lt;/p&gt;<br/>  &lt;p&gt;email@email.com&lt;/p&gt;</strong><br/>&lt;/app-toolbar&gt;<br/>...</span></pre><p id="3ad8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着插槽属性<em class="mg">从两个<code class="fe mh mi mj mk b"><strong class="ky ir">p</strong></code>标签中移除</em>，它们现在将在没有名称属性的插槽中呈现。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/0bb785b2870748f83fa723317abc62e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T1ZzS9TzG0G4uO4bOKuw9A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The image still is rendered in the correct slot and the remainder of the content is rendered in the second slot.</figcaption></figure><p id="90ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这很棒，因为现在我们可以呈现自定义元素的多个版本，每个版本中包含不同的内容！</p><pre class="kg kh ki kj gt nj mk nk nl aw nm bi"><span id="cdcf" class="nn mm iq mk b gy no np l nq nr">...<br/>&lt;app-toolbar&gt;<br/>  &lt;img <strong class="mk ir">slot="image"</strong><br/>  src="https://images.unsplash.com/photo-1509281373149-e957c6296406?ixlib=rb-1.2.1&amp;dpr=2&amp;auto=format&amp;fit=crop&amp;w=416&amp;h=312&amp;q=60"<br/>  width="200px"&gt;<br/>  &lt;/img&gt;</span><span id="94ff" class="nn mm iq mk b gy ns np l nq nr"><strong class="mk ir">  &lt;p&gt;Retro TV Picture&lt;/p&gt;<br/>  &lt;p&gt;By: Photo by </strong><a class="ae kv" href="https://unsplash.com/@ajeetmestry?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><strong class="mk ir">Ajeet Mestry</strong></a><strong class="mk ir"> on </strong><a class="ae kv" href="https://unsplash.com/wallpapers/design/retro?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><strong class="mk ir">Unsplash</strong></a><strong class="mk ir">&lt;/p&gt;</strong><br/>&lt;/app-toolbar&gt;</span><span id="de83" class="nn mm iq mk b gy ns np l nq nr">&lt;hr&gt;</span><span id="43c3" class="nn mm iq mk b gy ns np l nq nr">&lt;app-toolbar&gt;<br/>  &lt;img <strong class="mk ir">slot="image"</strong><br/>  src="https://images.unsplash.com/photo-1509281373149-e957c6296406?ixlib=rb-1.2.1&amp;dpr=2&amp;auto=format&amp;fit=crop&amp;w=416&amp;h=312&amp;q=60"<br/>  width="200px"&gt;<br/>  &lt;/img&gt;</span><span id="d893" class="nn mm iq mk b gy ns np l nq nr"><strong class="mk ir">  &lt;p&gt;Yellow Gameboy&lt;/p&gt;<br/>  &lt;p&gt;By: Photo by </strong><a class="ae kv" href="https://unsplash.com/@mike_meyers?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><strong class="mk ir">Mike Meyers</strong></a><strong class="mk ir"> on </strong><a class="ae kv" href="https://unsplash.com/wallpapers/design/retro?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank"><strong class="mk ir">Unsplash</strong></a><strong class="mk ir">&lt;/p&gt;</strong><br/>&lt;/app-toolbar&gt;<br/>...</span></pre><p id="66d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是它的样子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/41ac0542df64eb56105ff03232d4599c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1246/format:webp/1*CFzMmmug_zg6QKVvVsTX7w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Using just one template with slots we can render dynamic content</figcaption></figure><h1 id="46da" class="ml mm iq bd mn mo mp mq mr ms mt mu mv jw mw jx mx jz my ka mz kc na kd nb nc bi translated">结论</h1><p id="6a66" class="pw-post-body-paragraph kw kx iq ky b kz nd jr lb lc ne ju le lf nf lh li lj ng ll lm ln nh lp lq lr ij bi translated">在这篇文章中，我们讨论了</p><ul class=""><li id="ab89" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">影子DOM使用的术语</li><li id="894c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如何将阴影根附加到任何元素以及自定义元素</li><li id="cad1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">影子DOM保护它的内部DOM不被意外访问</li><li id="488b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">阴影DOM的打开和关闭模式</li><li id="0967" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">插槽标签及其工作原理</li></ul><p id="2728" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，就这些。如果您完成了这三个部分，那么您应该对用于制作web组件的三种技术有很好的理解。你应该对你所获得的知识有足够的信心去开始创建web组件。</p><p id="4a33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这个系列，请随意在社交媒体上与你的同伴分享，也可以随意提出任何问题。</p><p id="b1db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">干杯！</p></div></div>    
</body>
</html>