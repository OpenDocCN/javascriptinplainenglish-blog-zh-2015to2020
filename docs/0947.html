<html>
<head>
<title>Find Path — Depth First Search</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">查找路径—深度优先搜索</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/find-path-depth-first-search-28d27bba8ae0?source=collection_archive---------5-----------------------#2020-01-05">https://javascript.plainenglish.io/find-path-depth-first-search-28d27bba8ae0?source=collection_archive---------5-----------------------#2020-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e03c94f913ee74a82cc8c727c8f6bdca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QPGjOXhmiNBtjiUF97uVFw.png"/></div></div></figure><p id="669d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是深度优先搜索的一个样例问题。要快速阅读这是什么，以及对图形的基本理解，请阅读<a class="ae kw" href="https://medium.com/javascript-in-plain-english/data-structures-understanding-graphs-82509d35e6b5" rel="noopener">这个</a>。</p><p id="7fa7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">问题陈述:</strong></p><p id="f0fd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给定一个图，一个起点(<strong class="ka ir"> src </strong>)和一个目的地(<strong class="ka ir"> dest </strong>)，返回从<strong class="ka ir"> src </strong>到<strong class="ka ir"> dest </strong>的路径，如果没有路径，返回一个空数组。</p><p id="5a86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">给定以下边缘列表:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="2d08" class="lg lh iq lc b gy li lj l lk ll">let smallFlightMap = [<br/>  ["ATL", "DC"],<br/>  ["DC", "NYC"],<br/>  ["ATL", "DAL"],<br/>  ["DAL", "DC"]<br/>]</span></pre><p id="ffcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，编写一个转换为邻接表的函数:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="4718" class="lg lh iq lc b gy li lj l lk ll">const toAdjacencyList = function(edgeList) {<br/>    const adjacencyList = {};<br/>    for (let edge of edgeList) {<br/>      const src = edge[0];<br/>      const dest = edge[1];</span><span id="93bb" class="lg lh iq lc b gy lm lj l lk ll">      if (adjacencyList[src] != undefined) {<br/>          adjacencyList[src].push(dest);<br/>      } else {<br/>          adjacencyList[src] = [dest];<br/>      }<br/>    }<br/>    return adjacencyList;<br/>}</span></pre><p id="cf9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">目标是将所有片段写入以下函数，该函数使用深度优先搜索找到从<strong class="ka ir"> src </strong>(源)到<strong class="ka ir"> dest </strong>(目的地)的路径:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="5a79" class="lg lh iq lc b gy li lj l lk ll">const findPath = function(src, dest, flights) {<br/>    const graph = toAdjacencyList(flights);<br/>    const visited = new Set();<br/>    const stack = [];<br/>    stack.push(src);</span></pre><p id="f66b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">步骤1。创建一个名为<code class="fe ln lo lp lc b">cameFrom</code>的对象来记录你从哪里来。城市将是键，值是前一个城市，我们称之为<code class="fe ln lo lp lc b">previousCity</code></strong></p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="4d11" class="lg lh iq lc b gy li lj l lk ll">const cameFrom = {};</span></pre><p id="3789" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">步骤二。</strong>将<code class="fe ln lo lp lc b">cameFrom[src]</code>设置为未定义。因为你是从src开始的，它不是从任何地方来的。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="76d9" class="lg lh iq lc b gy li lj l lk ll">cameFrom[src] = undefined;</span><span id="da41" class="lg lh iq lc b gy lm lj l lk ll">while (stack.length &gt; 0) {<br/>    const currentCity = stack.pop();<br/>    console.log(currentCity);<br/>    const adjacentCities = graph[currentCity] || [];</span></pre><p id="33d4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，在最后一行，如果<code class="fe ln lo lp lc b">graph[currentCity]</code>未定义，它将返回一个空数组。</p><p id="2a26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">步骤三。</strong>如果到达目的地，通过<code class="fe ln lo lp lc b">cameFrom</code>返回，建立从<code class="fe ln lo lp lc b">src</code>到<code class="fe ln lo lp lc b">dest</code>的路径。</p><p id="0903" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将需要一个变量— <code class="fe ln lo lp lc b">pathFromSrcToDes</code> t，以一个空数组开始，并使用unshift()将目的地添加到数组的前面。<code class="fe ln lo lp lc b">const pathFromSrcToDest = []</code>和<code class="fe ln lo lp lc b">pathFromSrcToDest.unshift(dest)</code></p><p id="0586" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，创建另一个变量来跟踪path (stack)中的前一个城市，该变量被设置为您刚来的目的地。，<code class="fe ln lo lp lc b">let previousCity = cameFrom[dest]</code>。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="34e1" class="lg lh iq lc b gy li lj l lk ll">if (currentCity === dest) {<br/>        const pathFromSrcToDest = [];<br/>        pathFromSrcToDest.unshift(dest);<br/>        let previousCity = cameFrom[dest];<br/>                }</span></pre><p id="31c7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe ln lo lp lc b">unshift()</code>将<code class="fe ln lo lp lc b">previousCity </code>添加到<code class="fe ln lo lp lc b">pathFromSrcToDest</code>并设置<code class="fe ln lo lp lc b">previousCity = cameFrom[previousCity]</code>然后返回<code class="fe ln lo lp lc b">pathFromSrcToDest</code>。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="7c86" class="lg lh iq lc b gy li lj l lk ll">while (previousCity != undefined) {<br/>          pathFromSrcToDest.unshift(previousCity);<br/>          previousCity = cameFrom[previousCity];<br/>        }<br/>        return pathFromSrcToDest;<br/>      }</span></pre><p id="3920" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">设置<code class="fe ln lo lp lc b">cameFrom[nextCity] = currentCity</code>并记住如果解未定义(没有路径)则返回一个空数组。</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="95e7" class="lg lh iq lc b gy li lj l lk ll">for (nextCity of adjacentCities) {<br/>        if (!visited.has(nextCity)) <br/>         cameFrom[nextCity] = currentCity;<br/>         stack.push(nextCity);<br/>         visited.add(nextCity);<br/>            }<br/>     }<br/> }<br/> return [];<br/>}</span></pre><p id="137c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在<a class="ae kw" href="https://codepen.io/rachelhawa/pen/XWJzxbj" rel="noopener ugc nofollow" target="_blank">这里</a>查看上面正在使用的代码和测试用例。</p></div></div>    
</body>
</html>