<html>
<head>
<title>The Vue.js Created Lifecycle Hook Explained With Example</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue.js创建的生命周期钩子举例说明</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-vue-js-created-lifecycle-hook-explained-with-example-2566d878d21?source=collection_archive---------5-----------------------#2020-12-24">https://javascript.plainenglish.io/the-vue-js-created-lifecycle-hook-explained-with-example-2566d878d21?source=collection_archive---------5-----------------------#2020-12-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c868" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">通过示例了解创建的Vue.js生命周期挂钩</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a392d644e746f7d0c1a1782bbe867397.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*q5aBNAfoba2kdjyp"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@heylagostechie?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">heylagostechie</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="2a51" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">什么是生命周期挂钩？</h2><p id="ab26" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">生命周期挂钩是纯函数，其上下文绑定到它们的实例。对于这种情况，Vue.js生命周期钩子不应该被声明为箭头函数。</p><h2 id="cc17" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">为什么没有箭头功能？</strong></h2><p id="95d5" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">生命周期挂钩应该是纯函数，因为箭头函数的上下文完全绑定到它们的父上下文。<br/>在arrow函数中使用<strong class="lu ir"> <em class="ml">这个</em> </strong>访问数据、方法和计算属性，会在Vue.js实例上抛出一个未定义的错误。</p><h2 id="91d9" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">创建了钩子</strong></h2><p id="4c0c" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">这个生命周期钩子在数据创建后被同步调用。这发生在$el设置之前，但在数据观察、计算属性、观察器/事件回调和方法设置之后。</p><p id="f384" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">创建的挂钩允许您添加代码，如果创建了Vue实例，就会运行这些代码。</p><p id="0f36" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">一个<a class="ae kv" href="https://vuejs.org/images/lifecycle.png" rel="noopener ugc nofollow" target="_blank"> Vue生命周期的步骤</a>。是:创建前、已创建、装载前、已装载、更新前、已更新、销毁前、已销毁。</p><p id="9043" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">此时，$el属性还不可访问，并且完全不可用。<br/>所以，当你需要在数据实例创建后立即运行一个特定的函数时，我们可以使用这个钩子。</p><p id="ba4f" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">还要注意，创建的钩子只在数据、方法和计算属性设置好之后运行一次。</p><p id="4045" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated"><strong class="lu ir">示例</strong></p><pre class="kg kh ki kj gt mr ms mt mu aw mv bi"><span id="0533" class="kw kx iq ms b gy mw mx l my mz">async created() {</span><span id="cd66" class="kw kx iq ms b gy na mx l my mz"><em class="ml">//Called synchronously after the instance is created</em></span><span id="4faf" class="kw kx iq ms b gy na mx l my mz"><em class="ml">try</em> {</span><span id="05f9" class="kw kx iq ms b gy na mx l my mz">const response = <em class="ml">await</em> fetch(</span><span id="8ce4" class="kw kx iq ms b gy na mx l my mz">`https://api.pexels.com/v1/search?query=cars&amp;per_page=40`</span><span id="eb78" class="kw kx iq ms b gy na mx l my mz">);</span><span id="5cf8" class="kw kx iq ms b gy na mx l my mz">const data = <em class="ml">await</em> response.json();</span><span id="cbdb" class="kw kx iq ms b gy na mx l my mz">console.log(data)</span><span id="9c88" class="kw kx iq ms b gy na mx l my mz">} <em class="ml">catch</em> (error) {</span><span id="22b3" class="kw kx iq ms b gy na mx l my mz">console.log(error);</span><span id="2e89" class="kw kx iq ms b gy na mx l my mz">}</span><span id="5a03" class="kw kx iq ms b gy na mx l my mz">}</span></pre><p id="9b9a" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">在上面显示的例子中，我们向端点发出一个fetch API请求，并等待一个承诺。</p><p id="20d5" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">如果承诺得到解决，我们只需将其记录到控制台，如果出现任何错误，我们也会将其记录到控制台。</p><p id="64a3" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">我们还可以将async附加到创建的生命周期挂钩上，以进行异步调用。</p><p id="6c2e" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated"><strong class="lu ir"> <em class="ml">注意:</em> </strong> <em class="ml">不要使用</em> <a class="ae kv" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank"> <em class="ml">箭头函数</em> </a> <em class="ml">对某个options属性或回调，如</em> <code class="fe nb nc nd ms b"><em class="ml">created: () =&gt; console.log(this.a)</em></code> <em class="ml">或</em> <code class="fe nb nc nd ms b"><em class="ml">vm.$watch('a', newValue =&gt; this.myMethod())</em></code> <em class="ml">。由于箭头函数没有</em> <code class="fe nb nc nd ms b"><em class="ml">this</em></code> <em class="ml">，</em> <code class="fe nb nc nd ms b"><em class="ml">this</em></code> <em class="ml">将被视为任何其他变量，并通过父作用域进行词汇查找，直到找到为止，这通常会导致错误，如</em> <code class="fe nb nc nd ms b"><em class="ml">Uncaught TypeError: Cannot read property of undefined</em></code> <em class="ml">或</em> <code class="fe nb nc nd ms b"><em class="ml">Uncaught TypeError: this.myMethod is not a function</em></code> <em class="ml">。vuejs.org</em></p><h2 id="a0c6" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated"><strong class="ak">结论</strong></h2><p id="ec8d" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">简单回顾一下，我们已经看到了创建的生命周期挂钩是如何工作的，以及何时在我们的应用程序中使用它。</p><p id="0415" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">当我们想在Vue.js应用程序中运行一次函数时，也可以使用它。</p><p id="ccac" class="pw-post-body-paragraph ls lt iq lu b lv mm jr lx ly mn ju ma lf mo mc md lj mp mf mg ln mq mi mj mk ij bi translated">感谢您通读这篇文章。如果你觉得这篇文章有帮助，请不要犹豫，分享出来。</p></div></div>    
</body>
</html>