<html>
<head>
<title>How To Create Custom Event Listeners in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript创建自定义事件监听器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/event-listeners-in-javascript-7c241fb74976?source=collection_archive---------9-----------------------#2020-11-15">https://javascript.plainenglish.io/event-listeners-in-javascript-7c241fb74976?source=collection_archive---------9-----------------------#2020-11-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="db89" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在您的代码库中，创建自定义事件监听器有什么用处？</h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/a167256bf1fdbe9df41922e9690180cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DmYVHF_nK0rR1H6d.png"/></div></div></figure><p id="9290" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">浏览器环境中的JavaScript使用事件驱动架构。这意味着我们可以执行我们的代码来响应某些用户行为，如点击按钮或聚焦输入。</p><p id="2a6a" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这里重要的是，DOM(文档对象模型)是一个为我们提供与文档交互的访问的系统，我们的代码并不直接相连。我们需要我们的系统能够响应不同的DOM事件，事件侦听器是我们将系统耦合到DOM以使其具有交互性的方式。</p><p id="74e7" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这里的想法是能够连接两个系统，以便能够响应彼此的行为。</p><p id="3ecc" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">因此，假设您有一个大型代码库，其中有不同的独立组件执行不同的任务，您可能希望在它们之间有一个通信媒介，这就是事件监听器的作用。</p><p id="f6e7" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在这种情况下，我们可以创建自己的事件，并将代码绑定到事件上，以便以后需要时触发。</p><p id="02fd" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这种系统的粘合剂将是一个全局对象，我们可以将所有这些函数附加到它上面，并用一个键来引用它们。这个键可以在以后需要时触发这些功能。</p><p id="64d0" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">最初的任务是创建一个类，它可以用所有需要的方法返回一个对象。如果只需要一个实例，还可以为同一个实例创建一个简单的对象。</p><p id="c592" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">之后，我们需要的第一个重要方法是在一个特定的事件上附加一个回调函数，我们可以根据自己的喜好给它命名。</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="6b26" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在这个方法中，我们根据事件的名称创建一个对象属性，它将保存一个回调函数的数组，当事件被触发时，可以调用这些函数。</p><p id="6721" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在操作现有属性的同时，保持检查以确保您没有针对原型链中的任何现有属性。</p><p id="975c" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">假设我们使用<strong class="kr io">‘on’</strong>方法将<em class="ln">回调1、回调2和回调3 </em>附加到一个名为<strong class="kr io">‘logger’</strong>的事件，我们应该有如下输出:</p><pre class="ke kf kg kh gt lo lp lq lr aw ls bi"><span id="4e2e" class="lt lu in lp b gy lv lw l lx ly">{</span><span id="eebb" class="lt lu in lp b gy lz lw l lx ly">'logger':[callback1, callback2, callback3 ]</span><span id="91c4" class="lt lu in lp b gy lz lw l lx ly">}</span></pre><p id="cd45" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">一旦我们发出这个事件，我们应该调用并执行附加到这个事件的所有回调函数，为此我们可以使用如下所示的方法:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="6fc9" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">当发出一个特定的事件时，我们也可以将一些<strong class="kr io">信息作为与该事件相关的参数</strong>传递给回调函数。</p></div><div class="ab cl ma mb hr mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ig ih ii ij ik"><p id="ec5e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">通常这对于事件处理来说是很好的，但是使用事件处理程序的一个缺点或副作用是，只要代码在运行，全局对象就会一直保持活动状态，并且无论您在事件中附加什么函数，以及通过闭包附加到事件上的数据，都不会被垃圾收集器收集。这里有一个小例子:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="mh lm l"/></div></figure><p id="799d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这里，<strong class="kr io"> deleteData </strong>函数重新分配变量<strong class="kr io"> maindata </strong>，但是定义的对象仍然通过<strong class="kr io"> eventhandler </strong>保持引用，可以通过在任何时候发出事件来检查，如上例所示。</p><p id="2b56" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">为了避免这样的内存泄漏，我们需要在不需要回调的时候立即删除它们，可以这样做，如下所示:</p><figure class="ke kf kg kh gt ki"><div class="bz fp l di"><div class="ll lm l"/></div></figure><p id="bec5" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">如果不再需要事件，我们还可以添加一个方法来删除事件属性本身。</p><p id="c1c3" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae mi" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kr io">！</strong></p><p id="d4c6" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">以上是我的观点，如果你需要一个npm包，这里有相同的链接:</p><div class="mj mk gp gr ml mm"><a href="https://www.npmjs.com/package/mini-event-handler" rel="noopener  ugc nofollow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd io gy z fp mr fr fs ms fu fw im bi translated">迷你事件处理程序</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">“迷你事件处理程序”为您提供了一个可以用来构造事件处理程序的类。返回的对象是…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">www.npmjs.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na kn mm"/></div></div></a></div></div></div>    
</body>
</html>