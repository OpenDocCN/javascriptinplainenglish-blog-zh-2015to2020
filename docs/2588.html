<html>
<head>
<title>Inside PixiJS: The ultimate scene graph optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PixiJS内部:终极场景图优化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/inside-pixijs-the-ultimate-scene-graph-optimization-35b62bb2153?source=collection_archive---------0-----------------------#2020-07-07">https://javascript.plainenglish.io/inside-pixijs-the-ultimate-scene-graph-optimization-35b62bb2153?source=collection_archive---------0-----------------------#2020-07-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bda9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">剔除，以及如何用十行代码实现它！</h2></div><p id="3b5e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的WebGL应用程序有一个非常大的场景，但在任何时候都只有部分可见，那么您可以通过剔除不可见的显示对象来立即提高性能。</p><p id="cb33" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">你正在阅读PixiJS: WebGL渲染器</em>  <em class="lb">里面的一章“</em> <a class="ae lc" href="/@sukantk3.4/inside-pixijs-webgl-renderer-eca3357ad7f5" rel="noopener ugc nofollow" target="_blank"> <em class="lb">”。</em></a></p><h1 id="4ed6" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">选择</h1><p id="79c0" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">在计算机图形学中，“剔除”有多重含义。此处的术语用于描述评估对象是否“可见”以及是否应该渲染的过程。这允许渲染器跳过不需要绘制的对象，并减少每个节拍的绘制调用次数。这是第一次尝试60 FPS的优化。</p><p id="da21" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最初的想法是受大卫·菲格纳特的pixi-cull包的启发；然而，这并没有提供基于世界边界的递归和健壮的解决方案。相反，它是为使用pixi-viewport插件而设计的，并基于局部边界比较进行挑选。</p><h1 id="7a12" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">@ pixi-essentials/精选</h1><p id="bf9f" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">我专门为递归剔除构建了<code class="fe ma mb mc md b"><a class="ae lc" href="https://github.com/SukantPal/pixi-essentials/tree/master/packages/cull" rel="noopener ugc nofollow" target="_blank">@pixi-essentials/cull</a></code>包。它使用优化的算法来评估哪些对象需要剔除。</p><p id="4569" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于大多数基本应用程序，您可以在每个渲染周期从舞台开始挑选整个场景图形。</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="960e" class="mm le iq md b gy mn mo l mp mq">import { Application } from 'pixi.js';<br/>import { Cull } from '@pixi-essentials/cull';</span><span id="809d" class="mm le iq md b gy mr mo l mp mq">const app = new Application({ });</span><span id="b867" class="mm le iq md b gy mr mo l mp mq">// These options are the default.<br/>const cull = new Cull({ recursive: true, toggle: 'renderable' });</span><span id="6772" class="mm le iq md b gy mr mo l mp mq">// Cull the entire scene graph, starting from the stage<br/>cull.add(app.stage);</span><span id="aa75" class="mm le iq md b gy mr mo l mp mq">// "prerender" is fired right before the renderer draws the scene<br/>app.renderer.on('prerender', () =&gt; {</span><span id="1e45" class="mm le iq md b gy mr mo l mp mq">    // Cull out all objects that don't intersect with the screen<br/>    cull.cull(app.renderer.screen);<br/>});</span></pre><p id="7e3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码片段将评估每个显示对象是否应该被“剔除”,并相应地设置它们的<code class="fe ma mb mc md b">renderable</code>属性。</p><h2 id="9fed" class="mm le iq bd lf ms mt dn lj mu mv dp ln ko mw mx lp ks my mz lr kw na nb lt nc bi translated">副作用</h2><p id="6832" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">每当渲染器重绘场景时，就会触发<code class="fe ma mb mc md b">prerender</code>事件。如果您的应用程序需要在渲染之外使用显示对象的边界，这可能是一个问题。</p><p id="660b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为容器的边界是其子级边界和自身边界的并集。如果其中一个孩子被剔除，那么它将不包括那个孩子的边界；因此，计算将是不正确的。</p><p id="792d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要纠正这一点，可以在渲染后取消场景图形的模糊:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="a30a" class="mm le iq md b gy mn mo l mp mq">app.renderer.on('postrender', () =&gt; {<br/>  cull.uncull();<br/>});</span></pre><p id="0269" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将简单地使你的所有对象在一个过程中可见/可渲染。</p><blockquote class="nd ne nf"><p id="7237" class="kf kg lb kh b ki kj jr kk kl km ju kn ng kp kq kr nh kt ku kv ni kx ky kz la ij bi translated">注意:如果您需要保持某些对象不可见，即使它们的边界与屏幕相交，您也可以将剔除“切换”设置为不同于保持对象永久不可见的属性。例如，如果您在显示对象上设置了<code class="fe ma mb mc md b">visible=false</code>，您可以将剔除切换设置为<code class="fe ma mb mc md b">renderable</code>。这将确保对象的可见性保持为假，并且只评估可渲染性。</p></blockquote><h2 id="4cd9" class="mm le iq bd lf ms mt dn lj mu mv dp ln ko mw mx lp ks my mz lr kw na nb lt nc bi translated">“可呈现”与“可见”</h2><p id="2944" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">剔除“切换”是在显示对象上设置的属性，指示它是“剔除”还是“未剔除”。</p><p id="2ba0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以为剔除设置两个“切换”:</p><ul class=""><li id="b875" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la no np nq nr bi translated"><code class="fe ma mb mc md b">renderable</code>:如果显示对象不可渲染，则不会被绘制。然而，它的变换将在<code class="fe ma mb mc md b">updateTransform</code>中重新计算。</li><li id="3088" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la no np nq nr bi translated"><code class="fe ma mb mc md b">visible</code>:如果一个显示对象不是“可见的”，那么它也不会被绘制；然而，它的转换不会在<code class="fe ma mb mc md b">updateTransform</code>调用中更新。如果你知道<em class="lb">何时变换已经改变</em>并且需要重新计算，这可能是一个有价值的优化。</li></ul><h2 id="44aa" class="mm le iq bd lf ms mt dn lj mu mv dp ln ko mw mx lp ks my mz lr kw na nb lt nc bi translated">与投影的兼容性</h2><p id="63f5" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">如果你在你的场景图中使用投影(这是一件非常特殊的事情)，剔除期望场景的投影和未投影部分是“断开的”。换句话说，您不能直接投影容器的子容器:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="10e7" class="mm le iq md b gy mn mo l mp mq">class Camera {<br/>    constructor() {<br/>        this.projectedContent = this.addChild(new Container());<br/>    }</span><span id="62a6" class="mm le iq md b gy mr mo l mp mq">    render(renderer) {<br/>        // Set projection<br/>        this.projectedContent.render(renderer);<br/>        // Unset projection<br/>    }<br/>}</span></pre><p id="ebc2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码片段不能用于剔除。为什么？</p><p id="47f1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它期望容器的子级的屏幕边界位于容器的内部。如果使用不同的投影变换投影子对象，则它们的屏幕边界不需要位于容器的屏幕边界内(即使它们的世界边界也是如此)。</p><p id="4372" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要纠正这一点，您需要确保投影的内容不会作为容器的子容器添加:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="f5f4" class="mm le iq md b gy mn mo l mp mq">class Camera {<br/>    constructor() {<br/>        this.projectedContent = new Container();<br/>    }<br/>}</span></pre><p id="64d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于“摄像机”和“投影内容”现在在场景图中是断开的，所以您可以在剔除器中单独添加它们:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="cdb8" class="mm le iq md b gy mn mo l mp mq">cull.add(app.stage);<br/>cull.add(camera.projectedContents);</span></pre><h1 id="f1cd" class="ld le iq bd lf lg lh li lj lk ll lm ln jw lo jx lp jz lq ka lr kc ls kd lt lu bi translated">在后台</h1><p id="e4d1" class="pw-post-body-paragraph kf kg iq kh b ki lv jr kk kl lw ju kn ko lx kq kr ks ly ku kv kw lz ky kz la ij bi translated">递归剔除算法如下:</p><ol class=""><li id="b844" class="nj nk iq kh b ki kj kl km ko nl ks nm kw nn la nx np nq nr bi translated">取消缩放整个场景图形，以便正确计算显示对象的边界。</li><li id="1571" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la nx np nq nr bi translated">对于当前显示对象，评估边界是否与“屏幕”相交，其中屏幕的边界是一个参数。</li><li id="5780" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la nx np nq nr bi translated">如果有，保持物体不可见。如果对象完全位于屏幕内，不要在子对象上运行剔除。这是因为孩子也将完全躺在屏幕内(在他们的父母内)。如果对象只是部分可见，那么需要为孩子评估剔除(因为他们可能位于屏幕内部或外部)，然后我们再次转到步骤2。</li><li id="1fa9" class="nj nk iq kh b ki ns kl nt ko nu ks nv kw nw la nx np nq nr bi translated">如果没有，即对象位于屏幕之外，则剔除对象(使其不可见)。孩子们不需要被评估，因为画他们也会和他们的父母一起被跳过。</li></ol><p id="d367" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该算法的速度来自于这样一个事实，即递归只在显示对象“部分”可见时发生，并且与屏幕的边界线相交。</p><p id="5617" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的示例演示了评估哪些对象的可见性。标记为红色的将被评估，而蓝色的将被跳过。</p><figure class="me mf mg mh gt nz gh gi paragraph-image"><div role="button" tabindex="0" class="oa ob di oc bf od"><div class="gh gi ny"><img src="../Images/9edda3f7df518b4b81c52e556d6121a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8aZpll5YND6Lm8cjXmQ99Q.png"/></div></div></figure><p id="eace" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这里，只有50%的对象被剔除。因为很少有物体正好位于屏幕的边界，所以剔除通常非常快。</p></div><div class="ab cl og oh hu oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ij ik il im in"><p id="4e7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">我是舒坎特·帕尔(Shukant Pal)——</em><a class="ae lc" href="https://github.com/pixijs/pixi.js" rel="noopener ugc nofollow" target="_blank"><em class="lb">PixiJS</em></a><em class="lb">的维护者，这是最快的网络2D渲染器。我喜欢优化和加速WebGL应用程序。在推特上关注我阅读更多我的内容:</em><a class="ae lc" href="https://twitter.com/ShukantP" rel="noopener ugc nofollow" target="_blank"><em class="lb">https://twitter.com/ShukantP</em></a></p></div></div>    
</body>
</html>