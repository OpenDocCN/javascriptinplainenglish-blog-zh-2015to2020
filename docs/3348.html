<html>
<head>
<title>5 Ways to Write Cleaner Code Quicker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更快写出更简洁代码的5种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-ways-to-write-cleaner-code-quicker-2c7d6b3617b9?source=collection_archive---------10-----------------------#2020-09-21">https://javascript.plainenglish.io/5-ways-to-write-cleaner-code-quicker-2c7d6b3617b9?source=collection_archive---------10-----------------------#2020-09-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a52ae91a545cbd0a8dd3bc29025cea79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L5TmR-zgboo0wLjRIpVDbA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sarahdorweiler?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Sarah Dorweiler</a> on <a class="ae kc" href="https://unsplash.com/s/photos/clean?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bf3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了满足开发期限而偷工减料是很常见的。但它总会回来咬你。在某些时候，有人会发现你做了什么，并不得不通过谈判来解决这个问题。他们可能会花两个小时试图破译逻辑，或者，更常见的是，他们可能只是建立在上面，让别人来处理它。</p><p id="482f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">项目就是这样消亡的。不是通过有意的破坏或一贯的滥用，而是一些捷径的演变。</p><p id="89d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要指望最后期限会改变，不管它们有多不合理。利益相关者不关心你。找到快速编写干净代码的方法。</p><p id="9773" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以下规则将对此有所帮助。</p><h2 id="3d50" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><strong class="ak">使用TDD </strong></h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lu"><img src="../Images/e68dd8500d76d11220d9d722173bf764.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DmUf9smSja1BOTHOTtIFew.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@craftedbygc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Green Chameleon</a> on <a class="ae kc" href="https://unsplash.com/s/photos/test?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0b9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TDD代表<em class="lz">测试驱动开发。</em>这是一种在逻辑之前编写测试的方法。</p><p id="3e15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">考虑下面的函数伪代码。</p><pre class="lv lw lx ly gt ma mb mc md aw me bi"><span id="c3a7" class="lb lc iq mb b gy mf mg l mh mi">if inputNumber = 0<br/>  return inputNumber<br/>else if inputNumber = 1<br/>  return inputNumber * 2<br/>else<br/>  return inputNumber * 10</span></pre><p id="9a2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用TDD实现这一点，您首先要编写一个带有简单断言的简单测试。例如，我们可以看到，如果我们传递0，这个函数应该返回0，所以我们将编写如下测试(注意:我使用的是JavaScript，但它适用于任何语言)。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/35a992a7504d713a2c7bcffe3e6300b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*HwKvj-e9oUGVoL8HbLUhcg.png"/></div></figure><p id="e6d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您可以编写逻辑来通过测试。最简单的方法是让函数返回0。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/859757f119b93cac406334fa13f88d59.png" data-original-src="https://miro.medium.com/v2/resize:fit:536/format:webp/1*qh8DpnzU7AafFKMCEuXt4g.png"/></div></figure><p id="1c6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然测试通过了，我们可以进行下一个断言，也就是说，如果输入为1，函数应该返回2，并为此编写一个测试。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/62a2bb9b5d5440a82687f4ce4e2bbfed.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*ThiXTHNQf1hIihjZmVRtPw.png"/></div></figure><p id="8f69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为我们构建的逻辑只能通过第一个测试。因此，现在我们编写使两个测试一起通过所需的<strong class="kf ir">最小代码</strong>。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/54275bc4e2e2965e32f7765505ec21bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:528/format:webp/1*Sz-jKre-wYDfBz0Y9YVZHg.png"/></div></figure><p id="1b69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对最后一个断言重复前面的过程，其中函数应该返回任何其他乘以10的输入。为这样的东西编写两个或更多的断言来增加全面性是一个好主意。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/4b80834d09f549f355e0836c57452071.png" data-original-src="https://miro.medium.com/v2/resize:fit:940/format:webp/1*gr1rh0GLpdBn_tnAOdg6Dg.png"/></div></figure><p id="1d05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让它在不破坏其他测试的情况下再次通过。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/15947554e4d1f92839d55593f698aaa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:542/format:webp/1*aBkf8djAWM0SC8a2S0ciGA.png"/></div></figure><p id="6948" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成了。</p><p id="4bf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会注意到我们改变了函数处理0值的方式。这是TDD的重要组成部分。每次你写代码通过另一个测试，你重构它。</p><p id="c6d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TDD几乎总是可以应用，实际上更适合比这更复杂的情况。</p><p id="1186" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TDD:</p><ul class=""><li id="454f" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">确保你所有的逻辑都被覆盖，因为你只写通过测试所需要的东西</li><li id="ef91" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">实际上是为你写逻辑，因为你把它分解成简单的、可管理的步骤，而不是试图一下子想出来</li><li id="8d5e" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">充当代码的清晰文档</li></ul><p id="4c0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是快速编写干净代码的最好方法之一。</p><h2 id="9c31" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><em class="nc">避免嵌套逻辑</em></h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nd"><img src="../Images/084923a06907798fe7caeb08eee48c40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whdOswlacQ_B_cpFkYssEw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@edvardr?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Edvard Alexander Rølvaag</a> on <a class="ae kc" href="https://unsplash.com/s/photos/hierarchy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7c07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一些计算裁员工资的函数的伪代码。</p><pre class="lv lw lx ly gt ma mb mc md aw me bi"><span id="5001" class="lb lc iq mb b gy mf mg l mh mi">if employee's age &lt; 20<br/>  redundancyPay = 0<br/>else<br/>  if employeeRole = management<br/>    redundancyPay = employeeTerm * (annualSalary * 0.05)<br/>  else<br/>    if employeeTerm &lt;5<br/>      redundancyPay = employeeTerm * (annualSalary * 0.02)<br/>    else if employeeTerm &gt; 10<br/>      redundancyPay = employeeTerm * (annualSalary * 0.04)<br/>    else<br/>      redundancyPay = employeeTerm * (annualSalary * 0.03)</span></pre><p id="6ca8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以这样写。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/b7727db740ed350277e6fc8a33e917d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*un2jtQ-6aAywVyMqHgrltg.png"/></div></div></figure><p id="1614" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可能见过这样的代码，公平地说，它读起来接近英语。也是一个比较简单的例子。但是想象一下更现实的代码，其中您可能必须混合API调用或更复杂的逻辑。你可以想象这很快会失去控制。</p><p id="7699" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最好的解决方案是完全避免这样的代码，也就是说，在一个函数中提交一级嵌套。你把它分解成一个新的函数。考虑下面的重构代码。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/933de9d8b590c24a4661ee9ac73da9e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YbFlki6RQ30JSvf2GrUhRg.png"/></div></div></figure><p id="4287" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码更简洁，也更容易理解。如果您从一开始就知道不希望有一层以上的嵌套，构思这段代码也不会比第一个示例花费更多的时间。您可以将所有这些函数封装在一个公开单个入口点的文件中。您还可以单独测试所有这些函数，这将使您的测试更简单，因为它们只处理逻辑的一个部分，而不是整个逻辑。</p><p id="a16e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能会注意到，我将第一个示例中的四个参数压缩到了一个employee对象中。这就引出了下一条规则。</p><h2 id="7250" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><em class="nc">偏好一个参数一个责任的功能</em></h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/f38e45a759506e170da4784c11c113de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ovUpgF2SewlCVB5xBJJRiA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@fabrizioverrecchia?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Fabrizio Verrecchia</a> on <a class="ae kc" href="https://unsplash.com/s/photos/lonely?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="19b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有多个参数的函数令人生畏。论点和复杂性之间通常也是正相关的。</p><p id="10b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时你无法避免拥有多个参数。但是在大多数情况下，您可以执行以下一项或两项操作:</p><ul class=""><li id="aa8e" class="mo mp iq kf b kg kh kk kl ko mq ks mr kw ms la mt mu mv mw bi translated">创建一个数据类型来封装相关参数</li><li id="1dae" class="mo mp iq kf b kg mx kk my ko mz ks na kw nb la mt mu mv mw bi translated">重新思考你的职能有多少职责</li></ul><p id="6318" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于第一点，强类型语言非常好。一般来说，定义良好的自定义数据类型是使程序更容易理解和维护的可靠方法。但是，即使使用Python和JavaScript这样的语言，当数据相关时，您仍然应该更喜欢对象而不是单独的属性，因为这至少给数据作为一个整体贴上了标签，并帮助读者理解所有东西是如何组合在一起的。</p><p id="f807" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果您的函数也做了过多的工作，那么将参数封装成一种数据类型并不是正确的方法。考虑下面的例子，我们从一些表单输入中构建一个雇员记录。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/98796d057b8239d07d3684e185e4c8ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M6TWY53abQ3-Ms-VrFTRvQ.png"/></div></div></figure><p id="8464" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ni nj nk mb b">calculateEmployeeFinancials</code>函数执行多项任务。你可能会说，从技术上来说，这是“计算财务”的单一职责，但它仍然可以进一步细分。一般来说，尽可能地分解你的功能是最佳的，如果你从一开始就有想法的话，这不会比选择更费力。它使你的代码更容易理解和测试。这里有一个重构的解决方案。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/f08cff1f1bc6beef0096cd04f8b53b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kZcTz_ItGcxagg6gPi_MnA.png"/></div></div></figure><p id="9f4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当有更复杂的事情发生时，这种技术会大放异彩，但即使在这里它也是有意义的。这些功能现在只有一个职责，很容易快速确定到底发生了什么。</p><p id="9412" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ni nj nk mb b">buildEmployee</code>函数也许也可以被分解，但是有时候你需要做一些更复杂的逻辑。想法是尽可能地分解它，然后像拼图一样把碎片拼在一起，构建更复杂的流程。</p><h2 id="0296" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated"><em class="nc">警惕花哨的工具</em></h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/3e5fce090f2bc62413b315ef49c029ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RoTr6mi7oVkJ3tXf3o0Hgg.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@thenewmalcolm?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Obi Onyeador</a> on <a class="ae kc" href="https://unsplash.com/s/photos/fancy-tool?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="58a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个可能会有争议。大多数语言都有简洁的书写方式，但这种简洁往往是以清晰为代价的。考虑一下这个<code class="fe ni nj nk mb b">if</code>语句。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/9bef3d6a16f9f78ac5dfa4b4039e05c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*_40StY8oUvTEtJFlQHgVRQ.png"/></div></figure><p id="5348" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码有6行，看起来有点笨拙。但它<strong class="kf ir">是</strong>清晰。现在，把它写成一个JavaScript <em class="lz">三元表达式</em>。</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/d86368c7945e6baba7e5b7d07c960656.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4QK9Fh5c3RsKCBrhBiVShw.png"/></div></div></figure><p id="4fbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只占了一行，看起来很花哨。但是真的不清楚。像这样的表达带来了一种认知负荷，这种负荷是常规的<code class="fe ni nj nk mb b">if</code>语句所没有的。</p><p id="8241" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">学期并不坏。它们在非常简单的情况下也很有用，比如:</p><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/1520c12a6f4743b784a6fff420aa6c9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6M7qLFT6CH7270LBiQSvIg.png"/></div></div></figure><p id="e64a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但如果比这更复杂，你就是在玩火。</p><h2 id="0dc7" class="lb lc iq bd ld le lf dn lg lh li dp lj ko lk ll lm ks ln lo lp kw lq lr ls lt bi translated">赞成程序设计</h2><figure class="lv lw lx ly gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nq"><img src="../Images/acf66dfdd095043036ec0c05d1ab67f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jpG4yy0wsi4ZZlOFyMcbyQ.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@designus?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Maxime Guy</a> on <a class="ae kc" href="https://unsplash.com/s/photos/spider-web?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4385" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自定义数据类型很棒，但是当你给它们附加行为时，它们就变成了对象。这就是事情变得复杂的时候。</p><p id="d518" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象是类的实例。类是属性和方法的集合。类可以拥有其他类的对象，这使得它们可以调用程序中其他对象的行为。这听起来已经很复杂了，但情况会变得更糟。</p><p id="145e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你有一堆对象在你的程序中飞来飞去时，数据流开始看起来像蜘蛛网一样。一个对象可能向外调用另一个对象，然后该对象调用另一个对象，后者回调原始对象，后者调用另一个对象，后者修改另一个对象上的一些数据，结果创建一个对象，然后该对象启动并进行HTTP调用。诸如此类。</p><p id="cac8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你遇到这种情况时，就很难跟上程序的流程。调试包括试图想象迷宫中蜿蜒的虚拟路径。然后就是<strong class="kf ir">继承。Eugh。</strong></p><p id="8424" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">过程编程没有这些问题。过程代码只是按清晰的顺序一步一步地运行。这并不意味着你不能调用其他函数，但是没有其他“实体”的概念，比如一个控制执行的对象或者其他什么。只是一步一步，一路走过来。它更容易理解，更容易阅读，也更容易调试。</p><p id="e384" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里有一个关于这个的很棒的<a class="ae kc" href="https://www.youtube.com/watch?v=QM1iUe6IofM" rel="noopener ugc nofollow" target="_blank">视频</a>。如果你是面向对象的爱好者，就不要看了。实际上也不会。</p></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><p id="6567" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">几乎每个项目都会受到交付期限的困扰。作为职业程序员的一部分就是理解这一点并注重实效。但是为了速度而牺牲质量的想法是有害的。每一个快捷方式都是你的应用程序基础上的另一个漏洞，有一天可能会把它推翻。在你编码的时候记住这些规则，你可以避免这种情况。</p></div></div>    
</body>
</html>