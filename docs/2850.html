<html>
<head>
<title>One of the first things to understand in JavaScript — Immutability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中需要理解的第一件事——不变性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/one-of-the-first-things-to-understand-in-javascript-immutability-629fabdf4fee?source=collection_archive---------5-----------------------#2020-07-29">https://javascript.plainenglish.io/one-of-the-first-things-to-understand-in-javascript-immutability-629fabdf4fee?source=collection_archive---------5-----------------------#2020-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9257" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript中的突变以及了解这一点的重要性</h2></div><h2 id="97ab" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">让我们回到基础:“在JavaScript中，<em class="lb">变量</em>或者常量是不可变的吗？”</strong></h2><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/85b8468c543cd017b2de4f57048e5920.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4PrMNL-FF9Z5G5BXJliAYg.png"/></div></div></figure><p id="24d7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">答案是<strong class="lq ir">都不是</strong>，如果你对你的答案有一点犹豫，请继续读下去。每种编程语言都有不同的风格和特点，在JavaScript中，这是需要注意的最重要的事情之一，尤其是在我们学习Python、Java等语言的时候。</p><p id="c725" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">您可能不需要立即改变用JavaScript编写代码的方式，但是尽早了解这一点，可以防止您陷入以后难以调试的糟糕境地。我将包括一些你可以采用的方法来防止陷入这样的问题——做浅层和深层拷贝的不同方法。</p><p id="2ca5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">在我们开始之前，先简单总结一下:<br/> <strong class="lq ir">变量</strong>(用<code class="fe mh mi mj mk b">let</code>初始化)—可重新赋值的&amp;可变的<br/> <strong class="lq ir">常量</strong>(用<code class="fe mh mi mj mk b">const</code>初始化)—不可重新赋值的&amp;可变的</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="1130" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">在我们解释JavaScript的可变性之前，让我们快速浏览一些基础知识…你可以跳过这一部分。</p><p id="ea7a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">JavaScript中大致有几组数据类型:</p><ol class=""><li id="dc99" class="ms mt iq lq b lr ls lu lv ko mu ks mv kw mw mg mx my mz na bi translated"><strong class="lq ir">原始(主要)</strong> —布尔、数字、字符串</li><li id="d895" class="ms mt iq lq b lr nb lu nc ko nd ks ne kw nf mg mx my mz na bi translated"><strong class="lq ir">非原语(引用)或对象</strong> —对象、数组、函数</li><li id="dee9" class="ms mt iq lq b lr nb lu nc ko nd ks ne kw nf mg mx my mz na bi translated"><strong class="lq ir">特殊</strong> —空，未定义</li></ol><p id="bb0c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated"><em class="ng">快速提示，你可以用</em> <code class="fe mh mi mj mk b"><em class="ng">console.log(typeof unknownVar)</em></code> <em class="ng">算出你正在处理的变量的数据类型</em></p><h2 id="9848" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">默认情况下，原始数据类型是不可变的</h2><p id="60cc" class="pw-post-body-paragraph lo lp iq lq b lr nh jr lt lu ni ju lw ko nj ly lz ks nk mb mc kw nl me mf mg ij bi translated">对于原始数据类型(如boolean、number和strings)，如果它们被声明为常量，它们就是<strong class="lq ir">不可变的</strong>，因为对于这些数据类型，您不能添加任何附加属性或改变某些属性。</p><p id="5cba" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">要‘改变/改变’原语，仅仅意味着你必须重新分配它们，只有当它们被声明为变量时才有可能。</p><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="b1ef" class="kf kg iq mk b gy nq nr l ns nt"><strong class="mk ir">let</strong> var1 = 'apple' //'apple' is stored in memory location A<br/>var1 = 'orange' //'orange' is stored in memory location B</span><span id="eaa3" class="kf kg iq mk b gy nu nr l ns nt"><strong class="mk ir">const</strong> var2 = 'apple'<br/>var2 = 'orange' // ERROR: Re-assignment not allowed for constants</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nv"><img src="../Images/b9990fd05eb89d010207b21bbb3db2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xyaMxzBMpouTQbMr-O0pXg.png"/></div></div></figure><p id="c807" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">在上面的例子中，如果我们编辑var1的字符串，JavaScript将简单地在另一个内存位置创建另一个字符串，var1将指向这个新的内存位置，这被称为<strong class="lq ir">重新分配</strong>。这适用于所有的<em class="ng">原始数据类型</em>，不管它们是被声明为变量还是常量。</p><p id="5b42" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">并且所有常数都不能被重新赋值。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="e0f8" class="nw kg iq bd kh nx ny nz kk oa ob oc kn jw od jx kr jz oe ka kv kc of kd kz og bi translated">在JavaScript中，对象是通过引用传递的</h1><p id="9d2b" class="pw-post-body-paragraph lo lp iq lq b lr nh jr lt lu ni ju lw ko nj ly lz ks nk mb mc kw nl me mf mg ij bi translated">当我们处理<strong class="lq ir">对象</strong>时，问题开始出现…</p><h2 id="3172" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">对象不是不可变的</h2><p id="d93a" class="pw-post-body-paragraph lo lp iq lq b lr nh jr lt lu ni ju lw ko nj ly lz ks nk mb mc kw nl me mf mg ij bi translated">对象一般指非原语数据类型(对象、数组、函数)，即使用<code class="fe mh mi mj mk b">const</code>声明为常量也是可变的</p><p id="3a6f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated"><em class="ng">(在本文的其余部分，我将给出Object数据类型的例子，因为这里出现的问题最多。数组和函数的概念是一样的)</em></p><p id="cbbc" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">那么这意味着什么呢？</p><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="de11" class="kf kg iq mk b gy nq nr l ns nt">const profile1 = {'username':'peter'}<br/><strong class="mk ir">profile1.username = 'tom'</strong><br/>console.log(profile1) //{'username':'tom'}</span></pre><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oh"><img src="../Images/07234ad38ad9eed0c60141a0cbc57353.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FluTwbCYFCQO6pW5enoLoQ.png"/></div></div></figure><p id="911e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">在这种情况下，profile1指向位于同一内存位置的对象，我们所做的是在同一内存位置改变该对象的属性。</p><p id="b616" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">这看起来很简单，为什么会有问题呢？</p><h2 id="d41c" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">当对象的变异成为一个问题时…</h2><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="89b9" class="kf kg iq mk b gy nq nr l ns nt">const sampleprofile = {<strong class="mk ir">'username':'name'</strong>, 'pw': '123'}<br/>const profile1 = sampleprofile</span><span id="1930" class="kf kg iq mk b gy nu nr l ns nt"><strong class="mk ir">profile1.username = 'harry'</strong></span><span id="a8e7" class="kf kg iq mk b gy nu nr l ns nt">console.log(profile1) // {<strong class="mk ir">'username':'harry'</strong>, 'pw': '123'}<br/>console.log(sampleprofile) // {<strong class="mk ir">'username':'harry'</strong>, 'pw': '123'}</span></pre><p id="ea1a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated"><em class="ng">看起来像是一段简单的代码，你可能无意中编写了这段代码，对吗？你猜怎么着，这里已经有一个问题了！</em></p><p id="4b0c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">这是因为在JavaScript中对象是通过引用传递的<strong class="lq ir">。</strong></p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oi"><img src="../Images/1198577528ad5bf2bd31910c07dd5ce3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K7JS9v4pbm1b0W4yaf-fZQ.png"/></div></div></figure><p id="99a8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">在这种情况下，通过引用传递的'<em class="ng">'的意思是，我们将常量sampleprofile的引用传递给profile1。换句话说，profile1和sampleprofile的常量都指向位于 <strong class="lq ir">相同内存位置</strong>的同一个对象<strong class="lq ir">。</strong></em></p><p id="0e8f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">因此，当我们更改常量profile1的对象的属性时，它也会影响sampleprofile，因为它们都指向同一个对象。</p><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="4ce0" class="kf kg iq mk b gy nq nr l ns nt">console.log(sampleprofile===profile1)//true</span></pre><p id="8df0" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated"><em class="ng">这只是一个简单的例子，说明了通过引用传递(以及由此产生的变异)可能会有问题。但是我们可以想象，当我们的代码变得更加复杂和庞大时，这将变得非常棘手，如果我们没有意识到这一点，我们将很难解决某些错误。</em></p><p id="a832" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">那么，我们如何预防或试图避免潜在的此类问题呢？</p><p id="28bb" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">为了有效地面对与对象突变相关的潜在问题，我们应该了解两个概念:</p><ul class=""><li id="4227" class="ms mt iq lq b lr ls lu lv ko mu ks mv kw mw mg oj my mz na bi translated"><strong class="lq ir">通过冻结物体防止变异</strong></li><li id="bbfe" class="ms mt iq lq b lr nb lu nc ko nd ks ne kw nf mg oj my mz na bi translated"><strong class="lq ir">使用浅层&amp;深层复制</strong></li></ul><p id="d1cd" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">我将展示一些用JavaScript实现的例子，使用普通的JavaScript方法，以及一些我们可以使用的有用的库。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="b019" class="nw kg iq bd kh nx ny nz kk oa ob oc kn jw od jx kr jz oe ka kv kc of kd kz og bi translated">防止对象中的突变</h1><h2 id="9d95" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">1.使用Object.freeze()方法</h2><p id="bae6" class="pw-post-body-paragraph lo lp iq lq b lr nh jr lt lu ni ju lw ko nj ly lz ks nk mb mc kw nl me mf mg ij bi translated">如果你想阻止一个对象改变属性，你可以使用<code class="fe mh mi mj mk b">Object.freeze()</code>。这样做的目的是不允许对象的现有属性改变。任何这样做的尝试都会导致它“无声地失败”，这意味着它不会成功，但也不会有任何警告。</p><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="d6ef" class="kf kg iq mk b gy nq nr l ns nt">const sampleprofile = {'username':'name', 'pw': '123'}</span><span id="0647" class="kf kg iq mk b gy nu nr l ns nt"><strong class="mk ir">Object.freeze</strong>(sampleprofile)</span><span id="e411" class="kf kg iq mk b gy nu nr l ns nt">sampleprofile.username = 'another name' <strong class="mk ir">// no effect</strong></span><span id="a0c0" class="kf kg iq mk b gy nu nr l ns nt">console.log(sampleprofile) // {'username':'name', 'pw': '123'}</span></pre><p id="9bc8" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">然而，这是一种<strong class="lq ir">浅冻结</strong>的形式，它不能用于深度嵌套的对象:</p><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="20ba" class="kf kg iq mk b gy nq nr l ns nt">const sampleprofile = {<br/>  'username':'name', <br/>  'pw': '123', <br/>  'particulars':{'firstname':'name', 'lastname':'name'}<br/>}</span><span id="f875" class="kf kg iq mk b gy nu nr l ns nt"><strong class="mk ir">Object.freeze</strong>(sampleprofile)</span><span id="6790" class="kf kg iq mk b gy nu nr l ns nt">sampleprofile.username = 'another name' <strong class="mk ir">// no effect</strong><br/>console.log(sampleprofile)</span><span id="60f7" class="kf kg iq mk b gy nu nr l ns nt">/*<br/>{<br/>  'username':'name', <br/>  'pw': '123', <br/>  'particulars':{'firstname':'name', 'lastname':'name'}<br/>}<br/>*/</span><span id="09e5" class="kf kg iq mk b gy nu nr l ns nt">sampleprofile.particulars.firstname = 'changedName' <strong class="mk ir">// changes</strong><br/>console.log(sampleprofile)</span><span id="4e97" class="kf kg iq mk b gy nu nr l ns nt">/*<br/>{<br/>  'username':'name', <br/>  'pw': '123', <br/>  'particulars':{'firstname':'changedName', 'lastname':'name'}<br/>}<br/>*/</span></pre><p id="6251" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">在上面的例子中，嵌套对象的属性仍然能够改变。</p><p id="b1a3" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">您可以创建一个简单的函数来递归冻结嵌套的对象(您可以自己尝试一下，并在本文中评论您的答案？😊)，但是如果你很懒，这里有一些你可以使用的库:</p><h2 id="6fc6" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">2.使用深度冷冻</h2><p id="2d3b" class="pw-post-body-paragraph lo lp iq lq b lr nh jr lt lu ni ju lw ko nj ly lz ks nk mb mc kw nl me mf mg ij bi translated">但说真的，如果你看看<a class="ae ok" href="https://www.npmjs.com/package/deep-freeze" rel="noopener ugc nofollow" target="_blank">深冻</a>的<a class="ae ok" href="https://github.com/substack/deep-freeze/blob/master/index.js" rel="noopener ugc nofollow" target="_blank">源代码</a>，它本质上只是一个简单的递归函数，但无论如何这是你可以轻松使用它的方式..</p><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="c75f" class="kf kg iq mk b gy nq nr l ns nt">var deepFreeze = require('deep-freeze');</span><span id="6e8a" class="kf kg iq mk b gy nu nr l ns nt">const sampleprofile = {<br/>  'username':'name', <br/>  'pw': '123', <br/>  'particulars':{'firstname':'name', 'lastname':'name'}<br/>}</span><span id="8bd7" class="kf kg iq mk b gy nu nr l ns nt">deepFreeze(sampleprofile)</span></pre><p id="621d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">深度冻结的另一个替代方法是<a class="ae ok" href="https://immutable-js.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank"> ImmutableJS </a>，你们中的一些人可能更喜欢它，因为它有助于在你试图改变你用库创建的对象时抛出一个错误。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="490c" class="nw kg iq bd kh nx ny nz kk oa ob oc kn jw od jx kr jz oe ka kv kc of kd kz og bi translated">避免与通过引用传递相关的问题</h1><p id="7051" class="pw-post-body-paragraph lo lp iq lq b lr nh jr lt lu ni ju lw ko nj ly lz ks nk mb mc kw nl me mf mg ij bi translated">关键在于理解JavaScript中的<strong class="lq ir">浅层和深层复制/克隆/合并</strong>。</p><p id="b884" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">根据程序中对象的具体实现，您可能希望使用浅层或深层复制。还可能有关于内存和性能的其他考虑，这将影响您对浅拷贝或深拷贝甚至库的选择。但是我们将把这个留到我们到达那里的另一天😉</p><p id="62b6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">我们先从浅抄开始，然后是深抄。</p><h1 id="dca3" class="nw kg iq bd kh nx ol nz kk oa om oc kn jw on jx kr jz oo ka kv kc op kd kz og bi translated">浅层复制</h1><h2 id="3f72" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">1.使用扩展运算符(…)</h2><p id="9fec" class="pw-post-body-paragraph lo lp iq lq b lr nh jr lt lu ni ju lw ko nj ly lz ks nk mb mc kw nl me mf mg ij bi translated">ES6引入的spread操作符为我们提供了一种更简洁的方式来组合数组和对象。</p><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="0f18" class="kf kg iq mk b gy nq nr l ns nt">const firstSet = [1, 2, 3];<br/>const secondSet= [4, 5, 6];<br/>const firstSetCopy = [...firstset]<br/>const resultSet = [...firstSet, <strong class="mk ir">...</strong>secondSet];</span><span id="27ff" class="kf kg iq mk b gy nu nr l ns nt">console.log(firstSetCopy) <!-- -->// [1, 2, 3]<br/>console.log(resultSet) // [1,2,3,4,5,6]</span></pre><p id="7a3e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">ES2018还将跨页属性扩展到了对象文字，因此我们也可以对对象进行同样的操作。所有对象的属性将被合并，但对于冲突的属性，后续对象将优先。</p><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="a04c" class="kf kg iq mk b gy nq nr l ns nt">const profile1 = {'username':'name', 'pw': '123', 'age': 16}<br/>const profile2 = {'username':'tom', 'pw': '1234'}<br/>const profile1Copy = {...profile1}<br/>const resultProfile = {...profile1, ...profile2}</span><span id="5af8" class="kf kg iq mk b gy nu nr l ns nt">console.log(profile1Copy) <!-- -->// <!-- -->{'username':'name', 'pw': '123', 'age': 16}<br/>console.log(<!-- -->resultProfile<!-- -->) // <!-- -->{'username':'tom', 'pw': '1234', 'age': 16}</span></pre><h2 id="2c8e" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">2.使用Object.assign()方法</h2><p id="fbc8" class="pw-post-body-paragraph lo lp iq lq b lr nh jr lt lu ni ju lw ko nj ly lz ks nk mb mc kw nl me mf mg ij bi translated">这类似于使用上面的spread操作符，它可以用于数组和对象。</p><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="e6ec" class="kf kg iq mk b gy nq nr l ns nt">const profile1 = {'username':'name', 'pw': '123', 'age': 16}<br/>const profile2 = {'username':'tom', 'pw': '1234'}<br/>const profile1Copy = <strong class="mk ir">Object.assign</strong>({}, profile1)<br/>const resultProfile = <strong class="mk ir">Object.assign</strong>({},...profile1, ...profile2)</span><span id="d07b" class="kf kg iq mk b gy nu nr l ns nt">console.log(profile1Copy) <!-- -->// <!-- -->{'username':'name', 'pw': '123', 'age': 16}<br/>console.log(<!-- -->resultProfile<!-- -->) // <!-- -->{'username':'tom', 'pw': '1234', 'age': 16}</span></pre><p id="f0d9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">注意，我使用了一个空对象<code class="fe mh mi mj mk b">{}</code>作为第一个输入，因为这个方法从浅层合并的结果中更新了第一个输入。</p><h2 id="f8e5" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">3.使用。切片()</h2><p id="cd81" class="pw-post-body-paragraph lo lp iq lq b lr nh jr lt lu ni ju lw ko nj ly lz ks nk mb mc kw nl me mf mg ij bi translated">这只是针对<em class="ng">浅克隆数组</em>的一种便捷方法！</p><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="f1b2" class="kf kg iq mk b gy nq nr l ns nt">const firstSet = [1, 2, 3];<br/>const firstSetCopy = firstSet<strong class="mk ir">.slice()</strong></span><span id="70ec" class="kf kg iq mk b gy nu nr l ns nt">console.log(firstSetCopy) <!-- -->// [1, 2, 3]</span><span id="43ab" class="kf kg iq mk b gy nu nr l ns nt">//note that they are not the same objects<br/>console.log(firstSet===firstSetCopy) // false</span></pre><h2 id="0d2c" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">4.使用lodash.clone()</h2><p id="dfc3" class="pw-post-body-paragraph lo lp iq lq b lr nh jr lt lu ni ju lw ko nj ly lz ks nk mb mc kw nl me mf mg ij bi translated">另请注意，lodash中也有一种方法可以进行浅层克隆。我认为使用这个有点过分(除非你已经包含了lodash ),但是我在这里只给出一个例子。</p><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="88d1" class="kf kg iq mk b gy nq nr l ns nt">const clone = require('lodash/clone')</span><span id="48fb" class="kf kg iq mk b gy nu nr l ns nt">const profile1 = {'username':'name', 'pw': '123', 'age': 16}<br/>const profile1Copy = <strong class="mk ir">clone</strong>(profile1)<br/>...</span></pre><h2 id="81c9" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">浅层克隆的问题:</h2><p id="0f3e" class="pw-post-body-paragraph lo lp iq lq b lr nh jr lt lu ni ju lw ko nj ly lz ks nk mb mc kw nl me mf mg ij bi translated">对于所有这些浅层克隆的例子，如果我们有<strong class="lq ir">更深层次的对象嵌套</strong>，问题就开始出现了，如下例所示。</p><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="d210" class="kf kg iq mk b gy nq nr l ns nt">const sampleprofile = {<br/>  'username':'name', <br/>  'pw': '123', <br/>  'particulars':{'firstname':'name', 'lastname':'name'}<br/>}</span><span id="76df" class="kf kg iq mk b gy nu nr l ns nt">const profile1 = {...sampleprofile}<br/><strong class="mk ir">profile1.username='tom'<br/>profile1.particulars.firstname='Wong'</strong></span><span id="012e" class="kf kg iq mk b gy nu nr l ns nt">console.log(sampleprofile)<br/>/*<br/>{<br/>  <strong class="mk ir">'username':'name'</strong>, <br/>  'pw': '123', <br/>  'particulars':{<strong class="mk ir">'firstname':'Wong'</strong>, 'lastname':'name'}<br/>}<br/>*/</span><span id="1f70" class="kf kg iq mk b gy nu nr l ns nt">console.log(profile1)<br/>/*<br/>{<br/>  <strong class="mk ir">'username':'tom'</strong>, <br/>  'pw': '123', <br/>  'particulars':{<strong class="mk ir">'firstname':'Wong'</strong>, 'lastname':'name'}<br/>}<br/>*/</span><span id="8593" class="kf kg iq mk b gy nu nr l ns nt">console.log(sampleprofile.particulars===profile1.particulars) //true</span></pre><p id="7373" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">注意改变<code class="fe mh mi mj mk b">profile1</code>的嵌套属性(‘名字’)也会影响<code class="fe mh mi mj mk b">sampleprofile</code>。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oq"><img src="../Images/24eff8e1edb85efc83e75e433abcf49f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7QbV9c0-yJ98rgeciFYgCg.png"/></div></div></figure><p id="362d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">对于浅层克隆，嵌套对象的引用被复制。因此，<code class="fe mh mi mj mk b">sampleprofile</code>和<code class="fe mh mi mj mk b">profile1</code>的“细节”对象指的是位于相同存储位置的相同对象。</p><p id="1489" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">为了防止这样的事情发生，并且如果你想要一个没有外部引用的100%真实的拷贝，我们需要使用<strong class="lq ir">深度拷贝</strong>。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="94bb" class="nw kg iq bd kh nx ny nz kk oa ob oc kn jw od jx kr jz oe ka kv kc of kd kz og bi translated">深度复制</h1><h2 id="cb4a" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">1.使用JSON.stringify() &amp; JSON.parse()</h2><p id="36c1" class="pw-post-body-paragraph lo lp iq lq b lr nh jr lt lu ni ju lw ko nj ly lz ks nk mb mc kw nl me mf mg ij bi translated">这在以前是不可能的，但是对于ES6，JSON.stringify()方法也能够对嵌套对象进行深度复制。但是，请注意，该方法仅适用于数字、字符串和布尔数据类型。这里有一个JSFiddle中的例子，试着到处玩一下，看看哪些是复制的，哪些不是。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="or os l"/></div></figure><p id="fd44" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">通常，如果您只使用原始数据类型和一个简单的对象，这是一个简短的单行代码！</p><h2 id="0a9f" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">2.使用lodash.deepclone()</h2><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="dcc1" class="kf kg iq mk b gy nq nr l ns nt">const cloneDeep = require('lodash/clonedeep')<br/>const sampleprofile = {<br/>  'username':'name', <br/>  'pw': '123', <br/>  'particulars':{'firstname':'name', 'lastname':'name'}<br/>}</span><span id="6449" class="kf kg iq mk b gy nu nr l ns nt">const profile1 = cloneDeep(sampleprofile)<br/><strong class="mk ir">profile1.username='tom'<br/>profile1.particulars.firstname='Wong'</strong></span><span id="37e3" class="kf kg iq mk b gy nu nr l ns nt">console.log(sampleprofile)<br/>/*<br/>{<br/>  <strong class="mk ir">'username':'name'</strong>, <br/>  'pw': '123', <br/>  'particulars':{<strong class="mk ir">'firstname':'name'</strong>, 'lastname':'name'}<br/>}<br/>*/</span><span id="d2b0" class="kf kg iq mk b gy nu nr l ns nt">console.log(profile1)<br/>/*<br/>{<br/>  <strong class="mk ir">'username':'tom'</strong>, <br/>  'pw': '123', <br/>  'particulars':{<strong class="mk ir">'firstname':'Wong'</strong>, 'lastname':'name'}<br/>}<br/>*/</span></pre><p id="5270" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated"><em class="ng">仅供参考，lodash包含在使用create-react-app创建的react应用中</em></p><h2 id="b652" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">3.自定义递归函数</h2><p id="ce86" class="pw-post-body-paragraph lo lp iq lq b lr nh jr lt lu ni ju lw ko nj ly lz ks nk mb mc kw nl me mf mg ij bi translated">如果你不想下载一个库只是为了做深度复制，也可以随意创建一个简单的递归函数！</p><p id="da3b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">下面的代码(虽然没有涵盖所有情况)给出了如何自己创建它的大致思路。</p><pre class="ld le lf lg gt nm mk nn no aw np bi"><span id="e539" class="kf kg iq mk b gy nq nr l ns nt">function clone(obj) {<br/>    if (obj === null || typeof (obj) !== 'object' || 'isActiveClone' in obj)<br/>        return obj;<br/><br/>    if (obj instanceof Date)<br/>        var temp = new obj.constructor(); //or new Date(obj);<br/>    else<br/>        var temp = obj.constructor();<br/><br/>    for (var key in obj) {<br/>        if (Object.prototype.hasOwnProperty.call(obj, key)) {<br/>            obj['isActiveClone'] = null;<br/>            temp[key] = clone(obj[key]);<br/>            delete obj['isActiveClone'];<br/>        }<br/>    }<br/>    return temp;<br/>}<br/>// taken from <a class="ae ok" href="https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript</a></span></pre><p id="1c7d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">也许下载一个库来实现深度克隆更简单？还有其他的<strong class="lq ir">微库</strong>，比如<a class="ae ok" href="https://www.npmjs.com/package/rfdc" rel="noopener ugc nofollow" target="_blank"> rfdc </a>、<a class="ae ok" href="https://www.npmjs.com/package/clone" rel="noopener ugc nofollow" target="_blank">克隆</a>、<a class="ae ok" href="https://www.npmjs.com/package/deepmerge" rel="noopener ugc nofollow" target="_blank"> deepmerge </a>来完成这项工作，它们的封装尺寸比lodash更小。你不必为了使用一个功能而下载lodash。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><p id="8c1b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw ko lx ly lz ks ma mb mc kw md me mf mg ij bi translated">希望这能让你对JavaScript面向对象的本质有所了解，以及如何处理与对象突变相关的错误！这也是一个流行的JavaScript面试问题。感谢阅读！:)</p><h2 id="1b64" class="kf kg iq bd kh ki kj dn kk kl km dp kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="79d8" class="pw-post-body-paragraph lo lp iq lq b lr nh jr lt lu ni ju lw ko nj ly lz ks nk mb mc kw nl me mf mg ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae ok" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="lq ir">！</strong></p></div></div>    
</body>
</html>