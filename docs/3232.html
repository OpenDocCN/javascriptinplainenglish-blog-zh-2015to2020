<html>
<head>
<title>Deno for JavaScript Beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向JavaScript初学者的Deno</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/deno-for-javascript-beginners-1a300d152977?source=collection_archive---------10-----------------------#2020-09-11">https://javascript.plainenglish.io/deno-for-javascript-beginners-1a300d152977?source=collection_archive---------10-----------------------#2020-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d6c6249dc3886e858697a848245ac110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lVUbFe73au4VelxBjPg48w.png"/></div></div></figure><p id="3e21" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，你在努力学习JavaScript。您刚刚对浏览器中的JavaScript有点熟悉了。然后突然间，你遇到了<a class="ae kw" href="https://deno.land/" rel="noopener ugc nofollow" target="_blank"> Deno </a>和#NodeKiller炒作。但你不知道这些是什么。如果是这样，请继续阅读！</p><p id="9927" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在深入研究之前，您需要一些背景信息。</p><h1 id="82bd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是JavaScript引擎？</h1><p id="f8eb" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">您可能知道，JavaScript是一种解释型编程语言。这意味着源代码在执行前不会被编译成二进制代码。</p><h2 id="41fe" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><em class="mm">但是计算机怎么知道如何处理一个纯文本脚本呢？</em></h2><p id="9a17" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这是JavaScript引擎的工作。JavaScript引擎动态地将JavaScript代码编译成可执行的机器代码。这就是所谓的实时(JIT)编译。</p><p id="38f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">比如你在谷歌chrome上运行JavaScript，你的JavaScript引擎是V8。如果在Mozilla上，就是蜘蛛猴。</p><h1 id="3e11" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是JavaScript运行时环境？</h1><p id="cbfa" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">你通常不会直接使用JavaScript引擎。JavaScript引擎在一个环境中工作，该环境为您的JavaScript应用程序提供了可以在运行时使用的附加特性。</p><h2 id="1a13" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><em class="mm">什么特征？</em></h2><p id="5f5b" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这些可以是允许与引擎外部的环境通信的API。</p><p id="4a4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">比如像Google Chrome这样的web浏览器，就是一个桌面JavaScript运行时环境，使用V8 JavaScript引擎，提供DOM API、Fetch API、Storage API等。</p><p id="13b3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">类似地，Node和Deno等服务器端运行时环境使用V8引擎，并提供文件系统访问、网络访问、控制台等。</p><h1 id="dd88" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">为什么我们需要浏览器之外的运行时？</h1><p id="9b61" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">尽管JavaScript的主要环境是web浏览器，但近年来，JavaScript已经接管了服务器平台。</p><p id="7f1e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">服务器端JavaScript运行时环境允许您访问文件系统、网络和其他在web浏览器中不允许的东西。你可以用一个只基于JavaScript的技术栈来构建一个完整的web应用程序(从UI到数据层)，比如像<a class="ae kw" href="http://meanjs.org/" rel="noopener ugc nofollow" target="_blank">意味着</a>或者<a class="ae kw" href="https://www.geeksforgeeks.org/mern-stack/" rel="noopener ugc nofollow" target="_blank"> MERN </a>。</p><h1 id="ef6f" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">NodeJS怎么了？</h1><p id="e38f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">根据Ryan Dahl(NodeJS的创始人)的说法，NodeJS做错了一些事情。他在JSConf EU 2018上就此发表了一篇<a class="ae kw" href="https://youtu.be/M3BM9TB-8yA" rel="noopener ugc nofollow" target="_blank">演讲</a>。</p><h1 id="f15d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">不遵守承诺</h1><p id="d633" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">NodeJS有原生的promises支持，但是几个月后，它被移除了。由于这个原因，NodeJS必须使用变通办法来实现承诺。</p><h1 id="fb57" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">安全性</h1><p id="4931" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">V8本身就是一个非常好的安全沙箱。NodeJS删除了所有这些安全特性，并允许应用程序访问所有内容。</p><h1 id="fc3b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">该构建系统</h1><p id="b26a" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我不完全理解这个，所以不要引用我的话。</p><p id="3c93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Chrome开始使用<a class="ae kw" href="https://gyp.gsrc.io/" rel="noopener ugc nofollow" target="_blank"> GYP </a>构建系统，所以NodeJS也进行了切换。但是后来Chrome放弃了GYP，采用了<a class="ae kw" href="https://gn.googlesource.com/gn/" rel="noopener ugc nofollow" target="_blank"> GN </a>作为他们的构建系统，因为它更快更简单。Ryan Dahl认为，继续使用GYP可能是NodeJS核心最大的失败。</p><h1 id="f801" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">npm和package.json</h1><p id="3d85" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">所有npm包都包含一个文件，通常在项目根目录下，名为<a class="ae kw" href="https://docs.npmjs.com/files/package.json" rel="noopener ugc nofollow" target="_blank">package . JSON</a>——这个文件保存了与项目相关的各种元数据。</p><h2 id="fa32" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><em class="mm">什么是npm？</em></h2><p id="0dbc" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">npm或节点包管理器，顾名思义，是用来管理项目中的依赖包，让你的生活更轻松。</p><h2 id="5b9c" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><em class="mm">听起来很棒！这有什么问题？</em></h2><p id="7467" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">package.json文件包含一些不必要的信息，只有npm注册表需要这些信息。Ryan将此描述为“样板噪声”,因为它除了噪声之外没有给项目增加任何东西。</p><p id="f0de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">国家预防机制是中央集权和私人控制的。如果你在浏览器中做过一些项目，你会知道如何链接到依赖项。类似JQuery，Bootstrap等。你添加任何链接到HTML，你可以直接使用它。在节点中，除了npm之外，不能在任何地方安装依赖项表单。</p><h1 id="500c" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">require("module ")不带扩展名"。js "</h1><p id="cf59" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这就是你导入外部库的方式，不够具体。例如，如果您想在项目中安装JQuery，那么首先要使用npm，通过install命令将其安装在项目文件夹中</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="ab37" class="ma ky iq ms b gy mw mx l my mz">npm install jquery</span></pre><p id="e04d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，如果您想在文件中使用它，您可以在想要使用JQuery的文件中添加一个“require()”语句。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="272c" class="ma ky iq ms b gy mw mx l my mz">require("JQuery")</span><span id="92db" class="ma ky iq ms b gy na mx l my mz">// code that uses JQuery</span></pre><h2 id="fca0" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><em class="mm">这有什么问题？看起来很整洁！</em></h2><p id="e499" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">是的，但是这种<em class="nb">简洁的</em>语法所需要的算法非常复杂且效率低下。模块加载程序必须在多个位置查询文件系统，试图猜测用户的意图。</p><h1 id="5405" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">节点_模块</h1><p id="5971" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">这是使用简洁的语法导入模块的结果。</p><p id="4025" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您在项目中安装依赖项时，它们会被下载到“node_modules”文件夹中。</p><blockquote class="nc nd ne"><p id="75f9" class="jy jz nb ka b kb kc kd ke kf kg kh ki nf kk kl km ng ko kp kq nh ks kt ku kv ij bi translated">那使它更整洁！我可以离线使用它们！有问题吗？</p></blockquote><p id="86f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">问题是你安装的依赖项，有他们的依赖项，对他们来说也一样。依赖关系树变得如此之大，很难管理和存储。您必须对每个项目都这样做，这些项目可能大部分都使用相同的依赖项。没有办法在项目之间共享依赖关系。</p><p id="58a8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您想要创建两个不同的项目，但它们都使用JQuery，您可以下载“JQuery.js”文件并将其保存在一个共享文件夹中，您可以从这两个项目链接到该文件夹。当您准备好发布项目时，您只需更改到远程文件的链接并发布它们。您甚至可以在将来的项目中重用本地文件。这在节点中是不可能的。</p><p id="6089" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果有关于它的迷因，那么你知道它是严重的。这是演示中的一张幻灯片。</p><figure class="mn mo mp mq gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ni"><img src="../Images/a121a25eac90b618b5649e46f4f981cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*93zBft7iSh-8sB7b.jpg"/></div></div></figure><h1 id="23cd" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">索引. js</h1><p id="1182" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">与“index.html”类似，如果没有指定，NodeJS将查找“index.js”文件。这是一件没有必要做的事。它不必要地使模块装载系统变得复杂。在“require()”支持package.json之后，这变得尤其不必要</p><h2 id="b05c" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated">他们为什么不解决这些问题？</h2><p id="2cb5" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在这一点上，所有这些问题都是NodeJS的核心特性，试图修复它们将意味着创建一个全新的东西。使用NodeJS的代码如此之多，以至于修复这些问题就像永久停电一样。所有旧代码都会过时。许多科技巨头使用它，许多初创公司使用它，许多开发人员将它用于个人项目。<strong class="ka ir">到处都是！</strong></p><h2 id="0df1" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><em class="mm">那他们为什么不创造一个全新的东西？</em></h2><p id="b835" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">对此，我想说:</p><p id="53b0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在你知道你能得到之前，你不会去要求。</p><p id="c27b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">NodeJS在2009年问世时，是互联网上可能发生的最好的事情。</p><p id="f474" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是的，他们确实创造了一个全新的东西… Deno。</p><h1 id="b1c8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">什么是德诺？</h1><p id="ee6f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Deno是一个<em class="nb">新的</em>跨平台运行时环境，基于Google的V8引擎，就像NodeJS一样。它是由NodeJS的创造者Ryan Dahl制作的。它和NodeJS的目的是一样的。</p><h2 id="358c" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated">如果就像NodeJS一样，那有什么新的？</h2><p id="26f8" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">与Node (C++)不同，它是用Rust编写的，这使得它更快更安全。它还有许多很酷的新功能。</p><h1 id="e602" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">类型脚本支持</h1><p id="e520" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Deno支持开箱即用的<a class="ae kw" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">类型脚本</a>。您不需要设置或配置任何东西。</p><h2 id="128f" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><em class="mm">什么是TypeScript？</em></h2><p id="76a4" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">TypeScript是JavaScript的一个类型化超集，可以转换成普通JavaScript。它是由微软开发的。Typescript增加了许多特性，使您的JavaScript应用程序更容易扩展，并从一开始就防止未来的错误。</p><p id="ce85" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你不需要为此学习一门全新的语言。任何JavaScript代码都是有效的类型脚本代码，但反之则不然。TypeScript transpiles生成干净、简单的JavaScript代码，可以在任何支持ECMAScript 3(或更新版本)的JavaScript引擎上运行。</p><h1 id="2546" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">ES模块导入语法</h1><p id="71e6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Deno允许您使用ES模块语法从web导入，就像在浏览器中一样。</p><pre class="mn mo mp mq gt mr ms mt mu aw mv bi"><span id="b598" class="ma ky iq ms b gy mw mx l my mz">import { bgBlue, red, bold } from "https://deno.land/std/colors/mod.ts";</span></pre><h2 id="c3aa" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><em class="mm">线下使用情况如何？</em></h2><p id="8328" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Deno在第一次获取依赖项后缓存它们。所以现在你甚至不必使用单独的本地文件进行开发。一切正常。缓存的依赖项可以在项目之间共享，因此您可以为您正在处理的每个项目使用每个依赖项的一个副本。</p><p id="0b0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个开关解决了整个node_modules问题，使它更快，并有助于Deno使用您在任何地方都使用的标准JavaScript。</p><h1 id="993e" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">默认安全</h1><p id="119c" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">默认情况下，如果您在Deno中运行一个JavaScript文件，除了读取项目目录的权限之外，它没有其他权限。您必须明确地同意您希望脚本拥有的所有权限。它甚至没有权限连接到互联网甚至你的本地网络。你控制你想要你的脚本做什么。</p><h2 id="f186" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><em class="mm">就这样？你就这点能耐吗？</em></h2><p id="7f2f" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">大多数变化都发生在幕后。运行时本身变得更快，尊重浏览器标准，因此它不必使用现成的API，摆脱了npm及其带来的一切。去掉了所有不必要的工作区，给你一个最小的运行环境来完成工作。</p><h2 id="abc6" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><em class="mm">节点刚刚被摧毁，对不对？</em></h2><p id="2de0" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">不对！有一件事，仍然保持节点在那里…年龄。随着时间的推移，Node获得了大量的用户、学习资源和社区支持。另一方面，Deno最近达到了1.0版本的里程碑。这意味着它的用户群很小，没有很多学习资源，而且它本身把JavaScript社区分成了两部分。</p><p id="2307" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Deno也没有标准的工作流程和开发栈。从谷歌和微软这样的科技巨头转向全职it还有很长的路要走。这反过来意味着没有与Deno相关的工作，正因为如此，没有多少人会尝试学习它。</p><p id="0c6f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以阻止Deno成为#节点杀手的主要原因是用户群。</p><h2 id="7260" class="ma ky iq bd kz mb mc dn ld md me dp lh kj mf mg ll kn mh mi lp kr mj mk lt ml bi translated"><em class="mm">那么我应该试试吗？</em></h2><p id="0930" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">试试看？是啊！全力以赴？还没有！</p><p id="534d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您是JavaScript新手，应该学习Node。JS第一。将来，如果Deno仍然被证明是#NodeKiller，你可以很容易地切换到Deno。你所要做的就是抛弃整洁的导入语法，开始对你所做的负责。</p><p id="81f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您阅读这篇文章。</p></div></div>    
</body>
</html>