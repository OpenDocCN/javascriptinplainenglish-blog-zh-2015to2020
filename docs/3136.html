<html>
<head>
<title>Differences Between Vue 2 And Vue 3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue 2和Vue 3的区别</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/differences-between-vue-2-and-vue-3-ee627e2c83a8?source=collection_archive---------0-----------------------#2020-09-02">https://javascript.plainenglish.io/differences-between-vue-2-and-vue-3-ee627e2c83a8?source=collection_archive---------0-----------------------#2020-09-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="96bf" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Vue 3是一个渐进式的JavaScript框架，是Vue的最新版本。它帮助开发人员创建易接近的、通用的、高性能的、可维护的、可测试的代码库。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/2e56a270888a9a86322abf8e7f8cf0e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*maurjo94aWjtzeoMZKkncA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@johnschno?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">John Schnobrich</a> on <a class="ae ks" href="https://unsplash.com/s/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="688d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Vue 3正式版将于2020年第三季度发布。它目前处于发布候选阶段，这意味着API、核心、结构是稳定的，并且能够成为产品发布，除非出现重大错误。因此，现在是弄清楚Vue 3和Vue 2之间的编程差异并做出必要调整的适当时机。</p><p id="d7d2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Vue 3和Vue 2并没有绝对的改变，但是当Vue 2重写完成后，一些预期的升级变成了现实。预期意味着它使我们的应用程序更小、更快、更强大。</p><p id="7e25" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这篇文章是写给那些有Vue 2使用经验的人的。</p><h1 id="0d9f" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">基本要素</h1><ul class=""><li id="fe25" class="mh mi in kv b kw mj kz mk lc ml lg mm lk mn lo mo mp mq mr bi translated"><a class="ae ks" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue 2 </a></li><li id="6d1a" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated"><a class="ae ks" href="https://v3.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue 3 </a></li></ul><h1 id="3c50" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">创建应用程序</h1><p id="f47f" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">首先，看看创建一个应用程序的方式，你会看到语法上的不同。不仅句法变了，本质也变了。</p><h2 id="0d9e" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">Vue 2</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="c2f9" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">Vue 3</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="71a4" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">改变的原因</h2><ul class=""><li id="1150" class="mh mi in kv b kw mj kz mk lc ml lg mm lk mn lo mo mp mq mr bi translated">全局配置会在单元测试中产生问题，因为测试用例会因全局配置而相互影响。所有这些影响都是污染。</li><li id="6a04" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">Vue 3提供了不同的全局配置，但是很难将配置的副本共享给多个<code class="fe no np nq nr b">apps</code>。</li></ul><p id="bd88" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">示例:</p><ul class=""><li id="986b" class="mh mi in kv b kw kx kz la lc ns lg nt lk nu lo mo mp mq mr bi translated">Vue 2</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><ul class=""><li id="202f" class="mh mi in kv b kw kx kz la lc ns lg nt lk nu lo mo mp mq mr bi translated">Vue 3</li></ul><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="5e93" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">多重根</h1><p id="9851" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">在Vue 2中，您只在模板中实现一个根节点，但是Vue 3不再要求组件有一个根节点，这意味着它在模板中为开发人员提供了多个根节点。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/ead24318d5279f82cc6b349cb59e73dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:750/format:webp/1*9aNSzQ-RJEiuCUjEjnXQDA.png"/></div></figure><p id="29f2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这条消息从来不会出现在Vue 3中。</p><h2 id="0295" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">Vue 2</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="2ef7" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">Vue 3</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="70c4" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">组合API</h1><p id="6caf" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">创建组合API的原因是:</p><ul class=""><li id="e3c3" class="mh mi in kv b kw kx kz la lc ns lg nt lk nu lo mo mp mq mr bi translated">大型组件变得难以阅读和维护。</li><li id="616e" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">管理和维护组件之间的逻辑是一个大问题(mixins)。</li></ul><p id="f27b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，组合API的出现将解决上述问题。</p><p id="676f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">组合API的特性包括:</p><ul class=""><li id="011b" class="mh mi in kv b kw kx kz la lc ns lg nt lk nu lo mo mp mq mr bi translated">最佳类型脚本支持。</li><li id="9c8e" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">组件太大，良好的代码组织是必需的。</li><li id="2954" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">需要可重用的代码。</li></ul><p id="2da8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nw">注意:如果想在Vue 2中使用composition API，可以使用</em> <a class="ae ks" href="https://github.com/vuejs/composition-api" rel="noopener ugc nofollow" target="_blank"> <em class="nw">这个插件</em> </a> <em class="nw">。</em></p><h2 id="04b7" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">设置</h2><p id="bbe6" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">要使用Composition API，我们应该从<code class="fe no np nq nr b">setup()</code>方法开始。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="097e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在Vue 3中，您可以用以下选项替换<code class="fe no np nq nr b">setup()</code>方法:</p><ul class=""><li id="477e" class="mh mi in kv b kw kx kz la lc ns lg nt lk nu lo mo mp mq mr bi translated">成分</li><li id="2495" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">小道具</li><li id="9e3c" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">数据</li><li id="03ac" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">方法</li><li id="0774" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">计算属性</li><li id="d022" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">生命周期方法</li></ul><p id="1d7c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="nw">注意:Vue 3开发可以像Vue 2一样正常使用以上所有，不需要setup()方法。</em></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="b2bb" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">反应参考</h2><p id="43ef" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated"><code class="fe no np nq nr b">ref</code>是“反应式引用”,它包装原始数据以允许我们跟踪变化。别忘了我们在Vue 2中使用<code class="fe no np nq nr b">data()</code>来包装对象内部的原语。</p><p id="517e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> Vue 2 </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="7652" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> Vue 3 </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="4e24" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">方法</h2><p id="78f4" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">Vue 2有一个单独的方法部分，但是在Vue 3中，你可以在<code class="fe no np nq nr b">setup()</code>方法中定义方法。这是一个使用<code class="fe no np nq nr b">setup()</code>方法创建方法的例子。</p><p id="7483" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> Vue 2 </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0c82" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> Vue 3 </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="fa5f" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">计算</h2><p id="a857" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">Vue 2有一个单独的部分用于<code class="fe no np nq nr b">computed</code>，但是你可以在<code class="fe no np nq nr b">setup()</code>方法中定义一个函数。让我向您展示如何在<code class="fe no np nq nr b">setup()</code>方法中实现<code class="fe no np nq nr b">computed</code>。</p><p id="54ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> Vue 2 </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="c96b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> Vue 3 </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="5063" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">看</h2><p id="ec10" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">Vue 2提供了一种观察数据变化并对其做出反应的方式，这就是<code class="fe no np nq nr b">watch</code>属性，但是Vue 3提供了一些新的东西来做这件事。</p><p id="c989" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> Vue 2 </strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d1b2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> Vue 3 </strong></p><p id="2bd6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">新版本为反应式观察数据的变化提供了一个新的东西叫做<code class="fe no np nq nr b">watchEffect()</code>。当它们的依赖关系改变时，它将重新运行。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="d5ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">或者可以用Vue 2熟悉的<code class="fe no np nq nr b">watch</code>功能。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h2 id="03e1" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">小道具</h2><p id="1972" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">你可以在没有<code class="fe no np nq nr b">this</code>的情况下在设置中访问道具:</p><pre class="kd ke kf kg gt nx nr ny nz aw oa bi"><span id="405b" class="na lq in nr b gy ob oc l od oe">setup(props) {<br/>  watch(() =&gt; {<br/>    console.log(props.name);<br/>  });<br/>}</span></pre><h1 id="c3af" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">拆下Vue过滤器</h1><p id="4218" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">Vue 3中不推荐使用的过滤器可用于应用常见的文本格式。</p><p id="c497" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Vue 2中的过滤器示例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="3b4b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是一个局部过滤器声明的例子。</p><pre class="kd ke kf kg gt nx nr ny nz aw oa bi"><span id="22f8" class="na lq in nr b gy ob oc l od oe">filters: {                           <br/>  formatUnix(value) {                             <br/>    if (value) {                               <br/>      return moment(value).format("DD/MM/YYYY");<br/>    }                           <br/>  },                         <br/>},</span></pre><p id="8580" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如何使用此过滤器(格式化日期)。</p><pre class="kd ke kf kg gt nx nr ny nz aw oa bi"><span id="02e2" class="na lq in nr b gy ob oc l od oe">{{ new Date() | formatUnix }}</span></pre><p id="4a1d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使Vue过滤器美化模板的目标是能够在多个组件中重复使用，但它可以由<code class="fe no np nq nr b">methods</code>替换，因为在性能方面没有区别。Vue writer决定移除过滤器的另一个原因是语法，<code class="fe no np nq nr b">{{ new Date() | formatUnix}}</code>和<code class="fe no np nq nr b">|</code>很奇怪，这让开发者很困惑。移除过滤器的最终原因是，它将鼓励开发人员创建更一致的函数来重用每个组件中已建立的显式方法。</p><p id="9635" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">示例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">DateFormat.js</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">App.vue</figcaption></figure><h1 id="8f66" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">多个虚拟模型</h1><p id="e384" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">正如我们所知的Vue 2，<code class="fe no np nq nr b">v-model</code>是给定组件上的双向绑定，但是我们可以在Vue 2中使用单个<code class="fe no np nq nr b">v-model</code>。对于那些对双向绑定一无所知的人来说，双向绑定使得用户输入值在父组件和子组件之间同步，而<code class="fe no np nq nr b">v-model</code>是传递<code class="fe no np nq nr b">value</code>属性和监听<code class="fe no np nq nr b">input</code>事件的快捷方式。</p><h2 id="3426" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">Vue 2</h2><p id="0fa8" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">这是Vue 2中一个简单的<code class="fe no np nq nr b">v-model</code>。</p><pre class="kd ke kf kg gt nx nr ny nz aw oa bi"><span id="a621" class="na lq in nr b gy ob oc l od oe">&lt;input v-model="property" /&gt;</span></pre><p id="0c30" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以用另一种方式编写上面的示例，但效果与下面的代码相同:</p><pre class="kd ke kf kg gt nx nr ny nz aw oa bi"><span id="ff23" class="na lq in nr b gy ob oc l od oe">&lt;input                          <br/>  :value="property"                         <br/>  @input="property = $event.target.value"                       <br/>/&gt;</span></pre><h2 id="be66" class="na lq in bd lr nb nc dn lv nd ne dp lz lc nf ng mb lg nh ni md lk nj nk mf nl bi translated">Vue 3</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">InviteForm.vue</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">App.vue</figcaption></figure><p id="a975" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一个组件可以像这样处理多个v-model:</p><p id="648d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe no np nq nr b">&lt;InviteForm v-model:name=”inviteName” v-model:email=”inviteEmail” /&gt;</code></p><p id="f383" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在组件中，我们有两个道具，分别是字符串类型的<code class="fe no np nq nr b">name</code>和<code class="fe no np nq nr b">email</code>。为了更新父组件的值，我们使用发出一个事件来处理如下属性:</p><ul class=""><li id="ca51" class="mh mi in kv b kw kx kz la lc ns lg nt lk nu lo mo mp mq mr bi translated">更新名称<code class="fe no np nq nr b">emit(“update:name”, value);</code>的值</li><li id="8a75" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">更新电子邮件的值<code class="fe no np nq nr b">emit(“update:email”, value);</code></li></ul><p id="31bd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以它比Vue 2更简单易用，Vue 2至少有2个事件来在多值处理中将每个值从子组件同步到父组件。</p><h1 id="9c54" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">模块化的</h1><p id="0740" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">您应该使您的代码模块化，可以按功能进行组织，并且可以跨其他组件重用。在这一部分，我将介绍另一种方法，而不是<code class="fe no np nq nr b">mixins</code>。</p><p id="634f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们将<code class="fe no np nq nr b">setup()</code>中的任何东西分离到另一个名为<strong class="kv io">复合函数</strong>的函数中，并且我们应该将它保存在一个JavaScript文件中以便重用。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="9f7b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">而这就是如何复用<strong class="kv io">合成函数。</strong></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="fcc2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">正如你在上面看到的，我们使用<code class="fe no np nq nr b">setup()</code>方法来实现2个复合函数，然后我们可以正常使用所有的内部函数。</p><h1 id="73c9" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">入口</h1><p id="fd52" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">传送门的另一个名字是<strong class="kv io">传送组件。</strong> Portal允许我们指定模板HTML，即使它不属于应用程序，我们也可以将其带到DOM的其他部分。</p><pre class="kd ke kf kg gt nx nr ny nz aw oa bi"><span id="f032" class="na lq in nr b gy ob oc l od oe">&lt;div id="app"&gt;&lt;/div&gt;<br/>&lt;div id="out-side-app"&gt;&lt;/div&gt;</span></pre><p id="0e67" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">id为<code class="fe no np nq nr b">out-side-app</code>的DOM是外部应用，我们可以通过使用<strong class="kv io">门户</strong>与之交互。</p><pre class="kd ke kf kg gt nx nr ny nz aw oa bi"><span id="b963" class="na lq in nr b gy ob oc l od oe">&lt;template&gt;<br/>  &lt;teleport to="#out-side-app"&gt;<br/>  This is teleport<br/>  &lt;/teleport&gt;<br/>  &lt;div&gt;APP&lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="f851" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要使用transport组件，我们需要定义“To”属性，该属性接受一个DOM查询选择器。</p><pre class="kd ke kf kg gt nx nr ny nz aw oa bi"><span id="d4bc" class="na lq in nr b gy ob oc l od oe">&lt;teleport to=”#out-side-app”&gt;</span></pre><p id="931c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们使用id来选择DOM，我们也可以像这样使用一个类来选择DOM:</p><pre class="kd ke kf kg gt nx nr ny nz aw oa bi"><span id="48ff" class="na lq in nr b gy ob oc l od oe">&lt;teleport to=”.anyClass”&gt;</span></pre><h1 id="4df4" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">焦虑</h1><p id="929a" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated"><strong class="kv io">suspension</strong>是一个特殊的组件，它代替你的组件呈现回退内容，直到满足一个条件，比如一个加载的后端API。下面的代码是一个使用悬念回调API的例子。</p><p id="2afa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有一个调用API的合成函数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="42c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有一个简单的演示组件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="feb5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有一个悬念成分的例子。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="f1d8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe no np nq nr b">&lt;template #default&gt;</code>内部，我们将具有返回Promise或异步组件的<code class="fe no np nq nr b">setup()</code>方法的组件放在这里。</p><p id="55fb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe no np nq nr b">&lt;template #fallback&gt;</code>里面，我们放了载入时显示的东西，比如微调器、图标或者类似的东西。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi of"><img src="../Images/9c68aa11ac2788caa32d4022b6a75b5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:256/1*r4CZPStav8gIJ6MbYMHGVw.gif"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Suspense demo</figcaption></figure><h1 id="e18b" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">生命周期挂钩</h1><p id="4711" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">Vue 2生命周期方法:</p><ul class=""><li id="c617" class="mh mi in kv b kw kx kz la lc ns lg nt lk nu lo mo mp mq mr bi translated">创建之前()</li><li id="0e1f" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">已创建()</li><li id="719e" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">安装前()</li><li id="3087" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">已安装()</li><li id="258e" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">更新前()</li><li id="f7da" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">已更新()</li><li id="7da7" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated">销毁前()</li></ul><p id="4521" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Vue 3生命周期中有一些新的挂钩:</p><ul class=""><li id="060b" class="mh mi in kv b kw kx kz la lc ns lg nt lk nu lo mo mp mq mr bi translated"><code class="fe no np nq nr b">beforeDestroy()</code>变成了<code class="fe no np nq nr b">beforeUnmount()</code></li><li id="3ee9" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated"><code class="fe no np nq nr b">destroyed()</code>变成了<code class="fe no np nq nr b">unmounted()</code></li><li id="0822" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated"><code class="fe no np nq nr b">onRenderTracked</code>在渲染函数中第一次访问反应依赖时被调用。</li><li id="a298" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated"><code class="fe no np nq nr b">onRenderTriggered()</code>当一个新的渲染被触发时被调用，允许你检查一个组件什么时候重新渲染。</li></ul><p id="46fc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以在<code class="fe no np nq nr b">setup()</code>方法内部回调钩子。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="4842" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以对<code class="fe no np nq nr b">setup()</code>方法中的其他钩子做同样的事情，比如<code class="fe no np nq nr b">onBeforeUpdate()</code>、<code class="fe no np nq nr b">onUpdated()</code>等等。</p><p id="df56" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用组合API时不需要<code class="fe no np nq nr b">beforeCreate()</code>和<code class="fe no np nq nr b">create()</code>方法，因为app会在<code class="fe no np nq nr b">setup()</code> hook之前调用<code class="fe no np nq nr b">beforeCreate()</code> hook，在<code class="fe no np nq nr b">setup()</code>之后立即调用<code class="fe no np nq nr b">created()</code> hook。因此我们可以使用<code class="fe no np nq nr b">setup()</code>来处理我们在<code class="fe no np nq nr b">beforeCreate()</code>和<code class="fe no np nq nr b">create()</code>中需要的东西。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi og"><img src="../Images/a4d1d6909bb27bd3eb8a297f4dbb6f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:214/format:webp/1*-Vtm69BGmYVVAUTPNAzUqQ.png"/></div></figure><h1 id="f95e" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">性能改进</h1><p id="c5f8" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">Vue 3.0侧重于性能改进:</p><ul class=""><li id="c93c" class="mh mi in kv b kw kx kz la lc ns lg nt lk nu lo mo mp mq mr bi translated"><a class="ae ks" href="https://docs.google.com/presentation/d/1yhPGyhQrJcpJI2ZFvBme3pGKaGNiLi709c37svivv0o/preview#slide=id.g42acc26207_0_169" rel="noopener ugc nofollow" target="_blank">更小尺寸的核心</a></li><li id="c696" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated"><a class="ae ks" href="https://www.youtube.com/watch?v=XkOMOeEAFQI&amp;feature=youtu.be&amp;t=612" rel="noopener ugc nofollow" target="_blank">摇树</a></li><li id="f376" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated"><a class="ae ks" href="https://docs.google.com/presentation/d/1yhPGyhQrJcpJI2ZFvBme3pGKaGNiLi709c37svivv0o/preview?slide=id.g4689c30700_0_104" rel="noopener ugc nofollow" target="_blank">优化的插槽生成</a></li><li id="20bc" class="mh mi in kv b kw ms kz mt lc mu lg mv lk mw lo mo mp mq mr bi translated"><a class="ae ks" href="https://docs.google.com/presentation/d/1yhPGyhQrJcpJI2ZFvBme3pGKaGNiLi709c37svivv0o/preview#slide=id.g4689c30700_0_114" rel="noopener ugc nofollow" target="_blank">吊装和内联</a></li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/31752557bb63aa4abe942b0f154dbb3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_-rzuZ_U5cFSeIq0"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Glenn Carstens-Peters</a> on <a class="ae ks" href="https://unsplash.com/s/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f5e0" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结论</h1><p id="c006" class="pw-post-body-paragraph kt ku in kv b kw mj jo ky kz mk jr lb lc mx le lf lg my li lj lk mz lm ln lo ig bi translated">Vue 3是Vue的转折点，我是Vue的超级粉丝，所以我没有理由忽视它。</p><p id="682a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">虽然Vue 3对Vue 2的许多改变使得熟悉Vue 2的开发者不得不花时间学习新的东西，但在我看来，这是有价值的。也许这篇文章仍然有一些缺点，所以我总是欢迎大家的反馈。感谢阅读。</p></div></div>    
</body>
</html>