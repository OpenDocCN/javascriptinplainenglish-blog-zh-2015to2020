<html>
<head>
<title>Othello Kata: The Iterator Pattern in JavaScript/TypeScript Functional Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Othello Kata:JavaScript/TypeScript函数式编程中的迭代器模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/othello-kata-the-iterator-pattern-in-javascript-typescript-functional-programming-78b3709bbcc9?source=collection_archive---------10-----------------------#2020-10-18">https://javascript.plainenglish.io/othello-kata-the-iterator-pattern-in-javascript-typescript-functional-programming-78b3709bbcc9?source=collection_archive---------10-----------------------#2020-10-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/189851d9e131130f4fd1c1fdfa2428ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqru2Ul1CMieUhlOhIwgxA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk"><a class="ae jz" href="https://www.youtube.com/watch?v=8VAq0C3oMBc&amp;ab_channel=SpinMasterGames" rel="noopener ugc nofollow" target="_blank">Othello Tutorial with 2x World Champion Ben Seeley on YouTube</a></figcaption></figure><p id="8d01" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">本文是在TypeScript中著名的kata上演示函数式编程概念的系列文章的一部分。参见 <a class="ae jz" href="https://medium.com/javascript-in-plain-english/fizzbuzz-kata-an-exploration-with-functors-41d5217464fc" rel="noopener"> <em class="ky"> FizzBuzz形:与函子的探索</em> </a> <em class="ky">！</em></p><h1 id="9c9b" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">奥赛罗(又名黑白棋)</h1><p id="b46f" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">《奥赛罗》除了是威廉·莎士比亚的著名悲剧之外，还是一款两人在8×8棋盘上玩的策略棋盘游戏。据说需要“一分钟学习，一生掌握”。事实上，看到戏剧性的优势逆转直到比赛结束并不罕见。如果你对这个游戏不熟悉，想学，可以<a class="ae jz" href="https://www.othelloonline.org/" rel="noopener ugc nofollow" target="_blank">在线</a>试一试。</p><p id="ed45" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个形中，我们将尝试实现告诉玩家可以在哪里玩的功能:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="6477" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们选择将棋盘建模为数组的数组:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="8fc5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在某些时候，这个形需要在棋盘上迭代，并确定每个格子放置一个圆盘是否允许捕捉对手颜色的圆盘。对于数组的数组，这意味着循环遍历行(1到8)以及每行循环遍历列(A到H)。</p><p id="7eaa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但这是实现细节，人们可能会在不知道这实际上是如何发生的情况下，对棋盘进行循环。迭代器模式就是在那里弹出来的！</p><h1 id="d9ba" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">迭代器模式</h1><p id="353c" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">迭代一个数组似乎很明显，你只需循环遍历它的所有项。但是如何迭代一棵树呢？深度优先遍历和广度优先遍历是最有用和最常用的方法，尽管也可以设想其他方法。无论如何，相应的实现细节是<em class="ky">而不是</em>客户端代码所关心的。</p><p id="dfdd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://refactoring.guru/design-patterns/iterator" rel="noopener ugc nofollow" target="_blank">重构大师</a>指出:</p><blockquote class="mi"><p id="d509" class="mj mk in bd ml mm mn mo mp mq mr kx dk translated">迭代器是一种行为设计模式，允许您遍历集合的元素，而不暴露其底层表示。</p></blockquote><p id="2e3a" class="pw-post-body-paragraph ka kb in kc b kd ms kf kg kh mt kj kk kl mu kn ko kp mv kr ks kt mw kv kw kx ig bi translated">在JavaScript中，<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol" rel="noopener ugc nofollow" target="_blank">迭代器协议</a>指定了一个对象为了在<code class="fe mx my mz na b"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="noopener ugc nofollow" target="_blank">for...of</a></code>语句中可迭代而必须实现的接口。具体地说，当一个对象实现一个返回具有以下两个属性的对象的<code class="fe mx my mz na b">next()</code>方法时，它就是一个迭代器:</p><ul class=""><li id="48a1" class="nb nc in kc b kd ke kh ki kl nd kp ne kt nf kx ng nh ni nj bi translated"><code class="fe mx my mz na b">done</code> : <code class="fe mx my mz na b">false</code>如果迭代器能够产生集合中的下一个值；<code class="fe mx my mz na b">true</code>如果迭代器完成了它的序列。</li><li id="c120" class="nb nc in kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated"><code class="fe mx my mz na b">value</code>:如果<code class="fe mx my mz na b">done</code>是<code class="fe mx my mz na b">false</code>，则是集合的下一个JavaScript值。否则，不定义该属性。</li></ul><p id="a540" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这非常方便，但是不太适合函数式编程风格，函数式编程风格更喜欢声明而不是命令式语句(参见维基百科上的<a class="ae jz" href="https://en.wikipedia.org/wiki/Declarative_programming" rel="noopener ugc nofollow" target="_blank">声明式编程</a>)。实际上，这意味着人们更喜欢使用<code class="fe mx my mz na b">map</code>或<code class="fe mx my mz na b">reduce</code>函数而不是<code class="fe mx my mz na b">for...of</code>循环来迭代数据结构。</p><p id="f107" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，迭代器模式需要调整。</p><h1 id="1d50" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">遍历数组</h1><p id="60c1" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">对于数组，迭代通常通过<code class="fe mx my mz na b"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank">reduce</a></code>函数实现，该函数具有以下签名:</p><pre class="mc md me mf gt np na nq nr aw ns bi"><span id="36d1" class="nt la in na b gy nu nv l nw nx">Array.prototype.reduce(callback(accumulator, currentValue[, index[, array]]) {<br/>  ...<br/>}[, initialValue]);</span></pre><p id="0616" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mx my mz na b">reduce</code>函数的一个常见用例是将所有数组的数字相加:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="d64e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">顺便说一下，<code class="fe mx my mz na b">reduce</code>函数是基本的，因为<code class="fe mx my mz na b">map</code>和<code class="fe mx my mz na b">filter</code>函数是从它派生出来的，正如这些替代实现所暗示的:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="12b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，受数组的启发，我们将定义一个具有类似签名的<code class="fe mx my mz na b">reduce</code>函数，以便在棋盘上迭代。</p><h1 id="50c2" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">建议的实现</h1><p id="8f04" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">首先让我们定义一个集合的通用接口，我们可以用一个<code class="fe mx my mz na b">reduce</code>函数对其进行迭代:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="c5cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以如下定义一个可迭代的棋盘:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="3950" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">并在棋盘上实现实际的循环。电路板的<code class="fe mx my mz na b">reduce</code>功能依赖于底层数组的<code class="fe mx my mz na b">reduce</code>功能:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="73dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于上述原因，通过<code class="fe mx my mz na b">reduce</code>函数迭代棋盘终于成为可能。简单地说，我们在棋盘上迭代，并在一个数组中收集可玩单元的坐标:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><h1 id="94c0" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">最后的想法</h1><p id="b6ff" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">通过一个具体的例子，本文说明了这样一个事实，即许多面向对象的编程模式在函数式编程世界中仍然有效，假设做了一些调整。</p><p id="4188" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将一种模式从一种编程风格转换到另一种编程风格需要引用该模式想要解决的原始问题，例如，在不知道具体细节的情况下迭代一个数据结构。</p><p id="dfb0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">欢迎评论。感谢阅读！</p></div><div class="ab cl ny nz hr oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ig ih ii ij ik"><h1 id="a14d" class="kz la in bd lb lc of le lf lg og li lj lk oh lm ln lo oi lq lr ls oj lu lv lw bi translated">资源</h1><ul class=""><li id="b448" class="nb nc in kc b kd lx kh ly kl ok kp ol kt om kx ng nh ni nj bi translated"><a class="ae jz" href="https://github.com/mathieueveillard/othello" rel="noopener ugc nofollow" target="_blank">https://github.com/mathieueveillard/othello</a></li><li id="2e07" class="nb nc in kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated"><a class="ae jz" href="https://en.wikipedia.org/wiki/Reversi#Rules" rel="noopener ugc nofollow" target="_blank">维基百科上的奥赛罗</a></li><li id="afc3" class="nb nc in kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated">重构大师的迭代器模式</li><li id="46f7" class="nb nc in kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" rel="noopener ugc nofollow" target="_blank">MDN上的array . prototype . reduce</a></li><li id="f3a6" class="nb nc in kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated">作曲软件:埃里克·埃利奥特的书</li><li id="da42" class="nb nc in kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated">凯尔·辛普森的<a class="ae jz" href="https://github.com/getify/Functional-Light-JS" rel="noopener ugc nofollow" target="_blank">功能轻JavaScript </a></li><li id="d96f" class="nb nc in kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated"><a class="ae jz" href="https://github.com/MostlyAdequate/mostly-adequate-guide" rel="noopener ugc nofollow" target="_blank">基本上足够的函数式编程指南</a></li><li id="b2c4" class="nb nc in kc b kd nk kh nl kl nm kp nn kt no kx ng nh ni nj bi translated"><a class="ae jz" href="https://katalyst.codurance.com/browse" rel="noopener ugc nofollow" target="_blank">催化剂</a>，通过共保</li></ul></div></div>    
</body>
</html>