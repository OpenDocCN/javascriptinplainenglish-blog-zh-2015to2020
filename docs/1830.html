<html>
<head>
<title>5 Better Practices for JavaScript Promises in Real Projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">真实项目中JavaScript承诺的5个更好实践</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-better-practices-for-javascript-promises-in-real-projects-4917a9daec01?source=collection_archive---------4-----------------------#2020-04-27">https://javascript.plainenglish.io/5-better-practices-for-javascript-promises-in-real-projects-4917a9daec01?source=collection_archive---------4-----------------------#2020-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8527" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用Promise.all、Promise.race和Promise.prototype.then来提高代码质量。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c6e6672de0c054c3f078209ad5c42b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WrO6pqf5aLgB319V"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9958" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在学习了Promise的基本用法后，本文希望能帮助你在实际项目中更好地使用Promise。</p><h1 id="9c60" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">承诺。所有</h1><p id="d5ec" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">Promise.all实际上是一个承诺，它接受一个承诺数组(或一个可迭代的)作为输入。然后，当所有的承诺都得到解决，或者其中任何一个被拒绝时，问题就解决了。</p><p id="7b0e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，假设您有十个承诺(执行网络调用或数据库连接的异步操作)。你必须知道什么时候所有的承诺都解决了，或者你必须等到所有的承诺都解决了。所以你把所有的十个承诺传递给了promise.all，那么，Promise.all本身作为一个承诺将会得到解决，一旦所有的十个承诺都得到解决，或者十个承诺中的任何一个被错误地拒绝。</p><p id="19da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">让我们用代码来看看:</strong></p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e31c" class="mu lt iq mq b gy mv mw l mx my">Promise.all([promise1, promise2, promise3])<br/> .then(result) =&gt; {<br/>   console.log(result)<br/> })<br/> .catch(error =&gt; console.log(`Error in promises ${error}`))</span></pre><p id="8b35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们将一个数组传递给promise.all。当三个承诺都被解析时，promise.all被解析，输出得到安慰。</p><p id="aea5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">我们来看一个例子:</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="5e09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的示例中，Promise.all在2000 ms后解析，输出以数组的形式进行控制。</p><p id="cd13" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于承诺，有趣的一点是承诺的顺序是保持不变的。数组中的第一个承诺将被解析为输出数组的第一个元素，第二个承诺将是输出数组中的第二个元素，依此类推。</p><p id="7155" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，以上是promise.all的基本用法，下面我来介绍一下它在真实项目中的应用。</p><h2 id="1f8a" class="mu lt iq bd lu nb nc dn ly nd ne dp mc lf nf ng me lj nh ni mg ln nj nk mi nl bi translated">1.同步多个异步请求</h2><p id="3498" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在实际项目中，一个页面往往需要向后台发送多个异步请求。等到后台返回结果后，我们才开始呈现页面。</p><p id="93f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些程序员可能会编写这样的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="ca23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码确实有效，但是在这个代码中有两个缺陷:</p><ul class=""><li id="2a3c" class="nm nn iq ky b kz la lc ld lf no lj np ln nq lr nr ns nt nu bi translated">每次我们从服务器请求数据时，我们需要编写一个单独的函数来处理数据。这样会导致代码冗余，也不方便以后的升级和扩展。</li><li id="2d48" class="nm nn iq ky b kz nv lc nw lf nx lj ny ln nz lr nr ns nt nu bi translated">每个请求花费不同的时间，导致函数呈现页面三次不同步，用户感觉页面卡住了。</li></ul><p id="0ddd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们可以使用Promise.all来优化我们的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="bed4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当所有请求完成后，我们统一处理数据。</p><h2 id="c41a" class="mu lt iq bd lu nb nc dn ly nd ne dp mc lf nf ng me lj nh ni mg ln nj nk mi nl bi translated">2.处理异常</h2><p id="31bb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在上面的例子中，我们非常直接地采用这种方法来处理异常:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4956" class="mu lt iq mq b gy mv mw l mx my">Promise.all([p1, p2]).then(res =&gt; {<br/>  // ...<br/>}).catch(error =&gt; {<br/>  // handle error<br/>})</span></pre><p id="ec02" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们知道，Promise.all机制是，只有当Promise数组中的任何promise实例作为参数抛出异常时，整个Promise.all函数才会直接进入catch方法，而不管其他promise实例是成功还是失败。</p><p id="dc27" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但在实践中，我们经常需要的是这样的:即使一个或多个promise实例抛出异常，我们仍然希望Promise.all继续正常执行。比如上面的例子，即使<code class="fe oa ob oc mq b">getBannerList()</code>发生异常，只要<code class="fe oa ob oc mq b">getStoreList()</code>或者<code class="fe oa ob oc mq b">getCategoryList()</code>没有发生异常，我们就继续想执行程序。</p><p id="140f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了满足这一需求，我们可以使用一个技巧来增强Promise.all特性。我们可以这样写代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="a5fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，即使一个promise实例出现异常，也不会中断Promise.all的其他实例。</p><p id="0d66" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">应用到前面的例子，这是结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="3586" class="mu lt iq bd lu nb nc dn ly nd ne dp mc lf nf ng me lj nh ni mg ln nj nk mi nl bi translated">3.让多个promise实例一起工作</h2><p id="ab15" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当用户试图上传或发布某些内容时，我们可能需要验证用户提供的内容。比如检查内容是否包含血腥暴力、色情、假新闻等。在许多情况下，这些检测行为是由后端提供的不同API或SaaS服务提供商提供的不同云功能来执行的。</p><p id="75a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一些程序员可能会编写这样的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><p id="8968" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是有了Promise.all，我们可以让不同的承诺任务协同工作:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="23b8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">承诺.比赛</h1><p id="ccd8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe oa ob oc mq b">promise.race</code>的参数和<code class="fe oa ob oc mq b">promise.all</code>一样，可以是promise数组，也可以是iterable对象。</p><p id="ec3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oa ob oc mq b">Promise.race()</code>方法返回一个承诺，只要iterable中的一个承诺满足或拒绝，该承诺就会满足或拒绝，并带有该承诺的值或原因。</p><h2 id="4023" class="mu lt iq bd lu nb nc dn ly nd ne dp mc lf nf ng me lj nh ni mg ln nj nk mi nl bi translated">4.计时功能</h2><p id="af80" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当我们从后端服务器异步请求资源时，我们通常会限制一个时间。如果在指定的时间内没有收到数据，将引发异常。</p><p id="dc94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑一下你将如何实现这个特性？Promise.race可以帮助我们解决这个问题。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><h1 id="f1a1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">答应我，然后</h1><p id="2809" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们知道<code class="fe oa ob oc mq b">promise.then()</code>总是返回一个promise对象，所以<code class="fe oa ob oc mq b">promise.then</code>支持链式调用。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9fd1" class="mu lt iq mq b gy mv mw l mx my">Promise.then().then().then()</span></pre><h2 id="7d10" class="mu lt iq bd lu nb nc dn ly nd ne dp mc lf nf ng me lj nh ni mg ln nj nk mi nl bi translated">5.承诺链</h2><p id="1f4f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">因此，如果接口返回的数据量很大，并且一个then中的处理看起来很臃肿，我们可以考虑访问处理逻辑，并在多个then方法中轮流执行它:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mz na l"/></div></figure><h2 id="4813" class="mu lt iq bd lu nb nc dn ly nd ne dp mc lf nf ng me lj nh ni mg ln nj nk mi nl bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="2d41" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kv" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ky ir">AI in Plain English</strong></a><a class="ae kv" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ky ir">UX in Plain English</strong></a><a class="ae kv" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ky ir">Python in Plain English</strong></a><strong class="ky ir"/>——谢谢，继续学习！</p><p id="b742" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kv" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">submissions @ plain English . io</strong></a><strong class="ky ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>