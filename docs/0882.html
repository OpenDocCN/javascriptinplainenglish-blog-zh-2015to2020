<html>
<head>
<title>JavaScript Design Pattern — Module Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript设计模式—模块模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-design-pattern-module-pattern-555737eccecd?source=collection_archive---------2-----------------------#2019-12-28">https://javascript.plainenglish.io/javascript-design-pattern-module-pattern-555737eccecd?source=collection_archive---------2-----------------------#2019-12-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="4336" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Java Script语言</h2><div class=""/><div class=""><h2 id="7cfb" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">JavaScript中最常见的模式之一</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/8b5d92659971986989af591dbbb3dd09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2AcrSOQPc9RihDIM"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@sgcreative?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">sgcdesignco</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5ab6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">有许多JavaScript模式可以让你的代码更加漂亮和稳定。编程设计模式已经存在了很多年，希望有一个更好的架构。今天我要讲的是JavaScript中一个简单但功能强大的设计模式，叫做模块模式或者闭包模式。</p><h1 id="99de" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">什么是终结？</h1><p id="bb15" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">闭包是一个引用了已经执行完的外部函数的函数。比如有函数，这个例子是解释闭包是什么的一个非常典型的例子。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="a679" class="nd mc iq mz b gy ne nf l ng nh">function outer(x) {<br/>  function inner(y) {<br/>    return x + y;<br/>  }<br/>  return inner;<br/>}</span><span id="6fd1" class="nd mc iq mz b gy ni nf l ng nh">const inner = outer(5);<br/>inner(3); // 5 + 3 == 8</span></pre><p id="c2aa" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在本例中，内部函数由接受参数x的外部函数包装。内部函数也接受参数y，它所做的是将两个参数相加并返回。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nj"><img src="../Images/0119df29819be74a774efbe970c782a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dyWpGb0BgueRV1oHwKJnEg.png"/></div></div></figure><p id="81f8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">内部函数有一个新的作用域，名为Closure，引用外部函数x，那么在外部函数之外的作用域中，你不能访问x，因为x只存在于外部函数的作用域内部。</p><p id="0d55" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">闭包是JavaScript中神秘而有趣的东西。这似乎是一个神奇的咒语，<em class="nk">羽加迪姆·勒维奥萨</em> 🧙‍♂️.但是如果您了解JavaScript中的执行上下文，您会更好地理解这一点。如果你想了解更多的信息，我建议你先看看我的另一篇文章。</p><div class="nl nm gp gr nn no"><a href="https://medium.com/better-programming/execution-context-lexical-environment-and-closures-in-javascript-b57c979341a5" rel="noopener follow" target="_blank"><div class="np ab fo"><div class="nq ab nr cl cj ns"><h2 class="bd ja gy z fp nt fr fs nu fu fw iz bi translated">JavaScript中的执行上下文、词汇环境和闭包</h2><div class="nv l"><h3 class="bd b gy z fp nt fr fs nu fu fw dk translated">你应该知道的高级JavaScript概念</h3></div><div class="nw l"><p class="bd b dl z fp nt fr fs nu fu fw dk translated">medium.com</p></div></div><div class="nx l"><div class="ny l nz oa ob nx oc ky no"/></div></div></a></div><h1 id="7c88" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">模块模式</h1><p id="8833" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">因此，我们可以利用闭包只能从函数内部访问的特性。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="7c4d" class="nd mc iq mz b gy ne nf l ng nh">function jane() {<br/>  const name = 'jane';<br/>  const mid = 'A';<br/>  const final = 'B+';</span><span id="0cb5" class="nd mc iq mz b gy ni nf l ng nh">  return {<br/>    midtermScore: () =&gt; mid,<br/>    finaltermScore: () =&gt; final,<br/>  }<br/>}</span><span id="9cff" class="nd mc iq mz b gy ni nf l ng nh">jane().midtermScore(); // A<br/>jane().finaltermScore(); // B+</span></pre><p id="6ecb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在本例中，Jane的期中和期末分数无论如何都不能修改。函数jane返回一个对象，该对象包含返回函数本身属性的其他函数。从作用域出简的角度来看，它不能访问里面的任何变量。</p><p id="b27b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果您以错误的方式过度使用闭包，它很容易导致内存泄漏，但是您可以安全地封装函数。如果你想修改变量，你需要做的只是在返回对象中添加setter函数。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="7d24" class="nd mc iq mz b gy ne nf l ng nh">return {<br/>  getMid: () =&gt; mid,<br/>  getFinal: () =&gt; final,<br/>  setMid: score =&gt; mid = score,<br/>  setFinal: score =&gt; final = score,<br/>};</span></pre><p id="9628" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">然后，改变Jane考试分数值的唯一方法是使用<code class="fe od oe of mz b">jane</code>返回的对象中的方法。</p><h1 id="ed46" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">生活中的习惯用法</h1><p id="09c7" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">通常，模块模式与IIFE一起使用。生命有自己独立的功能范围，没有人能从外面进入。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="bfa4" class="nd mc iq mz b gy ne nf l ng nh">var stories = 'Medium Story';</span><span id="9ffa" class="nd mc iq mz b gy ni nf l ng nh">var medium = (function() {<br/>  var stories = ['🍔', '🍟', '🍕'];<br/>  return { getStories: stories };<br/>})();</span></pre><p id="9a35" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这样做的好处是，即使有一个变量与生命中的变量同名，它们的作用域也不会崩溃。此外，您还可以使用闭包，用这种模式创建私有变量或函数。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="2c52" class="nd mc iq mz b gy ne nf l ng nh">console.log(stories); // Medium Story<br/>console.log(medium.getStories()); // ['🍔', '🍟', '🍕']<br/>console.log(medium.stories); // undefined</span></pre><p id="c6a6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这种情况下，您无法访问<code class="fe od oe of mz b">medium</code>中的<code class="fe od oe of mz b">stories</code>，因为它只存在于函数范围内。访问它的唯一方法是使用<code class="fe od oe of mz b">getStories</code>。</p><h1 id="950a" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">Export关键字的用法</h1><p id="076b" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">自从ES6出现后，创建模块模式的方法变得简单多了。这种模式有多种方式，但基本上他们的概念是“将代码隔离到不同的文件中”。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="fea9" class="nd mc iq mz b gy ne nf l ng nh">const stories = ['🍔', '🍟', '🍕'];</span><span id="ca97" class="nd mc iq mz b gy ni nf l ng nh">const getStories = () =&gt; stories;</span><span id="1646" class="nd mc iq mz b gy ni nf l ng nh">export { getStories };</span></pre><p id="7a25" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">并在不同的地方导入这个模块。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="c9d6" class="nd mc iq mz b gy ne nf l ng nh">import { getStories } from '..';</span><span id="7175" class="nd mc iq mz b gy ni nf l ng nh">const stories = 'Medium Story';</span><span id="e896" class="nd mc iq mz b gy ni nf l ng nh">console.log(stories); // Medium Story<br/>console.log(getStories(); // ['🍔', '🍟', '🍕']</span></pre><h1 id="413b" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">与类一起使用</h1><p id="1a39" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在ES2020中，增加了JavaScript类中的private关键字。所以现在你可以在现实生活中加上这个。可以用#关键字声明成员属性。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="4b9b" class="nd mc iq mz b gy ne nf l ng nh">const stories = 'Medium Story';<br/>class Medium {<br/>  #stories = ['🍔', '🍟', '🍕'];<br/>  get Stories() {<br/>    return this.#stories;<br/>  }<br/>}</span><span id="652e" class="nd mc iq mz b gy ni nf l ng nh">const medium = new Medium();</span><span id="d263" class="nd mc iq mz b gy ni nf l ng nh">console.log(stories); // Medium Story<br/>console.log(medium.Stories); // ['🍔', '🍟', '🍕']<br/>console.log(medium.#stories); <br/>                   ~~~~~~~~<br/>// Uncaught SyntaxError: Private field '#stories' must be declared in an enclosing class</span></pre><p id="7804" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是你应该检查一下浏览器的支持状态，因为这是JavaScript中一个全新的特性。</p><h1 id="d984" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">额外收获:打字稿的用法</h1><p id="cffd" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">如果您使用TypeScript，那么您甚至可以使用一个类来封装它们。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="2b6a" class="nd mc iq mz b gy ne nf l ng nh">const stories = 'Medium Story';<br/>class Medium {<br/>  private stories = ['🍔', '🍟', '🍕'];</span><span id="52ac" class="nd mc iq mz b gy ni nf l ng nh">  get Stories() {<br/>    return this.stories;<br/>  }<br/>}</span><span id="e16b" class="nd mc iq mz b gy ni nf l ng nh">const medium = new Medium();</span><span id="cb4f" class="nd mc iq mz b gy ni nf l ng nh">console.log(stories); // Medium Story<br/>console.log(medium.Stories); // ['🍔', '🍟', '🍕']<br/>console.log(medium.stories); // ['🍔', '🍟', '🍕']<br/>                   ~~~~~~~<br/>// Property 'stories' is private and only accessible within class 'Medium'</span></pre><p id="8716" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">即使变量stories在Medium中是私有的，您仍然可以访问它。因为private是一个只存在于TypeScript而非JavaScript中的关键字，所以当TypeScript将代码传输到JavaScript中时，它不做任何事情。</p><p id="4ae2" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">TypeScript只是让你知道在你设置的规则下你做错了什么。实际上，如果不修复TypeScript错误，您就无法转换代码，但是转换后的代码与JavaScript类没有任何不同。您甚至可以通过添加这个注释来避免这个错误。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="2efe" class="nd mc iq mz b gy ne nf l ng nh">// @ts-ignore<br/>console.log(medium.stories);</span><span id="ac11" class="nd mc iq mz b gy ni nf l ng nh">// Now the error is gone</span></pre><p id="cc9f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">因此，TypeSript可以帮助您避免人为错误。它实际上并没有创建一个模块模式，但是它可以帮助您创建一个合适的模块模式。</p><h1 id="9a1b" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">结论</h1><p id="0ade" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">JavaScript中的模块模式绝对有用且强大。它将变量和函数隐藏在声明它们的范围内。而封闭是这个概念的根源。</p><h1 id="f05f" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">资源</h1><ul class=""><li id="2bee" class="og oh iq lh b li mt ll mu lo oi ls oj lw ok ma ol om on oo bi translated"><a class="ae le" href="https://coryrylan.com/blog/javascript-module-pattern-basics" rel="noopener ugc nofollow" target="_blank"> JavaScript模块模式基础</a></li><li id="416f" class="og oh iq lh b li op ll oq lo or ls os lw ot ma ol om on oo bi translated"><a class="ae le" href="https://www.joezimjs.com/javascript/javascript-closures-and-the-module-pattern/" rel="noopener ugc nofollow" target="_blank"> JavaScript闭包和模块模式</a></li><li id="30e6" class="og oh iq lh b li op ll oq lo or ls os lw ot ma ol om on oo bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/web/javascript/reference/statements/export" rel="noopener ugc nofollow" target="_blank">出口— MDN </a></li><li id="a21a" class="og oh iq lh b li op ll oq lo or ls os lw ot ma ol om on oo bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" rel="noopener ugc nofollow" target="_blank">导入— MDN </a></li></ul></div></div>    
</body>
</html>