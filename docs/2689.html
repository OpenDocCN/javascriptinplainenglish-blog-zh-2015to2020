<html>
<head>
<title>JavaScript Tips — Removing Options, Create Random Tokens, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript技巧——移除选项、创建随机令牌等等</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-tips-removing-options-create-random-tokens-and-more-b0db8c5adf2a?source=collection_archive---------12-----------------------#2020-07-14">https://javascript.plainenglish.io/javascript-tips-removing-options-create-random-tokens-and-more-b0db8c5adf2a?source=collection_archive---------12-----------------------#2020-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1593bb59c0c800e4e6e100e8c78b31b0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FH0QeS3vp62HB6KW"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@eprouzet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Eric Prouzet</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6824" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写JavaScript应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些常见JavaScript问题的解决方案。</p><h1 id="d93a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Node.js中的安全随机令牌</h1><p id="f02c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用Node.js轻松地生成一个安全的随机令牌。</p><p id="b687" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cb66" class="mn lc iq mj b gy mo mp l mq mr">require('crypto').randomBytes(48, (err, buffer) =&gt; {<br/>  const token = buffer.toString('hex');<br/>});</span></pre><p id="b769" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入<code class="fe ms mt mu mj b">crypto</code>库并调用它的<code class="fe ms mt mu mj b">randomBytes</code>方法。</p><p id="21c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它用一个我们可以转换成十六进制字符串的<code class="fe ms mt mu mj b">buffer</code>来调用回调。</p><h1 id="61eb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">表演。连接对象数组中的值</h1><p id="a299" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们首先调用<code class="fe ms mt mu mj b">map</code>来获取值，那么我们可以对对象数组中的值调用<code class="fe ms mt mu mj b">join</code>，</p><p id="132d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0fe4" class="mn lc iq mj b gy mo mp l mq mr">const students = [<br/>  { name: "james", age: 12 },<br/>  { name: "alex", age: 14 },<br/>  { name: "mary", age: 11 }<br/>]</span></pre><p id="ed27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过编写来使用<code class="fe ms mt mu mj b">map</code>和<code class="fe ms mt mu mj b">join</code>:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c12c" class="mn lc iq mj b gy mo mp l mq mr">students.map(s =&gt; s.name).join(",");</span></pre><p id="a22e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们获取数组中每个对象的<code class="fe ms mt mu mj b">name</code>属性，并调用<code class="fe ms mt mu mj b">join</code>用逗号将它们连接起来。</p><h1 id="a28a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">仅在指定字符的第一个实例上拆分字符串，并获取其后的子字符串</h1><p id="fe5b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在和<code class="fe ms mt mu mj b">split</code>一起使用的正则表达式中使用捕捉括号。</p><p id="3ead" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="35db" class="mn lc iq mj b gy mo mp l mq mr">"foo_bar_baz".split(/_(.+)/)[1]</span></pre><p id="f717" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个模式将只捕捉第一个下划线。</p><p id="4067" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">_.+</code>表示下划线及其后的所有内容。</p><p id="8061" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到从它返回的<code class="fe ms mt mu mj b">'bar_baz'</code>。</p><p id="5b1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用<code class="fe ms mt mu mj b">substring</code>和<code class="fe ms mt mu mj b">indexOf</code>来做同样的事情。</p><p id="7e48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ec62" class="mn lc iq mj b gy mo mp l mq mr">const str = "foo_bar_baz";<br/>const newStr = str.substring(str.indexOf('_') + 1);</span></pre><p id="7ed6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">indexOf</code>得到第一个<code class="fe ms mt mu mj b">_</code>实例的索引，然后我们加1得到字符串的其余部分。</p><h1 id="d723" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解决一个又一个承诺</h1><p id="2711" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了解决一个接一个的承诺，我们可以写一个<code class="fe ms mt mu mj b">async</code>函数。</p><p id="7c0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f558" class="mn lc iq mj b gy mo mp l mq mr">async function writeFiles(texts) {<br/>  for(const text of texts) {<br/>    await writeFile(text);<br/>  }<br/>};</span></pre><p id="0ffd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过for-of循环使用<code class="fe ms mt mu mj b">async</code>和<code class="fe ms mt mu mj b">await</code>来写文件。</p><p id="f8a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">writeFile</code>是一个返回承诺的函数。</p><p id="4ada" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以承诺在Noe应用程序中现有的异步调用。</p><p id="979b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用蓝鸟做到这一点:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="250f" class="mn lc iq mj b gy mo mp l mq mr">const Promise = require("bluebird");<br/>const fs = Promise.promisifyAll(require("fs"));</span><span id="dcdc" class="mn lc iq mj b gy mv mp l mq mr">const readAll = Promise.resolve(files).map(fs.readFile,{ concurrency: 1 });</span><span id="ce1b" class="mn lc iq mj b gy mv mp l mq mr">readAll.then((allFileContents) =&gt; {<br/>    // do stuff to read files.<br/>});</span></pre><p id="3ef5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe ms mt mu mj b">fs.readFile</code>方法转换成承诺，这样我们就可以调用<code class="fe ms mt mu mj b">then</code>来锁住它们。</p><h1 id="53c4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取不带查询字符串的URL</h1><p id="091a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要获得没有查询字符串部分的URL，我们可以使用<code class="fe ms mt mu mj b">split</code>方法。</p><p id="7a2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f35b" class="mn lc iq mj b gy mo mp l mq mr">window.location.href.split('?')[0]</span></pre><p id="efd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们带着问号调用<code class="fe ms mt mu mj b">split</code>，得到第一部分。</p><p id="51f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7555" class="mn lc iq mj b gy mo mp l mq mr">const url = `${location.origin}${location.pathname}${location.hash}`;</span></pre><p id="c9c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取查询字符串之前的所有部分并将它们连接在一起。</p><p id="e29c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取URL的域部分。</p><p id="21f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">location.pathname</code>获取IRL的路径。</p><p id="d424" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe ms mt mu mj b">location.hash</code>得到散列部分。</p><h1 id="fe1e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用Moment.js从日期中删除时间</h1><p id="1847" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要用moment.js从日期中删除时间，我们可以调用<code class="fe ms mt mu mj b">format</code>来格式化日期字符串。</p><p id="8e4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d159" class="mn lc iq mj b gy mo mp l mq mr">moment().format('LL');</span></pre><p id="b6c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="674c" class="mn lc iq mj b gy mo mp l mq mr">moment().startOf('day')</span></pre><p id="267a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了得到这一天。</p><h1 id="00f8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从选择框中删除项目</h1><p id="0f6e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用jQuery从选择框中移除一个项目。</p><p id="f19b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有给定的select元素:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7f16" class="mn lc iq mj b gy mo mp l mq mr">&lt;select name="fruit" id="fruit"&gt;<br/>  &lt;option value="apple"&gt;Apple&lt;/option&gt;<br/>  &lt;option value="orange"&gt;Orange&lt;/option&gt;<br/>  &lt;option value="grape"&gt;Grape&lt;/option&gt;<br/>&lt;/select&gt;</span></pre><p id="5537" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来删除它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1340" class="mn lc iq mj b gy mo mp l mq mr">$("#fruit option[value='grape']").remove();</span></pre><p id="ba1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用选择器删除值为<code class="fe ms mt mu mj b">grape</code>的选项。</p><h1 id="739b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用jQuery访问iFrame父页面</h1><p id="1fd4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以向<code class="fe ms mt mu mj b">$</code>函数传递第二个参数来指定我们想要访问父窗口。</p><p id="fd18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="19a4" class="mn lc iq mj b gy mo mp l mq mr">$('#parentEl', window.parent.document).html();</span></pre><p id="e3af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入<code class="fe ms mt mu mj b">window.parent.document</code>值来从父窗口而不是当前窗口中选择ID为<code class="fe ms mt mu mj b">parentEl</code>的元素。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/8696a8497441c06a88fbe067ee63e1f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C75R2_kGqiLy3BTi"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mbenna?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mike Benna</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="600b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="824e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe ms mt mu mj b">crypto</code>模块创建一个随机令牌。</p><p id="608e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要对数组中对象的属性调用join，我们可以先调用<code class="fe ms mt mu mj b">map</code>来获取数组中的值。</p><p id="e48f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以通过使用<code class="fe ms mt mu mj b">location</code>对象的各种属性来获得没有查询字符串的URL。</p><p id="1477" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过选择器删除选项元素。</p></div></div>    
</body>
</html>