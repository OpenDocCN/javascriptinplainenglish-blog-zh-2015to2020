<html>
<head>
<title>Algorithms 101: Find Pairs in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:在JavaScript中寻找配对</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-101-find-pairs-in-javascript-72a1f5e9e68f?source=collection_archive---------0-----------------------#2019-10-25">https://javascript.plainenglish.io/algorithms-101-find-pairs-in-javascript-72a1f5e9e68f?source=collection_archive---------0-----------------------#2019-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8906" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Noob诉算法#16，频率计数器和设置</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/230c19561906b135ca05df924e1466e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e8kfkAZ6sfQlBIFLpOu86g.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@chrfickinger?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Christian Fickinger</a> on <a class="ae lb" href="https://unsplash.com/s/photos/socks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9c37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae lb" href="https://leetcode.com/problems/k-diff-pairs-in-an-array/" rel="noopener ugc nofollow" target="_blank">今天的LeetCode挑战:</a></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lc"><img src="../Images/160b2847a128e65d054f1c740701e578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QqDqpyLdKeP1WEYggsmw1A.png"/></div></div></figure><p id="621e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于数组中的每个数字，我们想看看它是否可以与数组中的另一个数字配对，使得第一个数字减去另一个数字的绝对值为<em class="ld"> k </em>。我们可以在不同的配对中使用每个数字，但前提是每个配对都是唯一的。</p><p id="3f26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ld">注意</em>:如果k = 0，我们寻找零差的数字对:即相同数字对。</p><h2 id="b6e0" class="le lf iq bd lg lh li dn lj lk ll dp lm jy ln lo lp kc lq lr ls kg lt lu lv lw bi translated">为了解决这个问题，让我们把工作分成更小的步骤。</h2><ol class=""><li id="e1ae" class="lx ly iq jp b jq lz ju ma jy mb kc mc kg md kk me mf mg mh bi translated">设置一个计数器，这样我们就可以记录找到的配对数量。</li><li id="52ac" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">将数组中的每个数字与其他数字进行比较。看看有没有符合我们条件的。</li><li id="d37d" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">当我们找到满足我们条件的一对时，递增计数器。</li><li id="74e7" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">退回柜台。</li><li id="5575" class="lx ly iq jp b jq mi ju mj jy mk kc ml kg mm kk me mf mg mh bi translated">处理其他边缘情况。</li></ol><h2 id="7adf" class="le lf iq bd lg lh li dn lj lk ll dp lm jy ln lo lp kc lq lr ls kg lt lu lv lw bi translated">第一步。设置计数器</h2><p id="c83b" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">我们的函数应该返回我们找到的配对的数量；所以我们还需要在函数结束时返回计数器，就像这样:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mq"><img src="../Images/d14b9dfda9ee440de089a939169ce880.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vRDrzMGVrvkAAN73uzRLhw.png"/></div></div></figure><h2 id="47cf" class="le lf iq bd lg lh li dn lj lk ll dp lm jy ln lo lp kc lq lr ls kg lt lu lv lw bi translated">2.将数组中的每个数字与其他数字进行比较。</h2><p id="c034" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">换句话说，对于数组中的每个元素，我们需要考虑数组中的每个其他元素。很容易用嵌套循环来实现这一点:</p><pre class="km kn ko kp gt mr ms mt mu aw mv bi"><span id="ebad" class="le lf iq ms b gy mw mx l my mz">for(let i = 0; i &lt; array.length; i++){<br/>   for(let j= 1; j &lt; array.length, j++){ <br/>      //check if absolute value of array[i] - array[j] === k  <br/>   }<br/>}</span></pre><p id="f91a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是这种方法效率很低——它的运行时间为n，这意味着它必须为n的数组执行的计算次数为n。换句话说，与数组的长度相比，所需的计算次数呈指数增长。</p><h2 id="b76a" class="le lf iq bd lg lh li dn lj lk ll dp lm jy ln lo lp kc lq lr ls kg lt lu lv lw bi translated">哈希来救援！</h2><p id="862f" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">当你发现自己试图用嵌套循环来解决某个问题时，这是一个信号，表明你应该考虑使用不同的数据结构，比如散列。我们可以将数组转换成如下的散列:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi na"><img src="../Images/7bd79c868340b56b9ecacf29c261ef95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EED6s8eGJUAj1xxx4rf1fg.png"/></div></div></figure><p id="1820" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，我们设置一个空散列:<code class="fe nb nc nd ms b">{}</code></p><p id="0a82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，我们遍历nums数组，将每个数字作为一个键添加到我们的新散列中，使用真值(我们使用“true”，但是我们可以使用任何真值，比如“banana”)。</p><p id="0519" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">稍后，如果我们想知道我们的散列是否包含某个键，我们可以简单地检查我们的散列是否包含与真值相关联的那个键。如果它</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/147b530e9b988992ef68d341d2b415a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:580/format:webp/1*AZzCtc2zRYezhY_8c5MbMQ.png"/></div></figure><p id="c418" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们如何在这里使用它呢？</p><p id="8681" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们想要做的是检查数组中的每个数字，并找出它是否有匹配的数字。我们可以计算出匹配的数字是多少，然后检查我们的散列是否包含这个数字。</p><p id="6166" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先我们需要计算匹配的数字应该是多少。在本例中:</p><pre class="km kn ko kp gt mr ms mt mu aw mv bi"><span id="5cbf" class="le lf iq ms b gy mw mx l my mz">[3, 1, 4, 1, 5], k = 2</span></pre><p id="6440" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">3与5匹配，因为它们的绝对差是2；1和3匹配。在任何一种情况下，我们都可以通过将k加到配对中较小的数字来计算匹配的值。(因为我们在遍历整个数组，所以即使数组中较大的数字先出现，我们最终也会到达数组中较小的数字。)</p><p id="1191" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以检查我们的散列是否有一个等于我们考虑的数字+ <em class="ld"> k </em>的键。如果是，我们递增计数器。</p><pre class="km kn ko kp gt mr ms mt mu aw mv bi"><span id="ab97" class="le lf iq ms b gy mw mx l my mz">nums.forEach(n =&gt; {<br/>      let key = n + k</span><span id="62a8" class="le lf iq ms b gy nf mx l my mz">      if(hash[key]){<br/>        counter++<br/>      }<br/>  })</span></pre><p id="5a9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到目前为止，我们的代码是这样的:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/b6ce1ae05ee9e54ccef30a0cb62c77d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*19aXRzP4quGJwwC6wdkwhw.png"/></div></div></figure><p id="9164" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这适用于我们的第一个例子，但是有几个问题。</p><h2 id="111e" class="le lf iq bd lg lh li dn lj lk ll dp lm jy ln lo lp kc lq lr ls kg lt lu lv lw bi translated">边缘情况</h2><p id="8c07" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">首先，如果<em class="ld"> k </em>等于零呢？为了找到一对绝对差值为零的数字，我们需要两个相同的数字。我们的散列并没有告诉我们每个数字有多少；它只能告诉我们是否至少有一个数字。</p><p id="d6a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以我们需要把我们的hash改成一个频率计数器。我们不会给每个键分配一个值<em class="ld"> true </em>，而是给它分配一个值，该值等于键在数组中出现的次数:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nh"><img src="../Images/64577ba448e2d2a1b42a1414018499a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HL5DKC_lLgYlkFp8yXMbOg.png"/></div></div></figure><p id="197d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第7行，我们说——嘿，我们的hash已经有一个键<em class="ld"> n </em>了吗？如果是，则将键值增加1；否则，我们将其添加到初始值为1的散列中。这是一个如何工作的例子:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ni"><img src="../Images/e18abdb0311ba2fa3abfb39ab9e51d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ffhYboV7Q6CHSemkr72cGQ.png"/></div></div></figure><p id="88d4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们需要修正我们检查匹配的方式:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nj"><img src="../Images/76b90bad496b2170be3612eb6eac1e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g1AIKJXw3zYyJSYcA-TMtA.png"/></div></div></figure><p id="04df" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第14行，我们仍然在计算匹配数字的值，即数字本身加上<em class="ld"> k. </em></p><p id="120c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第15行，我们说如果<em class="ld"> k </em>是0，我们需要找到<em class="ld"> n </em>的两个实例来组成一对。所以让我们检查一下我们的<em class="ld"> hash[key] </em>是否有一个大于1的值。</p><p id="4c5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第17行，我们说对于所有其他的情况，其中<em class="ld"> k </em>不等于零，让我们看看我们是否能找到匹配数字的一个实例。</p><p id="c1f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们的代码看起来像这样:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nk"><img src="../Images/23310c150ab7ed59fab5780d37450a05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tQHtjtjdsf6ptjIXQwWa-w.png"/></div></div></figure><h2 id="aeba" class="le lf iq bd lg lh li dn lj lk ll dp lm jy ln lo lp kc lq lr ls kg lt lu lv lw bi translated">另一个极端情况:数组中有重复的数字</h2><p id="0319" class="pw-post-body-paragraph jn jo iq jp b jq lz js jt ju ma jw jx jy mn ka kb kc mo ke kf kg mp ki kj kk ij bi translated">哎呦。如果得到如下所示的nums数组:</p><p id="a08d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nb nc nd ms b">[3,1,4,1,5]</code>和<code class="fe nb nc nd ms b">k=2</code></p><p id="7897" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们当前的代码找到了三个匹配对:</p><p id="a6fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi">[3, 1], [1,3], [3,5],</p><p id="e892" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是说明书告诉我们只计算唯一的一对。说明中说，顺序不同的两个相同的数字不被认为是唯一的一对。</p><p id="c9a0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过确保只迭代nums中唯一的数字来解决这个问题。为了消除nums中的重复，我们可以使用JavaScript的Set结构。</p><pre class="km kn ko kp gt mr ms mt mu aw mv bi"><span id="453c" class="le lf iq ms b gy mw mx l my mz">let nums = [1,1,2,3]<br/>let unique = new Set(nums)<br/>=&gt; [1,2,3]<br/>//this is an object, not an array</span></pre><p id="4f76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是我们代码的最终版本:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nl"><img src="../Images/31d351c69c5c6744446f24c695b2d83c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HVHnx8bkyj9E-PI6UP2iQw.png"/></div></div></figure><p id="7dd5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在repl.it上玩这个代码:<a class="ae lb" href="https://repl.it/@Joan_IndianaInd/K-diff-pairs" rel="noopener ugc nofollow" target="_blank">https://repl.it/@Joan_IndianaInd/K-diff-pairs</a></p><p id="03d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它不是超级快，但是比平均速度要好，并且在内存使用上相当轻:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi nm"><img src="../Images/2da2c83993b2ac2546c61717b42f024e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fzzu1Ijf4j7C3JzFFlNkCw.png"/></div></div></figure><p id="bc02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢我的熨斗同学Lizzie Chan，Burak Kocak和Vinh Do帮助我解决了这个问题！</p><p id="255e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">版权所有琼·印第安纳·琳斯2019</p><p id="a3fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ld">接下来:</em> <a class="ae lb" href="https://medium.com/@joanrigdon/algorithms-101-count-primes-in-javascript-97f1ff85e040" rel="noopener"> <em class="ld">算法101，#17，厄拉多塞的JavaScript /Sieve中数素数</em> </a></p><p id="1f92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="ld">以防你错过:</em> <a class="ae lb" href="https://medium.com/javascript-in-plain-english/algorithms-101-can-place-flowers-in-javascript-b87c6cb1dc24" rel="noopener"> <em class="ld">算法101 #15，可以在JavaScript </em> </a>中放置花朵</p></div></div>    
</body>
</html>