<html>
<head>
<title>React Context Patterns with useContext Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用useContext挂钩反应上下文模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-context-patterns-with-usecontext-hook-62085b90c7eb?source=collection_archive---------0-----------------------#2019-10-21">https://javascript.plainenglish.io/react-context-patterns-with-usecontext-hook-62085b90c7eb?source=collection_archive---------0-----------------------#2019-10-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b706029fe1f5e58b4903aaac90a36e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E0CYvkUII-wni2nrtLOgVw.png"/></div></div></figure><p id="d82c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React <a class="ae kw" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> Context </a> API提供了一种便捷的方式来实现全局状态，而无需向应用添加任何其他依赖。它不是Redux、MobX或其他类似库的直接替代。相反，上下文提供了一种架构应用程序状态管理的替代方法。</p><h2 id="3a8b" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">为什么选择语境？</h2><p id="0bb2" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">如果你的应用程序中只有几个全局状态，可能不值得立即使用Redux。例如，应用程序需要全局共享用户授权状态。该状态可能有额外的用户信息，如用户偏好。但除此之外，它没有任何其他全局状态。因此，不添加Redux，使用React Context是一个很好的替代方案。</p><p id="2f0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我能想到的另一种情况是app使用GraphQL的时候。像Apollo或Relay这样的库已经处理了来自远程数据的状态突变。上下文可以用来处理任何其他状态，比如UI主题、语言偏好或来自其他REST APIs的数据。上下文远没有覆盖另一个状态管理库那样固执己见和灵活。</p><p id="d434" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">关于“<em class="lv">为什么不redux”，</em>看看丹·阿布拉莫夫的“<a class="ae kw" href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367" rel="noopener">你可能不需要Redux </a>”。Redux或Context，没有一个选择自动优于另一个。这都是关于取舍的。</p><h2 id="c614" class="kx ky iq bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">如何利用上下文？</h2><p id="7748" class="pw-post-body-paragraph jy jz iq ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">所以你已经考虑了权衡利弊。你想给上下文一个机会。如何实现？</p><p id="356e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我第一次在Hooks之前研究上下文API时，我发现必须将<code class="fe lw lx ly lz b">Context.Consumer</code>放在多个组件上相当麻烦。它也无助于减少道具演练或简化状态更改。随着<a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">钩子和</a> <code class="fe lw lx ly lz b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="noopener ugc nofollow" target="_blank">useContext</a></code>的发布，现在使用上下文API看起来更有吸引力了。</p><p id="a811" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个探索练习中，我决定用影响所有组件的全局状态来构建一个游戏。让我们玩骰子吧！</p><p id="f05f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">演示游戏</p><p id="9636" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将看到使用上下文和钩子实现这个演示游戏的3种方法。</p><p id="2dbe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模式A和B松散地遵循外观模式。两者都创建了一个简单的接口来与更复杂的对象(状态)进行交互。模式C类似Redux，有一个缩减器和调度器。</p><p id="7652" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我提到这一点是为了防止你像我一样，发现对设计模式至少有一个模糊的心智模型是有用的。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="c567" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在所有3个实施中，高级架构都有两个主要部分:</p><ol class=""><li id="069a" class="mh mi iq ka b kb kc kf kg kj mj kn mk kr ml kv mm mn mo mp bi translated">一个<strong class="ka ir"> Provider </strong>高阶组件(演示中的<em class="lv"> provider.js)。这个HOC必须包装所有想要使用全局上下文状态的组件。</em></li><li id="0671" class="mh mi iq ka b kb mq kf mr kj ms kn mt kr mu kv mm mn mo mp bi translated">一个<strong class="ka ir">定制钩子</strong>(在演示中<em class="lv">使用GameContext.js)，通过它UI组件可以读取和改变上下文。</em></li></ol><p id="65a0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们获利所需的一切💰💰💰！</p><p id="5869" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有示例中的应用程序架构都是相同的。位于所有UI组件之上的提供者:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="48ef" class="kx ky iq lz b gy nd ne l nf ng">function App() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;GameProvider&gt;<br/>        &lt;GameProgress /&gt;<br/>        &lt;DiceBoard /&gt;<br/>        &lt;RollDiceButton /&gt;<br/>        &lt;PlayerScores /&gt;<br/>      &lt;/GameProvider&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="5a61" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种扁平的结构很好地说明了每一个片段是如何消费上下文的。把它们几个嵌套在一起，然后把道具传下去，也是一样的道理。无论哪种方式，都不会改变我们用钩子实现上下文的方式。</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="23b1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，让我们看看3个模式的实现细节。</p><p id="59d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">模式A——基础知识</strong></p><p id="4478" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">1:<em class="lv">provider . js</em>T28】</strong></p><p id="ac6d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模式A的provider.js</p><p id="5239" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在提供者组件中，首先创建上下文:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="6c35" class="kx ky iq lz b gy nd ne l nf ng">const GameContext = React.createContext();</span></pre><p id="53ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后创建一个返回<code class="fe lw lx ly lz b">Context.Provider</code>的提供者组件:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="2247" class="kx ky iq lz b gy nd ne l nf ng">const GameProvider = ({ children }) =&gt; {<br/>  const [state, dispatch] = useImmer({ ...defaultState });<br/>  <br/> return (<br/>    &lt;GameContext.Provider value={[state, dispatch]}&gt;<br/>      {children}<br/>    &lt;/GameContext.Provider&gt;<br/>  );<br/>};</span></pre><p id="d15a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">什么是<code class="fe lw lx ly lz b">useImmer</code>？这是Immer 的<a class="ae kw" href="https://github.com/immerjs/use-immer" rel="noopener ugc nofollow" target="_blank">钩子实现，我选择的不可变状态util库。它类似于<code class="fe lw lx ly lz b">useState</code>，但是返回当前状态和一个更新函数。</a></p><p id="d0c9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你熟悉Immer，可以把它想象成一个返回<code class="fe lw lx ly lz b">produce</code>函数(<code class="fe lw lx ly lz b">produce(currentState, producer:(draftState) =&gt; void): nextState</code>)的定制钩子。</p><p id="a9de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者，如果不使用Immer，第二行可以简单地是:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="a6cd" class="kx ky iq lz b gy nd ne l nf ng">const [state, setState] = useState({...defaultState});</span></pre><p id="208d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你不需要采用<code class="fe lw lx ly lz b">useImmer</code>或者你可以使用你自己选择的不可变util库。模式的其余部分仍然可以实现，如下所示。唯一的区别是在自定义钩子中改变状态的函数(下面会详细介绍)。</p><p id="1323" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lw lx ly lz b">defaultState</code>也是可选的。但是我相信清楚地描述<code class="fe lw lx ly lz b">state</code>是一个好习惯，即使默认值是空的或者一开始就没有定义。这使得代码更容易推理。</p><p id="137c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样值得注意的是，我选择将updater函数命名为<code class="fe lw lx ly lz b">dispatch</code>，以便在所有示例中保持一致。我本可以把它留在这里。🤷</p><p id="7d0d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，导出提供者和上下文:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="21b2" class="kx ky iq lz b gy nd ne l nf ng">export { GameProvider, GameContext };</span></pre><p id="667e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lw lx ly lz b">GameProvider</code>是包装特设，前面解释过。<code class="fe lw lx ly lz b">GameContext</code>由自定义钩子<em class="lv"> useGameContext.js </em>使用。</p><p id="eb23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是提供者组件！</p><p id="2b5a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="lv">2:use game context . js</em></strong></p><p id="7499" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们创建一个自定义钩子，这是操作的主体。</p><p id="67a3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将GameContext.js用于模式A</p><p id="d001" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">自定义钩子只是另一个函数。为了让React将其视为一个钩子并允许该函数调用其他钩子，名称需要以<strong class="ka ir"> use </strong>开头。(更多关于React文档中的<a class="ae kw" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">定制钩子的信息</a>。)</p><p id="21f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，出于我们的目的，我们将这个函数命名为<code class="fe lw lx ly lz b">useGameContext</code>。它调用<code class="fe lw lx ly lz b">useContext</code>钩子，该钩子接收我们从<em class="lv"> provider.js </em>导出的<code class="fe lw lx ly lz b">GameContext</code>。</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="cc6d" class="kx ky iq lz b gy nd ne l nf ng">const [state, dispatch] = useContext(GameContext);</span></pre><p id="4af3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以读取<code class="fe lw lx ly lz b">state</code>并使用<code class="fe lw lx ly lz b">dispatch</code>来更新我们的上下文。</p><p id="271c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个定制钩子的其余部分包括两个处理状态变化的函数。例如，触发掷骰子和确定下一轮的功能。</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="e7e5" class="kx ky iq lz b gy nd ne l nf ng">function initRoll(currentPlayer) {<br/>    const nextTurn = decideTurn(currentPlayer);<br/>    dispatch(draft =&gt; {<br/>      draft.rollingDice = true;<br/>      draft.playerTurn = nextTurn;<br/>      if (nextTurn === "A") {<br/>        draft.round++;<br/>      }<br/>      if (draft.round === 12 &amp;&amp; nextTurn === "B") {<br/>        draft.gameEnded = true;<br/>      }<br/>    });<br/>}</span></pre><p id="3da8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面要注意的重点是<code class="fe lw lx ly lz b">dispatch</code>函数调用。如果你不熟悉Immer标准，这可能看起来很奇怪。实际上，它很可能是任何其他变量名。这里的<code class="fe lw lx ly lz b">dispatch</code>是一个Immer updater函数，它接受一个Immer producer函数。我不会在这里进入这个API的细节，更多见<a class="ae kw" href="https://immerjs.github.io/immer/docs/produce" rel="noopener ugc nofollow" target="_blank">关于生产</a>的Immer API文档。</p><p id="e754" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，您传入状态，并像普通JS对象一样改变它的任何部分。然后Immer负责返回一个新对象。(真的，很牛逼。)</p><p id="61c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在非Immer实现中，该函数可能类似于:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="8132" class="kx ky iq lz b gy nd ne l nf ng">function initRoll(currentPlayer) {<br/>    const nextTurn = decideTurn(currentPlayer);<br/>    const newState = {...state};<br/>    newState.rollingDice = true;<br/>    ......<br/>}</span></pre><p id="8c8c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你明白了。</p><p id="6a52" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，<code class="fe lw lx ly lz b">useGameContext</code>返回状态以及您想要公开的更新函数:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="1918" class="kx ky iq lz b gy nd ne l nf ng">const useGameContext = () =&gt; {</span><span id="cbe3" class="kx ky iq lz b gy nh ne l nf ng">......omitted here.....</span><span id="e531" class="kx ky iq lz b gy nh ne l nf ng">return {<br/>    ...state,<br/>    initRoll,<br/>    updateDice<br/>  };<br/>};</span></pre><p id="3e34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3: </strong>💰💰💰</p><p id="ca8a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，从状态中读取，例如，显示玩家的分数。我们可以从<code class="fe lw lx ly lz b">useGameContext</code>钩子中读取我们想要的状态，就像这样:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="43c2" class="kx ky iq lz b gy nd ne l nf ng">const PlayerScores = () =&gt; {<br/>  const { playerAScore, playerBScore } = useGameContext();</span><span id="a4d7" class="kx ky iq lz b gy nh ne l nf ng">return (<br/>    &lt;ScoreContainer&gt;<br/>      &lt;PlayerContainer&gt;<br/>        &lt;h4&gt;Player A&lt;/h4&gt;<br/>        &lt;div&gt;Score: {playerAScore}&lt;/div&gt;<br/>      &lt;/PlayerContainer&gt;<br/>      &lt;PlayerContainer&gt;<br/>        &lt;h4&gt;Player B&lt;/h4&gt;<br/>        &lt;div&gt;Score: {playerBScore}&lt;/div&gt;<br/>      &lt;/PlayerContainer&gt;<br/>    &lt;/ScoreContainer&gt;<br/>  );<br/>};</span></pre><p id="14bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了触发状态更新，比如掷骰子，我们从钩子中获得状态和函数的一部分:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="6e4d" class="kx ky iq lz b gy nd ne l nf ng">const RollDiceButton = () =&gt; {<br/>  const { playerTurn, gameEnded, initRoll } = useGameContext();</span><span id="b865" class="kx ky iq lz b gy nh ne l nf ng">function handleClick() {<br/>    initRoll(playerTurn);<br/>  }<br/>  return (<br/>    &lt;Button onClick={handleClick} disabled={gameEnded}&gt;<br/>      Roll the Dice<br/>    &lt;/Button&gt;<br/>  );<br/>};</span></pre><p id="7b14" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">💥我们已经用钩子实现了上下文！</p><p id="4b62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">图案B — A分离</strong></p><p id="d378" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模式A包含了利用钩子时使用上下文的所有部分。然而，用一个单一的<strong class="ka ir">上下文。处理状态<em class="lv">和更新状态</em>的提供者</strong>，它有可能导致性能问题。</p><p id="bf34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">避免这种情况的方法是创建两个上下文，一个为<code class="fe lw lx ly lz b">state</code>做准备，另一个为<code class="fe lw lx ly lz b">dispatch</code>做准备。值得注意的是，过早的性能调整仅仅是过早的。过度架构从来都不是好事。(有关优化上下文值的更多信息，请参见肯·多兹的<a class="ae kw" href="https://kentcdodds.com/blog/how-to-optimize-your-context-value" rel="noopener ugc nofollow" target="_blank">这篇</a>。)</p><p id="8717" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们浏览代码时，您可以自己判断是否需要这种复杂程度。幸运的是，模式A的重构不需要那么多工作。大部分代码将非常相似，甚至组件的消耗也是如此。</p><p id="aa6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">1:<em class="lv">provider . js</em>T25】</strong></p><p id="aad0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模式B的provider.js</p><p id="fdb0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在提供者组件中，我们创建了两个上下文，而不是一个:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="cd68" class="kx ky iq lz b gy nd ne l nf ng">const StateContext = React.createContext();<br/>const DispatchContext = React.createContext();</span></pre><p id="6f45" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lw lx ly lz b">StateContext</code>是为国家对象。<code class="fe lw lx ly lz b">DispatchContext</code>是针对变异状态。</p><p id="f151" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后创建返回两个而不是一个提供者的<code class="fe lw lx ly lz b">GameProvider</code>特设。<code class="fe lw lx ly lz b">StateContext.Provider</code>取单值<code class="fe lw lx ly lz b">state</code>。<code class="fe lw lx ly lz b">DispatchContext.Provider</code>将<code class="fe lw lx ly lz b">dispatch</code>更新器函数作为值。</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="9a55" class="kx ky iq lz b gy nd ne l nf ng">const GameProvider = ({ children }) =&gt; {<br/>  const [state, dispatch] = useImmer({ ...defaultState });</span><span id="e4a6" class="kx ky iq lz b gy nh ne l nf ng">return (<br/>    &lt;StateContext.Provider value={state}&gt;<br/>      &lt;DispatchContext.Provider value={dispatch}&gt;<br/>        {children}<br/>      &lt;/DispatchContext.Provider&gt;<br/>    &lt;/StateContext.Provider&gt;<br/>  );<br/>};</span></pre><p id="f4b8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，导出提供者和两个上下文:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="a305" class="kx ky iq lz b gy nd ne l nf ng">export { GameProvider, StateContext, DispatchContext };</span></pre><p id="b7a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lw lx ly lz b">StateContext</code>和<code class="fe lw lx ly lz b">DispatchContext</code>都将被自定义钩子<em class="lv"> useGameContext.js </em>使用。如您所见，与模式a的差异很小。</p><p id="1afd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="lv">2:use game context . js</em></strong></p><p id="6226" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将GameContext.js用于模式B</p><p id="26a9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<em class="lv"> useGameContext.js </em>这里，<em class="lv"> </em>我们可以通过拆分模式a中的<code class="fe lw lx ly lz b">useGameContext</code>钩子来创建两个独立的钩子。</p><p id="f483" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<code class="fe lw lx ly lz b">useGameStateContext</code>吊钩，用于收回<code class="fe lw lx ly lz b">StateContext</code>并返回<code class="fe lw lx ly lz b">state</code>；</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="021b" class="kx ky iq lz b gy nd ne l nf ng">function useGameStateContext() {<br/>  const state = useContext(StateContext);</span><span id="2f6d" class="kx ky iq lz b gy nh ne l nf ng">if (state === undefined) {<br/>    throw new Error("Ut oh, where is my state?");<br/>  }</span><span id="433f" class="kx ky iq lz b gy nh ne l nf ng">return state;<br/>};</span></pre><p id="599a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个<code class="fe lw lx ly lz b">useGameDispatchContext</code>钩子，接受<code class="fe lw lx ly lz b">DispatchContext</code>并返回更新函数<code class="fe lw lx ly lz b">initRoll</code>和<code class="fe lw lx ly lz b">updateDice</code>。实际上是模式A的复制和粘贴:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="7f2c" class="kx ky iq lz b gy nd ne l nf ng">function useGameDispatchContext() {<br/>  const dispatch = useContext(DispatchContext);</span><span id="292c" class="kx ky iq lz b gy nh ne l nf ng">if(dispatch === undefined) {<br/>    throw new Error("Ut oh, where is my dispatch?");<br/>  }</span><span id="f4ef" class="kx ky iq lz b gy nh ne l nf ng">function initRoll(currentPlayer) {<br/>    const nextTurn = decideTurn(currentPlayer);<br/>    dispatch(draft =&gt; {<br/>      draft.rollingDice = true;<br/>      draft.playerTurn = nextTurn;<br/>      if (nextTurn === "A") {<br/>        draft.round++;<br/>      }<br/>      if (draft.round === 12 &amp;&amp; nextTurn === "B") {<br/>        draft.gameEnded = true;<br/>      }<br/>    });<br/>  }</span><span id="c8ec" class="kx ky iq lz b gy nh ne l nf ng">function updateDice({ dieOne, dieTwo }) {<br/>    ...omitted...<br/>  }</span><span id="1771" class="kx ky iq lz b gy nh ne l nf ng">return { initRoll, updateDice };<br/>};</span></pre><p id="c4a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们可以选择导出并单独使用这两个钩子，或者创建另一个钩子来返回这两个钩子:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="7969" class="kx ky iq lz b gy nd ne l nf ng">const useGameContext = () =&gt; {<br/>  return [useGameStateContext(), useGameDispatchContext()]<br/>}</span></pre><p id="0386" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过只导出这个<code class="fe lw lx ly lz b">useGameContext</code>,我们可以将上下文限制在一个交互点上。那是专家。缺点是我们确实增加了另一层间接性。</p><p id="fc65" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3: </strong>💰💰💰</p><p id="bb33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了与上下文交互，我们仍然调用<code class="fe lw lx ly lz b">useGameContext</code>,只有一个非常小的变化——解构一个函数数组而不是一个对象。例如，在同一个<code class="fe lw lx ly lz b">RollDiceButton</code>组件中，我们得到的状态和更新函数如下:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="c7c6" class="kx ky iq lz b gy nd ne l nf ng">const RollDiceButton = () =&gt; {<br/>  const [state, dispatch] = useGameContext();<br/>  const { playerTurn, gameEnded } = state;<br/>  const { initRoll } = dispatch;</span><span id="d116" class="kx ky iq lz b gy nh ne l nf ng">function handleClick() {<br/>    ...omitted...<br/>  };<br/>}</span></pre><p id="69da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">💥从模式A简单重构，我们已经用钩子优化了上下文！</p><p id="1661" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">模式C — Redux-Lite </strong></p><p id="e4c3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">另一个实现选项是通过使用<code class="fe lw lx ly lz b"><a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">useReducer</a></code> <a class="ae kw" href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="noopener ugc nofollow" target="_blank">钩子</a>来设计一些非常类似于Redux的reducer +动作模式的东西，这是<code class="fe lw lx ly lz b">useState</code>的替代方案。</p><p id="f3c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你不仅对Redux感到舒服，而且还是它的粉丝，这是一个不错的选择。Ken Dodds有另一篇关于上下文的很棒的文章，重点是<a class="ae kw" href="https://kentcdodds.com/blog/how-to-use-react-context-effectively" rel="noopener ugc nofollow" target="_blank">如何有效地使用这个方法</a>。我建议读一读，因为我抄袭了很多！</p><p id="b84b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与A和B相比，模式C的状态管理更加集中，但是增加了更多的样板文件和复杂性，这是选择Redux的一个折衷。</p><p id="2bf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要注意的关键区别是，A和B中的状态操作是在自定义钩子<code class="fe lw lx ly lz b">useGameContext</code>中管理的。在C模式中，钩子只是简单的返回函数。状态管理将位于提供者组件中。</p><p id="c897" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">1:<em class="lv">provider . js</em>T21】</strong></p><p id="3d5b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">模式C的provider.js</p><p id="513d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这个例子中，为了便于说明，我创建了两个上下文，就像模式B一样:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="1fc3" class="kx ky iq lz b gy nd ne l nf ng">const StateContext = React.createContext();<br/>const DispatchContext = React.createContext();</span></pre><p id="8839" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们创建<code class="fe lw lx ly lz b">reducer</code>函数。这里也使用Immer <code class="fe lw lx ly lz b">produce</code>来处理不变性:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="0d0f" class="kx ky iq lz b gy nd ne l nf ng">const ACTION_TYPES = {<br/>  initRoll: "INIT_ROLL",<br/>  updateDice: "UPDATE_DICE_AND_SCORE"<br/>};</span><span id="fc7d" class="kx ky iq lz b gy nh ne l nf ng">const reducer = (state, action) =&gt;<br/>  produce(state, draft =&gt; {<br/>    switch (action.type) {<br/>      case ACTION_TYPES.initRoll: {<br/>        const nextTurn = decideTurn(action.payload);<br/>        draft.rollingDice = true;<br/>        draft.playerTurn = nextTurn;<br/>        if (nextTurn === "A") {<br/>          draft.round++;<br/>        }<br/>        if (state.round === 12 &amp;&amp; nextTurn === "B") {<br/>          draft.gameEnded = true;<br/>        }<br/>        return draft;<br/>      }<br/>      case ACTION_TYPES.updateDice: {<br/>        ...omitted...<br/>      }<br/>      default: {<br/>        throw new Error(`Unhandled action type: ${action.type}`);<br/>      }<br/>    }<br/>});</span></pre><p id="2441" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe lw lx ly lz b">ACTION_TYPES</code>对象定义了将改变状态的两个动作。就是我们到目前为止一直在看的那两个函数，<code class="fe lw lx ly lz b">initRoll</code>和<code class="fe lw lx ly lz b">updateDice</code>。我选择不添加动作创建者。我不认为复杂是必要的。但是，嘿，如果你喜欢动作创作者，那就去吧！👍</p><p id="deee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们创建了返回两个上下文的<code class="fe lw lx ly lz b">GameProvider</code>组件。这就是我们使用<code class="fe lw lx ly lz b">useReducer</code>钩子的地方:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="90ef" class="kx ky iq lz b gy nd ne l nf ng">const GameProvider = ({ children }) =&gt; {<br/>  const initState = {<br/>    ...defaultState<br/>  };</span><span id="8fac" class="kx ky iq lz b gy nh ne l nf ng">const [state, dispatch] = useReducer(reducer, initState);</span><span id="b67c" class="kx ky iq lz b gy nh ne l nf ng">return (<br/>    &lt;StateContext.Provider value={state}&gt;<br/>      &lt;DispatchContext.Provider value={dispatch}&gt;<br/>        {children}<br/>      &lt;/DispatchContext.Provider&gt;<br/>    &lt;/StateContext.Provider&gt;<br/>  );<br/>};</span></pre><p id="66ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将<code class="fe lw lx ly lz b">reducer</code>函数传递给<code class="fe lw lx ly lz b">useReducer</code>钩子，并用<code class="fe lw lx ly lz b">initState</code>初始化它。<code class="fe lw lx ly lz b">dispatch</code>功能被赋值给<code class="fe lw lx ly lz b">DispatchContext</code>。而<code class="fe lw lx ly lz b">StateContext</code>取<code class="fe lw lx ly lz b">state</code>作为值。与模式b中的设置相同。</p><p id="087c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而且……我们已经与提供商断绝关系了！</p><p id="f07f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"><em class="lv">2:usegamecontext . js</em></strong></p><p id="f907" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将GameContext.js用于模式C</p><p id="d136" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与B和C相比，在这种情况下，自定义钩子要简单得多。两个上下文钩子<code class="fe lw lx ly lz b">useGameStateContext</code>和<code class="fe lw lx ly lz b">useGameDispatchContext</code>只需要返回从两个上下文接收到的<code class="fe lw lx ly lz b">state</code>和<code class="fe lw lx ly lz b">dispatch</code>。</p><p id="5da6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与模式B一样，我们也可以创建另一个返回两者的钩子。然后只从消费组件调用<code class="fe lw lx ly lz b">useGameContext</code>。但是对于这个模式的例子，我把这个额外的层去掉了。</p><p id="9ddf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3: </strong>💰💰💰</p><p id="97e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，为了与我们一直在关注的<code class="fe lw lx ly lz b">RollDiceButton</code>组件中的上下文进行交互，我们将通过分别调用<code class="fe lw lx ly lz b">useGameStateContext</code>和<code class="fe lw lx ly lz b">useGameDispatchContext</code>来获取状态片段和更新函数:</p><pre class="mv mw mx my gt mz lz na nb aw nc bi"><span id="1aa7" class="kx ky iq lz b gy nd ne l nf ng">const RollDiceButton = () =&gt; {<br/>  const { playerTurn, gameEnded } = useGameStateContext();<br/>  const dispatch = useGameDispatchContext();</span><span id="744a" class="kx ky iq lz b gy nh ne l nf ng">function handleClick() {<br/>    dispatch({<br/>      type: ACTION_TYPES.initRoll,<br/>      payload: playerTurn<br/>    });<br/>  }</span><span id="7904" class="kx ky iq lz b gy nh ne l nf ng">...omitted...</span><span id="c522" class="kx ky iq lz b gy nh ne l nf ng">}</span></pre><p id="340c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于<code class="fe lw lx ly lz b">handleClick</code>函数，我们不会触发类似<code class="fe lw lx ly lz b">initRoll</code>的函数，而是按类型调度一个动作并传递有效载荷，这是一种常见的Redux调度实践。</p><p id="f61a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果不进一步合并到一个单独的<code class="fe lw lx ly lz b">useGameContext</code>钩子，每个消费组件都需要清楚地识别要导入和使用哪个上下文钩子。这增加了一点精神负担。但是我发现故意调用<code class="fe lw lx ly lz b">useGameStateContext</code>和<code class="fe lw lx ly lz b">useGameDispatchContext</code>让意图更加清晰。我其实更喜欢。</p><p id="3609" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">💥我们在Redux模式中使用带钩子的上下文(没有Redux)！</p></div><div class="ab cl ma mb hu mc" role="separator"><span class="md bw bk me mf mg"/><span class="md bw bk me mf mg"/><span class="md bw bk me mf"/></div><div class="ij ik il im in"><p id="4eef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">总结</strong></p><p id="a7f0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们看了三种不同的方式来使用定制钩子的上下文。总的来说，它们都遵循相同的两个步骤:</p><p id="cb23" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">步骤1:用<code class="fe lw lx ly lz b">React.creatContext()</code>创建一个提供者特设</p><p id="134a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">步骤2:创建一个React自定义钩子，从上下文返回状态和状态更新函数。</p><p id="5d09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，应用程序的其余部分可以使用自定义挂钩与上下文进行交互。</p><p id="839e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">以下是3个示例代码沙箱的链接:</strong></p><p id="894e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">A.<a class="ae kw" href="https://codesandbox.io/embed/chicago-dice-game-a-4djy5" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/embed/chicago-dice-game-a-4djy5</a></p><p id="709e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">B.https://codesandbox.io/embed/chicago-dice-game-b-iecy1<a class="ae kw" href="https://codesandbox.io/embed/chicago-dice-game-b-iecy1" rel="noopener ugc nofollow" target="_blank"/></p><p id="e728" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">C.【https://codesandbox.io/embed/chicago-dice-game-c-7kpit T4】</p><p id="2f35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">下面是Github对所有三个例子的回购:</strong></p><p id="d408" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/cherihung/react-provider-patterns" rel="noopener ugc nofollow" target="_blank">https://github.com/cherihung/react-provider-patterns</a></p></div></div>    
</body>
</html>