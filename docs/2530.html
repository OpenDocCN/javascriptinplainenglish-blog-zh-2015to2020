<html>
<head>
<title>JavaScript Best Practices — Bad Expressions and Statements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践——糟糕的表达式和语句</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-simple-expressions-b2b104d66eb6?source=collection_archive---------11-----------------------#2020-07-02">https://javascript.plainenglish.io/javascript-best-practices-simple-expressions-b2b104d66eb6?source=collection_archive---------11-----------------------#2020-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5ecf96b6ece10bcf797811eb804864ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*btNqnYB4KewMIJvX"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@memoreno?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Martin Moreno</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2e4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些在编写JavaScript代码时应该遵循的最佳实践。</p><h1 id="68df" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">当存在更简单的选择时，没有三元表达式</h1><p id="5f42" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当存在更简单的选择时，我们不应该写三元表达式。</p><p id="3344" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2e49" class="mn lc iq mj b gy mo mp l mq mr">let score = val ? val : 0</span></pre><p id="5434" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fa74" class="mn lc iq mj b gy mo mp l mq mr">let score = val || 0</span></pre><p id="7961" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，因为他们做同样的事情。</p><p id="bba7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe ms mt mu mj b">val</code>是falsy，那么在两个例子中都将返回0。</p><h1 id="0035" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在return、throw、continue或break语句之后没有无法访问的代码</h1><p id="fcd0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们编写这些语句，那么我们应该确保在某些情况下它后面的代码仍然是可访问的。</p><p id="f576" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该有这样的代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="30b4" class="mn lc iq mj b gy mo mp l mq mr">function foo () {<br/>  return true;<br/>  console.log('never');<br/>}</span></pre><p id="96df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">控制台日志不可访问，因为它出现在一个总是运行的<code class="fe ms mt mu mj b">return</code>语句之后。</p><h1 id="89ad" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">finally块中没有流控制语句</h1><p id="d1d3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在<code class="fe ms mt mu mj b">finally</code>块中使用流控制语句。</p><p id="d9a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript挂起<code class="fe ms mt mu mj b">try</code>和<code class="fe ms mt mu mj b">catch</code>块的流控制语句，直到<code class="fe ms mt mu mj b">finally</code>块的执行完成。</p><p id="3103" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以当<code class="fe ms mt mu mj b">finally</code>中使用<code class="fe ms mt mu mj b">return</code>、<code class="fe ms mt mu mj b">throw</code>、<code class="fe ms mt mu mj b">break</code>或<code class="fe ms mt mu mj b">continue</code>时，<code class="fe ms mt mu mj b">try</code>或<code class="fe ms mt mu mj b">catch</code>中的控制流语句被覆盖。</p><p id="c024" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，可能会导致意外的行为。</p><p id="90ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该写这样的代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0a39" class="mn lc iq mj b gy mo mp l mq mr">try {<br/>  // ...<br/>} catch (e) {<br/>  // ...<br/>} finally {<br/>  return 1;<br/>}</span></pre><h1 id="d07c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">关系运算符的左操作数不应被求反</h1><p id="b426" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有这样的代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f9f2" class="mn lc iq mj b gy mo mp l mq mr">if (!key in obj) {}</span></pre><p id="e1bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么只有<code class="fe ms mt mu mj b">key</code>被否定，这很可能是一个错误。</p><p id="6b92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该否定整个表达式:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fbf2" class="mn lc iq mj b gy mo mp l mq mr">if (!(key in obj)) {}</span></pre><h1 id="8801" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免不必要的呼叫和申请</h1><p id="778f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们只需要使用<code class="fe ms mt mu mj b">call</code>和<code class="fe ms mt mu mj b">apply</code>来改变函数内部<code class="fe ms mt mu mj b">this</code>的值。</p><p id="7b3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除此之外，我们可以使用spread操作符将数组条目扩展到参数中，而不是调用<code class="fe ms mt mu mj b">apply</code>。</p><p id="7be6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="343b" class="mn lc iq mj b gy mo mp l mq mr">sum.call(null, 1, 2, 3)</span></pre><p id="cd21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4d95" class="mn lc iq mj b gy mo mp l mq mr">sum.call(1, 2, 3)</span></pre><p id="96f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b474" class="mn lc iq mj b gy mo mp l mq mr">sum.call(...nums)</span></pre><h1 id="3fbc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要在对象上使用不必要的计算属性键</h1><p id="40f2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在对象上使用不必要的计算属性键。</p><p id="a2f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们没有用，可以简化。</p><p id="7a3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="14dd" class="mn lc iq mj b gy mo mp l mq mr">const user = { ['name']: 'james' };</span></pre><p id="c043" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9bfb" class="mn lc iq mj b gy mo mp l mq mr">const user = { name: 'james' };</span></pre><h1 id="aa92" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有不必要的构造函数</h1><p id="0146" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们的类中有一个空的构造函数，那么我们不需要它。</p><p id="526b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4ef9" class="mn lc iq mj b gy mo mp l mq mr">class Car {<br/>  constructor () {      <br/>  }<br/>}</span></pre><p id="ed31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为JavaScript将为我们提供一个空的构造函数。</p><h1 id="c657" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有不必要的转义字符的使用</h1><p id="6cf7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该用无用的方式来转义字符。</p><p id="b95b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该编写这样的代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4fdd" class="mn lc iq mj b gy mo mp l mq mr">let message = 'hell\o'</span></pre><h1 id="288e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要将导入、导出和析构的赋值重命名为相同的名称</h1><p id="9094" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">将导入、导出和重构的赋值重命名为相同的名称是没有意义的。</p><p id="10dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该这样做。</p><p id="5fdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6952" class="mn lc iq mj b gy mo mp l mq mr">import { foo as foo } from './config'</span></pre><p id="f993" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们只是写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8214" class="mn lc iq mj b gy mo mp l mq mr">import { foo } from './config'</span></pre><h1 id="25e1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">属性前没有空格</h1><p id="4444" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">属性前的空格是无用的，也不符合普遍接受的JavaScript代码格式约定。</p><p id="46f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该拥有它们。</p><p id="f3ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="eb99" class="mn lc iq mj b gy mo mp l mq mr">user .password</span></pre><p id="5f70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9856" class="mn lc iq mj b gy mo mp l mq mr">user.password</span></pre><h1 id="50fb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有语句</h1><p id="3f98" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用<code class="fe ms mt mu mj b">with</code>语句。</p><p id="7707" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在严格模式下不允许使用它们。</p><p id="7edc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，它们会创建具有混淆范围的变量。</p><p id="6765" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该写这样的东西:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5518" class="mn lc iq mj b gy mo mp l mq mr">with (obj) {...}</span></pre><h1 id="eab3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象属性之间的换行符保持一致</h1><p id="9dcc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们定义对象文字时，我们应该在每个属性后换行。</p><p id="6483" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，如果不溢出页面，我们可以在同一行中输入所有属性。</p><p id="983b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们要么写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="513b" class="mn lc iq mj b gy mo mp l mq mr">const user = { name: 'jame', age: 30, password: '123' }</span></pre><p id="4e89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="db6d" class="mn lc iq mj b gy mo mp l mq mr">const user = { <br/>  name: 'jame', <br/>  age: 30, <br/>  password: '123' <br/>}</span></pre><h1 id="cdbd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">块内无填充</h1><p id="25af" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在块内填充。</p><p id="76c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2a31" class="mn lc iq mj b gy mo mp l mq mr">if (user) {<br/>                           <br/>  const name = getName()<br/> <br/>}</span></pre><p id="4998" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7531" class="mn lc iq mj b gy mo mp l mq mr">if (user) {<br/>  const name = getName()<br/>}</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/e6778bacc848638e2bad81d849c5c8f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gx_16uF01mQLLstV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jmacca88?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">John Mccann</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4806" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="de9b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该有无用的空白。</p><p id="fc28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，当涉及到换行符时，我们应该格式化对象的一致性。</p><p id="416c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还应该确保我们的块中没有任何不可到达的代码。</p><h1 id="874c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">简明英语JavaScript</strong></h1><p id="2c35" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？在<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> plainenglish.io </strong> </a>和<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">找到它们订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>