<html>
<head>
<title>Creating custom JavaScript syntax with Babel</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Babel创建定制的JavaScript语法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-custom-javascript-syntax-with-babel-ee76e05a6390?source=collection_archive---------5-----------------------#2019-11-29">https://javascript.plainenglish.io/creating-custom-javascript-syntax-with-babel-ee76e05a6390?source=collection_archive---------5-----------------------#2019-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c767" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继我上一篇关于<a class="ae kl" href="https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation" rel="noopener ugc nofollow" target="_blank">编写自定义babel转换</a>的文章之后，今天我将向您展示如何使用Babel创建自定义JavaScript语法。</p><h1 id="eeac" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">概述</strong></h1><p id="c28c" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">让我在本文结尾向您展示我们将实现的目标:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="3eb1" class="ly kn iq lu b gy lz ma l mb mc">// ‘@@’ makes the function `foo` curried</span><span id="30b3" class="ly kn iq lu b gy md ma l mb mc">function @@ foo(a, b, c) {<br/>  return a + b + c;<br/>}</span><span id="da09" class="ly kn iq lu b gy md ma l mb mc">console.log(foo(1, 2)(3)); // 6</span></pre><p id="3665" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将创建一个<a class="ae kl" href="https://en.wikipedia.org/wiki/Currying" rel="noopener ugc nofollow" target="_blank">库里函数</a>语法<code class="fe me mf mg lu b">@@</code>。语法类似于<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" rel="noopener ugc nofollow" target="_blank">生成器函数</a>，除了在<code class="fe me mf mg lu b">function</code>关键字和函数名之间放置<code class="fe me mf mg lu b">@@</code>而不是<code class="fe me mf mg lu b">*</code>，例如<code class="fe me mf mg lu b">function @@ name(arg1, arge2)</code>。</p><p id="add8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本例中，您可以使用功能<code class="fe me mf mg lu b">foo</code>对<a class="ae kl" href="https://scotch.io/tutorials/javascript-functional-programming-explained-partial-application-and-currying" rel="noopener ugc nofollow" target="_blank">进行局部应用</a>。调用参数数量少于所需参数的<code class="fe me mf mg lu b">foo</code>将返回一个包含剩余参数的新函数:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="8686" class="ly kn iq lu b gy lz ma l mb mc">foo(1, 2, 3); // 6</span><span id="f951" class="ly kn iq lu b gy md ma l mb mc">const bar = foo(1, 2); // (n) =&gt; 1 + 2 + n<br/>bar(3); // 6</span></pre><blockquote class="mh mi mj"><p id="0e70" class="jn jo mk jp b jq jr js jt ju jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj kk ij bi translated"><em class="iq">我选择</em> <code class="fe me mf mg lu b"><em class="iq">@@</em></code> <em class="iq">的原因是变量名中不能有</em> <code class="fe me mf mg lu b"><em class="iq">@</em></code> <em class="iq">，所以</em> <code class="fe me mf mg lu b"><em class="iq">function @@foo() {}</em></code> <em class="iq">仍然是有效的语法。而</em> <code class="fe me mf mg lu b"><em class="iq">@</em></code> <em class="iq">这个“操作符”是用于</em> <a class="ae kl" href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841" rel="noopener"> <em class="iq">的装饰函数</em> </a> <em class="iq">但是我想用一些全新的东西，因此</em> <code class="fe me mf mg lu b"><em class="iq">@@</em></code> <em class="iq">。</em></p></blockquote><p id="2125" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了实现这一目标，我们将:</p><ul class=""><li id="9160" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">分叉巴别塔解析器</li><li id="3b7d" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">创建一个自定义的巴别塔转换插件</li></ul><p id="e2a9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">听起来不可能😨？</p><p id="77ea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">别担心，我会指导你每一步。希望在这篇文章结束时，你会成为同龄人中的通天塔大师。🤠</p><h1 id="c874" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">叉巴别塔</strong></h1><p id="b5f8" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">前往<a class="ae kl" href="https://github.com/babel/babel" rel="noopener ugc nofollow" target="_blank"> babel的Github repo </a>，点击页面左上角的“分叉”按钮。</p><figure class="lp lq lr ls gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nc"><img src="../Images/10b4a29e6ee280a94d74d55907646dca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qGimQHt56_e5VQ5vATkKFA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Forking Babel</figcaption></figure><p id="755f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这是你第一次分叉一个流行的开源项目，那么恭喜你！🎉</p><p id="c4da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将你的分叉的babel克隆到你的本地工作区，然后<a class="ae kl" href="https://github.com/tanhauhau/babel/blob/master/CONTRIBUTING.md#setup" rel="noopener ugc nofollow" target="_blank">设置它</a>:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="af3c" class="ly kn iq lu b gy lz ma l mb mc">$ git clone <a class="ae kl" href="https://github.com/tanhauhau/babel.git" rel="noopener ugc nofollow" target="_blank">https://github.com/tanhauhau/babel.git</a></span><span id="f6b3" class="ly kn iq lu b gy md ma l mb mc"><em class="mk"># set up</em><br/>$ cd babel<br/>$ make bootstrap<br/>$ make build</span></pre><p id="f87b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">同时，让我简单地向您介绍一下巴别塔知识库是如何组织的。</p><p id="4b56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Babel使用monorepo结构，所有的包，例如:<code class="fe me mf mg lu b">@babel/core</code>、<code class="fe me mf mg lu b">@babel/parser</code>、<code class="fe me mf mg lu b">@babel/plugin-transform-react-jsx</code>等都在<code class="fe me mf mg lu b">packages/</code>文件夹中:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="706d" class="ly kn iq lu b gy lz ma l mb mc">- doc<br/>- packages<br/>  - babel-core<br/>  - babel-parser<br/>  - babel-plugin-transform-react-jsx<br/>  - ...<br/>- Gulpfile.js<br/>- Makefile<br/>- ...</span></pre><blockquote class="mh mi mj"><p id="831a" class="jn jo mk jp b jq jr js jt ju jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">琐事:</em> </strong> <em class="iq"> Babel使用</em><a class="ae kl" href="https://opensource.com/article/18/8/what-how-makefile" rel="noopener ugc nofollow" target="_blank"><em class="iq">Makefile</em></a><em class="iq">进行自动化任务。对于构建任务，比如</em> <code class="fe me mf mg lu b"><em class="iq">make build</em></code> <em class="iq">，它会使用</em><a class="ae kl" href="https://gulpjs.com" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a><em class="iq">作为任务运行器。</em></p></blockquote></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="ed30" class="km kn iq bd ko kp nv kr ks kt nw kv kw kx nx kz la lb ny ld le lf nz lh li lj bi translated"><strong class="ak">AST代码解析速成班</strong></h1><p id="e0fe" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在我们继续之前，如果你对解析器和抽象语法树(AST)不熟悉，我强烈推荐查看<a class="ae kl" href="https://twitter.com/vaidehijoshi" rel="noopener ugc nofollow" target="_blank"> Vaidehi Joshi </a>的<a class="ae kl" href="https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff" rel="noopener">用AST提升你的解析游戏。</a></p><p id="d19f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">总结一下，这是babel解析您的代码时发生的情况:</p><ul class=""><li id="7f70" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">作为“字符串”的代码是一长串字符:<code class="fe me mf mg lu b">f</code>、<code class="fe me mf mg lu b">u</code>、<code class="fe me mf mg lu b">n</code>、<code class="fe me mf mg lu b">c</code>、<code class="fe me mf mg lu b">t</code>、<code class="fe me mf mg lu b">i</code>、<code class="fe me mf mg lu b">o</code>、<code class="fe me mf mg lu b">n</code>、<code class="fe me mf mg lu b"> </code>、<code class="fe me mf mg lu b">@</code>、<code class="fe me mf mg lu b">@</code>、<code class="fe me mf mg lu b">f</code>、…</li><li id="5a06" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">第一步叫做<strong class="jp ir">记号化</strong>，巴贝尔扫描每个角色，创建<em class="mk">记号</em>，像<code class="fe me mf mg lu b">function</code>、<code class="fe me mf mg lu b">@@</code>、<code class="fe me mf mg lu b">foo</code>、<code class="fe me mf mg lu b">(</code>、<code class="fe me mf mg lu b">a</code>、…</li><li id="7c66" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">然后，令牌通过一个解析器进行<strong class="jp ir">语法分析</strong>，在这里，babel基于<a class="ae kl" href="https://www.ecma-international.org/ecma-262/10.0/index.html#Title" rel="noopener ugc nofollow" target="_blank"> JavaScript语言规范</a>创建一个AST。</li></ul><p id="389e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想更深入地了解一般的编译器，Robert Nystrom的《打造解释器》是一个很好的选择。</p><blockquote class="mh mi mj"><p id="eb24" class="jn jo mk jp b jq jr js jt ju jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj kk ij bi translated"><em class="iq">不要被</em> <strong class="jp ir"> <em class="iq">编译器</em> </strong> <em class="iq">这个词吓到，它无非是解析你的代码并从中生成XXX。XXX可能是机器码，这是我们大多数人心目中的编译器；XXX可以兼容旧浏览器的JavaScript，Babel就是这种情况。</em></p></blockquote><h1 id="19b9" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">我们定制的巴别塔解析器</strong></h1><p id="6c5e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们将要处理的文件夹是<code class="fe me mf mg lu b">packages/babel-parser/</code>:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="4e1b" class="ly kn iq lu b gy lz ma l mb mc">- src/<br/>  - tokenizer/<br/>  - parser/<br/>  - plugins/<br/>    - jsx/<br/>    - typescript/<br/>    - flow/<br/>  - ...<br/>- test/</span></pre><p id="f179" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经讨论了<em class="mk">标记化</em>和<em class="mk">解析</em>，现在很清楚在哪里可以找到每个进程的代码。<code class="fe me mf mg lu b">plugins</code>文件夹包含扩展基本解析器和添加自定义语法的插件，如<code class="fe me mf mg lu b">jsx</code>和<code class="fe me mf mg lu b">flow</code>。</p><p id="2bd8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们来做一个<a class="ae kl" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank">测试驱动开发(TDD) </a>。我发现定义测试用例然后慢慢地用我们的方式“修复”它更容易。在不熟悉的代码库中尤其如此，TDD允许您“容易地”指出需要更改的代码位置。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="b036" class="ly kn iq lu b gy lz ma l mb mc">// filename: packages/babel-parser/test/curry-function.js</span><span id="1b33" class="ly kn iq lu b gy md ma l mb mc">import { parse } from ‘../lib’;<br/>function getParser(code) {<br/>  return () =&gt; parse(code, { sourceType: ‘module’ });<br/>}</span><span id="96b1" class="ly kn iq lu b gy md ma l mb mc">describe(‘curry function syntax’, function() {<br/>  it(‘should parse’, function() {<br/>    expect(getParser(`function @@ foo() {}`)()).toMatchSnapshot();<br/>  });<br/>});</span></pre><p id="9c50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以运行<code class="fe me mf mg lu b">TEST_ONLY=babel-parser TEST_GREP=”curry function” make test-only</code>来运行<code class="fe me mf mg lu b">babel-parser</code>的测试，并查看您的失败案例:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="633c" class="ly kn iq lu b gy lz ma l mb mc">SyntaxError: Unexpected token (1:9)</span><span id="7325" class="ly kn iq lu b gy md ma l mb mc">at Parser.raise (packages/babel-parser/src/parser/location.js:39:63)<br/>at Parser.raise [as unexpected] (packages/babel-parser/src/parser/util.js:133:16)<br/>at Parser.unexpected [as parseIdentifierName] (packages/babel-parser/src/parser/expression.js:2090:18)<br/>at Parser.parseIdentifierName [as parseIdentifier] (packages/babel-parser/src/parser/expression.js:2052:23)<br/>at Parser.parseIdentifier (packages/babel-parser/src/parser/statement.js:1096:52)</span></pre><blockquote class="mh mi mj"><p id="2c0b" class="jn jo mk jp b jq jr js jt ju jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj kk ij bi translated"><em class="iq">如果你发现扫描所有的测试用例需要时间，你可以直接调用</em> <code class="fe me mf mg lu b"><em class="iq">jest</em></code> <em class="iq">来运行测试:</em> <code class="fe me mf mg lu b"><em class="iq">BABEL_ENV=test node_modules/.bin/jest -u packages/babel-parser/test/curry-function.js</em></code></p></blockquote><p id="be89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的解析器在不应该出现的地方发现了2个看似无辜的<code class="fe me mf mg lu b">@</code>标记。</p><p id="1096" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我怎么知道？让我们启动手表模式，<code class="fe me mf mg lu b">make watch</code>，戴上我们的侦探帽🕵️‍，开始挖掘吧！</p><p id="1a6f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">追踪堆栈跟踪，将我们带到<code class="fe me mf mg lu b"><a class="ae kl" href="https://github.com/tanhauhau/babel/blob/feat/curry-function/packages/babel-parser/src/parser/expression.js#L2092" rel="noopener ugc nofollow" target="_blank">packages/babel-parser/src/parser/expression.js</a></code>，在那里它抛出<code class="fe me mf mg lu b">this.unexpected()</code>。</p><p id="67f3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们补充一些<code class="fe me mf mg lu b">console.log</code>:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="96fa" class="ly kn iq lu b gy lz ma l mb mc">// filename: packages/babel-parser/src/parser/expression.js<br/>parseIdentifierName(pos: number, liberal?: boolean): string {<br/>  if (this.match(tt.name)) {<br/>    // ...<br/>  } else {<br/>    console.log(this.state.type); // current token<br/>    console.log(this.lookahead().type); // next token<br/>    throw this.unexpected();<br/>  }<br/>}</span></pre><p id="388e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，两个令牌都是<code class="fe me mf mg lu b">@</code>令牌:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="1322" class="ly kn iq lu b gy lz ma l mb mc">TokenType {<br/>  label: '@',<br/>  // ...<br/>}</span></pre><p id="6eca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我怎么知道<code class="fe me mf mg lu b">this.state.type</code>和<code class="fe me mf mg lu b">this.lookahead().type</code>会给我当前和下一个令牌？</p><p id="6e57" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好吧，我以后会解释的。</p><p id="0d02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在继续之前，让我们回顾一下到目前为止我们所做的工作:</p><ul class=""><li id="78df" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">我们已经为<code class="fe me mf mg lu b">babel-parser</code>编写了一个测试用例</li><li id="ad46" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">我们运行<code class="fe me mf mg lu b">make test-only</code>来运行测试用例</li><li id="ccaa" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">我们已经通过<code class="fe me mf mg lu b">make watch</code>启动了观看模式</li><li id="67c7" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">我们已经了解了解析器的状态，并控制当前的令牌类型<code class="fe me mf mg lu b">this.state.type</code></li></ul><p id="4103" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们接下来要做的是:</p><p id="bc91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有两个连续的<code class="fe me mf mg lu b">@</code>，它不应该是单独的令牌，它应该是一个<code class="fe me mf mg lu b">@@</code>令牌，我们刚刚为curry函数定义的新令牌</p><p id="d1e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">新令牌:' @@' </strong></p><p id="2dce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们先来看看令牌类型是在哪里定义的:<a class="ae kl" href="https://github.com/tanhauhau/babel/blob/feat/curry-function/packages/babel-parser/src/tokenizer/types.js#L86" rel="noopener ugc nofollow" target="_blank">packages/babel-parser/src/tokenizer/types . js</a>。</p><p id="f800" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里您会看到一个令牌列表，因此让我们也添加新的令牌定义:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="c4a0" class="ly kn iq lu b gy lz ma l mb mc">// filename: packages/babel-parser/src/tokenizer/types.js<br/>export const types: { [name: string]: TokenType } = {<br/>  // ...<br/>  at: <strong class="lu ir">new</strong> TokenType(‘@’),<br/>  // add this here<br/>  atat: <strong class="lu ir">new</strong> TokenType(‘@@’),<br/>};</span></pre><p id="683a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，让我们看看在<em class="mk">令牌化</em>过程中令牌是在哪里创建的。在<code class="fe me mf mg lu b">babel-parser/src/tokenizer</code>中快速搜索<code class="fe me mf mg lu b">tt.at</code>会将我们带到<a class="ae kl" href="https://github.com/tanhauhau/babel/blob/da0af5fd99a9b747370a2240df3abf2940b9649c/packages/babel-parser/src/tokenizer/index.js#L790" rel="noopener ugc nofollow" target="_blank">packages/babel-parser/src/tokenizer/index . js</a></p><blockquote class="mh mi mj"><p id="fef3" class="jn jo mk jp b jq jr js jt ju jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj kk ij bi translated">嗯，在整个babel-parser中，标记类型是作为“tt”导入的。</p></blockquote><p id="6d23" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果有另一个<code class="fe me mf mg lu b">@</code>继承当前的<code class="fe me mf mg lu b">@</code>，让我们创建令牌<code class="fe me mf mg lu b">tt.atat</code>而不是<code class="fe me mf mg lu b">tt.at</code>:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="0c1b" class="ly kn iq lu b gy lz ma l mb mc">// filename: packages/babel-parser/src/tokenizer/index.js<br/>getTokenFromCode(code: number): void {<br/>  switch (code) {<br/>    // ...<br/>    case charCodes.atSign:<br/>      // if the next character is a `@`<br/>      if (this.input.charCodeAt(this.state.pos + 1) === charCodes.atSign) {<br/>        // create `tt.atat` instead<br/>        this.finishOp(tt.atat, 2);<br/>      } else {<br/>        this.finishOp(tt.at, 1);<br/>      }<br/>      return;<br/>      //...<br/>  }<br/>}</span></pre><p id="4638" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您再次运行测试，您将看到当前令牌和下一个令牌都已更改:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="0025" class="ly kn iq lu b gy lz ma l mb mc">// current token<br/>TokenType {<br/>  label: ‘@@’,<br/>  // ...<br/>}</span><span id="8d0f" class="ly kn iq lu b gy md ma l mb mc">// next token<br/>TokenType {<br/>  label: ‘name’,<br/>  // ...<br/>}</span></pre><p id="5538" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">耶！看起来不错，让我们继续。</p><p id="03fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">新解析器</strong></p><p id="a014" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们继续之前，让我们检查一下AST 中是如何表示<a class="ae kl" href="https://lihautan.com/babel-ast-explorer/#?eyJiYWJlbFNldHRpbmdzIjp7InZlcnNpb24iOiI3LjYuMCJ9LCJ0cmVlU2V0dGluZ3MiOnsiaGlkZUVtcHR5Ijp0cnVlLCJoaWRlTG9jYXRpb24iOnRydWUsImhpZGVUeXBlIjp0cnVlfSwiY29kZSI6ImZ1bmN0aW9uICogZm9vKCkge30ifQ==" rel="noopener ugc nofollow" target="_blank">生成器函数的:</a></p><figure class="lp lq lr ls gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nc"><img src="../Images/ef46e70e4d3ebfaaf1ab28c461ba8cd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uH4a_tomeFUb2Ekkt-Z8LA.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">AST for generator function</figcaption></figure><p id="aaa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如您所见，生成器函数由<code class="fe me mf mg lu b">FunctionDeclaration</code>的<code class="fe me mf mg lu b">generator: true </code>属性表示。</p><p id="c0b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，如果它是一个curry函数，我们也可以添加<code class="fe me mf mg lu b">FunctionDeclaratio</code>的一个<code class="fe me mf mg lu b">curry: true</code>属性:</p><figure class="lp lq lr ls gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi nc"><img src="../Images/9e4a9089be2dd18cf2757eb73ca7cbd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H9rXBne9m3QahJOtfYoX4g.png"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">AST for curry function</figcaption></figure><p id="3c24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在有一个计划，让我们实施它。</p><p id="8e46" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">快速搜索"<em class="mk"> FunctionDeclaration" </em>，我们会在<a class="ae kl" href="https://github.com/tanhauhau/babel/blob/da0af5fd99a9b747370a2240df3abf2940b9649c/packages/babel-parser/src/parser/statement.js#L1030" rel="noopener ugc nofollow" target="_blank">packages/babel-parser/src/parser/statement . js</a>中找到一个名为<code class="fe me mf mg lu b">parseFunction</code>的函数，在这里我们会发现一行设置了“generator”属性，让我们再添加一行:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="5fcb" class="ly kn iq lu b gy lz ma l mb mc">// filename: packages/babel-parser/src/parser/statement.js<br/>export default class StatementParser extends ExpressionParser {<br/>  // ...<br/>  parseFunction&lt;T: N.NormalFunction&gt;(<br/>    node: T,<br/>    statement?: number = FUNC_NO_FLAGS,<br/>    isAsync?: boolean = false<br/>  ): T {<br/>    // ...<br/>    node.generator = this.eat(tt.star);<br/>    // add this line<br/>    node.curry = this.eat(tt.atat);<br/>  }<br/>}</span></pre><p id="5423" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你再次运行测试，你会惊奇地发现它竟然通过了！</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="cb46" class="ly kn iq lu b gy lz ma l mb mc">PASS packages/babel-parser/test/curry-function.js</span><span id="554e" class="ly kn iq lu b gy md ma l mb mc">curry function syntax<br/>✓ should parse (12ms)</span></pre><p id="6fbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就这样？我们是如何奇迹般地修复它的？</p><p id="b571" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将简要地解释解析是如何工作的，在这个过程中，希望您能理解这一行代码的变化。</p><p id="58d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">解析如何工作</strong></p><p id="04db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了来自<em class="mk">记号赋予器</em>的记号列表，解析器一个接一个地使用记号并构造AST。解析器使用语言语法规范来决定如何使用标记，接下来应该使用哪个标记。</p><p id="bb43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">语法规范如下所示:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="00f1" class="ly kn iq lu b gy lz ma l mb mc">...<br/>ExponentiationExpression -&gt; UnaryExpression<br/>UpdateExpression ** ExponentiationExpression<br/>MultiplicativeExpression -&gt; ExponentiationExpression<br/>MultiplicativeExpression (“*” or “/” or “%”) ExponentiationExpression<br/>AdditiveExpression -&gt; MultiplicativeExpression<br/>AdditiveExpression + MultiplicativeExpression<br/>AdditiveExpression - MultiplicativeExpression<br/>...</span></pre><p id="e7e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它解释了每个表达式/语句的优先级。例如，<code class="fe me mf mg lu b">AdditiveExpression</code>由以下两者之一组成:</p><ul class=""><li id="e32b" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">一个<code class="fe me mf mg lu b">MultiplicativeExpression</code>，或者</li><li id="c377" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">一个<code class="fe me mf mg lu b">AdditiveExpression</code>后跟一个<code class="fe me mf mg lu b">+</code>操作员令牌，后跟一个<code class="fe me mf mg lu b">MultiplicativeExpression</code>，或者</li><li id="1b42" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">一个<code class="fe me mf mg lu b">AdditiveExpression</code>后跟<code class="fe me mf mg lu b">-</code>操作符令牌，再后跟<code class="fe me mf mg lu b">MultiplicativeExpression</code>。</li></ul><p id="e933" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以如果你有一个表达式<code class="fe me mf mg lu b">1 + 2 * 3</code>，它会像:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="6b04" class="ly kn iq lu b gy lz ma l mb mc">(AdditiveExpression “+” 1 (MultiplicativeExpression “*” 2 3))</span></pre><p id="d717" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">代替</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="28fd" class="ly kn iq lu b gy lz ma l mb mc">(MultiplicativeExpression “*” (AdditiveExpression “+” 1 2) 3)</span></pre><p id="a89f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据这些规则，我们将它们翻译成解析器代码:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="da95" class="ly kn iq lu b gy lz ma l mb mc">class Parser {<br/>  // ...<br/>  parseAdditiveExpression() {<br/>    const left = this.parseMultiplicativeExpression();<br/>    // if the current token is `+` or `-`<br/>    if (this.match(tt.plus) || this.match(tt.minus)) {<br/>      const operator = this.state.type;<br/>      // move on to the next token<br/>      this.nextToken();<br/>      const right = this.parseMultiplicativeExpression();</span><span id="3787" class="ly kn iq lu b gy md ma l mb mc">      // create the node<br/>      this.finishNode(<br/>        {<br/>          operator,<br/>          left,<br/>          right,<br/>        },<br/>        'BinaryExpression'<br/>      );<br/>    } else {<br/>      // return as MultiplicativeExpression<br/>      return left;<br/>    }<br/>  }<br/>}</span></pre><p id="d32e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mk">这是一个虚构的代码，过度简化了巴别塔有什么，但我希望你能得到它的要点。</em></p><p id="60e2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您在这里看到的，解析器本质上是递归的，它从最低优先级到最高优先级的表达式/语句。例:<code class="fe me mf mg lu b">parseAdditiveExpression</code>调用<code class="fe me mf mg lu b">parseMultiplicativeExpression</code>，T11又调用<code class="fe me mf mg lu b">parseExponentiationExpression</code>，T12又调用…这个递归过程被称为<a class="ae kl" href="https://craftinginterpreters.com/parsing-expressions.html#recursive-descent-parsing" rel="noopener ugc nofollow" target="_blank">递归下降解析</a>。</p><p id="1537" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">这.吃，这.配，这.下</strong></p><p id="ee7c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你已经注意到，在我上面的例子中，我使用了一些效用函数，如<code class="fe me mf mg lu b">this.eat</code>、<code class="fe me mf mg lu b">this.match</code>、<code class="fe me mf mg lu b">this.next</code>等。这些是babel parser的内部函数，但是它们在解析器中也非常普遍:</p><ul class=""><li id="35af" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated"><strong class="jp ir"> this.match </strong>返回一个<code class="fe me mf mg lu b">boolean</code>指示当前令牌是否匹配条件</li><li id="e167" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir"> this.next </strong>将令牌列表向前移动，指向下一个令牌</li><li id="c909" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir"> this.eat </strong>返回什么<code class="fe me mf mg lu b">this.match</code>返回什么，如果<code class="fe me mf mg lu b">this.match</code>返回<code class="fe me mf mg lu b">true</code>，就做<code class="fe me mf mg lu b">this.next</code></li><li id="5d1a" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir"> this.eat </strong>通常用于可选操作符，如生成器函数中的<code class="fe me mf mg lu b">*</code>、语句末尾的<code class="fe me mf mg lu b">;</code>以及typescript类型中的<code class="fe me mf mg lu b">?</code>。</li><li id="de59" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><strong class="jp ir"> this.lookahead </strong>获取下一个令牌而不向前移动以对当前节点做出决定</li></ul><p id="129f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您再看一下我们刚刚更改的解析器代码，现在更容易理解了。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="5658" class="ly kn iq lu b gy lz ma l mb mc">// filename: packages/babel-parser/src/parser/statement.js</span><span id="e93e" class="ly kn iq lu b gy md ma l mb mc">export default class StatementParser extends ExpressionParser {<br/>  parseStatementContent(/* …*/) {<br/><em class="mk">    // …<br/>    // NOTE: we call match to check the current token</em><br/>    if (this.match(tt._function)) {<br/>      this.next();<br/><em class="mk">      // NOTE: function statement has a higher precendence than a generic statement<br/></em>      this.parseFunction();<br/>    }<br/>  }</span><span id="7fbf" class="ly kn iq lu b gy md ma l mb mc">  // …<br/>  parseFunction(/* … */) {<br/><em class="mk">    // NOTE: we call eat to check whether the optional token exists</em><br/>  node.generator = this.eat(tt.star);<br/><em class="mk">    </em><strong class="lu ir"><em class="mk">node.curry = this.eat(tt.atat);</em></strong><br/>    node.id = this.parseFunctionId();<br/>  }<br/>}</span></pre><p id="b362" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我知道我没有很好地解释解析器是如何工作的。以下是我从中学到的一些资源，我强烈推荐它们:</p><ul class=""><li id="2753" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">罗伯特·尼斯特罗姆<a class="ae kl" href="https://twitter.com/munificentbob?lang=en" rel="noopener ugc nofollow" target="_blank">制作口译员</a></li><li id="dc16" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">佐治亚理工学院提供的免费Udacity课程:“编译器:理论与实践”</li></ul></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="6aca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会好奇我是如何在Babel AST浏览器中可视化定制语法的，在那里我向你展示了AST中新的“curry”属性。</p><p id="c05c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为我在Babel AST Explorer中添加了一个新功能，您可以上传您的自定义解析器！</p><p id="92b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您转到<code class="fe me mf mg lu b">packages/babel-parser/lib</code>，您会发现您的解析器的编译版本和源映射。打开Babel AST Explorer的抽屉，您会看到一个上传自定义解析器的按钮。拖动<code class="fe me mf mg lu b">packages/babel-parser/lib/index.js</code>,您将看到通过自定义解析器生成的AST！</p><figure class="lp lq lr ls gt nd gh gi paragraph-image"><div role="button" tabindex="0" class="ne nf di ng bf nh"><div class="gh gi oa"><img src="../Images/fd6c5f4e9e66a01adc4d49488c3c8465.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*llW_K3unLgxh4xpjop4_Ig.gif"/></div></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Uploading custom parser</figcaption></figure></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="426e" class="km kn iq bd ko kp nv kr ks kt nw kv kw kx nx kz la lb ny ld le lf nz lh li lj bi translated"><strong class="ak">我们的巴别塔插件</strong></h1><p id="018e" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">自定义的巴别塔解析器完成后，让我们继续编写我们的巴别塔插件。</p><p id="1d56" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是在此之前，你可能会对我们如何使用自定义的babel解析器有一些疑问，特别是对于我们现在正在使用的构建栈？</p><p id="dd0c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">别担心。一个巴别塔插件可以提供一个定制的解析器，这是<a class="ae kl" href="https://babeljs.io/docs/en/babel-parser#will-the-babel-parser-support-a-plugin-system" rel="noopener ugc nofollow" target="_blank">在巴别塔网站</a>上记录的</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="9f53" class="ly kn iq lu b gy lz ma l mb mc">// filename: babel-plugin-transformation-curry-function.js<br/>import customParser from ‘./custom-parser’;</span><span id="2a89" class="ly kn iq lu b gy md ma l mb mc">export default function ourBabelPlugin() {<br/>  return {<br/>    parserOverride(code, opts) {<br/>      return customParser.parse(code, opts);<br/>    },<br/>  };<br/>}</span></pre><p id="1446" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自从我们推出了巴别塔解析器，所有现有的巴别塔解析器选项或内置插件仍然可以完美工作。</p><p id="faf7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这个疑问，让我们看看如何使我们的curry函数可流通？<em class="mk">(不完全确定有没有这个词)</em></p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="d94c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们开始之前，如果你急切地想把我们的插件添加到你的构建系统中，你会注意到curry函数被编译成了一个普通的函数。</p><p id="a7e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是因为解析+转换后，babel会使用<a class="ae kl" href="https://babeljs.io/docs/en/babel-generator" rel="noopener ugc nofollow" target="_blank"> @babel/generator </a>从转换后的AST生成代码。因为<code class="fe me mf mg lu b">@babel/generator</code>不知道我们添加的新的<code class="fe me mf mg lu b">curry</code>属性，所以它将被省略。</p><blockquote class="mh mi mj"><p id="ca87" class="jn jo mk jp b jq jr js jt ju jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj kk ij bi translated"><em class="iq">如果有一天curry函数成为了新的JavaScript语法，你可能想做一个pull请求在这里</em><a class="ae kl" href="https://github.com/tanhauhau/babel/blob/da0af5fd99a9b747370a2240df3abf2940b9649c/packages/babel-generator/src/generators/methods.js#L82" rel="noopener ugc nofollow" target="_blank"><em class="iq"/></a><em class="iq">！</em></p></blockquote></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><p id="c2aa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">好了，为了使我们的函数可处理，我们可以用一个<code class="fe me mf mg lu b">currying</code>辅助高阶函数来包装它:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="2b8b" class="ly kn iq lu b gy lz ma l mb mc">function currying(fn) {<br/>  const numParamsRequired = fn.length;<br/>  function curryFactory(params) {<br/>    return function (...args) {<br/>      const newParams = params.concat(args);<br/>      if (newParams.length &gt;= numParamsRequired) {<br/>        return fn(...newParams);<br/>      }<br/>      return curryFactory(newParams);<br/>    }<br/>  }<br/>  return curryFactory([]);<br/>}</span></pre><blockquote class="mh mi mj"><p id="985e" class="jn jo mk jp b jq jr js jt ju jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj kk ij bi translated"><em class="iq">如果你想学习如何编写一个curry函数，你可以通过</em><a class="ae kl" href="https://twitter.com/zhirzh" rel="noopener ugc nofollow" target="_blank"><em class="iq">Shirsh Zibbu</em></a>阅读JS   <em class="iq">中的这个</em> <a class="ae kl" href="https://hackernoon.com/currying-in-js-d9ddc64f162e" rel="noopener ugc nofollow" target="_blank"> <em class="iq"/></a></p></blockquote><p id="138c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，当我们转换curry函数时，我们可以将其转换为以下形式:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="68e9" class="ly kn iq lu b gy lz ma l mb mc">// from<br/>function @@ foo(a, b, c) {<br/>  return a + b + c;<br/>}</span><span id="5044" class="ly kn iq lu b gy md ma l mb mc">// to<br/>const foo = currying(function foo(a, b, c) {<br/>  return a + b + c;<br/>})</span></pre><blockquote class="mh mi mj"><p id="ab33" class="jn jo mk jp b jq jr js jt ju jv jw jx ml jz ka kb mm kd ke kf mn kh ki kj kk ij bi translated"><em class="iq">我们先忽略JavaScript中的</em> <a class="ae kl" href="https://scotch.io/tutorials/understanding-hoisting-in-javascript" rel="noopener ugc nofollow" target="_blank"> <em class="iq">函数提升</em> </a> <em class="iq">，在这里可以在定义之前调用' foo '。</em></p></blockquote><p id="631f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你已经阅读了我的<a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/step-by-step-guide-for-writing-a-babel-transformation">关于巴别塔转换的分步指南</a>，那么编写这个转换应该是可以管理的:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="dc4f" class="ly kn iq lu b gy lz ma l mb mc">// filename: babel-plugin-transformation-curry-function.js</span><span id="a0bd" class="ly kn iq lu b gy md ma l mb mc">export default function ourBabelPlugin() {<br/>  return {<br/>    visitor: {<br/>      FunctionDeclaration(path) {<br/>        if (path.get(‘curry’).node) {<br/>          // const foo = curry(function () { … });<br/>          path.node.curry = false;<br/>          path.replaceWith(<br/>            t.variableDeclaration(‘const’, [<br/>              t.variableDeclarator(<br/>                t.identifier(path.get(‘id.name’).node),<br/>                t.callExpression(t.identifier(‘currying’), [<br/>                  t.toExpression(path.node),<br/>                ])<br/>              ),<br/>            ])<br/>          );<br/>        }<br/>      },<br/>    },<br/>  };<br/>}</span></pre><p id="d2d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是我们如何提供<code class="fe me mf mg lu b">currying</code>功能？</p><p id="d843" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有两种方法:</p><ol class=""><li id="20de" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk ob mu mv mw bi translated"><strong class="jp ir">假设已经在全局范围内声明了“currying”。</strong></li></ol><p id="84e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，你的工作已经完成了。</p><p id="677c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果没有定义' currying '，那么在执行编译后的代码时，运行时会喊出“<em class="mk"> currying未定义”</em>，就像<a class="ae kl" href="https://www.google.com/search?q=regeneratorRuntime+is+not+defined" rel="noopener ugc nofollow" target="_blank">“regenerator runtime未定义”</a>一样。</p><p id="1232" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，你可能必须教育用户安装<code class="fe me mf mg lu b">currying</code> polyfills，以便使用你的<code class="fe me mf mg lu b">babel-plugin-transformation-curry-function</code>。</p><p id="da2a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> 2。使用</strong> <code class="fe me mf mg lu b"><strong class="jp ir">@babel/helpers</strong></code></p><p id="16a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以给<code class="fe me mf mg lu b">@babel/helpers</code>添加一个新的助手，当然你不太可能把它合并到正式的<code class="fe me mf mg lu b">@babel/helpers</code>中，所以你必须想办法让<code class="fe me mf mg lu b">@babel/core</code>解析到你的<code class="fe me mf mg lu b">@babel/helpers</code>:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="fda0" class="ly kn iq lu b gy lz ma l mb mc">// filename: package.json</span><span id="5c2e" class="ly kn iq lu b gy md ma l mb mc">{<br/>  "resolutions": {<br/>    "@babel/helpers": "7.6.0 — your-custom-forked-version",<br/>  }<br/>}</span></pre><p id="3749" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">免责声明:</strong> <em class="mk">我没有亲自尝试过这个，但我相信它会起作用。如果你在尝试这个的时候遇到了问题，</em><a class="ae kl" href="https://twitter.com/lihautan" rel="noopener ugc nofollow" target="_blank"><em class="mk">DM me</em></a><em class="mk">，我很乐意和你讨论。</em></p><p id="497f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在<code class="fe me mf mg lu b">@babel/helpers</code>中添加一个新的助手函数非常容易。</p><p id="2b89" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">转到<a class="ae kl" href="https://github.com/tanhauhau/babel/blob/feat/curry-function/packages/babel-helpers/src/helpers.js" rel="noopener ugc nofollow" target="_blank">packages/babel-helpers/src/helpers . js</a>并添加一个新条目:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="9ae8" class="ly kn iq lu b gy lz ma l mb mc">helpers.currying = helper(“7.6.0”)`<br/>  export default function currying(fn) {<br/>    const numParamsRequired = fn.length;<br/>    function curryFactory(params) {<br/>      return function (…args) {<br/>        const newParams = params.concat(args);<br/>        if (newParams.length &gt;= numParamsRequired) {<br/>          return fn(…newParams);<br/>        }<br/>        return curryFactory(newParams);<br/>      }<br/>    }<br/>    return curryFactory([]);<br/>  }<br/>`;</span></pre><p id="7746" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">助手标签功能指定所需的<code class="fe me mf mg lu b">@babel/core</code>版本。这里的诀窍是<code class="fe me mf mg lu b">export default</code>的<code class="fe me mf mg lu b">currying</code>功能。</p><p id="e0a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要使用助手，只需调用<code class="fe me mf mg lu b">this.addHelper()</code>:</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="ce00" class="ly kn iq lu b gy lz ma l mb mc">path.replaceWith(<br/>  t.variableDeclaration(‘const’, [<br/>    t.variableDeclarator(<br/>      t.identifier(path.get(‘id.name’).node),<br/>      t.callExpression(this.addHelper(“currying”), [<br/>        t.toExpression(path.node),<br/>      ])<br/>    ),<br/>  ])<br/>);</span></pre><p id="8f2d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果需要的话，<code class="fe me mf mg lu b">this.addHelper</code>会在文件的顶部注入帮助器，并返回一个<code class="fe me mf mg lu b">Identifier</code>给注入的函数。</p><h1 id="cfa4" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">结束语</strong></h1><p id="713d" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们已经看到了如何修改巴别塔解析器函数，编写我们自己的巴别塔转换插件(<em class="mk">这很简短，主要是因为我在以前的帖子</em>  <em class="mk"> ) </em>中详细介绍了 <a class="ae kl" rel="noopener ugc nofollow" target="_blank" href="/step-by-step-guide-for-writing-a-babel-transformation"> <em class="mk">)，简要介绍了<code class="fe me mf mg lu b">@babel/generator</code>，以及我们如何通过<code class="fe me mf mg lu b">@babel/helpers</code>添加助手函数。</em></a></p><p id="9e55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一路上，我们上了一堂关于解析器如何工作的速成课，我会在底部提供“<strong class="jp ir">进一步阅读”</strong>的链接。</p><p id="cbce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们上面经历的步骤类似于定义一个新的JavaScript规范时<a class="ae kl" href="https://github.com/tc39/proposals" rel="noopener ugc nofollow" target="_blank"> TC39提案</a>T3】流程的一部分。当提出一个新的规范时，提案的支持者通常会编写多份文件或撰写概念验证演示。正如您所看到的，派生一个解析器或编写polyfills并不是这个过程中最难的部分，而是定义问题空间、计划和思考用例以及收集来自社区的意见和建议。为此，我要感谢提案倡导者，感谢他们努力推动JavaScript语言向前发展。</p><p id="4173" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，如果你想看到我们到目前为止所做的代码的全貌，你可以从Github 查看一下<a class="ae kl" href="https://github.com/tanhauhau/babel/compare/3a7b6e1c2...b793efad1" rel="noopener ugc nofollow" target="_blank">。</a></p></div><div class="ab cl no np hu nq" role="separator"><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt nu"/><span class="nr bw bk ns nt"/></div><div class="ij ik il im in"><h1 id="0743" class="km kn iq bd ko kp nv kr ks kt nw kv kw kx nx kz la lb ny ld le lf nz lh li lj bi translated"><strong class="ak">编者按</strong></h1><p id="41e8" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我已经在巴别塔库上工作了一段时间，但是我以前从未给巴别塔解析器添加过新的语法。我的大部分贡献只是修复bug和规范遵从特性。</p><p id="9288" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，创建一种新语法的想法已经在我的脑海中存在了一段时间。所以我抓住机会写了一篇博客来尝试一下。看到它像预期的那样工作是一种令人兴奋的体验。</p><p id="23fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有能力操纵你正在写的语言的语法是令人振奋的。它使我们有可能编写更少的代码或更简单的代码，并将复杂性转移到编译时。正如<code class="fe me mf mg lu b">async-await</code>如何解决回调地狱和承诺链地狱。</p><p id="4d76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这篇文章启发了你一些伟大的想法，并且你希望与某人讨论它，你总是非常欢迎通过<a class="ae kl" href="https://twitter.com/lihautan" rel="noopener ugc nofollow" target="_blank"> Twitter </a>与我联系。</p><h1 id="fa1d" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated"><strong class="ak">延伸阅读</strong></h1><p id="cbba" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">关于编译器:</p><ul class=""><li id="10b8" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated"><a class="ae kl" href="https://craftinginterpreters.com/introduction.html" rel="noopener ugc nofollow" target="_blank">制作口译员</a>作者<a class="ae kl" href="https://twitter.com/munificentbob?lang=en" rel="noopener ugc nofollow" target="_blank">罗伯特·尼斯特罗姆</a></li><li id="36a4" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><a class="ae kl" href="https://www.udacity.com/course/compilers-theory-and-practice--ud168" rel="noopener ugc nofollow" target="_blank">免费Udacity课程:“编译器:理论与实践”</a>，由佐治亚理工学院提供</li><li id="9f8e" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><a class="ae kl" href="https://medium.com/basecs/leveling-up-ones-parsing-game-with-asts-d7a6fc2400ff" rel="noopener">用ASTs提升自己的解析游戏</a>作者<a class="ae kl" href="https://twitter.com/vaidehijoshi" rel="noopener ugc nofollow" target="_blank"> Vaidehi Joshi </a></li></ul><p id="0cb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">杂项:</p><ul class=""><li id="029c" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated"><a class="ae kl" href="https://scotch.io/tutorials/understanding-hoisting-in-javascript" rel="noopener ugc nofollow" target="_blank">理解JavaScript中的吊装</a>作者<a class="ae kl" href="https://twitter.com/emabishi" rel="noopener ugc nofollow" target="_blank">马比斯·瓦基奥</a></li><li id="a032" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><a class="ae kl" href="https://hackernoon.com/currying-in-js-d9ddc64f162e" rel="noopener ugc nofollow" target="_blank">在JS </a>中被<a class="ae kl" href="https://twitter.com/zhirzh" rel="noopener ugc nofollow" target="_blank"> Shirsh Zibbu </a>奉承</li><li id="0db5" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><a class="ae kl" href="https://github.com/tc39/proposals" rel="noopener ugc nofollow" target="_blank"> TC39提案</a></li><li id="199b" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><a class="ae kl" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank"> TC39工艺文件</a></li></ul></div></div>    
</body>
</html>