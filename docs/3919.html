<html>
<head>
<title>How Child Classes and Inheritance work in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中子类和继承的工作方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-classes-inheritance-f4a1b516b160?source=collection_archive---------5-----------------------#2020-11-03">https://javascript.plainenglish.io/javascript-classes-inheritance-f4a1b516b160?source=collection_archive---------5-----------------------#2020-11-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a449" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript类、扩展和超的介绍</h2></div><p id="3093" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">大家好，今天我又回到了JavaScript类介绍的第二部分。</p><p id="db52" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天，我要覆盖子类、继承、<strong class="ke io"> <em class="ky">、</em> </strong>和<strong class="ke io"> <em class="ky">超</em> </strong>关键词。所以，事不宜迟，让我们开始派对吧。</p><p id="7ed2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的上一篇文章中，我将JavaScript类与Chipotle进行了比较。事实上，我说过“我喜欢把一个类想象成Chipotle人们进去，出来的时候带着墨西哥卷饼。”你可能知道，你不仅限于墨西哥卷饼。你也可以吃墨西哥卷饼碗、墨西哥玉米卷或墨西哥玉米卷沙拉，但所有这些食物在配料方面仍然和墨西哥玉米卷饼有相同的选择。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi kz"><img src="../Images/8a12569ac28e6659892b0967e8293960.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aLM-WlQiL-0hRWR-9aIRxg.jpeg"/></div></div></figure><p id="fd14" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，修正一下我之前的说法，我喜欢把“父类”想象成Chipotle人们进去，出来就有饭吃。但是那些食物呢？它们可能彼此不同，但它们是由相同的成分制成的。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ll"><img src="../Images/5a08fe118eb75c88834901dfe2a33496.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3pMWiD4FGaRKy1uy3mfk9A.jpeg"/></div></div></figure><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lm"><img src="../Images/21a5e612cbb58fefe3344ea0d5770fd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1392/format:webp/1*FV-soB1v7WigzHDM2anlIQ.jpeg"/></div></div></figure><p id="287b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了创建一个父类，我们需要考虑的第一件事是所有的饭菜有什么共同点。无论你是吃墨西哥卷饼、墨西哥玉米卷、墨西哥玉米卷碗还是墨西哥玉米卷沙拉，它们都有以下选择:生菜、豆类、蛋白质、蔬菜、奶酪、番石榴、酸奶油和沙拉。对吗？既然你可以在不添加这些配料的情况下做墨西哥玉米沙拉，那就让我们给自己的父母做一份墨西哥玉米沙拉吧。</p><p id="e33d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">步骤1:类声明</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ln"><img src="../Images/888f69c3c371b07a815a1d1f6804003b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7bqSbPlUrLkSPHxTQkAwyA.png"/></div></div></figure><p id="1332" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然我们已经声明了TacoSalad类，我们想添加<strong class="ke io"> <em class="ky">构造函数</em> </strong>方法。请记住，构造函数方法就像你的墨西哥卷饼艺术家(在这种情况下是你的膳食艺术家)，这意味着我们需要给它所有配料的参数来制作墨西哥玉米沙拉，就像这样。</p><p id="3e5b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">步骤2:添加构造函数和方法</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lo"><img src="../Images/6e4e214f8f9b2f86221fb8ab87706bd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VayE4uZfBcZ3liw8ZekkhA.png"/></div></div></figure><p id="a96b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以用我们选择的任何配料做沙拉，这并不坏，对吗？但是，如果一个顾客进来，他们想要一个玉米煎饼碗呢？我们可以创建一个名为玉米煎饼碗的新类，但是玉米煎饼碗和墨西哥玉米卷沙拉看起来非常相似。这就像有一个玉米卷沙拉配料站，一个玉米卷碗配料站，一个玉米卷配料站，一个玉米卷配料站。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/6e235f5ce00e5b7d8db440596c024289.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*38FJ1nq6dellwg6HOCddKA.jpeg"/></div></figure><p id="334f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那是相当多余的，对吗？相反，我们可以将大米添加到配料站，只在需要的时候添加到食物中。这将是一个使用<strong class="ke io"> <em class="ky">扩展</em> </strong>关键字的好机会；我们可以使用扩展来创建一个类，它是TacoSalad的子类。子类将继承父类的所有键值对和方法…有点像我继承了我父亲的发际线。让我们来看看这是如何工作的。</p><p id="b382" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">步骤1:带有扩展的类声明</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lq"><img src="../Images/ba95df8b842618f066ee74817abc7a6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GSJgdNFHFxnoYEPZhvadGQ.png"/></div></div></figure><p id="0bad" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然我们已经声明了我们的BurritoBowl类，我们需要给它一个<strong class="ke io"> <em class="ky">构造函数</em> </strong>方法，就像我们对我们的taco沙拉类所做的那样，但是我们要在构造函数中放什么呢？对我来说，它看起来像一个墨西哥卷饼碗，除了它在一层米饭上之外，它的配料和玉米卷沙拉一样，所以让我们给构造函数添加一个riceType参数。</p><p id="fe09" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第2步:添加一个构造函数方法</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lr"><img src="../Images/5d2464d6b6d17e2b894f14e66b7ac1da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PRCSjdoXUN8fXO5jULNgzQ.png"/></div></div></figure><p id="44ae" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这一点上，如果我们实例化一个新的BurritoBowl实例，我们将会得到一个错误，因为我们正在扩展玉米沙拉类，但是我们没有使用<strong class="ke io"> <em class="ky"> super </em> </strong>关键字。<strong class="ke io"> <em class="ky">构造函数</em> </strong>可以使用super关键字调用父类(或“super”)的构造函数，允许子类从其父类继承所有的键值对和方法。哇，那个关键词真的很棒！…它将为我们节省大量的代码。让我们看看它是如何工作的。</p><p id="ee51" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第三步:添加超级关键词</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ls"><img src="../Images/567fb97c6bde7bd338cf0f1b8c8093ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v6Km5-9kAyMfruY4zpevTg.png"/></div></div></figure><p id="c0a5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们创建一个新的BurritoBowl实例，看看它是如何工作的！请注意，因为我们的BurritoBowl接受riceType的一个额外参数，所以我们将把它包含在BurritoBowl <strong class="ke io"> <em class="ky">构造函数</em> </strong>中，但是，因为taco沙拉不接受这个参数，所以我们将它排除在<strong class="ke io"> <em class="ky">超级</em> </strong>之外。</p><p id="a650" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">步骤4:实例化类的实例</p><p id="7550" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">//向fajita蔬菜数组添加更多内容</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lt"><img src="../Images/00d2bcb36036b48e64a0a3fdd4357421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gr6DZqOnaEpyNq4BcMR9UA.png"/></div></div></figure><p id="7be0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，如果我们记录new膳食(我们新的BurritoBowl实例)，您可以看到它继承了TacoSalad的键值对，并且它还有一个riceType属性。我们也可以登录BurritoBowl.smellDelicious美味()，看到它也继承了TacoSalad的方法。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lu"><img src="../Images/3887ba230a8b1ef69946649ceb74f4be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*989l1tyrc_3LLb81p3pKsw.png"/></div></div></figure><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lv"><img src="../Images/bcbccd7147350dbff39a12f9160d08c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*akoYDCmoMEJmWtFMfdkl8g.png"/></div></div></figure><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lw"><img src="../Images/9b0f081a5fde7bddb4ae378e431ab9f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R8ufE17a_sg_978syOlawg.png"/></div></div></figure><figure class="la lb lc ld gt le gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/8ce4aea1a3c0034acf3246aff3c72daf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*H5d4cwwhATBCRlrIdHPrpw.png"/></div></figure><p id="5f10" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然您已经知道如何创建子类，让我们创建一个塔科和布里托类。向下滚动之前，请继续并尝试一下。如果你感觉非常自信，试试给塔科课程增加一个新的方法。</p><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi ly"><img src="../Images/aae9bcfa06cd5940ba54d3c8517352ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qMvhHOOYoQl0pr0we-JW2w.png"/></div></div></figure><figure class="la lb lc ld gt le gh gi paragraph-image"><div role="button" tabindex="0" class="lf lg di lh bf li"><div class="gh gi lz"><img src="../Images/e2281e283b91f4773f57c3f70f5657ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aW52G01ods0lyNJyafv5VQ.png"/></div></div></figure><p id="d67f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">展望未来，如果我们决定在菜单中添加新的项目，我们可以使用<strong class="ke io"> <em class="ky"> extends </em> </strong>和<strong class="ke io"> <em class="ky"> super </em> </strong>关键字来创建一个子类，而不是复制代码。</p><p id="92fe" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇博文中，我们讲述了如何使用继承以及<strong class="ke io"> <em class="ky">扩展的</em> </strong>和<strong class="ke io"> <em class="ky">超级</em> </strong>关键词来创建子类。我们还讨论了使用子类来生成干净的、可重用的代码的优点。我希望你觉得这篇文章很有帮助；如果你有任何你希望我在未来报道的话题，把它们放到评论中。</p></div></div>    
</body>
</html>