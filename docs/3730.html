<html>
<head>
<title>5 Scenarios That Will Help You Understand The “this” keyword in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有助于您理解JavaScript中“这个”关键词的5种场景</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-this-keyword-in-javascript-87b34b2b60e9?source=collection_archive---------10-----------------------#2020-10-20">https://javascript.plainenglish.io/the-this-keyword-in-javascript-87b34b2b60e9?source=collection_archive---------10-----------------------#2020-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="95a7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">五种不同的场景来了解“这”是什么意思。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f2f63a90f8633cce1c75ba25404ae773.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ustU1RvWGs3NU28E0TmRMQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@prateekkatyal?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Prateek Katyal</a> on <a class="ae kv" href="https://unsplash.com/s/photos/you-got-this?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b949" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript最令人困惑的特征之一是<code class="fe ls lt lu lv b">this</code>关键字。<code class="fe ls lt lu lv b">this</code>虽然看起来令人生畏，但并不那么难。下面是<strong class="ky ir">五个不同的场景</strong>来最终解读<code class="fe ls lt lu lv b">this</code>的神秘！</p><p id="bd32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">开始前:</p><ul class=""><li id="af9c" class="lw lx iq ky b kz la lc ld lf ly lj lz ln ma lr mb mc md me bi translated">您可以通过在浏览器的开发人员控制台中执行代码片段来继续。使用以下快捷方式打开您的Chrome Developer Console*<strong class="ky ir">Mac:</strong>Cmd+Option+J | |<strong class="ky ir">Windows:</strong>Ctrl+Shift+J。</li></ul></div><div class="ab cl mf mg hu mh" role="separator"><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk ml"/><span class="mi bw bk mj mk"/></div><div class="ij ik il im in"><h1 id="d781" class="mm mn iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated"><strong class="ak">JavaScript中的“这个”是什么？</strong></h1><p id="3a61" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">我们可以将<code class="fe ls lt lu lv b">this</code>定义为:<em class="nj">“正在执行当前函数的对象”</em></p><p id="c85b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是什么意思？<code class="fe ls lt lu lv b">this</code>的价值通常由<strong class="ky ir">执行上下文</strong>决定。<strong class="ky ir">执行上下文</strong>是<strong class="ky ir"> </strong>执行JavaScript代码的环境<strong class="ky ir"/>。知道<strong class="ky ir"> JavaScript运行时</strong>跟踪这些执行上下文的<strong class="ky ir">堆栈</strong>是很重要的，位于该堆栈顶部的是当前正在执行的。</p><p id="b5ad" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关键字<code class="fe ls lt lu lv b">this</code>所指的对象在每次执行上下文改变时都会改变。</p><p id="da4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上<code class="fe ls lt lu lv b">this</code>的值是由<em class="nj">如何执行</em>代码决定的。</p><h1 id="28f7" class="mm mn iq bd mo mp nk mr ms mt nl mv mw jw nm jx my jz nn ka na kc no kd nc nd bi translated"><strong class="ak"> 1。全局对象</strong></h1><p id="c562" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">让我们看一个例子:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="1ef6" class="nt mn iq lv b gy nu nv l nw nx">function fn () {<br/>  console.log(this);<br/>}<br/>fn();   </span><span id="0eba" class="nt mn iq lv b gy ny nv l nw nx">//Window {…}</span></pre><p id="89f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下<strong class="ky ir">执行上下文</strong>为<strong class="ky ir">全局上下文</strong>。对于浏览器，全局上下文是<code class="fe ls lt lu lv b">window</code>。因为我们从窗口上下文中调用函数<code class="fe ls lt lu lv b">fn()</code>，所以<code class="fe ls lt lu lv b">this</code>指的是窗口对象。</p><h1 id="519a" class="mm mn iq bd mo mp nk mr ms mt nl mv mw jw nm jx my jz nn ka na kc no kd nc nd bi translated">2.声明的对象</h1><p id="ee4c" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">当<code class="fe ls lt lu lv b">this</code>在声明的对象内部使用时，<code class="fe ls lt lu lv b">this</code>的值被设置为<strong class="ky ir">最接近的父对象</strong>，该方法被调用。</p><p id="1ab9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="c4d9" class="nt mn iq lv b gy nu nv l nw nx">let student = {<br/>  name: 'John',<br/>  introduction: function() {<br/>    console.log("Hi, my name is " + this.name); <br/>  },<br/>  secondStudent:{<br/>  name: 'Theresa',<br/>  introduction: function() {<br/>    console.log("Hi, my name is " + this.name);<br/>  }<br/> }<br/>};<br/>student.introduction();<br/>student.secondStudent.introduction();</span><span id="23f3" class="nt mn iq lv b gy ny nv l nw nx">//Hi, my name is John<br/>//Hi, my name is Theresa</span></pre><p id="c91c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用<code class="fe ls lt lu lv b">student.introduction()</code>时，<code class="fe ls lt lu lv b">this</code>在<code class="fe ls lt lu lv b">student</code>对象内，等于<strong class="ky ir">最接近的父对象。</strong></p><p id="d430" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同时，当<code class="fe ls lt lu lv b">student.secondStudent.introduction()</code>被调用时，在整个函数中，它被绑定到<code class="fe ls lt lu lv b">secondStudent</code>对象，在这种情况下，是最接近的父对象。</p><h1 id="667d" class="mm mn iq bd mo mp nk mr ms mt nl mv mw jw nm jx my jz nn ka na kc no kd nc nd bi translated">3.调用、应用、绑定</h1><p id="aadd" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated"><code class="fe ls lt lu lv b">call()</code>、<code class="fe ls lt lu lv b">bind()</code>和<code class="fe ls lt lu lv b">apply()</code>允许我们显式设置<code class="fe ls lt lu lv b">this</code>的值。用这些方法，我们可以操纵<code class="fe ls lt lu lv b">this</code>。</p><p id="3ae4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="4eb0" class="nt mn iq lv b gy nu nv l nw nx">const jordan = {<br/>  name: 'Michael',<br/>  shootingAccurany: 95,<br/>  practice() {<br/>    console.log(this.shootingAccurany = 100);<br/>  } <br/>};</span><span id="ba75" class="nt mn iq lv b gy ny nv l nw nx">const ebeling = {<br/>  name: 'Gianmarco',<br/>  shootingAccurany: 65,<br/>};</span><span id="b696" class="nt mn iq lv b gy ny nv l nw nx">jordan.practice.call(ebeling);</span><span id="e617" class="nt mn iq lv b gy ny nv l nw nx">// 100</span></pre><p id="e15c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们想从我们的<code class="fe ls lt lu lv b">jordan</code>对象借出方法<code class="fe ls lt lu lv b">practice()</code>。我们可以用<code class="fe ls lt lu lv b">call()</code>来做。当我们使用<code class="fe ls lt lu lv b">jordan.practice.call(ebeling)</code>时，第一个参数是<code class="fe ls lt lu lv b">this</code>应该绑定到什么。</p><p id="acf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一个参数之后<code class="fe ls lt lu lv b">call()</code>可以有许多<em class="nj"> n个</em>后续参数，这些参数被传递到我们正在调用的函数中。<code class="fe ls lt lu lv b">apply()</code>的工作方式与<code class="fe ls lt lu lv b">call()</code>完全相同，但是在第一个参数之后，它只能再有一个参数，并且始终是一个数组。</p><p id="8ed5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">bind()</code>的工作方式与<code class="fe ls lt lu lv b">call()</code>和<code class="fe ls lt lu lv b">apply()</code>非常相似，但这里的主要区别在于<code class="fe ls lt lu lv b">bind()</code>并不立即调用函数，而是返回一个原始函数的副本，该函数的<code class="fe ls lt lu lv b">this</code>关键字被设置为一个提供的值。</p><h1 id="19cb" class="mm mn iq bd mo mp nk mr ms mt nl mv mw jw nm jx my jz nn ka na kc no kd nc nd bi translated">4.“新”关键字</h1><p id="48b9" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated"><code class="fe ls lt lu lv b">new</code>关键字用于从构造函数创建一个对象。使用关键字<code class="fe ls lt lu lv b">new</code>我们创建了一个新的对象，它绑定了<code class="fe ls lt lu lv b">this</code>的值。</p><p id="ef35" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="96bf" class="nt mn iq lv b gy nu nv l nw nx">function Tesla(model, color) {<br/>  this.model = model;<br/>  this.color = color;<br/>}</span><span id="bda3" class="nt mn iq lv b gy ny nv l nw nx">const modelX= new Tesla('X', 'white');</span><span id="4e1a" class="nt mn iq lv b gy ny nv l nw nx">console.log(modelX.model);<br/>console.log(modelX.color);</span><span id="add9" class="nt mn iq lv b gy ny nv l nw nx">// X<br/>// white</span></pre><h1 id="38a0" class="mm mn iq bd mo mp nk mr ms mt nl mv mw jw nm jx my jz nn ka na kc no kd nc nd bi translated">5.箭头功能</h1><p id="818f" class="pw-post-body-paragraph kw kx iq ky b kz ne jr lb lc nf ju le lf ng lh li lj nh ll lm ln ni lp lq lr ij bi translated">与普通函数不同，<strong class="ky ir">箭头函数</strong>不绑定<code class="fe ls lt lu lv b">this</code>，而是在词汇上绑定。</p><pre class="kg kh ki kj gt np lv nq nr aw ns bi"><span id="c52a" class="nt mn iq lv b gy nu nv l nw nx">const object = {<br/>  print: () =&gt; { console.log(this); }<br/>};</span><span id="1070" class="nt mn iq lv b gy ny nv l nw nx">object.print()<br/>//Window {…}<br/></span><span id="8e1a" class="nt mn iq lv b gy ny nv l nw nx">const object2 = {<br/>  print: function() {<br/>    console.log (this);<br/>  }<br/>};</span><span id="9468" class="nt mn iq lv b gy ny nv l nw nx">object2.print()<br/>//{print: ƒ}</span></pre><h1 id="e7fc" class="mm mn iq bd mo mp nk mr ms mt nl mv mw jw nm jx my jz nn ka na kc no kd nc nd bi translated">结论</h1><ol class=""><li id="33a0" class="lw lx iq ky b kz ne lc nf lf nz lj oa ln ob lr oc mc md me bi translated"><code class="fe ls lt lu lv b">this</code>的值通常由<strong class="ky ir">执行上下文决定。</strong></li><li id="2dc1" class="lw lx iq ky b kz od lc oe lf of lj og ln oh lr oc mc md me bi translated">默认情况下，<strong class="ky ir">执行上下文</strong>就是<strong class="ky ir">全局上下文</strong>。</li><li id="579e" class="lw lx iq ky b kz od lc oe lf of lj og ln oh lr oc mc md me bi translated">通过<code class="fe ls lt lu lv b">call()</code>、<code class="fe ls lt lu lv b">bind()</code>和<code class="fe ls lt lu lv b">apply()</code>，我们可以显式设置<code class="fe ls lt lu lv b">this</code>的值。</li><li id="c530" class="lw lx iq ky b kz od lc oe lf of lj og ln oh lr oc mc md me bi translated">使用关键字<code class="fe ls lt lu lv b">new</code>我们创建了一个新的对象，它绑定了<code class="fe ls lt lu lv b">this</code>的值。</li><li id="76ee" class="lw lx iq ky b kz od lc oe lf of lj og ln oh lr oc mc md me bi translated">箭头函数不绑定<code class="fe ls lt lu lv b">this</code>，但是它被词汇绑定。</li></ol><p id="72f8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="ky ir">！</strong></p></div></div>    
</body>
</html>