<html>
<head>
<title>Are Generics a Good Enough Reason To Use TypeScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">泛型是使用TypeScript的足够好的理由吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/are-generics-a-good-enough-reason-to-consider-typescript-ed0b8c6aaf7c?source=collection_archive---------7-----------------------#2020-11-13">https://javascript.plainenglish.io/are-generics-a-good-enough-reason-to-consider-typescript-ed0b8c6aaf7c?source=collection_archive---------7-----------------------#2020-11-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ccbc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">JavaScript是一种动态类型的语言，这很棒。但是，当您作为一个团队与许多开发人员一起工作时，这确实会增加一些混乱。接口、类型和泛型有助于开发可重用、类型安全和无错误的代码。</p><p id="d915" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TypeScript泛型确实有助于提高代码的可读性和可用性。如果你看到的TypeScript代码变得如此复杂，以至于到处都可以看到“任何”类型，通常可以用泛型来解决。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/219d518f0bf84f1a50608c172a16231e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZfCTE6kZArxc0Nr_MybXPQ.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Logo Provided by TypeScript.org Branding</figcaption></figure><h1 id="2276" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是通用？</h1><p id="fa71" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">泛型是一个用来标识方法签名的术语，它支持许多不同的类型。你们可能都用过的最常见的通用名是:<code class="fe mb mc md me b">Array</code>。例如，你可以让你的数据类型成为一个任意:<code class="fe mb mc md me b">Array&lt;any&gt;</code>的数组或者一个数字:<code class="fe mb mc md me b">Array&lt;number&gt;</code>的数组，你明白了。注意这相当于<code class="fe mb mc md me b">number[]</code>。</p><p id="f04d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以这里的“泛型”部分就是数据类型所在的地方。数组被定义为<code class="fe mb mc md me b">Array&lt;T&gt;</code>，其中“T”(可以是<code class="fe mb mc md me b">&lt;</code> <code class="fe mb mc md me b">&gt;</code>之间的任何字符)是由泛型类型的使用者定义的。</p><h1 id="54c8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我怎样才能把它合并到我的代码中呢？</h1><p id="ba3e" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">假设你创建了一个方法，你可以传入这些类型中的任何一个:一个字符串，一个数字或字符串的数组，一个自定义对象的数组，比如一个用户。现在，你怎么打这个？你可能会说:</p><pre class="kj kk kl km gt mf me mg mh aw mi bi"><span id="aa60" class="mj kz in me b gy mk ml l mm mn">function myFunction(arg: string | number[] | string[] | User[]);</span></pre><p id="bb16" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">看起来真的很乱。在某种程度上，您的方法签名会变得如此之大，以至于您最终会做下面的事情，并破坏您从使用TypeScript中获得的任何好处。</p><pre class="kj kk kl km gt mf me mg mh aw mi bi"><span id="002b" class="mj kz in me b gy mk ml l mm mn">function myFunction(arg: any[]);</span></pre><p id="fe4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以在这里使用通用的吗？绝对的！让我们给我们的方法一些意义。这个方法的目的是从传入的列表中返回一个随机元素。我们知道这不是任何数组，而是一个泛型，它将从数组中返回一个元素。我们可以这样定义:</p><pre class="kj kk kl km gt mf me mg mh aw mi bi"><span id="312b" class="mj kz in me b gy mk ml l mm mn">function getRandomElement&lt;T&gt;(list: Array&lt;T&gt;): T;</span></pre><p id="dcee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以将这种方法用于上面提到的任何类型。值得注意的是，类型既可以由开发人员显式定义，也可以在TypeScript中推断。在第二个例子中，<code class="fe mb mc md me b">el</code>被推断为<code class="fe mb mc md me b">string</code>类型，因为我们传入了一个字符串数组。</p><pre class="kj kk kl km gt mf me mg mh aw mi bi"><span id="f6e9" class="mj kz in me b gy mk ml l mm mn">const n: number = getRandomElement&lt;number&gt;([4, 23, 42, 54]);</span><span id="006c" class="mj kz in me b gy mo ml l mm mn">const el = getRandomElement(["hello", "world", "medium"]);</span></pre><h2 id="7283" class="mj kz in bd la mp mq dn le mr ms dp li jv mt mu lm jz mv mw lq kd mx my lu mz bi translated">泛型的默认值</h2><p id="2024" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">通常，如果没有提供，泛型的默认值最终是“any”。但是，如果愿意，您可以提供默认值:</p><pre class="kj kk kl km gt mf me mg mh aw mi bi"><span id="5851" class="mj kz in me b gy mk ml l mm mn">function getRandomElement&lt;<strong class="me io">T = number</strong>&gt;(list: T[]): T;</span></pre><h2 id="6422" class="mj kz in bd la mp mq dn le mr ms dp li jv mt mu lm jz mv mw lq kd mx my lu mz bi translated">扩展泛型</h2><p id="67ab" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">如果不是返回一个随机元素，而是在函数中返回一个用户的年龄，会怎么样？你会想保护自己不受年龄的影响，对吗？这就是你的泛型需要扩展T4的地方。让我们在实践中看到这一点，如果您有一个用户、管理员和人员类型会怎么样:</p><pre class="kj kk kl km gt mf me mg mh aw mi bi"><span id="076e" class="mj kz in me b gy mk ml l mm mn">interface User { <br/>  name: string;<br/>  age: number;<br/>  data: WebData;<br/>}<br/>interface Person { <br/>  name: string; <br/>  age: number;<br/>  data: PersonalData;<br/>}<br/>interface Admin {<br/>  name: string;<br/>  organization: string<br/>}</span><span id="4988" class="mj kz in me b gy mo ml l mm mn">function getRandomAge(arr: User[] | Person[]): number;</span></pre><p id="2899" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以看到，只有用户和个人拥有“年龄”属性，而管理员没有。在上面的例子中，我们可以使用一个通用的函数，而不是专门键入您的函数“User”或“Person ”:</p><pre class="kj kk kl km gt mf me mg mh aw mi bi"><span id="9c78" class="mj kz in me b gy mk ml l mm mn">function getRandomAge&lt;<strong class="me io">T extends {age: number}</strong>&gt;(arr: T[]): number;</span></pre><p id="74a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们知道这个函数仍然会返回一个数字，但是我们保证传递给<code class="fe mb mc md me b">getRandomAge</code>的对象至少有一个<code class="fe mb mc md me b">age</code>属性，它的类型是number。如果我们在函数中传递一个“Admin ”, TypeScript不会允许:</p><pre class="kj kk kl km gt mf me mg mh aw mi bi"><span id="e895" class="mj kz in me b gy mk ml l mm mn">Type 'Admin' is missing the following properties from type '{ age: number; }[]</span></pre><h2 id="15ba" class="mj kz in bd la mp mq dn le mr ms dp li jv mt mu lm jz mv mw lq kd mx my lu mz bi translated">我们还能提高吗？</h2><p id="bd52" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在上一节中，我们创建了一个人和一个用户，两者都有相同的三个属性:姓名、年龄和数据。唯一的区别是Person有一个“PersonalData”类型的数据，而User有一个“WebData”类型的数据。我们能重新组织一下吗？</p><p id="983b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们尝试使用泛型来解决这个问题。我们知道所有3个属性名称都是相同的，所以让我们用一个通用类型创建一个接口。</p><pre class="kj kk kl km gt mf me mg mh aw mi bi"><span id="eec2" class="mj kz in me b gy mk ml l mm mn">interface GenericPerson&lt;T&gt; {<br/>  name: string;<br/>  age: number<br/>  data: T;<br/>}</span></pre><p id="68c1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这意味着，必须用另一种类型创建GenericPerson，这种类型是为对象的“数据”属性保留的。现在，我们可以使用这个GenericPerson创建我们的Person和User类型。我们将定义一个“类型”而不是一个接口。</p><pre class="kj kk kl km gt mf me mg mh aw mi bi"><span id="ece6" class="mj kz in me b gy mk ml l mm mn">type Person = GenericPerson&lt;PersonalData&gt;;<br/>type User = GenericPerson&lt;WebData&gt;;</span></pre><p id="1c5b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上述人员和用户类型的工作方式与我们在上一节中的界面相同。唯一的区别是，我们减少了代码的重复，并抽象出了通用接口中的一些逻辑。</p><h1 id="8c50" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">概括起来</h1><p id="230a" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">在这种情况下，您可以清楚地看到使用泛型的好处，因为它允许您的代码是类型安全的和可重用的。使用“any”会产生潜在的bug，这些bug只能在运行时被发现。TypeScript允许您在这些错误到达任何运行环境之前就捕捉到它们，因为它们是在将代码编译成JavaScript之前被捕捉到的。如果您想了解更多，您可以跟随我的“构建应用程序”系列，该系列在实践中使用了TypeScript。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="na nb l"/></div></figure></div></div>    
</body>
</html>