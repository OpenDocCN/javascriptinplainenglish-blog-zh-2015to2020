<html>
<head>
<title>Lessons learned testing a Apache Kafka based application with Jest &amp; Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Jest &amp; Node.js测试基于Apache Kafka的应用程序的经验教训</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lessons-learned-testing-a-apache-kafka-based-application-with-jest-node-js-5dfa50389121?source=collection_archive---------0-----------------------#2019-02-16">https://javascript.plainenglish.io/lessons-learned-testing-a-apache-kafka-based-application-with-jest-node-js-5dfa50389121?source=collection_archive---------0-----------------------#2019-02-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e765" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在最近的工作中，我已经从使用Selenium构建UI自动化套件(我非常习惯这样做)转移到为基于Kafka &amp; REST API的应用程序构建自动化的端到端测试，这是整个系统的主干，编写为一组Java服务，充当两个服务之间的适配器。</p><p id="23bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这组Java服务完成以下工作:</p><ul class=""><li id="ce89" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">从Kafka队列中取出Avro序列化消息，Kafka队列由上游第三方系统填充，该系统根据发送到其REST API的数据生成这些消息</li><li id="5b21" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">将消息转换成另一种格式</li><li id="f219" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">将转换后的消息作为未序列化的JSON发送到另一个Kafka队列，该队列将被另一个服务使用，该服务将数据填充到前端使用的REST API中</li></ul><figure class="kx ky kz la gt lb gh gi paragraph-image"><div role="button" tabindex="0" class="lc ld di le bf lf"><div class="gh gi kw"><img src="../Images/6800aac672f461353dd9810b0fc306de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mT0ymRXSxhv9aZ8Vd5bhpg.png"/></div></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Diagram of the type of app I’ve been testing</figcaption></figure><p id="4d6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了对系统进行端到端测试，我需要做以下工作:</p><ul class=""><li id="1e87" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">向上游系统发送一个REST API调用来触发一个动作(比如创建和更新一个完整的记录及其关联的实体)</li><li id="6e3c" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">检查上游系统正在向Kafka队列发布的被测系统将要使用的序列化消息</li><li id="881b" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">检查被测系统发布到下游系统将使用的Kafka队列的未序列化消息</li><li id="1946" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">检查下游系统的REST API，确保它根据输入消息显示正确的状态</li></ul><p id="7bf1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我还有一个技术上的限制。虽然测试中的系统是用Java构建的，但我的同事们使用现有的库来处理用JavaScript编写的上游和下游REST APIs。</p><p id="e79e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哦，还有一个心理约束，我从未使用或测试过分布式队列系统，也从未使用过Avro序列化。</p><h1 id="a758" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">演示项目</h1><p id="0462" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">为了更好地说明我一直在测试的系统类型，我在Github上构建了一个示例应用程序和测试套件:<a class="ae mp" href="https://gitlab.com/colinfwren/testing-kafka-app-with-jest" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/colinfwren/testing-kafka-app-with-jest</a></p><p id="d9dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该系统由三个应用程序组成:</p><ul class=""><li id="cf42" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">一个生产者应用程序，接受一个API调用并将Avro序列化消息发布到一个队列</li><li id="d837" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">一个适配器应用程序，将Avro序列化消息从队列中取出，并将非序列化JSON消息发布到另一个主题</li><li id="2668" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">一个消费者应用程序，接受JSON消息并在REST API中输出结果</li></ul><p id="cfa5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">演示项目包含一个端到端测试系统的测试套件和一个在Docker Compose中运行整个堆栈的Makefile。</p><h1 id="8e8a" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">连接到卡夫卡</h1><p id="f143" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">因为我使用JavaScript库，所以我决定使用Jest来运行测试。主要的困难是找到一个库来处理从Kafka获取的消息，并对上游系统发布的Avro消息进行反序列化。</p><p id="702c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">经过一番搜索和试验，我发现<code class="fe mq mr ms mt b">kafka-node</code>是Node可用的普通Kafka库中较好的一个。它相对容易设置，并允许动态调整topic &amp;分区的偏移量。</p><p id="1723" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在测试Kafka队列时，偏移量非常重要(尤其是当涉及Avro模式时),如果您不设置偏移量，您的消费者将从主题消息的开头开始阅读，这可能意味着您必须处理一周的消息，才能看到您真正想要看到的消息。</p><p id="c70d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我还发现<code class="fe mq mr ms mt b">kafka-avro</code>有一个非常简单的设置过程，你只需将它指向模式注册表，一旦它接收到消息，JSON对象就可以通过<code class="fe mq mr ms mt b">data.parsed</code>获得。我在这个上与偏移做了一点斗争，因为它只支持<code class="fe mq mr ms mt b">auto.offset.reset=latest</code>，而且(据我所知)没有办法动态调整偏移。</p><p id="5b0e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">具有Avro序列化消息的队列的偏移量非常重要，因为如果用于序列化消息的模式在队列的保持期内发生变化，您可能会遇到试图用不兼容的模式去序列化消息的问题。</p><h2 id="4704" class="mu ln in bd lo mv mw dn ls mx my dp lw jv mz na ma jz nb nc me kd nd ne mi nf bi translated">地方发展陷阱</h2><p id="e8f3" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">当我从本地开发转移到在部署基础设施中运行测试时，有两件事让我感到困惑:</p><ul class=""><li id="c0cf" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">Kafka对消息进行分区，每个分区都有不同的偏移量，所以如果你假设消息在开发过程中只出现在一个分区上(像我一样)，那么你的偏移量就不起作用了</li><li id="b1d4" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">Kafka有一个安全协议，如果你不把它包含在你的用户配置中，就意味着你不能得到任何补偿，因为用户不会连接</li></ul><h2 id="f408" class="mu ln in bd lo mv mw dn ls mx my dp lw jv mz na ma jz nb nc me kd nd ne mi nf bi translated">Avro模式</h2><p id="37f4" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">虽然<code class="fe mq mr ms mt b">kafka-avro</code>会从模式注册表中为您获取模式，但值得注意的是，它不能防止模式改变或模式无效。</p><p id="88ea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我遇到的一个问题是Avro schema deserialiser的Java实现只会读取它需要读取的模式，因此当模式中有错误时不会崩溃，但节点库<code class="fe mq mr ms mt b">avsc</code>会。</p><p id="78cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">模式中的一个记录将记录的默认值设置为<code class="fe mq mr ms mt b">"{}"</code>而不是<code class="fe mq mr ms mt b">{}</code>，这导致<code class="fe mq mr ms mt b">avsc.parse()</code>函数抛出错误。</p><h2 id="0ba7" class="mu ln in bd lo mv mw dn ls mx my dp lw jv mz na ma jz nb nc me kd nd ne mi nf bi translated">组id和偏移</h2><p id="582b" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">每个分区的偏移量通过消费者在连接时声明的组ID链接到消费者。如果您正在使用<code class="fe mq mr ms mt b">auto.offset.reset</code>，并且似乎没有只收到最新的消息，这可能是因为您重复使用了一个没有提交的消费者的组ID，这将抵消回Kafka。</p><p id="1c4c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我发现在我的消费者的组ID后面附加一个UUID是一个好主意，可以确保每个消费者总是收到最新的消息。</p><p id="83cc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这也适用于被测系统。如果有配置组ID和偏移量的方法(比如通过环境变量)，这将加快消息通过系统所有部分的时间。</p><h1 id="2970" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">对分布式队列进行断言</h1><p id="1cbc" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">我正在测试的系统最难的部分可能是不能保证消息会在一定时间内到达，而且根据系统的构建方式，也不能保证消息的顺序。</p><p id="35f8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了解决这个问题，我重新使用了UI测试中常用的一种方法，即在对事物执行动作之前等待。</p><p id="9b66" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我通过轮询Kafka消费者接收到的一组消息来实现这一点，直到我需要的消息被添加到该组中，如果在合理的时间范围内没有接收到任何消息，我会超时以确保测试失败。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">A recursive function to poll an array of messages for a value</figcaption></figure><p id="30e2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我也对下游系统的REST API使用相同的模式。这样，在断言数据之前，我可以将消息发布到Kafka和REST API输出。</p><p id="2ae8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于这种类型的工作来说是必须的，因为它使得代码很容易理解。如果我必须用承诺链(或者上帝禁止回调)来做这件事，我会害怕去想嵌套的数量。</p><h1 id="156c" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">在本地开发测试</h1><p id="feee" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">幸运的是，我的团队已经将我们的服务容器化了，这使得设置本地版本的堆栈变得非常简单，因为我可以使用Docker Compose来构建一个包含以下内容的堆栈:</p><ul class=""><li id="e6de" class="ki kj in jm b jn jo jr js jv kk jz kl kd km kh kn ko kp kq bi translated">我会向Kafka队列发布Avro序列化消息，供测试中的系统使用，如果我想检查任何东西而不必进行完整的端到端检查</li><li id="1505" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">通过我的compose中的环境变量配置的测试系统指向我的本地Kafka实例或其他地方的另一个实例</li><li id="3238" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">测试中的系统会将转换后的JSON消息发布到Kafka队列</li><li id="39ae" class="ki kj in jm b jn kr jr ks jv kt jz ku kd kv kh kn ko kp kq bi translated">下游系统的一个实例，它将连接到被测系统发布到的本地Kafka队列</li></ul><p id="9f92" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我遇到的一个问题是Kafka广告的listeners IP需要是本地网络上主机的IP，这样Kafka才能正常工作。</p><p id="85a1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我设法通过创建一个Makefile来解决这个问题，我用这个Makefile来打开堆栈，这个堆栈执行一个小bash命令来获取主机的IP，并将其作为环境变量传递给Docker Compose文件。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Using a sub-shell in Make to get the host’s IP and passing that to Docker Compose</figcaption></figure><h1 id="b4c1" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">使用卡夫卡的有用工具</h1><p id="6723" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">Confluent免费提供了一些与Kafka一起工作的有用工具。这些可以通过自制软件使用下面的命令<code class="fe mq mr ms mt b">brew install confluent-oss</code>安装在Mac上。</p><h2 id="a6c9" class="mu ln in bd lo mv mw dn ls mx my dp lw jv mz na ma jz nb nc me kd nd ne mi nf bi translated">用于查看发布到队列的内容的工具</h2><p id="475b" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">如果您需要查看某些消息是否进入了队列，那么您可以使用<code class="fe mq mr ms mt b">kafka-console-consumer</code>和<code class="fe mq mr ms mt b">kafka-avro-console-consumer</code>来查看。</p><p id="e3fd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些工具将作为消费者连接到队列，并在消息发布时显示消息(除非您指定从头开始播放)。如果您想将它们保存在本地，那么您可以通过管道将其保存到一个文件中。</p><p id="6e3e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要使用队列中的非序列化消息，可以使用以下命令:</p><pre class="kx ky kz la gt ni mt nj nk aw nl bi"><span id="0fca" class="mu ln in mt b gy nm nn l no np">kafka-console-consumer --topic [TOPIC TO CONSUME] --bootstrap-server [KAFKA HOST]</span></pre><p id="b58f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要使用队列中的序列化消息，可以使用以下命令:</p><pre class="kx ky kz la gt ni mt nj nk aw nl bi"><span id="c47f" class="mu ln in mt b gy nm nn l no np">kafka-avro-console-consumer --value-deserializer io.confluent.kafka.serializers.KafkaAvroDeserializer --key-deserializer org.apache.kafka.common.serialization.StringDeserializer --formatter io.confluent.kafka.formatter.AvroMessageFormatter --property print.key=true --property schema.registry.url=http://[SCHEMA REGISTRY HOST] --topic [TOPIC TO CONSUME] --bootstrap-server [KAFKA HOST]</span></pre><h2 id="8827" class="mu ln in bd lo mv mw dn ls mx my dp lw jv mz na ma jz nb nc me kd nd ne mi nf bi translated">将消息发布到队列的工具</h2><p id="d947" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">如果您需要将某些消息添加到队列中，以便消费系统根据有效负载做一些事情，您可以使用<code class="fe mq mr ms mt b">kafka-console-producer</code>和<code class="fe mq mr ms mt b">kafka-avro-console-producer</code>来完成。</p><p id="19b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些工具将作为生产者连接到队列，并提示您键入或粘贴消息。需要注意的一点是，您不能像在“终端”中那样回忆以前的信息，因此您需要编辑并粘贴来自其他地方的信息。</p><p id="3a3f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要生成非序列化消息，您可以使用以下命令:</p><pre class="kx ky kz la gt ni mt nj nk aw nl bi"><span id="6976" class="mu ln in mt b gy nm nn l no np">kafka-console-producer --topic=[TOPIC TO PUBLISH TO] --broker-list[KAFKA HOST]</span></pre><p id="8a1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要生成序列化消息，您可以使用以下命令:</p><pre class="kx ky kz la gt ni mt nj nk aw nl bi"><span id="06b8" class="mu ln in mt b gy nm nn l no np">kafka-avro-console-producer --broker-list [KAFKA HOST] --topic [TOPIC TO PUBLISH TO] --property schema.registry.url=[SCHEMA REGISTRY HOST] --property value.schema=[SCHEMA FOR MESSAGES AS JSON]</span></pre><h2 id="ffda" class="mu ln in bd lo mv mw dn ls mx my dp lw jv mz na ma jz nb nc me kd nd ne mi nf bi translated">将消息从一个队列回放到另一个队列的工具</h2><p id="b1c3" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">有时，您需要将一个队列中的消息播放到另一个队列中，以模拟系统的使用情况，或者简单地创建一个单独的主题来进行测试。</p><p id="189e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mq mr ms mt b">kakfa-mirror-maker</code>是你需要的工具，但它需要一些设置来工作。这包括为消费者和生产者创建配置文件，消费者可以在其中声明其组ID和偏移量，这样您就可以控制要获取多少消息。</p><figure class="kx ky kz la gt lb"><div class="bz fp l di"><div class="ng nh l"/></div><figcaption class="li lj gj gh gi lk ll bd b be z dk">Example usage of kafka-mirror-maker</figcaption></figure><h1 id="4fa2" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">摘要</h1><p id="85ca" class="pw-post-body-paragraph jk jl in jm b jn mk jp jq jr ml jt ju jv mm jx jy jz mn kb kc kd mo kf kg kh ig bi translated">虽然由于我缺乏使用分布式队列的经验，学习曲线最初很陡，但是我学到了很多，并且使用这项技术使我成为了一名更强的技术测试人员。</p><p id="3c5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">能够看到系统中许多不同的服务之间正在发送什么消息，这是一种真正有用的集成和端到端测试系统整体和隔离的方法。</p><p id="2611" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Confluent在提供与Kafka和Avro协同工作的工具方面做得很好，当从第三方上游系统消费时，它允许快速加入和分析。</p><p id="0d06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用异步系统真的让我更多地思考我过去编写的测试类型，在这些测试中，我假设事情“只是发生”,以及我应该如何编写更具防御性的测试代码，特别是当涉及到API调用时。</p><p id="a64d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我已经创建了一个演示项目(<a class="ae mp" href="https://gitlab.com/colinfwren/testing-kafka-app-with-jest" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/colinfwren/testing-kafka-app-with-jest</a>)来检验如何以我正在使用的系统的方式使用kafka进行端到端测试。</p></div></div>    
</body>
</html>