<html>
<head>
<title>Hidden Tricks In Recent JavaScript Versions (ES2016-ES2020)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">最近的JavaScript版本(ES2016-ES2020)中隐藏的技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-ecmascript-history-the-hidden-features-acb38af57be8?source=collection_archive---------10-----------------------#2020-12-12">https://javascript.plainenglish.io/javascript-ecmascript-history-the-hidden-features-acb38af57be8?source=collection_archive---------10-----------------------#2020-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="28cf" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">关于每个ECMAScript版本中不太流行的技巧的JavaScript历史指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f002e8b78de675bd3242f05f0db95ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vt-3gvNz22tHkccmvGItcA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://unsplash.com/@ricardoaguilera" rel="noopener ugc nofollow" target="_blank">Ricardo Aguilara</a> via <a class="ae kv" href="https://unsplash.com/photos/ATVZGXO457I" rel="noopener ugc nofollow" target="_blank">unsplash</a> (CC0)</figcaption></figure><h1 id="fc3c" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="8472" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">JavaScript已经改变了很多年，这是事实。在过去的十年里，它发生了巨大的变化。一个重大的变化带来了ECMAScript2015，也称为ECMAScript6 (ES6)。从那以后，每年都会发布一个新的ECMAScript。但是当你们大多数人知道大的变化时，你们是否也知道一些小的事情呢？也值得一看的东西？在这篇文章中，我将向你介绍他们。</p><h1 id="43ee" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">ECMAScript 2016</h1><h2 id="f4ec" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">或**运算符的幂</h2><p id="ed7a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这不是一个游戏规则的改变者，但它有它存在的权利，因为它有很高的实用性。</p><p id="834b" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">ECMA2016让你能够运用爱的力量...我是说用另一个数来加强一个数的最短的方法。幂运算符<em class="nb"> ** </em>确保您可以省略<em class="nb">数学。Pow(a，b) </em>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c7f3" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">在此之前，如果你来自C#，你知道这里要做什么。对，叫<em class="nb">数学。Pow() </em>。这看起来一点也不像是一个影响，但是如果你做长时间的数学计算，并且每次在这期间，一个函数调用出现，那么你已经在这些函数调用上停下来，有一个短暂的精神休息。</p><h2 id="da34" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">包含</h2><p id="1e17" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">这简化了检查数组中是否存在元素的过程。大多数程序员和我也是这样做的，使用<em class="nb"> IndexOf() </em>方法，并使用返回值继续我们的操作。此外，代码变得更可读，更人性化。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="176c" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated"><em class="nb">注意:Includes只检查值类型的值，以便返回正确的结果。当使用像对象或数组这样的引用类型时，它们通过它们的链接引用进行比较！</em></p><h1 id="a969" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">ECMAScript 2017</h1><div class="ne nf gp gr ng nh"><a href="https://medium.com/javascript-in-plain-english/javascript-async-await-promisify-the-future-to-callback-never-again-6762707e18e5" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">JavaScript Async Await:承诺未来不再回调！</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">对承诺的回调直到异步等待</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv kp nh"/></div></div></a></div><p id="aa79" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">2017年对于JavaScript来说是不同寻常的一年，然而两个大词出现在桌面上:<a class="ae kv" href="https://medium.com/javascript-in-plain-english/javascript-async-await-promisify-the-future-to-callback-never-again-6762707e18e5" rel="noopener"> <em class="nb"> Async和Await </em> </a>。他们革新了编写异步代码的方式。我们从回调和承诺上升到这些新的关键词。但是等等！<em class="nb">异步</em>和<em class="nb">等待</em>不就是基于回调和承诺吗？是的，它们可以，但是它们至少使代码像同步代码一样可读，而回调和承诺却不能！</p><p id="777e" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">我们现在回到我们为什么在这里的话题上来。所有在大舞台上不被尊重的小事都会在我的舞台上获得毕业。从那时起，可以在函数的最后一个参数后面添加最后一个逗号。这符合数组和对象的规则。这只是一件小事，但更引人注目的是，您可以使用<em class="nb"> padStart/padEnd </em>来填充字符串，例如用空格。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/b14d165afa70e216868b2da8254942e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:658/format:webp/1*BdLuMFnPfCdkBhJ54-JiLw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Console Print out for padStart (code: padding.js)</figcaption></figure><p id="a5ec" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">正如你可以从控制台打印中看到的，我正在用前导零填充便士价格，以使我的格式适合例如商店。如果你没有给这个函数发送第二个参数，它会用空格填充前导字符。</p><p id="c95e" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">我差点忘了提到还有另外两个功能可以派上用场。<em class="nb"> Object.values </em>和<em class="nb">object . entry</em>。它们以数组的形式返回对象的值或键值对。<strong class="lq ir">提示:与for-of循环结合起来，它们非常坚韧！</strong></p><h1 id="e63e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">ECMAScript 2018</h1><p id="7fb6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于JavaScript来说，2018年并不是突出的一年，但是它给我们带来了<em class="nb"> Rest </em> -以及<em class="nb">Spread</em>-运算符，该运算符只用于对象而非数组。另一颗冉冉升起的新星是<em class="nb">等待环的引入。它是for循环的异步拮抗剂。</em></p><h1 id="87bd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">ECMAScript 2019</h1><h2 id="90c9" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">试试看-抓住-不要在意</h2><p id="68d6" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">来自C#？然后，我认为您非常了解异常，您还必须指定您想要捕获的异常类型，或者至少声明所有异常的基本类型，以确保您至少可以处理它们。ECMAScript2019引入了<em class="nb">可选锁扣绑定</em>。您可以忽略异常并返回一个对您来说更有趣的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e55b" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated"><em class="nb">检查装备</em>可以是一个在装甲未装备时返回空值的功能。我们想知道是否装备了某种盔甲，你害怕任何例外吗？无论什么回来，如果它不是你故意传入的盔甲，只要返回一个错误作为默认值，你就完了！很简单，是吧？</p><h1 id="babb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">平的</h1><p id="502a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">ECMAScript 2019的另一个好处是<em class="nb">扁平</em>功能。用于去除嵌套数组。类似于reduce函数，但它只能减少一个嵌套级别。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/494938c05ab6a95fd0a43e919f36d941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2yjQpNj-nJ5RI7sN59sMzw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">console print out after running items.flat().</figcaption></figure><p id="ec0a" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">降低一级不成问题。要么你把<em class="nb">平面</em>的调用串连起来，要么你只需要传入一个整数参数，这个参数相当于你想要平面的层数。</p><p id="1d03" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">平面功能的一个很好的相关就是<em class="nb">平面图</em>-功能。这是<em class="nb">平面</em>和<em class="nb">地图</em>的组合。与其给你一个列表作为结果，你可以立即得到一个扁平化的结果。这里有一些赌博赌注和允许的产出，如果你现在下注的话。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="5eb3" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">如果您单独调用两个函数，也会发生同样的情况，但是这会减少代码和工作量。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b76a" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated"><em class="nb"> FlatMap </em>工作效率更高，可以在计算密集型场景中使用。</p><h1 id="3f13" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">TrimStart &amp; TrimEnd</h1><p id="c0ce" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">两者的工作方式都与引入的<em class="nb"> padStart </em>和<em class="nb"> padEnd </em>功能相似，但它们不是填充，而是修剪不想要的空字符。我们可以将它们视为常规<em class="nb"> trim </em>功能的特殊任务组，以及一种快速访问方法。在游戏引擎中，Unity也是在简单的方向上创建向量的快速访问方法。</p><blockquote class="ny"><p id="2e20" class="nz oa iq bd ob oc od oe of og oh mj dk translated"><em class="oi"> Vector2.up() = &gt; (0，1)，Vector2.left() = &gt; (-1，0)等。</em></p></blockquote><div class="oj ok ol om on nh"><a href="https://medium.com/unity-hub" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">统一中心</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">在篝火旁取暖，在团结中心与长者和智者聊天，以确保你的…</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="oo l ns nt nu nq nv kp nh"/></div></div></a></div><h1 id="114e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">object . from entries vs objects . entries</h1><p id="1b13" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果你想获得一个对象的每个键值作为一个数组，你可以使用<em class="nb"> Object.entries </em>方法，而<em class="nb"> Object.fromEntries </em>将数组转换回一个对象。当你使用像<em class="nb"> reduce </em>、<em class="nb"> map </em>、<em class="nb"> filter </em>这样的函数，并且你得到了一个要进一步处理的对象时，你可以从中获利。使用<em class="nb"> Object.entries </em>并用<em class="nb"> Object.fromEntries </em>包裹它。在这里，我以我最喜欢的视频游戏<strong class="lq ir">黑暗之魂</strong>的装备对象为例向你展示我的意思:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/79c558427250ae2c98d91525ed69039b.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*h1AMzrF1PwXIiOqSLZOQBg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Console printout of object.entries wrapped by object.fromEntries</figcaption></figure><p id="7248" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">你也可以用武器和饰品槽来做这件事。</p><h1 id="b100" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">ECMAScript 2020</h1><h2 id="9231" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">BigBang还是BigInt？</h2><p id="af3f" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">遵循IEEE-754的规范<em class="nb">，JavaScript只知道双精度的数据类型号。这就是为什么JavaScript可以保存像<em class="nb"> +0/-0 </em>和<em class="nb"> Infinity、</em>包括<em class="nb"> -Infinity </em>这样的值。此外，不允许的数学运算:除以0是有效的运算，不会导致错误。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/88fbb6f33d542383dc32c96bf9502111.png" data-original-src="https://miro.medium.com/v2/resize:fit:426/format:webp/1*godyla2p1-j_L8Js_ThgRQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Console printout division by zero in JavaScript</figcaption></figure><p id="22c9" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">但是这种功能有其局限性。而整数没有完整的64位大小范围，因为内部处理为浮点数，所以等于整数<br/><strong class="lq ir">(2⁵)-1 = 9007199254740992的绝对最大值。</strong></p><p id="5299" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">如果要访问这个数，可以通过访问常数值<a class="ae kv" href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER" rel="noopener ugc nofollow" target="_blank"> <em class="nb">数来实现。MAX _ SAFE _ INTEGER</em></a><em class="nb">【1】</em>。</p><p id="e259" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">有趣的是，您可以在JavaScript中累加可达到的最大整数值。但是如果你想把1或2相加，结果就不再明显了。大于3时，这也是可能的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/57560a1f3e1fed7901dd5d9dc620e6e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:670/format:webp/1*mkxTYY5NzMyymipGpeh-sg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Console print out from goldExploit.js</figcaption></figure><p id="321a" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">ECMAScript 2020通过在一个数字上加一个“n”或者在初始化变量时只使用<em class="nb"> BigInt </em>函数，使得这一点变得可能。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3872" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">但是请注意。只能用其他BigInt类型的变量计算<em class="nb"> BigInt </em>类型的变量，否则会导致运行时错误。最糟糕的错误！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi or"><img src="../Images/26785f6888a0916b3e56a28ee00880c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1138/format:webp/1*rEg3vwOE_qwjRhp0xY4dDg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">An error by calculating two different number types (BIG_INT and number)</figcaption></figure><p id="ce71" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">这里不要混淆类型，你可以像普通整数一样使用它们。除法会向下舍入到下一个整数。所有其他的像<em class="nb"> +、-、*、/ </em>和<em class="nb"> ** </em>(功率)和<em class="nb"> % </em>(模数)都是合法的，并且非常有效。此外，比较操作符可以按预期工作。唯一的例外是“===”运算符，如果您想要比较两个数字，其中第一个数字的类型为<em class="nb"> BigInt </em>而第二个数字的类型为<em class="nb"> number </em>，则该运算符不可用。比较不安全的“==”一个可用。不知道“==”和“===”的详细区别？<a class="ae kv" href="https://stackoverflow.com/questions/359494/which-equals-operator-vs-should-be-used-in-javascript-comparisons" rel="noopener ugc nofollow" target="_blank">最佳堆栈溢出贴</a>。[2]</p><p id="c902" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">有些函数不能覆盖这个数据类型<em class="nb"> BigInt </em>。<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" rel="noopener ugc nofollow" target="_blank">在你使用无头</a>之前最好查一下这个、<a class="ae kv" href="https://www.smashingmagazine.com/2019/07/essential-guide-javascript-newest-data-type-bigint/" rel="noopener ugc nofollow" target="_blank">。[3][4]</a></p><h2 id="4af6" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">不要再这样了，麻烦制造者</h2><p id="f716" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">你有对付这个小捣蛋鬼的经验吗？当我来自C#时，这看起来像是一个已知的关键字，但我觉得很不对劲。有模因存在于<em class="nb">和</em>之间，而不是出于任何原因。</p><p id="3ee0" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">引入<em class="nb">λ表达式</em>和<em class="nb">严格模式</em>使得<em class="nb">这个</em>变成了一个不再那么锋利的武器。因为写工作代码的努力被那两个降低了。进入全球空间变得更加困难。但是，谁想进入全球空间呢？嗯……有时候，有时候会有需要的场景。</p><p id="33c2" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">在浏览器内部工作，你可以通过<em class="nb">窗口</em>访问它，有时也可以通过<em class="nb">自身</em>或<em class="nb">框架</em>或最后一个选项<em class="nb">这个</em>访问它。节点。JS只提供了<em class="nb">全局</em>和<em class="nb">这个</em>。</p><p id="c953" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">以前，使用一个辅助函数很常见:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2a3a" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">使用该功能也意味着不能使用<em class="nb">严格模式</em>。因为是函数的定义而不是方法的定义，你不能再在任何函数里面定义这个了(函数和方法一样，但是方法在对象里面，而函数在对象外面，就像这个<em class="nb"> getGlobal </em>右边的无主函数)。为了解决这个问题，出现了另一个辅助函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="82ff" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">这个返回，无论结果不是<em class="nb">未定义</em>。这个回归一定是全球空间。ECMAScript 2020介绍了如何消除这些变通办法:</p><blockquote class="ny"><p id="6349" class="nz oa iq bd ob oc od oe of og oh mj dk translated"><em class="oi"> globalThis </em></p></blockquote><p id="d875" class="pw-post-body-paragraph lo lp iq lq b lr os jr lt lu ot ju lw lx ou lz ma mb ov md me mf ow mh mi mj ij bi translated">现在，代码可以更短、更健壮，对于编码人员来说，这是最好的衡量尺度:代码的表达能力。</p><h2 id="c8d6" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">动态导入代码</h2><p id="a6f4" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">如果你开发软件，一定要以模块化为目标。JavaScript为您提供了<em class="nb">导入</em>和<em class="nb">导出</em>关键字，以便创建和使用模块。进口当时有一个缺陷。它允许你只在文件的开头写它。这是必要的，因为环境需要检查哪些引用是导入和导出所必需的。</p><div class="ne nf gp gr ng nh"><a href="https://medium.com/javascript-in-plain-english/javascript-es6-modules-import-export-129a90e83ad6" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">JavaScript ES6模块导入导出</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">ES6模块导入导出业务用JavaScript和JS遗留代码</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="ox l ns nt nu nq nv kp nh"/></div></div></a></div><p id="ea1b" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">当你做一个基于插件的解决方案时，必须在运行时分析所需的插件，因为它们直到运行时才会出现。使用<em class="nb"> require </em>是一种变通方法，它使得在运行时动态加载模块在技术上成为可能，但是每次使用时都会留下代码味道。2020版给我们带来了更好的工作导入。<em class="nb">导入</em>功能。从那时起，现在有了一个导入函数，可以在任何地方调用，并支持动态加载，而关键字import只允许在文件的顶部使用。然后，该模块被异步加载到。为了访问这个模块，你自己履行这个承诺，或者使用await关键字。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="c748" class="mk kx iq bd ky ml mm dn lc mn mo dp lg lx mp mq li mb mr ms lk mf mt mu lm mv bi translated">拿着它，拿着它，爱它！</h2><p id="141d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">因为动态类型系统比互联网本身更古老，所以有一个检查变量、参数或对象属性是否被定义的传统。检查之后，通常将其设置为默认值。主要是一个<em class="nb"> If- </em> check赢得比赛，以找出这些是否等于未定义。结果为true时，将为变量、参数或属性赋一个默认值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="751f" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">有什么可以让它变得更好？<em class="nb"> Falsy </em>值！这些值导致逻辑条件结果为假。与<em class="nb">或</em>-操作符(||)结合使用，您可以将它们用作后备。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="78a0" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">这样看起来好多了，但是效果不会长久，因为这样也改变了语义。<em class="nb"> GetNearestEnemy() </em>将被调用，不仅当<em class="nb">敌人</em>未定义时，而且当<em class="nb">敌人</em>为空、0、假或空字符串时。这是4个选项，如果其中一些可能不会出现在这里，至少有两个总是匹配的，导致在<em class="nb">或</em>-操作符之后的替代。这取决于你使用哪种类型的变量。如果你想用一个数字，你可以这样写:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="fb09" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">该函数现在对于0的输入是安全的。你每次都会造成伤害。0损坏是不可能的。如果你想启用0损害作为一个有效的输入，你必须明确地检查未定义的，用一个If语句。但这是我们试图避免的一件事。解决方案，使用默认参数值:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="068c" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">这个案子已经结了。但是变量和对象属性呢？这些文件现在被搁置了吗？不要！退一步，追查凶手的路径……我的意思是，退一步，在这里搜索真正的问题。每当做这样的检查时，心态是:如果是<em class="nb">未定义</em>或<em class="nb"> null </em>，取默认值，其他值都很大。<br/> ECMAScript 2020引入了<em class="nb">无效合并</em>操作符来解决这个问题。当你有了C#背景，你就知道这个美女了，<em class="nb">？？s </em> ign它在语义上做了完全一样的事情。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4169" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">操作符<em class="nb">空合并总结:如果左侧既不是<em class="nb">空</em>也不是<em class="nb">未定义</em>，则取左侧。如果左侧<em class="nb">为空</em>或<em class="nb">未定义</em>，则取右侧。</em></p><h1 id="bacd" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">漂亮的发型和好听的声音(猫王操作员/可选链接操作员)</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/478048754561188edb7933269262c588.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*HY106w6Noi5nERmtD5jM_g.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A Big Hunk O’ Love — Elvis Presley</figcaption></figure><p id="e21d" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">这里还有一个星号，也是C#中的。是猫王算子(对比图片)。正式命名为“可选链接操作符”。当您想要链接对象的属性时，请使用此选项。您在那里使用点运算符来访问对象的属性或方法。但是，如果您想要访问的点运算符没有定义，则会导致崩溃。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2c86" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">Elvis操作符没有崩溃，而是中断并取消访问以返回undefined。在ECMAScript 2020之前，您必须使用嵌套的if语句来检查深入到对象属性和方法深度的路径的每个部分。但是像猫王一样，我们不再生活在那个时代了。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e700" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">今天只需要这个操作符:左边是定义的，右边是属性/方法，如果不是，返回未定义的。</p><p id="37d8" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated"><em class="nb">注意:只有“？”的对象的内部路径跟踪而不是“？:“是同样的行为。要么获取左侧的内容(如果它没有被定义),要么获取一个预定义的值。虽然它们看起来不同，但却是同一个操作员。"?:" gets也称为三元运算符。</em></p><h1 id="49cc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="5c80" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">ECMAScript为我们提供了大的更新和小的更新。本文向您展示了小家伙们的遭遇，以及如何通过外包繁琐的任务来增强您的编码体验。利用这里介绍的改进来启发您的编码，有更多的时间来做真正酷的任务。JavaScript还没有完全进化。如果你看一下TC39的议程，你会发现离最终目标还有多少距离，如果有最终目标的话。语言是一种活的结构。[5]</p><p id="c054" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">我认为有趣的是，JavaScript变得像C#。C#在过去的几年里发展成为一种功能更强的语言。此外，Typescript，JavaScript的超集，是这两种语言中最好的部分。像他们俩的孩子一样。这会不会导致一个超级孩子，我们会背弃C#和JavaScript只使用TypeScript？</p><p id="901a" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">我们会看到的。现在，看看<a class="ae kv" href="https://github.com/tc39/agendas/blob/master/2020/11.md" rel="noopener ugc nofollow" target="_blank"> TC39议程</a>并关注下一篇文章，当我总结时，ECMAScript 2021是什么！[5]</p><p id="2707" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated"><a class="ae kv" href="https://arnoldcodeacademy.ck.page/26-web-dev-cheat-sheets" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir"> <em class="nb">节省自己大量的时间，专注于重要的主题。</em> </strong> </a></p><h1 id="fa8a" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">继续读</h1><div class="ne nf gp gr ng nh"><a href="https://medium.com/next-level-source-code/enums-typescript-4-0-and-javascript-guide-all-you-need-to-know-5e090355bff6" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">Enums TypeScript 4.0和JavaScript指南—您需要知道的一切</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">你将读到的关于enums的最后一个指南！</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="oz l ns nt nu nq nv kp nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://medium.com/next-level-source-code/do-you-follow-these-10-principles-for-good-programmers-1445727af447" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">你遵循了优秀程序员的这10条原则吗？</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">从接吻和干燥到足球和YAGNI和聪明屁股代码的10个原则！</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="pa l ns nt nu nq nv kp nh"/></div></div></a></div><div class="ne nf gp gr ng nh"><a href="https://medium.com/next-level-source-code/javascript-es6-var-let-or-const-88da65f3a0df" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd ir gy z fp nm fr fs nn fu fw ip bi translated">JavaScript ES6 Var，Let或Const</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">掌握JavaScript中的变量，避免用var，let，const提升</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="pb l ns nt nu nq nv kp nh"/></div></div></a></div><h1 id="2301" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">链接和参考</h1><p id="aa8c" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated"><em class="nb">【1】数字。MAX _ SAFE _ INTEGER</em><a class="ae kv" href="https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/de/docs/Web/JavaScript/Reference/Global _ Objects/Number/MAX _ SAFE _ INTEGER</a></p><p id="b02e" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">[2]“= =”和“===”的区别<a class="ae kv" href="https://stackoverflow.com/questions/359494/which-equals-operator-vs-should-be-used-in-javascript-comparisons" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/359494/which-equals-operator-vs-should-be-use-in-JavaScript-comparisons</a></p><p id="74c0" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">[3]Operators &amp; BigInt Doku:<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Global _ Objects/BigInt</a></p><p id="3884" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">[4]粉碎杂志必备指南BigInt<a class="ae kv" href="https://www.smashingmagazine.com/2019/07/essential-guide-javascript-newest-data-type-bigint/" rel="noopener ugc nofollow" target="_blank">https://www . smashingmagazine . com/2019/07/Essential-Guide-JavaScript-newest-data-type-BigInt/</a></p><p id="abdb" class="pw-post-body-paragraph lo lp iq lq b lr mw jr lt lu mx ju lw lx my lz ma mb mz md me mf na mh mi mj ij bi translated">[5] TC39议程【https://github.com/tc39/agendas/blob/master/2020/11.md】<br/>T3</p></div></div>    
</body>
</html>