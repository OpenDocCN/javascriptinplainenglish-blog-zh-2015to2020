<html>
<head>
<title>Useful JavaScript Tips — Timestamps, Combining Values, and Calling Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有用的JavaScript技巧——时间戳、组合值和调用函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/useful-javascript-tips-timestamps-combining-values-and-calling-functions-70af74f583f4?source=collection_archive---------5-----------------------#2020-07-01">https://javascript.plainenglish.io/useful-javascript-tips-timestamps-combining-values-and-calling-functions-70af74f583f4?source=collection_archive---------5-----------------------#2020-07-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cb01f8fcbb54b5370c9fe0695905485e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WM6PbhVySKWg8PT2"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@martinsanchez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Martin Sanchez</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2d05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些应该遵循的技巧，以便更快更好地编写JavaScript代码。</p><h1 id="b802" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在JavaScript中提取UNIX时间戳</h1><p id="a252" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">+</code>操作符获得一个<code class="fe me mf mg mh b">Date</code>实例的UNIX时间戳。</p><p id="6d2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f4bd" class="mq lc iq mh b gy mr ms l mt mu">+new Date(2020, 0, 1)</span></pre><p id="5793" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到1577865600000。</p><p id="b9b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以使用<code class="fe me mf mg mh b">getTime</code>方法来做同样的事情:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="60f8" class="mq lc iq mh b gy mr ms l mt mu">new Date(2020, 0, 1).getTime()</span></pre><p id="1016" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到同样的回报。</p><p id="61d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果日期是YYYY-MM-DD格式，也可以解析。</p><p id="a4f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0937" class="mq lc iq mh b gy mr ms l mt mu">new Date('2020-01-01').getTime()</span></pre><p id="3dd7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也得到了同样的东西。</p><p id="3f71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">时间戳是从UTC时间1970年1月1日12点开始的毫秒数。</p><p id="f007" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以将返回的数字除以1000，转换成秒。</p><h1 id="1645" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将数组值组合成一个</h1><p id="84c8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">reduce</code>方法将数组条目减少到一个结果中。</p><p id="a8b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f4db" class="mq lc iq mh b gy mr ms l mt mu">const cart = [{price: 10}, {price: 40}, {price: 20}];</span></pre><p id="ce9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们从<code class="fe me mf mg mh b">cart</code>得到的总价格可以写成:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ecbc" class="mq lc iq mh b gy mr ms l mt mu">const reducer = (total, item) =&gt; total + item.price;const total = <!-- -->cart<!-- -->.reduce(reducer, 0);</span></pre><p id="049f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">total</code>就是70，因为我们通过将所有<code class="fe me mf mg mh b">cart</code>条目的<code class="fe me mf mg mh b">price</code>属性的值相加来组合它们。</p><h1 id="3d56" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检测文档是否准备好</h1><p id="b1db" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">document.readyState</code>属性检测一个页面是否被完全加载。</p><p id="1503" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6050" class="mq lc iq mh b gy mr ms l mt mu">if (document.readyState === 'complete') {<br/>  //...<br/>}</span></pre><p id="3402" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来检测一个页面是否被完全加载，然后做一些事情。</p><p id="16f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用以下方法定期检查状态:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="876a" class="mq lc iq mh b gy mr ms l mt mu">let stateCheck = setInterval(() =&gt; {<br/>  if (document.readyState === 'complete') {<br/>    clearInterval(stateCheck);<br/>    // document ready<br/>  }<br/>}, 100);</span></pre><p id="61ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以每隔100毫秒检查一次页面的加载状态，直到它准备好。</p><p id="e7d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">if</code>块中，我们调用<code class="fe me mf mg mh b">clearInterval</code>来结束计时器，因此我们将停止检查<code class="fe me mf mg mh b">readyState</code>。</p><p id="e6ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以通过以下方式监听<code class="fe me mf mg mh b">readystatechange</code>事件:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5f77" class="mq lc iq mh b gy mr ms l mt mu">document.onreadystatechange = () =&gt; {<br/>  if (document.readyState === 'complete') {<br/>    // document ready<br/>  }<br/>}</span></pre><p id="400b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比创建一个计时器并运行它直到就绪状态改变要好。</p><h1 id="4dbe" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">计算数组的最大值或最小值</h1><p id="3463" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以向<code class="fe me mf mg mh b">Math.max</code>或<code class="fe me mf mg mh b">Math.min</code>方法中传递尽可能多的值，以检查数组的最大值或最小值。</p><p id="5308" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="eadd" class="mq lc iq mh b gy mr ms l mt mu">const max = Math.max(1, 2, 3);</span></pre><p id="fc46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回最大值或:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b380" class="mq lc iq mh b gy mr ms l mt mu">const min = Math.min(1, 2, 3);</span></pre><p id="eb4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回最小值。</p><p id="b730" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要传入数组，我们可以使用spread运算符:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a623" class="mq lc iq mh b gy mr ms l mt mu">const max = Math.max(...[1, 2, 3]);</span></pre><p id="8ca2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d27c" class="mq lc iq mh b gy mr ms l mt mu">const min = Math.min(...[1, 2, 3]);</span></pre><p id="e09b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以使用<code class="fe me mf mg mh b">apply</code>如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="879a" class="mq lc iq mh b gy mr ms l mt mu">const max = Math.max.apply(undefined, [1, 2, 3]);</span></pre><p id="46d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="eb60" class="mq lc iq mh b gy mr ms l mt mu">const min = Math.min.apply(undefined, [1, 2, 3]);</span></pre><p id="0ee4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">apply</code>将<code class="fe me mf mg mh b">this</code>的值作为第一个参数，由于<code class="fe me mf mg mh b">Math.max</code>和<code class="fe me mf mg mh b">Math.min</code>是静态方法，所以第一个参数是<code class="fe me mf mg mh b">undefined</code>。</p><p id="3afb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是一个参数数组，我们希望将它作为参数传入数组。</p><h1 id="999d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函数参数中的析构</h1><p id="c2ba" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用析构语法来析构对象参数。</p><p id="c49d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="eb84" class="mq lc iq mh b gy mr ms l mt mu">const greet = ({ name, lastName }) =&gt; {<br/>  console.log(`hi, ${name} ${lastName}`);<br/>};</span></pre><p id="f853" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过析构赋值获得对象的<code class="fe me mf mg mh b">name</code>和<code class="fe me mf mg mh b">lastName</code>属性。</p><p id="297f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过调用:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="59fc" class="mq lc iq mh b gy mr ms l mt mu">greet({ name: 'jane', lastName: 'doe' })</span></pre><p id="6edd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以为析构变量设置一个默认值。</p><p id="09c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a816" class="mq lc iq mh b gy mr ms l mt mu">const greet = ({ name = 'jane', lastName = 'smith' }) =&gt; {<br/>  console.log(`hi, ${name} ${lastName}`);<br/>};</span></pre><p id="ac34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们用文字称之为:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="657c" class="mq lc iq mh b gy mr ms l mt mu">greet({})</span></pre><p id="4bf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">name</code>就是<code class="fe me mf mg mh b">'jane'</code>，而<code class="fe me mf mg mh b">lastName</code>就是<code class="fe me mf mg mh b">'smith'</code>，因为我们没有设置这两个属性的值。</p><h1 id="c7c9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">防止改变内置原型</h1><p id="5bba" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以调用<code class="fe me mf mg mh b">Object.freeze</code>来阻止改变对象，包括内置的原型。</p><p id="c864" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b8ad" class="mq lc iq mh b gy mr ms l mt mu">Object.freeze(Object.prototype);<br/>Object.freeze(Array.prototype);<br/>Object.freeze(Function.prototype);</span></pre><p id="57e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以防止改变任何内置原型。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/389929cacaf63c2deaec9ccde8eb7961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KSYPiY0YLczpIMVH"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@memoreno?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Martin Moreno</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="aa8b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0e81" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">Object.freeze</code>防止改变内置原型。</p><p id="22fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用spread操作符或<code class="fe me mf mg mh b">apply</code>来调用带有一组参数的函数。</p><p id="b30d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有各种方法可以获得UNIX时间戳。</p><h2 id="d76c" class="mq lc iq bd ld mv mw dn lh mx my dp ll ko mz na lp ks nb nc lt kw nd ne lx nf bi translated">简单英语的JavaScript</h2><p id="0e16" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？在<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">plain English . io</strong></a>和<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">找到它们订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>