<html>
<head>
<title>The most surprising behavior of JavaScript regular expression you have ever seen</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你见过的最令人惊讶的JavaScript正则表达式行为</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/most-surprising-behavior-of-javascript-regular-expression-you-have-ever-seen-1ddb84539163?source=collection_archive---------4-----------------------#2020-02-07">https://javascript.plainenglish.io/most-surprising-behavior-of-javascript-regular-expression-you-have-ever-seen-1ddb84539163?source=collection_archive---------4-----------------------#2020-02-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b2ac" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">我敢肯定，你可能从来没有注意到这个令人惊讶的行为</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1f5c861c8fa52d1dd48eb4c9423bc998.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6U9gDwB5YAuLTdhmb0mvsw.png"/></div></div></figure><blockquote class="kr ks kt"><p id="a7e9" class="ku kv kw kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> JavaScript正则表达式对象在模式中有/g或/y标志匹配时是有状态的。</strong></p></blockquote><p id="267d" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">当您创建一个带有<code class="fe lu lv lw lx b">/g</code>标志的正则表达式时，它维护<code class="fe lu lv lw lx b">lastIndex</code>属性，该属性跟踪<strong class="kx ir">索引，从哪里开始寻找下一个匹配</strong>。所以下次当我们开始使用相同的模式测试时，它会从找到最后一个匹配的索引开始搜索。</p><p id="fe8e" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">考虑一下，我们有这样一个正则表达式</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="1bf4" class="mc md iq lx b gy me mf l mg mh">const pattern = /ab/g;</span></pre><p id="8e3e" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">如果你想找出这个模式是否存在于任何一个被传递的字符串中，我们可以这样做:</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="af9e" class="mc md iq lx b gy me mf l mg mh">console.log(pattern.test('abcd')) // true<br/>console.log(pattern.lastIndex) // 2</span></pre><p id="a5e0" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">但是由于<code class="fe lu lv lw lx b">lastIndex</code>属性是由存储在变量<code class="fe lu lv lw lx b">pattern</code>中的正则表达式维护的，变量<code class="fe lu lv lw lx b">pattern</code>最初为0，当它在字符串<code class="fe lu lv lw lx b">abcd</code>中的<code class="fe lu lv lw lx b">0th</code>位置找到匹配时变为2，所以当我们下次调用<code class="fe lu lv lw lx b">test</code>方法时，它从<code class="fe lu lv lw lx b">2nd</code>位置开始搜索匹配，所以匹配失败。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="45ab" class="mc md iq lx b gy me mf l mg mh">console.log(pattern.test('abcd')) // true<br/>console.log(pattern.lastIndex) // 2</span><span id="67a0" class="mc md iq lx b gy mi mf l mg mh">console.log(pattern.test('abcd')) // false<br/>console.log(pattern.lastIndex) // 0</span></pre><p id="ca22" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">由于它无法从位置2开始在<code class="fe lu lv lw lx b">abcd</code>中找到字符串<code class="fe lu lv lw lx b">ab</code>，它将<code class="fe lu lv lw lx b">lastIndex</code>属性重置为<code class="fe lu lv lw lx b">0</code>，因此当我们再次调用该方法时，它将返回<code class="fe lu lv lw lx b">true</code>。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="8d9e" class="mc md iq lx b gy me mf l mg mh">console.log(pattern.test('abcd')) // true</span></pre><blockquote class="mj"><p id="4321" class="mk ml iq bd mm mn mo mp mq mr ms lq dk translated"><strong class="ak"> <em class="mt">这可能不是您所期望的行为，但这就是正则表达式在使用</em> </strong> <code class="fe lu lv lw lx b"><strong class="ak"><em class="mt">test()</em></strong></code> <strong class="ak"> <em class="mt">或</em> </strong> <code class="fe lu lv lw lx b"><strong class="ak"><em class="mt">exec()</em></strong></code> <strong class="ak"> <em class="mt">方法时维护lastIndex属性的方式。</em> </strong></p></blockquote><p id="3726" class="pw-post-body-paragraph ku kv iq kx b ky mu jr la lb mv ju ld lr mw lg lh ls mx lk ll lt my lo lp lq ij bi translated">在某些情况下，这种行为有时很有用。</p><p id="c050" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated"><em class="kw">假设你想找到一个字符串中所有元音的位置，你可以这样做</em></p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="1a33" class="mc md iq lx b gy me mf l mg mh">const source = "This is some text";<br/>const pattern = /[aeiou]/g;</span><span id="1566" class="mc md iq lx b gy mi mf l mg mh">while((result = pattern.exec(source)) !== null) {<br/>  console.log("Character " + result[0] + " found at position " + (pattern.lastIndex - 1));<br/>}</span><span id="8de5" class="mc md iq lx b gy mi mf l mg mh">/* output:</span><span id="b3c2" class="mc md iq lx b gy mi mf l mg mh">Character i found at position 2<br/>Character i found at position 5<br/>Character o found at position 9<br/>Character e found at position 11<br/>Character e found at position 14</span><span id="2949" class="mc md iq lx b gy mi mf l mg mh">*/</span></pre><p id="1377" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">但这可能不是你一直想要的行为。</p><p id="5437" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">所以在那种情况下，你可以使用正则表达式的<code class="fe lu lv lw lx b">match()</code>方法，而不是<code class="fe lu lv lw lx b">test()</code>或者<code class="fe lu lv lw lx b">exec()</code>。</p><p id="3127" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">如果您只想使用<code class="fe lu lv lw lx b">test()</code>方法，那么您需要在每次搜索后将<code class="fe lu lv lw lx b">lastIndex</code>重置为0。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="fba5" class="mc md iq lx b gy me mf l mg mh">const pattern = /ab/g;<br/>console.log(pattern.test('abcd')) // true<br/>pattern.lastIndex = 0;<br/>console.log(pattern.test('abcd')) // true</span></pre><p id="e2ff" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated"><em class="kw">这是你见过的最令人惊讶的正则表达式行为之一。</em></p><p id="4d1b" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated">今天到此为止。希望你今天学到了新东西。</p><p id="2206" class="pw-post-body-paragraph ku kv iq kx b ky kz jr la lb lc ju ld lr lf lg lh ls lj lk ll lt ln lo lp lq ij bi translated"><strong class="kx ir">别忘了直接在你的收件箱</strong> <a class="ae mz" href="https://yogeshchavan.dev" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">这里</strong> </a> <strong class="kx ir">订阅我的每周时事通讯，里面有惊人的技巧、诀窍和文章。</strong></p></div></div>    
</body>
</html>