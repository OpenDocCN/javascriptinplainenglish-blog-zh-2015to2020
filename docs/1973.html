<html>
<head>
<title>Angular Route Reuse Strategy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度路由重用策略</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-route-reuse-strategy-b5d40adce841?source=collection_archive---------0-----------------------#2020-05-09">https://javascript.plainenglish.io/angular-route-reuse-strategy-b5d40adce841?source=collection_archive---------0-----------------------#2020-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/48f97392fadd3d567548c307f6974c27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A35OgC5ANH6gEX0dxctWMw.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@steve_j?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Steve Johnson</a> on <a class="ae kc" href="https://unsplash.com/s/photos/storage?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="602f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当导航离开一条路线时，Angular破坏相应的组件，除非新路线使用相同的组件(例如，如果我们从<code class="fe lb lc ld le b">/user/12</code>导航到<code class="fe lb lc ld le b">/user/57</code>)。Angular在可能的情况下重用组件，但在其他情况下会破坏它们以释放内存，这是大多数情况下需要的行为。</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="d5cc" class="ln lo iq le b gy lp lq l lr ls">    /user/12    ----------------------------------&gt;   /user/57<br/>  UserComponent                                     UserComponent</span><span id="b70e" class="ln lo iq le b gy lt lq l lr ls"><br/>   /user/12     -------------&gt; /users ------------&gt;   /user/57<br/>  UserComponent           UserListComponent         UserComponent</span></pre><p id="daa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在第一种情况下，<code class="fe lb lc ld le b">UserComponent</code>将被重用。不过在第二个版本中，<code class="fe lb lc ld le b">UserComponent</code>将在导航到<code class="fe lb lc ld le b">/users</code>时被销毁，并在导航到<code class="fe lb lc ld le b">/user/57</code>时被重新创建。</p><p id="f1fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你知道你很快会再次需要一个组件时，销毁它是你想要避免的。与往常一样，Angular提供了一个解决方案，并让您通过实现<a class="ae kc" href="https://angular.io/api/router/RouteReuseStrategy" rel="noopener ugc nofollow" target="_blank">routereustrategy</a>类来定义自己的重用策略。</p><h1 id="4fd2" class="lu lo iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">主/详细界面</h1><p id="67ae" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">您可以从实现自己的重用策略中获益的一个经典例子是主/细节接口。在这样的界面中，用户通常在主视图(元素列表)和细节视图之间切换。在每次导航后销毁/重建这些页面并不是最佳选择。</p><p id="c023" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你可以看看下面的gif，在我们每次关闭详细信息页面时，列表出现之前会有一个小的延迟。这是因为list组件在每次构建时都会获取图书。我们可以通过缓存和重用列表组件来防止这种情况。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/ae3cf01f0e8d55857b1fa633f8f9e70b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*om1nm2uQkLFlrPEDudguzw.gif"/></div></figure><h1 id="6c63" class="lu lo iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">定制路由重用策略</h1><p id="74c9" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">为了防止在视图之间导航时组件被破坏，我们需要实现自己的路由重用策略。我们创建一个实现抽象类<code class="fe lb lc ld le b">RouteReuseStrategy</code>的类<code class="fe lb lc ld le b">CustomRouteReuseStrategy</code>，并在我们的模块中提供它。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="605a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，为了实现<code class="fe lb lc ld le b">RouteReuseStrategy</code>类，我们必须实现五个方法(它们的定义来自<a class="ae kc" href="https://angular.io/api/router/RouteReuseStrategy" rel="noopener ugc nofollow" target="_blank"> Angular文档</a>):</p><ul class=""><li id="bb78" class="mz na iq kf b kg kh kk kl ko nb ks nc kw nd la ne nf ng nh bi translated"><code class="fe lb lc ld le b">shouldDetach</code>:确定该路由(及其子树)是否应该分离，以便以后重用。</li><li id="84e4" class="mz na iq kf b kg ni kk nj ko nk ks nl kw nm la ne nf ng nh bi translated"><code class="fe lb lc ld le b">store</code>:存储分离的路线。</li><li id="1c05" class="mz na iq kf b kg ni kk nj ko nk ks nl kw nm la ne nf ng nh bi translated"><code class="fe lb lc ld le b">shouldAttach</code>:确定是否应该重新附加此路由(及其子树)。</li><li id="893b" class="mz na iq kf b kg ni kk nj ko nk ks nl kw nm la ne nf ng nh bi translated"><code class="fe lb lc ld le b">retrieve</code>:检索先前存储的路线。</li><li id="3b39" class="mz na iq kf b kg ni kk nj ko nk ks nl kw nm la ne nf ng nh bi translated"><code class="fe lb lc ld le b">shouldReuseRoute</code>:确定是否应该重复使用一条路线。</li></ul><p id="d3e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular的默认路由重用策略如下所示:</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Source: <a class="ae kc" href="https://github.com/angular/angular/blob/master/packages/router/src/route_reuse_strategy.ts" rel="noopener ugc nofollow" target="_blank">Angular Source Code</a></figcaption></figure><p id="9965" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如前所述，如果新路由与前一个路由具有相同的配置(使用相同的组件), Angular就会重用该路由，否则就不会。我们希望保持这种行为，所以我们复制了这个<code class="fe lb lc ld le b">shouldReuseRoute</code>函数的实现。如果你想防止Angular在从<code class="fe lb lc ld le b">/user/57</code>导航到<code class="fe lb lc ld le b">/user/12</code>时重用组件，这个函数将是改变的正确位置，但这不是我们打算做的。</p><p id="4205" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们对其他四种方法感兴趣。<code class="fe lb lc ld le b">shouldDetach</code>和<code class="fe lb lc ld le b">store</code>在你离开一条路线时被调用。如果<code class="fe lb lc ld le b">shouldDetach</code>返回<code class="fe lb lc ld le b">true</code>，那么我们需要<code class="fe lb lc ld le b">store</code>该路由，因为我们希望以后重用它。<code class="fe lb lc ld le b">shouldAttach</code>和<code class="fe lb lc ld le b">retrieve</code>在输入路线时被调用。如果<code class="fe lb lc ld le b">shouldAttach</code>返回<code class="fe lb lc ld le b">true</code>，我们希望重用之前存储的路线，而不是构建新的组件。</p><h1 id="48cc" class="lu lo iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">存储和检索列表组件</h1><p id="462c" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">要缓存列表组件，我们首先需要存储它。因此，当路由路径等于列表视图的路径时，我们应该将<code class="fe lb lc ld le b">true</code>返回到<code class="fe lb lc ld le b">shouldDetach</code>，在我们的例子中是<code class="fe lb lc ld le b">list</code>。我们需要自己保管，但这听起来很简单。我们只需要存储与我们的路线相对应的<code class="fe lb lc ld le b">DetachedRouteHandle</code>，例如使用路线路径作为关键字存储在<code class="fe lb lc ld le b">Map</code>中。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f7e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">储存到此为止。现在，当回到列表视图时，我们想要重用我们存储的路由句柄，如果我们有一个的话。因此，如果我们的<code class="fe lb lc ld le b">storedRoutes</code>中有给定路线路径的值，我们将<code class="fe lb lc ld le b">true</code>返回到<code class="fe lb lc ld le b">shouldAttach</code>。检索路由句柄很容易，我们从<code class="fe lb lc ld le b">storedRoutes</code>返回对应于路径的值。</p><figure class="lf lg lh li gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e9db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">list组件现在被存储和重用，避免了每次进入主视图时都必须获取书籍。我们再也看不到这种短暂的延迟。</p><figure class="lf lg lh li gt jr gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/bb3a1d6921b108b46a34824232211398.png" data-original-src="https://miro.medium.com/v2/resize:fit:1040/1*5BfWZar5N7IMLpa6KN3Ghg.gif"/></div></figure></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="c244" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个简单的例子，但我希望它能帮助您了解如何实现定制的重用策略。这五种方法一开始可能看起来有点混乱，但是它们实际上有明确定义的角色:</p><ul class=""><li id="c629" class="mz na iq kf b kg kh kk kl ko nb ks nc kw nd la ne nf ng nh bi translated"><code class="fe lb lc ld le b">shouldReuseRoute</code>允许您决定是否允许Angular在引用相同组件类的路径之间导航时重复使用相同的组件对象，或者Angular是否每次都应销毁和重建组件。</li><li id="450f" class="mz na iq kf b kg ni kk nj ko nk ks nl kw nm la ne nf ng nh bi translated"><code class="fe lb lc ld le b">shouldDetach</code>和<code class="fe lb lc ld le b">store</code>分别让你决定一个组件是否应该以后存储，如果是，让你存储它。当离开一条路线时，它被调用。</li><li id="bb93" class="mz na iq kf b kg ni kk nj ko nk ks nl kw nm la ne nf ng nh bi translated"><code class="fe lb lc ld le b">shouldAttach</code>和<code class="fe lb lc ld le b">retrieve</code>分别让你决定是否重用一个存储的组件，而不是创建一个新的组件，如果是，让你把这个存储的组件交给Angular。当输入一条路线时，它被调用。</li></ul></div><div class="ab cl nn no hu np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ij ik il im in"><p id="ff73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">来源</strong>:</p><p id="6650" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个例子是使用<a class="ae kc" href="https://openlibrary.org/dev/docs/api/books" rel="noopener ugc nofollow" target="_blank"> OpenLibrary </a>构建的。书籍可以从它们的ISBN中获取，因此要获取三本指环王书籍作为一个JSON对象，我们调用:</p><pre class="lf lg lh li gt lj le lk ll aw lm bi"><span id="66ae" class="ln lo iq le b gy lp lq l lr ls"><a class="ae kc" href="https://openlibrary.org/api/books?format=json&amp;jscmd=data&amp;bibkeys=ISBN:0261103253,ISBN:9780261102361,ISBN:9780618002245" rel="noopener ugc nofollow" target="_blank">https://openlibrary.org/api/books?format=json&amp;jscmd=data&amp;bibkeys=ISBN:0261103253,ISBN:9780261102361,ISBN:9780618002245</a></span></pre><h2 id="fb03" class="ln lo iq bd lv nu nv dn lz nw nx dp md ko ny nz mh ks oa ob ml kw oc od mp oe bi translated">进一步阅读</h2><div class="of og gp gr oh oi"><a href="https://bit.cloud/blog/how-to-reuse-react-components-across-your-projects-l4pz83f4" rel="noopener  ugc nofollow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">如何在项目中重用React组件</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">最后，您完成了为应用程序中的表单创建一个奇妙的输入字段的任务。你对……很满意</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">比特云</p></div></div><div class="or l"><div class="os l ot ou ov or ow jw oi"/></div></div></a></div><p id="696a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="ox">更多内容看</em> <a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="ox">说白了。报名参加我们的</em> <a class="ae kc" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="ox">免费周报</em> </strong> </a> <em class="ox">。关注我们上</em> <a class="ae kc" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="ox">推特</em> </strong> </a>，<a class="ae kc" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="ox">LinkedIn</em></strong></a><strong class="kf ir"><em class="ox">，</em></strong><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="ox">YouTube</em></strong></a><strong class="kf ir"><em class="ox">，以及</em></strong><em class="ox"><a class="ae kc" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="ox">不和</em> </strong> </a></em> </strong> <em class="ox">对成长黑客感兴趣？检查出</em> </a><a class="ae kc" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="ox">电路</em> </strong> </a> <strong class="kf ir"> <em class="ox">。</em>T75】</strong></p></div></div>    
</body>
</html>