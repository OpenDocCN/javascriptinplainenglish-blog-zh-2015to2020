<html>
<head>
<title>How does ‘Require’ and ‘Module’ work in Node.js?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js中的‘Require’和‘Module’是如何工作的？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-do-nodejs-require-and-module-work-545ab4fe5423?source=collection_archive---------5-----------------------#2020-07-16">https://javascript.plainenglish.io/how-do-nodejs-require-and-module-work-545ab4fe5423?source=collection_archive---------5-----------------------#2020-07-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="6836" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用<code class="fe ki kj kk kl b">require("someModule")</code>在另一个文件中导入一个模块，但是是在幕后使<code class="fe ki kj kk kl b">require</code>工作吗？</p></div><div class="ab cl km kn hr ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ig ih ii ij ik"><h2 id="130d" class="kt ku in bd kv kw kx dn ky kz la dp lb jv lc ld le jz lf lg lh kd li lj lk ll bi translated">步骤的顺序</h2><ol class=""><li id="3628" class="lm ln in jm b jn lo jr lp jv lq jz lr kd ls kh lt lu lv lw bi translated"><strong class="jm io"> <em class="lx">解析</em> </strong>:获取模块的绝对路径。</li><li id="1feb" class="lm ln in jm b jn ly jr lz jv ma jz mb kd mc kh lt lu lv lw bi translated"><strong class="jm io"> <em class="lx">加载</em> </strong>:加载模块</li><li id="78e3" class="lm ln in jm b jn ly jr lz jv ma jz mb kd mc kh lt lu lv lw bi translated"><strong class="jm io"> <em class="lx">包装</em> </strong>:给你的变量一个单独的范围。</li><li id="9602" class="lm ln in jm b jn ly jr lz jv ma jz mb kd mc kh lt lu lv lw bi translated"><strong class="jm io"> <em class="lx">评估</em> </strong>:是VM(通常是V8)最终对代码做的事情</li><li id="8c91" class="lm ln in jm b jn ly jr lz jv ma jz mb kd mc kh lt lu lv lw bi translated"><strong class="jm io"> <em class="lx">缓存</em> </strong>:缓存模块，以备再次使用。</li></ol><h2 id="5ec9" class="kt ku in bd kv kw kx dn ky kz la dp lb jv lc ld le jz lf lg lh kd li lj lk ll bi translated">当我们需要一个模块时会发生什么？</h2><p id="cf14" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">为了弄清楚需求模块是如何工作的，我们可以使用或者在REPL模式下输入<code class="fe ki kj kk kl b">module</code>。<code class="fe ki kj kk kl b">module</code>在全局对象中可用。</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi mg"><img src="../Images/9215b54b59fbc7857ab077e57ee5a2b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-nCztAGbeIqI7d-wvwk8aA.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">paths inside the `module`</figcaption></figure><p id="464c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我使用这一行代码:<code class="fe ki kj kk kl b">const test = require("tetsModule")</code> Node.js将查看路径数组中的位置来找到这个模块。</p><ul class=""><li id="218d" class="lm ln in jm b jn jo jr js jv mw jz mx kd my kh mz lu lv lw bi translated">第一步，它在当前文件夹的node_modules中查找，如果找不到该模块，它将逐步查找父文件夹。</li><li id="a423" class="lm ln in jm b jn ly jr lz jv ma jz mb kd mc kh mz lu lv lw bi translated">之后，Node.js会查看你的home文件夹中的<code class="fe ki kj kk kl b">.node_modules</code>文件夹，如果你用的是Linux或者Mac。</li><li id="3822" class="lm ln in jm b jn ly jr lz jv ma jz mb kd mc kh mz lu lv lw bi translated">最后，查看Node.js所在的文件夹</li></ul><p id="05a9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些是找到<strong class="jm io"> <em class="lx">非核心模块</em> s. </strong>核心模块是异常，Node.js立即找到它们。</p><h2 id="9ed5" class="kt ku in bd kv kw kx dn ky kz la dp lb jv lc ld le jz lf lg lh kd li lj lk ll bi translated">有没有可能只解析一个模块而不执行？</h2><p id="c96f" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">答案是肯定的，为此我们需要使用<code class="fe ki kj kk kl b">require.resolve</code>。</p><p id="76eb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">const m = require.resolve("myModuleName");</code></p><p id="ee6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">有什么用法？<br/> </strong>帮助你检查模块是否存在。</p><h2 id="34f7" class="kt ku in bd kv kw kx dn ky kz la dp lb jv lc ld le jz lf lg lh kd li lj lk ll bi translated">需要具有相对和绝对路径的模块</h2><p id="5b5c" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">要使用相对路径，我们需要从<code class="fe ki kj kk kl b">.</code>或<code class="fe ki kj kk kl b">..</code>开始。<br/>一个例子:<code class="fe ki kj kk kl b">const test = require("./testFolder/myFile.js")</code></p><p id="493c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要使用绝对路径我们需要从<code class="fe ki kj kk kl b">/</code> <br/>开始一个例子:<code class="fe ki kj kk kl b">const test = require('/home/poorshad/Desktop/myfile.js')</code></p><h2 id="6971" class="kt ku in bd kv kw kx dn ky kz la dp lb jv lc ld le jz lf lg lh kd li lj lk ll bi translated">如果我们需要两个模块在彼此内部，会发生什么？</h2><p id="86a7" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">在Node.js中允许循环引用，我们可以引用如下代码所示的模块:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi na"><img src="../Images/dfb3c51fd19b9194d1d7629c153a065f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-JGskVbpnBfStVKSL8Lvkg.png"/></div></div><figcaption class="ms mt gj gh gi mu mv bd b be z dk">Circular reference</figcaption></figure><p id="f520" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们用Node.js运行<code class="fe ki kj kk kl b">Test.js</code>,终端中的结果将是这样的:</p><figure class="mh mi mj mk gt ml gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/3290d340cea6b288d60a88e9a16759d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*ryBlyz2JxoQhrAto9exyZQ.png"/></div></figure><p id="6b6e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们在<code class="fe ki kj kk kl b">Test.js</code>中导入了<code class="fe ki kj kk kl b">f1.js</code>，所以它是第一个需要加载的模块，控制台中的第一个日志是<code class="fe ki kj kk kl b">it is f1</code>。</p><p id="fd36" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<code class="fe ki kj kk kl b">f1.js</code>内部，我们导入了<code class="fe ki kj kk kl b">f2.js</code>，因此，我们可以在控制台中看到<code class="fe ki kj kk kl b">this is f2</code>。</p><p id="4300" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们在<code class="fe ki kj kk kl b">f2.js</code> f1模块中记录<code class="fe ki kj kk kl b">f1</code>时，模块还没有导出它的变量，我们在控制台上得到一个空对象。在这个控制台日志<code class="fe ki kj kk kl b">f2</code>模块导出后，它的变量出现在它代码的第4行和第5行。现在，模块<code class="fe ki kj kk kl b">f2</code>已完全加载。</p><p id="89ff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Node.js从<code class="fe ki kj kk kl b">f1.js</code>的第3行继续，由于<code class="fe ki kj kk kl b">f2.js</code>已加载，它在控制台中将<code class="fe ki kj kk kl b">[2]</code>显示为该模块的值。</p><p id="6029" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们可以在控制台的最后一行看到<code class="fe ki kj kk kl b">Test.js</code>的控制台日志。</p><h2 id="3f01" class="kt ku in bd kv kw kx dn ky kz la dp lb jv lc ld le jz lf lg lh kd li lj lk ll bi translated">当我们需要一个没有扩展名的文件时`<em class="nc">requires`</em>如何处理文件扩展名？</h2><p id="f245" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv md jx jy jz me kb kc kd mf kf kg kh ig bi translated">例如，我们有这样一行代码:</p><pre class="mh mi mj mk gt nd kl ne nf aw ng bi"><span id="2d89" class="kt ku in kl b gy nh ni l nj nk">const myFile = require("./myFile");</span></pre><p id="2d20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Node.js将按以下顺序执行:</p><pre class="mh mi mj mk gt nd kl ne nf aw ng bi"><span id="5818" class="kt ku in kl b gy nh ni l nj nk">myFile.js<br/>myFile.json<br/>myFile.node</span></pre></div></div>    
</body>
</html>