<html>
<head>
<title>React and TypeScript: Generic Search, Sort, and Filter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React和TypeScript:一般搜索、排序和过滤</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-and-typescript-generic-search-sort-and-filter-879c5c3e2f0e?source=collection_archive---------0-----------------------#2020-10-27">https://javascript.plainenglish.io/react-and-typescript-generic-search-sort-and-filter-879c5c3e2f0e?source=collection_archive---------0-----------------------#2020-10-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="211c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">利用TypeScript泛型的强大功能实现可重用的搜索、排序和过滤的分步指南。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/93a85712faa4caa5164f5dd1320272b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q4C3LGm0jGTaDtoSco5d1w.jpeg"/></div></div></figure><p id="e273" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><a class="ae lk" href="https://chrisfrewin.com/blog/react-typescript-generic-search-sort-and-filters/" rel="noopener ugc nofollow" target="_blank"> <em class="ll">本帖镜像在我的个人博客</em><strong class="kq io"><em class="ll">chrisfrew . in</em></strong><em class="ll">上，这里有语法高亮和代码片段复制！</em>T11】</a></p><p id="f875" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="ll">通过我的课程中的完整视频课程，学习这篇文章中详细介绍的所有内容，以及更多内容，Skillshare和Udemy上的</em> <strong class="kq io"> <em class="ll">【高级打字稿:通用搜索、排序和过滤】</em></strong><em class="ll">:</em></p><div class="lm ln gp gr lo lp"><a href="https://skl.sh/3oGQMbr" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd io gy z fp lu fr fs lv fu fw im bi translated">高级类型脚本:一般搜索、排序和筛选| Chris Frewin | Skillshare</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">这门课将会是关于在TypeScript中使用泛型。在本课程中，我们将首先回顾…</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">skl.sh</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md km lp"/></div></div></a></div><div class="lm ln gp gr lo lp"><a href="https://www.udemy.com/course/advanced-typescript-generic-search-sorting-and-filtering/?referralCode=22441D8B6B06045473D2" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd io gy z fp lu fr fs lv fu fw im bi translated">高级类型脚本:一般搜索、排序和筛选</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">Chris Frewin是一名专业的全栈软件工程师，从事编程已经超过七年…</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">www.udemy.com</p></div></div><div class="ly l"><div class="me l ma mb mc ly md km lp"/></div></div></a></div><h1 id="a88d" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">示例存储库</h1><p id="59c5" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">示例存储库在这里。</p><h1 id="336c" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">动机</h1><p id="12bd" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">在最近的一个项目中，我的任务是实现前端过滤和搜索功能。然而，该任务还要求排序和过滤功能可以很容易地应用于任何类型。幸运的是，我一直在大量使用<a class="ae lk" href="https://www.typescriptlang.org/docs/handbook/generics.html" rel="noopener ugc nofollow" target="_blank">泛型</a>(并且慢慢地越来越好！)，但是我给自己(和我的同事)留下了特别深刻的印象，我构建了一个轻量级的、完全可重用的解决方案。</p><p id="4d8e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我想我会和大家分享我的解决方案。尽情享受吧！</p><h1 id="0595" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">第一:通用搜索！</h1><p id="16db" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">让我们先来看看搜索函数，因为它是我们将要构建的三个函数中最简单的一个。</p><p id="a77e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">假设我们有一个API端点，它返回一个类型为<code class="fe nc nd ne nf b"><strong class="kq io">T</strong></code>的数组。对于搜索，通常，我们希望能够查询(潜在的)多个<code class="fe nc nd ne nf b"><strong class="kq io">T</strong></code>属性，并让搜索返回至少有一个属性匹配的元素。因此，构建这样一个函数，我们需要对象本身、我们想要搜索的属性和查询。</p><p id="4830" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是JavaScript的 <code class="fe nc nd ne nf b"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">Array.prototype.filter()</strong></a></code> <a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">函数</a>的一个完美用例，它从调用它的数组中接受一个对象并返回true或false。</p><p id="f4d6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们还需要函数中的查询值本身，以匹配对象的实际值。</p><p id="b2c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">至此，我们已经可以构建函数的签名了:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="8caa" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">export function genericSearch&lt;T&gt;(object: T, properties: Array&lt;keyof T&gt;, query: string): boolean {</strong></span><span id="7d18" class="nk mg in nf b gy np nm l nn no"><strong class="nf io">}</strong></span></pre><p id="9724" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意这里漂亮的<code class="fe nc nd ne nf b"><strong class="kq io">keyof T</strong></code>输入。那是最重要的！😂</p><p id="d662" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">TypeScript只允许我们传递表示对象<code class="fe nc nd ne nf b"><strong class="kq io">T</strong></code>中键名的字符串值。记住，我们说过我们希望允许<em class="ll">有多个<code class="fe nc nd ne nf b"><strong class="kq io">T</strong></code>类型的</em>属性，所以这些属性是<code class="fe nc nd ne nf b"><strong class="kq io">keyof T</strong></code>的一个<code class="fe nc nd ne nf b"><strong class="kq io">Array</strong></code>，即<code class="fe nc nd ne nf b"><strong class="kq io">Array&lt;keyof T&gt;</strong></code>。所以我们需要做的第一件事就是遍历这些属性。<code class="fe nc nd ne nf b"><strong class="kq io">map</strong></code>应该做的:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="1006" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">properties.map(property =&gt; {</strong></span><span id="fcbe" class="nk mg in nf b gy np nm l nn no"><strong class="nf io">})</strong></span></pre><p id="82db" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个<code class="fe nc nd ne nf b"><strong class="kq io">map</strong></code>中，我们现在可以像这样访问值:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="fe83" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">object[property]</strong></span></pre><p id="24ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">TypeScript不会抱怨这个语法，因为它知道<code class="fe nc nd ne nf b"><strong class="kq io">property</strong></code>实际上是一个<code class="fe nc nd ne nf b"><strong class="kq io">keyof T</strong></code> - <em class="ll">但是</em>，我们不能直接访问属性值<em class="ll"/>，例如。<code class="fe nc nd ne nf b"><strong class="kq io">object[property].toString()</strong></code>因为TypeScript会声明<code class="fe nc nd ne nf b"><strong class="kq io">keyof T</strong></code>不属于<code class="fe nc nd ne nf b"><strong class="kq io">string</strong></code>类型，所以我们需要在一个变量中存储该值的一个副本(这无论如何都会使代码更干净):</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="046f" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">const value = object[property];</strong></span></pre><p id="69a2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于属性值和查询之间的实际字符串搜索，我决定使用漂亮的<code class="fe nc nd ne nf b"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">String.prototype.includes()</strong></a></code> <a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes" rel="noopener ugc nofollow" target="_blank">函数</a>。然而，如果我们试图在我们的<code class="fe nc nd ne nf b"><strong class="kq io">value</strong></code> <code class="fe nc nd ne nf b"><strong class="kq io">const</strong></code>上直接使用<code class="fe nc nd ne nf b"><strong class="kq io">includes()</strong></code>，TypeScript将<em class="ll">仍然</em>抱怨，这是理所当然的，因为我们的<code class="fe nc nd ne nf b"><strong class="kq io">value</strong></code>不一定是类型<code class="fe nc nd ne nf b"><strong class="kq io">string</strong></code>。我们可以做一些类型检查来让TypeScript满意(即使你决定使用正则表达式而不是<code class="fe nc nd ne nf b"><strong class="kq io">includes()</strong></code>，你也需要同样的类型检查——因为正则表达式只能作用于<code class="fe nc nd ne nf b"><strong class="kq io">string</strong></code>类型。)</p><p id="c93c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过这种类型检查，到目前为止，我们的函数如下所示:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="ff20" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">export function genericSearch&lt;T&gt;(object: T, properties: Array&lt;keyof T&gt;, query: string): boolean {<br/>    properties.map(property =&gt; {<br/>        const value = object[property];<br/>        if (typeof value === "string" || typeof value === "number") {<br/>            return value.toString().includes(query)<br/>        }<br/>        return false;<br/>    })<br/>}</strong></span></pre><p id="f283" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于我正在构建的搜索的具体情况，我认为如果它是不区分大小写的，那么它是最用户友好的，所以我在对象和查询值上都使用了<code class="fe nc nd ne nf b"><strong class="kq io">toLowerCase()</strong></code>。然而，这可能是一个额外的标志或选项，您可以在其中指定在最后的<code class="fe nc nd ne nf b"><strong class="kq io">if</strong></code>块中做什么。所以，加上这两个<code class="fe nc nd ne nf b"><strong class="kq io">toLowerCase()</strong></code>调用，我们有:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="60d7" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">export function genericSearch&lt;T&gt;(object: T, properties: Array&lt;keyof T&gt;, query: string): boolean {<br/>    properties.map(property =&gt; {<br/>        const value = object[property];<br/>        if (typeof value === "string" || typeof value === "number") {<br/>            return value.toString().toLowerCase().includes(query.toLowerCase())<br/>        }<br/>        return false;<br/>    })<br/>}</strong></span></pre><p id="95c2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在让我们实际上为我们的<code class="fe nc nd ne nf b"><strong class="kq io">map</strong></code>返回的内容分配一个<code class="fe nc nd ne nf b"><strong class="kq io">const</strong></code>，称之为<code class="fe nc nd ne nf b"><strong class="kq io">expressions</strong></code>:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="1711" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">export function genericSearch&lt;T&gt;(object: T, properties: Array&lt;keyof T&gt;, query: string): boolean {<br/>    const expressions = properties.map(property =&gt; {<br/>        const value = object[property];<br/>        if (typeof value === "string" || typeof value === "number") {<br/>            return value.toString().toLowerCase().includes(query.toLowerCase())<br/>        }<br/>        return false;<br/>    })<br/>}</strong></span></pre><p id="c445" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，<code class="fe nc nd ne nf b"><strong class="kq io">expressions</strong></code>是一个由<code class="fe nc nd ne nf b"><strong class="kq io">boolean</strong></code>值组成的数组。如果<em class="ll">至少</em>一个如果<code class="fe nc nd ne nf b"><strong class="kq io">true</strong></code>，我们想要返回<code class="fe nc nd ne nf b"><strong class="kq io">true</strong></code>(因为如果查询在我们正在搜索的对象类型的属性的<em class="ll">任何</em>中，我们想要匹配)。我们可以编写自己的for循环或map，并自己显式地进行这种检查，但这是2020年——数组函数再次拯救了我们！看看<code class="fe nc nd ne nf b"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">Array.prototype.some()</strong></a></code>！这正是我们想要的，基于一个测试函数。我们的值已经是true / false，所以我们的测试函数只是返回布尔值本身。</p><p id="e612" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以我们总共有:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="bdb3" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">export function genericSearch&lt;T&gt;(object: T, properties: Array&lt;keyof T&gt;, query: string): boolean {<br/>    const expressions = properties.map(property =&gt; {<br/>        const value = object[property];<br/>        if (typeof value === "string" || typeof value === "number") {<br/>            return value.toString().toLowerCase().includes(query.toLowerCase())<br/>        }<br/>        return false;<br/>    })<br/>    return expressions.some(expression =&gt; expression);<br/>}</strong></span></pre><p id="c4bf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是等等，我们可以把<em class="ll">甚至</em>做得更好！由于我们的<code class="fe nc nd ne nf b"><strong class="kq io">if</strong></code>语句和类型检查<em class="ll">是我们的</em>测试函数，我们可以稍微重构一下，删除<code class="fe nc nd ne nf b"><strong class="kq io">map</strong></code>和<code class="fe nc nd ne nf b"><strong class="kq io">expressions</strong></code>常量，直接在属性上调用<code class="fe nc nd ne nf b"><strong class="kq io">.some()</strong></code>，并返回<code class="fe nc nd ne nf b"><strong class="kq io">some()</strong></code>函数的结果:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="26e1" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">// case insensitive search of n-number properties of type T<br/>// returns true if at least one of the property values includes the query value<br/>export function genericSearch&lt;T&gt;(<br/>    object: T,<br/>    properties: Array&lt;keyof T&gt;,<br/>    query: string<br/>): boolean {</strong></span><span id="f098" class="nk mg in nf b gy np nm l nn no"><strong class="nf io">    if (query === "") {<br/>        return true;<br/>    } </strong></span><span id="8edb" class="nk mg in nf b gy np nm l nn no"><strong class="nf io">    return properties.some((property) =&gt; {<br/>        const value = object[property];<br/>        if (typeof value === "string" || typeof value === "number") {<br/>            return value.toString().toLowerCase().includes(query.toLowerCase());<br/>        }<br/>        return false;<br/>    });<br/>}</strong></span></pre><p id="ede0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">😄漂亮！</p><h1 id="6c97" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">第二:通用排序器！</h1><p id="0d15" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">本着与<code class="fe nc nd ne nf b"><strong class="kq io">genericSearch</strong></code>函数相同的思路，我们来写一个可以接受任何类型<code class="fe nc nd ne nf b"><strong class="kq io">T</strong></code>的<code class="fe nc nd ne nf b"><strong class="kq io">genericSort</strong></code>函数。在<code class="fe nc nd ne nf b"><strong class="kq io">genericSearch</strong></code>被用于<code class="fe nc nd ne nf b"><strong class="kq io">filter</strong></code>数组函数的情况下，<code class="fe nc nd ne nf b"><strong class="kq io">genericSort</strong></code>函数当然会被应用为数组<code class="fe nc nd ne nf b"><strong class="kq io">sort</strong></code>调用的回调。因此，这需要一个比较器函数，接受类型为<code class="fe nc nd ne nf b"><strong class="kq io">T</strong></code>的“a”和“b”对象，以及当前活动的排序器:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="4698" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">export function genericSort&lt;T&gt;(<br/>  objectA: T,<br/>  objectB: T,<br/>  sorter: ISorter&lt;T&gt;<br/>) {<br/>...<br/>}</strong></span></pre><p id="2dff" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">其中ISorter(也是通用的)是一个帮助接口，帮助我们跟踪活动的过滤器属性，以及排序是否应该是降序的:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="abb9" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">export default interface ISorter&lt;T&gt; {<br/>    property: Extract&lt;keyof T, string | number | Date&gt;;<br/>    isDescending: boolean;<br/>}</strong></span></pre><p id="0e32" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请再次注意，我们在这里使用了<code class="fe nc nd ne nf b"><strong class="kq io">keyof T</strong></code>语法，但是只提取了那些与<code class="fe nc nd ne nf b"><strong class="kq io">&gt;</strong></code>和<code class="fe nc nd ne nf b"><strong class="kq io">&lt;</strong></code>比较器操作预期功能相同的类型(对我们来说是<code class="fe nc nd ne nf b"><strong class="kq io">string</strong></code> s、<code class="fe nc nd ne nf b"><strong class="kq io">number</strong></code> s和<code class="fe nc nd ne nf b"><strong class="kq io">Date</strong></code>s——您自己的应用程序中可能有更多类型！)我们可以如下使用它:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="4832" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">const result = () =&gt; {<br/>    if (objectA[property] &gt; objectB[property]) {<br/>        return 1;<br/>    } else if (objectA[property] &lt; objectB[property]) {<br/>        return -1;<br/>    } else {<br/>        return 0;<br/>    }<br/>}</strong></span></pre><p id="29af" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，如果降序排序是<code class="fe nc nd ne nf b"><strong class="kq io">true</strong></code>，我们对<code class="fe nc nd ne nf b"><strong class="kq io">result</strong></code>的值取反，并返回它:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="0f6a" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">return sorter.isDescending ? result() * -1 : result();</strong></span></pre><p id="04b7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">总之，我们的<code class="fe nc nd ne nf b"><strong class="kq io">genericSort</strong></code>函数看起来像这样:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="4a0d" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">import ISorter from "../interfaces/ISorter";</strong></span><span id="067b" class="nk mg in nf b gy np nm l nn no"><strong class="nf io">// comparator function for any property within type T<br/>// works for: strings, numbers, and Dates (and is typed to accept only properties which are those types)<br/>// could be extended for other types but would need some custom comparison function here<br/>export function genericSort&lt;T&gt;(<br/>  objectA: T,<br/>  objectB: T,<br/>  sorter: ISorter&lt;T&gt;<br/>) {<br/>  const result = () =&gt; {<br/>    if (objectA[sorter.property] &gt; objectB[sorter.property]) {<br/>        return 1;<br/>    } else if (objectA[sorter.property] &lt; objectB[sorter.property]) {<br/>        return -1;<br/>    } else {<br/>        return 0;<br/>    }<br/>  }</strong></span><span id="bf51" class="nk mg in nf b gy np nm l nn no"><strong class="nf io">  return sorter.isDescending ? result() * -1 : result();<br/>}</strong></span></pre><h1 id="75da" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">第三:通用滤镜！</h1><p id="d28a" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">对于我们的最后一个功能，让我们实现通用过滤。在<code class="fe nc nd ne nf b"><strong class="kq io">genericSearch</strong></code>是一个<code class="fe nc nd ne nf b"><strong class="kq io">filter</strong></code>回调的情况下，它有点特殊，比较用户输入的值。对于<code class="fe nc nd ne nf b"><strong class="kq io">T</strong></code>(在我们的例子中是<code class="fe nc nd ne nf b"><strong class="kq io">IWidget</strong></code>)的每个给定属性，我们将允许用户选择他们是否想要查看该属性的<em class="ll">真实</em>或<em class="ll">虚假</em>的所有项目。</p><h1 id="3701" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">真理？福尔西。啊？🤔</h1><p id="b489" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated"><code class="fe nc nd ne nf b"><strong class="kq io">T</strong></code>的任何属性都可以有任何类型。为了避免编写基于各种类型的花哨过滤函数，我退回到JavaScript对<em class="ll"> falsy </em>和<em class="ll"> truthy </em>值的评估——换句话说，一个给定值在布尔语句中使用时的评估结果。概括一下，最常见的<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank"> JavaScript原语</a>的<em class="ll"> falsy </em>值如下:</p><p id="3258" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">TypeFalsey值<code class="fe nc nd ne nf b"><strong class="kq io">objectundefined</strong></code>、<code class="fe nc nd ne nf b"><strong class="kq io">null</strong></code>、<code class="fe nc nd ne nf b"><strong class="kq io">NaNstring""number0booleanfalse</strong></code>(咄！😂)</p><p id="67bf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">其中每种类型的任何其他值在布尔评估中将评估为<code class="fe nc nd ne nf b"><strong class="kq io">true</strong></code>。</p><p id="be0f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我意识到为用户提供每个属性的真与假的选项可能有些过头了。您可以决定对某些属性只提供一个过滤器。这取决于您正在过滤的实际项目以及您希望UI中包含的内容。为了完整性和您的方便，我已经实现了。😄</p><p id="2f56" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">也就是说，我们可以预期我们的<code class="fe nc nd ne nf b"><strong class="kq io">genericFilter</strong></code>需要什么样的签名。我们需要将出现在<code class="fe nc nd ne nf b"><strong class="kq io">filter()</strong></code>回调中的<code class="fe nc nd ne nf b"><strong class="kq io">T</strong></code>类型的对象，以及活动过滤器本身:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="5242" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">export function genericFilter&lt;T&gt;(object: T, filters: Array&lt;IFilter&lt;T&gt;&gt;) {<br/>...<br/>}</strong></span></pre><p id="67f6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">其中<code class="fe nc nd ne nf b"><strong class="kq io">IFilter</strong></code>是一个帮助界面(也是通用的),帮助跟踪我们正在过滤的属性，以及用户是否选择查看它们真实或虚假的一面:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="576d" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">export default interface IFilter&lt;T&gt; {<br/>    property: keyof T;<br/>    isTruthyPicked: boolean;<br/>}</strong></span></pre><p id="8576" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后，我们要确保选择的每个<em class="ll">过滤器都适用于我们当前正在过滤的项目。这是JavaScript的 <code class="fe nc nd ne nf b"><a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" rel="noopener ugc nofollow" target="_blank"><strong class="kq io">Array.prototype.every()</strong></a></code> <a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every" rel="noopener ugc nofollow" target="_blank">函数</a>的完美用例。</em></p><p id="0d90" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">回到JavaScript的truthy / falsy评估并使用<code class="fe nc nd ne nf b"><strong class="kq io">Array.prototype.every()</strong></code>,<code class="fe nc nd ne nf b"><strong class="kq io">genericFilter</strong></code>的实际过滤逻辑非常容易理解:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="3558" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">return filters.every((filter) =&gt; {<br/>    return filter.isTruthyPicked ? object[filter.property] :     !object[filter.property];<br/>});</strong></span></pre><p id="d9fd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">回到每个属性的truthy和falsy选项:我生成了一对单选按钮，用户可以根据它们的truthy或falsy值显式地过滤对象。</p><p id="d570" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，对于我们的<code class="fe nc nd ne nf b"><strong class="kq io">IWidget</strong></code>的<code class="fe nc nd ne nf b"><strong class="kq io">title</strong></code>属性，用户可以明确地选择显示所有<code class="fe nc nd ne nf b"><strong class="kq io">title</strong></code>为真的结果。标记为“is falsy”的单选按钮当然会提供相反的结果(显示小部件，其中<code class="fe nc nd ne nf b"><strong class="kq io">title</strong></code>是一个空字符串——到目前为止，在我的模拟数据中只有一个在<a class="ae lk" href="https://github.com/princefishthrower/react-typescript-generic-search-sort-and-filter" rel="noopener ugc nofollow" target="_blank">示例存储库</a>中)。或者，当没有为给定属性选择单选按钮时，当然对该属性的过滤没有影响。</p><p id="34a3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可能还想实现一个clear all按钮，该按钮将删除在<code class="fe nc nd ne nf b"><strong class="kq io">genericSearch</strong></code>中使用的<code class="fe nc nd ne nf b"><strong class="kq io">filters</strong></code>数组(有状态的，更多细节见下一节)中的所有项目，但是我将把这个任务留给您。😄</p><p id="7f6e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">总之我们的<code class="fe nc nd ne nf b"><strong class="kq io">genericFilter</strong></code>函数看起来是这样的:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="9870" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">import IFilter from "../interfaces/IFilters";</strong></span><span id="2e03" class="nk mg in nf b gy np nm l nn no"><strong class="nf io">// filter n properties for truthy or falsy values on type T (no effect if no filter selected)<br/>export function genericFilter&lt;T&gt;(object: T, filters: Array&lt;IFilter&lt;T&gt;&gt;) {<br/>  // no filters; no effect - return true<br/>  if (filters.length === 0) {<br/>    return true;<br/>  }</strong></span><span id="9ebe" class="nk mg in nf b gy np nm l nn no"><strong class="nf io">  return filters.every((filter) =&gt; {<br/>    return filter.isTruthyPicked ? <br/>    object[filter.property] : <br/>    !object[filter.property];<br/>  });<br/>}</strong></span></pre><h1 id="a803" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">把一切都联系起来</h1><p id="9d2c" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">因此，我们有(在我看来)非常酷的通用<code class="fe nc nd ne nf b"><strong class="kq io">genericSearch</strong></code>、<code class="fe nc nd ne nf b"><strong class="kq io">genericSort</strong></code>和<code class="fe nc nd ne nf b"><strong class="kq io">genericFilter</strong></code>函数。让我们把它们接到我们的阵列上。</p><p id="fc71" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于没有过滤的标准列表呈现(姑且称之为<code class="fe nc nd ne nf b"><strong class="kq io">widgets</strong></code>带<code class="fe nc nd ne nf b"><strong class="kq io">Array&lt;IWidget&gt;</strong></code> ) <em class="ll">，你应该这样做:</em></p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="5af1" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">widgets.map(<br/>    item =&gt; return &lt;SomeComponentToRenderYourWidget {...object}/&gt;<br/>)</strong></span></pre><p id="609a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了挂接我们的函数，我们应该这样做:</p><pre class="kd ke kf kg gt ng nf nh ni aw nj bi"><span id="6089" class="nk mg in nf b gy nl nm l nn no"><strong class="nf io">import { genericSearch } from "./utils/genericSearch";<br/>import { genericSort } from "./utils/genericSort";<br/>import { genericFilter } from "./utils/genericFilter";<br/>import IWidget from './interfaces/IWidget';</strong></span><span id="8bb2" class="nk mg in nf b gy np nm l nn no"><strong class="nf io">...</strong></span><span id="0b8c" class="nk mg in nf b gy np nm l nn no"><strong class="nf io">return (<br/>    &lt;&gt;<br/>        {widgets<br/>            .filter((widget) =&gt;<br/>                genericSearch&lt;IWidget&gt;(widget, ["title", "description"], query)<br/>            )<br/>            .sort((widgetA, widgetB) =&gt;<br/>                genericSort&lt;IWidget&gt;(widgetA, widgetB, activeSorter)<br/>            )<br/>            .filter((widget) =&gt; <br/>                genericFilter&lt;IWidget&gt;(widget, activeFilters)<br/>            ).map(widget =&gt; <br/>                return &lt;SomeComponentToRenderYourWidget {...widget}/&gt;<br/>            )<br/>        }<br/>    &lt;/&gt;<br/>)</strong></span></pre><p id="2f6d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过向<code class="fe nc nd ne nf b"><strong class="kq io">genericSearch</strong></code>函数提供<code class="fe nc nd ne nf b"><strong class="kq io">&lt;IWidget&gt;</strong></code>类型，如果在<code class="fe nc nd ne nf b"><strong class="kq io">properties</strong></code>数组中传递的任何字符串在<code class="fe nc nd ne nf b"><strong class="kq io">IWidget</strong></code>中不存在，TypeScript将对我们大喊。同样的还有<code class="fe nc nd ne nf b"><strong class="kq io">genericFilter</strong></code>和<code class="fe nc nd ne nf b"><strong class="kq io">genericSort</strong></code>。这里不再有讨厌的运行时错误！</p><p id="7739" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">即使我们忘记了<code class="fe nc nd ne nf b"><strong class="kq io">IWidget</strong></code>中的某个属性是<code class="fe nc nd ne nf b"><strong class="kq io">object</strong></code>或者某个无法排序或搜索的其他类型，我们也知道这些属性不会对搜索结果有任何影响，因为我们在<code class="fe nc nd ne nf b"><strong class="kq io">search</strong></code>和<code class="fe nc nd ne nf b"><strong class="kq io">sort</strong></code>函数中进行了类型检查(在这种情况下我们返回<code class="fe nc nd ne nf b"><strong class="kq io">false</strong></code>)。</p><p id="9804" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们的<code class="fe nc nd ne nf b"><strong class="kq io">filter</strong></code>函数是<em class="ll">函数，所以</em>是泛型的，我们根本不用担心，并且可以在这里传递所有类型的属性，这要归功于JavaScript的真实和虚假的功能。</p><h1 id="67df" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">重要警告</h1><p id="4c34" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">事实上，在上面的代码片段中，我遗漏了一些步骤来获得一个完全运行的应用程序。您需要您的<code class="fe nc nd ne nf b"><strong class="kq io">query</strong></code>、<code class="fe nc nd ne nf b"><strong class="kq io">activeSorter</strong></code>和<code class="fe nc nd ne nf b"><strong class="kq io">activeFilters</strong></code>变量是有状态的，我们当然必须实际实现<code class="fe nc nd ne nf b"><strong class="kq io">&lt;SomeComponentToRenderYourWidget/&gt;</strong></code>组件来呈现每个<code class="fe nc nd ne nf b"><strong class="kq io">widget</strong></code>中的值。不过，这些都是在<a class="ae lk" href="https://github.com/princefishthrower/react-typescript-generic-search-sort-and-filter" rel="noopener ugc nofollow" target="_blank">示例存储库中</a>实现的。</p><h1 id="533e" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">这应该成为节点包吗？😍</h1><p id="f382" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">如果有兴趣的话，通过进一步的清理和选项设置，以及一些微调，我相信这可以移植到一个开源项目和Node.js包中——尽管我确信还有其他的过滤/排序/搜索包和解决方案。请在评论中告诉我！</p><h1 id="4158" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">塞:在我的课程中了解更多信息！</h1><p id="12d8" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">您可以在本文中了解到所有细节，并通过我课程中的完整视频课程,<strong class="kq io">“高级类型脚本:通用搜索、排序和过滤”</strong>可在Skillshare和Udemy上获得:</p><div class="lm ln gp gr lo lp"><a href="https://skl.sh/3oGQMbr" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd io gy z fp lu fr fs lv fu fw im bi translated">高级类型脚本:通用搜索、排序和过滤| Chris Frewin | Skillshare</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">本课程将讲述如何在TypeScript中使用泛型。在本课程中，我们'将从复习…</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">skl.sh</p></div></div><div class="ly l"><div class="lz l ma mb mc ly md km lp"/></div></div></a></div><div class="lm ln gp gr lo lp"><a href="https://www.udemy.com/course/advanced-typescript-generic-search-sorting-and-filtering/?referralCode=22441D8B6B06045473D2" rel="noopener  ugc nofollow" target="_blank"><div class="lq ab fo"><div class="lr ab ls cl cj lt"><h2 class="bd io gy z fp lu fr fs lv fu fw im bi translated">高级类型脚本:通用搜索、排序和过滤</h2><div class="lw l"><h3 class="bd b gy z fp lu fr fs lv fu fw dk translated">Chris Frewin已经是一名专业的完整堆栈软件工程师超过七年，并为更多的人编程…</h3></div><div class="lx l"><p class="bd b dl z fp lu fr fs lv fu fw dk translated">www.udemy.com</p></div></div><div class="ly l"><div class="me l ma mb mc ly md km lp"/></div></div></a></div><p id="ca23" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要免费预览前几节课，请查看YouTube上的播放列表:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="1033" class="mf mg in bd mh mi mj mk ml mm mn mo mp jt mq ju mr jw ms jx mt jz mu ka mv mw bi translated">谢谢你！</h1><p id="6209" class="pw-post-body-paragraph ko kp in kq b kr mx jo kt ku my jr kw kx mz kz la lb na ld le lf nb lh li lj ig bi translated">我希望你喜欢这个帖子。我非常喜欢TypeScript及其泛型能力的力量。我希望这个帖子对你有用！</p><p id="9773" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">干杯！🍺</p><p id="ceae" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">-克里斯</p></div></div>    
</body>
</html>