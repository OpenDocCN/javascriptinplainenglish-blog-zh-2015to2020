<html>
<head>
<title>ELI5: Binary Search Trees 🌲</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ELI5:二分搜索法树🌲</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/eli5-binary-search-trees-fd560f81b553?source=collection_archive---------11-----------------------#2020-12-15">https://javascript.plainenglish.io/eli5-binary-search-trees-fd560f81b553?source=collection_archive---------11-----------------------#2020-12-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9da3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">先说算法。特别是二叉查找树算法。在这篇文章中，我将解释(比如你5岁)什么是二叉查找树，如何实现它，以及何时使用它。准备好了吗？我们走吧！</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/3b717e15d01b1f612cccb312783222da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gFqq_Osp7P4iIvXE"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@hectorfalcon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hector Falcon</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0d59" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么是二叉查找树？🌲</h1><p id="884f" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">二叉查找树是一种有序的树形数据结构。这是一种根据一组“大于/小于”规则对数据进行排序的便捷方式。</p><p id="9a18" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">树是由称为节点的东西组成的。每当您向树中添加新数据时，它就开始排序之旅，从根节点开始，沿着树向下，直到找到一个空位置插入。很快会有更多的技术术语。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">New nodes finding a home in our binary search tree</figcaption></figure><p id="4e17" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">换句话说，当你添加一个新的数据到你的树中时，它会寻找一个空的位置来建立它的家。把你的新数据想象成一个人想要在一个完美的地点建造他们的家。你有一些规则可以遵循，以找到你的完美家园地段。一个接一个，新的数据(也就是我们正在寻找一个称之为家的地方的人)基于“我，这个新的数据点，是大于还是小于这个当前的家？”</p><p id="d07c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种比较产生两种选择:</p><ol class=""><li id="c7de" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">如果比当前房屋少，它会沿着左边的街道检查下一个地块是否是空的。如果下一个地段是空的，我们的<em class="me">新的</em>数据点将在那里安家。如果下一个地块被占用，它继续与下一个住宅进行比较，直到找到一个空的地块。</li></ol><p id="dfc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.或者，如果它比当前房屋大，它会沿着正确的街道检查下一个地块是否是空的。如果下一个地段是空的，我们的<em class="me">新的</em>数据点就在那里安家。如果下一个批次被占用，它将继续进行比较，直到找到一个空批次。</p><h1 id="f818" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">二叉查找树的特征📝</h1><ul class=""><li id="d101" class="mf mg in jm b jn lx jr ly jv mo jz mp kd mq kh mr ml mm mn bi translated">有一个根节点</li><li id="b0b8" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mr ml mm mn bi translated">有父节点、兄弟节点和子节点</li><li id="03e4" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mr ml mm mn bi translated">父节点可以有0、1或2个子节点。</li><li id="5aa5" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mr ml mm mn bi translated">左边的子节点总是小于它们的父节点</li><li id="cc68" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mr ml mm mn bi translated">右边的子节点总是大于它们的父节点</li><li id="ef35" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mr ml mm mn bi translated">左侧的同级节点总是小于当前节点</li><li id="4dda" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mr ml mm mn bi translated">右边的同级节点总是大于当前节点</li><li id="7f0c" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mr ml mm mn bi translated">根节点是最大值节点</li></ul><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="16b5" class="nc la in my b gy nd ne l nf ng">// EXAMPLE OF A BINARY SEARCH TREE</span><span id="5d1e" class="nc la in my b gy nh ne l nf ng">//          22         &lt;&lt; 22 is the root node</span><span id="f9a6" class="nc la in my b gy nh ne l nf ng">//         /  \</span><span id="a274" class="nc la in my b gy nh ne l nf ng">//        19   100     &lt;&lt; 19 &amp; 100 are children of 22 &amp; parent nodes</span><span id="5455" class="nc la in my b gy nh ne l nf ng">//       / \   / \</span><span id="1a8a" class="nc la in my b gy nh ne l nf ng">//      11 20 53 250  &lt;&lt; 11 has one child, 20/53/250 have none</span><span id="a21f" class="nc la in my b gy nh ne l nf ng">//      /</span><span id="eb9a" class="nc la in my b gy nh ne l nf ng">//     5</span></pre></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><h1 id="4c0a" class="kz la in bd lb lc np le lf lg nq li lj lk nr lm ln lo ns lq lr ls nt lu lv lw bi translated">代码:实现⌨️二叉查找树</h1><p id="c335" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">让我们使用JavaScript和ES6语法写出我们的代码。我们将在一个类中编写所有内容。</p><h1 id="102a" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">1.声明我们的类构造函数</h1><p id="5c5b" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">首先，我们声明节点类，并在其中编写构造函数:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="a82a" class="nc la in my b gy nd ne l nf ng">class Node {<br/>  constructor(data) {<br/>   this.data = data;<br/>   this.left = null;<br/>   this.right = null;<br/>  }<br/>}</span></pre><p id="fad2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们树上的每个节点都有三条重要信息:</p><ol class=""><li id="69b3" class="mf mg in jm b jn jo jr js jv mh jz mi kd mj kh mk ml mm mn bi translated">this.data =节点的实际数据</li><li id="a8f0" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">this.left =当前节点左侧的同级节点的信息</li><li id="bb5b" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mk ml mm mn bi translated">this.right =当前节点右侧的同级节点的信息</li></ol><p id="801f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这三条信息创建了节点本身，并为树中的其他节点提供了重要的上下文和连接。当我们遍历树时，这些连接将帮助我们。</p><p id="ac07" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将this.left和this.right设置为空值，因为我们没有将新创建的节点插入到我们的树中。那是我们的下一步！</p><h1 id="be46" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">2.创建“插入”方法</h1><p id="0d87" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">好了，让我们将新创建的节点插入到二叉查找树中。为此，我们需要在我们的类中创建一个方法。</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="b53f" class="nc la in my b gy nd ne l nf ng">class Node {</span><span id="e54a" class="nc la in my b gy nh ne l nf ng">// oh look, it's the code we just wrote!</span><span id="4775" class="nc la in my b gy nh ne l nf ng">constructor(data) {<br/>    this.data = data;<br/>    this.left = null;<br/>    this.right = null;<br/>  }</span><span id="6ac0" class="nc la in my b gy nh ne l nf ng">// hello, new "insert" method!</span><span id="558b" class="nc la in my b gy nh ne l nf ng">insert(data) {<br/>    if (data &lt; this.data &amp;&amp; this.left) {<br/>      this.left.insert(data);<br/>    } else if (data &lt; this.data) {<br/>      this.left = new Node(data);<br/>    }</span><span id="17b0" class="nc la in my b gy nh ne l nf ng">    if (data &gt; this.data &amp;&amp; this.right) {<br/>      this.right.insert(data);<br/>    } else if (data &gt; this.data) {<br/>      this.right = new Node(data);<br/>    }<br/>  }<br/>}</span></pre><p id="3abf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看我们新的“insert”方法代码，我们看到它依赖于将未排序的节点与树中的每个节点进行比较，直到找到最佳位置。我们想看看传入的数据是否大于/小于当前节点的数据。如果它小于当前节点，我们检查左边的子节点位置，如果它未赋值，我们在那里插入新数据。如果它已经被分配，我们再次开始比较过程，并使用左边的子节点作为当前节点。未排序的数据会将其自身插入/分配到第一个可用且有效的未结位置。</p><h1 id="cc6d" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">3.创建“包含”方法</h1><p id="a79a" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">我们已经创建了自己的类和一个向二叉查找树中插入新数据的方法。现在我们想检查特定的数据是否包含在我们的树中。我们如何做到这一点？再写一个方法！</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="1c9e" class="nc la in my b gy nd ne l nf ng">class Node {</span><span id="f516" class="nc la in my b gy nh ne l nf ng">// new node constructor!</span><span id="0d9c" class="nc la in my b gy nh ne l nf ng">constructor(data) {<br/>    this.data = data;<br/>    this.left = null;<br/>    this.right = null;<br/>  }</span><span id="280d" class="nc la in my b gy nh ne l nf ng">// "insert" method!</span><span id="a134" class="nc la in my b gy nh ne l nf ng">insert(data) {<br/>    if (data &lt; this.data &amp;&amp; this.left) {<br/>      this.left.insert(data);<br/>    } else if (data &lt; this.data) {<br/>      this.left = new Node(data);<br/>    }</span><span id="bff2" class="nc la in my b gy nh ne l nf ng">    if (data &gt; this.data &amp;&amp; this.right) {<br/>      this.right.insert(data);<br/>    } else if (data &gt; this.data) {<br/>      this.right = new Node(data);<br/>    }<br/>  }</span><span id="eb34" class="nc la in my b gy nh ne l nf ng">// let's write our "contains" method below!</span><span id="a5c2" class="nc la in my b gy nh ne l nf ng">contains(data) {<br/>    if (this.data === data) {<br/>      return this;<br/>    }</span><span id="9a87" class="nc la in my b gy nh ne l nf ng">    if (data &lt; this.data &amp;&amp; this.left) {<br/>      return this.left.contains(data);<br/>    } else if (data &gt; this.data &amp;&amp; this.right) {<br/>      return this.right.contains(data);<br/>    } else {<br/>      return null;<br/>    }<br/>  }<br/>}</span></pre><p id="ca5d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您注意到，我们的“包含”方法与“插入”方法非常相似。我们从一个数据点开始，遍历我们的树，将该数据点与左边和右边的节点进行比较。不同的是我们的基本情况。“包含”方法的基本情况是当我们成功地找到我们正在寻找的数据时:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="2c6d" class="nc la in my b gy nd ne l nf ng">if (this.data === data) {<br/>      return this;<br/>    }</span></pre><p id="ac94" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者，当我们搜索了整个树但没有找到数据时:</p><pre class="kj kk kl km gt mx my mz na aw nb bi"><span id="6b94" class="nc la in my b gy nd ne l nf ng">else {<br/>      return null;<br/>    }</span></pre></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><h1 id="39a7" class="kz la in bd lb lc np le lf lg nq li lj lk nr lm ln lo ns lq lr ls nt lu lv lw bi translated">我们什么时候用二分搜索法树？🧐</h1><p id="a30c" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">每当您想要使用大于/小于方法比较数据时，此算法都很有用。如果您有一组数字，可以使用二叉查找树对它们进行排序。另一个例子，如果你有一个名单，你想按字母顺序排序，二叉查找树是一个很好的选择。</p><h1 id="5ddf" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论💭</h1><p id="a3a1" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">二分搜索法树是一种快速排序和搜索数据集的方法，因为数据是根据二元规则组织的。你可以在这里了解更多关于二叉查找树数据结构<a class="ae ky" href="https://en.wikipedia.org/wiki/Binary_search_tree" rel="noopener ugc nofollow" target="_blank">的知识，以及它在大O符号中的时间复杂度。</a></p><h1 id="6e1f" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">ELI5算法系列📚</h1><ul class=""><li id="0998" class="mf mg in jm b jn lx jr ly jv mo jz mp kd mq kh mr ml mm mn bi translated"><a class="ae ky" href="https://haleepagel.medium.com/eli5-bubble-sort-algorithms-%EF%B8%8F-78bbce018846" rel="noopener"> ELI5:冒泡排序算法🛁</a></li><li id="a994" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mr ml mm mn bi translated"><a class="ae ky" href="https://haleepagel.medium.com/eli5-linear-search-algorithms-%EF%B8%8F-%EF%B8%8F-6f79cf9b3bb7" rel="noopener"> ELI5:线性搜索算法🕵️‍♀️ </a></li><li id="5067" class="mf mg in jm b jn ms jr mt jv mu jz mv kd mw kh mr ml mm mn bi translated"><a class="ae ky" href="https://haleepagel.medium.com/eli5-binary-search-trees-fd560f81b553" rel="noopener"> ELI5:二分搜索法树🌲</a></li></ul></div><div class="ab cl ni nj hr nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ig ih ii ij ik"><p id="d457" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢阅读！我叫Halee Pagel(与Cali Bagel押韵)，是日本东京的一名软件工程师。你可以在推特上找到我，我主要用它来喜欢科技迷因和MLB的更新。✌️</p></div></div>    
</body>
</html>