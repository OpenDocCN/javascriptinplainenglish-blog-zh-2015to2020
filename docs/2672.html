<html>
<head>
<title>Building Web Applications With Node.JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Node构建Web应用程序。射流研究…</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-web-applications-with-node-js-15027e69159e?source=collection_archive---------12-----------------------#2020-07-13">https://javascript.plainenglish.io/building-web-applications-with-node-js-15027e69159e?source=collection_archive---------12-----------------------#2020-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4dcb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何使用node.js构建实时应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/917e9a2c5696d5ab7a2c78626255d91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h4TLlisFk7XvtREAsS7C7Q.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by Christopher Gower on Unsplash</figcaption></figure><p id="e7b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在开发人员开发实时应用程序的时间越来越多。我们今天使用的大多数应用程序，无论是移动应用程序还是桌面应用程序，都具有实时功能。例如，考虑包含实时消息和通知的messenger应用程序，它们都是应用程序中常用的实时功能。</p><p id="c81c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个故事中，我将通过构建一个messenger应用程序来介绍如何使用<strong class="kx ir"> node.js </strong>开发一个实时应用程序。尽管这个故事将解释特定的用例，但是您也可以在其他场景中应用这个策略。</p><p id="eda7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在进入主题之前，你必须了解一点<strong class="kx ir"> node.js </strong>，由于它的异步特性，它是构建实时应用的强大编程语言之一。</p><h1 id="cebf" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">实时应用的特点</h1><p id="c588" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">您可以找到构建实时应用程序所需的功能。他们是，</p><h1 id="67dd" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">实时消息传递</h1><p id="28b9" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们都熟悉像WhatsApp、脸书等即时通讯软件的使用。这些实时应用不仅用于纯粹的消息服务。我们可以获得实时消息服务，如送货应用程序、打车应用程序和其他合作平台。</p><h1 id="0d58" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">通知传递</h1><p id="6aae" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">当用户参与度急剧增加时，启用实时通知非常复杂。所以，这就是为什么你会看到一个现代的应用程序不能实时地向用户发送通知。</p><h1 id="17f2" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">直播</h1><p id="77e0" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">随着实时流的使用，用户能够与其他用户进行交互在社交媒体平台上越来越受欢迎。因此，我们可以将实时视频流集成到应用程序中。最好的例子是脸书和Instagram直播视频流功能。</p><h1 id="2cbf" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">实时跟踪</h1><p id="2c4a" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">实时跟踪变得更加重要。优步和亚马逊等流行的打车和送货应用程序正在使用实时跟踪功能。这个特性增加了应用程序的可用性和可读性。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="fa3a" class="lr ls iq bd lt lu mv lw lx ly mw ma mb jw mx jx md jz my ka mf kc mz kd mh mi bi translated">构建实时应用程序需要遵循哪些步骤？</h1><p id="517d" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">构建实时应用程序是否不同于普通的web应用程序？。答案是，可以。</p><p id="8be4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于构建消息应用程序，用户可以向其他用户发送消息。当第一个用户发送后，其他用户也可以收到这些消息。如果我们像普通的web应用程序一样开发这个应用程序，我们只能向服务器发出接收数据的请求，用户必须定期刷新网页才能看到新消息。因此，它不是用户友好的，我们必须找到一些替代方法来构建实时应用程序。</p><p id="8d19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Web socket为此提供了解决方案。这是一种允许客户端和服务器同时交互的通信协议。使用web socket，服务器可以随时向客户端发送数据，而无需客户端请求。我们可以使用web socket API来构建我们的应用程序。</p><h1 id="596d" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">Socket.io</h1><p id="70dd" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">当我们使用node实现实时应用时，我们不必直接使用web socket API。取而代之的是JavaScript和<strong class="kx ir"> node.js </strong>库<strong class="kx ir"> socket.io </strong>这是web socket API的一个API，使用起来很简单。在这个项目中，我们将使用<strong class="kx ir"> socket.io </strong>来创建和管理客户端和服务器之间的web socket连接。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="afda" class="lr ls iq bd lt lu mv lw lx ly mw ma mb jw mx jx md jz my ka mf kc mz kd mh mi bi translated">用node.js构建聊天室</h1><p id="c47f" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">现在我们可以开始创建我们的应用程序了。首先，我们将创建一个简单的聊天室，用户可以在其中与其他连接的用户进行交流。任何数量的用户都可以加入聊天室，一旦用户发送消息，聊天室的所有用户都会立即收到。</p><p id="16b6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们聊天室的特色，</p><ul class=""><li id="4448" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated">更改用户的用户名。</li><li id="7ba0" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">发送消息。</li><li id="b500" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">当用户正在输入消息时显示输入。</li></ul><h1 id="8d0c" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">设置应用程序环境</h1><p id="3d2c" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">首先为应用程序创建一个新目录，运行npm init来设置<strong class="kx ir"> package.json </strong>文件。那么<strong class="kx ir"> app.js </strong>就是你的主脚本。确保你得到它。</p><h1 id="7ad8" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">安装依赖项</h1><p id="66af" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在这个项目中，我们使用express、Ejs、socket.io和nodemon包来构建应用程序。</p><ul class=""><li id="a401" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated">我们在前面已经看到了关于<strong class="kx ir"> socket.io </strong>的内容。</li><li id="1c48" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">Ejs是一个JavaScript模板引擎。</li><li id="0dac" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated">Nodemon是一个包，当我们改变应用程序中的代码时，它会自动重启服务器。我们将nodemon安装为开发依赖项，因为我们仅将它用于开发目的。</li></ul><p id="e862" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用此命令安装express。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="9483" class="nt ls iq np b gy nu nv l nw nx">npm install express ejs socket.io --save</span></pre><p id="5562" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用以下命令安装nodemon。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="1a45" class="nt ls iq np b gy nu nv l nw nx">npm install nodemon --save-dev</span></pre><p id="c079" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要用nodemon启动应用程序，我们必须在我们的<strong class="kx ir"> package.json </strong>中添加一个启动脚本。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="ba8b" class="nt ls iq np b gy nu nv l nw nx">"scripts": {<br/>    "start": "nodemon app.js",<br/> },</span></pre><p id="688f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们使用这个命令启动应用程序。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="3bbb" class="nt ls iq np b gy nu nv l nw nx">npm run start</span></pre><h1 id="3d49" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">设置应用程序结构</h1><p id="4725" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">该应用程序所需的所有依赖项都已安装，让我们构建应用程序结构。首先，我们需要创建一些指令。应用程序结构如下所示。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="6cf8" class="nt ls iq np b gy nu nv l nw nx">|--app.js<br/>|--views<br/>|--node_modules<br/>|--package.json<br/>|--public<br/>   |--css<br/>   |--js</span></pre><ul class=""><li id="b869" class="na nb iq kx b ky kz lb lc le nc li nd lm ne lq nf ng nh ni bi translated"><strong class="kx ir">app . js</strong>——是一个用来托管我们的服务器端代码的文件。</li><li id="9744" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated"><strong class="kx ir">视图</strong> -包含视图的文件夹。</li><li id="d402" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated"><strong class="kx ir">node _ modules</strong>——包含我们项目的所有依赖项。</li><li id="63ec" class="na nb iq kx b ky nj lb nk le nl li nm lm nn lq nf ng nh ni bi translated"><strong class="kx ir">public</strong>——是一个用来存储我们所有项目文件的目录。</li></ul></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="c26e" class="lr ls iq bd lt lu mv lw lx ly mw ma mb jw mx jx md jz my ka mf kc mz kd mh mi bi translated">构建服务器</h1><p id="7eb0" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们需要做的第一步是打开我们的<strong class="kx ir"> app.js </strong>文件并粘贴以下代码。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="c500" class="nt ls iq np b gy nu nv l nw nx">const express = require('express')<br/>const socketio = require('socket.io')<br/>const app = express()<br/><br/>app.set('view engine', 'ejs')<br/>app.use(express.static('public'))<br/><br/>app.get('/', (req, res)=&gt; {<br/>    res.render('index')<br/>})<br/><br/>const server = app.listen(process.env.PORT || 3000, () =&gt; {<br/>    console.log("server is running")<br/>})</span></pre><p id="f73d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦我们用<strong class="kx ir"> ejs </strong>模板配置了<strong class="kx ir"> express </strong>，那么就开始在<strong class="kx ir"> socket.io </strong>上工作。为此，在<strong class="kx ir"> app.js </strong>文件的末尾添加以下代码。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="b479" class="nt ls iq np b gy nu nv l nw nx">//initialize socket for the server<br/>const io = socketio(server)<br/><br/>io.on('connection', socket =&gt; {<br/>    console.log("New user connected")<br/>})</span></pre><p id="5c3b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您使用<strong class="kx ir">NPM</strong>T34】start运行您的服务器，您将能够接收新的套接字连接。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="f11f" class="lr ls iq bd lt lu mv lw lx ly mw ma mb jw mx jx md jz my ka mf kc mz kd mh mi bi translated">构建我们的前端</h1><p id="91ee" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">让我们首先创建一个模板，然后创建一个<strong class="kx ir"> index.ejs </strong>文件，并粘贴以下代码。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="5b83" class="nt ls iq np b gy nu nv l nw nx">&lt;!DOCTYPE html&gt;<br/>&lt;head&gt;<br/>    &lt;title&gt;Simple realtime chatroom&lt;/title&gt;<br/>    &lt;link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>    &lt;div class="container"&gt;<br/>        &lt;div class="title"&gt;<br/>            &lt;h3&gt;Realtime Chat Room&lt;/h3&gt;<br/>        &lt;/div&gt;<br/>       <br/>        &lt;div class="card"&gt;<br/>            &lt;div class="card-header"&gt;Anonymous&lt;/div&gt;<br/>            &lt;div class="card-body"&gt;<br/>                &lt;div class="input-group"&gt;<br/>                    &lt;input type="text" class="form-control" id="username" placeholder="Change your username" &gt;<br/>                    &lt;div class="input-group-append"&gt;<br/>                        &lt;button class="btn btn-warning" type="button" id="usernameBtn"&gt;Change&lt;/button&gt;<br/>                    &lt;/div&gt;<br/>                &lt;/div&gt;<br/>            &lt;/div&gt;<br/>            &lt;div class="message-box"&gt;<br/>                &lt;ul class="list-group list-group-flush" id="message-list"&gt;&lt;/ul&gt;<br/>                &lt;div class="info"&gt;&lt;/div&gt;<br/>            &lt;/div&gt;<br/>            <br/>            &lt;div class="card-footer"&gt;<br/>                &lt;div class="input-group"&gt;<br/>                    &lt;input type="text" class="form-control" id="message" placeholder="Send new message" &gt;<br/>                    &lt;div class="input-group-append"&gt;<br/>                        &lt;button class="btn btn-success" type="button" id="messageBtn"&gt;Send&lt;/button&gt;<br/>                    &lt;/div&gt;<br/>                &lt;/div&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/><br/>    &lt;/div&gt;<br/>    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.4/socket.io.js"&gt;&lt;/script&gt;<br/>    &lt;script src="/js/chatroom.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="4e4e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是客户端<strong class="kx ir"> socket.io </strong>库的脚本和我们将在这段代码中使用的自定义JavaScript文件。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="f3ea" class="nt ls iq np b gy nu nv l nw nx">&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.4/socket.io.js"&gt;&lt;/script&gt;<br/>&lt;script src="/js/chatroom.js"&gt;&lt;/script&gt;</span></pre><p id="16bc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们创建了一个ID为<strong class="kx ir"> messageBtn </strong>的按钮来发送消息，并创建了另一个ID为<strong class="kx ir"> usernameBtn </strong>的按钮来创建新用户。所有用户消息都出现在ID为<strong class="kx ir"> message_list </strong>的无序列表中。如果用户正在输入一条消息，那么它会出现在div中，带有类别<strong class="kx ir">信息</strong>。</p><p id="b2ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，如果你打开浏览器，运行http://localhost:3000/你的应用程序将会是这样的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/111fd6c857fd7ef2bc05f6932db83c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nQ-gnHVXq2J5IjPu2-Qh8g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Chat Room layout</figcaption></figure><p id="892f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们只创建了一个前端，它不工作，除非我们提供功能。接下来，我们将前端与服务器连接起来。</p><p id="ac4b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为此，您需要在js文件夹中创建一个新的JavaScript文件名<strong class="kx ir"> chatroom.js </strong>，在JavaScript文件中，我们需要使用以下代码将前端与socket连接起来。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="139c" class="nt ls iq np b gy nu nv l nw nx">(function connect(){<br/>    let socket = io.connect('http://localhost:3000')<br/>})()</span></pre><p id="f594" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，您的应用程序运行良好。接下来让我们构建功能。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="e284" class="lr ls iq bd lt lu mv lw lx ly mw ma mb jw mx jx md jz my ka mf kc mz kd mh mi bi translated">更改用户名</h1><p id="9c43" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们用于每个连接的默认用户名是匿名的。因此，我们必须给用户选择改变他们的用户名。为此，我们必须设置后端，以便在前端发出<strong class="kx ir"> change_username </strong>事件时更改用户名。让我们在<strong class="kx ir"> app.js </strong>中编辑您的连接事件。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="fb50" class="nt ls iq np b gy nu nv l nw nx">io.on('connection', socket =&gt; {<br/>    console.log("New user connected")<br/><br/>    socket.username = "Anonymous"<br/><br/>    socket.on('change_username', data =&gt; {<br/>        socket.username = data.username<br/>    })<br/>})</span></pre><p id="1755" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后我们需要调整我们的前端。因此，当我们按下更改用户按钮时，它会触发<strong class="kx ir"> change_username </strong>事件。在<strong class="kx ir"> chatroom.js </strong>中添加事件监听器到<strong class="kx ir"> usernameBtn </strong>中，当按钮被点击时发出一个<strong class="kx ir"> change_username </strong>事件。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="2454" class="nt ls iq np b gy nu nv l nw nx">(function connect(){<br/>    let socket = io.connect('http://localhost:3000')<br/><br/>    let username = document.querySelector('#username')<br/>    let usernameBtn = document.querySelector('#usernameBtn')<br/>    let curUsername = document.querySelector('.card-header')<br/>    <br/>    usernameBtn.addEventListener('click', e =&gt; {<br/>        console.log(username.value)<br/>        socket.emit('change_username', {username: username.value})<br/>        curUsername.textContent = username.value<br/>        username.value = ''<br/>    })<br/>})()</span></pre><p id="8223" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在你可以添加新的用户名，接下来让我们开始发送消息。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="144a" class="lr ls iq bd lt lu mv lw lx ly mw ma mb jw mx jx md jz my ka mf kc mz kd mh mi bi translated">发送消息</h1><p id="f1b9" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们要实现的下一个特性是发送消息。每次前端发出消息时，服务器都会接收到<strong class="kx ir"> new_message </strong>事件，并向所有连接的客户端触发该功能，以便它们可以获得新消息。</p><p id="3345" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先设置前端在提交新消息时发出一个<strong class="kx ir"> new_message </strong>事件。然后同时创建一个<strong class="kx ir"> receive_message </strong>事件来显示新消息。我们可以通过使用<strong class="kx ir"> chatroom.js </strong>中的以下代码来实现这两者。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="b32d" class="nt ls iq np b gy nu nv l nw nx">let message = document.querySelector('#message')<br/>let messageBtn = document.querySelector('#messageBtn')<br/>let messageList = document.querySelector('#message-list')<br/><br/>messageBtn.addEventListener('click', e =&gt; {<br/>    console.log(message.value)<br/>    socket.emit('new_message', {message: message.value})<br/>    message.value = ''<br/>})<br/><br/>socket.on('receive_message', data =&gt; {<br/>    console.log(data)<br/>    let listItem = document.createElement('li')<br/>    listItem.textContent = data.username + ': ' + data.message<br/>    listItem.classList.add('list-group-item')<br/>    messageList.appendChild(listItem)<br/>})</span></pre><p id="e376" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">然后在后端，当我们收到一个<strong class="kx ir"> new_message </strong>事件时，我们需要向所有客户端发出一个新事件，为此我们使用了<strong class="kx ir"> io.sockets.emit() </strong>函数。现在将文件上的<strong class="kx ir">连接</strong>事件更改如下:</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="1c04" class="nt ls iq np b gy nu nv l nw nx">io.on('connection', socket =&gt; {<br/>    console.log("New user connected")<br/><br/>    socket.username = "Anonymous"<br/><br/>    socket.on('change_username', data =&gt; {<br/>        socket.username = data.username<br/>    })<br/><br/><br/>    //handle the new message event<br/>    socket.on('new_message', data =&gt; {<br/>        console.log("new message")<br/>        io.sockets.emit('receive_message', {message: data.message, username: socket.username})<br/>    })<br/><br/>})</span></pre><p id="d23a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在你可以连接到聊天室了。在两个浏览器中打开它，看看消息是如何通过应用程序界面从一个用户传递到另一个用户的。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="93a3" class="lr ls iq bd lt lu mv lw lx ly mw ma mb jw mx jx md jz my ka mf kc mz kd mh mi bi translated">打字</h1><p id="2459" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">在大多数应用中，我们看到当用户x正在输入时，它向另一个用户显示用户x正在输入。这提供了实时感并改善了用户体验。让我们在应用程序中构建这个特性。</p><p id="afcc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在消息输入框中添加了一个新的事件监听器，以便每当按键发生时发出一个<strong class="kx ir">输入</strong>事件。每当用户键入消息时，它触发服务器用户正在键入的消息，并将其显示在用户界面上。</p><p id="b9c7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在连接函数内部，在<strong class="kx ir"> chatroom.js </strong>中添加以下代码。</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="8548" class="nt ls iq np b gy nu nv l nw nx">let info = document.querySelector('.info')<br/><br/>message.addEventListener('keypress', e =&gt; {<br/>    socket.emit('typing')<br/>})<br/><br/>socket.on('typing', data =&gt; {<br/>    info.textContent = data.username + " is typing..."<br/>    setTimeout(() =&gt; {info.textContent=''}, 5000)<br/>})</span></pre><p id="9891" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们需要设置后端来处理输入事件。下面的代码是，</p><pre class="kg kh ki kj gt no np nq nr aw ns bi"><span id="096a" class="nt ls iq np b gy nu nv l nw nx">socket.on('typing', data =&gt; {<br/>    socket.broadcast.emit('typing', {username: socket.username})<br/>})</span></pre><p id="533e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，您可以看到功能齐全的实时聊天应用程序。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/dbbb86c6abd432d75158adde6f8a9759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oTnaNArN9PXle72Sqsn-xw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Final Chat Application</figcaption></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="0b0c" class="lr ls iq bd lt lu mv lw lx ly mw ma mb jw mx jx md jz my ka mf kc mz kd mh mi bi translated">结论</h1><p id="b971" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我希望你喜欢这个故事，并花了宝贵的时间。现在，您已经学习了如何使用node.js和socket.io创建实时应用程序。</p><p id="e421" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>