<html>
<head>
<title>Build a Notes App with NestJS, MySQL, TypeORM</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用NestJS，MySQL，TypeORM构建一个Notes应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-nestjs-mysql-typeorm-in-building-simple-notes-app-5cdbee9712e0?source=collection_archive---------0-----------------------#2020-10-12">https://javascript.plainenglish.io/using-nestjs-mysql-typeorm-in-building-simple-notes-app-5cdbee9712e0?source=collection_archive---------0-----------------------#2020-10-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/68eb9ce01a57bdb4a22a77c60e109f48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zeOv4blDpgcoqTLUvfmbXQ.png"/></div></div></figure><p id="bbfc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Nest (NestJS)是一个用于构建高效、可伸缩的Node.js服务器端应用程序的框架。</p><p id="978e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Nest提供了开箱即用的应用程序架构，允许开发人员和团队创建高度可测试、可伸缩、松散耦合且易于维护的应用程序。</p><p id="36da" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您应该考虑在您的项目中使用NestJS作为框架的主要原因是因为它非常强大，但使用起来非常友好，文档非常容易理解，提供非常简单的开发和测试，支持Typescript和GraphQL等。</p><p id="ecd3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的项目中，我们将建立一个简单的存储和检索笔记的后端应用程序。</p><p id="1359" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文的底部，您将找到示例代码，因此如果您在遵循本文中描述的步骤时遇到问题，您可以查看它。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="5580" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了创建新的嵌套应用程序，我们将安装嵌套CLI并执行创建新嵌套应用程序的命令:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="eeb8" class="lj lk in lf b gy ll lm l ln lo">npm i -g @nestjs/cli<br/>nest new nestjs-mysql-typeorm-sample</span></pre><p id="f9b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">并选择<em class="lp"> npm </em>作为包管理器。</p><p id="9360" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在应用程序中，我们将使用MySQL数据库，并将使用TypeORM库来存储和检索MySQL中的数据，因此我们需要调用以下命令来安装这些库:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="4846" class="lj lk in lf b gy ll lm l ln lo">npm install --save @nestjs/typeorm typeorm mysql</span></pre><p id="ee1d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了建立到MySQL的TypeORM连接，我们需要用适当的MySQL配置数据创建<em class="lp"> ormconfig.json </em>(请确保您指定了正确的用户名、密码和数据库名称):</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="c619" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">TypeORM配置数据将从<em class="lp"> ormconfig.json </em>文件中加载，因此在主应用程序模块文件(<em class="lp"> app.module.ts </em>文件)中，我们必须通过调用不带任何选项的“forRoot”来导入“TypeOrmModule ”:</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="621b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所见，NestJS应用程序结构由三个核心文件组成:</p><ul class=""><li id="6a6f" class="ls lt in jx b jy jz kc kd kg lu kk lv ko lw ks lx ly lz ma bi translated"><strong class="jx io"> app.controller.ts </strong> -单路基本控制器</li><li id="80a0" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated"><strong class="jx io"> app.module.ts </strong> -应用程序的根模块</li><li id="ed8c" class="ls lt in jx b jy mb kc mc kg md kk me ko mf ks lx ly lz ma bi translated"><strong class="jx io"> main.ts </strong> -使用核心函数<em class="lp"> NodeFactory </em>创建嵌套应用实例的应用的入口文件</li></ul><p id="f525" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因为我们的应用程序将只提供一个特性，即创建、更新、检索notes列表，所以我们将创建适当的notes模块、服务、提供者和控制器(所有这些都在单独的notes文件夹中)。通过这样做，我们清楚地将notes功能与应用程序可能具有的其他功能分开，并且我们使代码更干净，可读性更好。</p><p id="6c7b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将对模型字段进行一些验证，因此当用户试图在数据库中插入新的或编辑现有的note对象时，我们需要调用下面的<em class="lp"> npm </em>命令，并安装将验证我们的模型对象的“类验证器”库:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="c7f2" class="lj lk in lf b gy ll lm l ln lo">npm install class-validator</span></pre><p id="f65a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还将安装“class-transformer”包，允许我们将普通对象转换为类的实例，反之亦然:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="12e7" class="lj lk in lf b gy ll lm l ln lo">npm install class-transformer</span></pre><p id="ee82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们将要创建控制器、服务和其他类之前，让我们创建我们的主数据类，<em class="lp"> Note </em>实体对象(在‘notes/Note . entity . ts’文件中):</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="4cfd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们所看到的，<em class="lp">注意到</em>实体类包含不同的装饰者。与TypeORM相关的装饰器有:“@Entity”、“PrimaryGeneratedColumn”和“@Column”。与类验证器相关的装饰器是与数据类型和值验证相关的所有其他装饰器，例如“@MinLength”或“@IsString”。</p><p id="e399" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们要创建的下一个类是notes服务(' notes/notes.service.ts '文件)，它负责向我们的notes控制器提供在MySQL数据库中检索或存储数据的方法:</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="66d7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们在notes服务中看到的，有许多方法负责从MySQL数据库中存储或检索notes，所有这些都是通过使用TypeORM提供的存储库数据模式来完成的。</p><p id="a290" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们要创建的下一个类是notes controller，他的主要职责是处理传入的请求并向客户端返回响应:</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="8705" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在构造函数中，我们注入了notes服务，它将通过notes repository处理MySQL数据库操作。服务中的每个方法都有自己合适的装饰器(比如' @GET ')，并被分配给这个装饰处理的合适方法。每个带decorator的方法都处理适当的HTTP方法调用(比如' @Get' decorator处理' HTTP GET '调用)。</p><p id="f419" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">到目前为止，我们已经创建了notes控制器，它将处理传入的请求，并将返回响应和用于数据存储和检索的notes服务。</p><p id="2ed6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后一部分是创建notes模块，它将使notes相关的依赖项组织在同一个文件下:</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="0a01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们需要在app模块中导入notes模块:</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="0e27" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在我们的应用程序的主入口文件(文件' main.ts ')中，我们需要设置应用程序使用' ValidationPipe '，这将确保所有端点都不会收到不正确的数据。此外，我们将启用“CORS ”,以便我们可以从前端应用程序访问后端应用程序端点。</p><figure class="la lb lc ld gt jo"><div class="bz fp l di"><div class="lq lr l"/></div></figure><p id="7917" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">确保端口设置为“3001”，因为我们将在<a class="ae mg" href="https://medium.com/@zoransasko/using-react-react-router-redux-redux-form-in-building-simple-notes-app-fd3114f5131a" rel="noopener">创建的前端应用程序将指向端口“3000”。</a></p><p id="5b62" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在，我们已经准备好了后端应用程序运行所需的一切，我们可以通过调用以下命令来启动它:</p><pre class="la lb lc ld gt le lf lg lh aw li bi"><span id="0c1f" class="lj lk in lf b gy ll lm l ln lo">npm start</span></pre><p id="9942" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以试着通过邮递员插入新邮件:</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/930d4f20fc6696e565ca44e24446c6a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/format:webp/1*t9NuC1pf1AeiXBPQTFxlXQ.png"/></div></figure><p id="153e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们还可以通过提供无效的“描述”数据来检查验证是否有效:</p><figure class="la lb lc ld gt jo gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/15d353169549c307fbb86fa6d16473f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*JpwcWMmS1QqsGDKG-6WHQA.png"/></div></figure><p id="3841" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">恭喜你，我们已经成功创建了NestJS后端应用程序，它可以存储和读取MySQL数据库中的数据。</p><p id="7d01" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下一篇文章中，我们将探讨如何在React前端应用程序中显示notes数据:</p><div class="mj mk gp gr ml mm"><a href="https://medium.com/@zoransasko/using-react-react-router-redux-redux-form-in-building-simple-notes-app-fd3114f5131a" rel="noopener follow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd io gy z fp mr fr fs ms fu fw im bi translated">使用React、React Router、Redux、Redux表单构建简单的Notes应用程序</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">首先，我们将通过调用以下npm命令初始化React项目:npx create-react-app…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">medium.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na jt mm"/></div></div></a></div></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="79d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本文构建的示例应用程序的源代码:<a class="ae mg" href="https://github.com/zsasko/nestjs-mysql-typeorm-sample" rel="noopener ugc nofollow" target="_blank">https://github.com/zsasko/nestjs-mysql-typeorm-sample</a></p><p id="f4ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae mg" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="jx io">！</strong></p></div></div>    
</body>
</html>