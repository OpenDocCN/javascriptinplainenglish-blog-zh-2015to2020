<html>
<head>
<title>Best of Modern JavaScript — WeakMaps and Sets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华——弱映射和集合</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-weakmaps-and-sets-aab5be635a39?source=collection_archive---------13-----------------------#2020-10-25">https://javascript.plainenglish.io/best-of-modern-javascript-weakmaps-and-sets-aab5be635a39?source=collection_archive---------13-----------------------#2020-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/65abb8fe9e03435d2a4bf4d8f57b6d90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wIVWVcSH_Pinvktg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@wbayreuther?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">William Bayreuther</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="143a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究弱映射。</p><h1 id="f631" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">WeakMap API</h1><p id="50df" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">武器地图有4种方法。</p><p id="f035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">WeakMap</code>构造函数接受一个键值对数组。</p><p id="b521" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">键必须是对象。</p><p id="fbf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">WeakMap.prototype.get</code>方法获取键并返回给定键的值。</p><p id="fbc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">WeakMap.prototype.set</code>将键和值作为参数，并返回带有新条目的WeakMap。</p><p id="483b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">WeakMap.prototype.has</code>将键作为参数，如果具有给定键的项目存在，则返回<code class="fe me mf mg mh b">true</code>，否则返回<code class="fe me mf mg mh b">false</code>。</p><p id="875a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">WeakMap.prototype.delete</code>获取带有要删除项目的键，如果删除了项目，则返回<code class="fe me mf mg mh b">true</code>，如果没有找到项目，则返回<code class="fe me mf mg mh b">false</code>。</p><h1 id="b879" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">一组</h1><p id="440e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">ES5没有固定的数据结构。</p><p id="8b53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">替代方法是使用对象的键来存储元素。</p><p id="4461" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者我们可以将元素存储在一个数组中。</p><p id="8a4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过<code class="fe me mf mg mh b">indexOf</code>检查它是否包含一个元素，或者用<code class="fe me mf mg mh b">filter</code>等删除重复的元素。</p><p id="1d45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">indexOf</code>找不到值<code class="fe me mf mg mh b">NaN</code>。</p><p id="91fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ES6有<code class="fe me mf mg mh b">Set</code>构造函数来创建一个集合。</p><p id="9dcd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">速度很快，处理<code class="fe me mf mg mh b">NaN</code>正确。</p><p id="319d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下内容来创建一个集合:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="202a" class="mq lc iq mh b gy mr ms l mt mu">const set = new Set();<br/>set.add('foo');</span></pre><p id="917d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">Set</code>结构创建一个集合，并调用<code class="fe me mf mg mh b">add</code>来添加一个条目。</p><p id="203d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">has</code>实例方法检查该项是否存在。</p><p id="7aeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d087" class="mq lc iq mh b gy mr ms l mt mu">const hasFoo = set.has('foo');</span></pre><p id="0d64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">hasFoo</code>是<code class="fe me mf mg mh b">true</code>，因为我们有一个值为<code class="fe me mf mg mh b">'foo'</code>的条目。</p><p id="5f17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">delete</code>实例让我们删除项目。</p><p id="3949" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f92f" class="mq lc iq mh b gy mr ms l mt mu">const deletedFoo = set.delete('foo');</span></pre><p id="b491" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将密钥作为参数。如果项目被删除，它返回<code class="fe me mf mg mh b">true</code>。</p><p id="71cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性有集合中的项目数。</p><p id="584d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ec20" class="mq lc iq mh b gy mr ms l mt mu">const set = new Set();<br/>set.add('foo');</span><span id="032e" class="mq lc iq mh b gy mv ms l mt mu">const size = set.size;</span></pre><p id="d376" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe me mf mg mh b">size</code>是1。</p><p id="6d84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实例方法让我们从集合中删除所有的条目。</p><p id="5599" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="634a" class="mq lc iq mh b gy mr ms l mt mu">set.clear();</span></pre><h1 id="4f29" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设置布景</h1><p id="cc01" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过将一个数组传入<code class="fe me mf mg mh b">Set</code>构造函数来获取集合。</p><p id="a0e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="153b" class="mq lc iq mh b gy mr ms l mt mu">const set = new Set(['foo', 'bar', 'baz']);</span></pre><p id="7fcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用<code class="fe me mf mg mh b">add</code>方法来添加项目:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d55d" class="mq lc iq mh b gy mr ms l mt mu">const set = new Set().add('foo').add('bar').add('baz');</span></pre><p id="9bd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Set</code>构造函数有零个或一个参数。</p><p id="2ff6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有传入任何参数，则创建一个空集。</p><p id="a358" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果传入一个参数，那么这个参数必须是一个iterable对象。</p><h1 id="4bcf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">比较集合元素</h1><p id="17b5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">has</code>方法来比较集合元素。</p><p id="ed08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该算法的工作原理类似于<code class="fe me mf mg mh b">===</code>，但<code class="fe me mf mg mh b">NaN</code>等于它本身</p><p id="ea33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0b5b" class="mq lc iq mh b gy mr ms l mt mu">const set = new Set([NaN]);</span></pre><p id="0259" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以检查是否有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9da5" class="mq lc iq mh b gy mr ms l mt mu">consrt hasNaN = set.has(NaN);</span></pre><p id="c4c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二次添加相同的元素没有效果。</p><p id="a3a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f106" class="mq lc iq mh b gy mr ms l mt mu">const set = new Set();<br/>set.add('bar');<br/>set.add('bar');</span><span id="b1a4" class="mq lc iq mh b gy mv ms l mt mu">const size = set.size;</span></pre><p id="8d7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们添加了两次<code class="fe me mf mg mh b">'bar'</code>后，<code class="fe me mf mg mh b">size</code>仍然是一个。</p><p id="72c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两个对象永远不会被认为是相等的。</p><p id="1130" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种行为是改不了的。</p><p id="afed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5374" class="mq lc iq mh b gy mr ms l mt mu">const set = new Set();<br/>set.add({});<br/>set.add({});</span><span id="ba1f" class="mq lc iq mh b gy mv ms l mt mu">const size = set.size;</span></pre><p id="12fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">size</code>就是2。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/b930c67f771d218026f8fdf2366b7958.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2nkq-K7wd2N0i7Av"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@onelast?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">T L</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="b9f2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="df7a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">WeakMaps有一个比地图简单得多的API。</p><p id="e23a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">集合不能有重复的值，但是对象永远不会被认为是相同的，即使它们有相同的内容。</p><p id="3201" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>