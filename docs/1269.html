<html>
<head>
<title>Creating Pure Immutable Reducers in Redux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Redux中创建纯不可变的Reducers</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/redux-creating-pure-immutable-reducers-7a32e993ade0?source=collection_archive---------0-----------------------#2020-02-22">https://javascript.plainenglish.io/redux-creating-pure-immutable-reducers-7a32e993ade0?source=collection_archive---------0-----------------------#2020-02-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="201c" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这是一个关于如何将当前的reducers迁移为纯粹的和不可变的快速演示。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b7bb2a6d79b01d058f82447fcae50e83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MZrq-iODK9T8W8EDFxTmFA.jpeg"/></div></div></figure><h1 id="27d0" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">快速还原摘要</h1><p id="08f8" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Redux的核心实际上只是一个单向消息订阅系统，但有了它，我们可以创建惊人的可扩展状态管理。</p><p id="f508" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在这个消息传递系统中，我们可以订阅(也称为“观察”和“监听”)事件，比如调用一个函数向API发出请求。有趣的是，在这个订阅<strong class="ll ir">中，我们可以传递数据。</strong></p><h2 id="a848" class="mk ks iq bd kt ml mm dn kx mn mo dp lb ls mp mq ld lw mr ms lf ma mt mu lh mv bi translated">运行时</h2><ul class=""><li id="abcd" class="mw mx iq ll b lm ln lp lq ls my lw mz ma na me nb nc nd ne bi translated">订阅已设置</li><li id="e3f5" class="mw mx iq ll b lm nf lp ng ls nh lw ni ma nj me nb nc nd ne bi translated">商店已申报。</li></ul><h2 id="5515" class="mk ks iq bd kt ml mm dn kx mn mo dp lb ls mp mq ld lw mr ms lf ma mt mu lh mv bi translated">数据流</h2><ol class=""><li id="71ad" class="mw mx iq ll b lm ln lp lq ls my lw mz ma na me nk nc nd ne bi translated"><strong class="ll ir">数据调度动作</strong> → 2。<strong class="ll ir">通过数据通知用户</strong> → 3。<strong class="ll ir">全球商店中的数据集</strong></li></ol><p id="cdde" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">正如你所看到的，redux非常模块化和简单。记住你的Redux实现应该是<strong class="ll ir">可移植的、可替换的</strong>、<strong class="ll ir">并且几乎与应用程序分离。</strong></p><p id="4d52" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在本文中，我们将主要讨论优化<strong class="ll ir">步骤2。</strong></p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="6780" class="kr ks iq bd kt ku ns kw kx ky nt la lb jw nu jx ld jz nv ka lf kc nw kd lh li bi translated">我们如何处理Redux中的数据？</h1><p id="78aa" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果你在网上搜索“<strong class="ll ir">在Redux应用程序中哪里处理逻辑？</strong>“你会得到一些<strong class="ll ir">非常固执己见的</strong>信息。有人说reducer，有人说actions，有人说不要在你的动作或reducer中包含任何逻辑。</p><p id="1ba4" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">我们要说的是<strong class="ll ir">在你的归约器和动作中不应该有逻辑，它们应该是完全纯粹的和功能性的</strong>。</p><h1 id="58ac" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">那么我们把逻辑放在哪里呢？</h1><p id="0348" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我发现有两个选项是最具可伸缩性和最简洁的。</p><ol class=""><li id="1449" class="mw mx iq ll b lm mf lp mg ls nx lw ny ma nz me nk nc nd ne bi translated"><strong class="ll ir"> Redux逻辑中间件</strong>(个人推荐)</li><li id="021a" class="mw mx iq ll b lm nf lp ng ls nh lw ni ma nj me nk nc nd ne bi translated"><strong class="ll ir">在<strong class="ll ir">逻辑服务</strong>中的Redux </strong>之外，即<strong class="ll ir">将数据传递给动作</strong></li></ol><p id="9fe6" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">一旦您将您的逻辑移出了您的reducer，您就可以开始进行增强了。我们将使我们的存储<strong class="ll ir">不可变</strong>和<strong class="ll ir">纯</strong>，这意味着无论它接收到什么状态，都是它将要设置的状态，没有副作用或函数调用(如果需要，您可以进行一些格式化，但是<strong class="ll ir">不改变结构</strong>)。记住你希望你的状态是<strong class="ll ir">可预测的</strong>和<strong class="ll ir">确定的</strong>，这是我们设置一个<strong class="ll ir">初始状态</strong>的原因之一。</p><p id="ec75" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">通过遵循这些规则，我们可以利用reducer中的不变性库来只更新存储中已经更改的值。这非常重要，因为它允许在应用程序的其余部分进行进一步优化</p><p id="2d50" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated"><strong class="ll ir">例如</strong>:在React中有<code class="fe oa ob oc od b">PureComponents</code>根据传递给组件的状态差异进行优化。如果我们要完全克隆状态(<strong class="ll ir">不要_。每次在我们的减速器里克隆</strong>，都会让<code class="fe oa ob oc od b">PureComponents</code>完全没用(<strong class="ll ir">连丹阿布拉莫夫都同意</strong>)。没有T2，我们就不能恰当地纪念他。如你所见，使用不变性有一系列的好处。</p><h2 id="85a7" class="mk ks iq bd kt ml mm dn kx mn mo dp lb ls mp mq ld lw mr ms lf ma mt mu lh mv bi translated">这是你的减速器现在的样子(没有优化)</h2><pre class="kg kh ki kj gt oe od of og aw oh bi"><span id="3693" class="mk ks iq od b gy oi oj l ok ol">// <strong class="od ir">BAD IMPLEMENTATION</strong><br/>export const <strong class="od ir">userReducer</strong> = (state = {}, action = {}) =&gt; {<br/> <br/><strong class="od ir">  let newState = _.cloneDeep(state);</strong></span><span id="8c61" class="mk ks iq od b gy om oj l ok ol">  switch (action.type) {</span><span id="7d98" class="mk ks iq od b gy om oj l ok ol">    case GET_USER:<br/>      newState.status = "runnning";<br/>      return newState; <br/>  <br/>    case USER_SUCCESS: {<br/><strong class="od ir">      if(newState.user.name === undefined){<br/>        newState.user.name = "noname";<br/>      }<br/>      if(newState.user.time){<br/>        newState.timestamp = Date.now();<br/>        resetTimer(user.time)<br/>      }</strong></span><span id="9a37" class="mk ks iq od b gy om oj l ok ol">      return newState;<br/>    <br/>     case USER_ERROR:<br/>       newState.status = "error"<br/>       return newState;</span><span id="75fe" class="mk ks iq od b gy om oj l ok ol">     default: {<br/>       return newState;<br/>     }<br/>  }<br/>};</span></pre><p id="0f72" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在这个<strong class="ll ir"> <em class="on">未优化</em> </strong>的例子中，有几个<strong class="ll ir">问题</strong>。我们可以看到有<strong class="ll ir">没有初始状态</strong>设置，我们是<strong class="ll ir">深度克隆</strong>状态，有<strong class="ll ir">副作用</strong>，我们也是<strong class="ll ir">有条件更新存储</strong>。如前所述，这将影响优化的能力，并使我们的数据更难预测。</p><h2 id="b113" class="mk ks iq bd kt ml mm dn kx mn mo dp lb ls mp mq ld lw mr ms lf ma mt mu lh mv bi translated">纯/不可变缩减器示例(优化)</h2><pre class="kg kh ki kj gt oe od of og aw oh bi"><span id="225c" class="mk ks iq od b gy oi oj l ok ol">import <strong class="od ir">immutable</strong> from "immutability-helper";<br/>import {<strong class="od ir">handleActions</strong>} from "redux-actions";<br/>import {ACTIONS} from './constants';</span><span id="ebfb" class="mk ks iq od b gy om oj l ok ol">const <strong class="od ir">initialState</strong> = {<br/>  status: "",<br/>  user: {},<br/>};</span><span id="07b5" class="mk ks iq od b gy om oj l ok ol">export const <strong class="od ir">userReducer</strong> = <strong class="od ir">handleActions</strong>(<br/>  {<br/>    [ACTIONS.GET_USER]: state =&gt;<br/>      <strong class="od ir">immutable</strong>(state, {<br/>        status: {$set: "running"}<br/>      }),<br/>    [ACTIONS.USER_SUCCESS]: (state, {<strong class="od ir">data</strong>}) =&gt;<br/>      <strong class="od ir">immutable</strong>(state, {<br/>        status: {$set: "success"},<br/>        <strong class="od ir">user</strong>: {$set: data.<strong class="od ir">user</strong>},<br/>      }),<br/>    [ACTIONS.USER_ERROR]: state =&gt;<br/>      <strong class="od ir">immutable</strong>(state, {<br/>        status: {$set: "error"}<br/>      })<br/>  },<br/>  <strong class="od ir">initialState</strong><br/>);</span></pre><p id="75e1" class="pw-post-body-paragraph lj lk iq ll b lm mf jr lo lp mg ju lr ls mh lu lv lw mi ly lz ma mj mc md me ij bi translated">在<strong class="ll ir"> <em class="on">优化的</em> </strong>示例中，我们减少了代码，我们的状态更加可预测。</p><h2 id="3771" class="mk ks iq bd kt ml mm dn kx mn mo dp lb ls mp mq ld lw mr ms lf ma mt mu lh mv bi translated">好处:</h2><ol class=""><li id="ff79" class="mw mx iq ll b lm ln lp lq ls my lw mz ma na me nk nc nd ne bi translated">没有逻辑或副作用</li><li id="4be1" class="mw mx iq ll b lm nf lp ng ls nh lw ni ma nj me nk nc nd ne bi translated">单一责任</li><li id="aa06" class="mw mx iq ll b lm nf lp ng ls nh lw ni ma nj me nk nc nd ne bi translated">我们总是返回相同的存储结构</li><li id="7a21" class="mw mx iq ll b lm nf lp ng ls nh lw ni ma nj me nk nc nd ne bi translated">定义初始状态是为了一致性/可预测性</li><li id="1aa9" class="mw mx iq ll b lm nf lp ng ls nh lw ni ma nj me nk nc nd ne bi translated">不变性有助于仅对已更改的存储值进行操作</li><li id="61fc" class="mw mx iq ll b lm nf lp ng ls nh lw ni ma nj me nk nc nd ne bi translated">允许使用<code class="fe oa ob oc od b">PureComponents</code>和<code class="fe oa ob oc od b">Memoizing</code></li></ol></div></div>    
</body>
</html>