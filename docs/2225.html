<html>
<head>
<title>How to Write Effective Code that Every Programmer Loves to Maintain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何写出每个程序员都喜欢维护的有效代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-write-effective-javascript-code-that-every-programmer-loves-to-maintain-a490b42b9b9f?source=collection_archive---------8-----------------------#2020-06-01">https://javascript.plainenglish.io/how-to-write-effective-javascript-code-that-every-programmer-loves-to-maintain-a490b42b9b9f?source=collection_archive---------8-----------------------#2020-06-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a453" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">要不要写更易维护的代码？运用坚实的原则</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/052ee6296494cbb703f98b7e5321e76c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EXt9zA6YArFzva90"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@swimstaralex?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alexander Sinn</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4905" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为一名程序员，你可能听说过SOLID。你曾经在你的项目中应用过这个原则吗？</p><p id="b602" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将带您了解SOLID。相信我，一旦你掌握了它，你的同事会很乐意维护你的代码。</p><h1 id="34ec" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">单一责任原则</h1><p id="5e29" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一心多用会降低你的工作效率。你不可能一次完成十个高质量的任务，更别说你有时间去完成它们。重点是挑一个做好。</p><p id="2cd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样的心态也应该适用于编程。每当你写一个函数，让它仅仅做一件事。函数名中没有和/或。如果你写了类似于<strong class="ky ir"> validateAndLogin() </strong>的东西，你就做错了。</p><p id="7f74" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">保持你的功能简明扼要。对你写的每一个函数使用你的常识，如果你觉得一个函数的一部分可以被提取到另一个函数中，不要犹豫去做。</p><p id="3e26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个什么都做的函数是丑陋的，难以阅读的，你肯定想下地狱而不是维护它。</p><p id="1d5a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们以<strong class="ky ir"> validateAndLogin() </strong>为例。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="e3ed" class="mu lt iq mq b gy mv mw l mx my">function validateAndLogin(username, password) {<br/>  // Validate username and password<br/>  // Then login<br/>}</span></pre><p id="8b70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了满足SRP，将其分成两个独立部分——验证和登录。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9122" class="mu lt iq mq b gy mv mw l mx my">function validate(username, password) {<br/>  // Validate username and password<br/>}</span><span id="b36b" class="mu lt iq mq b gy mz mw l mx my">function login(username, password) {<br/>  // login<br/>}</span></pre><h1 id="4ee2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">o:开闭原则</h1><p id="64c3" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你写的每一个函数/模块都应该对扩展开放，对修改关闭。这意味着无论何时你想要做出改变，比如一个新的特性，你应该添加新的代码，而不是修改现有的代码。</p><p id="0629" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，您希望根据用户类型显示不同的徽章。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3223" class="mu lt iq mq b gy mv mw l mx my">function showBadge(userType) {<br/>  if (userType === ‘normal’) {<br/>    // Show normal badge<br/>  } else if (userType === ‘admin’) {<br/>    // Show admin badge<br/>  } else (userType === ‘author’) {<br/>    // Show author badge<br/>  }<br/>}</span></pre><p id="a7f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想出示vip胸卡怎么办？除了编辑showBadge函数为其添加一个<strong class="ky ir"> if </strong>之外，没有其他方法。每当你需要展示一个新徽章的时候,<strong class="ky ir"> if/else </strong>就会一直持续下去。</p><p id="b500" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是你如何让这种情况符合开闭原则:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6367" class="mu lt iq mq b gy mv mw l mx my">function showNormalBadge() {<br/>  // Show normal badge<br/>}</span><span id="8be4" class="mu lt iq mq b gy mz mw l mx my">function showAdminBadge() {<br/>  // Show admin badge<br/>}</span><span id="3528" class="mu lt iq mq b gy mz mw l mx my">function showAuthorBadge() {<br/>  // Show author badge<br/>}</span></pre><p id="5fe8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">需要出示新的徽章吗？只需添加新功能，无需修改现有功能。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9de5" class="mu lt iq mq b gy mv mw l mx my">function showVipBadge() {<br/>  // Show vip badge<br/>}</span></pre><p id="cf81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你看。您不需要编辑现有的功能。每次需要展示新徽章时，只需添加一个函数来扩展代码库即可。</p><h1 id="335e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">李:里斯科夫替代原理</h1><p id="b027" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">每个子类必须可以替换它们的父类。</p><p id="686c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如Bob叔叔所说，“要用可互换的部件构建软件系统，这些部件必须遵守一个允许这些部件相互替换的契约。”</p><p id="9623" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="287b" class="mu lt iq mq b gy mv mw l mx my">class Programmer {<br/>  constructor(name: string) {<br/>  }</span><span id="ed98" class="mu lt iq mq b gy mz mw l mx my">  getSkills() {<br/>  }<br/>}</span><span id="fa05" class="mu lt iq mq b gy mz mw l mx my">class Junior extends Programmer {<br/>  getSkills() {<br/>    return ‘Junior skills’;<br/>  }<br/>}</span><span id="9c58" class="mu lt iq mq b gy mz mw l mx my">class Senior extends Programmer {<br/>  getSkills() {<br/>    return ‘Senior skills’;<br/>  }<br/>}</span><span id="5b3f" class="mu lt iq mq b gy mz mw l mx my">function getProgrammersSkills(programmers: Array&lt;Programmer&gt;) {<br/>  for (let i = 0; i &lt; programmers.length; i++) {<br/>    console.log(programmers[i].getSkills());<br/>  }<br/>}</span></pre><p id="20a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<em class="na"> getProgrammersSkills() </em>函数中可以看到，<em class="na"> getSkills() </em>方法的实现是可以互换的。这样，你就遵守了利斯科夫替代原理。</p><h1 id="2b08" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">I:界面分离原理</h1><p id="a58e" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我不知道为什么我的一些同事经常强迫客户端依赖它不使用的接口或方法。</p><p id="9199" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JS中没有本机接口，但这应该没关系。如果你不需要依赖一个函数或模块，那就不要依赖。</p><p id="4e2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看下面的例子:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="8f3a" class="mu lt iq mq b gy mv mw l mx my">class Programmer {<br/>  constructor(name: string) {}<br/>  <br/>  showJuniorSalary() {<br/>  }</span><span id="f463" class="mu lt iq mq b gy mz mw l mx my">  showSeniorSkills() {<br/>  }<br/>}</span><span id="94f4" class="mu lt iq mq b gy mz mw l mx my">class Junior extends Programmer {<br/>  showJuniorSalary() {<br/>    console.log(‘junior salary’);<br/>  }</span><span id="05cc" class="mu lt iq mq b gy mz mw l mx my">  showSeniorSkills() {<br/>    // Do nothing<br/>  }<br/>}</span><span id="e0b6" class="mu lt iq mq b gy mz mw l mx my">class Senior extends Programmer {<br/>  showJuniorSalary() {<br/>    // Do nothing<br/>  }</span><span id="87a4" class="mu lt iq mq b gy mz mw l mx my">  showSeniorSkills() {<br/>    console.log(‘senior skills’);<br/>  }<br/>}</span></pre><p id="5e7f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在父类中同时有<em class="na"> showJuniorSalary() </em>和<em class="na"> showSeniorSkills() </em>是没有意义的。我们永远不会用<em class="na">senior . showjuniorsalary()</em>和<em class="na">junior . showseniorskills()</em>。</p><p id="58c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道这个例子很荒谬，但你应该明白了。</p><h1 id="11aa" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">依赖倒置原则</h1><p id="bede" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这个原理也被称为控制反转。</p><p id="b09f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着抽象不能依赖于细节。细节必须依赖于抽象。而且高层模块一定不能依赖低层模块。</p><p id="4acf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">抽象不应该知道细节是如何实现的。否则，你就违反了规则。</p><p id="771e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，不要这样做:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b2ae" class="mu lt iq mq b gy mv mw l mx my">function calculateProgrammerSalary(rate) {<br/>  let senior = new SeniorProgrammer();<br/>  return senior.workTime() * rate;<br/>}</span></pre><p id="9e72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">calculateProgrammerSalary()应该不知道高级是怎么实现的。让我们这样做:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4df0" class="mu lt iq mq b gy mv mw l mx my">function calculateProgrammerSalary(rate, programmer) {<br/>  return programmer.workTime() * rate;<br/>}</span></pre><p id="22f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样更好。计算器不依赖于程序员类的具体实现。现在，您可以将senior或junior作为参数传递。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="9b92" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">写代码的时候，要时刻保持扎实的头脑。</p><p id="cc70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不仅仅是关乎代码的质量，还要表现出你对它的在乎，对每一行代码都用心——一种你应该成为的程序员。</p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt ni"><a href="https://medium.com/javascript-in-plain-english/9-great-javascript-extensions-for-visual-studio-code-to-speed-up-your-development-8b3275248718" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">Visual Studio代码的9大JavaScript扩展加速您的开发</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">谁想更快更容易地编码？</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw kp ni"/></div></div></a></div><div class="nx ny gp gr nz ni"><a href="https://medium.com/javascript-in-plain-english/7-simple-ways-to-conditionally-render-components-in-react-a3170d0cd9e0" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">在React中有条件地呈现组件的7种简单方法</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">为用户类型A显示红色用户名，为用户类型B显示蓝色用户名，或者只为登录用户显示仪表板…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="oa l nt nu nv nr nw kp ni"/></div></div></a></div><h1 id="fb6f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">用简单英语写的便条</strong></h1><p id="1939" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">plain English . io</strong></a>找到所有这些内容——关注我们的出版物并<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅我们的YouTube频道</strong> </a> <strong class="ky ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>