<html>
<head>
<title>All the different ways to create Objects in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中创建对象的所有不同方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/objects-and-how-to-make-them-b733bb4b01e8?source=collection_archive---------10-----------------------#2020-10-28">https://javascript.plainenglish.io/objects-and-how-to-make-them-b733bb4b01e8?source=collection_archive---------10-----------------------#2020-10-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="bbf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我最近一直在试图弄清楚如何用JavaScript(确切地说，是许多JavaScript)制作对象，以及理解<code class="fe ki kj kk kl b">.prototype</code>、<code class="fe ki kj kk kl b">__proto__</code>、原型继承与类继承以及对象组合。这是一个相当深刻的主题，这篇博客文章可能只是触及了表面，但我希望它也能帮助你更好地理解它。</p><p id="137c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，我将看看我们如何创建一个对象，以及它如何演变成一个工厂函数、构造函数和类。然后我们会看看为什么你会喜欢某些方法。</p><p id="eccc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些想法不是我自己的，而是我从别处学到的东西的融合。你将要读到的，我来自以下参考资料。如果你没有从这篇文章中得到你所需要的一切，我鼓励你去钻研这些:</p><ol class=""><li id="4fc8" class="km kn in jm b jn jo jr js jv ko jz kp kd kq kh kr ks kt ku bi translated"><a class="ae kv" href="https://ui.dev/beginners-guide-to-javascript-prototype/" rel="noopener ugc nofollow" target="_blank">https://ui.dev/beginners-guide-to-javascript-prototype/</a></li><li id="3fd1" class="km kn in jm b jn kw jr kx jv ky jz kz kd la kh kr ks kt ku bi translated"><a class="ae kv" href="https://medium.com/better-programming/prototypes-in-javascript-5bba2990e04b" rel="noopener">https://medium . com/better-programming/prototypes-in-JavaScript-5 BBA 2990 e04b</a></li><li id="51be" class="km kn in jm b jn kw jr kx jv ky jz kz kd la kh kr ks kt ku bi translated"><a class="ae kv" href="https://medium.com/javascript-scene/javascript-factory-functions-with-es6-4d224591a8b1" rel="noopener">https://medium . com/JavaScript-scene/JavaScript-factory-functions-with-es6-4d 224591 A8 b 1</a></li><li id="67a8" class="km kn in jm b jn kw jr kx jv ky jz kz kd la kh kr ks kt ku bi translated"><a class="ae kv" href="https://medium.com/javascript-scene/javascript-factory-functions-vs-constructor-functions-vs-classes-2f22ceddf33e" rel="noopener">https://medium . com/JavaScript-scene/JavaScript-factory-functions-vs-constructor-functions-vs-classes-2f 22 ceddf 33 e</a></li><li id="329e" class="km kn in jm b jn kw jr kx jv ky jz kz kd la kh kr ks kt ku bi translated"><a class="ae kv" href="https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9" rel="noopener">https://medium . com/JavaScript-scene/master-the-JavaScript-interview-what-s-the-difference-class-prototypal-inheritance-e4c d0 a 7562 e 9</a></li></ol><h1 id="dd56" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">只有一个</h1><p id="6e03" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">这是我们如何用JavaScript创建一个对象:</p><pre class="me mf mg mh gt mi kl mj mk aw ml bi"><span id="b000" class="mm lc in kl b gy mn mo l mp mq">const name = "Aaron";</span><span id="47e5" class="mm lc in kl b gy mr mo l mp mq">const thing = {<br/>  name,<br/>  setName(name) {<br/>    this.name = name;<br/>    return this;<br/>  } <br/>}</span></pre><p id="a258" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这叫做对象字面量。请注意这里也使用了速记语法。这与以下内容相同:</p><pre class="me mf mg mh gt mi kl mj mk aw ml bi"><span id="20e3" class="mm lc in kl b gy mn mo l mp mq">const thing = {<br/>  name: "Aaron",<br/>  setName: function(name) {<br/>    this.name = name;<br/>    return this;<br/>  } <br/>}</span></pre><p id="d743" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">太好了，我们可以做一个，多一个怎么样？</p><h1 id="5ffe" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">工厂功能</h1><p id="8e62" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">我们可以设想创建一个函数，让许多对象看起来有点像这样:</p><pre class="me mf mg mh gt mi kl mj mk aw ml bi"><span id="99f1" class="mm lc in kl b gy mn mo l mp mq">function Thing(name) {<br/>  const thing = {};<br/>  thing.name = name;<br/>  thing.setName = function (name) {<br/>    this.name = name;<br/>    return thing;<br/>  };<br/>  return thing;<br/>}</span><span id="a79d" class="mm lc in kl b gy mr mo l mp mq">const thing1 = Thing("Aaron");</span></pre><p id="1e28" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个工厂函数。它可以用几种不同的方式编写，包括箭头函数语法(稍后将详细介绍)。</p><p id="dbdb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">假设<code class="fe ki kj kk kl b">Thing</code>的每个实例都有一个<code class="fe ki kj kk kl b">setName</code>方法。因此，理想情况下，我们希望所有的<code class="fe ki kj kk kl b">Thing</code>实例共享同一个<code class="fe ki kj kk kl b">setName</code>方法。我们可以这样实现:</p><pre class="me mf mg mh gt mi kl mj mk aw ml bi"><span id="4d8f" class="mm lc in kl b gy mn mo l mp mq">const sharedThingMethods = {<br/>  setName(name) {<br/>    this.name = name;<br/>    return this;<br/>  },<br/>};</span><span id="bbb2" class="mm lc in kl b gy mr mo l mp mq">function Thing(name) {<br/>  const thing = Object.create(sharedThingMethods);<br/>  thing.name = name;<br/>  return thing;<br/>}</span><span id="f4d3" class="mm lc in kl b gy mr mo l mp mq">const thing1 = Thing("Aaron");</span></pre><p id="e738" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" rel="noopener ugc nofollow" target="_blank">Object.create()</a></code>是这里的钥匙。它创建一个新对象，并将其参数用作查找失败的委托对象。所以，假设你做了<code class="fe ki kj kk kl b">thing1.setName("new name")</code>，JavaScript将会寻找<code class="fe ki kj kk kl b">sharedThingMethods</code>的<code class="fe ki kj kk kl b">setName()</code>方法，因为它不存在于<code class="fe ki kj kk kl b">Thing</code>的实例中。</p><p id="dd68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事实证明，JavaScript有一种内置的方式来完成上面的工作，这就是函数<code class="fe ki kj kk kl b">.prototype</code>属性。</p><h1 id="9561" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是原型？</h1><p id="4759" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">对于这一点，您将需要打开一个浏览器窗口，并准备好开发工具。不，说真的，不要只是读它😉。</p><p id="bef0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将<code class="fe ki kj kk kl b">Thing</code>功能复制粘贴到控制台，然后点击<code class="fe ki kj kk kl b">console.dir(Thing)</code>。这将列出<code class="fe ki kj kk kl b">Thing</code>函数对象的所有属性，您应该有如下内容。</p><figure class="me mf mg mh gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ms"><img src="../Images/fd9800361726b70a6cd68f0f377719be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yEUSMIHcJ3IYzVulURpaKA.png"/></div></div></figure><p id="ff0a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">查看<code class="fe ki kj kk kl b">prototype: constructor: f Thing(name)</code>。这是什么？它与我们的<code class="fe ki kj kk kl b">sharedThingMethods</code>有何关系？</p><p id="88bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所有的函数(用<code class="fe ki kj kk kl b">function</code>关键字定义——稍后会讲到)都有一个引用对象的<code class="fe ki kj kk kl b">.prototype</code>属性。该对象有一个<code class="fe ki kj kk kl b">.constructor</code>属性，该属性返回到它所属的函数。原来，这个原型对象的功能和<code class="fe ki kj kk kl b">sharedThingMethods</code>差不多。正如您在控制台中看到的，目前的情况是<code class="fe ki kj kk kl b">Thing</code>没有利用它的原型，让我们改变这一点。</p><pre class="me mf mg mh gt mi kl mj mk aw ml bi"><span id="dd5e" class="mm lc in kl b gy mn mo l mp mq">function Thing(name) {<br/>  const thing = Object.create(Thing.prototype); // &lt;&lt;&lt; This bit changes<br/>  thing.name = name;<br/>  return thing;<br/>}</span><span id="cb39" class="mm lc in kl b gy mr mo l mp mq">Thing.prototype.setName = function (name) {<br/>  this.name = name;<br/>  return this;<br/>};</span><span id="1bab" class="mm lc in kl b gy mr mo l mp mq">const thing1 = Thing("Aaron");</span></pre><p id="4ae4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在查找失败时，我们将参考原型，而不是参考<code class="fe ki kj kk kl b">sharedThingMethods</code>对象。我们现在有这样一种情况:</p><figure class="me mf mg mh gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi na"><img src="../Images/28106f1f49097bba7987375284b2e6c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tdMMkwwMca0cH0WryAlHJQ.png"/></div></div></figure><p id="d0d6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">注意功能<code class="fe ki kj kk kl b">.prototype</code>上的<code class="fe ki kj kk kl b">setName</code>和实例<code class="fe ki kj kk kl b">__proto__</code>。</p><p id="2658" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您也可以这样想象:</p><figure class="me mf mg mh gt mt gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nb"><img src="../Images/a5b3f5f8c37a1b3b6ff3b3f7863f58b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vQ42m9Pvzl2IQzQhgmyliQ.png"/></div></div></figure><p id="19bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ki kj kk kl b">Thing</code>的每个实例都有一个引用函数<code class="fe ki kj kk kl b">.prototype</code>的<code class="fe ki kj kk kl b">__proto__</code>属性。<code class="fe ki kj kk kl b">setName</code>通过函数的原型在<code class="fe ki kj kk kl b">Thing</code>的所有实例之间共享。</p><h1 id="6012" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">工厂功能3种方式</h1><p id="8927" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">因此，我们知道我们可以创建一个工厂函数来制造大量的对象，我们也知道工厂函数原型在其中扮演了什么角色。但是，当您使用Arrow函数来定义工厂函数时会发生什么呢？</p><p id="529f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这三个工厂的功能几乎相同，但有一个轻微的差异，你能告诉吗？</p><pre class="me mf mg mh gt mi kl mj mk aw ml bi"><span id="3120" class="mm lc in kl b gy mn mo l mp mq">// Factory 1 (the one we have already been looking at)<br/>function Thing(name) {<br/>  const thing = Object.create(Thing.prototype);<br/>  thing.name = name;<br/>  return thing;<br/>}</span><span id="16eb" class="mm lc in kl b gy mr mo l mp mq">Thing.prototype.setName = function (name) {<br/>  this.name = name;<br/>  return this;<br/>};</span><span id="3be9" class="mm lc in kl b gy mr mo l mp mq">const thing1 = Thing("Aaron");</span><span id="95ce" class="mm lc in kl b gy mr mo l mp mq">// Factory 2<br/>const proto = {<br/>  setName(name) {<br/>    this.name = name;<br/>    return this;<br/>  },<br/>};</span><span id="b472" class="mm lc in kl b gy mr mo l mp mq">const Thing = (name) =&gt; {<br/>  const thing = Object.create(proto);<br/>  thing.name = name;<br/>  return thing;<br/>};</span><span id="57ee" class="mm lc in kl b gy mr mo l mp mq">// Factory 3 ()<br/>const Thing = (name) =&gt; ({<br/>  name,<br/>  __proto__: {<br/>    setName(name) {<br/>      this.name = name;<br/>      return this;<br/>    },<br/>  },<br/>});</span></pre><p id="0606" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这到底是怎么回事？为什么“工厂2”看起来像是我们要回到手动设置原型对象，工厂3中的<code class="fe ki kj kk kl b">__proto__</code>是什么？</p><p id="1f8b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">总之</strong>:所有这些功能都采用原型委托，只是方式不同。前两个在功能上是等效的——它们在所有实例之间共享一个原型。最后一个在内存使用上有所不同。它为每个实例创建一个新的原型。</p><p id="e264" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">话真多，让我们详细说明一下。</p><p id="1ed5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank"> Arrow函数</a>没有<code class="fe ki kj kk kl b">.prototype</code>属性，这意味着它们不能用作构造函数(更多关于构造函数的内容请参见下文)，但是它们可以用作如上的工厂函数。查看工厂2，缺少<code class="fe ki kj kk kl b">.prototype</code>意味着您必须自己委托一个原型对象并将其传递给<code class="fe ki kj kk kl b">Object.create()</code>。你选择工厂1还是工厂2完全是个人喜好的问题，但是他们的行为都是一样的。</p><p id="4ab2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">工厂3的不同之处在于，它通过定义<code class="fe ki kj kk kl b">__proto__</code>来创建原型，但是它为每个创建的实例创建一个新的原型，并且缺乏其他工厂2所具有的内存节省优势。那么，工厂3中的原型有什么意义呢？假设我们想使用类似<code class="fe ki kj kk kl b">Object.keys(thing1)</code>的东西迭代我们的<code class="fe ki kj kk kl b">Thing</code>实例，我们可能希望从这个操作中排除类似<code class="fe ki kj kk kl b">setName</code>的方法。因为某些属性在所有情况下都是通用的，所以包含它们可能会产生无用的“噪音”,没有什么意义。将它们放在<code class="fe ki kj kk kl b">__proto__</code>属性上可以隐藏它们。</p><h1 id="fb40" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从工厂到施工人员</h1><p id="b06a" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">因此，我们已经研究了工厂函数，如何使用它们来创建对象的多个实例，如何为对象属性查找创建委托的原型链，以及根据您编写工厂函数的方式，这看起来会有什么不同。现在让我们看看JavaScript是如何用构造函数和类在整个过程中添加一些语法糖的。</p><p id="3985" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果用关键字<code class="fe ki kj kk kl b">new</code>调用一个函数，即<code class="fe ki kj kk kl b">const thing1 = new Thing("Aaron")</code>，那么这个函数就是一个构造函数。将我们的工厂函数转换成构造函数，我们可以省略几行。</p><pre class="me mf mg mh gt mi kl mj mk aw ml bi"><span id="eaee" class="mm lc in kl b gy mn mo l mp mq">function Thing(name) {<br/>  // const this = Object.create(Thing.prototype);<br/>  this.name = name;<br/>  // return this<br/>}</span><span id="24fe" class="mm lc in kl b gy mr mo l mp mq">Thing.prototype.setName = function (name) {<br/>  this.name = name;<br/>  return this;<br/>};</span><span id="e952" class="mm lc in kl b gy mr mo l mp mq">const thing1 = new Thing("Aaron");</span></pre><p id="a5b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有了构造函数，上面注释掉的两行就隐式地完成了。注意，创建的对象名为<code class="fe ki kj kk kl b">this</code>，并被隐式返回。</p><h1 id="7f98" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从构造函数到类</h1><p id="b6de" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">只要用关键字<code class="fe ki kj kk kl b">class</code>稍微增加一点语法上的难度，我们就能得到这个结果:</p><pre class="me mf mg mh gt mi kl mj mk aw ml bi"><span id="1b26" class="mm lc in kl b gy mn mo l mp mq">class Thing {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  setName(name) {<br/>    this.name = name;<br/>    return this;<br/>  }<br/>}</span><span id="a292" class="mm lc in kl b gy mr mo l mp mq">const thing1 = new Thing("Aaron");</span></pre><p id="bb89" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">值得注意的是，这在功能上等同于上面的构造函数。只是看起来不一样。</p><h1 id="423b" class="lb lc in bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">工厂函数vs构造函数vs类</h1><p id="4aa0" class="pw-post-body-paragraph jk jl in jm b jn lz jp jq jr ma jt ju jv mb jx jy jz mc kb kc kd md kf kg kh ig bi translated">这篇文章已经讨论了工厂函数、构造函数和类，但是让我们后退一步，看看什么时候我们可以使用其中的一个。</p><p id="8061" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类和构造函数是一样的，只是语法上稍有不同。因此，构造函数的优点和缺点也适用于类。</p><p id="7302" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">构造函数强制调用方使用<code class="fe ki kj kk kl b">new</code>关键字。工厂没有。这是唯一的区别，但这确实有一些副作用。</p><p id="264f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">工厂函数有时被视为构造函数的升级，实际上是一种常见的重构模式。</p><p id="d2ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简单重述一下——<code class="fe ki kj kk kl b">new</code>关键字的使用导致JavaScript自动创建一个新对象，在函数中为该对象设置<code class="fe ki kj kk kl b">this</code>,并返回该对象。这在工厂函数中不会自动发生。您需要告诉工厂函数返回什么(在大多数情况下是新对象)，但这确实增加了一点灵活性。</p><pre class="me mf mg mh gt mi kl mj mk aw ml bi"><span id="d2b3" class="mm lc in kl b gy mn mo l mp mq">function ConstructorThing(name) {<br/>  this.name = name;<br/>}<br/>ConstructorThing.prototype.setName = function (name) {<br/>  this.name = name;<br/>  return this;<br/>};</span><span id="e885" class="mm lc in kl b gy mr mo l mp mq">function factoryThing(name) {<br/>  const obj = {<br/>    name,<br/>    setName(name) {<br/>      this.name = name;<br/>      return this;<br/>    },<br/>  };<br/>  // Other code to manipulate obj in some way here<br/>  return obj;<br/>}</span></pre><p id="f0b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">事实上，我们可以包含其他代码来以某种方式操作对象，并定义要返回的对象，这意味着返回值可能因参数而异。</p><p id="1631" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从<a class="ae kv" href="https://www.aaron-thompson.dev/posts/code-encapsulation-40mm/" rel="noopener ugc nofollow" target="_blank">封装</a>的角度来看，这种灵活性也是有益的。考虑以下工厂函数:</p><pre class="me mf mg mh gt mi kl mj mk aw ml bi"><span id="4e1e" class="mm lc in kl b gy mn mo l mp mq">function createWallet() {<br/>  const balance = 0;</span><span id="ab01" class="mm lc in kl b gy mr mo l mp mq">  function privateMethod() {<br/>    console.log("do a private thing");<br/>  }<br/>  function add() {<br/>    console.log("add");<br/>  }<br/>  function empty() {}</span><span id="247c" class="mm lc in kl b gy mr mo l mp mq">  return Object.freeze({<br/>    add,<br/>    empty,<br/>  });<br/>}</span></pre><p id="d604" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">只有我们在返回中公开的方法是公共的。其他的都被封装了。</p><p id="727a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">默认情况下，类(以及扩展构造函数)属性是公共的，可以在类外部检查或修改。也就是说，私有字段作为一个实验特性在类中是可用的。</p><p id="4d0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">类和构造函数可以创建有问题的层次结构，导致面向对象设计中众所周知的问题，包括脆弱的基类、“大猩猩香蕉问题”和必然的复制。通过使用工厂函数，你可以采用一种复合优于继承的方法，但这是另一篇博文的大主题！</p><p id="2b2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是一个巨大的话题，我期待着写更多关于它的东西。我还在学习，所以一如既往，任何建设性的意见都很感谢。</p></div></div>    
</body>
</html>