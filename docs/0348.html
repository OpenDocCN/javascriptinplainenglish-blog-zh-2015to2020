<html>
<head>
<title>How to build reusable layouts in React JS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React JS中构建可重用的布局</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-build-reusable-layouts-in-react-js-daf8adcbca79?source=collection_archive---------0-----------------------#2019-09-23">https://javascript.plainenglish.io/how-to-build-reusable-layouts-in-react-js-daf8adcbca79?source=collection_archive---------0-----------------------#2019-09-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a0fd8a146c5f21f4894a57ee9da6d2b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jeYZXY-q_jGsCoQusMvhqQ.jpeg"/></div></div></figure><div class=""/><p id="18d3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在web开发过程中，我们经常会在应用程序的屏幕上遇到非常相似的布局，当我们使用React JS来构建这些布局时，这意味着我们将在许多组件中重复使用样式。</p><p id="d3e5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在下面这个简单的例子中，我们可以看到登录和注册页面共享红色渐变背景，其内容在左上角对齐，而仪表板和个人资料页面共享绿色渐变，组件和标题居中。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi kw"><img src="../Images/3ce76e5a64fb23c3f752659713db8cdd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pvpmla5DZOb-6ZtVzGFo6Q.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Example screens</figcaption></figure><p id="c5fd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我将向你展示一种在你的应用程序的页面之间非常有效地共享样式的技术。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="d2a0" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">重要的事情先来！</h1><p id="9230" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在本教程中，我将使用一个基础应用程序，在该应用程序中，我根据用户权限配置了路由和导航，这意味着只有经过身份验证的用户才能访问仪表板和个人资料页面。你可以在<a class="ae mp" href="https://medium.com/swlh/routing-and-navigation-in-react-cffc26e8a389" rel="noopener">这篇文章</a>中看到我是如何做的。</p><blockquote class="mq mr ms"><p id="22b5" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">虽然我建议您自己配置导航(这样您可以更好地了解幕后发生的一切)，但是您也可以在codesandbox上派生<a class="ae mp" href="https://codesandbox.io/embed/react-basic-navigation-mk5lb?fontsize=14" rel="noopener ugc nofollow" target="_blank">这个模板</a>，在code sandbox上已经为您配置了这个部分。</p></blockquote><p id="6507" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在这个应用程序中使用<a class="ae mp" href="https://www.styled-components.com/docs/basics" rel="noopener ugc nofollow" target="_blank">样式的组件</a>(如果您以前从未使用过它，它是一个惊人的库，可以帮助我们在没有react中的camelcase语法的情况下样式化react组件，外加许多惊人的特性！).</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="2c47" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">重置CSS</h1><p id="6a20" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">许多开发人员使用重置CSS从浏览器中移除默认样式。让我们开始创建我们的重置组件(不要忘记，所有的反应都是用组件完成的！)</p><p id="2030" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建文件<code class="fe mx my mz na b">./src/styles/global.js</code>:</p><pre class="kx ky kz la gt nb na nc nd aw ne bi"><span id="82b2" class="nf ln jb na b gy ng nh l ni nj">import { createGlobalStyle } from "styled-components";</span><span id="5f37" class="nf ln jb na b gy nk nh l ni nj">export default createGlobalStyle`<br/>  @import url('&lt;https://fonts.googleapis.com/css?family=Roboto:400,700&amp;display=swap&gt;');<br/>  <br/>  * {<br/>    margin: 0;<br/>    padding: 0;<br/>    outline: 0;<!-- --> <br/>    border: 0;<br/>    <!-- -->box-sizing: border-box;<br/>  }</span><span id="14a2" class="nf ln jb na b gy nk nh l ni nj">  *:focus {<br/>    outline: 0;<br/>  }</span><span id="cd18" class="nf ln jb na b gy nk nh l ni nj">  html, body, #root {<br/>    height: 100%;<br/>  }</span><span id="b87a" class="nf ln jb na b gy nk nh l ni nj">  body {<br/>    -webkit-font-smoothing: antialiased;<br/>  }</span><span id="f618" class="nf ln jb na b gy nk nh l ni nj">  body, input, button {<br/>    font: 14px 'Roboto', sans-serif;<br/>  }</span><span id="4cbd" class="nf ln jb na b gy nk nh l ni nj">  a {<br/>    text-decoration: none;<br/>  }</span><span id="8f89" class="nf ln jb na b gy nk nh l ni nj">  ul {<br/>    list-style: none;<br/>  }</span><span id="d355" class="nf ln jb na b gy nk nh l ni nj">  button {<br/>    cursor: pointer;<br/>  }<br/>`;</span></pre><p id="6e17" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个文件使用了syled组件<code class="fe mx my mz na b">createGlobalStyle</code>。这将使它们在我们的应用程序的所有组件中可用。</p><p id="c226" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下一步是将它们导入到我们路由器组件中的<code class="fe mx my mz na b">./src/App.js</code>中。</p><pre class="kx ky kz la gt nb na nc nd aw ne bi"><span id="7220" class="nf ln jb na b gy ng nh l ni nj">import React from "react";<br/>import { Router } from "react-router-dom";</span><span id="cfa2" class="nf ln jb na b gy nk nh l ni nj">import history from "./services/history";<br/>import Routes from "./routes";</span><span id="0192" class="nf ln jb na b gy nk nh l ni nj">import GlobalStyles from "./styles/global";</span><span id="13b1" class="nf ln jb na b gy nk nh l ni nj">function App() {<br/>  return (<br/>    &lt;Router history={history}&gt;<br/>      &lt;Routes /&gt;<br/>      &lt;GlobalStyles /&gt;<br/>    &lt;/Router&gt;<br/>  );<br/>}</span><span id="ea3e" class="nf ln jb na b gy nk nh l ni nj">export default App;</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="334f" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">创建布局</h1><p id="1f39" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">我们将在一个名为<code class="fe mx my mz na b">./src/pages/layouts/.</code>的文件夹中创建我们的基本布局。因为这里有两个模式，我们将创建一个默认布局供非认证页面使用，一个认证布局供认证页面使用。</p><h1 id="5a6b" class="lm ln jb bd lo lp nl lr ls lt nm lv lw lx nn lz ma mb no md me mf np mh mi mj bi translated">默认布局</h1><p id="322c" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">从默认布局开始，让我们保持我们在页面中使用的相同约定，并用布局的名称创建一个文件夹(出于约定，我们将用小写来命名它们)。在这个文件夹中，我们将有两个文件:</p><ul class=""><li id="c4c2" class="nq nr jb ka b kb kc kf kg kj ns kn nt kr nu kv nv nw nx ny bi translated">styles.js ( <code class="fe mx my mz na b">./src/pages/_layouts/default/index.js</code> ) →这个样式化的组件将只有红色渐变和高度，表明它可以占据整个屏幕。</li></ul><pre class="kx ky kz la gt nb na nc nd aw ne bi"><span id="fc90" class="nf ln jb na b gy ng nh l ni nj">import styled from "styled-components";</span><span id="8a21" class="nf ln jb na b gy nk nh l ni nj">export const Wrapper = styled.div`<br/>  background: linear-gradient(to bottom, #ffc5c5, #ff4949);<br/>  height: 100%;<br/>`;</span></pre><ul class=""><li id="1bf0" class="nq nr jb ka b kb kc kf kg kj ns kn nt kr nu kv nv nw nx ny bi translated">index.js ( <code class="fe mx my mz na b">./src/pages/_layouts/default/index.js</code> )→这个文件将导入我们之前创建的包装器组件，并返回包含子元素的组件。</li></ul><pre class="kx ky kz la gt nb na nc nd aw ne bi"><span id="5b46" class="nf ln jb na b gy ng nh l ni nj">import React from 'react'; <br/>import PropTypes from 'prop-types';  </span><span id="47c2" class="nf ln jb na b gy nk nh l ni nj">import { Wrapper } from './styles';  </span><span id="2d70" class="nf ln jb na b gy nk nh l ni nj">export default function DefaultLayout({ children }) {   <br/>  return &lt;Wrapper&gt;{children}&lt;/Wrapper&gt;; <br/>}  </span><span id="58f9" class="nf ln jb na b gy nk nh l ni nj">DefaultLayout.propTypes = {   <br/>  children: PropTypes.element.isRequired, <br/>};</span></pre><p id="37d1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您对我们在这里所做的感到困惑，让我提醒您一个react概念:当我们有一个包含子组件的组件时，父元素在一个名为children的属性中接收它们。</p><pre class="kx ky kz la gt nb na nc nd aw ne bi"><span id="8076" class="nf ln jb na b gy ng nh l ni nj">&lt;Element&gt;<br/>  &lt;SubElement1 /&gt;<br/>  &lt;SubElement2 /&gt;<br/>&lt;/Element&gt;</span></pre><blockquote class="mq mr ms"><p id="504d" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated">元素接收一个名为children的属性，顾名思义，它拥有关于其子组件的所有信息。这就是React组合元素构建页面的方式！</p></blockquote><p id="dcf9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将提前看到如何调用这个DefaultLayout。</p><h1 id="31f1" class="lm ln jb bd lo lp nl lr ls lt nm lv lw lx nn lz ma mb no md me mf np mh mi mj bi translated">授权布局</h1><p id="4f9f" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">让我们使用默认布局中的相同逻辑来创建授权布局:</p><ul class=""><li id="f54a" class="nq nr jb ka b kb kc kf kg kj ns kn nt kr nu kv nv nw nx ny bi translated">styles.js ( <code class="fe mx my mz na b">./src/pages/_layouts/auth/index.js</code> ) →这里我们将导出两个样式化的组件:Header和Wrapper。</li></ul><blockquote class="mq mr ms"><p id="20d4" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated"><em class="jb">标题只是一个不同颜色的div，所以我们可以区分它。</em></p><p id="0414" class="jy jz mt ka b kb kc kd ke kf kg kh ki mu kk kl km mv ko kp kq mw ks kt ku kv ij bi translated"><em class="jb"> Wrapper具有绿色渐变，占据整个屏幕，并使用flex布局将内容放置在中央。</em></p></blockquote><pre class="kx ky kz la gt nb na nc nd aw ne bi"><span id="e453" class="nf ln jb na b gy ng nh l ni nj">import styled from "styled-components";</span><span id="d62e" class="nf ln jb na b gy nk nh l ni nj">export const Wrapper = styled.div`<br/>  background: linear-gradient(to bottom, #e7ffb3, #707070);<br/>  height: 100%;<br/>  display: flex;<br/>  justify-content: center;<br/>  align-items: center;<br/>`;</span><span id="a18e" class="nf ln jb na b gy nk nh l ni nj">export const Header = styled.div`<br/>  background: #333;<br/>  height: 10vh;<br/>`;</span></pre><ul class=""><li id="34d0" class="nq nr jb ka b kb kc kf kg kj ns kn nt kr nu kv nv nw nx ny bi translated">index.js ( <code class="fe mx my mz na b">./src/pages/_layouts/auth/index.js</code> )→这个文件与DefaultLayout非常相似，除了它将头和包装一起返回。</li></ul><pre class="kx ky kz la gt nb na nc nd aw ne bi"><span id="d9fa" class="nf ln jb na b gy ng nh l ni nj">import React from "react";<br/>import PropTypes from "prop-types";</span><span id="7235" class="nf ln jb na b gy nk nh l ni nj">import { Wrapper, Header } from "./styles";</span><span id="9125" class="nf ln jb na b gy nk nh l ni nj">export default function AuthLayout({ children }) {<br/>  console.log(children);<br/>  return (<br/>    &lt;&gt;<br/>      &lt;Header /&gt;<br/>      &lt;Wrapper&gt;{children}&lt;/Wrapper&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span><span id="0217" class="nf ln jb na b gy nk nh l ni nj">AuthLayout.propTypes = {<br/>  children: PropTypes.element.isRequired<br/>};</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="b1f8" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">应用布局</h1><p id="330a" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">太好了！我们创建了我们需要的所有文件，但直到现在我们还看不到任何区别，因为我们没有在代码中调用新文件。</p><p id="b00f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您检查我们的Route组件，我们将返回一个react-router-dom路由，将一个组件作为属性传递:</p><pre class="kx ky kz la gt nb na nc nd aw ne bi"><span id="7073" class="nf ln jb na b gy ng nh l ni nj">return &lt;Route {...rest} component={Component} /&gt;;</span></pre><p id="681b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将修改该返回，使其返回我们的布局，并将组件作为子组件:</p><pre class="kx ky kz la gt nb na nc nd aw ne bi"><span id="062d" class="nf ln jb na b gy ng nh l ni nj">import React from "react";<br/>import PropTypes from "prop-types";<br/>import { Route, Redirect } from "react-router-dom";</span><span id="8f86" class="nf ln jb na b gy nk nh l ni nj">import DefaultLayout from "../pages/_layouts/default";<br/>import AuthLayout from "../pages/_layouts/auth";</span><span id="d1d7" class="nf ln jb na b gy nk nh l ni nj">export default function RouteWrapper({<br/>  component: Component,<br/>  isPrivate,<br/>  ...rest<br/>}) {<br/>  const signed = true;</span><span id="496d" class="nf ln jb na b gy nk nh l ni nj">  /**<br/>   * Redirect user to SignIn page if he tries to access a private route<br/>   * without authentication.<br/>   */<br/>  if (isPrivate &amp;&amp; !signed) {<br/>    return &lt;Redirect to="/" /&gt;;<br/>  }</span><span id="8397" class="nf ln jb na b gy nk nh l ni nj">  /**<br/>   * Redirect user to Main page if he tries to access a non private route<br/>   * (SignIn or SignUp) after being authenticated.<br/>   */<br/>  if (!isPrivate &amp;&amp; signed) {<br/>    return &lt;Redirect to="/dashboard" /&gt;;<br/>  }</span><span id="4b28" class="nf ln jb na b gy nk nh l ni nj">  const Layout = signed ? AuthLayout : DefaultLayout;</span><span id="02b7" class="nf ln jb na b gy nk nh l ni nj">  /**<br/>   * If not included on both previous cases, redirect user to the desired route.<br/>   */<br/>  return (<br/>    &lt;Route<br/>      {...rest}<br/>      render={props =&gt; (<br/>        &lt;Layout&gt;<br/>          &lt;Component {...props} /&gt;<br/>        &lt;/Layout&gt;<br/>      )}<br/>    /&gt;<br/>  );<br/>}</span><span id="460f" class="nf ln jb na b gy nk nh l ni nj">RouteWrapper.propTypes = {<br/>  isPrivate: PropTypes.bool,<br/>  component: PropTypes.oneOfType([PropTypes.element, PropTypes.func]).isRequired<br/>};</span><span id="3eff" class="nf ln jb na b gy nk nh l ni nj">RouteWrapper.defaultProps = {<br/>  isPrivate: false<br/>};</span></pre><p id="3f01" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们来关注一下变化:</p><ol class=""><li id="d270" class="nq nr jb ka b kb kc kf kg kj ns kn nt kr nu kv nz nw nx ny bi translated">请注意，现在我们正在导入我们的布局，我们将其中一个布局归属于一个名为Layout的变量，这取决于用户是否登录(请注意，我们可以有其他布局和其他逻辑来定义根据应用程序使用哪一个)。</li><li id="f986" class="nq nr jb ka b kb oa kf ob kj oc kn od kr oe kv nz nw nx ny bi translated">现在，我们使用一个名为render的属性，而不是直接传递组件。在这个属性中，我们可以将组件作为子组件返回我们的布局。</li></ol><p id="73fd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果会是这样的:</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Results after applying the layouts</figcaption></figure></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="fe83" class="lm ln jb bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="25b0" class="pw-post-body-paragraph jy jz jb ka b kb mk kd ke kf ml kh ki kj mm kl km kn mn kp kq kr mo kt ku kv ij bi translated">在您配置了应用程序的这一部分之后，一切都将在后台运行，因此您不需要更改任何其他内容来添加新的路线(除非您想要添加新的基本布局)。</p><p id="5795" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用可重用的布局是一个非常好的实践，因为它让您只需编写一次代码，就可以在应用程序的许多部分中使用它。我可以向您保证，当您的应用程序增长时，维护它会容易得多！</p><p id="00b6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，认证仍然是手动的，我们将在以后使用Redux的文章中介绍这部分的自动化。还要注意，我们的组件返回的只是一个带有名称的h1标签，但是在实际的应用程序中，您可以根据需要用其他组件来更改它们。</p><p id="05f1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在codesandbox上查看完整的实现:</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="oh og l"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">Code implementation in codesandbox</figcaption></figure><p id="1aab" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这篇教程能对你的项目有所帮助！感谢阅读！</p></div></div>    
</body>
</html>