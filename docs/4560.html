<html>
<head>
<title>Server side user authentication and authorization in Node apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">节点应用中的服务器端用户认证和授权</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/server-side-user-authentication-and-authorization-in-node-apps-733c387c7103?source=collection_archive---------6-----------------------#2020-12-21">https://javascript.plainenglish.io/server-side-user-authentication-and-authorization-in-node-apps-733c387c7103?source=collection_archive---------6-----------------------#2020-12-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="63ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在web应用程序中，用户注册和后续登录的过程很复杂，有几种实现方式可以使您的应用程序更加健壮和安全。</p><p id="96b4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">每个实现都增加了一个抽象层，值得研究一下开发人员在身份验证(验证客户端身份)和授权(授予权限)方面的各种选择。</p><h2 id="84f7" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">使用的技术</strong></h2><ul class=""><li id="8a71" class="lb lc in jm b jn ld jr le jv lf jz lg kd lh kh li lj lk ll bi translated"><strong class="jm io"> Express: </strong>节点JS框架，处理app路由</li><li id="988c" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io"> Express-validator: </strong>验证用户凭证</li><li id="1995" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">Bcrypt: 在将密码保存到我们的数据库之前对其进行哈希处理</li><li id="997e" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io"> Jsonwebtoken: </strong>生成令牌，用于授权和访问我们的应用程序路由</li><li id="012e" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io">mongose:</strong>与我们的MongoDB数据库交互</li><li id="14e6" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io"> Nodemon: </strong>每次有变化时重启我们的服务器</li><li id="8d14" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io"> Dotenv: </strong>存储我们的环境变量</li><li id="be7f" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated"><strong class="jm io">邮递员:</strong>测试我们的端点</li></ul><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="c881" class="ki kj in lw b gy ma mb l mc md">//initialize a node project<br/>npx express-generator</span><span id="7335" class="ki kj in lw b gy me mb l mc md">npm install bcrypt dotenv express-validator jsonwebtoken mongoose</span><span id="4deb" class="ki kj in lw b gy me mb l mc md">npm install --save-dev nodemon</span></pre><h1 id="3c67" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">设置您的项目</h1><p id="9bfb" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">package.json</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="e929" class="ki kj in lw b gy ma mb l mc md">"scripts": {<br/>  "start": "node ./bin/www",<br/>  "dev": "nodemon ./bin/www"<br/>},</span></pre><p id="3431" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将这些添加到您的。gitignore文件</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="07fa" class="ki kj in lw b gy ma mb l mc md">node_modules/<br/>.env</span></pre><p id="73aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在你的。env文件设置你的变量</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="94c3" class="ki kj in lw b gy ma mb l mc md">MODE=dev<br/>MONGO_DEV=mongodb://localhost:27017/auth-project<br/>MONGO_PROD=mongodb://localhost:27017/auth-project-prod<br/>JWT_SECRET=typearandomstringhere</span></pre><h1 id="3908" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">文件夹结构</h1><figure class="lr ls lt lu gt na gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/708d4a4668c02db7f9bca54166f8c4ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:550/format:webp/1*R7csYc3XpxwVI3PMiNwEJw.png"/></div></figure><h1 id="a08f" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">App.js</h1><p id="4ee3" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">让我们要求或导入:</p><ul class=""><li id="b397" class="lb lc in jm b jn jo jr js jv nd jz ne kd nf kh li lj lk ll bi translated">文件顶部的dotenv包，</li><li id="5b07" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">我们的Mongo数据库，我们将很快加入</li><li id="e602" class="lb lc in jm b jn lm jr ln jv lo jz lp kd lq kh li lj lk ll bi translated">auth.route并在express generator模板中为我们的路由修改中间件。</li></ul><figure class="lr ls lt lu gt na"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="1d29" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">设置Mongo数据库</h1><p id="60f0" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">创建一个config文件夹和两个文件index.js和db.js。之前的env文件。</p><figure class="lr ls lt lu gt na gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/56b25b20a656212f068d41f079e14d96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1238/format:webp/1*Q_yLVYGAZzZEjHF7XJurPw.png"/></div></figure><p id="4055" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在db.js文件中，使用Mongoose设置Mongo数据库</p><figure class="lr ls lt lu gt na gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/85f6a7d946c2cd2fddc50d50c6b9af37.png" data-original-src="https://miro.medium.com/v2/resize:fit:1262/format:webp/1*LSesNCmMVvJcCJwqZK8d7Q.png"/></div></figure><p id="e079" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">运行npm install并注释掉身份验证路由，因为我们尚未创建它们，这将引发一个错误。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="5a7d" class="ki kj in lw b gy ma mb l mc md">// Comment out for now from app.js<br/>line 12 const authRouter = require(‘./routes/auth’);<br/>line 24 app.use(‘/api/auth’, authRouter);</span></pre><p id="10aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在您的终端中，根据您的操作系统，使用命令在新窗口中运行mongo，并使用以下命令在另一个窗口中运行服务器。您应该在终端中看到“DB Connected MongoDB://localhost:27017/auth-project”</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="336c" class="ki kj in lw b gy ma mb l mc md">npm run dev</span></pre><h1 id="5fd1" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">创建用户模型</h1><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="1e4b" class="ki kj in lw b gy ma mb l mc md">const mongoose = require('mongoose');<br/>const Schema = mongoose.Schema;</span><span id="e65c" class="ki kj in lw b gy me mb l mc md">const userSchema = new Schema({</span><span id="b051" class="ki kj in lw b gy me mb l mc md">name: {<br/>type: String,<br/>required: true,<br/>},</span><span id="c637" class="ki kj in lw b gy me mb l mc md">email: {<br/>type: String,<br/>required: true,<br/>},</span><span id="c4e8" class="ki kj in lw b gy me mb l mc md">password: {<br/>type: String,<br/>required: true,<br/>},</span><span id="dfb4" class="ki kj in lw b gy me mb l mc md">createdOn: {<br/>type: Date,<br/>default: Date.now()<br/>},</span><span id="925c" class="ki kj in lw b gy me mb l mc md">lastActive: {<br/>type: Date,<br/>default: Date.now()<br/>}</span><span id="4951" class="ki kj in lw b gy me mb l mc md">module.exports = mongoose.model('User', userSchema);</span></pre><p id="8a01" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在最后一行module.exports之前，我们将添加几行代码。为了散列密码，我们需要使用一个Mongoose中间件和使用散列算法的第三方包Bcrypt。</p><h1 id="3b96" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">猫鼬中间件</h1><p id="9179" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">Mongoose中有许多内置的中间件，其中之一就是。pre hook允许我们调用一个函数，比如保存一个用户到我们的数据库。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="ddfc" class="ki kj in lw b gy ma mb l mc md">schema.pre('save', <strong class="lw io">async</strong> <strong class="lw io">function</strong>() {<br/>  <strong class="lw io">await</strong> doStuff();<br/>  <strong class="lw io">await</strong> doMoreStuff();<br/>});</span></pre><p id="04b0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以在我们的用户模型文件中，在模式级别上使用它。这个中间件是在保存用户文档之前执行的，在我们的例子中，我们希望在将密码保存到我们的数据库之前对密码<em class="nl">进行哈希运算，因为以明文形式保存密码会暴露密码，使其易受黑客攻击。</em></p><p id="ffe4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们想调用中间件，第一个参数是“save ”,第二个参数是回调异步函数。这里很重要的一点是，我们<em class="nl">没有</em>使用箭头函数，因为我们需要访问函数中的“this”关键字。我们使用“this”来访问我们的用户。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="c11a" class="ki kj in lw b gy ma mb l mc md">userSchema.pre('save', async function () {</span><span id="287e" class="ki kj in lw b gy me mb l mc md">try {<br/>  const user = this;<br/>  user.password = await bcrypt.hash(user.password, saltRounds);}}   catch (error) {<br/>throw error;<br/>}});</span></pre><h1 id="fa93" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">散列密码</h1><p id="8409" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">为了散列我们的密码，我们使用Bcrypt。散列函数(与双向加密相反)是一种单向数学算法，使得实际上不可能将散列密码转换为原始数据。</p><h1 id="2f34" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">加盐密码</h1><p id="a711" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">为什么我们需要盐？使用哈希，如果多个用户拥有相同的密码，哈希后的字符串输出将是相同的。如果其中一个密码被破解，黑客就可以访问另一个。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="07c3" class="ki kj in lw b gy ma mb l mc md">//Hashing example with no salt<br/>//plaintext: password123</span><span id="62b4" class="ki kj in lw b gy me mb l mc md">$2b$10$wAnm6x2BT1cOtzRULrBueeBsXIKsoz5mEmGieeQShOPc3K3JG.xwq</span></pre><p id="52ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，为了防止这种情况，我们在散列密码之前使用“盐”。salt是附加在密码后面的唯一随机数据。</p><p id="4cac" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Bcrypt为我们做了这件事，我们只需要定义saltRounds变量，例如<em class="nl"> const saltRounds =10 </em>。该数字表示明文密码经过哈希运算的次数。随着循环次数的增加，将密码处理成哈希格式的时间也会增加。在<a class="ae nk" href="https://www.npmjs.com/package/bcrypt" rel="noopener ugc nofollow" target="_blank">文档</a>中，你可以看到不同的场景，考虑到处理器的成本和用户等待的时间，10轮是一个很好的标准。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="2249" class="ki kj in lw b gy ma mb l mc md">rounds=8 : ~40 hashes/sec<br/>rounds=9 : ~20 hashes/sec<br/>rounds=10: ~10 hashes/sec<br/>rounds=11: ~5  hashes/sec<br/>rounds=12: 2-3 hashes/sec<br/>rounds=13: ~1 sec/hash<br/>rounds=14: ~1.5 sec/hash<br/>rounds=15: ~3 sec/hash<br/>rounds=25: ~1 hour/hash<br/>rounds=31: 2-3 days/hash</span></pre><figure class="lr ls lt lu gt na"><div class="bz fp l di"><div class="ng nh l"/></div></figure><h1 id="307b" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">Document.prototype.isModified()</h1><p id="0d90" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">我们在第29行添加的一个重要代码行是。is修改函数。如果文档被修改，该函数返回true，我们需要检查这一点，这样我们就不会在每次用户登录时散列密码，而是只在密码被修改时散列密码。</p><h1 id="6d54" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated"><strong class="ak">验证用户数据</strong></h1><p id="56a9" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">在我们创建用户并将其保存到数据库中之前，我们希望确保输入的数据格式正确。<a class="ae nk" href="https://express-validator.github.io/docs/" rel="noopener ugc nofollow" target="_blank"> Express validator </a>是一个用于服务器端数据验证的Express中间件。这是文档中的基本样板文件。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="189d" class="ki kj in lw b gy ma mb l mc md"><strong class="lw io">const</strong> express = require('express'); <br/><strong class="lw io">const</strong> app = express();<br/><strong class="lw io">const</strong> { body, validationResult } = require('express-validator');<br/>  <br/>app.use(express.json());</span><span id="ae6c" class="ki kj in lw b gy me mb l mc md">app.post('/user', [   <br/>  // username must be an email   <br/>  body('username').isEmail(),   <br/>  // password must be at least 5 chars long   <br/>  body('password').isLength({ min: 5 })<br/>], (req, res) =&gt; {   <br/>// Finds the validation errors in this request and wraps them in an object with handy functions   <br/>  <strong class="lw io">const</strong> errors = validationResult(req);   <br/>  <strong class="lw io">if</strong> (!errors.isEmpty()) {     <br/>   <strong class="lw io">return</strong> res.status(400).json({ errors: errors.array() });   <br/>}    </span><span id="10e7" class="ki kj in lw b gy me mb l mc md">User.create({     <br/>  username: req.body.username,     <br/>  password: req.body.password   <br/>}).then(user =&gt; res.json(user)); <br/>});</span></pre><h1 id="88bc" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">使用自定义验证器创建注册路由</h1><p id="c799" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">然而，当构建一个生产应用时，更好的实现是进行用户验证，包括Regex和<a class="ae nk" href="https://express-validator.github.io/docs/custom-validators-sanitizers.html" rel="noopener ugc nofollow" target="_blank">自定义验证器</a>。首先，让我们在routes/auth.js文件中创建用户注册路由。</p><figure class="lr ls lt lu gt na"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="a17b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在创建用户并将其保存到数据库之前，我们已经使用了定制验证器。</p><h1 id="2ac4" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">在Postman中测试/注册端点并存储用户</h1><p id="57ab" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">(现在我们已经对auth.js文件进行了编码，请记住取消我们之前在app.js中注释的行的注释)</p><p id="299d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe nm nn no lw b">POST request: <a class="ae nk" href="http://localhost:3001/api/user/register" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/auth/register</a></code></p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="90cc" class="ki kj in lw b gy ma mb l mc md">//body-raw-json</span><span id="b4a2" class="ki kj in lw b gy me mb l mc md">{<br/>    "name":"test1",<br/>    "email":"test1@test.com",<br/>    "password": "12345abc",<br/>    <!-- -->"passwordConfirmation":<!-- -->"12345abc"<br/>}</span></pre><p id="9db1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您应该在Postman中得到类似的结果</p><figure class="lr ls lt lu gt na gh gi paragraph-image"><div class="gh gi np"><img src="../Images/351eb12017abbce942b6e52ca719f2df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*58alJqRap0oC8msFQk_0Kw.png"/></div></figure><h1 id="e65d" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">创建用户登录路径</h1><p id="d5d2" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">现在，我们的用户集合数据库中已经有了一个用户，让我们创建登录路由，这里我们需要进行与注册路由相同的自定义验证，但需要编写以下三行代码—第5–7行。我们添加Bcrypt来使用它的compare方法检查用户输入的密码是否与数据库中的密码匹配。在此过程中，我们还将使用JWT提供一个访问令牌。</p><figure class="lr ls lt lu gt na"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="00dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在postman <code class="fe nm nn no lw b">http://localhost:3000/api/auth/login</code>中测试这个POST请求</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="a72e" class="ki kj in lw b gy ma mb l mc md">"name":"test1",<br/>    "email":"test1@test.com",<br/>    "password": "12345abc",<br/>    <!-- -->"passwordConfirmation":<!-- -->"12345abc"<br/>}</span></pre><p id="296b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您应该在响应中获得访问令牌</p><figure class="lr ls lt lu gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nq"><img src="../Images/cfbd83bcb9ef758fcd7a385293a839e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HIxpbMo3DIzOWdQvrrkzKw.png"/></div></div></figure><h1 id="fd6d" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">访问令牌和刷新令牌</h1><p id="649f" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">最后一个重要的实现要求我们在登录路径中为刷新令牌添加几行代码。</p><p id="7537" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">访问令牌和刷新令牌之间的区别在于，刷新令牌的生命周期比访问令牌长得多。例如，我们可以将访问令牌的有效期设置为5分钟，而将刷新令牌的有效期设置为6个月。</p><p id="4699" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">访问令牌授予对存储在资源服务器中的资源的访问，而刷新令牌每当到期时授予新的访问令牌。访问令牌通常具有较短的寿命，这限制了潜在黑客访问资源的时间。刷新令牌由单独的授权服务器发布。</p><h1 id="e62b" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">创建刷新令牌模型</h1><figure class="lr ls lt lu gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nv"><img src="../Images/00171e3116cb8b8c678eb4ee795742c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2XGyNHsBDLIA0qx_HErRAg.png"/></div></div></figure><h1 id="cc1a" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">创建一个中间件来验证令牌</h1><p id="7f83" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">在我们的中间件文件夹中，让我们在verifyToken.js文件中编写一些代码来验证用户。我们从客户端请求头中获取accessToken。然后我们使用jwt.verify方法。检查拼写是否是headers而不是header，否则无法工作。</p><figure class="lr ls lt lu gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nw"><img src="../Images/6869a91326745c12645e3575740a9af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Uy3oN7nvAM-P52cjGSpHLw.png"/></div></div></figure><h1 id="24f4" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">为经过验证的用户创建一条专用路线</h1><p id="fc9c" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">在routes文件夹中创建一个新文件users.js，为经过验证的用户设置一个私有路径。在这里，我们在获取用户信息之前使用verifyJWT作为中间件。</p><figure class="lr ls lt lu gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nx"><img src="../Images/4c005a12379ff29e096dc14ea270b0e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ow9lf61AJ8Iyb8Xpo78TQQ.png"/></div></div></figure><h1 id="d938" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">在登录路由中实现刷新令牌</h1><p id="0662" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">这是我们最终的auth.js文件，我们在其中导入刷新模型和加密模块以使用它的。randomBytes()方法<strong class="jm io">。</strong>该方法<strong class="jm io"> </strong>生成一个加密安全的随机数据。</p><figure class="lr ls lt lu gt na"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="6e27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们在邮递员那里检查这个。将这个设置为GET，url为<a class="ae nk" href="http://localhost:3000/api/users/userInfo." rel="noopener ugc nofollow" target="_blank">http://localhost:3000/API/users/userInfo。从上一个post请求中获取_id。</a></p><figure class="lr ls lt lu gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi ny"><img src="../Images/d2a238381d22816d02c85919c0327507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ChEHCsCp-xPv47bbydH2ew.png"/></div></div></figure><p id="0b39" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，在Headers选项卡中创建一个名为authorization的新键，并粘贴我们之前获得的访问令牌的值。如果一切正常，您应该获得用户数据作为响应。</p><figure class="lr ls lt lu gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nr ns di nt bf nu"><div class="gh gi nz"><img src="../Images/9f2c6f3f33fe0f11cf88d9f35f4f06fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BeUBjSooRqnuja_iVibFpg.png"/></div></div></figure><h1 id="e476" class="mf kj in bd kk mg mh mi kn mj mk ml kq mm mn mo kt mp mq mr kw ms mt mu kz mv bi translated">结论</h1><p id="a8bc" class="pw-post-body-paragraph jk jl in jm b jn ld jp jq jr le jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">实现了这一点，值得注意的是，作为开发人员，我们还有其他选择，例如使用Passport(一种用于节点或服务的认证中间件，如Auth0)。然而，事先了解这些过程是如何工作的是有好处的。</p></div></div>    
</body>
</html>