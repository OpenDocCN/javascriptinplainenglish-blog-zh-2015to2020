<html>
<head>
<title>JavaScript Best Practices — Privacy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—隐私</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-privacy-bfef099274a7?source=collection_archive---------8-----------------------#2020-06-04">https://javascript.plainenglish.io/javascript-best-practices-privacy-bfef099274a7?source=collection_archive---------8-----------------------#2020-06-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0c6d82ef2ba22231e355838cf3b69ac6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rMCwF45yGJU7cDau"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@dtopkin1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dayne Topkin</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="de91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript让我们可以做很多事情。它的语法有时过于宽容。</p><p id="9766" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何创建和使用对象，包括保持事物的私有性。</p><h1 id="a9d0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">隐私失败</h1><p id="ca38" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们在一个应该是私有的函数中直接返回对象时，我们可以直接从外部修改它们。</p><p id="c96a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为变量是通过引用传递的。</p><p id="4052" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8eff" class="mn lc iq mj b gy mo mp l mq mr">function Foo() {<br/>  const bar = {<br/>    a: 1,<br/>    b: 2<br/>  };</span><span id="6baf" class="mn lc iq mj b gy ms mp l mq mr">  // public function<br/>  this.getBar = function() {<br/>    return bar;<br/>  }<br/>}</span></pre><p id="d409" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe mt mu mv mj b">bar</code>是私有的，但是因为它是由<code class="fe mt mu mv mj b">getBar</code>返回的，所以我们可以从外部访问它。</p><p id="f8b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以修改它。</p><p id="3e89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f152" class="mn lc iq mj b gy mo mp l mq mr">const foo = new Foo();<br/>bar = foo.getBar();<br/>console.log(foo.getBar());<br/>bar.a = 2;<br/>console.log(foo.getBar());</span></pre><p id="182b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会看到<code class="fe mt mu mv mj b">bar</code>现在是<code class="fe mt mu mv mj b">{a: 2, b: 2}</code>。</p><p id="acb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这并不好，因为我们不想从外部改变<code class="fe mt mu mv mj b">bar</code>。</p><p id="fa73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该在返回对象或将其放入模块之前克隆它。</p><p id="d1bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用spread操作符做一个浅层克隆。</p><p id="1599" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe mt mu mv mj b">export</code>关键字来导出模块中的对象。</p><p id="b4ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们要么改变对象的克隆，要么在试图直接修改它时得到一个错误。</p><h1 id="0b56" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象文字和隐私</h1><p id="8a59" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们希望对象数据是私有的，那么我们必须将它包装在一个函数中，然后返回它的一部分。</p><p id="2e48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="44ad" class="mn lc iq mj b gy mo mp l mq mr">(() =&gt; {<br/>  const name = 'foo';</span><span id="a071" class="mn lc iq mj b gy ms mp l mq mr">  return {<br/>    getName() {<br/>      return name;<br/>    }<br/>  }<br/>})()</span></pre><p id="b38b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，<code class="fe mt mu mv mj b">getName</code>有特权访问<code class="fe mt mu mv mj b">name</code>常量。</p><p id="2334" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在函数定义后立即运行它，所以如果我们将返回的对象赋给一个变量或常量，就可以调用它。</p><p id="2d8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以将对象赋给一个生命之外的变量，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6ef1" class="mn lc iq mj b gy mo mp l mq mr">let obj;<br/>(() =&gt; {<br/>  const name = 'foo';</span><span id="f0d4" class="mn lc iq mj b gy ms mp l mq mr">  obj = {<br/>    getName() {<br/>      return name;<br/>    }<br/>  }<br/>})()</span></pre><p id="a8df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以在生活结束后调用<code class="fe mt mu mv mj b">obj.getName</code>。</p><h1 id="6a22" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">原型和隐私</h1><p id="c59a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们不想在一个构造函数的每个实例中有单独的方法实例，那么我们必须把它们放在原型中。</p><p id="09cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，所有实例方法都是从构造函数的原型继承的。</p><p id="0d21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="12fa" class="mn lc iq mj b gy mo mp l mq mr">function Foo() {}</span><span id="9535" class="mn lc iq mj b gy ms mp l mq mr">Foo.prototype.hello = function() {<br/>  //...<br/>}</span></pre><p id="3128" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，由于构造函数没有存储私有数据的地方，我们不得不努力寻找一个存储私有数据的地方。</p><p id="4a5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4adb" class="mn lc iq mj b gy mo mp l mq mr">function Foo() {}</span><span id="a350" class="mn lc iq mj b gy ms mp l mq mr">Foo.prototype = (() =&gt; {<br/>  const foo = "foo";<br/>  return {<br/>    getFoo() {<br/>      return foo;<br/>    }<br/>  };<br/>})();</span></pre><p id="e709" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们将<code class="fe mt mu mv mj b">foo</code>作为私有变量。</p><p id="da0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe mt mu mv mj b">getFoo</code>函数返回一个对象。</p><p id="f945" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当我们调用<code class="fe mt mu mv mj b">getFoo</code>时如下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="22b2" class="mn lc iq mj b gy mo mp l mq mr">const foo = new Foo();<br/>console.log(foo.getFoo());</span></pre><p id="3ee6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们记录了<code class="fe mt mu mv mj b">'foo'</code>而没有公开<code class="fe mt mu mv mj b">foo</code>常量本身。</p><p id="b677" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是类语法现在没有的一点。</p><p id="114f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有好的方法可以用类语法添加私有变量，所以这是构造函数语法的一个优点。</p><h1 id="5a46" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将私有函数公开为公共方法</h1><p id="c61f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们想将一些私有函数作为公共方法公开，我们可以这样做。</p><p id="4476" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用启示模式来揭示我们选择的一些私有成员。</p><p id="f167" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1878" class="mn lc iq mj b gy mo mp l mq mr">const obj = (() =&gt; {<br/>  const foo = () =&gt; {<br/>    //...<br/>  }</span><span id="ea07" class="mn lc iq mj b gy ms mp l mq mr">  const bar = () =&gt; {<br/>    //...<br/>  }<br/>  const baz = () =&gt; {<br/>    //...<br/>  }</span><span id="8b23" class="mn lc iq mj b gy ms mp l mq mr">  return {<br/>    foo,<br/>    bar<br/>  }<br/>})();</span></pre><p id="4bdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在下面的对象中返回了<code class="fe mt mu mv mj b">foo</code>和<code class="fe mt mu mv mj b">bar</code>，所以我们可以用<code class="fe mt mu mv mj b">obj.foo()</code>和<code class="fe mt mu mv mj b">obj.bar()</code>来调用它们。</p><p id="4e78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于存储我们不想暴露给外界的帮助函数是很方便的。</p><p id="7ab7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以冻结<code class="fe mt mu mv mj b">obj</code>对象以防止意外修改。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/65dc1763f4a5783406745fd9cdd3d898.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*02sH8RwodCWipG57"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@timmossholder?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tim Mossholder</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3341" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">模块模式</h1><p id="2f79" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在模块模式中，我们将私有和特权方法和名称空间合二为一。</p><p id="acaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下代码来定义自己的模块:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ff09" class="mn lc iq mj b gy mo mp l mq mr">const APP = {<br/>  utilities: {}<br/>}</span><span id="e800" class="mn lc iq mj b gy ms mp l mq mr">APP.utilities.math = (() =&gt; {<br/>  return {<br/>    add(a, b) {<br/>      // ...<br/>    },<br/>    subtract(a, b) {<br/>      // ...<br/>    }<br/>  };<br/>}());</span></pre><p id="46bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码定义了一个名为<code class="fe mt mu mv mj b">APP.utilities.math</code>的模块。</p><p id="62d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有对外可用的<code class="fe mt mu mv mj b">add</code>和<code class="fe mt mu mv mj b">subtract</code>方法。</p><p id="bd07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以随时打电话给他们:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d1f1" class="mn lc iq mj b gy mo mp l mq mr">APP.utilities.math.add((1, 2)</span></pre><p id="7e9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4953" class="mn lc iq mj b gy mo mp l mq mr">APP.utilities.math.subtract(1, 2)</span></pre><p id="9551" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不必返回返回对象中的所有成员。</p><p id="0b2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以保留一些隐私。</p><p id="4ab2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们的JavaScript项目中没有模块时，这仍然很有用。</p><h1 id="0ab7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7f26" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们的项目中没有模块时，我们可以创建自己的模块。</p><p id="e556" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了防止意外修改函数中返回的对象，我们可以复制或冻结它们。</p><p id="3e68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以通过给返回一个对象的<code class="fe mt mu mv mj b">prototype</code>分配一个生命来在构造函数中拥有私有成员。</p><h2 id="cfa0" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="a784" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">来表达爱意吧！</strong></p></div></div>    
</body>
</html>