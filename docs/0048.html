<html>
<head>
<title>How to traverse the DOM in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中遍历DOM</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-traverse-the-dom-in-javascript-d6555c335b4e?source=collection_archive---------0-----------------------#2018-11-03">https://javascript.plainenglish.io/how-to-traverse-the-dom-in-javascript-d6555c335b4e?source=collection_archive---------0-----------------------#2018-11-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/41f951c6f2d89bf21d537bd55d3f3e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bZdQR7bYle1V88r5"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">“pink sakura tree at day time” by <a class="ae jz" href="https://unsplash.com/@fcornish?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Faye Cornish</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="870b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">文档对象模型，简称DOM，是浏览器在网页上放置元素时的参考。元素在DOM中放置的位置叫做<code class="fe ky kz la lb b">Nodes</code>，在网页上，并不是只有HTML元素才有它们的节点，HTML元素的属性也有它们的节点(<code class="fe ky kz la lb b">attribute nodes</code>)，每一段文本都有它的节点(<code class="fe ky kz la lb b">text nodes</code>)，还有很多其他的节点类型。这些节点的结构关系反映了HTML文档的结构。因此，我们可以将页面上元素之间的关系定义为它们在DOM中的节点之间的关系。</p><p id="5217" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们用编程语言(比如JavaScript)操作网页上的元素时，我们是通过它们的DOM节点来完成的。通过访问给定元素的DOM节点，我们可以操纵它的属性，比如位置、外观、内容、行为等。通常，我们希望在元素之间有某种关系的元素上执行操作，这种关系称为相关节点。为了做到这一点，我们必须有一种从一个节点移动到另一个节点的方法，也就是遍历DOM的方法。</p><p id="5ced" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了对DOM中某个节点的访问权，就有了使用相关节点遍历DOM的方法。我们可以在DOM树中上下移动，也可以在同一DOM级别上横向移动。在本文中，我们将了解如何使用JavaScript编程语言访问相关的DOM节点。</p><h1 id="ed74" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">DOM节点之间的关系</h1><p id="f264" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">首先，让我们看看元素之间存在什么关系，以便我们以后能够更好地理解访问它们所使用的技术。HTML元素相互嵌套，形成树状结构。嵌套元素可能有很多层，所有这些都反映在元素节点的DOM树中。</p><h2 id="4970" class="mf ld in bd le mg mh dn li mi mj dp lm kl mk ml lq kp mm mn lu kt mo mp ly mq bi translated">后代和祖先元素</h2><p id="b6d3" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">这个关系没有实际用途，但是它将帮助我们更清楚地表达一些元素关系。</p><p id="26a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个元素下可能嵌套了许多层的其他元素，所有嵌套层中的所有嵌套元素都被称为起始元素的<strong class="kc io">后代</strong>元素。例如，让我们用一个<code class="fe ky kz la lb b">main</code>元素作为页面的主要内容，其内容如下:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8e39" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在嵌套的第一层有<code class="fe ky kz la lb b">&lt;h1&gt;</code>元素和两个&lt;文章&gt;元素。然后，在第二嵌套层次我们有<code class="fe ky kz la lb b">&lt;h2&gt;</code>和<code class="fe ky kz la lb b">&lt;section&gt;</code>元素，最后在第三层次有<code class="fe ky kz la lb b">&lt;p&gt;</code>元素在<code class="fe ky kz la lb b">&lt;section&gt;</code>元素里面。所有这些元素都是<code class="fe ky kz la lb b">&lt;main&gt;</code>元素的后代。</p><p id="d061" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也就是说，<code class="fe ky kz la lb b">&lt;main&gt;</code>元素是它们的<strong class="kc io">祖先</strong>元素，也就是它们在DOM树中所属的元素。</p><p id="7594" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是在这个例子中，在其他元素之间也可以看到后代/祖先关系。例如，<code class="fe ky kz la lb b">&lt;article&gt;</code>元素是它们嵌套的<code class="fe ky kz la lb b">&lt;h2&gt;</code>、<code class="fe ky kz la lb b">&lt;section&gt;</code>和<code class="fe ky kz la lb b">&lt;p&gt;</code>元素的祖先，而这些元素又是它的后代元素。同样的关系也适用于<code class="fe ky kz la lb b">&lt;section&gt;</code>和<code class="fe ky kz la lb b">&lt;p&gt;</code>元件。</p><p id="f1a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我们必须指出一个重要的事情。例如，标题“如何种植盆景”不是<code class="fe ky kz la lb b">&lt;article id=”article-1"&gt;</code>的后代，那篇文章也不是提到的标题的祖先。这是因为“如何种植盆景”的标题并不在第一篇文章中，而是在第二篇文章中。因此，它们之间没有后代/祖先关系。这同样适用于<code class="fe ky kz la lb b">&lt;section&gt;</code>和<code class="fe ky kz la lb b">&lt;p&gt;</code>元素，它们是嵌套它们的article元素的后代，而article元素是它们的祖先。</p><h2 id="ff3b" class="mf ld in bd le mg mh dn li mi mj dp lm kl mk ml lq kp mm mn lu kt mo mp ly mq bi translated">父和子元素</h2><p id="8fa7" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">特殊且非常有用的后代/祖先关系是元素是给定节点的直接后代或祖先的情况。“直接”意味着它们离给定的节点只有一个嵌套层次。</p><p id="d0e5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">父节点</strong>(元素)是给定元素最接近的祖先元素。如果我们选择标题“如何种植盆景”，第一个祖先元素(向上一级)是<code class="fe ky kz la lb b">&lt;article id=”article-2"&gt;</code>元素，我们称它为给定标题的父元素。<code class="fe ky kz la lb b">&lt;article&gt;</code>元素共享同一个父元素，它们都嵌套在作为其父元素的<code class="fe ky kz la lb b">&lt;main&gt;</code>元素下。注意<code class="fe ky kz la lb b">&lt;h1&gt;</code>也有<code class="fe ky kz la lb b">&lt;main&gt;</code>元素作为其父元素。“我们现在做什么！?"第一个项目元素下有<code class="fe ky kz la lb b">&lt;section&gt;</code>元素作为其父元素。</p><p id="c518" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与父元素相对的是<strong class="kc io">子元素</strong>，但是虽然该元素只能有一个父元素，但是它下面可以有多个子元素。子元素是给定元素的所有直接后代元素(向下一级)。<code class="fe ky kz la lb b">&lt;main&gt;</code>元素的子元素是<code class="fe ky kz la lb b">&lt;h1&gt;</code>和<code class="fe ky kz la lb b">&lt;article&gt;</code>元素，没有其他元素。第二篇文章的子元素是“如何种植盆景”标题和嵌套在它下面的<code class="fe ky kz la lb b">&lt;section&gt;</code>。该部分中的段落不是第二个文章元素的子元素，而是<code class="fe ky kz la lb b">&lt;section&gt;</code>元素的子元素。</p><p id="5bf2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里需要注意的另一件重要的事情是，HTML中的每一位文本在DOM中都有一个<strong class="kc io">文本节点</strong>。鉴于此，第一篇文章中的标题有一个文本节点作为其子节点，该节点包含文本“人类历史上第一次接触外星生物”，并且标题元素是该文本节点的父节点，第二篇文章中的标题是文本为“如何种植盆景”的子文本节点的父节点。</p><h2 id="b19f" class="mf ld in bd le mg mh dn li mi mj dp lm kl mk ml lq kp mm mn lu kt mo mp ly mq bi translated">同级元素</h2><p id="1dd4" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">如果两个或多个元素的父元素相同，则它们是同级元素。在我们的示例中，<code class="fe ky kz la lb b">&lt;h1&gt;</code>和两个<code class="fe ky kz la lb b">&lt;article&gt;</code>元素是同级的，因为它们有相同的父元素，即<code class="fe ky kz la lb b">&lt;main&gt;</code>元素。第一篇文章中的<code class="fe ky kz la lb b">&lt;p&gt;</code>元素是同级元素，因为它们的父元素是第一篇文章中的<code class="fe ky kz la lb b">&lt;section&gt;</code>元素。但是第二篇文章中的<code class="fe ky kz la lb b">&lt;p&gt;</code>元素不是第一篇文章中的<code class="fe ky kz la lb b">&lt;p&gt;</code>元素的同级，因为它们并不共享同一个父元素，即使它们处于相同的嵌套级别。</p><h1 id="3073" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">通过相关节点遍历DOM</h1><p id="2693" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">最后，我们将看到如何使用节点之间的关系来遍历DOM树。DOM树中的一个节点用一个node对象表示，Node对象具有允许我们访问给定节点的相关节点的属性。</p><p id="ab38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将在示例HTML中添加一些id和类，以便更好地访问DOM树中的元素:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="c6f5" class="mf ld in bd le mg mh dn li mi mj dp lm kl mk ml lq kp mm mn lu kt mo mp ly mq bi translated">查找给定节点的父节点</h2><p id="d316" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">如果我们有一个Node对象，它是对DOM中的一个<code class="fe ky kz la lb b">node</code>的引用，为了获得它的父节点，我们可以使用<code class="fe ky kz la lb b">node</code>上的<code class="fe ky kz la lb b">parentNode</code>属性。由于<code class="fe ky kz la lb b">node</code>是一个对象，<code class="fe ky kz la lb b">parentNode</code>是一个属性，我们可以使用‘点’符号来访问<code class="fe ky kz la lb b">node</code>的父元素，如下所示:</p><pre class="mr ms mt mu gt mx lb my mz aw na bi"><span id="820c" class="mf ld in lb b gy nb nc l nd ne">const parent = node.parentNode;</span></pre><p id="828f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们在示例HTML中找到第一个文章节点的父节点。</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1c50" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们找到标题“如何种植盆景”的父代。</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a150" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用给定节点的父节点来获取DOM树中给定节点的所有祖先。例如:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="e79d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也可以通过在<code class="fe ky kz la lb b">bonsai</code>节点上链接parentNode <code class="fe ky kz la lb b">property</code>来获得<code class="fe ky kz la lb b">grandParent</code>节点:</p><pre class="mr ms mt mu gt mx lb my mz aw na bi"><span id="82ca" class="mf ld in lb b gy nb nc l nd ne">const grandParent = bonsai.parentNode.parentNode;</span></pre><p id="9364" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">parentNode</code>通常用于从DOM中移除给定的节点。假设我们想从文档中删除第一篇文章，因为它太令人苦恼了。我们会这样做:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b09c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">HTML元素的父元素可以是元素节点、文档节点或文档片段节点。在应用于Document和DocumentFragment节点的情况下，节点的<code class="fe ky kz la lb b">parentNode</code>属性可以返回<code class="fe ky kz la lb b">null</code>，因为它们永远不会有父节点。如果刚刚创建了一个节点，但是它没有附加到DOM，那么对它应用<code class="fe ky kz la lb b">parenNode</code>也会返回<code class="fe ky kz la lb b">null</code>。</p><p id="2076" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还有一点需要注意的是,<code class="fe ky kz la lb b">parentNode</code>属性是一个只读属性，这意味着不可能做这样的事情:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="c42b" class="mf ld in bd le mg mh dn li mi mj dp lm kl mk ml lq kp mm mn lu kt mo mp ly mq bi translated">查找给定节点的子节点</h2><p id="3cd5" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">要获得一个<code class="fe ky kz la lb b">node</code>的所有子节点，我们可以使用它的<code class="fe ky kz la lb b">childNodes</code>属性。例如:</p><pre class="mr ms mt mu gt mx lb my mz aw na bi"><span id="6dec" class="mf ld in lb b gy nb nc l nd ne">const children = node.childNodes;</span></pre><p id="3167" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">结果是一个节点列表，每个对象代表我们的<code class="fe ky kz la lb b">node</code>的一个子节点。节点列表在某种程度上类似于数组，可以使用数组索引遍历列表。例如，让我们打印一个节点列表中所有子节点的<code class="fe ky kz la lb b">nodeName</code>属性。</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="9600" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们用一个不同的HTML来解释使用<code class="fe ky kz la lb b">childNodes</code>属性的一些重要含义:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="919e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们应用前面的javascript代码打印出来自<code class="fe ky kz la lb b">&lt;ul&gt;</code>元素的子节点的节点名，我们将得到这样的结果:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b170" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不完全如人们所料。您可能认为只会打印出六个<code class="fe ky kz la lb b">li</code>元素名称，但是我们得到了七个以上的文本节点。</p><p id="fa43" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是因为节点列表还包含文本节点和注释节点，所以我们在使用该属性时必须小心。发生这种情况是因为在HTML中，新的一行被视为空白，即文本节点。因此，HTML标记之间的换行符和空白将文本节点添加到子节点列表中。</p><p id="23ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了避免这种情况，我们可以像这样重新组织我们的HTML结构:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6087" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们得到了预期的输出:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="88f0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">节点列表是节点的动态列表。这意味着在<code class="fe ky kz la lb b">node</code>中添加或删除子元素会更新列表，我们不必再次获取它。这也意味着，如果节点列表中的元素数量发生变化，像这样使用的<code class="fe ky kz la lb b">for</code>循环将会失败:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5bf8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这段代码将在第六次迭代时导致错误:<code class="fe ky kz la lb b">TypeError: children[i] is undefined</code>。这是因为<code class="fe ky kz la lb b">children</code>节点列表随着删除第三项而改变。为了避免这种情况，我们应该在每次迭代中更新<code class="fe ky kz la lb b">len</code>变量，或者更好的是，在循环条件中使用<code class="fe ky kz la lb b">children.length</code>而不是我们所做的<code class="fe ky kz la lb b">len</code>。</p><p id="8e37" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们只想获得HTML元素作为<code class="fe ky kz la lb b">node</code>的子元素，我们可以使用<code class="fe ky kz la lb b">children</code>属性而不是<code class="fe ky kz la lb b">childNodes</code>属性:</p><pre class="mr ms mt mu gt mx lb my mz aw na bi"><span id="abf1" class="mf ld in lb b gy nb nc l nd ne">const childElements = list.children;</span></pre><h2 id="73d3" class="mf ld in bd le mg mh dn li mi mj dp lm kl mk ml lq kp mm mn lu kt mo mp ly mq bi translated">“特殊”儿童</h2><p id="9bec" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">嗯，通常在家庭中，孩子们中有最喜欢的，那些“特别”的。node家族也是如此，有些孩子很特别。那些是什么孩子？—你可能会问。你可能猜到了，这是第一个也是最后一个。:)</p><p id="eb3f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个类比不是一个毫无意义的笑话。在DOM树中，具有子节点的节点已经定义了属性<code class="fe ky kz la lb b">firstChild</code>和<code class="fe ky kz la lb b">lastChild</code>。它们用于快速查找给定节点下的第一个和最后一个子节点。在我们的例子中，第一个孩子对应于第一个列表项，最后一个孩子对应于第六个列表项。下面是我们获取这些元素的方法:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="855b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">需要注意的是，<code class="fe ky kz la lb b">firstChild</code>和<code class="fe ky kz la lb b">lastChild</code>也将换行符视为文本节点，在我们的第一个列表(带有换行符的列表)中，它们会产生文本节点，而不是列表项。</p><h2 id="ce21" class="mf ld in bd le mg mh dn li mi mj dp lm kl mk ml lq kp mm mn lu kt mo mp ly mq bi translated">查找节点的兄弟节点</h2><p id="e20d" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">当我们可以访问一个<code class="fe ky kz la lb b">node</code>时，我们可以使用<code class="fe ky kz la lb b">nextSibling</code>和<code class="fe ky kz la lb b">previousSibling</code>属性访问它的兄弟节点。</p><p id="982a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">属性<code class="fe ky kz la lb b">nextSibling</code>将获得紧跟在给定的<code class="fe ky kz la lb b">node</code>之后的兄弟节点。语法如下:</p><pre class="mr ms mt mu gt mx lb my mz aw na bi"><span id="f636" class="mf ld in lb b gy nb nc l nd ne">const next = node.nextSibling;</span></pre><p id="ed02" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们找到带有<code class="fe ky kz la lb b">id=”three”</code>的条目的下一个兄弟条目:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="5f27" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以一步一步地浏览下面的兄弟姐妹:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="653c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们到达父节点中的最后一个兄弟节点时，使用<code class="fe ky kz la lb b">nextSibling</code>将返回<code class="fe ky kz la lb b">null</code>，因为在最后一个子节点之后不再有兄弟节点:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1d2d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">属性<code class="fe ky kz la lb b">previousSibling</code>将获得紧接在给定<code class="fe ky kz la lb b">node</code>之前的兄弟节点。该语法类似于<code class="fe ky kz la lb b">nextSibling</code>的语法:</p><pre class="mr ms mt mu gt mx lb my mz aw na bi"><span id="0ab0" class="mf ld in lb b gy nb nc l nd ne">const previous = node.previousSibling;</span></pre><p id="fe00" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们找到带有<code class="fe ky kz la lb b">id=”three”</code>的条目的前一个兄弟条目:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="421c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在可以一步一步地检查其他以前的兄弟姐妹:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="4d51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们到达父节点中的第一个兄弟节点时，使用<code class="fe ky kz la lb b">previousSibling</code>将返回<code class="fe ky kz la lb b">null</code>，因为在第一个子节点之前没有兄弟节点:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="3d16" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">最后一个例子</h1><p id="f7aa" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">现在，让我们做一个例子，这个例子需要比我们之前的例子更复杂的遍历。让我们再次使用第一个HTML示例结构:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="fe6e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们可以访问第一篇文章的标题(<code class="fe ky kz la lb b">&lt;h2 class=”sensations”&gt;</code>)，我们想阅读下一篇文章的标题文本。</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="88e7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">糟糕，错误的节点！请记住，换行符被视为空白，并且空白与文本节点一起呈现。那么，如何才能避免这种情况呢？</p><p id="33ae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用一个循环，遍历下一个兄弟节点，检查节点是否是元素节点，而不是文本或任何其他节点。为了检查一个<code class="fe ky kz la lb b">node</code>是否是一个元素节点，我们可以检查一个叫做<code class="fe ky kz la lb b">nodeType</code>的节点属性。元素节点的<code class="fe ky kz la lb b">nodeType</code>属性将具有值<code class="fe ky kz la lb b">ELEMENT_NODE</code>，该值被称为常量，或者它可以具有数值<code class="fe ky kz la lb b">1</code>，您可以检查其中任何一个。要查看所有其他节点类型及其值，您可以查看<a class="ae jz" href="https://developer.mozilla.org/en/docs/Web/API/Node/nodeType" rel="noopener ugc nofollow" target="_blank">这篇文章</a>。</p><p id="38a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个任务最好使用<code class="fe ky kz la lb b">while</code>循环。让我们更改前面的代码，添加一个while循环并检查节点类型。</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3f2f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经找到了下一篇文章。最后，我们希望得到它下面的标题。因为我们知道标题是文章节点下的第一个元素节点，所以我们可以考虑在<code class="fe ky kz la lb b">nextNode</code>节点上使用<code class="fe ky kz la lb b">firstChild</code>属性，但是文本节点的问题会再次出现。为了避免这种情况，我们可以再次使用循环来检查节点的类型，或者我们可以使用<code class="fe ky kz la lb b">nextNode</code>上的<code class="fe ky kz la lb b">querySelector</code>来获取第一个<code class="fe ky kz la lb b">h2</code>元素，并且，第二种方法可能是最安全的。但是，为了便于实践，让我们使用前面简单提到的<code class="fe ky kz la lb b">node</code>对象的<code class="fe ky kz la lb b">children</code>属性。</p><p id="7a23" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">属性将返回列表子元素节点，然后我们可以从列表中选择第一个。以下是完整的代码:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h1 id="ba2a" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="c81c" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">仔细看看最后一个例子，有人可能会问，当我们可以像这样做一个简单的查询时，为什么还要遍历所有相关的节点呢？</p><pre class="mr ms mt mu gt mx lb my mz aw na bi"><span id="d4bb" class="mf ld in lb b gy nb nc l nd ne">const secondH2 = document.querySelector('.horticulture');</span></pre><p id="8249" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然在这个简单的例子中确实如此，但是请记住，我们明确地想要到达下一篇文章的标题，并且在一个真实的网站中，页面可以大得多，内容可以嵌套得更深。此外，内容可以自动生成，我们不知道什么类将对我们可用。因此，我们必须对每个下一个标题进行完整的DOM查询。但是通过使用相关的兄弟节点，我们能够在我们感兴趣的节点周围，而不是每次都查询整个DOM树，因此当我们有一个非常大的网页时，可以提高性能。</p><p id="6f9d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了在包含许多文章的大型web页面上有效地使用这一点，我们可以将其全部封装到一个函数中，该函数接受当前节点作为参数:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="7b21" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，我们在while循环条件中增加了一个检查<code class="fe ky kz la lb b">nextNode.nodeName === ‘ARTICLE’</code>,只是为了确保我们得到了正确的元素类型，因为可能会发生这样的情况，即article元素的其他兄弟元素不是article。</p><p id="6d5a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以在第二个标题上调用函数<code class="fe ky kz la lb b">nextHeading</code>,尝试从下一篇文章中获取标题:</p><figure class="mr ms mt mu gt jo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="613a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有许多用例可以使用相关节点来遍历DOM。您将使用的方法取决于HTML结构和您的想象力。所以，好好了解节点家族和它们之间的关系，它们会对你的DOM相关任务有很大帮助。</p><p id="3ec3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的阅读，并祝您在DOM中找到自己的路！</p></div></div>    
</body>
</html>