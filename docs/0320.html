<html>
<head>
<title>In Defense of Shallow Rendering</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为浅渲染辩护</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/in-defense-of-shallow-rendering-5f627f7c155d?source=collection_archive---------0-----------------------#2019-09-18">https://javascript.plainenglish.io/in-defense-of-shallow-rendering-5f627f7c155d?source=collection_archive---------0-----------------------#2019-09-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b55d7785bed924380c094bcb0e8e268d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qk111mwk18vtUs8hfM1p_w.jpeg"/></div></div></figure><p id="9276" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">作为测试React组件的工具，浅层渲染最近受到了不少批评，但大多数批评是不公正的，或者是基于对浅层渲染旨在解决的问题的误解。</p><p id="5fec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就在最近，我让一个开发人员再次提起Kent C. Dodds的这篇文章,解释他为什么在单元测试中使用DOM渲染。我钦佩Kent，他继续为JavaScript社区做出巨大贡献，但在浅层渲染这个话题上，我们的观点不同。</p><p id="0789" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">浅层渲染是一个直接针对React组件单元测试的工具。</em></p><p id="14db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Kent的文章避开了肤浅的渲染，这是很有意义的，因为他更喜欢集成测试而不是其他类型的测试。在这里，我的观点又一次不同，并且更接近传统智慧。</p><p id="ae10" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然集成(或服务)和端到端(或UI)测试是必不可少的，但它们的成本、较慢的速度和固有的脆弱性应该导致相应的投入。经典的测试金字塔最好地说明了这一点。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/d5d2dc8566a60892d847a4ef43bf4ca2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*IBpGR7l_cU-NlkIBSr81AQ.png"/></div><figcaption class="ld le gj gh gi lf lg bd b be z dk"><a class="ae kw" href="https://martinfowler.com/bliki/TestPyramid.html" rel="noopener ugc nofollow" target="_blank">https://martinfowler.com/bliki/TestPyramid.html</a></figcaption></figure><p id="bfe0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据这种方法，由于单元测试编写起来很便宜，运行起来也很快，所以你应该花更多的精力编写单元测试，而不是其他类型的测试。</p><p id="e37e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，这并不能说明全部情况。测试不仅仅是验证你代码的正确性。测试过程本身能够——也应该——帮助提高代码的整体质量。</p><p id="8788" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">单元测试有助于确保您生成的代码由小的、模块化的、单一责任部分组成，这些部分可以重用并组合在一起以解决更大的问题。如果说软件开发社区学到了什么，那就是解决大型复杂问题的最佳方式是将它们分解成小而简单的解决方案，这些解决方案可以组合起来解决更大的问题。单元测试，尤其是<a class="ae kw" href="https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530" rel="noopener ugc nofollow" target="_blank">测试驱动开发</a>，<a class="ae kw" href="https://blogs.itemis.com/en/unit-tests-are-tests-of-modularity" rel="noopener ugc nofollow" target="_blank">有助于确保这种方法</a>。</p><p id="776c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">本文的其余部分关注React组件的单元测试。除了浅层渲染，还有其他技术更适合测试金字塔的更高层。</p><h1 id="f900" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">测试反应组件</h1><p id="3f7a" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">在测试React组件时，考虑React提供的抽象是有帮助的，主要是将用户界面建模为组件树。</p><p id="4b26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从React文档中:</p><blockquote class="mk ml mm"><p id="08b2" class="jy jz kx ka b kb kc kd ke kf kg kh ki mn kk kl km mo ko kp kq mp ks kt ku kv ij bi translated">React组件允许您将UI分割成独立的、可重用的部分，并孤立地考虑每一部分。</p></blockquote><p id="dddd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些组件中的每一个都是最终用户界面的一部分的抽象。</p><blockquote class="mk ml mm"><p id="7127" class="jy jz kx ka b kb kc kd ke kf kg kh ki mn kk kl km mo ko kp kq mp ks kt ku kv ij bi translated">从概念上讲，组件就像JavaScript函数。它们接受任意输入(称为“props”)并返回描述屏幕上应该显示什么的React元素。与浏览器DOM元素不同，React元素是普通的对象，创建起来很便宜。<strong class="ka ir"> React DOM负责更新DOM以匹配React元素。</strong></p></blockquote><p id="675a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一点值得重复:</p><blockquote class="mk ml mm"><p id="f59d" class="jy jz kx ka b kb kc kd ke kf kg kh ki mn kk kl km mo ko kp kq mp ks kt ku kv ij bi translated"><strong class="ka ir"> React DOM负责更新DOM以匹配React元素。</strong></p></blockquote><p id="2d91" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">事实上，React的设计反映了这种抽象。我们得到了一个名为<code class="fe mq mr ms mt b">react</code>的包，其中包含核心组件抽象，以及一个名为<code class="fe mq mr ms mt b">react-dom</code>的完全独立的包，它负责将React元素(普通对象)转换为DOM表示的实现细节。</p><p id="f2ed" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">DOM是一个实现细节</strong></p><p id="bccd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这也是为什么，例如，我们可以使用基本的<code class="fe mq mr ms mt b">react</code>包和<code class="fe mq mr ms mt b">react-native</code>包——后者知道本地移动用户界面的实现细节。</p><h1 id="1fb4" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">反应元素</h1><p id="c929" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">那么，如果一个React组件返回一个称为React元素的普通对象，那么它看起来像什么呢？</p><p id="5a75" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">很高兴你问了。它看起来非常像这样:</p><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c7db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能希望组件返回一个DOM元素，就像这样？</p><pre class="kz la lb lc gt mw mt mx my aw mz bi"><span id="3839" class="na li iq mt b gy nb nc l nd ne">&lt;h1&gt;Hello Tim&lt;/h1&gt;</span></pre><p id="364c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但事实上，您得到的只是一个名为React元素的普通对象，您可以将它视为用于在以后生成实际UI的指令，以及目标UI所需的任何实现细节。</p><h1 id="0cca" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">儿童</h1><p id="4751" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">好吧，但是如果一个组件的子组件本身就是组件呢？</p><p id="e61c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将得到一个描述子组件的React元素，它具有与子组件相同的公共接口(props)</p><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="74ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，描述子组件的React元素没有公开任何实现细节，它只是描述了一个<code class="fe mq mr ms mt b">type</code>函数的子组件，有一个重要的属性叫做<code class="fe mq mr ms mt b">props</code>。</p><p id="6ba5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kx">React元素的概念对于理解React测试——实际上是React的一般工作方式——是如此的基础，以至于您应该在这里停下来，在继续之前重新阅读上面的所有内容。我是认真的，如果你没找到，就不要走。</em></p><h1 id="b7db" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">单元测试</h1><p id="2051" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">单元测试是一种在与外部系统和依赖关系隔离的情况下测试单个代码单元的方法。在React land中，单元是React组件。</p><p id="1486" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们之前了解到，React组件是UI的一个单独部分的抽象，将组件的抽象转换成DOM表示是一个实现细节。</p><p id="69ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，DOM是一个独立于运行代码的JavaScript引擎的系统。DOM由浏览器管理，虽然它为您的代码提供了一个JavaScript API进行交互，但它仍然是一个外部系统。这意味着，如果JavaScript代码单元在测试过程中与DOM交互，就不可能孤立地测试它。</p><p id="1827" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">测试中的最佳实践表明，我们不应该测试实现细节，而应该只测试测试对象的公共接口和行为。这是因为实现细节<strong class="ka ir"> <em class="kx">可以</em></strong><strong class="ka ir"><em class="kx">应该</em> </strong> <a class="ae kw" href="https://refactoring.com/" rel="noopener ugc nofollow" target="_blank">经常变化</a>，而行为应该只在需求变化时变化。</p><p id="bde3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">综上所述，这些信息表明，如果我们发现单元测试React组件的想法令人信服，我们只能在不与DOM交互的情况下测试它们，此外，如果我们这样做，我们将测试实现细节。</p><h1 id="a6b4" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">为浅渲染辩护</h1><p id="07a5" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">有益的是，React的工作人员也考虑到了这一点:</p><blockquote class="mk ml mm"><p id="5237" class="jy jz kx ka b kb kc kd ke kf kg kh ki mn kk kl km mo ko kp kq mp ks kt ku kv ij bi translated">在为React编写单元测试时，浅层渲染会很有帮助。浅层呈现允许您呈现“一级深度”的组件，并断言其呈现方法返回的内容，而不用担心子组件的行为，因为子组件没有被实例化或呈现。这不需要DOM。</p></blockquote><p id="0c89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的关键语句是，"<strong class="ka ir"> <em class="kx">断言其呈现方法返回的内容"</em> </strong></p><p id="2c6a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们之前了解到，React组件返回React元素— <em class="kx">而不是DOM元素</em>——一个描述稍后将创建的UI的普通对象。</p><p id="b3de" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着我们可以断言组件返回的React元素的正确性，而无需将其呈现到DOM中。</p><p id="0307" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">更重要的是，它让我们独立于外部系统(DOM)和它的任何子组件的实现细节来断言返回的对象<strong class="ka ir"> <em class="kx">。</em></strong></p><p id="ef9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="kx">浅层渲染使我们能够对React组件进行真正的单元测试。</em> </strong></p><p id="a944" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React团队发布了一个<a class="ae kw" href="https://reactjs.org/docs/shallow-renderer.html" rel="noopener ugc nofollow" target="_blank">浅层渲染器</a>和他们的“react-test-renderer”包。你在JSX和它说话，它会回答……你猜对了，简单的物体！</p><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="04dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">React测试渲染器的浅层渲染器非常好用，但是文档继续说:</p><blockquote class="mk ml mm"><p id="ae08" class="jy jz kx ka b kb kc kd ke kf kg kh ki mn kk kl km mo ko kp kq mp ks kt ku kv ij bi translated">我们还建议查看Enzyme的浅层渲染API。它在相同的功能上提供了更好的高级API。</p></blockquote><h1 id="f3db" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">酶的浅层渲染器</h1><p id="5122" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">由于它建立在React测试渲染器的浅层渲染器之上，所以毫不奇怪Enzyme的浅层渲染器也返回普通对象。</p><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c128" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Enzyme隐藏了ShallowWrapper对象的属性(通过在其原型的属性描述符上将enumerable设置为false ),但是您可以用<code class="fe mq mr ms mt b">Object.getOwnPropertyNames</code>将它们梳理出来</p><pre class="kz la lb lc gt mw mt mx my aw mz bi"><span id="cdb4" class="na li iq mt b gy nb nc l nd ne">{<br/>  length: 1,<br/>  Symbol(enzyme.__root__): ShallowWrapper,<br/>  Symbol(enzyme.__unrendered__): {…},<br/>  Symbol(enzyme.__renderer__): {…},<br/>  Symbol(enzyme.__node__): {…},<br/>  <strong class="mt ir">//…<br/></strong>}</span></pre><p id="9540" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Enzyme的<code class="fe mq mr ms mt b">ShallowWrapper</code>对象提供了比React的浅层渲染器丰富得多的API，使我们能够简洁而轻松地做一些用基本渲染器很麻烦的事情。它带有一些警告和合理的批评，但让我们首先澄清它的目的。</p><h2 id="814b" class="na li iq bd lj nf ng dn ln nh ni dp lr kj nj nk lv kn nl nm lz kr nn no md np bi translated">浅层渲染是</h2><ul class=""><li id="8c46" class="nq nr iq ka b kb mf kf mg kj ns kn nt kr nu kv nv nw nx ny bi translated">浅层渲染对于单独测试单个组件提供的抽象很有用。</li></ul><h2 id="fa4c" class="na li iq bd lj nf ng dn ln nh ni dp lr kj nj nk lv kn nl nm lz kr nn no md np bi translated">浅层渲染不是</h2><ul class=""><li id="54cb" class="nq nr iq ka b kb mf kf mg kj ns kn nt kr nu kv nv nw nx ny bi translated">浅层渲染对于测试最终用户体验没有用处。</li><li id="ee5f" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated">浅层呈现对于测试DOM呈现或交互没有用。</li><li id="cda0" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated">浅层渲染对集成测试没有用。</li><li id="b251" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated">浅层渲染对浏览器测试没有用。</li><li id="bcc0" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated">浅层渲染对端到端测试没有用。</li></ul><p id="823c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你没有发现单元测试React组件的价值，浅层渲染不适合你，但是我鼓励你在下定决心之前重读这篇文章，并查阅关于单元测试优点的现有文献。</p><h1 id="d7c2" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">该做的和不该做的</h1><h2 id="5880" class="na li iq bd lj nf ng dn ln nh ni dp lr kj nj nk lv kn nl nm lz kr nn no md np bi translated">做</h2><ul class=""><li id="407e" class="nq nr iq ka b kb mf kf mg kj ns kn nt kr nu kv nv nw nx ny bi translated">使用<code class="fe mq mr ms mt b">shallow</code>进行单元测试</li><li id="b952" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated">对断言使用不可知的方法:</li><li id="fc3d" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated">。find() —按名称、实例、aria-\*属性等搜索组件。</li><li id="8083" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated">。text()-返回当前渲染树的渲染文本字符串</li><li id="72cc" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated">。findWhere() —与结合。text()等。，用于灵活的、不可知的断言</li></ul><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><ul class=""><li id="b45d" class="nq nr iq ka b kb kc kf kg kj oe kn of kr og kv nv nw nx ny bi translated">。dive()——最多一两层——并且只针对由公共组件的源文件封装的子组件(不导出，但在同一个文件中)</li></ul><h2 id="389f" class="na li iq bd lj nf ng dn ln nh ni dp lr kj nj nk lv kn nl nm lz kr nn no md np bi translated">不</h2><ul class=""><li id="7db3" class="nq nr iq ka b kb mf kf mg kj ns kn nt kr nu kv nv nw nx ny bi translated">搜索实现细节:避免。find()包含类名、id、特定的DOM类型React元素、结构细节等。</li><li id="d16b" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated">使用练习实现细节的实用程序:</li><li id="1c65" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated">。setState()</li><li id="bbdf" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated">。实例()</li><li id="bbd1" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated">。html()</li><li id="5e34" class="nq nr iq ka b kb nz kf oa kj ob kn oc kr od kv nv nw nx ny bi translated">。潜水()深度超过几层。</li></ul><h1 id="cce6" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">把所有的放在一起</h1><p id="180a" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">下面这个浅显的渲染例子来自我的<a class="ae kw" href="https://www.youtube.com/watch?v=SDoq37lXHEw" rel="noopener ugc nofollow" target="_blank"> TDCD:测试驱动开发</a>演讲。你可以在这里克隆<a class="ae kw" href="https://github.com/timdoherty/tdcd" rel="noopener ugc nofollow" target="_blank">代码。</a></p><p id="959a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设我们正在构建一个Todo应用程序(因为以前没有人构建过这样的应用程序😉)并且我们想要对Todos组件进行单元测试——这个更高级别的组件包含todo组件列表和输入新组件的输入组件。</p><figure class="kz la lb lc gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/a09d24af96391b17b97b9bd7f6f3e2c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A5XwhEwDMUflvbXaoaRgag.png"/></div></div></figure><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="f532" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经对子组件进行了单元测试，这里我们想做的是约束自己只测试Todos组件的功能。一个这样的测试可能是验证当用户输入一个新的todo时，它被添加到todo列表中。</p><p id="f667" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">换句话说，我们希望验证我们的新todos组件是否为输入组件提供了一个更新Todos列表内容的回调。该回调驻留在Todos组件中，并导致其返回值(一个React元素)发生变化。我们可以验证Todo组件返回的React元素的正确性，而无需实例化或呈现子组件。</p><p id="bf16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们新的Todos组件呈现了一个子组件<a class="ae kw" href="https://github.com/timdoherty/tdcd/blob/5-app/src/TodoInput.jsx" rel="noopener ugc nofollow" target="_blank"> TodoInput </a>(已经过单元测试),它将实际接收用户的输入，并在用户按下回车键时调用一个<code class="fe mq mr ms mt b">onChange</code>回调(通过props传递)。</p><p id="3654" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里我们不需要模拟按回车键。我们甚至不需要渲染TodoInput。请记住，组件的返回值只是一个称为React元素的普通对象，它的子元素也是如此:</p><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="33ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">TodoInput子元素中没有<input/> DOM元素，没有按键事件，事实上除了一个普通的对象——React元素之外什么都没有。</p><p id="4e16" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">每个React元素都有一个名为<code class="fe mq mr ms mt b">props</code>的特殊属性，表示传递给组件的输入。我们的TodoInput有一个名为<code class="fe mq mr ms mt b">onChange</code>的<code class="fe mq mr ms mt b">prop</code>，它是由我们新的Todos组件传递给它的。<code class="fe mq mr ms mt b">onChange</code>的值是Todos组件内部的一个函数，名为<code class="fe mq mr ms mt b">addTodo.</code></p><p id="75b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mq mr ms mt b">addTodo</code>是一个实现细节。我们之前了解到，我们不应该测试实现细节。相反，我们应该通过使用组件的公共接口来验证实现细节是否满足组件的预期行为。React组件的公共接口是它的返回值——一个React元素。</p><p id="a730" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们该怎么做呢？我们只是调用作为普通对象上的<code class="fe mq mr ms mt b">prop</code>属性公开的<code class="fe mq mr ms mt b">onChange</code>函数，该对象表示我们的TodoInput子组件:</p><figure class="kz la lb lc gt jr"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5ab0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们通过练习组件返回的React元素的公共接口<code class="fe mq mr ms mt b">onChange</code>来练习<code class="fe mq mr ms mt b">addTodo</code>实现细节。然后，我们通过验证组件的外部表示反映了组件的内部状态来断言返回的React元素的正确性。</p><p id="cf05" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以在这里看到完整的<a class="ae kw" href="https://github.com/timdoherty/tdcd/blob/5-app/src/__tests__/Todos.test.js" rel="noopener ugc nofollow" target="_blank">测试套件</a>。</p><h1 id="f5cf" class="lh li iq bd lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me bi translated">结论</h1><p id="9243" class="pw-post-body-paragraph jy jz iq ka b kb mf kd ke kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv ij bi translated">肤浅的渲染招致了很多不公正的批评，我认为很大程度上是因为误解了它旨在解决什么问题。与软件工程中的大多数选择一样，这一选择归结为为工作选择正确的工具。</p><p id="3969" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">浅层渲染是一种专门针对<strong class="ka ir"> <em class="kx">单元测试React组件</em> </strong>的技术，它非常适合这个任务。理解浅层渲染的工作方式和原因——以及何时使用它——可以而且应该成为React技能集的重要组成部分。</p><p id="acd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">浅层渲染不适用于测试金字塔更高层的其他类型的测试，例如集成和端到端测试。像酵素这样的工具。mount()和React测试库针对集成测试，而Cypress和WebdriverIO等工具则针对E2E测试。</p><p id="9775" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为手头的工作使用合适的工具。编码快乐！</p></div></div>    
</body>
</html>