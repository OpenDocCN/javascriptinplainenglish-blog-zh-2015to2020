<html>
<head>
<title>Getting Request Data with Koa</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Koa获取请求数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/getting-request-data-with-koa-6edcd65f8471?source=collection_archive---------6-----------------------#2020-05-28">https://javascript.plainenglish.io/getting-request-data-with-koa-6edcd65f8471?source=collection_archive---------6-----------------------#2020-05-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c2da71c04ff5b4b4ea3ef9decdfd4a6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MuRldkon4gCFgxui"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@enginakyurt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">engin akyurt</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5391" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Koa是一个小框架，让我们可以创建在Node.js平台上运行的后端应用程序。</p><p id="ca2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何用Koa接收请求数据。</p><h1 id="acc7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取请求的内容类型标头</h1><p id="6d0b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">ctx.request.type</code>属性来获取请求的<code class="fe me mf mg mh b">Content-Type</code>头。</p><p id="e191" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码在屏幕上显示该值:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5a45" class="mq lc iq mh b gy mr ms l mt mu">const Koa = require('koa');<br/>const app = new Koa();</span><span id="4a6f" class="mq lc iq mh b gy mv ms l mt mu">app.use(async (ctx, next) =&gt; {<br/>  ctx.body = ctx.request.type;<br/>});</span><span id="c5b1" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000);</span></pre><p id="f0f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，如果我们发送带有设置为<code class="fe me mf mg mh b">application/json</code>的<code class="fe me mf mg mh b">Content-Type</code>头值的请求，那么当我们得到响应时，我们将在屏幕上显示它。</p><h1 id="bffa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取请求的字符集</h1><p id="16b2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">ctx.request.charset</code>属性具有请求字符集。</p><h1 id="c9ae" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从请求URL获取查询字符串</h1><p id="c48d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">ctx.request.query</code>属性将查询字符串解析成一个键值对。</p><p id="c34c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查询字符串的每个查询参数都被解析为一个对象的键值对。</p><p id="e3ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4d72" class="mq lc iq mh b gy mr ms l mt mu">const Koa = require('koa');<br/>const app = new Koa();</span><span id="4d39" class="mq lc iq mh b gy mv ms l mt mu">app.use(async (ctx, next) =&gt; {<br/>  ctx.body = ctx.request.query;<br/>});</span><span id="c936" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000);</span></pre><p id="2664" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们只是将<code class="fe me mf mg mh b">query</code>属性设置为<code class="fe me mf mg mh b">ctx.body</code>的值。</p><p id="d648" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们向<a class="ae kc" href="https://CraftyGrouchyCables--five-nine.repl.co?a=1&amp;b=2," rel="noopener ugc nofollow" target="_blank">https://craftygrouchyccables-five-nine.repl.co发出请求时？a=1 &amp; b=2，</a>我们得到如下响应:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3616" class="mq lc iq mh b gy mr ms l mt mu">{<br/>    "a": "1",<br/>    "b": "2"<br/>}</span></pre><p id="e257" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，查询字符串中的键值对被解析为对象的键值对，该对象被设置为<code class="fe me mf mg mh b">ctx.request.query</code>的值，而我们自己不做任何事情。</p><p id="bc4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">ctx.request.query</code>属性也是一个setter，所以我们可以把它设置成别的。但是，它不支持嵌套对象。</p><h1 id="7098" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检查请求缓存是否是新的，或者其内容是否已经更改</h1><p id="85e0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">ctx.fresh</code>属性来检查请求缓存的新鲜度。</p><p id="97ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="528e" class="mq lc iq mh b gy mr ms l mt mu">const Koa = require('koa');<br/>const app = new Koa();</span><span id="7a55" class="mq lc iq mh b gy mv ms l mt mu">app.use(async (ctx, next) =&gt; {<br/>  ctx.status = 200;<br/>  ctx.set('ETag', 'foo');<br/>  if (ctx.fresh) {<br/>    ctx.status = 304;<br/>    console.log('fresh');<br/>    return;<br/>  }<br/>  ctx.body = 'foo';<br/>});</span><span id="cb6e" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000);</span></pre><p id="6c26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们通过使用<code class="fe me mf mg mh b">ctx.fresg</code>属性来检查请求缓存是否是新的。如果它是新的，那么我们将看到记录的<code class="fe me mf mg mh b">fresh</code>字符串。</p><p id="8000" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们不会看到它被记录。如果我们向我们的应用程序发出多个请求，那么我们不会看到它被记录，因为缓存已经填充了没有改变的数据，我们总是返回相同的响应。</p><p id="3ed7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一个<code class="fe me mf mg mh b">ctx.stale</code>属性检查<code class="fe me mf mg mh b">ctx.fresh</code>的对方状态是<code class="fe me mf mg mh b">true</code>。</p><h1 id="11a5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取我们请求的协议</h1><p id="ac72" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">ctx.request.protocol</code>属性来获取请求协议。不是<code class="fe me mf mg mh b">https</code>就是<code class="fe me mf mg mh b">http</code>。</p><p id="d511" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">app.proxy</code>设置为<code class="fe me mf mg mh b">true</code>，它还可以检查协议的<code class="fe me mf mg mh b">X-Forwarded-Proto</code>请求报头。</p><h1 id="4ada" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取发出请求的设备的IP地址</h1><p id="3398" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">ctx.request.ip</code>和<code class="fe me mf mg mh b">ctx.request.ips</code>可以获取发出请求的设备的远程地址。</p><p id="e9b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">ips</code>属性为我们获取所有设备的IP地址，请求通过这些设备到达我们的应用程序。</p><p id="5d56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用<code class="fe me mf mg mh b">ip</code>属性:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1050" class="mq lc iq mh b gy mr ms l mt mu">const Koa = require('koa');<br/>const app = new Koa();</span><span id="c8f0" class="mq lc iq mh b gy mv ms l mt mu">app.use(async (ctx, next) =&gt; {<br/>  ctx.body = ctx.request.ip;<br/>});</span><span id="e811" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000);</span></pre><p id="fc7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们向我们的应用程序发出请求时，我们会获得发出请求的设备的IP地址。</p><p id="59f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">app.proxy</code>被设置为<code class="fe me mf mg mh b">true</code>，我们也可以使用<code class="fe me mf mg mh b">ips</code>属性。例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="49e8" class="mq lc iq mh b gy mr ms l mt mu">const Koa = require('koa');<br/>const app = new Koa();</span><span id="54bc" class="mq lc iq mh b gy mv ms l mt mu">app.proxy = true;</span><span id="7231" class="mq lc iq mh b gy mv ms l mt mu">app.use(async (ctx, next) =&gt; {<br/>  ctx.body = ctx.request.ips;<br/>});</span><span id="3c66" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000);</span></pre><p id="d8e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会看到一组IP地址，请求通过这些地址到达我们的Koa应用程序。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/b264d7d50b69b18137fae5d5c0e86bde.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Rf4ChUzNXBxvwn13"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@carlesrgm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Carles Rabada</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="789f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取请求子域</h1><p id="3561" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">subdomain</code>属性获得请求URL的子域。</p><p id="e754" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f9a7" class="mq lc iq mh b gy mr ms l mt mu">const Koa = require('koa');<br/>const app = new Koa();</span><span id="7d04" class="mq lc iq mh b gy mv ms l mt mu">app.use(async (ctx, next) =&gt; {<br/>  ctx.body = ctx.request.subdomains;<br/>});</span><span id="f373" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000);</span></pre><p id="1aae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，如果我们的应用程序位于<a class="ae kc" href="https://CraftyGrouchyCables--five-nine.repl.co," rel="noopener ugc nofollow" target="_blank">https://craftygrouchyccables-five-nine.repl.co，</a>中，我们将得到<code class="fe me mf mg mh b">subdomains</code>属性将返回<code class="fe me mf mg mh b">[“craftygrouchycables — five-nine”]</code>，因此我们将得到显示在屏幕上的响应值。</p><h1 id="647c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="c912" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">ctx.request</code>属性来获取所请求URL的IP和子域。</p><p id="cb7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">协议和查询字符串也可用。查询字符串被自动解析为一个对象。</p><h1 id="877f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">简明英语笔记</strong></h1><p id="f8a7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">plain English . io</strong></a>上找到所有这些——关注我们的出版物并<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>