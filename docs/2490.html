<html>
<head>
<title>Code splitting with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React进行代码拆分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/code-splitting-with-react-31d76d3f64ab?source=collection_archive---------0-----------------------#2020-06-29">https://javascript.plainenglish.io/code-splitting-with-react-31d76d3f64ab?source=collection_archive---------0-----------------------#2020-06-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3793" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">用最少的努力提高您的SPA的性能</h2></div><p id="73d6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">web应用程序的性能很大程度上取决于它生成的包的大小。如果React应用程序的加载时间太长，这篇文章可能会对你有所帮助。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div class="gh gi ky"><img src="../Images/e78e66d822e4a432819a8239950ac0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*9QruKUyn4_7ckIvjTqpBOw.gif"/></div><figcaption class="lg lh gj gh gi li lj bd b be z dk">source: Giphy</figcaption></figure><h1 id="ec4c" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">什么是捆绑？</h1><p id="059c" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">当用户试图访问您的React应用程序时，服务器会向他们的浏览器推送一个巨大的JavaScript文件。这个JavaScript文件包含了让您的web应用程序工作所需的所有代码。它包括您编写的代码，也包括您的项目使用的第三方库中的代码。这个文件被称为<strong class="ke io">包</strong>。</p><p id="eb97" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有几个工具可以为您创建包。这种工具被称为捆扎机。一些流行的打包工具有Webpack、Browserify、Rollup等。任何用<code class="fe mh mi mj mk b">create-react-app</code>构建的React应用都使用Webpack进行捆绑。</p><h1 id="4fe4" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">为什么我们需要捆绑包？</h1><p id="8c5b" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">这些包最初是为了优化下载多个文件所需的HTTP请求数量而创建的。然而，捆绑器不仅仅将代码存放在一个文件中。此外，他们还转换代码，使浏览器能够运行您的应用程序，就像它是使用原始JavaScript编写的一样。</p><p id="a12d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">束和包的方式，让我们现在谈论代码分割和懒惰加载。</p><h1 id="3623" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">代码分割和延迟加载</h1><p id="8df1" class="pw-post-body-paragraph kc kd in ke b kf mc jo kh ki md jr kk kl me kn ko kp mf kr ks kt mg kv kw kx ig bi translated">随着产品中代码的增加，包的大小也会增加。较大的包需要较长的时间来下载，从而导致较差的用户体验和沮丧的用户。</p><p id="b4de" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">代码分割是bundler的一个特性，它将你的代码分割成不同的更小的包文件。这些包文件只有在需要时才会被调用。这种在需要的时候加载项目的方法被称为延迟加载。</p><p id="fa12" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React使用动态导入实现模块的延迟加载。按照惯例，当我们用React导入一个模块时，该模块会被立即添加和绑定。使用动态导入，当遇到导入语句时，执行代码拆分。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="c18c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于用<code class="fe mh mi mj mk b">create-react-app</code>构建的应用，Webpack支持开箱即用的代码拆分。</p><p id="4bc9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然动态导入触发了拆分，但是有一种不同的方法来拆分和延迟加载模块。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="32fc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面第<code class="fe mh mi mj mk b">12</code>行的代码缓慢地导入了<code class="fe mh mi mj mk b">Home</code>组件。懒惰成分应该存在于<code class="fe mh mi mj mk b">Suspense</code>内部</p><p id="8b9f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">悬念有一个属性<code class="fe mh mi mj mk b">fallback</code>，这个属性取一个分量作为它的值。这是在加载惰性模块时呈现的。在上面的例子中，当<code class="fe mh mi mj mk b">Home</code>组件将被加载时，用户将被显示为“正在加载…”</p><p id="9ed2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">必须注意，到目前为止，只有<strong class="ke io">默认导入</strong>可以被延迟加载。如果您想延迟加载一个命名导入，您将必须创建一个模块来导入命名实体，然后将它作为缺省值重新导出。</p><p id="6958" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">多个惰性组件可以放置在单个悬念之间。下面是一个路由惰性导入的例子。</p><figure class="kz la lb lc gt ld"><div class="bz fp l di"><div class="ml mm l"/></div></figure><p id="6752" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们使用npm或yarn构建应用程序时，没有延迟加载，</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi mn"><img src="../Images/d73b14865b6d6f2a2f4eb0f669c4e2e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4OCoiRhBjVoYmqYMNo0Aw.png"/></div></div></figure><p id="a0e0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">带有惰性导入的相同项目</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="mo mp di mq bf mr"><div class="gh gi ms"><img src="../Images/cb190abf83c40348b54c4d03fa7305b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nuk1VArrigRHeF3G883uNA.png"/></div></div></figure><p id="44b3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">希望有所帮助:)</p></div></div>    
</body>
</html>