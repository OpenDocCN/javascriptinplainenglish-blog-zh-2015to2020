<html>
<head>
<title>JavaScript Mistakes — Expressions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript错误—表达式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-mistakes-expressions-9b86d7591a9e?source=collection_archive---------6-----------------------#2020-04-10">https://javascript.plainenglish.io/javascript-mistakes-expressions-9b86d7591a9e?source=collection_archive---------6-----------------------#2020-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bdc6c75fc5804579b5f8879d03afefdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*m4yPKy64hIErK2Wo"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@cotk_photo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Church of the King</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2638" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="b52f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看到一些令人困惑的表达式，这些表达式不应该用JavaScript代码编写。</p><h1 id="e222" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">令人困惑的多行表达式</h1><p id="aea6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript具有自动分号插入(ASI)特性，可以自动添加分号。</p><p id="675a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以省略分号，仍然有一个有效的JavaScript代码。然而，这并不意味着它们对用户来说容易阅读。</p><p id="bf5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，换行符总是以分号结束语句，除非:</p><ul class=""><li id="6321" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">该语句有未闭合的括号、数组文字、对象文字或以其他方式结束，这不是结束语句的有效方式</li><li id="fef0" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">线条是<code class="fe ms mt mu mv b">--</code>或<code class="fe ms mt mu mv b">++</code></li><li id="b0e3" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">是<code class="fe ms mt mu mv b">for</code>、<code class="fe ms mt mu mv b">while</code>、<code class="fe ms mt mu mv b">do</code>、<code class="fe ms mt mu mv b">if</code>或者<code class="fe ms mt mu mv b">else</code>没有<code class="fe ms mt mu mv b">(</code></li><li id="2039" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">接下来的几行以只能在两个操作数之间找到的算术或其他二元运算符开始</li></ul><p id="92a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有些情况下，多行表达式中的新行看起来像是在结束一个语句，但实际上不是。例如，以下不是多行的，但实际上是一个表达式:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="e548" class="ne lc iq mv b gy nf ng l nh ni">let b = 3<br/>let a = b<br/>(1 || 2).c();</span></pre><p id="0175" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将得到“b不是函数”消息，因为最后两行被解释为:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="aa72" class="ne lc iq mv b gy nf ng l nh ni">let a = b(1 || 2).c();</span></pre><p id="34fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个例子如下:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c446" class="ne lc iq mv b gy nf ng l nh ni">let addNumber = ()=&gt;{}<br/>let foo = 'bar'<br/>[1, 2, 3].forEach(addNumber);</span></pre><p id="818a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码会给我们带来语法错误。因此，我们应该在每个语句的末尾加上分号，这样开发人员或JavaScript解释人员就不会混淆或出错。</p><h1 id="3f9e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">return、throw、continue和break语句后无法访问的代码</h1><p id="4aad" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mv b">return</code>、<code class="fe ms mt mu mv b">throw</code>、<code class="fe ms mt mu mv b">break</code>和<code class="fe ms mt mu mv b">continue</code>之后的不可达代码是无用的，因为这些语句无条件地退出代码块。</p><p id="403c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该有那些永远不会在这些行之后运行的代码。</p><p id="7633" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，以下函数具有不可访问的代码:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d0e6" class="ne lc iq mv b gy nf ng l nh ni">const fn = () =&gt; {<br/>  let x = 1;<br/>  return x;<br/>  x = 2;<br/>}</span></pre><p id="bf4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mv b">x = 2</code>不可达，因为它在<code class="fe ms mt mu mv b">return</code>语句之后。</p><p id="b720" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不应该编写的其他代码包括:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d96c" class="ne lc iq mv b gy nf ng l nh ni">while(true) {<br/>    break;<br/>    console.log("done");<br/>}</span><span id="813d" class="ne lc iq mv b gy nj ng l nh ni">const fn = () =&gt; {<br/>  throw new Error("error");<br/>  console.log("done");<br/>}</span></pre><p id="a541" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该写:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="f56a" class="ne lc iq mv b gy nf ng l nh ni">const fn = () =&gt; {<br/>  let x = 1;<br/>  return x;<br/>}</span></pre><h1 id="8e4b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">finally块中的控制流语句</h1><p id="3c93" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在JavaScript中，当添加到<code class="fe ms mt mu mv b">try...catch</code>块之后时，<code class="fe ms mt mu mv b">finally</code>块总是在<code class="fe ms mt mu mv b">try...catch</code>块结束之前运行。因此，每当<code class="fe ms mt mu mv b">finally</code>中有<code class="fe ms mt mu mv b">return</code>、<code class="fe ms mt mu mv b">throw</code>、<code class="fe ms mt mu mv b">break</code>、<code class="fe ms mt mu mv b">continue</code>时，<code class="fe ms mt mu mv b">try...catch</code>中的就会被覆盖。</p><p id="5288" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="7269" class="ne lc iq mv b gy nf ng l nh ni">let x = (() =&gt; {<br/>  try {<br/>    return 'foo';<br/>  } catch (err) {<br/>    return 'bar';<br/>  } finally {<br/>    return 'baz';<br/>  }<br/>})();</span></pre><p id="eefc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mv b">x</code>将是<code class="fe ms mt mu mv b">'baz'</code>，因为<code class="fe ms mt mu mv b">finally</code>块的<code class="fe ms mt mu mv b">return</code>语句在<code class="fe ms mt mu mv b">try...catch</code>块的语句之前运行。</p><p id="b3e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该在finally块中添加流控制语句，因为这会使<code class="fe ms mt mu mv b">try...catch</code>中的语句变得无用。我们应该这样写:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="c8be" class="ne lc iq mv b gy nf ng l nh ni">let x = (() =&gt; {<br/>  try {<br/>    return 'foo';<br/>  } catch (err) {<br/>    return 'bar';<br/>  } finally {<br/>    console.log('baz');<br/>  }<br/>})();</span></pre><p id="f642" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以便<code class="fe ms mt mu mv b">try...catch</code>中的<code class="fe ms mt mu mv b">return</code>语句有机会运行。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/f944924e628ab47f4f3c471cd06ec3d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dXiHEYLVFL8lzxQO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@gabrielsilverio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gabriel Silvério</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="1938" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对关系运算符的左操作数求反</h1><p id="9422" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">否定左操作数并不总是否定JavaScript中的整个运算表达式。</p><p id="0003" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="d394" class="ne lc iq mv b gy nf ng l nh ni">!prop in object</span></pre><p id="0c5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仅否定<code class="fe ms mt mu mv b">prop</code>和:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="12d3" class="ne lc iq mv b gy nf ng l nh ni">!foo instanceof C</span></pre><p id="89d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">仅否定<code class="fe ms mt mu mv b">foo</code>。</p><p id="bdd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe ms mt mu mv b">!prop in object</code>实际上是<code class="fe ms mt mu mv b">true in object</code>或<code class="fe ms mt mu mv b">false in object</code>，取决于<code class="fe ms mt mu mv b">prop</code>的真度。</p><p id="f20b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，<code class="fe ms mt mu mv b">!foo instanceof C</code>实际上是，<code class="fe ms mt mu mv b">true instanceof C</code>还是<code class="fe ms mt mu mv b">false instanceof C</code>取决于<code class="fe ms mt mu mv b">foo</code>的真实度。</p><p id="21bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该把整个表达式用括号括起来，这样它实际上就否定了整个表达式的返回值，如下所示。因此:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="7ee9" class="ne lc iq mv b gy nf ng l nh ni">!(<!-- -->prop in object)</span></pre><p id="4729" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且:</p><pre class="mw mx my mz gt na mv nb nc aw nd bi"><span id="0558" class="ne lc iq mv b gy nf ng l nh ni">!(<!-- -->foo instanceof C)</span></pre><p id="bc50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是我们想要的。</p><p id="98d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就不会对这些表达式的用途产生混淆。</p><h1 id="41da" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="a9a9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">用JavaScript创建令人困惑的表达式有很多方法。一种方法是省略行尾的分号。省略分号很容易产生歧义。</p><p id="f6c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以通过编写不可及的表达式来创建无用的代码。它们毫无用处，所以不应该被写出来。这包括在<code class="fe ms mt mu mv b">return</code>、<code class="fe ms mt mu mv b">break</code>、<code class="fe ms mt mu mv b">throw</code>和<code class="fe ms mt mu mv b">continue</code>之后编写代码。此外，在<code class="fe ms mt mu mv b">finally</code>中编写这些语句也会使<code class="fe ms mt mu mv b">try...catch</code>中的语句变得无用。</p><p id="9795" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，对<code class="fe ms mt mu mv b">in</code>和<code class="fe ms mt mu mv b">instanceof</code>操作符的左操作数求反只是对左操作数求反，而不是对整个表达式求反。</p><h2 id="8769" class="ne lc iq bd ld nl nm dn lh nn no dp ll ko np nq lp ks nr ns lt kw nt nu lx nv bi translated"><strong class="ak">用简单英语写的JavaScript的一个注释:</strong></h2><p id="ce08" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"> <strong class="kf ir"> AI in Plain English </strong> </a>，<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p></div></div>    
</body>
</html>