<html>
<head>
<title>Referential Transparency in JavaScript and TypeScript: Or why to prefer const over let</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript和TypeScript中的参考透明度:或者为什么喜欢常量而不是字母</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/referential-transparency-in-javascript-and-typescript-or-why-to-prefer-const-over-let-9fe241b0a7f3?source=collection_archive---------6-----------------------#2020-01-04">https://javascript.plainenglish.io/referential-transparency-in-javascript-and-typescript-or-why-to-prefer-const-over-let-9fe241b0a7f3?source=collection_archive---------6-----------------------#2020-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/289cce903df77530ee176691ef9b59bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-237AhY20BfwxJp7_kzXLA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">our code through the eyes of the compiler</figcaption></figure><blockquote class="jz ka kb"><p id="dee2" class="kc kd ke kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ig bi translated">当我回顾我的编程经验时，我明白在我职业生涯的开始，读别人的代码比写代码困难得多。尽管现在我认为我擅长这两项任务，但我正在阅读的代码的风格有所不同。</p></blockquote></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><h1 id="2663" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">什么是参照透明度？</h1><p id="81dd" class="pw-post-body-paragraph kc kd in kf b kg mg ki kj kk mh km kn mi mj kq kr mk ml ku kv mm mn ky kz la ig bi translated">如果我们能在不改变程序行为的情况下用相应的值替换它，一个被称为<a class="ae mo" href="https://en.wikipedia.org/wiki/Referential_transparency" rel="noopener ugc nofollow" target="_blank">的表达式是可引用透明的</a>。下面的两个例子将帮助你理解最后一句话:</p><h2 id="f299" class="mp lj in bd lk mq mr dn lo ms mt dp ls mi mu mv lw mk mw mx ma mm my mz me na bi translated">1.不透明的表达:</h2><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="c65d" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">let </strong>x = 10;</span><span id="8225" class="mp lj in ng b gy no nl l nm nn"><em class="ke">// ... imagine 100 lines of code between that 2 lines</em></span><span id="5ef0" class="mp lj in ng b gy no nl l nm nn"><strong class="ng io">const </strong>z = x + 5; <em class="ke">// what is the value of z?</em></span></pre><p id="9596" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mi kp kq kr mk kt ku kv mm kx ky kz la ig bi translated">当我们定义<strong class="kf io"> z </strong>时，不能保证<strong class="kf io"> x </strong>仍然有值<strong class="kf io"> 10 </strong>(因为<strong class="kf io">让</strong>允许重新分配)。所以现在我们需要努力搜索100行代码来回答这个问题"<em class="ke">z的值是多少？</em>”。</p><h2 id="2653" class="mp lj in bd lk mq mr dn lo ms mt dp ls mi mu mv lw mk mw mx ma mm my mz me na bi translated">2.指代透明表达:</h2><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="d9ce" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">const</strong> x = 10;</span><span id="2fb8" class="mp lj in ng b gy no nl l nm nn"><em class="ke">// ... imagine 100 lines of code between that 2 lines</em></span><span id="64d8" class="mp lj in ng b gy no nl l nm nn"><strong class="ng io">const </strong>z = x + 5; <em class="ke">// what is the value of z?</em></span></pre><p id="4641" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mi kp kq kr mk kt ku kv mm kx ky kz la ig bi translated">在这里您只需要用<strong class="kf io"> x </strong>的赋值来检查一行，就可以理解<strong class="kf io"> z </strong>的值了，因为<strong class="kf io"> const </strong>关键字保证了<strong class="kf io"> x </strong>在运行时的值永远是<strong class="kf io"> 10 </strong>。所以表达式可以用它的相应值代替，而不改变程序的行为:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="ad25" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">const </strong>z = 15;</span></pre><p id="c98c" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mi kp kq kr mk kt ku kv mm kx ky kz la ig bi translated">注意:参考透明度的主题要宽泛得多，可以触及不可变数据结构和纯函数的概念。我特意想在这里只关注<strong class="kf io"> const vs let </strong>部分。</p></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><h1 id="5f5d" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">参照透明表达的好处是什么？</h1><p id="5d1d" class="pw-post-body-paragraph kc kd in kf b kg mg ki kj kk mh km kn mi mj kq kr mk ml ku kv mm mn ky kz la ig bi translated">我想您可以从前面的例子中猜到，主要的好处是代码更加清晰。人们不需要从赋值开始就怀疑变量值的任何变化，就像他们通常对<strong class="kf io"> let </strong>所做的那样。这在使用部分git diff进行代码审查时尤其有用。</p><p id="9ae0" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mi kp kq kr mk kt ku kv mm kx ky kz la ig bi translated">此外，<strong class="kf io"> const </strong>提供了编译器级优化的可能性。</p><p id="cc3b" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mi kp kq kr mk kt ku kv mm kx ky kz la ig bi translated">这就是为什么在你没有意图变异你的变量之前，要使用<strong class="kf io"> const。</strong>如果你习惯于编写你认为变量不可重分配的代码，你会发现你的代码库中只有不到1%的<strong class="kf io">让</strong>变量的真实情况。不要害怕在你的项目中启用<a class="ae mo" href="https://eslint.org/docs/rules/prefer-const" rel="noopener ugc nofollow" target="_blank">“prefere-const”</a>lint规则。</p></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><h1 id="6c1c" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">人们误用let关键字的一些典型案例。</h1><h2 id="e317" class="mp lj in bd lk mq mr dn lo ms mt dp ls mi mu mv lw mk mw mx ma mm my mz me na bi translated">1.条件变量赋值</h2><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="7ffb" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">let </strong>x;</span><span id="c09f" class="mp lj in ng b gy no nl l nm nn"><strong class="ng io">if </strong>(isTrue) {<br/>   x = 10;<br/>} <strong class="ng io">else </strong>{<br/>   x = 100;<br/>}</span></pre><p id="2421" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mi kp kq kr mk kt ku kv mm kx ky kz la ig bi translated">你可以很容易地在这里使用一个三元运算符来声明x为<strong class="kf io">常量</strong></p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="901d" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">const </strong>x = isTrue <strong class="ng io">?</strong> 10 <strong class="ng io">:</strong> 100;</span></pre><h2 id="e78b" class="mp lj in bd lk mq mr dn lo ms mt dp ls mi mu mv lw mk mw mx ma mm my mz me na bi translated">2.变量的无意义重新赋值</h2><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="636d" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">let </strong>str = 'cats,love,fish';<br/>str = str.split(',').join(' ');</span></pre><p id="2d24" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mi kp kq kr mk kt ku kv mm kx ky kz la ig bi translated">不要偷懒，用一个更好的名字创建一个新的<strong class="kf io">常量</strong>变量:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="2f29" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">const </strong>str = 'cats,love,fish';<br/><strong class="ng io">const </strong>transformedStr = str.split(',').join(' ');</span></pre><h2 id="a217" class="mp lj in bd lk mq mr dn lo ms mt dp ls mi mu mv lw mk mw mx ma mm my mz me na bi translated">3.对内置Array.prototype函数了解不多</h2><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="5ee8" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">const</strong> result = [];</span><span id="e03f" class="mp lj in ng b gy no nl l nm nn"><strong class="ng io">for</strong> (<strong class="ng io">let</strong> i=0; i &lt; arr.length; i++) {<br/>    <strong class="ng io">if</strong> (arr[i] % 2) {<br/>        result.push(arr[i]);<br/>    }<br/>}</span></pre><p id="ccde" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mi kp kq kr mk kt ku kv mm kx ky kz la ig bi translated">这里不需要显式的循环计数器:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="816e" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">const</strong> result = arr.filter(element =&gt; element % 2);</span></pre><h2 id="0c49" class="mp lj in bd lk mq mr dn lo ms mt dp ls mi mu mv lw mk mw mx ma mm my mz me na bi translated">4.缺乏抽象思维[一个先进的例子]</h2><p id="5e6b" class="pw-post-body-paragraph kc kd in kf b kg mg ki kj kk mh km kn mi mj kq kr mk ml ku kv mm mn ky kz la ig bi translated">然而，在某些情况下，您可能需要使用let，但是您可以将它隐藏在一个抽象的实用函数中，或者放在一些像lodash这样的库中。这里有一个简单的例子:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="336e" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">let</strong> isLikeSent = <strong class="ng io">false</strong>;</span><span id="d869" class="mp lj in ng b gy no nl l nm nn"><em class="ke">// that function likes an article only once</em><br/><strong class="ng io">function </strong>sendUsersLike() {<br/>   <strong class="ng io">if </strong>(!isLikeSent) {<br/>      isLikeSent = true;<br/>      likeAnArticle('anID');<br/>   }<br/>}</span></pre><p id="0039" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mi kp kq kr mk kt ku kv mm kx ky kz la ig bi translated">让我们用<a class="ae mo" href="https://lodash.com/docs" rel="noopener ugc nofollow" target="_blank"> lodash once </a>函数重写它。它能满足我们的需求:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="7b92" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">import </strong>once <strong class="ng io">from </strong>'lodash/once';</span><span id="2166" class="mp lj in ng b gy no nl l nm nn"><em class="ke">// that function likes an article only once</em><br/><strong class="ng io">const </strong>sendUsersLike = once(() =&gt; likeAnArticle('anID'));</span></pre><p id="1032" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mi kp kq kr mk kt ku kv mm kx ky kz la ig bi translated">如果您想知道如何实现自己的类似于lodash的函数，请查看下一段代码。最后，一个有效的案例为<strong class="kf io"> let </strong>声明:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="7098" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">const</strong> once = (func) =&gt; {<br/>   <strong class="ng io">let </strong>isCalled = <strong class="ng io">false</strong>;</span><span id="05a7" class="mp lj in ng b gy no nl l nm nn"><strong class="ng io">return </strong>(...args) =&gt; {<br/>      <strong class="ng io">if</strong> (!isCalled) {<br/>         isCalled = <strong class="ng io">true</strong>;<br/>         func(...args);<br/>      }<br/>   }<br/>}</span></pre></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><h1 id="f07c" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">额外收获:说几句关于打字稿的话</h1><p id="ab76" class="pw-post-body-paragraph kc kd in kf b kg mg ki kj kk mh km kn mi mj kq kr mk ml ku kv mm mn ky kz la ig bi translated">当TypeScript编译器进行类型推断时，如果您的代码具有更多引用透明的表达式，它往往会更加精确和有效。查看下一个示例:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="9a95" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">const </strong>x = 'a'; // here inferred type of x is a constant <strong class="ng io">'a' </strong>which is subtype of <strong class="ng io">string</strong>;</span><span id="37d3" class="mp lj in ng b gy no nl l nm nn"><strong class="ng io">function </strong>foo(param: <strong class="ng io">'a' | 'b'</strong>) {}<br/><strong class="ng io">function </strong>bar(param: <strong class="ng io">string</strong>) {}</span><span id="933d" class="mp lj in ng b gy no nl l nm nn">foo(x); // no errors <strong class="ng io">'a'</strong> is one of union type values<br/>bar(x); <em class="ke">// no errors, compiler will make </em><a class="ae mo" href="https://mariusschulz.com/blog/literal-type-widening-in-typescript" rel="noopener ugc nofollow" target="_blank"><em class="ke">type widening</em></a></span></pre><p id="c21f" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mi kp kq kr mk kt ku kv mm kx ky kz la ig bi translated">现在让我们看看如果我们将<strong class="kf io"> x </strong>声明为<strong class="kf io"> let </strong>会发生什么</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="7d4b" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">let </strong>x = 'a'; <em class="ke">// here inferred type of x is a</em> <strong class="ng io">string</strong>;</span><span id="37bb" class="mp lj in ng b gy no nl l nm nn"><strong class="ng io">function </strong>foo(param: <strong class="ng io">'a' | 'b'</strong>) {}<br/><strong class="ng io">function </strong>bar(param: <strong class="ng io">string</strong>) {}</span><span id="a4b9" class="mp lj in ng b gy no nl l nm nn">foo(x); <em class="ke">//</em> <strong class="ng io">error!</strong> <em class="ke">type string is wider than the union</em> <strong class="ng io">'a' | 'b'</strong><br/>bar(x); <em class="ke">// no errors, because type matches.</em></span></pre><p id="c43b" class="pw-post-body-paragraph kc kd in kf b kg kh ki kj kk kl km kn mi kp kq kr mk kt ku kv mm kx ky kz la ig bi translated">但是如果在没有赋值的情况下声明了<strong class="kf io"> let </strong>，情况会变得更糟:</p><pre class="nb nc nd ne gt nf ng nh ni aw nj bi"><span id="8c72" class="mp lj in ng b gy nk nl l nm nn"><strong class="ng io">let</strong> x; <em class="ke">// we forgot to declare type, so now x has</em> <strong class="ng io">any</strong> <em class="ke">type!</em></span><span id="0387" class="mp lj in ng b gy no nl l nm nn">x = 10; // it doesn't matter what we assign it will remain <strong class="ng io">any</strong></span><span id="aedc" class="mp lj in ng b gy no nl l nm nn">// so now your x starts spreading <a class="ae mo" href="https://medium.com/@kreznykov/there-is-no-point-to-use-typescript-in-your-project-if-you-dont-care-about-types-68131deeb43a" rel="noopener"><strong class="ng io">any </strong>type epidemy</a>..</span></pre></div><div class="ab cl lb lc hr ld" role="separator"><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg lh"/><span class="le bw bk lf lg"/></div><div class="ig ih ii ij ik"><h1 id="1fd0" class="li lj in bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="0c45" class="pw-post-body-paragraph kc kd in kf b kg mg ki kj kk mh km kn mi mj kq kr mk ml ku kv mm mn ky kz la ig bi translated">所以在代码中避免使用<strong class="kf io"> let </strong>可以确保你不会无意中重新分配变量。它帮助人们更快地理解你的代码。它可能会在未来给你的应用程序带来性能优势。TypeScript提供了更好的类型推断。它帮助您编写更接近函数式编程风格的代码。这里唯一的缺点是，它需要一些努力来改变你的思维模式。但是相信我，这是值得的。</p></div></div>    
</body>
</html>