<html>
<head>
<title>JavaScript Best Practices — Shadowing Variables and Spacing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—隐藏变量和间距</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-shadowing-variables-and-spacing-950c0ee2259f?source=collection_archive---------8-----------------------#2020-07-12">https://javascript.plainenglish.io/javascript-best-practices-shadowing-variables-and-spacing-950c0ee2259f?source=collection_archive---------8-----------------------#2020-07-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a628741126ac970d393862088be3acb9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2bs0FV-KOkQRe7ln"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ybs9641?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Boris YUE</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="29c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="bf2a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">外部作用域中声明的隐藏变量没有变量声明</h1><p id="561f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该有在外部作用域声明的隐藏变量的变量声明。</p><p id="91e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该这样写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5f8b" class="mn lc iq mj b gy mo mp l mq mr">var a = 3;</span><span id="fc57" class="mn lc iq mj b gy ms mp l mq mr">function b() {<br/>  var a = 10;<br/>}</span></pre><p id="9ca6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0510" class="mn lc iq mj b gy mo mp l mq mr">function b() {<br/>  let a = 10;<br/>}</span></pre><p id="10af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不想声明它们两次，因为函数外的<code class="fe mt mu mv mj b">a</code>在全局范围内，这意味着它们会引起混淆。</p><h1 id="ff06" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有受限名称的阴影</h1><p id="87b6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该用受限的名字给变量赋值。</p><p id="8732" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该写这样的语句:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9627" class="mn lc iq mj b gy mo mp l mq mr">const undefined = "foo";</span></pre><p id="99af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="835c" class="mn lc iq mj b gy mo mp l mq mr">const foo = "foo";</span></pre><h1 id="677c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">函数标识符和它们的应用程序之间没有空格</h1><p id="b65d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">函数标识符和它们的调用之间不应该有空格。</p><p id="c24e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该有这样的事情:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e15f" class="mn lc iq mj b gy mo mp l mq mr">fn ()<br/><br/>fn<br/>()</span></pre><p id="244a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5413" class="mn lc iq mj b gy mo mp l mq mr">fn()</span></pre><h1 id="25da" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有稀疏数组</h1><p id="2c62" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">稀疏数组有空槽。</p><p id="b5a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些可能是错误，所以我们可能想要避免它们。</p><p id="8a07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0e37" class="mn lc iq mj b gy mo mp l mq mr">const items = [,,];</span></pre><p id="94fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="577a" class="mn lc iq mj b gy mo mp l mq mr">const colors = [ "red", "green"];</span></pre><h1 id="7779" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">节点同步方法</h1><p id="75b4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们正在编写一个应用程序，我们绝对不应该使用同步方法。</p><p id="46ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于Node是单线程的，所以它们用一个操作就能完成整个应用程序。</p><p id="ad6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们仍然适合写剧本。</p><p id="767e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fab5" class="mn lc iq mj b gy mo mp l mq mr">function foo(path) {<br/>  const contents = fs.readFileSync(path).toString();<br/>}</span></pre><p id="2e15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写作；</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8f21" class="mn lc iq mj b gy mo mp l mq mr">async(function() {<br/>  // ...<br/>});</span></pre><p id="bff1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在应用程序中。</p><h1 id="b7b3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有标签</h1><p id="f565" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">制表符的间距不如空格，因为它们在文本编辑器和平台之间可能不同。</p><p id="ee79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们写空格而不是制表符。</p><p id="e02c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用空格自动替换制表符。</p><h1 id="aac9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">常规字符串中没有模板文字占位符语法</h1><p id="50cd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">常规字符串中的模板文字占位符语法是无用的。</p><p id="2977" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该只在模板字符串中使用它们。</p><p id="440e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f5a7" class="mn lc iq mj b gy mo mp l mq mr">const greet = "Hello ${name}!";</span></pre><p id="c7e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b25e" class="mn lc iq mj b gy mo mp l mq mr">const greet = `Hello ${name}!`;</span></pre><h1 id="f0b8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">三元运算符</h1><p id="9de4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">三元运算符对于有条件地返回行中的数据很有用。</p><p id="ef06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8be6" class="mn lc iq mj b gy mo mp l mq mr">const foo = isBar ? baz : bar;</span></pre><p id="558c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它很短，也不太难读。</p><h1 id="0761" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在构造函数中调用<code class="fe mt mu mv mj b">super()</code>之前没有使用<code class="fe mt mu mv mj b">this</code> / <code class="fe mt mu mv mj b">super</code></h1><p id="0bd1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在子类构造函数中分配<code class="fe mt mu mv mj b">this</code>属性之前调用<code class="fe mt mu mv mj b">super</code>。</p><p id="6e67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bc0e" class="mn lc iq mj b gy mo mp l mq mr">class A extends B {<br/>  constructor() {<br/>    this.a = 0;<br/>    super();<br/>  }<br/>}</span></pre><p id="f818" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="af9a" class="mn lc iq mj b gy mo mp l mq mr">class A extends B {<br/>  constructor() {<br/>    super();<br/>    this.a = 0;<br/>  }<br/>}</span></pre><p id="6551" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在第一个例子中得到一个错误。</p><h1 id="c4b0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">限制可以作为异常抛出的内容</h1><p id="b486" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当使用<code class="fe mt mu mv mj b">throw</code>时，我们显示throw <code class="fe mt mu mv mj b">Error</code>实例，</p><p id="eace" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7ddf" class="mn lc iq mj b gy mo mp l mq mr">throw "error";</span></pre><p id="48b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1e39" class="mn lc iq mj b gy mo mp l mq mr">throw new Error("error");</span></pre><p id="601d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">Error</code>对象有更多有用的东西，比如堆栈跟踪和消息，这是其他对象或值所没有的。</p><h1 id="f976" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">行尾的尾随空格</h1><p id="00db" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在行尾有尾随空白。</p><p id="b0bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有尾随空格，我们应该删除它们。</p><h1 id="e4f1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有未声明的变量</h1><p id="d1ea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在代码中使用未声明的变量。</p><p id="077c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果没有严格模式，它们将被视为全局变量。</p><p id="9251" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果严格模式打开，它将被视为一个错误。</p><p id="786c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以w不应该写这样的东西:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f190" class="mn lc iq mj b gy mo mp l mq mr">const bar = a + 1;</span></pre><p id="c4a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe mt mu mv mj b">a</code>没有声明。</p><p id="a829" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="be46" class="mn lc iq mj b gy mo mp l mq mr">const a = 2;<br/>const bar = a + 1;</span></pre><h1 id="ff72" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">否初始化为未定义</h1><p id="c246" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">没有赋值声明的变量默认初始化为<code class="fe mt mu mv mj b">undefined</code>，所以我们不需要显式设置。</p><p id="bf56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不需要写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bcaf" class="mn lc iq mj b gy mo mp l mq mr">let foo = undefined;</span></pre><p id="7e46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e433" class="mn lc iq mj b gy mo mp l mq mr">let foo;</span></pre><h1 id="0748" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有使用<code class="fe mt mu mv mj b">undefined</code>变量</h1><p id="d79f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该给<code class="fe mt mu mv mj b">undefined</code>设置一个值。</p><p id="e470" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在严格模式下它会抛出一个错误。</p><p id="dc24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该编写这样的代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="500c" class="mn lc iq mj b gy mo mp l mq mr">const undefined = "hi";</span></pre><p id="2ea3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">给<code class="fe mt mu mv mj b">undefined</code>赋值是没有意义的。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/952d78250f441a148ce6b3b0ba38ee55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yTEEsGCrLL7hu0Nr"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@braintax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Oli Woodman</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4602" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3a73" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该给受限标识符赋值。</p><p id="f4c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们应该确保函数调用和代码以传统方式格式化，以避免混淆和其他问题。</p><p id="e999" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">节点同步方法适用于脚本，但不适用于应用程序。</p><h2 id="13cf" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="3572" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>