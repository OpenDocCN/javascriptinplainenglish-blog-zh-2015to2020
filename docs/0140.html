<html>
<head>
<title>How does referencing work in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的引用是如何工作的？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-referencing-in-javascript-9ecb6ba29e22?source=collection_archive---------0-----------------------#2019-05-05">https://javascript.plainenglish.io/object-referencing-in-javascript-9ecb6ba29e22?source=collection_archive---------0-----------------------#2019-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5e47" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">对JavaScript中引用的工作方式有点困惑？你不是唯一一个。把我也包括在名单里。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bca29349f189fb86f13d8a16a5033c15.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JAzC4v4CIeLD3ZhDIq7tpg.jpeg"/></div></div></figure><p id="5250" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们快点开始吧。我们将变量arr声明为一个数组，并使用第二个arr2来引用变量arr。然后我们将使用console.log来查找arr2的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ln"><img src="../Images/d4ca2c8ed79fe1ee62ab0b5a55eb73e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ASUu5H84_FMnW0TIj1hrtw.png"/></div></div></figure><p id="ef43" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，console.log(arr2)的结果会是什么呢？猜不到奖。是[1，2，3，4，5]。现在让我们做点新的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lo"><img src="../Images/8d845569539b92b2cc7338e5877075d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CcSXfh2MR8sp4_rtdrJgcQ.png"/></div></div></figure><p id="0083" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么，arr2的输出是什么呢？这很简单，不是吗？是啊，当然。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lp"><img src="../Images/9443fdd0e373900d9dbfd6791e88115d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HM_efRtb5PG6PS41dhmfew.png"/></div></div></figure><p id="563f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哇哦。arr2的输出是预期的，但不是arr的输出。这让我们所有人都很惊讶，可能对那些稍微有点参考价值的人来说不是这样。那么，这里到底发生了什么？</p><p id="7e8f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们声明变量arr并初始化它时。变量arr指向内存中的一个位置。当我们调用arr时，它会去那个内存位置并获取值。现在，当我们声明变量arr2并将其初始化为变量arr时。arr的存储位置传递给arr2，而不是值。因此，无论何时对这两个变量中的任何一个进行更改，更改都是在内存位置进行的，这就是为什么对这两个变量都有反映。</p><blockquote class="lq lr ls"><p id="592b" class="kr ks lt kt b ku kv jr kw kx ky ju kz lu lb lc ld lv lf lg lh lw lj lk ll lm ij bi translated">我们可以有n个变量引用变量arr，每次n个变量中的任何一个发生变化时，都会在内存位置上发生变化，并反映到每个变量输出中。</p></blockquote><p id="ba9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在让我们注意一下引用中的一个复杂的概念。我们会看到对象中的引用。现在，我们将从变量obj1和obj2开始。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lx"><img src="../Images/48625ccff719daf9e39d90945fae5a6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5IkzLTGGcxVQ3p_RdbFB3g.png"/></div></div></figure><p id="aee1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我想我们现在可以理解上面的代码片段是如何工作的了。不是吗？我们初始化一个变量obj1，它指向一个内存位置，并在那里存储数据。现在，我们初始化另一个变量obj2，并将obj1的地址引用到obj2。现在，当我们对obj2进行任何更改时，它也会反映在obj1上。但是，我们现在重新初始化obj2。现在，obj2将指向新的内存位置，因此当obj2更改时，它不会在obj2重新初始化后立即反映到obj1上。</p><p id="5bc7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在你会说这很容易，我们都能猜到。好吧！现在这里是另一个代码片段，猜猜变量obj1和obj2的输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ly"><img src="../Images/4e6d60c225c5978f57aa39547563d984.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WtZcV6sNFxIpqse7MX0bpw.png"/></div></div></figure><p id="b59b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你们都猜到了吗？好吧，让我们看看你是否答对了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lz"><img src="../Images/eb4056756cb68f5c1e9b9d44f6d43572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EuaAff2UubN2rJuNkt4LOA.png"/></div></div></figure><blockquote class="lq lr ls"><p id="626d" class="kr ks lt kt b ku kv jr kw kx ky ju kz lu lb lc ld lv lf lg lh lw lj lk ll lm ij bi translated">不，你应该猜对了。不是吗？即使我们重新初始化了obj2 = data，obj2上的变化也反映在obj1上。到底是怎么发生的？当我们放置obj2.next = data时，obj2.next现在指向数据的内存位置，obj1.next也是如此。现在当我们做obj2 = data时，obj2指向数据的内存位置。</p></blockquote><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ma"><img src="../Images/aa53256ea0e2db523b3894c5b873945f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W-ofqnlPFGATBsL_UOMbkQ.png"/></div></div></figure><p id="4643" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，我尽了最大的努力，试图让这个概念的理解。希望你喜欢。</p><blockquote class="lq lr ls"><p id="3413" class="kr ks lt kt b ku kv jr kw kx ky ju kz lu lb lc ld lv lf lg lh lw lj lk ll lm ij bi translated">当我们使用链表时，这个概念会派上用场。在末尾插入一个节点的复杂度将从O(n)急剧地转移到O(1)。也许，我会在下一篇文章中尝试使用这个概念，这篇文章可能是关于链表的。</p></blockquote><p id="3333" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想了解JavaScript中另一个重要的提升概念，这里有链接【http://tiny.cc/zqo75y<a class="ae mb" href="http://tiny.cc/zqo75y" rel="noopener ugc nofollow" target="_blank"/></p><div class="mc md gp gr me mf"><a href="https://medium.com/@anupam1996/hoisting-in-javascript-946708c532af" rel="noopener follow" target="_blank"><div class="mg ab fo"><div class="mh ab mi cl cj mj"><h2 class="bd ir gy z fp mk fr fs ml fu fw ip bi translated">在JavaScript中提升。</h2><div class="mm l"><h3 class="bd b gy z fp mk fr fs ml fu fw dk translated">提升是JavaScript的一种未知或被忽略的行为。</h3></div><div class="mn l"><p class="bd b dl z fp mk fr fs ml fu fw dk translated">medium.com</p></div></div><div class="mo l"><div class="mp l mq mr ms mo mt kp mf"/></div></div></a></div></div></div>    
</body>
</html>