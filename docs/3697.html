<html>
<head>
<title>Better JavaScript — Methods and this</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的JavaScript——方法和这个</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/better-javascript-methods-and-this-51bf5892ad01?source=collection_archive---------12-----------------------#2020-10-18">https://javascript.plainenglish.io/better-javascript-methods-and-this-51bf5892ad01?source=collection_archive---------12-----------------------#2020-10-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/774f9e9daf81e0a3d2b9ef708a4c749c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vDDn2O9O0KftkxFg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ack15?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">ACK15</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7bf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究改进JavaScript代码的方法。</p><h1 id="ca2c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在原型上存储方法</h1><p id="40a0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该将方法存储在构造函数的原型中。</p><p id="8119" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们只存储一个方法的副本，每个实例都从原型继承。</p><p id="ecf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6c21" class="mn lc iq mj b gy mo mp l mq mr">function Person(name) {<br/>  this.name = name;</span><span id="af54" class="mn lc iq mj b gy ms mp l mq mr">  this.toString = function() {<br/>    return `Person: ${this.name}`;<br/>  };<br/>}</span></pre><p id="6428" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fb98" class="mn lc iq mj b gy mo mp l mq mr">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="86dd" class="mn lc iq mj b gy ms mp l mq mr">Person.prototype.toString = function() {<br/>  return `Person: ${this.name}`;<br/>};</span></pre><p id="46d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从表面上看，它们是一样的。</p><p id="ba4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们用<code class="fe mt mu mv mj b">new</code>操作符创建一个新的<code class="fe mt mu mv mj b">Person</code>实例，无论如何我们都会得到<code class="fe mt mu mv mj b">toString</code>方法。</p><p id="cef4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但在表面之下，第二种方式更有效率。</p><h1 id="db92" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用闭包来存储私有数据</h1><p id="3879" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript可以在函数中包含函数。</p><p id="eb21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数内部的数据对外部是不可访问的。</p><p id="7137" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以把私有数据放在函数里面。</p><p id="d4ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4903" class="mn lc iq mj b gy mo mp l mq mr">(() =&gt; {<br/>  let x = 1;</span><span id="bcb5" class="mn lc iq mj b gy ms mp l mq mr">  function add(y) {<br/>    return x + y;<br/>  }<br/>})();</span></pre><p id="d588" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">箭头函数中有<code class="fe mt mu mv mj b">add</code>函数。</p><p id="d8c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了<code class="fe mt mu mv mj b">add</code>函数中的<code class="fe mt mu mv mj b">x</code>值。</p><p id="f50d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，<code class="fe mt mu mv mj b">x</code>就不会对外可用了。</p><h1 id="40f7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在实例对象上存储实例状态</h1><p id="4338" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们只在实例对象上存储实例状态。</p><p id="7d80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该有这样的代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="71ad" class="mn lc iq mj b gy mo mp l mq mr">function Tree() {}</span><span id="5860" class="mn lc iq mj b gy ms mp l mq mr">Tree.prototype = {<br/>  children: [],<br/>  addChild(x) {<br/>    this.children.push(x);<br/>  }<br/>};</span></pre><p id="1abe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="62b9" class="mn lc iq mj b gy mo mp l mq mr">function Tree() {<br/>  this.children = [];<br/>}</span><span id="7d6e" class="mn lc iq mj b gy ms mp l mq mr">Tree.prototype = {  <br/>  addChild(x) {<br/>    this.children.push(x);<br/>  }<br/>};</span></pre><p id="308d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原型是<code class="fe mt mu mv mj b">Tree</code>继承而来的，所以我们不应该把状态放在那里，因为它被<code class="fe mt mu mv mj b">Tree</code>的所有实例共享。</p><p id="c518" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该向构造函数添加状态，这样它们就不会在实例中共享。</p><p id="7692" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可变数据在共享时总是有问题。</p><p id="9c7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用类语法可以避免这个错误。</p><p id="2016" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a128" class="mn lc iq mj b gy mo mp l mq mr">class Tree {<br/>  constructor() {<br/>    this.children = [];<br/>  }</span><span id="f979" class="mn lc iq mj b gy ms mp l mq mr">  addChild(x) {<br/>    this.children.push(x);<br/>  }<br/>}</span></pre><p id="f33e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，就没有办法创建多个实例共享的状态。</p><h1 id="a6ec" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">此的隐式绑定</h1><p id="d62a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mt mu mv mj b">this</code>是在不同位置可以有不同值的东西。</p><p id="6953" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它在顶层，那么<code class="fe mt mu mv mj b">this</code>是全局对象，如果严格模式是关闭的，而<code class="fe mt mu mv mj b">undefined</code>是打开的。</p><p id="a6ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果在原型的方法中，则为构造函数。</p><p id="75d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而在一个类中，那么<code class="fe mt mu mv mj b">this</code>就是类本身。</p><p id="b7a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4a02" class="mn lc iq mj b gy mo mp l mq mr">function Tree() {<br/>  this.children = [];<br/>}</span><span id="cc46" class="mn lc iq mj b gy ms mp l mq mr">Tree.prototype = {  <br/>  addChild(x) {<br/>    this.children.push(x);<br/>  }<br/>};</span></pre><p id="cc2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe mt mu mv mj b">this</code>就是<code class="fe mt mu mv mj b">Tree</code>构造器。</p><p id="38a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有传统函数的回调，那么<code class="fe mt mu mv mj b">this</code>就是回调本身。</p><p id="95b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们要清楚它们的值，这样才不会引用错<code class="fe mt mu mv mj b">this</code>的值。</p><p id="9380" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">箭头函数不绑定到它们自己的值<code class="fe mt mu mv mj b">this</code>，所以它们非常适合回调。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/2f742e906a58f7099f5bf5e5d3fd64ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fwQNqn_G--nRsdZQ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@zacharykeimig?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zachary Keimig</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f0bd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="36d8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该小心放置构造函数状态的位置。</p><p id="e1f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，<code class="fe mt mu mv mj b">this</code>的值可以根据上下文而改变。</p><p id="da1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>