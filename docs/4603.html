<html>
<head>
<title>Validate your Node/Express.js REST API Calls with yup</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用yup验证Node/Express.js REST API调用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/validate-your-node-express-js-rest-api-calls-with-yup-5c4080fdae87?source=collection_archive---------1-----------------------#2020-12-24">https://javascript.plainenglish.io/validate-your-node-express-js-rest-api-calls-with-yup-5c4080fdae87?source=collection_archive---------1-----------------------#2020-12-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ae2e93d7af29042ca32b25e812df6a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dV5FFZwNvyyjjeZk"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@momentsbygabriel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gabriel Crismariu</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><h1 id="f010" class="kh ki in bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">概观</h1><p id="3b20" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">当您的Express API收到HTTP请求时，如何检查请求是否有效？特别是对于POST和PUT请求，您希望请求体包含要处理的整个对象，那么您如何知道它是否有正确的字段和有效值呢？</p><p id="42dc" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">在我早期的一些API中，在我的路径中编写我自己的验证代码来检查字段和类型，或者甚至在模型层中编写一些代码，在将对象放入数据库之前检查它的各种条件，这似乎是很自然的。这些解决方案总是以混乱/不可靠/不完整告终。本文向您展示了如何使用一个名为yup   <strong class="lh io">的很酷的验证库</strong> <a class="ae jz" href="https://github.com/jquense/yup" rel="noopener ugc nofollow" target="_blank"> <strong class="lh io">创建定制的Express中间件来验证HTTP请求体。</strong>我还将展示一个在yup模式中嵌套对象和条件验证的例子。</a></p><p id="e0ad" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">所有这些示例的代码都可以在这个存储库中找到:</p><div class="mi mj gp gr mk ml"><a href="https://github.com/neightjones/express-yup-validation" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">邻居/快递-是-验证</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">该模板使用babel创建了一个基本的Node.js / Express.js API。它还为eslint和…设置了很好的默认值</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">github.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz jt ml"/></div></div></a></div><p id="fd9a" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated"><em class="na">这个库是基于</em><a class="ae jz" href="https://github.com/neightjones/node-babel-template" rel="noopener ugc nofollow" target="_blank">https://github.com/neightjones/node-babel-template</a>—<em class="na">我在这两篇文章中写了建立这个babel/eslint/prettle简单样板项目的过程:</em></p><ul class=""><li id="eb6e" class="nb nc in lh b li md lm me lq nd lu ne ly nf mc ng nh ni nj bi translated"><a class="ae jz" href="https://medium.com/javascript-in-plain-english/a-minimal-node-js-express-babel-setup-part-1-6be7b3f3bb55" rel="noopener">https://medium . com/JavaScript-in-plain-English/a-minimal-node-js-express-babel-setup-part-1-6 be 7 B3 F3 bb 55</a></li><li id="dd41" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated"><a class="ae jz" href="https://medium.com/javascript-in-plain-english/a-minimal-node-js-setup-part-2-eslint-prettier-vs-code-7963768dbb30" rel="noopener">https://medium . com/JavaScript-in-plain-English/a-minimal-node-js-setup-part-2-eslint-beauty-vs-code-7963768 dbb 30</a></li></ul></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><h1 id="1afd" class="kh ki in bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">1.我们的新“产品”模型</h1><p id="97ff" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">首先，让我们创建一个可以在整个示例中使用的新类型的对象。让我们假设我们正在创建一个电子商务网站，在那里我们有很多产品列表供人们购买。目前，我们的产品模型非常简单，包含以下几个方面:</p><ul class=""><li id="add3" class="nb nc in lh b li md lm me lq nd lu ne ly nf mc ng nh ni nj bi translated"><code class="fe np nq nr ns b">id</code>:这是每个产品的唯一标识符——这是<strong class="lh io">要求的</strong></li><li id="0c08" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated"><code class="fe np nq nr ns b">name</code>:表示产品名称的字符串— <strong class="lh io">必选</strong></li><li id="1be8" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated"><code class="fe np nq nr ns b">description</code>:描述产品的字符串——这是<strong class="lh io">可选</strong></li><li id="38d2" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated">这个产品多少钱？—这是<strong class="lh io">要求的</strong></li><li id="a7dd" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated"><code class="fe np nq nr ns b">category</code>:尽管我们可能不会这样做，但这将是一个简单的字符串，用于指定产品的类型(<code class="fe np nq nr ns b">sporting goods</code>、<code class="fe np nq nr ns b">clothing</code>等)。)—这是<strong class="lh io">要求的</strong></li></ul><p id="ca0a" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">这是一个有效产品的例子:</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="7fa4" class="ob ki in ns b gy oc od l oe of">// Looks good!<br/>const product = {<br/>  id: 1,<br/>  name: 'The Imitation Game',<br/>  description: 'Movie about Alan Turing',<br/>  price: 19.99,<br/>  category: 'movie',<br/>};</span></pre><p id="a629" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">唯一可选的字段是<code class="fe np nq nr ns b">description</code>，所以我们不需要添加它来获得有效的产品。所有其他字段(使用正确的类型！)是必需的。</p></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><h1 id="8615" class="kh ki in bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">2.含yup的产品模式</h1><p id="0a94" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">考虑到我们新的<code class="fe np nq nr ns b">product</code>模型，让我们看看如何将这些信息编码到一个yup模式中。</p><p id="5a48" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated"><a class="ae jz" href="https://github.com/jquense/yup" rel="noopener ugc nofollow" target="_blank"> Yup声称</a>它是“一个用于值解析和验证的JavaScript模式构建器。”在本帖中，我们将重点关注验证用例。需要做两件事:</p><ol class=""><li id="aa4a" class="nb nc in lh b li md lm me lq nd lu ne ly nf mc og nh ni nj bi translated">我们定义一个模式来表示我们的<code class="fe np nq nr ns b">product</code>对象模型——这意味着编码它的字段、类型、什么是必需的或者不是必需的，等等。</li><li id="3d3b" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc og nh ni nj bi translated">我们将看到如何使用yup模式来测试一个JavaScript对象是否有效</li></ol><p id="3862" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">本节中的代码在关联回购中找不到——这只是通过一些例子来感受一下yup验证是如何工作的。</p><p id="ac27" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">看看这个最初的例子:</p><figure class="nt nu nv nw gt jo"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="e8e7" class="nb nc in lh b li md lm me lq nd lu ne ly nf mc ng nh ni nj bi translated">第1行:从yup导入所有内容，这样我们就可以使用<code class="fe np nq nr ns b">yup.&lt;x&gt;</code>语法</li><li id="c0ce" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated">第3行:这是我们的第一个yup模式……我们很快会对此进行扩展，但是现在我们说<code class="fe np nq nr ns b">productSchema</code>只是有一个名为<code class="fe np nq nr ns b">name</code>的字段，它的类型是string</li><li id="0ac0" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated">第7、8行:这是两个简化的产品示例</li><li id="35a0" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated">第10、14行:这两个块使用<code class="fe np nq nr ns b">productSchema</code>上的<code class="fe np nq nr ns b">isValid</code>方法来检查我们传入的对象是否有效(它返回一个承诺，所以我们使用<code class="fe np nq nr ns b">.then</code>来等待结果并注销它</li></ul><p id="e607" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">如您所料，<code class="fe np nq nr ns b">product1</code>是有效的——它有<code class="fe np nq nr ns b">name</code>字段，这是到目前为止模式中提到的唯一字段。但是，<code class="fe np nq nr ns b">product2</code>是不是<strong class="lh io">也有效</strong> …在我们的schema中，并没有说<code class="fe np nq nr ns b">name</code>字段是必需的，所以<code class="fe np nq nr ns b">product2</code>只有一个名为<code class="fe np nq nr ns b">title</code>的字段也没关系，多余的字段也可以。</p><p id="eb06" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">幸运的是，我们可以在每个yup模式字段上链接不同的操作符，包括<code class="fe np nq nr ns b">.required()</code>调用。记住这一点，让我们用最初描述的字段创建完整的<code class="fe np nq nr ns b">productSchema</code>,并在需要的地方使用<code class="fe np nq nr ns b">.required()</code>:</p><figure class="nt nu nv nw gt jo"><div class="bz fp l di"><div class="oh oi l"/></div></figure><ul class=""><li id="8534" class="nb nc in lh b li md lm me lq nd lu ne ly nf mc ng nh ni nj bi translated">第3行:我们的<code class="fe np nq nr ns b">productSchema</code>现在拥有了我们讨论过的所有字段。除了<code class="fe np nq nr ns b">description</code>之外的所有字段都链接了<code class="fe np nq nr ns b">required()</code>调用，因为<code class="fe np nq nr ns b">description</code>是唯一的非必填字段。此外，您可以看到数字字段有一些额外的验证(两个都是正数，一个是整数)……<a class="ae jz" href="https://github.com/jquense/yup#number" rel="noopener ugc nofollow" target="_blank">您可以在这里找到所有这些选项，例如数字的选项</a>。</li><li id="57f9" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated">第11行:<code class="fe np nq nr ns b">product1</code>包含所有必需的字段，并且每个字段都有适当的类型</li><li id="2ba6" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated">第19行:<code class="fe np nq nr ns b">product2</code>缺少<code class="fe np nq nr ns b">description</code>，这很好，因为它不是必需的。然而，看看它的<code class="fe np nq nr ns b">price</code>字段……该模式需要一个数字，<em class="na">而不是</em>一个字符串。</li><li id="74ba" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated">基于此，控制台日志将显示<code class="fe np nq nr ns b">product1</code>有效，但<code class="fe np nq nr ns b">product2</code>是<strong class="lh io">而不是</strong>。当我们将实际代码添加到我们的项目中时，您还将看到如何捕获<em class="na">对象无效时的验证错误</em>。</li></ul><p id="a4d4" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">这是让我们继续前进的基本思路，所以我们将深入实际代码。稍后，我们将通过一个稍微复杂一点的例子来展示如何在一个yup模式中进行条件验证。</p></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><h1 id="0fa5" class="kh ki in bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">3.添加一个简单的产品路由器</h1><p id="1194" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">正如我之前提到的，你可以在这个报告中看到所有的最终代码<a class="ae jz" href="https://github.com/neightjones/express-yup-validation" rel="noopener ugc nofollow" target="_blank">，或者如果你想继续下去，你可以从我之前写的这个样板文件</a>中学习。</p><p id="3f3f" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">首先，我们将为<code class="fe np nq nr ns b">products</code>添加一个新的routes文件。在<code class="fe np nq nr ns b">src/routes</code>下，我们将创建一个名为<code class="fe np nq nr ns b">products</code>的新文件夹(我们使用一个文件夹而不是一个简单的<code class="fe np nq nr ns b">products.js</code>文件，因为我们将有更多的代码与这个新的路由逻辑组合在一起)…在<code class="fe np nq nr ns b">src/routes/products</code>内，添加一个<code class="fe np nq nr ns b">index.js</code>文件，并将其添加到您的新文件中:</p><figure class="nt nu nv nw gt jo"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="41ff" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">接下来，您需要通过添加2行代码将它与<code class="fe np nq nr ns b">src/app.js</code>连接起来。首先，在导入其他路由器的地方导入<code class="fe np nq nr ns b">productsRouter</code>，就像这样:</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="6042" class="ob ki in ns b gy oc od l oe of">import indexRouter from '#routes/index'; // this was already here<br/>import usersRouter from '#routes/users'; // this was already here<br/>import productsRouter from '#routes/products'; // this is new!</span></pre><p id="6711" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">第二，您将告诉<code class="fe np nq nr ns b">app</code>使用此路由器用于<code class="fe np nq nr ns b">/products</code>路由，方法是在其他路由器被使用后添加一行，如下所示:</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="5d64" class="ob ki in ns b gy oc od l oe of">app.use('/', indexRouter); // this was already here<br/>app.use('/users', usersRouter); // this was already here<br/>app.use('/products', productsRouter); // this is new!</span></pre><p id="4768" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">现在我们已经准备好给我们的新<code class="fe np nq nr ns b">productsRouter</code>打几个电话。这里没有太令人兴奋的事情发生。这是一个简单的<code class="fe np nq nr ns b">POST</code>端点，它记录在请求体中发送的对象，然后将该对象回显给请求者……在继续之前，让我们测试一下它是否工作。假设您已经在端口3000上启动了Express服务器，从终端运行以下命令:</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="3a13" class="ob ki in ns b gy oc od l oe of">curl -v localhost:3000/products \<br/>-X POST \<br/>-H "Content-Type: application/json" \<br/>-d '{ "hello": "world" }'</span></pre><p id="0456" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">如果一切顺利，您将看到您的Express服务器打印出对象<code class="fe np nq nr ns b">{ "hello": "world" }</code>，并从您的终端看到您的请求收到了一个<code class="fe np nq nr ns b">200</code>响应，其中<code class="fe np nq nr ns b">{ "hello": "world" }</code> JSON被回显给您。</p><p id="a147" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">现在我们准备添加一些验证。</p></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><h1 id="de3f" class="kh ki in bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">4.验证POST / PUT的快速中间件</h1><p id="b422" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">Express中的中间件允许您在主API端点代码中处理请求之前，向请求/响应周期添加逻辑层。我们添加一些定制的Express中间件的目标是什么？我们想在主处理程序之前<strong class="lh io">检查POST请求是否包含有效的产品对象。这样，有两种结果:</strong></p><ol class=""><li id="7619" class="nb nc in lh b li md lm me lq nd lu ne ly nf mc og nh ni nj bi translated">如果产品是有效的，我们的路线/服务/模型代码的剩余部分可以干净地编写，因为我们将保证<code class="fe np nq nr ns b">product</code>有它需要的字段，或者</li><li id="60ee" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc og nh ni nj bi translated">如果产品无效，最好尽早失败，并向请求者返回一个<code class="fe np nq nr ns b">400: Bad Request</code>。如果我们这样做了，我们就成功地将验证逻辑隔离在一个地方，一旦它变得复杂，这就是一个巨大的胜利。</li></ol><h2 id="f4b8" class="ob ki in bd kj oj ok dn kn ol om dp kr lq on oo kv lu op oq kz ly or os ld ot bi translated">创建验证程序文件</h2><p id="4a47" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">在上面创建的新文件夹<code class="fe np nq nr ns b">src/routes/products</code>中创建一个新文件，命名为<code class="fe np nq nr ns b">validator.js</code>。该文件将简单地包含我们需要在该文件夹的相应API端点中验证的任何对象的yup模式。现在，我们只处理<code class="fe np nq nr ns b">products</code>，所以我们将使用我们之前创建的<code class="fe np nq nr ns b">productSchema</code>并使其成为默认导出，如下所示:</p><figure class="nt nu nv nw gt jo"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="2a06" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">当然，这还没有做任何事情…我们将需要创建实际的Express中间件，并最终与中间件一起使用这个<code class="fe np nq nr ns b">productSchema</code>。</p><h2 id="bbdc" class="ob ki in bd kj oj ok dn kn ol om dp kr lq on oo kv lu op oq kz ly or os ld ot bi translated">创建中间件</h2><p id="e716" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">尽管我们现在只处理<code class="fe np nq nr ns b">products</code>路线，但是让我们在任何新路由器都可以使用它来验证其对象的地方创建中间件。在<code class="fe np nq nr ns b">src/routes</code>中创建一个名为<code class="fe np nq nr ns b">middleware</code>的新文件夹，并在该文件夹中创建一个名为<code class="fe np nq nr ns b">validateResource.js</code>的文件。添加以下代码:</p><figure class="nt nu nv nw gt jo"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="e5bb" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">让我们来看看这是如何工作的:</p><p id="7ae1" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">快速中间件的标准签名如下所示:</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="81f5" class="ob ki in ns b gy oc od l oe of">function myMiddleware(req, res, next) {<br/>  // logic for my middleware here<br/>}</span></pre><p id="cef7" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">这里有一个关于中间件的快速指南。重要的是，您可以访问请求和响应对象。这样，您可以看到请求体、方法等内容。，如果您愿意，也可以通过<code class="fe np nq nr ns b">res</code>参数返回一个响应。最后，<code class="fe np nq nr ns b">next</code>参数是您如何将中间件链接在一起——当您调用<code class="fe np nq nr ns b">next();</code>时，您是在告诉Express继续前进到链中的下一个中间件(或者，在我们的例子中，继续前进到主路由处理器，它本质上只是另一个中间件)。</p><p id="e8d3" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">我们上面的<code class="fe np nq nr ns b">validateResourceMW</code>中间件的一个有趣的属性是，它<em class="na">返回</em> <em class="na">一个函数</em>，该函数具有作为一个Express中间件的适当形式。我们这样做是为了能够参数化我们的中间件。因此，导出的函数将一个名为<code class="fe np nq nr ns b">resourceSchema</code>的参数作为它的单个参数，并返回一个在其逻辑中利用了<code class="fe np nq nr ns b">resourceSchema</code>的有效中间件函数。通过这种方式，不同的路由器可以将不同的对象模式传递给这个通用中间件，这使得每个路由器能够为其关心的对象类型获得正确的定制中间件。在我们的例子中，我们将传入我们刚刚在位于产品路由器旁边的<code class="fe np nq nr ns b">validator.js</code>文件中创建的<code class="fe np nq nr ns b">productSchema</code>。</p><p id="8a80" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">让我们看看中间件功能中的逻辑:</p><ul class=""><li id="7f7d" class="nb nc in lh b li md lm me lq nd lu ne ly nf mc ng nh ni nj bi translated">第7行:我们试图验证的“资源”是请求体。在我们的<code class="fe np nq nr ns b">productsRouter</code>中，将是一个产品对象被发布</li><li id="4a21" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated">第10行:我们现在使用稍微不同的yup来验证资源。您可以看到对<code class="fe np nq nr ns b">resourceSchema.validate(resource);</code>的异步调用。这很方便，因为如果资源无效，它将抛出一个错误，这就是为什么我们将它包装在一个<code class="fe np nq nr ns b">try</code> <code class="fe np nq nr ns b">catch</code>块中。</li><li id="2d90" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated">第11行:如果我们到达这里，我们知道资源是有效的，所以我们调用<code class="fe np nq nr ns b">next()</code>，它将请求转发给我们的路由处理器</li><li id="e925" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated">第13–14行:如果<code class="fe np nq nr ns b">validate</code>调用抛出一个错误，我们就进入<code class="fe np nq nr ns b">catch</code>块。为了捕捉错误，我们在这里使用<code class="fe np nq nr ns b">validate</code>而不是<code class="fe np nq nr ns b">isValid</code>(之前的)。您可以看到，我们返回了一个使用了<code class="fe np nq nr ns b">e.errors.join(', ')</code>的定制JSON响应的<code class="fe np nq nr ns b">400</code>错误——这些错误是关于验证期间出错的有用字符串。我们会看到一些例子。</li></ul><h2 id="c6d3" class="ob ki in bd kj oj ok dn kn ol om dp kr lq on oo kv lu op oq kz ly or os ld ot bi translated">更新<code class="fe np nq nr ns b">Product Schema</code></h2><p id="9263" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">在我们把所有的部分联系在一起之前，让我们回顾一下我们在<code class="fe np nq nr ns b">src/routes/products/validator.js</code>中创建的<code class="fe np nq nr ns b">productSchema</code>。当我们之前运行一些基本测试时，这是非常有意义的…具体来说，一个产品有一个<code class="fe np nq nr ns b">id</code>字段是有意义的，因为我们正在回答问题<em class="na">“这是一个有效的产品吗？”</em>然而，在POST请求的情况下，不应该有与请求主体相关联的<code class="fe np nq nr ns b">id</code>——数据库将为我们生成一个新的、唯一的id。因此，让我们删除id字段，留给我们一个更新后的<code class="fe np nq nr ns b">validator.js</code>文件，如下所示:</p><figure class="nt nu nv nw gt jo"><div class="bz fp l di"><div class="oh oi l"/></div></figure><h2 id="c4f4" class="ob ki in bd kj oj ok dn kn ol om dp kr lq on oo kv lu op oq kz ly or os ld ot bi translated">把它们绑在一起</h2><p id="fce8" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">最后，我们需要在我们的<code class="fe np nq nr ns b">products</code>路由器索引文件中使用中间件，这又需要我们在<code class="fe np nq nr ns b">validator.js</code>中定义的<code class="fe np nq nr ns b">productSchema</code>…现在，新的<code class="fe np nq nr ns b">products</code>路由器文件将看起来像这样:</p><figure class="nt nu nv nw gt jo"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="3e12" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">我们将<code class="fe np nq nr ns b">validateObjectMW</code>(中间件)和<code class="fe np nq nr ns b">productSchema</code>(yup模式)导入到路由索引文件中。然后，在第7行，您可以看到<code class="fe np nq nr ns b">post</code>的第二个参数现在是<code class="fe np nq nr ns b">validateObjectMW(productSchema)</code>，它告诉Express在运行我们的POST端点中的逻辑之前运行这个中间件。</p><p id="973a" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">重启你的Express服务器，让我们运行几个<code class="fe np nq nr ns b">curl</code>来测试一下。</p><p id="f0f5" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">初次尝试:</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="2878" class="ob ki in ns b gy oc od l oe of">curl -v localhost:3000/products \<br/>-X POST \<br/>-H "Content-Type: application/json" \<br/>-d '{ "name": "The Imitation Game", "price": 19.99, "category": "movie" }'</span></pre><p id="fe6d" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">这成功地通过了，因为我们的请求体是一个有效的产品(我没有添加<code class="fe np nq nr ns b">description</code>，但这不是必需的)。既然成功了，您应该会看到日志“很好！我们通过了验证。”以及一个<code class="fe np nq nr ns b">200</code>的回应随着JSON的身体回响了回来。</p><p id="2765" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">接下来，让我们通过测试这个无效体来证明我们的验证是有效的:</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="fe71" class="ob ki in ns b gy oc od l oe of">curl -v localhost:3000/products \<br/>-X POST \<br/>-H "Content-Type: application/json" \<br/>-d '{ "name": "The Imitation Game", "price": "$19.99", "category": "movie" }'</span></pre><p id="e6d4" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">我收到一个带有以下JSON正文的<code class="fe np nq nr ns b">400</code>状态响应:</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="276e" class="ob ki in ns b gy oc od l oe of">{"error":"price must be a `number` type, but the final value was: `NaN` (cast from the value `\"$19.99\"`)."}</span></pre><p id="1f58" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">完美！您是否希望向用户返回类似这样的内容是另一回事，但是现在我们知道我们可以成功地从我们的模式中捕获验证错误。还要注意的是，服务器上没有日志显示“太好了！我们通过了验证。”中间件在任何路由处理器代码运行之前返回<code class="fe np nq nr ns b">400</code>响应，这正是我们想要的结果。</p><p id="b059" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated"><code class="fe np nq nr ns b">POST</code>和<code class="fe np nq nr ns b">PUT</code>请求的工作方式非常相似。与<code class="fe np nq nr ns b">PUT</code>的唯一区别是，您可能有一个路径变量来表示被更新资源的id(例如<code class="fe np nq nr ns b">PUT /products/:id</code>)。在这种情况下，您仍然可以使用我们定义的相同的<code class="fe np nq nr ns b">productSchema</code>请求体。</p><p id="e82f" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">如果请求命中我们的API来发布或放置无效对象，我们已经实现了尽早失败的目标。我喜欢这个解决方案，因为它很好地将验证对象和验证对象上的任何业务逻辑分开。简单的情况已经解决了，但是让我们看看几个更有趣的特性，我们可以在yup中使用它们来处理更复杂的模式。</p></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><h1 id="680c" class="kh ki in bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">5.yup模式中的嵌套对象</h1><p id="ae76" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">到目前为止，我们的<code class="fe np nq nr ns b">product</code>对象只有简单的字段类型，比如数字和字符串。更复杂类型的模式看起来如何？让我们给我们的<code class="fe np nq nr ns b">product</code>模型添加另一个名为<code class="fe np nq nr ns b">locations</code>的字段。<code class="fe np nq nr ns b">locations</code>键将包含一个表示产品销售地点的对象数组。每个位置都有以下字段:</p><ul class=""><li id="69e2" class="nb nc in lh b li md lm me lq nd lu ne ly nf mc ng nh ni nj bi translated"><code class="fe np nq nr ns b">city</code>:所在城市</li><li id="7015" class="nb nc in lh b li nk lm nl lq nm lu nn ly no mc ng nh ni nj bi translated"><code class="fe np nq nr ns b">state</code>:位置的2个字母的州代码</li></ul><p id="8130" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">幸运的是，我们可以嵌套yup对象，并通过分离子对象(<code class="fe np nq nr ns b">location</code>)信息来保持我们的模式整洁。这是我们更新的产品路线的<code class="fe np nq nr ns b">validator.js</code>文件:</p><figure class="nt nu nv nw gt jo"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="e285" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">我们现在有了一个名为<code class="fe np nq nr ns b">locationSchema</code>的新的yup模式，它反映了上面的描述。我在yup的<code class="fe np nq nr ns b">string</code> api上使用了一个名为<code class="fe np nq nr ns b">matches</code>的特性——它使用了一个正则表达式，并确保字符串相对于正则表达式是有效的。对于两个字母的州代码来说，这不是一个完美的解决方案，但至少我们检查了我们有两个大写字母。</p><p id="e0a8" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">在第16行，我们将两个模式联系在一起。<code class="fe np nq nr ns b">productSchema</code>现在有了<code class="fe np nq nr ns b">locations</code>，这是一个必须遵循我们的<code class="fe np nq nr ns b">locationSchema</code>的对象数组。注意，值不是<code class="fe np nq nr ns b">.required()</code>，所以产品不需要有<code class="fe np nq nr ns b">locations</code>才有效。下面是一个将成功通过验证的测试:</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="32e1" class="ob ki in ns b gy oc od l oe of">curl -v localhost:3000/products \<br/>-X POST \<br/>-H "Content-Type: application/json" \<br/>-d '{ "name": "The Imitation Game", "price": 19.99, "category": "movie", "locations": [{ "city": "New York", "state": "NY" }, { "city": "Denver", "state": "CO" }] }'</span></pre><p id="55e2" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">这里发生了什么？</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="b276" class="ob ki in ns b gy oc od l oe of">curl -v localhost:3000/products \<br/>-X POST \<br/>-H "Content-Type: application/json" \<br/>-d '{ "name": "The Imitation Game", "price": 19.99, "category": "movie", "locations": [{ "city": "New York", "state": "NY" }, { "city": "Denver", "state": "Colorado" }] }'</span></pre><p id="b2fe" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">我们得到一个<code class="fe np nq nr ns b">400</code>和一个有用的错误消息:</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="d9c5" class="ob ki in ns b gy oc od l oe of">{"error":"locations[1].state must match the following: \"/^[A-Z]{2}$/\""}</span></pre><p id="3922" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">发送的是完整的州名“科罗拉多”，而不是它的两个字母的代码“CO”，这触发了一个验证错误。</p></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><h1 id="1786" class="kh ki in bd kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le bi translated">6.yup模式中的条件逻辑</h1><p id="07d5" class="pw-post-body-paragraph lf lg in lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc ig bi translated">让我们做最后一个例子。如果我们想在我们的<code class="fe np nq nr ns b">product</code>模型中添加一个<code class="fe np nq nr ns b">subCategory</code>字段，但是只有某些<code class="fe np nq nr ns b">category</code>值需要它，该怎么办？例如，如果<code class="fe np nq nr ns b">sporting goods</code>类别需要一个类似<code class="fe np nq nr ns b">basketball</code>或<code class="fe np nq nr ns b">football</code>的子类别，类似的<code class="fe np nq nr ns b">electronics</code>类别需要一个类似<code class="fe np nq nr ns b">laptops</code>或<code class="fe np nq nr ns b">tvs</code>的子类别，该怎么办？我们假设没有其他的<code class="fe np nq nr ns b">category</code>需要一个<code class="fe np nq nr ns b">subCategory</code>。</p><p id="a42c" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">我们可以在Yep中轻松处理这个问题。这是我们模式的另一个更新版本:</p><figure class="nt nu nv nw gt jo"><div class="bz fp l di"><div class="oh oi l"/></div></figure><p id="9435" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">我们利用了yup的<code class="fe np nq nr ns b">.when</code>条款。内容如下:<em class="na">“子类别是一个字符串…当类别字段为‘体育用品’时，我们知道子类别是一个必需的字符串，如果类别为‘电子产品’，情况也是如此，但是，如果两个条件都不成立，则子类别不是必需的。”</em></p><p id="8c4b" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">让我们测试几个<code class="fe np nq nr ns b">curl</code> s…</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="eb81" class="ob ki in ns b gy oc od l oe of">curl -v localhost:3000/products \<br/>-X POST \<br/>-H "Content-Type: application/json" \<br/>-d '{ "name": "The Imitation Game", "price": 19.99, "category": "movie" }'</span></pre><p id="7422" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">第一次调用是成功的，因为类别是<code class="fe np nq nr ns b">movie</code>，所以不需要添加<code class="fe np nq nr ns b">subCategory</code>字段。让我们合并一个具有新需求的类别:</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="d450" class="ob ki in ns b gy oc od l oe of">curl -v localhost:3000/products \<br/>-X POST \<br/>-H "Content-Type: application/json" \<br/>-d '{ "name": "The Imitation Game", "price": 19.99, "category": "sporting goods" }'</span></pre><p id="8965" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">此示例未通过验证。<code class="fe np nq nr ns b">category</code>是“体育用品”，但是我们的新模式中没有指定包含<code class="fe np nq nr ns b">subCategory</code>。最后:</p><pre class="nt nu nv nw gt nx ns ny nz aw oa bi"><span id="dce8" class="ob ki in ns b gy oc od l oe of">curl -v localhost:3000/products \<br/>-X POST \<br/>-H "Content-Type: application/json" \<br/>-d '{ "name": "The Imitation Game", "price": 19.99, "category": "sporting goods", "subCategory": "basketball" }'</span></pre><p id="1958" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">这是一个成功的调用，因为我们再次为<code class="fe np nq nr ns b">category</code>使用了“sporting goods ”,并且这次根据需要包含了一个<code class="fe np nq nr ns b">subCategory</code>字符串。这个想法对于我们模式中的另一个有趣的“电子”也是一样的。</p><p id="95b9" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">Yep中的<code class="fe np nq nr ns b">.when</code>选项提供了很大的灵活性。如果您需要更大的灵活性，甚至还有一个逃生舱，您可以在<code class="fe np nq nr ns b">when</code>子句中使用更通用的函数— <a class="ae jz" href="https://github.com/jquense/yup#mixedwhenkeys-string--arraystring-builder-object--value-schema-schema-schema" rel="noopener ugc nofollow" target="_blank">参见文档</a>中的这些示例。</p></div><div class="ab cl ka kb hr kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="ig ih ii ij ik"><p id="e28c" class="pw-post-body-paragraph lf lg in lh b li md lk ll lm me lo lp lq mf ls lt lu mg lw lx ly mh ma mb mc ig bi translated">感谢您的关注，如果您发现任何问题或有其他改进工作流程的建议，请与我联系。</p></div></div>    
</body>
</html>