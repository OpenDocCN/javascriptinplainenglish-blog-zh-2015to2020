<html>
<head>
<title>Node.js Tips — Async and Map, Async and MongoDB, and Copying Files with S3</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示——异步和映射、异步和MongoDB，以及用S3复制文件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-async-and-map-async-and-mongodb-and-copying-files-with-s3-df814b7e81d1?source=collection_archive---------5-----------------------#2020-07-20">https://javascript.plainenglish.io/node-js-tips-async-and-map-async-and-mongodb-and-copying-files-with-s3-df814b7e81d1?source=collection_archive---------5-----------------------#2020-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9f9dc9ec991a8d026510f5eb002c29d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Xx8ZQFuHxmwOW3D4"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@pineapplepuppy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ilianna Brett</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a19a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="4448" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在映射中调用异步函数</h1><p id="d8d2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">Promise.all</code>将函数映射到异步函数。</p><p id="3b01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c1d9" class="mq lc iq mh b gy mr ms l mt mu">const asyncMap = async (teachers) =&gt; {<br/>  const data = await Promise.all(teachers.map(async teacher =&gt; {<br/>    return {<br/>      ...teacher,<br/>      image: `${teacher.name}.jpg`<br/>   }<br/>  }));<br/>  //...<br/>}</span></pre><p id="070d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">teachers</code>数组映射到带有<code class="fe me mf mg mh b">map</code>的承诺数组。</p><p id="011a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<code class="fe me mf mg mh b">async</code>函数返回一个承诺，所以我们可以在对<code class="fe me mf mg mh b">map</code>的回调之前添加<code class="fe me mf mg mh b">async</code>关键字。</p><p id="d2d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">await</code>和<code class="fe me mf mg mh b">Promise.all</code>来并行调用所有的承诺。</p><p id="f431" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">之后我们可以随心所欲地处理结果。</p><h1 id="26e8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用Nodemon监视目录的变化</h1><p id="7d97" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">--watch</code>选项来查看多个文件和目录。</p><p id="220a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e6ad" class="mq lc iq mh b gy mr ms l mt mu">nodemon --watch src app.js</span></pre><p id="12bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">观看<code class="fe me mf mg mh b">src</code>文件夹和<code class="fe me mf mg mh b">app.js</code>。</p><h1 id="d8b5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Node.js的AWS SDK将Amazon S3中的所有对象从一个前缀复制到另一个前缀</h1><p id="6c5d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要将对象从一个键复制到另一个键，我们可以使用<code class="fe me mf mg mh b">listObjects</code>来列出条目。</p><p id="2799" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">copyObject</code>将条目复制到密钥位置。</p><p id="b799" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="77f3" class="mq lc iq mh b gy mr ms l mt mu">const AWS = require('aws-sdk');<br/>const async = require('async');<br/>const bucketName = 'foo';<br/>const oldPrefix = 'bar/';<br/>const newPrefix = 'baz/';<br/>const s3 = new AWS.S3({ params: { Bucket: bucketName }, region: 'us-west-2' });</span><span id="b851" class="mq lc iq mh b gy mv ms l mt mu">const done = (err, data) =&gt; {<br/>  if (err) { console.log(err); }<br/>  else { console.log(data); }<br/>};</span><span id="15d6" class="mq lc iq mh b gy mv ms l mt mu">s3.listObjects({ Prefix: oldPrefix }, (err, data) =&gt; {<br/>  if (data.Contents.length) {<br/>    async.each(data.Contents, (file, cb) =&gt; {<br/>      const params = {<br/>        Bucket: bucketName,<br/>        CopySource: `${bucketName}/${file.Key}`,<br/>        Key: file.Key.replace(oldPrefix, newPrefix)<br/>      };<br/>      s3.copyObject(params, (copyErr, copyData) =&gt; {<br/>        if (copyErr) {<br/>          console.log(copyErr);<br/>        }<br/>        else {<br/>          console.log(params.Key);<br/>          cb();<br/>        }<br/>      });<br/>    }, done);<br/>  }<br/>});</span></pre><p id="fd8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">oldPrefix</code>调用<code class="fe me mf mg mh b">listObjects</code>来获取lol路径中的项目。</p><p id="a603" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">条目存储在<code class="fe me mf mg mh b">data.Contents</code>中。</p><p id="a9c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们使用<code class="fe me mf mg mh b">async.each</code>遍历每个对象。</p><p id="58d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Bucket</code>有桶名。</p><p id="95f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">CopySource</code>有原始路径。</p><p id="d685" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Key</code>有了新的钥匙，我们称<code class="fe me mf mg mh b">replace</code>为<code class="fe me mf mg mh b">oldPrefix</code>，用<code class="fe me mf mg mh b">newPrefix</code>代替<code class="fe me mf mg mh b">oldPrefix</code>。</p><p id="a61d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">params</code>对象传递给<code class="fe me mf mg mh b">copyObject</code>方法。</p><p id="c6af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会得到结果。</p><p id="5157" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们这样做了，我们就调用<code class="fe me mf mg mh b">cb</code>来完成迭代。</p><p id="fe64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用前面定义的<code class="fe me mf mg mh b">done</code>来打印任何错误或结果。</p><h1 id="9e7f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Node.js中的顺序MongoDB查询</h1><p id="19f0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">async</code>和<code class="fe me mf mg mh b">await</code>以同步方式进行MongoDB查询。</p><p id="a6c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它看起来是同步的，因为它是顺序的，但它是异步的。</p><p id="136d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4e04" class="mq lc iq mh b gy mr ms l mt mu">const getPerson = async () =&gt; {<br/>  const db = await mongodb.MongoClient.connect('mongodb://server/db');<br/>  if (await db.authenticate("username", "password")) {<br/>    const person = await db.collection("Person").findOne({ name: "james" });<br/>    await db.close();<br/>    return person;<br/>  }<br/>}</span></pre><p id="410b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">return</code>返回解析为<code class="fe me mf mg mh b">person</code>的承诺。</p><p id="a990" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它实际上并不返回<code class="fe me mf mg mh b">person</code>。</p><p id="0f37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">db.collection</code>获取我们想要查询的集合。</p><p id="ce25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">findOne</code>在对象中找到一个符合条件的条目。</p><p id="6424" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们寻找具有<code class="fe me mf mg mh b">name</code>值<code class="fe me mf mg mh b">'james'</code>的条目。</p><p id="614d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查询的解析值被设置为<code class="fe me mf mg mh b">person</code>。</p><p id="f26a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成查询后，我们调用<code class="fe me mf mg mh b">db.close</code>。</p><p id="5653" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们返回<code class="fe me mf mg mh b">person</code>将返回的承诺解析为该值。</p><h1 id="a8d5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">自动将标题添加到Express应用程序中的每个“呈现”响应</h1><p id="2c9a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以制作自己的中间件，为每个响应添加一个头。</p><p id="0b93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="eb5a" class="mq lc iq mh b gy mr ms l mt mu">app.use((req, res, next) =&gt; {<br/>  res.header('foo', 'bar');<br/>  next();<br/>});</span></pre><p id="7d72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">res.header</code>，我们将带有值<code class="fe me mf mg mh b">'bar'</code>的<code class="fe me mf mg mh b">'foo'</code>响应头添加到所有响应中。</p><p id="8b62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">next</code>运行下一个中间件。</p><p id="4c25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码应该添加到路由之前，这样它就可以在每个路由之前运行。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/bd6f55a660c4a778054ec8ea472076c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tAvtfyAiXE0yF17O"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@saketh_upadhya?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Saketh Upadhya</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="cceb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="57a2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以调用<code class="fe me mf mg mh b">map</code>将每个条目映射到一个承诺。</p><p id="0d80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">Promise.all</code>来并行调用它们。</p><p id="f622" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用AWS SDK在S3复制文件。</p><p id="1207" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">MongoDB方法支持承诺。</p><p id="23af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用中间件给所有的路由添加响应头。</p><h1 id="6521" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单英语的JavaScript</h1><p id="ef2b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>