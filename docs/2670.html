<html>
<head>
<title>Design Patterns: Null Object</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式:空对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/design-patterns-null-object-768041613026?source=collection_archive---------10-----------------------#2020-07-13">https://javascript.plainenglish.io/design-patterns-null-object-768041613026?source=collection_archive---------10-----------------------#2020-07-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d128" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用这种模式避免条件复杂性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/84acf69d52ac9338d4e92fb5d4d3ee7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ge2Rif-VrVura-KnJsWwyA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@terminath0r?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Thor Alvis</a> on <a class="ae kv" href="https://unsplash.com/s/photos/object?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="db24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有23个经典的设计模式，在原著<code class="fe ls lt lu lv b">Design Patterns: Elements of Reusable Object-Oriented Software</code>中有描述。这些模式为软件开发中经常重复出现的特定问题提供解决方案。</p><p id="4c9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将描述什么是<strong class="ky ir">空对象模式</strong>；以及如何和何时应用它。这个模式<strong class="ky ir">没有包含在经典模式书中的</strong>中，但是它首先发表在程序  <em class="lw"> </em>的<strong class="ky ir"> <em class="lw">模式语言中，并且它<em class="lw"> </em>被广泛使用以避免复杂性。</em></strong></p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="cbad" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">空对象模式:基本思想</h1><p id="1dc5" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated"><em class="lw">在面向对象编程中，</em> <strong class="ky ir"> <em class="lw">空对象</em> </strong> <em class="lw">是一个没有引用值或者定义了中性(“空”)行为的对象。空对象设计模式描述了这些对象的用途和它们的行为(或缺乏行为)。—维基百科</em></p><p id="7957" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式的主要特点是可以避免代码的复杂性。在大多数语言中，如Java、C#或JavaScript，引用可能为空。根据我们的业务逻辑，在调用任何方法之前，可能需要检查代码以确保它们不为空，因为方法通常不能在空引用上调用。</p><p id="5980" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总而言之，空对象模式允许我们通过使用对象而不是原始类型来避免条件复杂性。这个模式的UML图如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/7783f921e59f2780e8362052d3be4bf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:978/format:webp/0*yfylpRX0O2q4k0PP.png"/></div></figure><p id="4986" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">AbstractObject</code>类是一个抽象类，它定义了必须在<code class="fe ls lt lu lv b">RealObject</code>和“空”或“默认”对象(<code class="fe ls lt lu lv b">NullObject</code>)中实现的不同操作。<code class="fe ls lt lu lv b">RealObject</code>将对每个真实对象进行操作，而<code class="fe ls lt lu lv b">NullObject</code>什么也不做，或者可能你想对这个对象进行默认操作。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="760a" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">空对象模式:何时使用</h1><ol class=""><li id="12f4" class="nc nd iq ky b kz mw lc mx lf ne lj nf ln ng lr nh ni nj nk bi translated">您需要动态地、透明地向单个对象添加职责，也就是说，不影响其他对象。</li><li id="afd0" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nh ni nj nk bi translated">你需要加上随时可以收回的责任。</li></ol></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="4743" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">空对象模式:优势</h1><p id="1e20" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">空对象模式有几个优点，总结如下:</p><ul class=""><li id="3a8e" class="nc nd iq ky b kz la lc ld lf nq lj nr ln ns lr nt ni nj nk bi translated">它定义了由真实对象和空对象组成的类层次结构。</li><li id="1114" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nt ni nj nk bi translated">当预期对象不做任何事情时，可以使用空对象来代替真实对象。</li><li id="23e5" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nt ni nj nk bi translated">客户端代码更加简单，因为避免了条件复杂性。客户统一使用真实的和无效的合作者。</li></ul></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="dacb" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">空对象模式—示例1:赛亚人的世界(问题)</h1><p id="7190" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">我现在将向您展示如何使用JavaScript/TypeScript实现这种模式。在应用该模式之前，意识到您试图解决的问题是很有趣的。接下来，我们将给出例子的上下文。假设我们有一个名为Saiyan的类，它将允许我们对我们亲爱的<strong class="ky ir"> Saiyan </strong>的属性和方法进行建模。这个类实现了一个ISaiyan接口，该接口清楚地确定了每个对象为了成为真正的<strong class="ky ir"> Saiyan </strong>而必须满足的特征。名为<code class="fe ls lt lu lv b">SaiyanFactory</code>的工厂用于创建<strong class="ky ir">赛亚人</strong>对象。这个类将我们从赛亚人的来源中抽象出来，可以从内存、数据库中的查询或制造新对象的复杂算法中生成。</p><p id="6ec3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">作为开发人员，我们的问题出现在充当客户端并使用我们工厂的类中。在下面的客户端代码中，我们调用了<code class="fe ls lt lu lv b">getSaiyan</code>方法来获取几个<strong class="ky ir">赛亚人</strong>，具体来说我们创建了<em class="lw">贝吉塔</em>、<em class="lw">鲍勃</em>、<em class="lw">小悟空</em>和<em class="lw">劳拉</em>。我明白，读者们知道，上一份名单中仅有的赛亚人是<em class="lw">贝吉塔</em>和<em class="lw">儿子悟空</em>；因此<em class="lw">鲍勃</em>和<em class="lw">劳拉</em>都不能被制造成赛亚人类型的物品。</p><p id="1d9b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们总是必须检查工厂返回的对象不是空对象，因为我们不确定工厂是否总是返回Saiyan类型的对象。</p><p id="0744" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终的代码有不必要的条件复杂性，因为在找到的每个对象上都有重复的代码片段<code class="fe ls lt lu lv b">if-else</code>。我知道这个代码片段可以用一个函数抽象出来，但是它仍然在代码中。</p><p id="a292" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们得到了下面的UML图。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/358dbd080936010e9930ae4f5e5c15fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*jP5UVnorQib13lnp.jpg"/></div></div></figure><p id="e508" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下一节中，我们将通过使用空对象模式来解决这个问题。</p><p id="cdb9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关联的<code class="fe ls lt lu lv b">ISayian</code>和<code class="fe ls lt lu lv b">Saiyan</code>代码如下:</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="6561" class="nz mf iq lv b gy oa ob l oc od">export <strong class="lv ir">interface</strong> <strong class="lv ir">ISaiyan</strong> {<br/>  name: <strong class="lv ir">string</strong>;<br/>  power: number;<br/>}<br/>/****/</span><span id="6310" class="nz mf iq lv b gy oe ob l oc od">import { ISaiyan } <strong class="lv ir">from</strong> './saiyan.interface';</span><span id="9c8f" class="nz mf iq lv b gy oe ob l oc od">export <strong class="lv ir">class</strong> <strong class="lv ir">Saiyan</strong> {<br/>  <strong class="lv ir">protected</strong> name: <strong class="lv ir">string</strong>;<br/>  <strong class="lv ir">protected</strong> power: number;</span><span id="a1a3" class="nz mf iq lv b gy oe ob l oc od">constructor({ name, power }: ISaiyan) {<br/>    <strong class="lv ir">this</strong>.name = name;<br/>    <strong class="lv ir">this</strong>.power = power;<br/>  }<br/>  getName(): <strong class="lv ir">string</strong> {<br/>    <strong class="lv ir">return</strong> <strong class="lv ir">this</strong>.name;<br/>  }</span><span id="f664" class="nz mf iq lv b gy oe ob l oc od"><strong class="lv ir">public</strong> <strong class="lv ir">toString</strong>(): <strong class="lv ir">string</strong> {<br/>    <strong class="lv ir">return</strong> `${<strong class="lv ir">this</strong>.name} - ${<strong class="lv ir">this</strong>.power}`;<br/>  }<br/>}</span></pre><p id="7856" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与作为数据库查找模拟的工厂相关联的代码如下:</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="1613" class="nz mf iq lv b gy oa ob l oc od">import { Saiyan } <strong class="lv ir">from</strong> './saiyan.class';</span><span id="6d5d" class="nz mf iq lv b gy oe ob l oc od">export <strong class="lv ir">class</strong> <strong class="lv ir">SaiyanFactory</strong> {<br/>  <strong class="lv ir">public</strong> saiyans = [<br/>    { name: 'Son Goku', power: 1000 },<br/>    { name: 'Son Gohan', power: 800 },<br/>    { name: 'Vegeta', power: 950 },<br/>  ];</span><span id="9181" class="nz mf iq lv b gy oe ob l oc od"><strong class="lv ir">public</strong> <strong class="lv ir">getSaiyan</strong>(name: <strong class="lv ir">string</strong>): Saiyan | null {<br/>    // Mock Database find<br/>    <strong class="lv ir">for</strong> (<strong class="lv ir">const</strong> saiyan of <strong class="lv ir">this</strong>.saiyans) {<br/>      <strong class="lv ir">if</strong> (saiyan.name === name) {<br/>        <strong class="lv ir">return</strong> <strong class="lv ir">new</strong> Saiyan(saiyan);<br/>      }<br/>    }<br/>    <strong class="lv ir">return</strong> null;<br/>  }<br/>}</span></pre><p id="268e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，与客户端相关联的代码，其中由于来自工厂的空对象，条件复杂度是指数级的。</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="8951" class="nz mf iq lv b gy oa ob l oc od"><strong class="lv ir">import</strong> { SaiyanFactory } <strong class="lv ir">from</strong> './saiyan-factory.class';</span><span id="30e4" class="nz mf iq lv b gy oe ob l oc od"><strong class="lv ir">const</strong> saiyanFactory = <strong class="lv ir">new</strong> SaiyanFactory();<br/><strong class="lv ir">const</strong> saiyan1 = saiyanFactory.getSaiyan('Vegeta');<br/><strong class="lv ir">const</strong> saiyan2 = saiyanFactory.getSaiyan('Bob');<br/><strong class="lv ir">const</strong> saiyan3 = saiyanFactory.getSaiyan('Son Goku');<br/><strong class="lv ir">const</strong> saiyan4 = saiyanFactory.getSaiyan('Laura');</span><span id="9981" class="nz mf iq lv b gy oe ob l oc od"><strong class="lv ir">console</strong>.log('Saiyan');<br/><strong class="lv ir">if</strong> (saiyan1 !== null) {<br/>  <strong class="lv ir">console</strong>.log(saiyan1.toString());<br/>} <strong class="lv ir">else</strong> {<br/>  <strong class="lv ir">console</strong>.log('Not Available in Customer Database');<br/>}<br/><strong class="lv ir">if</strong> (saiyan2 !== null) {<br/>  <strong class="lv ir">console</strong>.log(saiyan2.toString());<br/>} <strong class="lv ir">else</strong> {<br/>  <strong class="lv ir">console</strong>.log('Not Available in Customer Database');<br/>}<br/><strong class="lv ir">if</strong> (saiyan3 !== null) {<br/>  <strong class="lv ir">console</strong>.log(saiyan3.toString());<br/>} <strong class="lv ir">else</strong> {<br/>  <strong class="lv ir">console</strong>.log('Not Available in Customer Database');<br/>}<br/><strong class="lv ir">if</strong> (saiyan4 !== null) {<br/>  <strong class="lv ir">console</strong>.log(saiyan4.toString());<br/>} <strong class="lv ir">else</strong> {<br/>  <strong class="lv ir">console</strong>.log('Not Available in Customer Database');<br/>}</span></pre></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="00e4" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">空对象模式—示例1:赛亚人的世界(解决方案)</h1><p id="b83b" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">解决方案是使用null-ojbect模式。使用这种模式的新UML图如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/65428381c7a23d76f07fb68905ec3288.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*auv763DGmL0NhCJG.jpg"/></div></div></figure><p id="25b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从应用模式后我们感兴趣的结果开始。如果您遵守客户端代码，我们的赛亚人的四个请求所来自的工厂被保留。它们存储在变量中，因此这有助于我们避免在对每个Saiyan执行之前验证对象是否为空。在我们的例子中，我们使用<code class="fe ls lt lu lv b">toString</code>方法只是为了说明一个返回字符串的方法将要被排列。</p><p id="ac17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们消除了客户端的复杂性，这要归功于我们内部类结构的一个小变化。该工厂不是只使用一个生成新赛亚人的赛亚人类，而是从这个赛亚人类创建一个简单的继承(刚性组合)，产生两个新类<strong class="ky ir"> RealSaiyan </strong>和<strong class="ky ir"> NullSaiyan </strong>，将赛亚人类转换成一个抽象类。</p><p id="481e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Saiyan类现在定义了所有派生的Saiyan类必须实现的方法，在知识库中找到的Saiyan的逻辑将在<strong class="ky ir"> RealSaiyan </strong>类中实现，而没有找到的对象的逻辑(空)或者即使我们希望默认行为在<strong class="ky ir"> NullSaiyan </strong>类中实现。</p><p id="5185" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，总会有一种行为，即使他们没有把客户从不适用的复杂性中解放出来。</p><p id="f408" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在来看看实现这种模式所生成的代码:</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="75c0" class="nz mf iq lv b gy oa ob l oc od"><strong class="lv ir">import</strong> { SaiyanFactory } <strong class="lv ir">from</strong> './saiyan-factory.class';</span><span id="03c5" class="nz mf iq lv b gy oe ob l oc od"><strong class="lv ir">const</strong> saiyanFactory = <strong class="lv ir">new</strong> SaiyanFactory();<br/><strong class="lv ir">const</strong> saiyan1 = saiyanFactory.getSaiyan('Vegeta');<br/><strong class="lv ir">const</strong> saiyan2 = saiyanFactory.getSaiyan('Bob');<br/><strong class="lv ir">const</strong> saiyan3 = saiyanFactory.getSaiyan('Son Goku');<br/><strong class="lv ir">const</strong> saiyan4 = saiyanFactory.getSaiyan('Laura');</span><span id="afd6" class="nz mf iq lv b gy oe ob l oc od"><strong class="lv ir">console</strong>.log('Saiyan');<br/><strong class="lv ir">console</strong>.log(saiyan1.toString());<br/><strong class="lv ir">console</strong>.log(saiyan2.toString());<br/><strong class="lv ir">console</strong>.log(saiyan3.toString());<br/><strong class="lv ir">console</strong>.log(saiyan4.toString());</span></pre><p id="9650" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与工厂相关的代码返回两种对象，如下所示:</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="f909" class="nz mf iq lv b gy oa ob l oc od"><strong class="lv ir">import</strong> { AbstractSaiyan } <strong class="lv ir">from</strong> './saiyan.class';<br/><strong class="lv ir">import</strong> { NullSaiyan } <strong class="lv ir">from</strong> './null-saiyan.class';<br/><strong class="lv ir">import</strong> { RealSaiyan } <strong class="lv ir">from</strong> './real-saiyan.class';</span><span id="58f7" class="nz mf iq lv b gy oe ob l oc od"><strong class="lv ir">export</strong> <strong class="lv ir">class</strong> <strong class="lv ir">SaiyanFactory</strong> {<br/>  public saiyans = [<br/>    { name: 'Son Goku', power: 1000 },<br/>    { name: 'Son Gohan', power: 800 },<br/>    { name: 'Vegeta', power: 950 },<br/>  ];</span><span id="2598" class="nz mf iq lv b gy oe ob l oc od">public getSaiyan(name: string): AbstractSaiyan {<br/>    <strong class="lv ir">for</strong> (<strong class="lv ir">const</strong> saiyan <strong class="lv ir">of</strong> <strong class="lv ir">this</strong>.saiyans) {<br/>      <strong class="lv ir">if</strong> (saiyan.name === name) {<br/>        <strong class="lv ir">return</strong> <strong class="lv ir">new</strong> RealSaiyan(saiyan);<br/>      }<br/>    }<br/>    <strong class="lv ir">return</strong> <strong class="lv ir">new</strong> NullSaiyan();<br/>  }<br/>}</span></pre><p id="86e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与<code class="fe ls lt lu lv b">AbstractSaiyan</code>相关的代码如下:</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="0e52" class="nz mf iq lv b gy oa ob l oc od">export <strong class="lv ir">abstract</strong> <strong class="lv ir">class</strong> <strong class="lv ir">AbstractSaiyan</strong> {<br/>  <strong class="lv ir">protected</strong> name: <strong class="lv ir">string</strong>;<br/>  <strong class="lv ir">protected</strong> power: number;<br/>  <strong class="lv ir">public</strong> <strong class="lv ir">abstract</strong> <strong class="lv ir">getName</strong>(): <strong class="lv ir">string</strong>;<br/>  <strong class="lv ir">public</strong> <strong class="lv ir">abstract</strong> <strong class="lv ir">toString</strong>(): <strong class="lv ir">string</strong>;<br/>}</span></pre><p id="3347" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，与每个具体类相关的代码如下:</p><pre class="kg kh ki kj gt nv lv nw nx aw ny bi"><span id="50b6" class="nz mf iq lv b gy oa ob l oc od"><strong class="lv ir">import</strong> { AbstractSaiyan } <strong class="lv ir">from</strong> './saiyan.class';<br/><strong class="lv ir">import</strong> { Saiyan } <strong class="lv ir">from</strong> './saiyan.interface';</span><span id="5826" class="nz mf iq lv b gy oe ob l oc od"><strong class="lv ir">export</strong> <strong class="lv ir">class</strong> <strong class="lv ir">RealSaiyan</strong> <strong class="lv ir">extends</strong> <strong class="lv ir">AbstractSaiyan</strong> {<br/>  <strong class="lv ir">constructor</strong>({ name, power }: Saiyan) {<br/>    <strong class="lv ir">super</strong>();<br/>    <strong class="lv ir">this</strong>.name = name;<br/>    <strong class="lv ir">this</strong>.power = power;<br/>  }</span><span id="5952" class="nz mf iq lv b gy oe ob l oc od">getName(): string {<br/>    <strong class="lv ir">return</strong> <strong class="lv ir">this</strong>.name;<br/>  }<br/>  toString(): string {<br/>    <strong class="lv ir">return</strong> `${<strong class="lv ir">this</strong>.name} - ${<strong class="lv ir">this</strong>.power}`;<br/>  }<br/>}</span><span id="1059" class="nz mf iq lv b gy oe ob l oc od">import { AbstractSaiyan } <strong class="lv ir">from</strong> './saiyan.class';</span><span id="c834" class="nz mf iq lv b gy oe ob l oc od">export <strong class="lv ir">class</strong> <strong class="lv ir">NullSaiyan</strong> <strong class="lv ir">extends</strong> <strong class="lv ir">AbstractSaiyan</strong> {<br/>  <strong class="lv ir">public</strong> <strong class="lv ir">getName</strong>(): <strong class="lv ir">string</strong> {<br/>    <strong class="lv ir">return</strong> 'Not Available in Saiyan Database';<br/>  }<br/>  toString(): <strong class="lv ir">string</strong> {<br/>    <strong class="lv ir">return</strong> 'Not Available in Saiyan Database';<br/>  }<br/>}</span></pre><p id="4ff4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我创建了几个npm脚本，在应用了null-ojbect模式后，这些脚本运行这里显示的代码示例。</p><p id="22e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">npm run example1-problem</code>T12<code class="fe ls lt lu lv b">npm run example1-solution-1</code></p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="0289" class="me mf iq bd mg mh mi mj mk ml mm mn mo jw mp jx mq jz mr ka ms kc mt kd mu mv bi translated">结论</h1><p id="ceee" class="pw-post-body-paragraph kw kx iq ky b kz mw jr lb lc mx ju le lf my lh li lj mz ll lm ln na lp lq lr ij bi translated">空对象模式可以避免项目中的条件复杂性。<br/>这种模式允许您在没有对象的情况下配置默认行为，从而不必坚持检查对象是否为空。</p><p id="3f20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种模式使用简单的继承来解决出现的问题。然而，这种模式被归类为本博客所研究的另一种模式的特例:<a class="ae kv" href="https://medium.com/better-programming/design-patterns-using-the-strategy-pattern-in-javascript-3c12af58fd8a" rel="noopener"> <strong class="ky ir">策略模式</strong> </a>。</p><p id="e8b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，可以说这种模式使用刚性组合(继承)来解决一个问题，这个问题可以用组合来解决，但是会导致比它所解决的问题更复杂的问题。这是一个很好的例子，说明我们作为开发人员的每一个“工具”都必须在正确的时间使用，而在我们的行业中最重要的事情是了解所有的工具以及我们应该何时使用它们。</p><p id="2a8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最重要的事情不是实现我所展示的模式，而是能够识别这个特定模式可以解决的问题，以及何时可以或不可以实现所述模式。这一点至关重要，因为实现会因您使用的编程语言而异。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h2 id="ff5a" class="nz mf iq bd mg og oh dn mk oi oj dp mo lf ok ol mq lj om on ms ln oo op mu oq bi translated">更多阅读</h2><ul class=""><li id="af33" class="nc nd iq ky b kz mw lc mx lf ne lj nf ln ng lr nt ni nj nk bi translated">设计模式:可重用的面向对象软件的元素</li><li id="1451" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nt ni nj nk bi translated">【Sourcemaking.com T2】号</li><li id="7da1" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nt ni nj nk bi translated"><a class="ae kv" href="https://en.wikipedia.org/wiki/Null_object_pattern" rel="noopener ugc nofollow" target="_blank">空对象模式——维基百科</a>。</li><li id="bf74" class="nc nd iq ky b kz nl lc nm lf nn lj no ln np lr nt ni nj nk bi translated"><a class="ae kv" href="https://www.geeksforgeeks.org/null-object-design-pattern/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/null-object-design-pattern/</a></li></ul></div></div>    
</body>
</html>