<html>
<head>
<title>Simple Ways To Speed Up Your React App</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">加速React应用程序的简单方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/simple-ways-to-speed-up-your-react-app-10cf9b553b84?source=collection_archive---------7-----------------------#2020-07-06">https://javascript.plainenglish.io/simple-ways-to-speed-up-your-react-app-10cf9b553b84?source=collection_archive---------7-----------------------#2020-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/473e16abdb4586cb784a65afa32645e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*t9V_KXxRJtZv9ZPQ.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image by <a class="ae kc" href="https://pixabay.com/users/ProDexorite-823142/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=967011" rel="noopener ugc nofollow" target="_blank">ProDexorite</a> from <a class="ae kc" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=967011" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="dd6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React可以说是最简单的UI库。但是这种轻松是有代价的，那就是性能。在本文中，我将列出一些方法来大幅提高React应用程序的性能。</p><h1 id="30f7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用钥匙！</h1><p id="ccfb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这可能是显而易见的，但却是势在必行的。如果你以列表的形式渲染任何东西(使用<code class="fe me mf mg mh b">.map</code>，或者类似<code class="fe me mf mg mh b">FlatList</code>的东西)，React会使用键来优化重新渲染。如果你错过了键，或者，更糟糕的是，使它们不唯一，不仅你的应用程序将运行缓慢，而且可能导致一些令人沮丧的错误。所以，这段代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6be9" class="mq lc iq mh b gy mr ms l mt mu">data.map(item =&gt; &lt;SomeComponent item={item} /&gt;)</span></pre><p id="c897" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变成了:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a0ce" class="mq lc iq mh b gy mr ms l mt mu">data.map(item =&gt; &lt;SomeComponent key={item.id} item={item} /&gt;)</span></pre><p id="4367" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能想使用索引作为键:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c245" class="mq lc iq mh b gy mr ms l mt mu">data.map((item, index) =&gt; &lt;SomeComponent key={index} item={item} /&gt;)</span></pre><p id="0c60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我打断你一下。只有当<code class="fe me mf mg mh b">data</code>中的项目从未被重新排列、删除或插入时，这才会起作用。即使现在是这种情况，想想未来的几个步骤:你需要在几个冲刺阶段变异<code class="fe me mf mg mh b">data</code>吗？我想是的。</p><h1 id="fe44" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用虚拟列表！</h1><p id="3495" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">与前一点密切相关，这适用于需要呈现大量列出的数据的情况。React和React本地项目都有一些提供类似功能的库。虚拟化列表的工作方式是，只呈现当前在视口中可见的几个项目，其他所有项目都在滚动时缓慢(按需)呈现。</p><p id="ed6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在React中，对于稍微复杂一点的用例，您的选择是<code class="fe me mf mg mh b"><a class="ae kc" href="https://github.com/bvaughn/react-window" rel="noopener ugc nofollow" target="_blank">react-window</a></code>和<code class="fe me mf mg mh b"><a class="ae kc" href="https://github.com/bvaughn/react-virtualized" rel="noopener ugc nofollow" target="_blank">react-virtualized</a></code>。例如，使用<code class="fe me mf mg mh b">react-window</code>会将这段代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4546" class="mq lc iq mh b gy mr ms l mt mu">data.map(item =&gt; &lt;SomeComponent key={item.id} item={item} /&gt;);</span></pre><p id="496e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变成这样:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e776" class="mq lc iq mh b gy mr ms l mt mu">const Row = ({index}) =&gt; &lt;SomeComponent item={data[index]} /&gt; </span><span id="03b0" class="mq lc iq mh b gy mv ms l mt mu">// later, in render <br/>return ( <br/>  &lt;List height={150} itemCount={data.length}&gt; {Row} &lt;/List&gt; <br/>);</span></pre><p id="fc3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在你可以在<code class="fe me mf mg mh b">data</code>中拥有尽可能多的物品，而不用担心它们会永远呈现出来！</p><p id="307f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在React Native中，使用了内置的<code class="fe me mf mg mh b">FlatList</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e5bd" class="mq lc iq mh b gy mr ms l mt mu">&lt;FlatList <br/>  data={data}<br/>  renderItem={({item}) =&gt; &lt;SomeComponent item={item} /&gt;} <br/>/&gt;</span></pre><h1 id="d947" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用React profiler！</h1><p id="99e9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果在实现了上述两种技术之后，您仍然对React应用程序的性能不满意，请考虑使用React profiler。它会准确地告诉你什么重新渲染，什么时候，需要多长时间，最重要的是，是什么导致了重新渲染。</p><p id="3511" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React profiler内置于React devtools扩展中，因此，很可能您已经安装了它。如果没有，<a class="ae kc" href="https://addons.mozilla.org/en-CA/firefox/addon/react-devtools/" rel="noopener ugc nofollow" target="_blank">头这里</a>。不幸的是，对于React本地开发人员来说，没有简单的方法可以做到这一点。有两种方法可以分析React本机应用程序:</p><ol class=""><li id="d884" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">打开手机/模拟器上的开发菜单(shake/Ctrl+M)并按下<em class="nf">启用性能叠加</em>。它将提供一个小窗口，显示UI和JS线程的当前FPS，以及跳过的帧数。使用它，你可以大致知道问题出在哪里。</li><li id="2da6" class="mw mx iq kf b kg ng kk nh ko ni ks nj kw nk la nb nc nd ne bi translated">Android用<code class="fe me mf mg mh b">systrace</code>，IOS用XCode。这些都是低级工具，需要一些高级设置。这超出了本文的范围，所以<a class="ae kc" href="https://reactnative.dev/docs/profiling" rel="noopener ugc nofollow" target="_blank">阅读此</a>以了解更多。</li></ol><h1 id="b235" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用useMemo！</h1><p id="c458" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">很有可能，你正在你的应用中做一些数据处理。有可能，您不必在每次重新呈现时都重新处理它。<code class="fe me mf mg mh b">useMemo</code>就是专门为此设计的。</p><p id="3991" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">useMemo</code>接受一个函数和一个依赖列表。然后，它会记住函数返回的值，除非其中一个依赖关系发生变化，否则不会再次调用该函数。例如:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="57e3" class="mq lc iq mh b gy mr ms l mt mu">const importantData = useMemo(() =&gt; calculateImportantData(rawData, [rawData]);</span></pre><p id="9ca8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想了解更多关于<code class="fe me mf mg mh b">useMemo</code>的信息，可以<a class="ae kc" href="https://everyday.codes/javascript/react-usememo-and-when-you-should-use-it/" rel="noopener ugc nofollow" target="_blank">阅读我的文章</a>详细解释。</p><h1 id="75bb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用React并发模式？</h1><p id="1a28" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">小心行事。React并发模式是对React内部机制的重大改写，它允许异步呈现和多个虚拟DOM树。它提供了巨大的性能提升，但是这个特性仍然是实验性的，不适合生产应用。点击阅读更多关于它如何工作以及如何启用它的信息<a class="ae kc" href="https://everyday.codes/javascript/everything-you-need-to-know-about-react-concurrent-mode-in-2020/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="1da1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结束语</h1><p id="a78a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">感谢您的阅读，我希望您学到了一些关于优化React代码的新知识。敬请关注更多内容！</p><h1 id="bb78" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">资源</h1><ul class=""><li id="962b" class="mw mx iq kf b kg lz kk ma ko nl ks nm kw nn la no nc nd ne bi translated"><a class="ae kc" href="https://reactnative.dev/docs/performance" rel="noopener ugc nofollow" target="_blank"> React本机性能概述</a></li><li id="3ada" class="mw mx iq kf b kg ng kk nh ko ni ks nj kw nk la no nc nd ne bi translated"><a class="ae kc" href="https://medium.com/better-programming/how-the-react-reconciliation-algorithm-works-e29bf77a4d78" rel="noopener">React协调算法如何工作</a></li><li id="3967" class="mw mx iq kf b kg ng kk nh ko ni ks nj kw nk la no nc nd ne bi translated"><a class="ae kc" href="https://medium.com/javascript-in-plain-english/everything-you-need-to-know-about-react-concurrent-mode-in-2020-826af48c1f37" rel="noopener">反应并发模式</a></li></ul><h2 id="4da8" class="mq lc iq bd ld np nq dn lh nr ns dp ll ko nt nu lp ks nv nw lt kw nx ny lx nz bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="98bc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>