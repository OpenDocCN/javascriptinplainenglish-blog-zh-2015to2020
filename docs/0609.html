<html>
<head>
<title>How to construct Tree data using recursive mechanism with RxJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用RxJS的递归机制构造树形数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-construct-tree-data-using-recursive-mechanism-with-rxjs-b838127b39ac?source=collection_archive---------2-----------------------#2019-11-15">https://javascript.plainenglish.io/how-to-construct-tree-data-using-recursive-mechanism-with-rxjs-b838127b39ac?source=collection_archive---------2-----------------------#2019-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1c2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这篇博客中，我们将看到如何借助RxJS的递归机制将树节点的平面数据转换成树数据结构。</p><blockquote class="kl km kn"><p id="b408" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">理想情况下，UI应该由来自后端服务的数据驱动，但有时服务可能无法促进用户界面的预期，因此我们必须在UI中的状态/数据转换上做出妥协。</p></blockquote><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/e30313972a7214b8bbbb28e296932c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*57992hgfwWglX3LZ3aOXow.png"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Data Collection vs Tree</figcaption></figure><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="li lj l"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Data we receive from service for Tree conversion</figcaption></figure><p id="3474" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从服务端接收一个键值对对象，其中<code class="fe lk ll lm ln b">key</code>代表记录的唯一标识符，<code class="fe lk ll lm ln b">value</code>代表数据模型。</p><p id="9c28" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在处理完数据后，我们的最终状态应该是，</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="li lj l"/></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">tree data</figcaption></figure><p id="4df1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们开始编写代码，首先让我们尝试将数据转换成<a class="ae lo" href="https://codeburst.io/reactive-streams-are-so-simple-4105378f4c59" rel="noopener" target="_blank">流</a></p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="c46b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这里的<code class="fe lk ll lm ln b">getFromServer</code>方法中，我们传递根节点的标识符，并将数据转换成可观察值。</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="7a5e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们一步步讨论<code class="fe lk ll lm ln b">getRecursive</code>方法的功能，</p><ol class=""><li id="f4a7" class="lp lq iq jp b jq jr ju jv jy lr kc ls kg lt kk lu lv lw lx bi translated">我们用记录的唯一标识符调用方法<code class="fe lk ll lm ln b">getFromServer</code>，并进一步用下面的操作符<code class="fe lk ll lm ln b">map</code>、<code class="fe lk ll lm ln b">flatMap</code>、<code class="fe lk ll lm ln b">forkJoin</code>、<code class="fe lk ll lm ln b">tap</code>来管理它</li><li id="497a" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><code class="fe lk ll lm ln b">map</code>将类型<code class="fe lk ll lm ln b">FlatTreeData </code>的数据转换为<code class="fe lk ll lm ln b">{parent: {name: string; id: number;children:Array&lt;number&gt;}}</code>我们将子对象重置为空数组，因为管道中的未来操作符会分配相应的子对象。</li><li id="9a56" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><code class="fe lk ll lm ln b">forkJoin</code>用于累加父节点和该父节点的所有子节点，因为来自<code class="fe lk ll lm ln b">getFromServer</code>方法的响应是可观察的。我们使用了<code class="fe lk ll lm ln b">forkJoin</code></li><li id="6570" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><code class="fe lk ll lm ln b">flatMap</code>用于处理高阶可观测值。这里，我们需要将内部可观察对象展平，即从<code class="fe lk ll lm ln b">forkJoin(parentStream, ...childrenStreams)</code>到<code class="fe lk ll lm ln b">[parent, …children]</code>的响应</li><li id="9eec" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated"><code class="fe lk ll lm ln b">tap</code>用于更新从<code class="fe lk ll lm ln b">parent</code>对象中的rest操作符获得的<code class="fe lk ll lm ln b">children</code>属性</li><li id="aacf" class="lp lq iq jp b jq ly ju lz jy ma kc mb kg mc kk lu lv lw lx bi translated">最后，在<code class="fe lk ll lm ln b">map</code>中，我们析构了父类和角色类型<code class="fe lk ll lm ln b">TreeData</code></li></ol><p id="4cb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">完整的例子在这里-</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="md lj l"/></div></figure><p id="f8fc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢阅读。快乐编码👍🏽</p></div></div>    
</body>
</html>