<html>
<head>
<title>Create A Medium-like Modal with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React创建一个类似介质的模型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/medium-like-modal-with-reactjs-3a0db7c0d38c?source=collection_archive---------2-----------------------#2020-07-30">https://javascript.plainenglish.io/medium-like-modal-with-reactjs-3a0db7c0d38c?source=collection_archive---------2-----------------------#2020-07-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="57c8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何在React中创建一个全页的基本模型？射流研究…</h2></div><p id="1a46" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在web应用程序的上下文中，模态是一个漂亮的工具，它可以呈现信息，而不必强迫用户从当前网页导航。在这篇文章中，我们大胆地</p><ol class=""><li id="0ef8" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">使用React创建一个模态。</li><li id="2f81" class="ky kz in ke b kf lh ki li kl lj kp lk kt ll kx ld le lf lg bi translated">让情态看起来像是媒介用来寻求确认的令人愉快的情态。</li></ol><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/52598fc72917d84b45d4965216e0f63b.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/1*UwanUefSWX4o9TLE3mfMUA.gif"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">source: Giphy</figcaption></figure><h1 id="99a0" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">什么是模态？</h1><p id="25d5" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">模式视图是显示在宿主窗口顶部的独特视图。模态可以用来服务于多种用例，从呈现信息或错误到以授权墙或付费墙的形式阻止用户。</p><p id="af11" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模态独立于宿主窗口或视图。这使得模态成为一个典型的可重用组件。这篇文章的目的是模仿Medium使用的最小情态动词之一。下面是我们将尝试镜像的模型的图像。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi mv"><img src="../Images/472e135052809f1b55c3d1ab2638b067.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FEpyZvFDwMcIuMxNDHUyqw.png"/></div></div></figure><h1 id="ac67" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">第1部分:在React中创建一个模型</h1><p id="f9b2" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">我们首先使用<code class="fe na nb nc nd b">create-react-app</code>创建一个React应用程序，转到您的终端或命令提示符，导航到首选目录并键入</p><p id="97a3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe na nb nc nd b">npx create-react-app medium-modal-mimic</code></p><p id="cae8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这应该会创建一个React项目。用您最喜欢的IDE打开项目。</p><h2 id="aeea" class="ne lz in bd ma nf ng dn me nh ni dp mi kl nj nk mk kp nl nm mm kt nn no mo np bi translated">1.1使用主机组件-app . js</h2><p id="0892" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">宿主组件或宿主窗口是将在自身上呈现模式的实体。一旦应用程序被创建，移动到<code class="fe na nb nc nd b">src/App.js</code>并移除除了顶部容器<code class="fe na nb nc nd b">div</code>之外的所有东西。你的<code class="fe na nb nc nd b">App.js</code>应该如下图所示</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="c567" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，移动到<code class="fe na nb nc nd b">App.css</code>并遵循类似的模式，删除除<code class="fe na nb nc nd b">App</code>以外的所有样式</p><p id="4be2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对<code class="fe na nb nc nd b">App</code>类进行以下更改。我们已经使我们的主机屏幕采取全屏高度。由于<code class="fe na nb nc nd b">align-items</code>和<code class="fe na nb nc nd b">justify-content</code>的缘故，这个div中的任何内容都将居中</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="dcf0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">移回<code class="fe na nb nc nd b">App.js</code>并在<code class="fe na nb nc nd b">div</code>中添加一个按钮，如下图所示。请确保在页面中央看到这个按钮。</p><pre class="ln lo lp lq gt ns nd nt nu aw nv bi"><span id="3b85" class="ne lz in nd b gy nw nx l ny nz">&lt;div className="App"&gt;<br/>    <!-- -->&lt;button&gt;Toggle Modal&lt;/button&gt;<br/>&lt;/div&gt;</span></pre><p id="f96d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模态的可见性将取决于状态变量。你需要使用<code class="fe na nb nc nd b">useState</code>钩子来创建一个状态变量。这个状态变量决定了我们模态的命运。</p><p id="4112" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从导入<code class="fe na nb nc nd b">App.js</code>中的<code class="fe na nb nc nd b">useState</code>开始</p><p id="dc73" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe na nb nc nd b">import React, {useState} from 'React';</code></p><p id="ba4a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在App组件中，创建一个状态变量。状态变量<code class="fe na nb nc nd b">showModal</code>的初始值将被设置为<strong class="ke io"> false </strong>，因为您不希望在页面首次加载时显示模式。</p><pre class="ln lo lp lq gt ns nd nt nu aw nv bi"><span id="b1bc" class="ne lz in nd b gy nw nx l ny nz">function App() {</span><span id="2e40" class="ne lz in nd b gy oa nx l ny nz">const [showModal, setShowModal] = useState(false);</span><span id="074b" class="ne lz in nd b gy oa nx l ny nz">.....</span><span id="2a52" class="ne lz in nd b gy oa nx l ny nz">}</span></pre><p id="96e8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，您需要一个函数来改变这个状态变量的值。为了实现这一点，您应该创建如下所示的函数</p><pre class="ln lo lp lq gt ns nd nt nu aw nv bi"><span id="c7b9" class="ne lz in nd b gy nw nx l ny nz">const toggleModal = () =&gt; {</span><span id="ce8b" class="ne lz in nd b gy oa nx l ny nz">    setShowModal(<strong class="nd io">!</strong>showModal);</span><span id="d1f3" class="ne lz in nd b gy oa nx l ny nz">}</span></pre><p id="9de1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当调用上面的函数时，状态变量<code class="fe na nb nc nd b">showModal</code>的值被反转。请注意！在showModal前面。showModal的初始值被设置为false。当第一次单击按钮时，这个函数将被执行，showModal的取反值(恰好为真)将被赋给状态变量。</p><p id="c14e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，您尚未将按钮与功能连接。除非你这样做，否则这不会生效。要在点击按钮时调用<code class="fe na nb nc nd b">toggleModal</code>功能，向您的按钮添加一个<code class="fe na nb nc nd b">onClick</code>，如下所示</p><p id="5a3f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe na nb nc nd b">&lt;button onClick={toggleModal}&gt; Toggle modal&lt;/button&gt;</code></p><p id="9e1f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你一直跟着做，你的主机窗口已经设置好了，你应该有一个类似下面的<code class="fe na nb nc nd b">App.js</code></p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">App.js</figcaption></figure><h2 id="7321" class="ne lz in bd ma nf ng dn me nh ni dp mi kl nj nk mk kp nl nm mm kt nn no mo np bi translated">1.2进入对话的核心——模态</h2><p id="eb9f" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">现在，您需要创建模态组件。在<code class="fe na nb nc nd b">src</code>目录下，创建一个名为<code class="fe na nb nc nd b">Modal</code>的新目录，在模态目录下，创建一个新文件<code class="fe na nb nc nd b">index.js</code>这个文件将包含我们想要显示的模态组件。</p><p id="0731" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于这个模态的范围是只显示<strong class="ke io">一个标题、一个副标题和两个按钮，</strong>我们将在模态视图中提取这些属性。这些属性稍后将由主机(<code class="fe na nb nc nd b">App.js</code>)传递给这个模态组件。</p><pre class="ln lo lp lq gt ns nd nt nu aw nv bi"><span id="1d2e" class="ne lz in nd b gy nw nx l ny nz">const { showModal, <br/>        onClose, <br/>        onAction, <br/>        titleForCloseButton="Cancel", <br/>        titleForActionButton="Delete", <br/>        title = "Missing Title", <br/>        subtitle = ""} = <em class="ob">props</em>;</span></pre><h2 id="2d13" class="ne lz in bd ma nf ng dn me nh ni dp mi kl nj nk mk kp nl nm mm kt nn no mo np bi translated">1.2.1了解道具</h2><p id="8de0" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated"><strong class="ke io"> showModal </strong>是状态变量标志，它决定了模态是可见还是隐藏。我们在和<code class="fe na nb nc nd b">App.js</code>一起工作的时候创造了这个</p><p id="74c8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> onClose </strong>是一个事件处理程序，当你想关闭模态时应该调用它。如果你一直在关注，你会注意到你已经在<code class="fe na nb nc nd b">App.js</code>中编写的<em class="ob"> toggleModal </em>函数中实现了这一点，你需要将对toggleModal函数的引用传递给onClose属性。</p><p id="07a4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> onAction </strong>是当单击主按钮时您想要调用的操作处理程序。</p><p id="c091" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们暂时还没用过这些。但是，这些可以用来定制按钮标题。关闭按钮的<strong class="ke io">标题</strong>和动作按钮的<strong class="ke io">标题</strong>分别是这些按钮的标题。如果没有为这些按钮传递值，它们将分别采用默认值<em class="ob">【取消】</em>和<em class="ob">【删除】</em>。</p><p id="b558" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">标题</strong>和<strong class="ke io">副标题</strong>字段是不言自明的。需要注意的是，我们还没有通过道具。我们将在随后的一个部分中完成这项工作。</p><h2 id="0696" class="ne lz in bd ma nf ng dn me nh ni dp mi kl nj nk mk kp nl nm mm kt nn no mo np bi translated">1.2.2设计莫代尔风格</h2><p id="69e8" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">此外，您需要有条件地呈现模态。如果showModal的标志为true，则返回一个模态视图。模态视图将具有<em class="ob">全宽和全高</em>。它将有一个95% 不透明度的<em class="ob">白色背景。因为您希望它显示时与主窗口没有关联，所以这个模态的位置必须是绝对的。</em></p><p id="2184" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，您可能希望它总是在主机的顶部，并且您可能希望有一个更高值的z索引，比如说9？这大致编译成下面的一组CSS样式</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="a57e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在您的模态组件中，使用模态类在div中创建一个按钮来关闭模态。稍后，这将以取消按钮的形式出现。我们还需要创建两个跨度来保存标题和副标题。在这一点上，我们不会担心美学，因为我们将在以后处理CSS。</p><p id="8bc6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果<code class="fe na nb nc nd b">shouldShow</code>为真，我们将用<code class="fe na nb nc nd b">modal</code>类有条件地渲染这个<code class="fe na nb nc nd b">div</code>。在另一种情况下，我们将返回一个带有<code class="fe na nb nc nd b">display:none</code>的<code class="fe na nb nc nd b">div</code></p><pre class="ln lo lp lq gt ns nd nt nu aw nv bi"><span id="46cc" class="ne lz in nd b gy nw nx l ny nz">const MyModal = (<em class="ob">props</em>) =&gt; {</span><span id="c3c0" class="ne lz in nd b gy oa nx l ny nz">   const {shouldShow, <br/>          onClose, <br/>          title = "Missing Title", <br/>          subtitle = ""} = <em class="ob">props</em>;</span><span id="850a" class="ne lz in nd b gy oa nx l ny nz">   return shouldShow === true <br/>            ?<br/>            &lt;div <em class="ob">className</em>="modal"&gt;<br/>              &lt;span <em class="ob">className</em>="title"&gt;{title}&lt;/span&gt;<br/>              &lt;span <em class="ob">className</em>="subtitle"&gt;{subtitle}&lt;/span&gt;<br/>              &lt;button <em class="ob">onClick</em>={onClose} <em class="ob">className</em>="close"&gt;Close&lt;/button&gt;<br/>            &lt;/div&gt; <br/>             : <br/>            &lt;div <em class="ob">style</em>={{display: 'none'}}&gt;&lt;/div&gt;</span><span id="7c07" class="ne lz in nd b gy oa nx l ny nz">}</span></pre><h2 id="88bc" class="ne lz in bd ma nf ng dn me nh ni dp mi kl nj nk mk kp nl nm mm kt nn no mo np bi translated">1.2.3连接点..</h2><p id="dc70" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">回到<code class="fe na nb nc nd b">App.js</code>，把需要的道具传给模特。更新后的<code class="fe na nb nc nd b">App.js</code>应该如下图所示。</p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="e702" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果一切顺利，您应该会有如下结果。</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/68b330cfe7b6b516207911b55504078b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*yU2vLkbcXjM74lZC9o6FZQ.gif"/></div></figure><h1 id="8968" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">第二部分:让它看起来像媒介的模态</h1><p id="6db0" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">现在我们已经有了一个工作模式，让我们试着模仿一下中间模式。</p><h2 id="e7d3" class="ne lz in bd ma nf ng dn me nh ni dp mi kl nj nk mk kp nl nm mm kt nn no mo np bi translated">最初印象</h2><p id="abd6" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">我最初印象的主要部分围绕着三个非常直接的观察。</p><ol class=""><li id="c025" class="ky kz in ke b kf kg ki kj kl la kp lb kt lc kx ld le lf lg bi translated">与许多常见的模态不同，这个模态没有定义明确的内容容器。作为参考，看看下面的维基百科模式。有一个单独的部分包含内容，在这个例子中是消息表单，背景有一个半透明的黑色阴影，目的是使主网页散焦。</li></ol><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi od"><img src="../Images/d540fde5903d81b746370b1e7ecafcad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*li1KYZeA1S8PabGgy0xrng.png"/></div></div><figcaption class="lu lv gj gh gi lw lx bd b be z dk">Wikipedia modal with a central focused element.</figcaption></figure><p id="a531" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">2.这个模态有一个最小的白色背景和一些透明度(透明度5%/alpha 95%)。我们在使用<code class="fe na nb nc nd b">modal.css</code>的时候已经完成了</p><p id="0a75" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">3.内容居中。</p><p id="bae6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">了解了所有的背景和观察之后，下一个合理的行动是卷起袖子，修改一些CSS。</p><h2 id="9ddf" class="ne lz in bd ma nf ng dn me nh ni dp mi kl nj nk mk kp nl nm mm kt nn no mo np bi translated">2.1字体</h2><p id="4178" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">根据<a class="ae oe" href="https://qr.ae/pNsa1A" rel="noopener ugc nofollow" target="_blank">这个</a> Quora的回答，Medium使用<em class="ob"> Charter </em>和<em class="ob"> Kievit </em>字体。在检查标题元素时，我发现了这个</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div class="gh gi of"><img src="../Images/3986cf0c2307991b3235832d2721c421.png" data-original-src="https://miro.medium.com/v2/resize:fit:1292/format:webp/1*ixBdE-4cTpwANqYPZXi5VQ.png"/></div></figure><p id="b126" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不过一个<a class="ae oe" href="https://medium.design/cast-of-characters-17eaa82755cf" rel="noopener ugc nofollow" target="_blank">中帖</a>，一个<a class="ae oe" href="https://qr.ae/pNsa1V" rel="noopener ugc nofollow" target="_blank">异Quora回答</a>和一个<a class="ae oe" href="https://www.reddit.com/r/web_design/comments/6a5kvd/where_to_find_mediumcontentseriffont_and_why_are/" rel="noopener ugc nofollow" target="_blank"> Reddit跟帖</a>证实了这是ITC Charter字体。字体可以在 <em class="ob">这里找到<a class="ae oe" href="https://www.myfonts.com/fonts/itc/charter/" rel="noopener ugc nofollow" target="_blank">。</a></em></p><p id="b2fa" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了在模态中使用这种字体，我们使用CSS <code class="fe na nb nc nd b">@font-face</code>，就像下面的<code class="fe na nb nc nd b">modal.css</code></p><pre class="ln lo lp lq gt ns nd nt nu aw nv bi"><span id="ba50" class="ne lz in nd b gy nw nx l ny nz">@font-face {<br/>  font-family: 'ModalFont';<br/>  <!-- -->src: url('../assets/CharterBold.ttf');<br/>}</span></pre><p id="af59" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还在同一个CSS文件中使用了这个字体。除了设置字体系列，我们还添加了一些视觉属性，如字体大小、边距和颜色。</p><pre class="ln lo lp lq gt ns nd nt nu aw nv bi"><span id="ca5d" class="ne lz in nd b gy nw nx l ny nz">.title{<br/>font-size: 2rem;<br/>color: #000;<br/>margin-bottom: 1rem;<br/>font-family: 'ModalFont';<br/>}</span></pre><p id="1797" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">类似地，对于字幕跨度，检查时，</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi og"><img src="../Images/cad16286afebe45bec6d3694f80791fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pfg2CNQWCF8K1cT0Gtwsbg.png"/></div></div></figure><p id="1d03" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们发现字体是一样的，但是字体颜色是#757575。这使得我们的字幕有如下风格</p><pre class="ln lo lp lq gt ns nd nt nu aw nv bi"><span id="c684" class="ne lz in nd b gy nw nx l ny nz">.subtitle{<br/>font-size: 1rem;<br/>font-family:'ModalFont';<br/>margin-bottom: 3rem;<br/>color: #757575;<br/>}</span></pre><p id="c25f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我们没有完全抄袭Medium的模式，我们将跳过确切的字体大小、边距等。就在应用字体之后，我们的模态开始看起来和Medium的相似</p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi oh"><img src="../Images/a5cc04fe495c24d27fbfc87b1622abf5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FR5ff5VJ_pNGyl1DqSXEcw.png"/></div></div></figure><h2 id="2a32" class="ne lz in bd ma nf ng dn me nh ni dp mi kl nj nk mk kp nl nm mm kt nn no mo np bi translated">2.2按钮</h2><p id="d82c" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">我们将为按钮使用两种不同的样式。第一个样式组决定按钮的视觉效果，第二个样式组添加特定于动作按钮的视觉效果。在<code class="fe na nb nc nd b">modal.css</code></p><pre class="ln lo lp lq gt ns nd nt nu aw nv bi"><span id="24b6" class="ne lz in nd b gy nw nx l ny nz">.btn{<br/>padding: 0.6rem 1rem;<br/>font-family: 'ModalSubtFont';<br/>border-radius: 4px;<br/>font-size: 1rem;<br/>margin:0.3rem<br/>}</span><span id="0f51" class="ne lz in nd b gy oa nx l ny nz">.action-btn{<br/>color:#FFF;<br/>background-color:#CC5454;<br/>border: 1px solid #CC5454;<br/>}</span><span id="c8a3" class="ne lz in nd b gy oa nx l ny nz">.dismiss-btn{<br/>color:#292929;<br/>background-color:transparent;<br/>border: 1px solid #292929;<br/>}</span></pre><p id="ecbe" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而在<code class="fe na nb nc nd b">modal/index.js</code></p><pre class="ln lo lp lq gt ns nd nt nu aw nv bi"><span id="d108" class="ne lz in nd b gy nw nx l ny nz">&lt;div <em class="ob">className</em>="btns"&gt;<br/>  &lt;button <em class="ob">onClick</em>={onClose} <em class="ob">className</em>="btn action-btn"&gt;Delete&lt;/button&gt;&lt;button <em class="ob">className</em>="btn dismiss-btn"&gt;Cancel&lt;/button&gt;<br/>&lt;/div&gt;</span></pre><p id="b48d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在上面的代码片段中，我们还引入了一个名为<code class="fe na nb nc nd b">btns</code>的CSS类，它充当flex-direction列的包装器。这是并排放置按钮所需要的。</p><p id="1805" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还编写了一个CSS类<code class="fe na nb nc nd b">content-wrapper</code>，将内容包装在屏幕中央。这个类可以方便地进行微妙的改变，比如给内容添加边框。这将在下面演示。</p><p id="a7b8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> A .无边框内容包装</strong></p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi oi"><img src="../Images/c5f180c9aa3727c6d516d2899f501c8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rwX-8UDdpR5I6l92rMkbtw.png"/></div></div></figure><p id="a479" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> B .带边框的内容包装</strong></p><figure class="ln lo lp lq gt lr gh gi paragraph-image"><div role="button" tabindex="0" class="mw mx di my bf mz"><div class="gh gi oj"><img src="../Images/0a1b182b844089116bf63a8d493c5f66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ieFxLKkAvjuCYDrg8M2pQ.png"/></div></div></figure><p id="2a6d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完成<code class="fe na nb nc nd b">modal.css</code></p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="67a5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完整的<code class="fe na nb nc nd b">modal/index.js</code></p><figure class="ln lo lp lq gt lr"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="3c95" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">结论</h1><p id="e0f5" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">按照计划，我们可以创建一个类似于媒体的模型。然而，这个模型仍然有点粗略，可以做得更好。当我们将道具从主机传递到模态时，我们缩小了这个模态的范围。这可以通过使用道具来解决</p><h2 id="961d" class="ne lz in bd ma nf ng dn me nh ni dp mi kl nj nk mk kp nl nm mm kt nn no mo np bi translated">简单英语的JavaScript</h2><p id="562b" class="pw-post-body-paragraph kc kd in ke b kf mq jo kh ki mr jr kk kl ms kn ko kp mt kr ks kt mu kv kw kx ig bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae oe" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="ke io">！</strong></p></div></div>    
</body>
</html>