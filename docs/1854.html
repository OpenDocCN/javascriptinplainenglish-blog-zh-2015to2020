<html>
<head>
<title>Understanding Regular Expressions Part 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解正则表达式第1部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/regular-expressions-part-i-6965172168f8?source=collection_archive---------12-----------------------#2020-04-28">https://javascript.plainenglish.io/regular-expressions-part-i-6965172168f8?source=collection_archive---------12-----------------------#2020-04-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="ea6f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简介</h2></div><p id="a59b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">亲爱的读者，我要对你说实话。我讨厌正则表达式。对我来说，它们很复杂，而且在许多方面令人困惑。我总是通过使用替代品来尽力避免使用它们。对我来说，即使是一组复杂的嵌套条件也比一行正则表达式更好，我必须用头撞墙才能最终得到正确的模式。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lb"><img src="../Images/13f4565efbd57d9a95d0606a3cf859f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/1*Q6-EY9Ze7HwdKmZJmMZ68g.gif"/></div></figure><p id="0306" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管如此，我还是决定打败正则表达式这个存在主义怪物。正如老话所说，千里之行始于足下。我向你保证这将是一个漫长的旅程。然而，就像处理任何其他似乎超出你能力的复杂话题一样，我们必须一步一步来。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/aa6dd7bb15f3655792037fc287a1b064.png" data-original-src="https://miro.medium.com/v2/resize:fit:900/1*3b-Ms_Y7rHYOYPNTBXKusw.gif"/></div></figure><h1 id="19e3" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated">创建简单的正则表达式</h1><p id="63a0" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">让我们从创建一个简单的正则表达式开始，看看它是如何解决问题的。在JavaScript中，可以通过两种方式创建正则表达式:使用RegExp构造函数或创建文字。下面两行显示了用模式“abc”双向创建一个正则表达式。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mh"><img src="../Images/f7d695bbf9d2f6ebf48f5b2105b18903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RTul8Sw7djQxQWiDlk8GeA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">Defining a regular expression object and literal</figcaption></figure><p id="268e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些是最简单的正则表达式。一个是作为正则表达式对象创建的，另一个是文字。这两个都是表示字符串模式的模式，即“a”紧接着“b”，紧接着“c”。为了了解这些表达式是如何工作的以及它们的用途，让我们来看看为正则表达式显式开发的方法。</p><p id="6ce5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript提供了许多将正则表达式应用于字符串的方法。下面是一个简单的列表:</p><ol class=""><li id="0b5d" class="mq mr iq kh b ki kj kl km ko ms ks mt kw mu la mv mw mx my bi translated"><strong class="kh ir"> Exec: </strong>在字符串中搜索正则表达式模式，并返回第一个匹配文本的数组、匹配开始的索引、下一个匹配开始的索引(如果有)以及带括号的子字符串匹配(如果有)。</li><li id="f82c" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated"><strong class="kh ir"> Replace: </strong>在字符串中搜索正则表达式模式，并用给定的子字符串替换该模式。它返回null或带有替换项的新字符串。</li><li id="052a" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated"><strong class="kh ir"> Match: </strong> Like exec match返回一个匹配数组。主要的区别在于，这个方法作用于字符串本身，而不是正则表达式，即String.prototype.match()。</li><li id="2ffa" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated"><strong class="kh ir"> matchAll: </strong>类似于match，只是它返回所有匹配模式的结果的迭代器，包括捕获组。</li><li id="1106" class="mq mr iq kh b ki mz kl na ko nb ks nc kw nd la mv mw mx my bi translated"><strong class="kh ir"> Test: </strong>如果在字符串中找到正则表达式的匹配项，则返回true，否则返回false。</li></ol><h1 id="8707" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated"><strong class="ak">简单测试</strong></h1><p id="50bb" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">现在，让我们关注这些方法中最基本的<strong class="kh ir">测试</strong>。只有在字符串中找到匹配项时，它才返回true。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ne"><img src="../Images/0b8a2682a44fc83beb31daf067bb721d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AdSoB_UJlf2CvZujGSrXtg.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">test method applied to simple strings</figcaption></figure><p id="2afd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">结果并不令人惊讶。该函数在第一个字符串中找到“abc”的匹配项，并返回true而在第二个字符串中没有找到匹配。此外，我们可以看到，测试方法将正则表达式文字和对象视为相同。如果我们改变字母的顺序呢？</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi nf"><img src="../Images/d8e26d5238c8c59580ea4693e8fa0917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LT_mZUndup-DVUzQaJ-7EQ.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">letters are now out of order</figcaption></figure><p id="9f1e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">匹配字母</strong></p><p id="fffb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设你只是想看看一个字符串是否包含字母a、b和c，但不关心顺序。为此，我们需要匹配字符串中出现的单个字符，而不管它们的位置。让我们重新加载控制台并重新定义正则表达式。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mh"><img src="../Images/d746cdda072e74e9fd714af8d8a4a10b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z8uDo4rmRfNv-LKlzZyVBA.png"/></div></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk">introducing the brackets</figcaption></figure><p id="97d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将这些字母用括号括起来会创建一个隐含的OR，意思是查找与这些字符中的任何一个匹配。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi ng"><img src="../Images/9813a57b6c7d8fb7d489b886871548d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X0cBxPi-4TWrurYUiHu2ow.png"/></div></div></figure><p id="90be" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从上面看，我们可以看到该方法成功地找到了a、b或c的匹配项。换句话说，该函数表示，如果您可以在该字符串中的任何位置找到a、b或c，1次或多次将返回true。这是一个需要把握的重要区别，因为它将在我们将来处理更复杂的模式时帮助我们。</p><p id="feeb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir">时代</strong></p><p id="f1a6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们通过修改这个问题把它提高一个档次。如果我们想在字符串中找到一个字符特定的次数呢？让我们回过头来，把注意力集中在一个字母“a”上来回答这个问题。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="gh gi mh"><img src="../Images/88830af8240ada5bf33e6b809fef2b58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iv_aGOXyTZoAM4O6j6IRpg.png"/></div></div></figure><p id="c4ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面，我们用{}为两个a编写了一个正则表达式搜索。这些{}可以用{x}表示x次，或者用{x，}表示x次或更多次，或者用{，x}表示0到x次。该测试方法查找两次匹配“a”或“aa”第一个和最后一个结果有意义。第二个回答可能令人费解。似乎应该返回false，因为子字符串是' aaa '然而，这并不是测试函数的工作方式。一旦在字符串中找到第一个匹配项，该函数就返回true，而不再进一步查找。所以第三个‘a’被忽略了。稍后，我们将研究解决这个问题的方法。</p><h1 id="6541" class="lk ll iq bd lm ln lo lp lq lr ls lt lu jw lv jx lw jz lx ka ly kc lz kd ma mb bi translated"><strong class="ak">结论</strong></h1><p id="2c11" class="pw-post-body-paragraph kf kg iq kh b ki mc jr kk kl md ju kn ko me kq kr ks mf ku kv kw mg ky kz la ij bi translated">JavaScript正则表达式提供了识别字符串中特定字符模式的能力。JavaScript提供了几种在字符串上使用正则表达式的方法:match、matchAll、exec、replace和test。函数match、matchAll和exec返回一个匹配数组。Replace查找模式匹配并用子字符串替换它。其中最简单的是，如果存在匹配，test简单地返回true。方括号[]允许test查找那些括号中的任何字符的匹配。{}括号指定了这些字符应该重复的精确次数或次数范围。</p><p id="a85d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本系列的下一部分中，我们将研究更复杂的正则表达式，以获得更通用的匹配模式。</p></div></div>    
</body>
</html>