<html>
<head>
<title>JavaScript Algorithms: Find All Duplicates in an Array (LeetCode)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法:查找数组中的所有重复项(LeetCode)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-algorithms-find-all-duplicates-in-an-array-leetcode-fb7b8c01a93a?source=collection_archive---------3-----------------------#2020-11-29">https://javascript.plainenglish.io/javascript-algorithms-find-all-duplicates-in-an-array-leetcode-fb7b8c01a93a?source=collection_archive---------3-----------------------#2020-11-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2f648845af9d10d615affa718f6c29a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yH7sxLzc1bp5rFPo"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@bthjnr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Beth Jnr</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a7b5" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">描述</h1><p id="c6ac" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">给定一个整数数组，1≤a[I]≤<em class="lw">n</em>(<em class="lw">n</em>=数组大小)，有些元素出现<strong class="la io">两次</strong>，有些出现<strong class="la io">一次</strong>。</p><p id="42d5" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">找出在这个数组中出现两次的<strong class="la io">的所有元素。</strong></p><p id="7e3b" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">你能在没有额外空间的情况下在O( <em class="lw"> n </em>)运行时完成吗？</p><p id="414d" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated"><strong class="la io">例如:</strong></p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><h1 id="52aa" class="ka kb in bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated">解决办法</h1><p id="c1ce" class="pw-post-body-paragraph ky kz in la b lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我想到的第一个解决方案是两个嵌套的for循环:</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/bfb500a1241bc7c9ae221d2174fcbd16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F9F7dbTAPUXd__Z_sdWAEw.png"/></div></div></figure><p id="61c6" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">时间复杂度为<code class="fe mj mk ml mm b">O(n²)</code>，空间复杂度为<code class="fe mj mk ml mm b">O(1)</code>。然而，我们需要用线性时间复杂度来实现。</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><p id="d338" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">我想到的第二个解决方案是用一个<code class="fe mj mk ml mm b">map</code>来计算所有的字符，然后循环遍历它，把所有大于<code class="fe mj mk ml mm b">1</code>的字符推到<code class="fe mj mk ml mm b">result</code>。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mu"><img src="../Images/51f4713b350bba09d83616b690f7974b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C2ZDf7QcnY8PhfP4v-ztJA.png"/></div></div></figure><p id="7ae4" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">时间复杂度是<code class="fe mj mk ml mm b">O(n)</code>，空间复杂度也是。我们已经做到了，但仍然不够好。让我们考虑一下如何在没有额外内存的情况下，用线性时间来求解…</p><figure class="mc md me mf gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/f0972d789efe5ec10ebd5763ec991360.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4iW9AouxNPDvRCRf"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@fabrizioverrecchia?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fabrizio Verrecchia</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="356d" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">提示在上面的描述中。<code class="fe mj mk ml mm b">Given an array of integers, 1 ≤ a[i] ≤ n</code> <em class="lw">。如果我们从T7开始，我们可以说T8是这个项目的索引。因此，让我们想象我们有一个从<code class="fe mj mk ml mm b">1</code>开始的索引数组。我们如何找到所有只出现两次的元素？我们可以标记每个<code class="fe mj mk ml mm b">nums[index]</code>它们的负拷贝。正如我们决定的那样<code class="fe mj mk ml mm b">index</code>将会是<code class="fe mj mk ml mm b">nums[i]</code>。</em></p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="7708" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">我知道，这看起来很棘手。让我们用<strong class="la io">例子1: </strong>来看看这个解决方案</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="5d30" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">时间复杂度是线性的，空间复杂度是常数。</p><p id="d519" class="pw-post-body-paragraph ky kz in la b lb lx ld le lf ly lh li lj lz ll lm ln ma lp lq lr mb lt lu lv ig bi translated">我希望，它对你有用。感谢阅读！期待您的反馈。回头见，✌️</p></div></div>    
</body>
</html>