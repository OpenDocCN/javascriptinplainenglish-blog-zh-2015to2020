<html>
<head>
<title>Why I Love The Spread Operator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么我喜欢传播运营商</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-i-love-the-spread-operator-58f396dbbb78?source=collection_archive---------6-----------------------#2020-08-26">https://javascript.plainenglish.io/why-i-love-the-spread-operator-58f396dbbb78?source=collection_archive---------6-----------------------#2020-08-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="aa20" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">ES6最有用的JavaScript特性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/da9ae9b9d41023ed9ec7d2533e9b25f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3yUaO3J7RU6vTMSH"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@seimesa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mario Mesaglio</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9fa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在过去的几年里，JavaScript的语法和功能有了很大的改进，增加了许多新特性。</p><p id="fe87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些新特性中最有用的一个是<strong class="ky ir">扩展操作符<em class="ls">(又名…操作符)</em> </strong></p><p id="dce5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Spread非常有用，但是它的语法乍一看并不特别有意义。它并没有告诉你它是做什么的。幸运的是，一旦你学会了Spread的三个主要用途，它将成为JS工具箱中你最喜欢的工具之一！</p><p id="1ef9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">根据MDN: </em> </strong>“扩展语法允许在预期零个或多个参数(用于函数调用)或元素(用于数组文字)的地方扩展可迭代对象，如数组表达式或字符串，或者在预期零个或多个键值对(用于对象文字)的地方扩展对象表达式。”</p><p id="8ea6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有三个地方可以使用spread:</p><ol class=""><li id="93e9" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">函数调用</li><li id="0976" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">数组文字</li><li id="bae1" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">对象文字</li></ol><h1 id="dc40" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">传播和功能</h1><p id="4cbc" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">当向函数传递参数时，我们可以使用spread来扩展iterable元素。我们可以将每一项作为参数“展开”,而不必单独传递每一个参数。</p><p id="019b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ne nf ng nh b"><strong class="ky ir">Math.min</strong></code> <strong class="ky ir"> </strong>是一个接受任意数量的参数并返回最小值的函数。如果我们想找到一个数组的最小值，将整个数组传入是行不通的:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="8cd2" class="nm mi iq nh b gy nn no l np nq">const temperatures = [76,72,68,79,54,65];</span><span id="0263" class="nm mi iq nh b gy nr no l np nq">Math.min(temperatures)</span><span id="fca6" class="nm mi iq nh b gy nr no l np nq">//Result<br/>▶ NaN</span></pre><p id="dac6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，我们可以使用spread来扩展数组，将每个元素作为参数传入:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="e7d7" class="nm mi iq nh b gy nn no l np nq">const temperatures = [<strong class="nh ir">76,72,68,79,54,65</strong>];<br/>Math.min(...temperatures) <br/>//the same as Math.min(<strong class="nh ir">76,72,68,79,54,65</strong>)</span><span id="90f0" class="nm mi iq nh b gy nr no l np nq">//Result<br/>▶ 54</span></pre><p id="9513" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里还有一个使用<code class="fe ne nf ng nh b">console.log</code>的例子。如果我们将整个数组传递给<code class="fe ne nf ng nh b">console.log</code></p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="61c4" class="nm mi iq nh b gy nn no l np nq">const tvShows = ["<strong class="nh ir">Six Feet Under", "Chernobyl", "Black Mirror", "Fleabag</strong>" ] <br/>console.log(tvShows);</span></pre><p id="c624" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们所看到的:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="c86e" class="nm mi iq nh b gy nn no l np nq">▶(4) ["Six Feet Under", "Chernobyl", "Black Mirror", "Fleabag"]</span></pre><p id="547d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">整个数组被视为一个参数。如果我们使用Spread，我们最终会将四个参数传递给<code class="fe ne nf ng nh b">console.log</code></p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="ef7f" class="nm mi iq nh b gy nn no l np nq">const tvShows = ["<strong class="nh ir">Six Feet Under", "Chernobyl", "Black Mirror", "Fleabag</strong>" ]</span><span id="54d3" class="nm mi iq nh b gy nr no l np nq">//I can pass each element in tvShows as a separate argument using spread: console.log(...tvShows);</span><span id="1ccd" class="nm mi iq nh b gy nr no l np nq">▶ Six Feet Under Chernobyl Black Mirror Fleabag</span></pre></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="b458" class="mh mi iq bd mj mk nz mm mn mo oa mq mr jw ob jx mt jz oc ka mv kc od kd mx my bi translated">展开和数组文字</h1><h2 id="69ef" class="nm mi iq bd mj oe of dn mn og oh dp mr lf oi oj mt lj ok ol mv ln om on mx oo bi translated"><strong class="ak">组合数组</strong></h2><p id="c301" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">我们还可以使用spread语法，利用现有的数组创建新的数组。例如，要合并两个数组，我们可以这样做:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="b483" class="nm mi iq nh b gy nn no l np nq">const parents = [<strong class="nh ir">"Lorie", "John"</strong>]; <br/>const kids = ["<strong class="nh ir">Jackson", "Ana", "Jessy</strong>"];  <br/>const fullFamily = <strong class="nh ir">[...parents, ...kids]</strong>;</span><span id="ee07" class="nm mi iq nh b gy nr no l np nq">▶ //[<strong class="nh ir">"Lorie", "John", "Jackson", "Ana", "Jessy"</strong>]</span></pre><p id="7e07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在给定的表达式中，我们可以任意多次使用spread。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="6749" class="nm mi iq nh b gy nn no l np nq">const parents = [<strong class="nh ir">"Lorie", "John"</strong>]; <br/>const kids = ["<strong class="nh ir">Jackson", "Ana", "Jessy</strong>"]; <br/>const dogs = ["<strong class="nh ir">Olie", "Cosmo"</strong>];<br/>const fullFamily = <strong class="nh ir">[...parents, ...kids, "Me", ...dogs, "Unnamed Turtle"];</strong></span><span id="49f2" class="nm mi iq nh b gy nr no l np nq">▶ //[<strong class="nh ir">"Lorie", "John", "Jackson", "Ana", "Jessy", "Me", "Olie", "Cosmo", "Unnamed Turtle</strong>"]</span></pre><h2 id="dc89" class="nm mi iq bd mj oe of dn mn og oh dp mr lf oi oj mt lj ok ol mv ln om on mx oo bi translated">复制数组</h2><p id="fd1d" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">Spread也常用于创建数组的副本。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="edc4" class="nm mi iq nh b gy nn no l np nq">const originals = [<strong class="nh ir">"Mona Lisa", "American Gothic", "The School of Athens"</strong>]; <br/>const copies = <strong class="nh ir">[...originals]</strong>;  <br/>originals.push("Nighthawks"); <br/>console.log(copies);</span><span id="95a1" class="nm mi iq nh b gy nr no l np nq">▶ ["Mona Lisa", "American Gothic", "The School of Athens"]</span></pre><p id="7d3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">重要提示:复制数组时，展开仅深入“一级”。它不执行嵌套数组的深度复制！</em></p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="2f55" class="mh mi iq bd mj mk nz mm mn mo oa mq mr jw ob jx mt jz oc ka mv kc od kd mx my bi translated">跨页和对象文字</h1><p id="aef3" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">就像使用数组一样，我们可以使用spread来组合现有的对象:</p><p id="606c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以对对象做同样的事情，我们可以将现有对象的属性复制到新对象中。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="2bd6" class="nm mi iq nh b gy nn no l np nq">const lion = {hasTail: true, legs: 4}; <br/>const eagle = {canFly: true }; <br/>const hybrid = {name: "Gryphon", ...lion, ...eagle};</span><span id="0194" class="nm mi iq nh b gy nr no l np nq">▶//{name: "Gryphon", hasTail: true, legs: 4, canFly: true}</span></pre></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><h1 id="c3aa" class="mh mi iq bd mj mk nz mm mn mo oa mq mr jw ob jx mt jz oc ka mv kc od kd mx my bi translated">扩散和不变性</h1><p id="76eb" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">现在这里还有最后一个话题，这真的很重要，它与您为什么应该关注这个问题有关，我将使用<strong class="ky ir"> React的示例。</strong></p><p id="4fd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在像<strong class="ky ir"> React </strong>这样的框架中，重要的是不要改变特定的数据(特别是状态)。由于React的编写方式，直接在状态中更新arrays &amp;对象可能会导致应用程序在应该呈现或重新呈现时无法呈现的问题。在这种情况下，你会经常看到Spread。</p><p id="f886" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个简单的例子说明<strong class="ky ir">不要做什么</strong>。我们有一个数组<code class="fe ne nf ng nh b">todos</code>，我们想在数组的末尾添加一个新的todo。“简单”的方法是简单地推进到<code class="fe ne nf ng nh b">todos</code> <strong class="ky ir">，但是这会改变数组！</strong></p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="f87a" class="nm mi iq nh b gy nn no l np nq">const todos = [  <br/>{user: "Brick", completed: false, task: "Upload Video"},  <br/>{user: "Lilith", completed: true, task: "Rob Bank"} <br/>]</span><span id="2802" class="nm mi iq nh b gy nr no l np nq">function addTodo(newTodo){   <br/>todos.push(newTodo); <br/>}</span></pre><p id="9a10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们有一个函数叫做<code class="fe ne nf ng nh b">addTodo</code>这是非常幼稚的<code class="fe ne nf ng nh b">addTodo</code>。在那里我们有一个<code class="fe ne nf ng nh b">todos</code>阵列。每一个都是你认为添加新待办事项最简单的方法就是按下<code class="fe ne nf ng nh b">todos</code>键，这就成功了！这本身没有问题，但是如果这是为<strong class="ky ir"> React </strong>或类似的框架编写的，我们不希望<strong class="ky ir">改变</strong>我们的数据结构。</p><p id="4a84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与其直接改变<code class="fe ne nf ng nh b">todos</code>数组，我们不如复制一个<code class="fe ne nf ng nh b">todos</code>数组，它也包含添加在末尾的<code class="fe ne nf ng nh b">newTodo</code>。传播使这变得相对容易:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="0f30" class="nm mi iq nh b gy nn no l np nq">const todos = [  <br/>{user: "Brick", completed: false, task: "Upload Video"},  <br/>{user: "Lilith", completed: true, task: "Rob Bank"} <br/>]</span><span id="c999" class="nm mi iq nh b gy nr no l np nq">function addTodo(newTodo){   <br/>return [...todos, {...newTodo, completed: false}] <br/>}</span><span id="0ded" class="nm mi iq nh b gy nr no l np nq">const newTodos = addTodo({user: "Mordecai", task: "Feed Bloodwing"});</span></pre><p id="0de1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以这样做，所以我们有同样的数组叫做<code class="fe ne nf ng nh b">todos</code>，但是这次的<code class="fe ne nf ng nh b">addTodo</code> a函数有点不同。在本例中，它返回一个数组，我们将所有现有的<code class="fe ne nf ng nh b">todos</code>分布到这个数组中。然后在数组的末尾，我们添加一个新的对象。</p><p id="168b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在如果我调用<code class="fe ne nf ng nh b">addTodo</code>并传递一个对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/98c6077df384541a4de735a73a159f79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1282/format:webp/1*wQMZE_yzRi9eKqL8p0nWMg.png"/></div></figure><p id="1f49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你会注意到<code class="fe ne nf ng nh b">todos</code>本身没有更新。我没有变异<code class="fe ne nf ng nh b">todos</code></p><p id="ee82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们做的是创建一个新的数组。</p><p id="d42d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样！希望你喜欢这篇文章，它有助于你的发展。你也可以看我的其他文章。</p><div class="oq or gp gr os ot"><a href="https://medium.com/javascript-in-plain-english/should-i-use-map-or-foreach-in-javascript-af9da3b4adc3" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">JavaScript中应该用map()还是forEach()。</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">了解何时使用哪种类型的数组方法</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph kp ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://medium.com/javascript-in-plain-english/make-eye-catching-javascript-popups-with-sweet-alert-470e05ed026d" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">用“甜蜜警告”制作引人注目的JavaScript弹出窗口</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">一个吸引人的用户界面，你可以更好地提醒</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph kp ot"/></div></div></a></div><p id="a875" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">继续学习！快乐编码👩‍💻</p></div></div>    
</body>
</html>