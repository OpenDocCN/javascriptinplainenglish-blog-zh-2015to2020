<html>
<head>
<title>JavaScript Interview Questions — Functions and Scope</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript面试问题—功能和范围</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-interview-questions-functions-and-scope-8c8793f2ef5d?source=collection_archive---------6-----------------------#2020-03-13">https://javascript.plainenglish.io/javascript-interview-questions-functions-and-scope-8c8793f2ef5d?source=collection_archive---------6-----------------------#2020-03-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/30961745931b3fe2657cab068d54e97a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CHE9-fW2o7Wj5UVn"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@louishansel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Louis Hansel</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6743" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了得到一份前端开发人员的工作，我们需要搞定编码面试。</p><p id="c95d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些基本的函数和范围问题。</p><h1 id="7480" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是吊装？</h1><p id="035a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">提升意味着一个变量或函数被移动到我们定义该变量或函数的范围的顶部。</p><p id="5eb6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScripts将函数声明移动到它们的作用域的顶部，我们可以在以后引用它们，并获取所有的变量声明，给它们赋值<code class="fe me mf mg mh b">undefined</code>。</p><p id="223f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在执行过程中，被提升的变量被赋值或运行函数。</p><p id="24fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有用关键字<code class="fe me mf mg mh b">var</code>声明的函数声明和变量被提升。</p><p id="ad6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe me mf mg mh b">let</code>和<code class="fe me mf mg mh b">const</code>常量声明的变量不会被提升。此外，箭头函数和函数表达式不会被提升。</p><p id="3bc1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，下面的代码有一个被提升的函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bc6f" class="mq lc iq mh b gy mr ms l mt mu">foo();</span><span id="f0a1" class="mq lc iq mh b gy mv ms l mt mu">function foo(){<br/> console.log('foo')<br/>}</span></pre><p id="b6f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">foo</code>被提升了，所以它可以在被定义之前被调用，因为它是一个函数声明。</p><p id="17e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的变量声明被挂起:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="60fe" class="mq lc iq mh b gy mr ms l mt mu">console.log(x);<br/>var x = 1;<br/>console.log(x);</span></pre><p id="f20a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自<code class="fe me mf mg mh b">var x</code>升起后第一个<code class="fe me mf mg mh b">console.log</code>输出<code class="fe me mf mg mh b">undefined</code>。</p><p id="e3ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当<code class="fe me mf mg mh b">var x = 1</code>运行时，<code class="fe me mf mg mh b">x</code>被设置为1。然后我们在第二个<code class="fe me mf mg mh b">console.log</code>中记录1，因为<code class="fe me mf mg mh b">x</code>之前设置了它的值。</p><p id="0a45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他的都不吊了。</p><h1 id="af58" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是范围？</h1><p id="c0c5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript的作用域是我们可以有效访问变量或函数的区域。</p><p id="c94f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript中有三种作用域——全局、函数和块作用域。</p><p id="a26f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具有全局范围的变量和函数在脚本或模块文件中的任何地方都是可访问的。</p><p id="fb37" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以声明一个全局变量，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c4fc" class="mq lc iq mh b gy mr ms l mt mu">var global = 'global';</span><span id="a317" class="mq lc iq mh b gy mv ms l mt mu">const foo = () =&gt; {<br/>  console.log(global);<br/>  const bar = () =&gt; {<br/>    console.log(global);<br/>  }<br/>  bar();<br/>}<br/>foo();</span></pre><p id="d239" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们在代码顶部声明了一个带有<code class="fe me mf mg mh b">var</code>的变量，所以它在任何地方都是可访问的。所以两个<code class="fe me mf mg mh b">console.log</code>都将输出<code class="fe me mf mg mh b">'global'</code>。</p><p id="c2ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数作用域的变量只在函数内部可用。</p><p id="8eb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下定义一个函数范围的变量:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f210" class="mq lc iq mh b gy mr ms l mt mu">const foo = () =&gt; {<br/>  var fooString = 'foo';<br/>  console.log(fooString);<br/>  const bar = () =&gt; {<br/>    console.log(fooString);<br/>  }<br/>  bar();<br/>}<br/>foo();</span><span id="19b9" class="mq lc iq mh b gy mv ms l mt mu">console.log(fooString);</span></pre><p id="b297" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有函数作用域的变量<code class="fe me mf mg mh b">fooString</code>。它也是用<code class="fe me mf mg mh b">var</code>声明的，在<code class="fe me mf mg mh b">foo</code>函数和嵌套的<code class="fe me mf mg mh b">bar</code>函数中都可用。</p><p id="091e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们将用<code class="fe me mf mg mh b">foo</code>函数中的2个<code class="fe me mf mg mh b">console.log</code>语句记录<code class="fe me mf mg mh b">‘foo’</code>。</p><p id="d808" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">底部的<code class="fe me mf mg mh b">console.log</code>给了我们一个错误，因为函数范围内的变量在函数之外是不可用的。</p><p id="e623" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">块范围的变量仅在块内部可用。也就是说，在<code class="fe me mf mg mh b">if</code>块、功能块、循环或显式定义的块中。由花括号分隔的任何内容都是块。</p><p id="954b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们要么用<code class="fe me mf mg mh b">let</code>定义，要么用<code class="fe me mf mg mh b">const</code>定义，这取决于它是变量还是常数。</p><p id="3426" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6312" class="mq lc iq mh b gy mr ms l mt mu">if (true) {<br/>  let x = 1;<br/>  console.log(x);<br/>}</span><span id="4a1f" class="mq lc iq mh b gy mv ms l mt mu">console.log(x);</span></pre><p id="8e77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">x</code>只在<code class="fe me mf mg mh b">if</code>块内可用。底部的<code class="fe me mf mg mh b">console.log</code>给了我们一个<code class="fe me mf mg mh b">x is not defined</code>错误。</p><p id="1026" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，如果我们有一个循环:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d44f" class="mq lc iq mh b gy mr ms l mt mu">for (let i = 0; i &lt;= 1; i++) {<br/>  let x = 1;<br/>  console.log(x);<br/>}</span><span id="4327" class="mq lc iq mh b gy mv ms l mt mu">console.log(x);</span></pre><p id="14a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">x</code>只在循环内部可用。底部的<code class="fe me mf mg mh b">console.log</code>给了我们一个<code class="fe me mf mg mh b">x is not defined</code>错误。</p><p id="776c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以显式定义一个块，以便将变量与外部隔离开来:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ef65" class="mq lc iq mh b gy mr ms l mt mu">{<br/>  let x = 1;<br/>  console.log(x);<br/>}</span><span id="5e5b" class="mq lc iq mh b gy mv ms l mt mu">console.log(x);</span></pre><p id="32f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">x</code>将只在花括号内可用。底部的<code class="fe me mf mg mh b">console.log</code>会给我们一个错误。</p><p id="8560" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">范围决定了JavaScript在多大程度上寻找一个变量。如果它不存在于当前作用域中，那么它将在外部作用域中查找。</p><p id="27d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它在外部作用域中找到它，并且它以一种我们可以访问变量的方式被声明，那么它将获得那个值。</p><p id="6d9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，如果找不到它，我们就会得到一个错误。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/8418af18079f1b1a9b1bf8c6358156c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aT62CazC3Lj_Lg6z"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@meaxgang?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">MEAX</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e318" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是闭包？</h1><p id="8880" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">闭包是记住当前作用域和全局作用域的变量和参数的函数。</p><p id="cef4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，当内部函数可用于外部函数之外的任何范围时。</p><p id="640c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用它以受限的方式公开私有函数或数据。</p><p id="9962" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下闭包函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="613a" class="mq lc iq mh b gy mr ms l mt mu">const foo = (() =&gt; {<br/>  let x = 'Joe';<br/>  const privateFn = () =&gt; {<br/>    alert(`hello ${x}`);<br/>  }</span><span id="4b4c" class="mq lc iq mh b gy mv ms l mt mu">  return {<br/>    publicFn() {<br/>      privateFn();<br/>    }<br/>  }<br/>})();</span><span id="8dc0" class="mq lc iq mh b gy mv ms l mt mu">foo.publicFn();</span></pre><p id="9379" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有一个(立即调用的函数表达式)IIFE，它运行一个函数，该函数返回一个具有<code class="fe me mf mg mh b">publicFn</code>属性的对象，该属性被设置为调用<code class="fe me mf mg mh b">privateFn</code>的函数，该函数对外部是隐藏的。</p><p id="c55d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，调用<code class="fe me mf mg mh b">privateFn</code>时在函数内部声明了<code class="fe me mf mg mh b">x</code>。</p><p id="49f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在将返回的对象赋给<code class="fe me mf mg mh b">foo</code>后调用<code class="fe me mf mg mh b">publicFn</code>。</p><p id="30a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这段代码实现的是，我们将私有项隐藏在一个闭包内，同时将我们想要公开的内容公开给外部。</p><p id="8e3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，闭包让我们持有驻留在对外部不可用的范围内的项目，同时我们可以公开在闭包之外可以使用的内容。</p><p id="dd5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">闭包的一个主要用途是保持一些实体的私有性，同时向外部公开必要的功能。</p><h1 id="c7c1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="cbad" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">提升是在编译期间将函数和变量拉到代码的顶部。</p><p id="cb77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">函数声明是完全提升的，用<code class="fe me mf mg mh b">var</code>声明的变量在赋值提升之前拥有一切。</p><p id="500a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作用域是指一段代码可以有效访问变量或常量的地方。</p><p id="2ef2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">闭包是一种返回内部函数的方法，其中包含了外部函数的一些实体。这对于在公开某些功能的同时保持某些东西的私密性是很有用的。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><h2 id="4413" class="mq lc iq bd ld ne nf dn lh ng nh dp ll ko ni nj lp ks nk nl lt kw nm nn lx no bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="95e7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们总是有兴趣帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，请用你的中级用户名在<a class="ae kc" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">submissions@javascriptinplainenglish.com</a>给我们发电子邮件，我们会把你添加为作者。</p></div></div>    
</body>
</html>