<html>
<head>
<title>Ultimate Authentication using GraphQL Nexus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL Nexus的终极身份验证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/ultimate-authentication-using-graphql-nexus-ec01f79dff2c?source=collection_archive---------1-----------------------#2020-08-27">https://javascript.plainenglish.io/ultimate-authentication-using-graphql-nexus-ec01f79dff2c?source=collection_archive---------1-----------------------#2020-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/1f419487a582ab1c70862f13908a5dbc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ggf4CoLksFbvWcjXMGzQsg.png"/></div></div></figure><div class=""/><div class=""><h2 id="3e72" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">如何为您的应用程序制作最终的身份验证样板。我们将使用graphql-nexus和prisma作为我们的ORM。</h2></div><p id="a38c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">本教程要求您了解GraphQL查询、变异和上下文。</p><h2 id="bd23" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated">本教程涵盖以下内容:</h2><ol class=""><li id="9f00" class="mf mg jb ks b kt mh kw mi kz mj ld mk lh ml ll mm mn mo mp bi translated">注册用户</li><li id="50a8" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">帐户激活</li><li id="5ca4" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">登录用户</li><li id="c6fe" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">密码重置</li><li id="cf92" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">脸书登录</li><li id="add2" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">谷歌登录</li><li id="a17a" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">管理员角色(删除用户，获取所有用户)</li><li id="cd74" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">获取当前用户</li></ol><h2 id="ccbd" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated">身份验证和授权需要以下软件包:</h2><ol class=""><li id="7650" class="mf mg jb ks b kt mh kw mi kz mj ld mk lh ml ll mm mn mo mp bi translated">bcrypt:这个包用来散列我们密码</li><li id="5eb5" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">jsonwebtoken:这个包使用加密有效载荷，返回用于认证的令牌，我们还可以配置这个令牌持续多长时间。</li><li id="2b6e" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">node-fetch:这个包用来发出一个获取请求</li><li id="e0ea" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">nodemailer:这个包用来发送电子邮件</li><li id="ab4a" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">graphql-middleware:这个包使用中间件来管理多个解析器上附加功能。</li><li id="e5db" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">graphql-shield:这个包有助于为您的应用程序创建一个权限中间件。</li></ol><h2 id="f2cc" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">安装这些软件包</strong></h2><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="33eb" class="lm ln jb na b gy ne nf l ng nh">yarn add bcrypt jsonwebtoken node-fetch nodemailer graphql-middleware graphql-shield google-auth-library</span></pre><h2 id="57d1" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">在这个用户模式中</strong></h2><ol class=""><li id="1559" class="mf mg jb ks b kt mh kw mi kz mj ld mk lh ml ll mm mn mo mp bi translated">id和电子邮件是唯一的</li><li id="64e5" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">不像facebook和google那样每个用户都需要密码。</li><li id="81bf" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">ResetPasswordToken用于在重置密码时检查令牌是否过期</li><li id="2e10" class="mf mg jb ks b kt mq kw mr kz ms ld mt lh mu ll mm mn mo mp bi translated">isAdmin默认设置为false</li></ol><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="8d10" class="lm ln jb na b gy ne nf l ng nh">type User {<br/>  id: ID! @id<br/>  name: String!<br/>  email: String! @unique<br/>  password: String<br/>  isAdmin: Boolean @default(value: false)<br/>  resetPasswordToken: String @default(value: "")<br/>  createdAt: DateTime! @createdAt<br/>  updatedAt: DateTime! @updatedAt<br/>}<br/></span></pre><h2 id="94f1" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">在GraphQL服务器中定义上下文</strong></h2><p id="b60a" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">我们必须为它创建一个上下文类型</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="9f29" class="lm ln jb na b gy ne nf l ng nh">import { Prisma } from "./generated/prisma-client";<br/><br/>export interface Context {<br/>  prisma: Prisma;<br/>  request: {<br/>    request: {<br/>      headers: {<br/>        authorization: string;<br/>      };<br/>    };<br/>    connection: {<br/>      context: {<br/>        Authorization: string;<br/>      };<br/>    };<br/>  };<br/>}</span></pre><p id="bb12" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">定义上下文类型后，将全局上下文设置为prisma和request，这样我们就可以使用prisma方法和请求对象来获取授权令牌。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="5a2c" class="lm ln jb na b gy ne nf l ng nh">const server = new GraphQLServer({<br/>  context: (req) =&gt; {<br/>    return {<br/>      request: req,<br/>      prisma,<br/>    };<br/>  },<br/>});</span></pre><h2 id="f5e7" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">为注册创建消息有效负载和注册输入</strong></h2><p id="f6a3" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">为了定义变异，我们需要提供解析器返回负载和参数类型，对于注册，我们必须将messagePayload定义为我们的负载，将signupInput定义为我们的输入参数。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2ff3" class="lm ln jb na b gy ne nf l ng nh">import { inputObjectType, objectType } from "nexus";<br/>export const signupInput = inputObjectType({<br/>  name: "signupInput",<br/>  definition(t) {<br/>    t.string("name", { nullable: false });<br/>    t.string("email", { nullable: false });<br/>    t.string("password", { nullable: false });<br/>  },<br/>});<br/>export const messagePayload = objectType({<br/>  name: "MessagePayload",<br/>  definition(t) {<br/>    t.string("message", { nullable: false });<br/>  },<br/>});</span></pre><p id="0b70" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因为消息有效负载仅返回字符串形式的成功消息，所以signpInput接受由用户名、电子邮件和密码提供的3个参数。</p><h2 id="b984" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">使用nodemailer创建电子邮件服务</strong></h2><p id="c9d6" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">你可以定义任何你想要的提供商，我使用gmail作为发送电子邮件的提供商。它只需要电子邮件、gmail帐户密码和创建传输层的提供商名称。</p><p id="05db" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果您使用gmail，请在gmail设置中启用不太安全的应用程序。对于激活电子邮件，它需要一个令牌和一个html，所以当用户可以获得激活电子邮件时，它会看起来很好。ResetPassword也需要相同的密码，但它用于忘记密码功能。SendEmail用于实际发送电子邮件。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="a9a9" class="lm ln jb na b gy ne nf l ng nh">import { createTransport } from "nodemailer";<br/>type Token = string;<br/><br/>const transport = createTransport({<br/>  service: "gmail",<br/>  auth: {<br/>    user: process.env.GMAIL_USER,<br/>    pass: process.env.GMAIL_PASSWORD,<br/>  },<br/>});<br/><br/>export default {<br/>  activationEmail(token: Token) {<br/>    // Compose email<br/>    const html = `Hi there,<br/>      &lt;br/&gt;<br/>      Thank you for registering!<br/>      &lt;br/&gt;&lt;br/&gt;<br/>      Please verify your email by clicking the following link:<br/>      &lt;br/&gt;<br/>      On the following page:<br/>      &lt;a target="_blank" href="${<br/>        process.env.CLIENT_URL<br/>      }/auth/activate/${token}"&gt;${<br/>      process.env.CLIENT_URL<br/>    }/auth/activate/${token}&lt;/a&gt;<br/>      &lt;br/&gt;&lt;br/&gt;<br/>      Have a pleasant day.`;<br/>    return html;<br/>  },<br/>  resetPassword(token: Token) {<br/>    const html = `<br/>    &lt;h1&gt;Please use the following link to reset your password&lt;/h1&gt;<br/>    &lt;a target="_blank" href="${<br/>      process.env.CLIENT_URL<br/>    }/auth/password/reset/${token}"&gt;${<br/>      process.env.CLIENT_URL<br/>    }/auth/password/reset/${token}&lt;/a&gt;<br/>    `;<br/>    return html;<br/>  },<br/>  sendEmail(from: string, to: string, subject: string, html: string) {<br/>    return new Promise((resolve, reject) =&gt; {<br/>      transport.sendMail({ from, subject, to, html }, (err, info) =&gt; {<br/>        if (err) reject(err);<br/>        resolve(info);<br/>      });<br/>    });<br/>  },<br/>};</span></pre><h2 id="b199" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">创建generateHashPassword实用函数</strong></h2><p id="9d0e" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">我们必须从bcrypt导入hash，generatHashPassword需要一个arg密码，首先它检查8个字符的有效性，如果无效，它抛出一个错误，如果有效，它散列密码并返回</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="0557" class="lm ln jb na b gy ne nf l ng nh">import { hash } from "bcrypt";<br/>const generateHashPassword = (password: String) =&gt; {<br/>    if (password.length &lt; 8) {<br/>        throw new Error("Password should be greater than 8 characters");<br/>    }<br/>    return hash(password, 10);<br/>};<br/><br/>export default generateHashPassword;</span></pre><h2 id="a3f7" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">创建注册和账户激活突变</strong></h2><p id="32d2" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">首先，我们必须检查用户传递的电子邮件是否已经与一个帐户相关联，如果是，我们必须抛出一个错误，如果不是，我们必须生成散列密码。在这之后，我们必须创建一个jwt令牌。它需要有效载荷、密钥和过期时间。我们在有效载荷中传递电子邮件、姓名和hashPassword。我们给token 10分钟的过期时间。我们必须发送一封帐户激活邮件，为此我们使用了我们之前创建的sendEmail服务，最后我们返回消息有效负载。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="94ac" class="lm ln jb na b gy ne nf l ng nh">t.field("signup", {<br/>      type: "MessagePayload",<br/>      nullable: false,<br/>      args: {<br/>        signupInput: arg({ type: "signupInput", required: true }),<br/>      },<br/>      resolve: async (_, { signupInput: { name, email, password } }, ctx) =&gt; {<br/>        try {<br/>          const isUserExist = await ctx.prisma.$exists.user({ email });<br/>          if (isUserExist) {<br/>            throw new Error("Email is already associated with another user");<br/>          }<br/>          const hashPassword = await generateHashPassword(password);<br/>          const token = sign(<br/>            {<br/>              name,<br/>              email,<br/>              password: hashPassword,<br/>            },<br/>            process.env.JWT_ACCOUNT_ACTIVATION,<br/>            {<br/>              expiresIn: "10m",<br/>            }<br/>          );<br/>          const html = mailService.activationEmail(token);<br/>          await mailService.sendEmail(<br/>            process.env.EMAIL_FROM,<br/>            email,<br/>            "Account activation",<br/>            html<br/>          );<br/>          return {<br/>            message: `Email has been sent to ${email}. Follow the instruction to activate your account`,<br/>          };<br/>        } catch (error) {<br/>          throw new Error(error.message);<br/>        }<br/>      },<br/>    });</span></pre><p id="cd97" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">向用户成功发送电子邮件后，激活用户的时间到了，accountActivation也有一个messagePayload解析器返回类型，它需要token作为参数。首先，我们使用verify jwt方法检查令牌是否过期，如果没有过期，我们解码名称、电子邮件和hashPassword以成功创建用户并返回消息有效负载。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2035" class="lm ln jb na b gy ne nf l ng nh">t.field("accountActivation", {<br/>      type: "MessagePayload",<br/>      nullable: false,<br/>      args: {<br/>        token: stringArg({ required: true }),<br/>      },<br/>      resolve: async (_, { token }, ctx) =&gt; {<br/>        try {<br/>          if (!token) {<br/>            throw new Error("No token for activation");<br/>          }<br/>          const decoded = verify(token, process.env.JWT_ACCOUNT_ACTIVATION);<br/>          const { name, email, password } = decode(token) as {<br/>            name: string;<br/>            email: string;<br/>            password: string;<br/>          };<br/>          await ctx.prisma.createUser({<br/>            name,<br/>            password,<br/>            email,<br/>          });<br/>          return {<br/>            message: "Signup success. Please signin.",<br/>          };<br/>        } catch (error) {<br/>          throw new Error(error.message);<br/>        }<br/>      },<br/>    });</span></pre><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/f5eeafed5edd186eefe294ec4ef43500.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZGF4UZMRkS2G1HZzTtSoJw.png"/></div></div></figure><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/71054278af426f178c01ea970a3b0bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5IGqQjr3-OOV8eAAnTHMLw.png"/></div></div></figure><h2 id="2013" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">为登录突变创建LoginInput，AuthPayload】</strong></h2><p id="af20" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">我们必须创建loginInput，它以字符串形式定义电子邮件和密码。接下来，我们为解析器返回类型创建一个AuthPayload。AuthPayload返回一个令牌和一个用户。我们还将用户类型定义为只返回这些字段。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="7dcc" class="lm ln jb na b gy ne nf l ng nh">export const User = prismaObjectType&lt;"User"&gt;({<br/>  name: "User",<br/>  definition(t) {<br/>    t.prismaFields(["id", "email", "name", "isAdmin"]);<br/>  },<br/>});</span><span id="2b76" class="lm ln jb na b gy nn nf l ng nh">export const loginInput = inputObjectType({<br/>  name: "loginInput",<br/>  definition(t) {<br/>    t.string("email", { nullable: false });<br/>    t.string("password", { nullable: false });<br/>  },<br/>});</span><span id="fca1" class="lm ln jb na b gy nn nf l ng nh">export const AuthPayload = objectType({<br/>  name: "AuthPayload",<br/>  definition(t) {<br/>    t.string("token", { nullable: false });<br/>    t.field("user", {<br/>      type: "User",<br/>      nullable: false,<br/>    });<br/>  },<br/>});</span></pre><h2 id="9a3a" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">创建一个generateToken实用函数</strong></h2><p id="b8bb" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">我们必须提供一个userId作为有效负载、一个密钥和一个生成令牌的过期时间。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="15bc" class="lm ln jb na b gy ne nf l ng nh">import { sign } from "jsonwebtoken";<br/>const generateToken = (userId: String) =&gt; {<br/>    const token = sign(<br/>        {<br/>            userId,<br/>        },<br/>        process.env.JWT_SECRET,<br/>        {<br/>            expiresIn: "7d",<br/>        }<br/>    );<br/>    return token;<br/>};<br/><br/>export default generateToken;</span></pre><h2 id="8382" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">创造登录变异</strong></h2><p id="cc55" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">我们必须检查所提供的电子邮件是否与帐户相关联，然后我们将hashPassword与所提供的密码进行比较。我们检查验证，如果失败，抛出一个错误，如果不返回AuthPayload。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="bb8f" class="lm ln jb na b gy ne nf l ng nh">t.field("login", {<br/>      type: "AuthPayload",<br/>      nullable: false,<br/>      args: {<br/>        loginInput: arg({ type: "loginInput", required: true }),<br/>      },<br/>      resolve: async (_, { loginInput: { email, password } }, ctx) =&gt; {<br/>        const user = await ctx.prisma.user({<br/>          email,<br/>        });<br/>        if (!user) {<br/>          throw new Error("User not exist");<br/>        }<br/>        const isPasswordMatch = await compare(password, user.password);<br/>        if (!isPasswordMatch) {<br/>          throw new Error("Password not correct");<br/>        }<br/>        return {<br/>          user,<br/>          token: generateToken(user.id),<br/>        };<br/>      },<br/>    });</span></pre><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/a68c6b3e52e2c0239efa8b1a5b601504.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0OOcnHGaUy9YRdKal7PiQQ.png"/></div></div></figure><h2 id="83c5" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">创建忘记密码突变</strong></h2><p id="de42" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">它还返回一个messagePayload，并需要一个用户电子邮件作为输入参数。我们必须检查用户提供的电子邮件是否与帐户相关联，然后我们为有效负载生成一个带有用户id和名称的令牌。这个令牌持续10分钟。之后，我们向用户发送一封电子邮件，并将resetPasswordToken更新为生成的令牌。最后我们返回messagePayload。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="39f6" class="lm ln jb na b gy ne nf l ng nh">t.field("forgotPassword", {<br/>      type: "MessagePayload",<br/>      nullable: false,<br/>      args: {<br/>        email: stringArg({ required: true }),<br/>      },<br/>      resolve: async (_, { email }, ctx) =&gt; {<br/>        try {<br/>          const user = await ctx.prisma.user({<br/>            email,<br/>          });<br/>          if (!user) {<br/>            throw new Error("User not exist");<br/>          }<br/>          const token = sign(<br/>            {<br/>              _id: user.id,<br/>              name: user.name,<br/>            },<br/>            process.env.JWT_RESET_PASSWORD,<br/>            {<br/>              expiresIn: "10m",<br/>            }<br/>          );<br/>          const html = mailService.resetPassword(token);<br/>          await ctx.prisma.updateUser({<br/>            where: {<br/>              id: user.id,<br/>            },<br/>            data: {<br/>              resetPasswordToken: token,<br/>            },<br/>          });<br/>          await mailService.sendEmail(<br/>            process.env.EMAIL_FROM,<br/>            email,<br/>            "Password Reset",<br/>            html<br/>          );<br/>          return {<br/>            message: `Email has been sent to ${email}. Follow the instruction to reset your password`,<br/>          };<br/>        } catch (error) {<br/>          throw new Error(error.message);<br/>        }<br/>      },<br/>    });</span></pre><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/dd349f6dff14a34988ec9308a5d8fa05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7HmfcJcRTBkQVDYNgPtxhA.png"/></div></div></figure><h2 id="50e1" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">创建重置密码输入和变异</strong></h2><p id="5aa4" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">ResetPassword输入将两个字段resetPasswordToken和newPassword作为字符串类型。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="8e52" class="lm ln jb na b gy ne nf l ng nh">export const resetPasswordInput = inputObjectType({<br/>  name: "resetPasswordInput",<br/>  definition(t) {<br/>    t.string("resetPasswordToken", { nullable: false });<br/>    t.string("newPassword", { nullable: false });<br/>  },<br/>});</span></pre><p id="9121" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">ResetPassword变异返回消息负载，并要求将resetPassword输入作为参数。首先，我们必须检查用户提供的resetPasswordToken是否与用户相关联，如果不是，它将抛出一个错误，如果存在，它将返回一个用户。我们对新密码进行哈希运算，并将用户密码和resetPasswordToken更新为空字符串。最后我们返回一个消息负载。</p><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/edd710fa3f42bdfe1cce316f77bc5449.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BAjbUYkBGR1RwACvjZ8A7g.png"/></div></div></figure><h2 id="d713" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">创建脸书登录输入和变异</strong></h2><p id="b3e4" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">脸书登录输入将accessToken和userId定义为字符串类型。变异将AuthPayload作为解析器返回类型返回。用于测试目的的AccessToken和userId可以从<a class="ae np" href="https://developers.facebook.com/tools/explorer/" rel="noopener ugc nofollow" target="_blank"> Graph api explorer </a>获得，在此之前你必须在<a class="ae np" href="https://developers.facebook.com/" rel="noopener ugc nofollow" target="_blank"> facebook开发者控制台</a>上创建一个应用</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="40f0" class="lm ln jb na b gy ne nf l ng nh">export const facebookLoginInput = inputObjectType({<br/>  name: "facebookLoginInput",<br/>  definition(t) {<br/>    t.string("userId", { nullable: false });<br/>    t.string("accessToken", { nullable: false });<br/>  },<br/>});</span></pre><p id="8987" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们必须将userId和accessToken传递给graph api，并从中获取数据。姓名和电子邮件应该从响应中返回，我们必须首先检查电子邮件是否已经与帐户相关联。如果它已经存在，返回授权有效负载，如果不是，我们创建一个新用户的电子邮件和密码，并返回授权有效负载。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="6446" class="lm ln jb na b gy ne nf l ng nh">t.field("facebookLogin", {<br/>      type: "AuthPayload",<br/>      nullable: false,<br/>      args: {<br/>        facebookLoginInput: arg({ type: "facebookLoginInput", required: true }),<br/>      },<br/>      resolve: async (<br/>        _,<br/>        { facebookLoginInput: { userId, accessToken } },<br/>        ctx<br/>      ) =&gt; {<br/>        try {<br/>          const url = `https://graph.facebook.com/v2.11/${userId}/?fields=id,name,email&amp;access_token=${accessToken}`;<br/>          const response = await fetch(url, {<br/>            method: "GET",<br/>          });<br/>          const data = (await response.json()) as {<br/>            name: string;<br/>            email: string;<br/>            // error: {<br/>            //   message: string;<br/>            // };<br/>          };<br/>          if (response.status !== 200) {<br/>            throw new Error("Something went wrong");<br/>          }<br/>          const { email, name } = data;<br/>          const user = await ctx.prisma.user({<br/>            email,<br/>          });<br/>          if (!user) {<br/>            const newUser = await ctx.prisma.createUser({<br/>              name,<br/>              email,<br/>            });<br/>            return {<br/>              user: newUser,<br/>              token: generateToken(newUser.id),<br/>            };<br/>          }<br/>          return {<br/>            user,<br/>            token: generateToken(user.id),<br/>          };<br/>        } catch (error) {<br/>          throw new Error(error.message);<br/>        }<br/>      },<br/>    });</span></pre><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nq"><img src="../Images/0e76835d5010067108513928f2fec194.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HyGxUP883HbJIrtNVhS4Yg.png"/></div></div></figure><h2 id="0069" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">创建一个谷歌登录输入和变异</strong></h2><p id="cf66" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">对于<strong class="ks jc"> </strong> google登录，我们使用google-auth-library npm包。它需要一个客户端id进行设置。从谷歌云平台获取客户端id很简单，按照这个<a class="ae np" href="https://support.google.com/cloud/answer/6158849?hl=en" rel="noopener ugc nofollow" target="_blank">https://support.google.com/cloud/answer/6158849?hl=en</a></p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="0536" class="lm ln jb na b gy ne nf l ng nh">import { OAuth2Client } from "google-auth-library";<br/>const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);</span></pre><p id="5922" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们将idToken定义为google登录输入的字符串。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="cda1" class="lm ln jb na b gy ne nf l ng nh">export const googleLoginInput = inputObjectType({<br/>  name: "googleLoginInput",<br/>  definition(t) {<br/>    t.string("idToken", { nullable: false });<br/>  },<br/>});</span></pre><p id="045e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Google登录突变也返回一个AuthPayload，它与facebook登录突变相同。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="f07b" class="lm ln jb na b gy ne nf l ng nh">t.field("googleLogin", {<br/>      type: "AuthPayload",<br/>      nullable: false,<br/>      args: {<br/>        googleLoginInput: arg({ type: "googleLoginInput", required: true }),<br/>      },<br/>      resolve: async (_, { googleLoginInput: { idToken } }, ctx) =&gt; {<br/>        try {<br/>          const { email_verified, email, name } = (await client.verifyIdToken({<br/>            idToken,<br/>            audience: process.env.GOOGLE_CLIENT_ID,<br/>          })).getPayload();<br/>          if (email_verified) {<br/>            const user = await ctx.prisma.user({<br/>              email,<br/>            });<br/>            if (!user) {<br/>              const newUser = await ctx.prisma.createUser({<br/>                name,<br/>                email,<br/>              });<br/>              return {<br/>                user: newUser,<br/>                token: generateToken(newUser.id),<br/>              };<br/>            }<br/>            return {<br/>              user,<br/>              token: generateToken(user.id),<br/>            };<br/>          }<br/>        } catch (error) {<br/>          throw new Error(error.message);<br/>        }<br/>      },<br/>    });</span></pre><p id="1bad" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">由于google不像facebook那样提供测试用户，如果您的客户端是基于react构建的，那么您必须为它设置一个客户端，使用<a class="ae np" href="https://www.npmjs.com/package/react-google-login" rel="noopener ugc nofollow" target="_blank"> react-google-login </a>作为响应返回idToken。</p><h2 id="ba65" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">创建一个getUserId util和当前用户查询</strong></h2><p id="9a1f" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">对于getUserId实用程序，它只需要上下文。从请求头中获取授权令牌，并使用jwt verify方法检查它是否有效。如果超过7天，它可能会过期，因为我们设置令牌在登录时应该持续7天。如果您的应用程序有订阅，请取消对这3行的注释。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="93a8" class="lm ln jb na b gy ne nf l ng nh">import { verify } from "jsonwebtoken";<br/>import { Context } from "../types";<br/>interface Token {<br/>  userId: string;<br/>}<br/>export const getUserId = (context: Context) =&gt; {<br/>  // const authTokenWithBarer = context.request.request<br/>  //   ? context.request.request.headers.authorization<br/>  //   : context.request.connection.context.Authorization;<br/>  const authTokenWithBarer = context.request.request.headers.authorization;<br/>  if (authTokenWithBarer) {<br/>    const token = authTokenWithBarer.split(" ")[1];<br/>    const user = verify(token, process.env.JWT_SECRET) as Token;<br/>    return user &amp;&amp; user.userId;<br/>  }<br/>};</span></pre><p id="2574" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于当前用户查询，我们将用户定义为解析器返回类型。用户仅返回id、姓名、电子邮件和isAdmin，因为我们之前定义了这些prisma字段。从实用函数中获取userId，并从这个Id中获取用户。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="158f" class="lm ln jb na b gy ne nf l ng nh">t.field("currentUser", {<br/>      type: "User",<br/>      nullable: false,<br/>      resolve: async (parent, args, ctx) =&gt; {<br/>        const userId = getUserId(ctx);<br/>        const user = await ctx.prisma.user({ id: userId });<br/>        return user;<br/>      },<br/>    });</span></pre><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/e69a190fccc00a98e242847382c81706.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*icCufJvDWY50WPGJWMQvYA.png"/></div></div></figure><h2 id="d577" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">创建获取所有用户和删除用户功能</strong></h2><p id="65cf" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">所有用户的查询和变异只能由管理员访问。对于admin，您必须在数据库中手动将isAdmin设置为true。所有用户查询返回用户列表，您可以传递用户名进行过滤，但它是一个可选参数。我们将所有用户解析器类型设置为用户。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="5d3a" class="lm ln jb na b gy ne nf l ng nh">t.list.field("allUsers", {<br/>      type: "User",<br/>      nullable: false,<br/>      args: {<br/>        searchNameString: stringArg({ nullable: true }),<br/>      },<br/>      resolve: (parent, { searchNameString }, ctx) =&gt; {<br/>        return ctx.prisma.users({<br/>          where: {<br/>            name_contains: searchNameString,<br/>          },<br/>        });<br/>      },<br/>    });</span></pre><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nl"><img src="../Images/8541f14cef9b60aa2924b0237c1f7890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2t7hD588keA1CXV7ccJzfQ.png"/></div></div></figure><p id="43b8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于删除用户，我们将删除用户输入定义为在一个数组中获取用户id</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="2a04" class="lm ln jb na b gy ne nf l ng nh">export const deleteUserInput = inputObjectType({<br/>  name: "DeleteUserInput",<br/>  definition(t) {<br/>    t.list.id("id", { required: true });<br/>  },<br/>});</span></pre><p id="5462" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们将删除用户解析器返回类型定义为消息有效负载。这种变异需要一个删除用户输入，因为它是一个用户id数组。</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="e5f9" class="lm ln jb na b gy ne nf l ng nh">t.field("deleteUsers", {<br/>      type: "MessagePayload",<br/>      nullable: false,<br/>      args: {<br/>        ids: arg({ type: "DeleteUserInput", required: true }),<br/>      },<br/>      resolve: async (parent, { ids }, ctx) =&gt; {<br/>        await ctx.prisma.deleteManyUsers({<br/>          id_in: ids.id,<br/>        });<br/>        return {<br/>          message: "Delete users successfully",<br/>        };<br/>      },<br/>    });</span></pre><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/aef71637c375f9c22cb63cb99b59200f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I7UR8NLmstCvWqrr8W28DA.png"/></div></div></figure><h2 id="035e" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">定义授权规则</strong></h2><p id="c7c9" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">我们必须为查询和变异定义规则，因此只有管理员或经过身份验证的用户才能访问它。我们使用graphql-shield来定义规则。我们定义了两个规则isUserAuthenticated和isAdmin，并为查询和变异创建了一个屏蔽。对于currentUser查询，它只需要isAuthenticatedUser，但是对于get all users，它还需要isAdmin。对于突变删除，用户只需要isAdmin角色</p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="ef8a" class="lm ln jb na b gy ne nf l ng nh">import { rule, shield } from "graphql-shield";<br/>import { getUserId } from "../utils/getUserId";<br/>import { Context } from "../types";<br/><br/>const rules = {<br/>  isAuthenticatedUser: rule()((parent, args, ctx: Context) =&gt; {<br/>    const userId = getUserId(ctx);<br/>    return Boolean(userId);<br/>  }),<br/>  isAdmin: rule()(async (parent, args, ctx: Context) =&gt; {<br/>    const userId = getUserId(ctx);<br/>    const isAdmin = await ctx.prisma.$exists.user({<br/>      id: userId,<br/>      isAdmin: true,<br/>    });<br/>    return isAdmin;<br/>  }),<br/>};<br/>export const middlewares = shield({<br/>  Query: {<br/>    currentUser: rules.isAuthenticatedUser,<br/>    allUsers: rules.isAdmin,<br/>  },<br/>  Mutation: {<br/>    deleteUsers: rules.isAdmin,<br/>  },<br/>});</span></pre><p id="0d71" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">定义许可标准后，将这个中间件传递给全局graphQL服务器。为此，我们使用了<a class="ae np" href="https://www.npmjs.com/package/graphql-middleware" rel="noopener ugc nofollow" target="_blank"> graphql中间件</a></p><pre class="mv mw mx my gt mz na nb nc aw nd bi"><span id="3a8e" class="lm ln jb na b gy ne nf l ng nh">import { applyMiddleware } from "graphql-middleware";<br/>import { middlewares } from "./middlewares";</span><span id="78af" class="lm ln jb na b gy nn nf l ng nh">const server = new GraphQLServer({<br/>  schema: applyMiddleware(schema, middlewares),<br/>  context: (req) =&gt; {<br/>    return {<br/>      request: req,<br/>      prisma,<br/>    };<br/>  },<br/>});</span></pre><figure class="mv mw mx my gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/3c1c17f3bc9f6c0dac6646455a6b1833.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uop4IBiJ5SjFQs57vIVX3A.png"/></div></div></figure><h2 id="9c84" class="lm ln jb bd lo lp lq dn lr ls lt dp lu kz lv lw lx ld ly lz ma lh mb mc md me bi translated"><strong class="ak">结论</strong></h2><p id="dede" class="pw-post-body-paragraph kq kr jb ks b kt mh kc kv kw mi kf ky kz ni lb lc ld nj lf lg lh nk lj lk ll ij bi translated">在本教程中，我们介绍了GraphQL Nexus中的认证和授权。了解许多图书馆JWT，bcrypt，graphQL盾。这将有助于您实现身份验证。我的主要目的是建立一个终极的生物模板，我希望它有所帮助。</p><p id="fbb5" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下面是这个终极认证【https://github.com/muhammadali448/ultimate_auth<br/>T5】的完整代码的链接</p><p id="f756" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我想知道你对最佳方法的反馈，因为有这么多的方法，如果我们可以进一步改善它。</p></div></div>    
</body>
</html>