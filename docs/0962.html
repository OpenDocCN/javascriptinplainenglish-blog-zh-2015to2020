<html>
<head>
<title>Angular web components? What are those?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有角度的web组件？那些是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-web-components-what-are-those-80da596932e2?source=collection_archive---------2-----------------------#2020-01-07">https://javascript.plainenglish.io/angular-web-components-what-are-those-80da596932e2?source=collection_archive---------2-----------------------#2020-01-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b943baf22d0fdcbaeb89a44bcb4956ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZnG6ltmgV-oO1V33t83hnA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@freetousesoundscom?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Free To Use Sounds</a> on <a class="ae kc" href="https://unsplash.com/s/photos/small-boxes?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dc4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自从web组件被引入以来已经有一段时间了，但是我们中的许多人甚至还没有听说过它们(或者甚至没有尝试过它们)。</p><p id="7c39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不要被标题误导了，它们不是只在<strong class="kf ir">角</strong>建造的。你可以继续在<strong class="kf ir">React/Vue/Polymer/Stencil</strong>甚至<strong class="kf ir"> vanilla JS </strong>和good old <strong class="kf ir"> HTML </strong>中构建它们。</p><p id="76cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular 给你的唯一东西是我们Angular开发者喜欢的伟大的工具(尽管其他人可能不同意)。</p><p id="b787" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是撇开实现不谈，让我们先来谈谈什么是web组件以及我们如何使用它们。</p><p id="8811" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来让我们深入了解一下<strong class="kf ir"> Angular </strong>中的实用指南。</p><blockquote class="lb"><p id="1de9" class="lc ld iq bd le lf lg lh li lj lk la dk translated"><strong class="ak"> Web组件</strong>被<a class="ae kc" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" rel="noopener ugc nofollow" target="_blank"> Mozilla文档</a>定义为可重用的定制元素，具有<strong class="ak">封装的</strong>功能。</p></blockquote><p id="8809" class="pw-post-body-paragraph kd ke iq kf b kg ll ki kj kk lm km kn ko ln kq kr ks lo ku kv kw lp ky kz la ij bi translated">这意味着，你可以创建自己的定制<strong class="kf ir"> HTML </strong>元素(比如<code class="fe lq lr ls lt b">&lt;my-first-custom-element&gt;</code>)，在<strong class="kf ir">限定的</strong>范围内执行逻辑。</p><p id="e374" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这基本上意味着您需要与元素建立一个通信通道，否则您将无法发送/接收数据。</p><p id="7dcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">已经为您设置了发送。所需要的只是<strong class="kf ir"> HTML </strong>属性值，比如<code class="fe lq lr ls lt b">&lt;my-first-custom-element input=”red”&gt;</code></p><p id="8a86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是要接收数据，您需要添加<strong class="kf ir">事件监听器</strong>，它将连接到您的元素并监听确切的<strong class="kf ir">事件发射</strong>。</p><p id="d32d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这可能会带来很多痛苦，因为你需要处理父结构中的所有事件，而且随着页面中<strong class="kf ir"> web组件</strong>数量的增加，这可能会变得混乱，除非应用某些<strong class="kf ir">模式和实践</strong>。</p><p id="673a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之<strong class="kf ir"> web组件</strong>所允许的，是一个清晰的逻辑分离，通过将你实际的<strong class="kf ir">单片</strong>前端分割成多个独立的部分。</p><p id="4f27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你正在从事任何尖端技术，你可能不会直接看到好处，但是一旦你面对一个<strong class="kf ir">旧的遗留单片应用</strong>，它有一个<strong class="kf ir"> web服务器</strong>，它也作为前端提供者。</p><h1 id="2db2" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">不，不，不…当然不是你想象中的前台。</h1><p id="32e1" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">当我说前端时，我不是指作为静态资产提供的<strong class="kf ir"> SPA </strong>。<br/>我指的是纯粹的<strong class="kf ir"> HTML </strong>和<strong class="kf ir"> JavaScript </strong>页面，它们是从一个模板在服务器端生成的，比如<strong class="kf ir"> jsp </strong>、<strong class="kf ir"> ejs </strong>、<strong class="kf ir"> php </strong>或任何其他。</p><p id="b27f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你发现自己处在一个不能废弃整个应用程序并重新开始的地方，那么用<strong class="kf ir"> web组件</strong>慢慢扼杀<strong class="kf ir">应用程序可能是解决这种情况的方法。</strong></p><blockquote class="mx my mz"><p id="2184" class="kd ke na kf b kg kh ki kj kk kl km kn nb kp kq kr nc kt ku kv nd kx ky kz la ij bi translated">TLDR；你可以在这里查看angular web组件示例<a class="ae kc" href="https://github.com/marrej/angular-webcomponents" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><h1 id="592f" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated">让我们从构建一个简单的web组件开始</h1><p id="729d" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">与任何其他angular项目一样，我们从<code class="fe lq lr ls lt b">ng new simple-webcomponent</code>开始，创建我们的起始项目。</p><p id="6974" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了回答我们的<strong class="kf ir"> Angular CLI </strong> builder，</p><p id="b158" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">否</strong>以角度路由、</p><p id="de8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> SCSS </strong>为样式表格式。</p><p id="979a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">就让<strong class="kf ir"> Angular CLI </strong>施展它的魔法吧。:D</p><p id="89d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们进一步讨论之前，我们先来谈谈<strong class="kf ir"> Angular </strong>中<strong class="kf ir"> web组件</strong>的架构。</p><p id="fc9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可能习惯于将<strong class="kf ir"> AppComponent </strong>作为您的应用程序的根(当然，如果您习惯于angular ),但是为了能够在开发中测试web组件并在编译时让它完美运行，我们需要在它下面的一个级别上创建一个web组件根。</p><p id="df90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您所需要做的就是，导航到您的<strong class="kf ir"> AppComponent、</strong>所在的目录，并使用<code class="fe lq lr ls lt b">ng g c webcomponent-root</code>创建一个webcomponent-root</p><p id="08b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要查看我们工作的结果，清理整个root.component.ts并添加<code class="fe lq lr ls lt b">&lt;app-webcomponent-root&gt;&lt;/app-webcomponent-root&gt;</code>标签(或者您定义的选择器，如果您编辑了<strong class="kf ir">web component-root . component . ts</strong>选择器属性)。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/27e0bc2fd950a922d4447a92c890f279.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ime6RhIBV9yv8zyZFFt_EA.png"/></div></div></figure><p id="b560" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">看起来棒极了！</p><p id="00fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，不要抱太大希望，因为我们仍然只是在角度试验场。我们需要更新我们的<strong class="kf ir"> app.module.ts </strong>中的一些东西，以便能够构建我们的webcomponent。</p><p id="ee89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们快速浏览一下<strong class="kf ir"> app.module.ts </strong>看看我们现在有什么。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="266d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如你所见，我们正在<strong class="kf ir">引导</strong>我们的<strong class="kf ir"> AppModule </strong>中的<strong class="kf ir"> AppComponent </strong>。</p><p id="6a34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们想要做的，是定义我们的自定义元素(<strong class="kf ir"> WebcomponentRoot </strong>)，将它用作<strong class="kf ir">入口组件</strong>，然后<strong class="kf ir">引导</strong>我们的应用程序。</p><p id="59d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管这在<strong class="kf ir"> @NgModule </strong>装饰器中无法实现，所以我们将在装饰器和<strong class="kf ir"> AppModule </strong>的实例之间分割它。</p><p id="1dfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们做这些之前，我们还需要安装<code class="fe lq lr ls lt b">@angular/elements </code>包，它允许我们定义自定义元素。</p><p id="4daa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以请运行<code class="fe lq lr ls lt b">ng add @angular/elements</code>。</p><p id="517f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看我们将在<strong class="kf ir"> app.module.ts </strong>中引入的更改。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="df19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你所需要做的，就是复制现有的<strong class="kf ir"> NgModule </strong> decorator，换出入口组件的引导程序，并添加<strong class="kf ir"> APP_BASE_HREF </strong>作为提供者(如果你问为什么它是必要的，它会向你显示你的资产应该是服务器的<strong class="kf ir"> URL </strong>)。</p><p id="c463" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后只需在<strong class="kf ir"> AppModule </strong>的构造函数中添加自定义元素，定义自定义元素(同时选择其名称)，并引导应用程序(因为我们确实从<strong class="kf ir"> @NgModule </strong>中抛出了bootstrap子句)。</p><p id="98ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们和一个正常工作的web组件之间唯一的障碍是…</p><h1 id="dbf7" class="lu lv iq bd lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr bi translated"><strong class="ak">建造它</strong></h1><p id="f68e" class="pw-post-body-paragraph kd ke iq kf b kg ms ki kj kk mt km kn ko mu kq kr ks mv ku kv kw mw ky kz la ij bi translated">运行<code class="fe lq lr ls lt b">ng build –prod –output-hashing=none</code>命令(<strong class="kf ir"> output-hashing none </strong>非常方便，如果你想以编程方式使用文件名，否则会在文件名中创建散列)。</p><p id="d5fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还建议将脚本放入您的<strong class="kf ir"> package.json </strong>中，以方便您的工作。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/ab1508c5f81e787f1e30a3e6b4da1b90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SXps-y4-tjGYyFKBCoUnjw.png"/></div></div></figure><p id="c774" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如您所看到的，构建创建了一些文件，我们需要压缩这些文件以减轻web组件的加载: )</p><p id="c41a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以利用<strong class="kf ir"> bash </strong>的能力将文件压缩在一起</p><p id="520a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lq lr ls lt b">cat dist/simple-webcomponent/runtime-es2015.js dist/simple-webcomponent/polyfills-es2015.js dist/simple-webcomponent/scripts.js dist/simple-webcomponent/main-es2015.js &gt; dist/simple-webcomponent/component.js</code></p><p id="0899" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，您应该在应用程序工作区的<strong class="kf ir">dist/simple-web component</strong>文件夹中看到一个<strong class="kf ir"> component.js </strong>文件。</p><p id="387a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需抓取<strong class="kf ir"> component.js </strong>文件，并在您喜欢的任何位置创建一个新的<strong class="kf ir">index.html</strong>(您也可以只重写<strong class="kf ir"> dist </strong>文件夹中的<strong class="kf ir">index.html</strong>，因为它不会被用于任何东西，但它会在下一次构建时被清除，所以我不建议这样做)。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="12d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是你现在应该看到的。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nm"><img src="../Images/3955bd7f7d57ffcc7a5af8685429f538.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vjY-Bby8W8s8M8NVujjkSA.png"/></div></div></figure><p id="bc39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好极了。所以我们刚刚创建了有史以来最简单的web组件！</p><p id="204a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这很好，但是在现实世界中，我们的<strong class="kf ir"> web组件</strong>将是一个大的<strong class="kf ir">前端</strong>的一部分。因此，我们需要我们的webcomponent以特定的方式运行，传入数据，并能够接收外部响应。</p><p id="9052" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">我们如何实现这一目标？</strong></p><p id="fa59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们利用<strong class="kf ir">@输入</strong>&amp;<strong class="kf ir">@输出</strong>，将数据传入&amp;输出。</p><p id="d00a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，首先让我们注释Webcomponent设置部分(带有<strong class="kf ir">entry component</strong>“web component root”)并取消注释测试设置部分(因为我们希望看到更改:)。</p><p id="56f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后打开我们的<strong class="kf ir"> webcomponent-root </strong>(或者你的<strong class="kf ir"> webcomponent </strong>的base)。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="8ecc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，我们已经将<strong class="kf ir"> @Input </strong>与将传递给我们的组件(' text ')的值关联起来，并将<strong class="kf ir"> @Output </strong>与我们的<strong class="kf ir"> EventEmitter </strong> ('notify ')关联起来，因此我们可以开始监听我们从父组件中的<strong class="kf ir"> EventEmitter </strong>(使用<strong class="kf ir"> notifyUsers( ) </strong>)发出的值。</p><p id="16b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实际上能够看到变化，比如输入值，或者能够触发事件发射器，让我们更新<strong class="kf ir"> HTML </strong>文件。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f7d4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好的，很好，现在我们只需要更新保存对我们的<strong class="kf ir"> web组件</strong>的引用的文件。当我们在Angular环境中测试时，对<strong class="kf ir"> web组件</strong>的引用可以在<strong class="kf ir">app.component.html</strong>中找到。</p><p id="2274" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要更新这个文件来测试我们的<strong class="kf ir"> webcomponent </strong>的输入和输出。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="f873" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，输入是一个单词Hola，它将显示在屏幕上，我们已经将notify事件绑定到<strong class="kf ir"> userNotification( ) </strong>函数，该函数只输出<strong class="kf ir">发出的值</strong>。</p><p id="14b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是不要忘记，我们需要添加一个函数，一旦事件在<strong class="kf ir"> app.component.ts </strong>中发生，这个函数就会被调用。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="a8b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">单击该按钮后，您应该会在开发人员工具中看到一个控制台日志。</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nn"><img src="../Images/c091d1cda8cc611ab3ce77ac01a054a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*O7tMw3giVWlDguoUWgDeGA.png"/></div></div></figure><p id="d8a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">太好了！我们已经让它在我们的测试环境中运行了，但是让我们看看如何用普通的<strong class="kf ir"> JavaScript </strong>将它连接到一个普通的<strong class="kf ir"> HTML </strong>文件中。</p><p id="2b0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注释掉<strong class="kf ir"> app.module.ts </strong>中的testing setup部分，并取消注释Webcomponent setup部分(即带有入口组件“<strong class="kf ir"> webcomponent root </strong>”的部分)。当然，构建它并通过压缩结果创建新的<strong class="kf ir"> component.js </strong>。</p><p id="9725" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以像上次一样使用相同的<strong class="kf ir">index.html</strong>，让我们通过只更新<strong class="kf ir"> component.js </strong>文件来观察会发生什么。(不要忘记，如果你像我一样懒惰，在<strong class="kf ir"> dist </strong>之外创建index.html，它也会被构建删除，所以你需要再次复制代码)</p><figure class="nf ng nh ni gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi no"><img src="../Images/d41358f03cf3b62ca26473f703e23baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TcvvxaK4acedINwBvv1e-w.png"/></div></div></figure><p id="3094" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，因为我们没有添加输入文本，所以在<strong class="kf ir">输入字符串</strong>之后没有显示任何内容。因为我们也没有连接notify事件，所以我们没有从按钮上的点击获得日志。</p><p id="0d88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了连接我们的输出，我们需要使用一个<strong class="kf ir"> querySelector </strong>找到我们的webcomponent，然后监听一个选定类型的事件(我们的是<strong class="kf ir"> notify </strong>)。</p><p id="c566" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，输入的工作方式和以前一样(我们只需要在<code class="fe lq lr ls lt b">&lt;web-component&gt;</code>的文本属性中传递值“Hola”)。</p><p id="287d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在更新的文件中签出它。</p><figure class="nf ng nh ni gt jr"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="41e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们有了一个正常工作的web组件，它可以接收数据，也可以根据需要发送数据。</p><p id="5150" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这在实际应用中也可以用来传输数据，比如你可能需要从你的父应用程序传递的<strong class="kf ir"> JWT </strong>令牌(或者不取决于保密程度，或者你的<strong class="kf ir"> JWT </strong>需要的保护)。请谨慎使用，因为它将在页面的<strong class="kf ir"> HTML </strong>中可见。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><p id="2b5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们已经在<strong class="kf ir"> Angular </strong>中介绍了<strong class="kf ir"> web组件</strong>的基础知识，我们将在下一部分继续路由。</p><p id="fb97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">希望你喜欢这篇文章，我将期待你的下一篇文章。</p><p id="fa80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">祝你今天休息愉快！</p><p id="02b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">马库斯</p></div></div>    
</body>
</html>