<html>
<head>
<title>Improve Your JavaScript Level With These 4 Interview Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用这4个面试问题提高你的JavaScript水平</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/i-use-these-4-questions-to-find-outstanding-javascript-developers-4a468ea17155?source=collection_archive---------0-----------------------#2020-09-11">https://javascript.plainenglish.io/i-use-these-4-questions-to-find-outstanding-javascript-developers-4a468ea17155?source=collection_archive---------0-----------------------#2020-09-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4a7a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">准备JavaScript面试应该知道的事情。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/06e114ae2c8a0c0a671a3ed0f8b7e8ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FmKNAltUMObr-_b5"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@headwayio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Headway</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b266" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript是现在非常流行的编程语言，基于它衍生出了大量的库和框架。但无论上层生态系统如何进化，都离不开香草JavaScript。在这里，我选择了4个JavaScript面试问题来测试程序员的普通JavaScript技能。</p><h1 id="2073" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.实现Array.prototype.map</h1><blockquote class="mk"><p id="fcb6" class="ml mm iq bd mn mo mp mq mr ms mt lr dk translated">如何手工实现一个<code class="fe mu mv mw mx b">Array.prototype.map</code>方法？</p></blockquote></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="bcbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">熟练使用数组的内置方法并不困难。但如果只是熟悉语法，不知道原理，就很难真正理解JavaScript。</p><p id="048c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe mu mv mw mx b">Array.prototype.map</code>,它<strong class="ky ir">创建一个新的数组</strong>,其中填充了调用数组中每个元素的函数的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/5311914970b68f5cbd255b0dca0d1b43.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PP4enLavQaqZN0yIlISIdA.png"/></div></div></figure><p id="c020" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们参考<a class="ae kv" href="https://github.com/lodash/lodash" rel="noopener ugc nofollow" target="_blank"> lodash </a>，我们可以写一个这样的映射函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/1690ad98b64f256ea04d100a701ab076.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gXldTHpAhTZ3GEGoNWt6Nw.png"/></div></div></figure><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="0d9e" class="nl lt iq mx b gy nm nn l no np">function map(array, iteratee) {<br/>  let index = -1<br/>  const length = array == null ? 0 : array.length<br/>  const result = new Array(length)</span><span id="fd77" class="nl lt iq mx b gy nq nn l no np">  while (++index &lt; length) {<br/>    result[index] = iteratee(array[index], index, array)<br/>  }<br/>  return result<br/>}</span></pre><p id="d705" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用示例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/8b4e4f082fadae5faf6c495a557f8ee6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wK02y4xdDuihxf7aQpyLwQ.png"/></div></div></figure><h1 id="6d65" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.Object.defineProperty属性和代理</h1><p id="39e4" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">如何实现这种代码效果？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/b327bc13daa447b77a6985eedffe91ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I0IGJdZffrB0SBfEUhO2hA.png"/></div></div></figure><p id="19a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以看到，当我们连续三次尝试打印<code class="fe mu mv mw mx b">obj.a</code>时，我们会得到三种不同的结果。这看起来多么不可思议！</p><p id="84a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">能否创造一个神秘的物体<code class="fe mu mv mw mx b">obj</code>来达到这种效果？</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="89d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，这个问题有三个解决方案:</p><ul class=""><li id="2d7b" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated">存取器属性</li><li id="ec66" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">对象.定义属性</li><li id="b15e" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated">代理人</li></ul><p id="e7c9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据ECMAScript，对象的属性有两种形式:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/dabe08a640e5e6b241e795d7c08c78f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xAhKqYYX_DrutUH7T8og8g.png"/></div></div></figure><p id="b79a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对象在逻辑上是属性的集合。每个属性要么是数据属性，要么是访问者属性:</p><ul class=""><li id="ee28" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated"><em class="on">数据属性</em>将键值与ECMAScript语言值和一组布尔属性相关联。</li><li id="b39c" class="ny nz iq ky b kz oh lc oi lf oj lj ok ln ol lr od oe of og bi translated"><em class="on">访问器属性</em>将一个键值与一个或两个访问器函数以及一组布尔属性相关联。访问器函数用于存储或检索与属性关联的ECMAScript语言值。</li></ul><p id="534d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所谓数据属性就是我们平时写的:</p><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="b043" class="nl lt iq mx b gy nm nn l no np">let obj = {<br/>  a: 1,<br/>  b: 2<br/>}</span></pre><p id="bd32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们对一个对象的属性只有两个操作:读取属性和设置属性。对于访问器属性，我们使用<code class="fe mu mv mw mx b">get</code>和<code class="fe mu mv mw mx b">set</code>方法来定义属性，编写如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/8a96fd26ef7c7696f248e7ecb0ab8434.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n1ISYNWzkTILZKUaIc3z8Q.png"/></div></div></figure><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="c0a8" class="nl lt iq mx b gy nm nn l no np">let obj = {<br/>  get a(){<br/>    console.log('triggle get a() method')<br/>    console.log('you can do anything as you want')<br/>    return 1<br/>  },<br/>  set a(value){<br/>    console.log('triggle set a() method')<br/>    console.log('you can do anything as you want')<br/>    console.log(`you are trying to assign ${value} to obj.a`)<br/>    }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/8a87854b6a469f8aa888f5ecab0eb74c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sZZjFqBKO3RJ2wofjW-S5Q.png"/></div></div></figure><p id="4d00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">访问属性为我们提供了强大的元编程能力，因此我们可以通过以下方式完成我们的需求:</p><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="9cba" class="nl lt iq mx b gy nm nn l no np">let obj = {<br/>  _initValue: 0,<br/>  get a() {<br/>    this._initValue++;<br/>    return this._initValue<br/>  }<br/>}</span><span id="374b" class="nl lt iq mx b gy nq nn l no np">console.log(obj.a, obj.a, obj.a)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/25480be0ceb20363cd44da08ce2114fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lx9hNR3lRP-68uOMRFUySA.png"/></div></div></figure><p id="ebee" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二种方法是使用<code class="fe mu mv mw mx b">Object.defineProperty</code>，它的工作方式与我们过去访问属性的方式相同，只是我们不是直接声明访问属性，而是通过<code class="fe mu mv mw mx b">Object.defineProperty</code>配置访问属性。</p><p id="dfa1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这使用起来更灵活一点，所以我们可以这样写:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/d4ca06fd1409fc245fce3eabeddab7e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d7404kK-5T_aIRA7dIsHEw.png"/></div></div></figure><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="203a" class="nl lt iq mx b gy nm nn l no np">let obj = {}<br/>Object.defineProperty(obj, 'a', {<br/>  get: (function(){<br/>    let initValue = 0;<br/>    return function(){<br/>      initValue++;<br/>      return initValue<br/>    }<br/>  })()<br/>})</span><span id="85e6" class="nl lt iq mx b gy nq nn l no np">console.log(obj.a, obj.a, obj.a)</span></pre><p id="82b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里的<code class="fe mu mv mw mx b">get</code>方法中，我们使用了一个闭包，这样我们需要使用的变量<code class="fe mu mv mw mx b">initValue</code>就隐藏在闭包中，不会污染其他作用域。</p><p id="f6fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第三种方法是使用<code class="fe mu mv mw mx b">Proxy</code>。如果你还不知道代理，你可以参考我之前写的一篇文章:</p><div class="os ot gp gr ou ov"><a href="https://medium.com/javascript-in-plain-english/why-proxies-in-javascript-are-fantastic-db100ddc10a0" rel="noopener follow" target="_blank"><div class="ow ab fo"><div class="ox ab oy cl cj oz"><h2 class="bd ir gy z fp pa fr fs pb fu fw ip bi translated">为什么JavaScript中的代理如此神奇</h2><div class="pc l"><h3 class="bd b gy z fp pa fr fs pb fu fw dk translated">4个实际例子帮助您掌握JavaScript的这一强大特性</h3></div><div class="pd l"><p class="bd b dl z fp pa fr fs pb fu fw dk translated">medium.com</p></div></div><div class="pe l"><div class="pf l pg ph pi pe pj kp ov"/></div></div></a></div><p id="7d3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过代理，我们可以拦截对对象属性的访问。只要我们用代理拦截对<code class="fe mu mv mw mx b"> obj.a</code>的访问，然后依次返回1、2、3，就可以完成之前的要求:</p><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="9fe6" class="nl lt iq mx b gy nm nn l no np">let initValue = 0;<br/>let obj = new Proxy({}, {<br/>  get: function(item, property, itemProxy){<br/>    if(property === 'a'){<br/>      initValue++;<br/>      return initValue<br/>    }<br/>    return item[property]<br/>  }<br/>})</span><span id="6225" class="nl lt iq mx b gy nq nn l no np">console.log(obj.a, obj.a, obj.a)</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pk"><img src="../Images/19e14a399997b9a5add3117b9aba938a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0SBdzTzhUlrX9wi8qi8LMQ.png"/></div></div></figure></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="c52b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么理解这个问题很重要？因为<code class="fe mu mv mw mx b">Object.defineProperty</code>和代理给了我们强大的元编程能力，我们可以适当地修改我们的对象来做一些特殊的事情。</p><p id="bfbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在知名前端框架Vue中，其核心机制之一就是数据的双向绑定。在Vue2.0中，Vue通过使用<code class="fe mu mv mw mx b">Object.defineProperty</code>实现了这个机制；在Vue3.0中，代理是用来完成这个机制的。</p><p id="5f44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你不掌握这个，你就无法真正理解像Vue这样的框架是如何工作的。掌握了这些原则，学习Vue就会事半功倍。</p><h1 id="c692" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.范围和结束</h1><p id="3a10" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">运行这段代码的结果是什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pl"><img src="../Images/703344826cb834c1fe84520b4077c54e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3TzE4SqDIrFjmPg8QypICg.png"/></div></div></figure><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="45da" class="nl lt iq mx b gy nm nn l no np">function foo(a,b) {<br/>  console.log(b)<br/>  return {<br/>    foo:function(c){<br/>      return foo(c,a);<br/>    }<br/>  };<br/>}</span><span id="6204" class="nl lt iq mx b gy nq nn l no np">let res = foo(0); <br/>res.foo(1); <br/>res.foo(2); <br/>res.foo(3);</span></pre></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="15ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码有多个嵌套函数，嵌套函数中同时有三个<code class="fe mu mv mw mx b"> foo</code>，乍一看非常繁琐。那么我们如何理解这一点呢？</p><p id="5136" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，我们先确定一下上面的代码里有多少个函数？我们可以看到上面的代码中有两处使用了关键字<code class="fe mu mv mw mx b">function</code>，所以上面的代码中有两个函数，分别是第一行<code class="fe mu mv mw mx b">function foo(a,b) {</code>和第四行<code class="fe mu mv mw mx b">foo:function(c){</code>。而且这两个函数同名。</p><p id="b4ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个问题:第5行的<code class="fe mu mv mw mx b">foo (c, a)</code>调用了哪个函数？如果你不确定，让我们看一个更简单的例子:</p><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="0dd4" class="nl lt iq mx b gy nm nn l no np">var obj={<br/>  fn:function (){<br/>    console.log(fn);<br/>  }<br/>};<br/>obj.fn()</span></pre><p id="de94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们运行这段代码，它会抛出异常吗？答案是肯定的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pm"><img src="../Images/25e3a8d3c679e67fd9dc350877cb9fa4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C_fwzzfzWrmNREBIXc5GZA.png"/></div></div></figure><p id="9c07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是因为<code class="fe mu mv mw mx b">obj.fn()</code>方法的上限范围是全局的，不能访问<code class="fe mu mv mw mx b">obj</code>内部的<code class="fe mu mv mw mx b">fn</code>方法。</p><p id="c397" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到我们之前的例子，按照同样的逻辑，当我们调用<code class="fe mu mv mw mx b">foo(c, a)</code>时，我们实际上在第一行调用了<code class="fe mu mv mw mx b">foo</code>函数。</p><p id="8918" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而当我们调用<code class="fe mu mv mw mx b"> res.foo(1)</code>时，调用的是哪个<code class="fe mu mv mw mx b">foo</code>？显然，第4行的<code class="fe mu mv mw mx b">foo</code>函数被调用。</p><p id="8171" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为这两个foo函数的工作方式不同，所以我们可以将其中一个函数的名称改为<code class="fe mu mv mw mx b">bar</code>，以便我们更容易理解代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pn"><img src="../Images/990bee48bddc38f1a22a6f65ac2dee7b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iqcdZUUQyjqWjOAOjmsnlw.png"/></div></div></figure><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="86f4" class="nl lt iq mx b gy nm nn l no np">function foo(a,b) {<br/>  console.log(b)<br/>  return {<br/>    bar:function(c){<br/>      return foo(c,a);<br/>    }<br/>  };<br/>}</span><span id="a2d6" class="nl lt iq mx b gy nq nn l no np">let res = foo(0); <br/>res.bar(1); <br/>res.bar(2); <br/>res.bar(3);</span></pre><p id="9d75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种改变不会影响最终的结果，但会让我们更容易理解代码。如果你将来遇到类似的问题，试试这个技巧。</p><p id="5701" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次调用一个函数，都会创建一个新的作用域，所以我们可以绘制图表来帮助我们理解代码如何工作的逻辑。</p><p id="f226" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们执行<code class="fe mu mv mw mx b">let res = foo(0);</code>时，我们实际上是在执行<code class="fe mu mv mw mx b">foo(0, undefiend)</code>。此时，程序中创建了一个新的作用域，在当前作用域中，<code class="fe mu mv mw mx b">a=0</code>，<code class="fe mu mv mw mx b">b=undefined</code>。所以我画的图表看起来像这样。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/f264d111df415a284b22c63ad439beb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NQ7fpgdsSrtVfNsbESCxww.png"/></div></div></figure><p id="509d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后<code class="fe mu mv mw mx b">console.log(b)</code>会被执行，所以它第一次在控制台打印出‘未定义’。</p><p id="ba7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后执行<code class="fe mu mv mw mx b">res.bar(1)</code>，创建一个新的作用域，其中c=1:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pp"><img src="../Images/fd682c33afddb2c651c8dce4b5d0ce5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tt88VKcxqeyN2CMjnBJVIg.png"/></div></div></figure><p id="4db8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后从上面的函数中再次调用<code class="fe mu mv mw mx b">foo(c, a)</code>，实际上是<code class="fe mu mv mw mx b">foo(1, 0)</code>，作用域看起来是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pq"><img src="../Images/79ecf9a67ba507464df6c503a3858447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fh_A8Kwzu6bROaodGa0S0A.png"/></div></div></figure><p id="ecac" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在新的范围中，<code class="fe mu mv mw mx b">a</code>的值是1，<code class="fe mu mv mw mx b">b</code>的值是0，因此控制台将打印出0。</p><p id="fc11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来再次执行<code class="fe mu mv mw mx b">res.bar(2)</code>。注意<code class="fe mu mv mw mx b">res.bar(2)</code>和<code class="fe mu mv mw mx b">res.bar(1)</code>是平行关系，我们应该这样画范围图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pr"><img src="../Images/f468960e6afb6048d264a00331c5e32c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7RUWuTq2NNAtk4oV_f6AHg.png"/></div></div></figure><p id="c376" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以在这段代码中，控制台也输出了值0。</p><p id="78ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">执行<code class="fe mu mv mw mx b">res.bar(3)</code>的进程也是如此，控制台仍然打印0。</p><p id="9505" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以上面代码的最终结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ps"><img src="../Images/f1c5b40adc443c8ceae226d6c85bfcd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:896/format:webp/1*sMaj3AY4Y9acrJmANrG1qg.png"/></div></figure><p id="9879" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">其实上面的问题可以换成其他方式。例如，它可以更改为以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pt"><img src="../Images/3c9c254fa5f57d87eb66f95bcbe1b8ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7IzXFeSOtWgaehlej4ubJA.png"/></div></div></figure><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="f8ae" class="nl lt iq mx b gy nm nn l no np">function foo(a,b) {<br/>  console.log(b)<br/>  return {<br/>    foo:function(c){<br/>      return foo(c,a);<br/>    }<br/>  };<br/>}</span><span id="f865" class="nl lt iq mx b gy nq nn l no np">foo(0).foo(1).foo(2).foo(3);</span></pre><p id="0143" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们解决这个问题之前，我们需要做的第一件事是区分这两个不同的foo函数，所以上面的代码可以修改成这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pu"><img src="../Images/cdc16988ec90856eb5eb83af8ccaafc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4U1S2J_Oqh5ZwdZg2V0pqQ.png"/></div></div></figure><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="8c29" class="nl lt iq mx b gy nm nn l no np">function foo(a,b) {<br/>  console.log(b)<br/>  return {<br/>    bar:function(c){<br/>      return foo(c,a);<br/>    }<br/>  };<br/>}</span><span id="9e30" class="nl lt iq mx b gy nq nn l no np">foo(0).bar(1).bar(2).bar(3);</span></pre><p id="40fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当它执行<code class="fe mu mv mw mx b">foo(0)</code>时，作用域和之前一样，然后控制台会打印出‘未定义’。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pv"><img src="../Images/8f7d4f4762a06e5841016a8281a0cb3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XuU29AshQgY1tSBgh18bOw.png"/></div></div></figure><p id="7ac9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后执行<code class="fe mu mv mw mx b">.bar(1)</code>创建一个新的范围。这个参数1其实就是c的值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pw"><img src="../Images/568e44f150d68b734b4ced42e1719fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t46A6iYEvCoCHD6yu38VyA.png"/></div></div></figure><p id="afb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后<code class="fe mu mv mw mx b">.bar(1)</code>方法再次调用<code class="fe mu mv mw mx b">foo(c, a)</code>，其实就是<code class="fe mu mv mw mx b">foo(1, 0)</code>。这里的参数1实际上将是新作用域中<code class="fe mu mv mw mx b">a</code>的值，而0将是新作用域中<code class="fe mu mv mw mx b">b</code>的值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi px"><img src="../Images/a0dd180328c91783dc1ace547c3c48fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4YC_Cn2J4OjukDbu-tfdDg.png"/></div></div></figure><p id="090f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以控制台然后打印出<code class="fe mu mv mw mx b">b</code>的值，它是0。</p><p id="2b32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mu mv mw mx b">.bar(2)</code>再次被调用，新作用域中<code class="fe mu mv mw mx b">c</code>的值为2:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi py"><img src="../Images/26a3074c94645c1a5e39561e9d027202.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IY2NKZQt5qSX_TojasiMhw.png"/></div></div></figure><p id="acb4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后<code class="fe mu mv mw mx b">.bar(2)</code>调用<code class="fe mu mv mw mx b">foo(c, a)</code>，其实就是<code class="fe mu mv mw mx b">foo(2, 1)</code>，其中2是新范围内<code class="fe mu mv mw mx b">a</code>的值，1是新范围内<code class="fe mu mv mw mx b">b</code>的值。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi po"><img src="../Images/83cb2bf2c35e90cd604e8989407b6618.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RsL4tQFZUKdkoLHgz9-96A.png"/></div></div></figure><p id="0a9d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">于是控制台然后打印出<code class="fe mu mv mw mx b">b</code>的值，也就是<code class="fe mu mv mw mx b">0</code>。</p><p id="20f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后它会执行<code class="fe mu mv mw mx b">.bar(3)</code>，过程和之前一样，所以我不打算展开描述，这一步控制台打印出2。</p><p id="6942" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如上所述，代码运行的最终结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pz"><img src="../Images/f17837e63783dcd8f3bfddceea64f223.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*4vxW7K1qGp-swKIEIH27eA.png"/></div></figure><p id="7167" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，经过长途跋涉，我们终于得到了答案。这个问题很好地测试了受访者对闭包和作用域的理解。</p><h1 id="06fc" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.构成</h1><p id="2b06" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">假设我们有一个这样的函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qa"><img src="../Images/c7da5d4443866215fbe02fd65264631f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SVziaA-SUpwNs3Psfv8eew.png"/></div></div></figure><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="d706" class="nl lt iq mx b gy nm nn l no np">function compose (middleware) {<br/>  // some code<br/>}</span></pre><p id="a6f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">compose函数接受函数数组<code class="fe mu mv mw mx b">middleware</code>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qb"><img src="../Images/eab060d2fec4c8cf6c0456faf4be6c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lXDSD2xEtX5tinKEEYC3Aw.png"/></div></div></figure><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="b137" class="nl lt iq mx b gy nm nn l no np">let middleware = []<br/>middleware.push((next) =&gt; {<br/> console.log(1)<br/> next()<br/> console.log(1.1)<br/>})<br/>middleware.push((next) =&gt; {<br/> console.log(2)<br/> next()<br/> console.log(2.1)<br/>})<br/>middleware.push(() =&gt; {<br/>    console.log(3)<br/>})</span><span id="2800" class="nl lt iq mx b gy nq nn l no np">let fn = compose(middleware)<br/>fn()</span></pre><p id="f42c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们试图执行<code class="fe mu mv mw mx b">fn</code>时，它调用中间件中的函数，并将<code class="fe mu mv mw mx b">next</code>函数作为参数传递给每个小函数。</p><p id="9a45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们在一个小函数中执行<code class="fe mu mv mw mx b">next</code>，那么这个函数在中间件中的<code class="fe mu mv mw mx b">next</code>函数被调用。如果你不执行<code class="fe mu mv mw mx b">next</code>，程序就不会运行。</p><p id="9f14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">执行上述代码后，我们得到以下结果:</p><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="6d90" class="nl lt iq mx b gy nm nn l no np">1<br/>2<br/>3<br/>2.1<br/>1.1</span></pre><p id="9cf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们如何编写一个组合函数来完成这个任务呢？</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="72af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，compose函数必须返回一个组合函数，所以我们可以这样写代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pu"><img src="../Images/31f698970c394ff3a8186dfcc1e73447.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qQ7j5jQxEhIkB7HMoD_NBQ.png"/></div></div></figure><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="7abb" class="nl lt iq mx b gy nm nn l no np">function compose (middleware) {<br/>  return function () {<br/>  }<br/>}</span></pre><p id="f7ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，在返回的函数中，中间件的第一个函数开始执行。我们还将传递<code class="fe mu mv mw mx b">next</code>函数作为它的参数。所以让我们这样写:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qc"><img src="../Images/a2bbae3acedf0cd0d27781a676d157bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ocksMzq-LQvuRj-Y2AXhyQ.png"/></div></div></figure><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="5618" class="nl lt iq mx b gy nm nn l no np">function compose (middleware) {<br/>  return function () {<br/>    let f1 = middleware[0]<br/>    f1(function next(){<br/>    })<br/>  }<br/>}</span></pre><p id="5fb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一个函数作为一个开关继续通过中间件，看起来像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qd"><img src="../Images/50a9bedbc4bb573b17919a004f4ff976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNitfrkLsN2L62KjHfkCng.png"/></div></div></figure><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="d2de" class="nl lt iq mx b gy nm nn l no np">function compose (middleware) {<br/>  return function () {<br/>    let f1 = middleware[0]<br/>    f1(function next(){<br/>      let f2 = middleware[1]<br/>      f2(function next(){<br/>        ...<br/>      })<br/>    })<br/>  }<br/>}</span></pre><p id="0b24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后继续调用下一个函数中的第三个函数……等等，这看起来像递归！所以我们可以写一个递归函数来完成这个嵌套调用:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qa"><img src="../Images/9574572b7eb52ea1bb8c0b52f336f9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w3dkGlcxj1mpVcQklJoALg.png"/></div></div></figure><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="86ab" class="nl lt iq mx b gy nm nn l no np">function compose (middleware) {<br/>   return function () {<br/>      dispatch(0)<br/>      function dispatch (i) {<br/>         const fn = middleware[i]<br/>         if (!fn) return null<br/>         fn(function next () {<br/>            dispatch(i + 1)<br/>         })<br/>      }<br/>   }<br/>}</span></pre><p id="c3ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，这就是我们的合成函数，让我们来测试一下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qe"><img src="../Images/3a782443aca7314825b19fa0cabade00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UtEfuc-zxJvNfda_uwhtyg.png"/></div></div></figure><p id="2ef6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数做了它需要做的事情。但是我们也可以优化我们的组合函数来支持异步函数。我们可以改进以下代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi qf"><img src="../Images/33c6790042045853d6769ab22e8b8aa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1rCVEcw-nAskEF8PLwZUWA.png"/></div></div></figure><pre class="kg kh ki kj gt nh mx ni nj aw nk bi"><span id="82af" class="nl lt iq mx b gy nm nn l no np">function compose (middleware) {<br/>   return async function () {<br/>      await dispatch(0)<br/>      function async dispatch (i) {<br/>         const fn = middleware[i]<br/>         if (!fn) return null<br/>         await fn(function next () {<br/>            dispatch(i + 1)<br/>         })<br/>      }<br/>   }<br/>}</span></pre><p id="dca3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">实际上，上面的<code class="fe mu mv mw mx b">compose</code>函数就是众所周知的节点框架<a class="ae kv" href="https://github.com/koajs/koa" rel="noopener ugc nofollow" target="_blank"> koa </a>的核心机制。</p><p id="8359" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我选择一个候选人时，我承认他/她不熟悉某些框架。毕竟，JavaScript生态系统中有如此多的库和框架，没有人能够全部掌握。但是我确实希望候选人了解这些重要的普通JavaScript技巧，因为它们是所有库和框架的基础。</p><h1 id="d214" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="de21" class="pw-post-body-paragraph kw kx iq ky b kz ns jr lb lc nt ju le lf nu lh li lj nv ll lm ln nw lp lq lr ij bi translated">其实我的草稿里还有一些其他的面试问题，由于文章篇幅有限，这里就不继续解释了。以后再和你分享。</p><p id="248d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文主要讨论普通JavaScript，而不是浏览器、节点、框架、算法、设计模式等。如果你也对这些话题感兴趣，欢迎发表评论。</p><p id="f15f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>