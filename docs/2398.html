<html>
<head>
<title>Juggle arrays like a pro with these JavaScript statements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用这些JavaScript语句像专家一样处理数组</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/juggle-arrays-like-a-pro-with-these-javascript-statements-929be25ccbd5?source=collection_archive---------9-----------------------#2020-06-20">https://javascript.plainenglish.io/juggle-arrays-like-a-pro-with-these-javascript-statements-929be25ccbd5?source=collection_archive---------9-----------------------#2020-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c610" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript数组的6个不太容易的部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f18b9e8b6eba6a21610d0014333e78da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ebdtfI_ndPdq3yAR9zJKNw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">An array of oriented coloured cars (original photo <a class="ae kv" href="https://www.needpix.com/photo/1535968/array-auto-car-color-colorful-cute-mini-multi-rainbow" rel="noopener ugc nofollow" target="_blank">here</a>)</figcaption></figure><p id="7f8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript中的<strong class="ky ir"> <em class="ls">数组</em> </strong>对象有相当多的操作方法，这些方法往往被一般程序员所忽略。每个人都喜欢使用琐碎的<strong class="ky ir"> <em class="ls">来实现</em> </strong>循环，而不是冒险去尝试那些很难理解且有点神秘的函数。</p><p id="26a8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">事实上，没有人能否认最流行的手册对克服这个障碍没有多大帮助，因为它们用简单的例子解释这些方法，对于那些面临真正编程问题的人来说用处不大。</p><p id="f4e9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是为什么我决定提供一些更复杂、更现实的使用这些函数的例子，希望能说服一些好心的程序员采取额外的步骤，在JavaScript中专业地使用数组。</p><p id="2b45" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于编程中最常见的数组是对象的<strong class="ky ir"> <em class="ls">数组</em> </strong>，我将使用一个或多个描述彩色汽车的数组作为练习的基础，如上图所示。</p><p id="c6be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，数组中的每一项都是包含汽车属性的JavaScript对象，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A <strong class="ak"><em class="lv">car </em></strong><em class="lv">object</em></figcaption></figure><p id="7413" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我知道，上面的照片不包含任何法拉利，但…使用一点想象力。无论如何，让我们为我们的练习场创建一个数组:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">An array of car objects</figcaption></figure><p id="d3dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们走吧！</p><h2 id="f8e3" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">1)寻找具有给定属性的最大值的元素</h2><p id="8c1d" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">在我们的例子中，让我们找到价格最高的汽车。如果我们只想要一个结果(即使在平局的情况下)，我们可以使用。<strong class="ky ir"> <em class="ls">减少</em> </strong>的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Find the first car with the maximum price</figcaption></figure><p id="22a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，使用ES6箭头语法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><h2 id="fc1a" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">它是如何工作的</h2><p id="ae2d" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated"><strong class="ky ir">。<em class="ls"> reduce </em>在这种情况下，仅当</strong>新价格高于先前价格时，计算才包括用新条目<strong class="ky ir">替换结果(先前条目);因此，最终结果将等于找到的具有最高价格的第一个条目。</strong></p><p id="3404" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">注意:如果你只想得到最高的价格，而不是整个“车”的对象，最紧凑的解决方案是:</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><h2 id="f274" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">它是如何工作的</h2><p id="db3b" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">。map </em> </strong>方法创建一个与car_array元素个数相同的简单数组，包含每辆车的<strong class="ky ir"> <em class="ls">价格</em> </strong> <em class="ls"> </em>属性。“<strong class="ky ir"><em class="ls">…”</em></strong>spread运算符将价格数组转换为<strong class="ky ir"> <em class="ls"> Math.max </em> </strong>函数的不同参数列表。</p><p id="b4f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">警告</em> </strong>:考虑一下，对于大型数组，上述表达式可能会超出JavaScript引擎堆栈限制，因为每个数组元素的副本都被压入堆栈。在这样的情况下，你可以再次使用<strong class="ky ir"> <em class="ls">。减少</em> </strong>的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="faf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想让所有的车都有相同的最高价格，万一出现平局呢？您必须将它们作为子数组从原始数组中提取出来；解决方案可以是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><h2 id="f5a6" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">它是如何工作的</h2><p id="7be4" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">首先，通过<strong class="ky ir">和<em class="ls">计算最高价格。减少</em> </strong>，然后使用<strong class="ky ir"> <em class="ls">将价格等于最大值的汽车提取到一个新数组中。</em>过滤</strong>方法。</p><h2 id="3052" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">2)按两个属性的值排序</h2><p id="4f2a" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">假设我们想要得到一个汽车列表，按照<em class="ls">品牌</em>和<em class="ls">价格降序排列。</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><h2 id="a3ac" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">工作原理:</h2><p id="5991" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">。sort </em>在我们的例子中，我们使用条件三元赋值来比较<em class="ls">和</em>的价格，并且只有当价格相等时，才比较<em class="ls">和</em>的价格。</strong></p><p id="d70b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">注意:要注意的是</em> <strong class="ky ir"> <em class="ls">。sort </em> </strong> <em class="ls">方法不返回数组的副本，但它改变原来的数组。</em></p><h2 id="ce8e" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">3)删除重复的元素</h2><p id="0c7a" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">如果我们的数组不包含对象，那么删除重复行的最简洁的方法就是下面这条精彩的ES6语句:</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="6d6e" class="lw lx iq mv b gy mz na l nb nc">var unique = […new Set(myarray)];</span></pre><h2 id="46f0" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">它是如何工作的</h2><p id="4170" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">根据定义，<strong class="ky ir"> <em class="ls"> Set </em> </strong>对象包含唯一值，因此当从数组创建集合时，JavaScript会自动排除重复值。之后，“<strong class="ky ir"> … </strong>”运算符将集合拆分成单个元素，并用<strong class="ky ir"> [] </strong>括号将它们组成一个新数组。</p><p id="8bf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">不幸的是</em>，</strong>这不是处理<em class="ls">对象</em>数组的正确方法，因为该操作隐式地使用简单比较来匹配数组中的任意两个对象，但是我们不能像处理简单数据类型那样比较两个对象。例如，以下表达式:</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="a802" class="lw lx iq mv b gy mz na l nb nc">{id: 1, make: ‘Ferrari’} === {id: 1, make: ‘Ferrari’}</span><span id="ecf6" class="lw lx iq mv b gy nd na l nb nc">{} === {}</span></pre><p id="bb0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">都是<strong class="ky ir">假</strong>，即使对我们人类来说明目张胆<strong class="ky ir">真</strong>。</p><p id="ec20" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看在我们的<strong class="ky ir"> <em class="ls">汽车</em> </strong>数组中删除重复的正确方法是什么。对于完全重复的条目(即所有属性具有相同的值)，可能的解决方案是:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><h2 id="0781" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">工作原理:</h2><p id="ff4b" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我们的数组首先被转换成一个字符串数组(其中<strong class="ky ir"> <em class="ls"> JSON.stringify </em> </strong>通过<strong class="ky ir"> <em class="ls">应用于所有项目)。map </em> </strong>)，然后创建一个新的集合来删除重复的字符串，最后，使用通过<strong class="ky ir"> <em class="ls">应用的“<strong class="ky ir"> … </strong>”、<strong class="ky ir"> <em class="ls"> [] </em> </strong>运算符和<strong class="ky ir"> <em class="ls"> JSON.parse </em> </strong>将该集合转换回对象数组。</em>地图</strong>。</p><p id="3956" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想将两辆具有某些共同属性(并非所有属性)的汽车视为复制品，例如<em class="ls">制造</em>和<em class="ls">型号</em>，我们可以使用不同的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><h2 id="20f8" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">它是如何工作的</h2><p id="76db" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated"><strong class="ky ir"> <em class="ls">。filter </em> </strong>方法<strong class="ky ir"> <em class="ls"> </em> </strong>通过提取满足第一个函数所表达的标准的所有元素来构建一个新数组。</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="5709" class="lw lx iq mv b gy mz na l nb nc">(item,index) =&gt; index === cars.findIndex(...)</span></pre><p id="b13d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该函数将当前元素索引与满足内部函数所表达的条件的第一个索引进行比较</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="c567" class="lw lx iq mv b gy mz na l nb nc">car =&gt; car.make === item.make &amp;&amp; car.model === item.model</span></pre><p id="c4cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果索引相等，这意味着当前元素是具有给定属性的第一个元素(在我们的示例中，第一个元素具有相等的make+model)。</p><h2 id="fc13" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">4)按一个或多个属性对值进行分组</h2><p id="d44b" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">假设我们想知道每个汽车制造商的产品数量，以及相应的价格范围:我们需要以类似于在SQL中使用GROUP BY子句和COUNT()、MIN()和MAX()等聚合函数的方式来聚合值。</p><p id="9154" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个可能的解决方案是利用<strong class="ky ir"> <em class="ls">。减少</em>和</strong>的方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><h2 id="f881" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">它是如何工作的</h2><p id="84d4" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated"><strong class="ky ir">的第二个论点<em class="ls">。reduce </em> </strong>是最终结果的初始值<strong class="ky ir"> <em class="ls"> {} </em> </strong>，是内部函数在数组元素循环时对聚合求和的对象。</p><p id="7dd6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们需要根据多个属性进行分组，例如<em class="ls"> make </em>和<em class="ls"> colour </em>，我们改变结果数组的索引方式，例如:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><h2 id="47d1" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">5)合并两个数组</h2><p id="2ad3" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">让我们为我们的游戏添加另一个数组:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="dacf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何才能合并<strong class="ky ir"> <em class="ls">车</em> </strong>和<strong class="ky ir"> <em class="ls">车2 </em> </strong>？</p><p id="4a19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一种方法:将一个附加到另一个并删除重复项(这里我们认为是具有相同<strong class="ky ir"> <em class="ls"> id </em> </strong>的两辆汽车的重复项):</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><p id="608b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我们用的是<strong class="ky ir"> <em class="ls">。concat </em> </strong>方法，后跟示例#3中所示的相同过滤器。在平局的情况下，我们从第一个数组中获取汽车；如果我们想做相反的事情，优先考虑第二个数组，我们将在<em class="ls"> .concat. </em>中交换它们的角色</p><p id="86fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另一种方法是使用<strong class="ky ir"> <em class="ls">。减少</em> </strong>的方法循环超过<em class="ls">汽车2: </em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><h2 id="5aaf" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">它是如何工作的</h2><p id="5dd2" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">使用<em class="ls">cars</em>(“cars . slice(0)”作为<em class="ls">的第二个参数)的副本初始化<em class="ls">结果</em>数组。减少</em>)；在每次迭代中，如果当前的<em class="ls"> id </em>不在<em class="ls">汽车</em>中，则该行被追加到<em class="ls">结果中。</em></p><p id="fb1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想要两个数组的交集，即一个只包含公共元素的新数组，该怎么办？如前所述，如果我们的数组不包含对象，将会有一个非常紧凑的解决方案:</p><pre class="kg kh ki kj gt mu mv mw mx aw my bi"><span id="1da0" class="lw lx iq mv b gy mz na l nb nc">array1.filter(value =&gt; array2.includes(value))</span></pre><p id="7de3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相反，由于我们正在处理对象，我们被迫使用稍微复杂一点的解决方案:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><h2 id="5d6e" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">6)重构阵列</h2><p id="17b4" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">最后一个练习:让我们创建一个数组，它是由以下人员构建的<em class="ls">汽车</em>、<em class="ls"> </em>的返工版本:</p><ul class=""><li id="9cb4" class="ne nf iq ky b kz la lc ld lf ng lj nh ln ni lr nj nk nl nm bi translated">按加价排序条目；</li><li id="a1f0" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">给它们一个新的<em class="ls">位置</em>属性，指示数组中的相对位置；</li><li id="6684" class="ne nf iq ky b kz nn lc no lf np lj nq ln nr lr nj nk nl nm bi translated">移除<em class="ls">颜色</em>属性。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="lt lu l"/></div></figure><h2 id="d3c7" class="lw lx iq bd ly lz ma dn mb mc md dp me lf mf mg mh lj mi mj mk ln ml mm mn mo bi translated">它是如何工作的</h2><p id="d2e9" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">首先，它复制了<em class="ls"> cars2 </em>(带有<em class="ls">)。slice(0) </em>，然后它按价格递增排序；最后，用<strong class="ky ir"> <em class="ls">变换每个元素。绘制</em> </strong>方法。请注意，内部函数的第二个参数(index)用于设置新的<em class="ls">位置</em>属性。</p><h1 id="6552" class="ns lx iq bd ly nt nu nv mb nw nx ny me jw nz jx mh jz oa ka mk kc ob kd mn oc bi translated">结论</h1><p id="90e1" class="pw-post-body-paragraph kw kx iq ky b kz mp jr lb lc mq ju le lf mr lh li lj ms ll lm ln mt lp lq lr ij bi translated">我已经展示了如何使用JavaScript提供的一些更灵活的方法(map、reduce、filter、sort、findIndex)来操作矩阵。</p><p id="9c01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，其他语言为程序员提供了更有效的方法，但我认为至少应该学习如何使用我们拥有的武器。</p></div></div>    
</body>
</html>