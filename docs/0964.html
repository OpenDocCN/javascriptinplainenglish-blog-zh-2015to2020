<html>
<head>
<title>Nuxt Socket.IO: Connection Status and Error Handling Made Easy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nuxt插座。IO:连接状态和错误处理变得简单</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nuxt-socket-io-connection-status-and-error-handling-made-easy-6fcf1c2ac43c?source=collection_archive---------4-----------------------#2020-01-07">https://javascript.plainenglish.io/nuxt-socket-io-connection-status-and-error-handling-made-easy-6fcf1c2ac43c?source=collection_archive---------4-----------------------#2020-01-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8e2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TL；DR——如果你在过去几年中一直从事web开发，你可能听说过关于错误处理的争论。"使用try / catch！"，“不，使用async / await /。接住！”，“不，用承诺/。接住！”。这里介绍了两个新特性，可以帮助开发人员清楚地了解给定IO套接字的连接状态，并以一种更干净、更主动的方式处理错误。随着插件承担起这一责任，现在开发人员对手头的问题有了一个全新的选择和视角，希望关于错误处理的整个争论会因为潜在前提的过时而变得平静。</p><p id="0162" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">声明:我是<a class="ae ki" href="https://npmjs.com/package/nuxt-socket-io" rel="noopener ugc nofollow" target="_blank"> nuxt-socket-io </a>的作者</p></div><div class="ab cl kj kk hr kl" role="separator"><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko kp"/><span class="km bw bk kn ko"/></div><div class="ig ih ii ij ik"><h1 id="e9bb" class="kq kr in bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln bi translated">介绍</h1><p id="43f5" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">除非你是机器人先生，让他的代码第一次工作，否则当你的代码试图从你的后端或其他服务请求数据时，你很可能会遇到错误。最有可能的情况是，您的代码如下所示:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="db82" class="mc kr in ly b gy md me l mf mg">try { <br/>  const resp = await Svc.getData({ userId: 'abc123' })<br/>  if (resp !== undefined) { // Note: Please don't do this. <br/>    // If it's undefined, it's an error if you were expecting a response.<br/>    /* handle response */<br/>  }<br/>} catch (err) {<br/>  /* handle error */ // this placeholder comment stays here forever<br/>  throw new Error(err) // Note: Please don't do this! <br/>  // ^^ Don't catch an error just to throw it!)<br/>}</span></pre><p id="a0a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这两个代码块看起来都很简单，而且有些优雅，但是当您有许多不同类型的请求要发送时，问题可能很快变得一团糟。在您意识到之前，您的代码将被许多try/catch块弄得乱七八糟。考虑到VueJS给了我们反应性属性，并让我们创建计算属性，当其他属性改变时，这些计算属性也会改变，我认为我们可以做得更好！</p><p id="0cd6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是我的观点。当我调用一些方法来获取数据时，这些是我的期望:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="e9a1" class="mc kr in ly b gy md me l mf mg">// I want my request to be simple: (i.e., just make the request)<br/>Svc.getData(...) // I just want to call this and have the response get sent directly to a property "resp".</span><span id="2cf1" class="mc kr in ly b gy mh me l mf mg">// Success handling: (if all was good, handle response)<br/>function handleResp(resp) { // If I want to post-process resp, I call this<br/>  /* handle resp */<br/>  // The response is valid here, if not...<br/>  // I have no business calling this function<br/>}</span><span id="5e03" class="mc kr in ly b gy mh me l mf mg">// Error handling: (if errors occurred, collect them and don't set property "resp")<br/>emitErrors: { // &lt;-- send any errors directly to this property<br/>  getData: [{...}], // &lt;-- send specific getData errors here<br/>  // it's useful to include hints and timestamps<br/>}</span></pre><p id="147d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这样，我可以将我的关注点分开，并保持我的代码完全有组织。如果<code class="fe mi mj mk ly b">emitErrors</code>变得真实，我可以基于此轻松地设计页面或组件的不同部分(使用<em class="ml">计算属性</em>)。另外，如果我可以消除<em class="ml">在<code class="fe mi mj mk ly b">handleResp</code>方法中验证</em>响应的需要，我<em class="ml">也</em>消除了为此拥有<em class="ml">测试用例</em>的需要。节省的时间真的会越来越多。</p><h1 id="b0ad" class="kq kr in bd ks kt mm kv kw kx mn kz la lb mo ld le lf mp lh li lj mq ll lm ln bi translated">连接状态</h1><p id="c3db" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">许多IO错误可以追溯到服务的实际连接。客户端连上了吗？这是要问的最基本的问题，但容易被忽视。幸运的是，socket.io-client公开了几个事件，nuxt-socket-io插件可以监听这些事件来确定状态<em class="ml">，如果</em>用户选择监听的话(下面解释)。下列事件是:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="3c82" class="mc kr in ly b gy md me l mf mg">const clientEvts = [<br/>  'connect_error', <br/>  'connect_timeout',<br/>  'reconnect',<br/>  'reconnect_attempt',<br/>  'reconnecting',<br/>  'reconnect_error',<br/>  'reconnect_failed',<br/>  'ping',<br/>  'pong'<br/>]</span></pre><p id="53b6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果希望检查状态，用户只需通过在实例化<code class="fe mi mj mk ly b">this.$nuxtSocket</code>的同一个组件上定义属性<code class="fe mi mj mk ly b">socketStatus</code>来选择加入。然后,<em class="ml">插件</em>将自动设置状态(它将使用事件名称的大小写形式作为正确的名称，因为这是Javascript中的一个常见约定)。如果希望使用除<code class="fe mi mj mk ly b">socketStatus</code>之外的专有名称，只需设置ioOpts属性<code class="fe mi mj mk ly b">statusProp</code>。</p><p id="2be3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">示例:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="c5b6" class="mc kr in ly b gy md me l mf mg">data() {<br/>  return {<br/>    socketStatus: {}, // simply define this, and it will be populated with the status<br/>    badStatus: {} // Status will be populated here if "statusProp == 'badStatus'"<br/>  }<br/>},<br/>mounted() {<br/>  this.goodSocket = this.$nuxtSocket({<br/>    name: 'goodSocket',<br/>    channel: '/index',<br/>    reconnection: false<br/>  })</span><span id="e060" class="mc kr in ly b gy mh me l mf mg">  this.badSocket = this.$nuxtSocket({<br/>    name: 'badSocket',<br/>    channel: '/index',<br/>    reconnection: true,<br/>    statusProp: 'badStatus' // This will cause 'badStatus' prop to be populated<br/>  })<br/>}</span></pre><p id="69d4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了方便起见，SocketStatus.vue组件现在也和nuxt-socket-io打包在一起，这将有助于可视化状态:(<code class="fe mi mj mk ly b">import SocketStatus from ‘nuxt-socket-io/components/SocketStatus.vue</code>)</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="186c" class="mc kr in ly b gy md me l mf mg">&lt;socket-status :status="socketStatus"&gt;&lt;/socket-status&gt;<br/>&lt;socket-status :status="badStatus"&gt;&lt;/socket-status&gt;</span></pre><p id="33ed" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将产生以下动态表格:</p><figure class="lt lu lv lw gt ms gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/e404bb2cd36e44244944abdc513a5356.png" data-original-src="https://miro.medium.com/v2/resize:fit:1302/format:webp/0*gqJGZGq3h-1aVIRL.png"/></div><figcaption class="mv mw gj gh gi mx my bd b be z dk">Example Socket Status for Two Sockets (one good vs. one bad)</figcaption></figure><p id="d89e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，由于<code class="fe mi mj mk ly b">socketStatus</code> props是反应式的，所以基于连接状态显示或隐藏给定页面的某些部分变得很容易。</p><h1 id="751c" class="kq kr in bd ks kt mm kv kw kx mn kz la lb mo ld le lf mp lh li lj mq ll lm ln bi translated">错误处理</h1><p id="37c3" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">即使连接是稳固的，仍然有可能发生IO错误。错误的两个主要类别可以被认为是:1)超时-和2)非超时相关。该插件允许用户利用新的内置错误处理功能。</p><p id="ea73" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">1) <strong class="jm io">处理超时错误</strong>。如果客户端已连接，但发出了不支持的请求(该请求将永远得不到处理)，则可能会发生超时错误。当实例化<code class="fe mi mj mk ly b">this.$nuxtSocket</code>时，用户通过在IO选项中指定一个<code class="fe mi mj mk ly b">emitTimeout</code> (ms)来选择让插件处理超时错误:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="ba0e" class="mc kr in ly b gy md me l mf mg">this.socket = this.$nuxtSocket({ <br/>  channel: '/examples', <br/>  emitTimeout: 1000  // 1000 ms<br/>})</span></pre><p id="3ef3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，如果发生“发送超时”，有两种可能的结果。一个是，插件的方法将拒绝一个“emitTimeout”错误，这将取决于用户捕捉下游的错误:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="542b" class="mc kr in ly b gy md me l mf mg">this.someEmitMethod() <br/>.catch((err) =&gt; { // If method times out, catch the err<br/>  /* Handle err */<br/>})</span></pre><p id="feae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面允许用户以一种已经熟悉的方式编写代码，然而，我认为有一种更简单的方法来处理错误。</p><p id="2d9d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">该插件可以提供一种完全不同的错误处理方式，这取决于用户是否允许。如果用户在组件上定义了一个属性“emitErrors”，而服务器以一个附加的错误作为响应(例如，一个具有已定义属性“emitError”的对象)，插件不会抛出错误，而是在组件上设置属性(<code class="fe mi mj mk ly b">this.emitErrors</code>)并通过错误的emit事件组织<code class="fe mi mj mk ly b">this.emitErrors</code>。这可能会产生更干净的代码，并使组件的计算属性更容易处理，当“emitErrors”属性更改时，这些计算属性也会更改:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="e20b" class="mc kr in ly b gy md me l mf mg">data() {<br/>  emitErrors: {} // Emit errors will get collected here, if resp.emitError is defined<br/>}<br/>...<br/>this.someEmitMethod() // Now, when this times out, emitErrors will get updated (i.e., an error won't be thrown)</span></pre><p id="345e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重要提示:为了让<code class="fe mi mj mk ly b">this.emitErrors</code>得到更新，服务器必须将它的错误响应作为一个对象发送回来，并定义一个属性“emitError”。建议后端也将错误详细信息附加到响应中，以帮助进行故障排除。</p><p id="3bf4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2) <strong class="jm io">处理非超时错误</strong>，比如错误请求，或者任何特定于应用程序后端的错误。同样，像以前一样，如果<code class="fe mi mj mk ly b">this.emitErrors</code>在组件中定义，<em class="ml">和</em>响应是一个具有定义属性“emitError”的对象，属性<code class="fe mi mj mk ly b">this.emitErrors</code>将在组件上设置，否则，将抛出“emitError”。如果希望对emitErrors属性使用不同的名称，可以通过在ioOptions中指定“emitErrors prop”来实现:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="6612" class="mc kr in ly b gy md me l mf mg">data() {<br/>  myEmitErrors: {} // Emit errors will get collected here now<br/>}</span><span id="4bb8" class="mc kr in ly b gy mh me l mf mg">mounted() {<br/>  this.socket = this.$nuxtSocket({ <br/>    emitErrorsProp: 'myEmitErrors' <br/>  })<br/>}</span></pre><h1 id="033d" class="kq kr in bd ks kt mm kv kw kx mn kz la lb mo ld le lf mp lh li lj mq ll lm ln bi translated">未兑现的承诺</h1><p id="ca44" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">在文章的开头，我的第一个代码片段提到了我希望空的响应被认为是一个错误。这仍然是我想考虑的事情，然而，在我写这篇文章的时候，插件并没有这样对待它。它只将定义的<code class="fe mi mj mk ly b">resp.emitError</code>视为非超时错误。我认为现在更安全的做法是，假设不是所有的用户都希望我为他们处理他们的空响应，这就是为什么我要求他们以上述方式选择加入。如果有足够多的人想要自动的空响应处理，我会很高兴，但是我首先想看看人们在构建更多代码之前对代码的理解程度。一步步来。</p><h1 id="3ba9" class="kq kr in bd ks kt mm kv kw kx mn kz la lb mo ld le lf mp lh li lj mq ll lm ln bi translated">结论</h1><p id="715d" class="pw-post-body-paragraph jk jl in jm b jn lo jp jq jr lp jt ju jv lq jx jy jz lr kb kc kd ls kf kg kh ig bi translated">本文回顾了一种完全不同的，并且有望更简单的方法来处理IO连接状态和错误。当生活似乎只给我们提供了几种解决问题的方法时(尝试/抓住与承诺/抓住)，我喜欢尽可能想出另一种更省力的方法来解决问题。插件现在包括了其他的方式，我希望你会觉得有帮助！</p></div></div>    
</body>
</html>