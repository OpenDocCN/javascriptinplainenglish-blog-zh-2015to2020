<html>
<head>
<title>A guide to the Cache API</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">缓存API指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-guide-to-the-cache-api-88a81621dca8?source=collection_archive---------8-----------------------#2020-05-27">https://javascript.plainenglish.io/a-guide-to-the-cache-api-88a81621dca8?source=collection_archive---------8-----------------------#2020-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3f9e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">缓存请求及其相应响应的快速指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6afc9962d78572e80807cf0cb1a441b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hr163PtOXSQFehc5vNFmpg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://www.pexels.com/@padrinan?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Miguel Á. Padriñán</a> from <a class="ae kv" href="https://www.pexels.com/photo/store-text-signage-1591057/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="f666" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">缓存API为请求/响应对象对提供了一种存储机制。它允许您缓存资源，如资产、图像、javascript文件、HTML、API响应。</p><p id="e5a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它最初是作为服务工作者规范的一部分创建的，用于缓存请求并提供快速离线响应，但它也可以用作通用存储机制。在这篇文章中，我们将讨论缓存API的一些基础知识。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e016" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">检查可用性</h1><p id="6842" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><em class="mw">缓存</em>对象在窗口对象上直接可用，因此我们可以通过以下方式检查它是否存在:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="2d87" class="nc ma iq my b gy nd ne l nf ng">'caches' in window &amp;&amp; console.log('available')</span></pre><p id="c424" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果浏览器支持缓存API，则返回可用的<strong class="ky ir"/>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="88dd" class="nc ma iq bd mb nh ni dn mf nj nk dp mj lf nl nm ml lj nn no mn ln np nq mp nr bi translated">打开缓存</h2><p id="d44e" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">打开一个缓存就像调用<em class="mw"> caches.open('cacheName') </em>一样简单，它返回一个用缓存对象解析的承诺。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="e626" class="nc ma iq my b gy nd ne l nf ng">caches.open('cacheName').then(cache =&gt; {<br/>    //make use of cache object now<br/>})</span></pre><blockquote class="ns nt nu"><p id="5db1" class="kw kx mw ky b kz la jr lb lc ld ju le nv lg lh li nw lk ll lm nx lo lp lq lr ij bi translated"><em class="iq">注意:如果缓存不存在，它会创建一个新的缓存。</em></p></blockquote></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="0d40" class="nc ma iq bd mb nh ni dn mf nj nk dp mj lf nl nm ml lj nn no mn ln np nq mp nr bi translated">检查缓存中是否有东西</h2><p id="5624" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><em class="mw"> cache.keys() </em>可用于获取缓存中存在的所有键。它返回一个解析为缓存键数组的承诺。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="2465" class="nc ma iq my b gy nd ne l nf ng">cache.keys().then(keys =&gt; {<br/>    //array of cache keys<br/>})</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="f15e" class="nc ma iq bd mb nh ni dn mf nj nk dp mj lf nl nm ml lj nn no mn ln np nq mp nr bi translated">添加到缓存</h2><p id="0694" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">将内容放入缓存的三种方法——add、addAll、put。</p><ol class=""><li id="1e16" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated">cache.add(请求)</li></ol><p id="3a54" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接受请求URL，获取它并将响应添加到缓存中。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="25d4" class="nc ma iq my b gy nd ne l nf ng">const url = 'api/getPosts'<br/>cache.add(url)</span></pre><p id="85a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.cache.addAll(请求)</p><p id="03b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接受一组请求，获取它们，然后将它们的响应添加到缓存中。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="0d54" class="nc ma iq my b gy nd ne l nf ng">const urls = ['api/getPosts', 'api/getTodos']<br/>cache.addAll(urls)</span></pre><p id="f8ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.cache.put(请求)</p><p id="06e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">获取请求URL并缓存其响应。如果请求URL的响应已经存在，它将被新的响应覆盖。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="139d" class="nc ma iq my b gy nd ne l nf ng">const url = 'api/getSinglePost'<br/>cache.put(url)</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="a00a" class="nc ma iq bd mb nh ni dn mf nj nk dp mj lf nl nm ml lj nn no mn ln np nq mp nr bi translated">从缓存中获取项目</h2><p id="ec19" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">缓存API为此提供了两种方法:match、matchAll。</p><ol class=""><li id="4295" class="ny nz iq ky b kz la lc ld lf oa lj ob ln oc lr od oe of og bi translated">cache.match(请求)</li></ol><p id="ad16" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将缓存中的第一个响应与请求URL进行匹配，并返回一个解决该问题的承诺。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="02b0" class="nc ma iq my b gy nd ne l nf ng">const url = 'api/getSinglePost';<br/>cache.match(url).then(response =&gt; {<br/>    //first matched response for the requested url<br/>})</span></pre><p id="90b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.cache.matchAll(请求)</p><p id="215e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这类似于addAll，因为它接受一个请求URL数组。返回解析所提供请求的所有响应的承诺。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="7d90" class="nc ma iq my b gy nd ne l nf ng">const urls = ['api/getPosts', 'api/getTodos'];<br/>cache.matchAll(urls).then(responses =&gt; {<br/>    //all responses that match to request urls<br/>})</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="2fc4" class="nc ma iq bd mb nh ni dn mf nj nk dp mj lf nl nm ml lj nn no mn ln np nq mp nr bi translated">从缓存中删除项目</h2><p id="8aa0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><em class="mw"> cache.delete() </em>可用于从缓存中删除请求或资产URL。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="79d2" class="nc ma iq my b gy nd ne l nf ng">cache.delete('assets/icon.png')</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="cea7" class="nc ma iq bd mb nh ni dn mf nj nk dp mj lf nl nm ml lj nn no mn ln np nq mp nr bi translated">删除整个缓存</h2><p id="3611" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">接受一个缓存键并将其从缓存中完全删除。如果缓存被删除，则返回解析为true的承诺，否则返回false。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="0dd8" class="nc ma iq my b gy nd ne l nf ng">caches.delete('cacheName').then(status =&gt;{<br/>    //whether cache deleted or not<br/>})</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="83bf" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">结论</h1><p id="7344" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">还值得一提的是，浏览器对源可以使用的缓存存储量有一个硬性限制。因此，请确保随着时间的推移清除缓存条目。</p><p id="000b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浏览器兼容性如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/fae3045cee92088f532c45dce400eecb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P47QlW-PbU1X8P_gE2MFUQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://caniuse.com/#search=cache%20api" rel="noopener ugc nofollow" target="_blank">https://caniuse.com/#search=cache%20api</a></figcaption></figure><h1 id="2f68" class="lz ma iq bd mb mc oi me mf mg oj mi mj jw ok jx ml jz ol ka mn kc om kd mp mq bi translated"><strong class="ak">用简单英语写的便条</strong></h1><p id="2b76" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> plainenglish.io </strong> </a>找到所有这些内容——关注我们的出版物并<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅我们的YouTube频道</strong> </a> <strong class="ky ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>