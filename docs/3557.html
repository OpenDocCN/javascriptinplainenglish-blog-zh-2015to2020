<html>
<head>
<title>JavaScript: The Power of Recursion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:递归的力量</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-the-power-of-recursion-f56effadf63b?source=collection_archive---------7-----------------------#2020-10-08">https://javascript.plainenglish.io/javascript-the-power-of-recursion-f56effadf63b?source=collection_archive---------7-----------------------#2020-10-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="caf5" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">JavaScript Alpha指南</h2><div class=""/><div class=""><h2 id="a206" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">你所需要的就是递归——一个递归概念有多通用的小演示。</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/abd8943a35d7783679bbfd2d55e7bf8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4E9jMcPlNFmy-gZyw7_3Zw.jpeg"/></div></div></figure><blockquote class="kx"><p id="78d7" class="ky kz in bd la lb lc ld le lf lg lh dk translated">要理解递归，首先必须理解递归。</p><p id="b847" class="ky kz in bd la lb li lj lk ll lm lh dk translated">——斯蒂芬·霍金</p></blockquote><p id="2e25" class="pw-post-body-paragraph ln lo in lp b lq lr jx ls lt lu ka lv lw lx ly lz ma mb mc md me mf mg mh lh ig bi translated">我不得不注意到许多程序员在理解递归上有困难。大多数时候，他们不是不知道如何写递归函数，而是不知道如何递归地思考。</p><p id="5e21" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">我会试着向你们展示这并不是一个困难的概念。你必须记住一些事情，我们将会看到这些。</p><p id="90cd" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">我将只关注递归本身的概念。PTC(适当的尾调用)、TCO(尾调用优化)和STC(语法尾调用)今天将不涉及。所有的例子都是JavaScript或TypeScript代码，但是这个概念适用于每一种语言。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/40d455ed760676d291346f96d6ee1cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwJuXAHygbSZF3fT3RRyfw@2x.png"/></div></div></figure><h1 id="aed0" class="mo mp in bd mq mr ms mt mu mv mw mx my kc mz kd na kf nb kg nc ki nd kj ne nf bi translated">什么是递归</h1><p id="a399" class="pw-post-body-paragraph ln lo in lp b lq ng jx ls lt nh ka lv lw ni ly lz ma nj mc md me nk mg mh lh ig bi translated">递归是一种有用的编程模式，对于那些可以分解成几个同类任务的任务。但是更简单。</p><p id="897d" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">这是一个编程术语，意思是<strong class="lp ix">从自身调用函数</strong>。当一个函数调用自己时，这被称为一个<strong class="lp ix">递归步骤</strong>。</p><p id="8e54" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated"><strong class="lp ix">递归是函数调用自身。直到它不存在。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/aa0fe33e9c6c509f2d26331279dfe7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SBCbFfmQQOsIt48FDz-tA@2x.png"/></div></div></figure><p id="46fc" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">递归算法与<a class="ae nl" href="https://en.wikipedia.org/wiki/Recursive_data_type" rel="noopener ugc nofollow" target="_blank">递归定义的数据结构</a>配合得很好。递归定义的数据结构是可以使用自身定义的数据结构。使用TypeScript，它看起来像这样:</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="6df2" class="nr mp in nn b gy ns nt l nu nv">interface List&lt;T&gt; {<br/>    value: T,<br/>    next: List&lt;T&gt; | null<br/>}</span><span id="3711" class="nr mp in nn b gy nw nt l nu nv">const list: List&lt;number&gt; = {<br/>    value: 1,<br/>    next: {<br/>        value: 2,<br/>        next: {<br/>            value: 3,<br/>            next: null<br/>        }<br/>    }<br/>}</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/aa0fe33e9c6c509f2d26331279dfe7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SBCbFfmQQOsIt48FDz-tA@2x.png"/></div></div></figure><p id="1ee4" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated"><strong class="lp ix">递归函数不一定要返回值。</strong>返回值的递归函数的一个例子是诸如<code class="fe nx ny nz nn b">sum</code>、<code class="fe nx ny nz nn b">fibonacci</code>、<code class="fe nx ny nz nn b">map</code>、<code class="fe nx ny nz nn b">filter</code>、<code class="fe nx ny nz nn b">reverse</code>的函数。</p><p id="0a0a" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">但是当你有一个递归定义的数据结构或者<a class="ae nl" href="https://www.programiz.com/dsa/trees" rel="noopener ugc nofollow" target="_blank">树数据结构</a>时，你可以决定在访问一个节点时执行一些动作。通常，递归函数有两个参数——结构本身和访问节点时执行的回调函数。</p><p id="a1a0" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">我们将关注返回值的递归函数。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/40d455ed760676d291346f96d6ee1cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwJuXAHygbSZF3fT3RRyfw@2x.png"/></div></div></figure><h1 id="dad3" class="mo mp in bd mq mr ms mt mu mv mw mx my kc mz kd na kf nb kg nc ki nd kj ne nf bi translated">递归函数的两种情况</h1><p id="607a" class="pw-post-body-paragraph ln lo in lp b lq ng jx ls lt nh ka lv lw ni ly lz ma nj mc md me nk mg mh lh ig bi translated">递归函数有两种情况:</p><ul class=""><li id="b877" class="oa ob in lp b lq mi lt mj lw oc ma od me oe lh of og oh oi bi translated">边缘案例——通常称为基本案例</li><li id="a8b6" class="oa ob in lp b lq oj lt ok lw ol ma om me on lh of og oh oi bi translated">递归情况</li></ul><p id="f30c" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">让我们通过下面这个对列表中的元素求和的函数来解释这两个问题:</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="97bb" class="nr mp in nn b gy ns nt l nu nv">function sum(list) {<br/>  if (list.length === 0) {<br/><strong class="nn ix">    return 0; // (A)</strong><br/>  }</span><span id="f63e" class="nr mp in nn b gy nw nt l nu nv">  const [x, ...xs] = list;<br/><strong class="nn ix">  return x + sum(xs); // (B)</strong><br/>}</span><span id="92df" class="nr mp in nn b gy nw nt l nu nv">sum([1, 2, 3]); // 6</span></pre><p id="75ef" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">线<code class="fe nx ny nz nn b">(A)</code>示出了边缘情况。<strong class="lp ix"/><strong class="lp ix">边缘情况非常重要，因为那是你停止递归的地方。</strong>如果你不识别一个边界情况，递归将永远不会停止，你将耗尽内存。</p><p id="c6e0" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">第<code class="fe nx ny nz nn b">(B)</code>行说明了递归情况。<strong class="lp ix">在这种情况下，调用函数本身仍然有意义。</strong>这个调用创建了一个新的递归步骤。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oo"><img src="../Images/c9c1c88fd2c0d4acfb6b23ebdb4f86c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ILs2Wa8mNlc51-DQkn4rBw.jpeg"/></div></div><figcaption class="op oq gj gh gi or os bd b be z dk">Recursive sum function</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/40d455ed760676d291346f96d6ee1cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwJuXAHygbSZF3fT3RRyfw@2x.png"/></div></div></figure><h1 id="8790" class="mo mp in bd mq mr ms mt mu mv mw mx my kc mz kd na kf nb kg nc ki nd kj ne nf bi translated">寻找边缘案例</h1><p id="ac85" class="pw-post-body-paragraph ln lo in lp b lq ng jx ls lt nh ka lv lw ni ly lz ma nj mc md me nk mg mh lh ig bi translated">那么实际上如何找到边缘案例呢？试着找出这个问题最简单形式的解决方法。给定上面的<code class="fe nx ny nz nn b">sum</code>函数，你想要求和的最简单的列表是什么？是空名单。</p><blockquote class="kx"><p id="dc12" class="ky kz in bd la lb li lj lk ll lm lh dk translated"><strong class="ak">当递归函数对列表进行操作时，空列表通常是边缘情况。</strong></p></blockquote><p id="0547" class="pw-post-body-paragraph ln lo in lp b lq lr jx ls lt lu ka lv lw lx ly lz ma mb mc md me mf mg mh lh ig bi translated">空列表是递归应用程序没有意义的情况。如果您处理的是树，那么边缘案例通常是没有任何子节点的节点。</p><p id="1e71" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">通常情况下，边缘案例被证明是一个身份。把身份想象成一个<strong class="lp ix">中性元素</strong>。加法的中性元素是什么？现在是<strong class="lp ix"> 0 </strong>。当你把0加到某个东西上，你就把那个东西拿回来了。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="e5c1" class="nr mp in nn b gy ns nt l nu nv">1   + 0 =   1<br/>42  + 0 =  42<br/>256 + 0 = 256</span></pre><p id="16b1" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">同样，做乘法时，中性元素是<strong class="lp ix"> 1 </strong>。当你把某样东西乘以1，你会得到那个东西。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="d225" class="nr mp in nn b gy ns nt l nu nv">0   * 1 =   1<br/>42  * 1 =  42<br/>256 * 1 = 256</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/40d455ed760676d291346f96d6ee1cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwJuXAHygbSZF3fT3RRyfw@2x.png"/></div></div></figure><h1 id="15b9" class="mo mp in bd mq mr ms mt mu mv mw mx my kc mz kd na kf nb kg nc ki nd kj ne nf bi translated">正面和反面</h1><p id="5dee" class="pw-post-body-paragraph ln lo in lp b lq ng jx ls lt nh ka lv lw ni ly lz ma nj mc md me nk mg mh lh ig bi translated">在对列表进行操作时，似乎有一个非常常见的模式。列表被分解为一个<strong class="lp ix">头</strong>和一个<strong class="lp ix">尾。</strong>然后只对其中一个使用递归调用。</p><p id="2315" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">在以下示例中，<strong class="lp ix"> x </strong>为<strong class="lp ix">头；</strong><strong class="lp ix">xs</strong>就是<strong class="lp ix">尾巴。</strong></p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="f1a1" class="nr mp in nn b gy ns nt l nu nv">const list = [1, 2, 3, 4];<br/>const [x, ...xs] = list;</span></pre><p id="b505" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">有时候你需要打破列表来得到除了最后一个以外的所有元素，然后再分别得到最后一个。纯函数式语言有专门用于此的函数，称为<strong class="lp ix"> init </strong>和<strong class="lp ix"> last </strong>。JavaScript没有现成的函数，所以您必须创建自己的函数。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="63dd" class="nr mp in nn b gy ns nt l nu nv">const list = [1, 2, 3, 4];<br/>init(list); // [1, 2, 3]<br/>last(list); // [4]</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ot"><img src="../Images/2db6f49b48a0f8cc95fff82efde86fc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fcs5W7cnQZw6jmBBDPzjug.png"/></div></div><figcaption class="op oq gj gh gi or os bd b be z dk">head, tail, init, last</figcaption></figure><p id="1b31" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">当你将链表拆分到<strong class="lp ix">头</strong>和<strong class="lp ix">尾</strong>时，通常会调用<strong class="lp ix">尾</strong>上的递归函数。</p><p id="4b61" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">当你将链表拆分到<strong class="lp ix"> init </strong>和<strong class="lp ix">last</strong>时，你通常会调用<strong class="lp ix"> init </strong>上的递归函数。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/40d455ed760676d291346f96d6ee1cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwJuXAHygbSZF3fT3RRyfw@2x.png"/></div></div></figure><h1 id="c099" class="mo mp in bd mq mr ms mt mu mv mw mx my kc mz kd na kf nb kg nc ki nd kj ne nf bi translated">例子</h1><h2 id="a887" class="nr mp in bd mq ou ov dn mu ow ox dp my lw oy oz na ma pa pb nc me pc pd ne it bi translated">列表的乘积</h2><p id="ee53" class="pw-post-body-paragraph ln lo in lp b lq ng jx ls lt nh ka lv lw ni ly lz ma nj mc md me nk mg mh lh ig bi translated">列表的乘积是列表的第一个元素乘以列表其余元素的乘积。边缘情况是一个空列表。中性元件为<strong class="lp ix"> 1 </strong>。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="217b" class="nr mp in nn b gy ns nt l nu nv">function product(list) {<br/>  if (list.length === 0) {<br/>    return 1;<br/>  }</span><span id="0cf4" class="nr mp in nn b gy nw nt l nu nv">  const [x, ...xs] = list;<br/>  return x * product(xs);<br/>}</span></pre><h2 id="d794" class="nr mp in bd mq ou ov dn mu ow ox dp my lw oy oz na ma pa pb nc me pc pd ne it bi translated">列表的总和</h2><p id="382a" class="pw-post-body-paragraph ln lo in lp b lq ng jx ls lt nh ka lv lw ni ly lz ma nj mc md me nk mg mh lh ig bi translated">我们以前见过这个，但是让我们回顾一下。列表的总和是列表的第一个元素加上列表其余元素的总和。边缘情况是一个空列表。中性元件是<strong class="lp ix"> 0 </strong>。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="40ca" class="nr mp in nn b gy ns nt l nu nv">function sum(list) {<br/>  if (list.length === 0) {<br/>    return 0;<br/>  }</span><span id="1491" class="nr mp in nn b gy nw nt l nu nv">  const [x, ...xs] = list;<br/>  return x + sum(xs);<br/>}</span></pre><h2 id="ea49" class="nr mp in bd mq ou ov dn mu ow ox dp my lw oy oz na ma pa pb nc me pc pd ne it bi translated">列表的长度</h2><p id="2dfe" class="pw-post-body-paragraph ln lo in lp b lq ng jx ls lt nh ka lv lw ni ly lz ma nj mc md me nk mg mh lh ig bi translated">一个列表的长度基本上和用<strong class="lp ix"> 1 </strong>替换所有列表元素，然后加起来是一样的。边缘情况又是一个空列表。中性元素为<strong class="lp ix"> 0。</strong></p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="52cb" class="nr mp in nn b gy ns nt l nu nv">function length(list) {<br/>  if (list.length === 0) {<br/>    return 0;<br/>  }</span><span id="dfcf" class="nr mp in nn b gy nw nt l nu nv">  const [_, ...xs] = list;<br/>  return 1 + length(xs);<br/>}</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/aa0fe33e9c6c509f2d26331279dfe7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SBCbFfmQQOsIt48FDz-tA@2x.png"/></div></div></figure><p id="05af" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">好吧，这看起来很简单。<code class="fe nx ny nz nn b">map</code>、<code class="fe nx ny nz nn b">filter</code>、<code class="fe nx ny nz nn b">reduce</code>或<code class="fe nx ny nz nn b">zip</code>功能怎么样？它们可以用递归实现吗？当然了。</p><h2 id="0a86" class="nr mp in bd mq ou ov dn mu ow ox dp my lw oy oz na ma pa pb nc me pc pd ne it bi translated">列表映射</h2><p id="e2d2" class="pw-post-body-paragraph ln lo in lp b lq ng jx ls lt nh ka lv lw ni ly lz ma nj mc md me nk mg mh lh ig bi translated">列表上的映射基本上是两件事:</p><ol class=""><li id="6191" class="oa ob in lp b lq mi lt mj lw oc ma od me oe lh pe og oh oi bi translated">将映射函数<code class="fe nx ny nz nn b">fn</code>应用到列表的第一个元素，并将其放入数组</li><li id="cbdd" class="oa ob in lp b lq oj lt ok lw ol ma om me on lh pe og oh oi bi translated">将步骤1的结果与应用于列表其余部分(或尾部)的<code class="fe nx ny nz nn b">map</code>连接起来</li></ol><p id="a450" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">边缘情况是一个空数组。中性元素是<code class="fe nx ny nz nn b">[]</code>，因为<code class="fe nx ny nz nn b">[].concat([])</code>就是<code class="fe nx ny nz nn b">[]</code>。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="e6ce" class="nr mp in nn b gy ns nt l nu nv">function map(fn, list) {<br/>  if (list.length === 0) {<br/>    return [];<br/>  }</span><span id="878f" class="nr mp in nn b gy nw nt l nu nv">  const [x, ...xs] = list;<br/>  return [fn(x)].concat(map(fn, xs));<br/>}</span></pre><p id="be3b" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated"><code class="fe nx ny nz nn b">filter</code>和<code class="fe nx ny nz nn b">reduce</code>功能以相同的精神实现。</p><h2 id="aa8b" class="nr mp in bd mq ou ov dn mu ow ox dp my lw oy oz na ma pa pb nc me pc pd ne it bi translated">过滤列表</h2><p id="ea70" class="pw-post-body-paragraph ln lo in lp b lq ng jx ls lt nh ka lv lw ni ly lz ma nj mc md me nk mg mh lh ig bi translated">实现与<code class="fe nx ny nz nn b">map</code>基本相同。唯一的区别是谓词函数何时返回<code class="fe nx ny nz nn b">false</code>。在这种情况下，您不需要立即连接，而是把要添加到列表中的值委托给下一个递归步骤。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="3eba" class="nr mp in nn b gy ns nt l nu nv">function filter(predicate, list) {<br/>  if (list.length === 0) {<br/>    return [];<br/>  }</span><span id="d546" class="nr mp in nn b gy nw nt l nu nv">  const [x, ...xs] = list;<br/>  if (predicate(x)) {<br/>    return [x].concat(filter(predicate, xs));<br/>  } else {<br/>    return filter(predicate, xs);<br/>  }<br/>}</span></pre><h2 id="4dc8" class="nr mp in bd mq ou ov dn mu ow ox dp my lw oy oz na ma pa pb nc me pc pd ne it bi translated">减少名单</h2><p id="a00b" class="pw-post-body-paragraph ln lo in lp b lq ng jx ls lt nh ka lv lw ni ly lz ma nj mc md me nk mg mh lh ig bi translated">如果你看一下<code class="fe nx ny nz nn b">reduce</code>功能，它比<code class="fe nx ny nz nn b">filter</code>更类似于<code class="fe nx ny nz nn b">map</code>。</p><p id="8659" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated"><code class="fe nx ny nz nn b">fn</code>是将累计值与列表中下一个值相结合的减函数。<code class="fe nx ny nz nn b">acc</code>是缩减器第一次调用的初始值和后续调用的累计值。</p><pre class="km kn ko kp gt nm nn no np aw nq bi"><span id="3bb6" class="nr mp in nn b gy ns nt l nu nv">function reduce(fn, acc, list) {<br/>  if (list.length === 0) {<br/>    return acc;<br/>  }<br/>  <br/>  const [x, ...xs] = list;<br/>  return reduce(fn, fn(acc, x), xs);<br/>}</span></pre><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/40d455ed760676d291346f96d6ee1cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwJuXAHygbSZF3fT3RRyfw@2x.png"/></div></div></figure><h1 id="5efa" class="mo mp in bd mq mr ms mt mu mv mw mx my kc mz kd na kf nb kg nc ki nd kj ne nf bi translated">要记住的关键事情</h1><p id="ae39" class="pw-post-body-paragraph ln lo in lp b lq ng jx ls lt nh ka lv lw ni ly lz ma nj mc md me nk mg mh lh ig bi translated">当实现一个调用自身的函数时，请始终考虑:</p><ul class=""><li id="2621" class="oa ob in lp b lq mi lt mj lw oc ma od me oe lh of og oh oi bi translated">什么是边缘情况(有时称为基础情况)</li><li id="d33c" class="oa ob in lp b lq oj lt ok lw ol ma om me on lh of og oh oi bi translated">什么是中性元素(有时称为同一性)</li><li id="d024" class="oa ob in lp b lq oj lt ok lw ol ma om me on lh of og oh oi bi translated">开始用edge实现函数，首先覆盖问题的最简单形式</li></ul><p id="44fb" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">当处理列表时，想想你想在列表的哪个部分应用递归函数——是<code class="fe nx ny nz nn b">tail</code>还是<code class="fe nx ny nz nn b">init</code>？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/aa0fe33e9c6c509f2d26331279dfe7ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2SBCbFfmQQOsIt48FDz-tA@2x.png"/></div></div></figure><p id="051f" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">我希望你现在在实现递归的时候感觉更自信一点。请记住，我只想演示递归实现函数时如何思考。这些函数中的大部分在你选择的编程语言中已经有了对等物，而且很可能性能更好。</p><p id="56c2" class="pw-post-body-paragraph ln lo in lp b lq mi jx ls lt mj ka lv lw mk ly lz ma ml mc md me mm mg mh lh ig bi translated">下次见。<strong class="lp ix">🐺阿尔法，完毕。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi mn"><img src="../Images/40d455ed760676d291346f96d6ee1cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwJuXAHygbSZF3fT3RRyfw@2x.png"/></div></div></figure><h1 id="74c0" class="mo mp in bd mq mr ms mt mu mv mw mx my kc mz kd na kf nb kg nc ki nd kj ne nf bi translated">资源</h1><ul class=""><li id="bf5f" class="oa ob in lp b lq ng lt nh lw pf ma pg me ph lh of og oh oi bi translated"><a class="ae nl" href="https://en.wikipedia.org/wiki/Recursive_data_type" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Recursive_data_type</a></li><li id="48c6" class="oa ob in lp b lq oj lt ok lw ol ma om me on lh of og oh oi bi translated">http://learnyouahaskell.com<a class="ae nl" href="http://learnyouahaskell.com" rel="noopener ugc nofollow" target="_blank"/></li><li id="42ad" class="oa ob in lp b lq oj lt ok lw ol ma om me on lh of og oh oi bi translated">【https://javascript.info/recursion T4】</li></ul></div></div>    
</body>
</html>