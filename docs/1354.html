<html>
<head>
<title>Using GraphQL with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将GraphQL与React一起使用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-graphql-with-react-94c609cfbe52?source=collection_archive---------5-----------------------#2020-03-05">https://javascript.plainenglish.io/using-graphql-with-react-94c609cfbe52?source=collection_archive---------5-----------------------#2020-03-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/b9c9c231f633bc616c940bf21baa716c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*Sbfoc8u9fIfRSzyqxynwWQ.png"/></div></figure><p id="402f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在本教程中，我们将使用GraphQL和React。GraphQL是什么？GraphQL 是一种用于API的查询语言，也是完成这些查询的运行时。GraphQL为您的API中的数据提供了一个完整而清晰的描述，为客户提供了要求他们所需要的东西的能力，仅此而已。它还使API随着时间的推移更容易发展，并激活强大的开发工具。然而，在本教程中，您将只学习如何在前端实现GraphQL。让我们开始吧。</p><h1 id="b084" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">创建React项目</h1><p id="6f90" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">让我们创建一个电子商务应用程序</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="87bf" class="mf ku iq mb b gy mg mh l mi mj">create-react-app ecommerce</span></pre><p id="77c3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">接下来，导航到您的项目文件夹并启动本地开发服务器:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="5b0e" class="mf ku iq mb b gy mg mh l mi mj">cd ecommerce<br/>npm start</span></pre><p id="3a6a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">它将在<code class="fe mk ml mm mb b"><a class="ae ks" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank">http://localhost:3000</a></code>开始运行</p><h1 id="f74f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">安装Apollo客户端</h1><p id="bd1c" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">Apolo client是一个丰富的数据管理解决方案，包含了我们需要的所有基本东西。值得注意的是，Apolo提供了缓存，使其成为应用程序中本地和远程数据的单一来源。听起来像Redux生态系统权利“单一来源的真理”？以下是我们将要使用的软件包:</p><ul class=""><li id="e386" class="mn mo iq jw b jx jy kb kc kf mp kj mq kn mr kr ms mt mu mv bi translated"><a class="ae ks" href="https://www.npmjs.com/package/graphql" rel="noopener ugc nofollow" target="_blank">graph QL</a>:graph QL的JavaScript参考实现</li><li id="5e17" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated"><a class="ae ks" href="https://www.npmjs.com/package/react-apollo" rel="noopener ugc nofollow" target="_blank"> react-apollo </a>:这个包允许你从GraphQL服务器获取数据，并使用它来开发复杂的反应式用户界面。这个包主要用于React。</li><li id="d15f" class="mn mo iq jw b jx mw kb mx kf my kj mz kn na kr ms mt mu mv bi translated">Apollo Boost  : Apollo Boost是一种开始使用Apollo客户端的零配置方式。它包括一些合理的默认设置，比如我们推荐的<code class="fe mk ml mm mb b">InMemoryCache</code>和<code class="fe mk ml mm mb b">HttpLink</code>，它们是按照推荐的设置为您配置的。</li></ul><p id="32af" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">打开一个新的终端，导航到您的项目文件夹，然后运行以下命令:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8e2c" class="mf ku iq mb b gy mg mh l mi mj">npm install graphql --save<br/>npm install react-apollo --save<br/>npm install apollo-boost --save</span></pre><p id="0377" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们需要在我们的<strong class="jw ir">电子商务</strong>应用程序中配置它们。</p><p id="b7e2" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们从<strong class="jw ir"> index.js </strong>文件开始，添加以下代码:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e36a" class="mf ku iq mb b gy mg mh l mi mj">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { BrowserRouter } from "react-router-dom";<br/>import { ApolloProvider } from "react-apollo";<br/>import { createHttpLink } from "apollo-link-http";<br/>import { InMemoryCache } from "apollo-cache-inmemory";<br/>import { ApolloClient } from "apollo-boost";<br/>import "./index.css";<br/>import { default as App } from "./App/App.container";<br/>import { resolvers, typeDefs } from "./graphql/resolvers";<br/>import { default as data } from "./graphql/initial-data";</span><span id="977f" class="mf ku iq mb b gy nb mh l mi mj">const httpLink = createHttpLink({<br/>  uri: "URL goes here"<br/>});</span><span id="7920" class="mf ku iq mb b gy nb mh l mi mj">const cache = new InMemoryCache();</span><span id="d415" class="mf ku iq mb b gy nb mh l mi mj">const client = new ApolloClient({<br/>  link: httpLink,<br/>  cache,<br/>  typeDefs,<br/>  resolvers<br/>});</span><span id="0e1a" class="mf ku iq mb b gy nb mh l mi mj">client.writeData({ data });</span><span id="f5c1" class="mf ku iq mb b gy nb mh l mi mj">ReactDOM.render(<br/>  &lt;ApolloProvider client={client}&gt;<br/>    &lt;BrowserRouter&gt;<br/>      &lt;App /&gt;<br/>    &lt;/BrowserRouter&gt;<br/>  &lt;/ApolloProvider&gt;,<br/>  document.getElementById("root")<br/>);</span></pre><p id="5045" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们已经在内存缓存中创建了<strong class="jw ir">的实例，然后创建了<strong class="jw ir"> HttpLink </strong>的实例，并传入了我们的GraphQL API URI。然后我们创建了一个<strong class="jw ir"> ApolloClient </strong>的实例，并提供了缓存和链接实例。</strong></p><h1 id="c4aa" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">将Apollo客户端连接到React组件</h1><p id="d736" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">在创建了<strong class="jw ir"> ApolloClient </strong>的实例之后，我们需要将它连接到我们的React组件。让我们从最简单的场景开始，我们需要获取数据。</p><p id="a321" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">通过查询获取数据</strong></p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e8cd" class="mf ku iq mb b gy mg mh l mi mj">import React from "react";<br/>import { Query } from "react-apollo";<br/>import { gql } from "apollo-boost";<br/>import CategoriesOverview from "./categories-overview.component";<br/>import Spinner from "../spinner/spinner.component";<br/>const GET_CATEGORIES = gql`<br/>  {<br/>    categories {<br/>      id<br/>      title<br/>      items {<br/>        id<br/>        name<br/>        price<br/>        imageUrl<br/>      }<br/>    }<br/>  }<br/>`;<br/>const CategoriesOverviewContainer = () =&gt; (<br/>  &lt;Query query={GET_CATEGORIES}&gt;<br/>    {({ loading, data }) =&gt; {<br/>      if (loading) return &lt;Spinner /&gt;;<br/>      return &lt;CategoriesOverview categories={data.categories} /&gt;;<br/>    }}<br/>  &lt;/Query&gt;<br/>);<br/>export default CategoriesOverviewContainer;</span></pre><p id="3a58" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们只是使用查询来获取数据。如您所见，我们为想要显示的项目选择了特殊数据。并使用一个微调组件，该组件将一直显示，直到显示数据。</p><p id="58ca" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">变异数据</strong></p><p id="4474" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">是时候更进一步，看看我们如何改变数据了。让我们创建一个graphql文件夹并创建2个文件。</p><p id="692d" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> InitData.js </strong></p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c46e" class="mf ku iq mb b gy mg mh l mi mj">const INITIAL_DATA = {<br/>  cartHidden: true,<br/>  cartItems: [],<br/>  itemCount: 0,<br/>  cartTotal: 0<br/>};<br/>export default INITIAL_DATA;</span></pre><p id="4577" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这里，我们可以为可变数据设置初始值。让我们创建另一个文件，该文件将包含一个用于向购物车添加商品的可重用函数。这种方法将使我们的代码更加整洁。</p><p id="7ccc" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> utils.js </strong></p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3ee6" class="mf ku iq mb b gy mg mh l mi mj">export const addItemToCart = (cartItems, cartItemToAdd) =&gt; {<br/>    const existingCartItem = cartItems.find(<br/>        cartItem =&gt; cartItem.id === cartItemToAdd.id<br/>    );<br/>    if (existingCartItem) {<br/>        return cartItems.map(cartItem =&gt;<br/>            cartItem.id === cartItemToAdd.id ? {…<br/>                cartItem, quantity: cartItem.quantity + 1<br/>            } : cartItem<br/>        );<br/>    }<br/>    return […cartItems, {…<br/>        cartItemToAdd, quantity: 1<br/>    }];<br/>};</span></pre><p id="203c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如您所见，这是一个简单的函数，可用于向购物车添加新商品。是时候再次使用GraphQL了:<br/>让我们创建另一个名为:</p><p id="b64e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> resolvers.js </strong></p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7766" class="mf ku iq mb b gy mg mh l mi mj">import { gql } from "apollo-boost";<br/>import { addItemToCart } from "./utils";<br/>export const typeDefs = gql`<br/>  extend type Item {<br/>    quantity: Int<br/>  }<br/>  extend type Mutation {<br/>    ToggleCartHidden: Boolean!<br/>    AddItemToCart(item: Item!): [Item]!<br/>  }<br/>`;<br/>const GET_CART_HIDDEN = gql`<br/>  {<br/>    cartHidden <a class="ae ks" href="http://twitter.com/client" rel="noopener ugc nofollow" target="_blank">@client</a><br/>  }<br/>`;<br/>const GET_CART_ITEMS = gql`<br/>  {<br/>    cartItems <a class="ae ks" href="http://twitter.com/client" rel="noopener ugc nofollow" target="_blank">@client</a><br/>  }<br/>`;<br/>const updateCartItemsRelatedQueries = (cache, newCartItems) =&gt; {<br/>  cache.writeQuery({<br/>    query: GET_CART_ITEMS,<br/>    data: { cartItems: newCartItems }<br/>  });<br/>};<br/>export const resolvers = {<br/>  Mutation: {<br/>    toggleCartHidden: (_root, _args, { cache }) =&gt; {<br/>      const { cartHidden } = cache.readQuery({<br/>        query: GET_CART_HIDDEN<br/>      });<br/>      cache.writeQuery({<br/>        query: GET_CART_HIDDEN,<br/>        data: { cartHidden: !cartHidden }<br/>      });<br/>      return !cartHidden;<br/>    },<br/>    addItemToCart: (_root, { item }, { cache }) =&gt; {<br/>      const { cartItems } = cache.readQuery({<br/>        query: GET_CART_ITEMS<br/>      });<br/>      const newCartItems = addItemToCart(cartItems, item);<br/>      updateCartItemsRelatedQueries(cache, newCartItems);<br/>      return newCartItems;<br/>    }<br/>  }<br/>};</span></pre><p id="ff63" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">让我们看看这里发生了什么？<br/>首先，我们定义了购物车商品和购物车本身的类型。就您所知，ToggleCartHidden类型为布尔型，可以打开或关闭购物车下拉列表。你可能会认为这种语法很奇怪。并且对新术语感到困惑，可能会问什么是@client，什么是resolver…？<br/> <strong class="jw ir"> @client </strong>是一个指令，它告诉Apollo客户机在本地获取字段数据(从缓存或使用本地解析器)，而不是将其发送到我们的GraphQL服务器。</p><p id="cd10" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir">解析器</strong>提供将GraphQL操作(查询、变异或订阅)转换成数据的指令。它们要么返回我们在模式中指定的相同类型的数据，要么返回对该数据的承诺。</p><p id="bdac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> readQuery </strong>方法使您能够直接在缓存上运行GraphQL查询。</p><p id="66d5" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您的缓存包含完成指定查询所需的所有数据，readQuery将返回查询形状的数据对象，就像GraphQL服务器一样。</p><p id="498b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果您的缓存没有包含完成指定查询所需的所有数据，readQuery将抛出一个错误。它从不尝试从远程服务器获取数据。</p><p id="304a" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw ir"> writeQuery </strong>顾名思义就是用来更新数据的。</p><p id="1009" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">因此，我们使用这种新方法向购物车添加新商品，并切换购物车本身。你可以在这里添加其他功能，从购物车中删除商品，更新购物车商品计数等等……<br/>希望现在一切都清楚了。现在让我们看看如何将它与<strong class="jw ir">购物车下拉列表</strong>组件一起使用。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="d19c" class="mf ku iq mb b gy mg mh l mi mj">import React from "react";<br/>import { Query, Mutation } from "react-apollo";<br/>import { gql } from "apollo-boost";<br/>import CartDropdown from "./cart-dropdown.component";</span><span id="aa6d" class="mf ku iq mb b gy nb mh l mi mj">const TOGGLE_CART_HIDDEN = gql`<br/>  mutation ToggleCartHidden {<br/>    toggleCartHidden <a class="ae ks" href="http://twitter.com/client" rel="noopener ugc nofollow" target="_blank">@client</a><br/>  }<br/>`;<br/>const GET_CART_ITEMS = gql`<br/>  {<br/>    cartItems <a class="ae ks" href="http://twitter.com/client" rel="noopener ugc nofollow" target="_blank">@client</a><br/>  }<br/>`;<br/>const CartDropdownContainer = () =&gt; (<br/>  &lt;Mutation mutation={TOGGLE_CART_HIDDEN}&gt;<br/>    {toggleCartHidden =&gt; (<br/>      &lt;Query query={GET_CART_ITEMS}&gt;<br/>        {({ data: { cartItems } }) =&gt; (<br/>          &lt;CartDropdown<br/>            cartItems={cartItems}<br/>            toggleCartHidden={toggleCartHidden}<br/>          /&gt;<br/>        )}<br/>      &lt;/Query&gt;<br/>    )}<br/>  &lt;/Mutation&gt;<br/>);<br/>export default CartDropdownContainer;</span></pre><p id="2cb3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">正如您在这个组件中看到的，我们同时使用了变异和查询。就是这样。您可以尝试自己实现我们之前创建的另一个变体，用另一个组件向购物车添加新商品。如果这很难，那就给这个教程发个评论，我会为这个教程添加第二部分。</p><h1 id="bd32" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="dbc4" class="pw-post-body-paragraph ju jv iq jw b jx lr jz ka kb ls kd ke kf lt kh ki kj lu kl km kn lv kp kq kr ij bi translated">GraphQL现在非常流行，但是，您应该决定在客户端使用它作为Redux的替代，还是继续使用Redux？</p></div></div>    
</body>
</html>