<html>
<head>
<title>Object Oriented Programming and the Prototype Chain in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的面向对象编程和原型链</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-oriented-programming-and-the-prototype-chain-in-javascript-d71032a30324?source=collection_archive---------14-----------------------#2020-04-14">https://javascript.plainenglish.io/object-oriented-programming-and-the-prototype-chain-in-javascript-d71032a30324?source=collection_archive---------14-----------------------#2020-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4d30e40fca4bd9968a242d5f90c17e2a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BoOljdQTyei4IXEk5dqo1g.png"/></div></div></figure><p id="af2a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本文中，我们将介绍JavaScript如何允许开发人员以面向对象的方式组织他们的代码，以及它如何使用“原型继承”或“原型链”功能来实现这一点。</p><p id="b556" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">面向对象编程最早是由艾伦·凯(Alan Kay)在60年代创造出来的，从那时起，它就是最流行的代码组织结构之一。</p><p id="18e9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本系列的三个部分中，我们将了解JavaScript如何模拟面向对象的代码组织，了解__ <strong class="ka ir"> proto__ </strong>和<strong class="ka ir"> prototype </strong>之间的区别，这将导致对<code class="fe kx ky kz la b"><strong class="ka ir">new</strong></code>和<code class="fe kx ky kz la b"><strong class="ka ir">class</strong></code>关键词的解释，这是工程师最常见的面试问题之一，抽象出“幕后”正在发生的事情，给开发人员一个愉快的编码体验。我们还将覆盖箭头功能的力量以及<code class="fe kx ky kz la b"><strong class="ka ir">this</strong></code>关键词如何工作。</p><p id="4dd6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们从程序的核心基础开始:保存数据，并在其上运行代码。在一个问答游戏示例中，这将存储一个用户的分数，并在他得到正确答案时增加该用户的分数。</p><p id="7c9e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">放松。</p><p id="6a27" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，有什么问题呢？好吧，假设我们有1000个用户，每个用户都有许多不同的属性，比如年龄、名字、分数、电子邮件地址、头像等等。每个用户都有处理这些数据的功能，增加分数，减少分数，改变用户名，电子邮件地址等...在智力竞赛游戏中，我们也有计分板、智力竞赛问题、智力竞赛结果，您可以随意命名。智力竞赛游戏的所有这些特征都有关于它们的信息以及使用这些数据并与之交互的功能；显示它，渲染它，改变它，删除它等等…</p><p id="f0cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个100，000行代码的应用程序中，我们可以看到为什么这会变得很麻烦，当我需要它的时候，它的功能在哪里？我如何在用户身上应用这个功能，而不是在记分板上应用<strong class="ka ir">而不是</strong>？</p><p id="adc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望我们的代码易于推理，即易于理解，我们也希望我们的代码易于允许添加新的特性，同时保持其高效性和性能，这就是OOP的目标。</p><p id="b50a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们用一个简化的例子来说明。</p><p id="1acb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们有两个用户。</p><p id="ae33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望有能力提高他们的分数。</p><p id="1b3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望能够存储我们用户的信息，并在那里为我们的用户提供一些功能，来处理这些数据。</p><blockquote class="lb lc ld"><p id="22f9" class="jy jz le ka b kb kc kd ke kf kg kh ki lf kk kl km lg ko kp kq lh ks kt ku kv ij bi translated">关键是在相关数据上实现运行功能。</p></blockquote><p id="e438" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，我们如何用JavaScript将数据结构、数据和功能组织在一起呢？</p><p id="ca73" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将其存储在对象中。</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="a6b5" class="lq lr iq la b gy ls lt l lu lv">const user1 = {<br/>    name: "Tim",<br/>    score: 3,<br/>    increment: function(){ user1.score ++ }<br/>};<br/>​<br/>user1.increment();<br/>//user1.score -&gt; 4</span></pre><p id="0ef9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完成了。</p><p id="3b62" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们创建我们的<code class="fe kx ky kz la b">user2</code>,并使用<code class="fe kx ky kz la b">.</code>操作符向它添加属性。</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="31f0" class="lq lr iq la b gy ls lt l lu lv">const user2 = {}<br/>user2.name = "Tim";<br/>user2.score = 6;<br/>user2.increment = function() {<br/>    user2.score++;<br/>}<br/>user1.increment();<br/>//user1.score -&gt; 7</span></pre><p id="1d26" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们使用另一种方法创建<code class="fe kx ky kz la b">user3</code>，用JavaScript创建对象，<code class="fe kx ky kz la b">Object.create()</code>返回一个空对象，并再次使用<code class="fe kx ky kz la b">.</code>操作符向其添加属性。</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="61cc" class="lq lr iq la b gy ls lt l lu lv">const user3 = Object.create();<br/>user3.name = "Laura";<br/>user3.score = 7;<br/>user3.increment = function() {<br/>    user3.increment++;<br/>}<br/>user1.increment();<br/>//user1.score -&gt; 8</span></pre><p id="26ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嘣，搞定！数据和功能封装在一个数据结构中。</p><p id="1f11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">这太可怕了</strong>有两个原因，我们已经重复同样的代码三次了，如果我们有100，000个用户，我们会怎么做？我们需要开发人员在每次用户注册或做一些事情时手动输入数据。你做梦去吧。</p><p id="2a5c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么，当我们一次又一次地执行代码行时，我们该怎么办呢？</p><p id="d87b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们把它包装在一个函数里。保存一次，运行一次又一次，你想改变的位，作为输入传入。</p><h1 id="342c" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">解决方案1</h1><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="aead" class="lq lr iq la b gy ls lt l lu lv">function userCreator(name, score){<br/>    const newUser = {};<br/>    newUser.name = name;<br/>    newUser.score = score;<br/>    newUser.incrementScore = function(){<br/>        newUser.score++<br/>    }<br/>    return newUser;<br/>}<br/>​<br/>const user1 = userCreator("Tim", 6);<br/>const user2 = userCreator("Eva", 5);<br/>​<br/>user1.incrementScore();</span></pre><p id="c5b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于所有意图和目的来说，这个解决方案是可行的，但是它与保持我们的代码高效和高性能背道而驰。为什么？通过这种方法，每个用户都在其中存储了负责增加分数的代码。两个用户和一个<code class="fe kx ky kz la b">incrementScore</code>函数没问题，但是当我们有10，000个用户，每个用户有100个函数，每个函数大约10行代码时会发生什么？很明显，这将导致我们的应用程序的内存管理效率非常低，使用起来也很慢。此外，如果我们想要添加一个特性，我们必须手动将其添加到每个用户。</p><p id="e366" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">肯定有更好的方法。</p><h1 id="9dc1" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">解决方案2</h1><p id="f414" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我们可以有一个“函数库”来保存一个用户的所有<strong class="ka ir">共享</strong>函数，而不是每个对象上的每个函数的副本，每次我们想访问/使用这些函数中的一个时，每个用户都可以从中访问，当JavaScript在我们调用它的对象上找不到函数时，<strong class="ka ir">不会惊慌失措</strong>并去别的地方寻找那个函数，我们的“函数库”。</p><p id="b97f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以不要</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="9d79" class="lq lr iq la b gy ls lt l lu lv">user1 = {<br/>    name: "Tim",<br/>    score: 6,<br/>    incrementScore: function() { increment user score }<br/>}<br/>​<br/>user2 = {<br/>    name: "Eva",<br/>    score: 5,<br/>    incrementScore: function() { increment user score }<br/>}</span></pre><p id="cfaa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们会有的</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="a06c" class="lq lr iq la b gy ls lt l lu lv">sharedFunctionStore = {<br/>    incrementScore: function() { increment user score }<br/>}<br/>​<br/>user1 = {<br/>    name: "Tim",<br/>    score: 6,<br/>}<br/>​<br/>user2 = {<br/>    name: "Eva",<br/>    score: 5,<br/>}</span></pre><p id="98d3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们调用<code class="fe kx ky kz la b">user1.incrementScore()</code>时，JavaScript不会惊慌，并在我们的<code class="fe kx ky kz la b">sharedFunctionStore</code>中寻找我们的<code class="fe kx ky kz la b">incrementScore()</code>函数。</p><p id="36b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要<strong class="ka ir">在我们的用户和我们的“共享功能商店”之间创建链接</strong>。我们创建链接的方式是使用<code class="fe kx ky kz la b">Object.create()</code>技术。</p><p id="760c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将我们以前的解决方案重构为正确的方法将产生以下代码:</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="358a" class="lq lr iq la b gy ls lt l lu lv">var userFunctionStore = {<br/>    incrementScore: function(){ this.score++ },<br/>    login: function(){ console.log("User logged in!")}<br/>}</span><span id="1a9d" class="lq lr iq la b gy my lt l lu lv">function userCreator(name, score){<br/>    const newUser = Object.create(userFunctionStore);<br/>    newUser.name = name;<br/>    newUser.score = score;<br/>    return newUser<br/>}<br/>​<br/>const user1 = userCreator("Tim", 5)<br/>user1.incrementScore()<br/>// -&gt; 6</span></pre><p id="671e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在这里看到一个<strong class="ka ir">新关键字</strong>，<code class="fe kx ky kz la b"><strong class="ka ir">this</strong></code>。</p><p id="abd7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还必须解释当我们使用<code class="fe kx ky kz la b">Object.create()</code>时会发生什么，以及它如何在我们的用户和我们的<code class="fe kx ky kz la b">userFunctionStore</code>之间创建一个<strong class="ka ir">链接</strong>。</p><p id="51f3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么我们的代码中发生了什么呢？</p><p id="3b0e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们问问自己，当我们呼叫<code class="fe kx ky kz la b">user1.incrementScore()</code>时会发生什么？</p><p id="9f89" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">JavaScript将在我们的<code class="fe kx ky kz la b">user1</code>对象上寻找<code class="fe kx ky kz la b">incrementScore</code>属性，它会找到吗？<strong class="ka ir">否</strong>。</p><p id="fc25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来会发生什么？它在我们的<code class="fe kx ky kz la b">userFunctionStore</code>对象中寻找它，它找到了吗？<strong class="ka ir">是</strong>。</p><p id="b9b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它执行<code class="fe kx ky kz la b">incrementScore()</code>。我们的用户分数也会增加。</p><p id="0004" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是你可能想知道，这个<strong class="ka ir">神奇的链接</strong>是怎么创建的？JavaScript是怎么知道<code class="fe kx ky kz la b">userFunctionStore</code>的？为了解释这一点，我们必须解释当我们使用<code class="fe kx ky kz la b">Object.create()</code>时发生了什么。</p><p id="61f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们使用<code class="fe kx ky kz la b">Object.create(userFunctionStore)</code>时，JavaScript在我们的<code class="fe kx ky kz la b">newUser</code>对象上创建一个名为<code class="fe kx ky kz la b">__proto__</code>的隐藏属性，它有一个链接，或者对<code class="fe kx ky kz la b">userFunctionStore</code>的引用。这个<code class="fe kx ky kz la b">__proto__</code>属性被称为“dunderscore proto”或“双下划线proto ”,这意味着我们创建的用户对象实际上看起来像这样:</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="03fd" class="lq lr iq la b gy ls lt l lu lv">user1 = {<br/>    name: "Tim",<br/>    score: 6,<br/>    __proto__: { link to userFunctionStore } &lt;- Hidden property<br/>}<br/>​<br/>user2 = {<br/>    name: "Tim",<br/>    score: 5,<br/>    __proto__: { link to userFunctionStore } &lt;- Hidden property<br/>}</span></pre><p id="a098" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而这就是所谓的JavaScript的"<strong class="ka ir">原型特征</strong>，即:当JavaScript在对象上<strong class="ka ir">而不是</strong>或<strong class="ka ir">找到</strong>一个属性、函数或数据，我们试图访问时，<strong class="ka ir"> <em class="le">它不会死机！！！</em> </strong>，它直接进入<code class="fe kx ky kz la b"><strong class="ka ir">__proto__</strong></code>属性，并通过其原型引用链接向上查看<code class="fe kx ky kz la b">userFunctionStore</code>，找到我们正在寻找的属性，获取它，如果该属性是一个函数，则为其代码创建一个全新的<strong class="ka ir">执行上下文</strong>并运行它。</p><p id="8121" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们看看运行<code class="fe kx ky kz la b">function incrementScore(){ this.score++ }</code>时会发生什么</p><p id="ef72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kx ky kz la b"><strong class="ka ir">this</strong></code>作为一个<strong class="ka ir">隐式参数</strong>传入，它计算什么？正在其上运行方法的对象。因此，在我们的示例中，当我们运行<code class="fe kx ky kz la b">user1.incrementScore()</code>时，<code class="fe kx ky kz la b">this</code>的计算结果为<code class="fe kx ky kz la b">user1</code>。</p><h1 id="54ee" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated">原型链</h1><p id="121c" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">让我们看看JavaScript的<code class="fe kx ky kz la b">hasOwnProperty()</code>方法，通过下面的例子来解释和追溯原型链是如何工作的。</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="55bd" class="lq lr iq la b gy ls lt l lu lv">function userCreator(name, score){<br/>    const newUser = Object.create(userFunctionStore);<br/>    newUser.name = name;<br/>    newUser.score = score<br/>    return newUser<br/>}<br/>​<br/>userFunctionStore = {<br/>    incrementScore: function(){ this.score++ },<br/>    login: function(){ console.log("User logged in!")}<br/>}<br/>​<br/>const user1 = userCreator("Tim", 5)<br/>user1.hasOwnProperty('score')</span></pre><p id="fbc5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们运行<code class="fe kx ky kz la b">user1.hasOwnProperty('score')</code>时会发生什么？JavaScript试图在<code class="fe kx ky kz la b">user1</code>上找到<code class="fe kx ky kz la b">hasOwnProperty</code>方法，但找不到。会不会恐慌或者崩溃？<strong class="ka ir">否</strong>。</p><p id="35ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它会查找原型链到<code class="fe kx ky kz la b">userFunctionStore</code>，它会找到吗？<strong class="ka ir">否</strong>。会不会恐慌或者崩溃？<strong class="ka ir">否</strong>。</p><p id="c33a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">那么这个<code class="fe kx ky kz la b">hasOwnProperty()</code>方法是从哪里来的呢？</p><p id="cdda" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">原来有一个headline <code class="fe kx ky kz la b">Object.prototype</code>对象，它有一堆有用的函数，所有其他对象都可以使用这些函数。嗯怎么样？因为JavaScript中的所有<strong class="ka ir"/><code class="fe kx ky kz la b">Objects</code>都有一个默认链接到这个<code class="fe kx ky kz la b">Object.prototype</code>对象的<code class="fe kx ky kz la b">__proto__</code>属性，当我们使用<code class="fe kx ky kz la b">Object.create()</code>时，我们本质上所做的是修改从<code class="fe kx ky kz la b">Object.Prototype</code>对象到我们传递给<code class="fe kx ky kz la b">Object.create()</code>的对象的默认链接。</p><figure class="li lj lk ll gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mz"><img src="../Images/ccd20383fa7b814dc87c5c32b63d4d32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Dp2yvOZrPgHkKC5xAwdjwA.jpeg"/></div></div></figure><p id="0c86" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样，当我们调用<code class="fe kx ky kz la b">user1.hasOwnProperty('score')</code> JavaScript检查<code class="fe kx ky kz la b">user1</code>对象上的<code class="fe kx ky kz la b">hasOwnProperty</code>时，<strong class="ka ir">没有找到它</strong>，查找<code class="fe kx ky kz la b">userFunctionStore</code>对象的链，<strong class="ka ir">没有找到它</strong>，检查<code class="fe kx ky kz la b">Object.Prototype</code>对象，<strong class="ka ir">找到它并执行</strong>。</p><h2 id="c403" class="lq lr iq bd lx na nb dn mb nc nd dp mf kj ne nf mj kn ng nh mn kr ni nj mr nk bi translated">太棒了。</h2><p id="1101" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">现在让我们研究一下<code class="fe kx ky kz la b"><strong class="ka ir">this</strong></code>关键字，并了解当我们调用函数中定义的函数时，它的计算结果是什么。</p><p id="e678" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们以下面的例子来说明我们的观点:</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="3dd4" class="lq lr iq la b gy ls lt l lu lv">function userCreator(name, score){<br/>    const newUser = Object.create(userFunctionStore);<br/>    newUser.name = name;<br/>    newUser.score = score<br/>    return newUser;<br/>}<br/>​<br/>const userFunctionStore = {<br/>    increment: function() {<br/>        function add1(){ this.score++ }<br/>        add1()<br/>    }<br/>}<br/>​<br/>const user1 = userCreator("Tim", 3);<br/>​<br/>user1.increment();</span></pre><p id="ce34" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当我们运行<code class="fe kx ky kz la b">user1.increment()</code>时会发生什么？它返回<code class="fe kx ky kz la b">undefined</code>。我们来看看为什么。</p><p id="bd4e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当<code class="fe kx ky kz la b">user1.increment()</code>运行时；</p><ul class=""><li id="62ce" class="nl nm iq ka b kb kc kf kg kj nn kn no kr np kv nq nr ns nt bi translated">它创建了一个<strong class="ka ir">新的执行上下文</strong></li><li id="63a4" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">我们的<strong class="ka ir">隐式参数</strong> <code class="fe kx ky kz la b"><strong class="ka ir">this</strong></code>被传入，其计算结果为<code class="fe kx ky kz la b">user1</code>。</li><li id="1e02" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">然后我们声明我们的函数<code class="fe kx ky kz la b">add1</code></li><li id="1150" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated">我们跑<code class="fe kx ky kz la b">add1()</code></li><li id="2904" class="nl nm iq ka b kb nu kf nv kj nw kn nx kr ny kv nq nr ns nt bi translated"><code class="fe kx ky kz la b">add1()</code>将创建<strong class="ka ir">它自己的新执行上下文</strong>。</li></ul><p id="c814" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在问题来了，在<code class="fe kx ky kz la b">add1</code>的<strong class="ka ir">本地内存</strong>中<code class="fe kx ky kz la b">this</code>的值是多少？想必是<code class="fe kx ky kz la b">user1</code>...</p><p id="44a7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但它不是，可能在其他语言中，而不是在JavaScript中。</p><p id="5b06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在JavaScript中，<code class="fe kx ky kz la b">this</code>默认为全局的<code class="fe kx ky kz la b">window</code>对象，所以我们最终在<code class="fe kx ky kz la b">window</code>上定义了一个<code class="fe kx ky kz la b">score</code>属性，这个属性应该是<code class="fe kx ky kz la b">undefined</code>，并且我们试图递增它。哈哈，谁需要那个？这很可能被认为是JavaScript中的一个错误，但是因为我们知道它的行为方式，我们总是可以避免它。</p><p id="f5ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在过去，工程师们常常采用一种时髦的变通方法，使用<code class="fe kx ky kz la b">that=this</code>“黑客”。</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="be2b" class="lq lr iq la b gy ls lt l lu lv">const userFunctionStore = {<br/>    increment: function() {<br/>        const that = this<br/>        function add1(){ that.score++ }<br/>        add1()<br/>    }<br/>}</span></pre><p id="4fa8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是那太可怕了，让我的学长朋友想吐。</p><p id="b194" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">还有另一种手动运行<code class="fe kx ky kz la b">add</code>函数的方式，即<strong class="ka ir">允许我们控制</strong> <code class="fe kx ky kz la b"><strong class="ka ir">this</strong></code> <strong class="ka ir">赋值在</strong>中的内容。这是通过使用<code class="fe kx ky kz la b">call</code>或<code class="fe kx ky kz la b">apply</code>方法实现的。</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="14b7" class="lq lr iq la b gy ls lt l lu lv">const userFunctionStore = {<br/>    increment: function() {<br/>        function add1(){ this.score++ }<br/>        add1.call(this)<br/>    }<br/>}</span></pre><p id="68c4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在越来越多的标准方法是使用<strong class="ka ir">箭头函数</strong> <strong class="ka ir">，也就是说</strong> <code class="fe kx ky kz la b"><strong class="ka ir">this</strong></code> <strong class="ka ir">赋值是在词汇范围内</strong>。</p><p id="79db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这意味着，我们保存函数的位置决定了<code class="fe kx ky kz la b">this</code>的值。因此，当我们保存我们的<strong class="ka ir">箭头函数</strong>时，无论<code class="fe kx ky kz la b">this</code>的值是多少，当我们运行它时，都将是<code class="fe kx ky kz la b">this</code>的值。</p><p id="45cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">把我们的代码变成这样:</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="19ec" class="lq lr iq la b gy ls lt l lu lv">const userFunctionStore = {<br/>    increment: function(){<br/>        const add1 = () =&gt; { this.score++ }<br/>        add1()<br/>    }<br/>}</span></pre><p id="dcd3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里需要注意一点:</p><p id="54e6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们将存储在<code class="fe kx ky kz la b">increment</code>键中的函数声明为一个箭头函数，<code class="fe kx ky kz la b">this</code>将评估到它被定义的位置，在我们的例子中，是<strong class="ka ir">全局内存</strong>，并因此将<code class="fe kx ky kz la b">this</code>的值从<code class="fe kx ky kz la b">user1</code>覆盖到<code class="fe kx ky kz la b">window</code>。那会导致我们整个事情分崩离析。</p><p id="e82c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，一个很好的规则是，当存储为属性时，以传统方式声明函数，并使用箭头函数声明其中的迷你函数。</p><h1 id="9d11" class="lw lr iq bd lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms bi translated"><code class="fe kx ky kz la b">new</code>和<code class="fe kx ky kz la b">class</code></h1><p id="9c8d" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我们终于来了，现在我们已经理解了JavaScript的原链接和<code class="fe kx ky kz la b">this</code>是如何工作的，我们可以引入<code class="fe kx ky kz la b"><strong class="ka ir">new</strong></code>关键字，句法糖，来减少代码编写并自动化我们的代码。</p><p id="60e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们把代码带回来，评论一下这个新的<code class="fe kx ky kz la b"><strong class="ka ir">new</strong></code> (lol)关键字将为我们实现什么自动化。</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="f284" class="lq lr iq la b gy ls lt l lu lv">function userCreator(name, score){<br/>    // const newUser = Object.create(userFunctionStore); -&gt; Gone<br/>    // newUser.name = name; -&gt; Gone<br/>    this.name<br/>    // newUser.score = score  -&gt; Gone<br/>    this.score<br/>    // return newUser;  -&gt; Gone<br/>}</span><span id="f3fe" class="lq lr iq la b gy my lt l lu lv">The whole functionStore is gone.</span><span id="ffde" class="lq lr iq la b gy my lt l lu lv">// const userFunctionStore = {<br/>   // increment: function() {<br/>     //   const add1 = () =&gt; { this.score++ }<br/>       // add1()<br/>  //  } <br/>// } <br/>​<br/>userCreate.prototype.increment = function() {<br/>    this.score++<br/>}<br/>​<br/>const user1 = userCreator("Tim", 3);<br/>​<br/>user1.increment();</span></pre><p id="b2bc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将我们的代码转换为以下代码:</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="41fa" class="lq lr iq la b gy ls lt l lu lv">function userCreator(name, score){<br/>    this.name = name<br/>    this.score = score<br/>}<br/>​<br/>userCreator.prototype.increment = function() {<br/>    this.score++<br/>}<br/>​<br/>const user1 = new userCreator("Tim", 3);<br/>​<br/>user1.increment();</span></pre><p id="7933" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们去掉了<code class="fe kx ky kz la b">Object.create()</code>，它会在<code class="fe kx ky kz la b"><strong class="ka ir">new</strong></code>之前为我们完成。</p><p id="c04a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也不再显式<code class="fe kx ky kz la b">return newUser</code>了，转而返回一个<strong class="ka ir">隐式</strong> <code class="fe kx ky kz la b"><strong class="ka ir">this</strong></code>。</p><p id="2754" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要<code class="fe kx ky kz la b"><strong class="ka ir">new</strong></code>关键字处理的最后一件事是存储<code class="fe kx ky kz la b">__proto__</code>链接的<code class="fe kx ky kz la b">userFunctionStore</code>的内容。</p><p id="2797" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了理解它将被存储在哪里，我们需要引入一个新的想法来思考。</p><p id="9d4c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">在JavaScript中，函数既是函数又是对象</strong>。</p><p id="f3dc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并且它们都有一个默认为空对象的<code class="fe kx ky kz la b">prototype</code>属性。因此，<code class="fe kx ky kz la b">new</code>关键字将把以前在<code class="fe kx ky kz la b">userFunctionStore</code>中的内容存储在我们的<code class="fe kx ky kz la b">userCreator</code>函数的<code class="fe kx ky kz la b">prototype</code>属性中，我们的<code class="fe kx ky kz la b">user1</code>的<code class="fe kx ky kz la b">__proto__</code>属性将保存到该属性的链接。</p><p id="e99b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里出现了一个问题，当其他开发人员或我们未来的自己阅读这段代码时，我们需要知道我们的<code class="fe kx ky kz la b">userCreator</code>函数需要用<code class="fe kx ky kz la b"><strong class="ka ir">new</strong></code>关键字来调用才能完成它的工作。通知他人<code class="fe kx ky kz la b"><strong class="ka ir">new</strong></code>关键字的必要性的公认方式是<strong class="ka ir">将该函数的第一个字母</strong>大写，因此<code class="fe kx ky kz la b">userCreator</code>变成了<code class="fe kx ky kz la b">UserCreator</code>。</p><p id="96fe" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了克服这种烦恼，JavaScript添加了另一层语法糖，即新的<code class="fe kx ky kz la b"><strong class="ka ir">class</strong></code>关键字。</p><p id="6d25" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">添加<code class="fe kx ky kz la b"><strong class="ka ir">class</strong></code>关键字的另一个原因是让来自其他语言的开发人员更容易使用JavaScript，因为即使函数和对象在JavaScript中是<strong class="ka ir">紧密联系的</strong>，它们也是<strong class="ka ir">而不是</strong>，就像在其他语言中一样，是同一构造的一部分。所以<code class="fe kx ky kz la b"><strong class="ka ir">class</strong></code>关键字在视觉上封装了共享函数和我们的数据。</p><p id="2ebb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">允许我们像这样写代码。</p><pre class="li lj lk ll gt lm la ln lo aw lp bi"><span id="2ea3" class="lq lr iq la b gy ls lt l lu lv">class UserCreator {<br/>    constructor(name, score){<br/>        this.name = name;<br/>        this.score = score;<br/>    }<br/>    <br/>    incrementScore(){ this.score++ }<br/>    login(){ console.log("login") }<br/>}<br/>​<br/>const user1 = new UserCreator("Eva", 9)<br/>user1.increment();</span></pre><h2 id="2123" class="lq lr iq bd lx na nb dn mb nc nd dp mf kj ne nf mj kn ng nh mn kr ni nj mr nk bi translated">太美了。</h2><p id="4ddc" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">博客灵感来自<a class="ae kw" href="https://frontendmasters.com/" rel="noopener ugc nofollow" target="_blank">前端大师</a> / <a class="nz oa ep" href="https://medium.com/u/1b199ed2dfd?source=post_page-----d71032a30324--------------------------------" rel="noopener" target="_blank">前端大师</a>的，JavaScript: The Hard Parts，v2，<a class="nz oa ep" href="https://medium.com/u/c211a09475?source=post_page-----d71032a30324--------------------------------" rel="noopener" target="_blank">教授的课程将赠送</a>。对于那些想大幅增加他们的前端编程知识的人来说，这是一个惊人的资源。</p><p id="4487" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢阅读！</p><p id="dfe0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">爱，光，代码❤️</p><h2 id="ce5e" class="lq lr iq bd lx na nb dn mb nc nd dp mf kj ne nf mj kn ng nh mn kr ni nj mr nk bi translated">用简单英语写的JavaScript的注释</h2><p id="4eee" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我们已经推出了三种新的出版物！为我们的新出版物献上一点爱心吧，请跟随他们:<a class="ae kw" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ka ir">AI in Plain English</strong></a>，<a class="ae kw" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ka ir">UX in Plain English</strong></a>，<a class="ae kw" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ka ir">Python in Plain English</strong></a><strong class="ka ir"/>——谢谢，继续学习！</p><p id="ee00" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kw" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir">submissions @ plain English . io</strong></a><strong class="ka ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>