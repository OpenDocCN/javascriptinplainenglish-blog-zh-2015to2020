<html>
<head>
<title>Patterns for async programming and async functions optimization in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中异步编程和异步函数优化的模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/patterns-for-async-programming-and-async-function-optimization-in-javascript-931cf49cadcd?source=collection_archive---------6-----------------------#2020-05-05">https://javascript.plainenglish.io/patterns-for-async-programming-and-async-function-optimization-in-javascript-931cf49cadcd?source=collection_archive---------6-----------------------#2020-05-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="97cd" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">JavaScript的基础知识</h2><div class=""/><div class=""><h2 id="2f8f" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">关于异步机制的快速提示，以及一些可以快速应用的模式。</h2></div><p id="3411" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在对我的关于JavaScript异步性的文章进行了几个月的反馈后，我决定重新编辑一些更小更简单的内容，重点是模式而不是概念的解释。</p><p id="0d98" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">如果你是一个初学者，如果你准备好了，可以随意阅读这个链接上的全部课程或者阅读本文的其余部分。</p><div class="lk ll gp gr lm ln"><a href="https://medium.com/javascript-in-plain-english/understand-javascript-sequencing-and-asynchronous-behaviors-to-leverage-code-parallelism-1e381fa8d33c" rel="noopener follow" target="_blank"><div class="lo ab fo"><div class="lp ab lq cl cj lr"><h2 class="bd ja gy z fp ls fr fs lt fu fw iz bi translated">理解JavaScript排序和异步行为，以利用代码并行性。</h2><div class="lu l"><h3 class="bd b gy z fp ls fr fs lt fu fw dk translated">关于如何使用JS并发模型提高应用程序性能的小指南。</h3></div><div class="lv l"><p class="bd b dl z fp ls fr fs lt fu fw dk translated">medium.com</p></div></div><div class="lw l"><div class="lx l ly lz ma lw mb mc ln"/></div></div></a></div></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="b6f4" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">本文旨在简化初学者的逻辑，并且只给出您可以快速应用的模式，而不必阅读完整、全面和详细的示例。</p><p id="3d31" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">在获得模式之前，让我们快速回顾一些基础知识。</p><h1 id="186b" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">关于JS中异步性的快速提醒</h1><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="6b43" class="nl ml iq nh b gy nm nn l no np">console.log("a");<br/>setTimeout(() =&gt; console.log("b"), 0)<br/>console.log("c");</span></pre><p id="764b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">将<code class="fe nq nr ns nh b">a</code> <code class="fe nq nr ns nh b">c</code> <code class="fe nq nr ns nh b">b</code>输出得尽可能的奇怪。因为JavaScript是异步的，并且是著名的事件循环的一部分，你可能已经知道了，或者你最好在Google上看看这个。</p><p id="fb91" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja"> JavaScript主要有3个工具来处理异步。</strong></p><h2 id="6a93" class="nl ml iq bd mm nt nu dn mq nv nw dp mu kx nx ny mw lb nz oa my lf ob oc na iw bi translated">复试</h2><p id="2ebc" class="pw-post-body-paragraph ko kp iq kq b kr od ka kt ku oe kd kw kx of kz la lb og ld le lf oh lh li lj ij bi translated">回调函数是在某些事件上运行的函数，比如“作业完成”或“发生错误”，给定关于该事件的参数。</p><p id="9cec" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这导致了众所周知的“回调地狱”的情况，在这种情况下，您嵌套回调的方式使得代码不可读并且容易出现错误。</p><h2 id="f01a" class="nl ml iq bd mm nt nu dn mq nv nw dp mu kx nx ny mw lb nz oa my lf ob oc na iw bi translated">承诺</h2><p id="7d34" class="pw-post-body-paragraph ko kp iq kq b kr od ka kt ku oe kd kw kx of kz la lb og ld le lf oh lh li lj ij bi translated">哪些是新的(不太新？)的方式来<strong class="kq ja">处理异步处理。</strong>这允许<strong class="kq ja">通过允许链接语句而不是嵌套来减少“回调地狱”</strong>。</p><h2 id="05dc" class="nl ml iq bd mm nt nu dn mq nv nw dp mu kx nx ny mw lb nz oa my lf ob oc na iw bi translated">异步函数</h2><p id="7e7d" class="pw-post-body-paragraph ko kp iq kq b kr od ka kt ku oe kd kw kx of kz la lb og ld le lf oh lh li lj ij bi translated">这是对异步作业和承诺语法的改进。这纯粹是承诺的语法糖，使用了某种隐藏的生成器函数。</p><p id="7e27" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">简而言之，您可以编写异步代码，在进入下一条语句之前等待异步处理完成。</p><h1 id="e0a3" class="mk ml iq bd mm mn mo mp mq mr ms mt mu kf mv kg mw ki mx kj my kl mz km na nb bi translated">异步编程优化</h1><p id="c9b2" class="pw-post-body-paragraph ko kp iq kq b kr od ka kt ku oe kd kw kx of kz la lb og ld le lf oh lh li lj ij bi translated">好了，现在一切都是新鲜的，你可能已经使用过了，但是可能用错了异步函数。</p><p id="7c5c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">👨🏻‍🎓我们将在下面看到的模式:</strong></p><ol class=""><li id="aa02" class="oi oj iq kq b kr ks ku kv kx ok lb ol lf om lj on oo op oq bi translated"><strong class="kq ja">异步作业的小排序(SSAJ): </strong> <em class="or">当异步任务之间的关系很小，必须按特定顺序执行时。</em></li><li id="effa" class="oi oj iq kq b kr os ku ot kx ou lb ov lf ow lj on oo op oq bi translated"><strong class="kq ja">有延迟的小并行</strong> <code class="fe nq nr ns nh b"><strong class="kq ja">await</strong></code> <strong class="kq ja">启动后的语句:</strong> <em class="or">当异步任务之间没有关系，必须以任意顺序并行执行时。</em></li></ol><p id="3d66" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这些名字可能不存在，因为我只是这样命名的，它们可能有其他的名字😅</p><h2 id="f80d" class="nl ml iq bd mm nt nu dn mq nv nw dp mu kx nx ny mw lb nz oa my lf ob oc na iw bi translated">1 —异步作业的小排序(SSAJ)</h2><figure class="nc nd ne nf gt oy gh gi paragraph-image"><div role="button" tabindex="0" class="oz pa di pb bf pc"><div class="gh gi ox"><img src="../Images/0c3cd9346b84498f808c6d36594cbfba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IAQ44XCjxH_SBsob1GNPZg.png"/></div></div></figure><p id="3b8b" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">想象一下下面的代码片段，在阅读下一段之前，试着计算一下执行和打印这些值需要多长时间。</p><p id="d872" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">当你准备好得到答案时，只需在浏览器控制台或NodeJS程序中运行代码。</strong> <code class="fe nq nr ns nh b">console.time</code>是给出两个标记之间经过的时间的语句。</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="f6e1" class="nl ml iq nh b gy nm nn l no np">function resolveIn(time, val) {<br/>  return new Promise(res =&gt; setTimeout(() =&gt; res(val), time))<br/>}</span><span id="f070" class="nl ml iq nh b gy pe nn l no np">async function example() {<br/>  console.time("Example time");</span><span id="21d2" class="nl ml iq nh b gy pe nn l no np">const a = await resolveIn(3000, "a");<br/>  const b = await resolveIn(2000, a);</span><span id="8c04" class="nl ml iq nh b gy pe nn l no np">  console.log(a, b);</span><span id="b793" class="nl ml iq nh b gy pe nn l no np">  console.timeEnd("Example time");<br/>}</span><span id="5ad6" class="nl ml iq nh b gy pe nn l no np">example()</span></pre><p id="ee4e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">你觉得怎么样？</p><p id="745e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><strong class="kq ja">解释</strong></p><blockquote class="pf pg ph"><p id="5d29" class="ko kp or kq b kr ks ka kt ku kv kd kw pi ky kz la pj lc ld le pk lg lh li lj ij bi translated"><strong class="kq ja">答案大概5秒。</strong></p></blockquote><p id="de1e" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">正如你所看到的，使用关键字<code class="fe nq nr ns nh b">await</code>我们在第一条指令处阻塞了代码，这条指令必须等待3秒钟才能进入下一个事件。因此，我们等待3秒钟，然后一旦完成，我们只启动2秒钟的第二个计数器，这导致在打印语句之前总共有5秒钟。我们在第二个指令中使用了第一个异步指令值。<strong class="kq ja">那是排序或链接。</strong></p><blockquote class="pf pg ph"><p id="a50d" class="ko kp or kq b kr ks ka kt ku kv kd kw pi ky kz la pj lc ld le pk lg lh li lj ij bi translated">我们该如何改进呢？</p></blockquote><h2 id="8371" class="nl ml iq bd mm nt nu dn mq nv nw dp mu kx nx ny mw lb nz oa my lf ob oc na iw bi translated"><strong class="ak">2—启动后延迟</strong> <code class="fe nq nr ns nh b"><strong class="ak">await</strong></code> <strong class="ak">语句的异步作业(SPAJ)的小并行度。</strong></h2><figure class="nc nd ne nf gt oy gh gi paragraph-image"><div role="button" tabindex="0" class="oz pa di pb bf pc"><div class="gh gi ox"><img src="../Images/454b53e2defd8e5898506f42e3b18f02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RXe1lCrR3b25VlMoi7eEZw.png"/></div></div></figure><p id="1c05" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">我们在上面看到的<strong class="kq ja">非常适合需要以特定顺序执行的指令</strong>，例如，如果您需要来自第一个指令结果的一些数据来触发第二个指令。</p><p id="144a" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">但是当事情与副作用的免除无关时，你应该并行地实现那些<strong class="kq ja"/>来利用JavaScript异步能力。为此，<strong class="kq ja">你应该同时启动计数器</strong>,这样做的效果是同时将任务委托给内核，并将其放入事件循环中(或者至少在最快的时候，一个程序仍然一次执行一条语句😅).</p><p id="4ee6" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">下面的代码片段修复并改进了我们刚才看到的代码片段。</p><pre class="nc nd ne nf gt ng nh ni nj aw nk bi"><span id="2f5c" class="nl ml iq nh b gy nm nn l no np">function resolveIn(time, val) {<br/>  return new Promise(res =&gt; setTimeout(() =&gt; res(val), time))<br/>}</span><span id="0ed5" class="nl ml iq nh b gy pe nn l no np">async function example() {<br/>  console.time("Example time");</span><span id="9b72" class="nl ml iq nh b gy pe nn l no np">  const aPromise = resolveIn(3000, "a");<br/>  const bPromise = resolveIn(2000, "b");</span><span id="a4ef" class="nl ml iq nh b gy pe nn l no np">  console.log(await aPromise, await bPromise);<br/>  // or<br/>  console.log(await Promise.all([aPromise, bPromise]);<br/>  <br/>  console.timeEnd("Example time");<br/>}</span><span id="cd51" class="nl ml iq nh b gy pe nn l no np">example()</span></pre><p id="d215" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这里，我们(几乎)同时启动了异步计数器，程序仅在控制台语句处开始<code class="fe nq nr ns nh b">await</code>。我们没有等到第一条语句解决后再开始第二条语句，这导致了执行时间的整体改善。</p><p id="cf0c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated">这已经是一篇中等大小的文章了，但是我们可以通过循环和Javascript生成器更进一步。如果你有兴趣了解更多，请随时在LinkedIn上联系我，或者在Reddit上评论这个帖子</p></div><div class="ab cl md me hu mf" role="separator"><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi mj"/><span class="mg bw bk mh mi"/></div><div class="ij ik il im in"><p id="fc0c" class="pw-post-body-paragraph ko kp iq kq b kr ks ka kt ku kv kd kw kx ky kz la lb lc ld le lf lg lh li lj ij bi translated"><a class="ae pl" href="https://codingspark.io" rel="noopener ugc nofollow" target="_blank"> <strong class="kq ja"> 🇫🇷STOP！你是法国人吗🥖？</strong>您也可以访问ici网站，接收法国的私人通讯🙂</a></p><figure class="nc nd ne nf gt oy"><div class="bz fp l di"><div class="pm pn l"/></div></figure><h2 id="2f75" class="nl ml iq bd mm nt nu dn mq nv nw dp mu kx nx ny mw lb nz oa my lf ob oc na iw bi translated"><strong class="ak">简明英语笔记</strong></h2><p id="433d" class="pw-post-body-paragraph ko kp iq kq b kr od ka kt ku oe kd kw kx of kz la lb og ld le lf oh lh li lj ij bi translated">我们总是有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae pl" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kq ja">submissions @ plain English . io</strong></a><strong class="kq ja"/>，并附上您的Medium用户名，我们会将您添加为作者。</p></div></div>    
</body>
</html>