<html>
<head>
<title>What is Hoisting in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的提升是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-hoisting-in-javascript-7ad4f391c40e?source=collection_archive---------7-----------------------#2020-05-06">https://javascript.plainenglish.io/what-is-hoisting-in-javascript-7ad4f391c40e?source=collection_archive---------7-----------------------#2020-05-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ee24e9fe16be7d801b3892d888c0db62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UD-Xzx-VuOwSBGfhNS0etg.png"/></div></div></figure><blockquote class="jy jz ka"><p id="5e5e" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">对于TL；卷轴淹死博士</p></blockquote><p id="22fa" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">提升是一个经常被误用的术语，在工作面试和技术对话中经常被抛弃，很少有人真正理解它，并抓住幕后真正发生的事情。</p><p id="9b2b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">大多数刚接触JavaScript的开发人员，当被问及提升时，首先会想到<strong class="ke ir"> let </strong> vs <strong class="ke ir"> var </strong>变量，如何在声明(var)之前使用一个，而在声明(let)之前不使用另一个。他们是对的，因为在许多流行文章中发现的提升的核心定义如下:</p><blockquote class="jy jz ka"><p id="ab99" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">提升是JavaScript将var声明移动到顶部的默认行为。</p></blockquote><p id="9d93" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">因此，在声明变量之前物理地(在我们的代码中)使用一个<strong class="ke ir">变量</strong>是可以的，但是在声明变量之前使用一个<strong class="ke ir"> let </strong>变量(在我们的代码中)会导致错误。</p><p id="ad21" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">嗯，不完全是…让我们倒回去看看当JavaScript引擎执行我们的代码时实际发生了什么。</p><p id="1874" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">首先让我们记住，JavaScript中的每一行都是在执行上下文中运行的(如果代码在函数中，则是函数执行上下文，否则是全局执行上下文)。</p><p id="eee6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">因此，当JavaScript引擎执行我们的代码时，它在两个阶段设置全局执行上下文:创建阶段和执行阶段。</p><p id="f8ca" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke ir">创建阶段:</strong> JavaScript将创建全局对象(窗口，因为我们在全局级别)、用于访问全局对象的this变量和外部环境(将为<strong class="ke ir"> null </strong>，因为我们在全局级别)…</p><p id="b849" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">然后，它将为所有变量和函数设置内存空间，或者简称为“<strong class="ke ir">提升</strong>”！JavaScript引擎将通读我们的代码，每次在全局级别找到变量声明时，它将在内存中为它保留一个空间，将其值设置为<strong class="ke ir"> undefined </strong>，每次找到函数声明时，它将在内存中为它保留一个空间，并完全分配它。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ld"><img src="../Images/5627c8e2cf1332a2a8c0c3455db74d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pLo5sQq0NA0Z89M51Aku3w.gif"/></div></div></figure><p id="339b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated"><strong class="ke ir">执行阶段:</strong>在使用变量环境创建了全局上下文之后，JavaScript引擎开始逐行执行我们的代码。因此，当JavaScript引擎在执行阶段到达我们示例中的第二行时，它已经知道我们已经为值为<strong class="ke ir"> undefined </strong>的<strong class="ke ir">my village</strong>变量分配了一个空间，这意味着为变量分配一个新值是完全正确的，并且不会抛出错误(你知道…因为变量已经在变量环境中定义了！).</p><p id="c420" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">函数也是如此，因为它们已经在变量环境中声明了，所以在代码中物理声明函数之前先调用它是没问题的，假设我们使用函数语句来声明它(稍后会详细介绍)。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ld"><img src="../Images/312c57e05e0cbfee183822d8f480e149.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*KiqWbbwm7tlcx_e3iAQwMw.gif"/></div></div></figure><blockquote class="jy jz ka"><p id="73d7" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir"> <em class="iq">因此，提升简单来说就是在执行上下文的创建过程中，为变量和函数分配内存空间。</em>T3】</strong></p></blockquote><p id="ae71" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">但是等等……那么<strong class="ke ir"> let </strong>宣言呢？既然JavaScript引擎抛出一个错误，如果我们试图在声明之前使用它，这是否意味着提升不包括<strong class="ke ir"> let </strong>声明？</p><p id="271d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">答案是:不会。就像<strong class="ke ir"> var </strong>一样，<strong class="ke ir"> let </strong>声明也<strong class="ke ir">在创建执行上下文的过程中被提升。我们只是在声明<strong class="ke ir"> let </strong>变量的代码中，没有<strong class="ke ir"/><strong class="ke ir">允许</strong>使用它们。它仍然存在于内存中，我们只是不允许使用它！所以不用，对于<strong class="ke ir">功能</strong>、<strong class="ke ir">变量</strong>、<strong class="ke ir">让</strong>和<strong class="ke ir">常量</strong>声明，提升工作是一样的。</strong></p><p id="bca7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">以下是一些例子:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="9bae" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">现在你已经掌握了提升的概念，理解了实际发生的事情，并且代码不会“<em class="kd">神奇地</em>”移动到顶部，我有一个小测验给你(对一些人来说是基本的，但对另一些人来说是棘手的)。</p><p id="7d74" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">以下结果会是什么:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="4c9a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">没错，抛出一个错误。但这是为什么呢？为什么下面的代码运行良好:</p><figure class="le lf lg lh gt jr"><div class="bz fp l di"><div class="li lj l"/></div></figure><p id="e381" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">这是因为，在我们的第一个例子中，我们使用了一个函数表达式，而不是第二个例子中的函数语句(这两个术语值得另文讨论)。现在只要记住函数表达式创建一个对象并将其返回给一个<strong class="ke ir">变量</strong>，函数语句在内存中创建一个函数并不返回值。</p><p id="ae01" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">所以在第一个例子中，在提升时，JavaScript引擎会在内存中为<strong class="ke ir">攻击</strong>设置一个空间作为<strong class="ke ir">变量</strong>，并将其值设置为<strong class="ke ir">未定义</strong>，这是JavaScript的正常行为。记得吗？在执行上下文的创建阶段，内存空间中的每个<strong class="ke ir">变量</strong>、<strong class="ke ir"> let </strong>和<strong class="ke ir">常量</strong>都被设置为<strong class="ke ir">未定义</strong>。</p><p id="cf10" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">如果我们看看抛出的错误“<em class="kd">未捕获类型错误:攻击不是函数</em>”，它是非常不言自明的:攻击不是函数，仅仅因为它是<strong class="ke ir">未定义的</strong>。这是JavaScript引擎在执行阶段在其可变环境中寻找<strong class="ke ir">攻击</strong>时得到的值。</p><p id="5be7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">然而，在第二个例子中，我们使用了一个函数语句，它不会将对象返回给变量，而是在内存中创建函数。因此，JavaScript引擎将把它提升为一个函数，可以在声明之前调用。</p><h1 id="1e2a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated"><strong class="ak">TL；DR </strong></h1><p id="66e8" class="pw-post-body-paragraph kb kc iq ke b kf mp kh ki kj mq kl km la mr kp kq lb ms kt ku lc mt kx ky kz ij bi translated">1- <strong class="ke ir">提升</strong>意味着在创建执行上下文期间为变量和函数分配内存空间。变量以值的形式给出<strong class="ke ir">未定义</strong>。</p><p id="638b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">2-所有变量声明:<strong class="ke ir"> var </strong>、<strong class="ke ir"> let </strong>和<strong class="ke ir"> const </strong>均以吊装为准</p><p id="179e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">3-我们不允许使用<strong class="ke ir">让</strong>和<strong class="ke ir">在物理上符合代码中声明的行之前常量</strong>变量。即使它们确实存在于内存中并且被设置为<strong class="ke ir">未定义</strong>。</p><p id="2844" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">4-当使用函数表达式时，我们创建一个返回变量的对象，它将被视为……嗯，一个变量。即被吊起，给定值<strong class="ke ir">未定义</strong>。换句话说:如果声明为函数表达式，就不能在声明之前使用函数。</p><p id="5e46" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">5-另一方面，当使用函数语句时，函数在内存中被完全分配，并且它可以在我们的代码中在声明之前被调用。</p><p id="e302" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">6-是的，在JavaScript中，函数就是对象。</p></div><div class="ab cl lk ll hu lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ij ik il im in"><p id="4ea9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">Kaoutar LAGDANI</p><div class="mu mv gp gr mw mx"><a href="http://lagdani.com" rel="noopener  ugc nofollow" target="_blank"><div class="my ab fo"><div class="mz ab na cl cj nb"><h2 class="bd ir gy z fp nc fr fs nd fu fw ip bi translated">Kaoutar Lagdani | Fullstack开发人员</h2><div class="ne l"><h3 class="bd b gy z fp nc fr fs nd fu fw dk translated">Kaoutar Lagdani个人网站</h3></div><div class="nf l"><p class="bd b dl z fp nc fr fs nd fu fw dk translated">lagdani.com</p></div></div><div class="ng l"><div class="nh l ni nj nk ng nl jw mx"/></div></div></a></div><h2 id="ac5a" class="nm ls iq bd lt nn no dn lx np nq dp mb la nr ns mf lb nt nu mj lc nv nw mn nx bi translated"><strong class="ak">简明英语团队备注</strong></h2><p id="0a70" class="pw-post-body-paragraph kb kc iq ke b kf mp kh ki kj mq kl km la mr kp kq lb ms kt ku lc mt kx ky kz ij bi translated">你知道我们有四种出版物吗？给他们一个如下的提示来表达爱意:<a class="ae ny" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="ke ir"/></a>、<a class="ae ny" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ke ir">AI</strong>、</a>、<a class="ae ny" href="https://medium.com/ux-in-plain-english" rel="noopener">、<strong class="ke ir">UX</strong></a>、<a class="ae ny" href="https://medium.com/python-in-plain-english" rel="noopener">、<strong class="ke ir">Python</strong>、</a>、<strong class="ke ir">、</strong>——谢谢你，继续学习吧！</p><p id="7779" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km la ko kp kq lb ks kt ku lc kw kx ky kz ij bi translated">此外，我们总是有兴趣帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae ny" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ke ir">submissions @ plain English . io</strong></a><strong class="ke ir"/>，附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>