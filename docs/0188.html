<html>
<head>
<title>22 React Performance Optimization Techniques</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">22反应性能优化技术</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/https-medium-com-mayank-gupta-6-88-21-performance-optimizations-techniques-for-react-d15fa52c2349?source=collection_archive---------0-----------------------#2019-07-24">https://javascript.plainenglish.io/https-medium-com-mayank-gupta-6-88-21-performance-optimizations-techniques-for-react-d15fa52c2349?source=collection_archive---------0-----------------------#2019-07-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4770" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React编程的最佳优化技术。</h2></div><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="kk kl l"/></div><figcaption class="km kn gj gh gi ko kp bd b be z dk">Optimize React with Simple Steps !!!</figcaption></figure><p id="6196" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae lm" href="https://www.youtube.com/channel/UCo-h1M-5M6Y5D4Lgut8ge4w" rel="noopener ugc nofollow" target="_blank"><strong class="ks ir">techno funnel</strong></a><strong class="ks ir"/>带来另一篇关于<strong class="ks ir">优化React性能</strong>的文章，步骤简单。只需尝试实现这些优化步骤并获得增强的性能。React为设计高性能react应用程序提供了许多优化，通过遵循这些最佳实践可以实现这些优化。本文涵盖了React版本16.8及更高版本中的最新特性。</p><p id="e85c" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">父组件和子组件通常在以下情况下重新呈现:</p><ol class=""><li id="8556" class="ln lo iq ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">在同一个组件或父组件中调用<code class="fe lw lx ly lz b">setState</code>时。</li><li id="343c" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll ls lt lu lv bi translated">从父母那里得到的“支持”价值的变化。</li><li id="b0c7" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll ls lt lu lv bi translated">在组件中调用<code class="fe lw lx ly lz b">forceUpdate</code>。</li></ol><p id="e7a5" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks ir"> React性能优化</strong>通过以下简单步骤即可轻松实现。<strong class="ks ir">使用下面提到的步骤优化您的React应用程序</strong>。在列表之后，您可以查找关于每种方法的详细讨论</p><ul class=""><li id="aafd" class="ln lo iq ks b kt ku kw kx kz lp ld lq lh lr ll mf lt lu lv bi translated">使用React <a class="ae lm" href="#8d03" rel="noopener ugc nofollow">纯组件</a>减少重新渲染</li><li id="e116" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">使用<a class="ae lm" href="#50f6" rel="noopener ugc nofollow"> React钩子</a>并使用函数编程</li><li id="7dba" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">使用<a class="ae lm" href="#cbb7" rel="noopener ugc nofollow"> React.memo </a>进行组件记忆</li><li id="3aa8" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">使用<a class="ae lm" href="#c635" rel="noopener ugc nofollow"> shouldComponentUpdate </a>生命周期事件</li><li id="3206" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">使用<a class="ae lm" href="#677f" rel="noopener ugc nofollow">惰性加载</a>反应组件</li><li id="3101" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">使用<a class="ae lm" href="#d063" rel="noopener ugc nofollow">反应片段</a>以避免额外的标记</li><li id="bd4a" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">不要使用<a class="ae lm" href="#1827" rel="noopener ugc nofollow"> React内联函数定义</a></li><li id="195e" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">避免<a class="ae lm" href="#0a31" rel="noopener ugc nofollow"> componentWillMount() </a>中的异步请求</li><li id="20f8" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated"><a class="ae lm" href="#67cc" rel="noopener ugc nofollow">在构造函数早期绑定函数</a></li><li id="de55" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated"><a class="ae lm" href="#f147" rel="noopener ugc nofollow">箭头函数</a> vs构造函数中的绑定</li><li id="1ad3" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">避免<a class="ae lm" href="#cb48" rel="noopener ugc nofollow">使用内嵌样式</a>属性</li><li id="68ca" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated"><a class="ae lm" href="#a1c2" rel="noopener ugc nofollow">优化React中的条件渲染</a></li><li id="862d" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated"><a class="ae lm" href="#d287" rel="noopener ugc nofollow">不要在渲染方法中导出数据</a></li><li id="eaa9" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">为组件创建<a class="ae lm" href="#ed88" rel="noopener ugc nofollow">错误边界</a></li><li id="a2e0" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated"><a class="ae lm" href="#cc36" rel="noopener ugc nofollow">组件的不可变数据结构</a></li><li id="1a74" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">使用<a class="ae lm" href="#c550" rel="noopener ugc nofollow">唯一键进行迭代</a></li><li id="f413" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated"><a class="ae lm" href="#f459" rel="noopener ugc nofollow">节流和去抖动</a>事件</li><li id="8149" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">将<a class="ae lm" href="#8dcb" rel="noopener ugc nofollow">cdn</a>用于外部资源</li><li id="7044" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated"><a class="ae lm" href="#9676" rel="noopener ugc nofollow"> CSS动画</a>而不是JavaScript动画</li><li id="4ad2" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">在Web服务器上启用<a class="ae lm" href="#c30b" rel="noopener ugc nofollow"> gzip压缩</a></li><li id="7ded" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">使用<a class="ae lm" href="#d2b1" rel="noopener ugc nofollow">网络工作者</a>处理CPU扩展任务</li><li id="7063" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">React组件的服务器端渲染</li></ul><h1 id="8d03" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated"><strong class="ak"> 1。使用纯组件</strong></h1><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi my"><img src="../Images/e294f68131d2012fbe1696201f826a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7V4Kv9IKpf_UQfxsMsmEA.jpeg"/></div></div><figcaption class="km kn gj gh gi ko kp bd b be z dk">Pure Components in React Programming</figcaption></figure><p id="b03c" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果React组件为相同的状态和属性呈现相同的输出，则可以认为它是纯的。</p><p id="9437" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于这样的类组件，React提供了<code class="fe lw lx ly lz b">PureComponent</code> <strong class="ks ir"> </strong>基类。扩展<code class="fe lw lx ly lz b">React.PureComponent</code>类的类组件被视为纯组件。</p><p id="955c" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">除了<code class="fe lw lx ly lz b">PureComponents</code>负责<code class="fe lw lx ly lz b">shouldComponentUpdate</code>之外，它和普通组件是一样的——它对状态和道具数据进行简单的比较。</p><p id="66d9" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果前一个状态和属性数据与下一个属性或状态相同，则组件不会被重新渲染。</p><h2 id="6344" class="nf mh iq bd mi ng nh dn mm ni nj dp mq kz nk nl ms ld nm nn mu lh no np mw nq bi translated"><strong class="ak">什么是浅层渲染？</strong></h2><p id="e75f" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">当前一个属性和状态与下一个进行比较时，一个简单的比较将检查原语是否具有相同的值(例如:<code class="fe lw lx ly lz b">1</code>等于<code class="fe lw lx ly lz b">1</code>或<code class="fe lw lx ly lz b">true</code>等于<code class="fe lw lx ly lz b">true</code>)，以及在更复杂的JavaScript值(如对象和数组)之间<em class="nw">引用</em>是否相同。</p><p id="449a" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">与更新组件视图相比，比较原始引用和对象引用是一种成本更低的操作。</p><p id="1edf" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所以寻找状态和道具值的变化会更快，而不是做不必要的更新。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="0ec4" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上面的例子中，状态被传播到子组件<code class="fe lw lx ly lz b">RegularChildComponent</code>和<code class="fe lw lx ly lz b">PureChildComponent</code>。<code class="fe lw lx ly lz b">PureChildComponent</code>是纯成分。</p><p id="b8b2" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一秒钟后，调用<code class="fe lw lx ly lz b">setState</code>，这将重新触发组件的视图渲染。由于初始道具和新道具值相同，组件(<code class="fe lw lx ly lz b">PureChildComponent</code>)将不会被重新渲染。</p><p id="1b43" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">状态的简单比较表明，属性或状态的数据都没有变化，因此组件不需要呈现，使组件更有效。</p><p id="1b93" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有关纯组件的视频教程，请参考以下内容:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="ny kl l"/></div><figcaption class="km kn gj gh gi ko kp bd b be z dk"><a class="ae lm" href="https://www.youtube.com/watch?v=X94LfGK7I9Y" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=X94LfGK7I9Y</a></figcaption></figure></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="cbb7" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated"><strong class="ak"> 2。使用React.memo进行组件记忆</strong></h1><p id="7c09" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated"><code class="fe lw lx ly lz b">React.memo</code>是高阶分量。</p><p id="d863" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它类似于一个<code class="fe lw lx ly lz b">PureComponent</code>，但是<code class="fe lw lx ly lz b">PureComponent</code>属于<code class="fe lw lx ly lz b">Component</code>的类实现，而“memo”用于创建功能组件。</p><p id="6c93" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">类似于纯组件，如果输入属性相同，组件渲染将被跳过，使组件更快更有效。</p><p id="1551" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它会记住某个输入属性的最后一次执行的输出，并提升应用程序的性能。即使在这些组件中，比较也是肤浅的。</p><p id="531a" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您还可以为此组件传递自定义比较逻辑。</p><p id="147f" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">自定义逻辑可以使用户能够寻找对象的深层比较。如果比较函数返回<code class="fe lw lx ly lz b">false</code>，组件将被重新渲染，否则，没有组件的重新渲染。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="26cf" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上面的组件将对上一个和下一个道具的值做一个简单的比较。</p><p id="68f2" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在我们将对象引用作为道具传递给<code class="fe lw lx ly lz b">memo</code>组件的情况下，需要一些自定义登录来进行比较。在这种情况下，我们可以将比较函数作为第二个参数传递给<code class="fe lw lx ly lz b">React.memo</code>函数。</p><p id="d98a" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">假设props值(<code class="fe lw lx ly lz b">user</code>)是一个对象引用，包含特定用户的<code class="fe lw lx ly lz b">name</code>、<code class="fe lw lx ly lz b">age</code>和<code class="fe lw lx ly lz b">designation</code>。</p><p id="4ab4" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这种情况下，需要做一个深层次的比较。我们可以创建一个自定义函数，查找前一个和下一个props值的<code class="fe lw lx ly lz b">name</code>、<code class="fe lw lx ly lz b">age</code>和<code class="fe lw lx ly lz b">designation</code>的值，如果它们不相同，则返回<code class="fe lw lx ly lz b">false</code>。</p><p id="4bec" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这样，我们的组件将不会重新呈现，即使我们有引用数据作为<code class="fe lw lx ly lz b">memo</code>组件的输入。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="a841" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上面的代码提供了用于比较的自定义逻辑。</p><p id="a5f4" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有关高阶分量的视频指南，请参考以下内容:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="ny kl l"/></div><figcaption class="km kn gj gh gi ko kp bd b be z dk">Working with React Higher Order Components</figcaption></figure></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="c635" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">3.使用shouldComponentUpdate生命周期事件</h1><p id="af3d" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">这是组件重新呈现之前触发的生命周期事件之一。</p><p id="f9c4" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以有效地利用这个事件来决定组件何时需要重新呈现。如果组件属性改变或<code class="fe lw lx ly lz b">setState</code>被调用，该函数返回一个<code class="fe lw lx ly lz b">Boolean</code>值。</p><p id="160d" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这两种情况下，组件都倾向于重新呈现。我们可以在这个生命周期事件中放置一个自定义逻辑来决定是否调用组件的渲染函数。</p><p id="2d49" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">该函数将<code class="fe lw lx ly lz b">nextState</code>和<code class="fe lw lx ly lz b">nextProps</code>作为输入，并可以与当前的道具和状态进行比较，以决定是否需要重新渲染。</p><p id="8537" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们借助一个场景来理解它:</p><p id="e416" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我想在网页上显示员工的详细信息。每个雇员包含几个属性，如姓名、年龄、职务、工资、现任经理、前任经理、奖金等。</p><p id="6b16" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在所有这些细节中，我只想在我的网页上呈现所选员工的姓名和年龄。在某个时刻，员工的名称会更新。</p><p id="7699" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">由于雇员名称不是视图的一部分，理想情况下，视图不需要更新。我们可以在组件中添加定制逻辑，看看我们是否需要组件来更新视图。</p><p id="4797" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们在程序的帮助下看看这个场景:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="a524" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这里，即使组件中的<code class="fe lw lx ly lz b">designation</code>发生了变化，也不会对应用程序的视图产生影响。</p><p id="fe45" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当<code class="fe lw lx ly lz b">setState</code>被调用时，组件倾向于重新渲染，因为<code class="fe lw lx ly lz b">designation</code>的改变不会改变/影响组件的视图，所以在名称改变时重新渲染组件将是开销。</p><p id="1ea2" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了避免这种开销，我们可以定制逻辑来检查<code class="fe lw lx ly lz b">name</code>或<code class="fe lw lx ly lz b">age</code>是否正在更新，因为视图只受<code class="fe lw lx ly lz b">Name</code>或<code class="fe lw lx ly lz b">Age</code>的影响。</p><p id="b23e" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe lw lx ly lz b">shouldComponentUpdate</code>将输入参数作为状态和道具的新值。</p><p id="f556" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以比较姓名和年龄的当前值和新值。如果它们中的任何一个发生变化，我们可以触发重新渲染。</p><p id="f9a4" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">从<code class="fe lw lx ly lz b">shouldComponentUpdate</code>传递<code class="fe lw lx ly lz b">true</code>通知组件可以被重新渲染，反之亦然。因此，如果正确使用<code class="fe lw lx ly lz b">shouldComponentUpdate</code>，我们可以优化应用组件的性能。</p><p id="7c50" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">比较初始状态和道具，我们可以决定组件是否需要重新渲染。这将通过减少重新渲染周期来提高应用程序的性能。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="677f" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">4.使用组件的延迟加载</h1><p id="8f5c" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">捆绑是将多个文件导入并合并为一个文件的过程，这样应用程序就不必导入大量外部文件。</p><p id="0060" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所有主要组件和外部依赖项被合并到一个文件中，并通过网络发送，以启动和运行web应用程序。</p><p id="da3f" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这节省了大量的网络调用，但也导致了一个问题，即这个单个文件变成了一个大文件，消耗了大量的网络带宽。</p><p id="737f" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">应用程序一直在等待这个大文件的加载和执行，因此这个文件在网络上传输的延迟会导致应用程序的渲染时间更长。</p><p id="7540" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了解决这个问题，我们可以引入<em class="nw">代码分割</em>的概念。</p><p id="a0f6" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">像<a class="ae lm" href="https://webpack.js.org/" rel="noopener ugc nofollow" target="_blank"> webpack </a>这样的捆绑包支持代码分割的概念，它可以为应用程序创建多个捆绑包，并且可以在运行时动态加载。</p><p id="623e" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">运行时加载减少了创建的初始包的大小。</p><p id="b338" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以计划以某种方式分解包，以便最初没有加载到应用程序中的组件可以推迟到以后需要时再加载。</p><p id="8ae9" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这将减小主包的大小，并减少应用程序的加载时间。为此，我们使用<code class="fe lw lx ly lz b">Suspense</code>和<code class="fe lw lx ly lz b">lazy</code>。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="f89c" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上面的代码中，我们有一个条件语句，它查找props值，并根据指定的条件，在主组件中加载两个组件中的任何一个。</p><p id="d776" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最初在主包中加载这两个组件会增加包的整体大小。在任何时候，我们都需要渲染两个组件中的一个。</p><p id="1efe" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，加载视图中可能添加也可能不添加的所有组件会降低性能。</p><p id="8c3c" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以在需要时延迟加载组件，这些组件是单独块的一部分，在运行时加载，这增强了应用程序的整体性能。</p><p id="2219" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以借助另一个例子来理解这一点。</p><p id="47a6" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们假设有两个不同的组件是根据用户是否登录来呈现的。</p><p id="1f29" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">呈现两个组件中的一个:<code class="fe lw lx ly lz b">WelcomeComponent</code>或<code class="fe lw lx ly lz b">GuestComponents</code>，这取决于用户是否登录。</p><p id="4d39" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以根据以后的情况延迟组件的加载，而不是在初始的包文件中加载这两个组件。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="7e51" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上面的代码中，我们可以使用组件顶部的<code class="fe lw lx ly lz b">import</code>关键字预加载上面的两个组件，但是，我们没有预加载组件<code class="fe lw lx ly lz b">WelcomeCompoment</code>和<code class="fe lw lx ly lz b">GuestComponents</code>，而是进行了条件检查。</p><p id="d95a" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果用户名存在或不存在，根据指定的条件，我们决定哪个组件需要作为单独的包来加载。</p><p id="c0f2" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了使初始包不包含这两个组件，将根据指定的条件动态加载一个新包。</p><h2 id="491e" class="nf mh iq bd mi ng nh dn mm ni nj dp mq kz nk nl ms ld nm nn mu lh no np mw nq bi translated">该方法的优势</h2><ol class=""><li id="80ea" class="ln lo iq ks b kt nr kw ns kz ol ld om lh on ll ls lt lu lv bi translated">主包的大小将会减小，因为初始包中没有加载<code class="fe lw lx ly lz b">WelcomeCompoment</code>和<code class="fe lw lx ly lz b">GuestComponents</code>，初始包加载消耗的网络时间更少。</li><li id="56b3" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll ls lt lu lv bi translated">根据指定的条件，加载所需组件的单独请求是动态进行的。单独加载的包是一个小的包文件，可以很快加载。</li></ol><p id="10c8" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以寻找应用程序来决定哪些组件可以在以后加载，从而减少应用程序的初始加载时间。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="d063" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">5.使用React片段来避免额外的标签</h1><p id="bd2a" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">使用片段减少了包含的额外标签的数量，只是为了满足React组件中有一个公共父元素的要求。</p><p id="1c14" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在用户创建新组件的情况下，每个组件应该有一个父标签。两个标签不能位于父级，所以我们需要在顶层有一个公共标签。</p><p id="11e9" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了迎合这个需求，我们经常在组件的顶部添加一个额外的标签。</p><p id="dd34" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">请参见下面的示例:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi oo"><img src="../Images/3c4ae84c88611891206af31efcab2bc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N1qiBBmPvnyDnpvhADVCfA.png"/></div></div></figure><p id="39ed" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上面指定的组件中，我们需要一个额外的标记来为要呈现的组件提供一个公共父级。</p><p id="c296" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个额外的<code class="fe lw lx ly lz b">div</code>除了作为组件的父标签之外没有任何其他用途。添加它只是因为组件不能有两个父标记。</p><p id="361e" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">顶层有多个标记会导致以下错误:</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div role="button" tabindex="0" class="mz na di nb bf nc"><div class="gh gi op"><img src="../Images/e934c38b3a2b1f7238e49c3b75d47c90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zqutX7S3d3jU_2QlUxtSkw.png"/></div></div></figure><p id="cbe0" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，作为一种形式，我们需要一个额外的标签来封装位于同一层的标签。</p><p id="9213" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了解决这个问题，我们可以将元素放在一个片段中。</p><p id="4bb4" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">该片段没有向组件引入任何额外的标签，但是它仍然向两个相邻的标签提供父标签，从而满足了在组件的顶层具有单个父标签的条件。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="ced6" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上面的代码中，没有额外的标签来包含标签，因此节省了渲染器在页面上渲染额外元素的工作量。</p><p id="f8bc" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">请参考以下网址了解更多信息:</p><div class="oq or gp gr os ot"><a href="https://github.com/facebook/react/issues/2127" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">添加片段API以允许从渲染问题#2127 facebook/react返回多个组件</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">来自维护者的提示:我们知道这是一个问题，我们确切地知道哪一组问题可以被解决。我们也想要这个…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph nd ot"/></div></div></a></div></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="1827" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">6.不要使用内联函数定义</h1><p id="af76" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">如果我们使用内联函数，那么每次调用“render”函数时，都会创建该函数的一个新实例。</p><p id="544f" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当React进行虚拟DOM区分时，它每次都会找到一个新的函数实例，因此在呈现阶段，它会绑定新的函数，并将旧的实例留给垃圾收集。</p><p id="f65b" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，直接绑定内联函数会导致垃圾收集器上的额外工作以及绑定到DOM的新函数。</p><p id="8667" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下面是组件中内联函数的示例:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="9da4" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上面的函数创建了内联函数。每次调用render函数时，都会创建函数的新实例，render函数会将函数的新实例绑定到按钮。</p><p id="cc18" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">此外，最后一个函数实例可用于垃圾收集，因此增加了React应用程序的大量工作。</p><p id="697d" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">不要使用内联函数，而是在组件内部创建一个函数，并将事件绑定到该函数本身。这样做不会在每次调用render时创建单独的函数实例。</p><p id="4dab" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">作为参考，请参见下面的组件。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="0a31" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">7.避免componentWillMount()中的异步请求</h1><p id="bbcd" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">将在组件呈现之前调用<code class="fe lw lx ly lz b">componentWillMount</code>。</p><p id="3fc7" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这个功能用的不多。它可以用来配置组件的初始配置，但这可以通过<code class="fe lw lx ly lz b">constructor</code>方法本身来完成。</p><p id="9c17" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">该方法无法访问DOM元素，因为组件仍未安装。</p><p id="4c8e" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">尽管有些开发人员认为这是可以进行异步数据API调用的函数。但是，这样做没有任何好处。</p><p id="b228" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">由于API调用是异步的，组件在调用<code class="fe lw lx ly lz b">render</code>函数之前不会等待API返回数据。因此，组件在初始呈现时没有任何数据。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="1463" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上面的代码中，我们进行了一个异步调用来获取数据。由于数据调用是异步的，因此需要一段时间才能获取。</p><p id="b4ab" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在检索数据时，React触发组件的<code class="fe lw lx ly lz b">render</code>功能。因此，调用的第一个呈现仍然不包含所需的数据。</p><p id="c37e" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，最初，组件用空数据呈现，后来数据被检索，调用<code class="fe lw lx ly lz b">setState</code>，组件被重新呈现。在<code class="fe lw lx ly lz b">componentWillMount</code>阶段进行AJAX调用没有太大的好处。</p><p id="d740" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们应该避免在这个函数中发出<code class="fe lw lx ly lz b">Async</code>请求。相反，这样的函数和调用可以延迟到<code class="fe lw lx ly lz b">componentDidMount</code>生命周期事件。</p><p id="1126" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks ir">注意</strong> : <code class="fe lw lx ly lz b">componentWillMount</code>在React 16.3中已被弃用。如果您正在使用React的最新版本，请避免使用此生命周期事件。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="67cc" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">8.在构造函数的早期绑定函数</h1><p id="e5f1" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">当我们在React中创建函数时，我们需要使用<code class="fe lw lx ly lz b">bind</code>关键字将函数绑定到当前上下文。</p><p id="d435" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">绑定可以在构造函数中完成，也可以在我们将这个函数绑定到DOM元素的地方完成。</p><p id="1ea3" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这两者之间似乎没有太大的区别，但是性能影响是不同的。</p><p id="9b57" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有关更多详细信息，请参见下面的代码:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="e249" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上面的代码中，我们在绑定<code class="fe lw lx ly lz b">render</code>函数时将功能绑定到按钮。</p><p id="c6f1" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上面代码的问题在于，每次调用render函数时，都会创建并使用一个绑定到当前上下文的新函数。</p><p id="a4c9" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">每次渲染时使用已经存在的函数比每次渲染时创建新函数更有效。</p><p id="03bf" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们看看如何为此优化代码:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="ced2" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上面的代码优化了每次调用render函数时重新创建函数的问题。</p><p id="ca6c" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">与其每次在render时绑定函数，不如在构造函数调用期间用绑定到当前上下文的函数覆盖<code class="fe lw lx ly lz b">handleButtonClick</code>函数。</p><p id="b916" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这将减少将函数绑定到当前上下文并在每次渲染时重新创建函数的开销，从而提高应用程序的性能。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="f147" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">9.箭头函数与构造函数中的绑定</h1><p id="c165" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">使用箭头函数是处理类时的标准做法。如果我们使用箭头函数，执行的上下文将被保留。</p><p id="5bf6" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们不需要在调用函数时将它绑定到上下文。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="fc43" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">箭头功能似乎是一个很大的优势，但好处也有不好的一面。</p><p id="525c" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当我们添加一个箭头函数时，这个函数被添加为对象实例，而不是类的原型属性。这意味着，如果我们多次重用该组件，那么从该组件创建的每个对象中将会有这些功能的多个实例。</p><p id="9e9b" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对于这些功能，每个组件都有一个单独的实例，可重用性降低了。此外，因为它是对象属性而不是原型属性，所以这些函数在继承链中不可用。</p><p id="8002" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所以，尽管arrow函数看起来很有用，也很容易实现，但是它也有缺点。实现函数的最佳方式是在构造函数中绑定函数，如上面所述。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="cb48" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">10.避免使用内联样式属性</h1><p id="7060" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">使用内联样式，浏览器花费更多的时间编写脚本和渲染。</p><p id="f808" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">大量时间花费在脚本上，因为它必须将所有样式规则映射到实际的CSS属性，这增加了组件的呈现时间。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="082f" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上面创建的组件中，我们将内联样式附加到组件上。添加的内联样式是一个JavaScript对象，而不是样式标签。</p><p id="813a" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">样式<code class="fe lw lx ly lz b">backgroundColor</code>需要被转换成一个等价的CSS样式属性，然后样式将被应用。这样做包括编写脚本和执行JavaScript。</p><p id="c346" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">更好的方法是将CSS文件导入到组件中。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="a1c2" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated"><strong class="ak"> 11。优化React中的条件渲染</strong></h1><p id="5171" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">安装和卸载React组件是昂贵的操作。为了确保应用程序有更好的性能，我们需要确保减少安装和卸载操作的数量。</p><p id="24dc" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在许多情况下，我们可以有条件地呈现组件，条件是我们可以呈现或不呈现特定的元素。</p><p id="c9ae" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有关更多详细信息，请参见下面的场景。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="f627" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上面的代码中，我们有一个条件语句，其中组件根据指定的条件呈现。如果状态包含名称值<code class="fe lw lx ly lz b">Mayank</code>，则不呈现<code class="fe lw lx ly lz b">AdminHeaderComponent</code>。</p><p id="811a" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">条件操作符和<code class="fe lw lx ly lz b">if else</code>条件看起来不错，但是下面的代码有一个性能缺陷。</p><p id="6183" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们来评价一下上面的代码。</p><p id="cd6e" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">每次调用渲染函数并且值在<code class="fe lw lx ly lz b">Mayank</code>和另一个值之间切换时，执行不同的<code class="fe lw lx ly lz b">if else</code>语句。</p><p id="f7a2" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">diffing算法将运行检查，比较每个位置的元素类型。在diffing算法中，<code class="fe lw lx ly lz b">AdminHeaderComponent</code>似乎不可用，需要渲染的第一个组件是<code class="fe lw lx ly lz b">HeaderComponent</code>。</p><p id="6d3d" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">React将观察元素的位置。位置1和位置2的组件似乎已经更改，并将卸载这些组件。</p><p id="d6e4" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">组件<code class="fe lw lx ly lz b">HeaderComponent</code>和<code class="fe lw lx ly lz b">ContentComponent</code>将被卸载并重新安装在位置1和位置2。这在理想情况下是不需要的，因为这些组件不会改变，但是我们仍然必须卸载并重新装载这些组件。</p><p id="6c23" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是一个昂贵的手术。下面的代码可以这样优化:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="8096" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上面的代码中，当<code class="fe lw lx ly lz b">name</code>不是<code class="fe lw lx ly lz b">Mayank</code>时，React将<code class="fe lw lx ly lz b">null</code>放在位置1。</p><p id="568d" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当发生DOM diffing时，位置1的元素从<code class="fe lw lx ly lz b">AdminHeaderComponent</code>变为<code class="fe lw lx ly lz b">null</code>，但是位置2和位置3的组件保持不变。</p><p id="fb82" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">由于元素是相同的，组件没有被卸载，因此减少了应用程序中组件的<code class="fe lw lx ly lz b">Unmounting</code>和<code class="fe lw lx ly lz b">Mounting</code>。</p><p id="9f3e" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有关更深入的文档，请参考以下内容:</p><div class="oq or gp gr os ot"><a href="https://medium.com/@cowi4030/optimizing-conditional-rendering-in-react-3fee6b197a20" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">优化React中的条件渲染</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">我们知道React将从上到下爬行虚拟DOM，寻找组件树中的变化，并更新…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pi l pe pf pg pc ph nd ot"/></div></div></a></div></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="d287" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">12.不要在Render方法中派生数据</h1><p id="47c2" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated"><code class="fe lw lx ly lz b">Render</code>方法是React开发人员最熟悉的生命周期事件。</p><p id="4a8e" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">与任何其他生命周期事件不同，我们的核心原则是将<code class="fe lw lx ly lz b">render()</code>函数作为一个纯函数。</p><h2 id="932c" class="nf mh iq bd mi ng nh dn mm ni nj dp mq kz nk nl ms ld nm nn mu lh no np mw nq bi translated"><strong class="ak">纯函数对于render方法意味着什么？</strong></h2><p id="771b" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">保持函数的纯粹性意味着我们应该确保不调用<code class="fe lw lx ly lz b">setState</code>、对原生DOM元素的查询以及任何可以修改应用程序状态的东西。</p><p id="bb42" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">该函数不应该更新应用程序的状态。</p><p id="cdd4" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">更新组件状态的问题是，当状态更新时，它会触发另一个<code class="fe lw lx ly lz b">Render</code>循环，这在内部可以触发另一个<code class="fe lw lx ly lz b">Render</code>循环，并且这可以递归地继续下去。</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="d70b" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在上面的代码中，每次调用render函数时，它都会更新状态。一旦状态更新，组件就会被重新呈现。因此，更新状态会导致递归调用<code class="fe lw lx ly lz b">render</code>函数。</p><p id="8765" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">render函数应该保持<code class="fe lw lx ly lz b">Pure</code>，以确保组件以一致的方式运行和呈现。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="ed88" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated"><strong class="ak"> 13。为组件创建误差边界</strong></h1><p id="917a" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">您很容易遇到组件渲染导致错误的情况。</p><p id="f729" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在这种情况下，组件错误应该不会破坏整个应用程序。创建错误边界可以确保在特定组件出错的情况下应用程序不会中断。</p><p id="5aa7" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">错误边界是一个React组件，它捕捉子组件中任何地方的JavaScript错误。我们可以包含错误，记录错误消息，并为UI组件故障提供一个回退机制。</p><p id="4af1" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">误差边界基于高阶分量的概念。</p><p id="abc7" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有关高阶组件的更多详细信息，请参考以下内容:</p><div class="oq or gp gr os ot"><a href="https://levelup.gitconnected.com/introduction-to-reacts-higher-order-components-hocs-c42182fb634" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">React高阶组件(hoc)介绍</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">简单地说，高阶函数是要么以函数为参数，要么返回一个新的…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">levelup.gitconnected.com</p></div></div><div class="pc l"><div class="pj l pe pf pg pc ph nd ot"/></div></div></a></div><p id="c0fe" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">误差边界涉及一个高阶组件，包含这些方法:<code class="fe lw lx ly lz b">static getDerivedStateFromError()</code>和<code class="fe lw lx ly lz b">componentDidCatch()</code>。</p><p id="d923" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe lw lx ly lz b">static</code>函数用于指定回退机制，并从收到的错误中为组件导出新状态。</p><p id="aa0a" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe lw lx ly lz b">componentDidCatch</code>功能用于将错误信息记录到应用程序中。</p><p id="3fec" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有关错误边界，请参考下面的代码:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="122e" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当<code class="fe lw lx ly lz b">name</code>更新为<code class="fe lw lx ly lz b">Anshul</code>时，上面的代码抛出错误。</p><p id="1dff" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">组件<code class="fe lw lx ly lz b">ShowData</code>是嵌入在<code class="fe lw lx ly lz b">ErrorBoundaries</code>组件中的。</p><p id="b335" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，如果错误是从<code class="fe lw lx ly lz b">ShowData</code>函数抛出的，它会在父组件中被捕获，我们使用<code class="fe lw lx ly lz b">static getDerivedStateFromError</code>函数部署回退UI，并在<code class="fe lw lx ly lz b">componentDidCatch</code>生命周期事件中记录数据。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="cc36" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">14.组件的不可变数据结构</h1><p id="f949" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">React是以函数式编程为中心和焦点的。如果我们希望一个组件一致地工作，那么React组件中的状态和属性数据应该是不可变的。</p><p id="e3cf" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对象的突变会导致不一致的输出。</p><p id="0123" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们看看下面的代码就明白了:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><p id="6536" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以看到，在<code class="fe lw lx ly lz b">shouldComponentUpdate</code>函数中，我们指定，如果<code class="fe lw lx ly lz b">userInfo</code>的初始值不同于<code class="fe lw lx ly lz b">userInfo</code>的新值，组件应该被重新渲染。如果不是，它不应该重新呈现组件。</p><p id="4d6d" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有关更多详细信息，请参考以下链接:</p><div class="oq or gp gr os ot"><a href="https://blog.logrocket.com/immutability-in-react-ebe55253a1cc/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">React中的不变性:改变对象没有任何问题</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">当你开始使用React的时候，你学到的第一件事就是你不应该变异(修改)…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">blog.logrocket.com</p></div></div><div class="pc l"><div class="pk l pe pf pg pc ph nd ot"/></div></div></a></div></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="c550" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">15.使用唯一键进行迭代</h1><p id="453c" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">当我们需要呈现项目列表时，我们应该为项目添加一个键。</p><p id="2839" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">关键字有助于识别已更改、添加或删除的项目。键给元素一个稳定的标识。对于列表中的每个元素，键应该保持唯一。</p><p id="95f2" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果开发人员没有提供该元素的键，它会将一个<code class="fe lw lx ly lz b">index</code>作为默认键。在下面的代码中，我们默认不添加任何键，所以<code class="fe lw lx ly lz b">index</code>将被用作列表的默认键。</p><p id="98e1" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用<code class="fe lw lx ly lz b">index</code>作为一个键将解决维护组件的唯一身份的问题，因为<code class="fe lw lx ly lz b">index</code>将唯一地标识被呈现的组件。</p><p id="d891" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以在下面的场景中使用<code class="fe lw lx ly lz b">index</code>作为键:</p><ol class=""><li id="a7ce" class="ln lo iq ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">列表项是静态的，不随时间变化。</li><li id="9a16" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll ls lt lu lv bi translated"><code class="fe lw lx ly lz b">Items</code>没有唯一的id。</li><li id="8dfa" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll ls lt lu lv bi translated"><code class="fe lw lx ly lz b">List</code>不会被重新排序或过滤。</li><li id="f92c" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll ls lt lu lv bi translated">不会从顶部或中间添加或移除项目。</li></ol><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="nx kl l"/></div></figure><h2 id="f964" class="nf mh iq bd mi ng nh dn mm ni nj dp mq kz nk nl ms ld nm nn mu lh no np mw nq bi translated"><strong class="ak">向列表添加项目</strong></h2><p id="40df" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">使用<code class="fe lw lx ly lz b">index</code>作为键会增加出错的机会，并降低应用程序的性能。</p><p id="20a3" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">默认情况下，每当向列表中添加新元素时，React都会同时遍历新创建的列表和旧列表，并根据需要进行变异。</p><p id="6cdd" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当一个新元素被添加到列表的顶部时，包含索引作为键，所有已经存在的组件的索引被更新。</p><p id="d3d2" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">最初将<code class="fe lw lx ly lz b">key</code>作为<code class="fe lw lx ly lz b">1</code>的元素现在具有<code class="fe lw lx ly lz b">2</code>的<code class="fe lw lx ly lz b">key</code>值，因为该元素的索引已经更新。这导致React解释所有组件都已更改的事实，并对列表中的所有组件进行更新，从而导致性能下降。</p><p id="7c45" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上面的代码允许用户向列表顶部添加一个新项目。在顶部插入一个元素效果最差。</p><p id="1699" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一旦项目被添加到列表中，React就会比较原始列表和新列表。它发现顶部的元素发生了变化，试图用新列表中键值为<code class="fe lw lx ly lz b">1</code>的元素来评估旧列表中键值为<code class="fe lw lx ly lz b">1</code>的元素，观察到有变化，并最终重新呈现该元素。</p><p id="a3ad" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">对另一个组件也进行类似的比较。由于所有元素的索引都已更新，因此列表中的所有项目都将更新，从而导致性能下降。</p><p id="90a8" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，我们应该始终确保我们用作键的值始终代表一个可以唯一地标识列表中的元素的值。</p><p id="d839" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">所以，总结一下:</p><ul class=""><li id="e5c7" class="ln lo iq ks b kt ku kw kx kz lp ld lq lh lr ll mf lt lu lv bi translated"><code class="fe lw lx ly lz b">key</code>不仅仅是性能，更多的是身份(这反过来会带来更好的性能)。随机分配和改变值不是同一性。</li><li id="cb08" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">在不知道您的数据是如何建模的情况下，我们实际上无法提供键。如果你没有id，我建议你使用某种散列函数。</li><li id="a745" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">当我们使用数组时，我们已经有了内部键，但它们是数组中的索引。当你插入一个新元素时，那些键是错误的。</li></ul><p id="e5e3" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有关详细信息，请参考以下链接:</p><div class="oq or gp gr os ot"><a href="https://reactjs.org/docs/reconciliation.html#recursing-on-children" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">和解-反应</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">React提供了一个声明式API，因此您不必担心每次更新时会发生什么变化。这使得…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">reactjs.org</p></div></div><div class="pc l"><div class="pl l pe pf pg pc ph nd ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">索引作为键是一种反模式</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">我见过很多次开发人员在呈现列表时使用项目的索引作为键。</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pm l pe pf pg pc ph nd ot"/></div></div></a></div></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="f459" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">16。节流和去抖动事件</h1><p id="3075" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">节流和反跳可用于控制在指定时间内调用的事件处理程序的数量。</p><p id="58bd" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">事件处理程序是响应不同事件而调用的函数，比如鼠标点击和页面滚动。事件触发事件处理程序的速率不同。</p><h2 id="9905" class="nf mh iq bd mi ng nh dn mm ni nj dp mq kz nk nl ms ld nm nn mu lh no np mw nq bi translated">节流概念</h2><p id="0811" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">节流意味着延迟函数的执行。</p><p id="b3d0" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这些功能不会立即执行，在触发事件发生之前会增加几毫秒。</p><p id="83a2" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在页面滚动的情况下，我们不会过于频繁地触发滚动事件，而是将事件延迟一段时间，以便多个事件可以堆叠在一起。</p><p id="8532" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它确保该函数在特定的时间段内至少被调用一次。这意味着如果某个函数最近运行过，它将阻止该函数运行。它确保该功能以固定的时间间隔定期运行。</p><p id="78f7" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当我们拥有无限滚动并且当用户接近页面底部时必须获取数据时，我们可以使用throttling。</p><p id="874f" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果不使用限制，每向页面底部滚动一页都会触发多个事件，并且会触发多个网络调用，从而导致性能问题。</p><h2 id="6856" class="nf mh iq bd mi ng nh dn mm ni nj dp mq kz nk nl ms ld nm nn mu lh no np mw nq bi translated"><strong class="ak">去抖概念</strong></h2><p id="aaa3" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">去抖指的是忽略事件处理程序调用，直到调用停止一段时间。</p><p id="cadc" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">假设我们有一个<code class="fe lw lx ly lz b">debounce</code>时间为一秒的事件。一旦用户停止触发事件，该事件的事件处理程序将在一秒钟后被触发。</p><figure class="kf kg kh ki gt kj gh gi paragraph-image"><div class="gh gi pn"><img src="../Images/ed52a7b389addba38f06d090291afea2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1172/1*KE76UdL6nIxYbEEaJV8DaQ.gif"/></div></figure><p id="ecb8" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">典型的例子是当用户在自动完成搜索框中键入数据时。</p><p id="fdf5" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">一旦用户停止输入，AJAX查询就会从API获取数据。在每次按键时进行AJAX调用将导致对数据库的多次查询。</p><p id="a78f" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，我们对事件进行反跳，直到用户停止在流中输入更多数据，从而触发更少的网络调用，提高应用程序的性能。</p><p id="f8c3" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以使用第三方库来实现和使用节流和去抖动功能。一个这样的库是<a class="ae lm" href="https://www.npmjs.com/package/throttle-debounce" rel="noopener ugc nofollow" target="_blank"><em class="nw"/></a>。<strong class="ks ir"> </strong>参考下面的链接，使用本库实现节流。</p><div class="oq or gp gr os ot"><a href="https://www.npmjs.com/package/throttle-debounce" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">节流去抖</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">节流和去抖功能。</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">点击链接，了解如何在您的应用程序中使用该特性。www.npmjs.com</p></div></div><div class="pc l"><div class="po l pe pf pg pc ph nd ot"/></div></div></a></div></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="8dcb" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">17.将cdn用于外部资源</h1><p id="393a" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">谷歌、亚马逊、微软和许多其他公司提供了许多内容交付网络。</p><p id="1bed" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这些cdn是可以在您的应用程序中使用的外部资源。我们甚至可以创建私人cdn，托管我们的文件和资源。</p><p id="2f37" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">出于以下原因，使用cdn是有益的:</p><h2 id="0334" class="nf mh iq bd mi ng nh dn mm ni nj dp mq kz nk nl ms ld nm nn mu lh no np mw nq bi translated"><strong class="ak"> 1。不同的域</strong></h2><p id="13e7" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">浏览器将单个域的并发连接限制在特定数量，这可能因浏览器而异。</p><p id="a5e6" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">让我们假设允许的并发连接数是10。如果要从一个域中检索11个资源，那么在同一时刻只能同时检索10个，使得其中一个请求等待另一个请求完成。</p><p id="d1d7" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">cdn托管在不同的域/服务器上。因此，资源文件可以分布在不同的域中，以便在同一时刻满足多个请求。</p><h2 id="f050" class="nf mh iq bd mi ng nh dn mm ni nj dp mq kz nk nl ms ld nm nn mu lh no np mw nq bi translated"><strong class="ak"> 2。文件可能已被缓存</strong></h2><p id="db4c" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">多个网站使用这些cdn，因此很有可能您试图访问的资源已经缓存在浏览器中。</p><p id="ff32" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，应用程序将访问文件的已缓存版本，这减少了网络调用以及脚本和文件执行的延迟。这增加了应用程序的性能。</p><h2 id="aa24" class="nf mh iq bd mi ng nh dn mm ni nj dp mq kz nk nl ms ld nm nn mu lh no np mw nq bi translated"><strong class="ak"> 3。高容量基础设施</strong></h2><p id="c9ed" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">这些cdn由大公司托管，因此可用的基础设施种类非常多。他们将数据中心分布在全球各地。</p><p id="0066" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当向CDN发出请求时，会通过最近的可用数据中心来满足这些请求，从而减少延迟。</p><p id="1a30" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这些公司对服务器进行负载平衡，以确保请求到达最近的服务器，并减少网络延迟，使应用程序性能更好。</p><p id="9ff1" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这些是cdn提供的一些好处。如果安全性是一个大问题，使用CDN，或者考虑创建私有CDN。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="9676" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated"><strong class="ak"> 18。CSS动画代替JavaScript动画</strong></h1><p id="52d0" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">如今有多种方式来处理动画。</p><p id="9986" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在HTML5和CSS3之前，动画曾经是JavaScript的领域，但是随着HTML5和CSS3的引入，提供动画的责任开始重叠。动画甚至可以由CSS3处理。</p><p id="10f8" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">由于责任重叠，我们现在可以制定一些规则:</p><ul class=""><li id="489e" class="ln lo iq ks b kt ku kw kx kz lp ld lq lh lr ll mf lt lu lv bi translated">如果CSS比JavaScript更有优势，那就去做吧。</li><li id="0fd5" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll mf lt lu lv bi translated">如果HTML比JavaScript能实现什么，那就去做吧。</li></ul><p id="5af6" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">以下是证明这一点的一些理由:</p><ol class=""><li id="3f06" class="ln lo iq ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">残破的CSS规则和样式不会导致残破网页的错误，JavaScript就不是这样。</li><li id="6a02" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll ls lt lu lv bi translated">CSS很容易解释，因为它是声明性的。我们可以并行创建样式的内存表示，并且可以将样式属性的计算推迟到元素绘制完成之后。</li><li id="0c32" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll ls lt lu lv bi translated">为动画加载JavaScript库的成本相对较高，会消耗网络带宽和计算时间。</li><li id="fd5b" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll ls lt lu lv bi translated">即使JavaScript可以提供比CSS更多的优化，即使优化的JavaScript代码也可能锁定UI并导致web浏览器失败。</li></ol><p id="6df0" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在您的场景中，还有其他参数来决定哪一个更有性能。</p><p id="4712" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有关更多详细信息，您可以参考以下内容:</p><div class="oq or gp gr os ot"><a href="https://developers.google.com/web/fundamentals/design-and-ux/animations/css-vs-javascript" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">CSS与JavaScript动画|网络基础|谷歌开发者</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">你可以用CSS或者JavaScript制作动画。你应该使用哪一种，为什么？</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">developers.google.com</p></div></div><div class="pc l"><div class="pp l pe pf pg pc ph nd ot"/></div></div></a></div></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="c30b" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">19.在Web服务器上启用gzip压缩</h1><p id="8404" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">压缩是节省网络带宽和提高应用程序速度的最简单方法。</p><p id="e6c1" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以启用网络资源将它们压缩到较小的大小。<a class="ae lm" href="https://www.gzip.org/" rel="noopener ugc nofollow" target="_blank"> Gzip </a>是一种能够快速压缩和解压文件的数据压缩算法。</p><p id="3089" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它可以压缩几乎任何类型的文件，如图像、文本、JavaScript文件、样式文件等。在web页面上，gzip减少了传输到客户端的数据量。</p><p id="4ff3" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当web服务器收到请求时，它会提取文件数据并查找<code class="fe lw lx ly lz b">Accept-Encoding</code>头，以确定如何对应用程序进行编码。</p><p id="cbe7" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果服务器支持使用gzip压缩，资源将被压缩并通过网络发送。每个资源的压缩副本都添加了<code class="fe lw lx ly lz b">Content-Encoding</code>头，指定资源使用gzip编码。</p><p id="5dfe" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">然后，浏览器在将内容呈现给用户之前，将其解压缩为原始的未压缩版本。</p><p id="8f99" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">尽管gzip压缩是有代价的，但是文件的压缩和解压缩会触发CPU密集型任务。即便如此，还是建议对网页使用gzip压缩。</p><div class="oq or gp gr os ot"><a href="https://royal.pingdom.com/can-gzip-compression-really-improve-web-performance/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">Gzip压缩真的能提高Web性能吗？</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">我们运行了三种不同的配置，看看Gzip压缩或未压缩的网站是否有最好的页面速度。阅读…</h3></div></div><div class="pc l"><div class="pq l pe pf pg pc ph nd ot"/></div></div></a></div></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="d2b1" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated"><strong class="ak"> 20。使用网络工作者处理CPU扩展任务</strong></h1><p id="d1b0" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">JavaScript是处理所有同步执行的单线程应用程序。</p><p id="e542" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当网页被渲染时，它需要执行多个任务:</p><p id="29e3" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">处理UI交互、处理响应数据、操纵DOM元素、启用动画等。所有这些任务都由一个线程负责。</p><p id="eb11" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Workers可以被看作是减少主线程执行负载的一个选项。</p><p id="ab5f" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">工作线程是后台线程，可以让用户在不中断主线程的情况下执行多个脚本和JavaScript。</p><p id="a09c" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">每当有需要大量CPU资源的长时间执行的任务时，这些逻辑块可以使用workers在单独的线程上执行。</p><p id="4984" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它们在隔离的环境中执行，并且可以使用进程间线程通信与主线程进行交互。同时，主线程可以处理渲染和DOM操作任务。</p><p id="6698" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">有关更多详细示例，请查看以下URL:</p><div class="oq or gp gr os ot"><a href="https://medium.com/prolanceer/optimizing-react-app-performance-using-web-workers-79266afd4a7" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">使用Web Workers优化React应用程序性能</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">网络是一个古怪的平台，虽然非常吸引人，但在压力下会导致严重的心痛。</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pr l pe pf pg pc ph nd ot"/></div></div></a></div></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="2809" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">21.React组件的服务器端呈现</h1><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="ps kl l"/></div></figure><p id="411d" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">服务器端呈现是减少初始页面加载延迟的方法之一。</p><p id="3c3d" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们可以让web页面从服务器端加载初始页面，而不是在客户端呈现。它大大提高了网页搜索引擎的优化。</p><p id="be98" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">服务器端呈现是指显示的第一个组件的内容是从服务器本身发送的，而不是在浏览器级别进行处理。更多的页面直接从客户端加载。</p><p id="4c0c" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">因此，它为我们提供了初始服务器端内容呈现和客户端部分页面加载的能力，以满足未来的请求。</p><p id="cd40" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">以下是其他好处:</p><ol class=""><li id="5ba1" class="ln lo iq ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated">性能:包含数据的初始页面内容是从服务器本身加载的，因此我们不需要添加加载器和微调器，并且在浏览器上加载初始页面后等待初始组件的加载。</li><li id="c0ac" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll ls lt lu lv bi translated">SEO优化:爬虫在应用程序初始加载时寻找页面内容。当您处理客户端呈现时，初始网页不包含所需的组件。一旦加载了React脚本和其他相关文件，这些组件就会呈现在web页面上。</li></ol><p id="6d54" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">服务器端渲染的一个选项是使用第三方库，比如<a class="ae lm" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>。详情可在以下网站上找到:</p><div class="oq or gp gr os ot"><a href="https://nextjs.org/" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">next . js-React框架</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">生产级反应可扩展的应用。世界领先的公司使用Next.js构建服务器渲染的…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">nextjs.org</p></div></div><div class="pc l"><div class="pt l pe pf pg pc ph nd ot"/></div></div></a></div><p id="a810" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">您还可以在下面找到一个关于服务器端渲染的示例项目。要运行该应用程序，只需从项目存储库中执行以下步骤:</p><ol class=""><li id="167d" class="ln lo iq ks b kt ku kw kx kz lp ld lq lh lr ll ls lt lu lv bi translated"><code class="fe lw lx ly lz b">npm install</code></li><li id="ab95" class="ln lo iq ks b kt ma kw mb kz mc ld md lh me ll ls lt lu lv bi translated"><code class="fe lw lx ly lz b">npm start</code></li></ol><div class="oq or gp gr os ot"><a href="https://github.com/Mayankgupta688/reactServerRendering" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">mayankgupta 688/reactServerRendering</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">在GitHub上创建一个帐户，为mayankgupta 688/reactserverendering开发做出贡献。</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="pu l pe pf pg pc ph nd ot"/></div></div></a></div><p id="f6a8" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">应用程序的“pages”文件夹中的文件是可以使用服务器端呈现加载的初始URL。</p><p id="e007" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如需进一步了解，您可以联系我。</p><h1 id="50f6" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">22.使用React挂钩</h1><p id="073d" class="pw-post-body-paragraph kq kr iq ks b kt nr jr kv kw ns ju ky kz nt lb lc ld nu lf lg lh nv lj lk ll ij bi translated">React挂钩是React 16.8版本的新增功能。它基于函数式编程。React现在可以使用函数式编程来创建状态组件。React挂钩的好处将在单独的文章中介绍:</p><figure class="kf kg kh ki gt kj"><div class="bz fp l di"><div class="ny kl l"/></div><figcaption class="km kn gj gh gi ko kp bd b be z dk"><a class="ae lm" href="https://www.youtube.com/watch?v=X94LfGK7I9Y" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=X94LfGK7I9Y</a></figcaption></figure><div class="oq or gp gr os ot"><a href="https://medium.com/better-programming/introduction-to-react-hooks-e0102c038bf1" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">React挂钩简介</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">如何在React中使用状态挂钩</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pv l pe pf pg pc ph nd ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://medium.com/better-programming/https-medium-com-mayank-gupta-6-88-react-useeffect-hooks-in-action-2da971cfe83f" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">反应使用效果挂钩</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">关于React的使用效果挂钩，你需要知道的是</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="pw l pe pf pg pc ph nd ot"/></div></div></a></div><div class="oq or gp gr os ot"><a href="https://medium.com/better-programming/usememo-hook-in-react-d8d0eda6598a" rel="noopener follow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">React中的useMemo挂钩</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">如何用useMemo钩子优化性能</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">medium.com</p></div></div><div class="pc l"><div class="px l pe pf pg pc ph nd ot"/></div></div></a></div></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><h1 id="ccf6" class="mg mh iq bd mi mj og ml mm mn oh mp mq jw oi jx ms jz oj ka mu kc ok kd mw mx bi translated">参考</h1><ul class=""><li id="7539" class="ln lo iq ks b kt nr kw ns kz ol ld om lh on ll mf lt lu lv bi translated">示例代码的GitHub存储库:</li></ul><div class="oq or gp gr os ot"><a href="https://github.com/Mayankgupta688/react-demos" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">Mayankgupta688/react-demos</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">在GitHub上创建一个帐户，为Mayankgupta688/react-demos的开发做出贡献。</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">github.com</p></div></div><div class="pc l"><div class="py l pe pf pg pc ph nd ot"/></div></div></a></div><ul class=""><li id="5884" class="ln lo iq ks b kt ku kw kx kz lp ld lq lh lr ll mf lt lu lv bi translated">React优化技术:</li></ul><div class="oq or gp gr os ot"><a href="https://reactjs.org/docs/optimizing-performance.html" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">优化性能-反应</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">在内部，React使用了几种巧妙的技术来最小化更新…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">reactjs.org</p></div></div><div class="pc l"><div class="pz l pe pf pg pc ph nd ot"/></div></div></a></div><p id="b28b" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">谢谢你的时间。</p><h2 id="071d" class="nf mh iq bd mi ng nh dn mm ni nj dp mq kz nk nl ms ld nm nn mu lh no np mw nq bi translated">进一步阅读</h2><div class="oq or gp gr os ot"><a rel="noopener  ugc nofollow" target="_blank" href="/5-tools-practices-to-help-you-develop-faster-in-react-b884c1b20fc2"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd ir gy z fp oy fr fs oz fu fw ip bi translated">帮助您在React中更快开发的5种工具和实践</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">React工具、技巧和最佳实践将帮助您更快地构建应用</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="pc l"><div class="qa l pe pf pg pc ph nd ot"/></div></div></a></div></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="ec27" class="pw-post-body-paragraph kq kr iq ks b kt ku jr kv kw kx ju ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="nw">更多内容请看</em><a class="ae lm" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ks ir"><em class="nw">plain English . io</em></strong></a><em class="nw">。报名参加我们的</em> <a class="ae lm" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ks ir"> <em class="nw">免费周报</em> </strong> </a> <em class="nw">。关注我们关于</em><a class="ae lm" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="ks ir"><em class="nw">Twitter</em></strong></a><a class="ae lm" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ks ir"><em class="nw">LinkedIn</em></strong></a><em class="nw"/><a class="ae lm" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ks ir"><em class="nw">YouTube</em></strong></a><em class="nw"/><a class="ae lm" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ks ir"><em class="nw">不和</em> </strong> </a> <em class="nw">。</em></p></div></div>    
</body>
</html>