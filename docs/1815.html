<html>
<head>
<title>Understanding Debouncing &amp;&amp; Throttling</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">了解去抖动和节流</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-debouncing-throttling-2a0a5e9cc74a?source=collection_archive---------1-----------------------#2020-04-26">https://javascript.plainenglish.io/understanding-debouncing-throttling-2a0a5e9cc74a?source=collection_archive---------1-----------------------#2020-04-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8706" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">作为开发人员，您应该知道的两项技术</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/50125802296fed52a302910fec8a32f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Nj8IbgAwryFgylQ1c9C6SQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A woman with a laptop</figcaption></figure><p id="22ee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">去抖和节流是两种控制函数执行次数的方法。当我们将函数附加到DOM的事件时，函数的去抖或节流版本特别有用，因为在这些场景中，我们可能会在不必要的时候调用函数。</p><h2 id="c7a8" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">去抖动</h2><p id="42e2" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">去抖模式让我们控制连续触发的事件，如果两个事件之间的间隔小于一定的时间，它会完全忽略第一个事件。</p><p id="de08" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">重复这个过程，直到它得到高于期望的最小间隔的暂停。一旦发生，将只执行暂停前事件的最后一次发生，而忽略之前的所有事件。</p><p id="175e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简而言之:去抖动使得一个函数在没有被调用的情况下，直到一个特定的时间集合结束后才能被再次调用。示例:仅当超过1000毫秒未调用函数时，才执行该函数。</p><p id="a5a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一个网站上搜索栏的例子。每当我们在搜索栏中键入一些内容时，我们都会进行一次API调用，根据在搜索栏中键入的字母从函数服务器中获取数据:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="14cd" class="lr ls iq mq b gy mu mv l mw mx">&lt;html&gt;<br/>    &lt;body&gt;<br/>        &lt;input  type="text"  <br/>        id="searchId" /&gt;<br/>    &lt;/body&gt;    <br/>    &lt;script src="debounce.js"&gt; &lt;/script&gt;    <br/>    &lt;script src="search.js"&gt; &lt;/script&gt;<br/>&lt;/html&gt;</span></pre><p id="1478" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们的<strong class="kx ir"> makeApiFetch </strong>函数在每次用户在文本框中键入时被调用，并且后端调用被完成以恢复数据，正如您所猜测的，这在后端和UX级别都是低效的。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="697e" class="lr ls iq mq b gy mu mv l mw mx">//search.js<br/>let searchIdDom =  <br/> document.getElementById('searchId');</span><span id="9329" class="lr ls iq mq b gy my mv l mw mx">//1.<br/>const makeApiFetch () = &gt; {<br/>   ...<br/>}</span><span id="3e44" class="lr ls iq mq b gy my mv l mw mx">//2.<br/>searchIdDom.addEventListener('input', () =&gt; {<br/>   makeApiFetch();<br/>}</span></pre><p id="6cd5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">1.对服务器执行昂贵的搜索并获取结果。</p><p id="fbf5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.在我们的文本框搜索栏上添加一个事件监听器</p><p id="9417" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了解决这个问题，我们将创建一个函数，允许我们控制连续触发的事件，并且只执行最后一个事件:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c4cf" class="lr ls iq mq b gy mu mv l mw mx">//debounce.js<br/>const debounce = (callback, delay) =&gt; {<br/>  let timeout = null<br/>  return (...args) =&gt; {<br/>    const next = () =&gt; <br/>    callback(...args);<br/>    clearTimeout(timeout);<br/>    //1.   <br/>    timeout = setTimeout(next, delay)<br/>  }<br/>}</span></pre><ol class=""><li id="f700" class="mz na iq kx b ky kz lb lc le nb li nc lm nd lq ne nf ng nh bi translated">我们延迟回调的执行，直到延迟时间过去。</li></ol><p id="6b5f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们没有在addEventListener中直接调用makeApiFetch函数，而是用我们的wrap <strong class="kx ir">去抖</strong>函数调用它:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="4d58" class="lr ls iq mq b gy mu mv l mw mx">searchIdDom.addEventListener('input', () =&gt; {<br/>   //1.<br/>   <strong class="mq ir">debounce</strong>(makeApiFetch(), 1000);<br/>}</span></pre><p id="5e21" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，makeApiFetch函数只有在1000毫秒的时间间隔过后才会被调用。</p><h2 id="6f8a" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">一些典型的案例使用</h2><ul class=""><li id="75cf" class="mz na iq kx b ky mk lb ml le ni li nj lm nk lq nl nf ng nh bi translated">去反跳输入类型事件处理程序。(就像我们的搜索输入示例一样)</li><li id="5c9d" class="mz na iq kx b ky nm lb nn le no li np lm nq lq nl nf ng nh bi translated">解除滚动事件处理程序的反跳。</li></ul><h2 id="df79" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">节流</h2><p id="406b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">节流模式限制了一个函数可以被调用的最大次数。此方法通常用于控制调整大小、滚动和鼠标相关的事件。</p><p id="c8cd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">简而言之:节流强制规定了一个函数可以被调用的最大次数。示例:每1000 毫秒最多在<strong class="kx ir">执行一次该功能。</strong></p><p id="46ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">节流可以通过多种方式实现。我们可以通过单位时间内由大量事件触发的事件数量，或者通过两个处理的事件之间的延迟来调节。这里我们将实现最后一个选项，因为这是最简单的方法。</p><p id="1360" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，当函数第一次被调用时，我们设置“时间”变量。每次调用返回的函数时，它都会检查等待时间是否已过，如果是，它会触发回调并重置时间:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2647" class="lr ls iq mq b gy mu mv l mw mx">function throttle(callback, wait) {<br/> var time = Date.now();<br/> return function() {<br/>  if ((time + wait - Date.now()) &lt; 0) {<br/>    callback();<br/>    time = Date.now();<br/>  }<br/> }<br/>}</span></pre><p id="5f0b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用它:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b249" class="lr ls iq mq b gy mu mv l mw mx">const myHandler = <br/> (event) =&gt; {...do some stuf...}</span><span id="eadc" class="lr ls iq mq b gy my mv l mw mx">//1.<br/>const myThrottleHandler =<br/>  <strong class="mq ir">throttled</strong>(1000, myHandler);</span><span id="89e6" class="lr ls iq mq b gy my mv l mw mx">//2.<br/>myMouseDomElement.<br/> addEventListener("mousemove", myThrottleHandler);</span></pre><p id="ab77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">1.用我们的<strong class="kx ir">节流的</strong>函数包装“myHandler”函数。</p><p id="8761" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.在myMouseDomElement上添加一个事件侦听器。(鼠标dom元素)</p><h2 id="b072" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">一些典型的案例使用</h2><ul class=""><li id="5c0b" class="mz na iq kx b ky mk lb ml le ni li nj lm nk lq nl nf ng nh bi translated">抑制API调用。</li><li id="bb90" class="mz na iq kx b ky nm lb nn le no li np lm nq lq nl nf ng nh bi translated">抑制按钮点击，这样我们就不能垃圾点击。</li><li id="909c" class="mz na iq kx b ky nm lb nn le no li np lm nq lq nl nf ng nh bi translated">抑制触摸/移动鼠标事件处理程序。</li></ul><h2 id="ab75" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated">结论</h2><p id="a13b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在本文中，我们已经看到了去抖和节流模式的两个简单实现，虽然我们可以使用各种库中包含的实现，如<a class="ae nr" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank"> lodash.js </a>或<a class="ae nr" href="https://jquery.com/" rel="noopener ugc nofollow" target="_blank"> Jquery </a>去抖和节流是我们作为开发人员必须知道的两个简单技术。</p><p id="a7fd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">非常感谢你阅读这篇文章。我希望它对你有用！</p><h2 id="4933" class="lr ls iq bd lt lu lv dn lw lx ly dp lz le ma mb mc li md me mf lm mg mh mi mj bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="5af0" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae nr" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kx ir">AI in Plain English</strong></a><a class="ae nr" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kx ir">UX in Plain English</strong></a><a class="ae nr" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kx ir">Python in Plain English</strong></a><strong class="kx ir"/>——谢谢，继续学习！</p><p id="1e8d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae nr" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">submissions @ plain English . io</strong></a><strong class="kx ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>