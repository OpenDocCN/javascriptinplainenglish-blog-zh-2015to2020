<html>
<head>
<title>Build Reusable React Components with styled-components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用样式化组件构建可重用的React组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-building-reusable-components-8375b20c0d7a?source=collection_archive---------3-----------------------#2020-11-02">https://javascript.plainenglish.io/react-building-reusable-components-8375b20c0d7a?source=collection_archive---------3-----------------------#2020-11-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9d400deaa4ec3ba5939f8900d35f95fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fXJ8LDLTrbIHHnbQpe4i8w.png"/></div></div></figure><p id="1dc4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当我开始开发我的第一个大型应用程序时，我第一次使用了<code class="fe kt ku kv kw b">styled-components</code>，我真的很喜欢它的工作方式。它允许您构建可重用的组件，当您构建不同的布局时，这些组件易于扩展并适应新的情况。</p><p id="d32d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我将介绍一些你可以使用<code class="fe kt ku kv kw b">styled-components</code>来创建可重用组件的方法，这些组件抽象了CSS和HTML，创建了你自己的定制组件库。</p></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="bcab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">styled-components</code>的语法乍一看可能有点奇怪。您可以创建任何类型的HTML元素及其CSS样式，如下所示:</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="e9a2" class="lm ln in kw b gy lo lp l lq lr">const Container = styled.div`<br/>  display: flex;<br/>`</span></pre><p id="d46a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">CSS包含在紧跟在HTML元素的键名后面的反勾号中。一开始感觉很奇怪，但我很快就习惯了，因为这种语法真的很方便。您不必在样式表和组件之间切换。所有东西都在同一个文件中声明。</p><p id="ca7c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的一个危险是你的文件可能很快变得混乱，因为组件的不同部分有它们自己的风格。这是创建简单的、可重用的组件的好理由，您可以将这些组件拼凑成不同的布局。</p><p id="eadf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">构建简单的、可重用的组件的另一个很好的理由是，随着应用程序的增长，如果所有的东西都源自相同的组件，那么对布局和设计进行微小的调整会变得更快。</p><h1 id="35ad" class="ls ln in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">柔性框布局</h1><p id="9240" class="pw-post-body-paragraph jv jw in jx b jy mp ka kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks ig bi translated">我要构建的第一个组件是一个基本布局，它利用flex box来提高响应能力。首先，我们需要一个flex容器来放置内容:</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="9252" class="lm ln in kw b gy lo lp l lq lr">const Container = styled.div`<br/>  display: flex;<br/>  justify-content: center;<br/>  padding-top: 5rem;<br/>`</span></pre><p id="62cb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后是我们的响应flex box，其中包含媒体查询:</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="c431" class="lm ln in kw b gy lo lp l lq lr">const Flex = styled.div`<br/>  display: flex;<br/>  flex-direction: column;</span><span id="6c01" class="lm ln in kw b gy mu lp l lq lr">  @media(min-width: 768px){<br/>    flex-direction: row;<br/>  }<br/>`</span></pre><p id="00ab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将这些放在一起，我们得到了一个<code class="fe kt ku kv kw b">Layout</code>组件:</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="84e8" class="lm ln in kw b gy lo lp l lq lr">const Layout ({ children, className }) =&gt; (<br/>  &lt;Container className={className}&gt;<br/>    &lt;Flex&gt;<br/>      {children}<br/>    &lt;/Flex&gt;<br/>  &lt;/Container&gt;<br/>)</span></pre></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="0782" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我还构建了一个在<code class="fe kt ku kv kw b">Layout</code>内部使用的<code class="fe kt ku kv kw b">Column</code>组件。这里，我使用了<code class="fe kt ku kv kw b">styled-components</code>的一个很酷的特性，你可以在CSS字符串中使用变量来控制道具的样式:</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="2ed2" class="lm ln in kw b gy lo lp l lq lr">const Container = styled.div`<br/>  display: flex;<br/>  flex-direction: column;<br/>  align-items: ${({ centerAlign }) =&gt; centerAlign ? 'center' : 'flex-start'};<br/>  justify-content: ${({ centerJustify }) =&gt; centerJustify ? 'center' : 'flex-start'}<br/>`</span></pre><p id="656b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这在纯黑色文本中可能很难阅读，但我正在做的是使用<code class="fe kt ku kv kw b">${}</code>将一个函数插入CSS代码字符串。该功能是通过提供给<code class="fe kt ku kv kw b">Container</code>的道具实现的。然后，我编写了三元语句，根据props值返回正确的CSS。</p><p id="482e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最终的<code class="fe kt ku kv kw b">Column</code>组件如下所示:</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="3299" class="lm ln in kw b gy lo lp l lq lr">const Column = ({<br/>  children,<br/>  className,<br/>  centerAlign,<br/>  centerJustify<br/>}) =&gt; (<br/>  &lt;Container<br/>    className={className}<br/>    centerAlign={centerAlign}<br/>    centerJustify={centerJustify}<br/>  &gt;<br/>    {children}<br/>  &lt;/Container&gt;<br/>)</span></pre></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="4871" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我可以一起使用<code class="fe kt ku kv kw b">Layout</code>和<code class="fe kt ku kv kw b">Column</code>组件来构建这样的响应性布局:</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="005b" class="lm ln in kw b gy lo lp l lq lr">const Page = () =&gt; (<br/>  &lt;Layout&gt;<br/>    &lt;Column&gt;<br/>      // child components<br/>    &lt;/Column&gt;<br/>    &lt;Column&gt;<br/>      // child components<br/>    &lt;/Column&gt;<br/>  &lt;/Layout&gt;<br/>)</span></pre><h1 id="34f7" class="ls ln in bd lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo bi translated">表单元素</h1><p id="244d" class="pw-post-body-paragraph jv jw in jx b jy mp ka kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks ig bi translated">现在我想构建一些表单元素。我将从文本输入开始:</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="59e5" class="lm ln in kw b gy lo lp l lq lr">const Input = styled.input`<br/>  font-size: 1.5rem<br/>`</span></pre><p id="27f5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后是一个标签:</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="4a91" class="lm ln in kw b gy lo lp l lq lr">const Label = styled.label`<br/>  margin-bottom: 1rem;<br/>`</span></pre><p id="e53d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，一个容器来装它们:</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="4117" class="lm ln in kw b gy lo lp l lq lr">const Container = styled.div`<br/>  display: flex;<br/>  flex-direction: column;<br/>  max-width: 500px;<br/>`</span></pre><p id="99e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后将它们放在一起，创建一个带有可选标签的可重用输入元素:</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="ff02" class="lm ln in kw b gy lo lp l lq lr">const TextInput = ({ className, label, onChange, value}) =&gt; (<br/>  &lt;Container className={className}&gt;<br/>    {label &amp;&amp; &lt;Label&gt;{label}&lt;/Label&gt;}<br/>    &lt;Input<br/>      type='text'<br/>      onChange={onChange}<br/>      value={value}<br/>      name={label}<br/>    /&gt;<br/>  &lt;/Container&gt;<br/>)</span></pre></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="c233" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我要构建的最后一个组件是一个按钮。我喜欢构建一个基本的按钮组件，因为浏览器倾向于给按钮添加一些奇怪的默认样式，每个按钮都需要覆盖这些样式。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="0729" class="lm ln in kw b gy lo lp l lq lr">const Container = styled.button`<br/>  border: none;<br/>  background-color: $(({ disabled }) =&gt; disabled ? 'gray' : 'red'};<br/>  padding: 0.5rem;<br/>  width: ${({ fullWidth }) =&gt; fullWidth ? '100%' : '300px'};</span><span id="822a" class="lm ln in kw b gy mu lp l lq lr">  &amp;:hover {<br/>    cursor: pointer;<br/>    opacity: 0.9;<br/>  }<br/>`</span></pre><p id="c997" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我改变了按钮禁用时的颜色。我还添加了一个选项，使按钮的宽度等于其容器的宽度。否则，默认宽度为300像素。</p><p id="e349" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我可以保留<code class="fe kt ku kv kw b">&lt;button&gt;</code>元素的语义特性，同时完全定制它。</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="b05b" class="lm ln in kw b gy lo lp l lq lr">const Button = ({ children, className, onClick, disabled }) =&gt; (<br/>  &lt;Container<br/>    className={className}<br/>    onClick={onClick}<br/>    disabled={disabled}<br/>  &gt;<br/>    {children}<br/>  &lt;/Container&gt;<br/>)</span></pre></div><div class="ab cl kx ky hr kz" role="separator"><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc ld"/><span class="la bw bk lb lc"/></div><div class="ig ih ii ij ik"><p id="ce17" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以上是用<code class="fe kt ku kv kw b">styled-components</code>构建可重用组件的简要介绍。你会注意到我在每个组件中都包含了一个<code class="fe kt ku kv kw b">className</code>道具。这是为了允许使用<code class="fe kt ku kv kw b">styled</code>对象作为功能进行进一步定制:</p><pre class="le lf lg lh gt li kw lj lk aw ll bi"><span id="37e2" class="lm ln in kw b gy lo lp l lq lr">const CustomizedButton = styled(Button)`<br/>  // some CSS<br/>`</span></pre><p id="22ac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你需要增加更大的页边空白来在页面上留出空间，这很有帮助。</p><h2 id="5599" class="lm ln in bd lt mv mw dn lx mx my dp mb kg mz na mf kk nb nc mj ko nd ne mn nf bi translated">进一步阅读</h2><div class="ng nh gp gr ni nj"><a href="https://bit.cloud/blog/how-to-reuse-react-components-across-your-projects-l4pz83f4" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd io gy z fp no fr fs np fu fw im bi translated">如何在项目中重用React组件</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">最后，您完成了为应用程序中的表单创建一个奇妙的输入字段的任务。你对……很满意</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">比特云</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jt nj"/></div></div></a></div><p id="696a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ny">更多内容看</em> <a class="ae nz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ny">说白了就是</em> </strong> </a> <em class="ny">。报名参加我们的</em> <a class="ae nz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ny">免费周报</em> </strong> </a> <em class="ny">。关注我们关于</em> <a class="ae nz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ny">推特</em> </strong> </a>，<a class="ae nz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ny">领英</em> </strong> </a> <strong class="jx io"> <em class="ny">，</em></strong><a class="ae nz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ny">YouTube</em></strong></a><strong class="jx io"><em class="ny">，以及</em></strong><em class="ny"/><a class="ae nz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jx io"><em class="ny">不和</em> </strong> </a>  <em class="ny">对成长黑客感兴趣？检查出</em> <a class="ae nz" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io"> <em class="ny">电路</em> </strong> </a> <strong class="jx io"> <em class="ny">。</em>T71】</strong></p></div></div>    
</body>
</html>