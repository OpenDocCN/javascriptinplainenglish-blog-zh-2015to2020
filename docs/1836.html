<html>
<head>
<title>JavaScript Tips — Good Constructs to Use</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript技巧——好用的构造</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-tips-good-constructs-to-use-896937f9f5c9?source=collection_archive---------10-----------------------#2020-04-27">https://javascript.plainenglish.io/javascript-tips-good-constructs-to-use-896937f9f5c9?source=collection_archive---------10-----------------------#2020-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/429d635ab72492e11c94046e33332ad1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NNOpxMYmMrwU0Ssb"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@blakewisz?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Blake Wisz</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4209" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种非常灵活的语言。JavaScript中有很多东西我们可能不应该写。不好的旧结构与更好的新结构共存。</p><p id="24ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看JavaScript中一些我们应该经常使用的好的部分。</p><h1 id="8362" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用var，使用let或const</h1><p id="af3f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">var</code>是声明变量的过时关键字。相反，我们应该使用<code class="fe me mf mg mh b">let</code>和<code class="fe me mf mg mh b">const</code>。<code class="fe me mf mg mh b">let</code>和<code class="fe me mf mg mh b">const</code>都是块范围的，所以只要它们在一个块中，我们就可以不用担心冲突范围。</p><p id="4dec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下内容:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b0d7" class="mq lc iq mh b gy mr ms l mt mu">let x = 1;<br/>const y = 2;</span></pre><p id="56ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0a24" class="mq lc iq mh b gy mr ms l mt mu">var x = 1;<br/>var y = 2;</span></pre><p id="2cc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">const</code>还有一个好处就是我们不能给它重新赋值。然而，它并没有使对象成为不可变的。</p><h1 id="2e79" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用<code class="fe me mf mg mh b">=== or Object.is </code>代替<code class="fe me mf mg mh b">==</code></h1><p id="f981" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">==</code>节省了一个打字的字符，但是和<code class="fe me mf mg mh b">==</code>比较的规则比较复杂，很难记住。它还会产生许多意想不到的结果。所以，我们不应该用<code class="fe me mf mg mh b">==</code>。</p><p id="0010" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，以下两者都返回<code class="fe me mf mg mh b">true</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="74cd" class="mq lc iq mh b gy mr ms l mt mu">[10]  == 10<br/>'10' == 10</span></pre><p id="262f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可能不希望这样。因此，我们应该改为编写以下内容:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ac35" class="mq lc iq mh b gy mr ms l mt mu">[10] === 10<br/>'10' === 10</span></pre><p id="223a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后它们都返回<code class="fe me mf mg mh b">false</code>，因为两个操作数的数据类型和值必须匹配，以便<code class="fe me mf mg mh b">===</code>认为它们相同。但是，<code class="fe me mf mg mh b">NaN === NaN</code>返回<code class="fe me mf mg mh b">false</code>。</p><p id="b157" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检查<code class="fe me mf mg mh b">NaN</code>，我们应该使用<code class="fe me mf mg mh b">isNaN</code>函数，该函数试图将其参数转换为一个数字并进行检查。因此，<code class="fe me mf mg mh b">isNaN(‘NaN’) </code>和<code class="fe me mf mg mh b">isNaN(NaN)</code>都返回<code class="fe me mf mg mh b">true</code>。</p><p id="8de0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有<code class="fe me mf mg mh b">Number.isNaN</code>函数，它在检查时不做任何转换。因此，<code class="fe me mf mg mh b">Number.isNaN(‘NaN’)</code>返回<code class="fe me mf mg mh b">false</code>，<code class="fe me mf mg mh b">Number.isNaN(NaN)</code>返回<code class="fe me mf mg mh b">true</code>。</p><p id="2c44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有<code class="fe me mf mg mh b">Object.is</code>方法，它做的事情和<code class="fe me mf mg mh b">===</code>一样，只是<code class="fe me mf mg mh b">NaN</code>和它自己是一样的。</p><p id="158c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="007c" class="mq lc iq mh b gy mr ms l mt mu">Object.is('foo', 'bar')</span></pre><p id="e013" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">论点是我们想要比较的两个东西。</p><h1 id="a086" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">undefined，null，0，false，NaN，' '(空字符串)都是false。</h1><p id="e974" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们必须记住这些，因为当我们试图用<code class="fe me mf mg mh b">!!</code>或<code class="fe me mf mg mh b">Boolean</code>将它们转换成布尔时，它们都返回<code class="fe me mf mg mh b">false</code>。</p><h1 id="3222" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用分号来结束行</h1><p id="e19a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript是宽容的，因为它不需要分号来结束行。它只会在换行符后或者任何它认为可以结束一行的地方插入分号。</p><p id="69e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，这会产生意想不到的结果。例如:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="30b8" class="mq lc iq mh b gy mr ms l mt mu">const foo = () =&gt; {<br/>  return <br/>  {<br/>    first: 'john'<br/>  };<br/>}</span></pre><p id="9dc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">会返回<code class="fe me mf mg mh b">undefined</code>因为分号是加在<code class="fe me mf mg mh b">return</code>后面的，所以它下面的代码是永远不会运行的。</p><p id="0233" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该根据需要插入分号，以明确一行的结束位置。</p><h1 id="5939" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对对象构造函数使用类语法</h1><p id="2aba" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在JavaScript中，类与对象构造函数相同。然而，语法更严格，所以更难出错，特别是当我们需要继承的时候。例如，我们可以编写下面的类:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bd29" class="mq lc iq mh b gy mr ms l mt mu">class Person {<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }<br/>}</span></pre><p id="b500" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与以下内容相同:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="faa7" class="mq lc iq mh b gy mr ms l mt mu">function Person(firstName, lastName){<br/>  this.firstName =  firstName;<br/>  this.lastName = lastName;        <br/>}</span></pre><p id="6825" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只是<code class="fe me mf mg mh b">class</code>语法是更传统的语法，特别是对于那些使用其他面向对象语言的人来说。</p><p id="20b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有方法，那就更有意义了。例如，对于类语法，我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2447" class="mq lc iq mh b gy mr ms l mt mu">class Person {<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }</span><span id="b658" class="mq lc iq mh b gy mv ms l mt mu">  fullName() {<br/>    return `${this.firstName } ${this.lastName }`;<br/>  }<br/>}</span></pre><p id="c6c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的<code class="fe me mf mg mh b">Person</code>类有<code class="fe me mf mg mh b">fullName</code>方法。另一方面，使用旧的构造函数语法，我们编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2754" class="mq lc iq mh b gy mr ms l mt mu">function Person(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}</span><span id="3183" class="mq lc iq mh b gy mv ms l mt mu">Person.prototype.fullName = function() {<br/>  return `${this.firstName } ${this.lastName }`;<br/>}</span></pre><p id="12bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对许多开发人员来说没有多大意义，尤其是对非JavaScript开发人员。</p><p id="9182" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类语法使事情更加清晰。类语法对于继承更有意义。用旧语法，我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="feb9" class="mq lc iq mh b gy mr ms l mt mu">function Person(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>}</span><span id="655e" class="mq lc iq mh b gy mv ms l mt mu">Person.prototype.fullName = function() {<br/>  return `${this.firstName } ${this.lastName }`;<br/>}</span><span id="7bce" class="mq lc iq mh b gy mv ms l mt mu">function Student(studentId) {<br/>  Person.call(this, studentId);<br/>}<br/>Student.prototype = Object.create(Person.prototype);<br/>Student.prototype.constructor = Person;</span></pre><p id="328a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们写上面的代码时，如果我们遗漏了什么，也不会有错误。</p><p id="898f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，对于类语法，我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9f6b" class="mq lc iq mh b gy mr ms l mt mu">class Person {<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }<br/>  fullName() {<br/>    return `${this.firstName } ${this.lastName }`;<br/>  }<br/>}</span><span id="6cdc" class="mq lc iq mh b gy mv ms l mt mu">class Student extends Person {<br/>  constructor(firstName, lastName, studentId) {<br/>    super(firstName, lastName);<br/>    this.studentId = studentId;<br/>  }<br/>}</span></pre><p id="c5c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们没有遵循语法，我们也会得到错误，比如当我们有<code class="fe me mf mg mh b">extends</code>时忘记调用<code class="fe me mf mg mh b">super</code>。</p><h1 id="78db" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="b5d6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使用一些重要的东西来编写JavaScript代码，包括用<code class="fe me mf mg mh b">===</code>代替<code class="fe me mf mg mh b">==</code>，用类语法代替构造函数和原型，用<code class="fe me mf mg mh b">let</code>和<code class="fe me mf mg mh b">const</code>代替<code class="fe me mf mg mh b">var</code>来声明变量和常量，并记住falsy值</p><h2 id="cc1f" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="e5be" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="f0dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>