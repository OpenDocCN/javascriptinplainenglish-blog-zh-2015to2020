<html>
<head>
<title>Designing SolidJS: JSX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计固体:JSX</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/designing-solidjs-jsx-50ee2b791d4c?source=collection_archive---------2-----------------------#2019-12-02">https://javascript.plainenglish.io/designing-solidjs-jsx-50ee2b791d4c?source=collection_archive---------2-----------------------#2019-12-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8d35" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">为什么虚拟DOM产生的语法也是反应式UI库的最佳语法？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b2c9e0bfc518e3ac571fdd9813f70672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*A1mSfCoxdyoM4-vCuIbvyQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Black and White Carbon Close Up by Engin Akyurt</figcaption></figure><p id="191c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://github.com/ryansolid/solid" rel="noopener ugc nofollow" target="_blank"> <em class="ls"> SolidJS </em> </a> <em class="ls">是一个高性能的JavaScript UI库。本系列文章深入探讨了设计该库的技术和决策。使用Solid不需要了解这些内容。今天的文章主要关注Solid的JSX模板系统。</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><p id="0dc3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">JSX可能不是反应式UI库中模板化的最明显的选择，但它无疑带来了一些不容忽视的东西。它允许增加灵活性，更好的工具，和无与伦比的性能。我认为JSX是使Solid成为反应最快的库的重要因素。有些人声称这是不应该匹配的东西，但我挑战你，读者，读完这篇文章后，建议他们为什么不应该匹配。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="2361" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">简而言之JSX</h1><p id="dfd4" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">JSX是由脸书开发的，目的是让React的命令式API具有声明性。Reacts渲染方法与视频游戏引擎中的过程并无不同。它只是反复调用函数来渲染屏幕。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="6291" class="nc mb iq my b gy nd ne l nf ng">React.createElement("div", { id: "main" }, [<br/>  "Hi ",<br/>  React.createElement("span", {}, [state.name])<br/>]);</span></pre><p id="fde0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">JSX允许开发者写下:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="1a9d" class="nc mb iq my b gy nd ne l nf ng">&lt;div id="main"&gt;Hi &lt;span&gt;{state.name}&lt;/span&gt;&lt;/div&gt;</span></pre><p id="a89a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种将JSX编译成JavaScript的方法被标准化为HyperScript，通常用<code class="fe nh ni nj my b">h</code>表示，其中任何库都可以提供它们的工厂函数并利用JSX。这个简单的方法向JSX开放了许多库，因为你所需要的只是处理一个接受3个参数的函数，标签或组件，道具和子对象。您可以编写自己的DOM库，通过编写一个简单的函数来处理这个问题，从而利用今天的JSX。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="0942" class="nc mb iq my b gy nd ne l nf ng">import { h } from "your-library";</span><span id="d5ef" class="nc mb iq my b gy nk ne l nf ng">h("div", { id: "main" }, [<br/>  "Hi ",<br/>  h("span", {}, [state.name])<br/>]);</span></pre></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="d706" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">经典反应模板</h1><p id="1166" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">细粒度的反应式UI库的模板，那些基于原子状态更新而不是差分虚拟DOM构建的库已经成为字符串模板的领域。这始于在HTML之上应用的历史，以及在单页面应用流行之前的早期服务器端呈现。除了易于无缝地放置在呈现的HTML字符串之上，字符串模板对于这些反应式库还有一些重要的优势。</p><p id="643e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先，它们模糊了专用的反应式数据对象和计算。仅仅引用一个变量比执行一个访问函数(可观察的)或者将整个绑定包装在一个函数中要好得多。请记住，在Solid这样的细粒度库中，跟踪范围就是一切。所以你的绑定表达式不能被公开执行。</p><p id="a901" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其次，这些字符串通常代表HTML。这意味着可能的值和输入的范围非常有限。您可以绑定到属性或特性，但是条件和循环需要特定的发明语法或DSL(领域特定语言)。这将完全控制权放在解析器和库中，以处理和指定什么是合法的。</p><p id="32f0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，您可以提前看到整个模板，并从结构上优化代码执行。这个模板没有必要的基础。不仅仅是函数调用。它可以利用这个事实在运行任何代码之前进行预测。结果是为最终用户完全抽象了库的基础。</p><p id="d3a7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这绝对是一种让事情变得简单的方法，因为实际上这些库正在后台建立一个依赖图，动态地处理您所有的变更传播需求。但这是有代价的。最令人震惊的是需要一个人造的瞄准镜。需要构造数据对象来承载范围并在循环中定义新的范围，而不是使用局部范围。这不仅增加了开销，而且会妨碍ESLint或TypeScript之类的工具。有些人还会指出所需的DSL是一个缺点，但对于细粒度的，我对此持中立态度，因为无论如何，您都需要专门的方法来有效地处理反应数据。我想指出的是，缺乏可扩展性是DSL的更大问题。有些库不仅允许你写自定义绑定指令，还允许你写自定义控制流指令，所以这并不完全正确。不仅仅是这样做的过程变得更加努力。</p><p id="a058" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以以我典型的方式，我拒绝接受我不能做些什么来改善这一点。解决范围/上下文问题是我的出发点。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="7720" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">固体中的JSX</h1><h2 id="d06a" class="nc mb iq bd mc nl nm dn mg nn no dp mk le np nq mm li nr ns mo lm nt nu mq nv bi translated">屏蔽反应数据</h2><p id="58f9" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">JSX提供了一些真正有用的东西。一种预定义的AST语法，它是标准化的，并与现有工具兼容。所以现在的问题只是处理字符串模板中你认为理所当然的东西。</p><p id="831c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">很早我就决定使用代理作为主要的状态对象。我想在有意义的地方避免访问函数。在处理多状态原子时，我看到了<code class="fe nh ni nj my b">state.count</code>比<code class="fe nh ni nj my b">count()</code>的好处。幸运的是，使用巴别塔和JSX，我可以把表达转化为功能。所以上面的JSX可以编译成:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="198b" class="nc mb iq my b gy nd ne l nf ng">import { h } from "your-library";</span><span id="3514" class="nc mb iq my b gy nk ne l nf ng">h("div", { id: "main" }, [<br/>  "Hi ",<br/>  h("span", {}, [<strong class="my ir">() =&gt; state.name</strong>])<br/>]);</span></pre><p id="81b2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这允许<code class="fe nh ni nj my b">state.name</code>的访问发生在它自己的范围内。这允许只对该表达式进行重新计算，而无需重新执行整个树。我考虑了一下标签模板文字，但是它们会将访问包装推给最终用户。因此，就像字符串模板一样，预处理是必经之路。</p><p id="de6e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这看起来很简单，我本可以就此打住，但是这种方法虽然基本上是兼容的，却完全没有效率。想一想。当然，由于我们的细粒度反应性，我们不需要在这里重新呈现不必要的部分，但是当我们运行大块的视图代码，也许是列表中重复的行时，会发生什么呢？</p><h2 id="f219" class="nc mb iq bd mc nl nm dn mg nn no dp mk le np nq mm li nr ns mo lm nt nu mq nv bi translated">转义HyperScript</h2><p id="2d01" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">现在Solid确实支持HyperScript版本，如果人们希望使用它，他们可以使用带标记的模板文字或传统的JSX编译器，但这些方法可能永远不会是反应库的最佳选择。原因是它们是运行时方法。如果我们不做大量的区别或者构建一个虚拟DOM树，为什么要这么麻烦呢？</p><p id="c1d4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你首先应该考虑的是所有额外的函数调用和道具对象的创建。事实是，<code class="fe nh ni nj my b">h</code>工厂需要解析并确定处理每次执行的输入的最佳方式。如果我们正在编译，我们已经知道了形状。</p><p id="67e0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们再来看看HyperScript:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="ab58" class="nc mb iq my b gy nd ne l nf ng">import { h } from "your-library";</span><span id="3fbb" class="nc mb iq my b gy nk ne l nf ng">h("div", { id: "main" }, [<br/>  "Hi ",<br/>  h("span", {}, [() =&gt; state.name])<br/>]);</span></pre><p id="7d87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">唯一的动态部分是<code class="fe nh ni nj my b">state.name</code>其余的基本上是静态的HTML。HyperScript将HTML分解成多个方法，这意味着我们充其量只是在创作上做一堆<code class="fe nh ni nj my b">document.createElement</code>调用。克隆整个节点模板的性能要高得多。</p><p id="dd2a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可能还会注意到内部的<code class="fe nh ni nj my b">h</code>在外部的执行之前完成了执行。那个<code class="fe nh ni nj my b">span</code>在被创建的时候不知道它的父代是谁。HyperScript基本上是从内向外执行的。这对于运行时方法来说是完全可以接受的，这种方法对数据进行两次传递，比如渲染一棵虚拟树，然后进行差异修补。但是对于单遍库，这可能是有限制的。</p><p id="e140" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我的意思是我们真正想要的是更简单的东西。从概念上讲，我们寻求:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="d954" class="nc mb iq my b gy nd ne l nf ng">const div = &lt;div /&gt;</span></pre><p id="f9d3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为什么<code class="fe nh ni nj my b">&lt;div /&gt;</code>不能只是一个HTMLDivElement？为什么要额外收费。好吧，动态绑定可能没那么简单，但也不一定更复杂。那么，如果将上一节中的JSX示例编译成:</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="6184" class="nc mb iq my b gy nd ne l nf ng">// do once on module load<br/>const tmpl = document.createElement("template")<br/>tmpl.innerHTML = `&lt;div id="main"&gt;Hi &lt;span&gt;&lt;/span&gt;&lt;/div&gt;`</span><span id="3248" class="nc mb iq my b gy nk ne l nf ng">// inside your component, run as many times as you want<br/>const div = tmpl.content.firstChild.cloneNode(true);<br/>const span = div.firstChild.nextSibling;<br/>createEffect(() =&gt; span.textContent = state.name);</span></pre><p id="f02a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">设置时间确实花费了我们一个innerHTML。然而，运行时代码生成要高效得多。<code class="fe nh ni nj my b">createEffect</code>是Solid版本的反应式计算，它封装了单次更新。但是除此之外，没有额外的闭包，没有解析，你基本上可以看到所有相关的代码。它不仅效率更高，而且更加透明。这是该视图呈现时运行的所有代码。除了必须调试到<code class="fe nh ni nj my b">createEffect</code>之外，你所看到的就是你所得到的。这就是Svelte所说的正在消失的运行时。但是仍然有一个小的运行时，但是表面的简单程度可以很容易地看出哪里有错误。</p><h2 id="ed17" class="nc mb iq bd mc nl nm dn mg nn no dp mk le np nq mm li nr ns mo lm nt nu mq nv bi translated">组件和上下文</h2><p id="8233" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">记得刚才我提到过，HyperScript是从内向外执行的。嗯，这对于JSX来说是一件真实的事情，因为它只是JavaScript，所以我们可以在JSX的JSX插入JSX，等等…这里是完整的盗梦空间。无论我如何编译它，它最终都会成为某种函数调用，在它结束之前执行它的子对象。尤其是当你考虑组件的时候。我已经在做的一件事是将表达式包装在函数中，这样父类至少可以选择何时评估任何动态子类。但是我想要像React的上下文API那样的依赖注入。</p><p id="b459" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">通常，反应式库将其上下文与其DOM节点联系在一起，因此对组件做同样的事情是很自然的。JSX面临的挑战是，在附加到父节点之前创建子节点，除非进行第二次传递，否则无法沿着DOM树向上走。就像一个“onConnected”或“onMounted”生命周期挂钩，当反应式图在很大程度上使生命周期变得多余时，我知道我想要避免不必要的开销。我可以推迟组件的执行，直到附加到父组件，但是这会增加相当大的复杂性，并阻止我想探索的其他事情(比如悬念)。</p><p id="f5d6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我在反应式库方面做了一些前所未有的事情。我使用反应图的层次结构来存储上下文数据。具有自动依赖性跟踪的细粒度反应式系统的工作方式是，在每个执行上下文中，当前运行的计算(反应)被提升到全局范围，在该范围下可以分配任何反应式访问。所以我需要做的就是将每个上下文反向链接到它的父上下文。通过在其上存储值，任何子上下文都可以在执行时向上查找树来找到这个值。它的工作方式与React的Context API非常相似，因为reactive graph是一种虚拟树，它没有实际DOM的基础，即使在分离时也可以访问。</p><p id="2daa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这对于JSX来说意味着渲染首先发生在内存中，因为执行是沿着树向下的，然后在返回的路上附加到它的父节点。因此，只有当整个页面已经呈现时，它才附加到真正的DOM(异步效果之外)。</p><h2 id="0886" class="nc mb iq bd mc nl nm dn mg nn no dp mk le np nq mm li nr ns mo lm nt nu mq nv bi translated">控制流</h2><p id="2f94" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">这真的是最后一块了。理解了组件和上下文是如何工作的，我们就可以用它们来管理视图中的条件和循环。对于反应式库来说，无论是好是坏，您都是在处理专门的数据类型。无论你如何掩饰，它们都存在，所以像本机内置数组方法这样的东西永远不会是最佳的。反应库的字符串DSL也隐藏了这个事实。使用组件并不是前所未有的(见https://github.com/leebyron/react-loops<a class="ae lr" href="https://github.com/leebyron/react-loops" rel="noopener ugc nofollow" target="_blank"/>)，即使是React也是如此，尽管Solid使用这种方法要早得多。虽然它是一种DSL，但它不是固定的。这里最大的优势是我们仍然使用真正的JavaScript作用域。我们可以利用ESLint或TypeScript这样的工具。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="fbba" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">挑战</h1><p id="113d" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">尽管有这么多好处，但也存在一些挑战。讽刺的是，最难的是打字稿。一个关键的好处是，这种方法是完全开箱即用的。或者至少理论上是这样。事实是，TypeScript基本上假设如果你使用JSX，你使用的是React，并且在支持其他库甚至其他HyperScript库时速度非常慢。在这一点上，我已经提出了一些问题，并对十几个问题进行了权衡。这里有一些缺点。没有什么不可克服的，但绝对尴尬。就像没有一种简单的方法可以在不强制转换的情况下判断TypeScript <code class="fe nh ni nj my b">&lt;div /&gt;</code>是一个HTMLDivElement。</p><p id="97a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对我来说不幸的是，这是我第一次在Solid上介绍TypeScript，所以我不得不说，在这一点上感觉非常不成熟。但是所有的Solid都是用TypeScript编写的，并且考虑到了TypeScript，所以我打赌如果有足够的支持，他们最终会修复这些问题。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="839a" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="aaae" class="pw-post-body-paragraph kv kw iq kx b ky ms jr la lb mt ju ld le mu lg lh li mv lk ll lm mw lo lp lq ij bi translated">如果你一直跟进这一点，你可能会开始看到把所有这些东西放在一起的力量。JSX是JS意味着DSL是任意的。定制绑定并不比仅仅使用<code class="fe nh ni nj my b">ref</code>更难，因此您可以创建定制的控制流。我指的是条件和循环之类的东西。没有多少库允许你编写自己的<code class="fe nh ni nj my b">if</code>或<code class="fe nh ni nj my b">each</code>绑定。使用这种方法，您可以随心所欲地管理控制流。我用它来写一些东西，比如入口，悬念，开关/案例，懒惰加载组件，任何需要的东西。</p><p id="8c47" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我最喜欢的部分可能是制作部分是多么容易。您可以非常容易地拆分组件和重构。甚至像React这样简单地将内容拆分到一个文件中也不是这些库的典型做法。这是不需要任何实际成本的。这导致了更好的代码清晰度和可维护性。当谈到长期项目时，sanity React做了很多正确的事情。</p><p id="1e87" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我还意识到这种方法可以推广到任何反应式库。我也为<a class="ae lr" href="https://github.com/ryansolid/mobx-jsx" rel="noopener ugc nofollow" target="_blank"> MobX </a>和<a class="ae lr" href="https://github.com/ryansolid/ko-jsx" rel="noopener ugc nofollow" target="_blank"> Knockout </a>制作了这个核心编译器/渲染器的版本。两者的表现都令人难以置信的好，即使没有Solid快，它们仍然是最快的库之一，与Inferno等并驾齐驱，远远领先于任何更受欢迎的反应库，如Svelte或Vue。(参见<a class="ae lr" href="https://github.com/krausest/js-framework-benchmark" rel="noopener ugc nofollow" target="_blank"> JS框架基准</a>)</p><p id="7d52" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">显然，JSX不是实现这一目标的唯一途径，但它肯定更有活力。一旦你的字符串模板解析器开始需要一个JS解析器，你也可以考虑给JSX一个机会。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><div class="kg kh ki kj gt nw"><a href="https://github.com/ryansolid/solid" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">瑞安固体/固体</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">一个用于构建用户界面的声明式、高效且灵活的JavaScript库。-瑞安固体/固体</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">github.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok kp nw"/></div></div></a></div><div class="ol om gp gr on nw"><a href="https://medium.com/swlh/designing-solidjs-components-8f1ebb88d78b" rel="noopener follow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">设计SolidJS:组件</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">组件是现代Web UI开发的基础。本文探讨了固体的独特方法…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">medium.com</p></div></div><div class="of l"><div class="oo l oh oi oj of ok kp nw"/></div></div></a></div><div class="ol om gp gr on nw"><a href="https://itnext.io/designing-solidjs-reactivity-75180a4c74b4" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">设计固体:反应性</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">2019年前端开发的热点按钮话题。这很大程度上归功于苗条而富有的哈里斯…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">itnext.io</p></div></div><div class="of l"><div class="op l oh oi oj of ok kp nw"/></div></div></a></div><div class="ol om gp gr on nw"><a href="https://medium.com/@ryansolid/designing-solidjs-dualities-69ee4c08aa03" rel="noopener follow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">设计固体:二元性</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">看对立面能否帮助我们重新定义看待整体问题空间的方式？</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">medium.com</p></div></div><div class="of l"><div class="oq l oh oi oj of ok kp nw"/></div></div></a></div></div></div>    
</body>
</html>