<html>
<head>
<title>Plugin Architecture in JavaScript and Node.js with Plug and Play</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">具有即插即用功能的JavaScript和Node.js插件架构</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/plugin-architecture-in-javascript-and-node-js-with-plug-and-play-6ac0d410db0?source=collection_archive---------10-----------------------#2020-08-28">https://javascript.plainenglish.io/plugin-architecture-in-javascript-and-node-js-with-plug-and-play-6ac0d410db0?source=collection_archive---------10-----------------------#2020-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6e4155f96a2efcc246c7e9c1f0744ac2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KMm5Cqcf3gGBd2L5.png"/></div></div></figure><p id="7b09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://github.com/adaltas/node-plug-and-play" rel="noopener ugc nofollow" target="_blank">即插即用</a>帮助库和应用程序作者在他们的代码中引入插件架构。它通过定义明确的拦截点(也称为挂钩)简化了复杂的代码执行，并为库用户提供了扩展、修复和更改代码执行流的能力，而无需更改代码。</p><p id="711b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个库刚刚发布，并在麻省理工学院的许可下在NPM 上<a class="ae kw" href="https://www.npmjs.com/package/plug-and-play" rel="noopener ugc nofollow" target="_blank">出版。作为其他库的一部分，它已经开放了一段时间。第一个实现是为</a><a class="ae kw" href="https://github.com/adaltas/node-parameters/" rel="noopener ugc nofollow" target="_blank">节点参数</a>创建的，这是一个高级CLI参数库。它后来被改进为<a class="ae kw" href="https://nikita.js.org" rel="noopener ugc nofollow" target="_blank"> Nikita </a>，一个部署自动化工具，最后被隔离到即插即用包中。</p><p id="559d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">插件架构实现了多种目的。当钩子被仔细选择和设置时，应用程序和库用户可以扩展和调整库来满足他们的需要。但不仅仅是用户，当代码变得复杂时，原作者也会从插件中受益。</p><p id="e66a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">复杂的代码可以分解成多个组件。它简化了开发、调试和测试。例如，Node.js的部署自动化工具<a class="ae kw" href="https://nikita.js.org" rel="noopener ugc nofollow" target="_blank"> Nikita </a>的核心过去是基于一个600行的模块，它之所以能工作是因为它有300多个测试的支持。引入新功能很复杂，如果不是不可能的话。微妙和已知的错误仍然存在。在其最新的重构中，相同的核心模块大约有140行，一旦去掉即插即用总结代码，就只有100行。即使是代码的原作者，现在也有可能清楚地理解代码。旧的令人讨厌的错误被删除(新的错误可能已经被引入:)。一堆新功能出现了。更重要的是，当新想法出现时，开发人员的体验从噩梦变成了许多乐趣。</p><p id="157e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个教程，让您开始使用即插即用的主要功能。这并不复杂，我们将慢慢地学习下面的用法。</p><ul class=""><li id="38fa" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">访问和修改挂钩参数</li><li id="c313" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">修改处理程序行为</li><li id="5932" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">在处理程序执行后插入代码</li><li id="9ef9" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">订购挂钩并要求依赖关系</li><li id="d4a6" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">通过处理程序链传递结果</li><li id="21b4" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">异步钩子处理程序</li><li id="4204" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">嵌套/分层架构</li></ul><h1 id="07fd" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">1.没有任何插件的简单应用程序</h1><p id="830a" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">模块是一个基本的web服务器代码。它由核心库组成，并且可以通过插件进行扩展。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="f1af" class="na lm iq mr b be nb nc l nd ne">const http = require('http')<br/><br/>module.exports = (config = {}) =&gt; {<br/>  if(!config.mesage){<br/>    config.message = 'hello'<br/>  }<br/>  const server = http.createServer((req, res) =&gt; {<br/>    res.end(config.message)<br/>  })<br/>  return {<br/>    start: () =&gt; {<br/>      server.listen(config.port)<br/>    },<br/>    stop: () =&gt; {<br/>      server.close()<br/>    }<br/>  }<br/>}</span></pre><p id="46bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该模块由一个初始函数组成，该函数接受一个配置对象<code class="fe mo mp mq mr b">config</code>，并返回两个函数<code class="fe mo mp mq mr b">start</code>和<code class="fe mo mp mq mr b">stop</code>。</p><p id="d0c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b">sample/1/index.js</code>模块是一个cli界面，提示用户输入<code class="fe mo mp mq mr b">start</code>和<code class="fe mo mp mq mr b">stop</code>命令。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="105e" class="na lm iq mr b be nb nc l nd ne">const readline = require('readline')<br/>const app = require('./app')()<br/><br/>const rl = readline.createInterface({<br/>  input: process.stdin,<br/>  output: process.stdout<br/>});<br/>rl.prompt();<br/>rl.on('line', (line) =&gt; {<br/>  switch (line.trim()) {<br/>    case 'start':<br/>      app.start()<br/>      break;<br/>    case 'stop':<br/>      app.stop()<br/>      break;<br/>    default:<br/>      process.stdout.write('Only `start` and `stop` are supported\n')<br/>      break;<br/>  }<br/>  rl.prompt();<br/>})</span></pre><p id="feba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要执行这个示例，克隆<a class="ae kw" href="https://github.com/adaltas/node-plug-and-play-tutorial" rel="noopener ugc nofollow" target="_blank">教程库</a>。从项目根目录，运行<code class="fe mo mp mq mr b">node tutorial/1</code>。在shell提示符下，输入<code class="fe mo mp mq mr b">start</code>，然后输入<code class="fe mo mp mq mr b">stop</code>。它将在Node.js选择的某个随机端口上启动和停止web服务器。您可以修改代码来打印由<code class="fe mo mp mq mr b">server.address().port</code>返回的值，或者使用<code class="fe mo mp mq mr b">netcat</code> Linux命令来找出是哪个端口。</p><h1 id="97db" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">2.访问和修改挂钩参数</h1><p id="13a0" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">让我们用一个新的插件架构来增强我们的应用程序。我们的第一个插件将修改配置对象，将监听端口的默认值设为<code class="fe mo mp mq mr b">3000</code>。在注册新插件之前，我们应该更新我们的原始库，即<code class="fe mo mp mq mr b">app.js</code>文件。</p><p id="2a0b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mo mp mq mr b">sample/2/app.js</code>模块中，我们导入即插即用模块并初始化它。创建的名为<code class="fe mo mp mq mr b">plugins</code>的实例被返回并公开，这样用户可以通过调用<code class="fe mo mp mq mr b">plugins.register</code>函数来注册新的钩子。</p><p id="29a2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们定义了第一个名为<code class="fe mo mp mq mr b">server:start</code>的钩子。它的作用是为用户提供拦截<code class="fe mo mp mq mr b">start</code>命令的机会。<code class="fe mo mp mq mr b">handler</code>函数提供了默认实现。<code class="fe mo mp mq mr b">handler</code>函数的第一个参数在<code class="fe mo mp mq mr b">args</code>中定义。我们通过<code class="fe mo mp mq mr b">config</code>属性传递配置。</p><p id="24c2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">用户现在有能力修改、丰富、改变<code class="fe mo mp mq mr b">handler</code>函数及其参数。在我们的例子中，我们可以访问配置来设置默认的<code class="fe mo mp mq mr b">config.port</code>值。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="3e3c" class="na lm iq mr b be nb nc l nd ne">const http = require('http')<br/>// Import the Plug and Play module<br/>const plugandplay = require('plug-and-play')<br/><br/>module.exports = (config = {}) =&gt; {<br/>  // Initialize our plugin architecture<br/>  const plugins = plugandplay()<br/>  const server = http.createServer((req, res) =&gt; {<br/>    res.end(config.message)<br/>  })<br/>  return {<br/>    // Return and expose the plugin instance<br/>    plugins: plugins,<br/>    start: () =&gt; {<br/>      // Defined the `start` hook<br/>      plugins.call({<br/>        name: 'server:start',<br/>        args: {<br/>          config: config<br/>        },<br/>        handler: ({config}) =&gt; {<br/>          server.listen(config.port)<br/>        }<br/>      })<br/>    },<br/>    stop: () =&gt; {<br/>      server.close()<br/>    }<br/>  }<br/>}</span></pre><p id="7674" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过调用<code class="fe mo mp mq mr b">register</code>创建一个新的插件。为了有效，一个插件必须拦截至少一个钩子并插入它的逻辑。</p><p id="d6ad" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">挂钩名称与用户函数相关联。它也可以是具有与函数相关联的<code class="fe mo mp mq mr b">handler</code>属性的对象。当只定义了一个参数时，它将在原始钩子处理程序之前执行。我们将在后面看到如何通过声明第二个参数来访问原始处理程序以改变其执行或在执行后注入逻辑。</p><p id="709f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当一个新的钩子被注册时，用户函数接收与在<code class="fe mo mp mq mr b">args</code>中定义的相同的参数。在我们的例子中，我们可以访问<code class="fe mo mp mq mr b">config</code>的财产。<code class="fe mo mp mq mr b">sample/2/index.js</code>模块注册并实现我们的第一个钩子来修改配置。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="0ffc" class="na lm iq mr b be nb nc l nd ne">const readline = require('readline')<br/>const myapp = require('./app')()<br/><br/>myapp.plugins.register({<br/>  hooks: {<br/>    'server:start': ({config}) =&gt; {<br/>      // Set the default port value<br/>      if( !config.port ){<br/>        config.port = 3000<br/>      }<br/>    }<br/>  }<br/>})<br/><br/>const rl = readline.createInterface({<br/>  input: process.stdin,<br/>  output: process.stdout<br/>});<br/>rl.prompt();<br/>rl.on('line', (line) =&gt; {<br/>  switch (line.trim()) {<br/>    case 'start':<br/>      myapp.start()<br/>      break;<br/>    case 'stop':<br/>      myapp.stop()<br/>      break;<br/>    default:<br/>      process.stdout.write('Only `start` and `stop` are supported\n')<br/>      break;<br/>  }<br/>  rl.prompt();<br/>})</span></pre><h1 id="7c68" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">3.修改处理程序行为</h1><p id="504a" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">尝试输入<code class="fe mo mp mq mr b">start</code>两次将导致一个不太友好的错误，如下所示:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="dc51" class="na lm iq mr b be nb nc l nd ne">&gt; start<br/>&gt; start<br/>readline.js:1150<br/>            throw err;<br/>            ^<br/><br/>Error [ERR_SERVER_ALREADY_LISTEN]: Listen method has been called more than once without closing.<br/>    at Server.listen (net.js:1399:11)<br/>    at Object.start (/home/david/plug-and-play/sample/app.js:10:14)<br/>    at Interface.&lt;anonymous&gt; (/home/david/plug-and-play/sample/index.js:14:11)<br/>    at Interface.emit (events.js:315:20)<br/>    at Interface._onLine (readline.js:337:10)<br/>    at Interface._line (readline.js:666:8)<br/>    at Interface._ttyWrite (readline.js:1006:14)<br/>    at ReadStream.onkeypress (readline.js:213:10)<br/>    at ReadStream.emit (events.js:315:20)<br/>    at emitKeys (internal/readline/utils.js:335:14) {<br/>  code: 'ERR_SERVER_ALREADY_LISTEN'<br/>}</span></pre><p id="10a6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">web服务器已经在监听端口<code class="fe mo mp mq mr b">3000</code>，新的服务器无法启动。更有趣的是，如果已经启动，通过不调用它的<code class="fe mo mp mq mr b">server.listen</code>函数来避免启动HTTP服务器两次。为此，我们将在<code class="fe mo mp mq mr b">sample/3/app.js</code>模块中公开<code class="fe mo mp mq mr b">server</code>实例参数:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="d22f" class="na lm iq mr b be nb nc l nd ne">const http = require('http')<br/>const plugandplay = require('plug-and-play')<br/><br/>module.exports = (config = {}) =&gt; {<br/>  const plugins = plugandplay()<br/>  const server = http.createServer((req, res) =&gt; {<br/>    res.end(config.message)<br/>  })<br/>  return {<br/>    plugins: plugins,<br/>    start: () =&gt; {<br/>      plugins.call({<br/>        name: 'server:start',<br/>        // Expose the server argument<br/>        args: {<br/>          config: config,<br/>          server: server<br/>        },<br/>        // Grab the server argument<br/>        handler: ({config, server}) =&gt; {<br/>          server.listen(config.port)<br/>        }<br/>      })<br/>    },<br/>    stop: () =&gt; {<br/>      server.close()<br/>    }<br/>  }<br/>}</span></pre><p id="fcc4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的用户钩子现在可以访问<code class="fe mo mp mq mr b">server.listening</code>属性，以了解服务器是否启动并运行。根据它的值，我们将关闭原始钩子处理程序的执行。</p><p id="93e7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的处理程序中，我们声明了第二个参数，即之前调用的处理程序，它也是原始的处理程序。钩子可以通过提供另一个实现或<code class="fe mo mp mq mr b">null</code>来选择覆盖或绕过处理程序。在我们的例子中，当服务器已经在监听时，我们返回<code class="fe mo mp mq mr b">null</code>。另一种类似的方法是返回一个空函数<code class="fe mo mp mq mr b">function(){}</code>。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="283d" class="na lm iq mr b be nb nc l nd ne">const readline = require('readline')<br/>const myapp = require('./app')()<br/><br/>myapp.plugins.register({<br/>  hooks: {<br/>    // Declare the `handler` second argument<br/>    'server:start': ({config, server}, handler) =&gt; {<br/>      if( !config.port ){<br/>        config.port = 3000<br/>      }<br/>      // Return null when the server is already listening<br/>      return server.listening ? null : handler<br/>    }<br/>  }<br/>})<br/><br/>const rl = readline.createInterface({<br/>  input: process.stdin,<br/>  output: process.stdout<br/>});<br/>rl.prompt();<br/>rl.on('line', (line) =&gt; {<br/>  switch (line.trim()) {<br/>    case 'start':<br/>      myapp.start()<br/>      break;<br/>    case 'stop':<br/>      myapp.stop()<br/>      break;<br/>    default:<br/>      process.stdout.write('Only `start` and `stop` are supported\n')<br/>      break;<br/>  }<br/>  rl.prompt();<br/>})</span></pre><h1 id="bfb2" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">4.在处理程序执行后插入代码</h1><p id="320e" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">一旦服务器启动，打印一条消息将是一个很好的补充。</p><p id="03e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个新的插件将为此而创建。它向用户报告有关服务器生命周期的信息。它就在先前创建的那个之后注册。</p><p id="9787" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">挂钩插入<code class="fe mo mp mq mr b">server:start</code>拦截点。它返回一个新的处理函数，从而替换原来的函数。它首先调用原始处理程序，打印一条消息，并返回原始处理程序返回的任何内容。在这种情况下，我们的新处理程序的行为就像旧的一样，它只是在服务器启动后打印一条消息。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="262d" class="na lm iq mr b be nb nc l nd ne">const readline = require('readline')<br/>const myapp = require('./app')()<br/><br/>myapp.plugins.register({<br/>  hooks: {<br/>    'server:start': ({config, server}, handler) =&gt; {<br/>      if( !config.port ){<br/>        config.port = 3000<br/>      }<br/>      return server.listening ? null : handler<br/>    }<br/>  }<br/>})<br/><br/>myapp.plugins.register({<br/>  hooks: {<br/>    'server:start': {<br/>      handler: (args, handler) =&gt; {<br/>        // Return a new handler function<br/>        return () =&gt; {<br/>          // Call the original handler<br/>          const info = handler.call(null, args)<br/>          // Print a message<br/>          process.stdout.write('Server is started\n')<br/>          // Return whatever the original handler was returning<br/>          return info<br/>        }<br/>      }<br/>    }<br/>  }<br/>})<br/><br/>const rl = readline.createInterface({<br/>  input: process.stdin,<br/>  output: process.stdout<br/>});<br/>rl.prompt();<br/>rl.on('line', (line) =&gt; {<br/>  switch (line.trim()) {<br/>    case 'start':<br/>      myapp.start()<br/>      break;<br/>    case 'stop':<br/>      myapp.stop()<br/>      break;<br/>    default:<br/>      process.stdout.write('Only `start` and `stop` are supported\n')<br/>      break;<br/>  }<br/>  rl.prompt();<br/>})</span></pre><h1 id="cc07" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">5.订购挂钩并要求依赖关系</h1><p id="5287" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">运行两次<code class="fe mo mp mq mr b">start</code>命令将导致错误:</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="4b08" class="na lm iq mr b be nb nc l nd ne">[whoami@localhost] &gt; start<br/>[whoami@localhost] &gt; Server is started<br/>                     start<br/>[whoami@localhost] &gt; (node:1358) UnhandledPromiseRejectionWarning: TypeError: Cannot read property 'call' of null<br/>                     at Object.&lt;anonymous&gt; (/home/david/plug-and-play/sample/4/index.js:21:34)<br/>                     at Object.hook (/home/david/plug-and-play/lib/index.js:200:24)<br/>                     at processTicksAndRejections (internal/process/task_queues.js:97:5)<br/>                     (node:1358) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). To terminate the node process on unhandled promise rejection, use the CLI flag `--unhandled-rejections=strict` (see https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). (rejection id: 1)<br/>                     (node:1358) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span></pre><p id="efc1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在第二次调用中，<code class="fe mo mp mq mr b">handler</code>是<code class="fe mo mp mq mr b">null</code>而不是一个函数，因此抛出了上面的错误。这是预料之中的，因为我们的第一个插件返回<code class="fe mo mp mq mr b">null</code>如果服务器已经启动。</p><p id="ece1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一种解决方案是检查<code class="fe mo mp mq mr b">handler</code>值，当它等于<code class="fe mo mp mq mr b">null</code>时，打印一条类似“服务器已经在运行”的消息。为了说明钩子排序，我们选择了另一种方法。我们将确保第二个钩子总是在第一个钩子之前执行。</p><p id="f1da" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们给我们的插件取个名字。第一个名为<code class="fe mo mp mq mr b">plugin:enhancer</code>，第二个名为<code class="fe mo mp mq mr b">plugin:reporter</code>。<code class="fe mo mp mq mr b">server:start</code>钩子不再是一个处理函数。相反，它是一个包含处理程序和指向第一个插件<code class="fe mo mp mq mr b">plugin:enhancer</code>的<code class="fe mo mp mq mr b">before</code>属性的对象。这样，<code class="fe mo mp mq mr b">plugin:reporter</code>的<code class="fe mo mp mq mr b">server:start</code>钩子将总是在<code class="fe mo mp mq mr b">plugin:enhancer</code>钩子之前执行，并且<code class="fe mo mp mq mr b">handler</code>参数将永远不会是<code class="fe mo mp mq mr b">null</code>。</p><p id="ae1f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，<code class="fe mo mp mq mr b">before</code>和<code class="fe mo mp mq mr b">after</code>属性为多个插件定义了钩子之间的执行顺序。他们不要求插件存在。默认情况下，依赖项是可选的。要定义一个必需的依赖项，您必须在plugin <code class="fe mo mp mq mr b">required</code>属性中以字符串或字符串数组的形式列出它的名称，以表示插件名称。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="6dcf" class="na lm iq mr b be nb nc l nd ne">const readline = require('readline')<br/>const myapp = require('./app')()<br/><br/>myapp.plugins.register({  name: 'plugin:enhancer',  hooks: {    'server:start': ({config, server}, handler) =&gt; {      if( !config.port ){        config.port = 3000      }      return server.listening ? null : handler    }  }})<br/>myapp.plugins.register({  name: 'plugin:reporter',  required: 'plugin:enhancer',  hooks: {    'server:start': {      before: 'plugin:enhancer',      handler: (args, handler) =&gt; {        return () =&gt; {          const info = handler.call(null, args)          process.stdout.write('Server is started\n')          return info        }      }    }  }})<br/>const rl = readline.createInterface({<br/>  input: process.stdin,<br/>  output: process.stdout<br/>});<br/>rl.prompt();<br/>rl.on('line', (line) =&gt; {<br/>  switch (line.trim()) {<br/>    case 'start':<br/>      myapp.start()<br/>      break;<br/>    case 'stop':<br/>      myapp.stop()<br/>      break;<br/>    default:<br/>      process.stdout.write('Only `start` and `stop` are supported\n')<br/>      break;<br/>  }<br/>  rl.prompt();<br/>})</span></pre><h1 id="8d0a" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">6.通过处理程序链传递结果</h1><p id="4925" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">当插件注册新的钩子时，以原始处理程序开始的几个处理程序被一个接一个地调用。序列顺序基于插件注册以及钩子<code class="fe mo mp mq mr b">before</code>和<code class="fe mo mp mq mr b">after</code>属性。</p><p id="0dab" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当实现钩子处理程序时，库作者得到执行链返回的结果。<code class="fe mo mp mq mr b">plugins.call</code>函数返回最后执行的处理程序的值。库作者可以在函数中自由使用和返回值。在<code class="fe mo mp mq mr b">sample/6/app.js</code>模块中，处理程序返回端口号。该端口用于丰富info对象，该对象在<code class="fe mo mp mq mr b">start</code>函数结束时返回给最终用户。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="747b" class="na lm iq mr b be nb nc l nd ne">const http = require('http')<br/>const plugandplay = require('plug-and-play')<br/><br/>module.exports = (config = {}) =&gt; {<br/>  const plugins = plugandplay()<br/>  const server = http.createServer((req, res) =&gt; {<br/>    res.end(config.message)<br/>  })<br/>  return {<br/>    plugins: plugins,<br/>    start: async () =&gt; {<br/>      const info = {<br/>        time: new Date()<br/>      }<br/>      // Get the result returned by the last called handler<br/>      info.port = await plugins.call({<br/>        name: 'server:start',<br/>        args: {<br/>          config: config,<br/>          server: server<br/>        },<br/>        // Handler returning the port number<br/>        handler: ({config, server}) =&gt; {<br/>          server.listen(config.port)<br/>          return server.address().port<br/>        }<br/>      })<br/>      return info<br/>    },<br/>    stop: () =&gt; {<br/>      server.close()<br/>    }<br/>  }<br/>}</span></pre><p id="9cb2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在<code class="fe mo mp mq mr b">sample/6/index.js</code>模块中，<code class="fe mo mp mq mr b">info</code>对象用于打印端口号。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="7bdf" class="na lm iq mr b be nb nc l nd ne">const readline = require('readline')<br/>const myapp = require('./app')()<br/><br/>myapp.plugins.register({<br/>  name: 'plugin:enhancer',<br/>  hooks: {<br/>    'server:start': ({config, server}, handler) =&gt; {<br/>      if( !config.port ){<br/>        config.port = 3000<br/>      }<br/>      return server.listening ? null : handler<br/>    }<br/>  }<br/>})<br/><br/>myapp.plugins.register({<br/>  name: 'plugin:reporter',<br/>  required: 'plugin:enhancer',<br/>  hooks: {<br/>    'server:start': {<br/>      before: 'plugin:enhancer',<br/>      handler: (args, handler) =&gt; {<br/>        return () =&gt; {<br/>          const info = handler.call(null, args)<br/>          process.stdout.write('Server is started\n')<br/>          return info<br/>        }<br/>      }<br/>    }<br/>  }<br/>})<br/><br/>const rl = readline.createInterface({<br/>  input: process.stdin,<br/>  output: process.stdout<br/>});<br/>rl.prompt();<br/>rl.on('line', async (line) =&gt; {<br/>  switch (line.trim()) {<br/>    case 'start':<br/>      // Get the info object and print the port number<br/>      const info = await myapp.start()<br/>      process.stdout.write(`Port is ${info.port}\n`)<br/>      break;<br/>    case 'stop':<br/>      myapp.stop()<br/>      break;<br/>    default:<br/>      process.stdout.write('Only `start` and `stop` are supported\n')<br/>      break;<br/>  }<br/>  rl.prompt();<br/>})</span></pre><p id="6201" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，值总是作为承诺返回。任何其他类型的价值都包含在承诺中。</p><h1 id="f942" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">7.异步钩子处理程序</h1><p id="b2f1" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">上面的代码有点问题。该消息通知用户服务器已经启动，但并不完全正确。启动函数是一个异步函数。在打印消息时，服务器还没有启动并准备好处理请求。</p><p id="4749" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">异步处理程序必须返回并解析承诺。</p><p id="927a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b">sample/7/app.js</code>模块解决了这个问题。它的处理程序现在返回一个承诺。在返回之前，<code class="fe mo mp mq mr b">start</code>函数本身也必须等待承诺解决。注意，<code class="fe mo mp mq mr b">setTimeout</code>函数只出现在代码中，用来模拟缓慢的启动时间。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="787c" class="na lm iq mr b be nb nc l nd ne">const http = require('http')<br/>const plugandplay = require('plug-and-play')<br/><br/>module.exports = (config = {}) =&gt; {<br/>  const plugins = plugandplay()<br/>  const server = http.createServer((req, res) =&gt; {<br/>    res.end(config.message)<br/>  })<br/>  return {<br/>    plugins: plugins,<br/>    // Return a promise<br/>    start: async () =&gt; {<br/>      const info = {<br/>        time: new Date()<br/>      }<br/>      // Wait for the promise to resolve<br/>      info.port = await plugins.call({<br/>        name: 'server:start',<br/>        args: {<br/>          config: config,<br/>          server: server<br/>        },<br/>        handler: ({config, server}) =&gt; {<br/>          // Return a Promise<br/>          return new Promise( (accept, reject) =&gt; {<br/>            server.listen({port: config.port}, (err) =&gt; {<br/>              // Simulate a perceptible delay<br/>              setTimeout( () =&gt; {<br/>                err ? reject(err) : accept(server.address().port)<br/>              }, 1000)<br/>            })<br/>          })<br/>        }<br/>      })<br/>      return info<br/>    },<br/>    stop: () =&gt; {<br/>      server.close()<br/>    }<br/>  }<br/>}</span></pre><p id="9b0c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">插件作者还必须尊重处理程序的异步特性，并像在<code class="fe mo mp mq mr b">sample/7/index.js</code>模块中一样处理它们的返回值。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="5702" class="na lm iq mr b be nb nc l nd ne">const readline = require('readline')<br/>const myapp = require('./app')()<br/><br/>myapp.plugins.register({<br/>  name: 'plugin:enhancer',<br/>  hooks: {<br/>    'server:start': ({config, server}, handler) =&gt; {<br/>      if( !config.port ){<br/>        config.port = 3000<br/>      }<br/>      return server.listening ? null : handler<br/>    }<br/>  }<br/>})<br/><br/>myapp.plugins.register({<br/>  name: 'plugin:reporter',<br/>  required: 'plugin:enhancer',<br/>  hooks: {<br/>    'server:start': {<br/>      before: 'plugin:enhancer',<br/>      handler: (args, handler) =&gt; {<br/>        // Return a promise<br/>        return async () =&gt; {<br/>          // Obtain a promise<br/>          const info = await handler.call(null, args)<br/>          process.stdout.write('Server is started\n')<br/>          return info<br/>        }<br/>      }<br/>    }<br/>  }<br/>})<br/><br/>const rl = readline.createInterface({<br/>  input: process.stdin,<br/>  output: process.stdout<br/>});<br/>rl.prompt();<br/>rl.on('line', async (line) =&gt; {<br/>  switch (line.trim()) {<br/>    case 'start':<br/>      const info = await myapp.start()<br/>      process.stdout.write(`Port is ${info.port}\n`)<br/>      break;<br/>    case 'stop':<br/>      myapp.stop()<br/>      break;<br/>    default:<br/>      process.stdout.write('Only `start` and `stop` are supported\n')<br/>      break;<br/>  }<br/>  rl.prompt();<br/>})</span></pre><h1 id="66d4" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">8.嵌套/分层架构</h1><p id="7ec2" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">插件实例可以嵌套，这意味着一个拦截点可以调用当前实例和父实例中注册的钩子。</p><p id="d8cf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae kw" href="https://nikita.js.org" rel="noopener ugc nofollow" target="_blank"> Nikita项目</a>在其架构内部充分利用了这一特性。Nikita是一个<a class="ae kw" href="https://www.adaltas.com/en/tag/iac/" rel="noopener ugc nofollow" target="_blank">基础设施代码(IaC)工具</a>，用于自动化部署。它由嵌套的动作组成。父动作可以定义安装组件的过程，比如安装MariaDB。这个父动作由多个子动作组成，比如安装YUM或APT包、维护配置文件以及上传SSL证书。同样，每个动作都由多个子动作组成。配置操作写入一个文件，但也检查其权限和所有权。package操作根据当前的Linux发行版执行shell命令来安装软件包。在任何级别，Nikita都为用户提供了注册插件的机会。一旦注册，插件对每个子动作都是可用和有效的。例如，<code class="fe mo mp mq mr b">debug</code>插件将日志信息打印到stdout。注册并激活后，它将对一个动作及其子动作有效。</p><p id="f318" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嵌套架构的另一个常见用途是为用户提供在实例级和全局级注册插件的可能性。在全局级别注册一个插件使得它对每个实例都可用。</p><p id="b508" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b">sample/8/app.js</code>实现了最新的模式。主即插即用模块全局导出一个新的<code class="fe mo mp mq mr b">plugins</code>实例。这个全局实例被传递给每个创建的本地即插即用实例。父实例在初始化时通过<code class="fe mo mp mq mr b">parent</code>属性暴露给它们的子实例。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="e267" class="na lm iq mr b be nb nc l nd ne">const http = require('http')<br/>const plugandplay = require('plug-and-play')<br/><br/>module.exports = (config = {}) =&gt; {<br/>  const plugins = plugandplay({<br/>    // Pass the global plugins instance<br/>    parent: module.exports.plugins<br/>  })<br/>  const server = http.createServer((req, res) =&gt; {<br/>    res.end(config.message)<br/>  })<br/>  return {<br/>    plugins: plugins,<br/>    start: async () =&gt; {<br/>      const info = {<br/>        time: new Date()<br/>      }<br/>      info.port = await plugins.call({<br/>        name: 'server:start',<br/>        args: {<br/>          config: config,<br/>          server: server<br/>        },<br/>        handler: ({config, server}) =&gt; {<br/>          return new Promise( (accept, reject) =&gt; {<br/>            server.listen({port: config.port}, (err) =&gt; {<br/>              setTimeout( () =&gt; {<br/>                err ? reject(err) : accept(server.address().port)<br/>              }, 1000)<br/>            })<br/>          })<br/>        }<br/>      })<br/>      return info<br/>    },<br/>    stop: () =&gt; {<br/>      server.close()<br/>    }<br/>  }<br/>}<br/><br/>// Export global plugins<br/>module.exports.plugins = plugandplay()</span></pre><p id="7f4f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b">sample/8/index.js</code>模块说明了全球和本地注册。<code class="fe mo mp mq mr b">plugin:enhancer</code>是全球注册的，而<code class="fe mo mp mq mr b">plugin:reporter</code>是本地注册的。</p><pre class="ms mt mu mv gt mw mr mx bn my mz bi"><span id="46b6" class="na lm iq mr b be nb nc l nd ne">const readline = require('readline')<br/>const app = require('./app')<br/>// Global registration<br/>app.plugins.register({<br/>  name: 'plugin:enhancer',<br/>  hooks: {<br/>    'server:start': ({config, server}, handler) =&gt; {<br/>      if( !config.port ){<br/>        config.port = 3000<br/>      }<br/>      return server.listening ? null : handler<br/>    }<br/>  }<br/>})<br/><br/>// Local registration<br/>const myapp = app()<br/>myapp.plugins.register({<br/>  name: 'plugin:reporter',<br/>  required: 'plugin:enhancer',<br/>  hooks: {<br/>    'server:start': {<br/>      before: 'plugin:enhancer',<br/>      handler: (args, handler) =&gt; {<br/>        return async () =&gt; {<br/>          const info = await handler.call(null, args)<br/>          process.stdout.write('Server is started\n')<br/>          return info<br/>        }<br/>      }<br/>    }<br/>  }<br/>})<br/><br/>const rl = readline.createInterface({<br/>  input: process.stdin,<br/>  output: process.stdout<br/>});<br/>rl.prompt();<br/>rl.on('line', async (line) =&gt; {<br/>  switch (line.trim()) {<br/>    case 'start':<br/>      const info = await myapp.start()<br/>      process.stdout.write(`Port is ${info.port}\n`)<br/>      break;<br/>    case 'stop':<br/>      myapp.stop()<br/>      break;<br/>    default:<br/>      process.stdout.write('Only `start` and `stop` are supported\n')<br/>      break;<br/>  }<br/>  rl.prompt();<br/>})</span></pre><h1 id="67bc" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">结论</h1><p id="c7c0" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我们使用即插即用和它的祖先已经有几年了，它被证明是有帮助的。它为我们的库和应用程序打开了许多潜力，包括可扩展性和可组合性。我们希望它能很好地为你服务，并欢迎新的<a class="ae kw" href="https://github.com/adaltas/node-plug-and-play/issues" rel="noopener ugc nofollow" target="_blank">功能和修复</a>。</p></div><div class="ab cl nf ng hu nh" role="separator"><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk nl"/><span class="ni bw bk nj nk"/></div><div class="ij ik il im in"><p id="800c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nm">原载于2020年8月28日https://www.adaltas.com</em><em class="nm">的</em> <a class="ae kw" href="https://www.adaltas.com/en/2020/08/28/node-js-plugin-architecture/" rel="noopener ugc nofollow" target="_blank"> <em class="nm">。</em></a></p><p id="5894" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nm">更多内容请看</em> <a class="ae kw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="nm">说白了就是</em> </strong> </a> <em class="nm">。</em></p><p id="e045" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nm">报名参加我们的</em> <a class="ae kw" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="nm">免费每周简讯</em> </strong> </a> <em class="nm">。关注我们关于</em> <a class="ae kw" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="nm">推特</em> </strong> </a>，<a class="ae kw" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nm">LinkedIn</em></strong></a><em class="nm">，</em><a class="ae kw" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ka ir"><em class="nm">YouTube</em></strong></a><em class="nm">，以及</em> <a class="ae kw" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="nm">不和</em></strong></a><strong class="ka ir"><strong class="ka ir"><em class="nm">。</em> </strong></strong></p><p id="796d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> <em class="nm">有兴趣缩放你的软件启动</em> </strong> <em class="nm">？检查出</em> <a class="ae kw" href="https://circuit.ooo?utm=publication-post-cta" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir"> <em class="nm">电路</em> </strong> </a> <em class="nm">。</em></p></div></div>    
</body>
</html>