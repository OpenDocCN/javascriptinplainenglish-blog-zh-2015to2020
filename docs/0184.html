<html>
<head>
<title>5 tricky JavaScript problems to check before your next interview (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">下次面试前要检查的5个棘手的JavaScript问题(第1部分)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-tricky-javascript-problems-to-check-before-your-next-interview-part-1-60fdecaa59d6?source=collection_archive---------0-----------------------#2019-07-23">https://javascript.plainenglish.io/5-tricky-javascript-problems-to-check-before-your-next-interview-part-1-60fdecaa59d6?source=collection_archive---------0-----------------------#2019-07-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a2dd3bf400eb2b0b604c2f3c4ff55a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QcR3epupiJ1qwVQEXUoobA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Got you, JS!</figcaption></figure><h1 id="1f02" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">我希望你们还没有因为一些从未见过的奇怪问题而搞砸面试。</h1><p id="1781" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">JavaScript是一种特殊的语言，它的一些设计缺陷给面试官带来了真正有趣的时光，也给面试者带来了一些令人毛骨悚然的时刻。所以为了创造那个异想天开的<strong class="kz io"> <em class="lv">【暴徒人生】</em> </strong>时刻出现在面试官面前，看看这些问题。</p><h1 id="cddc" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">问题1。for循环内的setTimeout</h1><p id="8b12" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">这个问题最初是在谷歌采访中提出的，现在许多公司已经开始就这个概念提出问题。看看这个问题。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2258" class="mf ka in mb b gy mg mh l mi mj">const arr = [10, 12, 15, 21];<br/>for (var i = 0; i &lt; arr.length; i++) {<br/>  setTimeout(function() {<br/>    console.log('Index: ' + i + ', element: ' + arr[i]);<br/>  }, 3000);<br/>}</span></pre><p id="b74e" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">你认为输出是多少？</p><p id="5d9e" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">是这个吗？</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7600" class="mf ka in mb b gy mg mh l mi mj"><em class="lv">Index: 1, element: 10<br/>Index: 2, element: 12<br/>Index: 3, element: 15<br/>Index: 4, element: 21</em></span></pre><p id="92ab" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">当然不是。这不可能那么明显，不是吗！！</p><p id="17e9" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">输出实际上是这样的。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="75e0" class="mf ka in mb b gy mg mh l mi mj"><em class="lv">Index: 4, element: undefined // printed 4 times</em></span></pre><p id="2d5f" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">这里出现异常是因为JavaScript作用域的怪异性质和一个叫做“闭包”的概念。如果您不熟悉这些概念，请查阅这篇文章。</p><p id="fa70" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated"><a class="ae mp" href="https://medium.com/@akarshanbansal/everything-you-need-to-know-about-the-javascript-scope-f81cbffa9491" rel="noopener"><em class="lv">https://medium . com/@ akarshanbansal/everything-you-need-know-the-JavaScript-scope-f 81 CBF fa 9491</em></a></p><p id="cd92" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">让我们来理解这个奇怪的输出背后的逻辑。在JS中，每当创建一个新函数时，也会形成一个闭包，该闭包使函数能够访问外部作用域。</p><p id="2ead" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">我们在setTimeout中有一个匿名函数，其中将创建一个闭包，该闭包将允许函数从for循环中访问变量'<strong class="kz io"> <em class="lv"> i' </em> </strong>。该函数将被调用4次，因为循环中有4次迭代。但这里的问题是，这个函数会在3000ms后被调用，就像setTimeout的第二个参数中提到的那样。所以在执行这个函数的时候，变量'<strong class="kz io"> <em class="lv"> i' </em> </strong>已经递增到4。</p><p id="1ece" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">关键的区别在于，第一个函数调用只会发生在循环已经结束之后，这就是为什么我们看到'<strong class="kz io"> <em class="lv"> i' </em> </strong>的值为4。</p><p id="d32a" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">让我们稍微改造一下这个程序，以便我们可以在浏览器控制台中可视化它。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0d23" class="mf ka in mb b gy mg mh l mi mj">const arr = [10, 12, 15, 21];<br/>for (var i = 0; i &lt; arr.length; i++) {<br/> function log() {<br/>  console.log('Index: ' + i + ', element: ' + arr[i]);<br/>  }<br/>  console.dir(log)<br/>  setTimeout(log, 1000);<br/>}</span></pre><p id="aece" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">现在我们添加了一个命名函数<strong class="kz io"> <em class="lv"> log </em> </strong>而不是一个匿名函数，这样我们就可以使用<strong class="kz io"> <em class="lv"> console.dir </em> </strong>来检查它的作用域</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mq"><img src="../Images/26d730cf02b5c2495e02525b7586e60c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fF2W7aM6mfZrRDMqSC9MtQ.png"/></div></div></figure><p id="3007" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">可以非常清楚地看到，创建的闭包有'<strong class="kz io"> <em class="lv"> i' </em> </strong>的值为4。</p><p id="277a" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">现在我们该如何解决这个问题呢？有两种方法可以做到这一点。</p><p id="dbfe" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated"><strong class="kz io">首先是</strong>，我们可以使用“<strong class="kz io"> <em class="lv">【生命】”</em> </strong>设计将循环中计数器的值绑定到方法中的一个局部变量。让我们看看我们能做些什么。</p><p id="6601" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">如果你以前没看过，请看看生活设计模式。你可以关注这篇关于这个主题的精彩文章。</p><p id="6a77" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated"><a class="ae mp" href="https://medium.com/javascript-in-plain-english/https-medium-com-javascript-in-plain-english-stop-feeling-iffy-about-using-an-iife-7b0292aba174" rel="noopener"><em class="lv">https://medium . com/JavaScript-in-plain-English/https-medium-com-JavaScript-in-plain-English-stop-feeling-iffy-about-use-an-life-7b 0292 ABA 174</em></a></p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="e671" class="mf ka in mb b gy mg mh l mi mj">const arr = [10, 12, 15, 21];<br/>for (var i = 0; i &lt; arr.length; i++) {<br/>  setTimeout((function() {<br/>    console.log('Index: ' + i + ', element: ' + arr[i]);<br/>  })(i), 3000);<br/>}</span></pre><p id="60c9" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">因此，我们添加了一个带有计数器'<strong class="kz io"> <em class="lv"> i' </em> </strong>的IIFE作为参数，而不是一个匿名函数。因此，它将更新后的值存储为函数的参数。</p><p id="6e5f" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated"><strong class="kz io">其次，</strong>我们可以使用'<strong class="kz io"><em class="lv">' let '</em></strong>变量声明。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="fe4b" class="mf ka in mb b gy mg mh l mi mj">const arr = [10, 12, 15, 21];<br/>for (let i = 0; i &lt; arr.length; i++) {<br/>  setTimeout(function() {<br/>    console.log('Index: ' + i + ', element: ' + arr[i]);<br/>  }, 3000);<br/>}</span></pre><p id="94a7" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">为什么会这样？原因是'<strong class="kz io"> <em class="lv"> let' </em> </strong>是一个块范围的声明，它将为for循环的每次迭代创建一个新的变量绑定。所以在每次迭代中，一个带有更新值的新变量在内存中被创建。</p><p id="cb93" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">我知道。我也没想到会这样。</p><h1 id="7a6d" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">问题2。写一个函数mul(x)(y)(z)把x，y，z相乘。</h1><p id="7cc7" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">这个问题乍一看很吓人，但是如果你使用JS的函数式编程模式，你可以从一个函数返回一个函数。</p><p id="aa41" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">这个问题有三组不同的论点。因此，我们需要3个独立的函数来消耗参数并完成工作。我们开始吧。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="22bb" class="mf ka in mb b gy mg mh l mi mj">function mul(x) {<br/>   return function(y) {<br/>      return function(z) {<br/>         return x*y*z;<br/>      }<br/>   }<br/>}</span><span id="3db6" class="mf ka in mb b gy mr mh l mi mj">console.log(mul(2)(3)(4)); //output is 24</span></pre><p id="286b" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">在看到解决方案后，我知道这似乎很容易。您可以将它用于n个单独的参数</p><h1 id="a8fa" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">问题3。功能与可变提升。</h1><p id="2685" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">看看这个程序</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ea27" class="mf ka in mb b gy mg mh l mi mj">function func() {<br/> abc = "Variable";<br/>  function abc() {<br/>    return("Function")<br/>  }<br/>  return abc();<br/>}<br/>console.log(func());</span></pre><p id="fbfc" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">你认为答案是什么？不，它当然不是<strong class="kz io"> <em class="lv">“功能”。</em> </strong></p><p id="a986" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">您实际上会得到以下错误</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/b1bf0b14ec6ea6459e42479fffa019f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*aDOTiXiiiSR-vuB_7TNHxQ.png"/></div></figure><p id="9b0f" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">我知道。暂时不要拔掉你的头发。这其实和JavaScript中一个叫做提升的概念有关。JS中有两种类型的吊装。可变提升和功能提升。</p><p id="cbb2" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">在变量提升中，只有变量声明，而不是变量定义/赋值，被移动到作用域链的顶端。</p><p id="44a7" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">在函数提升中，函数声明和定义都被移动到作用域链的顶端。</p><p id="0528" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">我建议您在继续之前详细阅读提升的概念。看看这篇关于概念的伟大文章:<a class="ae mp" href="https://medium.com/javascript-in-plain-english/https-medium-com-javascript-in-plain-english-what-is-hoisting-in-javascript-a63c1b2267a1" rel="noopener"><strong class="kz io">JavaScript中的提升是什么？</strong> </a></p><p id="4dd0" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">现在，在这种情况下，变量和函数具有相同的名称。当这种情况发生时，函数将被提升到顶部，变量提升被忽略。因此，当return语句执行时，它将返回紧接在它前面的变量定义。</p><p id="82c3" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">这是程序提升后的样子。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="56fd" class="mf ka in mb b gy mg mh l mi mj">function func() {<br/>  function abc() {<br/>    return("Function")<br/>  }<br/>  abc = "Variable";<br/>  return abc();<br/>}<br/>console.log(func());</span></pre><p id="caf8" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">我希望这能澄清一切，而且你现在还没有秃顶。</p><h1 id="3a61" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">问题4。分号偏差</h1><p id="04bc" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">参见下面的程序</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3288" class="mf ka in mb b gy mg mh l mi mj">function func1() {<br/>  return {<br/>    name: "Akarshan"<br/>  };<br/>}</span><span id="3ae3" class="mf ka in mb b gy mr mh l mi mj">function func2() {<br/>  return<br/>  {<br/>    name: "Akarshan"<br/>  };<br/>}</span><span id="fb0e" class="mf ka in mb b gy mr mh l mi mj">console.log(func1())<br/>console.log(func2())</span></pre><p id="1906" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">理想情况下，这两个函数应该返回完全相同的东西，但是当然，它们没有。这就是为什么我们在讨论这个问题。</p><p id="6114" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">输出实际上是这样的</p><figure class="lw lx ly lz gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/e0fc762537d17d1224937f89ff9b19e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1178/format:webp/1*n_2DUZ7vLk0mJpZlVJu80A.png"/></div></figure><p id="1a41" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">这是因为在JavaScript中，分号<strong class="kz io">是可选的</strong>，JavaScript会在需要时自动在行尾插入一个分号。所以在第二种情况下，花括号被添加到下一行，JavaScript自动在return语句的末尾添加一个分号，因此，第二个函数中的值是'<strong class="kz io"> <em class="lv">【未定义】'</em> </strong>。</p><h1 id="9b32" class="jz ka in bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw bi translated">问题5。事件循环和调用堆栈</h1><p id="8645" class="pw-post-body-paragraph kx ky in kz b la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu ig bi translated">查看以下程序</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0d08" class="mf ka in mb b gy mg mh l mi mj">console.log("1")</span><span id="629a" class="mf ka in mb b gy mr mh l mi mj">setTimeout(function() {<br/> console.log("2")<br/>}, 0)</span><span id="a553" class="mf ka in mb b gy mr mh l mi mj">console.log("3")</span></pre><p id="2c51" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">输出不是1，2，3，而是1，3，2。</p><p id="5490" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">这个问题是基于我们的浏览器如何处理异步和同步操作。</p><p id="62d9" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">通常，同步功能在浏览器的事件循环中执行。但是任何时候，浏览器遇到一个异步函数，它就会被添加到调用堆栈中。调用堆栈会一直等待，直到可以将函数推送到要执行的事件循环。这只有在事件循环为空时才会发生。</p><p id="3833" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">在我们的例子中，即使setTimeout被设置为0，该函数本质上是异步的，因此被添加到调用堆栈中。事件循环直到打印出<strong class="kz io"><em class="lv">“3”</em></strong>才为空。只有在这之后，调用栈才会在事件循环中推送函数，并打印出<strong class="kz io"><em class="lv">【2】</em></strong>。</p><p id="ffbb" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">如果您想详细了解这个概念，请查看JavaScript并发模型。</p></div><div class="ab cl mu mv hr mw" role="separator"><span class="mx bw bk my mz na"/><span class="mx bw bk my mz na"/><span class="mx bw bk my mz"/></div><div class="ig ih ii ij ik"><p id="310c" class="pw-post-body-paragraph kx ky in kz b la mk lc ld le ml lg lh li mm lk ll lm mn lo lp lq mo ls lt lu ig bi translated">我希望我已经帮助了你们中的一些有需要的人，也希望我能看到一些新的<em class="lv">“在……开始一个新的职位”</em>在我的Linkedin Feed上。我将在第二部分贴出一些更有趣的问题。在那之前。再见。</p></div></div>    
</body>
</html>