<html>
<head>
<title>Better JavaScript — Destructuring, Hoisting, and Closures</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更好的JavaScript——析构、提升和闭包</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/better-javascript-destructuring-hoisting-and-closures-24bcd2e2229c?source=collection_archive---------7-----------------------#2020-10-07">https://javascript.plainenglish.io/better-javascript-destructuring-hoisting-and-closures-24bcd2e2229c?source=collection_archive---------7-----------------------#2020-10-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a6a0a74fae49d5e5a18bb7ee23a70e9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F6bzYkMOJ2q6ntmL"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@framemily?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Frame Harirak</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8b68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究改进JavaScript代码的方法。</p><h1 id="9929" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用析构将属性提取到变量中</h1><p id="49b1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们想提取变量的属性，我们可以使用析构赋值语法。</p><p id="efd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5169" class="mn lc iq mj b gy mo mp l mq mr">function foo(x, y) {<br/>  const {<br/>    min,<br/>    round,<br/>    sqrt<br/>  } = Math;<br/>  return min(round(x), sqrt(y));<br/>}</span></pre><p id="4efb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从<code class="fe ms mt mu mj b">Math</code>对象中获取<code class="fe ms mt mu mj b">min</code>、<code class="fe ms mt mu mj b">round</code>和<code class="fe ms mt mu mj b">sqrt</code>方法。</p><p id="2817" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过使用变量来调用方法，而不是重复引用<code class="fe ms mt mu mj b">Math</code>。</p><h1 id="5a5f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">熟悉闭包</h1><p id="6a64" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">闭包是我们可能不熟悉的东西。</p><p id="80bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们第一次和他们一起工作时，可能看起来有点吓人。</p><p id="2c4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，其实很简单。</p><p id="f162" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">闭包只是函数内部的函数。</p><p id="d82c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">内部函数可以引用其父范围内的变量。</p><p id="0dad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5bf0" class="mn lc iq mj b gy mo mp l mq mr">function makePie() {<br/>  const ingredient = "peanut butter";</span><span id="de8b" class="mn lc iq mj b gy mv mp l mq mr">  function make(filling) {<br/>    return `${ingredient} and ${filling}`;<br/>  }<br/>  return make("jelly");<br/>}</span></pre><p id="0536" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个<code class="fe ms mt mu mj b">make</code>函数，它接受<code class="fe ms mt mu mj b">filling</code>参数，并在将其与来自其父函数的<code class="fe ms mt mu mj b">ingredient</code>组合后返回一些内容。</p><p id="4ebb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们可以在函数中保存私有变量，然后从内部函数访问它们。</p><p id="ca5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以在JavaScript中将函数作为变量返回。</p><p id="d714" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1cf0" class="mn lc iq mj b gy mo mp l mq mr">function makePie() {<br/>  const ingredient = "peanut butter";</span><span id="b65f" class="mn lc iq mj b gy mv mp l mq mr">  function make(filling) {<br/>    return `${ingredient} and ${filling}`;<br/>  }<br/>  return make;<br/>}</span></pre><p id="8f85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并返回<code class="fe ms mt mu mj b">make</code>函数。</p><p id="483e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用它来创建一个新的函数，通过编写“</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="1f3a" class="mn lc iq mj b gy mo mp l mq mr">const f = makePie();<br/>f('banana cream');</span></pre><p id="c7ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们从返回的<code class="fe ms mt mu mj b">f</code>函数调用中得到<code class="fe ms mt mu mj b">'peanut butter and banana cream’</code>。</p><p id="6af8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下内容来进一步缩短<code class="fe ms mt mu mj b">makePie</code>函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="11ca" class="mn lc iq mj b gy mo mp l mq mr">function makePie() {<br/>  const ingredient = "peanut butter";</span><span id="5001" class="mn lc iq mj b gy mv mp l mq mr">  return function(filling) {<br/>    return `${ingredient} and ${filling}`;<br/>  }<br/>}</span></pre><p id="f16b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回一个匿名函数。</p><p id="7395" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript函数不一定要有名字。</p><p id="d2af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">闭包可以更新外部变量的值。</p><p id="0d3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b9ec" class="mn lc iq mj b gy mo mp l mq mr">function foo() {<br/>  let val;<br/>  return {<br/>    set(newVal) {<br/>      val = newVal;<br/>    },<br/>    get() {<br/>      return val;<br/>    },<br/>    type() {<br/>      return typeof val;<br/>    }<br/>  };<br/>}</span></pre><p id="c3ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了<code class="fe ms mt mu mj b">foo</code>函数，并用<code class="fe ms mt mu mj b">set</code>、<code class="fe ms mt mu mj b">get</code>和<code class="fe ms mt mu mj b">type</code>方法返回了一个对象。</p><p id="822d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">set</code>设置<code class="fe ms mt mu mj b">val</code>的值。</p><p id="171f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">get</code>返回<code class="fe ms mt mu mj b">val</code>的值。</p><p id="4054" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">type</code>返回<code class="fe ms mt mu mj b">val</code>的数据类型。</p><p id="33ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">val</code>在对象之外，但是对象可以访问它，因为它在父对象的范围内。</p><p id="f226" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些闭包共享对<code class="fe ms mt mu mj b">val</code>的访问。</p><h1 id="5c43" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可变提升</h1><p id="f91f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">变量提升是在定义变量之前可以访问变量声明的地方。</p><p id="fa43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只适用于用<code class="fe ms mt mu mj b">var</code>声明的变量。</p><p id="7336" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">let</code>和<code class="fe ms mt mu mj b">const</code>变量是块范围的，不会被提升。</p><p id="9761" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下内容来查看提升的变量:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e682" class="mn lc iq mj b gy mo mp l mq mr">console.log(foo);<br/>var foo = 1;</span></pre><p id="03df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">foo</code>是<code class="fe ms mt mu mj b">undefined</code>但是可以访问。</p><p id="e508" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免这种情况，我们应该只使用<code class="fe ms mt mu mj b">let</code>和<code class="fe ms mt mu mj b">const</code>变量。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0659f4d21296d34e71f4142d6712b318.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sciRj6mbB-3wjeH3"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ruqqqes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mark Kamalov</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e374" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="f7af" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使用析构语法从对象中提取属性。</p><p id="03ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">闭包是我们有时会用到的东西。</p><p id="ddec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们是函数中的函数。</p><p id="4df5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可变提升是我们可能会遇到的事情，但它越来越不常见。</p><p id="e611" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>