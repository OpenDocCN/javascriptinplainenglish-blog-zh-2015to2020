<html>
<head>
<title>React Tips — Error Handling, Input Validation, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React提示—错误处理、输入验证等等</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-tips-error-handling-input-validation-and-more-8d17ef989be4?source=collection_archive---------1-----------------------#2020-08-02">https://javascript.plainenglish.io/react-tips-error-handling-input-validation-and-more-8d17ef989be4?source=collection_archive---------1-----------------------#2020-08-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/06d4f608648f0b978268c2edfa8fbd86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KazORJewMVL6VDiF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@spktwo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">George Bonev</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7ed4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些编写更好的React应用程序的技巧。</p><h1 id="6a12" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将没有值的属性传递给组件</h1><p id="4768" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果组件的值是<code class="fe me mf mg mh b">true</code>，我们可以将不带值的布尔属性传递给组件。</p><p id="7aa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fa9b" class="mq lc iq mh b gy mr ms l mt mu">&lt;input type="button" disabled /&gt;;</span></pre><p id="7b9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="67e0" class="mq lc iq mh b gy mr ms l mt mu">&lt;input type="button" disabled={true} /&gt;;</span></pre><p id="d155" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们是一样的。</p><h1 id="3ef5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过引用访问子组件功能</h1><p id="6733" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在一个类组件中指定一个引用来访问它的方法。</p><p id="f8a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1f47" class="mq lc iq mh b gy mr ms l mt mu">class App extends React.Component {<br/>  save() {<br/>    this.refs.content.getWrappedInstance().save();<br/>  }</span><span id="2927" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;Dialog action={this.save.bind(this)}&gt;<br/>        &lt;Content ref="content"/&gt;<br/>      &lt;/Dialog&gt;);<br/>   }<br/>}</span><span id="6a32" class="mq lc iq mh b gy mv ms l mt mu">class Content extends React.Component {<br/>  save() { <br/>    //... <br/>  }<br/>}</span></pre><p id="880f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe me mf mg mh b">App</code>组件，它的<code class="fe me mf mg mh b">Content</code>被分配了一个ref。</p><p id="b62d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们就可以用<code class="fe me mf mg mh b">getWrapperdInstance</code>得到组件实例了。</p><p id="1096" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用它来调用<code class="fe me mf mg mh b">save</code>方法。</p><h1 id="e294" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">getDerivedStateFromError和componentDidCatch</h1><p id="048b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">两者都是让我们处理类组件中的错误的方法。</p><p id="1ce6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">getDerivedStateFromError</code>是一个静态方法，让我们在错误发生时设置一个状态。</p><p id="82c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">componentDidCatch</code>让我们提交副作用并访问<code class="fe me mf mg mh b">this</code>，这是组件实例。</p><p id="2b49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b40f" class="mq lc iq mh b gy mr ms l mt mu">class ErrorBoundary extends React.Component {<br/>  state = { hasError: false };</span><span id="fb62" class="mq lc iq mh b gy mv ms l mt mu">  static getDerivedStateFromError(error) {<br/>    return { hasError: true };<br/>  }</span><span id="644d" class="mq lc iq mh b gy mv ms l mt mu">  componentDidCatch(error, info) {<br/>    console.log(error, info);<br/>  }</span><span id="e2be" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    if (this.state.hasError) {<br/>      return &lt;h1&gt;error.&lt;/h1&gt;;<br/>    }</span><span id="bb5e" class="mq lc iq mh b gy mv ms l mt mu">    return this.props.children; <br/>  }<br/>}</span></pre><p id="4726" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有静态的<code class="fe me mf mg mh b">getDerivedStateFromError</code>方法来访问<code class="fe me mf mg mh b">error</code>参数。</p><p id="458b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以返回下一次渲染时的状态。</p><p id="6448" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">componentDidCatch</code>让我们访问组件实例。</p><p id="8bff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还有误差数据较多的<code class="fe me mf mg mh b">error</code>和<code class="fe me mf mg mh b">info</code>参数。</p><p id="9c3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">getDerivedStateFromError</code>使用服务器端渲染。</p><p id="712c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为它是一个渲染阶段生命周期，可用于服务器端渲染应用程序。</p><h1 id="df0d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">允许文件输入选择React组件中的相同文件</h1><p id="0328" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以让一个文件输入选择React组件中的同一个文件，如果我们在点击它之后将它设置为<code class="fe me mf mg mh b">null</code>的话。</p><p id="43a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b82e" class="mq lc iq mh b gy mr ms l mt mu">&lt;input <br/>  id="upload" <br/>  ref="upload" <br/>  type="file" <br/>  accept="image/*"<br/>  onChange={(event)=&gt; { <br/>    this.readFile(event) <br/>  }}<br/>  onClick={(event)=&gt; { <br/>    event.target.value = null<br/>  }}<br/>/&gt;</span></pre><p id="7aa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe me mf mg mh b">onChange</code> prop，它采用一个函数来读取文件。</p><p id="e9ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">onClick</code>属性中，我们将文件输入值设置为<code class="fe me mf mg mh b">null</code>。</p><h1 id="730a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将数字传递给组件</h1><p id="4da3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将一个数字传递给一个组件，方法是在花括号中输入一个数字。</p><p id="87bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5cfa" class="mq lc iq mh b gy mr ms l mt mu">Rectangle width={10} height={20} /&gt;</span></pre><h1 id="9351" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">React路由器中不同的路由路径使用相同的组件</h1><p id="660a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过将一个数组传入到<code class="fe me mf mg mh b">path</code>属性中，为不同的路由使用相同的组件。</p><p id="8f4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c125" class="mq lc iq mh b gy mr ms l mt mu">&lt;Route exact path={["/add", "/edit"]}&gt;<br/>  &lt;User /&gt;<br/>&lt;/Route&gt;</span></pre><h1 id="288f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Yup中的条件验证</h1><p id="a78d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">when</code>方法用Yup验证一个字段的条件性。</p><p id="1798" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="35ac" class="mq lc iq mh b gy mr ms l mt mu">validationSchema={yup.object().shape({<br/>  showName: yup.boolean(),<br/>  name: yup<br/>    .string()<br/>    .when("showName", {<br/>      is: true,<br/>      then: yup.string().required("name is required")<br/>    })<br/>  })<br/>}</span></pre><p id="cf0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe me mf mg mh b">showName</code>布尔字段。</p><p id="892f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只在<code class="fe me mf mg mh b">is</code>字段中显示的<code class="fe me mf mg mh b">true</code>时验证<code class="fe me mf mg mh b">name</code>字段。</p><p id="2ebc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">then</code>让我们只在<code class="fe me mf mg mh b">showName</code>为<code class="fe me mf mg mh b">true</code>时进行验证。</p><p id="1774" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是，我们就返回<code class="fe me mf mg mh b">'name is required'</code>消息。</p><h1 id="0cbf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">“修复”失败的表单属性类型:您向没有onChange处理程序的表单字段提供了选中的属性。警告</h1><p id="8d40" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要修复这个警告，我们可以在创建控制器组件时添加带有值的<code class="fe me mf mg mh b">checked</code>属性。</p><p id="73a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ab2b" class="mq lc iq mh b gy mr ms l mt mu">&lt;input<br/>  type="checkbox"<br/>  checked={this.props.checked}<br/>  onChange={this.onChange} <br/>/&gt;</span></pre><p id="cdfa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它是一个不受控制的组件，我们可以编写填充<code class="fe me mf mg mh b">defaultChecked</code>属性:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="00f6" class="mq lc iq mh b gy mr ms l mt mu">&lt;input<br/>  type="checkbox"<br/>  defaultChecked={this.props.checked} <br/>/&gt;</span></pre><h1 id="1fe4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">仅允许在React中输入数字</h1><p id="dde6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将pattern属性设置为regex字符串，以便将输入限制为数字。</p><p id="f7e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="48a4" class="mq lc iq mh b gy mr ms l mt mu">&lt;input type="text" pattern="[0-9]*" onInput={this.handleChange.bind(this)} value={this.state.goal} /&gt;</span></pre><p id="225e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们指定了模式，并听取了<code class="fe me mf mg mh b">inpurt</code> pro。</p><p id="ae67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么在<code class="fe me mf mg mh b">handleChange</code>方法中，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="60bb" class="mq lc iq mh b gy mr ms l mt mu">handleChange(evt) {<br/>  const goal = (evt.target.validity.valid) ? <br/>  evt.target.value : this.state.goal;<br/>  this.setState({ goal });<br/>}</span></pre><p id="d7af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只设置状态，如果它是有效的，那么我们不会在状态中得到任何无效的输入。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/a1cbac5650e71078fc77751096ff6033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TWTEfeoeCQM2WRZE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@keebarber?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Keenan Barber</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0177" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="2b86" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在输入处理程序中检查输入的有效性。</p><p id="49d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们不必显式地将<code class="fe me mf mg mh b">true</code>传递给一个道具。</p><p id="0066" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">错误边界组件有特殊的钩子，我们可以在错误发生时运行代码。</p><h2 id="cfa2" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="fce6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>