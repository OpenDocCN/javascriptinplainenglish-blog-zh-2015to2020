<html>
<head>
<title>Using TypeScript in React Context</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React上下文中使用TypeScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-typescript-in-react-context-3912472b933?source=collection_archive---------5-----------------------#2020-02-05">https://javascript.plainenglish.io/using-typescript-in-react-context-3912472b933?source=collection_archive---------5-----------------------#2020-02-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="598c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TypeScript席卷了JavaScript社区。曾经是无类型的编程语言，现在，通过仔细的思考，有了类型。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/2ce7bf33a9f1e7b581dd44ba499975e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k2sHPi-_oKZNsM7hoz8xPg.jpeg"/></div></div></figure><p id="3b50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文引用了这个repo，它有一个使用TypeScript在应用程序中创建React上下文的完整示例:</p><div class="ku kv gp gr kw kx"><a href="https://gitlab.com/sundry/react/material-ui-dark-mode" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd io gy z fp lc fr fs ld fu fw im bi translated">杂项/反应/材质-界面-深色-模式</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">材质UI黑暗模式</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">gitlab.com</p></div></div><div class="lg l"><div class="lh l li lj lk lg ll ks kx"/></div></div></a></div><p id="ace8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TypeScript可以接受普通的JavaScript并定义类型，这使得它在工具、调试和可读性方面非常出色。</p><p id="3136" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们将使用React上下文并添加TypeScript，这样我们就知道在整个应用程序中可以使用什么。</p><pre class="kj kk kl km gt lm ln lo lp aw lq bi"><span id="6a4f" class="lr ls in ln b gy lt lu l lv lw">interface ContextProps {<br/>  darkMode: boolean;<br/>  setDarkMode(darkMode: boolean): void;<br/>}</span><span id="c23c" class="lr ls in ln b gy lx lu l lv lw">const Context = React.createContext&lt;ContextProps&gt;({<br/>  darkMode: false,<br/>  setDarkMode: () =&gt; {},<br/>});</span></pre><p id="8952" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，让我们创建一个React上下文，它将接受一个名为ContextProps的TypeScript接口。这个接口将包括一个布尔darkMode和一个名为setDarkMode的setter函数。</p><p id="46f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，通过将ContextProps添加到上下文中，它将使我们能够知道我们的上下文中包含哪些变量。</p><pre class="kj kk kl km gt lm ln lo lp aw lq bi"><span id="0ae0" class="lr ls in ln b gy lt lu l lv lw">interface Props {<br/>  children?: React.ReactNode;<br/>}</span><span id="0dd0" class="lr ls in ln b gy lx lu l lv lw">const Provider: React.FC&lt;Props&gt; = ({ children }) =&gt; {<br/>  const [darkMode, setDarkMode] = useLocalStorage('darkMode', false);<br/>  return (<br/>    &lt;Context.Provider<br/>      value={{<br/>        darkMode,<br/>        setDarkMode,<br/>      }}<br/>    &gt;<br/>    {children}<br/>  &lt;/Context.Provider&gt;<br/> );<br/>};</span></pre><p id="c344" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在，我们将创建带有TypeScript接口的上下文提供程序，该接口只有React children属性。</p><p id="1924" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，让我们导出组件:</p><pre class="kj kk kl km gt lm ln lo lp aw lq bi"><span id="828a" class="lr ls in ln b gy lt lu l lv lw">export const useStore = () =&gt; useContext(Context);</span><span id="923b" class="lr ls in ln b gy lx lu l lv lw">export function withProvider(Component: any) {<br/>  return function WrapperComponent(props: any) {<br/>    return (<br/>      &lt;Provider&gt;<br/>        &lt;Component {...props} /&gt;<br/>      &lt;/Provider&gt;<br/>    );<br/>  };<br/>}</span><span id="3576" class="lr ls in ln b gy lx lu l lv lw">export { Context, Provider };</span></pre><p id="6e30" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">useStore导出只是一个助手函数，我们可以在任何子组件中使用它。</p><p id="4ab1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">withProvider是一个助手函数，它可以将上下文提供者巧妙地包装在任何组件周围。</p><p id="de5a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过向React添加TypeScript，我们可以轻松地阅读和理解应用程序可以使用的上下文。</p><p id="5277" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你需要温习你的打字稿，你可以看看这个链接:</p><div class="ku kv gp gr kw kx"><a href="https://www.typescriptlang.org/docs/home.html" rel="noopener  ugc nofollow" target="_blank"><div class="ky ab fo"><div class="kz ab la cl cj lb"><h2 class="bd io gy z fp lc fr fs ld fu fw im bi translated">已经熟悉TypeScript了？</h2><div class="le l"><h3 class="bd b gy z fp lc fr fs ld fu fw dk translated">编辑描述</h3></div><div class="lf l"><p class="bd b dl z fp lc fr fs ld fu fw dk translated">www.typescriptlang.org</p></div></div></div></a></div><p id="1ece" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">打字愉快！！！</p></div></div>    
</body>
</html>