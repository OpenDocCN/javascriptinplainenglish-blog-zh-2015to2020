<html>
<head>
<title>Increasing promise performance with pending-promise-recycler</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过待定承诺回收器提高承诺绩效</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/increasing-promise-performance-with-pending-promise-recycler-52fe6e65d545?source=collection_archive---------12-----------------------#2020-10-21">https://javascript.plainenglish.io/increasing-promise-performance-with-pending-promise-recycler-52fe6e65d545?source=collection_archive---------12-----------------------#2020-10-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="bace" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">JavaScript中最快的承诺是已经解决的承诺！</h2></div><p id="0bb4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">npm包<a class="ae ky" href="http://npmjs.com/package/pending-promise-recycler" rel="noopener ugc nofollow" target="_blank">未决承诺回收器</a>跟踪处于未决状态的承诺；这意味着尚未兑现的承诺。</p><p id="020b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果有人试图创建这些待定承诺之一的新实例，待定承诺回收器将<strong class="ke io">重用当前待定的<strong class="ke io">而不是不必要地创建一个重复的</strong>。</strong></p><h1 id="1a3b" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">如何使用待定承诺回收器？</h1><p id="981e" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">简单地用pending-promise-recycler包装任何返回承诺的函数:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="2e7c" class="mf la in mb b gy mg mh l mi mj">const <strong class="mb io">recycle</strong> = require('pending-promise-recycler');</span><span id="aaad" class="mf la in mb b gy mk mh l mi mj">const func = () =&gt; { return Promise.resolve(); }<br/>const <em class="ml">recycledFunc</em> = <strong class="mb io">recycle</strong>(func);</span><span id="a401" class="mf la in mb b gy mk mh l mi mj"><em class="ml">recycledFunc</em>().then(...);</span></pre><p id="a160" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">对</strong> <code class="fe mm mn mo mb b"><strong class="ke io">recycledFunc</strong></code> <strong class="ke io">的任何额外调用在它仍处于挂起状态时不会导致对</strong> <code class="fe mm mn mo mb b"><strong class="ke io">func</strong></code>的额外调用；相反，未决承诺将被回收并在任何后续调用中再次使用。</p><h1 id="336a" class="kz la in bd lb lc ld le lf lg lh li lj jt lk ju ll jw lm jx ln jz lo ka lp lq bi translated">快速应用程序的实际例子</h1><p id="fa39" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">让我们看一个更现实的例子。下面的代码片段显示了一个简单的express服务器，该服务器带有一个调用非常慢且昂贵的函数的端点:</p><figure class="lw lx ly lz gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="f39c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们调用这个端点，函数<code class="fe mm mn mo mb b">someSlowAndExpensiveOperation</code>将被调用一次。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="8ce2" class="mf la in mb b gy mg mh l mi mj">🍕 node index.js &amp;<br/>[1] 81740<br/>Express server up and running!</span><span id="7573" class="mf la in mb b gy mk mh l mi mj">✦ 🍕 curl <a class="ae ky" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/</a><br/>Starting a very slow operation!<br/>Slow operation is over!<br/>{"foo":"bar"}<br/>Request: 1517.251ms</span></pre><p id="ae50" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是如果我们同时发出10，000个呼叫，我们也会呼叫<code class="fe mm mn mo mb b">someSlowAndExpensiveOperation</code> 10，000次！即使我们缓存了操作的第一个响应，我们仍然会调用<code class="fe mm mn mo mb b">func</code> 10，000次，因为在第二个请求到达时，缓存的响应还没有出现！</p><h2 id="317d" class="mf la in bd lb ms mt dn lf mu mv dp lj kl mw mx ll kp my mz ln kt na nb lp nc bi translated">使用待定承诺回收器改进我们的快递应用程序</h2><p id="0b53" class="pw-post-body-paragraph kc kd in ke b kf lr jo kh ki ls jr kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">如果我们回收<code class="fe mm mn mo mb b">someSlowAndExpensiveOperation</code>会发生什么？让我们来看看以下改进版的express应用程序:</p><figure class="lw lx ly lz gt mp"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="4380" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在正在回收缓慢而昂贵的操作。</p><p id="3b4d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们使用<code class="fe mm mn mo mb b">apache-bench</code>向我们的应用程序发出5个并发请求…</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b1b0" class="mf la in mb b gy mg mh l mi mj">🍕 ab -n 5 -c 5 -k <a class="ae ky" href="http://localhost:3000/" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/</a></span></pre><p id="1ad5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的应用程序日志将如下所示:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="937a" class="mf la in mb b gy mg mh l mi mj">&gt;&gt;&gt; Incoming request<br/><strong class="mb io">Starting a very slow operation!</strong><br/>&gt;&gt;&gt; Incoming request<br/>&gt;&gt;&gt; Incoming request<br/>&gt;&gt;&gt; Incoming request<br/>&gt;&gt;&gt; Incoming request<br/><strong class="mb io">Slow operation is over!</strong><br/>&lt;&lt;&lt; Outgoing response<br/>&lt;&lt;&lt; Outgoing response<br/>&lt;&lt;&lt; Outgoing response<br/>&lt;&lt;&lt; Outgoing response<br/>&lt;&lt;&lt; Outgoing response</span></pre><p id="7914" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">我们用函数</strong> <code class="fe mm mn mo mb b"><strong class="ke io">someSlowAndExpensiveOperation</strong></code>中的一个承诺解析来响应所有这些并发请求，而不是重复调用这个函数5次。</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><figure class="lw lx ly lz gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="nl nm di nn bf no"><div class="gh gi nk"><img src="../Images/6bd4bfd6420709fb5190709f1b6b0ae5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bKRsevrzzD9rxL-I9lJFkA.png"/></div></div></figure><p id="d9bf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模块待定承诺回收器在<a class="ae ky" href="https://www.npmjs.com/package/pending-promise-recycler" rel="noopener ugc nofollow" target="_blank"> npm </a>和<a class="ae ky" href="https://www.npmjs.com/package/pending-promise-recycler" rel="noopener ugc nofollow" target="_blank"> GitHub </a>中可用。</p><p id="61da" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">非常欢迎投稿和问题报告！</p></div></div>    
</body>
</html>