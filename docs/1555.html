<html>
<head>
<title>JavaScript Interview Questions — Objects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript面试问题—对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-interview-questions-objects-e380395dffff?source=collection_archive---------4-----------------------#2020-03-31">https://javascript.plainenglish.io/javascript-interview-questions-objects-e380395dffff?source=collection_archive---------4-----------------------#2020-03-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6339ecea0fe427702384217ce8ca8ef1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bnjswy7wx8pYJkfS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@borisworkshop?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Boris Smokrovic</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="aae3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了得到一份前端开发人员的工作，我们需要搞定编码面试。</p><p id="4750" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看一些宾语问题。</p><h1 id="58b9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何检查某个属性是否存在于对象中？</h1><p id="2d27" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有几种方法可以检查对象中是否存在属性。</p><p id="1526" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们可以使用<code class="fe me mf mg mh b">in</code>操作符。例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8588" class="mq lc iq mh b gy mr ms l mt mu">const foo = { a: 1 };<br/>console.log('a' in foo);</span></pre><p id="2edc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">in</code>操作符检查给定名称的属性是否存在于对象本身或原型链中的原型中。</p><p id="045f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码应该返回<code class="fe me mf mg mh b">true</code>，因为<code class="fe me mf mg mh b">a</code>是<code class="fe me mf mg mh b">foo</code>的属性。</p><p id="250b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">console.log(‘toString’ in foo);</code>也应该记录<code class="fe me mf mg mh b">true</code>，因为<code class="fe me mf mg mh b">toString</code>在<code class="fe me mf mg mh b">Object</code>的原型中，而<code class="fe me mf mg mh b">foo</code>继承了它。</p><p id="e226" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用<code class="fe me mf mg mh b">Object.prototype.hasOwnProperty</code>方法。例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="854f" class="mq lc iq mh b gy mr ms l mt mu">const foo = { a: 1 };<br/>console.log(foo.hasOwnProperty('a'));</span></pre><p id="25c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码使用了<code class="fe me mf mg mh b">foo</code>原型中的<code class="fe me mf mg mh b">hasOwnProperty</code>方法来检查<code class="fe me mf mg mh b">a</code>是否存在于<code class="fe me mf mg mh b">foo</code>及其自身属性中，也就是说它存在于<code class="fe me mf mg mh b">foo</code>本身而不是其原型中。</p><p id="722e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe me mf mg mh b">a</code>是<code class="fe me mf mg mh b">foo</code>自己的财产，所以<code class="fe me mf mg mh b">console.log</code>记录<code class="fe me mf mg mh b">true</code>。</p><p id="726b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以使用括号符号进行检查，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f0f2" class="mq lc iq mh b gy mr ms l mt mu">const foo = {<br/>  a: 1<br/>};<br/>console.log(foo['a']);</span></pre><p id="a939" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它返回的不是<code class="fe me mf mg mh b">undefined</code>的值，那么我们知道我们把它作为一个属性添加了。</p><p id="de20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然我们的例子就是这样，它应该返回<code class="fe me mf mg mh b">true</code>。</p><h1 id="8bbd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">Object.seal</code>和<code class="fe me mf mg mh b">Object.freeze</code>的方法有什么区别？</h1><p id="8e5b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在对象上调用<code class="fe me mf mg mh b">Object.seal</code>之后，我们停止向对象添加属性。</p><p id="5889" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还使所有现有属性不可配置，这意味着属性描述符被阻止更改。</p><p id="63fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在对象上调用了<code class="fe me mf mg mh b">delete</code>操作符之后，现有的属性也不能被删除。</p><p id="cc36" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对象的属性<code class="fe me mf mg mh b">__proto__</code>是对象的原型，也是密封的。</p><p id="1532" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1b9d" class="mq lc iq mh b gy mr ms l mt mu">const foo = {<br/>  a: 1<br/>};<br/>Object.seal(foo);<br/>delete foo.a</span></pre><p id="c4ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">跑完最后一行我们还会看到<code class="fe me mf mg mh b">foo.a</code>。</p><p id="1a5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在严格模式下，我们会得到一个错误。</p><p id="2fa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Object.freeze</code>使对象不可变。不能以任何方式更改现有属性，包括每个属性的值。</p><p id="28cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也做<code class="fe me mf mg mh b">Object.seal</code>所做的一切。</p><h1 id="29b6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象中的<code class="fe me mf mg mh b">in</code>操作符和<code class="fe me mf mg mh b">hasOwnProperty</code>方法有什么区别？</h1><p id="b82c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">in</code>操作符检查一个属性是否在对象本身中，以及它是否在原型链上的原型中。</p><p id="e699" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，<code class="fe me mf mg mh b">hasOwnProperty</code>只检查一个对象是否在它所调用的对象内部，而不检查它的任何原型。</p><h1 id="a2df" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么<code class="fe me mf mg mh b">typeof null</code>会返回<code class="fe me mf mg mh b">object</code>？</h1><p id="8e8e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">null</code>拥有类型<code class="fe me mf mg mh b">object</code>,因为这是它在早期版本的JavaScript中的行为方式。它只是保持这种方式，以防止破坏现有的代码库。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/53d6b141b4e9c74a71ff1c21458ea379.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QFcFBsGe6poWeYfE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@roi_dimor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Roi Dimor</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="18e5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何检查一个值是否为<code class="fe me mf mg mh b">null</code>？</h1><p id="1365" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使用严格的等式运算符来检查<code class="fe me mf mg mh b">null</code>，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a8e1" class="mq lc iq mh b gy mr ms l mt mu">foo === null</span></pre><h1 id="bc2d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">new</code>关键字是做什么的？</h1><p id="a3dc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">new</code>关键字用于从构造函数或类创建一个对象。</p><p id="bb27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有一个<code class="fe me mf mg mh b">Person</code>类:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c0ad" class="mq lc iq mh b gy mr ms l mt mu">function Person(firstName, lastName) {<br/>  this.firstName = firstName;<br/>  this.lastName = lastName;<br/>};</span></pre><p id="8400" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过编写以下内容来创建它的新实例:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="581a" class="mq lc iq mh b gy mr ms l mt mu">const person = new Person("Jane", "Smith");</span></pre><p id="cf19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">new</code>做几件事:</p><ul class=""><li id="e21d" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">它创建一个空对象</li><li id="253e" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">将空对象分配给<code class="fe me mf mg mh b">this</code>值</li><li id="e41c" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">该函数继承自构造函数的<code class="fe me mf mg mh b">prototype</code>属性。所以<code class="fe me mf mg mh b">Person</code>继承了<code class="fe me mf mg mh b">Person.prototype</code>。</li><li id="9552" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">如果函数中没有<code class="fe me mf mg mh b">return</code>语句，那么它将返回<code class="fe me mf mg mh b">this</code>。</li></ul><p id="30c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，ES2015或更高版本中的类语法只是构造函数的语法糖。它做同样的事情，但看起来像一个类。</p><h1 id="2f5d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d316" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">in</code>操作符、<code class="fe me mf mg mh b">hasOwnProperty</code>或括号符号来检查对象中是否存在属性。</p><p id="d18e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Object.seal</code>防止属性描述符改变和属性被删除。</p><p id="9fec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使一个对象不可变。</p><p id="58c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">null</code>属于<code class="fe me mf mg mh b">object</code>类型，而不是拥有自己的类型。</p><p id="0b44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关键字从构造函数中创建一个新的对象并返回它。</p><p id="3953" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">【JavaScript用简单的英语写的一句话:我们总是乐于帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的中级用户名发邮件到submissions@javascriptinplainenglish.com<a class="ae kc" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">给我们，我们会把你添加为作者。</a></p></div></div>    
</body>
</html>