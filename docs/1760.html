<html>
<head>
<title>Why you should generally prefer TypeScript interfaces and custom types over classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么您通常更喜欢TypeScript接口和自定义类型而不是类</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-you-should-generally-prefer-typescript-interfaces-and-custom-types-over-classes-d145814218ce?source=collection_archive---------3-----------------------#2020-04-20">https://javascript.plainenglish.io/why-you-should-generally-prefer-typescript-interfaces-and-custom-types-over-classes-d145814218ce?source=collection_archive---------3-----------------------#2020-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="af25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在任何新项目中，您首先要做的事情之一就是领域模型，它是所有应用程序的核心。无论您做什么，您都将创建和操作大量属于<em class="kl">域模型</em>的对象。</p><p id="a42c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这样做的时候，一个重要的设计决策是你是否将使用类、接口/自定义类型(或者它们的混合)来表示域模型。</p><p id="5e45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">拥有Java/C#背景，当我在2016年第一次一头扎进TypeScript时，我最初的预感是大量使用类。然而四年后，我改变了主意。</p><p id="7356" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我目前的项目中，整个领域模型仅使用接口和类型/映射类型来定义，我真的不后悔这个选择。</p><p id="614e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在不要曲解这篇文章；我并不是说应该完全禁止上课。我所争论的是这样一个事实，我们实际上可以在很多情况下避免使用类，而不会损失太多。</p><p id="0e4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们从几个方面来讨论这个(真正有影响力的)选择的利弊。</p><h1 id="f18e" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">OOP(s)</h1><p id="07e7" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我反对为您的领域模型使用类的第一点是，尝试并避免在类似Java的项目中经常出现的面向对象编程(OOP)的复杂性废话(至少我亲眼目睹过)。</p><p id="c78d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">具有很强的面向对象背景的人往往会时不时地对OOP结构着迷。他们喜欢创建复杂的继承链，覆盖方法，做各种稀奇古怪的事情。</p><p id="7e30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这很好，而且真的很有益，但是通常这是糟糕设计的根源，并产生了许多可怕的怪物，同时吹嘘所有正在使用的好的GoF模式；好像这是某种清单“必须全部使用！”。</p><p id="32fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">俗话说:宁要作文不要继承。如果你限制了类的使用，那么你就摆脱了一整类的设计问题。</p><p id="a821" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，当不使用类时，你会错过的一件事是封装。保持内部/私有状态的想法很好，如果你完全摆脱了类，你可能会错过它；现在，EcmaScript私有成员已经登陆，尽管使用了“#”而不是更好的名称。</p><h1 id="2457" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">序列化/反序列化</h1><p id="656f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">当您正在构建一个与一些后端公开REST、GraphQL(或任何其他类型的API)交互的多层应用程序时，您将执行常见的创建/检索/更新/删除(即CRUD)操作。</p><p id="5431" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，当您想要检索元素列表时，您必须调用后端API来获取数据。当你这样做的时候，你会得到一个你想要的数据的表示，通常是在JSON中:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="4127" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来的问题是如何在客户端表示这些数据(例如，您将什么设置为？？?"在上面的例子中——<em class="kl">任何</em>都是大忌)。</p><p id="6b24" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您决定使用类来表示您的数据模型，那么您必须将接收到的JSON数据反序列化(即转换)成您的类的实例；那就是:</p><ul class=""><li id="a3de" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">解析返回的原始JSON数据</li><li id="ffdb" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">将产生的对象转换成类实例，要么手工<em class="kl">新建</em>这些实例，要么使用其他方法</li></ul><p id="9e6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一件你可以用不同方式去做的事情。例如，你<em class="kl">可以</em>去“像兰博一样”和<a class="ae mk" href="https://stackoverflow.com/questions/29758765/json-to-typescript-class-instance" rel="noopener ugc nofollow" target="_blank">手动转换使用自制的实用功能</a>(请不要)。或者你可以使用更优雅/可靠的库，如<a class="ae mk" href="https://github.com/weichx/cerialize" rel="noopener ugc nofollow" target="_blank"> cerialize </a>或<a class="ae mk" href="https://github.com/typestack/class-transformer" rel="noopener ugc nofollow" target="_blank"> class-transformer </a>。</p><p id="2146" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那些库非常相似；您通常可以修饰您的类/字段(如果您愿意),然后使用实用程序方法从类实例转换到JSON，或者相反。</p><p id="946c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，对于class-transformer，您可以这样做:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="lu lv l"/></div></figure><p id="8747" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，plainToClass实用函数将返回类实例。在我关于TypeScript的书<a class="ae mk" href="https://www.amazon.com/Learn-TypeScript-Building-Applications-understanding-ebook/dp/B081FB89BL" rel="noopener ugc nofollow" target="_blank">中，我用了相当多的篇幅来解释如何使用这些库。</a></p><p id="bf19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，NestJS似乎偏爱类，因为它提供的多个特性依赖于类:<a class="ae mk" href="https://docs.nestjs.com/techniques/serialization" rel="noopener ugc nofollow" target="_blank">https://docs.nestjs.com/techniques/serialization</a>。</p><p id="cf85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">缺点是你必须花费时间和精力来装饰你的类，并且一直在考虑那些转换。那里的事情时不时会变得棘手。例如，如果您在数据模型中使用泛型，或者想要使用特定的构造函数、带有访问器的私有字段、继承和多态性，那么这些库往往需要特定的知识和大量的摆弄。</p><p id="56ed" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，假设您想要使用不可变的数据结构(向您致敬！)，那么您应该只允许通过构造函数初始化数据，而不允许任何修改；你如何处理像cerialize和class-transformer这样的库呢？提示:你没有。</p><p id="b93f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我只想说:有无数的边缘案例和陷阱可以落入其中。如果你不幸仍然需要瞄准ES5，那就更糟了…</p><p id="8943" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，如果您只是简单地定义接口/自定义类型，那么您可以简单地解析收到的JSON(例如，使用JSON.parse(…))并继续您的生活；不需要转换，没有黑暗魔法。向后端发送数据时也是如此。</p><p id="2c40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，无论您使用类还是简单的接口/类型，您最好确保您正确地验证了您接收的数据确实具有您期望的“形状”。为此，你可以利用诸如<a class="ae mk" href="https://github.com/gcanti/io-ts" rel="noopener ugc nofollow" target="_blank"> io-ts </a>之类的库(我的书中也有涉及)，这使得验证/确保你收到的东西确实具有预期的<em class="kl">形状</em>变得简单。这真的很强大，我可能会写一篇文章来演示这一点。</p><p id="0f75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，有利也有弊，因为让类只序列化您在客户端使用的数据结构的一部分会让您受益。不过，使用接口和自定义类型以类型安全的方式实现这一点也是可能的。例如，您可以使用<a class="ae mk" href="https://mariusschulz.com/blog/mapped-types-in-typescript" rel="noopener ugc nofollow" target="_blank">映射类型</a>轻松定义和使用派生类型来满足这种需求。</p><p id="a796" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我想在这里传达的信息是，类比简单地解析/字符串化JSON数据/JavaScript对象更“昂贵”和“复杂”(所有事情都是相对的)。</p><p id="888f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">领域驱动设计(DDD) 狂热爱好者可能不喜欢我在这里看待事物的方式，但是我真的更喜欢避免不必要的转换。现代Web技术栈已经足够复杂，因为它不需要添加新的间接层。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="ff92" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">确认</h1><p id="0df6" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">使用TS类的一个很酷的事情是，你可以使用像<a class="ae mk" href="https://github.com/typestack/class-validator" rel="noopener ugc nofollow" target="_blank"> class-validator </a>这样的库来修饰东西。例如，NestJS <a class="ae mk" href="https://docs.nestjs.com/techniques/validation" rel="noopener ugc nofollow" target="_blank">支持开箱即用</a>。</p><p id="148a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">就序列化而言，正如我上面所说的，我认为它比任何东西都更增加了复杂性。但是在验证的情况下，这可能很好，因为它允许将数据结构的定义和它们的验证规则放在一起。</p><p id="6cdc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，当处理接口和自定义类型时，您只能以某种形式将这些验证规则存储在其他地方。</p><p id="216f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，你可以依靠编译器来帮助你确保你没有误用类型。如果你在项目中输入东西时足够严格，编译器不会让你做傻事。仅此一点就几乎消除了问题。但是，这仅包括基本的验证，例如“这个字段是否存在，它的类型是否正确”。</p><p id="7024" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于更复杂的验证规则(例如，开始日期在结束日期之前)，您只能靠自己了。对于这些，你可以想象不同的方法。</p><p id="6fef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一个是函数式编程，您可以定义简单的验证例程，以便在需要时重用。这通常很有效，而且也不难实现。一个好处是它是类型安全的，易于测试和维护。为了以这种方式实现验证，您可以利用像<a class="ae mk" href="https://github.com/gcanti/fp-ts" rel="noopener ugc nofollow" target="_blank"> fp-ts </a>这样的库。</p><p id="9aca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一种方法是仍然利用class-validator，它提供了“ValidationSchema”类型，允许您在代码或JSON文件中定义<a class="ae mk" href="https://github.com/typestack/class-validator#defining-validation-schema-without-decorators" rel="noopener ugc nofollow" target="_blank">一个验证模式</a> (heh)，并在以后使用该模式通过“validate”方法来验证对象。</p><p id="b531" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个来自他们文档的例子:</p><pre class="lp lq lr ls gt mx my mz na aw nb bi"><span id="11a7" class="nc kn iq my b gy nd ne l nf ng">import {ValidationSchema} from "class-validator";<br/>export let UserValidationSchema: ValidationSchema = { // using interface here is not required, its just for type-safety<br/>    name: "myUserSchema", // this is required, and must be unique<br/>    properties: {<br/>        firstName: [{<br/>            type: "minLength", // validation type. All validation types are listed in ValidationTypes class.<br/>            constraints: [2]<br/>        }, {<br/>            type: "maxLength",<br/>            constraints: [20]<br/>        }],<br/>        lastName: [{<br/>            type: "minLength",<br/>            constraints: [2]<br/>        }, {<br/>            type: "maxLength",<br/>            constraints: [20]<br/>        }],<br/>        email: [{<br/>            type: "isEmail"<br/>        }]<br/>    }<br/>};</span><span id="db4f" class="nc kn iq my b gy nh ne l nf ng">...</span><span id="f3a8" class="nc kn iq my b gy nh ne l nf ng">// Validation<br/>import {validate} from "class-validator";<br/>const user = { firstName: "Johny", secondName: "Cage", email: "johny@cage.com" };<br/>validate("myUserSchema", user).then(errors =&gt; {<br/>    if (errors.length &gt; 0) {<br/>        console.log("Validation failed: ", errors);<br/>    } else {<br/>        console.log("Validation succeed.");<br/>    }<br/>});</span></pre><p id="e453" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你在上面看到的，这非常简单，但是有一个<em class="kl">主要的</em>缺点:它与你的域模型接口/定制类型完全断开。对我来说，这确实是个问题，因为它很难维护。</p><p id="3c7f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后一种方法，我倾向于选择本文中的方法:定义JSON模式，并使用<a class="ae mk" href="https://github.com/epoberezkin/ajv" rel="noopener ugc nofollow" target="_blank"> ajv </a>、<a class="ae mk" href="https://github.com/bcherny/json-schema-to-typescript" rel="noopener ugc nofollow" target="_blank">JSON-schema-to-TypeScript</a>和类型保护将这些模式与TypeScript类型紧密联系起来。另一个我还没有尝试过的候选是<a class="ae mk" href="https://github.com/ostrowr/ts-json-validator" rel="noopener ugc nofollow" target="_blank"> ts-json-validator </a>。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="c59f" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">不变</h1><p id="2814" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">甚至在开始使用TypeScriptFor之前，我就已经在我的设计中倾向于不变性。我不会详细介绍使用不可变对象和不可变数据结构的许多优点，但可以说有很多优点。</p><p id="549b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在TypeScript中，定义不可变类非常简单；您可以在字段上使用<a class="ae mk" href="https://www.typescriptlang.org/docs/handbook/classes.html#readonly-modifier" rel="noopener ugc nofollow" target="_blank"> <em class="kl"> readonly </em> </a>修饰符，只公开get访问器。readonly修饰符很酷的一点是，您可以将它用于字段、索引签名等。</p><p id="9c8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您还可以利用ReadonlyArray、ReadonlyMap等数据结构。最后两个是它们的非只读变体的超类型；提供方法的子集，并在试图修改数据时抛出错误。</p><p id="dc25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管这些不是防弹的；举个例子，readonly，Readonly<t class="ae mk" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#a-new-syntax-for-readonlyarray" rel="noopener ugc nofollow" target="_blank">Readonly array&lt;T&gt;，Readonly mapK，T &gt;之类的都是<strong class="jp ir">仅限编译时的限制</strong>。没有什么可以阻止运行时修改的发生。虽然这通常不是一个重要的问题，但是也不经常需要运行时不变性..</t></p><p id="a942" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当使用接口和自定义类型并用相关类型标记对象时，您不能做那么多来保护您的数据免受突变。但是还是有解决办法的。</p><p id="1601" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先想到的是<a class="ae mk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" rel="noopener ugc nofollow" target="_blank"> Object.freeze </a> API，它可以<em class="kl">部分</em>冻结一个对象。我之所以强调这一点，部分是因为，不幸的是，它只冻结了顶级属性，使得嵌套的对象/属性可变。</p><p id="9598" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有像<a class="ae mk" href="https://immutable-js.github.io/immutable-js/" rel="noopener ugc nofollow" target="_blank"> ImmutableJS </a>这样的库，但是我真的不喜欢它，因为它们不适合与TypeScript一起使用。</p><p id="ec9e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，您可以使用和组合其他方法来在您的系统中推进不变性。首先，您可以使用spread语法来提取数据并创建新的&amp;“隔离的”引用。</p><p id="fd82" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您可以使用的另一个很酷的特性是TS 3.4中引入的<a class="ae mk" href="https://mariusschulz.com/blog/const-assertions-in-literal-expressions-in-typescript" rel="noopener ugc nofollow" target="_blank"> const assertions </a>，它有效地允许创建尽可能多的只读类型。</p><p id="b875" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个例子:</p><pre class="lp lq lr ls gt mx my mz na aw nb bi"><span id="d1ef" class="nc kn iq my b gy nd ne l nf ng">const example = {<br/>  name: 'JohnDoe',<br/>  isHereToStay: true,<br/>  mother: {<br/>    name: 'JaneDoe',<br/>  },<br/>} as const;</span></pre><p id="0b67" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">以上基本上被转换成这种类型:</p><pre class="lp lq lr ls gt mx my mz na aw nb bi"><span id="a20a" class="nc kn iq my b gy nd ne l nf ng">{<br/>  readonly name: 'JohnDoe';<br/>  readonly isHereToStay: true;<br/>  readonly mother: {<br/>    readonly name: 'JaneDoe';<br/>  };<br/>}</span></pre><p id="2ec0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么“as const”在TypeScript中做什么呢？</p><ul class=""><li id="83c4" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">它将字符串之类的原语缩小到精确的文字类型(例如，“JohnDoe”字符串被更改为只能以“JohnDoe”作为值的类型)。</li><li id="4860" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">它将readonly修饰符应用于一切(包括嵌套的数据结构)</li><li id="5858" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">它将数组文字转换成只读元组</li><li id="c0bd" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">(可能还有更多我不知道的)</li></ul><p id="07e5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">基本上，使用“as const”会创建只读类型，不允许对象发生任何变化。是不是很酷？</p><p id="5e91" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于TS 3.7及其新增的对<a class="ae mk" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases" rel="noopener ugc nofollow" target="_blank">递归类型别名</a>的支持，也可以定义和利用这样的类型来确保不变性:</p><pre class="lp lq lr ls gt mx my mz na aw nb bi"><span id="1453" class="nc kn iq my b gy nd ne l nf ng">type Immutable&lt;T&gt; = {<br/>  readonly [K in keyof T]: Immutable&lt;T[K]&gt;;<br/>};</span></pre><p id="edca" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种类型允许有效地将整个数据结构(包括嵌套数据结构)设置为只读。</p><p id="f5af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，无论您使用的是类还是“简单的”接口/自定义类型，您都可以创建不可变的数据结构。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="934b" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">作文</h1><p id="8fe5" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我认为接口和自定义类型的一个主要优点是，您可以根据自己的需要轻松地创建类型的变体。</p><p id="1115" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将很快发表另一篇文章，用一些例子更详细地解释下面的想法，但我已经给了你它的要点。</p><p id="c542" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">假设您从领域模型的核心开始。您有一些实体类型，它们是您将保存在数据存储中的元素类型。这是您的系统处理的数据的规范表示。</p><p id="2c5f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，如果您创建一个公开RESTful API的后端，那么您将需要创建该数据模型的表示。根据您的API的能力，您可以决定只公开信息的一个子集(例如，不公开您的用户的密码散列、他们的出生日期等)。为此，您可以派生类型，我们称之为数据传输对象(dto)。</p><p id="9500" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你只使用类，那么你可能会通过不相交的结构复制类型信息，这意味着无论何时一个类型改变，你都必须<em class="kl">考虑</em>对其他类型的影响，调整它们并处理转换/变换(我们现在已经走了一整圈)。</p><p id="6b47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你是接口/自定义类型，那么你的数据类型更具可塑性。例如，您可以创建一个规范类型来表示将在您的系统中公开和重用的“基本”属性。然后，您可以通过使用内置的<a class="ae mk" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types" rel="noopener ugc nofollow" target="_blank">映射类型</a>来创建变体，例如:</p><ul class=""><li id="a154" class="lw lx iq jp b jq jr ju jv jy ly kc lz kg ma kk mb mc md me bi translated">部分<t>:让T中的类型可选</t></li><li id="fe18" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">Readonly <t>:将T中的类型设为只读</t></li><li id="d3d8" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">挑选<t>:从一个类型中只挑选你需要的</t></li><li id="a300" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">排除<t>:从T中排除可赋给U的类型</t></li><li id="da41" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">省略<t>:只省略你不需要的类型</t></li><li id="50d0" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">提取<t>:从T中提取可分配给U的类型</t></li><li id="bd72" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">不可空<t>:使T中的类型不可空(移除空值)</t></li><li id="e8ee" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi translated">必需的<t>:强制T中的类型</t></li><li id="ba38" class="lw lx iq jp b jq mf ju mg jy mh kc mi kg mj kk mb mc md me bi">…</li></ul><p id="c0ab" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您甚至可以将它们结合起来，创建自己的类型，从而将类型系统推向极限。</p><p id="492b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你也可以使用像<a class="ae mk" href="https://github.com/piotrwitek/utility-types" rel="noopener ugc nofollow" target="_blank"> utility-types </a>这样的库，它提供了大量的实用类型(heh ),比如Primitive、SetIntersection、SetDifference、NonUndefined等等。</p><p id="f8dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可能会说，类也可以在TypeScript中用作接口，实现同样的事情，但是请<a class="ae mk" href="https://www.stevefenton.co.uk/2017/11/typescript-using-classes-interfaces/" rel="noopener ugc nofollow" target="_blank">不要</a>。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="0204" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">有角的</h1><p id="e24f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在角度项目中，我几乎只为我的角度组件控制器使用类，因为这是推荐的方法。</p><p id="d338" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这种情况下，类确实是有意义的。您可以从封装中受益，因为您可以将一些东西保留给控制器本身(不是所有东西都需要向模板公开)。</p><p id="d816" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这允许很好地分离关注点，因为我们需要在控制器中放入逻辑，它必须放在某个地方。</p><p id="fa99" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以不用担心，课程很好。</p><h1 id="ac12" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">反应</h1><p id="5978" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在React项目中，我感觉现在的班级都是老派。它们在过去更强大，但是现在React有了钩子，类就不再有用了。</p><p id="fd66" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我开始一个新的React项目，我可能不会那么频繁地使用类。</p><h1 id="c81b" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">某视频剪辑软件</h1><p id="e599" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">AFAIK，Vue的下一个主要版本将完全用TypeScript编写，也不会使用类。</p></div><div class="ab cl ml mm hu mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ij ik il im in"><h1 id="1c13" class="km kn iq bd ko kp ms kr ks kt mt kv kw kx mu kz la lb mv ld le lf mw lh li lj bi translated">结论</h1><p id="a8c5" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">在这篇文章中，我试图让你相信你可能不需要在你的TypeScript项目中到处使用类。</p><p id="b7e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然类很酷，很强大，并且提供了封装数据和逻辑(甚至在运行时保护数据)的方法，但是它们也受到许多问题(一些人为的，一些技术的)的影响，这些问题往往会增加代码库的复杂性，限制数据模型的表达能力。正如我所解释的，使用类创建规范模型的变体并不有趣，而映射类型却非常强大。</p><p id="7a31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于特定的需求，类仍然是非常相关和非常有用的，但是它们不一定要在系统的中心。</p><p id="550e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，您可以(应该)将类和接口/自定义类型结合起来，以便最大限度地利用TypeScript出色的类型系统。</p><p id="9173" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天到此为止！</p><p id="1ccc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:如果你想学习大量关于TypeScript、Angular、React、Vue和其他酷主题的其他酷东西，那么不要犹豫，去<a class="ae mk" href="https://www.amazon.com/Learn-TypeScript-Building-Applications-understanding-ebook/dp/B081FB89BL" rel="noopener ugc nofollow" target="_blank">拿一本我的书</a>并订阅<a class="ae mk" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">我的简讯</a>！</p></div></div>    
</body>
</html>