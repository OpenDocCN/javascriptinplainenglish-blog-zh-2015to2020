<html>
<head>
<title>Error Handling in React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应组分中的错误处理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/capturing-handling-errors-in-react-component-6bc48d533dd5?source=collection_archive---------6-----------------------#2020-10-31">https://javascript.plainenglish.io/capturing-handling-errors-in-react-component-6bc48d533dd5?source=collection_archive---------6-----------------------#2020-10-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="563b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何捕获错误并在反应中呈现回退组件</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c3b3ef64f1546d95851eea93955b26ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6oHuxp29ey-Cst6ocx5UJg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">componentDidCatch and getDerivedStateFromError in React</figcaption></figure><p id="b9e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">techno漏斗展示了另一篇文章，我们将在其中讨论从组件捕获错误并呈现回退组件(ErrorComponent)的机制，以防组件在呈现时导致某些错误。</p><p id="cdb3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面的文章将讨论以下生命周期事件:</p><ol class=""><li id="eca5" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">使用“<strong class="kx ir">componentdcatch</strong>”</li><li id="c441" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">使用“<strong class="kx ir">GetDeriveStateFromError</strong>”生命周期事件。</li></ol><h1 id="6858" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">了解用例场景…</h1><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">componentDidMount in React, getDerivedStateFromError</figcaption></figure><ol class=""><li id="b1e7" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">创建一个包含输入框的组件“雇员尾巴”</li><li id="a553" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">一旦用户在输入框中键入空格，组件应返回一个错误，表示空格不被接受。</li><li id="5be1" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">部署一种机制，可以跟踪返回的错误</li><li id="4245" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">遇到错误时，组件应该呈现一些“错误组件”而不是“雇员详细信息”组件。</li></ol><h2 id="95f1" class="mz mg iq bd mh na nb dn ml nc nd dp mp le ne nf mr li ng nh mt lm ni nj mv nk bi translated">开始使用员工详细信息组件</h2><p id="31f7" class="pw-post-body-paragraph kv kw iq kx b ky nl jr la lb nm ju ld le nn lg lh li no lk ll lm np lo lp lq ij bi translated">让我们首先创建一个“EmployeeDetails”组件，一旦输入框包含空格，它就会抛出一个错误。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq my l"/></div></figure><p id="ffa6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的组件中，每当我们在输入框中进行更改时，都会调用“updateName”函数。它检查文本框的当前更新值是否包含空格。如果有空格，组件将返回一个错误。由于错误不是句柄，应用程序将崩溃，并出现以下错误“名称不能包含空格”</p><h2 id="b2c7" class="mz mg iq bd mh na nb dn ml nc nd dp mp le ne nf mr li ng nh mt lm ni nj mv nk bi translated">添加使用“组件捕获”跟踪错误的机制</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">React componentDidMount, getDerivedStateFromError</figcaption></figure><p id="c33b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了捕捉错误，我们引入了术语“错误边界”。我们创建了一个组件，它作为一个错误边界，捕获所有子组件将调用的所有错误。让我们假设我们可以有一个名为“雇员尾巴”的组件，它可以根据某个条件抛出一个错误。为了捕获在这个组件内部引起的错误，我们需要创建一个父组件来保存这个容易出错的子组件。</p><p id="b0ad" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们创建一个可以表示为“<strong class="kx ir">错误边界</strong>的组件</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq my l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae nr" href="https://gist.github.com/Mayankgupta688/2f6b1e18af3c30abc8070753e1305ffe" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/2f6b1e18af3c30abc8070753e1305ffe</a></figcaption></figure><p id="8237" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">创建的“错误边界”组件现在可以呈现一些子组件。该类实现了方法“componentDidCatch ”,一旦任何子组件返回一些错误，就会调用该方法。由于在子组件内部引起的所有错误都将在这个方法中被捕获，所以组件可以被看作是一个外部组件，它不会让错误泄漏到它的边界之外。</p><h2 id="178e" class="mz mg iq bd mh na nb dn ml nc nd dp mp le ne nf mr li ng nh mt lm ni nj mv nk bi translated">回退到另一个组件“错误组件”</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ns my l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Error Handling in React</figcaption></figure><p id="092f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果组件返回错误，我们希望组件显示“错误组件”。该组件包含一个标题，表示在使用“雇员尾巴”组件时发生了什么错误。为了在错误期间部署这种回退机制，我们可以实现<strong class="kx ir">“getderivestateformerror”</strong>生命周期事件</p><p id="1b63" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">理解“getDerivedStateFromError”生命周期</strong></p><p id="52ca" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一旦接收到错误，可以使用该生命周期事件来导出新的状态。一旦收到错误，将执行以下生命周期事件，它可以更新上面显示的“ErrorBoundries”组件的状态。我们可以设置“ErrorBoundries”的状态，这样它就可以表示应用程序中的错误情况。一旦状态被更新,“ErrorBoundries”组件将重新呈现，我们可以根据组件状态部署我们的“ErrorComponent”。</p><p id="881a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们扩展上面的<strong class="kx ir"> ErrorBoundries </strong>组件来实现这个…</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nq my l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae nr" href="https://gist.github.com/Mayankgupta688/ed4e7865be5fd26dd7f68296c22e8d57" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/Mayankgupta688/ed4e7865be5fd26dd7f68296c22e8d57</a></figcaption></figure><p id="2b12" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在上面的组件中，我们可以看到我们创建了一个状态变量“hasError”。此变量可用于跟踪子组件内部的错误。“hasError”的初始值被标记为假，因为我们在初始阶段没有任何错误。一旦在“EmployeeDetails”组件上遇到错误，就会调用“getDerivedStateFromError”函数，并将“hasError”的值设置为“true”。</p><p id="7cbb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为组件正在设置新状态，所以组件将重新呈现。在render函数中，我们指定了表示“EmployeeDetails”或“ErrorComponent”是否可见的条件。由于“hasError”的值为true，因此将呈现“ErrorComponent”。在这种情况下，由于错误被处理，应用程序不会中断。要访问代码，请访问以下URL:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt my l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae nr" href="https://codesandbox.io/s/error-boundries-react-kghhd" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/error-boundries-react-kghhd</a></figcaption></figure><ul class=""><li id="040d" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq nu lx ly lz bi translated">*代码需要在生产模式下运行，以显示所需的行为。上面的代码只是一个参考，它不在生产模式下运行。</li></ul><p id="83fa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nv">更多内容尽在</em><a class="ae nr" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir"><em class="nv">plain English . io</em></strong></a></p></div></div>    
</body>
</html>