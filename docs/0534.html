<html>
<head>
<title>Understand JavaScript sequencing and asynchronous behaviors to leverage code parallelism.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript排序和异步行为，以利用代码并行性。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understand-javascript-sequencing-and-asynchronous-behaviors-to-leverage-code-parallelism-1e381fa8d33c?source=collection_archive---------4-----------------------#2019-11-04">https://javascript.plainenglish.io/understand-javascript-sequencing-and-asynchronous-behaviors-to-leverage-code-parallelism-1e381fa8d33c?source=collection_archive---------4-----------------------#2019-11-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="4d21" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Javascript的基础知识</h2><div class=""/><div class=""><h2 id="bb2b" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">关于异步性以及如何利用JS并发模型提高应用程序的性能和响应能力的小指南。</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/60bae74f150d8ffc7b7a7d91e1feabd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eYvN0mutt-ZBE3G73bW7iw.png"/></div></div></figure><p id="b285" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">JavaScript使用的是单线程并发模型，本文将给出一些想法和例子来理解JS中并发的基础。</p><p id="7c91" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们将通过两个演示来研究这一点:第一个是顺序的同步循环执行，然后是并行的异步循环。</p><h1 id="22b2" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">🗓摘要</h1><ol class=""><li id="ade6" class="mo mp iq lc b ld mq lg mr lj ms ln mt lr mu lv mv mw mx my bi translated"><strong class="lc ja"> 🛫线程和并发的基础知识</strong></li><li id="e986" class="mo mp iq lc b ld mz lg na lj nb ln nc lr nd lv mv mw mx my bi translated"><strong class="lc ja">📌JavaScript并发模型和代码并行的异步行为</strong></li><li id="4e87" class="mo mp iq lc b ld mz lg na lj nb ln nc lr nd lv mv mw mx my bi translated"><strong class="lc ja">🚀示例:JavaScript中的异步循环与同步循环</strong></li></ol></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h1 id="6419" class="lw lx iq bd ly lz nl mb mc md nm mf mg kf nn kg mi ki no kj mk kl np km mm mn bi translated">🛫线程和并发基础</h1><p id="3a01" class="pw-post-body-paragraph la lb iq lc b ld mq ka lf lg mr kd li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated"><strong class="lc ja">简短扼要:</strong>使用C或Java等传统语言时，有时你会做一些需要CPU计算时间的事情。</p><p id="3d38" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">在此期间，您不能执行当前指令之外的其他代码。当这个操作完成时，你的程序可能会冻结，UI可能根本没有响应。</strong></p><p id="3301" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这是完全正常的，你将不得不处理它。</p><p id="7ce4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja"> ➡️如何避免UI冻结？</strong></p><p id="5306" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了解决这个问题，你可以使用一个叫做<strong class="lc ja">的线程</strong>，它允许你在子进程中委托一些代码执行。由于多线程，这导致了非阻塞操作和并行代码执行。</p><p id="1e29" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">这是标准/以前语言中代码并行性和并发性的基础。</strong></p><p id="c542" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">并发是编程的一个复杂章节</strong>，尤其是对于初学者。在这里我就不深究了。上面的例子足以理解后面的内容，因为JavaScript不是多线程语言。</p><p id="5973" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">所以:</strong></p><blockquote class="nt nu nv"><p id="edbc" class="la lb nw lc b ld le ka lf lg lh kd li nx lk ll lm ny lo lp lq nz ls lt lu lv ij bi translated"><strong class="lc ja"> <em class="iq"> ❓How用JavaScript处理并发问题？</em> </strong></p></blockquote><h1 id="0476" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">📌代码并行的JavaScript并发模型和异步行为</h1><p id="98ff" class="pw-post-body-paragraph la lb iq lc b ld mq ka lf lg mr kd li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">正如你在上面看到的，JavaScript使用的是单线程语言，这适用于任何JS引擎实现，比如Chrome的<a class="ae oa" href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine)" rel="noopener ugc nofollow" target="_blank"> V8 </a>、苹果Safari的<a class="ae oa" href="https://en.wikipedia.org/wiki/JavaScriptCore" rel="noopener ugc nofollow" target="_blank"> JavaScriptCore </a>或脸书React native的<a class="ae oa" href="https://hermesengine.dev/" rel="noopener ugc nofollow" target="_blank"> Hermes </a>。</p><blockquote class="nt nu nv"><p id="aafb" class="la lb nw lc b ld le ka lf lg lh kd li nx lk ll lm ny lo lp lq nz ls lt lu lv ij bi translated"><strong class="lc ja"> <em class="iq"> ❓What是什么意思？</em> </strong></p></blockquote><p id="6631" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这意味着JavaScript一次只能执行一个任务，并且每个任务都要排队等待处理。</p><p id="8381" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">但是正如我们在上面看到的，有时你需要一次做多件事情，或者你会有一些指令需要花费很多秒来处理，这将导致由于线程阻塞而导致的冻结。</p><h2 id="2664" class="ob lx iq bd ly oc od dn mc oe of dp mg lj og oh mi ln oi oj mk lr ok ol mm iw bi translated"><strong class="ak"> ⚙️但Javascript没有多线程</strong></h2><p id="696b" class="pw-post-body-paragraph la lb iq lc b ld mq ka lf lg mr kd li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">所以处理这个问题的唯一方法是<strong class="lc ja">以某种方式将代码执行委托给一个外部处理程序，继续执行脚本，然后在执行完成后执行一个回调代码。</strong></p><p id="f371" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这就是引擎在事件循环中实现的功能。</p><p id="7ee9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja"> JavaScript可以使用内核提供的一些原生函数将异步行为委托给OS </strong>。</p><p id="2ea7" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">大多数情况下，这些都是IO指令，但也可能是其他指令。</p><ul class=""><li id="8bf4" class="mo mp iq lc b ld le lg lh lj om ln on lr oo lv op mw mx my bi translated">对于网络浏览器，你有<code class="fe oq or os ot b">fetch</code>或<code class="fe oq or os ot b">setTimeout</code>作为例子。</li><li id="dd51" class="mo mp iq lc b ld mz lg na lj nb ln nc lr nd lv op mw mx my bi translated">对于NodeJS，有<code class="fe oq or os ot b">readFile</code>或<code class="fe oq or os ot b">writeFile</code>作为例子，它们代表系统IO。</li></ul><p id="6790" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">一旦调用这样的动作，系统就接受命令，在子进程中执行自己命令的所有指令…</p><h2 id="4e51" class="ob lx iq bd ly oc od dn mc oe of dp mg lj og oh mi ln oi oj mk lr ok ol mm iw bi translated">JavaScript事件循环⚙️</h2><p id="b907" class="pw-post-body-paragraph la lb iq lc b ld mq ka lf lg mr kd li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">一旦完成，系统将调用你的程序:<strong class="lc ja">这是著名的JS事件循环的一部分。</strong></p><p id="a3b2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">如果你不知道这是怎么回事，你可以查看这里:<a class="ae oa" href="https://medium.com/front-end-weekly/javascript-event-loop-explained-4cd26af121d4" rel="noopener">https://medium . com/front-end-weekly/JavaScript-event-loop-explained-4c d26 af 121d 4</a>。</p><p id="222c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">💣快速&amp;简而言之:</strong>事件循环是程序运行时无限循环的引擎序列，它将按照给定的特定顺序执行队列中的语句。</p><p id="5060" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这些语句由代码函数和回调指令提供。</p><p id="e76f" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">回调指令</strong>提供一些在系统完成异步代码执行后需要执行的代码，比如读取系统上的一个文件。</p><p id="4ea6" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">我们说回调指令，但事实上，它可以是:</p><ul class=""><li id="5329" class="mo mp iq lc b ld le lg lh lj om ln on lr oo lv op mw mx my bi translated"><strong class="lc ja">回调函数</strong>，一旦被调用，将从操作系统接收参数</li><li id="352f" class="mo mp iq lc b ld mz lg na lj nb ln nc lr nd lv op mw mx my bi translated">或者<strong class="lc ja"> JavaScript承诺</strong>解决或拒绝(以async-await为例)</li></ul><p id="06ea" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">✋🏻⚠️ <em class="nw">我不会在这里展开什么承诺，你可以看看这个写得非常好的指南:</em><a class="ae oa" href="https://developers.google.com/web/fundamentals/primers/promises" rel="noopener ugc nofollow" target="_blank"><strong class="lc ja"><em class="nw">https://developers . Google . com/web/fundamentals/primers/promises</em></strong></a></p><h1 id="354e" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">🚀示例:JavaScript中的异步循环与同步循环</h1><p id="3947" class="pw-post-body-paragraph la lb iq lc b ld mq ka lf lg mr kd li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">在下面的例子中，我们将通过一系列主题来演示使用异步行为的阻塞循环和非阻塞循环之间的区别。</p><p id="3fd0" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">该数组包含主题，对于每个主题，我们需要:</p><ol class=""><li id="7dc5" class="mo mp iq lc b ld le lg lh lj om ln on lr oo lv mv mw mx my bi translated">从远程API获取数据…</li><li id="7ea7" class="mo mp iq lc b ld mz lg na lj nb ln nc lr nd lv mv mw mx my bi translated">然后在文件中写一些东西。</li></ol><p id="2bd9" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja"> ✋🏻⚠️ <em class="nw">下面所有的代码都提供了存根函数，它们只是使用JS Promise延迟了函数返回语句。这产生了与将代码执行推迟到系统相同的行为。</em>T11】</strong></p><p id="4bca" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><a class="ae oa" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ja">你还可以看看什么是</strong></a><code class="fe oq or os ot b"><a class="ae oa" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"><strong class="lc ja">async </strong></a></code><a class="ae oa" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"><strong class="lc ja">/</strong></a><code class="fe oq or os ot b"><a class="ae oa" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"><strong class="lc ja">await</strong></a></code><a class="ae oa" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="noopener ugc nofollow" target="_blank"><strong class="lc ja">这里的</strong> </a></p><p id="a92a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为了使用下面的代码片段，您需要创建一个<code class="fe oq or os ot b">index.js</code>文件，将代码片段复制到其中，并运行一个<code class="fe oq or os ot b">npm init -y &amp;&amp; npm install chalk</code>，以获得这个小的实用程序库，它在控制台中提供文本颜色。</p><p id="5ac2" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">简单地用<code class="fe oq or os ot b">node ./index.js</code>运行脚本</p><h2 id="3a7c" class="ob lx iq bd ly oc od dn mc oe of dp mg lj og oh mi ln oi oj mk lr ok ol mm iw bi translated">❶第一方法:同步代码执行</h2><p id="a710" class="pw-post-body-paragraph la lb iq lc b ld mq ka lf lg mr kd li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">我们从同步方法开始，只要被调用的函数没有返回，这个方法就会使用带有<code class="fe oq or os ot b">await</code>关键字的异步函数来阻塞循环内的执行。</p><p id="71a3" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">💡提示:</strong> <em class="nw">其实这并不是你所期待的真正同步。使用</em> <code class="fe oq or os ot b"><em class="nw">await</em></code> <em class="nw">只会确保代码在函数中按顺序执行。每当你</em> <code class="fe oq or os ot b"><em class="nw">await</em></code> <em class="nw">时，你就让其他事情发生，然后在某个时候继续你等待的事情。</em></p><p id="7186" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这导致以下假设:</p><ul class=""><li id="6734" class="mo mp iq lc b ld le lg lh lj om ln on lr oo lv op mw mx my bi translated">顺序程序执行</li><li id="1c10" class="mo mp iq lc b ld mz lg na lj nb ln nc lr nd lv op mw mx my bi translated">不存在的代码并行性</li><li id="7927" class="mo mp iq lc b ld mz lg na lj nb ln nc lr nd lv op mw mx my bi translated">保证对于每个主题，在进入下一个迭代之前，API调用已经返回，并且文件已经尝试写入成功/失败。</li></ul><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="ou ov l"/></div><figcaption class="ow ox gj gh gi oy oz bd b be z dk">Synchronous behavior using async</figcaption></figure><p id="6be1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">虽然对于某些用例来说，当内容对彼此有副作用时，这有时可以很好地保证排序，但是在下面的用例中，这不是实现这个目标的最佳方式。</p><p id="ab23" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">通过在NodeJS程序中运行以下脚本，您可以看到，与延迟持续时间相比，总的脚本执行时间相当长，但是随着我们进行链接，花费的时间呈线性增长。</p><h2 id="c566" class="ob lx iq bd ly oc od dn mc oe of dp mg lj og oh mi ln oi oj mk lr ok ol mm iw bi translated">❷第二种方法:异步代码执行和并行</h2><p id="0f98" class="pw-post-body-paragraph la lb iq lc b ld mq ka lf lg mr kd li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">由于我们的每个主题值在依赖性和副作用方面互不相关，<strong class="lc ja">我们的</strong> <strong class="lc ja">回调</strong> <code class="fe oq or os ot b"><strong class="lc ja">loopOccurence</strong></code> <strong class="lc ja">几乎是一个纯函数</strong>，<strong class="lc ja">因为它对我们的应用程序没有副作用。</strong>(作为一个真正的纯函数，它不应该有任何副作用)</p><blockquote class="nt nu nv"><p id="1b59" class="la lb nw lc b ld le ka lf lg lh kd li nx lk ll lm ny lo lp lq nz ls lt lu lv ij bi translated"><strong class="lc ja"> <em class="iq">👨🏻‍🔬</em> </strong>纯函数是指采用相同参数的函数，每次都会产生并返回相同的结果。这个函数也不会在其范围之外产生任何副作用。</p></blockquote><p id="b5a1" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">正因为如此，我邀请您看看如果您删除前面代码片段中的关键字<code class="fe oq or os ot b">await</code>会发生什么，如下所述。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pa"><img src="../Images/e5058076a322ddafa0f5902e9fe42f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yib5EshyUIOKkZuUuI5ouA.png"/></div></div><figcaption class="ow ox gj gh gi oy oz bd b be z dk">Enabling and leveraging parallelism thanks to our pure function loopOccurence</figcaption></figure><p id="3157" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">💡<code class="fe oq or os ot b">async</code> / <code class="fe oq or os ot b">await</code>关键字是<strong class="lc ja">控制函数执行流程的工具。</strong>删除<code class="fe oq or os ot b">await</code>关键字告诉解释器在进入下一个循环迭代之前不要等待函数响应。</p><p id="439a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">这种方法利用了并行性</strong>，因为JS引擎同时发送三个请求。</p><p id="c253" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">💡提示:</strong> <em class="nw">哦对了，我忘了，你没有在循环内部使用</em> <code class="fe oq or os ot b"><em class="nw">await</em></code> <em class="nw">但是这并不意味着你根本不需要</em><code class="fe oq or os ot b"><em class="nw">await</em></code><em class="nw"/><strong class="lc ja"><em class="nw">事实上，你需要处理错误并确保一切顺利完成。我们将在下一节看到这一点。</em> </strong></p><p id="0068" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">这些都是很好的工具，尽可能多地使用它们。</p><p id="74ad" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">➡️欢迎异步和并行。</p><p id="7ef4" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">应用程序的性能和响应能力得到了极大的提高</strong>，我们仍然可以通过首先等待获得API调用返回状态，然后创建文件，来保持每个主题循环内部的顺序。</p><p id="df4c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">从执行时间来看，这比我们的第一种方法要好得多。</p><p id="081c" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">为什么？因为JS委托并行执行，所以脚本可以更快地访问其他指令(在我们的例子中是循环迭代)，这导致了更好的性能。</p><h2 id="7f78" class="ob lx iq bd ly oc od dn mc oe of dp mg lj og oh mi ln oi oj mk lr ok ol mm iw bi translated">🎁好处:对每个指令使用函数式编程</h2><p id="278e" class="pw-post-body-paragraph la lb iq lc b ld mq ka lf lg mr kd li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">我们也可以用函数式编程中的一个名为<code class="fe oq or os ot b">forEach</code>的函数来替换我们的<code class="fe oq or os ot b">for…of</code>循环。结果将与您在这里看到的完全一样。</p><p id="1448" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><strong class="lc ja">💡</strong> <a class="ae oa" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ja">想了解更多关于forEach函数的知识？点击这里！</strong> </a></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pb"><img src="../Images/5c56869d7a13043a369c4766520b6a3a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n4HaNh72tnBkFUw8P1G5RA.png"/></div></div><figcaption class="ow ox gj gh gi oy oz bd b be z dk">Using functional programming we are achieving the same goal of parallelism</figcaption></figure><h2 id="0cfd" class="ob lx iq bd ly oc od dn mc oe of dp mg lj og oh mi ln oi oj mk lr ok ol mm iw bi translated">⚡️🔓最安全、最有效的方式:地图+承诺</h2><p id="19db" class="pw-post-body-paragraph la lb iq lc b ld mq ka lf lg mr kd li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">事实上，我忽略了一些真正重要的东西，比如确保一切正常运行和处理错误。</p><p id="8b6d" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">您可以使用函数式编程<code class="fe oq or os ot b">map</code>函数和<code class="fe oq or os ot b">Promise.all</code>函数的组合来改进上面的代码片段。</p><p id="7828" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">第一个将有助于映射将传递给第二个的承诺。第二个将接收一个承诺数组，如果给定数组中的任何承诺失败，它将快速失败。这是您的错误处理场景。</p><pre class="kp kq kr ks gt pc ot pd pe aw pf bi"><span id="f983" class="ob lx iq ot b gy pg ph l pi pj">const everythingOk = await Promise.all<!-- -->(themes.map(loopOccurence));</span></pre><h1 id="fbef" class="lw lx iq bd ly lz ma mb mc md me mf mg kf mh kg mi ki mj kj mk kl ml km mm mn bi translated">🚛外卖/TLDR；📦</h1><p id="120a" class="pw-post-body-paragraph la lb iq lc b ld mq ka lf lg mr kd li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">JavaScript应用程序运行在单线程上。您将需要使用异步机制来处理这个单线程属性。</p><p id="bc3a" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">异步机制利用JavaScript <strong class="lc ja">回调</strong>和<strong class="lc ja">承诺</strong>。</p><p id="ef49" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated"><code class="fe oq or os ot b">async</code> / <code class="fe oq or os ot b">await</code>关键字是<strong class="lc ja">控制函数内执行流程的工具。</strong></p><p id="1586" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">通过使用<strong class="lc ja">并行</strong>，使用异步可以<strong class="lc ja">极大地提高应用程序的性能和响应能力</strong>。</p><p id="2cb5" class="pw-post-body-paragraph la lb iq lc b ld le ka lf lg lh kd li lj lk ll lm ln lo lp lq lr ls lt lu lv ij bi translated">在循环指令中:你可以使用<code class="fe oq or os ot b">forEach</code>或者<code class="fe oq or os ot b">for…of</code>语句来获得异步迭代。另一方面:您可以将<code class="fe oq or os ot b">for…of</code>与<code class="fe oq or os ot b">await</code>关键字或<code class="fe oq or os ot b"><a class="ae oa" href="https://medium.com/javascript-in-plain-english/how-i-used-javascript-generators-to-create-a-casino-game-cards-shuffler-fef4f796110f" rel="noopener">generators</a></code> <a class="ae oa" href="https://medium.com/javascript-in-plain-english/how-i-used-javascript-generators-to-create-a-casino-game-cards-shuffler-fef4f796110f" rel="noopener">一起使用，以在函数</a>中同步执行代码。</p></div><div class="ab cl ne nf hu ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ij ik il im in"><h2 id="0b4f" class="ob lx iq bd ly oc od dn mc oe of dp mg lj og oh mi ln oi oj mk lr ok ol mm iw bi translated">🙏🏻感谢</h2><p id="9679" class="pw-post-body-paragraph la lb iq lc b ld mq ka lf lg mr kd li lj nq ll lm ln nr lp lq lr ns lt lu lv ij bi translated">Reddit 的人们帮助我改进了这篇开始有点笨拙的文章。</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="pk ov l"/></div></figure></div></div>    
</body>
</html>