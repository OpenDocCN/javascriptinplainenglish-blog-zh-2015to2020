<html>
<head>
<title>How to design a kick-ass GraphQL schema</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何设计一个出色的GraphQL模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-design-a-kick-ass-graphql-schema-79d573e85147?source=collection_archive---------3-----------------------#2020-02-10">https://javascript.plainenglish.io/how-to-design-a-kick-ass-graphql-schema-79d573e85147?source=collection_archive---------3-----------------------#2020-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e57e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">本文将提供一些实用的技巧，帮助您设计一个直观的、可伸缩的和强大的GraphQL模式。</p><h2 id="de01" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">什么是GraphQL模式？</h2><p id="1ca7" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">一个<strong class="jp ir">模式</strong>是一个产品领域的结构化表示。它描述了产品的关键概念、这些概念之间的关系以及系统支持的核心操作。</p><p id="0c4f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">GraphQL仅仅是一个<strong class="jp ir">工具</strong>，它让我们以一种易于使用的语法与我们定义的模式进行交互。它<em class="lj">没有强制执行</em>任何关于数据来源或我们定义模式的方式的标准。</p><p id="4347" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为没有强制的指导方针，好的模式设计经常被遗忘，直到为时已晚。这导致模式<strong class="jp ir">难以理解，</strong> <strong class="jp ir">难以维护，并且几乎不可能</strong>随着新特性的引入而扩展。</p><h1 id="feb4" class="lk km iq bd kn ll lm ln kq lo lp lq kt lr ls lt kw lu lv lw kz lx ly lz lc ma bi translated"><strong class="ak">产品驱动</strong></h1><p id="b78c" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">GraphQL的一个显著优势是，它允许您创建一个对<strong class="jp ir">工程师</strong>和<strong class="jp ir">产品</strong>团队直观的API。GraphQL模式应该揭示您的最终用户<strong class="jp ir">将与之交互的项目、字段和动作。</strong></p><p id="7edf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">数据库是以高度技术化和高性能的方式构建和设计的。GraphQL让我们<strong class="jp ir">将这些结构简化为项目和动作，从而<strong class="jp ir">更好地反映</strong>我们产品的本质。</strong></p><blockquote class="mb mc md"><p id="78fd" class="jn jo lj jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">首先，我们必须是我们领域的专家...其次，我们必须擅长graph QL’—<a class="ae mh" href="https://www.youtube.com/watch?v=pJamhW2xPYw" rel="noopener ugc nofollow" target="_blank">graph QL模式设计@ Scale (Marc-André Giroux) </a></p></blockquote><p id="4cd6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Shopify在一个友好的自述文件中标准化了他们的模式设计。主要的一点是，当设计一个模式时，API不需要直接对用户界面建模，“实现和UI都可以作为API设计的灵感和输入，但是您的决策的最终驱动因素必须始终是业务领域。”</p><h2 id="4bd5" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><strong class="ak">为什么是</strong>？</h2><ol class=""><li id="0f24" class="mi mj iq jp b jq le ju lf jy mk kc ml kg mm kk mn mo mp mq bi translated">一个产品比一个复杂的数据架构更容易理解</li><li id="a1d1" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">帮助推广一种通用的<strong class="jp ir">产品语言</strong>，工程师、设计师和所有利益相关者可以用它来讨论和阐述复杂的概念。</li></ol><h2 id="0470" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">例子</h2><p id="a9e4" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">假设我们正在创建一个系统，让员工在自己的公司提交休假申请。我们产品中的主要项目是<code class="fe mw mx my mz b">Employees</code>、<code class="fe mw mx my mz b">Admins</code>和<code class="fe mw mx my mz b">Leave Requests</code>。主要动作是<code class="fe mw mx my mz b">requesting</code>和<code class="fe mw mx my mz b">approving</code>休假请求。</p><p id="ecfb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是在我们的系统中为代表用户而创建的数据库表。</p><figure class="nb nc nd ne gt nf gh gi paragraph-image"><div class="gh gi na"><img src="../Images/0945cbeae9c98cf6b923fc5ea6980580.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*FM5mFNQhQuFLymFjzF0vxA.jpeg"/></div></figure><p id="e7e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">错误的模式设计</strong></p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="e003" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">良好的模式设计</strong></p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="667d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过将表格分成两个概念，我们已经正确地封装了每种类型用户的行为和字段。当实现特性时，我们可以轻松地与<code class="fe mw mx my mz b">Employees</code>和<code class="fe mw mx my mz b">Admins</code>交互，而不是每次我们想获取用户时都传递一个参数<code class="fe mw mx my mz b">is_admin</code>。</p><p id="04e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，我们将<code class="fe mw mx my mz b">e_id</code>列抽象为一个描述性字段，该字段仅与<code class="fe mw mx my mz b">Employee.</code>相关联。这<strong class="jp ir">防止混淆</strong>该字段是什么，并向我们的工程师表明该字段仅用于<code class="fe mw mx my mz b">Employees.</code></p><h2 id="a22d" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">仔细想想你想揭露什么</h2><blockquote class="mb mc md"><p id="75fd" class="jn jo lj jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">“添加一个字段比删除一个字段更容易”——<a class="ae mh" href="https://github.com/Shopify/graphql-design-tutorial/blob/master/TUTORIAL.md" rel="noopener ugc nofollow" target="_blank">规则#4 Shopify模式标准</a></p></blockquote><p id="7dbd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最好是手工制作一个模式，以确保您正在创建一个可用的API。从数据库生成模式的工具很诱人，但应该避免，因为它们充当瘦中间件，不会给我们的底层结构增加任何产品价值。在添加字段或实体之前，请仔细考虑，我们暴露的越多，模式就越不集中，对我们的工程师来说就越混乱。</p><p id="993b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Michael Watson在“<a class="ae mh" href="https://www.youtube.com/watch?v=fG8zy1OROp4" rel="noopener ugc nofollow" target="_blank">你的模式和GraphQL操作的注意事项</a>”中建议根据客户的用例慢慢地发展你的图。这里的要点是，在将解析器和每个字段添加到模式之前，要确保它们都有用例。</p><h2 id="7e54" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">简化复杂的结构</h2><p id="dbd9" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">在设计和扩展数据库时，我们经常会遇到来自多个不同数据源的表和关系的蜘蛛网。复杂功能的优化和实现需要这些结构。</p><p id="488d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，这导致新工程师和困惑的产品经理头疼。GraphQL让我们将底层架构抽象成一个<strong class="jp ir">友好的</strong> API，工程师可以更快地理解、交互和实现特性。</p><p id="eda7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要遵循的一条好规则是，解析器<strong class="jp ir">不应该公开底层数据源</strong>，而应该反映产品中的单一概念。</p><h2 id="daf4" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">在服务器端聚合字段</h2><p id="7e4f" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">在可能的情况下，在服务器端执行<em class="lj">复杂的计算</em>，并将它们作为产品中的一个值公开。这有助于我们<strong class="jp ir">重用</strong>逻辑，避免“客户端消费者不得不操纵数据”(<a class="ae mh" href="https://www.youtube.com/watch?reload=9&amp;v=b_qFpde74Ho" rel="noopener ugc nofollow" target="_blank"> Apollo </a>)并且<strong class="jp ir">简化了</strong>前端开发人员的认知负荷。</p><p id="9e26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">示例</strong></p><p id="acae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的人力资源公司，休假申请在满足一系列标准时被视为已被接受:管理员已<em class="lj">手动批准</em>它，休假类型为<em class="lj">医疗</em>或申请日期为<em class="lj">未来6个月以上</em>。</p><p id="dcfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">下面是典型的GraphQL响应。</p><p id="592e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">输出设计不良</strong></p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ebe5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的问题是，每当我们在UI中使用它时，我们都必须计算休假请求是否被批准——业务规则应该位于一个中心位置，而不是分散在代码库中。这增加了复杂性，每个工程师必须了解休假请求被批准的确切条件。</p><p id="e4f8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">良好的输出设计</strong></p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="ccea" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在重用这个逻辑，与单个<code class="fe mw mx my mz b">isApproved</code>字段交互变得简单多了。</p><p id="f535" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意—如果您的产品也向用户公开单个字段，请在您的模式中提供这些字段。</p><h1 id="b248" class="lk km iq bd kn ll lm ln kq lo lp lq kt lr ls lt kw lu lv lw kz lx ly lz lc ma bi translated">创建一个易于<strong class="ak">配置的模式</strong></h1><blockquote class="mb mc md"><p id="0293" class="jn jo lj jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">“构建经得起时间考验的API”——<a class="ae mh" href="https://www.youtube.com/watch?v=pJamhW2xPYw" rel="noopener ugc nofollow" target="_blank">Github</a></p></blockquote><p id="5b1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的关键信息是设计一个模式，让您可以轻松地添加功能并无缝地弃用产品的某些部分。这在敏捷开发中尤其重要。我们需要<strong class="jp ir">围绕客户需求快速迭代</strong>，尽快交付价值。</p><p id="94c8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">具体的数据库结构很难迭代，因为它们需要复杂的迁移。幸运的是，GraphQL模式更具延展性，如果设计正确，配置起来也很简单。</p><h2 id="a1a7" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><strong class="ak">始终</strong>使用单输入<strong class="ak">对象</strong>进行变异</h2><p id="0590" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated"><em class="lj">注意:截止到2020年末，一直在讨论在GraphQL规范中引入不赞成使用的输入参数。在实现时，这个输入规则可能不是必需的。</em></p><p id="d604" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这使得添加字段变得更加容易，也使得废弃字段变得更加容易。</p><p id="201f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个例子，我们将创建一个突变，让一个<code class="fe mw mx my mz b">Employee</code> <code class="fe mw mx my mz b">request</code>成为一个<code class="fe mw mx my mz b">LeaveRequest</code>。</p><p id="93fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">错误的输入设计</strong></p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="db0f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是我第一次创造突变时犯的错误。这里的问题是，添加<strong class="jp ir">和删除变异的功能变得非常困难。</strong></p><p id="de55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想添加一些功能，比如图片附件，唯一的方法就是添加第五个参数。这显然<em class="lj">不能很好地扩展</em>并且<em class="lj">难以维护</em>。</p><p id="78ce" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用单个参数也使得客户端的执行更加容易。</p><p id="4fd7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">良好的输入设计</strong></p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="c78c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种模式允许我们向输入对象添加字段，而不会引入任何重大更改。</p><p id="c875" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们想弃用<code class="fe mw mx my mz b">description</code>字段，我们可以将该字段设置为可空，添加弃用原因，并将其从我们的前端代码中淘汰。</p><h2 id="52da" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">你总是希望<strong class="ak">返回</strong>一个单一的输出对象，而不是一个值</h2><blockquote class="mb mc md"><p id="0d4d" class="jn jo lj jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">“当处理突变时，返回突变记录作为突变的结果被认为是好的设计。这允许我们相应地更新前端的状态并保持事情的一致性”“<a class="ae mh" href="https://atheros.ai/blog/graphql-best-practices-for-graphql-schema-design" rel="noopener ugc nofollow" target="_blank"> Atheros </a></p></blockquote><p id="f612" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于类似的原因，通过在响应中返回一个对象，向该响应对象添加和移除字段变得更加容易。当我们想要扩展功能并向响应添加新字段时，我们的客户端可以继续使用这些端点<strong class="jp ir">而不会中断更改</strong>。</p><p id="4e15" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用上面的例子，我们还将返回新的休假请求，这样我们就可以更新我们的UI，而不必执行第二次请求。</p><p id="e7a2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">良好的输出设计</strong></p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><h1 id="1905" class="lk km iq bd kn ll lm ln kq lo lp lq kt lr ls lt kw lu lv lw kz lx ly lz lc ma bi translated">将GraphQL中的突变映射到一个<strong class="ak">特定的用户流</strong></h1><p id="9ec5" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">将我们的变化映射到我们产品中的动作确保了我们创建更小和更集中的请求。</p><blockquote class="mb mc md"><p id="d933" class="jn jo lj jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated">“避免试图构建支持移动、桌面和所有功能的‘一刀切’的API。拥抱不同的使用案例和客户，并以此为基础进行构建。”— <a class="ae mh" href="https://www.youtube.com/watch?v=pJamhW2xPYw" rel="noopener ugc nofollow" target="_blank"> Github </a>。</p></blockquote><p id="481a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">为什么？</strong></p><ol class=""><li id="d79c" class="mi mj iq jp b jq jr ju jv jy nk kc nl kg nm kk mn mo mp mq bi translated">通过更小、更直观的操作，我们更容易理解和推理特定端点的功能</li><li id="2ccd" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated"><strong class="jp ir">更少的代码中断</strong>——如果更少的端点使用相同的通用突变，我们减少了我们的变化的影响</li><li id="7512" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">引导我们走向好的架构模式，尤其是'<a class="ae mh" href="https://medium.com/@severinperez/writing-flexible-code-with-the-single-responsibility-principle-b71c4f3f883f" rel="noopener">单一责任</a></li></ol><h2 id="062c" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><em class="nn">贫血设计</em></h2><p id="0d16" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">贫血设计是一种反模式，你把你的系统设计成纯粹的数据，没有任何内置的行为。简而言之，这意味着当您想要更改一些底层状态时，您可以使用通用的创建、读取、更新和删除方法直接与数据层进行交互。在贫血的设计中，商业规则和行为是存在的，但是它们存在于工程师的大脑中。</p><p id="4305" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于这个例子，一个<code class="fe mw mx my mz b">Admin</code>想要批准一个<code class="fe mw mx my mz b">LeaveRequest</code></p><p id="2d14" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">不良突变设计</strong></p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="21d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lj">为什么要避免贫血设计？</em></p><ol class=""><li id="a90f" class="mi mj iq jp b jq jr ju jv jy nk kc nl kg nm kk mn mo mp mq bi translated">你必须向<strong class="jp ir">发送你需要更新或创建的全部有效载荷</strong>。</li><li id="7279" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">工程师需要理解底层数据结构和改变每个字段的副作用</li><li id="f6f9" class="mi mj iq jp b jq mr ju ms jy mt kc mu kg mv kk mn mo mp mq bi translated">一个单一的突变必须迎合许多不同的用例</li></ol><p id="ed21" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">好的变异设计</strong></p><figure class="nb nc nd ne gt nf"><div class="bz fp l di"><div class="ni nj l"/></div></figure><p id="b206" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">动作现在更具体，副作用的空间更小，我们的逻辑现在可以更加集中在解析器内部。</p><h2 id="0ff9" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">使用一致的命名约定</h2><blockquote class="mb mc md"><p id="41b2" class="jn jo lj jp b jq jr js jt ju jv jw jx me jz ka kb mf kd ke kf mg kh ki kj kk ij bi translated"><a class="ae mh" href="https://github.com/Shopify/graphql-design-tutorial/blob/master/TUTORIAL.md" rel="noopener ugc nofollow" target="_blank"> Shopify规则9 </a> — <em class="iq">根据有意义的东西来选择字段名称，而不是根据实现或者字段在传统API中的名称。</em></p></blockquote><p id="8e50" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里主要的要点是使用一个<strong class="jp ir">对你的团队</strong>有效的标准，并坚持下去。一致的命名让您的团队能够立即理解特定分解器或变异的作用。</p><p id="54a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">整个行业的一个普遍规则是先用动词，再用名词。</p><h1 id="3fad" class="lk km iq bd kn ll lm ln kq lo lp lq kt lr ls lt kw lu lv lw kz lx ly lz lc ma bi translated"><strong class="ak">最终注释</strong></h1><p id="1ebb" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">当构建消费者软件时，我们需要一个反映我们产品的API。GraphQL的建立是为了让客户能够准确地要求他们所需要的东西，并让API随着时间的推移变得更容易。—<a class="ae mh" href="http://graphql.org" rel="noopener ugc nofollow" target="_blank">graphql.org</a>。</p><p id="2d4a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">是时候扩展我们的知识了，超越我们从基于REST和SOAP的端点中学到的原理。为了创建一个<strong class="jp ir">超棒的模式</strong>，仔细考虑你想要公开的实体、字段和动作。</p><p id="a0e9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">花时间确保你的模式是<strong class="jp ir">灵活的</strong>，并且<strong class="jp ir">高度耦合</strong>到你的业务领域。对您的模式设计的早期深谋远虑将使您的前端工程师的工作更加顺利，将帮助新的初学者更快地入门，并将确保更快地迭代改善您的用户生活的功能。</p></div></div>    
</body>
</html>