<html>
<head>
<title>JavaScript Problems — Promise vs Callbacks, Cloning, and JSON</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript问题——承诺与回调、克隆和JSON</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-problems-promise-vs-callbacks-cloning-and-json-ab4eb43302cf?source=collection_archive---------11-----------------------#2020-07-10">https://javascript.plainenglish.io/javascript-problems-promise-vs-callbacks-cloning-and-json-ab4eb43302cf?source=collection_archive---------11-----------------------#2020-07-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6c737b977b05b8544679faae8aeb4f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GhAcICScNdb6S0Ce"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@grmot?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">G-R Mottez</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c87a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写JavaScript应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些常见JavaScript问题的解决方案。</p><h1 id="cdc8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">格式化JavaScript浮点</h1><p id="5359" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要格式化一个JavaScript浮点数，我们可以使用<code class="fe me mf mg mh b">toFixed</code>方法。</p><p id="2b35" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d4a5" class="mq lc iq mh b gy mr ms l mt mu">consr x = 5.574859569;<br/>console.log(x.toFixed(2));</span></pre><p id="3469" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">x</code>上的<code class="fe me mf mg mh b">toFixed</code>来返回一个将它四舍五入到两位小数的字符串。</p><h1 id="9588" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">递增日期</h1><p id="598b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">getDate</code>的方法加上1来埋葬一个日期。</p><p id="844b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="025d" class="mq lc iq mh b gy mr ms l mt mu">const tomorrow = new Date();<br/>tomorrow.setDate(tomorrow.getDate() + 1);</span></pre><p id="8119" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要用moment.js做同样的事情，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3f3a" class="mq lc iq mh b gy mr ms l mt mu">const today = moment();<br/>const tomorrow = moment(today).add(1, 'days');</span></pre><p id="1059" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两者都获得今天的日期，并在其上加上1天。</p><h1 id="f245" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何替换字符串中的所有点</h1><p id="e985" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要替换字符串中的所有点，我们可以使用带有正则表达式的<code class="fe me mf mg mh b">replace</code>方法。</p><p id="d05d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4dd6" class="mq lc iq mh b gy mr ms l mt mu">str = str.replace(/\./g, ' ')</span></pre><p id="9a3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用正则表达式得到所有的点。</p><p id="eecb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用空格代替它们。</p><h1 id="e4b7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">承诺和回访</h1><p id="11c2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">承诺不是回调，尽管它们可以使用回调。</p><p id="4b59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是异步操作的未来结果。</p><p id="e0aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过回调得到结果来使用它们:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f664" class="mq lc iq mh b gy mr ms l mt mu">api()<br/>.then((result) =&gt; {<br/>  return api2();<br/>})<br/>.then((result2) =&gt; {<br/>  return api3();<br/>})<br/>.then((result3) =&gt; {<br/>  // ...<br/>});</span></pre><p id="4f0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们也可以使用async和await:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a22d" class="mq lc iq mh b gy mr ms l mt mu">async () =&gt; {<br/>  const result = await api();<br/>  const result2 = await api2();<br/>  const result3 = await api3();<br/>}</span></pre><p id="0fb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不一定要用承诺来回拨。</p><p id="47b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它们互不依赖，也可以同时运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5271" class="mq lc iq mh b gy mr ms l mt mu">Promise<br/>  .all([api(), api2(), api3()])<br/>  .then((result) =&gt; {<br/>    // ...<br/>  })<br/>  .catch((error) =&gt; {<br/>    // handle error<br/>  });</span></pre><p id="c59d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">Promise.all</code>同时运行它们。</p><p id="1be0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e2dd" class="mq lc iq mh b gy mr ms l mt mu">async () =&gt; {<br/>  try {<br/>    const result = await Promise<!-- -->.all([api(), api2(), api3()]);<br/>  }<br/>  catch(e){<br/>    // handle error<br/>  }<br/>}</span></pre><h1 id="d917" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">并行调用异步/等待函数</h1><p id="8fed" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">Promise.all</code>并行运行承诺。</p><p id="1bde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们在上面看到的，我们有带异步和等待的<code class="fe me mf mg mh b">Promise.all</code>。</p><p id="278a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以破坏每个承诺的结果:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d099" class="mq lc iq mh b gy mr ms l mt mu">async () =&gt; {<br/>  try {<br/>    const [r1, r2, r3] = await Promise<!-- -->.all([api(), api2(), api3()]);<br/>  }<br/>  catch(e){<br/>    // handle error<br/>  }<br/>}</span></pre><h1 id="a961" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">自动执行功能的目的是什么？</h1><p id="db05" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用自执行函数来防止变量从外部进入。</p><p id="2ee1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c844" class="mq lc iq mh b gy mr ms l mt mu">(() =&gt; { <br/>  let foo = 3; <br/>  console.log(foo); <br/>})();</span></pre><p id="2ac9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">foo</code>只在函数内可用。</p><h1 id="b475" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">迭代JavaScript对象</h1><p id="6df6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有几种方法可以迭代JavaScript对象。</p><p id="4fa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种方法是使用for-in循环:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4914" class="mq lc iq mh b gy mr ms l mt mu">for (const key in obj) {<br/>  console.log(key, obj[key]);<br/>}</span></pre><p id="3b49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">hasOwnProperty</code>来避免记录继承的属性:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="de14" class="mq lc iq mh b gy mr ms l mt mu">for (const key in obj) {<br/>  if (obj.hasOwnProperty(key)) {<br/>     console.log(key, obj[key]);<br/>  }<br/>}</span></pre><p id="690c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用带有for-of循环的<code class="fe me mf mg mh b">Object.entries</code>方法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a4af" class="mq lc iq mh b gy mr ms l mt mu">for (const [key, value] of Object.entries(obj)) {<br/>  console.log(key, value);<br/>}</span></pre><h1 id="b73a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何克隆对象数组？</h1><p id="fba6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">克隆对象数组最简单的方法是使用<code class="fe me mf mg mh b">JSON.stringify</code>和<code class="fe me mf mg mh b">JSON.parse</code>。</p><p id="9c27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="494e" class="mq lc iq mh b gy mr ms l mt mu">const cloned = JSON.parse(JSON.stringify(arr))</span></pre><p id="e576" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果所有条目都只有可序列化的内容，这将是可行的。</p><p id="745a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着没有函数，无穷大等。</p><p id="6f58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以使用<code class="fe me mf mg mh b">map</code>和<code class="fe me mf mg mh b">Object.assign</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1d95" class="mq lc iq mh b gy mr ms l mt mu">const cloned = arr.map(a =&gt; Object.assign({}, a));</span></pre><p id="10db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">map</code>并用<code class="fe me mf mg mh b">Object.assign</code>返回每个条目的克隆。</p><p id="4872" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用扩展语法来简化它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d36f" class="mq lc iq mh b gy mr ms l mt mu">const cloned = arr.map(a =&gt; ({...a}));</span></pre><p id="810a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以直接传播:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bd73" class="mq lc iq mh b gy mr ms l mt mu">const cloned = [...arr];</span></pre><p id="20f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们做一个<code class="fe me mf mg mh b">arr</code>的浅层克隆。</p><h1 id="7493" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">打印JavaScript对象的内容</h1><p id="54fe" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要打印JavaScript对象的内容，我们可以使用<code class="fe me mf mg mh b">JSON.stringify</code>方法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="181c" class="mq lc iq mh b gy mr ms l mt mu">console.log(JSON.stringify(obj, undefined, 2));</span></pre><p id="9eee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过传递要打印的对象作为第一个参数来使用<code class="fe me mf mg mh b">JSON.stringify</code>。</p><p id="3a4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是条目的可选映射函数。</p><p id="61d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不需要，所以传入<code class="fe me mf mg mh b">undefined</code>。</p><p id="13d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三个参数是用于缩进的空格数，我们传入2是为了方便阅读。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/4720b7965565d06229d5b048d7a3beca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZRK4DGIB7ipPvZ7Y"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@abnair?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aswathy N</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="9459" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="354e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">JSON.stringify</code>来克隆和打印物体。</p><p id="115d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">toFixed</code>让我们格式化浮点数。</p><p id="14bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">承诺不是回电。</p><h2 id="b076" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="25f2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>