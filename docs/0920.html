<html>
<head>
<title>GraphQL Pagination best practices: Using Edges vs Nodes in Connections</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">GraphQL分页最佳实践:在连接中使用边和节点</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/graphql-pagination-using-edges-vs-nodes-in-connections-f2ddb8edffa0?source=collection_archive---------1-----------------------#2020-01-03">https://javascript.plainenglish.io/graphql-pagination-using-edges-vs-nodes-in-connections-f2ddb8edffa0?source=collection_archive---------1-----------------------#2020-01-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9af4b2cb0fe0bb7471168ee3af08d35c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*17BqKGP9QwsjLx4qToGhew.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@s_erwin?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Sam Erwin</a> on <a class="ae kc" href="https://unsplash.com/s/photos/web?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5186" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在技术上没有放之四海而皆准的解决方案，每一个选择都需要权衡。了解我们工具的注意事项有助于我们选择问题的最佳解决方案。GraphQL连接也是如此。尽管graphql connections为我们提供了许多有用的<a class="ae kc" href="https://graphql.org/learn/pagination/#complete-connection-model" rel="noopener ugc nofollow" target="_blank">好处</a>，但为生产就绪的graphql API设计它们仍然很麻烦。</p><p id="bbee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GraphQL中分页的当前前景受到连接的<a class="ae kc" href="https://facebook.github.io/relay/graphql/connections.htm" rel="noopener ugc nofollow" target="_blank">中继规范</a>的巨大影响。GraphQL连接使用基于光标的分页，与基于偏移量的分页相比，它非常适合大型数据集(查看这篇关于此主题的优秀文章<a class="ae kc" href="https://slack.engineering/evolving-api-pagination-at-slack-1c1f644f8e12" rel="noopener ugc nofollow" target="_blank">和</a>)。自从脸书创建了GraphQL，推荐的连接中继规范就被采纳为GraphQL分页的事实上的标准。</p><p id="7468" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">GraphQL旨在让前端开发人员更容易使用API，Relay规范的部分内容与此相矛盾。来自GraphQL规范:</p><blockquote class="lc ld le"><p id="2c71" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated"><a class="ae kc" href="https://graphql.github.io/graphql-spec/draft/#sel-EADRDDAAACBvDgrB" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">以产品为中心的</strong> : GraphQL是由视图和编写视图的前端工程师的需求驱动的。</a></p></blockquote></div><div class="ab cl li lj hu lk" role="separator"><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln lo"/><span class="ll bw bk lm ln"/></div><div class="ij ik il im in"><h2 id="de31" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">问题:</h2><p id="3f50" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">我们发现我们组织中GraphQL API的消费者一直感到困惑的事情之一是<strong class="kf ir">在使用</strong> <code class="fe mn mo mp mq b"><strong class="kf ir">connection.</strong></code>时对中间 <code class="fe mn mo mp mq b"><strong class="kf ir">edges</strong></code> <strong class="kf ir">的需求，因为我们在API中使用Relay spec进行连接，所以我们以前从未考虑过这个问题。连接的继电器规范建议</strong></p><blockquote class="lc ld le"><p id="9f3c" class="kd ke lb kf b kg kh ki kj kk kl km kn lf kp kq kr lg kt ku kv lh kx ky kz la ij bi translated">连接类型必须具有名为<code class="fe mn mo mp mq b">edges</code>和<code class="fe mn mo mp mq b">pageInfo.</code>的字段，边缘类型必须具有名为<code class="fe mn mo mp mq b">node</code>和<code class="fe mn mo mp mq b">cursor</code>的字段。</p></blockquote><p id="9e21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们必须为<code class="fe mn mo mp mq b">organization.repositories</code>设计Github的GraphQL模式。这种模式的模式定义语言(SDL)模式如下所示:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="7dd7" class="lp lq iq mq b gy mz na l nb nc">type Query {<br/>    organization(name: String): Organization<br/>}</span><span id="e4d3" class="lp lq iq mq b gy nd na l nb nc">type Organization {<br/>   repositories(<br/>      first: Int<br/>      after: Int<br/>      last: Int<br/>      before: Int<br/>   ): RepositoriesConnection<br/>}</span><span id="3e63" class="lp lq iq mq b gy nd na l nb nc">type RepositoriesConnection {<br/>    edges: [RepositoryEdge!]!<br/>    pageInfo: PageInfo<br/>    totalCount: Int<br/>}</span><span id="edf8" class="lp lq iq mq b gy nd na l nb nc">type RepositoryEdge {<br/>    node: Repository!<br/>    cursor: PageInfo<br/>}</span><span id="2241" class="lp lq iq mq b gy nd na l nb nc">type Repository {<br/>    name<br/>    ... other fields for repository<br/>}</span></pre><p id="aa02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常的连接查询如下所示</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ne"><img src="../Images/84f6ef3ed40b5c80ae34d9015019ee39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o_ub5lCqAL5KizN97AhZhw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Query connection.edges for repository of organization Zalando</figcaption></figure><p id="b28a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这无意中迫使大多数GraphQL API消费者使用这种方式访问节点上的信息，即使他们可能不需要下一页的连接上的<code class="fe mn mo mp mq b">cursor</code></p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="3da7" class="lp lq iq mq b gy mz na l nb nc">const response = await getGraphqlResponse(query);<br/>const repos = response.data.organization.repositories;<br/>const repoNames = repos.edges.map(edge =&gt; edge.node.name)</span></pre><h2 id="9019" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">解决办法</h2><p id="e6eb" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">经过思考、讨论和研究，我们找到了一个从消费者的角度来看实用且语义直观的解决方案。我们决定在我们的关系上与<code class="fe mn mo mp mq b">Connection.edges</code>一起支持<code class="fe mn mo mp mq b">Connection.nodes</code>。这解决了我们的消费者必须在连接上访问中间<code class="fe mn mo mp mq b">edges</code>的目的。连接的模式定义如下所示</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="557d" class="lp lq iq mq b gy mz na l nb nc">...</span><span id="d32d" class="lp lq iq mq b gy nd na l nb nc">type RepositoriesConnection {<br/>    edges: [RepositoryEdge!]!<br/>    nodes: [Repository!]! ## allows to directly access Repository<br/>    pageInfo: PageInfo<br/>    totalCount: Int<br/>}</span><span id="fc33" class="lp lq iq mq b gy nd na l nb nc">...</span></pre><p id="b09e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从连接中获取存储库名称的查询被简化了很多，如下所示</p><figure class="mr ms mt mu gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/eb59caf33f48c28dffae3b94902071c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S4oLU42lzI3IMjSRZFYGmQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Query connection.nodes for repository of organization Zalando</figcaption></figure><p id="127f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且在代码中访问它不那么麻烦</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="91a0" class="lp lq iq mq b gy mz na l nb nc">const response = await getGraphqlResponse(query);<br/>const repos = response.data.organization.repositories;<br/>const names = repos.nodes.map(node =&gt; node.name);// No `edge` needed</span></pre><p id="b5de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个模型非常成功，Github已经在他们的GraphQL API上支持它了。以上截图摘自<a class="ae kc" href="https://developer.github.com/v4/explorer/" rel="noopener ugc nofollow" target="_blank"> Github的GraphQL v4 </a></p><h2 id="75a9" class="lp lq iq bd lr ls lt dn lu lv lw dp lx ko ly lz ma ks mb mc md kw me mf mg mh bi translated">建议:</h2><p id="65b3" class="pw-post-body-paragraph kd ke iq kf b kg mi ki kj kk mj km kn ko mk kq kr ks ml ku kv kw mm ky kz la ij bi translated">但是<code class="fe mn mo mp mq b">Connection.nodes</code>不是银弹，也不能取代对<code class="fe mn mo mp mq b">Connection.edges</code>的需求。当您需要用<code class="fe mn mo mp mq b">cursor</code>对一个非常大的连接对象进行分页时，边仍然是您的goto解决方案。</p><blockquote class="ng"><p id="54b3" class="nh ni iq bd nj nk nl nm nn no np la dk translated"><em class="nq">"当您有一个有限的列表要使用，但不需要光标分页时，请使用</em> <code class="fe mn mo mp mq b"><em class="nq">Nodes</em></code> <em class="nq">。当你有一个大的列表并且你需要知道光标来分页时，使用</em> <code class="fe mn mo mp mq b"><em class="nq">Edges</em></code> <em class="nq"/></p></blockquote><h2 id="9c76" class="lp lq iq bd lr ls nr dn lu lv ns dp lx ko nt lz ma ks nu mc md kw nv mf mg mh bi translated">参考资料:</h2><ol class=""><li id="6c5f" class="nw nx iq kf b kg mi kk mj ko ny ks nz kw oa la ob oc od oe bi translated"><a class="ae kc" href="https://graphql.github.io/graphql-spec/draft" rel="noopener ugc nofollow" target="_blank"> GraphQL规格</a></li><li id="2f15" class="nw nx iq kf b kg of kk og ko oh ks oi kw oj la ob oc od oe bi translated"><a class="ae kc" href="https://blog.apollographql.com/explaining-graphql-connections-c48b7c3d6976" rel="noopener ugc nofollow" target="_blank">解释GraphQL连接</a></li><li id="d32f" class="nw nx iq kf b kg of kk og ko oh ks oi kw oj la ob oc od oe bi translated"><a class="ae kc" href="https://facebook.github.io/relay/graphql/connections.htm" rel="noopener ugc nofollow" target="_blank">继电器图QL连接规范</a></li><li id="1818" class="nw nx iq kf b kg of kk og ko oh ks oi kw oj la ob oc od oe bi translated"><a class="ae kc" href="https://slack.engineering/evolving-api-pagination-at-slack-1c1f644f8e12" rel="noopener ugc nofollow" target="_blank">在空闲时发展API分页</a></li></ol></div></div>    
</body>
</html>