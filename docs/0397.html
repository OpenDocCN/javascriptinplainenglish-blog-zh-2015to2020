<html>
<head>
<title>Frequency Counter Algorithm</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">频率计数器算法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/frequency-counter-algorithm-405424e00f0c?source=collection_archive---------1-----------------------#2019-10-05">https://javascript.plainenglish.io/frequency-counter-algorithm-405424e00f0c?source=collection_archive---------1-----------------------#2019-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7967" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">第1部分:使用Javascript对象查找数组中的元素</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/91961d058e72c0742b088b119b8bc9bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SNJo_NBDu5edvAmqao86DA.png"/></div></div></figure><p id="44eb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">许多面试、<a class="ae ln" href="https://leetcode.com/" rel="noopener ugc nofollow" target="_blank"> LeetCode </a>、<a class="ae ln" href="https://www.hackerrank.com/" rel="noopener ugc nofollow" target="_blank"> HackerRank </a>、<a class="ae ln" href="https://www.codewars.com/" rel="noopener ugc nofollow" target="_blank"> CodeWars </a>和其他类似网站的编码挑战都涉及到计数或寻找数组中的元素。最近，我参加了一个技术面试，我遇到了两个问题。两者都涉及到这种模式的使用。我们来看其中一个！</p><h2 id="a8e3" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated">//在一个数组中找到两部电影，将<strong class="ak">加起来正好是</strong>给定的飞行长度</h2><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="99fd" class="lo lp iq mi b gy mm mn l mo mp">// Find 2 movies in an array that add up <strong class="mi ir">EXACTLY</strong> to a given flight   length</span><span id="edc5" class="lo lp iq mi b gy mq mn l mo mp">// <strong class="mi ir">Input</strong><br/>// flightLength: duration of the flight in minutes (integer)<br/>// movieLengths: array of movie times in minutes (array of integers)</span><span id="98cf" class="lo lp iq mi b gy mq mn l mo mp">//<strong class="mi ir"> Output</strong><br/>// boolean, true if there exists TWO movies that add up EXACTLY to the flightLength</span><span id="2d90" class="lo lp iq mi b gy mq mn l mo mp">// <strong class="mi ir">Examples</strong><br/>// flightLength 160<br/>// [80, 110, 40] =&gt; false, because no two movies = 160<br/>// [80, 110, 80] =&gt; true, because 80 + 80 = 160<br/>// [20, 30, 110, 40, 50] =&gt; true, because 110 + 50 = 160</span></pre><p id="14ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我的第一个反应(也是最常见的一个)是循环遍历数组，对于数组中的每部电影，再次循环遍历数组<strong class="kt ir">和</strong>，看看是否有另一部电影加在一起等于飞行长度。</p><p id="ccae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大概是这样的:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="83f3" class="lo lp iq mi b gy mm mn l mo mp"><strong class="mi ir">function find2Movies(flightLength, movies){</strong><br/>  //loop through every movie  <br/>  <strong class="mi ir">for(let i = 0; i &lt; movies.length; i++){</strong><br/>    //loop through every movie AGAIN<br/>    <strong class="mi ir">for(let j = 0; j &lt; movies.length; j++){</strong><br/>      //if the movies are different<br/>      <strong class="mi ir">if (i !== j){</strong><br/>        // if the sum of the 2 movies equals the flight length<br/>        <strong class="mi ir">if (movies[i] + movies[j] === flightLength){</strong><br/>          // Then return true<br/>          <strong class="mi ir">return true </strong><br/>        <strong class="mi ir">}</strong><br/>      <strong class="mi ir">}</strong> <br/>    <strong class="mi ir">}</strong><br/>  <strong class="mi ir">}</strong></span><span id="b321" class="lo lp iq mi b gy mq mn l mo mp">  // If you went through the loops and didn't find any movies that <br/>  // add up EXACTLY to a given flight length, return false<br/>  <strong class="mi ir">return false</strong><br/><strong class="mi ir">}</strong></span></pre><p id="f084" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是如何运行的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/611357e15a422e560bcfd456c92e7753.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*U_C518XyQy42_yEeI12BzA.gif"/></div></div></figure><p id="bb5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，除了它是O <strong class="kt ir"> (n ) </strong>之外，这将是非常好的。对于数组中的每个元素，循环遍历数组中的每个元素。这是一批<strong class="kt ir">迭代。如果你有100部电影，你必须检查100 * 100 = 10，000个案例。如果你有1000部电影，那就是100万个案例。扩展性不好。</strong></p><h1 id="0a86" class="ms lp iq bd lq mt mu mv lt mw mx my lw jw mz jx lz jz na ka mc kc nb kd mf nc bi translated">100部电影？一万箱！</h1><h1 id="9390" class="ms lp iq bd lq mt mu mv lt mw mx my lw jw mz jx lz jz na ka mc kc nb kd mf nc bi translated">1000部电影？100万箱？！</h1><p id="f5c9" class="pw-post-body-paragraph kr ks iq kt b ku nd jr kw kx ne ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">这就是所谓的暴力方法。你正在评估每一个可能的测试用例。</p><p id="e6af" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们评估一下我们的方法。</p><p id="0605" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要在数组中寻找一个元素，我们必须遍历数组，试图找到它，也就是O(n)。当我们在循环中这样做时，我们得到O(n)。</p><h2 id="af34" class="lo lp iq bd lq lr ls dn lt lu lv dp lw la lx ly lz le ma mb mc li md me mf mg bi translated"><strong class="ak">还有一个更高效的方法。</strong></h2><p id="64a6" class="pw-post-body-paragraph kr ks iq kt b ku nd jr kw kx ne ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">进入<strong class="kt ir">频率计数器</strong> <strong class="kt ir">算法</strong>。这个模式是关于滥用你可以在<strong class="kt ir">常量时间</strong>，O(1)中寻找一个对象中的元素的事实。</p><p id="2678" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它的工作原理是将你想在对象内部看到的值存储为一个键。然后，您可以比较当前迭代的电影是否在您的对象中。代码应该是这样的:</p><pre class="kg kh ki kj gt mh mi mj mk aw ml bi"><span id="dd48" class="lo lp iq mi b gy mm mn l mo mp"><strong class="mi ir">function find2Movies(flightLength, movies){</strong><br/>  // create an object<br/> <strong class="mi ir"> let results = {}</strong><br/><strong class="mi ir"> </strong> // loop through every movie<br/>  <strong class="mi ir">for(let i = 0; i &lt; movies.length; i++){</strong><br/>    // If current movie is inside your object<br/> <strong class="mi ir">   if (results[movies[i]]){<br/>      </strong>// Then return true<strong class="mi ir"><br/>      return true <br/>    }</strong><br/>    // Otherwise, add the movie that would pair with our current<br/>    // movie to our object <br/>    // We know what that movie's length should be by <br/>    // subtracting the current movie's length from the flight length <br/>    <strong class="mi ir">let result = flightLength — movies[i]<br/>    results[result] = true<br/>  }<br/>  </strong><br/>  // If you went through the loops and didn't find any movies that <br/>  // add up EXACTLY to a given flight length, return false<br/><strong class="mi ir">  return false<br/>}</strong></span></pre><p id="d51f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是如何运行的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/fc6a15fe86d096b7a8a67cb5b9267c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AnG6EGDpZmZp5J4hKFxycA.gif"/></div></div></figure><p id="2eef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这更快，快得多。使用<strong class="kt ir">频率计数器</strong> <strong class="kt ir">算法</strong>我们现在只需要对数组中的每个电影迭代一次。如果我们有100部电影，我们检查100个案例。如果我们有1000部电影，我们检查1000个案例。我们达到了O(n)。</p><h1 id="b382" class="ms lp iq bd lq mt mu mv lt mw mx my lw jw mz jx lz jz na ka mc kc nb kd mf nc bi translated">100部电影？100箱！</h1><h1 id="2622" class="ms lp iq bd lq mt mu mv lt mw mx my lw jw mz jx lz jz na ka mc kc nb kd mf nc bi translated">1000部电影？1000箱！</h1><p id="a679" class="pw-post-body-paragraph kr ks iq kt b ku nd jr kw kx ne ju kz la nf lc ld le ng lg lh li nh lk ll lm ij bi translated">这种模式适用于比这种情况更多的情况。如果你必须在一个数组中寻找元素，并且发现自己使用了嵌套循环，频率计数器很可能会帮助你更快地解决它！</p></div></div>    
</body>
</html>