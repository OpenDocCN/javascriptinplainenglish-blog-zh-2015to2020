<html>
<head>
<title>Build a Simple Chess AI in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript构建一个简单的象棋人工智能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-simple-chess-ai-in-javascript-22b350abb31?source=collection_archive---------3-----------------------#2020-12-20">https://javascript.plainenglish.io/build-a-simple-chess-ai-in-javascript-22b350abb31?source=collection_archive---------3-----------------------#2020-12-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a1a9" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">电路板评估和极大极小算法</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/517458e65af7cb99f097b49c421bdc78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gqEXyc5qfSceQpt6"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@grstocks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">GR Stocks</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5bd8" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">国际象棋是一项伟大的游戏。如果擅长就更好了。遗憾的是，我从来没有花时间学习象棋策略，所以我决定依靠计算和博弈论的力量来代替！作为一个有趣的业余项目，我用JavaScript实现了一个简单的象棋人工智能。</p><p id="cc6c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可以在我的<a class="ae ks" href="https://github.com/zeyu2001/chess-ai" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>中找到本教程的完整源代码。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lp"><img src="../Images/d3b405f094088b68f0c13337ae3faf17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j9HpWMAOCHXL5HuIV6IMzg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Play at <a class="ae ks" href="https://zeyu2001.github.io/chess-ai/" rel="noopener ugc nofollow" target="_blank">https://zeyu2001.github.io/chess-ai/</a></figcaption></figure><p id="fa7b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最终产品可以在https://zeyu2001.github.io/chess-ai/的<a class="ae ks" href="https://zeyu2001.github.io/chess-ai/" rel="noopener ugc nofollow" target="_blank">播放。</a></p><h1 id="445e" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">先决条件</h1><p id="a61d" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">你应该知道基本编程和一个<a class="ae ks" href="https://en.wikipedia.org/wiki/Tree_(data_structure)" rel="noopener ugc nofollow" target="_blank">树</a>数据结构的<em class="mn">一般</em>概念。其他内容将在本教程中介绍。</p><p id="4725" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">涉及的两个主要算法是<a class="ae ks" href="https://en.wikipedia.org/wiki/Minimax" rel="noopener ugc nofollow" target="_blank">最小最大算法</a>和<a class="ae ks" href="https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning" rel="noopener ugc nofollow" target="_blank">阿尔法-贝塔剪枝</a>。这些将在后面深入解释，如果你有编程经验，应该相对容易掌握。</p><h1 id="9e13" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">重要的事情先来</h1><p id="6625" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">摆脱图形用户界面和游戏机制。这使得我们可以将注意力集中在应用程序最吸引人的方面:决策(AI)部分！为此，我们将使用外部库:</p><ul class=""><li id="e9c4" class="mo mp in kv b kw kx kz la lc mq lg mr lk ms lo mt mu mv mw bi translated"><a class="ae ks" href="https://chessboardjs.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mn">棋盘. js </em> </a>处理图形界面，即棋盘本身。</li><li id="a886" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated"><a class="ae ks" href="https://github.com/jhlywa/chess.js" rel="noopener ugc nofollow" target="_blank"> <em class="mn"> chess.js </em> </a>处理游戏机制，如棋步生成/验证。</li></ul><p id="4d94" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了这些库，你应该能够按照<em class="mn">棋盘. js </em>网站上的<a class="ae ks" href="https://chessboardjs.com/examples#5000" rel="noopener ugc nofollow" target="_blank">示例</a>(特别是5000到5005)来创建一个有效的国际象棋游戏。</p><h1 id="9a25" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">评价函数</h1><p id="87b4" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">太好了！我们有一个正常运转的棋盘。但是我们如何实现一个能下(相当)好棋的人工智能呢？嗯，我们需要一个<em class="mn">评估函数。基本上，我们希望给每个棋盘实例(即棋盘上每组棋子位置)分配一个“分数”，这样我们的人工智能就可以决定哪些位置比其他位置更有利。</em></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nc"><img src="../Images/1c8d735abd0dab18357b2c51065cdbfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1346/format:webp/0*bsSnIR7Zc-C_SMq1.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Evaluation Function</figcaption></figure><h2 id="772c" class="nd lr in bd ls ne nf dn lw ng nh dp ma lc ni nj mc lg nk nl me lk nm nn mg no bi translated">零和游戏</h2><p id="3db8" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">国际象棋是一个零和游戏。玩家A获得的任何优势都意味着玩家b的劣势。优势可以表现为夺取对手的棋子，或者将棋子放在有利的位置。因此，当从我们人工智能的角度分配分数时，正分数意味着我们人工智能的整体优势和对手的劣势，而负分数意味着我们人工智能的整体劣势和对手的优势。</p><h2 id="88ab" class="nd lr in bd ls ne nf dn lw ng nh dp ma lc ni nj mc lg nk nl me lk nm nn mg no bi translated">简单的例子</h2><p id="ba54" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">例如，开始位置的分数是0，表明双方都没有优势。在游戏的后期，我们面临着两个行动之间的决定:移动A和移动B。假设移动A捕获了一个女王，我们的分数为900，而移动B捕获了一个棋子，我们的分数为100。</p><p id="2f4a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">人工智能将能够比较两种潜在的情况，并决定移动A是更好的移动。当然，这并没有考虑未来的影响——如果移动A给了我们的对手进攻的机会呢？在接下来的章节中，我们将通过执行前瞻来预测后续的移动，从而克服这个障碍。</p><h2 id="fc0b" class="nd lr in bd ls ne nf dn lw ng nh dp ma lc ni nj mc lg nk nl me lk nm nn mg no bi translated">单件重量</h2><p id="9729" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我们评估的第一个方面是为每种类型的产品分配重量。如果我们的人工智能从黑棋的角度出发，任何黑棋都将增加我们的分数，而任何白棋都将根据以下权重从我们的分数中减去:</p><ul class=""><li id="1905" class="mo mp in kv b kw kx kz la lc mq lg mr lk ms lo mt mu mv mw bi translated">卒:100</li><li id="a250" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">骑士:280</li><li id="9c14" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">主教:320</li><li id="e99a" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">479</li><li id="cf45" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">女王:929</li><li id="f879" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo mt mu mv mw bi translated">国王:六万</li></ul><h2 id="c0e4" class="nd lr in bd ls ne nf dn lw ng nh dp ma lc ni nj mc lg nk nl me lk nm nn mg no bi translated">块方桌</h2><p id="606e" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我们现在有了一个分数，它基于棋盘上存在的棋子，但是有些位置比其他位置更有利。例如，给予较高流动性的职位应该更有利。为此，我们使用<em class="mn">棋子方桌</em> (PSTs)，它根据每个棋子在棋盘上的位置为其分配一个额外的分数增量。</p><p id="b529" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，骑士的PST鼓励向中心移动:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi np"><img src="../Images/cfe09cad88054335fac016c71d1b5a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dD4sSaTsCUvyiLG2eRTgag.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Piece Square Table, Knight</figcaption></figure><p id="c218" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是从白色的角度来看，所以它必须被黑色反射。</p><p id="e87a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我当然不是象棋专家，所以棋子重量和PST值改编自<a class="ae ks" href="https://github.com/thomasahle/sunfish/blob/master/sunfish.py" rel="noopener ugc nofollow" target="_blank"> Sunfish.py </a>。下面是我对评价函数的实现。请注意，我们不是对每次评估迭代64个方格，而是简单地从0开始，根据最新的移动增加或减少分数，跟踪以前的分数。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="657e" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">极大极小</h1><p id="b869" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">现在我们有了评估算法，我们可以开始做出明智的决策了！我们将为此使用极大极小算法，我强烈推荐阅读维基百科文章<a class="ae ks" href="https://en.wikipedia.org/wiki/Minimax" rel="noopener ugc nofollow" target="_blank">来更好地理解这个决策策略。</a></p><h2 id="87f2" class="nd lr in bd ls ne nf dn lw ng nh dp ma lc ni nj mc lg nk nl me lk nm nn mg no bi translated">博弈树</h2><p id="c38f" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我们可以将棋盘位置表示为<em class="mn">博弈树中的节点。</em>每个节点都是一个棋盘实例，并且有对应于可以从父节点采取的可能走法的子节点。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/42f2d8c4c6f416508a4e25cbea52ecf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1078/format:webp/0*zI7Habz1lTG7GeA0.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Chessboard Positions as Tree Nodes</figcaption></figure><h2 id="6dc0" class="nd lr in bd ls ne nf dn lw ng nh dp ma lc ni nj mc lg nk nl me lk nm nn mg no bi translated">最小化损失</h2><p id="be41" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">本质上，minimax旨在最小化可能的损失，假设双方都是理性的决策者。我们可以将可能的移动表示为博弈树，其中每一层在最大化和最小化玩家之间交替。我们是最大化玩家，试图最大化我们的分数，而对手是最小化玩家，试图最小化我们的分数。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/fabbb6c96b97d8ff1eb92adb04f94b3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GWxQ2PSEz-sipgmK.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Game Tree, Minimax Algorithm</figcaption></figure><p id="39b1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在叶节点，评估的分数被回溯。正无穷大和负无穷大分别是赢和输。在每个递归层，最大化和最小化角色是交替的。第0层是当前的游戏状态，目标是最大化我们的分数。</p><h2 id="bb5b" class="nd lr in bd ls ne nf dn lw ng nh dp ma lc ni nj mc lg nk nl me lk nm nn mg no bi translated">交替移动</h2><p id="2e54" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我们的人工智能要回答的问题是:“在第0层所有可能的移动中，哪个<em class="mn">保证</em>得分最高？”</p><p id="2d20" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就好比问，“<em class="mn">假设我的对手总是做出最佳决策</em>，哪一步有可能获得最高分？”</p><p id="1753" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们想让我们的人工智能在国际象棋上表现得更好，我们就必须预测对手的下一步棋。当然，我们只能提前预测几个回合——要预测到最终的胜负状态在计算上是不可行的。我们将不得不引入一个<em class="mn">深度限制</em>，它对应于我们愿意向前看的回合数，并使用我们的评估函数来确定一旦我们达到深度限制时游戏状态的有利性。</p><h2 id="9115" class="nd lr in bd ls ne nf dn lw ng nh dp ma lc ni nj mc lg nk nl me lk nm nn mg no bi translated">该算法</h2><p id="4afa" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">这是一个有趣的递归问题，我建议尝试自己实现它，尽管我的实现可以在下面找到。如果你被卡住了，这里有一个总的想法:</p><ol class=""><li id="bdfe" class="mo mp in kv b kw kx kz la lc mq lg mr lk ms lo nu mu mv mw bi translated">我们决定一个预定的深度极限。</li><li id="b49e" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo nu mu mv mw bi translated">在第0层，我们考虑每个可能的移动，即子节点。</li><li id="2c82" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo nu mu mv mw bi translated">对于每个子节点，我们考虑对手能迫使我们接受的最低分数。然后，我们选择最大节点。</li><li id="48f1" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo nu mu mv mw bi translated">但是要知道对手能逼我们收的最低分，就必须到第1层。对于第1层中的每个节点，我们考虑它们的子节点。</li><li id="a633" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo nu mu mv mw bi translated">对于每个子节点(对手可能的移动)，我们考虑我们随后可以达到的最高分数。那么，对手能逼我们收的最低分就是最小节点。</li><li id="0b79" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo nu mu mv mw bi translated">但是要知道我们随后可以达到的最高分数，我们必须到第2层。</li><li id="a159" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo nu mu mv mw bi translated">诸如此类。</li><li id="19ae" class="mo mp in kv b kw mx kz my lc mz lg na lk nb lo nu mu mv mw bi translated">在层<em class="mn"> k </em>处，评估最终的棋盘状态，并回溯到层<em class="mn"> k - 1 </em>，这一直持续到我们到达层0，此时我们可以最终回答:“此时的最优移动是什么？”</li></ol><p id="1405" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是我的实现。注意，我使用了稍微修改过的<em class="mn"> chess.js </em>版本，它允许我使用<code class="fe nv nw nx ny b">game.ugly_moves()</code>和<code class="fe nv nw nx ny b">game.ugly_move()</code>来生成和进行移动，而无需将它们转换为人类可读的格式，提高了算法的效率。修改后的版本可以在这里找到<a class="ae ks" href="https://github.com/zeyu2001/chess-ai/blob/main/js/chess.js" rel="noopener ugc nofollow" target="_blank"/>，但是使用普通的<code class="fe nv nw nx ny b">game.moves()</code>和<code class="fe nv nw nx ny b">game.move()</code>也可以。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="5e94" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">阿尔法-贝塔剪枝</h1><p id="b8ae" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我们的人工智能现在应该能够做出相当好的决定。搜索深度越高，会玩的越好。但是，增加搜索深度会显著增加执行时间。<a class="ae ks" href="https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning" rel="noopener ugc nofollow" target="_blank"> Alpha-beta修剪</a>通过“修剪”我们不需要评估的分支，帮助提高算法的效率。可以在<a class="ae ks" href="http://web.cs.ucla.edu/~rosen/161/notes/alphabeta.html" rel="noopener ugc nofollow" target="_blank">这里</a>找到额外的阅读资源。</p><h2 id="59a7" class="nd lr in bd ls ne nf dn lw ng nh dp ma lc ni nj mc lg nk nl me lk nm nn mg no bi translated">核心理念</h2><p id="1ec8" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">阿尔法-贝塔剪枝的核心思想是，当至少有一种可能性被发现，证明一步棋比之前检查过的一步棋更差时，我们可以停止评估一步棋。</p><p id="f304" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设博弈树如下:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nz"><img src="../Images/b55fce3a9fddff26648b8af605ac81b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1lq4oW9h9Z46OiV6.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Minimax with Alpha-beta Pruning</figcaption></figure><p id="fe8d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了简洁起见，让我们考虑下面的子树:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oa"><img src="../Images/76be599223a3156d0eefdd76dbaf1392.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*bABfTmyI-t3iOIggo4pB5A.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Subtree, Alpha-beta Pruning</figcaption></figure><p id="c83d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最大化玩家首先考虑左边的孩子，并确定它的值为5。其他路径只有在它们的值为<code class="fe nv nw nx ny b">x &gt; 5</code>时才会被选择。</p><p id="42b6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">接下来考虑合适的孩子。最小化玩家，在右边的孩子，到目前为止已经找到了值7和4。但是这意味着不管剩余值是多少，最小化玩家最终得到的最小值最多是4。我们知道这个子树的最终值是<code class="fe nv nw nx ny b">x &lt;= 4</code>，不考虑剩余的值。</p><p id="9628" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了使该路径相关，<code class="fe nv nw nx ny b">x &gt; 5</code>。但是我们知道<code class="fe nv nw nx ny b">x &lt;= 4</code>。这是一个矛盾，所以最大化玩家不会选择这条路，进一步评估这条路是没有意义的。</p><h2 id="f8bd" class="nd lr in bd ls ne nf dn lw ng nh dp ma lc ni nj mc lg nk nl me lk nm nn mg no bi translated">该算法</h2><p id="a14e" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">同样的想法可以扩展到游戏树的其他部分。我们使用两个变量，<em class="mn"> alpha </em>和<em class="mn"> beta </em>，来分别跟踪最大化和最小值(上例中为5和4)。这只需要对前面的minimax函数进行微小的修改——看看你自己能不能实现！</p><p id="928a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面是我的实现:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="9a38" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">结论</h1><p id="069a" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">仅此而已！我希望你喜欢读这篇文章，就像我喜欢写它一样。我已经解释了我是如何实现我的人工智能的，并希望向你介绍几个新的有趣的概念。</p><p id="c8fe" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我还实现了一些其他功能，包括让人工智能与自身对抗。你可以在<a class="ae ks" href="https://zeyu2001.github.io/chess-ai/" rel="noopener ugc nofollow" target="_blank">https://zeyu2001.github.io/chess-ai/</a>玩，具体可以参考我的<a class="ae ks" href="https://github.com/zeyu2001/chess-ai" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>实现。</p></div></div>    
</body>
</html>