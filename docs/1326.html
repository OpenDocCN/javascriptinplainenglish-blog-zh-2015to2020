<html>
<head>
<title>A journey from Callbacks to Async Await in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中从回调到异步等待的旅程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-a-fast-trip-for-dummies-from-callbacks-to-es6-async-await-a61b0a4b0bed?source=collection_archive---------7-----------------------#2020-03-01">https://javascript.plainenglish.io/javascript-a-fast-trip-for-dummies-from-callbacks-to-es6-async-await-a61b0a4b0bed?source=collection_archive---------7-----------------------#2020-03-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f6a0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简明、有用的JavaScript课程——让它变得简单。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8b146c747bffa2a365e39905d9ec3cd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DxoBtB-wdUntxSKiDntYTw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">From callbacks to async/await in JavaScript ES6</figcaption></figure><h1 id="b696" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">历史</h1><p id="e95d" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">软件程序被定义为一组指令，它们按顺序一次运行一个。在代码执行期间，一个函数中的指令可能会调用另一个服务。当另一个服务完成时，它返回到我们的原始函数，并带有一些返回值，它可以继续执行另一个任务。在此期间，原始函数正在等待另一个服务完成，我们将此称为<strong class="lp ir">同步</strong>执行。</p><p id="1ac5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">当你异步执行某个<strong class="lp ir"/>的时候，你可以在它完成之前转移到另一个任务，而原来的函数<strong class="lp ir">不会等待</strong>另一个函数结束。</p><p id="f193" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">计算机在设计上是异步的。例如，当机器在磁盘上写入时，您可以继续浏览互联网。在目前的计算机中，每个程序运行一个特定的时间段，然后它停止执行，让另一个程序继续执行。</p><p id="8534" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">通常，编程语言是同步的，但是它们提供了管理异步的方法。</p><p id="b7f8" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">JavaScript默认为<strong class="lp ir">同步</strong>，而<strong class="lp ir">为单线程</strong>。代码不能创建新的线程并并行运行。</p><p id="6412" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">起初，JavaScript被创建为仅在浏览器中执行，其主要工作是运行用户动作，例如点击按钮或移动鼠标。这些动作是阻塞的，如果没有继续执行其他指令的机制，浏览器将被冻结。</p><p id="1325" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">同步与异步:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mo"><img src="../Images/eec83f941057a2d65393d5ea376e0886.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*euVtpvNa-gwGDpuTPb3zAQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Synchronous v.s Asynchronous sketch</figcaption></figure><h1 id="0f52" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">复试</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mp"><img src="../Images/40a6183c70e082c6bf608ec441e21e0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SIzexX-18S3UfBEf4hWFDA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Callbacks pyramid of doom sketch</figcaption></figure><p id="0660" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">回调是在另一个任务执行完毕后运行<strong class="lp ir">的函数。例如，这是一个两秒钟后运行的简单回调:</strong></p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="741e" class="mv kw iq mr b gy mw mx l my mz">...<br/>...</span><span id="8fd0" class="mv kw iq mr b gy na mx l my mz">setTimeout( () =&gt; {<br/>  console.log('Me second!');<br/>}, 2000);</span><span id="dbc8" class="mv kw iq mr b gy na mx l my mz">console.log("Me first");</span><span id="8971" class="mv kw iq mr b gy na mx l my mz">//Me first</span><span id="d380" class="mv kw iq mr b gy na mx l my mz">//Me second!</span><span id="bd95" class="mv kw iq mr b gy na mx l my mz">...<br/>...</span></pre><p id="d26b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">当调用setTimeout()时，这是对API的调用，这个函数从执行堆栈中移出，当超时完成时，回调被推入队列。一旦执行堆栈为空，事件循环将从队列中取出回调，并将其添加到执行堆栈中。</p><p id="0875" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">回调的问题是著名的回调地狱。如果代码有很多回调，很难直观地得到正确的结果。当多个函数需要来自其他函数的数据来完成它们的工作时，就会发生这种情况。对于回调，代码最终看起来如下例所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/1af836a54aa66bfcc36b11e2a166b66e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-0VTidELw_FrMIm4FhSv5w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Callback hell image</figcaption></figure><p id="69a6" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">现在，想象这种情况进一步发生，有5个或10个嵌套函数调用，试图理解代码在每一步做什么是疯狂的。</p><p id="a7b4" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">这些承诺是为了解决这些问题而产生的。</p><h1 id="68ee" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">承诺</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/99c19b8cb091ba2477a243d934d2996c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KwcncaZRP6AC_3RyGi2jBg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Promises sketch</figcaption></figure><p id="c646" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">承诺在ES6(2015)中引入。承诺是一个对象，它表示解决或拒绝的未来操作的结果。这是格式化异步函数的另一种方法。</p><p id="6020" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">主要区别是什么？</p><p id="b2f5" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">对我来说，最大的改进是格式。如果您正确地编写了代码，生成的代码将易于阅读。</p><p id="35aa" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">承诺立即返回一个承诺对象。它们不需要函数参数，也不需要嵌套。您使用名为<then>的Promise方法给出异步函数完成时要采取的动作。</then></p><p id="1715" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">当我们需要执行异步操作时，使用它们的<then>方法来链接承诺。每个链接的<then>函数返回一个新的承诺，表示链中另一个异步步骤的完成。类似于读:<do this="">然后做这个-&gt;然后做这个…&gt;</do></then></then></p><p id="9e28" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">上面使用承诺的同一个例子是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/082df485279e58ca4504b4bdc1e7006b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z_jeR4dBiARfNtn3McUgeQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Promises example image</figcaption></figure><h1 id="d5ba" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">异步等待</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/c35ab2334fe5aa014af53969e15d9c7a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*plxqQJ_4J19C277EOiZEaw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Async/Await sketch</figcaption></figure><p id="ac88" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">Async/Await是ES2017(ES8)的新增功能，它帮助我们甚至更多，允许我们在执行异步任务时编写完全同步的<strong class="lp ir">外观的</strong>代码。这仅仅是一种承诺。</p><p id="0c1e" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">与promises相比，它的主要优势在于，使用异步函数的代码的语法和结构更像使用标准同步函数，也更类似于我们顺序思考的方式。</p><p id="291b" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">一个异步函数可以包含<awaits>表达式，它暂停异步函数的执行并等待传递的承诺的解析。当承诺被解析后，将恢复异步函数的执行，并返回解析后的值。</awaits></p><p id="1487" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">上面使用承诺的同一个例子是:</p><p id="a222" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">注意:要使用<await>，需要将包含它的函数定义为async。</await></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/f7cc4dc92d6ed9f9f545f22b9e84d1fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oSmuKJgHThCn0y2A-4caOw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Async/await example image</figcaption></figure><h1 id="b4f5" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">结论</h1><p id="bfd6" class="pw-post-body-paragraph ln lo iq lp b lq lr jr ls lt lu ju lv lw lx ly lz ma mb mc md me mf mg mh mi ij bi translated">承诺和异步/等待完成同样的事情。它们使得处理异步代码更加自然。它们消除了回调的需要和著名的回调地狱。</p><p id="5bac" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">有了新的ES6 Async/Await附加功能，管理异步代码更像使用标准同步函数，也更类似于我们顺序思考的方式。Async/await是promises的语法糖，因为它仍然在幕后使用Promises，但是结果代码更加明确。</p><p id="c8e7" class="pw-post-body-paragraph ln lo iq lp b lq mj jr ls lt mk ju lv lw ml ly lz ma mm mc md me mn mg mh mi ij bi translated">感谢阅读。我希望这能帮助你们了解JavaScript中处理异步代码的不同方式。</p><h1 id="3e3b" class="kv kw iq bd kx ky kz la lb lc ld le lf jw lg jx lh jz li ka lj kc lk kd ll lm bi translated">参考</h1><ul class=""><li id="af53" class="ng nh iq lp b lq lr lt lu lw ni ma nj me nk mi nl nm nn no bi translated"><a class="ae np" href="https://developer.mozilla.org/en-US/" rel="noopener ugc nofollow" target="_blank">开发者Mozilla网站</a></li><li id="438f" class="ng nh iq lp b lq nq lt nr lw ns ma nt me nu mi nl nm nn no bi translated"><a class="ae np" href="https://en.wikipedia.org/wiki/Async/await" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Async/await</a></li></ul></div></div>    
</body>
</html>