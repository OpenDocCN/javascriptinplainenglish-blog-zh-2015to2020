<html>
<head>
<title>The Proper Way To Connect Redis — Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">连接Redis的正确方式— Node.js</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/proper-way-to-connect-redis-nodejs-80023fb033db?source=collection_archive---------2-----------------------#2020-10-19">https://javascript.plainenglish.io/proper-way-to-connect-redis-nodejs-80023fb033db?source=collection_archive---------2-----------------------#2020-10-19</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/6355df02e03992933f3f42d5d4fde73f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RvO-Dixmbq49R6BP-Retlg.png"/></div></figure><p id="99b7" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">你的客户是否长时间看到加载屏幕？您做了所有正确的事情，但是您仍然得到很高的响应时间甚至超时吗？您希望您的应用速度提高10倍、100倍、10000倍吗？Redis是来解决你所有问题的。</p><p id="68e5" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这让我想起了90年代的电视广告。反正我上面问的都是真题。如果您希望您的应用程序更快，添加内存缓存解决方案可以满足您的需求。有很多选项可供选择，例如你可以使用内存中的MongoDb，Ignite，Redis，Mem-cache等。所有这些技术都旨在让您的应用程序运行更快。</p><p id="1199" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我一直在NodeJs中使用Redis &amp; MongoDb组合，但是这篇文章的目的不是引导您找到完美的缓存策略。那是另一个话题了。</p><h1 id="2500" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">Redis是什么？</h1><p id="8f3b" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">Redis是一个键值数据结构存储，用作数据库、缓存和消息代理。Redis来自远程词典服务器。它使用ram来存储数据，因此它提供数据的速度快得惊人。它还支持集群，流，TTL，地理查询，发布/订阅等等。了解更多关于Redis的信息<a class="ae ls" href="https://redis.io/" rel="noopener ugc nofollow" target="_blank">点击此链接</a>。</p><p id="19d1" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">好了，让我们继续，我们需要设置我们的环境，</p><h1 id="a1af" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">我们需要什么？</h1><ul class=""><li id="d8f7" class="lt lu in jt b ju ln jy lo kc lv kg lw kk lx ko ly lz ma mb bi translated">NodeJs LTS — 10^</li><li id="f498" class="lt lu in jt b ju mc jy md kc me kg mf kk mg ko ly lz ma mb bi translated">Redis服务器</li><li id="5b22" class="lt lu in jt b ju mc jy md kc me kg mf kk mg ko ly lz ma mb bi translated">码头工人</li><li id="f71e" class="lt lu in jt b ju mc jy md kc me kg mf kk mg ko ly lz ma mb bi translated">Visual Studio代码</li></ul><h1 id="cb96" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">准备开始</h1><p id="f143" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">此时，我们需要安装依赖项。首先，我会在我的机器上安装Redis，顺便说一下，我们有很多选择，但我们是开发者，对不对？让我们用Docker运行安装它</p><p id="c028" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">另外，我写了关于Docker的介绍，如果你想看的话，可以随时通过<a class="ae ls" href="https://medium.com/faun/the-best-docker-introduction-8b518b6f0b05" rel="noopener">点击这个链接</a>来看。</p><p id="861b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果您已经安装了Docker，只需执行下面的命令来运行Redis服务器实例。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="da1d" class="mq kq in mm b gy mr ms l mt mu">docker run -d  --name redis_srv -p 6379:6379 redis</span></pre><p id="25e2" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">如果你不想安装Docker，我们可以简单地使用Redis实验室。打开<a class="ae ls" href="https://redislabs.com/try-free/" rel="noopener ugc nofollow" target="_blank">此链接</a>创建账户。</p><h1 id="98cc" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">好了，我们准备好出发了！</h1><p id="fd6f" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">按照以下步骤创建环境:</p><ul class=""><li id="d926" class="lt lu in jt b ju jv jy jz kc mv kg mw kk mx ko ly lz ma mb bi translated">创建一个空文件夹进行工作:</li></ul><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6b3e" class="mq kq in mm b gy mr ms l mt mu">mkdir connect-redis&amp;&amp; cd connect-redis</span></pre><ul class=""><li id="bc79" class="lt lu in jt b ju jv jy jz kc mv kg mw kk mx ko ly lz ma mb bi translated">初始化Node.js项目时，-y将跳过以下形式:</li></ul><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="36b2" class="mq kq in mm b gy mr ms l mt mu">npm init -y</span></pre><ul class=""><li id="fd49" class="lt lu in jt b ju jv jy jz kc mv kg mw kk mx ko ly lz ma mb bi translated">创建<strong class="jt io"> index.js </strong>:</li></ul><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="0443" class="mq kq in mm b gy mr ms l mt mu">touch index.js</span></pre><ul class=""><li id="9091" class="lt lu in jt b ju jv jy jz kc mv kg mw kk mx ko ly lz ma mb bi translated">编辑<strong class="jt io"> package.json </strong>如图所示:</li></ul><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="1f17" class="mq kq in mm b gy mr ms l mt mu">{<br/>  "name": "connect-redis",<br/>  "version": "0.0.0",<br/>  "private": true,<br/>  "scripts": {<br/>    "start": "node index",<br/>  },<br/>  "dependencies": {},<br/>  "devDependencies": {}<br/>}</span></pre><ul class=""><li id="2e77" class="lt lu in jt b ju jv jy jz kc mv kg mw kk mx ko ly lz ma mb bi translated">安装依赖项:</li></ul><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="fde0" class="mq kq in mm b gy mr ms l mt mu">npm install --save redis lodash</span></pre><ul class=""><li id="4a5d" class="lt lu in jt b ju jv jy jz kc mv kg mw kk mx ko ly lz ma mb bi translated">打开<strong class="jt io"> index.js </strong>，让我们定义依赖关系和我们的函数:</li></ul><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e6f2" class="mq kq in mm b gy mr ms l mt mu">const redis = require('redis');<br/>const _ = require('lodash');</span><span id="7000" class="mq kq in mm b gy my ms l mt mu">const clients = {};<br/>let connectionTimeout;</span><span id="9f80" class="mq kq in mm b gy my ms l mt mu">module.exports.init = () =&gt; {};</span><span id="e58d" class="mq kq in mm b gy my ms l mt mu">module.exports.getClients = () =&gt; {};</span><span id="a6a1" class="mq kq in mm b gy my ms l mt mu">module.exports.closeConnections = () =&gt; {};</span></pre><p id="01a8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">好了，我们定义了函数，让我们填充它们。首先，我们需要创建一个连接实例。我们这样做是因为将来我们可能需要第二次或第三次连接到另一个Redis数据库。不要问为什么，一个Redis是不够的，不要忘记用你的替换连接字符串！</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9d7d" class="mq kq in mm b gy mr ms l mt mu">module.exports.init = () =&gt; {<br/>    const cacheInstance = redis.createClient('redis://connection-string');<br/>    clients.cacheInstance = cacheInstance;<br/>};</span></pre><p id="0259" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们用Redis包创建了Redis连接，并将该连接保存在一个对象中，以便以后导入和使用。</p><p id="8dfe" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">根据连接的状态，将触发一些事件。最好是听他们采取行动。因为这个模块将管理整个连接流。我们需要知道任何中断或连接丢失。</p><p id="5835" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们看看这些事件是什么:</p><ul class=""><li id="cba5" class="lt lu in jt b ju jv jy jz kc mv kg mw kk mx ko ly lz ma mb bi translated">连接:成功连接后触发</li><li id="fdc9" class="lt lu in jt b ju mc jy md kc me kg mf kk mg ko ly lz ma mb bi translated">End:在连接断开时触发</li><li id="a476" class="lt lu in jt b ju mc jy md kc me kg mf kk mg ko ly lz ma mb bi translated">重新连接:当Redis试图连接时触发</li><li id="3ec3" class="lt lu in jt b ju mc jy md kc me kg mf kk mg ko ly lz ma mb bi translated">错误:发生任何错误时触发</li></ul><p id="cf27" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在让我们添加一个事件监听器，我改变了init()函数，如下所示，并添加了处理程序。在开发NodeJs应用程序时，我更喜欢RO-RO(接收对象—返回对象)方法。因为它提高了代码的可读性。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="db40" class="mq kq in mm b gy mr ms l mt mu">function instanceEventListeners({ conn }) {<br/>    conn.on('connect', () =&gt; {<br/>        console.log('CacheStore - Connection status: connected');<br/>    });</span><span id="202c" class="mq kq in mm b gy my ms l mt mu">    conn.on('end', () =&gt; {<br/>        console.log('CacheStore - Connection status: disconnected');<br/>    });</span><span id="0ba1" class="mq kq in mm b gy my ms l mt mu">    conn.on('reconnecting', () =&gt; {<br/>        console.log('CacheStore - Connection status: reconnecting');<br/>    });</span><span id="b259" class="mq kq in mm b gy my ms l mt mu">    conn.on('error', (err) =&gt; {<br/>        console.log('CacheStore - Connection status: error ', { err });<br/>    });<br/>}</span><span id="0b9d" class="mq kq in mm b gy my ms l mt mu">module.exports.init = () =&gt; {<br/>    const cacheInstance = redis.createClient('redis://connection-string');<br/>    clients.cacheInstance = cacheInstance;<br/>    instanceEventListeners({ conn: cacheInstance });<br/>};</span></pre><p id="04fa" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">现在怎么办？正如我上面所说，我们将自己处理重新连接程序。按照下面的代码，我只是简单的加了一个<code class="fe mz na nb mm b">timeout()</code>。就我而言，我可以忍受很少的连接中断。我的意思是，只要它在一定的时间内重新连接，失去连接是可以的吗？</p><p id="241b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">让我们添加那个<code class="fe mz na nb mm b">timeout()</code>来看看它是如何进行的，</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="60b1" class="mq kq in mm b gy mr ms l mt mu">function throwTimeoutError() {<br/>    connectionTimeout = setTimeout(() =&gt; {<br/>        throw new Error('Redis connection failed');<br/>    }, 10000);<br/>}</span><span id="dc4e" class="mq kq in mm b gy my ms l mt mu">function instanceEventListeners({ conn }) {<br/>    conn.on('connect', () =&gt; {<br/>        console.log('CacheStore - Connection status: connected');<br/>        clearTimeout(connectionTimeout);<br/>    });</span><span id="8590" class="mq kq in mm b gy my ms l mt mu">    conn.on('end', () =&gt; {<br/>        console.log('CacheStore - Connection status: disconnected');<br/>        throwTimeoutError();<br/>    });</span><span id="116f" class="mq kq in mm b gy my ms l mt mu">    conn.on('reconnecting', () =&gt; {<br/>        console.log('CacheStore - Connection status: reconnecting');<br/>        clearTimeout(connectionTimeout);<br/>    });</span><span id="6aab" class="mq kq in mm b gy my ms l mt mu">    conn.on('error', (err) =&gt; {<br/>        console.log('CacheStore - Connection status: error ', { err });<br/>        throwTimeoutError();<br/>    });<br/>}</span><span id="eb0a" class="mq kq in mm b gy my ms l mt mu">module.exports.init = () =&gt; {<br/>    const cacheInstance = redis.createClient('redis://connection-string');<br/>    clients.cacheInstance = cacheInstance;<br/>    instanceEventListeners({ conn: cacheInstance });<br/>};</span></pre><p id="32a4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们做到了！我们现在有什么？我们来分解一下，</p><ul class=""><li id="c229" class="lt lu in jt b ju jv jy jz kc mv kg mw kk mx ko ly lz ma mb bi translated">我们将<code class="fe mz na nb mm b">connectionTimeout</code>定义为空，因为我们想在结束触发特定事件时开始超时，</li><li id="97cb" class="lt lu in jt b ju mc jy md kc me kg mf kk mg ko ly lz ma mb bi translated">当我们得到一个结束事件，超时将开始，然后Redis将尝试重新连接。我们会等到超时。【Redis尝试连接时，将跟踪时间。如果连接再次建立，我们需要清除超时，因为我们不想在此之后抛出错误。顺便说一下，当<code class="fe mz na nb mm b">connectionTimeout</code>设置为空或未定义时，<code class="fe mz na nb mm b">clearTimeout</code>不会影响任何事情。</li></ul><p id="520e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们留下了一些好东西，让我们填满它们。我想管理关闭连接的流程，如何管理打开的流程。因为如果您在Kubernetes中运行应用程序，优雅地关闭应用程序总是最佳实践。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="76e5" class="mq kq in mm b gy mr ms l mt mu">module.exports.closeConnections = () =&gt; _.forOwn(clients, (conn) =&gt; conn.quit());</span></pre><ul class=""><li id="f307" class="lt lu in jt b ju jv jy jz kc mv kg mw kk mx ko ly lz ma mb bi translated"><code class="fe mz na nb mm b">forOwn()</code>将循环对象键，而每一个连接我们只是简单地称之为<code class="fe mz na nb mm b">quit()</code></li></ul><p id="012b" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">利用关系怎么样？让我们添加它，我们就完成了！</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="5abd" class="mq kq in mm b gy mr ms l mt mu">module.exports.getClients = () =&gt; clients;</span></pre><p id="4667" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">使用功能块，您可以导入和使用您创建的连接。</p><h1 id="2331" class="kp kq in bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">最后</h1><p id="bce0" class="pw-post-body-paragraph jr js in jt b ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk lr km kn ko ig bi translated">我们到达了终点，为自己创建了一个漂亮的Redis连接处理程序。这是我们找到的最适合我们微服务的方式。</p><p id="2271" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">处理连接状态并了解发生了什么将会提高您的服务质量。我总是欢迎你的想法，如果你有任何问题或建议，请在评论中告诉我们。</p><p id="1738" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于完整代码签出，此<a class="ae ls" href="https://github.com/irnmon/microservice-base/" rel="noopener ugc nofollow" target="_blank">链接</a>，</p><p id="8104" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于<a class="ae ls" href="https://medium.com/faun/the-best-docker-introduction-8b518b6f0b05" rel="noopener">介绍Docker checkout这个链接</a>，</p><p id="a67f" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于<a class="ae ls" href="https://www.freecodecamp.org/news/elegant-patterns-in-modern-javascript-roro-be01e7669cbd/" rel="noopener ugc nofollow" target="_blank">滚装进场检验环节</a>，</p><p id="4d37" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated"><a class="ae ls" href="https://github.com/irnmon/microservice-base/blob/master/lib/loaders/cacheStore.js" rel="noopener ugc nofollow" target="_blank"><strong class="jt io">TL；DR；</strong> </a></p></div></div>    
</body>
</html>