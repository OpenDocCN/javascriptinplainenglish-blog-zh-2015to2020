<html>
<head>
<title>2 constructs to avoid using in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中避免使用的2个构造</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/better-javascript-no-wrappers-and-70a3c471f637?source=collection_archive---------18-----------------------#2020-10-05">https://javascript.plainenglish.io/better-javascript-no-wrappers-and-70a3c471f637?source=collection_archive---------18-----------------------#2020-10-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b8d8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">更好的JavaScript——没有包装器并且==</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4d9b1045e8617def0bd859acd1efbdb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eVUir-yshWPw6-eG"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@ahungryblonde_?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sara Dubler</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="27a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将研究改进JavaScript代码的方法。</p><h1 id="b0cd" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">避免原始包装</h1><p id="59c2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们应该避免原始的包装器，这样我们就不必用它们来处理问题。</p><p id="c648" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们不应该有这样的代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="09e5" class="mu lt iq mq b gy mv mw l mx my">const s1 = new String("foo");<br/>const s2 = new String("foo");</span></pre><p id="aa50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么如果我们有:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="fd9e" class="mu lt iq mq b gy mv mw l mx my">s1 === s2;</span></pre><p id="e09a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后它返回<code class="fe mz na nb mq b">false</code>，因为它们是不同的对象。</p><p id="ba94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们只适用于隐式调用方法。</p><p id="9497" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以如果我们有:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3c58" class="mu lt iq mq b gy mv mw l mx my">"foo".toUpperCase();</span></pre><p id="fffc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后字符串被转换成一个字符串包装器对象，然后在其上调用<code class="fe mz na nb mq b">toUpperCase</code>方法。</p><p id="b6ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为原语可以用包装器自动包装，所以我们可以给它们添加属性。</p><p id="93c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们可以写:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a604" class="mu lt iq mq b gy mv mw l mx my">"foo".bar = 200;</span></pre><p id="01f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果我们写:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="bc00" class="mu lt iq mq b gy mv mw l mx my">"foo".bar</span></pre><p id="9278" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们得到<code class="fe mz na nb mq b">undefined</code>。</p><p id="c8c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次添加属性时都会进行包装。</p><p id="89d4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦这样做了，那么包装的对象立即被丢弃。</p><p id="4533" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们永远看不到我们设定的值。</p><p id="ab09" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是JavaScript隐藏类型错误的另一个地方。</p><h1 id="e36c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用== or！=混合类型</h1><p id="ecef" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果我们想要比较不同类型的操作数，那么我们必须小心操作数将被转换。</p><p id="f6db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，如果我们有:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="a3c8" class="mu lt iq mq b gy mv mw l mx my">const today = new Date();<br/>if (form.month.value == (today.getMonth() + 1) &amp;&amp;<br/>  form.day.value == today.getDate()) {<br/>  // ...<br/>}</span></pre><p id="8bd1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，操作数的类型将被转换为数字并进行比较。</p><p id="614f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很容易错过数据强制。</p><p id="2656" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，最好通过编写以下代码来明确地进行转换:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="1daf" class="mu lt iq mq b gy mv mw l mx my">const today = new Date();<br/>if (+form.month.value == (today.getMonth() + 1) &amp;&amp;<br/>  +form.day.value == today.getDate()) {<br/>  // ...<br/>}</span></pre><p id="e6fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们知道双方都有数字。</p><p id="087d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更好的是，我们应该使用<code class="fe mz na nb mq b">===</code>而不是<code class="fe mz na nb mq b">==</code>来进行等式比较，这样两个不同类型的东西都是<code class="fe mz na nb mq b">false</code>。</p><p id="a96c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们写道:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="2d1f" class="mu lt iq mq b gy mv mw l mx my">const today = new Date();<br/>if (+form.month.value === (today.getMonth() + 1) &amp;&amp;<br/>  +form.day.value === today.getDate()) {<br/>  // ...<br/>}</span></pre><p id="d858" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们知道只有两个数字可以进行比较。</p><p id="d90c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当两个参数的类型相同时，那么<code class="fe mz na nb mq b">==</code>和<code class="fe mz na nb mq b">===</code>就没有区别。</p><p id="2128" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是如果用于比较的操作数是不同的类型，我们就会遇到问题。</p><p id="81e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类型强制规则并不明显。</p><p id="2685" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们也很复杂。</p><p id="6021" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">计算机无法读取我们的思想，因此<code class="fe mz na nb mq b">==</code>很可能会使用错误的假设。</p><p id="0050" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe mz na nb mq b">==</code>操作符有几个规则。</p><p id="05d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果第一个操作数是<code class="fe mz na nb mq b">null</code>，第二个是<code class="fe mz na nb mq b">undefined</code>，那么就没有强制。</p><p id="59b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果第一个操作数是<code class="fe mz na nb mq b">null</code>或<code class="fe mz na nb mq b">undefined</code>，第二个操作数是除了<code class="fe mz na nb mq b">null</code>或<code class="fe mz na nb mq b">undefined</code>之外的任何值，那么就没有强制。</p><p id="8547" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果第一个操作数是一个原始字符串、数字或布尔值，而第二个操作数是<code class="fe mz na nb mq b">Date</code>对象，那么原始数据被转换成一个数字。</p><p id="d1a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过首先尝试<code class="fe mz na nb mq b">toString</code>，然后再尝试<code class="fe mz na nb mq b">valueOf</code>，将<code class="fe mz na nb mq b">Date</code>对象转换为图元。</p><p id="f998" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果第一个操作数是字符串、数字或布尔值，而第二个操作数是非<code class="fe mz na nb mq b">Date</code>对象，则原语被转换为数字。</p><p id="9200" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过首先尝试<code class="fe mz na nb mq b">toString</code>，然后再尝试<code class="fe mz na nb mq b">valueOf</code>，将非<code class="fe mz na nb mq b">Date</code>对象转换为原语。</p><p id="e6d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果两个操作数都是基本的字符串、数字或布尔值，那么它们都被转换为数字。</p><p id="a6e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只需使用<code class="fe mz na nb mq b">===</code>并忘记所有这些规则。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/f168e0c29940a5f1bc3078bcfd38f0c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9qTBARYgb_gXqZJX"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@edgarraw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Edgar Castrejon</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="282a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="22fb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mz na nb mq b">==</code>或者<code class="fe mz na nb mq b">!=</code>没有太多好处，问题很多。</p><p id="6ced" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb mq b">===</code>或<code class="fe mz na nb mq b">!==</code>更好。</p><p id="899a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原始包装器也应该避免。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/787be6c671be8d345dc786dad8729ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-sOyyG8NoRbKpCG_y4Cmw@2x.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Enjoyed this article? If so, get more similar content by <a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="bd ne">subscribing to Decoded, our YouTube channel</strong></a><strong class="bd ne">!</strong></figcaption></figure><p id="dd01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="ky ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>