<html>
<head>
<title>JavaScript Object Features in TypeScript — Maps and Sets</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的JavaScript对象功能—映射和集合</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-object-features-in-typescript-maps-and-sets-ca4023e75117?source=collection_archive---------7-----------------------#2020-06-11">https://javascript.plainenglish.io/javascript-object-features-in-typescript-maps-and-sets-ca4023e75117?source=collection_archive---------7-----------------------#2020-06-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/74b1b3d375fadada6f5c6126f3cfddaa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5WmJmn-SRcrOAK_K"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@danielcgold?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dan Gold</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b733" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript是JavaScript的自然扩展，在许多项目中取代了JavaScript。</p><p id="cc57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，并不是每个人都知道它实际上是如何工作的。</p><p id="ac53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用映射来存储键值对，以及如何使用集合来存储没有重复的项目。</p><h1 id="7442" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用映射存储键值对</h1><p id="379c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用映射存储键值对。</p><p id="4731" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">map和object literals之间的区别在于，我们可以拥有除字符串和符号之外的键。</p><p id="25ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用JavaScript内置的<code class="fe me mf mg mh b">Map</code>构造函数定义一个map。</p><p id="acd2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码来实现这一点:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7575" class="mq lc iq mh b gy mr ms l mt mu">const data = new Map();<br/>const key = {<br/>  foo: 'bar'<br/>};<br/>data.set("foo", "bar");<br/>data.set(key, 2);</span></pre><p id="6bf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，我们有一个带有字符串键和对象键的映射。</p><p id="f622" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">set</code>方法用给定的键存储一个值。</p><p id="a82c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要通过键获取值，我们可以使用<code class="fe me mf mg mh b">get</code>方法，将键作为参数。</p><p id="ad2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一个<code class="fe me mf mg mh b">keys</code>方法来获得一个带有映射键的迭代器。</p><p id="e652" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">values</code>方法返回地图的值。</p><p id="38a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">entries</code>方法返回一个带有映射的键值对的迭代器。</p><p id="022b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是地图的默认迭代器。</p><h1 id="f88d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对地图键使用符号</h1><p id="0ded" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">符号可用于<code class="fe me mf mg mh b">Map</code>和目标键。</p><p id="d3a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="555d" class="mq lc iq mh b gy mr ms l mt mu">const data = new Map();<br/>const symbol = Symbol();</span><span id="4582" class="mq lc iq mh b gy mv ms l mt mu">data.set("foo", "bar");<br/>data.set(symbol, 2);</span></pre><p id="22f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建的每个符号都是不同的，所以我们必须把它存储在一个变量中，这样我们以后就可以用符号键得到值。</p><p id="0ca8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对于非原语键也是一样的。</p><p id="3865" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以有多个名称相同但引用不同的符号。</p><p id="9ca7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9ed0" class="mq lc iq mh b gy mr ms l mt mu">const symbol1 = Symbol('foo');<br/>const symbol2 = Symbol('foo');</span></pre><p id="cfcf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们有相同的名字但是不同。</p><p id="799f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a5d8" class="mq lc iq mh b gy mr ms l mt mu">symbol1 === symbol2</span></pre><p id="b58e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">会返回<code class="fe me mf mg mh b">false</code>。</p><p id="d159" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用给定的符号键通过写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8fe6" class="mq lc iq mh b gy mr ms l mt mu">const value = data.get(symbol);</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/0612201945e9cbecd6442fcced4713b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mibU-eTdQzlx-3bb"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@robinstickel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Robin Stickel</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0213" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过索引存储数据</h1><p id="4376" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用一个<code class="fe me mf mg mh b">Set</code>实例存储没有重复的数据。</p><p id="5d70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cce8" class="mq lc iq mh b gy mr ms l mt mu">const set = new Set([1, 2, 3]);</span></pre><p id="7613" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到一个包含这些返回值的集合。</p><p id="fd99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">集合不能有重复，所以如果我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e412" class="mq lc iq mh b gy mr ms l mt mu">const set = new Set([1, 2, 3, 1]);</span></pre><p id="cc2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们仍然得到一个包含1、2和3的集合，因为只保存了某个事物的第一个实例。</p><p id="9835" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">集合具有返回集合大小的<code class="fe me mf mg mh b">size</code>属性。</p><p id="ad23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">集合实例有一些有用的方法，可以从中获取项、添加/移除项以及遍历这些项。</p><p id="72ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">add</code>将我们要添加到集合中的值作为参数。</p><p id="3ee4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">entries</code>按照条目添加的顺序返回所有条目的迭代器。</p><p id="c5a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">has</code>返回<code class="fe me mf mg mh b">true</code>是一个设定有指定值的集合。</p><p id="d6d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">forEach</code>接受在集合的每个项目上运行的回调。</p><h1 id="4ae6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="518e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用映射来存储键值对。与对象不同，它可以存储不是字符串或符号的键。</p><p id="d431" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">集合可以用来存储没有重复的数据。</p><p id="09a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们都是可迭代的对象，我们可以调用一个方法从它们返回迭代器。</p></div></div>    
</body>
</html>