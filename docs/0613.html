<html>
<head>
<title>Algorithms 101: includes() vs. indexOf() in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:JavaScript中的includes()与indexOf()</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-101-includes-vs-indexof-in-javascript-7f1b4af04127?source=collection_archive---------0-----------------------#2019-11-16">https://javascript.plainenglish.io/algorithms-101-includes-vs-indexof-in-javascript-7f1b4af04127?source=collection_archive---------0-----------------------#2019-11-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c276" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">算法#21:两个数组的交集。过滤器()</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f60cf380e64fdf48fb506223f54ea299.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mKM4KVf175RlO2DtmRf2Bg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">image from Wikipedia</figcaption></figure><p id="471e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在今天来自LeetCode 的挑战中，我们在两个数组中寻找共同的项目。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/77061b6f4adb2ddef5298c88010477cc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bhwFeWCPsvvhyqCQ_kizAQ.png"/></div></div></figure><h1 id="7e0b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">。过滤器()</h1><p id="72cc" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我们可以使用。filter()方法返回一个包含所有满足条件的元素的新数组。</p><p id="f95a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">是这样的。</strong>滤镜()【起作用。<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank"> (MDN文档在此)</a></p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="8862" class="mv lu iq mr b gy mw mx l my mz">input: nums1 = [1,3,5,6,7,9]<br/>nums1.filter(&lt;callback method goes here&gt;)</span><span id="239b" class="mv lu iq mr b gy na mx l my mz"><br/>//filter for elements that are greater than 4<br/>nums1.filter(num =&gt; num &gt; 4)<br/>=&gt; [6,7,9]</span><span id="922b" class="mv lu iq mr b gy na mx l my mz">//filter for elements that are even numbers<br/>nums1.filter(num =&gt; num % 2 === 0)</span><span id="cd39" class="mv lu iq mr b gy na mx l my mz">//filter for elements that are equal to 99<br/>nums1.filter(num =&gt; num === 99)<br/>=&gt; []</span><span id="f15d" class="mv lu iq mr b gy na mx l my mz">//filter for elements that are equal to "help"<br/>nums1.filter(num =&gt; num === "help")<br/>=&gt; []</span></pre><h1 id="ecaa" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">。包括()</h1><p id="bf06" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">让我们使用<strong class="kx ir">将其应用到我们的挑战中。在我们的回调中包含()</strong> <a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" rel="noopener ugc nofollow" target="_blank"> (MDN文档在此)</a>。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="3e02" class="mv lu iq mr b gy mw mx l my mz">input: nums1 = [1,2,2,1], nums2 = [2,2]<br/>nums1.filter(num =&gt; nums2.includes(num))<br/>=&gt; [2,2]<br/>//desired output [2]</span></pre><p id="f4c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这让我们更接近了！<strong class="kx ir">。includes() </strong>返回nums2 ( <a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes" rel="noopener ugc nofollow" target="_blank"> <em class="nb"> MDN文档此处</em> </a> <em class="nb"> ) </em>内num的每个实例。</p><h1 id="e276" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">一组</h1><p id="d671" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">现在我们只需要返回唯一的项目。我们可以使用ES6的<strong class="kx ir">设置</strong>来实现。(<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank"> MDN文档此处</a>)。<strong class="kx ir">设定</strong>是一个对象。它只存储唯一的值，您可以遍历它。</p><p id="413c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您还可以通过将数组作为参数传递给<strong class="kx ir"> new Set() </strong>来获取数组的唯一值，如下所示:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a75d" class="mv lu iq mr b gy mw mx l my mz">// Use Set to remove duplicate elements from the array <br/><br/>const numbers = [2,3,4,4,2,3,3,4,4,5,5,6,6,7,5,32,3,4,5]<br/><br/>console.log([...new Set(numbers)]) <br/><br/>// [2, 3, 4, 5, 6, 7, 32]</span></pre><p id="5c29" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以在我们的代码中，我们可以这样做:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/cdec10e5d4e91c906d89b351f3df2556.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tms_FqcccSEw09bagHFLDw.png"/></div></div></figure><p id="6404" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，根据LeetCode，我们的运行时间并不是很长:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/f70c1897c17fde5d82abf9ed5e33db6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pABlkpV3dFhE2CLNI15osw.png"/></div></div></figure><h1 id="194b" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">让我们加快速度——索引</h1><p id="96fd" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我们可以通过使用JavaScript的<strong class="kx ir">来加快速度。indexOf() </strong> ( <a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" rel="noopener ugc nofollow" target="_blank"> <em class="nb"> MDN文档此处</em> </a> <em class="nb"> ) </em>。</p><p id="305d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它是这样工作的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/7aee6fce8195fd5892481c968a6cf259.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iPEcR5u6LH_g32oSyy7nAA.png"/></div></div></figure><p id="87e8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果数组包含作为参数传递的值，<strong class="kx ir"> indexOf() </strong>返回该值的索引。</p><p id="b5e7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果数组包含多个传入的值，<strong class="kx ir"> indexOf() </strong>返回该值的第一个索引，如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nf"><img src="../Images/39f6d412c8d0610a123306c0641eb884.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kn9xpWtnEqumUw2lkmq8ZQ.png"/></div></div></figure><p id="304f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果数组不包含传入的值，indexOf()返回-1:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ng"><img src="../Images/2974858b01f5ade40dee115a292335dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2qySZUQGDQ6iRJfUqv0pnQ.png"/></div></div></figure><p id="4a1c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以像这样在代码中使用它:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/0001b253e8f36661b0dc6f5dafab13ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ac3XKB7FPtRoHqnXdKuasw.png"/></div></div></figure><p id="cfc6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们打开它。在第2行，我们要求我们的过滤器返回每个元素，该元素的indexOf()是*not*等于-1(记住，如果它不是负1，它存在于数组中)。</p><p id="cdc4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">顺便说一下，这些模式实现了相同的结果:</p><ul class=""><li id="fdf3" class="ni nj iq kx b ky kz lb lc le nk li nl lm nm lq nn no np nq bi translated"><code class="fe nr ns nt mr b">nums2.indexOf(num) != -1)</code></li><li id="a10f" class="ni nj iq kx b ky nu lb nv le nw li nx lm ny lq nn no np nq bi translated"><code class="fe nr ns nt mr b">nums2.indexOf(num) &gt; -1)</code></li></ul><p id="171d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">他们都试图建立指数是<em class="nb">而不是</em> <code class="fe nr ns nt mr b">-1.</code>我更喜欢第一种，因为这是最直接的方式来说，我们正在寻找一个不等于负的值。无论哪种方式，这些模式都很难阅读！它们不是语义上的。</p><p id="4a01" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是…如果你能接受这一点，现在我们的代码运行得更快了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/3b6dcad2f4237900a770ec48c4150e91.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J87ox-rscCm7DXmNYzOKEA.png"/></div></div></figure><h1 id="3d7e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">你什么时候使用？数组上的includes()与indexOf()。</h1><p id="3868" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated"><strong class="kx ir">。includes() </strong>如果查找的项目在数组中，则返回布尔值true或false。</p><p id="c6b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">。indexOf() </strong>如果找到则返回索引，否则返回-1。</p><p id="86c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果要在数组中搜索NaN(非数字),请使用。包括()。indexOf()不会找到它，因为它使用了严格的等式运算符<code class="fe nr ns nt mr b">===</code>，并且<code class="fe nr ns nt mr b">NaN === NaN</code>的计算结果为<code class="fe nr ns nt mr b">false</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/c6c231f7adf5df6bc43c47baefaf3966.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vnsvcz5wQB3HxH1yf1vweg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">remember, -1 means ‘not found’</figcaption></figure><p id="e912" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您正在搜索<code class="fe nr ns nt mr b">undefined</code>，两种方法都有效(使用严格等式，<code class="fe nr ns nt mr b">undefined === undefined</code>计算为<code class="fe nr ns nt mr b">true</code>)。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f122986112aaa6d14458ea39f8930f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vis1P4r0Oqg6z7-NANISZg.png"/></div></div></figure><h1 id="c306" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">性能？</h1><p id="9c20" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">在这个挑战上，LeetCode排名<strong class="kx ir">。indexOf() </strong>为更快的方式；但是在StackOverflow和其他地方发布了许多基准测试，声称其中一个或另一个更快。</p><p id="50a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对我来说，当性能差别不大时，我会选择<strong class="kx ir">。includes() </strong>因为它更容易阅读，因此也更容易维护！</p><p id="dda4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在<a class="ae lr" href="https://bit.ly/2XjrEeN" rel="noopener ugc nofollow" target="_blank">PythonTutor.com</a>上看到JavaScript代码的实时执行</p><p id="8534" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以在repl.it上玩它:</p><p id="0b2d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">【https://repl.it/@Joan_IndianaInd/StripedImportantArea】</p><h1 id="2ef4" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">嘘，红宝石迷们:</h1><p id="14e4" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">顺便说一下，如果你是Ruby的粉丝，Ruby让这变得非常简单！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/1f17ca98d57dfd40d034e0c2cb23f249.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZDVqurW29Tk6pp72X_XHNw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">done.</figcaption></figure><p id="36a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">版权Joan Indiana Lyness 2019 </strong></p><p id="c5e9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><em class="nb">万一你错过了:</em> <a class="ae lr" href="https://medium.com/javascript-in-plain-english/algorithms-101-container-with-most-water-in-javascript-8843a962ee0f" rel="noopener"> <em class="nb">算法101 #20，JavaScript </em> </a>中盛水最多的容器</p></div></div>    
</body>
</html>