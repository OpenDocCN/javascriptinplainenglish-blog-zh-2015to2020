<html>
<head>
<title>How to use the Generator function* in JavaScript (continued…)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中使用生成器函数*</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-the-generator-function-in-javascript-continued-aada07d220c7?source=collection_archive---------4-----------------------#2020-03-18">https://javascript.plainenglish.io/how-to-use-the-generator-function-in-javascript-continued-aada07d220c7?source=collection_archive---------4-----------------------#2020-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/a23acf448101e6e7ec85773e88252062.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*WWcMxPhcMn5A3kqW"/></div></div></figure><div class=""/><p id="928b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是<a class="ae kw" href="https://medium.com/javascript-in-plain-english/how-to-use-the-generator-function-in-javascript-6ab00380cc5f" rel="noopener"> JavaScript生成器函数系列</a>的第二部分。在本文中，我们将讨论生成器函数的用例，以及在处理它时需要记住的几个要点。</p><h1 id="7bb1" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用案例:-</h1><h1 id="8a21" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">可迭代实现</h1><p id="33a8" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">在任何迭代器实现中，首先我们必须手动创建一个迭代器对象，它将有一些方法来移动到下一条记录，功能与<strong class="ka jc"> <em class="ma"> next() </em> </strong>方法相同。</p><p id="23ea" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其次，我们需要以某种方式保持iterable的状态。使用普通函数，实现同样的功能是非常乏味的，有时也是一项具有挑战性的任务。</p><p id="a4f6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，使用生成器函数，我们可以在不使用额外样板代码的情况下实现它。原因是生成器本身就是可迭代的。</p><ul class=""><li id="9119" class="mb mc jb ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated"><strong class="ka jc">使用正常功能</strong></li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c587" class="mt ky jb mp b gy mu mv l mw mx">var iterableObject = {<br/>  [Symbol.iterator]() {<br/>    let index = 0;<br/>    return {<br/>      next() {<br/>        index++;<br/>        if (index === 1) {<br/>          return { value: 'Iterable : ' + index, done: false};<br/>        } else if (index === 2) {<br/>          return { value: 'Iterable : ' + index, done: false};<br/>        } else if (index === 3) {<br/>          return { value: 'Iterable : ' + index, done: false};<br/>        }<br/>        return { value: '', done: true };<br/>      }<br/>    }<br/>  },<br/>}</span><span id="952c" class="mt ky jb mp b gy my mv l mw mx">for (var val of iterableObject) {<br/>  console.log(val);<br/>}</span></pre><ul class=""><li id="01dd" class="mb mc jb ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated"><strong class="ka jc">使用发电机功能</strong></li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="c4c0" class="mt ky jb mp b gy mu mv l mw mx">function * iterableObject(index) {<br/>  yield 'Iterable : ' + index++;<br/>  yield 'Iterable : ' + index++;<br/>  yield 'Iterable : ' + index++;<br/>}</span><span id="cfa3" class="mt ky jb mp b gy my mv l mw mx">for (const val of iterableObject(1)) {<br/>  console.log(val);<br/>}</span></pre><p id="3b0a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在上面的例子中，我们可以看到使用发生器函数的方法更简单，也更容易实现。</p><h1 id="f7d4" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">异步功能实现</h1><p id="5d19" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">生成器可以简化承诺的工作。在下面的例子中，我们可以看到相同的-</p><ul class=""><li id="0027" class="mb mc jb ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated"><strong class="ka jc">利用承诺</strong></li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d708" class="mt ky jb mp b gy mu mv l mw mx">function fetchAPI(apiURL) {<br/>    return fetch(apiURL)<br/>    .then(request =&gt; request.text())<br/>    .then(text =&gt; {<br/>        return JSON.parse(text);<br/>    })<br/>    .catch(error =&gt; {<br/>        console.log('Error Occurred : ${error.stack}');<br/>    });<br/>}</span></pre><ul class=""><li id="f886" class="mb mc jb ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated"><strong class="ka jc">我们同样可以使用生成器和</strong><a class="ae kw" href="https://github.com/tj/co" rel="noopener ugc nofollow" target="_blank"><strong class="ka jc">co . js</strong></a><strong class="ka jc">库实现如下:</strong></li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="0a0c" class="mt ky jb mp b gy mu mv l mw mx">const fetchAPI = co.wrap(function* (apiURL) {<br/>    try {<br/>        let request = yield fetch(apiURL);<br/>        let text = yield request.text();<br/>        return JSON.parse(text);<br/>    }<br/>    catch (error) {<br/>        console.log('Error Occurred : ${error.stack}');<br/>    }<br/>});</span></pre><ul class=""><li id="9b82" class="mb mc jb ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated"><strong class="ka jc">使用ECMAScript 2017 </strong></li></ul><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="a2e1" class="mt ky jb mp b gy mu mv l mw mx">async function fetchAPI(apiURL) {<br/>    try {<br/>        let request = await fetch(apiURL);<br/>        let text = await request.text();<br/>        return JSON.parse(text);<br/>    }<br/>    catch (error) {<br/>        console.log('Error Occurred : ${error.stack}');<br/>    }<br/>}</span></pre><h1 id="af35" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">使用发电机作为观测器</h1><p id="9a1e" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><code class="fe mz na nb mp b">yield</code>也可以从<code class="fe mz na nb mp b">next()</code>接收一个值(通过一个参数)。这意味着我们可以使用生成器作为数据消费者，直到通过<code class="fe mz na nb mp b">next()</code>推送新的值，这些数据消费者才会暂停。</p><p id="e8a6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请查看<a class="ae kw" href="https://exploringjs.com/es6/ch_generators.html#sec_generators-as-observers" rel="noopener ugc nofollow" target="_blank"> <em class="ma">此链接</em> </a>了解相同的详细说明。</p><h1 id="4d52" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">协同程序(数据生产者和消费者)</h1><p id="734b" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">由于生成器可以被暂停，既可以用作数据生产者，也可以用作消费者，因此我们可以很容易地将它们用作<a class="ae kw" href="https://exploringjs.com/es6/ch_generators.html#sec_generators-as-coroutines" rel="noopener ugc nofollow" target="_blank"> <strong class="ka jc"> <em class="ma">协程</em></strong></a><strong class="ka jc"><em class="ma"/></strong>(协同多任务任务)。</p><h1 id="6800" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">需要注意的要点</h1><h2 id="b589" class="mt ky jb bd kz nc nd dn ld ne nf dp lh kj ng nh ll kn ni nj lp kr nk nl lt nm bi translated">1.yield只能在生成器函数中使用</h2><p id="ade9" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们只能在生成器函数中使用yield，在非生成器函数中是不允许的。这意味着在回调中屈服不起作用。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="cdeb" class="mt ky jb mp b gy mu mv l mw mx">function* someGeneratorFunction() {<br/>    ['Batman', 'Superman'].forEach(hero =&gt; yield hero); <br/> // Throws SyntaxError<br/>}</span></pre><p id="403d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们也可以在不使用回调的情况下重写上面的代码，它会像下面这样很好地工作。然而，这样做总是不可能的。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="7d06" class="mt ky jb mp b gy mu mv l mw mx">function* someGeneratorFunction() {<br/>    for (const hero of ['Batman', 'Superman']) {<br/>        yield hero; // OK<br/>    }<br/>}</span></pre><h2 id="f60a" class="mt ky jb bd kz nc nd dn ld ne nf dp lh kj ng nh ll kn ni nj lp kr nk nl lt nm bi translated">2.仅一次访问</h2><p id="f2d1" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">一旦我们迭代了生成器对象，我们就不能再迭代它了。我们需要创建新的生成器对象来迭代相同的值。</p><pre class="mk ml mm mn gt mo mp mq mr aw ms bi"><span id="d2c3" class="mt ky jb mp b gy mu mv l mw mx">function * evenNumber() {<br/>  let num = 2;<br/>  while (true) {<br/>    yield num;<br/>    num = num + 2<br/>  }<br/>}<br/>const numbers = evenNumber();</span><span id="e1f7" class="mt ky jb mp b gy my mv l mw mx">console.log(numbers.next())<br/>console.log(numbers.next())</span><span id="25da" class="mt ky jb mp b gy my mv l mw mx">const anotherNumbers = evenNumber();</span><span id="11d6" class="mt ky jb mp b gy my mv l mw mx">console.log(anotherNumbers.next())<br/>console.log(anotherNumbers.next())</span></pre><p id="3fed" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">他们也不允许像数组一样的随机访问。要访问任何特定的值，我们必须一个接一个地生成这些值。</p><h1 id="0216" class="kx ky jb bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">利益</h1><ul class=""><li id="413f" class="mb mc jb ka b kb lv kf lw kj nn kn no kr np kv mg mh mi mj bi translated"><a class="ae kw" href="https://exploringjs.com/es6/ch_generators.html#sec_examples-of-generators" rel="noopener ugc nofollow" target="_blank">懒评</a></li><li id="31db" class="mb mc jb ka b kb nq kf nr kj ns kn nt kr nu kv mg mh mi mj bi translated">高效的内存利用</li></ul></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><figure class="mk ml mm mn gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oc"><img src="../Images/8b7ff6debdb1684044e89629fb2f0048.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GNDdJ4Cr3DUBvpj2.png"/></div></div></figure><h2 id="91ac" class="mt ky jb bd kz nc nd dn ld ne nf dp lh kj ng nh ll kn ni nj lp kr nk nl lt nm bi translated">参考</h2><p id="8d7b" class="pw-post-body-paragraph jy jz jb ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><a class="ae kw" href="https://exploringjs.com/es6/ch_generators.html" rel="noopener ugc nofollow" target="_blank">探索js</a><br/>T5】代码突发</p></div></div>    
</body>
</html>