<html>
<head>
<title>JavaScript Concepts We Should Learn to Master React — Modules and Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我们应该学会掌握React的JavaScript概念——模块和承诺</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-concepts-we-should-learn-to-master-react-modules-and-promises-99a38842771?source=collection_archive---------6-----------------------#2020-05-22">https://javascript.plainenglish.io/javascript-concepts-we-should-learn-to-master-react-modules-and-promises-99a38842771?source=collection_archive---------6-----------------------#2020-05-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2d2bde813c3430c709524c220efb095d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fBWgOnP4TTjR3s5D"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@cmart10?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Caleb Martin</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0414" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">了解最新的JavaScript语法对于理解和掌握React至关重要。</p><p id="6907" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">阅读手册要容易得多，编写React代码也要短得多、干净得多。</p><p id="ad45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们掌握了一些新的JavaScript语法，编写React代码将变得轻而易举。</p><p id="c31e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解JavaScript模块在React应用程序中的使用，以及写承诺的更简短方式。</p><h1 id="75f4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">模块</h1><p id="d29b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">ES6模块是任何现代JavaScript应用程序的关键部分。他们让我们封装代码，只暴露我们想暴露的代码。我们不需要对功能做任何改动，也不需要使用第三方模块系统来做同样的事情。</p><p id="2606" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript模块中，有默认的导出，它导出没有名字的条目，我们可以自己设置名字。</p><p id="c1ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，还有命名的导出。但是，我们可以在用<code class="fe me mf mg mh b">as</code>关键字导入时更改名称。</p><p id="c4dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，模块的一个基本用途如下:</p><p id="d8fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">App.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0ee6" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>const App = () =&gt; {<br/>  return &lt;div&gt;hello&lt;/div&gt;;<br/>};<br/>export default App;</span></pre><p id="7fca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">main.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5741" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="bbf0" class="mq lc iq mh b gy mv ms l mt mu">import App from "./App";</span><span id="6956" class="mq lc iq mh b gy mv ms l mt mu">const rootElement = document.getElementById("root");<br/>ReactDOM.render(<br/>  &lt;React.StrictMode&gt;<br/>    &lt;App /&gt;<br/>  &lt;/React.StrictMode&gt;,<br/>  rootElement<br/>);</span></pre><p id="e850" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dd5c" class="mq lc iq mh b gy mr ms l mt mu">export default App;</span></pre><p id="df07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导出没有名称的<code class="fe me mf mg mh b">App</code>组件。然后我们通过编写来导入它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7478" class="mq lc iq mh b gy mr ms l mt mu">import App from "./App";</span></pre><p id="e95c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">main.js</code>。</p><p id="9d9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用我们喜欢的任何名称导入它，因为它是默认的导出。我们不能有一个以上的默认导出。</p><p id="c7ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大多数库，包括React本身，也封装在JavaScript模块中。</p><p id="24c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上示例包括以下导入:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bd29" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>import ReactDOM from "react-dom";</span></pre><p id="f8b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些导入也是JavaScript模块的默认导出，因为在关键字<code class="fe me mf mg mh b">import</code>后面没有括号。</p><p id="e42e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要创建具有命名导出的模块，我们可以编写以下代码:</p><p id="53ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Foo.js</code></p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="394e" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>const Foo = () =&gt; {<br/>  return &lt;div&gt;foo&lt;/div&gt;;<br/>};<br/>export { Foo };</span></pre><p id="f301" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">App.js</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a835" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>import { Foo } from "./Foo";<br/>const App = () =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Foo /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/>export default App;</span></pre><p id="042f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有将<code class="fe me mf mg mh b">Foo</code>组件导出为命名导出的<code class="fe me mf mg mh b">Foo.js</code>模块。</p><p id="9b0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">App.js</code>中，我们通过编写以下内容将<code class="fe me mf mg mh b">Foo</code>组件作为命名导入导入:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c02c" class="mq lc iq mh b gy mr ms l mt mu">import { Foo } from "./Foo";</span></pre><p id="f93f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用关键字<code class="fe me mf mg mh b">as</code>重命名命名导入，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f78f" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>import { Foo as FooComponent } from "./Foo";<br/>const App = () =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;FooComponent /&gt;<br/>    &lt;/div&gt;<br/>  );<br/>};<br/>export default App;</span></pre><p id="97fd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们用<code class="fe me mf mg mh b">as</code>关键字将<code class="fe me mf mg mh b">Foo</code>组件重命名为<code class="fe me mf mg mh b">FooComponent</code>，并在<code class="fe me mf mg mh b">App</code>中引用它来呈现它。</p><p id="7762" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导入和导出是静态分析的，因此文本编辑器和ide可以检查我们是否正确地导入和导出了它。</p><p id="78c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是使用模块的另一个优点。这些好处对几乎每个人都有用，因为几乎每个人都在使用JavaScript模块。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/d478736b6454d782625f1c197edd3d02.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wMaAZ06usu4g9mPe"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@javier365?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Javier Mazzeo</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f79c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步和等待</h1><p id="bbea" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">async</code>和<code class="fe me mf mg mh b">await</code>是承诺和给<code class="fe me mf mg mh b">then</code>回电的简写。</p><p id="29c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它让我们更容易地链接回调，看起来也更干净。</p><p id="eebd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c438" class="mq lc iq mh b gy mr ms l mt mu">import React, { useEffect, useState } from "react";</span><span id="4e8f" class="mq lc iq mh b gy mv ms l mt mu">const App = () =&gt; {<br/>  const [{ name, age, count }, setNameData] = useState({});</span><span id="8e2b" class="mq lc iq mh b gy mv ms l mt mu">  const getData = async () =&gt; {<br/>    const res = await fetch("https://api.agify.io/?name=michael");<br/>    const data = await res.json();<br/>    setNameData(data);<br/>  };</span><span id="6735" class="mq lc iq mh b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    getData();<br/>  }, []);</span><span id="74ab" class="mq lc iq mh b gy mv ms l mt mu">  return (<br/>    &lt;div&gt;<br/>      {name} {age} {count}<br/>    &lt;/div&gt;<br/>  );<br/>};<br/>export default App;</span></pre><p id="be49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有<code class="fe me mf mg mh b">getData</code>函数，它是一个<code class="fe me mf mg mh b">async</code>函数。它使用<code class="fe me mf mg mh b">async</code>和<code class="fe me mf mg mh b">await</code>语法来链接承诺。</p><p id="4580" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">fetch</code>返回一个承诺，所以我们对它使用<code class="fe me mf mg mh b">await</code>来获得解析的值。同样，我们对<code class="fe me mf mg mh b">res.json()</code>做了同样的事情，它也返回一个承诺。</p><p id="4983" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与以下内容相同:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1519" class="mq lc iq mh b gy mr ms l mt mu">import React, { useEffect, useState } from "react";</span><span id="83ff" class="mq lc iq mh b gy mv ms l mt mu">const App = () =&gt; {<br/>  const [{ name, age, count }, setNameData] = useState({});</span><span id="fe60" class="mq lc iq mh b gy mv ms l mt mu">  const getData = () =&gt; {<br/>    fetch("https://api.agify.io/?name=michael")<br/>      .then(res =&gt; res.json())<br/>      .then(data =&gt; setNameData(data));<br/>  };</span><span id="fce3" class="mq lc iq mh b gy mv ms l mt mu">  useEffect(() =&gt; {<br/>    getData();<br/>  }, []);</span><span id="1f8a" class="mq lc iq mh b gy mv ms l mt mu">  return (<br/>    &lt;div&gt;<br/>      {name} {age} {count}<br/>    &lt;/div&gt;<br/>  );<br/>};<br/>export default App;</span></pre><p id="05f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4308" class="mq lc iq mh b gy mr ms l mt mu">fetch("https://api.agify.io/?name=michael")<br/>      .then(res =&gt; res.json())<br/>      .then(data =&gt; setNameData(data));</span></pre><p id="9dfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与我们在<code class="fe me mf mg mh b">async</code>和<code class="fe me mf mg mh b">await</code>语法中的用法相同，除了我们必须在每个<code class="fe me mf mg mh b">then</code>回调中返回一个承诺以继续执行下一个承诺。</p><p id="3a05" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe me mf mg mh b">async</code>和<code class="fe me mf mg mh b">await</code>语法，我们不需要处理回调，这很好。</p><h1 id="75df" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="8d4a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们构建React应用程序，将代码划分成模块是使代码干净的必要条件。此外，几乎所有的库都可以作为JavaScript模块获得，所以如果我们想添加任何库，就必须使用它们。</p><p id="f665" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">async</code>和<code class="fe me mf mg mh b">await</code>语法是写承诺的一种更短的方式，它让我们消除了频繁使用回调，如果我们使用旧的<code class="fe me mf mg mh b">then</code>方法，我们必须添加回调。</p><h1 id="9569" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><strong class="ak">简明英语团队的笔记</strong></h1><p id="ec81" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">plain English . io</strong></a>上找到所有这些——关注我们的出版物并<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>