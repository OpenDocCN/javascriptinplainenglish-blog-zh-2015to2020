<html>
<head>
<title>React Tips — Scroll, Navigate, and Keeping Focus</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应提示—滚动、导航和保持焦点</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-tips-scroll-navigate-and-keeping-focus-e1bafff27005?source=collection_archive---------7-----------------------#2020-07-30">https://javascript.plainenglish.io/react-tips-scroll-navigate-and-keeping-focus-e1bafff27005?source=collection_archive---------7-----------------------#2020-07-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/851198cfab67044bdd701c04dd2557d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ic72rE2mxoF4juMP"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@blizzard88?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Grant Durr</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="662c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建web应用程序和移动应用程序的流行库。</p><p id="f2a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将探讨一些编写更好的React应用程序的技巧。</p><h1 id="2bc8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">借助挂钩，让路由器在每次过渡时都能滚动到顶部</h1><p id="db35" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建一个包装器组件，以便在每次导航时将路由组件滚动到顶部。</p><p id="da92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0222" class="mn lc iq mj b gy mo mp l mq mr">import React, { useEffect, Fragment } from 'react';<br/>import { withRouter } from 'react-router-dom';</span><span id="271b" class="mn lc iq mj b gy ms mp l mq mr">function ScrollToTop({ history, children }) {<br/>  useEffect(() =&gt; {<br/>    const unlisten = history.listen(() =&gt; {<br/>      window.scrollTo(0, 0);<br/>    });<br/>    return () =&gt; {<br/>      unlisten();<br/>    }<br/>  }, []);</span><span id="f142" class="mn lc iq mj b gy ms mp l mq mr">  return &lt;Fragment&gt;{children}&lt;/Fragment&gt;;<br/>}</span><span id="f9bb" class="mn lc iq mj b gy ms mp l mq mr">export default withRouter(ScrollToTop);</span></pre><p id="ba9c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们称<code class="fe mt mu mv mj b">history.listen</code>为倾听导航。</p><p id="b323" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在对它的回调中，我们调用<code class="fe mt mu mv mj b">window.scrollTo(0, 0)</code>滚动到顶部。</p><p id="b34c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回一个函数来清除监听程序，所以我们在<code class="fe mt mu mv mj b">useEffect</code>回调中返回的函数中调用该函数。</p><p id="c8c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将一个空数组传递给<code class="fe mt mu mv mj b">useEffect</code>，以便在安装<code class="fe mt mu mv mj b">ScrollToTop</code>组件时仅连接一次监听程序。</p><p id="cf67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写作来使用它；</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="66f1" class="mn lc iq mj b gy mo mp l mq mr">&lt;Router&gt;<br/>  &lt;ScrollToTop&gt;<br/>    &lt;Switch&gt;<br/>       &lt;Route path="/" exact component={Home} /&gt;<br/>    &lt;/Switch&gt;<br/>  &lt;/ScrollToTop&gt;<br/>&lt;/Router&gt;</span></pre><p id="c352" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe mt mu mv mj b">ScrollToTop</code>环绕在所有路线周围，以便在加载任何路线组件时滚动到顶部。</p><h1 id="2590" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对路由器和withRouter做出反应</h1><p id="d670" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mt mu mv mj b">withRouter</code>是一个我们可以调用的组件，让我们可以将<code class="fe mt mu mv mj b">location</code>、<code class="fe mt mu mv mj b">history</code>和<code class="fe mt mu mv mj b">match</code>对象作为道具包含在我们的组件中。</p><p id="3d52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="be37" class="mn lc iq mj b gy mo mp l mq mr">import React from "react";<br/>import PropTypes from "prop-types";<br/>import { withRouter } from "react-router";</span><span id="a5cc" class="mn lc iq mj b gy ms mp l mq mr">class App extends React.Component {<br/>  static propTypes = {<br/>    match: PropTypes.object.isRequired,<br/>    location: PropTypes.object.isRequired,<br/>    history: PropTypes.object.isRequired<br/>  };</span><span id="5422" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    const { match, location, history } = this.props;<br/>    return &lt;div&gt;{location.pathname}&lt;/div&gt;;<br/>  }<br/>}</span><span id="2b26" class="mn lc iq mj b gy ms mp l mq mr">const ShowTheLocationWithRouter = withRouter(App);</span></pre><p id="9af1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">match</code>是包含路由器路径信息的对象。</p><p id="f4d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它具有<code class="fe mt mu mv mj b">params</code>属性来获取路径的段。</p><p id="0d80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果路径与URL匹配，则<code class="fe mt mu mv mj b">isExact</code>为<code class="fe mt mu mv mj b">true</code>。</p><p id="a3a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">path</code>是具有用于匹配的模式的字符串。</p><p id="901a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">url</code>是具有URL的匹配部分的字符串。</p><p id="86cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">location</code>是具有带路径名的<code class="fe mt mu mv mj b">pathname</code>的对象。</p><p id="9af3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">search</code>为URL的查询字符串部分。</p><p id="4842" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">hash</code>为<code class="fe mt mu mv mj b">#</code>符号后的URL部分。</p><p id="ba3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">history</code>是本土历史的对象。</p><p id="118d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它的<code class="fe mt mu mv mj b">length</code>与历史堆栈中的条目数相同。</p><p id="fde3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">location</code>属性将URL的部分作为对象返回。</p><p id="0d42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与<code class="fe mt mu mv mj b">location</code>对象本身相同。</p><p id="0b43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">push</code>是一种让我们导航到新路径的方法。</p><p id="bbc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">replace</code>让我们通过改写历史来开启新的征程。</p><p id="aa66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">go</code>按步数导航至历史条目。</p><p id="c317" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">goBack</code>移至上一个历史。</p><p id="b2b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们转到下一个历史条目中的路径。</p><h1 id="b627" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对来自对象阵列的组件进行反应</h1><p id="50c2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe mt mu mv mj b">map</code>方法将一个对象数组呈现为一个组件列表。</p><p id="4d79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e4b1" class="mn lc iq mj b gy mo mp l mq mr">const Items = ({ items }) =&gt; (<br/>  &lt;&gt;<br/>    {items.map(item =&gt; (<br/>      &lt;div key={items.id}&gt;{items.name}&lt;/div&gt;<br/>    ))}<br/>  &lt;/&gt;<br/>);</span></pre><p id="bf25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们所做的就是用回调来调用<code class="fe mt mu mv mj b">map</code>，以返回从<code class="fe mt mu mv mj b">items</code>条目派生的条目。</p><p id="8937" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">key</code>应该有一个唯一的ID，以便React可以区分每个条目，即使他们已经移动。</p><h1 id="6b9d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">修复重新渲染时输入失去焦点的问题</h1><p id="4b42" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们创建自己的输入组件，并在<code class="fe mt mu mv mj b">render</code>方法中创建它，这可能会发生。</p><p id="af33" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将导致每次呈现输入时都创建一个自定义输入组件的新实例。</p><p id="a0c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以要把它搬出<code class="fe mt mu mv mj b">render</code>。</p><p id="3d1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过写下以下内容来保持输入的重点:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3454" class="mn lc iq mj b gy mo mp l mq mr">import React from 'react';<br/>import styled from 'styled-components';</span><span id="883e" class="mn lc iq mj b gy ms mp l mq mr">const Container = styled.div``;<br/>const Input = styled.input``;</span><span id="3470" class="mn lc iq mj b gy ms mp l mq mr">class App extends React.Component {<br/>  constructor(){<br/>    this.state = {<br/>      name: ''<br/>    };<br/>    this.updateName = this.updateName.bind(this);<br/>  }</span><span id="8c4f" class="mn lc iq mj b gy ms mp l mq mr">  updateName(e){<br/>    e.preventDefault();<br/>    this.setState({ name: e.target.value });<br/>  }</span><span id="33f5" class="mn lc iq mj b gy ms mp l mq mr">  render() {<br/>    return (<br/>      &lt;Container&gt;<br/>        &lt;Input<br/>          type="text"<br/>          onChange={this.updateName}<br/>          value={this.state.name}<br/>        /&gt;<br/>      &lt;/Container&gt;<br/>    )<br/>  }<br/>}</span></pre><p id="1cb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe mt mu mv mj b">Input</code>和<code class="fe mt mu mv mj b">Container</code>移动到<code class="fe mt mu mv mj b">App</code>组件的外部，以在外部创建组件，而不是在内部动态创建。</p><p id="9091" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着将始终使用同一个实例。</p><p id="39fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe mt mu mv mj b">App</code>重新呈现时，输入将保持焦点。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/0c9791fc93849f27fa8b5beb837c3c74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qjHi6O9l71xVDiS4"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@marcus_wallis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marcus Wallis</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d5c4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="a96b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在没有组件的情况下创建任何组件，这样就可以一直使用同一个实例。</p><p id="0e0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建自己的组件，以便在导航到不同的路线时将组件滚动到顶部。</p><p id="821a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">withRouter</code>向我们的组件注入一些对象。</p><h2 id="6018" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="562b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>