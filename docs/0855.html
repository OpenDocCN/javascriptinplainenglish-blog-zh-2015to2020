<html>
<head>
<title>Different types of dependencies in a Node.js application explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解释了Node.js应用程序中不同类型的依赖关系</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-the-dependency-types-of-dependencies-in-a-node-js-application-explained-904a5424fbd3?source=collection_archive---------1-----------------------#2019-12-23">https://javascript.plainenglish.io/what-the-dependency-types-of-dependencies-in-a-node-js-application-explained-904a5424fbd3?source=collection_archive---------1-----------------------#2019-12-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e084d1740aa98bd545c49f11ee8710a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*a1xRttwYkzLyV1CN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7f03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在创建或使用node js项目的过程中，每个开发人员偶尔都会遇到这样的短语:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3383" class="lk ll iq lg b gy lm ln l lo lp"><strong class="lg ir">npm i package_name<br/>npm i package_name --save-dev<br/>npm i package_name -g</strong></span></pre><p id="c0d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在还有其他的旗帜，比如:</p><p id="ecac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">I是install的简写</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="f8c0" class="lk ll iq lg b gy lm ln l lo lp"><strong class="lg ir">npm i package_name --save-optional<br/>npm i package_name --no-save</strong></span></pre><p id="7f48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些旗帜是什么意思？这些命令如何塑造我们的项目？</p><p id="535c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些问题的答案就在<strong class="kf ir"> package.json </strong>文件中。当我们创建一个节点js项目时，我们在我们的项目文件夹中使用命令:<em class="lq"> npm init </em>，这导致某些问题，并最终创建<strong class="kf ir"> package.json </strong>文件，或者如果我们下载一个节点js项目，我们总是在项目的文件夹中找到这个文件。</p><p id="183e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在这个文件包含了很多关于项目的信息，比如项目的名称、版本、入口点(main)、脚本、作者等等。但是关键的是，它包含了关于<strong class="kf ir">项目的依赖</strong>的信息，如果有的话。当用户发布他/她的项目时，项目接收者运行的第一个命令是:<em class="lq"> npm install </em>或者一些调用这个命令的脚本。这是建立项目的一部分。这是节点包管理器(npm)查看<strong class="kf ir"> package.json </strong>文件，并安装<strong class="kf ir"> package.json </strong>文件中列出的所有依赖项。但是依赖关系的类型不止一种。</p><ul class=""><li id="1c89" class="lr ls iq kf b kg kh kk kl ko lt ks lu kw lv la lw lx ly lz bi translated"><strong class="kf ir">依赖性(生产依赖性)</strong></li><li id="8090" class="lr ls iq kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated"><strong class="kf ir"> devDependencies(开发依赖关系)</strong></li><li id="0c61" class="lr ls iq kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated"><strong class="kf ir">选择性依赖</strong></li><li id="30dc" class="lr ls iq kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated"><strong class="kf ir">对等依赖</strong></li><li id="4e0d" class="lr ls iq kf b kg ma kk mb ko mc ks md kw me la lw lx ly lz bi translated"><strong class="kf ir">捆绑依赖</strong></li></ul><h1 id="ed97" class="mf ll iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">生产依赖性</h1><p id="5fd1" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated"><strong class="kf ir">生产依赖关系</strong>是正常的依赖关系，是运行项目所必需的。这些是在项目代码中使用的包。例如，如果我的应用程序使用mongoDB，那么在我的应用程序中可能有一个<a class="ae kc" href="https://www.npmjs.com/package/mongodb" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lq"> mongodb节点包</em> </strong> </a>的依赖项。这些依赖项在<strong class="kf ir"> package.json </strong>文件中的“依赖项”下指定。和开发人员可以使用</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="63c5" class="lk ll iq lg b gy lm ln l lo lp">npm i package_name<br/>// or<br/>npm i package_name --save-prod</span></pre><p id="8037" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来安装它们。如果安装了<strong class="kf ir"> package.json </strong>文件中“dependencies”项下的所有依赖项，应用程序将无法正常工作。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="9d30" class="mf ll iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">开发依赖性</h1><p id="1281" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">接下来是<strong class="kf ir">开发依赖</strong>，这些是在开发时需要的依赖，但不负责应用程序的工作，也就是说，即使我们跳过这些依赖，我们的应用程序也会正常工作。其中最常见的就是<a class="ae kc" href="https://www.npmjs.com/package/nodemon" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lq">nodemon</em></strong></a><strong class="kf ir"><em class="lq"/></strong>这其中</p><blockquote class="nj nk nl"><p id="0a27" class="kd ke lq kf b kg kh ki kj kk kl km kn nm kp kq kr nn kt ku kv no kx ky kz la ij bi translated">是一个帮助开发基于node.js的应用程序的工具，它在检测到目录中的文件更改时自动重新启动node应用程序。</p></blockquote><p id="5fe3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir"> Nodemon </strong>在开发应用程序时可能会有所帮助，因为当我们进行一些更改时，它使我们不必一次又一次地启动我们的应用程序，但当我们部署我们的应用程序时，它通常是无用的，因为用户/部署环境必须启动我们的应用程序一次，因为当唯一的目的是使用应用程序而不是修改它时，不必进行任何更改。开发人员可以使用下面的命令将软件包作为开发依赖项进行安装。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9113" class="lk ll iq lg b gy lm ln l lo lp">npm i package_name --save-dev</span></pre><p id="317d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过发出这个命令，一旦安装了这个包，<strong class="kf ir"> package.json </strong>文件将被修改，这个包及其版本将被保存在关键字“devDependencies”下。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="9053" class="mf ll iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">可选依赖项</h1><p id="74fc" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated"><strong class="kf ir">可选依赖关系</strong>是那些顾名思义是可选的依赖关系，即在为应用程序/项目安装依赖关系时，这些依赖关系不会导致安装失败，因为<strong class="kf ir"> npm </strong>将忽略这些依赖关系，如果这些依赖关系失败或未找到。无论有没有这些依赖项，应用程序都会运行得很好。</p><p id="409c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在为了让事情更清楚，考虑一下这个场景，假设您正在制作一个节点脚本，它接受一些输入并在控制台上记录多个自定义输出。控制台日志颜色相同，为了区分日志，您使用<a class="ae kc" href="https://www.npmjs.com/package/chalk" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lq">粉笔</em> </strong> </a>作为帮助您设置日志样式的依赖项，但是当您分发此脚本/应用程序时，脚本/应用程序的接收者/用户可能也使用<strong class="kf ir">粉笔</strong>来设置日志样式，这不是必需的，但也是可能的。这将使chalk成为这种特殊情况下的可选依赖项。这种依赖性不应该中断脚本/应用程序的工作，因为它的目的是控制台日志，而不是样式。当使用可选的依赖项时，要记住的一件事是，处理依赖项的缺乏仍然是你的程序的责任。如果您需要此任务的进一步帮助，请阅读此处的<a class="ae kc" href="http://npm.github.io/using-pkgs-docs/package-json/types/optionaldependencies.html" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"><em class="lq"/></strong></a>。要使依赖项可选，开发人员可以使用以下命令:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0a2b" class="lk ll iq lg b gy lm ln l lo lp">npm i package_name --save-optional</span></pre><p id="d5b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将导致您的包出现在<strong class="kf ir"> package.json </strong>文件中的“optionalDependencies”键下</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="6829" class="mf ll iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">对等依赖</h1><p id="cd92" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">当你为一个主机工具或包开发一个插件/包的时候，你会用到这些。这意味着您希望插件/包的用户安装这些依赖项，而不一定在您的插件/包中使用这些依赖项。例如，如果我正在为一个名为“汽车版本3.5.0”的虚拟主机工具或库制作一个名为“电动汽车版本1.2”的虚拟插件/包，那么我将在我的<strong class="kf ir"> package.json </strong>文件中的“peerDependencies”键下指定版本为3.5.0的包“汽车”。用户应该在安装/使用主机工具或库的插件之前安装这些主机依赖项。记住从插件目录运行<em class="lq"> npm安装</em>不会安装这些包。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure><h1 id="07df" class="mf ll iq bd mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my mz na nb bi translated">捆绑的依赖关系</h1><p id="14dc" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">这些是在发布我们的包时捆绑的包的数组。如果您希望将某些或所有依赖项捆绑在一个文件中，那么您可以在您的<strong class="kf ir"> package.json </strong>文件中的关键字“bundledDependencies”下指定这些依赖项。要实际创建一个包含<strong class="kf ir">bundle dependencies</strong>中提到的所有依赖项的tarball，您可以发出命令:<em class="lq"> npm pack </em>，这将创建一个<strong class="kf ir">。tgz </strong>文件名类似:<em class="lq">name _ of _ the _ project-version _ of _ the _ project . tgz</em>。在这之后，用户可以简单地发出命令<em class="lq">NPM install</em><em class="lq">name _ of _ the _ project-version _ of _ the _ project . tgz</em>来使用单个文件安装项目捆绑依赖项。当我们想要保留我们的依赖项并使用单个文件使它们可用时，就使用这种方法。</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="nh ni l"/></div></figure></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="8d79" class="mf ll iq bd mg mh nw mj mk ml nx mn mo mp ny mr ms mt nz mv mw mx oa mz na nb bi translated">—奖金—</h1><p id="071d" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">当开发人员在node js应用程序上工作时，他们有时会使用以下命令:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6b81" class="lk ll iq lg b gy lm ln l lo lp">npm i package_name -g</span></pre><p id="d7d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此命令用于将节点js包安装为全局依赖项，这意味着此包是全局安装的，并且只能在使用开发人员机器的任何应用程序/项目中使用，这些是经常使用的包，从未被任何特定的应用程序/项目使用。因此，在安装这些模块时，它们不会依赖于<strong class="kf ir"> package.json </strong>文件，事实上，这些模块不会导致对<strong class="kf ir"> package.json </strong>文件的任何修改。这些通常是为开发人员提供某些实用程序的包，这些实用程序在开发中经常使用，但在生产中几乎从不需要。一些例子是<a class="ae kc" href="https://www.npmjs.com/package/create-react-app" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">create-react-app</strong></a>包，它用于创建react app的react app框架，而无需为初始设置进行构建配置，像<strong class="kf ir"> nodemon </strong>这样的包也可以全局安装。</p><p id="fd91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有时，您可能还会遇到以下命令:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="7c2c" class="lk ll iq lg b gy lm ln l lo lp">npm i package-name --no-save</span></pre><p id="ad16" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样做的目的是安装一个在项目中使用的包，而不是作为依赖项。这些包是<em class="lq">一次性的</em>，应用程序不依赖于这些包，它们也不会像全局包安装一样列在<strong class="kf ir"> package.json </strong>文件中的任何依赖项下。</p><p id="ad85" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是主要的区别是，全局包可以从任何地方(任何项目)通过node访问，安装了-no-save标志的包只能从发出命令的特定项目访问。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="2ffc" class="mf ll iq bd mg mh nw mj mk ml nx mn mo mp ny mr ms mt nz mv mw mx oa mz na nb bi translated">Package . JSON vs Package-lock . JSON</h1><p id="fbfa" class="pw-post-body-paragraph kd ke iq kf b kg nc ki kj kk nd km kn ko ne kq kr ks nf ku kv kw ng ky kz la ij bi translated">这两个文件是node js应用程序中依赖关系管理的核心。</p><p id="ae8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Package.json文件用于提供关于项目的更多信息，package-lock.json提供关于依赖项的更多信息。Package.json文件包含关于所有种类的主要依赖关系的信息，例如如果我的应用程序使用<a class="ae kc" href="https://www.npmjs.com/package/express" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> <em class="lq"> express </em> </strong> </a>作为<em class="lq"> devDependencies </em>它将在package.json文件中列出，但是<em class="lq"> express </em>本身具有<strong class="kf ir"> 30 </strong>依赖关系和<strong class="kf ir">18</strong>dev依赖关系，这些信息包括版本、完整性等。将在package-lock.json文件中列出。因此，当发出<em class="lq"> npm install </em>命令时<strong class="kf ir"> npm </strong>利用这些文件创建一个完整的功能构建并相应地安装依赖项。</p><p id="ba1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是所有的人。我可能漏掉了一些要点，但大致就是这样。我只是想确保我在这里提到的包，如nodemon、chalk、express、mongodb等。在这篇文章中，我并不是在推广它们，我提到它们只是因为我广泛地使用它们，它们让我的生活变得轻松了一些。如果你觉得这篇文章有帮助，请留下掌声。</p><p id="d733" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">欢迎在其他社交平台上联系我，比如<a class="ae kc" href="https://www.instagram.com/ab_si_/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"/></a><a class="ae kc" href="https://www.linkedin.com/in/abhishek-singh-2939a0aa/" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">LinkedIn</strong></a><a class="ae kc" href="https://www.facebook.com/proabe" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">脸书</strong></a><strong class="kf ir"/>我一直都想进行一场智慧的对话，祝你周末愉快，编码愉快😉。</p></div></div>    
</body>
</html>