<html>
<head>
<title>JavaScript Reduce: The Ultimate Iterator</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript Reduce:终极迭代器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-reduce-the-ultimate-iterator-e486e4503a13?source=collection_archive---------5-----------------------#2020-10-04">https://javascript.plainenglish.io/javascript-reduce-the-ultimate-iterator-e486e4503a13?source=collection_archive---------5-----------------------#2020-10-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/b01655b98043a73ad060912f10a45a4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*l11JOuB7muziwsoY.png"/></div></div></figure><p id="6c87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我刚学JavaScript的时候完全低估了<code class="fe kt ku kv kw b">Array.prototype.reduce()</code>的威力。我并不完全理解它是如何工作的，所以我把它仅仅作为一种方便的方法来计算数组元素的和。</p><p id="0de6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是现在我明白了<code class="fe kt ku kv kw b">reduce</code>是如何工作的，我看到了它在各种不同应用中的潜力。为了展示这种潜力，我将首先使用<code class="fe kt ku kv kw b">reduce</code>来模拟我使用的两个最常见的数组方法——<code class="fe kt ku kv kw b">map</code>和<code class="fe kt ku kv kw b">filter</code>——的行为，然后展示如何使用它来代替<code class="fe kt ku kv kw b">for</code>循环，从而很好地清理代码。</p><h1 id="0e6f" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">缩小为地图</h1><p id="20e2" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">对于外行来说，<code class="fe kt ku kv kw b">Array.protoype.map()</code>是一种可以在任何数组上使用的方法，它可以对数组的每个元素运行相同的代码，从而产生一个新的、经过转换的数组。看起来是这样的(<code class="fe kt ku kv kw b">&gt;&gt;</code>表示返回值):</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="a201" class="mi ky in kw b gy mj mk l ml mm">[1, 2, 3].map(num =&gt; num + 1)<br/>&gt;&gt; <em class="mn">[2, 3, 4]</em></span></pre><p id="ffb6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">方法<code class="fe kt ku kv kw b">.map()</code>接受一个回调函数作为其第一个参数——这里我传递一个匿名函数——并将数组中的每个元素作为第一个参数传递给回调函数。</p><p id="0d64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">像这样用<code class="fe kt ku kv kw b">reduce</code>可以达到同样的结果:</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="c887" class="mi ky in kw b gy mj mk l ml mm">[1, 2, 3].reduce((result, num) =&gt; [ ...result, num + 1 ], [])<br/>&gt;&gt; <em class="mn">[2, 3, 4]</em></span></pre><p id="2212" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧，这里发生了什么？传递给<code class="fe kt ku kv kw b">reduce</code>的回调函数的第一个参数是累加器，即<code class="fe kt ku kv kw b">reduce</code>最终返回的值。每次<code class="fe kt ku kv kw b">reduce</code>运行这个回调函数，都会返回一个新的累加器，并传递给下一个回调函数，依此类推，直到到达数组的末尾。th；；</p><p id="7546" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">回调函数的第二个参数是数组中的实际元素。所以，我上面做的是把累加器复制到一个新的数组里，把当前数组元素加到新数组里。这个新数组成为新的累加器，然后传递给回调函数。</p><p id="0ffd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe kt ku kv kw b">reduce</code>方法也不同于<code class="fe kt ku kv kw b">map</code>，因为它接受可选的第二个参数，该参数用作累加器的初始值。在我的例子中，我传递了一个空数组。</p><h1 id="41e7" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">减少为过滤器</h1><p id="8c9c" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated"><code class="fe kt ku kv kw b">Array.prototype.filter()</code>与<code class="fe kt ku kv kw b">map</code>结构相似，但结果大不相同。传递给<code class="fe kt ku kv kw b">filter</code>的回调函数用于确定哪些值出现在新返回的数组中，哪些值不出现。</p><p id="7582" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看起来是这样的:</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="c156" class="mi ky in kw b gy mj mk l ml mm">[1, 2, 3].filter(num =&gt; num &gt; 1)<br/>&gt;&gt; <em class="mn">[2, 3]</em></span></pre><p id="83c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当回调函数返回<code class="fe kt ku kv kw b">false</code>时，被求值的元素从返回的数组中省略。</p><p id="65e2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">使用<code class="fe kt ku kv kw b">reduce</code>，看起来是这样的:</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="89ef" class="mi ky in kw b gy mj mk l ml mm">[1, 2, 3].reduce((result, num) =&gt; {<br/>  return num &gt; 1 ? [ ...result, num ] : result<br/>}, [])<br/>&gt;&gt; <em class="mn">[2, 3]</em></span></pre><p id="8477" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我通过返回一个三元语句来模仿<code class="fe kt ku kv kw b">filter</code>的行为。如果<code class="fe kt ku kv kw b">num &gt; 1</code>的计算结果为<code class="fe kt ku kv kw b">true</code>，则返回一个新数组，其中包含累加器的内容和<code class="fe kt ku kv kw b">num</code>的当前值。如果表达式计算结果为<code class="fe kt ku kv kw b">false</code>，则原样返回累加器，从返回的数组中忽略<code class="fe kt ku kv kw b">num</code>的当前值。</p><h1 id="bd19" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">减少的力量</h1><p id="9f62" class="pw-post-body-paragraph jv jw in jx b jy lv ka kb kc lw ke kf kg lx ki kj kk ly km kn ko lz kq kr ks ig bi translated">既然我们对如何使用<code class="fe kt ku kv kw b">reduce</code>来模仿其他数组方法的行为有了更好的了解，我想演示如何使用<code class="fe kt ku kv kw b">reduce</code>来替换我发现自己经常编写的有些难看的代码(通常是在解决关于<em class="mn">代码大战</em>或<em class="mn">黑客等级的问题时)。</em></p><p id="30b1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们来看一下场景。我们需要遍历一个数组，删除所有重复的数组，返回一个新的数组，该数组只包含原始数组中的唯一值。</p><p id="c143" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为具有复杂性意识的程序员，我们知道强力解决方案——为每个值迭代整个数组，或者换句话说，将一个迭代器嵌套在另一个迭代器中——会导致二次复杂性，因为您可以通过计算原始数组长度的平方来计算这样做所需的时间。</p><p id="4d19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们不需要在整个数组中搜索数组中的每个值，而是可以创建一个对象作为库，我们可以使用它来立即查找一个值，并查看它是否已经出现。当我第一次学习编码时，我是这样写这个解决方案的:</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="7fcd" class="mi ky in kw b gy mj mk l ml mm">const unique = array =&gt; {<br/>  const lib = {}<br/>  const result = []</span><span id="83e4" class="mi ky in kw b gy mo mk l ml mm">  for(let i=0; i &lt; array.length; i++) {<br/>    if(!lib[array[i]]) {<br/>      result.push(array[i])<br/>      lib[array[i]] = true<br/>    }<br/>  }</span><span id="e21e" class="mi ky in kw b gy mo mk l ml mm">  return result<br/>}</span><span id="66fc" class="mi ky in kw b gy mo mk l ml mm">unique([1, 2, 3, 3, 4, 5, 5])</span><span id="f314" class="mi ky in kw b gy mo mk l ml mm">&gt;&gt; <em class="mn">[1, 2, 3, 4, 5]</em></span></pre><p id="c0a7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这段代码完成了工作，但是看起来不太好。让我们看看如何用<code class="fe kt ku kv kw b">reduce</code>来清理它:</p><pre class="ma mb mc md gt me kw mf mg aw mh bi"><span id="1ffe" class="mi ky in kw b gy mj mk l ml mm">const unique = array =&gt; {<br/>  return array.reduce(<br/>    (result, num) =&gt; {<br/>      if(!result.lib[num]) {<br/>        return {<br/>          lib: { ...result.lib, [num]: true },<br/>          arr: [ ...result.arr, num ]<br/>        }<br/>      } else {<br/>        return result<br/>      }<br/>    },<br/>    { lib: {}, arr: [] }<br/>  ).arr<br/>}</span><span id="496f" class="mi ky in kw b gy mo mk l ml mm">unique([1, 2, 3, 3, 4, 5, 5])</span><span id="86d5" class="mi ky in kw b gy mo mk l ml mm">&gt;&gt; <em class="mn">[1, 2, 3, 4, 5]</em></span></pre><p id="e936" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">好吧，也许结果看起来不太干净，但我认为这个例子说明了<code class="fe kt ku kv kw b">reduce</code>的巨大潜力，因为它表明累加器可以像你需要的那样复杂。你可以在累加器中存储任何你需要的信息。只要记住总是返回一个值，否则<code class="fe kt ku kv kw b">undefined</code>将取代你的累加器，并可能导致一些令人沮丧的混乱。</p><p id="b29f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae mp" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="jx io">！</strong></p></div></div>    
</body>
</html>