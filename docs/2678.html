<html>
<head>
<title>React Native full-screen notifications (even on Lock Screen)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应本机全屏通知(即使在锁屏)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-full-screen-notification-tricking-android-1761e4fd2ac3?source=collection_archive---------1-----------------------#2020-07-14">https://javascript.plainenglish.io/react-native-full-screen-notification-tricking-android-1761e4fd2ac3?source=collection_archive---------1-----------------------#2020-07-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7369" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">仅限Android</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f58ea9f2df340da0ede5ab837599c84d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KT1Qcrig0ILT7_e6hWN4Fg.jpeg"/></div></div></figure><h1 id="d563" class="ko kp in bd kq kr ks kt ku kv kw kx ky jt kz ju la jw lb jx lc jz ld ka le lf bi translated">警报</h1><blockquote class="lg"><p id="24b7" class="lh li in bd lj lk ll lm ln lo lp lq dk translated">从android 10，SDK 29开始，这一招对运行Android 10的设备不再有效，因为谷歌已经设置了一个限制意思，你将无法从后台启动一个应用程序。</p><p id="c924" class="lh li in bd lj lk ll lm ln lo lp lq dk translated">参考:</p><p id="4cbe" class="lh li in bd lj lk ll lm ln lo lp lq dk translated"><a class="ae lr" href="https://developer.android.com/guide/components/activities/background-starts" rel="noopener ugc nofollow" target="_blank">https://developer . Android . com/guide/components/activities/background-starts</a></p><p id="fa2c" class="lh li in bd lj lk ll lm ln lo lp lq dk translated">解决这个问题的方法是在您的应用程序中运行一个前台服务。你可以看一下限制的例外部分。</p><p id="80dd" class="lh li in bd lj lk ll lm ln lo lp lq dk translated">这是我开发的前台服务。</p><p id="f6ba" class="lh li in bd lj lk ll lm ln lo lp lq dk translated">https://github.com/Raja0sama/rn-foreground-service<a class="ae lr" href="https://github.com/Raja0sama/rn-foreground-service" rel="noopener ugc nofollow" target="_blank"/></p><p id="31d4" class="lh li in bd lj lk ll lm ln lo lp lq dk translated">请注意，先前的解决方案没有经过测试，我假设是这样的，因为文档在异常中提到了这一点。</p></blockquote><p id="eb61" class="pw-post-body-paragraph ls lt in lu b lv lw jo lx ly lz jr ma mb mc md me mf mg mh mi mj mk ml mm lq ig bi translated">嗯，你在这里可能是因为你一直在寻找一种向react原生应用的用户显示全屏通知的方法。</p><p id="0694" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">我也一直在开发一个应用程序，这个应用程序是为司机和基于android的应用程序，每当服务器广播命令时，司机都会收到通知，在我的情况下，他可以回答他是否想接受命令的全屏通知。经过几个小时的搜索，我在互联网上没有找到解决方案，让你显示全屏通知，因为它不存在。<br/>安卓有个东西叫<a class="ae lr" href="https://developer.android.com/training/notify-user/time-sensitive" rel="noopener ugc nofollow" target="_blank">时间敏感通知</a>，上面写的很清楚。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ms"><img src="../Images/88d04ea4701483d76a9659e9d37b9dd6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jU99HouV74MVnPAY1StJCA.png"/></div></div></figure><p id="af9c" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">在我的例子中，我不希望它在“交互”之后显示一个正常的屏幕意图，我希望它是一个整页的通知，这显然是不支持的。</p><p id="7570" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">那我们现在怎么办？我们打开通知接收器上的应用程序，并在安装前获取一些参数，以导航我们的应用程序到某个屏幕，怎么样？在我的例子中，我所做的是创建一个只有一个屏幕的独立堆栈导航器，将它与mount上的firebase listener连接，显示订单的信息和操作按钮。</p><p id="73de" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">是的，这正是我所需要的。</p><p id="7f27" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">然后，我开始在谷歌上搜索关于通知接收者的打开活动。不过，我没有找到，所以打开我的Vscode，导航到react-native-firebase/messaging，我找到了一个文件ReactNativeFirebaseMessagingReceiver.java，其中有一个名为onReceive的函数，所有的通知都在这里传递，这就是我所需要的。</p><p id="b885" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">我开始测试它；首先，我尝试像这样从remoteMessage获取数据</p><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="2adf" class="my kp in mu b gy mz na l nb nc">Log.d('Testing ',remoteMessage.getData().toString());</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/c3b2ed4164d9c30074a28019bdfdcb64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DMHibYYDN8rrHQhk_H0PAg.png"/></div></div></figure><p id="dc6f" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">而在android Studio中收到的日志是</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/2701cfa0084b02c627729873670f9c87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1kMj83BL7DLWiw4UEFs0qg.png"/></div></div></figure><p id="c359" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">答对了，我收到了一个相当于javascript JSON对象的map，<br/>我通过使用这行代码获取了Super next</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nf"><img src="../Images/0028ad795b6252c32926cabd581141bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MtA6glDS4wFM9AJj-7RxTQ.png"/></div></div></figure><p id="9301" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">我重建，我得到了结果<strong class="lu io">测试测试</strong>。这就是我所需要的。<br/>下一步是看我是否能从后台打开活动，在我研究的时候，我发现很多资料说你不能从后台打开活动。那么现在该怎么办呢，我没有尝试打开一个活动，而是尝试打开一个应用程序，我尝试通过<code class="fe ng nh ni mu b">getLaunchIntentForPackage</code>打开我自己的应用程序</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nj"><img src="../Images/729bb5e6d47fd00a55438397ca2e9f74.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_lygv4dRJ6CbeWYblCbkWA.png"/></div></div></figure><p id="8624" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">答对了，收到通知如果我的应用程序在后台或者因为推送而被关闭，它会重新打开我的应用程序，这是我想要的。在活动状态下，没有不同的行为，因为我试图打开的进程已经打开；因此，没有变化。</p><p id="6cd1" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">之后我所有的问题都解决了，所有的问题都解决了，我在数据对象上做了一些条件检查，只在我需要的地方用props打开我的应用程序。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/137bb47cd9be060db463b5d269b70c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iE2YrwXj3ZVIMwPYfKwFKQ.png"/></div></div></figure><pre class="kd ke kf kg gt mt mu mv mw aw mx bi"><span id="c8f3" class="my kp in mu b gy mz na l nb nc">if (remoteMessage.getData().containsKey("Super")) {</span><span id="835f" class="my kp in mu b gy nk na l nb nc">Intent launchIntentt = context.getPackageManager().getLaunchIntentForPackage("com.waterlink");<br/>  launchIntentt.putExtra("String_I_need", "strName");<br/>  if (launchIntentt != null) {<br/>    Log.d("Testing ", "Inside");<br/>    context.startActivity(launchIntentt);</span><span id="abde" class="my kp in mu b gy nk na l nb nc">}<br/>}</span></pre><p id="90e1" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">到目前为止，一切正常。我面临的最后一个问题是，如何告诉应用程序，该应用程序是由通知而不是由用户打开的。</p><p id="c8ee" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">有两个修复，要么我可以利用putExtra将数据发送到主活动，要么我可以在我的应用程序上有一个监听器来检查订单广播。</p><p id="a93b" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">在我的例子中，我在我的应用程序中使用了监听器，但是对于put Extra，你可以通过使用你的mainactivity.java中的一段代码很容易地解决它</p><p id="0c97" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">转到您的主活动并声明一个变量</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nl"><img src="../Images/309916e636a8983acc402bbdf408a343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wzDRCYNa8BKJOMZdAeVD9Q.png"/></div></div></figure><p id="e638" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">您需要覆盖MainActivity的两个方法。</p><p id="78d9" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated"><em class="nm">确保首先覆盖onNewIntent，然后覆盖OnStart。</em></p><ul class=""><li id="62e0" class="nn no in lu b lv mn ly mo mb np mf nq mj nr lq ns nt nu nv bi translated">onNewIntent</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/8d6d71e943f7903cbd8b89e6bbad0f40.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qTUzK-Ot97-s4eIGwJ0r1w.png"/></div></div></figure><ul class=""><li id="a1d2" class="nn no in lu b lv mn ly mo mb np mf nq mj nr lq ns nt nu nv bi translated">onStart</li></ul><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nx"><img src="../Images/d6423c8bc352f3bf20532377c69b168e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nv_f3cGhJI-46eh8Zx-8lQ.png"/></div></div></figure><p id="229e" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">最后是我们的主要功能— <code class="fe ng nh ni mu b">FullScreenPropsEmitter</code></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ms"><img src="../Images/0412f0c1c4588db7b1061d1884dc7163.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwogx0izGZGLE5VyASwoIg.png"/></div></div></figure><p id="a5ef" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">在你的js上获取这个道具</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/d59b73fb8804d1c76726353b5bfd2002.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v3heFEDgOqVMJrz0afivTg.png"/></div></div></figure><p id="8763" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">你也可以使用这个方法，通过这个<a class="ae lr" href="https://reactnative.dev/docs/communication-android" rel="noopener ugc nofollow" target="_blank">方法</a>发送数据作为初始道具</p><p id="6ff1" class="pw-post-body-paragraph ls lt in lu b lv mn jo lx ly mo jr ma mb mp md me mf mq mh mi mj mr ml mm lq ig bi translated">这就是你如何从firebase通知中打开你的react本地应用程序，并在应用程序启动和显示通知的特定屏幕上发送和接收道具。我建议你在你的应用中使用这个库，而不是使用官方的，如果你在删除旧的节点模块后重新安装，官方的会被覆盖。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nz oa l"/></div></figure></div></div>    
</body>
</html>