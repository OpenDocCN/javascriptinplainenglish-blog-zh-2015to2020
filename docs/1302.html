<html>
<head>
<title>Exploring Vue.js Observable &amp; Composition APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">探索Vue.js可观察和组合API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/exploring-vue-js-observable-composition-apis-7cda7f317d0e?source=collection_archive---------1-----------------------#2020-02-27">https://javascript.plainenglish.io/exploring-vue-js-observable-composition-apis-7cda7f317d0e?source=collection_archive---------1-----------------------#2020-02-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/40b37f78f4a97d2843855d838651ee84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4AXreJjkDK3XVvQEMstMKA.jpeg"/></div></div></figure><p id="3735" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">虽然到目前为止Vue.js生态系统中最流行的状态管理解决方案是Vuex，但不要忽视其他有趣的解决方案，如observable和composition APIs，这一点很重要。通过写这篇文章，我假设你已经知道如何使用Vuex和它是如何工作的？所以我不会进一步解释Vuex。让我们探索可观察的和组合的API</p><h1 id="51a4" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">检查Vue.observable API</h1><p id="12d6" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">Vue.js 2.6引入了一些新特性，包括全局<a class="ae lz" href="https://vuejs.org/v2/api/#Vue-observable" rel="noopener ugc nofollow" target="_blank">可观察API </a>。</p><p id="d648" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在可以在Vue.js组件的范围之外创建反应对象了。此外，不使用Vuex，您也可以创建商店。当您需要共享几个组件的状态时，它将非常适合用于简单的场景。让我们看看如何在项目中实现vue.observable。</p><p id="0594" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，创建<code class="fe ma mb mc md b">store.js</code>:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="b6ae" class="mm kx iq md b gy mn mo l mp mq">import Vue from "vue";<br/>export const store = Vue.observable({<br/>  data: []<br/>});<br/>export const mutations = {<br/>  setData(payload) {<br/>    store.data = payload;<br/>  }<br/>};</span></pre><p id="1eec" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">听起来很容易，接近Vuex对不对？<br/>现在你只需要在一个组件中使用它。为了访问状态，就像在Vuex中一样，我们将使用计算的属性和突变方法:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="8dda" class="mm kx iq md b gy mn mo l mp mq">&lt;template&gt;<br/>    &lt;div id="app"&gt;<br/>        &lt;button <a class="ae lz" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>="fetch"&gt;Get the data&lt;/button&gt;</span><span id="8bb0" class="mm kx iq md b gy mr mo l mp mq">&lt;div v-if="!getData.length"&gt;Loading the data&lt;/div&gt;</span><span id="3730" class="mm kx iq md b gy mr mo l mp mq">&lt;div v-else="getData.length"&gt;<br/>            &lt;div v-for="data in getData" :key="data.id"&gt;<br/>                &lt;h5&gt;{{ data.title }}&lt;/h5&gt;<br/>                &lt;p&gt;{{ data.description }}&lt;/p&gt;<br/>            &lt;/div&gt;<br/>        &lt;/div&gt;<br/>    &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="e63f" class="mm kx iq md b gy mr mo l mp mq">&lt;script&gt;<br/>import { store, mutations } from "./store";<br/>export default {<br/>  name: "app",<br/>  computed: {<br/>    getData() {<br/>      return store.data;<br/>    }<br/>  },<br/>  methods: {<br/>    setData: mutations.setData,<br/>    async fetch() {<br/>      const req = await window.fetch("<a class="ae lz" href="http://example.com/tasks" rel="noopener ugc nofollow" target="_blank">http://example.com/tasks</a>");<br/>      const res = await req.json();<br/>      return this.setData(res);<br/>    }<br/>  }<br/>};</span><span id="fdb8" class="mm kx iq md b gy mr mo l mp mq">&lt;/script&gt;</span></pre><p id="1a15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！漂亮又简单，对吧？下面是如何实现observable。</p><h1 id="ee4c" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">检查合成API</h1><p id="3bab" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">让我们看看在使用组合API的情况下，将会是什么样的组件:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="ce4e" class="mm kx iq md b gy mn mo l mp mq">&lt;template&gt;<br/>    &lt;div&gt;<br/>        &lt;input type="text" v-model="state.input" placeholder="Add New Task" /&gt;<br/>        &lt;input type="submit" <a class="ae lz" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>="addTask()" /&gt;<br/>        &lt;ul&gt;<br/>            &lt;li v-for="(item, index) in state.tasks" :key="item"&gt;<br/>                {{ item }}<br/>                &lt;button <a class="ae lz" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>="deleteTask(index)"&gt;X&lt;/button&gt;<br/>            &lt;/li&gt;<br/>        &lt;/ul&gt;<br/>    &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="1b8d" class="mm kx iq md b gy mr mo l mp mq">&lt;script&gt;<br/>import { reactive } from "<a class="ae lz" href="http://twitter.com/vue/composition-api" rel="noopener ugc nofollow" target="_blank">@vue/composition-api</a>";<br/>export default {<br/>  setup() {<br/>    const { state, addTask, deleteTask } = useTaskList();<br/>    return {<br/>      state,<br/>      addTask,<br/>      deleteTask<br/>    };<br/>  }<br/>};</span><span id="09c7" class="mm kx iq md b gy mr mo l mp mq">function useTaskList() {<br/>  let state = reactive({<br/>    input: "",<br/>    tasks: []<br/>  });</span><span id="f31f" class="mm kx iq md b gy mr mo l mp mq">function addTask() {<br/>    state.tasks.push(state.input);<br/>    state.input = "";<br/>  }</span><span id="8708" class="mm kx iq md b gy mr mo l mp mq">function deleteTask(index) {<br/>    state.tasks.splice(index, 1);<br/>  }<br/>  return {<br/>    state,<br/>    addTask,<br/>    deleteTask<br/>  };<br/>}</span><span id="f691" class="mm kx iq md b gy mr mo l mp mq">&lt;/script&gt;</span></pre><p id="23f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看这个组件是怎么回事？正如你所看到的，与通常的Vue组件不同，这里没有<code class="fe ma mb mc md b">data</code>和<code class="fe ma mb mc md b">methods</code>选项。代替那些选项，你会看到一些叫做<code class="fe ma mb mc md b">setup.</code>的新方法</p><p id="7018" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">setup</code>方法应该返回一个对象，该对象将包含我们组件中应该可用的任何内容。</p><p id="ab5e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个重要的注意事项是，新的变量state指向反应值。Vue3提供了直接控制暴露哪些活性元素的能力。同样在前面，我们必须在组件的<code class="fe ma mb mc md b">methods</code>选项中声明所有函数，然而，在上面的例子中，我们使用了我们创建的<code class="fe ma mb mc md b">useTaskList </code>方法，在该方法中我们对函数进行了分组。它可以在一个单独的文件中，并导入到组件中，以使其更加清晰。</p><p id="391a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">同样需要注意的是，我们需要从模板中访问的所有内容都由<em class="ms"/><code class="fe ma mb mc md b">useTaskList()</code>和<code class="fe ma mb mc md b">setup()</code>方法返回。</p><h1 id="1e8a" class="kw kx iq bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">结论</h1><p id="9385" class="pw-post-body-paragraph jy jz iq ka b kb lu kd ke kf lv kh ki kj lw kl km kn lx kp kq kr ly kt ku kv ij bi translated">好了，现在你已经看到了这两个选项的作用。选择哪一个取决于你，取决于你对相关项目的需求。</p></div></div>    
</body>
</html>