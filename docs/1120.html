<html>
<head>
<title>Introduction to TypeScript Classes — More Access Modifiers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript类简介—更多访问修饰符</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-typescript-classes-more-access-modifiers-91c816311105?source=collection_archive---------9-----------------------#2020-01-31">https://javascript.plainenglish.io/introduction-to-typescript-classes-more-access-modifiers-91c816311105?source=collection_archive---------9-----------------------#2020-01-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e6368c73d3ea70daa207191f6de390fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*u18eX9dOBg_1-BAC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@usinglight?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Stefan Steinbauer</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="64c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与JavaScript一样，TypeScript中的类是其原型继承模型的特殊语法，这是基于类的面向对象语言中的类似继承。类只是添加到ES6中的特殊函数，用来模仿其他语言中的关键字<code class="fe lb lc ld le b">class</code>。在JavaScript中，我们可以有<code class="fe lb lc ld le b">class</code>声明和<code class="fe lb lc ld le b">class</code>表达式，因为它们只是函数。所以像所有其他函数一样，有函数声明和函数表达式。TypeScript也是如此。类充当创建新对象的模板。TypeScript扩展了JavaScript类的语法，然后添加了自己的变体。在本文中，我们将看到更多的TypeScript中类成员的访问修饰符。</p><h1 id="d2a6" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">只读修饰符</h1><p id="a3ba" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">使用TypeScript，我们可以用<code class="fe lb lc ld le b">readonly</code>关键字将类成员标记为只读。这可以防止成员在初始化后被修改。此外，它们必须在声明时或在构造函数中初始化。例如，我们可以在下面的代码中使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d6db" class="mq lg iq le b gy mr ms l mt mu">class Person {<br/>  readonly name: string;<br/>  constructor(name: string) {<br/>    this.name = name;      <br/>  }<br/>}</span><span id="028b" class="mq lg iq le b gy mv ms l mt mu">const person = new Person('Jane');</span></pre><p id="b5c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们试图在初始化后将一个值设置为<code class="fe lb lc ld le b">name</code>后再给它赋值，那么我们会得到一个错误。例如，如果我们写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6bbd" class="mq lg iq le b gy mr ms l mt mu">class Person {<br/>  readonly name: string;<br/>  constructor(name: string) {<br/>    this.name = name;      <br/>  }<br/>}<br/>const person = new Person('Jane');<br/>person.name = 'Joe';</span></pre><p id="21c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么TypeScript编译器不会编译代码，我们会得到错误消息“无法赋值给‘name ’,因为它是只读属性。(2540)"</p><p id="b133" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过使用参数属性来缩短上面的代码。有了参数属性，我们既可以声明一个<code class="fe lb lc ld le b">readonly</code>成员，也可以通过将成员声明放在构造函数的签名中为其赋值。一旦我们把它放在括号里，我们就可以声明它，同时给它赋值。例如，不要写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="cb28" class="mq lg iq le b gy mr ms l mt mu">class Person {<br/>  readonly name: string;<br/>  constructor(name: string) {<br/>    this.name = name;      <br/>  }<br/>}</span><span id="bb6c" class="mq lg iq le b gy mv ms l mt mu">const person = new Person('Jane');</span></pre><p id="7a4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以改为写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a31c" class="mq lg iq le b gy mr ms l mt mu">class Person {  <br/>  constructor(readonly name: string) {    <br/>  }<br/>}</span><span id="3099" class="mq lg iq le b gy mv ms l mt mu">const person = new Person('Jane');</span></pre><p id="48f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们在<code class="fe lb lc ld le b">person</code>上运行<code class="fe lb lc ld le b">console.log</code>时，我们可以看到成员<code class="fe lb lc ld le b">name</code>已经被赋值为‘Jane ’,而不必显式地编写代码来为其赋值。我们也可以用<code class="fe lb lc ld le b">public</code>、<code class="fe lb lc ld le b">private</code>或<code class="fe lb lc ld le b">protected</code>代替<code class="fe lb lc ld le b">readonly</code>；或者将<code class="fe lb lc ld le b">readonly</code>与<code class="fe lb lc ld le b">public</code>、<code class="fe lb lc ld le b">private</code>或<code class="fe lb lc ld le b">protected</code>组合。例如，我们可以编写以下代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3e00" class="mq lg iq le b gy mr ms l mt mu">class Person {  <br/>  constructor(private readonly name: string) {    <br/>  }</span><span id="7ebc" class="mq lg iq le b gy mv ms l mt mu">  getName() {<br/>    return this.name;<br/>  }<br/>}<br/>const person = new Person('Jane');<br/>console.log(person.getName());</span></pre><p id="0e84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取名为<code class="fe lb lc ld le b">name</code>的<code class="fe lb lc ld le b">private</code>和<code class="fe lb lc ld le b">readonly</code>成员，在<code class="fe lb lc ld le b">getName</code>方法中检索它的值。当我们在最后一行运行<code class="fe lb lc ld le b">console.log</code>行时，我们应该得到‘简’。同样，我们可以对<code class="fe lb lc ld le b">public</code>或<code class="fe lb lc ld le b">protected</code>做同样的事情，如下面的代码所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7de9" class="mq lg iq le b gy mr ms l mt mu">class Person {  <br/>  constructor(protected readonly name: string) {    <br/>  }<br/>}</span><span id="bc13" class="mq lg iq le b gy mv ms l mt mu">class Employee extends Person {  <br/>  constructor(<br/>    public name: string, <br/>    private employeeCode: number<br/>  ){    <br/>    super(name);<br/>  }</span><span id="6902" class="mq lg iq le b gy mv ms l mt mu">  getEmployeeCode() {<br/>    return this.employeeCode;<br/>  }<br/>}<br/>const person = new Employee('Jane', 123);<br/>console.log(person.name);<br/>console.log(person.getEmployeeCode());</span></pre><p id="5d44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，在<code class="fe lb lc ld le b">Person</code>和<code class="fe lb lc ld le b">Employee</code>类中，我们有各种访问修饰符和<code class="fe lb lc ld le b">readonly</code>关键字的参数属性。然后，我们可以使用<code class="fe lb lc ld le b">Employee</code>构造函数将所有值分配给具有<code class="fe lb lc ld le b">Employee</code>构造函数的所有成员。然后，当我们直接获取成员的值，或者通过私有成员<code class="fe lb lc ld le b">employeeCode</code>的方法获取成员的值时，我们通过<code class="fe lb lc ld le b">getEmployeeCode</code>方法获取成员的值，然后我们可以看到我们期望的值被记录。我们看到<code class="fe lb lc ld le b">person.name</code>是‘简’，而<code class="fe lb lc ld le b">person.getEmployeeCode()</code>得到我们123。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/7485982d689a4d6bef9c0cf9195c93b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vOl_JTXuc2Hq93uR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@richardbrutyo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Richard Brutyo</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f586" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">访问者</h1><p id="ac22" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">像在JavaScript中一样，我们可以将getter和setter方法添加到TypeScript类中。这可以防止我们意外地直接修改公共成员值，并让我们对如何检索和设置成员值有更多的控制。为了给类添加getters和setters，我们可以分别使用<code class="fe lb lc ld le b">get</code>和<code class="fe lb lc ld le b">set</code>关键字。我们将它们放在类的方法签名前面，以将一个方法指定为getter或setter。例如，我们可以在下面的代码中使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f8c0" class="mq lg iq le b gy mr ms l mt mu">class Person {<br/>  private _name: string = '';</span><span id="8be7" class="mq lg iq le b gy mv ms l mt mu">  get name(): string {<br/>    return this._name;        <br/>  }</span><span id="860e" class="mq lg iq le b gy mv ms l mt mu">  set name(newName: string) {<br/>    if (newName &amp;&amp; newName.length &lt; 5) {<br/>      throw new Error('Name is too short');      <br/>    }<br/>    this._name = newName;<br/>  }<br/>}</span><span id="18b9" class="mq lg iq le b gy mv ms l mt mu">let person = new Person();<br/>person.name = 'Jane Smith';<br/>console.log(person.name);<br/>person.name = 'Joe';</span></pre><p id="11b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，我们添加了一个带有<code class="fe lb lc ld le b">get</code>关键字的getter方法。<code class="fe lb lc ld le b">name</code>方法用于获取<code class="fe lb lc ld le b">_name</code>字段，该字段是私有的，因此如果没有getter方法，我们无法获取它的值。为了通过我们的getter <code class="fe lb lc ld le b">name</code>方法检索<code class="fe lb lc ld le b">this._name</code>的值，我们只需使用<code class="fe lb lc ld le b">person.name</code>属性来获取它。然后我们设置<code class="fe lb lc ld le b">this._name</code>的值，我们添加一个带有<code class="fe lb lc ld le b">set</code>关键字和方法名<code class="fe lb lc ld le b">name</code>的setter方法。在<code class="fe lb lc ld le b">name</code> setter方法中，我们传入参数，让我们用赋值操作符给它赋值，就像我们在上面代码的倒数第三行中做的那样。</p><p id="bcd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所见，我们可以将验证代码放在<code class="fe lb lc ld le b">set name</code>方法中。这是使用getter和setter方法的一个很好的理由，因为我们可以控制如何为单个类成员设置值。在上面的例子中，如果我们分配的值少于5个字符，那么我们抛出一个错误，消息是“名称太短”。这使我们无法在字符串少于5个字符的情况下赋值。如果我们运行代码，第一个赋值表达式:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2403" class="mq lg iq le b gy mr ms l mt mu">person.name = 'Jane Smith';</span></pre><p id="708c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们让“简·史密斯”登录。当我们试图给它赋一个少于5个字符的值时，就像我们对:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1c75" class="mq lg iq le b gy mr ms l mt mu">person.name = 'Joe';</span></pre><p id="1947" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到一个错误，就像我们在代码中指出的那样。</p><p id="74ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，要使用访问器，我们必须将输出编译到ES5或更高版本。不支持编译到ES3，但这应该是现代浏览器的问题。同样，有<code class="fe lb lc ld le b">get</code>但没有<code class="fe lb lc ld le b">set</code>的访问器被自动推断为<code class="fe lb lc ld le b">readonly</code>。</p><p id="4cb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在TypeScript中，我们为类成员提供了<code class="fe lb lc ld le b">readonly</code>修饰符，这样它们在初始化后就不能被设置为新值。此外，TypeScript具有参数属性特性，因此我们不必显式地编写代码来通过构造函数给变量赋值。如果我们在构造函数中添加参数，那么当我们用<code class="fe lb lc ld le b">new</code>关键字实例化这个类时，它们会被自动设置。访问器方法对于控制我们如何获取和设置类成员的值很有用。我们可以用关键字<code class="fe lb lc ld le b">get</code>和<code class="fe lb lc ld le b">set</code>指定getter和setter方法。</p></div></div>    
</body>
</html>