<html>
<head>
<title>How to Create Secure React &amp; Express Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建安全的React &amp; Express应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/secure-react-express-apps-jsonwebtoken-cookie-session-auth0-and-passport-tutorial-e58d6dce6c91?source=collection_archive---------2-----------------------#2020-09-13">https://javascript.plainenglish.io/secure-react-express-apps-jsonwebtoken-cookie-session-auth0-and-passport-tutorial-e58d6dce6c91?source=collection_archive---------2-----------------------#2020-09-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="53e7" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用jsonwebtoken、cookie会话、auth0和passport</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fa0b4fd2d1b846d711973ddacefc6b30.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3z8M00TOKNsAHN8vEHVKWg.jpeg"/></div></div></figure><p id="1df8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我长期学习express、node和react项目。我总是从一个例子跳到另一个例子，试图找出我的express服务器的最佳配置。在我的发展过程中，有一个特定的话题/问题似乎从我的生活中抽走了几天(如果不是几周的话)。</p><h2 id="5050" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">您将如何保护您的会话？</h2><p id="f45b" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">无论您是通过谷歌、脸书或其他第三方认证机构来认证您的用户，还是创建您自己的本地认证机构(除非您知道自己在做什么，否则这通常是个坏主意)，您的认证过程的安全性还取决于您如何与您的用户保持会话。</p><p id="608d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">本教程的重点是创建一个安全的express react应用程序，我们可以在其他酷项目中反复使用。对于那些正在为他们的react-express项目寻找一个简单而安全的设置的人，我将回顾我的首选配置，以及我对它的理解。有更多的配置具有更高的安全性或易用性，所以如果你遇到任何或希望击败我的摊位，我很乐意听到他们。</p><h2 id="0e08" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak">你首先需要知道的:</strong></h2><p id="da16" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我将在本教程中使用几个关键概念，所以这里有一个简短的概述:</p><p id="fa60" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">饼干</strong></p><p id="8421" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">HTTP Cookies是存储在web浏览器上的小块数据，从服务器端发送。cookies中有一些关键属性。安全的cookie只能通过加密连接(https)传输。客户端API(如javascript)无法访问仅支持http的<strong class="kq io">cookie。这些cookies被发送回原始服务器，因此它们可以保存有关连接用户的信息。</strong></p><p id="02a5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> JSON网络令牌(JWT) </strong></p><p id="fbd1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">JWT令牌是加密签名的base64 JSON对象。您可以创建这些令牌，并将它们从后端服务器发送到前端进行存储。当这些令牌被发回时，您可以验证令牌上的签名，以验证JWT是否有效。这可以作为验证会话的一种非常方便的方法。</p><p id="32a5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">为什么Cookies保存jwt而不是本地存储？</strong></p><p id="6540" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">浏览器上的本地存储易受XSS攻击，恶意代码可以窃取用户的浏览器存储并窃取有价值的会话数据。这很容易通过安全/仅http cookie来避免</p><h1 id="a321" class="mi ll in bd lm mj mk ml lp mm mn mo ls jt mp ju lv jw mq jx ly jz mr ka mb ms bi translated">我第一次学习时遇到的情况是:</h1><p id="8820" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">有两个非常受欢迎的软件包可用于维护express中的会话:</p><p id="09c4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mt mu mv mw b">express-session and cookie-session</code></p><p id="f413" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">快速会议</strong></p><p id="0dee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Express-session是一个会话中间件，用于存储会话数据<strong class="kq io">服务器端。</strong>这意味着当用户登录时，他们的会话数据被存储在后端的某个数据库中，会话id被存储在cookie中，然后被传递到前端。当cookie根据请求返回时，这个会话Id用于在数据库中查找会话。</p><p id="104a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> Cookie-session </strong></p><p id="1e53" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Cookie-session是另一个会话中间件。这个中间件创建了一个cookie，可以用来存储发送到前端的cookie中的信息。这不会在服务器上存储任何数据，因此不涉及存储。</p><h2 id="7095" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">为什么一个在另一个之上？</h2><p id="eb32" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">在我在网上找到的教程中，Express-session似乎用得更多，尤其是与passport等流行的认证库一起使用。对于那些只想通过快速教程深入学习的初学者来说，这无疑可以节省一些时间和头痛。</p><p id="bfdc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">不幸的是，超越开发是express-session更复杂的地方。因为快速会话的默认会话存储是MemoryStore，所以它不是专门为生产环境而设计的，并且由于它不能扩展到单个进程之外，所以会泄漏内存。它需要一个独立的服务器端存储系统，比如redis或mongodb，以便在生产环境中很好地运行。</p><p id="7b33" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">添加服务器端会话存储也会带来性能障碍，但是允许存储更多关于会话的数据，因为它是一个实际的存储系统，而不是一个小cookie。cookie(根据RFC625规范)建议浏览器应该允许每个cookie至少4096字节。不幸的是，这意味着每个域不能超过4093字节。</p><p id="d031" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">为什么Cookie-session是一个可爱的选择:</strong></p><p id="ffdf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Cookie会话不需要用于生产的服务器端存储，并且您可以自由操纵进入cookie会话的内容。我们可以很容易地给我们的会话cookie赋值，比如一个JWT令牌。这可以让您的服务器在负载平衡的情况下减少延迟和问题。</p><p id="43d2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您想添加服务器端存储来跟踪会话，您可以将此逻辑添加到cookie会话设置中，以防您有此功能的用例。cookie会话中间件很灵活，只需要一点点爱。</p><h1 id="9e6f" class="mi ll in bd lm mj mk ml lp mm mn mo ls jt mp ju lv jw mq jx ly jz mr ka mb ms bi translated">它看起来像什么:</h1><p id="8c57" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我们将使用<strong class="kq io"> passport、jsonwebtoken和cookie-session。</strong>我也将使用ReactJS前端。</p><p id="0c4b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">创建一个新的项目目录并初始化一个新的节点项目。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="e990" class="lk ll in mw b gy nb nc l nd ne">$ mkdir secure-starter<br/>$ cd secure-starter<br/>$ npm init</span></pre><p id="b534" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">没什么特别的，我只是喜欢将我的“main”设置为server.js，现在我们有了一个package.json文件。</p><p id="c78b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们下载起始依赖项</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="5d88" class="lk ll in mw b gy nb nc l nd ne">$ npm install --save express cookie-session</span></pre><p id="30a9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们在根目录下为一个简单的express应用程序创建server.js:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="21d7" class="lk ll in mw b gy nb nc l nd ne">// server.js<br/>const express = require('express');<br/>const session = require('cookie-session');<br/><br/>/* Create Express App */<br/>const app = express();<br/><br/>app.listen(8080, () =&gt; {<br/>  console.log("I'm listening!");<br/>});<br/><br/>module.exports = app;</span></pre><p id="e794" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的例子中，我们做了以下事情</p><ol class=""><li id="ec09" class="nf ng in kq b kr ks ku kv kx nh lb ni lf nj lj nk nl nm nn bi translated">导入我们的依赖项</li><li id="c142" class="nf ng in kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated">使用<code class="fe mt mu mv mw b">express()</code>创建快速应用程序</li><li id="f7d7" class="nf ng in kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated">我们的应用程序现在监听端口8080</li></ol><p id="0458" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们运行我们的服务器，我们可以看到它是活的:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="7adf" class="lk ll in mw b gy nb nc l nd ne">$ npm start<br/>&gt; node server.js</span><span id="005c" class="lk ll in mw b gy nt nc l nd ne">I'm listening!</span></pre><p id="96fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们添加饼干的东西:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="01e5" class="lk ll in mw b gy nb nc l nd ne">/* Create Express App */<br/>const app = express();</span><span id="6e21" class="lk ll in mw b gy nt nc l nd ne">...</span><span id="c77f" class="lk ll in mw b gy nt nc l nd ne">/* Set Cookie Settings */<br/>app.use(<br/>  session({<br/>    name: 'session',<br/>    secret: 'secretKeyWooo',<br/>    expires: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours<br/>  })<br/>);</span><span id="a69d" class="lk ll in mw b gy nt nc l nd ne">...</span><span id="7d99" class="lk ll in mw b gy nt nc l nd ne">app.listen(8080, () =&gt; {<br/>    console.log("I'm listening!");<br/>});</span></pre><p id="158d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好吧，这意味着什么</p><ol class=""><li id="f87f" class="nf ng in kq b kr ks ku kv kx nh lb ni lf nj lj nk nl nm nn bi translated">我们告诉我们的应用程序使用cookie会话中间件</li><li id="f786" class="nf ng in kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated">名称:是cookie设置的名称</li><li id="2fc5" class="nf ng in kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated">secret:用于签名和验证cookie值的字符串</li><li id="4c2f" class="nf ng in kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated">过期时间:我们的cookie将于何时过期。</li></ol><p id="daaa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">需要注意的是，我们可以将其他选项传递到我们的cookie设置中，这也是我没有包括它们的原因:</strong></p><ul class=""><li id="3c38" class="nf ng in kq b kr ks ku kv kx nh lb ni lf nj lj nu nl nm nn bi translated">secure:一个布尔值，指示cookie是否只通过https发送。默认情况下，http为false，https为true。所以我们现在可以把它留为空白，但是对于生产来说，这应该是正确的。<strong class="kq io">因此，请始终通过https托管您的站点</strong>。</li><li id="9998" class="nf ng in kq b kr no ku np kx nq lb nr lf ns lj nu nl nm nn bi translated">httpOnly:一个布尔值，指示cookie是否只通过http(s)发送。这在默认情况下是正确的，这很好，因为我们不希望客户端Javascript使用它。</li><li id="f56c" class="nf ng in kq b kr no ku np kx nq lb nr lf ns lj nu nl nm nn bi translated">signed:一个布尔值，指示是否要对cookie进行签名。默认情况下是这样的。</li></ul><p id="a0cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还有一些我们不需要的其他设置，但对您的应用程序可能有用，所以请查看文档了解详细信息。</p><h2 id="f8b2" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">添加一些额外的安全中间件</h2><p id="887c" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">以下是一些附加的安全中间件及其说明:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="b5fd" class="lk ll in mw b gy nb nc l nd ne">$ npm install --save helmet hpp csurf express-rate-limit</span></pre><p id="108e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">头盔— </strong>设置各种HTTP头，帮助防御常见的web应用安全漏洞，如xss攻击。</p><p id="d11b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> hpp — </strong>这可以防止HTTP参数污染攻击</p><p id="7d76" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> csurf — </strong>这可以防止跨站点请求伪造。这需要在我们的cookie会话连接之后使用。</p><p id="d6ac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们的server.js在实现后看起来像这样:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="4cfb" class="lk ll in mw b gy nb nc l nd ne">// server.js<br/>const express = require('express');<br/>const session = require('cookie-session');<br/>const helmet = require('helmet');<br/>const hpp = require('hpp');<br/>const csurf = require('csurf');<br/><br/>/* Create Express App */<br/>const app = express();<br/><br/>/* Set Security Configs */<br/>app.use(helmet());<br/>app.use(hpp());<br/><br/>/* Set Cookie Settings */<br/>app.use(<br/>    session({<br/>        name: 'session',<br/>        secret: 'secretKeyWooo',<br/>        expires: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours<br/>    })<br/>);<br/>app.use(csurf());<br/><br/>app.use(limiter);<br/><br/>app.listen(8080, () =&gt; {<br/>    console.log("I'm listening!");<br/>});<br/><br/>module.exports = app;</span></pre><h1 id="d069" class="mi ll in bd lm mj mk ml lp mm mn mo ls jt mp ju lv jw mq jx ly jz mr ka mb ms bi translated">创建react前端:</h1><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="cbde" class="lk ll in mw b gy nb nc l nd ne">$ npx create-react-app client</span></pre><p id="624d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将在名为client的新目录中创建一个样板react应用程序。</p><p id="9cf2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">安装完成后，我们可以像这样运行react前端:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="9f88" class="lk ll in mw b gy nb nc l nd ne">$ cd client<br/>$ yarn start</span></pre><p id="e19e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将启动我们的开发服务器，并在localhost:3000上打开我们的模板</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nv"><img src="../Images/4263738a3174c2a2d86e90bbb1c82f35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xa7j5QhKOZHtgobQGcsl4g.png"/></div></div></figure><p id="315a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">非常好。</p><p id="1e77" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">是时候去掉一些App.js并创建一些新页面了。并且还设置了我们的代理:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="82ea" class="lk ll in mw b gy nb nc l nd ne">$ cd client<br/>$ yarn add http-proxy-middleware</span></pre><p id="b701" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">setupProxy.js:这是在client/src中</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="0fed" class="lk ll in mw b gy nb nc l nd ne">const proxy = require('http-proxy-middleware').createProxyMiddleware;<br/><br/>module.exports = function (app) {<br/>    app.use(proxy(`/auth/**`, { target: 'http://localhost:8080' }));<br/>};</span></pre><p id="b5c4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们这样做的原因是为了能够将去往<code class="fe mt mu mv mw b">/auth/*</code>的请求传递到我们的后端，而不是被localhost:3000捕获，这个代理设置不应该影响生产中的任何事情。</p><p id="6bea" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">App.js</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="8f4b" class="lk ll in mw b gy nb nc l nd ne">import React, {useState} from 'react';<br/>import './App.css';<br/>import Home from "./Home";<br/>import Profile from "./Profile";<br/>import Loading from "./Loading";<br/><br/>function App() {<br/>  const [auth, setAuth] = useState(null); // IF WE CHANGE THIS INITIAL VALUE WE GET DIFFERENT PAGES<br/><br/>  if (auth === null) {<br/>    return &lt;Loading/&gt;<br/>  }<br/>  if (auth) {<br/>    return &lt;Profile/&gt;<br/>  }<br/>  return &lt;Home/&gt;<br/>}<br/><br/>export default App;</span></pre><p id="50c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">解释:</strong>我们的App.js文件现在将根据用户的身份验证状态来“路由”用户。当页面第一次加载时，我们不知道我们的用户是否经过身份验证，所以我们使用<code class="fe mt mu mv mw b">useState</code>创建一个auth值，并将其初始值设置为null</p><p id="2da5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当auth值为null时，我们返回加载屏幕。如果我们的身份验证是真的，那么我们返回我们的个人资料屏幕，否则我们将显示主屏幕(或登录屏幕)。稍后我们将实现一个逻辑，根据用户是否登录来改变auth值。</p><p id="f065" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> Home.js:在客户端/src </strong></p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="1164" class="lk ll in mw b gy nb nc l nd ne">import React from 'react';<br/>import './App.css';<br/><br/>function Home() {<br/>    return (<br/>        &lt;div className="App"&gt;<br/>            &lt;header className="App-header"&gt;<br/>                &lt;p&gt;<br/>                    You are not logged in<br/>                &lt;/p&gt;<br/>                &lt;a<br/>                    className="App-link"<br/>                    href={"/auth/login"}<br/>                &gt;<br/>                    Login Here<br/>                &lt;/a&gt;<br/>            &lt;/header&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}<br/><br/>export default Home;</span></pre><p id="51cc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">解释:</strong>这是一个简单的登录屏幕，我们的登录链接指向/auth/login，它应该路由到我们的后端。</p><p id="6f9d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> Loading.js </strong></p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="5ab6" class="lk ll in mw b gy nb nc l nd ne">import React from 'react';<br/>import './App.css';<br/><br/>function Loading() {<br/>    return (<br/>        &lt;div className="App"&gt;<br/>            &lt;header className="App-header"&gt;<br/>                &lt;p&gt;<br/>                    Loading...<br/>                &lt;/p&gt;<br/>            &lt;/header&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}<br/><br/>export default Loading;</span></pre><p id="7e41" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> Profile.js </strong></p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="1039" class="lk ll in mw b gy nb nc l nd ne">import React from 'react';<br/>import './App.css';<br/><br/>function Profile() {<br/>    return (<br/>        &lt;div className="App"&gt;<br/>            &lt;header className="App-header"&gt;<br/>                &lt;p&gt;<br/>                    You are logged in :)<br/>                &lt;/p&gt;<br/>                &lt;a<br/>                    className="App-link"<br/>                    href={"/auth/logout"}<br/>                &gt;<br/>                    Logout<br/>                &lt;/a&gt;<br/>            &lt;/header&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}<br/><br/>export default Profile;</span></pre><p id="6bcc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，如果auth为空，我们的屏幕如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/081761172b1557b7ca3349f061186651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/1*Gk-UeRXLjZWUi-nJzIbSOg.png"/></div></figure><p id="abfd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们的认证是假的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nx"><img src="../Images/4e1fc0ac75b232d2b98f20b93d94a536.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUfpinWGrEUupBUTTdCxgQ.png"/></div></div></figure><p id="72cd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">到目前为止，这些链接和按钮不会做任何事情，但是在我们配置了我们的auth0和后端服务器auth设置之后，它们就有意义了。</p><h1 id="1506" class="mi ll in bd lm mj mk ml lp mm mn mo ls jt mp ju lv jw mq jx ly jz mr ka mb ms bi translated"><strong class="ak">创建一个auth0帐户并设置回拨/重定向URL</strong></h1><p id="41d0" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">Auth0是一个很棒的第三方认证方，它允许对所有类型的应用程序进行多方面的集成。您不需要使用Auth0，基于passport的身份验证策略有许多选项，但Auth0是我尚未使用过的一种，它们允许自己的登录屏幕，并记录所有身份验证尝试。</p><ol class=""><li id="9fb9" class="nf ng in kq b kr ks ku kv kx nh lb ni lf nj lj nk nl nm nn bi translated">转到<a class="ae ny" href="https://manage.auth0.com/welcome/#" rel="noopener ugc nofollow" target="_blank">https://manage.auth0.com/welcome/#</a></li><li id="b571" class="nf ng in kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated">通过注册创建一个帐户</li><li id="8d76" class="nf ng in kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated">选择一个与您或您的应用相关联的租户域</li><li id="9fe6" class="nf ng in kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated">选择“个人”并进入下一步</li><li id="0ca8" class="nf ng in kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated">创建应用程序并选择常规web应用程序</li></ol><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nz"><img src="../Images/4641727d5ec11b9d44138217cea784f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V35CbOvTN1RNnmVzUgom4w.png"/></div></div></figure><p id="dbaf" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">选择node.js作为项目背后的技术。</p><p id="ab24" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">创建新应用程序后，您将能够在仪表板中查看基本信息和属性。您还可以访问Auth0的快速入门教程，这非常方便，但只有在您决定使用express-session时才完全有用。找到Node.js、auth0和cookie-session的教程实际上比我想象的要困难。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oa"><img src="../Images/e96d360f0b1796905b27d884afa077ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R60CCk_zHczz1bijCVa0xw.png"/></div></div></figure><p id="3e92" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">你需要做的一件重要的事情是:在你允许的回调url部分，你应该输入</strong> <code class="fe mt mu mv mw b"><a class="ae ny" href="http://localhost:3000/auth/callback." rel="noopener ugc nofollow" target="_blank">http://localhost:3000/auth/callback.</a></code>这是Auth0在完成对你的用户的认证后将重定向到的URL。</p><p id="0515" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您需要将您的Auth0应用程序域、clientID和客户端机密复制到您的应用程序中。最佳实践是将其存储在一个<code class="fe mt mu mv mw b">.env</code>文件中，并使用<code class="fe mt mu mv mw b">dotenv</code>包将这些配置应用到您的节点流程中，不要忘记将它们从您的git提交中排除，这样您就不会公开显示您的客户端秘密。你也可以用这个。env文件来保存您的cookie的秘密。</p><p id="1767" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">甚至在制作这个教程的时候，我不小心把我的auth0秘密提交给了github。幸运的是，Auth0允许您旋转您的密钥。呜呜:)</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="f1a1" class="lk ll in mw b gy nb nc l nd ne">$ npm install --save dotenv</span></pre><p id="e357" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后我们添加我们的dotenv配置设置</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="db1a" class="lk ll in mw b gy nb nc l nd ne">const dotenv = require('dotenv');<br/>const path = require('path');<br/><br/>/* Import config */ // THIS IS NEW :)<br/>dotenv.config({path: path.resolve(__dirname, '.env')});</span><span id="6142" class="lk ll in mw b gy nt nc l nd ne">/* Create Express App */<br/>const app = express();<br/><br/>/* Set Security Configs */<br/>app.use(helmet());<br/>app.use(hpp());<br/><br/>/* Set Cookie Settings */<br/>app.use(<br/>    session({<br/>        name: 'session',<br/>        secret: process.env.COOKIE_SECRET, // WE USE THIS NOW :)<br/>        expires: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours<br/>    })<br/>);<br/>app.use(csurf());</span></pre><p id="df2b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们的……env文件，该文件应位于根目录:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="2878" class="lk ll in mw b gy nb nc l nd ne">AUTH0_SECRET=&lt;your secret&gt;<br/>AUTH0_CLIENT_ID=&lt;your client id&gt;<br/>AUTH0_DOMAIN=&lt;your domain&gt;<br/>AUTH0_CALLBACK_URL=http://localhost:3000/auth/callback<br/>COOKIE_SECRET=&lt;move your cookie secret here&gt;<br/>JWT_SECRET_KEY=secretttttttt // THIS IS ALSO NEW</span></pre><h1 id="2de5" class="mi ll in bd lm mj mk ml lp mm mn mo ls jt mp ju lv jw mq jx ly jz mr ka mb ms bi translated">执行护照:</h1><p id="dcea" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">Passport是Node.js的一个身份验证中间件，它非常好。它有许多认证策略，例如通过谷歌、facebook，甚至本地认证策略。我们将实现两个策略:auth0和jwt。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="98b1" class="lk ll in mw b gy nb nc l nd ne">$ npm install --save passport passport-auth0 passport-jwt jsonwebtoken</span></pre><p id="6aa2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们创建了passport.js文件:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="29e3" class="lk ll in mw b gy nb nc l nd ne">// middlewares/passport.js<br/>const passport = require('passport');<br/>const Auth0Strategy = require('passport-auth0');<br/>const JwtStrategy = require('passport-jwt').Strategy;<br/>const auth0Strategy = new Auth0Strategy(<br/>    {<br/>        domain: process.env.AUTH0_DOMAIN,<br/>        clientID: process.env.AUTH0_CLIENT_ID,<br/>        clientSecret: process.env.AUTH0_SECRET,<br/>        callbackURL: process.env.AUTH0_CALLBACK_URL,<br/>    },<br/>    (accessToken, refreshToken, extraParams, profile, done) =&gt; {<br/>        return done(null, profile);<br/>    }<br/>);<br/><br/>const jwtStrategy = new JwtStrategy(<br/>    {<br/>        jwtFromRequest: (req) =&gt; req.session.jwt,<br/>        secretOrKey: process.env.JWT_SECRET_KEY,<br/>    },<br/>    (payload, done) =&gt; {<br/>        // <em class="ob">TODO: add additional jwt token verification<br/>        </em>return done(null, payload);<br/>    }<br/>);<br/><br/>passport.use(auth0Strategy);<br/>passport.use(jwtStrategy);<br/><br/>module.exports = passport;</span></pre><p id="90c7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们来谈谈这些策略:</p><ol class=""><li id="d0a8" class="nf ng in kq b kr ks ku kv kx nh lb ni lf nj lj nk nl nm nn bi translated"><strong class="kq io"> Auth0Strategy </strong>:这将从获取您的域、clientId、clientSecret和回调URL。，并使用它将用户重定向到Auth0登录页。一旦用户完成登录，Auth0将他们重定向回回调url，现在我们将在其中拥有此用户的配置文件。</li><li id="66e2" class="nf ng in kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated"><strong class="kq io"> JwtStrategy </strong>是passport验证jwt令牌的一种简单方法，它使用给定的秘密来解码jwt的签名并返回编码到令牌中的有效负载。</li></ol><p id="74ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将passport文件导入app.js文件，确保这是在导入<code class="fe mt mu mv mw b">.env</code>文件之后，因为<code class="fe mt mu mv mw b">passport.js</code>使用<code class="fe mt mu mv mw b">process.env</code>配置。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="19cd" class="lk ll in mw b gy nb nc l nd ne">const passport = require('./middlewares/passport');</span></pre><p id="76ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">初始化应用程序后，您应该告诉它使用passport中间件:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="208d" class="lk ll in mw b gy nb nc l nd ne">app.use(passport.initialize());</span></pre><p id="2908" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">现在我们的应用程序正在使用passport，而且我们配置的策略可用。</strong></p><h1 id="2e85" class="mi ll in bd lm mj mk ml lp mm mn mo ls jt mp ju lv jw mq jx ly jz mr ka mb ms bi translated">实现我们的身份验证路由</h1><p id="5966" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我们应该创建auth.js路由。这些将是中公开的开放终结点，供我们的前端重定向以进行登录/注销过程。</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="94ff" class="lk ll in mw b gy nb nc l nd ne">const express = require('express');<br/>const passport = require('passport');<br/>const jwt = require('jsonwebtoken');<br/><br/>const jwtRequired = passport.authenticate('jwt', { session: false });<br/><br/>const router = express.Router();<br/><br/>router.get(<br/>    '/login',<br/>    passport.authenticate('auth0', {<br/>        scope: 'openid email profile',<br/>    }),<br/>    (req, res) =&gt; {<br/>        res.redirect('/');<br/>    }<br/>);<br/><br/>router.get('/callback', (req, res, next) =&gt; {<br/>    passport.authenticate('auth0', (err, user) =&gt; {<br/>        if (err) {<br/>            return next(err);<br/>        }<br/>        if (!user) {<br/>            return res.redirect('/login');<br/>        }<br/>        console.log("CALLBACK SUCCESSFUL!")<br/>        const userReturnObject = {<br/>            nickname: user.nickname,<br/>        };<br/>        req.session.jwt = jwt.sign(userReturnObject, process.env.JWT_SECRET_KEY);<br/>        return res.redirect('/');<br/>    })(req, res, next);<br/>});</span><span id="6f22" class="lk ll in mw b gy nt nc l nd ne">module.exports = router;</span></pre><p id="16b8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">解释:</p><ol class=""><li id="b973" class="nf ng in kq b kr ks ku kv kx nh lb ni lf nj lj nk nl nm nn bi translated">我们的<code class="fe mt mu mv mw b">/login</code>路由利用了我们新的auth0 passport身份验证，为配置文件请求了一些用户范围。当此终结点被命中时，它实际上将用户重定向到Auth0登录屏幕。</li><li id="2f51" class="nf ng in kq b kr no ku np kx nq lb nr lf ns lj nk nl nm nn bi translated"><code class="fe mt mu mv mw b">/callback</code>需要从Auth0登录屏幕接收回用户数据。这将把我们的凭据传递回passport身份验证过程，该过程将验证从Auth0返回的信息是否有效。如果出现错误或用户为空，我们会将用户重定向回/login路径。否则，我们现在拥有用户的信用</li></ol><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="222b" class="lk ll in mw b gy nb nc l nd ne">req.session.jwt = jwt.sign(userReturnObject, process.env.JWT_SECRET_KEY)</span></pre><p id="a0b1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">3.上面的代码片段是为我们的用户创建无状态会话的基础。我们获取来自用户对象的一些信息，将其打包在JWT令牌中，并使用我们的密钥对其进行签名。然后，我们将JWT令牌分配给我们的req.session，这是我们使用<code class="fe mt mu mv mw b">cookie-session</code>库创建的cookie。</p><p id="174c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">此cookie将在每个请求时发回，并应包含我们的用户jwt令牌。</strong></p><p id="8ee7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的server.js文件中，我们需要包含新的身份验证路由:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="de81" class="lk ll in mw b gy nb nc l nd ne">app.use(passport.initialize()); </span><span id="e2c1" class="lk ll in mw b gy nt nc l nd ne">//... this is new stuff<br/>const authRoutes = require('./routes/auth');<br/>app.use('/auth', authRoutes);<br/>//...</span><span id="b057" class="lk ll in mw b gy nt nc l nd ne">app.listen(8080, () =&gt; {<br/>    console.log("I'm listening!");<br/>});</span></pre><p id="d526" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，当我们点击登录按钮时，我们应该正确地重定向到我们的auth0登录屏幕:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/495de07769b74a9460ff77b6d65271eb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1066/format:webp/1*_pfg6jJOURedMQ_NgpyE7g.png"/></div></figure><p id="5eb7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我们登录时，我们应该成功地重定向回我们的应用程序。不幸的是，我们还没有完全完成我们的前端，所以可能很难确定我们是否真正登录。但是你可以在回调函数中放置一些日志来打印一些成功的语句！我添加的那个应该显示:</p><p id="ce62" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe mt mu mv mw b">CALLBACK SUCCESSFUL!</code></p><h1 id="fe98" class="mi ll in bd lm mj mk ml lp mm mn mo ls jt mp ju lv jw mq jx ly jz mr ka mb ms bi translated">设置私有路由</h1><p id="875b" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我们已经正式给了我们的新用户一个jwt令牌。但是我们希望能够使用该令牌来验证他的会话是有效的。</p><p id="670b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">在我们的授权路由文件中，我们可以添加passport-jwt策略作为保护路由的中间件:</strong></p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="4ea6" class="lk ll in mw b gy nb nc l nd ne">const jwtRequired = passport.authenticate('jwt', { session: false });<br/><br/>router.get('/private-route', jwtRequired, (req, res) =&gt; {<br/>    return res.send('This is a private route');<br/>});</span></pre><p id="9b8b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，当我们在<code class="fe mt mu mv mw b">/private-route</code>端点接收到一个请求时，我们的passport-jwt策略试图解码附加到请求的cookie会话上的令牌。如果有问题，或者没有令牌，将发送401。如果没有问题，那么这条路线是可行的！</p><h1 id="dc56" class="mi ll in bd lm mj mk ml lp mm mn mo ls jt mp ju lv jw mq jx ly jz mr ka mb ms bi translated"><strong class="ak">如果我们想要保护前端路由怎么办？</strong></h1><p id="dff0" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我们的浏览器有cookie，但是我们实际的客户端react前端不知道身份验证状态。当我们在浏览器中加载页面时，我们希望我们的应用程序能够检查后端以获取当前用户会话。我们可以向我们的授权路由添加另一个路由来实现这一点:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="9c2b" class="lk ll in mw b gy nb nc l nd ne">router.get('/current-session', (req, res) =&gt; {<br/>    passport.authenticate('jwt', { session: false }, (err, user) =&gt; {<br/>        if (err || !user) {<br/>            res.send(false);<br/>        } else {<br/>            res.send(user);<br/>        }<br/>    })(req, res);<br/>});</span></pre><p id="3855" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这个端点中，我们验证用户的cookie会话是否包含有效的jwt令牌，但是一旦令牌被解码，我们就获取存储在该令牌中的信息，并将其发送到前端。</p><h1 id="7140" class="mi ll in bd lm mj mk ml lp mm mn mo ls jt mp ju lv jw mq jx ly jz mr ka mb ms bi translated">前端工作</h1><p id="c0bd" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我们需要设置我们的前端，以便当我们的网站加载时，我们向后端发送一个请求来获取我们的会话，如果我们的会话存在，那么我们可以正确地路由我们的用户。我们将安装axios，以便轻松发送请求:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="3d7a" class="lk ll in mw b gy nb nc l nd ne">$ cd client <br/>$ yarn add axios</span></pre><p id="7e4d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在我们的App.js中，我们添加了将请求发送到新的<code class="fe mt mu mv mw b">current-user</code>端点的逻辑:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="6e28" class="lk ll in mw b gy nb nc l nd ne">import React, {useState, useEffect} from 'react';<br/>import axios from 'axios';<br/>import './App.css';<br/>import Home from "./Home";<br/>import Profile from "./Profile";<br/>import Loading from "./Loading";<br/><br/>function App() {<br/>  const [auth, setAuth] = useState(null);<br/><br/>  useEffect(() =&gt; {<br/>    axios.get('/auth/current-session').then(({data}) =&gt; {<br/>      setAuth(data);<br/>    })<br/>  }, [])<br/><br/>  if (auth === null) {<br/>    return &lt;Loading/&gt;<br/>  }<br/>  if (auth) {<br/>    return &lt;Profile auth={auth}/&gt;<br/>  }<br/>  return &lt;Home/&gt;<br/>}<br/><br/>export default App;</span></pre><p id="7099" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">您可以看到，无论我们从请求中获得什么数据，我们都会设置我们的前端身份验证状态。如果您看一下端点逻辑，如果我们的会话不存在(我们的用户没有登录),那么就会返回一个false值，告诉我们的前端显示主屏幕。如果我们的会话存在，我们的身份验证状态就是我们的用户对象。我们将auth state对象传递给我们配置文件。</p><p id="e54f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在我们可以在Profile.js屏幕中使用我们的auth对象了:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="d993" class="lk ll in mw b gy nb nc l nd ne">import React from 'react';<br/>import './App.css';<br/><br/>function Profile({auth}) {<br/>    return (<br/>        &lt;div className="App"&gt;<br/>            &lt;header className="App-header"&gt;<br/>                &lt;p&gt;<br/>                    You are logged in as {auth &amp;&amp; auth.nickname ? auth.nickname : null}<br/>                &lt;/p&gt;<br/>                &lt;a<br/>                    className="App-link"<br/>                    href={"/auth/logout"}<br/>                &gt;<br/>                    Logout<br/>                &lt;/a&gt;<br/>            &lt;/header&gt;<br/>        &lt;/div&gt;<br/>    );<br/>}<br/><br/>export default Profile;</span></pre><p id="6c32" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">登录时应该看起来有点像这样:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi od"><img src="../Images/e70b0d6fe99f41d31fd424eba58ddd53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*SqeIcSbwxTz2x6UHB4aO8g.png"/></div></figure><h1 id="4367" class="mi ll in bd lm mj mk ml lp mm mn mo ls jt mp ju lv jw mq jx ly jz mr ka mb ms bi translated"><strong class="ak">注销时销毁您的会话</strong></h1><p id="dd3d" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">您可能会注意到，在我们的Profile.js屏幕上，我们有一个重定向到<code class="fe mt mu mv mw b">/auth/logout</code>的按钮。为了实现这一点，我们需要将该端点添加到我们的后端身份验证路由中:</p><pre class="kd ke kf kg gt mx mw my mz aw na bi"><span id="801c" class="lk ll in mw b gy nb nc l nd ne">router.get('/logout', (req, res) =&gt; {<br/>    req.session = null;<br/>    const homeURL = encodeURIComponent('http://localhost:3000/');<br/>    res.redirect(<br/>        `https://${process.env.AUTH0_DOMAIN}/v2/logout?returnTo=${homeURL}&amp;client_id=${process.env.AUTH0_CLIENT_ID}`<br/>    );<br/>});</span></pre><p id="6f70" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这种情况下，我们只是去掉了分配给req.session的jwt令牌，并让Auth0知道我们的用户已经请求注销。这应该会重定向到我们的主页！我们正式结束了！</p><h1 id="b45c" class="mi ll in bd lm mj mk ml lp mm mn mo ls jt mp ju lv jw mq jx ly jz mr ka mb ms bi translated"><strong class="ak">结论</strong></h1><p id="d5aa" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">实现可靠身份认证层的方法有很多，一旦你习惯了每一部分的工作方式，你就可以将它们组合在一起，形成一个适合你的应用功能的流程。</p><p id="1f5e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">非常感谢您的阅读，如果有任何不清楚的地方，请给我发问题！</p><p id="4be6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是源代码:<a class="ae ny" href="https://github.com/jdstregz/secure-starter" rel="noopener ugc nofollow" target="_blank">https://github.com/jdstregz/secure-starter</a></p><p id="790e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">黑客快乐！</p><h2 id="2bc9" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="927d" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae ny" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kq io">！</strong></p></div></div>    
</body>
</html>