<html>
<head>
<title>Roulette Logic Basics Built With React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">轮盘赌逻辑基础建立在反应钩上</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/roulette-logic-basics-built-with-react-hooks-c1433a025c36?source=collection_archive---------8-----------------------#2020-10-12">https://javascript.plainenglish.io/roulette-logic-basics-built-with-react-hooks-c1433a025c36?source=collection_archive---------8-----------------------#2020-10-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/407be379cb992b0003cbac72fce7e6e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a-69eqzB4QqmubNJSzWryQ.jpeg"/></div></div></figure><p id="00be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上周，我做了一个双层21点应用程序，并写了相关内容，链接到<a class="ae kt" href="https://medium.com/dev-genius/blackjack-game-logic-basics-built-with-react-hooks-8e7e41fbbb87" rel="noopener">这里</a>。作为一个曾经在赌场做了几年桌面游戏经销商的人，我非常喜欢制作21点应用程序，现在我正在创建一系列简单的赌场游戏web应用程序！</p><p id="77f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个星期，我决定轮盘赌将是有趣和具有挑战性的，但在短时间内建立和写是合理的。我在以前的21点帖子中使用了很多相同的心态，所以我建议你在这篇帖子之前先看看那篇帖子。</p><p id="40ba" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对我个人来说，这个应用程序与21点应用程序的最大区别之一是下注面。我用CSS网格创建了轮盘布局，它对我来说工作得很漂亮，如果你想创建任何一种类似于<em class="ku">网格</em>的结构，我强烈推荐它胜过Flexbox。</p><p id="2437" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，类似于21点后，这个职位将不会超过任何造型。相反，我们将关注创建这样一个应用程序所需的一些要素。</p><ol class=""><li id="1d4a" class="kv kw in jx b jy jz kc kd kg kx kk ky ko kz ks la lb lc ld bi translated">关于轮盘赌，我们需要事先了解什么？</li><li id="f283" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks la lb lc ld bi translated">它将需要什么样的状态，它是用来做什么的？</li><li id="a315" class="kv kw in jx b jy le kc lf kg lg kk lh ko li ks la lb lc ld bi translated">效果(生命周期方法)是如何流动的？</li></ol><p id="8ad0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些都是我将在这篇文章中回答的问题！如果你想看看我做的项目，我在底部放了一些游戏的GIF，并链接到Github库<a class="ae kt" href="https://github.com/tfunk2/tyleRoulette" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><h1 id="d6b8" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">简单来说就是轮盘赌</h1><p id="1b4e" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">首先，我要打破一个普遍的误解…绿色数字(0和00)并不比其他数字支付更多！</p><p id="6ac3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">除去这些，轮盘上总共有38个数字——1到36，都是零。球被旋转，当它落在一个编号的槽中时，在投注布局上有多个点根据赔率赢和支付。相当简单！</p><p id="26a2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是我发现的一个图表，我认为它很好地显示了每种类型的赌注是什么样子的，以及赔率是多少:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div class="gh gi mt"><img src="../Images/3fd61960dcf19ce697bf53986a59b136.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*1MEm1acxdVIcH8OS0hTC6w.jpeg"/></div></figure><p id="2373" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">彻底分解支出的例子有助于我理解这个游戏，所以我会在这里这样做。下面我将讨论3种不同的旋转会发生什么，这将展示轮盘赌的大部分基础知识。这是一个在旋转前下了多注的布局:</p><figure class="mu mv mw mx gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/6c4e7d5eb437c27926695bc80adf8b18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KY55mQZUYINh45ER9avbtg.png"/></div></div></figure><p id="62e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以下是支付任何轮盘赌赌注的非官方公式:</p><p id="c050" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="ku">(初始赌注)x(赔率乘数)+(赢的初始赌注返还)=支出</em> </strong></p><h2 id="1c04" class="mz lr in bd ls na nb dn lw nc nd dp ma kg ne nf me kk ng nh mi ko ni nj mm nk bi translated">中奖号码:14</h2><p id="38e3" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated"><strong class="jx io">下注即赢</strong> <br/> <em class="ku">直涨:</em><br/>3×35+3 = 108</p><p id="00ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">拆分:</em> <br/> (1 + 1) x 17 + 2 = 36</p><p id="8777" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">四角:</em><br/>2×8+2 = 18</p><p id="1174" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">街道:</em><br/>3×11+3 = 36</p><p id="0d3a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">双街道:</em><br/>2×5+2 = 12</p><p id="ff76" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">列:</em><br/>5×2+5 = 15</p><p id="acf3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="ku">总奖金:225 </em> </strong></p><p id="64b0" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">另外两个赌注(一个赌黑色，一个赌第三打)都输了，因为14是一个红色数字，不是25或更大。</p><h2 id="4416" class="mz lr in bd ls na nb dn lw nc nd dp ma kg ne nf me kk ng nh mi ko ni nj mm nk bi translated">中奖号码:26</h2><p id="5ce7" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated"><strong class="jx io">下注即赢</strong> <br/> <em class="ku">列:</em><br/>5×2+5 = 15</p><p id="197d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">打:</em><br/>10×2+10 = 30</p><p id="83f2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="ku">黑色:</em><br/>5×1+5 = 10</p><p id="c669" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="ku">总奖金:55 </em> </strong></p><p id="62b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这种情况下，唯一能赢的赌注是所谓的“外围”(列、打、高或低、奇数或偶数、红色或黑色)。所有其他押在“内部”的赌注都输了。</p><h2 id="fa26" class="mz lr in bd ls na nb dn lw nc nd dp ma kg ne nf me kk ng nh mi ko ni nj mm nk bi translated">中奖号码:00</h2><p id="98f1" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated"><strong class="jx io">赌赢</strong> <br/>无一</p><p id="3978" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="ku">总奖金:0 </em> </strong></p><p id="9e9e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当绿色数字落地时，赢的唯一方法是在零上下注或触摸零！在这种情况下，所有外面的赌注都输了，并且没有对00的赌注，所以没有赌注赢，玩家可能不太喜欢这个旋转！</p><p id="0522" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是全部了。下注、旋转球、根据中奖号码支付/接受赌注、冲洗、重复。现在我们可以开始写代码了！</p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><h1 id="3ac5" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">状态管理</h1><p id="c71b" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">看一个轮盘布局，投注点很多，差不多160个。有些号码在牌桌上有多达14个不同的中奖点。那么，用React钩子跟踪所有这些赌注和更多赌注是什么样子的呢？</p><p id="b3ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们来看看我在轮盘赌应用程序中使用的状态和它们的起始值:</p><pre class="mu mv mw mx gt nl nm nn no aw np bi"><span id="8eab" class="mz lr in nm b gy nq nr l ns nt">const [chipCount, setChipCount] = useState(1000);</span><span id="195f" class="mz lr in nm b gy nu nr l ns nt">const [pendingTotalBet, setPendingTotalBet] = useState(0);</span><span id="ca96" class="mz lr in nm b gy nu nr l ns nt">const [currentBetValue, setCurrentBetValue] = useState(0);</span><span id="fbf4" class="mz lr in nm b gy nu nr l ns nt">const [totalAmountWon, setTotalAmountWon] = useState(0); </span><span id="2c32" class="mz lr in nm b gy nu nr l ns nt">const [winningNumber, setWinningNumber] = useState(null);</span><span id="4048" class="mz lr in nm b gy nu nr l ns nt">const [previousTwenty, setPreviousTwenty] = useState([]);</span><span id="a4ec" class="mz lr in nm b gy nu nr l ns nt">const [straightUps, setStraightUps] = useState([<br/>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,<br/>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,<br/>0, 0, 0, 0, 0, 0, 0, 0<br/>]); // 38 straight up numbers</span><span id="23e9" class="mz lr in nm b gy nu nr l ns nt">const [splits, setSplits] = useState([<br/>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,<br/>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,<br/>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,<br/>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,<br/>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br/>]); // 60 streets</span><span id="29e9" class="mz lr in nm b gy nu nr l ns nt">const [streets, setStreets] = useState([<br/>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br/>]); // 15 streets</span><span id="a59e" class="mz lr in nm b gy nu nr l ns nt">const [corners, setCorners] = useState([<br/>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,<br/>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br/>]); // 22 corners</span><span id="cd00" class="mz lr in nm b gy nu nr l ns nt">const [doubleStreets, setDoubleStreets] = useState([<br/>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br/>]); // 11 double streets</span><span id="5f7e" class="mz lr in nm b gy nu nr l ns nt">const [basket, setBasket] = useState(0);</span><span id="c13d" class="mz lr in nm b gy nu nr l ns nt">const [columns, setColumns] = useState([0, 0, 0]);</span><span id="9bb3" class="mz lr in nm b gy nu nr l ns nt">const [dozens, setDozens] = useState([0, 0, 0]);</span><span id="9e1f" class="mz lr in nm b gy nu nr l ns nt">const [redBlack, setRedBlack] = useState([0, 0]);</span><span id="9027" class="mz lr in nm b gy nu nr l ns nt">const [oddEven, setOddEven] = useState([0, 0]);</span><span id="c48f" class="mz lr in nm b gy nu nr l ns nt">const [highLow, setHighLow] = useState([0, 0]);</span><span id="4be9" class="mz lr in nm b gy nu nr l ns nt">const [isSpinComplete, setIsSpinComplete] = useState(false);</span><span id="b55b" class="mz lr in nm b gy nu nr l ns nt">const [recentBet, setRecentBet] = useState([]);</span><span id="f34b" class="mz lr in nm b gy nu nr l ns nt">const [recentBetValue, setRecentBetValue] = useState(0);</span><span id="c91b" class="mz lr in nm b gy nu nr l ns nt">const [isWheelSpinning, setIsWheelSpinning] = useState(false)</span></pre><p id="666f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些状态中的每一个都有一个或多个目的，并跟踪某种相关信息。一些人跟踪下注和下注历史，而其他人跟踪游戏流程和统计数据。下面，我将把我通常使用的每个状态分解为:</p><p id="ef35" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nv nw nx nm b">const [chipCount, setChipCount] = useState(1000);</code> <br/>跟踪用户当前拥有的筹码总数，从1000开始，并在下注和领取奖金时更新。</p><p id="6981" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nv nw nx nm b">const [pendingTotalBet, setPendingTotalBet] = useState(0);</code> <br/>跟踪当前布局上所有下注的总数，并用于将<code class="fe nv nw nx nm b">chipCount</code>重置回下注前的状态。如果玩家的赌注都没有赢，也可以用来知道输了多少钱。</p><p id="58b3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nv nw nx nm b">const [currentBetValue, setCurrentBetValue] = useState(0);</code> <br/>跟踪选择哪个筹码值在布局上下注。我的轮盘赌应用程序中的面额从5英镑到100万英镑不等。这用来知道每个单独的投注空间的投注增加多少。</p><p id="b038" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nv nw nx nm b">const [totalAmountWon, setTotalAmountWon] = useState(0);</code> <br/>组合并跟踪任何一次特定旋转中每一次下注的总赢款。用于祝贺玩家旋转获胜，并告诉他们赢了多少钱。</p><p id="9d24" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nv nw nx nm b">const [winningNumber, setWinningNumber] = useState(null);</code> <br/>追踪任意一次旋转中被随机选中的当前中奖号码。用于准确确定每轮支付的赌注。</p><p id="5c87" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nv nw nx nm b">const [previousTwenty, setPreviousTwenty] = useState([]);</code> <br/>通过在每次旋转后添加中奖号码来跟踪最后二十次旋转。这是轮盘中常见的特征，为玩家提供了一个机会来查看球最近在轮盘中的位置。</p><p id="26b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于<code class="fe nv nw nx nm b">straightUps</code>、<code class="fe nv nw nx nm b">splits</code>、<code class="fe nv nw nx nm b">corners</code>、<code class="fe nv nw nx nm b">streets</code>、<code class="fe nv nw nx nm b">doubleStreets</code>、<code class="fe nv nw nx nm b">basket</code>、<code class="fe nv nw nx nm b">dozens</code>、<code class="fe nv nw nx nm b">columns</code>、<code class="fe nv nw nx nm b">redBlack</code>、<code class="fe nv nw nx nm b">oddEven</code>、<code class="fe nv nw nx nm b">highLow</code>、<br/>跟踪赌桌上每个可能投注点的投注金额。这些数字乘以基于下注类型的赔率，并添加到原始下注中，以了解玩家在任何一次旋转中应获得的金额(如果有)。</p><p id="a3f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nv nw nx nm b">const [isSpinComplete, setIsSpinComplete] = useState(false);<br/></code>跟踪轮盘是否已经旋转，换句话说，游戏是否结束。开始为<code class="fe nv nw nx nm b">false</code>，然后在旋转和支付完成/收集后，变为<code class="fe nv nw nx nm b">true</code>。用作控制游戏流程的手段，并有条件地显示或隐藏元素以提供更好的用户体验。</p><p id="b94c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nv nw nx nm b">const [recentBet, setRecentBet] = useState([]);</code> <br/>跟踪一个包含两个项目的数组，在一个字符串中输入下注类型(例如。:“split”)，以及在该特定状态的数组中可以找到下注点的索引。<code class="fe nv nw nx nm b">recentBet</code>用于我制作的一个功能/按钮，允许用户收回他们在布局上的最后一次下注。</p><p id="c8df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nv nw nx nm b">const [recentBetValue, setRecentBetValue] = useState(0);</code> <br/>跟踪所下的<code class="fe nv nw nx nm b">recentBet</code>的值，以便当赌注被取消时，正确的金额被放回<code class="fe nv nw nx nm b">chipCount</code>。</p><p id="6866" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><code class="fe nv nw nx nm b">const [isWheelSpinning, setIsWheelSpinning] = useState(false)<br/></code>点击“旋转”按钮后，跟踪轮子是否在运动，用来给人一种球在旋转的轮子上等待几秒钟的效果，就像你在现实生活中一样。当<code class="fe nv nw nx nm b">winningNumber</code>被设置时，它启动支付序列，玩家领取他们的钱或什么也得不到，布局在下一轮下注/旋转之前被清除。</p><p id="8a22" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了这样的状态设置，我就有了一个可以正常工作的轮盘赌应用程序。然而，为了让用户更喜欢这个应用程序，我创建了一个进程来帮助指导玩家完成每个旋转。我把这叫做游戏流，我接下来会讲到！</p></div><div class="ab cl lj lk hr ll" role="separator"><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo lp"/><span class="lm bw bk ln lo"/></div><div class="ig ih ii ij ik"><h1 id="e80f" class="lq lr in bd ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn bi translated">游戏流程</h1><p id="ed2f" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">这一部分讨论了是什么让游戏运行，但它没有深入到完美的细节，为了继续下去，请随意看看代码，我将在这里再次链接<a class="ae kt" href="https://github.com/tfunk2/tyleRoulette" rel="noopener ugc nofollow" target="_blank"/>。下面是一些游戏的GIF图，有助于形象化我在游戏流程中描述的内容:</p><figure class="mu mv mw mx gt jo"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="oa ob gj gh gi oc od bd b be z dk">Make sure to select HD! For some reason SD is default for me.</figcaption></figure><h2 id="2081" class="mz lr in bd ls na nb dn lw nc nd dp ma kg ne nf me kk ng nh mi ko ni nj mm nk bi translated">下注</h2><p id="f294" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">首先，我确保旋转按钮的<code class="fe nv nw nx nm b">onClick</code>功能不能被点击，直到在布局上有一个赌注。本质上，牌桌的最小赌注是1。</p><p id="3473" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我让赌博工作的方式是给每个芯片一个<code class="fe nv nw nx nm b">onClick</code>功能，它将把<code class="fe nv nw nx nm b">currentBetValue</code>状态改变为芯片上的数字。一旦<code class="fe nv nw nx nm b">currentBetValue</code>大于0，只要玩家的<code class="fe nv nw nx nm b">chipCount</code>中有足够的筹码，下注点就会变成可点击的。</p><p id="c3f7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着下注的进行，<code class="fe nv nw nx nm b">pendingTotalBet</code>增加。一旦玩家结束下注，他们可以点击旋转按钮；这引发了下一系列事件。</p><h2 id="e776" class="mz lr in bd ls na nb dn lw nc nd dp ma kg ne nf me kk ng nh mi ko ni nj mm nk bi translated">旋转方向盘</h2><p id="5276" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">一旦下注完毕，当点击旋转按钮时，一个我命名为<code class="fe nv nw nx nm b">spinTheWheel</code>的功能激活，让我们来看看:</p><pre class="mu mv mw mx gt nl nm nn no aw np bi"><span id="3b51" class="mz lr in nm b gy nq nr l ns nt">const spinTheWheel = () =&gt; {<br/>  if(!isSpinComplete &amp;&amp; pendingTotalBet &gt; 0 &amp;&amp; !isWheelSpinning) {<br/>    setIsWheelSpinning(true)</span><span id="3f18" class="mz lr in nm b gy nu nr l ns nt">    setTimeout(() =&gt; {<br/>      let randomIndex = Math.floor(Math.random() * Math.floor(38));<br/>      let randomWinner = wheelNumbers[randomIndex];<br/>      setWinningNumber(randomWinner);</span><span id="16d2" class="mz lr in nm b gy nu nr l ns nt">      let currentTwenty = [...previousTwenty];</span><span id="cb68" class="mz lr in nm b gy nu nr l ns nt">      if(currentTwenty.length &lt; 20) {<br/>        setPreviousTwenty([randomWinner, ...previousTwenty]);<br/>      } else {<br/>        currentTwenty.unshift(randomWinner);<br/>        currentTwenty.pop();<br/>        setPreviousTwenty(currentTwenty);<br/>      };</span><span id="3f71" class="mz lr in nm b gy nu nr l ns nt">      setIsSpinComplete(true)<br/>    }, 3000)<br/>  }<br/>};`</span></pre><p id="a8f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总结一下，如果旋转没有完成(下注阶段)，<strong class="jx io">和</strong>到目前为止总下注金额大于0，<strong class="jx io">和</strong>轮盘当前没有旋转，将<code class="fe nv nw nx nm b">isWheelSpinning</code>的状态改为<code class="fe nv nw nx nm b">true</code>。这就是轮子动画的工作方式，当该状态为真时，轮子图像样式的<code class="fe nv nw nx nm b">className</code>会改变，以使用CSS关键帧为其制作动画。</p><p id="f676" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后，我使用了一个<code class="fe nv nw nx nm b">setTimeout</code>来延迟即将到来的代码，这样轮子将继续旋转，直到我最终将<code class="fe nv nw nx nm b">isWheelSpinning</code>设置回false。</p><p id="a3f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦3000毫秒(3秒)过去，我将一个常数<code class="fe nv nw nx nm b">randomIndex</code>设置为0到37之间的一个随机数，你猜对了，这是为了索引。利用这个索引，我从一个名为<code class="fe nv nw nx nm b">wheelNumbers</code>的变量数组中获取中奖号码，将所有38种中奖可能性设置为字符串(这样我就可以正确地使用双零)。然后，我获取检索到的中奖号码字符串，并用它设置<code class="fe nv nw nx nm b">winningNumber</code>的状态。然后这开始了一连串的事件，我将在<strong class="jx io">旋转后/支出</strong>部分讨论这些事件。</p><p id="6017" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在将<code class="fe nv nw nx nm b">isSpinComplete</code>设置为<code class="fe nv nw nx nm b">true</code>以指示旋转结束并且获胜者已经被选择之前，我还改变了<code class="fe nv nw nx nm b">previousTwenty</code>的状态以包括最近的旋转。if语句检查到目前为止已经旋转了多少次，如果少于20次，它就添加这里找到的最新的<code class="fe nv nw nx nm b">winningNumber</code>作为变量<code class="fe nv nw nx nm b">randomWinner</code>。</p><p id="7974" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果数组中已经有20个数字，那么我们删除数组中的最后一个数字，并添加新的数字作为第一个索引。这被用于轮盘历史，并允许玩家看到之前发生了什么，以帮助他们做出决策。</p><h2 id="1638" class="mz lr in bd ls na nb dn lw nc nd dp ma kg ne nf me kk ng nh mi ko ni nj mm nk bi translated">旋转后/支付</h2><p id="68c6" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">一旦设置了<code class="fe nv nw nx nm b">winningNumber</code>和<code class="fe nv nw nx nm b">previousTwenty</code>，就会出现一条消息，通知玩家使用挂钩(<code class="fe nv nw nx nm b">useEffect</code>)在<code class="fe nv nw nx nm b">previousTwenty</code>改变时激活逻辑，我检查以确保当前有中奖号码。在确认之后，我使用了一个很长的switch语句来计算该号码的每个中奖投注点，并将一个名为<code class="fe nv nw nx nm b">allPayouts</code>的变量更改为这些支出的总和。</p><p id="7ceb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在switch语句之后，我将<code class="fe nv nw nx nm b">totalAmountWon</code>的状态设置为这个新的金额，这是点击“收集奖品”按钮时支付的金额，也是祝贺奖品消息中使用的数字。否则，如果玩家输了，消息中使用的数字来自于<code class="fe nv nw nx nm b">pendingTotalBet</code>状态，以显示在那次旋转中输了多少。</p><p id="a1bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据一些条件，最终消息可能有3个不同的按钮可供按下，每个按钮都将游戏继续回到下注阶段。</p><p id="7c3d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果玩家没有赢得任何赌注，并且他们的<code class="fe nv nw nx nm b">chipCount</code>中有0，出现的按钮将显示“+1000重新开始”。该按钮将所有状态重置回初始值，包括<code class="fe nv nw nx nm b">chipCount</code>，使玩家回到1000开始。</p><p id="5bf3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果<code class="fe nv nw nx nm b">chipCount</code> <strong class="jx io">或</strong><code class="fe nv nw nx nm b">totalAmountWon</code>大于0，那么我们会看到上面讨论的“收集奖金”按钮。该按钮将赢得的奖金添加到<code class="fe nv nw nx nm b">chipCount</code>中，并将必要的适当状态重置回默认状态以继续循环。</p><p id="bdd2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，如果<code class="fe nv nw nx nm b">totalWinningsAmount</code>为0，但玩家的<code class="fe nv nw nx nm b">chipCount</code>中仍有超过0的点数，将出现的按钮会显示“清除布局”。这个按钮和“收集奖金”按钮做的完全一样，除了当它加到筹码数量时，它加0，有效地拿走玩家放在布局上的钱。</p><p id="a52a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">按下这三个按钮中的任何一个，我们就回到下注阶段，游戏继续进行！</p><h1 id="6233" class="lq lr in bd ls lt oe lv lw lx of lz ma mb og md me mf oh mh mi mj oi ml mm mn bi translated">结论</h1><p id="d282" class="pw-post-body-paragraph jv jw in jx b jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ms kq kr ks ig bi translated">这总结了创建轮盘游戏逻辑的基础，希望它是有趣的，或者有助于开发你自己的赌场游戏！我在这个非官方系列中的下一个游戏是三张牌扑克！下期再见，和往常一样，黑客快乐！</p></div></div>    
</body>
</html>