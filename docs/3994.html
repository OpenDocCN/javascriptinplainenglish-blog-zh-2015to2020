<html>
<head>
<title>React: LifeCycle Methods Replicated with Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React:用钩子复制生命周期方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-lifecycle-methods-replicated-with-hooks-d96080af1b4e?source=collection_archive---------5-----------------------#2020-11-09">https://javascript.plainenglish.io/react-lifecycle-methods-replicated-with-hooks-d96080af1b4e?source=collection_archive---------5-----------------------#2020-11-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="8248" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于来自面向对象编程(OOP)背景的新开发人员来说，类和生命周期方法可能更容易理解。然而，React的Hook API在前端世界中变得越来越流行和可用。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image Provided by reactjs.org</figcaption></figure><h1 id="3528" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是生命周期方法？</h1><p id="5267" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下面的图表列出了组件每个阶段的所有生命周期方法:挂载、更新和卸载。正如您所看到的，安装和更新共享一些方法，但是其他的对于生命周期中的每一步都是非常不同的。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mb"><img src="../Images/1faa899e045c4be2dcebef9cb2d5b377.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YobHfnVTouORahXLHYKfaQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Image by Author, Aman Bhimani</figcaption></figure><h1 id="64a8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">钩子中的生命周期</h1><p id="2ed5" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">本文的其余部分将解释每个生命周期方法的用途，并展示如何使用Hooks API复制类似的行为。</p><h2 id="4da0" class="mc kz in bd la md me dn le mf mg dp li jv mh mi lm jz mj mk lq kd ml mm lu mn bi translated">构造器</h2><p id="1d5d" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">构造函数是React组件的特殊构造函数。反应过来的事实。components是一个类，我们必须从React为我们所有的组件扩展这个类。React钩子的工作方式有点不同:它们不是类，而是函数。也就是说，我们不需要构造函数！</p><p id="582a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，要点仍然是:构造函数通常用于设置基于类的组件的初始状态。您仍然可以使用useState挂钩来设置初始状态:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="773f" class="mc kz in mp b gy mt mu l mv mw">// useState takes initial state as first argument<br/>const [list, setList] = useState([]);</span></pre><p id="a44c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">或者，您也可以选择向useState传递一个函数，该函数将返回您的初始状态。这对于依赖于一些大型CPU密集型计算的初始值非常有用:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="7d0f" class="mc kz in mp b gy mt mu l mv mw">import {getInitialTodoList} from ‘./../data-api’;</span><span id="3235" class="mc kz in mp b gy mx mu l mv mw">// useState can take functions which return your initial state<br/>const [list, setList] = useState(() =&gt; getInitialTodoList());</span></pre><h2 id="88ef" class="mc kz in bd la md me dn le mf mg dp li jv mh mi lm jz mj mk lq kd ml mm lu mn bi translated">组件安装</h2><p id="a0db" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">这个方法是不言自明的，它在组件第一次安装时运行一次。重要的是要记住，它是在render方法完成并绘制DOM之后运行的。如果您在这个生命周期方法中调用API，请确保您已经设置了加载器，否则数据在第一次绘制时将为空。</p><p id="5180" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以使用useEffect钩子完成同样的工作。它接受两个参数:要运行的函数和要观察的依赖项。对于这个用例，我们不希望这段代码运行两次，所以我们没有任何依赖。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="58ed" class="mc kz in mp b gy mt mu l mv mw">useEffect(() =&gt; {</span><span id="7072" class="mc kz in mp b gy mx mu l mv mw">  <strong class="mp io">// code to run after first render</strong><br/>  const subscription = myTodoObservable.subscribe(() =&gt; { … })</span><span id="62f9" class="mc kz in mp b gy mx mu l mv mw">}, []) <strong class="mp io">// Empty array means only run this code once after render</strong></span></pre><h2 id="68c7" class="mc kz in bd la md me dn le mf mg dp li jv mh mi lm jz mj mk lq kd ml mm lu mn bi translated">组件将卸载</h2><p id="2899" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">下一个你可能想知道的是关于componentWillUnmount。在此方法中，您必须取消订阅任何事件处理程序。Hooks API的优点是你的代码非常紧密，它使用闭包来引用变量。</p><p id="46cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">useEffect可以返回一个“清理”函数，该函数将在效果完成后运行，如下所示:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="bc12" class="mc kz in mp b gy mt mu l mv mw">useEffect(() =&gt; {<br/>  const subscription = myTodoObservable.subscribe(() =&gt; { … })</span><span id="c067" class="mc kz in mp b gy mx mu l mv mw">  <strong class="mp io">// Clean up for “componentWillUnmount”</strong><br/>  return () =&gt; {<br/>    subscription.unsubscribe()<br/>  }<br/>}, [])</span></pre><h2 id="61b3" class="mc kz in bd la md me dn le mf mg dp li jv mh mi lm jz mj mk lq kd ml mm lu mn bi translated">提供；给予</h2><p id="f2f1" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">render方法是最常用的方法，它的工作是:渲染提供的JSX。由于钩子被用在基于函数的组件中，我们可以像render方法一样返回我们自己的JSX。只需删除“渲染”关键字，并返回JSX。</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="12ca" class="mc kz in mp b gy mt mu l mv mw">function TodoList() {<br/>  const [list, setList] = useState([]);<br/>  <br/>  return (<br/>    &lt;ul&gt;<br/>      {list.map(item =&gt;<br/>        &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;}<br/>    &lt;ul/&gt;<br/>  )<br/>}</span></pre><h2 id="37f1" class="mc kz in bd la md me dn le mf mg dp li jv mh mi lm jz mj mk lq kd ml mm lu mn bi translated">componentDidUpdate</h2><p id="1140" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">这个函数有点棘手，因为每次属性或状态更新(来自父组件或全局上下文)时都会调用它。componentDidUpdate接受3个参数:</p><ul class=""><li id="827e" class="my mz in jm b jn jo jr js jv na jz nb kd nc kh nd ne nf ng bi translated">prevProps:上次渲染的道具</li><li id="a2e3" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated">prevState:上一次渲染的状态</li><li id="0d3c" class="my mz in jm b jn nh jr ni jv nj jz nk kd nl kh nd ne nf ng bi translated">snapshot:来自getSnapshotBeforeUpdate的值，我们接下来将讨论这个值。</li></ul><p id="4df9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您之所以要运行这个方法，是因为组件状态或属性中的某些东西已经更新，您需要对它做出反应(双关语)。当你的道具或状态值更新时，你可以通过运行一个“效果”来完成同样的事情。</p><p id="2afa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">比方说，每当您的待办事项列表达到5的倍数时，您都需要调用一个API。通常，componentDidUpdate中可能有一些if-else块。让我们用钩子来做这件事:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="8605" class="mc kz in mp b gy mt mu l mv mw">function TodoList() {<br/>  const [list, setList] = useState([]);</span><span id="61fe" class="mc kz in mp b gy mx mu l mv mw">  <strong class="mp io">// effect to run</strong><br/>  useEffect(() =&gt; {<br/>    if (list.length % 5 === 0) {<br/><strong class="mp io">      // call your API here</strong><br/>    }</span><span id="3409" class="mc kz in mp b gy mx mu l mv mw">  <strong class="mp io">// Our dependency is “list”. Run every time list updates</strong><br/>  }, [list]);<br/>  <br/>  return (<br/>    &lt;ul&gt;{list.map(item =&gt; &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;}&lt;ul/&gt;<br/>  )<br/>}</span></pre><p id="ad11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">像useEffect这样的钩子让我们编写彼此相关的代码块。在这个useEffect块中，您可以编写与列表更新时间相关的代码。代替几个if-else块，你可以有单独的useEffects。</p><p id="7322" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住:您可以拥有无限数量的useEffect块，它们具有相同或不同的依赖关系。它们将从上到下依次运行。尽量不要将所有代码都塞进一个useEffect中。</p><h2 id="8ea5" class="mc kz in bd la md me dn le mf mg dp li jv mh mi lm jz mj mk lq kd ml mm lu mn bi translated">静态getDerivedStateFromProps</h2><p id="65f9" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">此方法的主要目的是在组件呈现之前或呈现期间更新组件的状态。这也是基于一个条件语句。你应该尽量避免使用这种方式来创建用户界面。React JS博客也建议:你可能不需要派生状态。但是如果必须的话，这就像在渲染之前更新状态一样:</p><pre class="kj kk kl km gt mo mp mq mr aw ms bi"><span id="e6a6" class="mc kz in mp b gy mt mu l mv mw">function TodoList({isLoggedIn}) {<br/>  const [list, setList] = useState([]);<br/>  const [prevIsLoggedIn, setPrevIsLoggedIn] = useState(null);<br/>  <br/>  <strong class="mp io">// if statement right before return</strong><br/>  if (isLoggedIn !== prevIsLoggedIn) {<br/>    <strong class="mp io">// call setState on a state variable</strong><br/>    setList([]);<br/>    <strong class="mp io">// set previous value of your prop</strong><br/>    setPrevIsLoggedIn(isLoggedIn);<br/>  }<br/>  <br/>  return (&lt;&gt;...&lt;/&gt;);<br/>}</span></pre><h2 id="f7ec" class="mc kz in bd la md me dn le mf mg dp li jv mh mi lm jz mj mk lq kd ml mm lu mn bi translated">误差边界</h2><p id="c8fa" class="pw-post-body-paragraph jk jl in jm b jn lw jp jq jr lx jt ju jv ly jx jy jz lz kb kc kd ma kf kg kh ig bi translated">目前，没有错误边界的替代品，React 16.8+或17只支持错误边界作为类组件。如果您想知道如何使用误差边界，可以观看下面的视频:</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="nm nn l"/></div></figure></div></div>    
</body>
</html>