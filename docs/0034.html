<html>
<head>
<title>Understanding JavaScript — Heap, Stack, Event-loops and Callback Queue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript——堆、堆栈、事件循环和回调队列</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-javascript-heap-stack-event-loops-and-callback-queue-6fdec3cfe32e?source=collection_archive---------2-----------------------#2018-09-07">https://javascript.plainenglish.io/understanding-javascript-heap-stack-event-loops-and-callback-queue-6fdec3cfe32e?source=collection_archive---------2-----------------------#2018-09-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/a8e5af3c6bce78545ce51f2f6f46680c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mUUFKW7qpR9mvb4U"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">“white smartphone on two softbound books” by <a class="ae jz" href="https://unsplash.com/@kobuagency?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kobu Agency</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="039d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript是一种单线程语言，这使得它不同于大多数语言。它缺乏多线程应用程序的能力，而不必处理复杂的问题，如死锁或共享变量问题。</p><h2 id="d35e" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">单线程？</h2><p id="e9b9" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">单线程语言缺少同时运行的并发进程。这意味着，如果你有一个花费很长时间的进程，那么它将<strong class="kc io">阻止其他进程</strong>运行。因此，浏览器中定义了一个等待进程响应的超时。当进程在超时内没有响应时，您将看到一个弹出窗口，询问您是否终止进程。</p><blockquote class="lw lx ly"><p id="c17a" class="ka kb lz kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">不要在浏览器上运行任何需要很长时间的业务，以免阻塞其他功能。</p></blockquote><p id="026e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，JavaScript如何模拟在多线程环境中运行我们的命令呢？为了回答这个问题，让我们深入了解JavaScript环境。</p><h2 id="f804" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">JavaScript环境</h2><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi md"><img src="../Images/ef48264125d63b63891c5e9c5a553176.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hTvFVz2Aw2w8wbMC_QPFXQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">JavaScript environment</figcaption></figure><p id="311b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然JavaScript是一种单线程语言，但我们有一个强大的助手，那就是能够管理复杂操作的浏览器。Web API、回调队列和事件循环机制是浏览器的一部分。</p><p id="a49d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面我们来深入挖掘一下每个部分的一些细节。</p><h2 id="0467" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">许多</h2><p id="bbd6" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">堆是我们定义变量时存储对象的地方(内存)。</p><h2 id="4281" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">堆</h2><p id="4206" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">堆栈保存我们的函数调用。在每个新的函数调用中，它被推到堆栈的顶部。通过堆栈跟踪，您可以在JavaScript上出现异常时看到您的堆栈。</p><h2 id="3830" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">Web API</h2><p id="d0e3" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">浏览器已经定义了API，开发者可以使用这些API进行复杂的处理，例如获取访问者的位置，地理位置被定义。在参考文献<em class="lz"> (1) </em>的链接中定义了API列表。</p><h2 id="b3d2" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">回调队列</h2><p id="8b1a" class="pw-post-body-paragraph ka kb in kc b kd lr kf kg kh ls kj kk kl lt kn ko kp lu kr ks kt lv kv kw kx ig bi translated">当一个进程完成它的任务时，比如一个xhr调用，它会被放入回调队列中。回调队列是在我们的堆栈为空之后由事件循环进程触发的，这意味着进程在该队列中等待，直到我们的堆栈为空。一旦我们的堆栈没有函数调用，那么一个进程就会从回调队列中弹出并被推入堆栈。</p><p id="93dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">事件循环</strong></p><p id="5c80" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个负责检查堆栈，然后不断触发回调队列的进程。</p><h2 id="5105" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">例子</h2><figure class="me mf mg mh gt jo gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/0dd9fdff6905dfcb482110e402c5c314.png" data-original-src="https://miro.medium.com/v2/resize:fit:1208/format:webp/1*04E2hwNjD7cJgSTrdw51bQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">setTimeout example</figcaption></figure><p id="f2b5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述示例的预期输出是什么？它从一个console.log开始，然后继续一个setTimeout函数，我们希望这个函数立即运行(？)通过给出一个“0”超时然后另一个console.log</p><blockquote class="lw lx ly"><p id="b90f" class="ka kb lz kc b kd ke kf kg kh ki kj kk ma km kn ko mb kq kr ks mc ku kv kw kx ig bi translated">setTimeout是一个特殊的东西。ECMAScript规范中没有定义。它是一个Web API (2)。它异步工作。给定的超时并不保证函数在给定时间后仍能工作，但保证它至少会等待给定时间。因此setTimeout(fn，0)不会立即开始，但会等待至少0毫秒。</p></blockquote><figure class="me mf mg mh gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mj"><img src="../Images/296cb865f19cfdecdbd361691959cb39.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*sDleG8vaNiYEk_FiCgzlQA.gif"/></div></div></figure><p id="40e1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们解释一下当我们运行上面的代码片段时，它将如何表现。</p><ol class=""><li id="bce1" class="mk ml in kc b kd ke kh ki kl mm kp mn kt mo kx mp mq mr ms bi translated">我们的第一个console . log(“Murat”)将被压入堆栈，因为我们正在进行函数调用。</li><li id="809b" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">变量将保存在堆(内存)中</li><li id="1af0" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">因为它不是异步调用，所以它将输出给定的参数</li><li id="6beb" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">第一个console.log函数将从堆栈中移除，堆将为空</li><li id="7fde" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">将调用setTimeout函数。所以它会被压入堆栈</li><li id="11be" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">这是一个异步函数，也是一个Web API函数。它将被推送到Web API框，setTimeout函数将从堆栈中移除</li><li id="52ab" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">将在后台启动一个计时器，至少等待给定的时间量，以设置超时。</li><li id="d3f0" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">console.log("Yusuf ")将被调用，它将被推到堆栈中，Yusuf将被存储在堆中。</li><li id="a3c3" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">它将输出优素福。但同时，我们的事件循环将继续检查堆栈的状态。</li><li id="4dfc" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">输出Yusuf后，它将从堆栈和堆中移除。</li><li id="f46e" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">当计时器确定至少等待了给定的时间，它将被推送到回调队列(console.log("Fatih "))</li><li id="abd5" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">当堆栈变空时，我们的事件循环将触发回调队列。</li><li id="bd36" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">接下来，console.log("Fatih ")将被放入堆栈</li></ol><p id="78d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们的输出将在“缪拉”，“优素福”，“法提赫”的顺序</p><h2 id="329b" class="ky kz in bd la lb lc dn ld le lf dp lg kl lh li lj kp lk ll lm kt ln lo lp lq bi translated">参考</h2><ol class=""><li id="c766" class="mk ml in kc b kd lr kh ls kl my kp mz kt na kx mp mq mr ms bi translated">Web API列表，<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/API" rel="noopener ugc nofollow" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API</a></li><li id="7739" class="mk ml in kc b kd mt kh mu kl mv kp mw kt mx kx mp mq mr ms bi translated">setTimeout规范，<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/settime out</a></li></ol></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="9ca5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lz">如果你喜欢我的文章，你可以鼓掌支持我，关注我。<br/>我也在</em><a class="ae jz" href="http://www.linkedin.com/in/muratcatal" rel="noopener ugc nofollow" target="_blank"><em class="lz">LinkedIn</em></a><em class="lz">上，欢迎所有邀请。</em></p></div></div>    
</body>
</html>