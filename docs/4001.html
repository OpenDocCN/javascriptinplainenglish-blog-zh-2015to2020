<html>
<head>
<title>Measuring JavaScript Performance the Easy Way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">测量JavaScript性能的简单方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/measuring-javascript-performance-the-easy-way-3b13630c025d?source=collection_archive---------12-----------------------#2020-11-09">https://javascript.plainenglish.io/measuring-javascript-performance-the-easy-way-3b13630c025d?source=collection_archive---------12-----------------------#2020-11-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3ee4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">有几个第三方工具可以测量web应用程序的性能。但是，我们是否使用了我们所掌握的基本工具？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b71340e8e9959e8a3e5918a012852a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZIPnhT5pACOzrwr0"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@gearfilms?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">José Pinto</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="751a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">网页——互联网世界中最简单却最强大的东西之一。我们都会看到一个设计精美的作品慢如蜗牛，我们也会看到至少一个设计糟糕的页面，它运行得如此之快和高效，以至于我们忽略了它的设计。为什么？都是因为幕后的代码。长时间的头脑风暴、研究、设计和对功能的用户体验考虑，如果代码执行得不好，所有这些都没有意义。你有没有想过JavaScript代码是如何执行的？深入到代码执行有哪些选项？</p><p id="d289" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">像你们大多数人一样，我用的是铬合金，我用的是T2角合金。让我们深入研究一下我们应该首先使用的——浏览器中的开发工具。</p><p id="a39f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> Lighthouse &amp;开发者工具中的性能标签</strong></p><p id="9d6f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们每个人都会在他们的开发工具中看到Lighthouse选项卡。Lighthouse是一个广泛使用的工具，它基于性能、可访问性、SEO和最佳实践来衡量一个网页。Lighthouse的建议是，最好以匿名模式运行报告，以避免浏览器扩展干扰您的报告。</p><p id="f613" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们以angular CLI为我们的小实验提供的样板应用程序为例。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lp"><img src="../Images/0b9c36bc397d2249e11ef4168e4edf82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WTJZ_2_DiRRfPUz3AKM8_w.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Lighthouse Report for the boilerplate Angular App</figcaption></figure><p id="b44d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">只需单击“查看原始跟踪”按钮，我们就可以导航到“性能”选项卡。performance选项卡显示了对给定事件下浏览器中发生的情况的逐步分析。在从灯塔导航的情况下，它很可能会反映页面负载。我们可以在这里看到页面加载期间发生的所有事件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lq"><img src="../Images/5771d1e90a7a6185121684a84e2d52ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I8WjCmUHlXLTXhJjK3RBiw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Summary Tab with Aggregate time</figcaption></figure><p id="a09c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，你可能想知道我的代码在哪里。我们很亲密…</p><p id="1313" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">“主”线程包含了我们代码的细节。当我们单击任何任务时，Summary选项卡显示所选任务花费的总时间。</p><p id="ded0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要记录用户可能完成的一系列操作的性能，请转到performance选项卡，点击record按钮，在浏览器上执行该操作，然后停止记录以分析结果。</p><p id="b71b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们从现在开始举一个真实世界的例子——比较容易理解。🙂</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lr"><img src="../Images/4398f9e71f765ad24bc81c950050b6b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZA5QCjr-jysSXGp90yAr4A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Bottom-Up tab showing the breakdown of Scripting Activity</figcaption></figure><p id="a0db" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上面的图像显示了我的一个页面的样本。我们可以在脚本活动下看到对我们代码的引用。单击该文件会将您带到source选项卡，突出显示HTML中每一行的细目以及相应的时间消耗。您还可以研究TypeScript/Javascript代码，看看当用户在UI上执行一组任务时，每个函数执行了多长时间。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/dbda59bb4ed9b73d9855de4ef8951972.png" data-original-src="https://miro.medium.com/v2/resize:fit:560/format:webp/1*c5j3Wnigeme5crevR-ColA.png"/></div></figure><h1 id="e23b" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated"><strong class="ak">我在页面中改进的内容</strong></h1><p id="fd83" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">无论应用程序有多大，简单的更改对提高web应用程序的性能大有帮助。我遇到过需要删除或简化的代码片段，以提高我的页面的性能。下面是开发/维护应用程序时需要注意的一些事情。</p><p id="e79e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当然，这些来自我的申请页面。所以，你可能会发现类似的/更新的东西来深入挖掘…</p><h2 id="74cf" class="mq lu in bd lv mr ms dn lz mt mu dp md lc mv mw mf lg mx my mh lk mz na mj nb bi translated"><em class="nc">动画&amp;布局变化</em></h2><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/2859c5a5fd67ee0e002d7837f65646e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*QktfaWuoy0rRh3DPqm4ujw.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Rendering and Painting triggered by Animation and Layout Shift</figcaption></figure><p id="6b24" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">尽可能减少动画和布局的变化。我见过需要大量CPU的动画，很少有完全不“用户友好”的。</p><h2 id="1d92" class="mq lu in bd lv mr ms dn lz mt mu dp md lc mv mw mf lg mx my mh lk mz na mj nb bi translated"><em class="nc"> @ViewChild decorator </em></h2><p id="3158" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">@ViewChild是常用的装饰器之一。最好是查看组件，确保确实需要引用。</p><p id="243a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们希望注入/引用指令，组件内部的组件，那么我们可以使用装饰器。对于更简单的操作，可能根本不需要@ViewChild。</p><h2 id="38c5" class="mq lu in bd lv mr ms dn lz mt mu dp md lc mv mw mf lg mx my mh lk mz na mj nb bi translated"><em class="nc">带*ngFor </em>的trackBy选项</h2><p id="fec7" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">在处理屏幕上绘制的大量项目列表时，将trackBy选项与*ngFor一起使用是一个好方法。当您使用正确的引用指定trackBy选项时，只有更改会重新呈现到屏幕上—类似这样。</p><pre class="kd ke kf kg gt ne nf ng nh aw ni bi"><span id="1380" class="mq lu in nf b gy nj nk l nl nm">trackByFn(index: number, item: any) {<br/>    return item.id;<br/>}</span></pre><h2 id="5a53" class="mq lu in bd lv mr ms dn lz mt mu dp md lc mv mw mf lg mx my mh lk mz na mj nb bi translated"><em class="nc"> ngClass &amp; &amp; ngIf </em></h2><p id="683d" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">将更简单的检查传递给*ngIf和[ngClass],而不是使用函数引用或复杂的检查。</p><p id="846a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">检查*ngIf是否可以被[hidden]属性替换，以避免<em class="nn">在屏幕上绘制*ngIf引用的元素的</em>。当试图隐藏/显示DOM中的复杂元素时，这可能会很方便。</p><h2 id="55c7" class="mq lu in bd lv mr ms dn lz mt mu dp md lc mv mw mf lg mx my mh lk mz na mj nb bi translated"><em class="nc">自定义指令</em></h2><p id="fa8a" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">当指令的输入通过来自组件的变量获得更新时，我们的定制指令通常与<em class="nn"> ngOnChanges </em>一起发挥作用。在大型列表上设置自定义指令需要更改检测周期来验证传递给指令的输入。如果可能的话，找一个替代的方法。</p><h1 id="062b" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated"><strong class="ak">结论</strong></h1><p id="ff09" class="pw-post-body-paragraph kt ku in kv b kw ml jo ky kz mm jr lb lc mn le lf lg mo li lj lk mp lm ln lo ig bi translated">实现Angular中定义的标准指导方针和方法将始终为您的应用程序提供性能方面的提升。即使遵循了所有的指导原则，仍然会有改进的空间，尤其是在维护模式下几个月后。随着变化的到来，回头看看我们的代码库中已经存在的东西总是好的，以确保更好的性能。</p><p id="dbdc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢阅读…编码快乐！</p></div></div>    
</body>
</html>