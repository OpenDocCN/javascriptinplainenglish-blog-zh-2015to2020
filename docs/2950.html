<html>
<head>
<title>React Best Practices — Components and Testing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应最佳实践—组件和测试</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-best-practices-components-and-testing-106714b615cf?source=collection_archive---------6-----------------------#2020-08-09">https://javascript.plainenglish.io/react-best-practices-components-and-testing-106714b615cf?source=collection_archive---------6-----------------------#2020-08-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d44b8eb226cad4f95c56bdc492603af5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*86vmwDOEnDe16Uq1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@monty_a?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Monty Allen</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3c54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写React应用程序时应该遵循的一些最佳实践。</p><h1 id="36bc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">组件名称使用大写字母</h1><p id="eb5c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该以大写字母开始组件。</p><p id="4b2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们可以将它们与其他JavaScript实体区分开来。</p><p id="ac3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该写像<code class="fe me mf mg mh b">SelectButton</code>这样的名字来命名选择按钮。</p><h1 id="6616" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">其他命名约定</h1><p id="e8f5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在JavaScript中，大多数东西都是camelCase。</p><p id="551c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类是PascalCase。</p><p id="48b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性也是驼色。</p><p id="2ab0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以尽可能地坚持下去。</p><h1 id="8b9d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将有状态方面与呈现分开</h1><p id="0e0e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以分离有状态和无状态的组件。</p><p id="fbe2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无状态组件只渲染道具中的东西，其他什么都不做。</p><p id="0a7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有状态组件有自己的动态状态，它们可以根据任何情况而改变。</p><p id="eaf5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以在各种钩子中操纵状态。</p><p id="9538" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以把逻辑放在我们自己的钩子中，这样我们就不必把它们放在我们的组件中。</p><p id="9063" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以将用于呈现表格的放入它自己的组件中。</p><p id="49ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在获取数据的组件中使用它，并将它传递给表组件。</p><p id="7094" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="58db" class="mq lc iq mh b gy mr ms l mt mu">import FancyTable from './FancyTable';</span><span id="99be" class="mq lc iq mh b gy mv ms l mt mu">class Table extends Component {<br/>  state = { loading: true };</span><span id="d0b3" class="mq lc iq mh b gy mv ms l mt mu">  componentDidMount() {<br/>    fetchData().then( tableData =&gt; {<br/>      this.setState( { loading: false, tableData } );<br/>    } );<br/>  }</span><span id="e6e6" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    const { loading, tableData } = this.state;<br/>    return loading ? &lt;Loading/&gt; : &lt;FancyTable data={tableData}/&gt;;<br/>  }<br/>}</span></pre><p id="604b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有将我们的<code class="fe me mf mg mh b">tableData</code>传递给它的<code class="fe me mf mg mh b">FancyTable</code>组件来呈现。</p><p id="6863" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种方式，我们将状态操作从渲染中分离出来。</p><h1 id="88c6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">与任何单个组件相关的所有文件都应该在一个文件夹中</h1><p id="3dce" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该将所有助手组件和其他文件放在与组件相同的文件夹中。</p><p id="911e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过这种方式，我们可以将大的组件分成更小的组件，从而更容易找到助手代码。</p><p id="905c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个组件通常有自己的CSS、图标、图像、测试和其他文件。</p><p id="6775" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该把它们放在一起，这样我们就可以在一个地方找到它们。</p><h1 id="170d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用像Bit这样的组件库</h1><p id="c1d0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">像Bit这样的组件库帮助我们将React组件组织到一个地方。</p><p id="16f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们帮助我们重用代码，因为我们可以从那里安装组件包。</p><p id="c5bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以创建一个包含所有组件包的NPM存储库。</p><p id="4911" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们不能像使用Bit那样即时预览它们。</p><p id="6369" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，代码可以在不同的项目中重用，节省我们的时间，减少挫折。</p><h1 id="db73" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用库</h1><p id="754a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">代码片段向我们展示了最好的和最新的语法。</p><p id="15a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们还帮助我们学习我们不应该错过的最佳实践。</p><p id="0e93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在互联网上找到它们的来源。</p><h1 id="ea48" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为所有代码编写测试</h1><p id="8cd9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该为所有代码编写测试，这样我们就不必自己手动测试每个部分。</p><p id="48ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们让我们知道，即使我们改变了现有的代码，我们的代码仍然在工作。</p><p id="41c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试还帮助我们轻松测试新代码。</p><p id="6f17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将它们放在一个<code class="fe me mf mg mh b">__Test__</code>文件夹中，这样我们就可以存放相关的测试。</p><p id="4a58" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">测试可以分为功能测试和在浏览器中呈现应用程序的测试。</p><p id="6c94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用跨浏览器测试工具来测试渲染。</p><p id="07ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Jest可以模拟DOM来测试React组件。</p><p id="259f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以操作DOM来执行点击等操作，并检查结果的呈现。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/75d991473aaaaa6da9a5510783d00e7f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x1GTd5CxQgKxcOeV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@antonchernyavskiy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anton Chernyavskiy</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="d535" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="91d5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">分离有状态和无状态组件使得维护和测试变得容易。</p><p id="2d42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，测试也很重要。</p><p id="6a45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以把我们的组件放在一个存储库中，这样我们就可以很容易地重用它们。</p><h2 id="91b0" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="203b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>