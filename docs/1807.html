<html>
<head>
<title>JavaScript Interview Questions — DOM and Event Questions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript面试问题— DOM和事件问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-interview-questions-dom-and-event-questions-fab714a3bad2?source=collection_archive---------8-----------------------#2020-04-24">https://javascript.plainenglish.io/javascript-interview-questions-dom-and-event-questions-fab714a3bad2?source=collection_archive---------8-----------------------#2020-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d16d7e9e58efe427c7d25d051456652c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*r7vWdlmyW4AjPmbF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@helloimnik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Hello I'm Nik 🇬🇧</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e1a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了得到一份前端开发人员的工作，我们需要搞定编码面试。</p><p id="4750" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些关于DOM操作和处理事件的更难的问题。</p><h1 id="c412" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是重画，什么时候会重画？</h1><p id="f752" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们改变一个元素的外观而不改变它的大小和形状时，就会发生重画。</p><p id="951f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不会导致回流，因为它的尺寸和位置没有改变。</p><p id="06a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当元素更改背景色、更改文本颜色或隐藏可见性时，会发生重新绘制过程。</p><h1 id="232b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">当DOM像<code class="fe me mf mg mh b">$(document).ready</code>一样准备好了，我们如何运行一些JavaScript呢？</h1><p id="02dd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将脚本放在HTML body元素中。当浏览器在那里运行脚本标记时，DOM已经准备好了。</p><p id="7113" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以将代码放在<code class="fe me mf mg mh b">DOMContentLoaded</code>事件处理程序中。只有当DOM完全加载后，里面的代码才会运行。</p><p id="60bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6ae2" class="mq lc iq mh b gy mr ms l mt mu">document.addEventListener('DOMContentLoaded', () =&gt; {<br/>  console.log('DOM loaded');<br/>});</span></pre><p id="7e46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以通过附加一个监听器来观察<code class="fe me mf mg mh b">readystatechange</code>事件。</p><p id="a0df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当<code class="fe me mf mg mh b">readyState</code>是<code class="fe me mf mg mh b">'complete'</code>时，我们就知道DOM已经加载了。</p><p id="888a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码来实现这一点:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="03af" class="mq lc iq mh b gy mr ms l mt mu">document.onreadystatechange = () =&gt; {<br/>  if (document.readyState == "complete") {<br/>    console.log('DOM loaded');<br/>  }<br/>}</span></pre><h1 id="874b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">什么是事件冒泡？事件如何流动？</h1><p id="c57b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">事件冒泡意味着事件从原始元素传播到其父元素、祖父元素，并一直传播到<code class="fe me mf mg mh b">window</code>对象。</p><p id="742d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了原始元素之外，浏览器还将运行附加到原始元素的所有父元素的所有事件处理程序。</p><p id="fd26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下HTML:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e0b8" class="mq lc iq mh b gy mr ms l mt mu">&lt;div&gt;<br/>  &lt;p&gt;<br/>    &lt;button&gt;Click&lt;/button&gt;<br/>  &lt;/p&gt;<br/>&lt;/div&gt;</span></pre><p id="3a0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们将事件监听器附加到所有元素和<code class="fe me mf mg mh b">document</code>和<code class="fe me mf mg mh b">window</code>时，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fb81" class="mq lc iq mh b gy mr ms l mt mu">const div = document.querySelector('div');<br/>const p = document.querySelector('p');<br/>const button = document.querySelector('button');</span><span id="9a0d" class="mq lc iq mh b gy mv ms l mt mu">button.onclick = () =&gt; {<br/>  alert('button clicked');<br/>}</span><span id="0d97" class="mq lc iq mh b gy mv ms l mt mu">p.onclick = () =&gt; {<br/>  alert('p clicked');<br/>}</span><span id="29f1" class="mq lc iq mh b gy mv ms l mt mu">div.onclick = () =&gt; {<br/>  alert('div clicked');<br/>}</span><span id="b90d" class="mq lc iq mh b gy mv ms l mt mu">document.onclick = () =&gt; {<br/>  alert('document clicked');<br/>}</span><span id="a1c2" class="mq lc iq mh b gy mv ms l mt mu">window.onclick = () =&gt; {<br/>  alert('window clicked');<br/>}</span></pre><p id="1758" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后单击“click”按钮，我们将看到所有的警报都按照代码中列出的顺序排列。</p><p id="e674" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们得到按顺序显示的“按钮被点击”、“p被点击”、“div被点击”、“文档被点击”和“窗口被点击”警报。</p><h1 id="ad27" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">我们如何用一个点击处理程序销毁多个列表项？</h1><p id="6334" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用事件委托来做到这一点。</p><p id="3d70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它通过监听列表的父元素的点击来工作。然后我们可以检查在click处理程序中点击了哪个子元素，然后从DOM中移除该元素。</p><p id="8651" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下HTML:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="27ef" class="mq lc iq mh b gy mr ms l mt mu">&lt;ul&gt;<br/>    &lt;li&gt;first&lt;/li&gt;<br/>    &lt;li&gt;second&lt;/li&gt;<br/>    &lt;li&gt;third&lt;/li&gt;<br/>    &lt;li&gt;forth&lt;/li&gt;<br/>    &lt;li&gt;Fifth&lt;/li&gt;<br/>&lt;/ul&gt;</span></pre><p id="ed7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以编写以下JavaScript代码来删除我们单击的li元素，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b4a6" class="mq lc iq mh b gy mr ms l mt mu">document.querySelector('ul').addEventListener('click', (e) =&gt; {<br/>  const elm = e.target.parentNode;<br/>  elm.removeChild(e.target);<br/>  e.preventDefault();<br/>});</span></pre><p id="65d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们获得了我们单击以获得ul的元素的<code class="fe me mf mg mh b">parentNode</code>属性。</p><p id="48eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以调用它的<code class="fe me mf mg mh b">removeChild</code>来删除我们点击的li，因为<code class="fe me mf mg mh b">e.target</code>是我们点击的元素，也就是li。</p><p id="8e9d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们调用<code class="fe me mf mg mh b">preventDefault</code>停止事件传播。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/38d2e33f153ec7fe7a64a59a735b2243.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-Cn95RqoDA8Wf-UL"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sanderdalhuisen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Sander Dalhuisen</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ceaf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建一个按钮，点击它就会被破坏，但是两个新的按钮会被替换。</h1><p id="642b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用上面的逻辑来移除我们点击的按钮。</p><p id="f6ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们添加使用<code class="fe me mf mg mh b">createElement</code>和<code class="fe me mf mg mh b">appendChild</code>来创建更多的按钮，并将它们添加到列表中。</p><p id="f97e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，给定以下HTML:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="66b1" class="mq lc iq mh b gy mr ms l mt mu">&lt;div&gt;<br/>  &lt;button&gt;button&lt;/button&gt;<br/>&lt;/div&gt;</span></pre><p id="7753" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们编写了下面的JavaScript代码来添加两个按钮，然后通过在div上附加一个click侦听器并操纵按钮来删除被点击的原始按钮:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5450" class="mq lc iq mh b gy mr ms l mt mu">document.querySelector('div').addEventListener('click', (e) =&gt; {<br/>  if (e.target.tagName === 'DIV') {<br/>    return;<br/>  }<br/>  const elm = e.target.parentNode;<br/>  e.preventDefault();</span><span id="af4c" class="mq lc iq mh b gy mv ms l mt mu">  const btn = document.createElement('button');<br/>  btn.innerHTML = 'button';</span><span id="4701" class="mq lc iq mh b gy mv ms l mt mu">  const btn2 = document.createElement('button');<br/>  btn2.innerHTML = 'button';</span><span id="9cbb" class="mq lc iq mh b gy mv ms l mt mu">  elm.appendChild(btn);<br/>  elm.appendChild(btn2);<br/>  elm.removeChild(e.target);<br/>});</span></pre><p id="f185" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们检查我们是否真的点击了一个按钮。</p><p id="043e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们这样做了，那么我们继续创建两个按钮。然后我们调用被点击按钮的<code class="fe me mf mg mh b">parentNode</code>上的<code class="fe me mf mg mh b">appendChild</code>来连接两个按钮，这个按钮就是div。</p><p id="44d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">e.target</code>上的<code class="fe me mf mg mh b">removeChild</code>来移除按钮，因为我们检查过它不是div，所以它应该是按钮。</p><h1 id="d8b8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="fb47" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以观察DOM是否已经为<code class="fe me mf mg mh b">readystatechange</code>或<code class="fe me mf mg mh b">DOMContentLoaded</code>事件做好准备。</p><p id="6f67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当元素的事件在DOM树中传播时，就会发生事件冒泡。</p><p id="f1ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">appendChild</code>、<code class="fe me mf mg mh b">removeChild</code>用于元素的添加和移除。我们可以通过事件委托来处理多个子元素的事件。</p><p id="90a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们改变元素的外观而不改变其几何形状时，就会发生重画。</p><h2 id="adfc" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">来自JavaScript的普通英语注释</strong></h2><p id="20b0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们推出了三种新的出版物！通过以下方式表达对我们新出版物的热爱:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"> <strong class="kf ir">通俗易懂的AI</strong></a>、<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"> <strong class="kf ir">通俗易懂的UX</strong>、</a>、<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener">、<strong class="kf ir">通俗易懂的Python</strong>、</a>、<strong class="kf ir">、</strong>——谢谢您，继续学习！</p><p id="6ad6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直对帮助推广高质量内容感兴趣。如果您有一篇文章想提交给我们的任何出版物，请通过电子邮件发送至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>并使用您的Medium用户名，我们会将您添加为作者。另外，请告诉我们您想添加到哪个出版物中。</p></div></div>    
</body>
</html>