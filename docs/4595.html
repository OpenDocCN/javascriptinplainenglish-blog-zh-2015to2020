<html>
<head>
<title>Build a Sticky Table Header with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React钩子构建一个粘性表头</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-sticky-table-header-with-react-hooks-b5a344203045?source=collection_archive---------13-----------------------#2020-12-22">https://javascript.plainenglish.io/build-a-sticky-table-header-with-react-hooks-b5a344203045?source=collection_archive---------13-----------------------#2020-12-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2d12" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">正视表格的局限性，用React钩子把它的标题变成一个粘性元素。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi kc"><img src="../Images/3032ae3285107d521ce188c2e28689b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/0*xM6dwlDyBgQO87gd.png"/></div></figure><p id="0e55" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">使用一个<code class="fe lg lh li lj b">&lt;table /&gt;</code>元素代替flexbox来表示数据是一件好事。想知道如何在React的帮助下制作一个粘性表头吗？想知道如何将解决方案应用到生产代码中吗？这篇博文是写给你的！</p><p id="908a" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">接下来的不是一个关于你应该如何解决这个问题的简单教程。它也不是一个理论或虚构的实现。相反，我们关注的是在真实项目中测试过的、可以轻松重用的可能解决方案。它还整理了使用<code class="fe lg lh li lj b">&lt;table /&gt;</code>时的一些边缘情况。</p><p id="61d3" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="lk">直奔</em> <a class="ae ll" href="#88a7" rel="noopener ugc nofollow"> <em class="lk">代号</em> </a> <em class="lk">，如果那多半就是你要找的。</em></p><h1 id="7116" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">目录:</h1><p id="c72a" class="pw-post-body-paragraph kk kl in km b kn me jo kp kq mf jr ks kt mg kv kw kx mh kz la lb mi ld le lf ig bi translated">1.<a class="ae ll" href="#53d8" rel="noopener ugc nofollow">表格与Flexbox </a></p><ul class=""><li id="a130" class="mj mk in km b kn ko kq kr kt ml kx mm lb mn lf mo mp mq mr bi translated"><a class="ae ll" href="#e764" rel="noopener ugc nofollow">通过标题单元格控制列</a></li><li id="a566" class="mj mk in km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated"><a class="ae ll" href="#3ca6" rel="noopener ugc nofollow">标题和内容组件拆分</a></li><li id="dcb8" class="mj mk in km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated"><a class="ae ll" href="#39fc" rel="noopener ugc nofollow">表格开箱即用</a></li></ul><p id="3ed2" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">2.<a class="ae ll" href="#88a7" rel="noopener ugc nofollow">粘性表头(代码解)</a></p><ul class=""><li id="8fc2" class="mj mk in km b kn ko kq kr kt ml kx mm lb mn lf mo mp mq mr bi translated"><a class="ae ll" href="#f436" rel="noopener ugc nofollow"> &lt;表/ &gt;组件接口</a></li><li id="575f" class="mj mk in km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated"><a class="ae ll" href="#234a" rel="noopener ugc nofollow"> &lt;表/ &gt;组件实现</a></li><li id="7968" class="mj mk in km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated"><a class="ae ll" href="#ff81" rel="noopener ugc nofollow"> useStickyHeader()实现</a></li></ul><p id="5443" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">3.<a class="ae ll" href="#aba8" rel="noopener ugc nofollow">最后的话</a></p><p id="b31d" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">4.<a class="ae ll" href="#1f7d" rel="noopener ugc nofollow">资源</a></p></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><h1 id="53d8" class="lm ln in bd lo lp ne lr ls lt nf lv lw jt ng ju ly jw nh jx ma jz ni ka mc md bi translated">表格与Flexbox</h1><p id="eb63" class="pw-post-body-paragraph kk kl in km b kn me jo kp kq mf jr ks kt mg kv kw kx mh kz la lb mi ld le lf ig bi translated">每当您必须处理数据表示时，通常第一个意图是用flexbox创建一个基于<code class="fe lg lh li lj b">&lt;div /&gt;</code>的布局。人们不知何故对桌子有偏见。在过去，表格被用来构建网页的名声并不好。但是如果做得好，它们可以帮你解决很多问题。表格也可以很好地使用React。</p><p id="8a1e" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km io">另一方面，循环遍历数据并将其放在基于flexbox的网格中并不方便。</strong>在<a class="ae ll" href="https://css-tricks.com/accessible-simple-responsive-tables/#1b-for-column-oriented-tables" rel="noopener ugc nofollow" target="_blank">可访问的、简单的、反应灵敏的表格</a>中对该问题进行了很好的说明。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/a60d45adcfa0e19840c92d916d4f7ee5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*bsEzT1dkyUo29DVN.png"/></div><figcaption class="nk nl gj gh gi nm nn bd b be z dk">Table layout with flexbox. The screenshot is taken from <a class="ae ll" href="https://codepen.io/moubi/pen/WNxVdxY" rel="noopener ugc nofollow" target="_blank">here</a>.</figcaption></figure><p id="98a6" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">上面的表格布局是用flex设计的，看起来非常类似于:</p><pre class="kd ke kf kg gt no lj np nq aw nr bi"><span id="ddde" class="ns ln in lj b gy nt nu l nv nw">&lt;div class="table"&gt;<br/>  &lt;h3 class="header"&gt;Eddard Stark&lt;/h3&gt;<br/>  &lt;div class="row"&gt;Has a sword named Ice&lt;/div&gt;<br/>  &lt;div class="row"&gt;No direwolf&lt;/div&gt;<br/>  &lt;div class="row"&gt;Lord of Winterfell&lt;/div&gt;<br/><br/>  &lt;h3 class="header"&gt;Jon Snow&lt;/h3&gt;<br/>  &lt;div class="row"&gt;Has a sword named Longclaw&lt;/div&gt;<br/>  &lt;div class="row"&gt;Direwolf: Ghost&lt;/div&gt;<br/>  &lt;div class="row"&gt;Knows nothing&lt;/div&gt;<br/>  ...<br/>&lt;/div&gt;</span></pre><p id="89f9" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">很快就出现了一个问题:用给定的标记遍历标题和行数据有多容易？</p><p id="fd31" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km io">相反，一些表的好处包括:</strong></p><ol class=""><li id="e6e2" class="mj mk in km b kn ko kq kr kt ml kx mm lb mn lf nx mp mq mr bi translated">通过标题单元格控制列宽</li><li id="d009" class="mj mk in km b kn ms kq mt kt mu kx mv lb mw lf nx mp mq mr bi translated">标题和内容(表格行)之间无痛苦的组件式拆分</li><li id="03f3" class="mj mk in km b kn ms kq mt kt mu kx mv lb mw lf nx mp mq mr bi translated">开箱即用(无css)</li></ol><p id="5e4d" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">所有这些都与将表格标题(<code class="fe lg lh li lj b">&lt;thead /&gt;</code>)变成粘性项目背后的挑战密切相关。理解它们，应该有助于你以后更好地遵循代码解决方案。</p></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><p id="17db" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">您可以使用常用的<code class="fe lg lh li lj b">&lt;table /&gt;</code>标签构建表格布局，或者通过带有<code class="fe lg lh li lj b">display: table</code>和语义元素(<code class="fe lg lh li lj b">&lt;div /&gt;</code>)的css来实现同样的功能。</p><pre class="kd ke kf kg gt no lj np nq aw nr bi"><span id="1907" class="ns ln in lj b gy nt nu l nv nw">// This<br/>&lt;table&gt;<br/>  &lt;thead /&gt;<br/>  ...<br/>&lt;/table&gt;<br/><br/>// is the same as<br/>&lt;div style={{ display: "table" }}&gt;<br/>  &lt;div style={{ display: "table-header-group" }} /&gt; <br/>  ...<br/>&lt;/div&gt;</span></pre><p id="1253" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">同样的视觉效果。但是，如果你把<code class="fe lg lh li lj b">&lt;thead /&gt;</code>放在它的<code class="fe lg lh li lj b">&lt;table /&gt;</code>父节点之外，第一个会引起React抱怨(也是在测试中)。</p><pre class="kd ke kf kg gt no lj np nq aw nr bi"><span id="d4f2" class="ns ln in lj b gy nt nu l nv nw">&lt;div&gt;<br/>  &lt;thead /&gt;<br/>&lt;/div&gt;</span><span id="4aaf" class="ns ln in lj b gy ny nu l nv nw">Warning: validateDOMNesting(...): &lt;thead&gt; cannot appear as a child of &lt;div&gt;.</span></pre><p id="3cab" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">为了简单和明确起见，后面的所有例子都基于<code class="fe lg lh li lj b">&lt;table /&gt;</code>元素。</p><p id="2963" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">回到福利上。</p><h1 id="e764" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">通过标题单元格控制列</h1><p id="c612" class="pw-post-body-paragraph kk kl in km b kn me jo kp kq mf jr ks kt mg kv kw kx mh kz la lb mi ld le lf ig bi translated">这可能看起来违反直觉，因为标题和正文单元格在DOM中彼此放置得很远。</p><pre class="kd ke kf kg gt no lj np nq aw nr bi"><span id="cccb" class="ns ln in lj b gy nt nu l nv nw">&lt;table&gt;<br/>  &lt;thead&gt;<br/>    &lt;tr&gt;<br/>      &lt;th style="width: 200px;"&gt;Header cell&lt;/th&gt;<br/>    &lt;/tr&gt;<br/>  &lt;/thead&gt;<br/>  &lt;tbody&gt;<br/>    &lt;tr&gt;<br/>      &lt;td&gt;Table cell 1&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>    &lt;tr&gt;<br/>      &lt;td&gt;Table cell 2&lt;/td&gt;<br/>    &lt;/tr&gt;<br/>  &lt;/tbody&gt;<br/>&lt;/table&gt;</span></pre><p id="d2db" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在本例中，所有<code class="fe lg lh li lj b">&lt;td /&gt;</code>元素的宽度将与用<code class="fe lg lh li lj b">&lt;th style="width: 200px;"&gt;Header cell&lt;/th&gt;</code>设置的宽度相同。</p><p id="a808" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km io">您得到了一个副作用，允许轻松控制列的大小，而不需要设置大量css规则的额外成本。</strong></p><h1 id="3ca6" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">标题和内容组件拆分</h1><p id="aaee" class="pw-post-body-paragraph kk kl in km b kn me jo kp kq mf jr ks kt mg kv kw kx mh kz la lb mi ld le lf ig bi translated">除了调整列的大小，排序和过滤功能也大多附加在标题上。原来他们是统治整个牌桌的非常强大的单位。特别是当您需要将表拆分成React组件时，这种依赖关系就会出现。</p><p id="e6e8" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">查看这个表组件接口(不涉及细节):</p><pre class="kd ke kf kg gt no lj np nq aw nr bi"><span id="b89d" class="ns ln in lj b gy nt nu l nv nw">&lt;Table sortable headers={["Country", "Population"]} data={data}&gt;<br/>  {dataAfterSorting =&gt; (<br/>    dataAfterSorting.map(country =&gt;<br/>      &lt;TableDataRow data={country} /&gt;<br/>    )<br/>  )}<br/>&lt;/Table&gt;</span></pre><p id="2209" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><a class="ae ll" href="https://reactjs.org/docs/fragments.html#motivation" rel="noopener ugc nofollow" target="_blank">这种结构很自然</a>因为:</p><p id="fe9e" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">1.它遵循了表格在DOM中的呈现方式(<em class="lk">带有单独的标题和主体部分</em>)。</p><p id="e32c" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">2.标题附带了排序功能。</p><p id="ad66" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">页眉设置自己的样式。这包括排序指示器、悬停状态，但也包括行为(点击处理程序)。一个独立的组件，编排与之分离的全部内容。</p><p id="443c" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">3.内容不知道它的上下文。</p><p id="239b" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">像<code class="fe lg lh li lj b">&lt;TableDataRow /&gt;</code>这样的组件可能存在于表外。它接受一部分预先排序的数据，并简单地用自己的样式呈现一行。<strong class="km io">这个组件不知道它的上下文，也不需要知道。有一个例外:它显示的单元格数量(</strong> <code class="fe lg lh li lj b"><strong class="km io">&lt;td /&gt;</strong></code> <strong class="km io">)必须与表头相同。</strong></p><h1 id="39fc" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">表格开箱即用</h1><p id="9115" class="pw-post-body-paragraph kk kl in km b kn me jo kp kq mf jr ks kt mg kv kw kx mh kz la lb mi ld le lf ig bi translated"><a class="ae ll" href="https://css-tricks.com/complete-guide-table-element/" rel="noopener ugc nofollow" target="_blank">表格简单明了，众所周知</a>。您不需要额外的代码来实现给定数据集的基本表示。通过简单地使用<code class="fe lg lh li lj b">&lt;table /&gt;</code>结构，你已经有了一个数字的形式。</p><p id="61bf" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如前所述，对于<strong class="km io">柔性盒</strong>来说，情况并非如此。</p><h1 id="88a7" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">粘性标题(代码解决方案)</h1><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/3c425719895ed34b52d3c2a7a6e594c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*9loZ1M8q6JcB5OTh.gif"/></div></figure><p id="a3a0" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这是演示实现，其代码可以在<a class="ae ll" href="https://codesandbox.io/s/sticky-header-table-with-react-3j5zy?file=/src/Table.js" rel="noopener ugc nofollow" target="_blank"> CodeSandbox项目</a>中找到。粘性是通过一个简单的<code class="fe lg lh li lj b">&lt;Table /&gt;</code>组件和一个<code class="fe lg lh li lj b">useStickyHeader</code>反应钩实现的。</p><p id="f9df" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="km io">通过在</strong><a class="ae ll" href="https://codesandbox.io/s/sticky-header-table-with-react-3j5zy?file=/src/styles.css" rel="noopener ugc nofollow" target="_blank"><strong class="km io">styles . CSS</strong></a><strong class="km io">中添加您的自定义表格样式来重用它。</strong></p><h1 id="f436" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated"><code class="fe lg lh li lj b">&lt;Table /&gt;</code>组件接口</h1><p id="68ee" class="pw-post-body-paragraph kk kl in km b kn me jo kp kq mf jr ks kt mg kv kw kx mh kz la lb mi ld le lf ig bi translated">表格组件本身呈现如下</p><pre class="kd ke kf kg gt no lj np nq aw nr bi"><span id="2508" class="ns ln in lj b gy nt nu l nv nw">// App.js<br/>const tableHeaders = ["Country", "Code", "Area", "Flag"];<br/><br/>export const tableData = [<br/>  {<br/>    country: "Brazil",<br/>    code: "BR",<br/>    area: "8,515,767 km2",<br/>    flag: "🇧🇷"<br/>  },<br/>  ...<br/>];<br/><br/>&lt;Table headers={tableHeaders} data={tableData} /&gt;</span></pre><p id="2aa9" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">其中它的<code class="fe lg lh li lj b">headers</code>属性接受一个字符串数组，而<code class="fe lg lh li lj b">data</code>是一个对象数组。</p><p id="24af" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">的接口对于实际的粘性实现并不重要，你可以构建自己的抽象。</p><h1 id="234a" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated"><code class="fe lg lh li lj b">&lt;Table /&gt;</code>组件实现</h1><p id="e2c3" class="pw-post-body-paragraph kk kl in km b kn me jo kp kq mf jr ks kt mg kv kw kx mh kz la lb mi ld le lf ig bi translated">下面是<code class="fe lg lh li lj b">Table.js</code>背后的代码。它充当表及其粘性头的包装器。</p><pre class="kd ke kf kg gt no lj np nq aw nr bi"><span id="25f8" class="ns ln in lj b gy nt nu l nv nw">// Table.js<br/>function Table({ headers = [], data = [] }) {<br/>  const { tableRef, isSticky } = useStickyHeader();<br/><br/>  const renderHeader = () =&gt; (<br/>    &lt;thead&gt;<br/>      &lt;tr&gt;<br/>        {headers.map(item =&gt; &lt;th key={item}&gt;{item}&lt;/th&gt;)}<br/>      &lt;/tr&gt;<br/>    &lt;/thead&gt;<br/>  );<br/><br/>  return (<br/>    &lt;div&gt;<br/>      {isSticky &amp;&amp; (<br/>        &lt;table<br/>          className="sticky"<br/>          style={{<br/>            position: "fixed",<br/>            top: 0,<br/>            left: 0,<br/>            right: 0<br/>          }}<br/>        &gt;<br/>          {renderHeader()}<br/>        &lt;/table&gt;<br/>      )}<br/>      &lt;table ref={tableRef}&gt;<br/>        {renderHeader()}<br/>        &lt;tbody&gt;<br/>          {data.map(item =&gt; (<br/>            &lt;tr key={item.code}&gt;<br/>              &lt;td&gt;{item.country}&lt;/td&gt;<br/>              &lt;td&gt;{item.code}&lt;/td&gt;<br/>              &lt;td&gt;{item.area}&lt;/td&gt;<br/>              &lt;td&gt;{item.flag}&lt;/td&gt;<br/>            &lt;/tr&gt;<br/>          ))}<br/>        &lt;/tbody&gt;<br/>      &lt;/table&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="8c3f" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">一些重要的方面需要一些细节。</p><pre class="kd ke kf kg gt no lj np nq aw nr bi"><span id="23d5" class="ns ln in lj b gy nt nu l nv nw">const { tableRef, isSticky } = useStickyHeader ( ) ;</span></pre><p id="3f76" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><a class="ae ll" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">自定义反应钩</a>露出两个道具:</p><ul class=""><li id="5a6e" class="mj mk in km b kn ko kq kr kt ml kx mm lb mn lf mo mp mq mr bi translated"><code class="fe lg lh li lj b">tableRef</code> -用于引用您希望具有粘性标题的表格元素。</li><li id="f913" class="mj mk in km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated"><code class="fe lg lh li lj b">isSticky</code> -每当表格超过页面的上边缘时，标志转动<code class="fe lg lh li lj b">true</code>。</li></ul><pre class="kd ke kf kg gt no lj np nq aw nr bi"><span id="42ec" class="ns ln in lj b gy nt nu l nv nw">// Render if isSticky is true.<br/>{isSticky &amp;&amp; (<br/>  // This is a required &lt;table /&gt; wrapper for the sticky header.<br/>  // .sticky class distinguishes from the original table<br/>  // and the additional style enables the stickiness.<br/>  &lt;table<br/>    className="sticky"<br/>    style={{<br/>      position: "fixed",<br/>      top: 0,<br/>      left: 0,<br/>      right: 0<br/>    }}<br/>  &gt;<br/>    {/* Render the same table header */}<br/>    {renderHeader()}<br/>  &lt;/table&gt;<br/>)}</span></pre><p id="52df" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果<code class="fe lg lh li lj b">isSticky</code>为真，则该部分呈现粘性报头。</p><p id="015f" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">上面的粘性元素应该继承原来的<code class="fe lg lh li lj b">&lt;table /&gt;</code>的样式，以获得相同的外观。</p><p id="3341" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">另一件需要注意的事情是——有两个对<code class="fe lg lh li lj b">renderHeader()</code>的调用。如果启用了粘性，这意味着标记中有两个<code class="fe lg lh li lj b">&lt;thead /&gt;</code>。<strong class="km io">这是必需的。原始头需要填充表顶部的物理空间。而且它不能去粘自</strong> <code class="fe lg lh li lj b"><strong class="km io">position: fixed</strong></code> <strong class="km io">断章取义</strong><a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/CSS/position#Syntax" rel="noopener ugc nofollow" target="_blank"><strong class="km io"/></a><strong class="km io">。在这种情况下，引入头的第二个副本是解决该问题的一种方法。</strong></p><h1 id="ff81" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">useStickyHeader()实现</h1><p id="5ba1" class="pw-post-body-paragraph kk kl in km b kn me jo kp kq mf jr ks kt mg kv kw kx mh kz la lb mi ld le lf ig bi translated">鉴于<code class="fe lg lh li lj b">&lt;Table /&gt;</code>组件上的注释，<code class="fe lg lh li lj b">useStickyHeader</code>钩子可能是你需要的唯一一段代码。</p><pre class="kd ke kf kg gt no lj np nq aw nr bi"><span id="326a" class="ns ln in lj b gy nt nu l nv nw">// useStickyHeader.js<br/>const useStickyHeader = (defaultSticky = false) =&gt; {<br/>  const [isSticky, setIsSticky] = useState(defaultSticky);<br/>  const tableRef = useRef(null);<br/><br/>  const handleScroll = useCallback(({ top, bottom }) =&gt; {<br/>    if (top &lt;= 0 &amp;&amp; bottom &gt; 2 * 68) {<br/>      !isSticky &amp;&amp; setIsSticky(true);<br/>    } else {<br/>      isSticky &amp;&amp; setIsSticky(false);<br/>    }<br/>  }, [isSticky]);<br/><br/>  useEffect(() =&gt; {<br/>    const handleScroll = () =&gt; {<br/>      handleScroll(tableRef.current.getBoundingClientRect());<br/>    };<br/>    window.addEventListener("scroll", handleScroll);<br/><br/>    return () =&gt; {<br/>      window.removeEventListener("scroll", handleScroll);<br/>    };<br/>  }, [handleScroll]);<br/><br/>  return { tableRef, isSticky };<br/>};</span></pre><p id="40bb" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">快速浏览一段一段的代码。</p><pre class="kd ke kf kg gt no lj np nq aw nr bi"><span id="7477" class="ns ln in lj b gy nt nu l nv nw">const [isSticky, setIsSticky] = useState(defaultSticky);<br/>const tableRef = useRef(null);</span></pre><p id="d912" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><code class="fe lg lh li lj b">useState</code>提供了一种基于某些计算来更新<code class="fe lg lh li lj b">isSticky</code>标志的方法。它采用父级传递的默认值(页面可能会加载中间的表)。<code class="fe lg lh li lj b">tableRef</code>只是对后面一些计算所需的表元素的引用。</p><pre class="kd ke kf kg gt no lj np nq aw nr bi"><span id="4689" class="ns ln in lj b gy nt nu l nv nw">const handleScroll = useCallback(({ top, bottom }) =&gt; {<br/>  // The number 68 is hardcoded here and is the header's height.<br/>  // It could also be skipped<br/>  if (top &lt;= 0 &amp;&amp; bottom &gt; 2 * 68) {<br/>    !isSticky &amp;&amp; setIsSticky(true);<br/>  } else {<br/>    isSticky &amp;&amp; setIsSticky(false);<br/>  }<br/>  // returns a new memoized callback<br/>  // whenever the value of isSticky changes<br/>}, [isSticky]);</span></pre><p id="bff3" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">下面是必要的计算。<code class="fe lg lh li lj b">{ top, bottom }</code>描述表格在屏幕上的位置。一旦它开始消失(<code class="fe lg lh li lj b">top &lt;= 0</code>)或至少有两个标题的可视空间(<code class="fe lg lh li lj b">bottom &gt; 2 * 68</code> ) -粘性模式启用。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/4e5446dc5fff72dc216639dd43c4f67e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/0*_qbxZTPu7qq0A9IB.png"/></div></figure><p id="06bc" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">钩子实现的第二部分是它的副作用。它执行滚动事件绑定，并将当前表维度向下传递给评估回调。</p><pre class="kd ke kf kg gt no lj np nq aw nr bi"><span id="bca3" class="ns ln in lj b gy nt nu l nv nw">useEffect(() =&gt; {<br/>  const handleScroll = () =&gt; {<br/>    // Pass the current bounding rect of the table<br/>    handleScroll(tableRef.current.getBoundingClientRect());<br/>  };<br/>  window.addEventListener("scroll", handleScroll);<br/>  // Clear the effect<br/>  return () =&gt; {<br/>    window.removeEventListener("scroll", handleScroll);<br/>  };<br/>  // Recreate the effect if handleScroll is a new function<br/>}, [handleScroll]);</span></pre><h1 id="aba8" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">最后的话</h1><p id="479c" class="pw-post-body-paragraph kk kl in km b kn me jo kp kq mf jr ks kt mg kv kw kx mh kz la lb mi ld le lf ig bi translated">全解住<a class="ae ll" href="https://codesandbox.io/s/sticky-header-table-with-react-3j5zy?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="ef01" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">与flexbox制作的东西相比，将表格标题变得有粘性可能是一项挑战。令人沮丧的是，简单地将<code class="fe lg lh li lj b">position: fixed</code>应用到标题并不能神奇地工作。也许不得不渲染两个<code class="fe lg lh li lj b">&lt;thead /&gt;</code>太多了。</p><p id="f534" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">另一方面，表格在呈现类似数组的数据时非常方便，有很多默认的好处。这就是为什么一篇独立的博文专门讨论头球挑战。最少你需要解开它是一个定制的反应钩是主要的螺栓。</p><p id="4455" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">📩<a class="ae ll" href="https://webup.org/blog/subscribe/" rel="noopener ugc nofollow" target="_blank">订阅</a>我的下一篇手工Javascript/React文章。每月发行。</p><h1 id="1f7d" class="lm ln in bd lo lp lq lr ls lt lu lv lw jt lx ju ly jw lz jx ma jz mb ka mc md bi translated">资源</h1><ul class=""><li id="f5e6" class="mj mk in km b kn me kq mf kt oa kx ob lb oc lf mo mp mq mr bi translated"><a class="ae ll" href="https://css-tricks.com/complete-guide-table-element/" rel="noopener ugc nofollow" target="_blank">表格元素的完整指南</a>—Chris Coyier的《深入表格》。</li><li id="ea56" class="mj mk in km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated"><a class="ae ll" href="https://css-tricks.com/accessible-simple-responsive-tables/" rel="noopener ugc nofollow" target="_blank">可访问、简单、响应迅速的桌子</a> —使用flexbox实现桌子布局。</li><li id="5002" class="mj mk in km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated"><a class="ae ll" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank"> Fragments </a> —用表拆分示例对片段上的文档进行反应。</li><li id="8f37" class="mj mk in km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated"><a class="ae ll" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">打造自己的钩子</a> —定制钩子提取背后的官方指南。</li><li id="8e17" class="mj mk in km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated"><a class="ae ll" href="https://developer.mozilla.org/en-US/docs/Web/CSS/position#Syntax" rel="noopener ugc nofollow" target="_blank"> CSS:层叠样式表—位置</a>—MDN上关于<code class="fe lg lh li lj b">position: fixed</code>的更多信息。</li><li id="6a47" class="mj mk in km b kn ms kq mt kt mu kx mv lb mw lf mo mp mq mr bi translated"><a class="ae ll" href="https://webup.org/blog/render-props-vs-hooks/" rel="noopener ugc nofollow" target="_blank">渲染道具vs React挂钩</a> —模式比较有助于决定组件接口。</li></ul></div><div class="ab cl mx my hr mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ig ih ii ij ik"><p id="bbc9" class="pw-post-body-paragraph kk kl in km b kn ko jo kp kq kr jr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><em class="lk">原载于</em><a class="ae ll" href="https://webup.org/blog/sticky-header-table-with-react-hooks/" rel="noopener ugc nofollow" target="_blank"><em class="lk">https://webup.org</em></a><em class="lk">。</em></p></div></div>    
</body>
</html>