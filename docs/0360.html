<html>
<head>
<title>Examples of closures in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的闭包示例</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/examples-of-closures-in-javascript-9bc397bbf1a1?source=collection_archive---------3-----------------------#2019-09-24">https://javascript.plainenglish.io/examples-of-closures-in-javascript-9bc397bbf1a1?source=collection_archive---------3-----------------------#2019-09-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f9fbdebb7a4ac13f9070646d0c03ab04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xx4L2LSYWZoOA178G44qCg.png"/></div></div></figure><p id="30c6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">闭包这个词听起来很复杂。您几乎肯定已经理解了闭包——让我们看看一些例子。</p><h1 id="d123" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">实施例1</h1><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="bb15" class="ma ku in lw b gy mb mc l md me">function outer() {<br/>  const a = 23;<br/>  function inner() {<br/>    console.log(a);<br/>  }<br/>  inner();<br/>}</span><span id="72e4" class="ma ku in lw b gy mf mc l md me">outer();<br/>//=&gt; 23</span><span id="e3cb" class="ma ku in lw b gy mf mc l md me">// The `inner` function is said to have closure over the variable `a`</span></pre><p id="4730" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上面的例子中，<code class="fe mg mh mi lw b">inner</code>函数可以访问变量<code class="fe mg mh mi lw b">a</code>，因此<code class="fe mg mh mi lw b">inner</code>被认为对变量a有闭包。</p><h1 id="7c69" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">示例2</h1><p id="8ec6" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">我们可以利用闭包来有效地隐藏我们可能不想用我们的程序公开的东西。</p><p id="2169" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有一个(不切实际的)例子来证明这一点:</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="3c7e" class="ma ku in lw b gy mb mc l md me">function outer(number) {<br/>  const secretNumber = 23;<br/>  function inner(num) {<br/>    console.log(num * secretNumber);<br/>  }<br/>  return inner(number);<br/>}</span><span id="378d" class="ma ku in lw b gy mf mc l md me">outer(10);<br/>//=&gt; 230</span></pre><p id="d63c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，<code class="fe mg mh mi lw b">outer</code>函数返回另一个可以访问变量<code class="fe mg mh mi lw b">secretNumber</code>的函数。</p><p id="28cd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然上面的例子可能有点简单，而且无效(任何人都可以通过调用<code class="fe mg mh mi lw b">outer(1)</code>来猜测<code class="fe mg mh mi lw b">secretNumber</code>是什么)，但是它展示了如何使用闭包来使事情变得私有。</p><h1 id="b28b" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">示例3:可重用的函数</h1><p id="bdd5" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">我们可以利用闭包的力量，使函数在不同的上下文中可以重用。</p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="8f8f" class="ma ku in lw b gy mb mc l md me">function adder(firstNumber) {<br/>  function add(secondNumber) {<br/>    console.log(firstNumber + secondNumber);<br/>  }<br/>  return add; <br/>}</span><span id="5259" class="ma ku in lw b gy mf mc l md me">const addFive = adder(5);<br/>addFive(10);<br/>//= &gt; 15</span><span id="458f" class="ma ku in lw b gy mf mc l md me">const addTen = adder(10);<br/>addTen(100);<br/>// =&gt; 110</span></pre><p id="1b7f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，上面的加法器函数返回<code class="fe mg mh mi lw b">add</code>函数，但不调用它(就像这样:<code class="fe mg mh mi lw b">add()</code>)。这意味着当我们用<code class="fe mg mh mi lw b">firstNumber</code>参数调用<code class="fe mg mh mi lw b">adder</code>时(例如:<code class="fe mg mh mi lw b">const addFive = adder(5)</code>)，它会返回一个现在知道<code class="fe mg mh mi lw b">firstNumber</code>值的函数，我们可以调用它(例如:<code class="fe mg mh mi lw b">addFive(10)</code>)来获得最终结果。</p><h1 id="0c29" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">示例5:可重用闭包的一个更实际的示例</h1><p id="1439" class="pw-post-body-paragraph jv jw in jx b jy mj ka kb kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks ig bi translated">我发现上面的<code class="fe mg mh mi lw b">adder</code>函数非常有助于理解闭包的这种用法，但是直到我看到一些真正的生产代码，我才真正“了解”它是如何被实际使用的。</p><p id="82e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里有一个例子，希望能让事情变得更清楚。</p><p id="6dc6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> <em class="mo">注</em> </strong> <em class="mo">:我正在用包</em> <code class="fe mg mh mi lw b"><em class="mo">axios</em></code> <em class="mo">取数据——你不需要知道</em> <code class="fe mg mh mi lw b"><em class="mo">axios</em></code> <em class="mo">是如何工作的，就能理解下面的例子</em></p><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="40a4" class="ma ku in lw b gy mb mc l md me">// Reusable data fetcher function </span><span id="957c" class="ma ku in lw b gy mf mc l md me">function dataFetcher(url) {<br/>  return async function getData(path) {<br/>    try {<br/>      const endpoint = path ? `${url}/${path}` : url;<br/>      const response = await axios.get(endpoint);<br/>      return response.data;<br/>    } catch (error) {<br/>      console.log(error);<br/>    }<br/>  };<br/>}<br/></span><span id="4caf" class="ma ku in lw b gy mf mc l md me">// Reusable UK police data fetcher function </span><span id="e2d4" class="ma ku in lw b gy mf mc l md me">async function ukPoliceForceDataFetcher(path) {<br/>  try {<br/>    const policeForces = dataFetcher('<a class="ae mp" href="https://data.police.uk/api/forces'" rel="noopener ugc nofollow" target="_blank">https://data.police.uk/api/forces'</a>);<br/>    const result = await policeForces(path);<br/>    console.log('result', result);<br/>  } catch (error) {<br/>    console.log(error);<br/>  }<br/>};</span><span id="bf7f" class="ma ku in lw b gy mf mc l md me">// EXAMPLES OF FUNCTION RE-USE</span><span id="38eb" class="ma ku in lw b gy mf mc l md me">// Example 1: Invoking it without a path parameter<br/>ukPoliceForceDataFetcher(); </span><span id="6e64" class="ma ku in lw b gy mf mc l md me">// Example 2: Invoking it with 'leicestershire'<br/>ukPoliceForceDataFetcher('leicestershire');</span><span id="83ba" class="ma ku in lw b gy mf mc l md me">// Example 3: Invoking it with 'essex' <br/>ukPoliceForceDataFetcher('essex');</span></pre><ol class=""><li id="eb1f" class="mq mr in jx b jy jz kc kd kg ms kk mt ko mu ks mv mw mx my bi translated">我创建了一个接受URL的通用<code class="fe mg mh mi lw b">dataFetcher</code>函数，并返回一个接受附加路径参数的函数。我用它来动态改变路径，以获得不同情况下的结果。</li><li id="8a67" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated">我创建了一个名为<code class="fe mg mh mi lw b">ukPoliceForceDataFetcher</code>的更具体的数据获取器，它使用步骤1中的<code class="fe mg mh mi lw b">dataFetcher</code>函数，并传入英国警察部队API的url(我选择这个是因为它不需要任何认证)</li><li id="bc5d" class="mq mr in jx b jy mz kc na kg nb kk nc ko nd ks mv mw mx my bi translated"><code class="fe mg mh mi lw b">ukPoliceForceDataFetcher</code>函数返回另一个函数，该函数可以将一个区域作为路径参数，并返回该区域的相关细节。如果没有提供区域，则默认返回所有区域的名称和id。</li></ol><p id="615c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">上面的例子显示了当我们想要获得不同地区的数据时，我们如何能够重用<code class="fe mg mh mi lw b">ukPoliceForceDataFetcher</code>函数，但是使用通用的<code class="fe mg mh mi lw b">dataFetcher</code>函数也使我们能够重用它。让我们看一个工作示例。</p><h1 id="08e7" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">示例6:重用通用数据提取器函数</h1><pre class="lr ls lt lu gt lv lw lx ly aw lz bi"><span id="06f6" class="ma ku in lw b gy mb mc l md me">// Here's the genetic dataFetcher function that we used to create our ukPoliceDataFetcher above</span><span id="fde1" class="ma ku in lw b gy mf mc l md me">function dataFetcher(url) {<br/>  return async function getData(path) {<br/>    try {<br/>      const endpoint = path ? `${url}/${path}`: url;<br/>      const response = await axios.get(endpoint);<br/>      return response.data;<br/>    } catch (error) {<br/>      console.log(error);<br/>    }<br/>  };<br/>}</span><span id="b10c" class="ma ku in lw b gy mf mc l md me">// Now, here's another re-use of it. Same function, but now we're using the <a class="ae mp" href="https://jsonplaceholder.typicode.com/todos'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos</a> API.</span><span id="2393" class="ma ku in lw b gy mf mc l md me">async function getToDos(path) {<br/>  try {<br/>    const placeHolderUrl = '<a class="ae mp" href="https://jsonplaceholder.typicode.com/todos'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos'</a>;<br/>    const todos = dataFetcher(placeHolderUrl);<br/>    const result = await todos(path);<br/>    console.log(result);<br/>  } catch (error) {<br/>    console.log(error);<br/>  }<br/>}</span><span id="c18a" class="ma ku in lw b gy mf mc l md me">getToDos(); // Gets the entire to do list<br/>getToDos('1'); // Gets the to do with id: 1<br/>getToDos('23'); // Gets the to do with id: 23</span></pre><p id="1a89" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以通过传递其他参数，比如<code class="fe mg mh mi lw b">queryString</code>、<code class="fe mg mh mi lw b">request body</code>和<code class="fe mg mh mi lw b">path</code>，来构建更多的内容，但是最重要的是总体概念。</p><p id="668a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你有什么建议或者问题，请在下面留言！</p></div></div>    
</body>
</html>