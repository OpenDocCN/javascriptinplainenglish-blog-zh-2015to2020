<html>
<head>
<title>Are JavaScript for loops better than filter() and forEach?()</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript for循环比filter()和forEach好吗？()</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/are-for-loops-better-than-arrays-filter-or-foreach-methods-f54b6880d201?source=collection_archive---------1-----------------------#2020-11-15">https://javascript.plainenglish.io/are-for-loops-better-than-arrays-filter-or-foreach-methods-f54b6880d201?source=collection_archive---------1-----------------------#2020-11-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="262b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在过去的几年里，ES6中的filter()、forEach()和map()等方法变得非常流行。但是他们真的更好吗？</h2></div><p id="c9eb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们都习惯了Array.map和Array.filter为我们提供的简洁代码，但是对于现实世界的应用程序来说，正则for循环比这些方便的方法更好吗？</p><p id="db57" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在将Array类中的方法与“旧的”for-loop方法进行比较时，我们将考虑几个指标:性能、可读性和可伸缩性。下面是我们今天要比较的环路类型的一个示例:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="2cc7" class="lh li in ld b gy lj lk l ll lm">const items = [’abc’, ’def’, ’ghi’, ’jk’];</span></pre><p id="86f7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是<code class="fe ln lo lp ld b">filter</code>方法的一个完美用例:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="2032" class="lh li in ld b gy lj lk l ll lm">const threes = items.filter(item =&gt; item.length === 3);</span></pre><p id="4fe0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">或者解决问题的for循环方法:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="a8b5" class="lh li in ld b gy lj lk l ll lm">const threes = [];<br/>for(let i = 0; i &lt; items.length; i++) {<br/>  if (items[i].length === 3) {<br/>    items.push(items[i]);<br/>  }<br/>}</span></pre><h1 id="6d43" class="lq li in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">寻找最好的</h1><p id="7737" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">对于本文中我们考虑的所有方法，很明显它们的时间复杂度是<strong class="ke io"> O(n) </strong>。也就是说，在最坏的情况下，我们至少需要数组中的每个元素来解决这个问题。想想看:我们无法过滤掉长度为3的项目，除非<em class="mm">实际上查看每一个项目。如果我们停在中间，也就是O(n/2)，我们还没有解决问题。</em></p><p id="1d6a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">考虑到我们有相同的时间复杂度，我们需要考虑三个问题:</p><ul class=""><li id="54bf" class="mn mo in ke b kf kg ki kj kl mp kp mq kt mr kx ms mt mu mv bi translated">哪种方法更快？</li><li id="67c7" class="mn mo in ke b kf mw ki mx kl my kp mz kt na kx ms mt mu mv bi translated">哪种方法的可扩展性更强？</li><li id="f928" class="mn mo in ke b kf mw ki mx kl my kp mz kt na kx ms mt mu mv bi translated">哪种方法更具可读性和可维护性？</li></ul><h2 id="25ad" class="lh li in bd lr nb nc dn lv nd ne dp lz kl nf ng mb kp nh ni md kt nj nk mf nl bi translated">因素一:性能</h2><p id="435a" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">在JavaScript中，可以用每秒操作数来计算性能。虽然我们不能直接访问CPU来测试我们的代码在如此接近“金属”的地方的性能，但是我们可以做的是测试我们的代码运行的速度。</p><p id="594f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将利用一个名为<a class="ae nm" href="https://benchmarkjs.com/" rel="noopener ugc nofollow" target="_blank"> Benchmark.js </a>的库来帮助我们，这将为我们提供具有统计意义的结果。Benchmark将多次迭代运行我们的代码，并为我们计算出结果的平均值。为了进行测试，我选择了一个包含1000个“Person”对象的数组，这些对象的属性包括:姓名、年龄和性别。对于我们的基准测试，我们将<strong class="ke io">过滤</strong>任何年龄超过10岁的人。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ba5f" class="lh li in ld b gy lj lk l ll lm">const people = [<br/>  {name: ’Jane Doe’, age: 32, gender: ”Female”},<br/>  ... 999 other persons<br/>}</span></pre><figure class="ky kz la lb gt no gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/7a43d7592b25642e817338e0a2110ad5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1082/format:webp/1*U9n3mWTwwUz0jA9MbBML7A.png"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Screenshot by the Author, Aman Bhimani. Library: Benchmark.js.</figcaption></figure><p id="9260" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">令我们惊讶的是，for循环比<code class="fe ln lo lp ld b">Array.filter</code>方法快得多。准确地说，Filter方法比for loop慢77%。这是为什么呢？一个原因可能是for循环同步运行，filter方法为数组中的每个元素创建一个新函数。然后，这个新函数被放到调用堆栈上，并由事件循环逐个运行。这种开销需要时间，而for循环完全忽略了这一点，并在同一个函数中运行您的操作。</p><p id="b298" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">很明显，如果我们从每秒操作数或时间的指标来看，for循环是纯粹性能的明显赢家。我们将不得不看看它在其余两个指标中的位置，以及它是否是一个明显的赢家。</p><h2 id="b478" class="lh li in bd lr nb nc dn lv nd ne dp lz kl nf ng mb kp nh ni md kt nj nk mf nl bi translated">因素二:可读性</h2><p id="f87b" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">当然，编写代码的主要因素之一是可读性。可读性更好的代码更容易维护，即使它只是一个简单的for循环。当我们在for循环中看到<em class="mm">单词</em>而不是数字时，我们就明白了。数组附带的方法名比编写for循环更具描述性。</p><ul class=""><li id="ea9a" class="mn mo in ke b kf kg ki kj kl mp kp mq kt mr kx ms mt mu mv bi translated">indexOf =查找匹配的第一个元素的索引</li><li id="54bb" class="mn mo in ke b kf mw ki mx kl my kp mz kt na kx ms mt mu mv bi translated">forEach =对每个元素运行函数</li><li id="c318" class="mn mo in ke b kf mw ki mx kl my kp mz kt na kx ms mt mu mv bi translated">filter =筛选任何匹配的元素</li></ul><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ddfa" class="lh li in ld b gy lj lk l ll lm">const threes = [];<br/>for(let i = 0; i &lt; items.length; i++) {<br/>  if (items[i].length === 3) {<br/>    items.push(items[i]);<br/>  }<br/>}</span></pre><p id="8a3d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们以之前的三为例，对其进行更深入的分析。</p><ul class=""><li id="815e" class="mn mo in ke b kf kg ki kj kl mp kp mq kt mr kx ms mt mu mv bi translated">第一行没有意义，我们创建了一个新的数组来保存我们过滤的元素，但是它没有添加任何业务逻辑。</li><li id="e19c" class="mn mo in ke b kf mw ki mx kl my kp mz kt na kx ms mt mu mv bi translated">第二行也是无意义的—它只是在整个数组中循环，这里没有业务逻辑。</li><li id="8913" class="mn mo in ke b kf mw ki mx kl my kp mz kt na kx ms mt mu mv bi translated">第三行是逻辑，我们需要长度为3的元素。</li><li id="d1a0" class="mn mo in ke b kf mw ki mx kl my kp mz kt na kx ms mt mu mv bi translated">第四行也没有逻辑——它只是结束了我们的函数。</li></ul><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="ae18" class="lh li in ld b gy lj lk l ll lm">const threes = items.filter(item =&gt; item.length === 3);</span></pre><p id="c028" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们将它与我们的过滤器示例进行比较时，它被限制在一行中，这一行包含了所有需要的逻辑。</p><h2 id="200c" class="lh li in bd lr nb nc dn lv nd ne dp lz kl nf ng mb kp nh ni md kt nj nk mf nl bi translated">因素三:可扩展性</h2><p id="dab0" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">为了理解JavaScript中的可伸缩性，我们需要首先理解JavaScript在核心部分是如何工作的:事件循环和事件队列。由于JavaScript是单线程的，我们一次只能运行一个操作。现代网站和网络应用程序需要同时进行多项操作，那么这是如何实现的呢？事件循环通过共享浏览器窗口可用的单线程来实现这一点。</p><figure class="ky kz la lb gt no gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi nv"><img src="../Images/f2bbf7a5d11c23497cae6a18426ebd3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nheGQ8OXgrCY7WBCUt7WDA.jpeg"/></div></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Sketch by the author, Aman Bhimani.</figcaption></figure><p id="d819" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上图描述了JavaScript事件循环是如何工作的。我们有事件队列，它将事件存放在先进先出队列中。当一个函数在事件循环中启动时，它会创建自己的“调用堆栈”，所有的函数引用都放在这个堆栈中。但问题是，这对我们真的有帮助吗？</p><p id="94b4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不幸的是，for-loops或forEach不使用事件循环，但它们是同步运行的(for-loops)或放在调用堆栈上的(forEach)。这也意味着使用这些循环数据的方式中的任何一种都会<strong class="ke io">阻塞</strong>任何其他需要在主线程上运行的任务。</p><p id="9643" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">作为一个例子，我们可以考虑下面的代码。在装载正文时，我们启动一个函数，打印前10，000个数字。我们有一个按钮可以运行打印“你好”的功能。</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="94cd" class="lh li in ld b gy lj lk l ll lm">function start() {<br/>  for(let i = 0; i &lt; 10000; i++) {<br/>    console.log(i);<br/>  }<br/>}</span><span id="43c1" class="lh li in ld b gy oa lk l ll lm">function print() {<br/>  console.log('HELLO');<br/>}</span></pre><p id="ffda" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">index.html:</p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="2b5a" class="lh li in ld b gy lj lk l ll lm">&lt;body onload="start()"&gt;<br/>  &lt;button onclick="print()"&gt;print&lt;/button&gt;<br/>&lt;/body&gt;</span></pre><p id="638b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当页面加载时，开始打印数字。如果我们在 <strong class="ke io"> <em class="mm"> </em> </strong>数字9999前按下<em class="mm">按钮，不会立即打印出来。这是因为按钮<code class="fe ln lo lp ld b">onclick</code>事件，被放在事件队列中。一旦事件循环可以自由调用下一个事件，它就会运行。我们使用哪种类型的循环进行迭代并不重要。</em></p><pre class="ky kz la lb gt lc ld le lf aw lg bi"><span id="20bd" class="lh li in ld b gy lj lk l ll lm">1<br/>2<br/>————-&gt; click button<br/>3<br/>...<br/>9994<br/>9995<br/>9998<br/>————-&gt; click button<br/>9999<br/>HELLO<br/>HELLO</span></pre><h1 id="b8a1" class="lq li in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">我们如何让它变得更好？</h1><p id="70f3" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">如果您的数组大小“很小”，那么使用常规的旧for循环显然对运行时性能更好。但是，如果您正在寻找最大的可伸缩性，我们需要更好地思考。我们需要滥用语言机制，利用事件循环。从现在开始，有几条路可以走:</p><ul class=""><li id="73f4" class="mn mo in ke b kf kg ki kj kl mp kp mq kt mr kx ms mt mu mv bi translated">每次迭代都是一个新事件</li><li id="511b" class="mn mo in ke b kf mw ki mx kl my kp mz kt na kx ms mt mu mv bi translated">数组的每个“块”都是一个新事件</li></ul><p id="28f4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的下一个练习中，我们将尝试创建一个“for”循环，该循环将事件循环考虑在内，并使这种for循环思想对于更大的数组集合具有无限的可伸缩性。</p></div></div>    
</body>
</html>