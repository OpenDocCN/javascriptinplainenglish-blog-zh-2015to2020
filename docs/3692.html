<html>
<head>
<title>Creating a find-in-page scroll feature with React 🤘</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React创建在页面中查找滚动功能🤘</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-a-find-in-page-scroll-feature-with-react-32983ad90138?source=collection_archive---------7-----------------------#2020-10-18">https://javascript.plainenglish.io/creating-a-find-in-page-scroll-feature-with-react-32983ad90138?source=collection_archive---------7-----------------------#2020-10-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/e37115bc345b18126c9cc95c495b4a47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*rQiApP0czIX1v4ec1jdI9w.gif"/></div></div></figure><p id="2c4f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最近，我一直在从事维基百科的一个开源分支，名为<a class="ae kt" href="https://wikiedu.org/" rel="noopener ugc nofollow" target="_blank"> WikiEdu </a>。我决定创建一个滚动特性，滚动到编辑对文章所做的修改。</p><p id="6bd9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">文章显示在浮动窗口中，编辑器列在底部。如果用户对文章进行了活动的修订，它们将与修订一起突出显示。</p><p id="7144" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个需要解决的有趣问题，因为我必须在文章呈现后创建滚动功能，滚动事件将由当前修订的位置决定。在这篇文章中，我将解释我是如何解决这个问题的。</p><h2 id="5651" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">定义问题:</strong></h2><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/5da0a3c5c4b4d1dc8e1dd26424023c02.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*0TBMRwEnjh6yA00tlHPMjw.jpeg"/></div></figure><p id="723d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">基本上这个功能应该如何工作就像浏览器中的页面查找功能一样。使用“在页面中查找”功能，您可以搜索某个单词或短语，如果该单词或短语包含在页面中，您可以通过单击向上或向下箭头滚动到该单词或短语(见下图)。</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/209bf37e28b9e8e1a7ca6fc9b8df2a38.png" data-original-src="https://miro.medium.com/v2/resize:fit:758/format:webp/1*wVH6uZ16Ve2KQ2ugYZ_8Sg.png"/></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">find_in_page</figcaption></figure><p id="38bb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，我的版本有一个额外的复杂性，因为可能有多个搜索词，这取决于进行修订的编辑的数量。</p><p id="0908" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">功能</strong>:</p><ol class=""><li id="41fc" class="lx ly in jx b jy jz kc kd kg lz kk ma ko mb ks mc md me mf bi translated">单击时，页面将滚动到文章查看器顶部选定用户所做的第一次编辑。</li></ol><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/4e7becb7c7b594ab161b525572c4a080.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FUpg4sQIQ-AcKa_1J0P40w.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">1</figcaption></figure><p id="bb3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">2.下一个滚动事件将找到一个视图之外的修订，并将其滚动到页面底部。这有助于保持用户对文章的心理模型。</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/0fa242a4086b76cb488000f51274d77f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wIP61hUmVADNXBB_nIhXlQ.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">2</figcaption></figure><p id="8ca3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">3.如果用户从先前选择的编辑器中选择了不同的编辑器，则该特征足够智能地滚动到当前编辑下方的新编辑器的最近编辑。如果在当前编辑下没有编辑，则滚动到编辑者进行的第一次编辑。</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/ddc94f2dcc6da15d49f5b174ab922a0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cd_c9DG-swYJGIfgCEcf4w.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">3</figcaption></figure><p id="9056" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">或……</strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mh"><img src="../Images/ae9db9954d900d8c4f556d16b17967fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1iK7uHTjJGaiUKksHKHfYQ.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">3</figcaption></figure><p id="e4be" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">4.如果用户一直点击到最后一次编辑，那么页面将滚动回第一次编辑。</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mg"><img src="../Images/3ac5c32a884010810ea3b2452f5a2625.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VAUDc_-0Curq-gEgh6XNMg.png"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">4</figcaption></figure></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h2 id="46ff" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">收集并存储滚动数据:</strong></h2><p id="1d8b" class="pw-post-body-paragraph jv jw in jx b jy mp ka kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks ig bi translated">所以首先要做的是找到包含编辑修改的段落。</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/85adb06bbe19d3fb328b06b71f9b50f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*PwkTsavmf4Xa6_OFeaXonw.png"/></div></figure><p id="c2a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇文章是通过MediaWiki的API检索的。我试图找到一种方法，在数据呈现之前以字符串形式收集数据。这将使得运行时间更快。然而，没有一种体面的方式来做到这一点。文章呈现后，我不得不满足于用querySelector抓取段落。</p><p id="4406" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">有了查询结果，我就可以进行搜索，找到包含与特定编辑器相关的突出显示文本的段落。然后将该段落添加到包含其他信息(如段落索引和当前段落的位置)的数据结构中。</p><p id="56e4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最终结果是这样的:</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mv"><img src="../Images/e984779561002caabf2217a0b8fc8978.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tnsc_60ZfLbYww6eWxKuDw.png"/></div></div></figure><p id="f814" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">“索引”键用于跟踪已经滚动到的当前段落。单击编辑器的按钮将使索引增加1。</p><p id="17f1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">实际代码:</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mw"><img src="../Images/1858886ee6e0984437687a8f5167ef87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Yqa0C_NlyqD9F6DGTwuPQ.png"/></div></div></figure></div><div class="ab cl mi mj hr mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ig ih ii ij ik"><h2 id="e7ed" class="ku kv in bd kw kx ky dn kz la lb dp lc kg ld le lf kk lg lh li ko lj lk ll lm bi translated"><strong class="ak">滚动功能:</strong></h2><p id="a2f9" class="pw-post-body-paragraph jv jw in jx b jy mp ka kb kc mq ke kf kg mr ki kj kk ms km kn ko mt kq kr ks ig bi translated">对于滚动，我决定使用<a class="ae kt" href="https://www.npmjs.com/package/react-scroll" rel="noopener ugc nofollow" target="_blank"> react-scroll </a>库。有一些内置的方法，比如Element.scroll()和Element.scrollIntoView()，但是react-scroll提供了更多的灵活性和控制，所以我选择了它。</p><p id="961e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦收集了用户的数据，我需要编写一个函数来确定下一步滚动到哪里。这个功能可以分为三个部分。</p><p id="c735" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如果用户从一个编辑器切换到另一个编辑器:</strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/80b051588253226c5885d3ff07f70cf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qx8nw0Kxi4RD1TzoQ45LPQ.png"/></div></div></figure><p id="a2ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如果看到下一个位置:</strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi my"><img src="../Images/8033f7cc6f04da67423c0655842df193.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-Cp5aWhjdGddP2wnSIBIGw.png"/></div></div></figure><p id="f76c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">如果距当前位置的距离小于最小滚动距离:</strong></p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/d6037aec0c4bf816c63e6f165a8638d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5U-4AZ6gqdCtoddpgtYusQ.png"/></div></div></figure><p id="748e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">滚动到</strong>:</p><p id="ea06" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面是最后一个功能！</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi na"><img src="../Images/fc3e5728037464e4512490cc6b369ffd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5xl7P639IqRddqLGguemlg.png"/></div></div></figure><p id="432a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最终结果！</p><figure class="lo lp lq lr gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/286304150e64c14aeed48cada8f17fb6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*NOc72puQnNeoGUQanNzong.gif"/></div></div><figcaption class="lt lu gj gh gi lv lw bd b be z dk">Main Scroll</figcaption></figure><p id="7ff5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我真的很喜欢构建这个功能，并且对结果非常满意！希望这篇文章对你有用。随意伸手！</p><p id="2aaf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kt" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">订阅解码，我们的YouTube频道</strong> </a> <strong class="jx io">获取更多类似内容！</strong></p></div></div>    
</body>
</html>