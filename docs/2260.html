<html>
<head>
<title>JavaScript Event Delegation Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript事件委托解释</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-event-delegation-explained-4786685bb21?source=collection_archive---------10-----------------------#2020-06-04">https://javascript.plainenglish.io/javascript-event-delegation-explained-4786685bb21?source=collection_archive---------10-----------------------#2020-06-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="1b48" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">各位编码员好！今天，我将解释JavaScript中一个有用且强大的事件处理概念，称为事件委托。但首先需要一点背景知识。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/57840bc41573950a7ab0694f803ce078.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WwQnAQvUKGTrtb5CxVZfCA.png"/></div></div></figure><h1 id="d3b8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">背景知识:事件捕获和冒泡</h1><p id="893a" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">“onclick”属性通常附加在HTML中的<button>元素上。这个属性允许按钮在有人点击时运行一个事件(函数)。类似于从脚本中添加一个<code class="fe ma mb mc md b">addEventListener()</code>到一个按钮。</button></p><p id="528f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于“onclick”事件处理程序，会发生两个阶段:<strong class="jp ir">捕获</strong>和<strong class="jp ir">冒泡</strong></p><blockquote class="me mf mg"><p id="b191" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">事件捕获:</em> </strong> <em class="iq">浏览器从最顶层的元素&lt; html &gt;开始检查上面的onclick处理程序。如果是，它将在</em> <strong class="jp ir"> <em class="iq">向下</em> </strong> <em class="iq">移动到下一个HTML元素之前运行它，并重复该过程，直到它到达目标(被单击的)元素。又名顶部到目标。</em></p></blockquote><p id="b200" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另一方面，</p><blockquote class="me mf mg"><p id="6c87" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="iq">事件冒泡:</em> </strong> <em class="iq">浏览器从目标(被点击)元素中检查其上的onclick处理程序。如果是，它将在</em> <strong class="jp ir"> <em class="iq">向上</em> </strong> <em class="iq">移动到下一个HTML元素之前运行它，并重复该过程，直到它到达最顶端的元素&lt; html &gt;。又名目标到顶端。</em></p></blockquote><p id="3997" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是对这两个阶段的直观解释</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/24b5c7fcbad5cf834bb3e620bf4d2594.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/0*yKhSWqo4QnOaoAN2"/></div><figcaption class="mm mn gj gh gi mo mp bd b be z dk"><a class="ae mq" href="https://hashnode.com/util/redirect?url=https://miro.medium.com/max/1280/1Et5UjVPGLfF1L43T7ErrxQ.png" rel="noopener ugc nofollow"><em class="mr">miro.medium.com/max/1280/1Et5UjVPGLfF1L43T7..</em></a></figcaption></figure><blockquote class="me mf mg"><p id="5767" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated"><em class="iq">注意:在现代浏览器中，默认情况下，所有的事件处理程序都是为冒泡阶段注册的。来源:</em><a class="ae mq" href="https://hashnode.com/util/redirect?url=https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events" rel="noopener ugc nofollow" target="_blank"><em class="iq">developer.mozilla.org/en-US/docs/Learn/Java..</em></a></p></blockquote><p id="2e30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于这个原因，使用太多的“onclick”处理程序有时会变得混乱，特别是当您有一个事件在一个元素中运行，而该元素的父元素也有“onclick”属性时。即使您不想触发父元素的“onclick ”,它也会被触发。</p><p id="a577" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个问题的解决方案是:</p><ol class=""><li id="eadf" class="ms mt iq jp b jq jr ju jv jy mu kc mv kg mw kk mx my mz na bi translated">请改用<code class="fe ma mb mc md b">addEventListener()</code></li><li id="c441" class="ms mt iq jp b jq nb ju nc jy nd kc ne kg nf kk mx my mz na bi translated">在事件函数中添加<code class="fe ma mb mc md b">event.stopPropagation()</code></li></ol><p id="f46e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这两个阶段看起来很麻烦，但它们并不完全是坏事。事实上，作为一名开发人员，事件捕获和冒泡可以用来实现一种更有效的方式来编写事件处理程序。是的，这种高效的事件处理概念被称为<strong class="jp ir">事件委托</strong>。</p><h1 id="1114" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">事件委托</h1><blockquote class="me mf mg"><p id="4163" class="jn jo mh jp b jq jr js jt ju jv jw jx mi jz ka kb mj kd ke kf mk kh ki kj kk ij bi translated"><em class="iq">一个强大而有效的事件处理模式，当一个父元素中的许多元素将运行同一个事件时使用。</em></p></blockquote><p id="6efa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看一个例子。假设你有一个这样的“待办事项”应用程序:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ng"><img src="../Images/8e1019435b6b62afacb0674268f31661.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9md6YknrAd4fz_ua"/></div></div></figure><p id="90f1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以只在父元素中放置一个事件处理程序，而不是在每个“已完成”按钮中添加一个事件处理程序，以便在单击按钮时删除任务。</p><p id="ffe7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是HTML:</p><pre class="km kn ko kp gt nh md ni nj aw nk bi"><span id="e4ed" class="nl ky iq md b gy nm nn l no np">&lt;div id="task-box"&gt;<br/>    &lt;h2&gt;My Tasks&lt;/h2&gt;<br/>    &lt;div id="task"&gt;<br/>        &lt;button class="done"&gt;COMPLETED&lt;/button&gt;<br/>        &lt;p&gt;9am-10am&lt;/p&gt;<br/>        &lt;p&gt;Walk my dog&lt;/p&gt;<br/>    &lt;/div&gt;<br/>    &lt;div id="task"&gt;<br/>        &lt;button class="done"&gt;COMPLETED&lt;/button&gt;<br/>        &lt;p&gt;10am-12pm&lt;/p&gt;<br/>        &lt;p&gt;Do homework&lt;/p&gt;<br/>    &lt;/div&gt;&lt;div id="task"&gt;<br/>        &lt;button class="done"&gt;COMPLETED&lt;/button&gt;<br/>        &lt;p&gt;12pm-4pm&lt;/p&gt;<br/>        &lt;p&gt;Lunch with friends&lt;/p&gt;<br/>    &lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="c3f6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，代替对每个<code class="fe ma mb mc md b">&lt;button&gt;</code>元素的“onclick”。我们为<code class="fe ma mb mc md b">&lt;div id="task-box"&gt;</code>元素分配了一个“onclick ”,它将检查按钮是否被单击，并运行removeTask()函数从待办事项列表中删除该按钮及其任务。让我们编写代码:</p><pre class="km kn ko kp gt nh md ni nj aw nk bi"><span id="1856" class="nl ky iq md b gy nm nn l no np">document.getElementById("task-box").onclick = function(event) { <br/>       if (event.target &amp;&amp; event.target.matches("button.done")) {<br/>                  removeTask(event.target.parentNode); <br/>       } <br/>});</span></pre><p id="6013" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">结果非常完美:</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/87b738c3dc1b3003e784e69cc6622cd5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*thTtXTHlRGnZJnOhgU4J1w.gif"/></div></figure><h1 id="6188" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">说明</h1><p id="df3e" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">当按钮被点击时，冒泡阶段检查按钮(目标元素)是否有“onclick”。它没有，所以它移动到<div id="“task”">并再次检查。不，它也没有“onclick”，所以它再次上升到<div id="”task-box”">。啊哈！找到一个“onclick ”!因此它将运行函数，该函数检查event.target(被单击的元素)。如果是一个class = "done "的按钮，那么我们将通过调用函数removeTask()移除<div id="“task”">(event . target的parentNode)。</div></div></div></p><h1 id="49b7" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">就是这样！</h1><p id="c291" class="pw-post-body-paragraph jn jo iq jp b jq lv js jt ju lw jw jx jy lx ka kb kc ly ke kf kg lz ki kj kk ij bi translated">我希望这个简单的例子能帮助您理解事件委托是如何工作的，以及它是如何使用事件冒泡/捕获来实现其概念的。这在类似待办事项列表的情况下非常有用，因为元素会不断地被删除和添加。给每个按钮添加一个“onclick”会很麻烦。</p><p id="7a2f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">实现事件委托有许多美妙的用途。我希望你能把它应用到你的项目中。感谢您的阅读，如果您觉得有帮助，请留下“大拇指”让我知道~如果您有任何关于事件捕获/冒泡和事件委托的问题，请不要犹豫，在评论中提问。下次再见，干杯！</p></div></div>    
</body>
</html>