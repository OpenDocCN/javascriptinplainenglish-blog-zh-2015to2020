<html>
<head>
<title>JSX Transformation Explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JSX变换解释道</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-react-uses-jsx-5bc989ebc674?source=collection_archive---------3-----------------------#2020-12-28">https://javascript.plainenglish.io/how-react-uses-jsx-5bc989ebc674?source=collection_archive---------3-----------------------#2020-12-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5062" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">建议在React应用中使用JSX(JavaScript XML)编写HTML。尽管浏览器不能理解JSX语法，因此需要将JSX转换成简单的JavaScript函数。这是一篇关于该主题的深度文章。</h2></div><h2 id="b3e1" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak">内容:</strong></h2><ol class=""><li id="7c2d" class="ky kz in la b lb lc ld le kl lf kp lg kt lh li lj lk ll lm bi translated">简单的"<strong class="la io"> Hello React" </strong> App</li><li id="cd51" class="ky kz in la b lb ln ld lo kl lp kp lq kt lr li lj lk ll lm bi translated"><strong class="la io"> ReactDOM.render()的参数</strong></li><li id="e0ce" class="ky kz in la b lb ln ld lo kl lp kp lq kt lr li lj lk ll lm bi translated">用JSX扩展“<strong class="la io">Hello React”App</strong></li><li id="b4d0" class="ky kz in la b lb ln ld lo kl lp kp lq kt lr li lj lk ll lm bi translated"><strong class="la io"> JSX </strong>变身穿越<strong class="la io">通天塔</strong></li></ol><p id="e8c1" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated"><strong class="la io">先决条件</strong> : JavaScript，用CRA，巴别塔，JSX反应安装设置</p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="fa04" class="mo kd in bd ke mp mq mr kh ms mt mu kk jt mv ju ko jw mw jx ks jz mx ka kw my bi translated">简单的“Hello React”应用程序</h1><p id="d9a0" class="pw-post-body-paragraph ls lt in la b lb lc jo lv ld le jr lx kl mz lz ma kp na mc md kt nb mf mg li ig bi translated">在看JSX之前，让我们首先尝试创建我们的第一个非常简单的React应用程序。我们将通过React在浏览器上呈现“Hello React”。继续创建react应用程序，我们选择<code class="fe nc nd ne nf b"><a class="ae ng" href="https://create-react-app.dev" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="nh">create-react-app</em></strong></a></code>来创建应用程序。现在，创建我们的“Hello React”应用程序就像在<code class="fe nc nd ne nf b">src/index.js</code>编写以下代码一样简单:</p><pre class="ni nj nk nl gt nm nf nn no aw np bi"><span id="b274" class="kc kd in nf b gy nq nr l ns nt">import ReactDOM from 'react-dom';<br/>ReactDOM.render(<br/>"Hello React!",<br/>document.getElementById('root')<br/>)</span></pre><p id="d5dd" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">我们可以在控制台/终端上运行<code class="fe nc nd ne nf b">npm start</code>，在浏览器中看到上面代码的输出。</p><figure class="ni nj nk nl gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi nu"><img src="../Images/1b4d566b00ba9c771361c96929914d44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EA5C2-CesK-ezQBZU5YgYw.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk">Output for above index.js</figcaption></figure></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="a5e1" class="mo kd in bd ke mp mq mr kh ms mt mu kk jt mv ju ko jw mw jx ks jz mx ka kw my bi translated"><strong class="ak"> ReactDOM.render() </strong>的参数</h1><p id="ea6f" class="pw-post-body-paragraph ls lt in la b lb lc jo lv ld le jr lx kl mz lz ma kp na mc md kt nb mf mg li ig bi translated">从上面的代码中我们可以看到，react从一小段代码开始了它的神奇。在这段代码中，我们调用react dom提供的<strong class="la io"> render() </strong>函数。<strong class="la io"> </strong>现在，这个渲染函数，我们可以看到，已经采用了两个参数。让我们检查一下这个函数实际接受的所有参数。</p><p id="78a1" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">如果我们在<code class="fe nc nd ne nf b">node_modules/react-dom/cjs/react-dom.development.js</code>检查代码，我们发现这个函数接受三个参数。</p><pre class="ni nj nk nl gt nm nf nn no aw np bi"><span id="21f1" class="kc kd in nf b gy nq nr l ns nt"><strong class="nf io">ReactDOM</strong>.<strong class="nf io">render(element, container, callback)</strong></span></pre><ol class=""><li id="3610" class="ky kz in la b lb lu ld lw kl og kp oh kt oi li lj lk ll lm bi translated">元素:这是我们想要渲染的主界面。</li><li id="3c3a" class="ky kz in la b lb ln ld lo kl lp kp lq kt lr li lj lk ll lm bi translated"><strong class="la io">容器</strong>:这是元素被渲染的地方，默认为<strong class="la io">根</strong>，但是我们可以更改。</li><li id="6cf6" class="ky kz in la b lb ln ld lo kl lp kp lq kt lr li lj lk ll lm bi translated"><strong class="la io">回调</strong>:这是<strong class="la io">可选</strong>。我们先不要担心这个。</li></ol><p id="422c" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">如果我们在运行react应用程序的同一个浏览器选项卡中打开开发人员控制台，并检查<strong class="la io">元素</strong>选项卡，我们会发现下面的HTML代码。</p><figure class="ni nj nk nl gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi oj"><img src="../Images/b1c84bd48f9a6eec0b8440e715ccd2fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c1a5PIsxgszhGRYmthum8w.png"/></div></div></figure><p id="ac97" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">这里的<code class="fe nc nd ne nf b">&lt;div id="root"&gt;</code>部分是<strong class="la io">容器</strong>而<code class="fe nc nd ne nf b">Hello React!</code>是<strong class="la io">元件</strong>。</p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="d182" class="mo kd in bd ke mp mq mr kh ms mt mu kk jt mv ju ko jw mw jx ks jz mx ka kw my bi translated">用JSX扩展“<strong class="ak">Hello React”App</strong></h1><p id="4021" class="pw-post-body-paragraph ls lt in la b lb lc jo lv ld le jr lx kl mz lz ma kp na mc md kt nb mf mg li ig bi translated">现在回到我们的“Hello React”应用程序。正如我们所知，render函数将第一个参数作为一个元素，这就是我们想要呈现给浏览器的内容。在这里，我们想要呈现复杂的HTML，而不是像前面那样只呈现一个字符串。<strong class="la io"> React推荐使用JSX(JavaScript XML) </strong>来达到同样的效果。让我们稍微改变一下我们的代码来支持JSX，这将帮助我们渲染更多的字符串。</p><pre class="ni nj nk nl gt nm nf nn no aw np bi"><span id="1e37" class="kc kd in nf b gy nq nr l ns nt">import ReactDOM from 'react-dom';<br/>ReactDOM.render(<br/>&lt;div&gt;Hello React!&lt;/div&gt;,<br/>document.getElementById('root')<br/>)</span></pre><p id="001e" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">你注意到没有，<code class="fe nc nd ne nf b">&lt;div&gt;Hello React!&lt;/div&gt;</code>，不是弦，而是JSX。我们来看看浏览器是如何渲染这个的。</p><figure class="ni nj nk nl gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi ok"><img src="../Images/67045db9c4fa47aa2456f18ef0712bc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QXb2ubOioQbY3xN2BySMkQ.png"/></div></div></figure><p id="237e" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">这里的<code class="fe nc nd ne nf b">&lt;div id="root"&gt;</code>部分是<strong class="la io">容器</strong>，<code class="fe nc nd ne nf b">&lt;div&gt;Hello React!&lt;/div&gt;</code>是<strong class="la io">元素</strong>。</p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><h1 id="6831" class="mo kd in bd ke mp mq mr kh ms mt mu kk jt mv ju ko jw mw jx ks jz mx ka kw my bi translated"><strong class="ak"> JSX </strong>变身穿越<strong class="ak">通天塔</strong></h1><p id="0c65" class="pw-post-body-paragraph ls lt in la b lb lc jo lv ld le jr lx kl mz lz ma kp na mc md kt nb mf mg li ig bi translated">让我们更深入地讨论JSX。我们知道浏览器不能理解JSX语法，因此有必要将这个JSX转换成浏览器能够理解的东西。</p><p id="d6c0" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">这个任务是由巴别塔预置和插件完成的。巴别塔会自动出现在我们的应用程序中。如果没有，可以通过npm轻松安装。我们将使用的Babel插件是"<a class="ae ng" href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx" rel="noopener ugc nofollow" target="_blank">@ babel/plugin-transform-react-jsx</a>"</p><p id="cc70" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated"><code class="fe nc nd ne nf b"><a class="ae ng" href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx" rel="noopener ugc nofollow" target="_blank"><strong class="la io">@babel/plugin-transform-react-jsx</strong></a></code> <strong class="la io"> </strong>是react app中负责转换JSX的插件。<strong class="la io">需要注意的一点是，JSX也可以在React应用之外使用</strong>。我们将尝试在没有React应用程序的情况下使用JSX，因为它将帮助我们了解React如何更好地改造JSX。</p><p id="5c4b" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated"><strong class="la io">没有React App的JSX:</strong></p><p id="4398" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">为此，在“Hello React”应用程序主题之外创建一个新文件夹，然后按照给定的步骤操作:<br/> 1。用<code class="fe nc nd ne nf b">npm init</code>命令初始化<code class="fe nc nd ne nf b">package.json</code>文件。<br/> 2。然后让我们安装<code class="fe nc nd ne nf b"><a class="ae ng" href="https://babeljs.io/docs/en/babel-cli" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="nh">@babel/cli</em></strong></a></code>和<code class="fe nc nd ne nf b"><a class="ae ng" href="https://babeljs.io/docs/en/babel-core" rel="noopener ugc nofollow" target="_blank"><strong class="la io"><em class="nh">@babel/core</em></strong></a></code>，带有开发依赖标志。<br/> 3。在<code class="fe nc nd ne nf b">package.json</code>中的<code class="fe nc nd ne nf b">scripts</code>下创建一个名为<code class="fe nc nd ne nf b">build</code>的命令，我们将像<code class="fe nc nd ne nf b">npm run build</code>一样使用它，将命令设为<code class="fe nc nd ne nf b">babel src -d lib</code> <br/> 4。安装<code class="fe nc nd ne nf b">@babel/plugin-transform-react-jsx</code>，如果还没有的话，也使用开发依赖标志</p><p id="b404" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">完成上述所有步骤后，package.json应该看起来像这样:</p><figure class="ni nj nk nl gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi ol"><img src="../Images/997f6844370f84e3f1cb13827a11e844.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SEa4atZAw5ROMjHPMOaD0A.png"/></div></div></figure><p id="c653" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">现在让我们创建与<strong class="la io"> package.json </strong>同级的<strong class="la io"> babel.config.json </strong>文件，并告诉babel使用:</p><h2 id="715d" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak"> <em class="om"> 1。</em> </strong> <strong class="ak"> <em class="om">【插件-转换-反应-jsx】</em></strong><strong class="ak"><em class="om">同经典运行时:</em> </strong></h2><pre class="ni nj nk nl gt nm nf nn no aw np bi"><span id="3299" class="kc kd in nf b gy nq nr l ns nt">{<br/>"plugins": [<br/>         ["@babel/plugin-transform-react-jsx", {<br/>          "runtime": "<strong class="nf io">classic</strong>"<br/>         }]<br/>    ]<br/>}</span></pre><p id="59a1" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated"><code class="fe nc nd ne nf b">@babel/plugin-transform-react-jsx</code>的运行时间默认值也是<strong class="la io">经典</strong>。但这将从巴别塔8开始改为"<strong class="la io">自动</strong>"运行时。</p><p id="82cb" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">接下来，让我们创建<code class="fe nc nd ne nf b">src/index.js</code>并使用以下内容:</p><pre class="ni nj nk nl gt nm nf nn no aw np bi"><span id="be2b" class="kc kd in nf b gy nq nr l ns nt">let c = 9;<br/>const jsxExpr = &lt;div className="test"&gt;<br/>&lt;p onClick={() =&gt; console.log('click')}&gt;{c}&lt;/p&gt;<br/>&lt;/div&gt;;</span></pre><p id="4671" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">下面是JSX表达式。</p><p id="db9f" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">接下来，我们需要构建我们的项目。还记得我们在<strong class="la io"> package.json </strong>中创建了一个<strong class="la io"> build </strong> <strong class="la io">命令</strong>吗？现在是时候使用它了。我们可以使用<code class="fe nc nd ne nf b">npm run build</code>运行该命令，这将运行<code class="fe nc nd ne nf b">babel src -d lib</code>，这意味着<strong class="la io"> babel将对</strong> <code class="fe nc nd ne nf b"><strong class="la io">src</strong></code> <strong class="la io">文件夹中的所有文件进行处理，并将输出放在名为</strong> <code class="fe nc nd ne nf b"><strong class="la io">lib</strong></code> <strong class="la io">的目标文件夹中。</strong></p><p id="f2ce" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">现在让我们在终端中运行<code class="fe nc nd ne nf b">npm run build</code>并检查<code class="fe nc nd ne nf b">lib</code>文件夹中的输出。<code class="fe nc nd ne nf b">lib/index.js</code>应该是这样的:</p><figure class="ni nj nk nl gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi on"><img src="../Images/04260c24d9ede1aabc9c2506216bde2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u1s-IzPb6nEbVR9rlp8dgA.png"/></div></div></figure><p id="b0ea" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">这里我们可以看到JSX现在被替换成了<strong class="la io"> React.createElement </strong>函数。如果我们想检查它如何在浏览器上工作。让我们在<code class="fe nc nd ne nf b">src</code>文件夹中创建一个HTML文件。</p><p id="f829" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated"><strong class="la io"> src/index.html </strong></p><pre class="ni nj nk nl gt nm nf nn no aw np bi"><span id="a804" class="kc kd in nf b gy nq nr l ns nt">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>&lt;meta charset="UTF-8" /&gt;<br/>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;<br/>&lt;title&gt;JSX without React App&lt;/title&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>&lt;div id="root"&gt;&lt;/div&gt;<br/>&lt;script src="../lib/index.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="9090" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">让我们用Chrome浏览器打开它，我们不会在浏览器上看到任何东西，所以让我们检查开发者控制台，<strong class="la io">控制台</strong>选项卡。这里，我们将看到一个错误，即<strong class="la io">反应</strong>未定义。这是意料之中的，因为它不是React应用程序。</p><p id="2136" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">如果我们想在没有React应用程序的情况下使用JSX，我们可以告诉babel使用我们的自定义函数，而不是<strong class="la io"> React.createElement函数</strong>。为此，我们可以将<code class="fe nc nd ne nf b">src/index.js</code>的内容替换为:</p><pre class="ni nj nk nl gt nm nf nn no aw np bi"><span id="21bf" class="kc kd in nf b gy nq nr l ns nt">/** @jsx jsxCallback */</span><span id="2c5c" class="kc kd in nf b gy oo nr l ns nt">let c = 9;</span><span id="b5c3" class="kc kd in nf b gy oo nr l ns nt">const jsxCallback = (tag, props, children) =&gt; {<br/>console.log({<br/>"tag": tag,<br/>"props": props,<br/>"children": children<br/>})<br/>}</span><span id="4076" class="kc kd in nf b gy oo nr l ns nt">const jsxExpr = &lt;div className="test"&gt;<br/>&lt;p onClick={() =&gt; console.log('click')}&gt;{c}&lt;/p&gt;<br/>&lt;/div&gt;;</span></pre><p id="6257" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated"><strong class="la io"> /** @jsx jsxCallback */ </strong>会让巴别知道<strong class="la io"> jsxCallback </strong>是它需要替换jsx表达式的函数。这也被称为<strong class="la io">杂注。</strong> <br/>由于我们正在使用<strong class="la io"> classic </strong>运行时，如果我们不提供这个<strong class="la io"> pragma注释</strong>，那么它将默认为<strong class="la io"> React.createElement </strong>函数。</p><p id="284b" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">做了这个修改后，我们需要再次运行<code class="fe nc nd ne nf b">npm run build</code>，让我们在<code class="fe nc nd ne nf b">lib/index.js</code>中检查结果。它应该看起来像:</p><figure class="ni nj nk nl gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi op"><img src="../Images/73acd4aa71a686a286edd4a29d1ded06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*M3ESIKx_v7s2GvUxEHkxug.png"/></div></div></figure><p id="b4a2" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">在这里，如果我们仔细观察，我们的JSX表达式已经被<strong class="la io"> jsxCallback </strong>函数所取代。</p><p id="487d" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">现在，如果我们试图用Chrome浏览器打开我们的<code class="fe nc nd ne nf b">src/index.html</code>文件。我们在浏览器上仍然看不到任何东西，但是让我们检查一下开发者控制台，<strong class="la io">控制台</strong>选项卡，它看起来应该是这样的:</p><figure class="ni nj nk nl gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi oq"><img src="../Images/aa0e2a72fde15e153ed2bd339e48d017.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81ljoe9RE-saWN4vbT-eXA.png"/></div></div></figure><p id="23c9" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">正如我们在这里看到的，详细信息如预期的那样打印在我们的控制台中。此时，我们只有在<strong class="la io"> jsxCallback </strong>函数中将JSX值打印到控制台的代码。我们当然可以改变它，使它能够创建HTML标签并将其附加到DOM。</p><h2 id="e9e8" class="kc kd in bd ke kf kg dn kh ki kj dp kk kl km kn ko kp kq kr ks kt ku kv kw kx bi translated"><strong class="ak"> <em class="om"> 2。带自动运行时的插件-转换-反应-jsx:</em></strong></h2><p id="990d" class="pw-post-body-paragraph ls lt in la b lb lc jo lv ld le jr lx kl mz lz ma kp na mc md kt nb mf mg li ig bi translated">随着React 17的发布，React最近引入了另一个运行时。为了检查它，我们需要在<strong class="la io"> babel.config.json </strong>文件中将我们的运行时值从<code class="fe nc nd ne nf b">classic</code>改为<code class="fe nc nd ne nf b">automatic</code>。</p><pre class="ni nj nk nl gt nm nf nn no aw np bi"><span id="5532" class="kc kd in nf b gy nq nr l ns nt">"plugins": [<br/>   ["@babel/<!-- -->plugin-transform-react-jsx<!-- -->", {<br/>          "runtime": "<strong class="nf io">automatic</strong>"<br/>   }]<br/>]}</span></pre><p id="6bd7" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">让我们把<code class="fe nc nd ne nf b">src/index.js</code>里面的内容改回:</p><pre class="ni nj nk nl gt nm nf nn no aw np bi"><span id="1af9" class="kc kd in nf b gy nq nr l ns nt">let c = 9;<br/>const jsxExpr = &lt;div className="test"&gt;<br/>&lt;p onClick={() =&gt; console.log('click')}&gt;{c}&lt;/p&gt;<br/>&lt;/div&gt;;</span></pre><p id="66c1" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">做了这个修改后，我们需要再次运行<code class="fe nc nd ne nf b">npm run build</code>，让我们在<code class="fe nc nd ne nf b">lib/index.js</code>中检查结果。它应该看起来像:</p><figure class="ni nj nk nl gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi or"><img src="../Images/36eca2d600921dea3d5f01cdf9295cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4KRnRTYlxBWccJwOn4fh2A.png"/></div></div></figure><p id="29ad" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">这里JSX被转换成从<code class="fe nc nd ne nf b">react/jsx-runtime</code>导入的<strong class="la io"> _jsx </strong> <strong class="la io">函数调用</strong>。</p><p id="d9b4" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">使用<strong class="la io">自动</strong>运行时，我们不能像使用<strong class="la io">经典</strong>运行时那样使用<code class="fe nc nd ne nf b"><strong class="la io">@jsx</strong></code>来调用我们的自定义函数，但是我们可以使用<code class="fe nc nd ne nf b"><strong class="la io">@jsxImportSource</strong></code> <strong class="la io">杂注</strong>来导入我们的自定义模块，而不是使用<strong class="la io">反应</strong>。因此，如果我们将<code class="fe nc nd ne nf b"><strong class="la io">/** @jsxImportSource myOwnJSX */</strong></code> <strong class="la io"> </strong>放在代码的顶部，并再次运行<code class="fe nc nd ne nf b">npm run build</code>，那么<code class="fe nc nd ne nf b">lib/index.js</code>将看起来像这样:</p><figure class="ni nj nk nl gt nv gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi os"><img src="../Images/00cfe6c70314ccd8a16234fdacc474c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5KTF_zTZobumWotZfzcU_g.png"/></div></div></figure><p id="804a" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">这里JSX被转换成从<code class="fe nc nd ne nf b">myOwnJSX/jsx-runtime</code>导入的<strong class="la io"> _jsx </strong> <strong class="la io">函数调用</strong>。</p><p id="9ee8" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated"><strong class="la io">React App中的JSX:</strong></p><p id="dbbc" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">每个React内部的应用程序都将使用<code class="fe nc nd ne nf b">@babel/plugin-transform-react-jsx</code>巴别塔插件进行JSX转换。<br/>现在回到“Hello React”应用程序，我们可以说当我们写<code class="fe nc nd ne nf b">&lt;div&gt;Hello React!&lt;/div&gt;</code>时，它翻译成</p><pre class="ni nj nk nl gt nm nf nn no aw np bi"><span id="2b08" class="kc kd in nf b gy nq nr l ns nt">/*#__PURE__*/React.createElement("div", null, "Hello React!");</span></pre><p id="3c70" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated"><strong class="la io">或</strong></p><pre class="ni nj nk nl gt nm nf nn no aw np bi"><span id="2080" class="kc kd in nf b gy nq nr l ns nt">import { jsx as _jsx } from "react/jsx-runtime";</span><span id="10ee" class="kc kd in nf b gy oo nr l ns nt">const jsxExpr = /*#__PURE__*/_jsx("div", {<br/>   children: "Hello React!"<br/>});</span></pre><p id="021f" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">如果你正在使用<code class="fe nc nd ne nf b">create-react-app 4.0.0+</code>，那么JSX变换将使用<strong class="la io">自动</strong>运行时完成。</p><p id="58a0" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated">有关<strong class="la io">自动运行时</strong>的更多信息，请查看<a class="ae ng" href="https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html" rel="noopener ugc nofollow" target="_blank">新JSX变换介绍</a>，这将有助于理解他们为什么要推出新JSX变换，做了哪些更改等等。详细地说。</p></div><div class="ab cl mh mi hr mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ig ih ii ij ik"><p id="83f8" class="pw-post-body-paragraph ls lt in la b lb lu jo lv ld lw jr lx kl ly lz ma kp mb mc md kt me mf mg li ig bi translated"><strong class="la io">感谢阅读。关于这个话题的任何问题/建议都欢迎评论。:)</strong></p></div></div>    
</body>
</html>