# “哑”角度—输入设置器/获取器与 NgOnChanges

> 原文：<https://javascript.plainenglish.io/dumb-angular-input-setter-getter-vs-ngonchanges-f30e61937926?source=collection_archive---------1----------------------->

## 有角度的尖端

## 了解通过 NgOnChanges 和输入绑定向非智能角度组件传递数据的正确方法。

![](img/ca2230c6f7f3b0f9a093b9a12fcaed8a.png)

Dumb

# 组件如何在角度上相互作用

角度组件有多种方式与应用程序的其他部分共享信息。开发一个复杂的 Angular 应用程序将涉及大量的数据，以及随后组件之间的大量交互。

一旦你学会了在组件中处理数据的方法，就很容易为不同的用例进行复制。

然而，有三种主要的方法来拦截数据变更，并且很容易假设所有的方法都是相同的。在简单的情况下，比如当您只需要监听更新的值时，它们可以表现得非常相似。

但是在某些情况下，每种方法都比其他方法更适合手头的任务。

使用的方法有:

*   **@输入设置器和获取器**
*   **恩贡奇斯**
*   一项服务

如题所示，我们将集中讨论**前两个，**我们将讨论它们在 Angular 中不同情况下的各自适用性。

# 角度中的哑分量

> 如果你没有听说过 Angular 中的哑组件…你可能会认为我在侮辱 Angular 或它的组件。我不是…

Angular 中哑组件的想法是创建像纯函数一样工作的**组件。也就是说，它们的内部状态和行为只受输入和输出的控制。没有副作用和外部数据源，如服务、API 或本地存储。**

哑组件通常是我们的应用程序的极简 UI/表示容器，其中考虑了大小和复杂性，并尽可能地减少。

> 因此,“智能”组件应该是在构造函数中注入了服务依赖的组件，或者是连接到 API 或本地存储的组件。他们倾向于控制而不是仅仅在场。

**依赖性通过增加的业务逻辑和数据处理增加了膨胀和复杂性**。这些依赖关系会影响性能，因此最好组织和设计应用程序，让更多的组件被认为是愚蠢的，而不是“聪明的”。

> 哑组件旨在轻量级和相对简单，与“智能”组件相反，后者更像是控制器，处理更复杂的逻辑，倾向于与应用程序的核心进行更多的交互。

## 哑组件是可重用的

没有依赖关系的组件是 Angular 中你可以创建的最可重用的东西。组件是组织和分组 DOM 中相互接近的相关功能的好方法。

当你考虑将组件转换成可重用的哑组件时，想想**布局组件**，比如列表、导航条和演示卡。

这些是您可以在应用程序中重用的组件，提供了定制每个实例的美学和行为的能力，以适应特定的用例/主题。

> [Angular 素材库](https://material.angular.io/)充满了开源的哑组件，在这里你可以提供自己的数据来定制它们的默认行为。

## 哑 vs 智能决定组件交互

向哑组件提供数据是通过使用@Input 绑定，而不是注入服务。

试图重用一个有服务依赖的组件将意味着你也必须注入那些服务，并在父组件中与它们交互，这在项目中不起作用。

这就是为什么**哑组件只通过输入和输出进行交互。**

# 1) NgOnChanges

NgOnChanges 是 Angular 提供的一个生命周期钩子，可以由 Angular 组件通过`OnChanges`接口实现。

这将公开一种方法来侦听父组件提供的对子组件的数据绑定输入属性的更改。

## 何时使用 OnChanges

*   当你想把逻辑组织在一起时
*   当数据改变逻辑和功能依赖于来自任何其它输入的改变时。
*   您需要知道以前和当前的值(更改后)，和/或它是否是第一次更改。

我个人喜欢在一个函数中处理输入的所有变化，当我有很多输入需要考虑的时候。

> NgOnChanges 让您更全面地了解组件中的数据是如何变化的

带有`SimpleChanges`参数的 NgOnChanges 实现提供了一个参数，使您不必编写和跟踪中间值。

## NgOnChanges 对可读性更好

如果我有一个开始变得复杂或庞大的组件，甚至在考虑处理输入更改之前，我可能会使用 NgOnChanges 来处理数据更改。

使用 NgOnChanges 而不是输入 Setter/getter 避免了由于输入 Setter/getter 的冗长而对可读性造成的额外影响。

考虑到中间值和更改逻辑，您实际上为每个输入设置器/获取器添加了大约 6 行。

## 使用 NgOnChanges 的示例

本例要求 NgOnChanges 根据`likeState`值触发角度动画`likeState()`。因此，我们需要截取`likes`和`liked`值，使用最新的`uid`来确定父组件上的喜好状态。

> 这里使用 NgOnChanges 的原因是**如果它是第一个变化**，我们希望跳过“喜欢”动画，这意味着用户实际上没有喜欢任何东西，组件正在初始化，默认状态是基于初始数据设置的。

Like button with NgOnChanges

## 与 NgOnChanges 无关的事情

不要忽略`SimpleChanges`。如果您忽略 Angular 在 NgOnChanges 接口中提供的这个参数，您就忽略了确定发生了什么变化的最简单的方法，包括它的“前后”值。

您选择实现 NgOnChanges 的主要原因是为了倾听和响应这些变化，所以忽略它们意味着您不需要 NgOnChanges。

如果不使用 SimpleChanges 参数，您将不得不自己跟踪组件中以前的值，这看起来会很混乱，另外，当您要努力战胜 Angular 实现时，重新发明那个特殊的轮子是没有意义的。

# 2)输入设置器和获取器

在子组件中提供了一个输入 decorated，让 Angular 知道它可以从父组件接收一个值。因此，父节点负责使用语法`<ngx-child-component [user]="userObj"></ngx-child-component>`向子节点提供一个值，输入为`user`。

## 何时使用

*   你有少量的输入

**加…**

*   当你只想孤立地聆听变化时
*   对组件的更改不依赖于其他输入的值
*   你不需要`SimpleChanges`提供的信息。

## 正交输入数据的获取器和设置器

将 getters 和 setters 与@Input 绑定结合使用是处理少量互不依赖的输入的最简单、最直观的方式。

使用 getters 和 setters，您仍然可以通过截取来控制更改。

然而，当您有这么多输入时，为您的输入数据编写 getters & setters 会变得重复和冗长。此外，您无法全面了解组件数据的所有更改，只能了解特定输入的新旧值(来自中间值)。

## 我们之前的例子…但是使用输入设置器/获取器

要了解使用输入 Setter/Getter 和 NgOnChanges 之间的真正区别，让我们看看我们在前面的例子中遇到的问题，使用 Setter/Getter 方法重新实现…

Like button with Input Getters/Setters

正如你所看到的，这个版本更加冗长，而且当我们试图确定这是他们对`uid`还是`likes`的第一次变更时，我们会陷入困境，如果是这样的话，我们可以跳过动画。

当然，您可以编写一些代码来保存一个值，该值表示每个输入经历的变化次数，但是我们应该为此使用 NgOnChanges。

# 使用@Input 和 NgOnChanges 时要记住什么

## 了解角度变化检测的工作原理

请记住，在某些情况下，无论使用何种方法，Angular 都不会检测到输入数据的变化。

一种情况是当您将**更改检测策略**设置为`OnPush`时。

```
@Component({
   selector: 'ngx-app-component',
   templateUrl: './app.component.html',
   styleUrls: ['./app.component.scss'],
   changeDetection: ChangeDetectionStrategy.*OnPush*
})
```

用 OnPush 配置组件意味着在某些情况下，数据绑定输入不会触发更改检测。

这些情况是当您正在处理一个对象，并且只有一个嵌套属性发生了更改。这里，**输入绑定和 NgOnChanges 都不会被触发，因为没有对底层对象引用**进行修改。

如果您将一个非基本对象向下传递给一个子组件，并对嵌套属性进行更改，通常会出现这种情况。这将保留对象的引用。

对于硬编码的值，您经常会遇到这种情况，硬编码的值是指那些不是来自异步流的值，比如可观察值或承诺值。

## 那么我应该使用默认的变化检测吗？

嗯，不一定。

如果你要使用 Angular 的默认变化检测机制，**直接对象突变将被允许**，因此没有提供新引用的对象变化将被检测到。

但是，您可能熟悉 OnPush 行为的好处及其相关的性能提升。

因此，对于某些应用程序来说，这不仅仅是说“我将只使用默认的变化检测”那么简单。从长远来看，理解 OnPush 的复杂性是值得的。这意味着可以使用 OnPush 而不会遇到缺点。

## 如何确保变更检测按预期工作

在整个应用程序中端到端地使用 Observables 使您的应用程序真正具有反应性。

这也是确保 Angular 检测数据变化的一种方法。使用 Observable，您可以访问异步管道，该管道可用于将数据传递给子组件。**当异步管道发出对数据的更改时，它自动标记组件以检测更改**。

因此，就变更检测而言，主要是硬编码对象需要格外小心。

## 小费

为了让你的应用到处都是可反应的，你总是可以用**将值包装在一个行为主体** **中，就像** `new BehaviorSubject({firstName: ‘John', lastName: 'Doe'});`，**用** `.next({firstName: 'Jane', lastName: 'Doe'});`控制变化，并且用`.asObservable();`将值作为可观察的提供给你的组件**。**

**感谢阅读！有任何问题，请在评论中告诉我。**