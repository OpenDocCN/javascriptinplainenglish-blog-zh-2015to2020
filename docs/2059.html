<html>
<head>
<title>Containerize your Angular Apps with Dockers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Dockers容器化你的Angular应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/containerize-your-angular-apps-with-dockers-40cb231bb990?source=collection_archive---------10-----------------------#2020-05-16">https://javascript.plainenglish.io/containerize-your-angular-apps-with-dockers-40cb231bb990?source=collection_archive---------10-----------------------#2020-05-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d2bd" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><em class="kc">了解如何为Angular </em> ⛴构建轻量级和可移植的软件容器</h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/874bc38fd7025d81181d13707fdfe1cb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*diskeq7g5jHhOKN_dwIqmw.png"/></div></div></figure><p id="a6a5" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在这篇文章中，我们来看看这个示例项目，并一步一步地了解如何将Angular应用程序与作为服务器的node js封装在一起。</p><ul class=""><li id="583a" class="ll lm in kr b ks kt kv kw ky ln lc lo lg lp lk lq lr ls lt bi translated"><strong class="kr io"> <em class="lu">什么是码头工人？</em> </strong></li><li id="e438" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated"><strong class="kr io"> <em class="lu">容器化你的棱角App </em> </strong></li><li id="c9f8" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated"><strong class="kr io"> <em class="lu">在Docker上运行应用</em> </strong></li><li id="152d" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated"><strong class="kr io"> <em class="lu">多级Docker构建</em> </strong></li><li id="c5a6" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated"><strong class="kr io"> <em class="lu">结论</em> </strong></li></ul><h1 id="6a98" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">什么是码头工人？⚓🚤 ⛴</h1><blockquote class="ms mt mu"><p id="8729" class="kp kq lu kr b ks kt jo ku kv kw jr kx mv kz la lb mw ld le lf mx lh li lj lk ig bi translated">Docker是一个工具，旨在通过使用容器来简化应用程序的创建、部署和运行。容器允许开发人员将应用程序与它需要的所有部分打包在一起，比如库和其他依赖项，并作为一个包进行部署。</p></blockquote><p id="94bc" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">简而言之，Docker使我们的应用程序完全可移植，因此它们可以在任何环境中运行。有了dockers的帮助，我们再也不用担心庞大的包或库依赖了。即插即用。Docker是用<a class="ae my" href="https://golang.org/" rel="noopener ugc nofollow" target="_blank"> Go </a>编写的，它利用了Linux内核的几个特性来提供它的功能。</p><h1 id="6a61" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">容器化角度应用</h1><p id="b853" class="pw-post-body-paragraph kp kq in kr b ks mz jo ku kv na jr kx ky nb la lb lc nc le lf lg nd li lj lk ig bi translated">闲聊够了！让我们开始创建docker容器。在本文中，我们将使用一个我很久以前构建的简单的角度应用程序。如果您愿意，也可以使用您的应用程序，并按照正确的顺序执行这些步骤。</p><p id="882c" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">首先，我们将从我的存储库中克隆项目:</p><pre class="ke kf kg kh gt ne nf ng nh aw ni bi"><span id="8b0a" class="nj mb in nf b gy nk nl l nm nn"><a class="ae my" href="https://github.com/ahmedkhan1/ng-content-projection.git" rel="noopener ugc nofollow" target="_blank">https://github.com/ahmedkhan1/ng-content-projection.git</a></span></pre><p id="3b2f" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">现在您已经在本地目录中获得了项目，确保您已经安装了所有必需的依赖项。在这种情况下，它的角和节点js。</p><p id="3cbc" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">如果安装了所有的依赖项，请打开终端并在项目的根目录中键入以下命令。</p><pre class="ke kf kg kh gt ne nf ng nh aw ni bi"><span id="44e2" class="nj mb in nf b gy nk nl l nm nn">ng build --prod</span></pre><p id="0a5b" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">该命令将创建一个名为<strong class="kr io"> dist </strong>的新文件夹，其中将包含项目中所有已编译的文件。</p><p id="d0fa" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">下一步是创建一个<strong class="kr io"> docker文件</strong>。</p><h2 id="dcb8" class="nj mb in bd mc no np dn mg nq nr dp mk ky ns nt mm lc nu nv mo lg nw nx mq ny bi translated">Docker文件</h2><p id="1741" class="pw-post-body-paragraph kp kq in kr b ks mz jo ku kv na jr kx ky nb la lb lc nc le lf lg nd li lj lk ig bi translated"><strong class="kr io"> dockerfile </strong>是一个文本文档，包含用户可以用来从<strong class="kr io"> Docker Hub </strong>获取Docker图像的所有命令/步骤。</p><h2 id="56f6" class="nj mb in bd mc no np dn mg nq nr dp mk ky ns nt mm lc nu nv mo lg nw nx mq ny bi translated">Docker图像</h2><p id="e09d" class="pw-post-body-paragraph kp kq in kr b ks mz jo ku kv na jr kx ky nb la lb lc nc le lf lg nd li lj lk ig bi translated">Docker图像只是包含创建Docker容器所需的所有信息的模板。我们可以创建自己的docker图片，也可以使用其他人创建并发布在Docker Hub上的图片，Docker Hub是Docker图片的公共注册中心。</p><p id="e704" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在项目的根目录下创建名为<code class="fe nz oa ob nf b">Dockerfile</code>的docker文件，然后输入以下几行:</p><pre class="ke kf kg kh gt ne nf ng nh aw ni bi"><span id="06ab" class="nj mb in nf b gy nk nl l nm nn"><strong class="nf io">FROM</strong> nginx:1.17.1-alpine<br/><strong class="nf io">COPY</strong> /dist/ng-content /usr/share/nginx/html</span></pre><p id="dead" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这些命令执行以下操作:</p><ul class=""><li id="6167" class="ll lm in kr b ks kt kv kw ky ln lc lo lg lp lk lq lr ls lt bi translated"> 中的<strong class="kr io"> <em class="lu">将指示docker前往Docker Hub并获取特定的Nginx docker映像</em></strong></li><li id="c9d9" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated"><strong class="kr io"> <em class="lu"> Copy </em> </strong>后面跟一个路径会简单的把那个图像复制粘贴到指定的路径。</li></ul><p id="a52b" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">回到终端，键入以下命令</p><pre class="ke kf kg kh gt ne nf ng nh aw ni bi"><span id="5ca4" class="nj mb in nf b gy nk nl l nm nn">docker image ls</span></pre><p id="9492" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">该命令将显示当前本地系统中所有可用的图像。目前，它不会显示任何内容。</p><p id="f71d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">接下来，键入以下命令来构建容器。</p><pre class="ke kf kg kh gt ne nf ng nh aw ni bi"><span id="3a67" class="nj mb in nf b gy nk nl l nm nn">docker build -t docker-app-image</span></pre><p id="92a2" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这里:</p><ul class=""><li id="0516" class="ll lm in kr b ks kt kv kw ky ln lc lo lg lp lk lq lr ls lt bi translated"><strong class="kr io"> -t </strong>标志用于指示docker使用标签</li><li id="6f3c" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated">在<strong class="kr io"> -t </strong>标志旁边，我们将键入容器的名称。</li></ul><p id="4981" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">输入上面的命令后，检查本地可用的docker图像。</p><pre class="ke kf kg kh gt ne nf ng nh aw ni bi"><span id="392a" class="nj mb in nf b gy nk nl l nm nn">docker image ls</span><span id="74a6" class="nj mb in nf b gy oc nl l nm nn"><strong class="nf io">REPOSITORY</strong>        <strong class="nf io">TAG</strong>            <strong class="nf io">IMAGE ID </strong>     <br/>docker-app-image  latest         a160a7494a19      <br/>nginx             1.17.1-alpine  ea1193fd3dde</span></pre><p id="bd15" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">如您所见，我们已经成功获取了docker映像。</p><p id="d002" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这里:</p><ul class=""><li id="df33" class="ll lm in kr b ks kt kv kw ky ln lc lo lg lp lk lq lr ls lt bi translated">存储库名称是图像名称</li><li id="5ce6" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated">标签只是用来区分它</li><li id="d867" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated">图像id是每个docker图像拥有的ID。它可以用来删除这个图像</li></ul><p id="9eb9" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">现在要运行映像，只需运行以下命令:</p><pre class="ke kf kg kh gt ne nf ng nh aw ni bi"><span id="10db" class="nj mb in nf b gy nk nl l nm nn">docker run --name docker-app-container -d -p 8080:80 docker-app-image</span></pre><p id="6547" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这里:</p><ul class=""><li id="d32d" class="ll lm in kr b ks kt kv kw ky ln lc lo lg lp lk lq lr ls lt bi translated"><code class="fe nz oa ob nf b">run</code>用于引用容器的开始。</li><li id="ebc6" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated"><code class="fe nz oa ob nf b">- -name</code>用于为容器命名，在本例中为<strong class="kr io"> docker-app-container </strong></li><li id="c7de" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated"><code class="fe nz oa ob nf b">-d</code>标志将保持容器在后台运行。</li><li id="8c3c" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated"><code class="fe nz oa ob nf b">-p 8080:80</code>用于你映射容器端口到你的本地，80是Nginx服务器。</li><li id="b8cc" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated">最后，在最后，您将提供可供使用的图像的名称。</li></ul><p id="e94c" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">现在让我们检查可用的容器。</p><pre class="ke kf kg kh gt ne nf ng nh aw ni bi"><span id="2bc0" class="nj mb in nf b gy nk nl l nm nn">docker container ls</span><span id="9821" class="nj mb in nf b gy oc nl l nm nn"><strong class="nf io">CONTAINER ID</strong>  <strong class="nf io">IMAGE  </strong>           <strong class="nf io">STATUS         NAMES</strong><br/>2523d9f77cf6  docker-app-image  Up 10 minutes  docker-app-container</span></pre><p id="b8d9" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><code class="fe nz oa ob nf b">docker ps -a</code>显示运行和停止的容器。</p><p id="c4ef" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><code class="fe nz oa ob nf b">docker stats --all</code>显示所有容器的列表，默认显示刚运行的。</p><p id="1d33" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我们已经成功地创建了docker的容器，并让它运行起来。这不是最有效的方法，但是我们可以通过简单地将<code class="fe nz oa ob nf b">build - -prod</code>命令传递到docker构建中来提高效率。这将使过程更加自动化和干净。</p><p id="1269" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">为了实现这一点，我们将不得不使用所谓的<a class="ae my" href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io">多级Docker构建</strong> </a> <strong class="kr io">。</strong></p><h1 id="6bb6" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated">多级码头建造</h1><p id="b4d0" class="pw-post-body-paragraph kp kq in kr b ks mz jo ku kv na jr kx ky nb la lb lc nc le lf lg nd li lj lk ig bi translated">通过多阶段构建，您现在可以在docker文件中使用多个<code class="fe nz oa ob nf b">FROM</code>语句。每条<code class="fe nz oa ob nf b">FROM</code>指令可以使用不同的基础，并且它们中的每一条都开始了构建的新阶段。因此，基本上我们将docker文件分成几个阶段，通过这种方法，我们可以将一个阶段的结果用于另一个阶段。</p><h2 id="965a" class="nj mb in bd mc no np dn mg nq nr dp mk ky ns nt mm lc nu nv mo lg nw nx mq ny bi translated">第一步:</h2><p id="fc7a" class="pw-post-body-paragraph kp kq in kr b ks mz jo ku kv na jr kx ky nb la lb lc nc le lf lg nd li lj lk ig bi translated">在这个阶段，我们将把我们的Angular应用程序代码编译成一个生产就绪的代码。</p><h2 id="35f9" class="nj mb in bd mc no np dn mg nq nr dp mk ky ns nt mm lc nu nv mo lg nw nx mq ny bi translated">第二步:</h2><p id="499f" class="pw-post-body-paragraph kp kq in kr b ks mz jo ku kv na jr kx ky nb la lb lc nc le lf lg nd li lj lk ig bi translated">接下来，我们将在docker映像中运行它。</p><p id="e4fa" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">为了编译Angular源代码，我们将使用包含<a class="ae my" href="https://hub.docker.com/_/node/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>的Docker image。</p><pre class="ke kf kg kh gt ne nf ng nh aw ni bi"><span id="fe3f" class="nj mb in nf b gy nk nl l nm nn"><strong class="nf io">FROM</strong> node:12.7-alpine <strong class="nf io">AS</strong> build<br/><strong class="nf io">WORKDIR</strong> /usr/src/app<br/><strong class="nf io">COPY</strong> package.json ./<br/><strong class="nf io">RUN</strong> npm install<br/><strong class="nf io">COPY</strong> . .<br/><strong class="nf io">RUN</strong> npm run build</span></pre><p id="9dda" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这里:</p><ul class=""><li id="9f3d" class="ll lm in kr b ks kt kv kw ky ln lc lo lg lp lk lq lr ls lt bi translated"><code class="fe nz oa ob nf b">FROM</code>正在从Docker Hub中获取<em class="lu">节点</em>的Docker映像，并且也是在多阶段Docker构建中，我们现在可以使用关键字<code class="fe nz oa ob nf b">AS</code>来命名每个阶段，在本例中该阶段被命名为<code class="fe nz oa ob nf b">build</code>。现在，我们可以在下一阶段参考它。</li><li id="1b1f" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated"><code class="fe nz oa ob nf b">WORKDIR</code>设置默认工作目录。</li><li id="5229" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated"><code class="fe nz oa ob nf b">COPY</code>正在从本地项目根目录复制<code class="fe nz oa ob nf b">package.json</code>文件，其中包含我们的应用程序需要的所有依赖项。</li><li id="e511" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated"><code class="fe nz oa ob nf b">RUN</code>安装库。</li><li id="699e" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated"><code class="fe nz oa ob nf b">COPY</code>用源代码复制所有剩余的文件。</li><li id="3630" class="ll lm in kr b ks lv kv lw ky lx lc ly lg lz lk lq lr ls lt bi translated"><code class="fe nz oa ob nf b">RUN</code>将运行构建命令来编译我们的应用程序。</li></ul><p id="fbc1" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">现在让我们创建一个名为<code class="fe nz oa ob nf b">.dockerignore</code>的文件。在这里，我们可以定义希望Docker忽略的文件和文件夹。</p><pre class="ke kf kg kh gt ne nf ng nh aw ni bi"><span id="7e25" class="nj mb in nf b gy nk nl l nm nn">dist<br/>node_modules</span></pre><p id="a386" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">现在，我们最终的docker文件将如下所示:</p><pre class="ke kf kg kh gt ne nf ng nh aw ni bi"><span id="cc77" class="nj mb in nf b gy nk nl l nm nn"><em class="lu">### STAGE No 1: Build ###</em><br/><strong class="nf io">FROM</strong> node:12.7-alpine <strong class="nf io">AS</strong> build<br/><strong class="nf io">WORKDIR</strong> /usr/src/app<br/><strong class="nf io">COPY</strong> package.json ./<br/><strong class="nf io">RUN</strong> npm install<br/><strong class="nf io">COPY</strong> . .<br/><strong class="nf io">RUN</strong> npm run build</span><span id="c011" class="nj mb in nf b gy oc nl l nm nn"><em class="lu">### STAGE No 2: Run ###</em><br/><strong class="nf io">FROM</strong> nginx:1.17.1-alpine<br/><strong class="nf io">COPY</strong> --from=build /usr/src/app/dist/ng-content /usr/share/nginx/html</span></pre><p id="e70d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在上面的代码中，您可以看到在阶段2中，我们引用了在步骤1中使用<code class="fe nz oa ob nf b">As</code>分配的名称build的阶段1。这将告诉Docker从阶段<code class="fe nz oa ob nf b">build</code>复制所有文件。</p><p id="888d" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">现在让我们创建新的图像:</p><pre class="ke kf kg kh gt ne nf ng nh aw ni bi"><span id="7dcc" class="nj mb in nf b gy nk nl l nm nn">docker build -t docker-app-multistage-image</span></pre><p id="a3e4" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">最后，在不同的端口上运行应用程序。</p><pre class="ke kf kg kh gt ne nf ng nh aw ni bi"><span id="20f8" class="nj mb in nf b gy nk nl l nm nn">docker run --name docker-app-multistage-container -d -p 8888:80 docker-app-multistage-image</span></pre><p id="4d97" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">现在进入浏览器，输入<a class="ae my" href="http://localhost:8080/" rel="noopener ugc nofollow" target="_blank"> http://localhost:8888/ </a>你会看到它正在运行！</p></div><div class="ab cl od oe hr of" role="separator"><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi oj"/><span class="og bw bk oh oi"/></div><div class="ig ih ii ij ik"><h1 id="de28" class="ma mb in bd mc md ok mf mg mh ol mj mk jt om ju mm jw on jx mo jz oo ka mq mr bi translated">结论🎉</h1><blockquote class="ms mt mu"><p id="66c6" class="kp kq lu kr b ks kt jo ku kv kw jr kx mv kz la lb mw ld le lf mx lh li lj lk ig bi translated">我希望这篇文章对您有所帮助，如果您有，<strong class="kr io"> <em class="in">请关注我的</em> </strong> <a class="ae my" href="https://medium.com/@mrahmedkhan019" rel="noopener"> <strong class="kr io"> <em class="in">中型</em> </strong> </a> <strong class="kr io"> <em class="in">和</em></strong><a class="ae my" href="https://twitter.com/50shadeofkhan" rel="noopener ugc nofollow" target="_blank"><strong class="kr io"><em class="in">Twitter</em></strong></a><strong class="kr io"><em class="in">以获取更多关于软件开发文章的通知，不要忘记点击</em> </strong>。终于！感谢阅读，快乐学习！</p></blockquote><div class="op oq gp gr or os"><a href="https://medium.com/javascript-in-plain-english/angular-regime-series-tree-shaking-technique-3dc07f5e85a1" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd io gy z fp ox fr fs oy fu fw im bi translated">树木倾斜地摇晃着</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">用温柔的方式，你可以撼动世界！</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg kn os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://medium.com/javascript-in-plain-english/a-deep-dive-into-web-components-3f7d6713da9e" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd io gy z fp ox fr fs oy fu fw im bi translated">对Web组件的深入研究</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">在本文中，我们将深入研究Web组件，并了解为什么前端开发人员迫切需要…</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="ph l pd pe pf pb pg kn os"/></div></div></a></div><div class="op oq gp gr or os"><a href="https://medium.com/@mrahmedkhan019/angular-regime-series-a-guide-to-change-detection-strategy-2a8a4da46c5c" rel="noopener follow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd io gy z fp ox fr fs oy fu fw im bi translated">角度范围系列:变化检测策略指南</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">开发可持续变化的应用程序！</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">medium.com</p></div></div><div class="pb l"><div class="pi l pd pe pf pb pg kn os"/></div></div></a></div><h1 id="3f2d" class="ma mb in bd mc md me mf mg mh mi mj mk jt ml ju mm jw mn jx mo jz mp ka mq mr bi translated"><strong class="ak">简明英语笔记</strong></h1><p id="cf9f" class="pw-post-body-paragraph kp kq in kr b ks mz jo ku kv na jr kx ky nb la lb lc nc le lf lg nd li lj lk ig bi translated">你知道我们推出了一个YouTube频道吗？我们制作的每个视频都旨在教给你一些新的东西。点击 点击<a class="ae my" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io">查看我们，并确保订阅该频道😎</strong></a></p></div></div>    
</body>
</html>