<html>
<head>
<title>Test styled components in React efficiently using ‘displayName’</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用“displayName”有效反应中的测试样式组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/test-styled-components-in-react-efficiently-using-displayname-53281a0c1f2d?source=collection_archive---------5-----------------------#2020-04-04">https://javascript.plainenglish.io/test-styled-components-in-react-efficiently-using-displayname-53281a0c1f2d?source=collection_archive---------5-----------------------#2020-04-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="12a3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何摆脱测试快照中风格怪异的组件名称</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/8937cf174a795ca463b5e5971d15cafa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y-oM9MNUF4cpZ-G8f0V_3A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Created using powerpoint</figcaption></figure><h1 id="99ce" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">介绍</h1><p id="7257" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">如果你练习了<a class="ae mg" href="https://en.wikipedia.org/wiki/Test-driven_development" rel="noopener ugc nofollow" target="_blank"> TDD </a>并且在你的React应用程序中使用了<a class="ae mg" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="lm io">风格的组件</strong> </a>，这个帖子可能适合你。</p><p id="4b99" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">这需要一些关于单元测试的先前知识反应代码。如果你想了解单元测试的基础，请在这里查看<a class="ae mg" href="https://link.medium.com/pRGrZSUWp5" rel="noopener"/>。</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><h2 id="6030" class="mt kt in bd ku mu mv dn ky mw mx dp lc lt my mz le lx na nb lg mb nc nd li ne bi translated">开始吧</h2><p id="8eab" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">相关代码示例请参见<a class="ae mg" href="https://github.com/anuk79/UnitTestingReactWithStyledComponents" rel="noopener ugc nofollow" target="_blank"> github </a>。如果需要，可以克隆存储库以进行后续操作。有两个文件夹具有相同的示例，其中一个使用displayName作为样式化组件，而另一个则不使用。我们将从不包含displayName的代码开始，以了解这些问题。</p><p id="6e20" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">请在此处查看代码-<a class="ae mg" href="https://github.com/anuk79/UnitTestingReactWithStyledComponents/tree/master/src/pages/without-display-name/user" rel="noopener ugc nofollow" target="_blank">https://github . com/anuk79/unittestingreactvertyledccomponents/tree/master/src/pages/无显示名称/用户</a></p><p id="2a12" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">主组件是<strong class="lm io"> user.jsx </strong>，它使用了一些样式化的组件。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nf"><img src="../Images/50e79f55112833cc87f42028a602aa53.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0vkHdUVql_uYnaWRXwUIvg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">code in user.jsx</figcaption></figure><p id="8765" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">样式化元件档案包含下列程式码:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ng"><img src="../Images/33eda83d556f42aa691e0bb8828de406.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C3ivWL1LZ751DXMx83kv1g.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">code in user.styled.js</figcaption></figure><h1 id="ee72" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">问题陈述</h1><p id="a84b" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">在单元测试时，当我们浅渲染<strong class="lm io">用户</strong>组件并生成快照时，我们将不会得到样式化组件的确切名称，相反，我们得到如下内容:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nh"><img src="../Images/d7f7adcc0121f62e0da9de5e2897f700.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_Yo7yD4vnGyafKM1hBvhA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">snapshot generated when not using displayName</figcaption></figure><p id="2495" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated"><strong class="lm io">我们的预期</strong>加载pinnerstyle，ErrorStyled</p><p id="f778" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated"><strong class="lm io">实际生成的东西</strong>:Styled(loading pinner)，styled.div</p><h2 id="cd39" class="mt kt in bd ku mu mv dn ky mw mx dp lc lt my mz le lx na nb lg mb nc nd li ne bi translated">这对单元测试过程有何影响？</h2><p id="f90a" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">当我们尝试为任何断言遍历组件树，并且目标组件是样式化组件时，我们不能简单地使用使用样式化组件名称的直接方法。</p><p id="8239" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">让我们假设<strong class="lm io">包装</strong>是<strong class="lm io">用户</strong>组件的浅渲染输出，并且我们试图测试<strong class="lm io">加载pinnerStyled </strong>组件是否确实存在于<strong class="lm io">用户</strong>组件中。所以我们根本不能做如下的事情:</p><p id="9361" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated"><code class="fe ni nj nk nl b">expect(wrapper.find('LoadingSpinnerStyled').length).toBe(1);</code></p><p id="9902" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">然而，如果我们将<strong class="lm io">loading pinnerstyled</strong>组件导入到我们的测试文件中，我们可以如下进行测试:</p><p id="8152" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated"><code class="fe ni nj nk nl b">expect(wrapper.find(LoadingSpinnerStyled).length).toBe(1);</code></p><p id="45c0" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">请注意，在上面的语句中，组件名称周围没有单引号。这意味着我们使用实际的组件来遍历组件树，而不仅仅是名称(这是使用enzyme的好处之一)。</p><p id="d0bb" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">或者，如果我们想要避免那些额外的导入到测试文件中，我们将不得不测试如下的代码:</p><p id="a33d" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated"><code class="fe ni nj nk nl b">expect(wrapper.find('Styled(LoadingSpinner)').length).toBe(1);</code></p><p id="0da0" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">那么，如果你想避免这两种可能的情况，该怎么做呢:</p><ol class=""><li id="9fa3" class="nm nn in lm b ln mh lq mi lt no lx np mb nq mf nr ns nt nu bi translated">测试文件中所有相关样式组件的显式导入</li><li id="58b3" class="nm nn in lm b ln nv lq nw lt nx lx ny mb nz mf nr ns nt nu bi translated">使用不太明显的标识符来遍历生成的组件树中的样式化组件</li></ol><h1 id="83be" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">解决办法</h1><p id="04dc" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">正如本文的标题所示，我们可以通过为所有样式化的组件指定<strong class="lm io">显示名称</strong>来解决上述所有问题。</p><p id="b2bc" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">您可以通过在每个组件旁边添加一行来分配显示名称，如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oa"><img src="../Images/4990701c12a20eead245cda1b8412ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_rCynUDfSGKzy0tso90Txg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">user.styled.js</figcaption></figure><p id="598c" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">现在，当组件被浅渲染时，请看输出:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nh"><img src="../Images/9e7f38ef943677b58158e3705ff8d651.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aANfRk41vo9vLlwPWdRR-w.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">snapshot generated after using displayName for styled components</figcaption></figure><p id="9c8d" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">它现在包含了我们想要的名字，并且使快照和单元测试更具可读性和可维护性。</p><p id="4e53" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">查看这里的代码—<a class="ae mg" href="https://github.com/anuk79/UnitTestingReactWithStyledComponents/tree/master/src/pages/with-display-name/user" rel="noopener ugc nofollow" target="_blank">https://github . com/anuk 79/UnitTestingReactWithStyledComponents/tree/master/src/pages/with-display-name/user</a></p><h1 id="8114" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">结论</h1><p id="4737" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">React提供的<strong class="lm io"> displayName </strong>是一个推荐的特性，对单元测试和代码调试有很大帮助。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ob"><img src="../Images/5f3153c1d53bd86cbdbb96bc19afea04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*coazRcNf9_rk3CQvv9erQQ.png"/></div></div></figure><h1 id="eee4" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">参考</h1><p id="c034" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">点击<a class="ae mg" href="https://hackernoon.com/improving-component-names-in-react-developer-tools-4894247510c5" rel="noopener ugc nofollow" target="_blank">https://hacker noon . com/improving-component-names-in-react-developer-tools-4894247510 C5</a>了解更多关于<strong class="lm io"> displayName </strong>的信息</p></div><div class="ab cl mm mn hr mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="ig ih ii ij ik"><p id="6dc4" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">感谢阅读。我希望这有所帮助。如果您有任何问题或建议，请随时回复。</p><p id="0b10" class="pw-post-body-paragraph lk ll in lm b ln mh jo lp lq mi jr ls lt mj lv lw lx mk lz ma mb ml md me mf ig bi translated">祝你学习愉快，度过愉快的一天！</p></div></div>    
</body>
</html>