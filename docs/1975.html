<html>
<head>
<title>How to Refactor Your Complex Nested ‘if-else’ Code?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何重构你复杂的嵌套‘if-else’代码？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-refactor-your-complex-nested-if-else-code-28aa162047d5?source=collection_archive---------2-----------------------#2020-05-09">https://javascript.plainenglish.io/how-to-refactor-your-complex-nested-if-else-code-28aa162047d5?source=collection_archive---------2-----------------------#2020-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2295" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">写出更好的代码并获得更多薪水的3个技巧。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a398a735c303915ad08c4423703d5c20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*f-8mZlNnlhXTFCuO"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9b25" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很多程序员在维护老项目的时候都遇到过各种嵌套的if-else语句。面对这样一堆乱七八糟的代码，简单地继续进行增量更改通常只会使代码越来越复杂，可读性越来越差。</p><p id="b591" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么如何解决这个问题呢？这里和大家分享三个简单又通用的重构方法，希望对你有帮助。</p><h1 id="7c46" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">嵌套if-else</h1><p id="11b0" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">先说初级程序员经常写的一段代码:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6f3a" class="mu lt iq mq b gy mv mw l mx my">function demo (a, b, c) {<br/>  if (f(a, b, c)) {<br/>    if (g(a, b, c)) {<br/>      // ...<br/>    }<br/>    // ...<br/>    if (h(a, b, c)) {<br/>      // ...<br/>    }<br/>  }</span><span id="376e" class="mu lt iq mq b gy mz mw l mx my">if (j(a, b, c)) {<br/>    // ...<br/>  }</span><span id="0aca" class="mu lt iq mq b gy mz mw l mx my">if (k(a, b, c)) {<br/>    // ...<br/>  }<br/>}</span></pre><p id="5eda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用流程图显示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/5c8bd7e3adfe1fbe0decfc29e01d95b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SoMzO4c7naGZmLcn"/></div></div></figure><p id="dfa3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个类型<code class="fe nb nc nd mq b">if…if</code>代码。它通过从上到下嵌套<code class="fe nb nc nd mq b">if</code>来保持控制流在单个函数中增长。你可能认为这段代码的复杂性会随着<code class="fe nb nc nd mq b">if</code>的数量线性增加，但事实并非如此。我们知道函数处理数据，每个<code class="fe nb nc nd mq b">if</code>通常都有处理数据的逻辑。因此，即使没有嵌套，如果你有3个<code class="fe nb nc nd mq b">if</code>，那么你就有<code class="fe nb nc nd mq b">2^3 = 8</code>个数据状态，这取决于每个<code class="fe nb nc nd mq b">if</code>是否被执行。如果你有6个<code class="fe nb nc nd mq b">if</code>，那么你就有<code class="fe nb nc nd mq b">2⁶=64</code>个状态。于是，当项目规模扩大时，函数的调试难度会成倍增加！</p><p id="ad11" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了<code class="fe nb nc nd mq b">if...if</code>，<code class="fe nb nc nd mq b">else if … else if</code>也很常见。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3a8e" class="mu lt iq mq b gy mv mw l mx my">function demo (a, b, c) {<br/>  if (f(a, b, c)) {<br/>    if (g(a, b, c)) {<br/>      // ...<br/>    }<br/>    // ...<br/>    else if (h(a, b, c)) {<br/>      // ...<br/>    }<br/>    // ...<br/>  } else if (j(a, b, c)) {<br/>    // ...<br/>  } else if (k(a, b, c)) {<br/>    // ...<br/>  }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/755121b3a122fc0e1e42201d9707b094.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eUgpcBj_HNi5v3QX"/></div></div></figure><p id="de8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nb nc nd mq b">else if</code>最终只会进入这些分支中的一个，所以之前没有所谓的组合爆炸。但是，在深度嵌套时，复杂度也不低。假设我们有三个嵌套层，每个层中有三个<code class="fe nb nc nd mq b">else if</code>，那么我们有<code class="fe nb nc nd mq b">3 ^ 3 = 27</code>个出口。如果每个出口对应于一种处理数据的方式，那么将如此多的逻辑封装在一个函数中也明显违反了单一责任原则。</p><p id="2bbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，上述两种类型可以无缝结合，进一步增加了复杂性，降低了可读性。</p><p id="547f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想成为一名高级程序员，总有一天你会面临如此复杂的业务逻辑。那你是做什么的？</p><h1 id="a7de" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">技巧1:分解函数</h1><p id="f3ef" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于<code class="fe nb nc nd mq b">if… if</code>代码，我们可以将其拆分成多个子功能。下图中的每个绿框代表一个新的拆分功能:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/89d75d4168db9bc4ddf5e91e57c8ec23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tJfvAmiroQ6KIz_s"/></div></div></figure><p id="9cc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为现代编程语言取消了<code class="fe nb nc nd mq b">goto</code>，不管控制流有多复杂，函数体中的执行顺序总是从上到下。因此，在不改变原有控制流逻辑的情况下，我们完全有能力将单个大函数从上到下分离出来，逐步划分成几个小函数，然后逐个调用。</p><p id="599e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们可以将一个有64种状态的大函数拆分成6个只返回2种不同状态的小函数，以及一个一个调用它们的主函数。结果，每个函数的复杂度的增长率从指数级降低到线性级。</p><p id="6b1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样，我们已经解决了<code class="fe nb nc nd mq b">if…if</code>代码，那么<code class="fe nb nc nd mq b">else if … else if</code>类型呢？</p><h1 id="271c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">提示2:查找表</h1><p id="9672" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">对于<code class="fe nb nc nd mq b">else if … else if</code>代码，最简单的重构策略之一是使用查找表。它以键-值对的形式封装了每个<code class="fe nb nc nd mq b">else if</code>中的逻辑:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d7cf" class="mu lt iq mq b gy mv mw l mx my">const rules = {<br/>  x: function (a, b, c) { /* ... */ },<br/>  y: function (a, b, c) { /* ... */ },<br/>  z: function (a, b, c) { /* ... */ }<br/>}</span><span id="fff5" class="mu lt iq mq b gy mz mw l mx my">function demo (a, b, c) {<br/>  const action = determineAction(a, b, c)<br/>  return rules[action](a, b, c)<br/>}</span></pre><p id="8da2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个<code class="fe nb nc nd mq b">else if</code>中的逻辑被重写为一个独立的函数，因此我们可以将流程拆分如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/20b9bd97dcfe273c97663f836ab28a90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6vQ7UleHoyL9hj4l"/></div></div></figure><h1 id="b707" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Tips3:责任链模式</h1><p id="ccc8" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在前面的部分中，查找表是用键-值对实现的，在简单确定每个分支是<code class="fe nb nc nd mq b">else if (x === ‘foo’)</code>的情况下，<code class="fe nb nc nd mq b">‘foo’</code>可以用作重构集的键。但是如果每个<code class="fe nb nc nd mq b">else if</code>分支包含复杂的条件判断，需要它们的执行顺序，我们可以使用责任链模式来更好地重构这样的逻辑。</p><p id="e758" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe nb nc nd mq b">else if</code>，请注意每个分支实际上都是从上到下，最后只在一个分支中结束。这意味着我们可以通过存储一组决策规则来实现这种行为。如果规则匹配，则执行对应于该规则的分支。我们称这个数组为“责任链”，这种模式下的执行流程如下所示:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/b689db41268b2305d5cc81e61a2920ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U4tb35bgYNWfmcWHOfIs6w.png"/></div></div></figure><p id="b77c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就代码实现而言，我们可以通过一系列责任链来定义完全等同于<code class="fe nb nc nd mq b">else if</code>的规则:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="72e6" class="mu lt iq mq b gy mv mw l mx my">const rules = [<br/>  {<br/>    match: function (a, b, c) { /* ... */ },<br/>    action: function (a, b, c) { /* ... */ }<br/>  },<br/>  {<br/>    match: function (a, b, c) { /* ... */ },<br/>    action: function (a, b, c) { /* ... */ }<br/>  },<br/>  {<br/>    match: function (a, b, c) { /* ... */ },<br/>    action: function (a, b, c) { /* ... */ }<br/>  }<br/>  // ...<br/>]</span></pre><p id="5ecc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nb nc nd mq b">rules</code>中的每一项都有<code class="fe nb nc nd mq b">match</code>和<code class="fe nb nc nd mq b">action</code>属性。此时，如果要遍历责任链的数组，我们可以重写else函数:</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="438b" class="mu lt iq mq b gy mv mw l mx my">function demo (a, b, c) {<br/>  for (let i = 0; i &lt; rules.length; i++) {<br/>    if (rules[i].match(a, b, c)) {<br/>      return rules[i].action(a, b, c)<br/>    }<br/>  }<br/>}</span></pre><p id="9ba1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个责任一旦匹配，函数就直接返回，和<code class="fe nb nc nd mq b">else if</code>语义一模一样。这样，我们就实现了单体复合体<code class="fe nb nc nd mq b">else if</code>逻辑的分离。</p><h2 id="0d62" class="mu lt iq bd lu nf ng dn ly nh ni dp mc lf nj nk me lj nl nm mg ln nn no mi np bi translated"><strong class="ak">简明英语团队的一份说明</strong></h2><p id="66f4" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你知道我们有四种出版物吗？给他们一个关注来表达爱意:<a class="ae kv" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="ky ir">JavaScript in Plain English</strong></a><a class="ae kv" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="ky ir">AI in Plain English</strong></a><a class="ae kv" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ky ir">UX in Plain English</strong></a><a class="ae kv" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ky ir">Python in Plain English</strong></a><strong class="ky ir"/>——谢谢，继续学习！</p><p id="520e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">此外，我们总是有兴趣帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kv" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">submissions @ plain English . io</strong></a><strong class="ky ir"/>，附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>