<html>
<head>
<title>Dynamic component styles in Nuxt using Tailwind CSS and Lookup tables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nuxt中使用顺风CSS和查找表的动态组件样式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dynamic-component-styles-in-nuxt-using-tailwind-css-and-lookup-tables-a86f9f487e2b?source=collection_archive---------2-----------------------#2020-09-25">https://javascript.plainenglish.io/dynamic-component-styles-in-nuxt-using-tailwind-css-and-lookup-tables-a86f9f487e2b?source=collection_archive---------2-----------------------#2020-09-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2b886439af4ab3d75d6f1e1ed2abeba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T_hcmB1rqcLypOuTR_Zlkg.png"/></div></div></figure><p id="d44f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">本文将假设一些Nuxt / Vue的知识</em></p><h1 id="1143" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">顺风、顺风和顺风</h1><p id="9127" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">顺风CSS是目前前端开发中最热门的话题之一。由Adam Wathan创建的实用优先的CSS框架，在过去的几年中，它已经从一个辅助项目发展成为一个成功的企业。如果您曾经使用过Tailwind，您可能会意识到它在构建时利用PurgeCSS来删除未使用的样式，并创建一个仅由web应用程序中使用的类组成的细长样式表。许多框架现在利用PurgeCSS在构建时从产品样式表中删除不必要的内容，您也可以在Nuxt中使用它。当在Nuxt中创建新项目并选择顺风预设时，PurgeCSS将被自动安装，尽管您可以使用<code class="fe ma mb mc md b">nuxt-purgecss</code>构建模块在任何项目中使用它。</p><p id="0881" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">PurgeCSS是一个很棒的插件，但是，它不能解析或运行JavaScript，并且在大多数情况下只在构建时使用。因此，如果使用不当，可能会导致开发和生产环境之间出现意外的不一致。</p><h1 id="dcda" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">用Tailwind CSS启动一个新的Nuxt项目</h1><p id="f676" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">让我们开始创建一个全新的Nuxt安装，打开您的终端并运行以下命令:</p><p id="7801" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe ma mb mc md b">npx create-nuxt-app &lt;your-project-name&gt;</code></p><p id="2a5f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，我们将使用默认设置，而不是从UI框架中选择Tailwind CSS。</p><h1 id="1cb0" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">带顺风的Nuxt中的动态组件样式</h1><p id="63e5" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Nuxt (Vue)中组件的一个关键特性是能够传递道具。道具是传递给组件的自定义属性，可用于控制外观和功能。让我们看看如何使用Tailwind创建一个简单的按钮组件，它接受两种颜色，“主要”和“次要”:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="e3cd" class="mm ky iq md b gy mn mo l mp mq">&lt;template&gt;<br/>    &lt;button <br/>        class="px-4 py-2 text-center transition-colors duration-300 ease-in-out border border-solid rounded shadow-md"<br/>        :class="{ <br/>            'bg-blue-800 text-white border-blue-800 hover:bg-transparent hover:text-blue-800 hover:border-blue-800' : color == 'primary',<br/>            'bg-transparent text-blue-800 border-blue-800 hover:bg-blue-800 hover:text-white hover:border-blue-800' : color == 'secondary'<br/>        }"<br/>    &gt;<br/>        &lt;slot /&gt;<br/>    &lt;/button&gt;<br/>&lt;/template&gt;</span><span id="a0a2" class="mm ky iq md b gy mr mo l mp mq">&lt;script&gt;<br/>    export default {<br/>        name: 'component--button',</span><span id="3777" class="mm ky iq md b gy mr mo l mp mq">        props: {<br/>            color: {<br/>                required: false,<br/>                type: String,<br/>                default: 'primary',<br/>                validator: value =&gt; {<br/>                    return ['primary', 'secondary'].includes(value)<br/>                }<br/>            }<br/>        }<br/>    }<br/>&lt;/script&gt;</span></pre><p id="d3b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，我们的按钮组件接受2种动态颜色，“主要”和“次要”，正如我们所设定的那样，然而，即使在这个简单的组件中，也很容易看到这些动态样式如何在更复杂的组件中失控。我们也有一个颜色道具验证器，我们必须手动与模板中的动态样式保持同步。</p><h1 id="564d" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">提取样式并保持验证器与查找表同步</h1><p id="8ae3" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">如果您没有听说过查找表，查找表是一个简单的键-值对对象，我们可以用它来匹配键和数据。我们可以利用查找表来提取动态样式，并确保我们的验证器始终与这些动态样式保持同步。</p><p id="0a42" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这个例子，我们将在项目的根目录下创建一个名为<code class="fe ma mb mc md b">validators</code>的新文件夹来存储我们的查找表，尽管如果愿意，也可以使用相同的技术来利用组件文件中的查找表。一旦你创建了一个名为<code class="fe ma mb mc md b">validators</code>的新文件夹，在里面创建一个名为<code class="fe ma mb mc md b">Button.js</code>的新文件。在<code class="fe ma mb mc md b">Button.js</code>中，我们将导出一个名为<code class="fe ma mb mc md b">ButtonColors</code>的<code class="fe ma mb mc md b">const</code>，一个包含动态样式的键值对的查找表，如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="7540" class="mm ky iq md b gy mn mo l mp mq">export const ButtonColors = {<br/>    'primary': 'bg-blue-800 text-white border-blue-800 hover:bg-transparent hover:text-blue-800 hover:border-blue-800',<br/>    'secondary': 'bg-transparent text-blue-800 border-blue-800 hover:bg-blue-800 hover:text-white hover:border-blue-800'<br/>}</span></pre><p id="8828" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经将动态样式提取到一个查找表中，我们需要对组件进行一些更改，首先，在开始的脚本标签下，我们需要导入我们的<code class="fe ma mb mc md b">ButtonColors const</code>:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="b654" class="mm ky iq md b gy mn mo l mp mq">&lt;script&gt;<br/>import { ButtonColors } from '~/validators/Button'</span><span id="7125" class="mm ky iq md b gy mr mo l mp mq">export default {/**/}<br/>&lt;/script&gt;</span></pre><p id="9aff" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来在我们的<code class="fe ma mb mc md b">color</code> props验证器中，用来自<code class="fe ma mb mc md b">ButtonColors</code>查找表的一个键数组替换这个数组:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="9b0c" class="mm ky iq md b gy mn mo l mp mq">/**/<br/>validator: (value) =&gt; {<br/>    return Object.keys(ButtonColors).includes(value)<br/>},<br/>/**/</span></pre><p id="0078" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们可以创建一个计算属性来处理组件模板中的动态类:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="a2f5" class="mm ky iq md b gy mn mo l mp mq">&lt;script&gt;<br/>/**/<br/>export default {<br/>    /**/<br/>    computed: {<br/>        buttonColor(){<br/>            return ButtonColors[this.color]<br/>        },<br/>    }<br/>}<br/>&lt;/script&gt;</span></pre><p id="80b7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，我们可以用新的计算属性替换模板中的所有动态类:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="f32a" class="mm ky iq md b gy mn mo l mp mq">&lt;template&gt;<br/>    &lt;button <br/>        class="px-4 py-2 text-center transition-colors duration-300 ease-in-out border border-solid rounded shadow-md"<br/>        :class="[buttonColor]"<br/>    &gt;<br/>        &lt;slot /&gt;<br/>    &lt;/button&gt;<br/>&lt;/template&gt;</span></pre><p id="18dd" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">总之，这应该给我们一个组件模板，如下所示:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="da81" class="mm ky iq md b gy mn mo l mp mq">&lt;template&gt;<br/>    &lt;button <br/>        class="px-4 py-2 text-center transition-colors duration-300 ease-in-out border border-solid rounded shadow-md"<br/>        :class="[buttonColor]"<br/>    &gt;<br/>        &lt;slot /&gt;<br/>    &lt;/button&gt;<br/>&lt;/template&gt;</span><span id="bc7c" class="mm ky iq md b gy mr mo l mp mq">&lt;script&gt;<br/>    import { ButtonColors } from '~/validators/Button'</span><span id="70ab" class="mm ky iq md b gy mr mo l mp mq">    export default {<br/>        name: 'component--button',</span><span id="9434" class="mm ky iq md b gy mr mo l mp mq">        props: {<br/>            color: {<br/>                required: false,<br/>                type: String,<br/>                default: 'primary',<br/>                validator: value =&gt; {<br/>                    return Object.keys(ButtonColors).includes(value)<br/>                }<br/>            }<br/>        },</span><span id="ce02" class="mm ky iq md b gy mr mo l mp mq">        computed: {<br/>            buttonColor() {<br/>                return ButtonColors[this.color]<br/>            },<br/>        }<br/>    }<br/>&lt;/script&gt;</span></pre><p id="e534" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一切看起来都很好，我们的动态样式被提取，我们的验证器将自动与我们添加的任何新的动态样式保持同步，然而不幸的是，目前我们的组件仍然不会像生产中预期的那样进行样式化。幸运的是，有一个非常简单的修复，从项目的根打开<code class="fe ma mb mc md b">tailwind.config.js</code>并在<code class="fe ma mb mc md b">purge</code>对象中，找到<code class="fe ma mb mc md b">content</code>数组并添加<code class="fe ma mb mc md b">'validators/*.js'</code>，这将告诉PurgeCSS检查我们的validators文件夹中的样式，我们最终的<code class="fe ma mb mc md b">purge</code>对象应该看起来像这样:</p><pre class="me mf mg mh gt mi md mj mk aw ml bi"><span id="3d54" class="mm ky iq md b gy mn mo l mp mq">purge: {<br/>    // Learn more on https://tailwindcss.com/docs/controlling-file-size/#removing-unused-css<br/>    enabled: process.env.NODE_ENV === 'production',<br/>    content: [<br/>        'components/**/*.vue',<br/>        'layouts/**/*.vue',<br/>        'pages/**/*.vue',<br/>        'plugins/**/*.js',<br/>        'validators/*.js',<br/>        'nuxt.config.js'<br/>    ]<br/>}</span></pre><h1 id="8b09" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">结论</h1><p id="2178" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">希望您发现这是一个在Nuxt、Tailwind和PurgeCSS中清理动态类的有用练习。</p><p id="5844" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你觉得这篇文章有用，请在<a class="ae ms" href="https://medium.com/@wearethreebears" rel="noopener">媒体</a>、<a class="ae ms" href="https://dev.to/wearethreebears" rel="noopener ugc nofollow" target="_blank">开发人员</a>和/或<a class="ae ms" href="https://twitter.com/wearethreebears" rel="noopener ugc nofollow" target="_blank">推特</a>上关注我。</p></div></div>    
</body>
</html>