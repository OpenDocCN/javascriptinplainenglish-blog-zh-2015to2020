<html>
<head>
<title>Node.js Tips — Closing Sockets, Writing Responses, and Parsing HTML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—关闭套接字、编写响应和解析HTML</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-closing-sockets-writing-responses-and-parsing-html-c46ecdf8b66b?source=collection_archive---------10-----------------------#2020-07-19">https://javascript.plainenglish.io/node-js-tips-closing-sockets-writing-responses-and-parsing-html-c46ecdf8b66b?source=collection_archive---------10-----------------------#2020-07-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/85b8e2a3ce4af773ba1e5a87e2c2028f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dBdGYcCBD5JG1XY1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@tekton_tools?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tekton</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="b5df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="a610" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">记录npm安装命令的输出</h1><p id="0bf1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了记录<code class="fe me mf mg mh b">npm install</code>命令的输出，我们可以将stderr路由到stdout。</p><p id="2675" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c2e9" class="mq lc iq mh b gy mr ms l mt mu">npm install 2&gt;&amp;1 | tee log.txt</span></pre><p id="4a3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">2&gt;&amp;1</code>将stderr路由到stdout。</p><p id="b5d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">tee</code>读取标准输出，并将其写入标准输出和一个或多个文件。</p><p id="dc59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们按照命令中的指定写入<code class="fe me mf mg mh b">log.txt</code>。</p><h1 id="9805" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Node.js和XPath解析页面</h1><p id="6773" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了用XPaths解析HTML，我们用<code class="fe me mf mg mh b">parse5</code>解析HTML。</p><p id="872e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它不把它解析成一个DOM对象，但是它很快并且符合W3C标准。</p><p id="754d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">xmlserializer</code>将其序列化为XHTML，</p><p id="f7f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后可以使用<code class="fe me mf mg mh b">xmldom</code>来获取DOM。</p><p id="9a40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">xpath</code>库来进行XPath查询。</p><p id="236d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2ec6" class="mq lc iq mh b gy mr ms l mt mu">const fs = require('mz/fs');<br/>const xpath = require('xpath');<br/>const parse5 = require('parse5');<br/>const xmlSer = require('xmlserializer');<br/>const DOMParser = require('xmldom').DOMParser;</span><span id="e204" class="mq lc iq mh b gy mv ms l mt mu">(async () =&gt; {<br/>  const html = await fs.readFile('./foo.html');<br/>  const document = parse5.parse(html.toString());<br/>  const xhtml = xmlSer.serializeToString(document);<br/>  const doc = new DOMParser().parseFromString(xhtml);<br/>  const select = xpath.useNamespaces({<br/>    x: "http://www.w3.org/1999/xhtml"<br/>  });<br/>  const nodes = select("/html/body/header/div/div[1]/a[2]", doc);<br/>  console.log(nodes);<br/>})();</span></pre><p id="8729" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入<code class="fe me mf mg mh b">fs</code>库来读取<code class="fe me mf mg mh b">foo.htmk</code>文件。</p><p id="1eb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将带有<code class="fe me mf mg mh b">parse5</code>的文档解析成一个<code class="fe me mf mg mh b">document</code>对象。</p><p id="cd0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">xmlserializer</code>的<code class="fe me mf mg mh b">serializeToString</code>方法将HTML转换成XHTML。</p><p id="bf2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们通过解析转换后的字符串来创建一个新的<code class="fe me mf mg mh b">DOMParser</code>实例。</p><p id="58e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们用<code class="fe me mf mg mh b">userNamespace</code>方法创建一个<code class="fe me mf mg mh b">select</code>对象，让我们通过XPath选择DOM元素。</p><p id="b4fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">select</code>通过XPath选择元素。</p><p id="4e1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">doc</code>是从<code class="fe me mf mg mh b">DOMParser</code>返回的DOM对象。</p><p id="bb09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">nodes</code>有返回的节点。</p><p id="27a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用<code class="fe me mf mg mh b">libxmljs</code>库通过XPath获取节点。</p><p id="da60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ed29" class="mq lc iq mh b gy mr ms l mt mu">const libxmljs = require("libxmljs");<br/>const xml =  `<br/>&lt;?xml version="1.0" encoding="UTF-8"?&gt;'<br/>&lt;root&gt;<br/>  &lt;child foo="bar"&gt;<br/>    &lt;grandchild baz="foo"&gt;some content&lt;/grandchild&gt;<br/>  &lt;/child&gt;<br/>  &lt;sibling&gt;with content!&lt;/sibling&gt;<br/>&lt;/root&gt;`;</span><span id="e1ff" class="mq lc iq mh b gy mv ms l mt mu">const xmlDoc = libxmljs.parseXml(xml);<br/>const gchild = xmlDoc.get('//grandchild');<br/>console.log(gchild.text())</span></pre><p id="01a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过向<code class="fe me mf mg mh b">parsXml</code>方法传递一个XML字符串来使用<code class="fe me mf mg mh b">libxmljs</code>。</p><p id="d04e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用传递一个XPath字符串给<code class="fe me mf mg mh b">get</code>方法来获取项目。</p><p id="3e0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且<code class="fe me mf mg mh b">text</code>将具有所选节点的文本，即<code class="fe me mf mg mh b">some content</code>。</p><h1 id="a49a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Node.js Webserver中的结束后写入错误</h1><p id="d5ab" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们使用<code class="fe me mf mg mh b">net</code>模块创建一个web服务器，那么当我们写一个消息时，我们必须传入一个回调函数作为第二个参数来调用它的<code class="fe me mf mg mh b">end</code>。</p><p id="499a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9016" class="mq lc iq mh b gy mr ms l mt mu">const netSocket = require('net').Socket();<br/>netSocket.connect(9090);<br/>netSocket.write('hello', err =&gt; netSocket.end());</span></pre><p id="c82f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在第二个参数的回调中调用<code class="fe me mf mg mh b">netSocket.end()</code>来在消息被写入后关闭套接字。</p><p id="c8eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须这么做，因为<code class="fe me mf mg mh b">write</code>是异步的。不能保证<code class="fe me mf mg mh b">write</code>在<code class="fe me mf mg mh b">end</code>之前完成，我们不会把它传递到回调中。</p><p id="a3fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">大概是这样的:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4112" class="mq lc iq mh b gy mr ms l mt mu">const netSocket = require('net').Socket();<br/>netSocket.connect(9090);<br/>netSocket.write('hello');<br/>netSocket.end();</span></pre><p id="2817" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">会出现“结束后写入”错误。</p><h1 id="e133" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">response.setHeader和response.writeHead之间的区别</h1><p id="2c14" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">response.setHeader</code>让我们为隐式标题设置一个单独的标题。</p><p id="d2d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果头已经存在，那么它的值将被替换。</p><p id="4e74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用一个字符串数组来发送多个同名的头。</p><p id="e782" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">response.writeHead</code>发送请求的响应头。</p><p id="fdad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种方法接受一个带有状态代码和响应头的对象。</p><p id="07e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用<code class="fe me mf mg mh b">setHeader</code>，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6f0a" class="mq lc iq mh b gy mr ms l mt mu">const body = "hello world";<br/>response.setHeader("Content-Length", body.length);<br/>response.setHeader("Content-Type", "text/plain");<br/>response.setHeader("Set-Cookie", "type=foo");<br/>response.status(200);</span></pre><p id="e776" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一个<code class="fe me mf mg mh b">setHeader</code>调用设置一个响应头。</p><p id="9670" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe me mf mg mh b">response.status</code>单独设置状态代码。</p><p id="93a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，使用<code class="fe me mf mg mh b">writeHead</code>，我们一次性设置响应状态代码和标题。</p><p id="7e10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="503c" class="mq lc iq mh b gy mr ms l mt mu">const body = "hello world";<br/>response.writeHead(200, {<br/>  "Content-Length": body.length,<br/>  "Content-Type": "text/plain",<br/>  "Set-Cookie": "type=foo"<br/>});</span></pre><p id="359d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在第一个参数中设置响应状态代码，在第二个参数中设置对象中的所有响应头。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/057885b37ec91b92577ca36c73f6b4f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nxMOUt7DCz3KWdZK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David Clode</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a696" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="18d5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">response.setHeader</code>和<code class="fe me mf mg mh b">response.writeHead</code>不一样。</p><p id="d08a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以解析HTML或XML，并使用XPath查询节点。</p><p id="f9ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要结束用<code class="fe me mf mg mh b">net</code>创建的套接字，我们必须在传入<code class="fe me mf mg mh b">write</code>第二个参数的回调中调用它。</p><p id="99cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过重定向输出将<code class="fe me mf mg mh b">npm install</code>错误记录到一个文件中。</p></div></div>    
</body>
</html>