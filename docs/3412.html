<html>
<head>
<title>Next.js Firebase authentication— Including SSR</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Next.js Firebase身份验证—包括SSR</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/next-js-firebase-authentication-including-ssr-1045b097ee18?source=collection_archive---------3-----------------------#2020-09-27">https://javascript.plainenglish.io/next-js-firebase-authentication-including-ssr-1045b097ee18?source=collection_archive---------3-----------------------#2020-09-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b606b7e9655a5c1493c9a5e2d4e54177.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s4qFZXMFQgSuIv4pio42Lw.png"/></div></div></figure><div class=""/><p id="fe3d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最近，我一直在玩Next.js。在我看来，这是一个很好的库，可以让基于React的应用程序运行起来。<br/>我刚刚还在纠结我的应用程序的认证问题。我喜欢使用Firebase身份验证服务，所以我想在Next.js应用程序中实现它。</p><p id="a33b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">我认为Next JS的一个很好的特性是服务器端渲染。这允许我对我的后端或数据库执行所有需要的调用，并基于这些调用检索的数据呈现静态网页。这有助于搜索引擎优化等显而易见的事情，也有助于将网页分享到社交媒体。当你在脸书上分享一个网页时，它会抓取你的页面并检索一些预览数据以嵌入到社交网络中。当您的一些数据基于客户端调用呈现时，脸书很有可能在抓取您的应用程序时遇到问题。</em></p><p id="3196" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="kw">其次，我喜欢我的终端用户不能在我的API调用中四处查看的事实。Firebase是一个很好的平台，可以为您的应用程序提供身份验证。通过Firebase在客户端检查用户认证状态非常容易。有时，我想在服务器端呈现页面时检查身份验证状态。我一直在努力工作。</em></p><p id="343b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这篇文章中，我将一步一步地展示我是如何完成我的解决方案的。一如既往，如果你在我的解决方案中看到任何问题，或者你对它有一些有趣的补充，请随时在下面发表评论！</p><h2 id="462f" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">标准的例子</h2><p id="eb5c" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">Next.js在他们的Github上有很多不错的例子。具体来说，有一个包括Firebase身份验证的示例:</p><div class="ip iq gp gr ir lv"><a href="https://github.com/vercel/next.js/tree/canary/examples/with-firebase-authentication" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jc gy z fp ma fr fs mb fu fw ja bi translated">vercel/next.js</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">该示例包括Firebase身份验证和无服务器API路由。使用Yarn或npx执行create-next-app以…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">github.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj ix lv"/></div></div></a></div><p id="fb15" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是如何使用Firebase身份验证的一个很好的例子，但是我总是在这里遗漏了一部分。在本例中，他们只展示了如何在客户端使用身份验证。这非常适合您的使用案例。</p><p id="b5fd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是当我查看Next.js的功能时，我对服务器端的功能非常感兴趣。</p><p id="d388" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">尤其是“getServerSideProps”方法。</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mk"><img src="../Images/ea98072fac0680ef962c0294ef03a8f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zHHiWwGPRrUaZFh8JnIKdA.png"/></div></div></figure><p id="1f2b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">js为我们提供了一个类似PHP的功能，我们可以在客户端呈现页面之前处理服务器端的逻辑。这意味着您可以在用户看到页面之前处理一些API请求或后端逻辑。你后端逻辑的结果可以通过‘道具’传递，可以在前端使用。这有很多好处。</p><p id="9895" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里的问题是，我希望能够检索用户的身份验证状态。这是上面的Firebase示例没有涉及到的内容。我想和你分享我的解决方案。</p><h2 id="5d18" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">解决方案</h2><p id="04bf" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">简而言之，我该怎么办？</p><ul class=""><li id="5cc6" class="mp mq jb ka b kb kc kf kg kj mr kn ms kr mt kv mu mv mw mx bi translated">使用会话cookie管理Firebase身份验证</li><li id="ee46" class="mp mq jb ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">设置一个身份验证API端点，它将从服务器端提供一个cookie</li><li id="6599" class="mp mq jb ka b kb my kf mz kj na kn nb kr nc kv mu mv mw mx bi translated">在getServerSideProps方法中使用Cookie。</li></ul><div class="ip iq gp gr ir lv"><a href="https://firebase.google.com/docs/auth/admin/manage-cookies" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jc gy z fp ma fr fs mb fu fw ja bi translated">管理会话Cookies | Firebase</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">Firebase Auth为依赖会话cookie的传统网站提供服务器端会话cookie管理…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">firebase.google.com</p></div></div><div class="me l"><div class="nd l mg mh mi me mj ix lv"/></div></div></a></div><h2 id="9b4d" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">Firebase设置</h2><p id="c44e" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">所以先建立一个Firebase项目。获取服务帐户并启用电子邮件身份验证。我不会详细解释这个步骤。</p><p id="e785" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我的另一个故事详细解释了这一点:</p><div class="ip iq gp gr ir lv"><a href="https://medium.com/javascript-in-plain-english/react-native-full-authentication-flow-with-spotify-bc0a5b895696" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd jc gy z fp ma fr fs mb fu fw ja bi translated">react Native—Spotify的完整认证流程</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">React Native中的身份验证可能是一场噩梦。让我们尝试构建一个React原生应用程序，并使用Spotify…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="ne l mg mh mi me mj ix lv"/></div></div></a></div><h2 id="1d7d" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">登录—客户端</h2><p id="c874" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">在我的例子中，我使用电子邮件认证。这意味着您需要一个允许用户输入电子邮件和密码的表单。您可以在本文末尾的资源库中找到我的示例代码。</p><p id="b0bf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将放大utils/auth.js文件:</p><p id="cbf2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们将把Firebase身份验证的持久性设置为None。这是因为我们将使用通过API调用设置的cookie自己处理这个问题。</p><p id="b855" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在“登录方法”中，我们使用Firebase提供的方法来处理用户凭证的验证。“signInWithEmailAndPassword”确实如其名。</p><p id="61e0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">成功登录后，我们执行Next.js API提供的POST调用。在这个调用中，我们提供了从Firebase收到的IDToken。我们的API端点将检查这个令牌的有效性，如果令牌有效，将返回一个包含Cookie的响应。</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="07f5" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">登录— API</h2><p id="970e" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">在我们的pages/api/auth.js文件中，我们将处理传入的POST请求并检查Firebase IDToken的有效性。</p><p id="bc96" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果令牌有效，我们将生成一个会话Cookie，该Cookie将通过标题“Set-Cookie”返回。这将为接收调用响应的客户端设置一个cookie。</p><p id="c890" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意“secure”和“httpOnly”参数，这将有助于保护cookie。因此，不能通过JavaScript访问cookie，这样可以保护用户免受恶意第三方的攻击。</p><p id="ba23" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">注意，secure参数在Localhost中不起作用。这就是我把它放在环境变量后面的原因。我的生产环境总是将这个参数设置为true，但是在本地测试时，我需要将这个参数设置为false。</p><p id="fa01" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我的一个大错误是试图让这个工作，这花了我很多时间，让路径参数为空。这样做时，路径将被设置为“/api”，因为这是设置cookie的路径。因此，我无法在getServerSideProps方法中检索cookie。将它改为“/”解决了这个问题。</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="ee1d" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">使用身份验证状态服务器端</h2><p id="7373" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated"><strong class="ka jc"> pages/user.js: </strong></p><p id="eb37" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我创建了一个简单的演示页面来展示我们如何使用Cookie来验证身份验证。</p><p id="3bd9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此时，我们将知道页面呈现之前的身份验证状态。这意味着我们可以在将HTML返回给客户端之前检索一些特定于用户的数据。</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><p id="e359" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> utils/verifyCookie.js </strong></p><p id="00d4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该函数将在Firebase SDK的帮助下验证会话Cookie:</p><figure class="ml mm mn mo gt is"><div class="bz fp l di"><div class="nf ng l"/></div></figure><h2 id="1434" class="kx ky jb bd kz la lb dn lc ld le dp lf kj lg lh li kn lj lk ll kr lm ln lo lp bi translated">完整代码示例— GitHub存储库</h2><p id="b014" class="pw-post-body-paragraph jy jz jb ka b kb lq kd ke kf lr kh ki kj ls kl km kn lt kp kq kr lu kt ku kv ij bi translated">可以在GitHub上找到完整的代码示例:<br/><a class="ae nh" href="https://github.com/ThomasSwolfs/nextjs-firebase-auth-ssr-example" rel="noopener ugc nofollow" target="_blank">https://GitHub . com/Thomas wolfs/nextjs-firebase-auth-SSR-example</a></p><p id="35c6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望我能帮助别人解决这个问题。如果你喜欢我的内容，请随时关注或鼓掌！</p><p id="092a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">干杯</p><p id="cf89" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">— <strong class="ka jc">托马斯</strong></p></div></div>    
</body>
</html>