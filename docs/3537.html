<html>
<head>
<title>Code Splitting in React apps with Suspense</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">带悬念的React应用中的代码拆分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/code-splitting-in-react-apps-with-suspense-2a6e780b703b?source=collection_archive---------13-----------------------#2020-10-06">https://javascript.plainenglish.io/code-splitting-in-react-apps-with-suspense-2a6e780b703b?source=collection_archive---------13-----------------------#2020-10-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="a8ba" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">保持应用程序包较小的简单方法。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/cf6a90c247c0e6fdfd9be4809e4dd1f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2q2EwujrsfoZeTwpxVkHSQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@furbee?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Oscar Nord</a> on <a class="ae kv" href="https://unsplash.com/s/photos/code-suspense?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4387" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我将演示如何使用React的悬念，向您展示实现代码分割是多么简单，并有助于保持您的整体包大小尽可能小。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="5ec3" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">为什么要进行代码分解？</h1><p id="d2be" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果你使用<em class="mw"> webpack </em>来构建你的React应用，默认情况下React应用会创建React应用，那么它会在构建过程中将你的代码捆绑在一起。</p><p id="b3ec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">随着应用程序的增长，您需要注意这个包的大小，尤其是在您添加外部库时。否则，随着包大小的增加，应用程序的初始加载会花费很长时间。</p><p id="1c7c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是代码拆分真正派上用场的地方。一旦实现<em class="mw"> webpack </em>会自动将你的代码分割成更小的包。</p><p id="b1cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很难确切地知道从哪里开始拆分代码，但是有一些合理的方法可以做到这一点。一个好的方法是在应用程序中为每条路线拆分。因此，您可以按照应用程序路由器中声明的每个路由来拆分这个包。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e420" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">让我们构建一个示例应用程序</h1><p id="17e2" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在我们知道了为什么代码分割对开发有益，让我们直接开始构建一个例子。我们将一步一步来，并随时查看<a class="ae kv" href="https://github.com/mbrown3321/react-suspense-demo" rel="noopener ugc nofollow" target="_blank"> Github </a>中完整的示例代码。</p><p id="cabe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们需要使用Create React App创建一个新的应用程序，并安装React Router来处理我们的演示应用程序中的路由。</p><pre class="kg kh ki kj gt mx my mz na aw nb bi"><span id="ff53" class="nc ma iq my b gy nd ne l nf ng">npx create-react-app react-suspense-demo<br/>cd react-suspense-demo<br/>npm install react-router-dom</span></pre><p id="c0b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一步，我们将为我们的路线创建一些组件。这些看起来都差不多。只是我们在下一步为应用程序创建的每条路线的占位符。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="dd41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们已经为应用程序的路线准备好了组件。我们已经将应用程序分为单独的部分:分数、主页、关于和活跃用户。</p><p id="e729" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在准备更新我们的<em class="mw"> App.js </em>文件。接下来让我们看看这段代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nh ni l"/></div></figure><p id="7cfa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以让我们一步一步来。首先，我们用<em class="mw"> React.lazy. </em>加载在上一步中创建的组件</p><p id="39bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个lazy加载这些组件的代码。这意味着组件的JavaScript在被请求之前不会被加载，而不是预先加载。</p><p id="9a8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用悬念的另一部分是在每条路线中，我们将每个组件包装在一个<em class="mw">悬念</em>组件中。</p><p id="0f7b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们为每个内容提供了一个<em class="mw"> fallback </em>属性，它将一直显示到惰性加载的内容加载完毕。这使得在加载时提供加载消息或spinner变得很容易。</p><p id="9af3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们完成演示应用程序所需的全部内容。现在让我们来看看我们的实际工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/32c07cd50e50db166764165270b78518.png" data-original-src="https://miro.medium.com/v2/resize:fit:1318/1*R1U_xT6079deO3i5gqGbCA.gif"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Screenshot by the author</figcaption></figure><p id="8e52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以从屏幕记录中看到，或者如果您正在本地运行代码，当我们切换路由时，会有为每个路由加载不同包的请求。</p><p id="0145" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这表明我们的悬疑代码完全按照我们的想法进行，并将代码分成多个包，而不是一个必须预先加载的大包。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="1b87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mw">本文到此结束。我希望这能让你更好地理解React的悬疑，以及为什么你应该战略性地使用它。在</em><a class="ae kv" href="https://github.com/mbrown3321/react-suspense-demo" rel="noopener ugc nofollow" target="_blank"><em class="mw"/></a><em class="mw">上找到完整的代码示例。谢谢！</em></p><p id="dec5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅我们的YouTube频道</strong> </a> <strong class="ky ir">获得更多类似的内容吧！</strong></p></div></div>    
</body>
</html>