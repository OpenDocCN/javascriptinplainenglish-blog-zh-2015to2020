<html>
<head>
<title>Connect Angular Components with Events, Bindings, and Services</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将角度组件与事件、绑定和服务连接起来</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/connect-angular-components-with-events-bindings-and-services-5d9ec1f4baf5?source=collection_archive---------2-----------------------#2020-02-09">https://javascript.plainenglish.io/connect-angular-components-with-events-bindings-and-services-5d9ec1f4baf5?source=collection_archive---------2-----------------------#2020-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="ebdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将探索如何使用角度双向绑定、事件和服务来连接用户界面，并允许不同的组件相互交互，而不会彼此紧密联系。我们将通过使用<code class="fe kl km kn ko b">ngModel</code>从用户那里收集命令，将它们发送给服务，并让另一个组件在输入命令时订阅来自服务的事件。</p><h1 id="8d4e" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">该项目</h1><p id="0371" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">在这篇文章中，我们将从我目前正在开发的一个名为<a class="ae ls" href="https://killalldefects.com/2020/02/01/game-design-with-event-modeling/" rel="noopener ugc nofollow" target="_blank">“Doggo Quest”</a>的基于文本的游戏开始。游戏有一个<a class="ae ls" href="https://killalldefects.com/2020/02/05/from-mockup-to-angular-material/" rel="noopener ugc nofollow" target="_blank">已经创建的用户界面</a>，有一个故事视图和一个玩家输入区。然而，这个游戏目前什么也不做，因为这些区域根本不互相交流。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/69bf26d5e0cdbd897c380b6e5c0ecd63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-GriMSw55lWd3yXX"/></div></div></figure><p id="0577" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我们将通过使用角度双向绑定、事件、事件发射器、服务和订阅来将用户界面链接在一起。用户将能够输入一个命令，并看到它出现在游戏的故事视图中，以及一个通用的响应。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/312a4aa6c599dd9e43934ca06f907961.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3LgZpTAnQBiGQvRi"/></div></div></figure><p id="3085" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">注意:在本系列的后面，我们可能会探索</em> <a class="ae ls" href="https://ngrx.io/" rel="noopener ugc nofollow" target="_blank"> <em class="mf"> NgRx </em> </a> <em class="mf">，</em><a class="ae ls" href="https://www.learnrxjs.io/" rel="noopener ugc nofollow" target="_blank"><em class="mf">RxJs</em></a><em class="mf">以及更复杂的处理事件和状态管理的方式，但是现在我想从管理基本Angular中的状态和事件的最简单的方式开始。</em></p><p id="6644" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想从头开始，看看Doggo Quest库的标签。本文最后的代码<a class="ae ls" href="https://github.com/IntegerMan/DoggoQuest/tree/AngularEventEmitters" rel="noopener ugc nofollow" target="_blank">也是可用的</a>。</p><h1 id="4d51" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">创建服务</h1><p id="2116" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">现在我们的用户界面只是一个输入框和一个按钮，什么也不做。为了将命令输入组件连接到主故事显示，我们将添加一个服务。</p><p id="93c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">服务是为应用程序的其他领域提供一些功能而设计的类。它们非常接近于普通对象，除了一个区别:Angular可以自动将服务注入到其他组件的构造函数中(稍后将详细介绍)。</p><p id="7426" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了创建一个组件，我们将启动我们的命令行并导航到项目目录，然后键入<code class="fe kl km kn ko b">ng g s &lt;name-of-service&gt;</code>to<strong class="jp ir">g</strong>generate a new<strong class="jp ir">s</strong>service。请记住，您不要输入您的服务名称<code class="fe kl km kn ko b">service</code>，因为Angular会自动为您终止您在<code class="fe kl km kn ko b">.service</code>的服务。</p><p id="b52f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的例子中，我运行<code class="fe kl km kn ko b">ng g s story</code>来生成<code class="fe kl km kn ko b">story.service</code>。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/b40486dd42e337eb3387dfba83810cc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/0*pKChXWaTG9p_Alvw"/></div></figure><h1 id="5dbf" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">构建服务方法和EventEmitter</h1><p id="6cb4" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">接下来，我们将通过添加一个<code class="fe kl km kn ko b">EventEmitter</code>和一个<code class="fe kl km kn ko b">handlePlayerInput</code>方法来充实服务，如下所示:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="0ca7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们停下来讨论一下事件发射器。<code class="fe kl km kn ko b">EventEmitter</code>是一个可以发出事件(顾名思义)的对象，其他代码可以订阅这些事件，并在事件发生时得到通知。</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/7e2195e85ed239a5648e2610c2a2418e.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/0*nVHBLK9NudK-uyYn"/></div></figure><p id="63bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过调用<code class="fe kl km kn ko b">EventEmitter</code>上的<code class="fe kl km kn ko b">.emit</code>并提供发射器的泛型类型的一个实例，可以简单地发射事件，如上面第24行所示。</p><p id="0985" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">订阅者将收到一个以该对象作为参数的事件。在本文的后面，我们将看到这对于订阅者来说是什么样子。您应该记住，任何<code class="fe kl km kn ko b">EventEmitter</code>都可以没有订阅者或者有许多不同的订阅者。这种灵活的体系结构使服务与依赖它们的各个组件相分离。</p><p id="64b6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，所有这些只是将消息记录到控制台，但是在本文的后面，我们将设置一个事件发射器，以便其他组件可以订阅命令事件。</p><h1 id="d6c3" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">向服务发送命令</h1><p id="b9d5" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">好了，现在我们有了一个服务，我们可以利用Angular内置的依赖注入功能来为我们的<code class="fe kl km kn ko b">command-entry.component</code>提供<code class="fe kl km kn ko b">story.service</code>。我们只需将它作为参数添加到构造函数中，如下面第12行所示:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="8177" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您不需要担心服务如何到达组件。Angular自动从您的应用模块为您提供服务。</p><p id="c1de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在来说说<code class="fe kl km kn ko b">submitCommand</code>法。这是我们的组件模板将调用的方法(我们将在下一节看到更多内容)，该方法将从<code class="fe kl km kn ko b">Command</code>字段中提取值并将其传递给服务。</p><p id="98a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，在向服务发送命令后，我们将清除<code class="fe kl km kn ko b">Command</code>字段。我们将在下一部分详细讨论这一点。</p><h1 id="3af0" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">角度分量中的事件</h1><p id="c466" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">让我们来看看<code class="fe kl km kn ko b">command-entry.component</code>的用户界面:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="1ece" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">其中大部分是标准的标记，尽管它使用了<a class="ae ls" href="https://killalldefects.com/2020/02/05/from-mockup-to-angular-material/" rel="noopener ugc nofollow" target="_blank">棱角分明的材料</a>进行一些额外的润色。</p><p id="5775" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在这个类中关注一些绑定和基于事件的语法，我们将按照复杂程度从下往上开始。</p><p id="008b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第6行的<code class="fe kl km kn ko b">(click)</code>处理程序告诉Angular注意按钮上的点击事件，并在事件发生时调用组件的类定义中的<code class="fe kl km kn ko b">submitCommand</code>方法。这就是我们的用户界面如何知道调用该方法。</p><p id="6d02" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似地，在第4行我们看到了<code class="fe kl km kn ko b">keyup.enter</code>上的一个句柄。这是一种奇特的角度语法，只监听与enter键相关的keyup事件。在这种情况下，出于可用性目的，我们希望在用户点击enter时调用<code class="fe kl km kn ko b">submitCommand</code>方法。</p><h1 id="e9ae" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">双向装订</h1><p id="e3bc" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">顺便说一下，在Angular中，模板<code class="fe kl km kn ko b">()</code>中的括号表示<em class="mf">事件</em>，而括号<code class="fe kl km kn ko b">[]</code>表示<em class="mf">绑定</em>。可以认为<code class="fe kl km kn ko b">()</code>表示某些东西进入了<em class="mf">组件的类定义</em>，而<code class="fe kl km kn ko b">[]</code>表示某些东西来自于类定义。</p><p id="43ad" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在让我们看看上面代码片段第3行的语法:<code class="fe kl km kn ko b">[(ngModel)]="Command"</code></p><p id="c514" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个语法是Angular最需要适应的东西之一。它通常被称为“盒子里的香蕉”，暗指嵌套在括号内的圆括号。</p><p id="bb06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">把这个<code class="fe kl km kn ko b">[()]</code>语法简单地看作是我们的属性绑定<code class="fe kl km kn ko b">[]</code>语法和事件绑定<code class="fe kl km kn ko b">()</code>语法的组合<em class="mf">。换句话说，当我们使用<code class="fe kl km kn ko b">[()]</code>时，我们想要一个双向绑定，其中组件的用户界面从类的字段接收更新，并且可能影响源字段的更新(比如用户在文本框中输入)也被推回到类中。</em></p><p id="e450" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">迷茫？回想一下这个组件的代码隐藏。我们有一个<code class="fe kl km kn ko b">Command</code>字段，当用户在输入框中输入内容时，该字段通过绑定进行更新。</p><p id="4032" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">此外，在我们调用<code class="fe kl km kn ko b">submitCommand</code>之后，我们将<code class="fe kl km kn ko b">Command</code>字段清空为一个空字符串。双向绑定开始生效，Angular的<a class="ae ls" href="https://blog.angular-university.io/how-does-angular-2-change-detection-really-work/" rel="noopener ugc nofollow" target="_blank">变化检测</a>告诉用户界面将输入框的值设置为空字符串。</p><h1 id="c8d0" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">订阅事件发射器</h1><p id="308c" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">现在我们已经介绍了服务和<code class="fe kl km kn ko b">command-entry.component</code>，让我们通过关注向用户显示故事的<code class="fe kl km kn ko b">story-view.component</code>来结束。</p><p id="b448" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似于<code class="fe kl km kn ko b">command-entry.component</code>,我们将使用Angular的依赖注入为组件提供<code class="fe kl km kn ko b">story.service</code>。只是我们将订阅由<code class="fe kl km kn ko b">EntryAdded</code> <code class="fe kl km kn ko b">EventEmitter</code>发出的任何事件，而不是调用该服务的方法，如下所示:</p><figure class="lu lv lw lx gt ly"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="bfb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们先看看第12行。该组件实现了<code class="fe kl km kn ko b">OnInit</code>和<code class="fe kl km kn ko b">OnDestroy</code>接口。这迫使我们向组件添加<code class="fe kl km kn ko b">ngOnInit</code>和<code class="fe kl km kn ko b">ngOnDestroy</code>方法。Angular在组件上寻找这些方法，并在组件分别加载和卸载时调用它们。</p><p id="ec25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以使用这些方法来订阅和退订我们在其他服务中关注的事件。正如我们在第24行和第29行看到的，我们订阅和取消订阅一个<code class="fe kl km kn ko b">EventEmitter</code>，并将订阅存储在一个字段中，以便我们以后可以取消订阅。</p><p id="70db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这方面的取消订阅很重要，因为它确保组件被正确处理，并且不会导致代码在与“死”组件相关的未来事件上运行。未能取消订阅可能会导致错误和性能下降。</p><p id="d433" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，让我们看看第24行。通过这一行，我们订阅了服务上的<code class="fe kl km kn ko b">EntryAdded</code>事件发射器，并将新条目添加到故事数组的末尾。Angular的绑定和变化检测机制将根据我们之前设置用户界面的方式自动为用户界面添加一个组件。</p><h1 id="cdca" class="kp kq iq bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm bi translated">结论</h1><p id="2ec7" class="pw-post-body-paragraph jn jo iq jp b jq ln js jt ju lo jw jx jy lp ka kb kc lq ke kf kg lr ki kj kk ij bi translated">只需几个步骤，我们就获得了一个只存在于样式和结构中的用户界面，并使用绑定、事件、服务和<code class="fe kl km kn ko b">EventEmitter</code>将其连接在一起。</p><p id="eba3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">更重要的是，我们以一种非常灵活的方式做到了这一点，因此我们可以更换整个组件，而不需要在其他方面进行大量的更改。</p><p id="6f88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当用户输入文本时，它会立即与默认响应一起出现在story视图中，如下所示:</p><figure class="lu lv lw lx gt ly gh gi paragraph-image"><div role="button" tabindex="0" class="lz ma di mb bf mc"><div class="gh gi lt"><img src="../Images/2bc24967d49f0adf607ee10abcb5b5fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jTvxmfjRpMBfOaHN"/></div></div></figure><p id="543a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">不难看出这个项目的其余部分将如何解析用户的输入并给出智能响应，但我们仍然需要讨论一些重要的概念，如可访问性和用户界面测试。</p><p id="659e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">敬请关注。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="188e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="mf">原载于2020年2月9日</em><a class="ae ls" href="https://killalldefects.com/2020/02/08/connect-angular-components-with-events-services-and-binding/" rel="noopener ugc nofollow" target="_blank"><em class="mf">【https://killalldefects.com】</em></a><em class="mf">。</em></p></div></div>    
</body>
</html>