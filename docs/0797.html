<html>
<head>
<title>Reports of the Virtual DOM’s Death are Greatly Exaggerated</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于虚拟世界死亡的报道被大大夸大了</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reports-of-the-virtual-doms-death-are-greatly-exaggerated-2206d00beead?source=collection_archive---------1-----------------------#2019-12-12">https://javascript.plainenglish.io/reports-of-the-virtual-doms-death-are-greatly-exaggerated-2206d00beead?source=collection_archive---------1-----------------------#2019-12-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="014b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">…揭穿其他现代Web开发神话</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d6b02a4178b96d1489f2db5d54269e7c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgibDrFNaLtUZp7ZyaJ-5w.jpeg"/></div></div></figure><p id="59f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我最近读了几篇文章，这些文章提出了一些相当离谱的主张，其依据只不过是一些会议讨论的轶事。一部分是一年中的时间。随着我们从一年走向下一年，这是一个展望未来的好时机。我甚至不认为所有的情绪都是错误的，只是缺乏证据和理由。我们也许有一天会到达那里，但那一天不是今天。</p><p id="5719" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，让我们深入探讨一下过去一年中流传的几个问题。</p><h1 id="4ebd" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">误解1: Web组件取代了框架/库</h1><p id="6607" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">Web组件是一系列技术，通过使用HTML元素，使HTML、CSS和JavaScript以可重用的方式模块化。这些技术为DOM添加了以前没有的特性，以帮助实现这个目标，包括模板、CSS封装、元素生命周期挂钩(包括属性监视)和子元素槽。从表面上看，这些是UI框架实现的许多相同的特性，最终你会得到组件。所以它们一定是等价的，对吗？</p><p id="3fac" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不，一点也不。一个是一组解决一般问题的原生工具，另一个是一组自以为是的特性，以提高应用程序的生产效率。现在这种困惑是可以理解的。有时，我甚至不确定那些参与撰写提案的人是否清楚界限在哪里。一些提议看起来像是下一个框架的规范。但在6年里，我一直在关注这一点，供应商之间的共识率很明显，这里的功能集越基本，就越有可能向前发展。对于他们应该扮演什么角色仍有许多争论。像支持原生内置(扩展现有元素的能力)没有完全支持。仅这一点就表明，一些政党并不认为这些适合设计系统。</p><p id="4098" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那么它们有什么用呢？微前端或插件包装似乎是可行的。您还可以发明自己的可访问性、本地化和表单处理功能，并设计自己的元素。有一点很清楚，它们与React组件不同。它们模块化，但与变更传播或高效呈现没有关系。它们的界限更重，代表了通过它们自己的生命周期的封装隔离。足以让每一个都拥有自己的UI库。有些确实如此。事实上，几乎所有产生Web组件的库都是这种性质的库。你不能避免学习一个框架/库。我的意思是你可以使用普通的DOM APIs，但是你现在也可以不使用Web组件。不要上当。你要么使用他们与你已经熟悉的库，如角元素，或Svelte或Vue导出自定义元素，或者你正在学习一个新的库，如聚合物，模板，异端或LitElement。</p><p id="e360" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">什么都没有改变。使用它们并不是突然支持开放网络。事实上，最自由的方法可能是像<a class="ae mk" href="https://github.com/skatejs/skatejs" rel="noopener ugc nofollow" target="_blank"> SkateJS </a>这样的东西，它并不试图附带一个框架，而是让你使用任何现有的框架。该库的存在只是为了使API表面均匀化，并允许您以自己想要的方式工作。但是你猜怎么着？您仍在使用框架/库。</p><h1 id="d09b" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">神话2:消失的框架</h1><p id="817e" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">我喜欢这个。这必须是自虚拟DOM以来网络前端最好的营销短语，并帮助苗条像风暴一样到来。这完全是夸张。总有一个运行时。它可以很小，但必须是能引发变化的东西。所有的库都是普通的JS、HTML和CSS。这里真正的英雄是树摇动，静态分析导入语句以消除死代码的过程。基本上，从不导入的代码不需要包含在最终的包中。使用编译，你所要做的就是寻找标识符，然后添加导入语句，树抖动会做得最好。不难想象这个过程。编译器遇到了像<code class="fe ml mm mn mo b">#each</code>这样的助手，并决定包含列表映射代码。不要相信我在你编译的细长代码中寻找<code class="fe ml mm mn mo b">import</code>语句。他们在那里。</p><p id="cdb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，通过编译，我们可以减少捆绑运行时代码的数量，因为您可以硬编码模板，本质上是解开循环。但是一旦遇到常见的模式，实际上抽象的规模效率更高，在你知道之前，运行时间更短。现在，任何足够简单的库与树抖动相结合都可以产生相同的结果，尽管可能不那么巧妙。反应式库往往更小，但甚至有虚拟DOM库甚至可以产生等效或更小的包(见<a class="ae mk" href="https://github.com/jorgebucaran/hyperapp" rel="noopener ugc nofollow" target="_blank"> HyperApp </a>)。也许我们应该考虑专注于让有价值的东西消失。</p><h1 id="792d" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">神话3:虚拟DOM是纯粹的开销</h1><p id="1029" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">好吧，我不能否认这不是真的。然而，该语句的使用会产生误导。绝对一切不是香草js是纯粹的开销。我的意思也不仅仅是编译优化的代码。正如神话2中提到的，仍然有一个运行时。因此，无论您如何攻击它，都需要管理DOM的更新和更改。一般来说，所有现代的数据驱动UI库都以3种方式工作，每种方式都有自己的权衡。您可以为每种方法创建有效的版本。事实上，已经有一些库体现了每种方法的规模和性能特征，远远超出了流行库的能力(见<a class="ae mk" href="https://github.com/krausest/js-framework-benchmark" rel="noopener ugc nofollow" target="_blank">https://github.com/krausest/js-framework-benchmark</a>)。</p><p id="af97" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虚拟DOM和其他方法一样是一种完全可行的方法，并且仍然是图书馆中最流行的方法，甚至在生产Web组件的图书馆中也是如此。大多数基准测试都是由库在一个组件中完成所有工作。在真实的项目中，您可以模块化成多个组件。这也有一个开销，并没有被谈论的那么多。与其他方法相比，虚拟DOM通常在更多的组件上具有更好的伸缩性。所以我们对真实表现的看法可能会有偏差。</p><p id="e76d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我看来，您选择不使用虚拟DOM的原因不是性能或大小。您更喜欢开发人员经验的扩展——组合模式、可变性与不可变性、代码结构等...但是仅仅因为用技术方法做某事不容易，并不意味着它不可能。React Fiber和Hooks表明虚拟DOM库可以表现得几乎像一个反应库。当然，KnockoutJS在2010年拥有这些功能，但这并没有减少它的潜力。</p><blockquote class="mp mq mr"><p id="4b0f" class="kr ks ms kt b ku kv jr kw kx ky ju kz mt lb lc ld mu lf lg lh mv lj lk ll lm ij bi translated">我提到的三种方法是虚拟DOM、DOM协调和反应式。</p><p id="355a" class="kr ks ms kt b ku kv jr kw kx ky ju kz mt lb lc ld mu lf lg lh mv lj lk ll lm ij bi translated">虚拟DOM库是基于使用生成一个虚拟树，然后不同于以前的迭代和修补DOM更新。它使用不变性和引用相等来简化优化。然而，不变性会导致大量的克隆和内存分配。示例:反应、Vue、地狱</p><p id="6cdd" class="kr ks ms kt b ku kv jr kw kx ky ju kz mt lb lc ld mu lf lg lh mv lj lk ll lm ij bi translated">DOM协调库在创建DOM节点时存储绑定值。每次更新时，它们都与以前的值进行比较，并更新DOM。它们类似于虚拟DOM库，除了它们在一个通道中工作，只有叶子不同。然而，基于可变性，它们需要在叶子处总是不同的，因此在深层嵌套结构中优化快捷方式的方法较少。示例:角形、聚合物、lit-html</p><p id="8d40" class="kr ks ms kt b ku kv jr kw kx ky ju kz mt lb lc ld mu lf lg lh mv lj lk ll lm ij bi translated">反应库在创建DOM节点时构造一个反应图。这样，每个绑定上下文都可以与一个事件订阅相关联，以便在数据更新时只运行相关的事件处理程序。这种方法是优化的，因为它需要最小的差异，但它具有最大的初始创建成本。例如:苗条、迷人、结实</p></blockquote><h1 id="f118" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">误解4: Web组装对于Web UI来说更快</h1><p id="d69c" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">不变的是:永远不要低估JavaScript。但在我看来更是如此:永远不要低估DOM的成本。DOM贵得离谱。到目前为止，大多数人都知道操作DOM的代价，因为它会导致重流和重画。并且即使读取影响布局的属性也会导致过早回流。然而，即使窥视它上面的其他属性也会有巨大的成本。任何类型的树遍历几乎都和创建DOM节点一样昂贵。几乎你用DOM做的任何事情都有额外的成本。</p><p id="e06e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不幸的是，对于其他技术来说，成本更难处理。Web工作人员会拯救我们，但是他们不能访问DOM，所以虽然他们有很多性能上的好处，但是他们对Web UI没有有意义的影响。WASM也有类似的限制。当你在WASM时，WASM比JavaScript快得多，但是你越是过渡到JavaScript APIs，它就越慢。目前，这是它访问DOM的唯一方式。随着Web绑定的引入，这种情况最终会改变。这在过去几年里一直在工作，当规范最终落地时，我们可以看到一些大的收获。到今天为止，普通js不仅在DOM渲染上更快，而且一些高级数据驱动库比最快的低级WASM实现更高效(见<a class="ae mk" href="https://github.com/krausest/js-framework-benchmark" rel="noopener ugc nofollow" target="_blank">https://github.com/krausest/js-framework-benchmark</a>)。更高级别的WASM实现可能会有更多的开销。所以，最新的WASM UI库远远不是性能最好的。</p><h1 id="23a2" class="ln lo iq bd lp lq lr ls lt lu lv lw lx jw ly jx lz jz ma ka mb kc mc kd md me bi translated">误解5:调度意味着更好的性能</h1><p id="9918" class="pw-post-body-paragraph kr ks iq kt b ku mf jr kw kx mg ju kz la mh lc ld le mi lg lh li mj lk ll lm ij bi translated">这不是一个新的，但它不断回来。React Concurrent Mode只是制作大多数无意义动画演示的最新趋势。为什么我说大多没有意义？有意义的性能受到帧速率的限制。几乎所有的演示都使用<code class="fe ml mm mn mo b">requestAnimationFrame</code>，因为不这样做就是做不必要的工作。所以通常唯一的解决方法就是想出荒谬的场景。然而这意味着我们只是在非常有限的情况下测试库——当它们受到最糟糕的约束时。这有一些优点。在资源有限的情况下，适度降级对低功耗设备至关重要。但是图书馆如何摆脱这种束缚呢？想办法少做工作。这不再是提高性能的练习，而是如何缩减工作以提供更好的用户体验。</p><p id="40bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个非常崇高的目标，但它有一些有趣的副作用。检测和调度有开销。显然比DOM少。但是库中的渲染越重，就越需要这种干预。它变成了一种自我实现的预言。所有的库都可以使用像<code class="fe ml mm mn mo b">requestAnimationFrame</code>这样的调度技术。因此，尽管我们同意阻塞主线程不利于交互性，但很难概括出性能和阻塞量之间的最佳平衡点。只有当我们超出硬件支持的极限时，我们才会注意到这一点，那么最优雅的降级方式是什么呢？我在我的办公室里用<a class="ae mk" href="https://github.com/ryansolid/solid-sierpinski-triangle-demo" rel="noopener ugc nofollow" target="_blank"> Sierpinski三角形演示</a>测试了对不同调度算法的视觉反应，结果相当不一致。没有更好的选择了。而在切换带有悬念的标签页时，延迟加载状态的视觉效果是一致的。</p><p id="fd5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">目前常用的技术是基于截止日期和排队的概念。<code class="fe ml mm mn mo b">requestAnimationFrame</code>和<code class="fe ml mm mn mo b">requestIdleCallback</code>的一个不太为人所知的特性是，调用你提供的回调函数时会带有一些信息，这些信息可以让你决定你需要工作多少时间。通过使用它来根据可用时间管理你的工作，你可以更聪明地安排时间。不幸的是，正如我所说的，这里没有灵丹妙药。有时候越快越好。</p></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="96ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我希望这次探索能够揭示2019年前端的一些常见神话。不只是一个唱反调的人，因为我知道很多这些来自一个展望未来的地方。虽然我认为这些技术具有很大的潜力，但我警告说，不要急于求成，因为这种热情尤其是在没有具体现实基础的情况下，可能会导致毫无根据的猜测，从而形成势头。在2014年，同样的原因导致一些人认为虚拟DOM比实际DOM更快。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/769a24705e19d944d536e9fd3ab47ba2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*PBhVlBC5zR9qz5rWVR6X1Q.jpeg"/></div></figure><p id="86b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是..没有那么多。</p></div></div>    
</body>
</html>