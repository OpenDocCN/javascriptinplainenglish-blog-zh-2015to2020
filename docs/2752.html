<html>
<head>
<title>TypeScript Best Practices — Literal Types and Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript最佳实践—文字类型和承诺</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typescript-best-practices-literal-types-and-promises-dca5440e7e8?source=collection_archive---------7-----------------------#2020-07-20">https://javascript.plainenglish.io/typescript-best-practices-literal-types-and-promises-dca5440e7e8?source=collection_archive---------7-----------------------#2020-07-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f4ece86b503d857d633bd915db00b090.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*N5o4vBgHT-pDVuVA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rigels?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">rigel</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="15ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="1457" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有包含计算键表达式的删除表达式</h1><p id="0d79" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用<code class="fe me mf mg mh b">delete</code>删除计算的键表达式是一个坏主意。</p><p id="f0fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不安全，也无法优化。</p><p id="d32e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="958d" class="mq lc iq mh b gy mr ms l mt mu">delete foo[bar];</span></pre><p id="8330" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以让这个物体保持原样。</p><h1 id="549c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有空块</h1><p id="f1f0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们的代码中不应该有空块。</p><p id="4c31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们没用。</p><p id="a8bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们应该删除如下代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="08ee" class="mq lc iq mh b gy mr ms l mt mu">function foo(){}</span></pre><h1 id="a702" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有浮动承诺</h1><p id="547f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">浮动承诺是不存储或返回任何数据的承诺。</p><p id="c897" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，它实际上没有做任何事情。</p><p id="6b75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="532f" class="mq lc iq mh b gy mr ms l mt mu">Promise.resolve(1);</span></pre><p id="0cfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那我们应该做点什么。</p><p id="657e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">未处理的承诺会导致意想不到的行为，因为它们在不确定的时间内给我们一个值。</p><h1 id="a0f9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要对数组使用for-in循环</h1><p id="00e6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在数组中使用for-in循环。它应该和普通物体一起使用。</p><p id="47a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">迭代的顺序没有保证。</p><p id="8fa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以不用for-in这样的:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2a7d" class="mq lc iq mh b gy mr ms l mt mu">for (const i in array){<br/>  console.log(array[i]);<br/>}</span></pre><p id="8dc8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="de57" class="mq lc iq mh b gy mr ms l mt mu">for (const a of array){<br/>  console.log(a);<br/>}</span></pre><p id="6879" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于数组项，我们用<code class="fe me mf mg mh b">of</code>和<code class="fe me mf mg mh b">a</code>替换了<code class="fe me mf mg mh b">in</code>。</p><p id="4143" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以轻松地按顺序遍历它们。</p><h1 id="97f2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有推断的空对象类型</h1><p id="b990" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该有空的对象类型，因为我们应该有一个更具体的变量、参数和返回类型。</p><p id="7016" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="df13" class="mq lc iq mh b gy mr ms l mt mu">const obj: {} = {};</span></pre><p id="a84b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ada3" class="mq lc iq mh b gy mr ms l mt mu">const obj: { foo: number } = { foo: 2 };</span></pre><h1 id="7e24" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不，这个无效</h1><p id="726a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在类或对象文字之外使用<code class="fe me mf mg mh b">this</code>。</p><p id="2240" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只会引起混乱，因为<code class="fe me mf mg mh b">this</code>应该是一个类实例。</p><p id="dfc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b6b2" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  a: 1,<br/>  b() {<br/>    console.log(this.a)<br/>  }<br/>}</span></pre><p id="2de7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="06b2" class="mq lc iq mh b gy mr ms l mt mu">class Foo {<br/>  constructor() {<br/>    this.a = 1;<br/>  }</span><span id="6138" class="mq lc iq mh b gy mv ms l mt mu">  bar() {<br/>    console.log(this.a)<br/>  }<br/>}</span></pre><h1 id="ac45" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">无空关键字</h1><p id="b8cc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该只对所有空值使用<code class="fe me mf mg mh b">undefined</code>，而不是混合<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">undefined</code>。</p><p id="732c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们的作用相同，所以我们不需要两者。</p><p id="94ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">undefined</code>也有类型<code class="fe me mf mg mh b">undefined</code>所以更容易检查。</p><p id="22ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，只要在我们的代码中处处使用<code class="fe me mf mg mh b">undefined</code>即可。</p><h1 id="61f3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有空的和未定义的联合类型</h1><p id="7c35" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">用<code class="fe me mf mg mh b">null</code>和<code class="fe me mf mg mh b">undefined</code>创建类型是多余的。</p><p id="7a1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为我们的变量、参数或返回值只能有<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">undefined</code>或我们指定的任何其他值。</p><p id="f8ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该使类型更具限制性，这样我们就可以真正利用TypeScript的类型检查功能。</p><h1 id="567c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有对象文字类型断言</h1><p id="b63c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">具有对象文字类型的类型断言将隐藏具有过多属性的错误。</p><p id="9c2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使对象缺少一些必需的字段，数据类型断言也将覆盖没有断言的任何类型。</p><p id="5810" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该在不强制类型为对象文字结构的情况下处理它。</p><p id="5c04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们不应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ceb9" class="mq lc iq mh b gy mr ms l mt mu">const foo = {} as { bar: number };</span></pre><p id="0cd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bee2" class="mq lc iq mh b gy mr ms l mt mu">const foo: Foo = {};</span></pre><p id="96cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">Foo</code>是接口、类型或类型别名。</p><h1 id="88b3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">布尔型无承诺</h1><p id="5001" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用一个<code class="fe me mf mg mh b">await</code>表达式作为布尔表达式。</p><p id="5199" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">await</code>只对未来给予实际价值的承诺。</p><p id="546e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不是我们想要检查的实际值。</p><p id="624a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该将<code class="fe me mf mg mh b">await</code> ed值赋给一个新变量，这样我们就可以用实际值进行检查。</p><p id="cda6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ce1d" class="mq lc iq mh b gy mr ms l mt mu">async function bar(personPromise: Promise&lt;Person&gt; ) {<br/>  if (await personPromise) {<br/>    console.log("person retrieved")<br/>  }<br/>}</span></pre><p id="1509" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="382a" class="mq lc iq mh b gy mr ms l mt mu">async function bar(personPromise: Promise&lt;Person&gt; ) {<br/>  const person = await personPromise; <br/>  if (person) {<br/>    console.log("person retrieved");<br/>  }<br/>}</span></pre><h1 id="34a0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有回报等待</h1><p id="1ee1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该在同一条线上使用<code class="fe me mf mg mh b">return</code>和<code class="fe me mf mg mh b">await</code>。</p><p id="d391" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只是在解决承诺之前增加了额外的时间，但是无论是否有<code class="fe me mf mg mh b">await</code>承诺都会被返回。</p><p id="8e0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4b73" class="mq lc iq mh b gy mr ms l mt mu">async function bar() {<br/>  return await aPromise;<br/>}</span></pre><p id="5c2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8749" class="mq lc iq mh b gy mr ms l mt mu">async function bar() {<br/>  return aPromise;<br/>}</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/5549dfeb5e972af0e370d32345167483.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*C9fSXlqf4vRg9Zv3"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@richardworks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Richard Burlton</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c3b2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3545" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">delete</code>运算符不应与计算表达式一起使用。</p><p id="314a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">for-in循环不应与数组一起使用。</p><p id="19fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">this</code>应该只用于对象文字和类。</p><p id="668f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">文字类型断言不应该用于强制对象的结构。</p><p id="5b9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">await</code>只能在<code class="fe me mf mg mh b">async</code>功能中的某些地方使用。</p><h1 id="de68" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单英语的JavaScript</h1><p id="f982" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>