<html>
<head>
<title>How to Solve a Sudoku with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript解一个数独</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/solve-a-sudoku-using-javascript-de456e8c34a5?source=collection_archive---------2-----------------------#2020-05-02">https://javascript.plainenglish.io/solve-a-sudoku-using-javascript-de456e8c34a5?source=collection_archive---------2-----------------------#2020-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/244e514d1b6340b56b00c39b55f6f746.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Msv0P6fIngQxn1PN_SVxbg.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Cover photo by <a class="ae jd" href="https://unsplash.com/@jayworks?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jonathan Ybema</a> on <a class="ae jd" href="https://unsplash.com/s/photos/sudoku-puzzle?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="bc6b" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">通过用JavaScript编写的例子，演示了解决流行的数独数字挑战的算法。</h2></div><h2 id="866d" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">游戏规则</strong></h2><p id="1cb4" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">对那些不熟悉数独规则的人做一个简单的总结。一个完整的数独是一个9 x 9的网格，其中每一个<strong class="lt jh">行</strong>、<strong class="lt jh">列</strong>和每一个<strong class="lt jh"> 3 x 3的正方形</strong>必须包含数字1-9中的每一个(并且只能包含一次)。下面的网格描述了遵守这些约束的单行、列和正方形。</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/33318240cb19ec08e5b920c14aeb1a6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:508/format:webp/1*z8WmYA6O2t0px1dtdr3ZjA.png"/></div></figure><p id="fcd3" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">游戏以部分完成的网格和复杂程度呈现，给出了预先填充的单元数量和这些单元的位置(提供“线索”)。他们的范围从简单到专家。</p><h2 id="0c5b" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">游戏输入</strong></h2><p id="34ed" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">为了挑战的利益，我们可以假设我们将从长度为9(行)的数组开始游戏。每行本身是一个长度为9(单元)的数组。</p><p id="429e" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">值将是0-9的整数，其中零表示空白。</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/7ab19b04d1fdc38ebd9eda72ea2ba64f.png" data-original-src="https://miro.medium.com/v2/resize:fit:742/format:webp/1*1nNuurGCY_Hy9UMmqSLHQA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Example Sudoku taken from Wikipedia</figcaption></figure><h2 id="1d12" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">助手功能</strong></h2><p id="e031" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">不管算法如何(我将在后面通过我采用的两种方法来讨论)，一些辅助函数总是有用的。源码分享在最后。</p><ul class=""><li id="9ad3" class="mv mw jg lt b lu mp lx mq le mx li my lm mz mj na nb nc nd bi translated"><strong class="lt jh"> <em class="ne"> get_row(board，row) </em> </strong> —由于游戏棋盘是一个行的数组，所以这是琐碎的，只是一个奢侈的方法！</li><li id="e365" class="mv mw jg lt b lu nf lx ng le nh li ni lm nj mj na nb nc nd bi translated"><strong class="lt jh"><em class="ne">【get _ column(board，column) </em> </strong> <em class="ne"> </em> —返回所提供列的所有单元格。</li><li id="db7b" class="mv mw jg lt b lu nf lx ng le nh li ni lm nj mj na nb nc nd bi translated"><strong class="lt jh"> <em class="ne"> get_square(board，square) </em> </strong> —我们可以在逻辑上将棋盘分割成9个3×3的正方形，给定<em class="ne"> (row，col) </em>坐标我们可以识别正方形，然后返回同一正方形内的所有单元格。</li><li id="dd3a" class="mv mw jg lt b lu nf lx ng le nh li ni lm nj mj na nb nc nd bi translated"><strong class="lt jh"><em class="ne">is _ solved(board)</em></strong>—给定一个已完成的棋盘，它是否正确，即我们是否完成了拼图？这个函数应该检查每一行、每一列和每一个正方形是否有完整的1-9值。</li><li id="0d0b" class="mv mw jg lt b lu nf lx ng le nh li ni lm nj mj na nb nc nd bi translated"><strong class="lt jh"><em class="ne">【print _ board(板)</em> </strong> <em class="ne"> </em> — <em class="ne"> </em>帮助可视化板/网格的功能。下面的输出是前面图片中游戏阵列的棋盘的起始位置。</li></ul><pre class="ml mm mn mo gt nk nl nm nn aw no bi"><span id="f655" class="kv kw jg nl b gy np nq l nr ns">|=======|=======|=======|<br/>| . . . | . . . | . . . |<br/>| . . . | . . 3 | . 8 5 |<br/>| . . 1 | . 2 . | . . . |<br/>|=======|=======|=======|<br/>| . . . | 5 . 7 | . . . |<br/>| . . 4 | . . . | 1 . . |<br/>| . 9 . | . . . | . . . |<br/>|=======|=======|=======|<br/>| 5 . . | . . . | . 7 3 |<br/>| . . 2 | . 1 . | . . . |<br/>| . . . | . 4 . | . . 9 |<br/>|=======|=======|=======|</span></pre><h2 id="a63c" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">两种方法</strong></h2><p id="1221" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我从两个角度来面对这个挑战，最后我使用了这两种技术——对于复杂的数独游戏来说，使用组合会更快。</p><p id="1121" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated"><strong class="lt jh">方法1。</strong>第一种方法是运用<strong class="lt jh">蛮力</strong>来解决问题。我们可以应用一个<a class="ae jd" href="https://en.wikipedia.org/wiki/Backtracking" rel="noopener ugc nofollow" target="_blank"> <strong class="lt jh">回溯</strong> </a>算法，遍历所有的空单元格，从值1开始并检查它是否有效。然后，我们移动到下一个空单元格，将其设置为1，并检查它是否有效。诸如此类。在任何时候，我们遇到一个不可能的解决方案(没有有效值的单元格)，我们尝试下一个值，然后下一个。如果我们用尽了当前单元格中的所有组合，我们会返回一个循环，增加前一个单元格的值，然后重新开始。</p><p id="b508" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">使用这种方法，一路回溯多次开始的情况并不少见。为了实现这种方法，我们可以使用一个简单的循环并应用递归(一个用改变或缩减的问题空间调用自己的函数)——逻辑只有几行。</p><p id="190d" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">我发现一种蛮力方法解决了所有数独游戏——但这是以<em class="ne">性能为代价的</em>。(尽管只有几分之一秒)。</p><p id="66e5" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated"><strong class="lt jh">方法二。</strong>这就是为什么我引入了第二种方法——<strong class="lt jh">单值单元格约束</strong>函数——当单独使用时，它解决了我扔给它的所有容易解决的问题，根本不需要诉诸暴力。在这里，我们应用了一个人在解决一个难题时会用到的技术——因此逻辑要长得多。</p><p id="7de5" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">我们获取每个空单元格，并确定它可能包含的值——将每个空单元格更新为其可能值的数组。</p><p id="39d8" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">如果任何单元格只能包含<strong class="lt jh">一个值</strong>，我们就在主游戏网格中将其正式设置为该值。所以在这个相当简单的例子中，标有“？”的单元格只有一个可能的值(9)。</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/0dd515181c6e52e1a6e0433e37bed490.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*mln22mRW6KuDs0cW3yTqXA.png"/></div></figure><p id="01d3" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">如果一个单元格有不止一个可能的值呢？在这种情况下，我们将每个可能的值<em class="ne"> x </em>与行、列和正方形中的其他单元格进行比较。如果<em class="ne"> x </em>仅作为该单元格的一种可能性出现，<em class="ne">不管该单元格可能有什么其他可能性</em>，都保证该单元格有该值。</p><p id="90c8" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">为了详细说明，在下一个示例中，标记为“？”的单元格可能第一次就有了可能性<code class="fe nu nv nw nl b">[1, 2, 3, 4, 5, 8, 9]</code>。然而，当我们查看行或正方形时，我们不会在任何其他单元格(标记为“x”)中找到值1的可能性。因此我们100%知道细胞"？一定是1的位置。人类会简单地在他们的大脑中应用这个规则。</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/9f4a97762ecd6abd0510ce9ffb34b34c.png" data-original-src="https://miro.medium.com/v2/resize:fit:626/format:webp/1*KReNwJxgft4XNwnYrxbmHQ.png"/></div></figure><p id="88a8" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">第二种方法是在整个表中迭代这两个循环，直到不能再应用更新为止— <strong class="lt jh">，它解决了大多数简单到中等复杂的数独问题。</strong></p><p id="e410" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">这也使得破解复杂的数独游戏——通过暴力—<strong class="lt jh">—</strong>要快得多，因为我们已经提前预填充了许多单元格。</p><h2 id="5d37" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">最终解决方案</strong></h2><p id="9437" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">解决方案是两种方法的结合；</p><ol class=""><li id="1056" class="mv mw jg lt b lu mp lx mq le mx li my lm mz mj ny nb nc nd bi translated"><strong class="lt jh">单值单元格约束</strong> —这里解决了大多数不复杂的解决方案。</li><li id="be8b" class="mv mw jg lt b lu nf lx ng le nh li ni lm nj mj ny nb nc nd bi translated"><strong class="lt jh">强力/回溯</strong> —在这里，我们可以重用(1)中的逻辑，即每次我们选择一个值，然后我们可以“向前看”并填充任何现在只有一个可能值的单元格，从而缩小问题空间(或快速消除我们认为不可能的选择)。</li></ol><p id="c9a1" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">这两种方法的结合解决了我早期单独使用蛮力挑战复杂数独的性能问题。</p><h2 id="cd33" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">代码</strong></h2><p id="affa" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">入口函数是<code class="fe nu nv nw nl b">solved(board)</code>，它调用实现前面描述的两种方法的函数。我们迭代我们的<strong class="lt jh">单值单元格约束</strong>函数，只要更新仍然被应用(即单元格被填充，因为它们只有一个可能的值)。当我们解决了数独或者不再填充任何单元格时，这个循环就结束了。</p><p id="311b" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">如果我们没有解决数独，那么我们就退回到<strong class="lt jh">强力</strong>功能。我们假设网格可以被解决——也就是说，不要试图抓住我们——所以最后我们会将电路板作为一个完整的解决方案返回。</p><pre class="ml mm mn mo gt nk nl nm nn aw no bi"><span id="4389" class="kv kw jg nl b gy np nq l nr ns">function solve(board) {</span><span id="22a2" class="kv kw jg nl b gy nz nq l nr ns">  let updated = true, solved = false<br/>    <br/>  while (updated &amp;&amp; !solved) {<br/>    updated = <strong class="nl jh">one_value_cell_constraint</strong>(board)<br/>    solved = is_solved(board)<br/>  }</span><span id="5904" class="kv kw jg nl b gy nz nq l nr ns">  if (!solved) {<br/>    board = <strong class="nl jh">backtrack_based</strong>(board)<br/>  }</span><span id="b5cb" class="kv kw jg nl b gy nz nq l nr ns">  return board<br/>}</span></pre></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><p id="9827" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">在<code class="fe nu nv nw nl b">one_value_cell_constraint</code>函数中(如下所示),我们保存了<code class="fe nu nv nw nl b">updated</code>的记录，网格的任何变化都会让我们继续下一次迭代——因为我们正在实时编辑游戏网格，函数中的每个循环都建立在之前的更新之上。</p><p id="45d2" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">在内部，我们使用了一个名为<code class="fe nu nv nw nl b">complete_cell</code>的函数，我们在后面的强力逻辑中也会用到它。该函数查找单元格的所有可能值—如果只有一个值，它将单元格设置为该值；如果有多个值，它将单元格设置为包含所有可能值的数组(如<code class="fe nu nv nw nl b">[1, 4, 5]</code>)。</p><p id="1c28" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">下一部分选取任何具有一系列可能性的单元格，并查看相应的行、列和方块，以查看是否有可能的值<code class="fe nu nv nw nl b">appears_once_only</code>。如果是，那么我们将单元格设置为该值。</p><pre class="ml mm mn mo gt nk nl nm nn aw no bi"><span id="9f41" class="kv kw jg nl b gy np nq l nr ns">function one_value_cell_constraint(board) {</span><span id="eb69" class="kv kw jg nl b gy nz nq l nr ns">  updated = false</span><span id="2d4a" class="kv kw jg nl b gy nz nq l nr ns">  // Convert every gap into an array of possibilities<br/>  for (let r = 0; r &lt; 9; r++) {<br/>    for (let c = 0; c &lt; 9; c++) {<br/>      if (board[r][c] == 0) {<br/>        updated = <strong class="nl jh">complete_cell</strong>(board, r, c) || updated<br/>      }<br/>    }<br/>  }</span><span id="524f" class="kv kw jg nl b gy nz nq l nr ns">  // Look out for any possibility that appears as a possibility<br/>  // once-only in the row, column, or quadrant.<br/>  for (let r = 0; r &lt; 9; r++) {<br/>    for (let c = 0; c &lt; 9; c++) {<br/>      if (Array.isArray(board[r][c])) {<br/>        let possibilities = board[r][c]<br/>        updated = <br/>          <strong class="nl jh">appears_once_only</strong>(board, possibilities, get_row(board, r), r, c) ||<br/>          <strong class="nl jh">appears_once_only</strong>(board, possibilities, get_column(board, c), r, c) ||<br/>          <strong class="nl jh">appears_once_only</strong>(board, possibilities, get_square(board, square_coordinates[r][c]), r, c) || updated<br/>      }<br/>    }<br/>  }</span><span id="bb6e" class="kv kw jg nl b gy nz nq l nr ns">  // Reinitialize gaps back to zero before ending<br/>  for (let r = 0; r &lt; 9; r++) {<br/>    for (let c = 0; c &lt; 9; c++) {<br/>      if (Array.isArray(board[r][c])) {<br/>        board[r][c] = 0<br/>      }<br/>    }<br/>  }</span><span id="6b5c" class="kv kw jg nl b gy nz nq l nr ns">  return updated<br/>}</span></pre><p id="aaf1" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">最后，<strong class="lt jh">暴力</strong>逻辑在我们的<code class="fe nu nv nw nl b">backtrack_based</code>函数中。</p><p id="7fc2" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">因为我们可能会跟踪死胡同，所以我们处理数组的副本——尽管JavaScript通过值在<em class="ne">中传递模板，数组中的所有对象都是引用JSON库帮助深度克隆数组。</em></p><p id="d49f" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">我们迭代每个空单元格，并最初重用我们之前提到的<code class="fe nu nv nw nl b">complete_cell</code>函数。如果只有一个可能的值，这将填充单元格——这在我们到达最后一个空单元格时很有用，这将基本上解决棋盘，因此我们在这里包含一个<code class="fe nu nv nw nl b">is_solved</code>检查并返回解决的棋盘。</p><p id="96c6" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">假设我们得到一个可能值的列表，我们依次迭代这些可能性——将单元格设置为列表中的第一个值，并递归调用函数。在某个阶段，一个递归会成功结束(用<code class="fe nu nv nw nl b">complete_cell</code>填充最后一个单元格)，但很可能我们会进入一个‘死胡同’。如果我们用尽了所有可能的值，我们返回false并回溯。</p><pre class="ml mm mn mo gt nk nl nm nn aw no bi"><span id="cf58" class="kv kw jg nl b gy np nq l nr ns">function backtrack_based(orig_board) {</span><span id="d0f8" class="kv kw jg nl b gy nz nq l nr ns">  // Create a temporary board for our recursion.<br/>  let board = JSON.parse(JSON.stringify(orig_board));</span><span id="bd1f" class="kv kw jg nl b gy nz nq l nr ns">  for (let r = 0; r &lt; 9; r++) {<br/>    for (let c = 0; c &lt; 9; c++) {<br/>      if (board[r][c] == 0) {<br/><strong class="nl jh">        complete_cell(board, r, c)<br/>        if (is_solved(board)) return board;</strong></span><span id="55ea" class="kv kw jg nl b gy nz nq l nr ns">        let cell = board[r][c]<br/>        if (Array.isArray(cell)) {<br/>          for (let i = 0; i &lt; cell.length; i++) {</span><span id="3fce" class="kv kw jg nl b gy nz nq l nr ns">            // Create a temporary board for each recursion.<br/>            let board_2 = JSON.parse(JSON.stringify(board));</span><span id="7eab" class="kv kw jg nl b gy nz nq l nr ns">            // Choose a value<br/>            board_2[r][c] = cell[i]</span><span id="1e76" class="kv kw jg nl b gy nz nq l nr ns">            // Recurse again using new board<br/><strong class="nl jh">            if (completed_board = backtrack_based(board_2)) {<br/>              return completed_board;<br/>            }<br/></strong>          }<br/>          return false // dead end<br/>        }<br/>      }<br/>    }<br/>  }</span><span id="8f04" class="kv kw jg nl b gy nz nq l nr ns">  return false;<br/>}</span></pre><h2 id="3fbf" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">结论和实例</strong></h2><p id="c899" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">首先——<strong class="lt jh">代码起作用了</strong>，包括对抗“<em class="ne">数独，该数独是为对抗暴力算法</em>而设计的。将两种不同的技术结合起来使用是一个很有价值的学习点。</p><figure class="ml mm mn mo gt is gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/8ce9f4e433e9bf226fcdc3a89af64c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*PS-CY6dpimCTQ-hfZXfRkg.png"/></div></figure><p id="f6d5" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">代码可以优化，尽管即使是最困难的代码，性能也是次秒级的。每次递归复制数组都会引入内存开销，我本可以解决这个问题。</p><h2 id="ef52" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">一些示例游戏和解决方案</strong></h2><div class="ml mm mn mo gt ab cb"><figure class="oi is oj ok ol om on paragraph-image"><img src="../Images/2e72f9925e7fcc764c70898b5de575e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*IkVH6XOsS-GQQKiTrBDQLg.png"/></figure><figure class="oi is oo ok ol om on paragraph-image"><img src="../Images/bc2d079b0dcada005b7395a9bda74396.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*0iueM3J8223Vx6aOBQuYPA.png"/></figure><figure class="oi is op ok ol om on paragraph-image"><img src="../Images/799771f7951f4c1864eb5d12e99269d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*epVMv5hNJCsY2LRRtYvdqg.png"/></figure></div></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><h2 id="4562" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">延伸阅读</strong></h2><ul class=""><li id="93c5" class="mv mw jg lt b lu lv lx ly le oq li or lm os mj na nb nc nd bi translated"><a class="ae jd" href="https://github.com/davelms/medium-articles/blob/master/sudoku-solver/sudoku.js" rel="noopener ugc nofollow" target="_blank">这个解决方案的源代码</a>可以在GitHub上找到。</li><li id="c85d" class="mv mw jg lt b lu nf lx ng le nh li ni lm nj mj na nb nc nd bi translated">维基百科关于“数独求解算法”的文章。</li></ul><div class="ip iq gp gr ir ot"><a href="https://en.wikipedia.org/wiki/Sudoku_solving_algorithms" rel="noopener  ugc nofollow" target="_blank"><div class="ou ab fo"><div class="ov ab ow cl cj ox"><h2 class="bd jh gy z fp oy fr fs oz fu fw jf bi translated">数独求解算法</h2><div class="pa l"><h3 class="bd b gy z fp oy fr fs oz fu fw dk translated">一个标准的数独游戏包含81个单元格，在9×9的网格中，有9个盒子，每个盒子是第一个…</h3></div><div class="pb l"><p class="bd b dl z fp oy fr fs oz fu fw dk translated">en.wikipedia.org</p></div></div><div class="pc l"><div class="pd l pe pf pg pc ph ix ot"/></div></div></a></div></div><div class="ab cl oa ob hu oc" role="separator"><span class="od bw bk oe of og"/><span class="od bw bk oe of og"/><span class="od bw bk oe of"/></div><div class="ij ik il im in"><h2 id="c984" class="kv kw jg bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="14fa" class="pw-post-body-paragraph lr ls jg lt b lu lv kh lw lx ly kk lz le ma mb mc li md me mf lm mg mh mi mj ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae jd" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="lt jh">AI in Plain English</strong></a>，<a class="ae jd" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="lt jh">UX in Plain English</strong></a>，<a class="ae jd" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="lt jh">Python in Plain English</strong></a><strong class="lt jh"/>—谢谢，继续学习！</p><p id="a142" class="pw-post-body-paragraph lr ls jg lt b lu mp kh lw lx mq kk lz le mr mb mc li ms me mf lm mt mh mi mj ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae jd" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="lt jh">submissions @ plain English . io</strong></a><strong class="lt jh"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>