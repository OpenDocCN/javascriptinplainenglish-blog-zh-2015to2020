<html>
<head>
<title>Parsing post data 3 different ways in Node.js without third-party libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中以3种不同的方式解析post数据，无需第三方库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/parsing-post-data-3-different-ways-in-node-js-e39d9d11ba8?source=collection_archive---------1-----------------------#2020-05-02">https://javascript.plainenglish.io/parsing-post-data-3-different-ways-in-node-js-e39d9d11ba8?source=collection_archive---------1-----------------------#2020-05-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/7581de9ed4fe25a623b093b26834b88a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AQs3uqzdAUiCUxRU0rg9bQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="30df" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated">application/json、application/x-www-form-urlencoded和multipart/form-data</h2></div><p id="44db" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">好吧，老实说，这并不容易，因为我到处都可以找到第三方库的解决方案或者只是部分理论信息，正如你可能已经知道的，我正在从头开始学习Node.js和web技术，以了解幕后发生的事情。</p><p id="30d8" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">完整的源代码在这篇文章的末尾，所以如果你知道你在做什么，你可以直接进入，如果你也在学习，享受阅读。</p><p id="a3b5" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这个项目利用了我在以前的帖子中分享的知识，所以我不会在这里讨论这些主题:</p><ul class=""><li id="8b08" class="lj lk iy kp b kq kr kt ku kw ll la lm le ln li lo lp lq lr bi translated"><a class="ae ls" href="https://medium.com/@ObjSal/how-to-encode-node-js-response-from-scratch-ce520018d6" rel="noopener">如何从头编码Node.js响应</a></li><li id="82d4" class="lj lk iy kp b kq lt kt lu kw lv la lw le lx li lo lp lq lr bi translated"><a class="ae ls" href="https://medium.com/@ObjSal/im-going-to-start-playing-with-node-js-ad1aa7f2ebbb" rel="noopener">我要开始玩Node.js了</a></li></ul><h1 id="d454" class="ly lz iy bd ma mb mc md me mf mg mh mi ke mj kf mk kh ml ki mm kk mn kl mo mp bi translated">1.application/x-www-form-urlencoded</h1><p id="bb77" class="pw-post-body-paragraph kn ko iy kp b kq mq jz ks kt mr kc kv kw ms ky kz la mt lc ld le mu lg lh li ig bi translated">html <a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form" rel="noopener ugc nofollow" target="_blank">表单</a>的默认<a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/enctype" rel="noopener ugc nofollow" target="_blank"> enctyp </a>是<code class="fe mv mw mx my b">application/x-www-form-urlencoded</code>，它发送的数据格式与你访问网站时在URL上看到的格式相同，例如:<code class="fe mv mw mx my b">name1=value2&amp;name2-value2</code>，发布文件时编码类型变为<code class="fe mv mw mx my b">multipart/form-data</code>，我们将在后面的故事中展示如何解析这类请求。</p><p id="2fd5" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">下面的HTML片段创建了一个将请求编码为<code class="fe mv mw mx my b">application/x-www-form-urlencoded</code>的表单，</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="ee90" class="nh lz iy my b gy ni nj l nk nl">&lt;form method="post"&gt;  <br/>  &lt;input id="username1" type="text" name="username"&gt;<br/>  &lt;input id="password1" type="password" name="password"&gt;<br/>  &lt;input type="submit"&gt;<br/>&lt;/form&gt;</span></pre><p id="864b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">上面的表单使用POST方法发送数据，您也可以将这种数据作为GET请求发送，但是我更愿意解析请求正文中的数据，而不是URL。</p><p id="c211" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在表单标签中有3种不同的输入类型，文本、密码和提交。</p><ul class=""><li id="50b7" class="lj lk iy kp b kq kr kt ku kw ll la lm le ln li lo lp lq lr bi translated"><code class="fe mv mw mx my b">text</code>:用于捕捉文本。</li><li id="408e" class="lj lk iy kp b kq lt kt lu kw lv la lw le lx li lo lp lq lr bi translated"><code class="fe mv mw mx my b">password</code>:与文本相同，但明显隐藏文本，并为每个键入的字符加上“”。</li><li id="dd28" class="lj lk iy kp b kq lt kt lu kw lv la lw le lx li lo lp lq lr bi translated"><code class="fe mv mw mx my b">submit</code>:创建触发post请求的按钮。</li></ul><p id="e5ed" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">输入中的<code class="fe mv mw mx my b">id</code>对于使用CSS进行样式化或者在通过JavaScript访问字段时很容易找到它们很有用。</p><p id="7f88" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><code class="fe mv mw mx my b">name</code>是真正<strong class="kp iz">重要的</strong>，如果不包含名称，它就不会将数据发送到服务器，名称是用来标识从服务器端传入的数据。</p><p id="b0f9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">因为这个表单在第一个<code class="fe mv mw mx my b">&lt;form&gt;</code>标签中没有包含<code class="fe mv mw mx my b">action</code>参数，所以它将请求发送到浏览器中加载的同一个URL。</p><p id="4443" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在，我们如何从Node.js中读取和解析这种数据呢？</p><p id="1d95" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">为了读取数据，我添加了对<code class="fe mv mw mx my b">data</code>和<code class="fe mv mw mx my b">end</code>发射事件的回调，如下所示:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="3196" class="nh lz iy my b gy ni nj l nk nl">const querystring = require('querystring')</span><span id="aee3" class="nh lz iy my b gy nm nj l nk nl">let rawData = ''<br/>request.on('data', chunk =&gt; {<br/>  rawData += chunk<br/>})</span><span id="7646" class="nh lz iy my b gy nm nj l nk nl">request.on('end', () =&gt; {<br/>  let parsedData = querystring.decode(rawData)<br/>  ...<br/>}</span></pre><p id="b54b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在注册回调之前，我声明并初始化了一个名为<code class="fe mv mw mx my b">rawData</code>的字符串，以便按顺序追加所有传入的数据，每次有数据可供服务器读取时将调用<code class="fe mv mw mx my b">data</code>事件，当没有更多传入的数据时将调用<code class="fe mv mw mx my b">end</code>事件。我使用<code class="fe mv mw mx my b">end</code>事件解析完整的捕获数据，并将响应发送给服务器。</p><p id="91bc" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">解析<code class="fe mv mw mx my b">application/x-www-form-urlencoded</code>是一个一行的！Node.js为这种类型的解析提供了一个名为<code class="fe mv mw mx my b">querystring</code>的内置库。</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><h1 id="7148" class="ly lz iy bd ma mb nu md me mf nv mh mi ke nw kf mk kh nx ki mm kk ny kl mo mp bi translated">2.应用程序/json</h1><p id="ce9b" class="pw-post-body-paragraph kn ko iy kp b kq mq jz ks kt mr kc kv kw ms ky kz la mt lc ld le mu lg lh li ig bi translated">解析JSON POST请求也是一个单独的程序，繁琐的部分来自HTML的观点，因为我们必须破解表单以防止它的默认行为，手动从表单中读取数据，手动创建JSON并创建请求。</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="5795" class="nh lz iy my b gy ni nj l nk nl">&lt;form action="javascript:" onsubmit="onFormSubmit(this)"&gt;<br/>  &lt;input id="username2" type="text"&gt;<br/>  &lt;input id="password2" type="password"&gt;<br/>  &lt;input type="submit"&gt;<br/>&lt;/form&gt;</span></pre><p id="6442" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在上面的HTML表单中，我们使用<code class="fe mv mw mx my b">action</code>来告诉表单它将触发一个javascript方法，而不是默认行为，我们使用<code class="fe mv mw mx my b">onsubmit</code>来指定当用户按下提交按钮时调用哪个JavaScript方法，我们将<code class="fe mv mw mx my b">this</code>作为参数发送给函数，以便我们能够从表单中读取信息。</p><p id="cd54" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">为了简单起见，我在同一个HTML站点中创建了<code class="fe mv mw mx my b">onFormSubmit(form)</code>方法，如下所示:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="3397" class="nh lz iy my b gy ni nj l nk nl">&lt;head&gt;<br/>...<br/>  &lt;script&gt;<br/>    'use strict'<br/>    function onFormSubmit(form) {<br/>      const username = form["username2"].value<br/>      const password = form["password2"].value<br/>      let body = JSON.stringify({<br/>        username: username,<br/>        password: password<br/>      });<br/>      (async () =&gt; {<br/>        try {<br/>          const response = await fetch('/', {<br/>            headers: {<br/>              'content-type': 'application/json'<br/>            },<br/>            method: 'POST',<br/>            body: body<br/>          })<br/>          const text = await response.text()<br/>          if (response.status !== 200) {<br/>            if (text &amp;&amp; text.length &gt; 0) {<br/>              console.error(text)<br/>            } else {<br/>              console.error('There was an error')<br/>            }<br/>            return<br/>          }<br/>          document.body.innerHTML = text<br/>        } catch (e) {<br/>          console.error(e.message)<br/>        }<br/>      })()<br/>    }<br/>  &lt;/script&gt;<br/>&lt;/head&gt;</span></pre><p id="6644" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">首先，我们使用表单中给定的<code class="fe mv mw mx my b">id</code>从用户名和密码中读取值。</p><p id="ace9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">然后，我们使用<code class="fe mv mw mx my b">JSON.stringify()</code>创建JSON字符串响应。</p><p id="53be" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">然后我创建一个POST fetch请求，指定数据为<code class="fe mv mw mx my b">application/json</code>，JSON数据为<code class="fe mv mw mx my b">body</code>。</p><p id="66b5" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">接下来的几行读取服务器响应，使用<code class="fe mv mw mx my b">document.body.innerHTML = text</code>行，我们用返回给浏览器的数据替换站点的当前内容，以获得与上面<code class="fe mv mw mx my b">application/x-www-form-urlencoded</code>类似的行为。</p><p id="7bc0" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在服务器端，我使用相同的<code class="fe mv mw mx my b">data</code>和<code class="fe mv mw mx my b">end</code> emit方法读取数据，然后用<code class="fe mv mw mx my b">JSON.parse(rawData)</code>解析数据。</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><h1 id="e122" class="ly lz iy bd ma mb nu md me mf nv mh mi ke nw kf mk kh nx ki mm kk ny kl mo mp bi translated">3.多部分/表单数据</h1><p id="b8b7" class="pw-post-body-paragraph kn ko iy kp b kq mq jz ks kt mr kc kv kw ms ky kz la mt lc ld le mu lg lh li ig bi translated">这是最棘手的一个，这不是一个接近一行；如果真的这么复杂，为什么还要麻烦呢？简单的答案是在单个请求中传输带有表单数据的文件。</p><p id="5ce3" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">有不同的方法来解析这些数据，但在本例中，我将所有数据加载到内存中，然后将给定的文件存储到服务器中，当然，与前面的示例一样，也将请求数据作为响应数据返回，我从响应中删除了二进制文件，因为我在网站上显示数据，加载二进制文件需要很长时间。HTML表单比<code class="fe mv mw mx my b">application/json</code>简单，它基本上和<code class="fe mv mw mx my b">application/x-www-form-urlencoded</code>一样，但是编码不同(enctype)</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="47c5" class="nh lz iy my b gy ni nj l nk nl">&lt;form method="post" enctype="multipart/form-data"&gt;<br/>  &lt;input id="username3" type="text" name="username"&gt;<br/>  &lt;input id="password3" type="password" name="password"&gt;<br/>  &lt;input id="picture3" type="file" name="picture"&gt;<br/>  &lt;input type="submit"&gt;<br/>&lt;/form&gt;</span></pre><p id="9f2a" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">与<code class="fe mv mw mx my b">x-www-form-urlencoded</code>不同的是，我们没有显式地将enctype赋给<code class="fe mv mw mx my b">multipart/form-data</code>，而是在mix中添加了一个名为picture的<code class="fe mv mw mx my b">file</code>输入类型。</p><p id="2f07" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我使用与前面方法相同的<code class="fe mv mw mx my b">data</code>和<code class="fe mv mw mx my b">end</code>发出事件回调，但是这一次，在我们注册回调之前，我们将请求编码更改为<code class="fe mv mw mx my b">latin1</code>，以便它正确读取二进制数据。</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="6a7e" class="nh lz iy my b gy ni nj l nk nl">if (request.headers['content-type'] === 'multipart/form-data') {<br/>  // Use latin1 encoding to parse binary files correctly<br/>  request.setEncoding('latin1')<br/>}</span></pre><p id="576d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated"><code class="fe mv mw mx my b">multipart/form-data</code>发送的数据由浏览器发送的content-type头中指定的边界分割成多个部分，例如:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="e4cc" class="nh lz iy my b gy ni nj l nk nl">------WebKitFormBoundaryxJi9AgGdxx83BunR<br/>Content-Disposition: form-data; name="username"</span><span id="5a63" class="nh lz iy my b gy nm nj l nk nl">sal<br/>------WebKitFormBoundaryxJi9AgGdxx83BunR<br/>Content-Disposition: form-data; name="password"</span><span id="d302" class="nh lz iy my b gy nm nj l nk nl">pass<br/>------WebKitFormBoundaryxJi9AgGdxx83BunR<br/>Content-Disposition: form-data; name="picture"; filename="Chromium_11_Logo.svg"<br/>Content-Type: image/svg+xml</span><span id="89da" class="nh lz iy my b gy nm nj l nk nl">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;<br/>&lt;!-- Created with Inkscape (<a class="ae ls" href="http://www.inkscape.org/" rel="noopener ugc nofollow" target="_blank">http://www.inkscape.org/</a>) --&gt;</span><span id="5755" class="nh lz iy my b gy nm nj l nk nl">&lt;svg&gt;<br/>...<br/>&lt;/svg&gt;</span><span id="df80" class="nh lz iy my b gy nm nj l nk nl">------WebKitFormBoundaryxJi9AgGdxx83BunR--</span></pre><p id="459d" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">上例中的边界是<code class="fe mv mw mx my b">------WebKitFormBoundaryxJi9AgGdxx83BunR</code>，我创建了一个助手函数来从请求头中提取边界，如下所示:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="8fe5" class="nh lz iy my b gy ni nj l nk nl">function getBoundary(request) {<br/>  let contentType = request.headers['content-type']<br/>  const contentTypeArray = contentType.split(';').map(item =&gt; item.trim())<br/>  const boundaryPrefix = 'boundary='<br/>  let boundary = contentTypeArray.find(item =&gt; item.startsWith(boundaryPrefix))<br/>  if (!boundary) return null<br/>  boundary = boundary.slice(boundaryPrefix.length)<br/>  if (boundary) boundary = boundary.trim()<br/>  return boundary<br/>}</span></pre><p id="f1ae" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在上面的方法中，我从<code class="fe mv mw mx my b">content-type</code>头中读取信息，然后通过<code class="fe mv mw mx my b">;</code>将其拆分，然后从content-type中的每个条目中读取<code class="fe mv mw mx my b">trim</code>空格，然后通过检查<code class="fe mv mw mx my b">boundary=</code>作为前缀在数组上运行<code class="fe mv mw mx my b">find()</code>方法来获得边界，然后返回前缀后的字符串。</p><p id="b8cf" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">现在我们知道了如何获得边界，我们将使用它来分割请求post主体，如下所示:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="84a7" class="nh lz iy my b gy ni nj l nk nl">const boundary = getBoundary(request)<br/>let result = {}<br/>const rawDataArray = rawData.split(boundary)<br/>for (let item of rawDataArray) {<br/>  ...<br/>}</span></pre><p id="cf06" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">在for循环中，我首先检查的是名字:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="4672" class="nh lz iy my b gy ni nj l nk nl">// Use non-matching groups to exclude part of the result<br/>let name = getMatching(item, /(?:name=")(.+?)(?:")/)<br/>if (!name || !(name = name.trim())) continue</span></pre><p id="835f" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">我使用非匹配组正则表达式搜索来排除匹配字符串的一部分，以便它只返回我要获取的数据，即与<code class="fe mv mw mx my b">(.+?)</code>匹配的名称，如果没有找到名称，则继续下一项。</p><p id="ef0e" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">接下来，我用一个有点复杂的正则表达式搜索获得给定命名输入的值，也使用了不匹配的组:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="ff32" class="nh lz iy my b gy ni nj l nk nl">let value = getMatching(item, /(?:\r\n\r\n)([\S\s]*)(?:\r\n--$)/)<br/>if (!value) continue</span></pre><p id="4164" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">上面匹配所有字符，包括空格、换行符和制表符，值与<code class="fe mv mw mx my b">([\S\s]*)</code>匹配，如果没有找到值，我们继续数组中的下一项。</p><p id="8fc6" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">下一步是检查这个条目是否是一个文件，如果我们找到一个文件名，我们就会发现它，如下所示:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="1ad2" class="nh lz iy my b gy ni nj l nk nl">let filename = getMatching(item, /(?:filename=")(.*?)(?:")/)<br/>if (filename &amp;&amp; (filename = filename.trim())) {<br/>...<br/>}</span></pre><p id="3c82" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">文件名可以是空的，如果用户没有选择任何文件并按下提交按钮，这就是为什么我使用<code class="fe mv mw mx my b">(.*?)</code>匹配0个或更多字符来匹配文件名。</p><p id="c68c" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">如果文件名有效，我也搜索内容类型，如下所示:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="fd94" class="nh lz iy my b gy ni nj l nk nl">let contentType = getMatching(item, /(?:Content-Type:)(.*?)(?:\r\n)/)</span></pre><p id="c87b" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">上面的regex字符串与带有<code class="fe mv mw mx my b">(.*?)</code>的内容类型匹配。</p><p id="dea0" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">因为在示例中post请求中可能有几个文件，所以我将所有文件存储在结果数组中，为了将文件存储在服务器中，我执行了以下操作:</p><pre class="mz na nb nc gt nd my ne nf aw ng bi"><span id="cbbc" class="nh lz iy my b gy ni nj l nk nl">for (let file of data.files) {<br/>  const stream = fs.createWriteStream(file.filename)<br/>  stream.write(file.picture, 'binary')<br/>  stream.close()<br/>  file.picture = 'bin'<br/>}</span></pre><p id="57a9" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">请注意，在写文件时，我将编码设置为<code class="fe mv mw mx my b">binary</code>，这是正确存储文件所必需的。</p></div><div class="ab cl nn no hr np" role="separator"><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns nt"/><span class="nq bw bk nr ns"/></div><div class="ig ih ii ij ik"><p id="8dbd" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">这就是现在所知道的如何对参数和表单配置的所有组合进行编码，但是这个例子应该给你一个很好的开始来创建你自己的完整的解析器，或者只是了解许多库的幕后发生了什么。</p><p id="8a66" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">完整的源代码你应该你的实现<code class="fe mv mw mx my b">getMatching()</code>在上面的例子中使用正则表达式查找匹配字符串，你还会发现一些条件来验证请求，以及一个安全措施来拒绝请求大于#字节；所有的解析代码都在一个名为<code class="fe mv mw mx my b">security-utils.js</code>的文件中，3种HTML格式在index.html都有。</p><figure class="mz na nb nc gt ip"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="7a5c" class="pw-post-body-paragraph kn ko iy kp b kq kr jz ks kt ku kc kv kw kx ky kz la lb lc ld le lf lg lh li ig bi translated">参考</p><ul class=""><li id="1ea1" class="lj lk iy kp b kq kr kt ku kw ll la lm le ln li lo lp lq lr bi translated"><a class="ae ls" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/HTML/Element/form</a></li><li id="1e2b" class="lj lk iy kp b kq lt kt lu kw lv la lw le lx li lo lp lq lr bi translated"><a class="ae ls" href="https://nodejs.org/api/querystring.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/api/querystring.html</a></li><li id="a61b" class="lj lk iy kp b kq lt kt lu kw lv la lw le lx li lo lp lq lr bi translated"><a class="ae ls" href="https://stackoverflow.com/q/42128238" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/q/42128238</a></li><li id="0fda" class="lj lk iy kp b kq lt kt lu kw lv la lw le lx li lo lp lq lr bi translated"><a class="ae ls" href="https://stackoverflow.com/a/44194173" rel="noopener ugc nofollow" target="_blank">https://stackoverflow.com/a/44194173</a></li><li id="96fc" class="lj lk iy kp b kq lt kt lu kw lv la lw le lx li lo lp lq lr bi translated"><a class="ae ls" href="https://itnext.io/how-to-handle-the-post-request-body-in-node-js-without-using-a-framework-cd2038b93190" rel="noopener ugc nofollow" target="_blank">https://it next . io/how-to-handle-the-post-request-body-in-node-js-without-using-a-framework-CD 2038 b 93190</a></li></ul><h1 id="b285" class="ly lz iy bd ma mb mc md me mf mg mh mi ke mj kf mk kh ml ki mm kk mn kl mo mp bi translated"><strong class="ak">简明英语团队的笔记</strong></h1><p id="8ac9" class="pw-post-body-paragraph kn ko iy kp b kq mq jz ks kt mr kc kv kw ms ky kz la mt lc ld le mu lg lh li ig bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae ls" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kp iz"> plainenglish.io </strong> </a>找到所有这些内容——关注我们的出版物并<a class="ae ls" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kp iz">订阅我们的YouTube频道</strong> </a> <strong class="kp iz">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>