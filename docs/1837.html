<html>
<head>
<title>Top 10 Quick Tips for JavaScript Developers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript开发人员的10大快速技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/top-10-tips-to-be-a-professional-javascript-developer-in-3-minutes-117192b8bb9b?source=collection_archive---------11-----------------------#2020-04-27">https://javascript.plainenglish.io/top-10-tips-to-be-a-professional-javascript-developer-in-3-minutes-117192b8bb9b?source=collection_archive---------11-----------------------#2020-04-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/24580bdf5d1ccee9c6a4cb0bef379593.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4lAsKrwpZhqCrYIxBKV1RQ.png"/></div></div></figure><div class=""/><p id="e6a1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们在编程中更经常听到“数据绑定”这个词。“数据绑定”的关键是监控数据的变化，但对于这样一个对象:<code class="fe kw kx ky kz b">let obj = {value: 1}</code>，我们该如何知道obj发生了变化？</p><h1 id="5bfe" class="la lb jb bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">1.定义属性</h1><p id="a107" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">ES5提供了Object.defineProperty方法，可以在对象上定义新的属性，或者修改对象的现有属性，并返回对象。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="8675" class="ml lb jb kz b gy mm mn l mo mp">obj: an object<br/>prop: attributes of the object<br/>descriptor: the description of the permission of the object<!-- --> </span></pre></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><pre class="mh kz mi mj aw mk bi"><span id="f7ce" class="ml lb jb kz b gy mx my mz na nb mn l mo mp">let obj = {}<br/>Object.defineProperty(obj, "money", {<br/>    value : 100, // Updated value, the default value is undefine.<br/>    writable : true, // The property can only be changed by the assignment operator if and only if the property's writable is true. The default is false.<br/>    enumerable : true, // This attribute can appear in the enumerated attribute of an object if and only if the enumerable of this attribute is true. The default is false.<br/>    configurable : true // The property descriptor can be changed and deleted if and only if the property's configurable is true. The default is false.<br/>    get: () =&gt; value; // Get current value <br/>    set: (newVal) =&gt; newVal; // Set current value<br/>});</span></pre><h1 id="ab8f" class="la lb jb bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">2.原型继承</h1><p id="51da" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">从父类继承的简单方法是，定义子类的原型并创建一个新的常量，以获得父类的值。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="05e2" class="ml lb jb kz b gy mm mn l mo mp">function Car() {<br/>    this.brand = 'bmw';<br/>}<br/><br/>Car.prototype.getBrand = () =&gt; console.log(this.brand)<br/><br/>function ElectricCar() {}<br/><br/>ElectricCar.prototype = new Car();<br/><br/>const eleCar = new ElectricCar();<br/><br/>console.log(eleCar.getBrand()); <br/><br/>// bmw</span></pre><p id="07cd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，如果您需要在其他地方重用子节点，也有一个经典的方法来保持从父节点的纯继承。参见例如</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="f9a9" class="ml lb jb kz b gy mm mn l mo mp">function Car() {<br/>    this.brand = ['bmw', 'audi'];<br/>}<br/><br/>function ElectricCar() {<br/>    Car.call(this);<br/>}<br/><br/>const carA = new ElectricCar();<br/><br/>carA.brand.push('toyota');<br/><br/>console.log(carA.brand); // ["bmw","audi","toyota"]<br/><br/>const carB = new ElectricCar();<br/><br/>console.log(carB.brand); // ['bmw', 'audi']</span></pre><h1 id="0cb4" class="la lb jb bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">3.致电/申请</h1><p id="3ac9" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated"><code class="fe kw kx ky kz b">Call</code>方法使用给定的this值和单独提供的参数调用函数。请参见下面的示例。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="b55d" class="ml lb jb kz b gy mm mn l mo mp">const food = {<br/>    value: 'apple'<br/>}<br/><br/>function fruit() {<br/>     console.log(this.value);<br/>}<br/><br/>fruit.call(food); // apple</span></pre><p id="05d5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">call、apply的相同用法可以达到相同的效果。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="df81" class="ml lb jb kz b gy mm mn l mo mp">Function.prototype.apply = (info, arr) =&gt; {<br/>      let info = Object(info) || window; <br/>      info.fn = this;</span><span id="674d" class="ml lb jb kz b gy nc mn l mo mp">      const result;<br/>      if(!arr) { result = info.fn(); }<br/>      else {<br/>        var args = [];<br/>        for (var i = 0, len = arr.length; i &lt; len; i++) {<br/>            args.push('arr[' + i + ']');<br/>        }<br/>        result = eval('info.fn(' + args + ')')<br/>    }</span><span id="1511" class="ml lb jb kz b gy nc mn l mo mp">    delete info.fn<br/>    return result;<br/>}</span></pre><h1 id="f870" class="la lb jb bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">4.记忆功能</h1><p id="af8f" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">程序经常浪费时间反复调用重新计算相同结果的函数。递归和数学函数尤其如此。斐波那契数生成器就是一个很好的例子。斐波那契数列是一系列整数，从0和1开始，其中每个值都是数列中前两个数的和。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="fd6c" class="ml lb jb kz b gy mm mn l mo mp">function memorize(func) {<br/>  var memo = {};<br/>  var slice = Array.prototype.slice;<br/><br/>  return function() {<br/>    var args = slice.call(arguments);<br/><br/>    if (args in memo)<br/>      return memo[args];<br/>    else<br/>      return (memo[args] = func.apply(this, args));<br/><br/>  }<br/>}</span></pre></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><pre class="mh kz mi mj aw mk bi"><span id="284c" class="ml lb jb kz b gy mx my mz na nb mn l mo mp">var count = function(a, b, c) {<br/>  return a + b + c<br/>}<br/><br/>var memoizedCount = memorize(count)<br/><br/>console.time('use memorize function')<br/>for(var i = 0; i &lt; 100000; i++) {<br/>    memoizedCount(1, 2, 3)<br/>}<br/>console.timeEnd('use memorize function')<br/><br/>console.time('without memorize function')<br/>for(var i = 0; i &lt; 100000; i++) {<br/>    count(1, 2, 3)<br/>}<br/>console.timeEnd('without memorize function')</span></pre><h1 id="2552" class="la lb jb bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">5.标志</h1><p id="d645" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">符号值可以用于对象的标签或属性名，并且它承诺相同的属性名。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="4a41" class="ml lb jb kz b gy mm mn l mo mp">var mySymbol = Symbol();<br/><br/>// FIRST<br/>var a = {};<br/>a[mySymbol] = 'Hello!';<br/><br/>// SECOND<br/>var a = {<br/><br/>};<br/><br/>// THIRD<br/>var a = {};<br/>Object.defineProperty(a, mySymbol, { value: 'Hello!' });<br/><br/>// All of them have the same result but they never equal to each other.<br/>console.log(a[mySymbol]); // "Hello!"</span></pre></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><pre class="mh kz mi mj aw mk bi"><span id="fe1c" class="ml lb jb kz b gy mx my mz na nb mn l mo mp">var s1 = Symbol.for("foo");<br/>console.log(Symbol.keyFor(s1)); // "foo"<br/><br/>var s2 = Symbol("foo");<br/>console.log(Symbol.keyFor(s2) ); // undefined</span></pre><h1 id="1cc9" class="la lb jb bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">6.数组. from()</h1><p id="a4cb" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">从ES6开始，<code class="fe kw kx ky kz b">[...arguments]</code>被迅速使用。它是如何从一个数组中产生的？看吧。例如</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="428b" class="ml lb jb kz b gy mm mn l mo mp">function mul(a, b) {<br/>    let args = Array.from(arguments); // [4, 5]<br/>    console.log(args.reduce((sum, cur) =&gt; sum * cur));<br/>}<br/>mul(4,5); //9</span></pre><h1 id="41a2" class="la lb jb bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">7.Array.prototype.slice.call()</h1><p id="5508" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">参数本身不能调用数组方法，它是另一种类型的对象，但是属性从0，0，1，2 …排序，最后是被调用者和长度属性。我们也把这样的对象称为类数组。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="2ab3" class="ml lb jb kz b gy mm mn l mo mp">function mul(a, b) {<br/>    let args = Array.prototype.slice.call(arguments); // [4, 5]<br/>    console.log(args.reduce((sum, cur) =&gt; sum * cur));<br/>}<br/>mul(4,5); //20</span></pre><h1 id="4e3b" class="la lb jb bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">8.分类</h1><p id="0142" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">一次排序一个数组项，并以这种方式构造最终排序的数组。假设第一个项目已经排序，然后与第二个项目进行比较。第二项应该留在原处还是插在第一项之前？这样前两项排序正确，再和第三项比较(应该插在第一、第二还是第三个位置？)，等等。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="d903" class="ml lb jb kz b gy mm mn l mo mp">Array.prototype.insertionSort = function() {<br/>    let j<br/>    let temp<br/>    for (let i = 1; i &lt; this.length; i++) {<br/>        j = i<br/>        temp = this[i]<br/>        while (j &gt; 0 &amp;&amp; this[j - 1] &gt; temp) {<br/>            this[j] = this[j - 1]<br/>            j--<br/>        } <br/>        this[j] = temp<br/>        console.log(this.join(', '))<br/>    }<br/>    return this<br/>}</span></pre><h1 id="1cbc" class="la lb jb bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">9.异步/等待</h1><p id="16bf" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">ES2018引入了异步迭代器，类似于常规迭代器，只是next()方法返回一个承诺。因此，await可以与循环的for …一起使用，以串行方式运行异步操作。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="fb91" class="ml lb jb kz b gy mm mn l mo mp">async function increase(array) {<br/>    for await (let i of array) {<br/>         // request to api<br/>    }<br/>}</span></pre><h1 id="4b56" class="la lb jb bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">10.Javascript关键代码</h1><p id="0b46" class="pw-post-body-paragraph jy jz jb ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">了解JavaScript中的大部分关键代码可以帮助您改善web应用程序的用户体验。</p><pre class="md me mf mg gt mh kz mi mj aw mk bi"><span id="034b" class="ml lb jb kz b gy mm mn l mo mp">let keyCodeMap = {<br/>    8: 'Backspace',<br/>    9: 'Tab',<br/>    13: 'Enter',<br/>    16: 'Shift',<br/>    17: 'Ctrl',<br/>    18: 'Alt',<br/>    19: 'Pause',<br/>    20: 'Caps Lock',<br/>    27: 'Escape',<br/>    32: 'Space',<br/>    33: 'Page Up',<br/>    34: 'Page Down',<br/>    35: 'End',<br/>    36: 'Home',<br/>    37: 'Left',<br/>    38: 'Up',<br/>    39: 'Right',<br/>    40: 'Down',<br/>    42: 'Print Screen',<br/>    45: 'Insert',<br/>    46: 'Delete',<br/><br/>    48: '0',<br/>    49: '1',<br/>    50: '2',<br/>    51: '3',<br/>    52: '4',<br/>    53: '5',<br/>    54: '6',<br/>    55: '7',<br/>    56: '8',<br/>    57: '9',<br/><br/>    65: 'A',<br/>    66: 'B',<br/>    67: 'C',<br/>    68: 'D',<br/>    69: 'E',<br/>    70: 'F',<br/>    71: 'G',<br/>    72: 'H',<br/>    73: 'I',<br/>    74: 'J',<br/>    75: 'K',<br/>    76: 'L',<br/>    77: 'M',<br/>    78: 'N',<br/>    79: 'O',<br/>    80: 'P',<br/>    81: 'Q',<br/>    82: 'R',<br/>    83: 'S',<br/>    84: 'T',<br/>    85: 'U',<br/>    86: 'V',<br/>    87: 'W',<br/>    88: 'X',<br/>    89: 'Y',<br/>    90: 'Z',<br/><br/>    91: 'Windows',<br/>    93: 'Right Click',<br/><br/>    96: 'Numpad 0',<br/>    97: 'Numpad 1',<br/>    98: 'Numpad 2',<br/>    99: 'Numpad 3',<br/>    100: 'Numpad 4',<br/>    101: 'Numpad 5',<br/>    102: 'Numpad 6',<br/>    103: 'Numpad 7',<br/>    104: 'Numpad 8',<br/>    105: 'Numpad 9',<br/>    106: 'Numpad *',<br/>    107: 'Numpad +',<br/>    109: 'Numpad -',<br/>    110: 'Numpad .',<br/>    111: 'Numpad /',<br/><br/>    112: 'F1',<br/>    113: 'F2',<br/>    114: 'F3',<br/>    115: 'F4',<br/>    116: 'F5',<br/>    117: 'F6',<br/>    118: 'F7',<br/>    119: 'F8',<br/>    120: 'F9',<br/>    121: 'F10',<br/>    122: 'F11',<br/>    123: 'F12',<br/><br/>    144: 'Num Lock',<br/>    145: 'Scroll Lock',<br/>    182: 'My Computer',<br/>    183: 'My Calculator',<br/>    186: ';',<br/>    187: '=',<br/>    188: ',',<br/>    189: '-',<br/>    190: '.',<br/>    191: '/',<br/>    192: '`',<br/>    219: '[',<br/>    220: '\\',<br/>    221: ']',<br/>    222: '\''<br/>};<br/><br/>function renderKeyName(keycode) {<br/>    if (keyCodeMap[keycode]) {<br/>        return keyCodeMap[keycode];<br/>    } else {<br/>        console.log('Unknow Key(Key Code:' + keycode + ')');<br/>        return '';<br/>    }<br/>};</span></pre><p id="490d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">参考:</p><p id="cc5d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nd" href="https://codeburst.io/understanding-memoization-in-3-minutes-2e58daf33a19" rel="noopener" target="_blank"> <em class="ne">记忆功能</em> </a></p><p id="32dd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank"><em class="ne"/></a></p><p id="3625" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae nd" href="https://keycode.info/" rel="noopener ugc nofollow" target="_blank"> <em class="ne">按键代码</em> </a></p><h1 id="bd87" class="la lb jb bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">了解更多信息</h1><div class="ip iq gp gr ir nf"><a href="https://medium.com/datadriveninvestor/top-10-trending-plugins-you-didnt-know-it-comes-with-macports-3a25558a4a9a" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd jc gy z fp nk fr fs nl fu fw ja bi translated">你不知道自己在2020年需要的十大MacPorts工具</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">对于大多数在用麦金塔操作系统的用户来说，他们了解自制程序。但是，有一个非常方便的工具调用…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt ix nf"/></div></div></a></div><div class="ip iq gp gr ir nf"><a href="https://medium.com/javascript-in-plain-english/top-10-tips-to-be-a-professional-javascript-developer-in-3-minutes-117192b8bb9b" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd jc gy z fp nk fr fs nl fu fw ja bi translated">JavaScript开发人员的10大快速技巧</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">我们在编程中更经常听到“数据绑定”这个词。“数据绑定”的关键是监控…</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">medium.com</p></div></div><div class="no l"><div class="nu l nq nr ns no nt ix nf"/></div></div></a></div><div class="ip iq gp gr ir nf"><a href="https://medium.com/@.jay/top-10-chrome-extensions-every-developer-likes-a1a3633b85e9" rel="noopener follow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd jc gy z fp nk fr fs nl fu fw ja bi translated">每个开发者都喜欢的十大Chrome扩展</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">每个开发者都喜欢的十大Chrome扩展</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">Likesmedium.com十大Chrome扩展</p></div></div><div class="no l"><div class="nv l nq nr ns no nt ix nf"/></div></div></a></div></div></div>    
</body>
</html>