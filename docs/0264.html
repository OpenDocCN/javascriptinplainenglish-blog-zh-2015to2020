<html>
<head>
<title>React Hooks and the “Observer” Pattern</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应钩子和“观察者”模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-hooks-and-the-observer-pattern-1e4274f0e5f5?source=collection_archive---------0-----------------------#2019-09-09">https://javascript.plainenglish.io/react-hooks-and-the-observer-pattern-1e4274f0e5f5?source=collection_archive---------0-----------------------#2019-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="896a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用React钩子时如何集成“观察者”模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/37becc2538cc6f058bafcec84420f73b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*VRKbI2twJg2t5Ymt"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@korpa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JR Korpa</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6f3d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> React钩子</strong> </a>的到来导致我们用React设计和编写应用程序的方式发生了许多变化:</p><ul class=""><li id="ff7c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">他们允许将内部状态添加到功能组件中，因此这些组件已经开始取代“经典”组件；</li><li id="b3e0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">他们鼓励使用声明式编程风格，因为它的功能性质；</li><li id="374a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">并且简化了我们在整个应用程序中重用逻辑的方式，使用<em class="mg">类组件</em>有些复杂。</li></ul><p id="9301" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文围绕着最后一点:我们可以使用钩子来实现一些最著名的设计模式，这样我们就可以<strong class="ky ir">构建更易于维护和扩展的应用程序。</strong></p><p id="8599" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看如何！</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="ac3a" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">介绍</h1><p id="61d7" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">如果您在阅读本文时不知道什么是设计模式，我将尝试对其进行简要总结，尽管我建议您访问以下链接来加深对应用程序开发中这一重要概念的理解:</p><ul class=""><li id="a6e4" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><a class="ae kv" href="https://amzn.to/3192Wii" rel="noopener ugc nofollow" target="_blank">头脑优先设计模式(一个大脑友好的指南)</a></li><li id="d454" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><a class="ae kv" href="https://amzn.to/2N5aLSC" rel="noopener ugc nofollow" target="_blank">设计模式:可重用面向对象软件的元素(Addison Wesley professional computing系列)</a></li><li id="a214" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我的文章“<a class="ae kv" href="https://medium.com/@ger86/patrones-de-diseño-en-php-2e486de337d7" rel="noopener">PHP中的设计模式</a>”(虽然它是为用PHP开发的应用程序而写的，但是通过我使用的例子，它可以让你了解这个概念)。</li></ul><blockquote class="nl"><p id="377f" class="nm nn iq bd no np nq nr ns nt nu lr dk translated">设计模式是应用程序设计中给定上下文中常见问题的通用且可重用的解决方案。</p></blockquote><p id="ebb8" class="pw-post-body-paragraph kw kx iq ky b kz nv jr lb lc nw ju le lf nx lh li lj ny ll lm ln nz lp lq lr ij bi translated">也就是说，<strong class="ky ir">设计模式</strong>为在考虑应用程序的架构时反复出现的某些问题提供解决方案，从而避免必须不断地重新发明轮子。</p><p id="a380" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它的强大之处在于，它的使用和应用不依赖于我们正在开发的语言，而是通过类图抽象出解决方案，我们可以在任何<em class="mg">软件</em>应用中实现它们。</p><p id="ac5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设计模式的另一个优势是<strong class="ky ir">它们在与其他开发人员</strong>交流时提供了一种通用语言，因为他们每个人都定义了一个特定的名称来引用它以及参与所提议的解决方案的元素。这使得无论开发的应用程序类型或使用的语言如何，都可以使用同一个“字典”来引用某些概念。通过这种方式，代码是“自文档化”的，允许将来参与维护的人快速识别实现的解决方案。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="bcbb" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">反应钩子和“观察者”模式</h1><blockquote class="oa ob oc"><p id="5aa7" class="kw kx mg ky b kz la jr lb lc ld ju le od lg lh li oe lk ll lm of lo lp lq lr ij bi translated">在模式“Observer”中，一个名为“subject”的对象维护一个名为“Observer”的依赖项列表，并自动通知它们状态的任何变化，通常调用它的一个方法。</p></blockquote><p id="7e73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于这种模式，我们可以拥有更多解耦的应用程序(因为观察者不需要连接到主题<em class="mg">和可维护性，因为每个观察者都是独立于其他观察者的，所以其中一个观察者的功能变化并不意味着其他观察者的修改。</em></p><p id="3c06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它的类和序列的UML方案如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/c67e28605e2a6d99edf39120a0313d78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*TzlZxnlkMiXc9Kul13T0pQ.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">By Vanderjoe — Own work, CC BY-SA 4.0, <a class="ae kv" href="https://commons.wikimedia.org/w/index.php?curid=61809260" rel="noopener ugc nofollow" target="_blank">https://commons.wikimedia.org/w/index.php?curid=61809260</a></figcaption></figure><p id="b904" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，假设我们想在React中开发一个应用程序，用户可以在应用程序的不同位置可视化一个城市的天气，例如，在侧栏中显示他们最喜欢的城市和城市列表。</p><p id="3bf5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，我们有两个组件:</p><ul class=""><li id="7624" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe oh oi oj ok b">FavouriteCity</code>，在我们的应用程序的侧边栏中显示一个城市的温度。</li><li id="5386" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe oh oi oj ok b">CityTeaser</code>，显示一列城市的温度。</li></ul><p id="4cf0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">城市中的气候状态被集中</strong>并且两个组件都接收到它，这很方便，也就是说，使它们不必请求它(这最终会导致重复代码)。我们如何集中一个城市的气候状态，以便每次发生变化时两个组件都得到更新？感谢格局<em class="mg">观察者</em>:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/977b3410a7ccd2515bae1f65b9fd03fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wqVdNu6LoYmBkwAxAuF5w.jpeg"/></div></div></figure><p id="1add" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">根据图表:</p><ul class=""><li id="2516" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe oh oi oj ok b">Weather</code>充当城市天气集中的<em class="mg">观察者</em>模式的<code class="fe oh oi oj ok b">Subject</code>。</li><li id="9541" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe oh oi oj ok b">FavouriteCity</code>和<code class="fe oh oi oj ok b">CityTeaser</code>充当观察者，通过它们的<code class="fe oh oi oj ok b">onWeatherChanged</code>方法接收来自天气类的天气更新。这些<em class="mg">观察者</em>可以通过“subject”的attach方法请求被通知(<code class="fe oh oi oj ok b">notify</code>方法)。</li></ul><p id="5a57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">清楚了这一点，我们将首先实现<code class="fe oh oi oj ok b">Weather</code>类的代码。为了能够定义新的类型和接口，以及能够键入每个方法的参数，我将使用<strong class="ky ir"> Typescript </strong>作为一种语言，尽管如果你愿意，你可以毫无问题地用Javascript编写自己的版本。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="8747" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">天气等级</h1><p id="b889" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">根据图表，<code class="fe oh oi oj ok b">WeatherSubject</code>类必须有以下方法:</p><ul class=""><li id="39bf" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe oh oi oj ok b">attach</code>，以便<em class="mg">观察者</em>可以注册并在温度更新时接收通知。</li><li id="fc90" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe oh oi oj ok b">detach</code>，当<em class="mg">观察者</em>不再希望接收更多的状态通知时，允许其取消订阅(同时防止<em class="mg">内存泄漏</em>由于在内存中保存对不再使用的对象的引用而导致的)。</li><li id="2d6e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe oh oi oj ok b">notify</code>，一种每次天气更新都会通知注册的“观察员”的方法。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/8e8ab2d4e16ec62f5c864c617c4b326c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*t8e_GPMdnpZJC9nrh9K-BA.png"/></div></div></figure><ul class=""><li id="d72d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">在第1行中，我们定义了可以订阅<code class="fe oh oi oj ok b">Weather</code>类的<em class="mg">观察者</em>的类型。在我们的例子中，它将是一个回调函数，接收获得的温度作为参数。</li><li id="42ea" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在第7行和第11行，我们定义了<code class="fe oh oi oj ok b">attach</code>和<code class="fe oh oi oj ok b">detach</code>方法的主体，这样<em class="mg">观察者</em>可以订阅和取消订阅状态更新。</li><li id="898c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在第15行，我们定义了<code class="fe oh oi oj ok b">updateWeather</code>方法，它每1秒获取一次天气，并通过<code class="fe oh oi oj ok b">notify</code>方法通知“观察者”。</li><li id="e2d1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在第33行上，<code class="fe oh oi oj ok b">notify</code>方法遍历<em class="mg">观察器</em>的数组，并用接收到的温度调用它们。</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="1bdb" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">FavoriteCityComponent</h1><p id="3d5b" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">我们的<code class="fe oh oi oj ok b">FavouriteCity</code>组件将充当“观察者”,以便:</p><ul class=""><li id="28d2" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">挂载时，必须通过<code class="fe oh oi oj ok b">attach</code>方法在<code class="fe oh oi oj ok b">Weather</code>类中订阅<em class="mg">观察者</em>。</li><li id="6f84" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">卸载时，您必须通过<code class="fe oh oi oj ok b">dettach</code>方法从<code class="fe oh oi oj ok b">Weather</code>类中<em class="mg">取消对</em>的描述，从而防止它在不再被使用时被调用。</li></ul><p id="3cb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是<strong class="ky ir">反应钩</strong>开始动作的地方。我们将创建一个使用两个挂钩的功能组件:</p><ul class=""><li id="858d" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe oh oi oj ok b"><a class="ae kv" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank">useState</a></code>存储当前温度。此外，这个钩子将为我们提供一个更新当前温度的函数，我们将在<code class="fe oh oi oj ok b">WeatherSubject</code>中注册的<em class="mg">回调</em>中使用这个函数。</li><li id="4039" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe oh oi oj ok b"><a class="ae kv" href="https://reactjs.org/docs/hooks-effect.html" rel="noopener ugc nofollow" target="_blank">useEffect</a></code>订阅和退订<code class="fe oh oi oj ok b">WeatherSubject</code>。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/49fbce6d270ca2f479a27118a28dc830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6j6b-uCh0GnHNF7eZRQWSg.png"/></div></div></figure><ul class=""><li id="4cba" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">在第6行中，我们为<code class="fe oh oi oj ok b">FavouriteCity</code>组件定义了一个状态，它将存储当前温度并允许我们使用<code class="fe oh oi oj ok b">setCurrentTemperature</code>方法更新它。</li><li id="583a" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在第8行，我们定义了将在<code class="fe oh oi oj ok b">WeatherSubject</code>中注册的回调函数:该函数接收一个带有获得的温度的<code class="fe oh oi oj ok b">Number</code>作为参数，并使用<code class="fe oh oi oj ok b">setCurrentTemperature</code>方法更新<code class="fe oh oi oj ok b">useState</code>钩子的状态。</li><li id="66ce" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在第12行，使用<code class="fe oh oi oj ok b">useEffect</code>钩子，我们通过<code class="fe oh oi oj ok b">attach</code>方法向<code class="fe oh oi oj ok b">WeatherSubject</code>订阅一次(使用空数组<code class="fe oh oi oj ok b">[]</code>作为钩子的第二个参数),当组件被反汇编时，我们使用<code class="fe oh oi oj ok b">detach</code>方法取消订阅。</li><li id="ca60" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">最后，在第19行，我们绘制了存储在<code class="fe oh oi oj ok b">useState</code>状态挂钩中的温度。</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="f6e9" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">CityTeaser组件</h1><p id="7f63" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">正如你在前面的组件中看到的，<strong class="ky ir"> <em class="mg">观察者</em>模式</strong>允许我们将气候更新从<code class="fe oh oi oj ok b">FavouriteCity</code>组件中分离出来。此外，由于<code class="fe oh oi oj ok b">useState</code>钩子只用了20行代码，我们就解决了这个问题，因为<em class="mg">回调</em>提供了更新状态的功能。</p><p id="8423" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了让你看到<code class="fe oh oi oj ok b"><strong class="ky ir">useReducer</strong></code>钩子是如何与这个设计模式完美集成的，我将以这种方式实现<code class="fe oh oi oj ok b">CityTeaser</code>组件:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/d2c173d52242c692dc82d6243c946821.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Clvt3oft9RMw25MyLPR3tw.png"/></div></div></figure><p id="8e43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，我们需要更多的代码:</p><ul class=""><li id="3333" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">在第4行和第6行中，我们定义了我们的<code class="fe oh oi oj ok b"><strong class="ky ir">reducer</strong></code>函数是什么:它将接收当前状态作为第一个参数，接收已经启动的动作作为第二个参数，该动作由具有type属性和temperature属性的对象表示，其温度值为要更新的值。</li><li id="3cdf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在第14行中，我们使用<code class="fe oh oi oj ok b">useEffect</code>钩子来获取<code class="fe oh oi oj ok b">dispatch</code>函数，然后我们定义<code class="fe oh oi oj ok b">onTemperatureUpdated</code>函数来调度每次<code class="fe oh oi oj ok b">WeatherSubject</code>通知我们时接收到的温度。</li><li id="73ba" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">最后，和在<code class="fe oh oi oj ok b">FavouriteCity</code>类中一样，我们使用<code class="fe oh oi oj ok b">useEffect</code>钩子分别在组件组装和拆卸时进行订阅和取消订阅。</li></ul></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="a500" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">最终结论</h1><p id="f398" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated"><strong class="ky ir">观察者模式</strong>可能是应用程序开发中最普遍的模式之一，因为它提供了以下优势:</p><ul class=""><li id="9d02" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><strong class="ky ir">组成应用程序的组件之间的低耦合</strong>。</li><li id="b890" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><strong class="ky ir">信息和状态传输的单一意义</strong>，即<code class="fe oh oi oj ok b">Subject</code>负责监控应用程序某一部分的状态，并通知请求它的<em class="mg">观察者</em>。</li></ul><p id="cba9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于有了<strong class="ky ir"> React钩子</strong>，在我们的应用程序中实现它非常简单，正如我在本文中试图展示的那样。</p><p id="42fa" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章已经帮助你发现了React钩子的另一种用法，因为它们已经存在了。</p></div><div class="ab cl mh mi hu mj" role="separator"><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm mn"/><span class="mk bw bk ml mm"/></div><div class="ij ik il im in"><h1 id="49e1" class="mo mp iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">你想收到更多这样的文章吗？</h1><p id="7367" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">如果你喜欢这篇文章，我鼓励你订阅我每周日发送的时事通讯，里面有类似的出版物和更多的推荐内容:👇👇👇</p><div class="on oo gp gr op oq"><a href="https://eepurl.us20.list-manage.com/subscribe?u=c14cad2102bcf33bf216cc69e&amp;id=2790da9378" rel="noopener  ugc nofollow" target="_blank"><div class="or ab fo"><div class="os ab ot cl cj ou"><h2 class="bd ir gy z fp ov fr fs ow fu fw ip bi translated">拿铁和代码</h2><div class="ox l"><h3 class="bd b gy z fp ov fr fs ow fu fw dk translated">这是一份最新的时事通讯，代码是recibirás cada domingo。——洛斯多斯乌尔蒂莫斯艺术博物馆……</h3></div><div class="oy l"><p class="bd b dl z fp ov fr fs ow fu fw dk translated">eepurl.us20.list-manage.com</p></div></div><div class="oz l"><div class="pa l pb pc pd oz pe kp oq"/></div></div></a></div></div></div>    
</body>
</html>