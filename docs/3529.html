<html>
<head>
<title>Building Web API using Express.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express.js构建Web API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-web-api-using-express-js-c0ae69901cf3?source=collection_archive---------5-----------------------#2020-10-06">https://javascript.plainenglish.io/building-web-api-using-express-js-c0ae69901cf3?source=collection_archive---------5-----------------------#2020-10-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9d8f917b0d3ceec6df1949ad0b6e7357.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dCCKpLBi6tmDWfXFl87xZQ.jpeg"/></div></div></figure><h1 id="186e" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">摘要</h1><p id="7aff" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">在这篇文章中，我将向您展示如何在Node.JS中构建博客web API。JS用于处理HTTP请求，Mongodb用于存储数据。</p><h1 id="d7a1" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">目录</h1><ul class=""><li id="8b09" class="lr ls in kv b kw kx la lb le lt li lu lm lv lq lw lx ly lz bi translated"><a class="ae ma" href="#12ce" rel="noopener ugc nofollow">简介</a></li><li id="336c" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae ma" href="#1c50" rel="noopener ugc nofollow">设置</a></li><li id="fcf9" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae ma" href="#12b9" rel="noopener ugc nofollow">套餐</a></li><li id="d811" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae ma" href="#2cf0" rel="noopener ugc nofollow">数据库</a></li><li id="a0d1" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae ma" href="#8d7b" rel="noopener ugc nofollow"> MVC结构</a></li><li id="b876" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae ma" href="#6d8d" rel="noopener ugc nofollow">快递申请</a></li><li id="b5fc" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae ma" href="#1711" rel="noopener ugc nofollow">完整示例</a></li><li id="1725" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated"><a class="ae ma" href="#daa4" rel="noopener ugc nofollow">结论</a></li></ul><h1 id="12ce" class="jv jw in bd jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks bi translated">介绍</h1><p id="91fc" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">节点。JS是一个使用Javascript构建服务器端应用程序的平台。带节点。JS，开发人员能够在几分钟内构建后端API。它有一个伟大的社区和一套庞大的软件包。这些包帮助开发人员构建优秀的应用程序。开发者不需要从头开始构建一切。我们主要关注两个包。首先是<strong class="kv io">快递。JS </strong>，这是开发者构建web APIs最常用的包之一。其次是<strong class="kv io">mongose</strong>，用于简化节点间的通信。JS和MongoDB。</p><h2 id="5f0d" class="mg jw in bd jx mh mi dn kb mj mk dp kf le ml mm kj li mn mo kn lm mp mq kr mr bi translated">要求</h2><ul class=""><li id="fe16" class="lr ls in kv b kw kx la lb le lt li lu lm lv lq lw lx ly lz bi translated">基本的Javascript知识</li><li id="28e7" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated">节点。JS 10.0.0或更高版本</li><li id="5880" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated">NPM 4.6.1或更高版本</li><li id="41f2" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated">Mongodb 4.2.1或更高版本</li><li id="0731" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated">VS-Code或任何其他编辑器</li></ul></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><h1 id="1c50" class="jv jw in bd jx jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks bi translated">设置</h1><p id="1e56" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">典型的节点。JS应用程序有一个根目录，其中包含至少两个文件<strong class="kv io"> package.json </strong>(保存关于应用程序和所需npm包的元数据)和<strong class="kv io"> index.js </strong>文件(一个javascript入口文件)。</p><ol class=""><li id="fcee" class="lr ls in kv b kw ne la nf le ng li nh lm ni lq nj lx ly lz bi translated">创建项目的目录</li></ol><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="558b" class="mg jw in np b gy nt nu l nv nw">mkdir blog-server<br/>cd blog-server</span></pre><p id="c96e" class="pw-post-body-paragraph kt ku in kv b kw ne ky kz la nf lc ld le nx lg lh li ny lk ll lm nz lo lp lq ig bi translated">2.创建<strong class="kv io"> package.json </strong>文件</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="a7f5" class="mg jw in np b gy nt nu l nv nw">npm init -y</span></pre><p id="912b" class="pw-post-body-paragraph kt ku in kv b kw ne ky kz la nf lc ld le nx lg lh li ny lk ll lm nz lo lp lq ig bi translated">3.创建<strong class="kv io"> index.js </strong>文件(入口文件)</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="900a" class="mg jw in np b gy nt nu l nv nw">// index.js<br/>const PORT = 3000;</span><span id="414c" class="mg jw in np b gy oa nu l nv nw">console.log(`A node.js server that runs on ${PORT}`);</span></pre><p id="af26" class="pw-post-body-paragraph kt ku in kv b kw ne ky kz la nf lc ld le nx lg lh li ny lk ll lm nz lo lp lq ig bi translated">4.运行应用程序</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="ef9f" class="mg jw in np b gy nt nu l nv nw">node index.js</span></pre></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><h1 id="12b9" class="jv jw in bd jx jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks bi translated">包装</h1><p id="400b" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我们的express.js web应用程序需要这些包。</p><ul class=""><li id="fa73" class="lr ls in kv b kw ne la nf le ng li nh lm ni lq lw lx ly lz bi translated"><strong class="kv io"> express </strong>:路由和中间件web框架</li><li id="b7a7" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kv io"> cors </strong>:启用cors(跨源资源共享)</li><li id="f642" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kv io">主体解析器</strong>:将json主体解析成javascript对象</li><li id="0b71" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kv io"> morgan </strong>:记录http请求，这对查看请求很重要</li><li id="8e6d" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kv io">猫鼬</strong>:猫鼬</li><li id="90c7" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kv io"> nodemon </strong>:通过在发生任何变化时重启服务器来简化开发</li></ul><p id="8235" class="pw-post-body-paragraph kt ku in kv b kw ne ky kz la nf lc ld le nx lg lh li ny lk ll lm nz lo lp lq ig bi translated">注意:<strong class="kv io"> nodemon </strong>被用作开发依赖项，因为它只在开发期间需要。</p><ol class=""><li id="28b7" class="lr ls in kv b kw ne la nf le ng li nh lm ni lq nj lx ly lz bi translated">从NPM安装软件包。</li></ol><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="cdb4" class="mg jw in np b gy nt nu l nv nw">npm install --save-dev nodemon<br/>npm install --save express cors body-parser morgan mongoose</span></pre><p id="69da" class="pw-post-body-paragraph kt ku in kv b kw ne ky kz la nf lc ld le nx lg lh li ny lk ll lm nz lo lp lq ig bi translated">2.在index.js文件中使用require导入包。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="4b17" class="mg jw in np b gy nt nu l nv nw">const express = require("express");</span><span id="2d90" class="mg jw in np b gy oa nu l nv nw">const cors = require("cors");</span><span id="b97e" class="mg jw in np b gy oa nu l nv nw">const bodyParser = require("body-parser");</span><span id="b9ac" class="mg jw in np b gy oa nu l nv nw">const morgan = require("morgan");</span><span id="cca1" class="mg jw in np b gy oa nu l nv nw">const mongoose = require("mongoose");</span></pre></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><h1 id="2cf0" class="jv jw in bd jx jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks bi translated">数据库ˌ资料库</h1><p id="82ee" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">如上所述，我们使用Mongodb来存储应用程序相关的信息。我们使用<strong class="kv io">mongose</strong>作为Mongodb和node.js应用程序模型之间的对象映射器。</p><ol class=""><li id="400f" class="lr ls in kv b kw ne la nf le ng li nh lm ni lq nj lx ly lz bi translated">连接到mongodb</li></ol><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="51aa" class="mg jw in np b gy nt nu l nv nw">mongoose.connect("mongodb://localhost:27017/blog");</span></pre><p id="7369" class="pw-post-body-paragraph kt ku in kv b kw ne ky kz la nf lc ld le nx lg lh li ny lk ll lm nz lo lp lq ig bi translated">2.创建<strong class="kv io">mongose模式</strong>来定义从读取<strong class="kv io">或从</strong> Mongodb写入<strong class="kv io">的文档结构。</strong></p><p id="71fc" class="pw-post-body-paragraph kt ku in kv b kw ne ky kz la nf lc ld le nx lg lh li ny lk ll lm nz lo lp lq ig bi translated">创建一个名为<strong class="kv io"> postSchema </strong>的模式来定义<strong class="kv io">文章</strong>的结构，它有<strong class="kv io">标题</strong>和<strong class="kv io">正文</strong>。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="728f" class="mg jw in np b gy nt nu l nv nw">const postSchema = new mongoose.Schema(<br/>   {<br/>      title: { type: String, required: true },<br/>      body: { type: String, required: true },<br/>   },<br/>   { timestamps: true }<br/>);</span></pre></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><h1 id="8d7b" class="jv jw in bd jx jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks bi translated">类似MVC的应用程序</h1><p id="f7f4" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">一个MVC应用被构造成三层[模型、视图、控制器]。有时，额外的层被添加到MVC中，比如DAL、服务、存储库。</p><p id="b12a" class="pw-post-body-paragraph kt ku in kv b kw ne ky kz la nf lc ld le nx lg lh li ny lk ll lm nz lo lp lq ig bi translated">在这个例子中，app分为三层【模型→服务→控制器】。通常，每一层都存在于一个目录中。</p><h2 id="714a" class="mg jw in bd jx mh mi dn kb mj mk dp kf le ml mm kj li mn mo kn lm mp mq kr mr bi translated">模型</h2><p id="4207" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">模型代表特定领域的数据。该模型基于上面定义的<strong class="kv io">后置模式</strong>。</p><ol class=""><li id="4e43" class="lr ls in kv b kw ne la nf le ng li nh lm ni lq nj lx ly lz bi translated">创建一个<strong class="kv io"> Post </strong>模型。</li></ol><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="9343" class="mg jw in np b gy nt nu l nv nw">const Post = mongoose.model("post", postSchema);</span></pre><h2 id="3069" class="mg jw in bd jx mh mi dn kb mj mk dp kf le ml mm kj li mn mo kn lm mp mq kr mr bi translated">服务</h2><p id="92f3" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">服务层是MVC中的一个附加层，它协调控制器<strong class="kv io">和模型<strong class="kv io">之间的通信。这一层增加了更多的抽象和易测试性。</strong></strong></p><ol class=""><li id="8618" class="lr ls in kv b kw ne la nf le ng li nh lm ni lq nj lx ly lz bi translated">创建一个<strong class="kv io"> postService </strong>实体，它公开两个服务:</li></ol><ul class=""><li id="26b9" class="lr ls in kv b kw ne la nf le ng li nh lm ni lq lw lx ly lz bi translated">查找:查询所有帖子数据</li><li id="19ae" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated">保存:保存帖子</li></ul><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="7c95" class="mg jw in np b gy nt nu l nv nw">const postService = {<br/>   <br/>   find: () =&gt; Post.find({}),<br/>   <br/>   save: async (postData) =&gt; {<br/>      const post = new Post({ ...postData });<br/>      await post.save();<br/>      return post;<br/>   },</span><span id="9d73" class="mg jw in np b gy oa nu l nv nw">};</span></pre><h2 id="ad80" class="mg jw in bd jx mh mi dn kb mj mk dp kf le ml mm kj li mn mo kn lm mp mq kr mr bi translated">控制器</h2><p id="c923" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">顾名思义，控制器控制传入的请求，捕捉错误并向客户端发回响应。</p><ol class=""><li id="9507" class="lr ls in kv b kw ne la nf le ng li nh lm ni lq nj lx ly lz bi translated">创建一个<strong class="kv io">后控制器</strong>，它有两个动作:</li></ol><ul class=""><li id="53fc" class="lr ls in kv b kw ne la nf le ng li nh lm ni lq lw lx ly lz bi translated">find:handles<strong class="kv io"><em class="ob">GET/API/post</em></strong></li><li id="93d5" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated">保存:处理<strong class="kv io"> <em class="ob">帖子/API/帖子</em> </strong></li></ul><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="44be" class="mg jw in np b gy nt nu l nv nw">const postController = {<br/>   <br/>  find: async (req, res, next) =&gt; {<br/>      try {<br/>         const posts = await postService.find({ ...req.query });<br/>         res.json(posts);<br/>      } catch (error) {<br/>         error.msg = "failed to retrieve posts";<br/>         next(error);<br/>      }<br/>   },<br/>   <br/>   save: async (req, res, next) =&gt; {<br/>      try {<br/>         const post = await postService.save(req.body);<br/>         res.json(post);<br/>      } catch (error) {<br/>         error.msg = "failed to create post";<br/>         next(error);<br/>      }<br/>   },<br/>};</span></pre></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><h1 id="6d8d" class="jv jw in bd jx jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks bi translated">快速申请</h1><blockquote class="oc od oe"><p id="5000" class="kt ku ob kv b kw ne ky kz la nf lc ld of nx lg lh og ny lk ll oh nz lo lp lq ig bi translated">Express是一个<strong class="kv io">路由</strong>和<strong class="kv io">中间件</strong> web框架，它拥有自己的最小功能:Express应用程序本质上是一系列中间件函数调用。</p></blockquote><ol class=""><li id="e2d2" class="lr ls in kv b kw ne la nf le ng li nh lm ni lq nj lx ly lz bi translated">创建快速应用程序</li></ol><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="76b2" class="mg jw in np b gy nt nu l nv nw">const app = express();</span></pre><h2 id="5cc4" class="mg jw in bd jx mh mi dn kb mj mk dp kf le ml mm kj li mn mo kn lm mp mq kr mr bi translated">中间件</h2><p id="ac98" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">中间件是在控制器动作之前或之后执行的功能。</p><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="c15f" class="mg jw in np b gy nt nu l nv nw">app.use(cors());<br/>app.use(morgan("tiny"));<br/>app.use(bodyParser.json());</span></pre><h2 id="c162" class="mg jw in bd jx mh mi dn kb mj mk dp kf le ml mm kj li mn mo kn lm mp mq kr mr bi translated">快速路由器</h2><p id="0695" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">快速路由器将请求路由到控制器中的特定动作。</p><ol class=""><li id="4933" class="lr ls in kv b kw ne la nf le ng li nh lm ni lq nj lx ly lz bi translated">定义两条基于<strong class="kv io">的快速路由</strong>来处理</li></ol><ul class=""><li id="88ea" class="lr ls in kv b kw ne la nf le ng li nh lm ni lq lw lx ly lz bi translated"><strong class="kv io">获取/API/发布</strong></li><li id="6827" class="lr ls in kv b kw mb la mc le md li me lm mf lq lw lx ly lz bi translated"><strong class="kv io">岗位/API/岗位</strong></li></ul><pre class="nk nl nm nn gt no np nq nr aw ns bi"><span id="b5c3" class="mg jw in np b gy nt nu l nv nw">const router = express.Router();<br/>router.get("/posts", postController.find);<br/>router.post("/posts", postController.save);<br/>app.use("/api", router);</span></pre><h2 id="1711" class="mg jw in bd jx mh mi dn kb mj mk dp kf le ml mm kj li mn mo kn lm mp mq kr mr bi translated">完整示例</h2><p id="3642" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">我已经包含了一个完整的express服务器示例。</p><figure class="nk nl nm nn gt jo"><div class="bz fp l di"><div class="oi oj l"/></div></figure></div><div class="ab cl ms mt hr mu" role="separator"><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx my"/><span class="mv bw bk mw mx"/></div><div class="ig ih ii ij ik"><h1 id="daa4" class="jv jw in bd jx jy mz ka kb kc na ke kf kg nb ki kj kk nc km kn ko nd kq kr ks bi translated">结论</h1><p id="793d" class="pw-post-body-paragraph kt ku in kv b kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq ig bi translated">您已经详细学习了如何创建express服务器并连接到mongodb来存储数据。您已经公开了一些API。在本教程中，为了简单起见，我将所有代码都写在一个文件中。你可以访问这个<a class="ae ma" href="https://github.com/bewarusman/blog-api.git" rel="noopener ugc nofollow" target="_blank">库</a>来获得完整的例子。</p></div></div>    
</body>
</html>