<html>
<head>
<title>How to fix “Avoid mutating a prop directly” in Vue</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何修复Vue中的“避免直接变异道具”</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/avoid-mutating-a-prop-directly-7b127b9bca5b?source=collection_archive---------0-----------------------#2019-09-14">https://javascript.plainenglish.io/avoid-mutating-a-prop-directly-7b127b9bca5b?source=collection_archive---------0-----------------------#2019-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/b3546d323a2a7b6b17ba589aaa1ddfce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/0*9C1V6QIMKp9tD1Cp"/></div></figure><p id="7b89" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你有没有面对过这个错误-</p><blockquote class="ks kt ku"><p id="ae73" class="ju jv kv jw b jx jy jz ka kb kc kd ke kw kg kh ki kx kk kl km ky ko kp kq kr ij bi translated"><em class="iq">避免直接改变道具，因为只要父组件重新渲染，该值就会被覆盖。相反，使用基于属性值的数据或计算属性。</em></p></blockquote><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi kz"><img src="../Images/79f87e06b8e0c009195172111ed80938.png" data-original-src="https://miro.medium.com/v2/resize:fit:1034/0*igckpRAoSBrvVy-7"/></div></figure><p id="0dac" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Vue不建议修改<code class="fe le lf lg lh b">prop</code>数据的原因是因为如果父组件有不同的值，子组件中的数据将被重新渲染。</p><h1 id="0394" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">怎么解决？</h1><p id="3c99" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">我将创建一个简单的Vue组件，由附加了<code class="fe le lf lg lh b">v-model</code>的输入和另一个接受<code class="fe le lf lg lh b">v-model</code>数据作为<code class="fe le lf lg lh b">props</code>并显示它的卡组件组成。</p><p id="aba7" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是界面看起来的样子。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/b301965e1a4a2620a7df957ef678af62.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/0*ZfekYaOt4zIfIorT"/></div></figure><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2126" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这就是界面的工作方式。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/939ba40a51671112f1f83cfcc0271ecd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*tVkJ4F6mRZ1q3ZS-AYnIGA.gif"/></div></figure><p id="7b48" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">每次用户在输入时，它都会直接反映在下面的卡片上。这是因为我们在<code class="fe le lf lg lh b">Card</code>组件中将<code class="fe le lf lg lh b">v-model: number</code>作为<code class="fe le lf lg lh b">prop</code>传递。</p><p id="0cbf" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">用户输入的任何值都会立即反映出来。</p><p id="6e1f" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我的下一个问题是，如果我们要操作子组件(即<code class="fe le lf lg lh b">Card</code>组件)中的数据，会发生什么。</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="3acb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">令人惊讶的是，这就是正在发生的事情。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/7e160870bf66590556b76852bf40afd2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*D-1pMl6AsnXTpthHHHhCeQ.gif"/></div></figure><p id="3460" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我们想增加子组件中的值时，Vue给我们一个错误信息，这是<strong class="jw ir">不推荐的</strong>方式。</p><h1 id="cf40" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">为什么不推荐？</h1><p id="28de" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">如果父组件中的数据<em class="kv"> v-model </em>发生变化，子组件中的数据将重新呈现。</p><p id="5d6c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">例如，我在输入中添加任意数字，并使用加号按钮增加<code class="fe le lf lg lh b">number</code>。如果我在<code class="fe le lf lg lh b">input</code>中添加一个新值会发生什么？</p><p id="d149" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们刚才增加的值是从输入中得到一个新值。</p><p id="a865" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">明白了吗？</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/a2072bf9809cb377b2e680b1eda6a903.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*1mUdfd8Ys0RABuc4Ov9e7A.gif"/></div></figure><h1 id="8955" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">我们怎么解决？</h1><p id="f9b4" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">由于我们不能直接修改props数据，所以我们需要将<code class="fe le lf lg lh b">props</code>数据复制到一个变量中。</p><p id="bb7e" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe le lf lg lh b">addNumber</code>方法中，将道具分配到一个新变量中并进行计算。</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9498" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下一个问题是，我们如何将新的数值发送给父节点？🤔</p><p id="7b5b" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">感谢上帝，有一个自定义事件来解决它。我们需要在<code class="fe le lf lg lh b">addNumber</code>方法中添加自定义事件。</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="2884" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这意味着我们正在通过<code class="fe le lf lg lh b">update-number</code>事件名称发送一个<code class="fe le lf lg lh b">myNumber</code>数据。因为我们正在发送一个定制数据，父组件需要监听<code class="fe le lf lg lh b">update-number</code>事件。</p><p id="d6a6" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe le lf lg lh b">App.vue</code>中，将监听器添加到<code class="fe le lf lg lh b">Card</code>组件中。</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f1eb" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果子组件中有一个名为<code class="fe le lf lg lh b">update-number</code>的<code class="fe le lf lg lh b">emit</code>事件被触发，就会调用<code class="fe le lf lg lh b">update</code>函数。</p><p id="d272" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe le lf lg lh b">App.vue</code>文件中，在<code class="fe le lf lg lh b">methods</code>部分添加<code class="fe le lf lg lh b">update</code>功能。</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e6e9" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">记住，当我们发送自定义事件时，我们发送的是参数<code class="fe le lf lg lh b">myNumber</code>。所以，在<code class="fe le lf lg lh b">update</code>函数中需要有一个参数来获取数据。</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="587c" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">之后，我们从自定义事件中获得的新值将被赋给<code class="fe le lf lg lh b">number</code>数据。因为，如果每次<code class="fe le lf lg lh b">props</code>数据改变，子组件数据将被重新渲染，我们可以看到<code class="fe le lf lg lh b">Card</code>组件的即时更新。</p><figure class="la lb lc ld gt jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/1aadd095985cd19573ee2082af64dd6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*lP2QaA01SrVS1X74WAqOOw.gif"/></div></figure><h1 id="2e50" class="li lj iq bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">源代码</h1><p id="dfa3" class="pw-post-body-paragraph ju jv iq jw b jx mg jz ka kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ij bi translated">App.vue</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="9397" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Card.vue</p><figure class="la lb lc ld gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="07b3" class="pw-post-body-paragraph ju jv iq jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">最初发表于<a class="ae mo" href="https://jakzaizzat.com/avoid-mutating-a-prop-directly" rel="noopener ugc nofollow" target="_blank">https://jakzaizzat.com</a></p></div></div>    
</body>
</html>