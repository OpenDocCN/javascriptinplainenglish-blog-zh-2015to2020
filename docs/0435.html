<html>
<head>
<title>React.memo explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React .备忘录解释道</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-react-memo-4364d14413c0?source=collection_archive---------2-----------------------#2019-10-14">https://javascript.plainenglish.io/using-react-memo-4364d14413c0?source=collection_archive---------2-----------------------#2019-10-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e294f68131d2012fbe1696201f826a51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*n7V4Kv9IKpf_UQfxsMsmEA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">google.com</figcaption></figure><h1 id="0b21" class="kc kd iq bd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz bi translated"><strong class="ak">react . memo()是什么？</strong></h1><p id="15e7" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">React.memo是一个函数，它接受一个函数作为参数，并返回一个记忆化的函数作为返回<em class="ly">或</em>换句话说，它是一个高阶组件，用于通过防止在属性没有改变的情况下重新呈现功能组件来提高该组件的性能。这类似于类组件中的纯组件。</p><p id="63f1" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">它将一个函数作为可选的第二个参数，这类似于类组件中的<code class="fe me mf mg mh b">shouldComponentUpdate</code>生命周期方法，并返回一个布尔值，该值允许定制memo生效或不生效的条件。</p><blockquote class="mi"><p id="610d" class="mj mk iq bd ml mm mn mo mp mq mr lx dk translated">React.memo在内部会对组件树中传递的每个组件的属性进行浅层比较，如果属性与之前的渲染相同，可以选择不重新渲染。</p></blockquote><h2 id="b120" class="ms kd iq bd ke mt mu dn ki mv mw dp km ll mx my kq lp mz na ku lt nb nc ky nd bi translated">我们什么时候使用它？</h2><p id="989e" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">在大多数情况下，我们在创建功能组件时不需要使用memo。这是一种优化，应该只在必要的时候谨慎使用。话虽如此，但在某些情况下它确实是有帮助的。例如，如果子组件在父组件触发的事件上连续呈现。在这种情况下，我们可能不想过于频繁地渲染孩子，除非它的道具发生了变化。</p><h2 id="2bf0" class="ms kd iq bd ke mt ne dn ki mv nf dp km ll ng my kq lp nh na ku lt ni nc ky nd bi translated"><strong class="ak">下面举个例子来解释一下</strong></h2><p id="a860" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">让我们看看下面的代码，我们可以看到一个名为<code class="fe me mf mg mh b">Inventory</code>的组件，它异步获取项目并在UI中更新它们。它有两个子组件，每个都是一个<code class="fe me mf mg mh b">Item</code>。</p><p id="7ab2" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">这里有一个重要的观察，即<code class="fe me mf mg mh b">updateItem1</code>和<code class="fe me mf mg mh b">updateItem2</code>没有绑定到组件，而是关联到组件实例的特定呈现，这意味着对于<code class="fe me mf mg mh b">Inventory</code>组件的重新呈现，会为这些方法中的每一个创建一个新的引用(<em class="ly"> useCallback </em>会防止这种情况发生，但我们稍后会谈到)。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Code to show a use-case for memoizing using React.memo()</figcaption></figure><p id="b137" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">当<code class="fe me mf mg mh b">updateItem1</code>被调用并且<code class="fe me mf mg mh b">item1</code>的值被重置时，由于上面的解释<code class="fe me mf mg mh b">Item1</code>和<code class="fe me mf mg mh b">Item2</code>都将更新。我们不希望这种情况发生，我们只希望<code class="fe me mf mg mh b">Item1</code>更新，因为<code class="fe me mf mg mh b">Item2</code>的值保持不变。</p><p id="55cc" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">我们可以在React.memo中实现这个包装<code class="fe me mf mg mh b">Item</code>组件，确保组件只在<code class="fe me mf mg mh b">Item</code>的属性改变时更新。</p><p id="640a" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">但是请记住，对函数的引用作为道具传递给每次渲染时更新的<code class="fe me mf mg mh b">Item</code>？我们需要先解决这个问题。这时<code class="fe me mf mg mh b">useCallback</code>来救援了。</p><p id="9841" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">我们同样可以将函数<code class="fe me mf mg mh b">updateItem1</code>和<code class="fe me mf mg mh b">updateItem2</code>与组件的实例绑定，方法是将它们封装在一个名为<code class="fe me mf mg mh b">useCallback</code>的react钩子中，该钩子将充当类组件中的<code class="fe me mf mg mh b">bind(this)</code>，防止在每次渲染时创建新的引用。我们修好了！</p><p id="2c52" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">就是这样！现在，我们的组件<code class="fe me mf mg mh b">Item2</code>将只在<code class="fe me mf mg mh b">item2</code>更新时呈现，如下所示。</p><figure class="nj nk nl nm gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Memoized solution to the problem above using useCallback and React.memo()</figcaption></figure><h2 id="b76f" class="ms kd iq bd ke mt ne dn ki mv nf dp km ll ng my kq lp nh na ku lt ni nc ky nd bi translated"><strong class="ak">结论</strong></h2><p id="8c2f" class="pw-post-body-paragraph la lb iq lc b ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ij bi translated">虽然这样的优化是好的，但是因为在依赖数组中保存道具副本的成本可能比实现的优化量高得多，所以应该小心使用，并且用在组件更新太快的地方，比如在动画或显示交互式图表/地图等的时候</p><p id="3409" class="pw-post-body-paragraph la lb iq lc b ld lz lf lg lh ma lj lk ll mb ln lo lp mc lr ls lt md lv lw lx ij bi translated">要了解如何处理频繁变化的值，请点击链接<a class="ae np" href="https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback" rel="noopener ugc nofollow" target="_blank"> <strong class="lc ir">查看</strong> </a> <strong class="lc ir">。</strong></p></div></div>    
</body>
</html>