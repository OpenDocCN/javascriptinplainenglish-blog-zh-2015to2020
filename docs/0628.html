<html>
<head>
<title>The power of Array.prototype.reduce</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Array.prototype.reduce</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-power-of-array-prototype-reduce-c00a2486ffa7?source=collection_archive---------9-----------------------#2019-11-18">https://javascript.plainenglish.io/the-power-of-array-prototype-reduce-c00a2486ffa7?source=collection_archive---------9-----------------------#2019-11-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2cc2d79455ba6984f90ac8a41fe4ce19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3SYHGZOeQrJMX_p_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="95a9" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">我为什么需要知道？</h1><p id="deb1" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">从技术上来说，你可以忽略这个方法，继续使用心爱的<code class="fe lz ma mb mc b">for</code>或<code class="fe lz ma mb mc b">while</code>循环，但是我相信理解这个方法及其背后的方法论是非常值得的。</p><h1 id="3857" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">它是什么，它看起来像什么</h1><p id="30bf" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">该方法可用于数组。此方法的目的是将集合缩减为单个值。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="fa90" class="ml ke iq mc b gy mm mn l mo mp">const result = myArray.reduce((acc, curr, index, array) =&gt; {<br/>    ...<br/>}, initialValue);</span></pre><p id="4de1" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated">该方法采用两个参数，一个函数和初始值，函数参数如下:</p><ul class=""><li id="24c1" class="mv mw iq ld b le mq li mr lm mx lq my lu mz ly na nb nc nd bi translated"><code class="fe lz ma mb mc b">acc</code> —累计值</li><li id="88b2" class="mv mw iq ld b le ne li nf lm ng lq nh lu ni ly na nb nc nd bi translated"><code class="fe lz ma mb mc b">curr</code> —当前元素值</li><li id="988d" class="mv mw iq ld b le ne li nf lm ng lq nh lu ni ly na nb nc nd bi translated"><code class="fe lz ma mb mc b">index</code> —当前元素的索引</li><li id="2502" class="mv mw iq ld b le ne li nf lm ng lq nh lu ni ly na nb nc nd bi translated"><code class="fe lz ma mb mc b">array</code> —调用reduce方法的数组</li></ul><p id="9f52" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated">乍一看似乎很多，但是您可以省略不需要的参数。关于如何使用它的最简单的例子是对所有的数组元素求和。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="cb06" class="ml ke iq mc b gy mm mn l mo mp">const favoriteNumbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];</span><span id="c5ee" class="ml ke iq mc b gy nj mn l mo mp">const result = favoriteNumbers.reduce((acc, curr) =&gt; {<br/>    return acc + curr; <br/>}, 0);</span></pre><p id="1b5e" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated">有必要在每次调用元素后返回新的累积值:<code class="fe lz ma mb mc b">return acc + curr</code> <br/>如果我们只返回<code class="fe lz ma mb mc b">acc</code>值，我们将得到<code class="fe lz ma mb mc b">0</code>作为结果。如果我们只返回<code class="fe lz ma mb mc b">curr</code>，我们将得到一个等于数组最后一个元素的值，在本例中，如果我们不返回任何东西，我们将得到结果<code class="fe lz ma mb mc b">undefined</code>。</p><p id="203a" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated">让我们添加一些控制台日志，以便更好地了解正在发生的事情:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="3f0d" class="ml ke iq mc b gy mm mn l mo mp">const favoriteNumbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];</span><span id="f0bb" class="ml ke iq mc b gy nj mn l mo mp">const result = favoriteNumbers.reduce((acc, curr, index) =&gt; {<br/>    console.log("\nFunction call on element number: " + index);<br/>    console.log("Current accumulated value: " + acc);<br/>    console.log("Current value: " + curr);<br/>    console.log("New accumulated value: " + (acc + curr));<br/>    return acc + curr;<br/>}, 0);</span><span id="261c" class="ml ke iq mc b gy nj mn l mo mp">console.log("\nFinal result: " + result);</span></pre><p id="0847" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated"><em class="nk">我确实加了一些</em> <code class="fe lz ma mb mc b"><em class="nk">\n</em></code> <em class="nk">让输出更好:)</em></p><p id="df28" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated">输出如下所示:</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="d76e" class="ml ke iq mc b gy mm mn l mo mp">Function call on element number: 0<br/>Current accumulated value: 0<br/>Current value: 2<br/>New accumulated value: 2</span><span id="3ce4" class="ml ke iq mc b gy nj mn l mo mp">Function call on element number: 1<br/>Current accumulated value: 2<br/>Current value: 3<br/>New accumulated value: 5</span><span id="58df" class="ml ke iq mc b gy nj mn l mo mp">Function call on element number: 2<br/>Current accumulated value: 5<br/>Current value: 5<br/>New accumulated value: 10</span><span id="705d" class="ml ke iq mc b gy nj mn l mo mp">Function call on element number: 3<br/>Current accumulated value: 10<br/>Current value: 7<br/>New accumulated value: 17</span><span id="1927" class="ml ke iq mc b gy nj mn l mo mp">Function call on element number: 4<br/>Current accumulated value: 17<br/>Current value: 11<br/>New accumulated value: 28</span><span id="03ab" class="ml ke iq mc b gy nj mn l mo mp">Function call on element number: 5<br/>Current accumulated value: 28<br/>Current value: 13<br/>New accumulated value: 41</span><span id="c2c0" class="ml ke iq mc b gy nj mn l mo mp">Function call on element number: 6<br/>Current accumulated value: 41<br/>Current value: 17<br/>New accumulated value: 58</span><span id="eb52" class="ml ke iq mc b gy nj mn l mo mp">Function call on element number: 7<br/>Current accumulated value: 58<br/>Current value: 19<br/>New accumulated value: 77</span><span id="827b" class="ml ke iq mc b gy nj mn l mo mp">Function call on element number: 8<br/>Current accumulated value: 77<br/>Current value: 23<br/>New accumulated value: 100</span><span id="408f" class="ml ke iq mc b gy nj mn l mo mp">Function call on element number: 9<br/>Current accumulated value: 100<br/>Current value: 29<br/>New accumulated value: 129</span><span id="7a52" class="ml ke iq mc b gy nj mn l mo mp">Final result: 129</span></pre><h1 id="fd52" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">for循环呢？</h1><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="7487" class="ml ke iq mc b gy mm mn l mo mp">let sum = 0;<br/>for(let i = 0; i &lt; favoriteNumbers.length; i++) {<br/>    sum += favoriteNumbers[i];<br/>}</span></pre><p id="3b62" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated">这太直接了，不是吗？我为什么要在这里为<code class="fe lz ma mb mc b">reduce</code>费心呢？</p><p id="873c" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated">这里是方法论:<code class="fe lz ma mb mc b">for</code>循环是一种强制性的方法，我们创建了一个变量，然后是一个索引变量来控制访问哪个元素。似乎只是把一堆数字加起来就够了。</p><p id="8862" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated"><code class="fe lz ma mb mc b">reduce</code>方法的用法在函数式方法中，我们只需传入一个函数，这个函数将在数组的每个元素上执行。这在一开始可能看起来有点奇怪，因为你必须以不同的方式思考，在我看来这是一件好事，因为它拓宽了如何做事的视角，并为自己决定你更喜欢哪种方法(如果我看到到处都是<code class="fe lz ma mb mc b">for</code>循环，我会做出刻薄的表情)。</p><p id="bef6" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated">现在是动力部分。</p><h1 id="9424" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">真正的力量</h1><p id="373a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我个人不太喜欢这个数字求和的例子，因为它只展示了这个方法最基本的用法——我们多久需要对一组数字求和一次？我们通常在有更多对象的对象中有对象，数字只是分散在两者之间。</p><p id="7e38" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated">我们可以很容易地在任何数组上使用<code class="fe lz ma mb mc b">reduce</code>方法，而<code class="fe lz ma mb mc b">initialValue</code>也可以是任何东西，比如一个空白对象，我们可以在其中放置我们感兴趣的数据。</p><p id="daa9" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated">不久前，我想做一个安卓天气应用，只是为了和<code class="fe lz ma mb mc b">React Native</code>玩玩。我确实找到了一个具有免费层的好API，但有一个问题，API以3小时的间隔返回带有时间戳的预测，所以我必须转换它们以获得一天中的最低和最高温度。T <a class="ae kc" href="https://openweathermap.org/forecast5" rel="noopener ugc nofollow" target="_blank">这是我使用的API </a>，我也为该应用程序写了一篇文章，可以在这里找到<a class="ae kc" href="https://medium.com/javascript-in-plain-english/building-a-simple-app-in-react-native-with-expo-d43b629152bf" rel="noopener"/>，它有一个包含所有代码的存储库。下面是使用<code class="fe lz ma mb mc b">reduce</code>的简化片段。</p><pre class="md me mf mg gt mh mc mi mj aw mk bi"><span id="6339" class="ml ke iq mc b gy mm mn l mo mp">data.list.reduce((acc, curr, index) =&gt; {<br/>    // Take the first as the current temprature<br/>    if (index === 0) {<br/>        acc.current = {<br/>            currTemp: toCelcius(curr.main.temp)<br/>        }<br/>    }</span><span id="bcfc" class="ml ke iq mc b gy nj mn l mo mp">    // Group max/min temps by date<br/>    const last = _.last(acc.future);<br/>    if (last) {<br/>        if (getDayOfTheMonth(curr.dt) !== last.date) {<br/>            acc.future.push({<br/>                date: getDayOfTheMonth(curr.dt),<br/>                maxTemp: toCelcius(curr.main.temp),<br/>                minTemp: toCelcius(curr.main.temp),<br/>                recCount: 1,<br/>            });<br/>        } else {<br/>            const currTemp = toCelcius(curr.main.temp);<br/>            if (currTemp &gt; last.maxTemp) {<br/>                last.maxTemp = currTemp;<br/>            }</span><span id="b228" class="ml ke iq mc b gy nj mn l mo mp">            if (currTemp &lt; last.minTemp) {<br/>                last.minTemp = currTemp;<br/>            }</span><span id="bb60" class="ml ke iq mc b gy nj mn l mo mp">            last.recCount++;<br/>        }<br/>    } else {<br/>        acc.future.push({<br/>            date: getDayOfTheMonth(curr.dt),<br/>            maxTemp: toCelcius(curr.main.temp),<br/>            minTemp: toCelcius(curr.main.temp),<br/>            recCount: 1,<br/>        });<br/>    }<br/>    return acc;<br/>}, { future: [] });</span></pre><p id="0b33" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated">我将<code class="fe lz ma mb mc b">currTemp</code>直接设置到初始对象上，然后创建一个代表每一天的元素。如果我们的<code class="fe lz ma mb mc b">future</code>属性中的最后一个元素(代表未来的一天)与当前元素不是同一天，我们创建一个新的条目，否则相应地更新最后一个元素的最低/最高温度。这是一个非常好的数据转换方法。</p><h1 id="2cc1" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">结论</h1><p id="d3d2" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">我可以在我的例子中使用一个简单的<code class="fe lz ma mb mc b">for</code>循环吗？是的，当然！但是我坚信使用<code class="fe lz ma mb mc b">reduce</code>更干净，这比更少的代码行更重要，这种方法可以让你的数据转换代码看起来像散文！</p><p id="685b" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated">我们希望编写尽可能少的认知负荷和尽可能少的错误的代码，不直接管理循环甚至使我们更不容易出错。</p><p id="1991" class="pw-post-body-paragraph lb lc iq ld b le mq lg lh li mr lk ll lm ms lo lp lq mt ls lt lu mu lw lx ly ij bi translated">从技术上来说，我们确实牺牲了一些性能，但这种差别可以忽略不计，尽管有些人可能会认为，编写性能稍差的代码会消耗更多的电力，从而导致全球变暖，但我们不要对此进行讨论。</p></div></div>    
</body>
</html>