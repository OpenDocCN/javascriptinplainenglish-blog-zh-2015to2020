<html>
<head>
<title>How to Solve Permutations in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何解决JavaScript中的排列问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-solve-permutations-in-javascript-502cc4522482?source=collection_archive---------6-----------------------#2020-11-23">https://javascript.plainenglish.io/how-to-solve-permutations-in-javascript-502cc4522482?source=collection_archive---------6-----------------------#2020-11-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="e80f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">经典的回溯问题，用图表和详尽的解释来揭开神秘面纱。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fc25d0d269047e959d59d81676a971c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MY9X_MEVGbq5wn3h"/></div></div></figure><p id="f5ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://leetcode.com/problems/permutations/" rel="noopener ugc nofollow" target="_blank">排列</a>不是一个容易的问题。对于那些以前没有见过<strong class="kt ir">回溯</strong>问题的人来说，没有明显幼稚的解决方案，这在采访中对软件工程师构成了真正的威胁。</p><p id="42b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，有一种方法可以解决排列这样的问题。在本文中，这个问题将被分解，然后使用说明和几个图表来解决。</p><p id="a410" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">确保仔细阅读并按照文章中出现的图表进行绘制。这种做法将使解决排列这样的问题在随后的曝光中变得更加容易。</p><p id="65a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">注</strong>:假设读者对递归很熟悉。</p><h1 id="2c8b" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">排列分解</h1><p id="1dd5" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">首先，人们需要彻底解决这个问题。让我们阅读描述，并探索由此产生的任何问题。</p><p id="0b6b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">问题描述是:<em class="ml">给定一个由不同整数组成的数组</em> <code class="fe mm mn mo mp b"><em class="ml">nums</em></code> <em class="ml">，返回所有可能的排列。您可以按照</em> <strong class="kt ir"> <em class="ml">任意顺序</em> </strong> <em class="ml">返回答案。</em></p><p id="2e43" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好吧——第一个问题应该很明显:什么是<strong class="kt ir">置换</strong>？查看示例输入和输出应该有所帮助:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="535f" class="mu lp iq mp b gy mv mw l mx my"><strong class="mp ir">Input:</strong>  [1,2,3]<br/><strong class="mp ir">Output:</strong> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></pre><p id="a37b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">输入为<code class="fe mm mn mo mp b">[1,2,3]</code>。输出中有六个答案，可以假设这些元素(子阵列)中的每一个都是一个排列。</p><p id="7230" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过分析排列的内容可以推断出什么？仔细观察，我们会发现:</p><ul class=""><li id="ab64" class="mz na iq kt b ku kv kx ky la nb le nc li nd lm ne nf ng nh bi translated">排列包含输入数组中的所有元素。</li><li id="4b1f" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">没有重复排列。</li><li id="c6a1" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ne nf ng nh bi translated">排列中没有重复的元素。</li></ul><p id="96df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，排列似乎是输入数组中所有元素的<strong class="kt ir">唯一组合</strong>。</p><p id="471b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另一个示例输入和输出将是:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="2b1e" class="mu lp iq mp b gy mv mw l mx my"><strong class="mp ir">Input:</strong>  [1,2]<br/><strong class="mp ir">Output:</strong> [[1,2], [2,1]]</span></pre><p id="c2dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，输入是<code class="fe mm mn mo mp b">[1,2]</code>。因为这些元素只能以两种不同的方式重新排列，所以只返回两种排列。</p><h2 id="95de" class="mu lp iq bd lq nn no dn lu np nq dp ly la nr ns ma le nt nu mc li nv nw me nx bi translated">限制</h2><p id="9e1f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">是时候写下问题的限制条件了。</p><p id="13ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在需要注意的唯一限制是<code class="fe mm mn mo mp b">nums</code>的元素将是不同的，这意味着它们都不会重复。</p><h2 id="1b69" class="mu lp iq bd lq nn no dn lu np nq dp ly la nr ns ma le nt nu mc li nv nw me nx bi translated">定义的排列</h2><p id="54ef" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">有了适当的定义和约束，让我们重新定义问题，使其更易读。</p><p id="266f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ml">给定一个输入数组，找到</em> <strong class="kt ir"> <em class="ml">所有可能唯一组合的</em> </strong> <em class="ml">位数字。</em></p><p id="bd8e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不幸的是，对于排列这样的问题，天真的解决方案并不明显，所以仅仅分解问题并不能产生解决方案。</p><p id="2f11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">不要担心——在下一部分，我们将分解<strong class="kt ir">为什么</strong>这个问题是一个<strong class="kt ir">回溯</strong>问题，然后探索这对一个潜在的解决方案意味着什么。</p><h1 id="ccc4" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">追踪</h1><p id="ef86" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">首先，什么是回溯？</p><p id="e7ce" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://www.geeksforgeeks.org/backtracking-algorithms/" rel="noopener ugc nofollow" target="_blank">回溯</a>是一种使用递归的算法。它用于逐步构建解决方案<strong class="kt ir"/>。</p><p id="1f3c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">每次递归调用都用于构建解决方案，一次一个调用。出于解释的目的，我们将递归调用称为<strong class="kt ir">子问题。</strong>基于整体问题的条件，子问题的结果要么包含在问题的整体解中，要么排除在问题的整体解之外。</p><p id="65fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">关于回溯，需要注意的一件重要事情是，一旦子问题的当前迭代不再满足问题的条件，就可以停止调用该递归行，因为我们可以肯定地知道，从该递归行中找不到可行的解决方案。</p><p id="1fea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在下一节中，我们将通过图表直观地看到这一过程。我们将使用回溯来为给定的输入逐步建立一个有效排列的列表。</p><p id="651f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，我们将回到我们的问题:是什么使排列成为回溯问题？人们可以把它定义为一个主要原因:</p><ol class=""><li id="f2cd" class="mz na iq kt b ku kv kx ky la nb le nc li nd lm ny nf ng nh bi translated">需要根据某些条件找到<strong class="kt ir">所有可能的解</strong>。</li></ol><p id="29a5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，问题需要从一个输入数组中找到<strong class="kt ir">元素的所有可能组合</strong>。单词<strong class="kt ir"> all </strong>提示我们探索回溯作为一种潜在的解决方案，因为我们需要沿着几条路径递归，以找到所有可能的解决方案。</p><h2 id="d774" class="mu lp iq bd lq nn no dn lu np nq dp ly la nr ns ma le nt nu mc li nv nw me nx bi translated">条件是什么？</h2><p id="0936" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">让我们开始把这个回溯算法分解成可管理的块。首先，有效排列的条件是什么？</p><p id="c2d9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们知道排列必须:</p><ol class=""><li id="7930" class="mz na iq kt b ku kv kx ky la nb le nc li nd lm ny nf ng nh bi translated">拥有来自输入数组的所有元素。</li><li id="b1de" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ny nf ng nh bi translated">独一无二(没有重复排列)。</li><li id="45f6" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ny nf ng nh bi translated">排列中有<strong class="kt ir">没有重复的元素</strong>。</li></ol><p id="074c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是我们回溯算法的<strong class="kt ir">结束条件</strong>。一旦这些条件得到满足，我们就可以:</p><ol class=""><li id="83d8" class="mz na iq kt b ku kv kx ky la nb le nc li nd lm ny nf ng nh bi translated">将当前排列添加到我们的排列列表中。</li><li id="7e6c" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ny nf ng nh bi translated">停止对当前排列的递归。</li></ol><p id="527d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">死胡同条件怎么样？一旦满足这些条件，我们就可以完全停止递归，因为当前的潜在解决方案是无效的。死胡同条件是:</p><ol class=""><li id="99c7" class="mz na iq kt b ku kv kx ky la nb le nc li nd lm ny nf ng nh bi translated">当前元素是子数组中已有元素的副本(置换)。</li><li id="ce74" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ny nf ng nh bi translated">当前排列已经包含在排列的总列表中。</li></ol><p id="29ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">识别这些死胡同条件，我们将通过避免多余的递归调用来帮助我们加速算法。</p><h2 id="0b7d" class="mu lp iq bd lq nn no dn lu np nq dp ly la nr ns ma le nt nu mc li nv nw me nx bi translated">怎么才能走回头路？</h2><p id="1ce8" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们已经确定我们需要执行递归。然而，不清楚如何进行递归。需要考虑的一些重要问题是:</p><ol class=""><li id="427d" class="mz na iq kt b ku kv kx ky la nb le nc li nd lm ny nf ng nh bi translated">我们什么时候做递归？</li><li id="7ad2" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ny nf ng nh bi translated">我们在什么上执行递归，什么参数被传递给调用？</li><li id="9b8e" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ny nf ng nh bi translated">我们如何回溯每个元素？</li><li id="4e46" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ny nf ng nh bi translated">对于一个不可行的排列，我们如何停止递归？</li></ol><p id="ee14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们再来看看这个问题给我们的第一个例子:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="79f1" class="mu lp iq mp b gy mv mw l mx my"><strong class="mp ir">Input:</strong>  [1,2,3]<br/><strong class="mp ir">Output:</strong> [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></pre><p id="911c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">返回的输出中有模式吗？看每个排列(子数组)的<strong class="kt ir">第一个数字</strong>。</p><p id="a8e1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这看起来就像迭代:首先，<code class="fe mm mn mo mp b">1</code>被访问，然后是<code class="fe mm mn mo mp b">2</code>，然后是<code class="fe mm mn mo mp b">3</code>。</p><p id="cb9e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于我们需要检查<strong class="kt ir">所有可能的组合</strong>，我们肯定需要回溯输入数组中的每个元素。因此，<strong class="kt ir">通过输入数组迭代</strong>，并为每个元素调用递归回溯函数是有意义的。</p><p id="70a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，我们将通过<code class="fe mm mn mo mp b">[1,2,3]</code>进行迭代。<code class="fe mm mn mo mp b">1</code>是当前迭代中的<code class="fe mm mn mo mp b">num</code>，我们以某种方式使用值<code class="fe mm mn mo mp b">1</code>执行递归。接下来是<code class="fe mm mn mo mp b">2</code>，以此类推。</p><p id="0655" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果这还不是100%清楚，也没关系——下一节将包含许多图表来展示文字不能表达的内容。</p><h1 id="b56f" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">最后，一些视觉效果</h1><p id="d6f0" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们终于对如何解决这个问题有了一个大致的想法。以下是我们攻击计划的简要回顾:</p><ol class=""><li id="88d7" class="mz na iq kt b ku kv kx ky la nb le nc li nd lm ny nf ng nh bi translated">遍历输入数组的每个元素。</li><li id="591a" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ny nf ng nh bi translated">使用该元素对每个元素执行递归以建立当前解(置换)。</li><li id="ab79" class="mz na iq kt b ku ni kx nj la nk le nl li nm lm ny nf ng nh bi translated">一旦满足某些条件，就停止递归并返回。</li></ol><p id="52ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们把这个画出来。一定要用笔和纸跟着做。这是这个想法的第一次迭代:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/eac7071ba55537db1bf3add750ffb1b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:402/format:webp/1*jMBALUNvoVrr3lUicr2ASA.png"/></div><figcaption class="oa ob gj gh gi oc od bd b be z dk">It’s that easy, right?</figcaption></figure><p id="6eba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">太棒了——我们已经有了第一级迭代；然而，有一个问题:我们如何处理当前被迭代的元素？</p><p id="bde1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如，让我们跟随元素<code class="fe mm mn mo mp b">1</code>的迭代。我们不能只退<code class="fe mm mn mo mp b">1</code>；我们需要为每个递归调用建立一个<strong class="kt ir">潜在排列</strong>。我们如何做到这一点？</p><p id="1a93" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">很重要的一点是，考虑我们希望排列存储在什么类型的数据结构中。根据示例解决方案，排列看起来像什么？看起来是这样的:<code class="fe mm mn mo mp b">[1,2,3]</code>。</p><p id="c233" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是一个数组。当我们越来越向下递归时，我们能使用一个数组来存储当前的潜在排列吗？让我们在我们的绘图中尝试一下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f05bdc0fe4ad96f2dbd5b7165d811f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*ZXuRgARLBXZjSoykH035Ig.png"/></div></figure><p id="7b40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看起来好多了。我们已经将当前元素添加到当前势排列中。现在，让我们深入下一幅图的递归的元素<code class="fe mm mn mo mp b">1</code>路径。</p><p id="f78f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们下一步需要做什么？是的——我们需要再次为每个<strong class="kt ir">元素</strong>遍历输入数组的每个元素。这是子问题！沿着<code class="fe mm mn mo mp b">[1]</code>排列的路径，将输入数组中的每个元素添加到当前的潜在排列中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/5b05a743e9ce3daea555d019ace33aa5.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*wE3gbx60MdkHdd5Lj_EQ-g.png"/></div></figure><p id="17e8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们已经在每个递归调用中将每个新元素推送到<strong class="kt ir">潜在置换数组</strong>中。记住，这些新子数组中的每一个，像<code class="fe mm mn mo mp b">[1,1] || [1,2]</code>一样，都是一个独立的递归调用。</p><p id="8a7b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们是否满足了任何结束条件？</p><p id="4548" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们遇到过一个:递归的<code class="fe mm mn mo mp b">[1,1]</code>行不能是排列，因为<code class="fe mm mn mo mp b">1</code>是重复的。我们称之为那个分支的死胡同，并停止递归。</p><p id="50fc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外两个分支呢？<code class="fe mm mn mo mp b">[1,2]</code>很好，因为没有重复的数字，因为同样的原因<code class="fe mm mn mo mp b">[1,3]</code>也是如此。让我们继续向下递归这些分支:对于这个迭代，只需画出对<code class="fe mm mn mo mp b">2</code>元素的递归调用。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/e39ed66577ce5ba2e517d2ddae61a5a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*6mfcgoXbJDO8AYYRdEOmiA.png"/></div></figure><p id="50d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有一个赢家——<code class="fe mm mn mo mp b">[1,2,3]</code>是一个排列。它没有重复项，包含输入数组中的所有元素。将其添加到排列列表中，并停止递归。另外两条路径是死胡同，因为它们包含重复的值。</p><p id="fc3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们继续前进到递归的<code class="fe mm mn mo mp b">[1,3]</code>路径。在这里的图中，我们已经删除了<code class="fe mm mn mo mp b">[1,2]</code>路径，为新的递归调用腾出了空间。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/d4881a4281415aea17e17e2f9c69fda8.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*wclT2pKIpdWVOyCKp8FWjA.png"/></div></figure><p id="d47c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">成功！列表中又增加了一个排列。下面有<code class="fe mm mn mo mp b">X</code>的两个子数组无效，因为它们重复。</p><p id="a6ff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">信不信由你，我们已经完全探索了递归的<code class="fe mm mn mo mp b">[1]</code>分支。再看一下我们的顶级递归:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f05bdc0fe4ad96f2dbd5b7165d811f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*ZXuRgARLBXZjSoykH035Ig.png"/></div></figure><p id="dce4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是时候进入<code class="fe mm mn mo mp b">[2]</code>分支了；确保继续跟着画。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/7dfd212cf7444aa5766d4d982b61f32f.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*r0HMRZ_StKIOs0ollfUmkg.png"/></div></figure><p id="eee6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于这些递归调用，只有一个潜在的排列是无效的，并被视为死胡同。另外两个，<code class="fe mm mn mo mp b">[2,1] &amp;&amp; [2,3]</code>，可能是多一次递归调用后的排列。让我们沿着<code class="fe mm mn mo mp b">[2,1]</code>的路线一探究竟:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/88a75515444f8e1cbe09f9692e4004de.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*tx15aeyYWcMVQDCY1aw-gA.png"/></div></figure><p id="6dc2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe mm mn mo mp b">[2,1,3]</code>添加到排列列表中。完成这条递归路径后，我们可以继续前进到<code class="fe mm mn mo mp b">[2,3]</code>路径。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/9867eab41685c62c1939e1d10fee0456.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*lzsnfQVGpegYjnCOqmoxsA.png"/></div></figure><p id="a9d0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe mm mn mo mp b">[2,3,1]</code>添加到排列列表中。</p><p id="f89b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mm mn mo mp b">[2]</code>路已经走完了。最后一条路径是<code class="fe mm mn mo mp b">[3]</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f05bdc0fe4ad96f2dbd5b7165d811f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*ZXuRgARLBXZjSoykH035Ig.png"/></div></figure><p id="6d0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">沿着<code class="fe mm mn mo mp b">[3]</code>小路潜下去:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi of"><img src="../Images/06554e9006161e2e03e46e0e70f14c98.png" data-original-src="https://miro.medium.com/v2/resize:fit:482/format:webp/1*Kx5MzqIOx7EkhPTHqy62EQ.png"/></div></figure><p id="bc71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe mm mn mo mp b">[3,3]</code>无效。另外两种可能的排列仍然可行:首先递归<code class="fe mm mn mo mp b">[3,1]</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/c85ed9e971917f4b5e996b0068e794e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*oDpLjB-N1j26CkBVvUUZ7A.png"/></div></figure><p id="dfde" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe mm mn mo mp b">[3,1,2]</code>添加到排列列表中。最后，沿着<code class="fe mm mn mo mp b">[3,2]</code>的路径递归。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/0df05cc9a0f9da47c2ae56f932f42199.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*povo6Z95HbgfS9uA_plcCA.png"/></div></figure><p id="9bf7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就这样，我们都完了。我们最终的排列列表如下:</p><pre class="kg kh ki kj gt mq mp mr ms aw mt bi"><span id="4e9b" class="mu lp iq mp b gy mv mw l mx my">[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span></pre><p id="2ced" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是困难的部分，现在是令人满意的部分:编写代码。</p><h1 id="79f6" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">编写代码</h1><p id="ccd4" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">让我们创建两个函数，<code class="fe mm mn mo mp b">backtrack</code>和<code class="fe mm mn mo mp b">permute</code>。第一个用于执行递归，第二个用于存储<code class="fe mm mn mo mp b">results</code>，调用<code class="fe mm mn mo mp b">backtrack</code>，返回<code class="fe mm mn mo mp b">results</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="705d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们弄清楚在<code class="fe mm mn mo mp b">backtrack</code>的函数定义中放什么。为了找到所有排列，<code class="fe mm mn mo mp b">backtrack</code>需要传递什么数据？</p><p id="acf2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，它需要<code class="fe mm mn mo mp b">nums</code>，输入数组。将它添加到函数定义中。</p><p id="4d04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的绘图中，我们还向每个递归调用传递了什么？</p><p id="da1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们通过了一个<strong class="kt ir">临时数组</strong>。该阵列用于建立潜在的排列。再看一下第一幅图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/f05bdc0fe4ad96f2dbd5b7165d811f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:422/format:webp/1*ZXuRgARLBXZjSoykH035Ig.png"/></div></figure><p id="6c0f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">临时数组是<code class="fe mm mn mo mp b">[1] &amp;&amp; [2] &amp;&amp; [3]</code>。那么，传递给第一个<code class="fe mm mn mo mp b">backtrack</code>函数调用的是什么？</p><p id="c15f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它必须是空数组，<code class="fe mm mn mo mp b">[]</code>。在每一级递归中，我们向临时数组中添加元素，或者完全停止递归。对于第一个<code class="fe mm mn mo mp b">backtrack</code>调用，从空数组开始是有意义的。相应地更新函数定义。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="9046" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在需要做的就是弄清楚<code class="fe mm mn mo mp b">backtrack</code>函数的逻辑。让我们将输入数组的迭代<code class="fe mm mn mo mp b">nums</code>添加到函数中。</p><p id="dbb4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们在每次迭代中做什么？首先，我们需要检查一个死胡同条件。这种情况下的死端条件是如果<strong class="kt ir">临时数组包括当前迭代的元素</strong>。</p><p id="9ada" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过检查<code class="fe mm mn mo mp b">temp</code>是否包含<code class="fe mm mn mo mp b">num</code>来验证这一点。万一不成功，我们就再做一次递归。否则，我们什么都不做。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="6691" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这将调用<code class="fe mm mn mo mp b">backtrack</code>到无穷大，因为我们没有将当前元素<code class="fe mm mn mo mp b">num</code>添加到<code class="fe mm mn mo mp b">temp</code>。让我们用<code class="fe mm mn mo mp b">push</code>来做吧。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="adea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这里还有一个问题。我们已经实现了将<code class="fe mm mn mo mp b">num</code>添加到<code class="fe mm mn mo mp b">temp</code>，但是我们还需要能够在当前递归之后从<code class="fe mm mn mo mp b">temp</code>中移除<code class="fe mm mn mo mp b">num</code>。</p><p id="400a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要这样做，因为我们不希望当前元素<code class="fe mm mn mo mp b">num</code>包含在下一个元素<code class="fe mm mn mo mp b">backtrack</code>的调用中。<code class="fe mm mn mo mp b">pop</code>在<code class="fe mm mn mo mp b">backtrack</code>之后的<code class="fe mm mn mo mp b">temp</code>的最后一个元素。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="6f96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们差不多完成了；我们只需要一种方法将<strong class="kt ir">有效排列</strong>添加到<code class="fe mm mn mo mp b">results</code>数组中。让我们再来看看最终条件:</p><ol class=""><li id="973f" class="mz na iq kt b ku kv kx ky la nb le nc li nd lm ny nf ng nh bi translated">输入数组的所有元素都包含在<code class="fe mm mn mo mp b">temp</code>中。</li></ol><p id="3b9d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们防止重复的元素被推到<code class="fe mm mn mo mp b">temp</code>上，所以我们可以确定<code class="fe mm mn mo mp b">temp</code>一旦与<code class="fe mm mn mo mp b">nums</code>具有相同的长度，就拥有了<code class="fe mm mn mo mp b">nums</code>的所有元素。在迭代之上实现一个条件<strong class="kt ir">，它检查这种情况并将<code class="fe mm mn mo mp b">temp</code>推送到<code class="fe mm mn mo mp b">results</code>上。</strong></p><p id="f93f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">将<code class="fe mm mn mo mp b">temp</code>推到<code class="fe mm mn mo mp b">results</code>上很容易。对吗？</p><p id="7b30" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">没那么快——记住，每次<code class="fe mm mn mo mp b">temp</code>传递给<code class="fe mm mn mo mp b">backtrack</code>时，都是通过引用传递的。这意味着<code class="fe mm mn mo mp b">temp</code>在<code class="fe mm mn mo mp b">backtrack</code>的所有递归调用中都是同一个数组。因此，如果您将<code class="fe mm mn mo mp b">temp</code>推送到<code class="fe mm mn mo mp b">results</code>上而不使其成为新数组，那么对<code class="fe mm mn mo mp b">temp</code>的任何更改，如推或弹出，都会导致中的<strong class="kt ir">所有子数组发生更改。</strong></p><p id="2d11" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当将其推到<code class="fe mm mn mo mp b">results</code>上时，使用<code class="fe mm mn mo mp b">temp</code>上的<code class="fe mm mn mo mp b">slice</code>来避免这种情况。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="6a19" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">瞧啊。解决方案已经完成。</p><h1 id="7536" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="c33a" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">可以看出，这个问题不需要大量复杂的代码，而是需要大量的规划、建模和绘图。这些正是面试官希望在软件工程师面试中看到的实践。</p><p id="9be1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你在面试中遇到这个问题，就像我们在这篇文章中所做的那样:花足够的时间分解和图解这个问题，只有当这些任务完成后，才开始编码。</p><p id="2775" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您的时间和快乐的编码！</p></div></div>    
</body>
</html>