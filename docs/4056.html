<html>
<head>
<title>NestJS — Access &amp; Refresh Token JWT Authentication</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">NestJS —访问和刷新令牌JWT认证</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nestjs-implementing-access-refresh-token-jwt-authentication-97a39e448007?source=collection_archive---------0-----------------------#2020-11-13">https://javascript.plainenglish.io/nestjs-implementing-access-refresh-token-jwt-authentication-97a39e448007?source=collection_archive---------0-----------------------#2020-11-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/04dbe6546854d6f02ddcb9e3a058df28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X5dlhMe6jk957iV7"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Photo by <a class="ae ja" href="https://unsplash.com/@lanceanderson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Lance Anderson</a> on <a class="ae ja" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="da92" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您正在Node.js中构建应用程序，那么您可能会熟悉<a class="ae ja" href="https://nestjs.com/" rel="noopener ugc nofollow" target="_blank"> NestJS </a>，这是一个自我描述的用于构建服务器端应用程序的功能打包框架。可以把它想象成Laravel、Ruby on Rails或Flask for Node。NestJS允许我们快速构建服务，其中包含路由、验证和数据库访问等基本功能。</p><p id="c431" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">令人欣慰的是，身份验证也获得了第一方的支持，通过passport和多重警卫支持各种提供商，包括今天的主题JWT。Nest为JWT的实现提供了一个基本的<a class="ae ja" href="https://docs.nestjs.com/techniques/authentication#jwt-functionality" rel="noopener ugc nofollow" target="_blank">指南</a>，但是它不一定包括你的典型应用可能需要的所有特性。</p><p id="cdf6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看看一个定制的、功能完整的实现，您可以在自己的应用程序中使用它。为了简单起见，我们假设您有一个基于Nest安装指南的现有项目，并且对Nest提供的各种组件有基本的了解。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="c057" class="lf lg jd bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated">入门指南</h2><p id="fdff" class="pw-post-body-paragraph ka kb jd kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">让我们从安装Nest的第一方认证包开始，它将为我们的实现提供90%的逻辑，以及一些额外支持的外部模块。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="fc41" class="lf lg jd mi b gy mm mn l mo mp">$ npm install --save @nestjs/passport @nestjs/jwt passport passport-local passport-jwt bcrypt class-validator</span><span id="4f46" class="lf lg jd mi b gy mq mn l mo mp">$ npm install --save-dev @types/passport-local @types/passport-jwt @types/bcrypt @types/jsonwebtoken</span></pre><p id="370c" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">酷！<a class="ae ja" href="https://www.npmjs.com/package/@nestjs/passport" rel="noopener ugc nofollow" target="_blank"> @nestjs/passport </a>和<a class="ae ja" href="https://www.npmjs.com/package/@nestjs/jwt" rel="noopener ugc nofollow" target="_blank"> @nestjs/jwt </a>是Nest的第一方包，提供基本的功能，而<a class="ae ja" href="https://www.npmjs.com/package/passport" rel="noopener ugc nofollow" target="_blank"> passport </a>、<a class="ae ja" href="https://www.npmjs.com/package/passport-local" rel="noopener ugc nofollow" target="_blank"> passport-local </a>和<a class="ae ja" href="https://www.npmjs.com/package/passport-jwt" rel="noopener ugc nofollow" target="_blank"> passport-jwt </a>是节点中的“标准”包认证。我们还将包括用于散列支持的<a class="ae ja" href="https://www.npmjs.com/package/bcrypt" rel="noopener ugc nofollow" target="_blank"> bcrypt </a>和用于请求验证的<a class="ae ja" href="https://github.com/typestack/class-validator" rel="noopener ugc nofollow" target="_blank"> class-validator </a>。当然，我们还将包括这些包的类型(假设您使用的是TypeScript，这是应该的！)，以及<a class="ae ja" href="https://www.npmjs.com/package/jsonwebtoken" rel="noopener ugc nofollow" target="_blank"> jsonwebtoken </a>的类型，它已经作为@nestjs/jwt的依赖项包含在内。</p><p id="9adb" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">安装完依赖项后，让我们讨论一下应用程序的基本结构。在实现身份验证时，我们将使用Nest的<a class="ae ja" href="https://docs.nestjs.com/modules" rel="noopener ugc nofollow" target="_blank">模块</a>系统将两个模块连接在一起，我们称之为<code class="fe mr ms mt mi b">UsersModule</code>和<code class="fe mr ms mt mi b">AuthenticationModule</code>。虽然我们不会特别关注这个实现的数据库部分，但是我们将讨论一个能够很好地工作并存储最基本数据的通用结构。用户数据将由我们的<code class="fe mr ms mt mi b">UsersService</code>和<code class="fe mr ms mt mi b">UsersRepository</code>处理，刷新令牌由<code class="fe mr ms mt mi b">RefreshTokensRepository</code>处理，并由<code class="fe mr ms mt mi b">TokensService</code>逻辑绑定在一起。</p><p id="baea" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">而数据库实现则不那么重要，它可以与您选择的任何提供者一起工作——sequel ize、TypeORM、MongoDB等。我们仍然需要创建两个模型/实体来支持我们的认证和用户模块。同样，为了简单起见，我们将使用Nest的<a class="ae ja" href="https://docs.nestjs.com/techniques/database#sequelize-integration" rel="noopener ugc nofollow" target="_blank">第一方序列包</a>，但是将它转换成您选择的包应该相当简单。</p><p id="0547" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们以树形图的形式将所有这些放在一起，以了解您最终会得到什么。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="5f56" class="lf lg jd mi b gy mm mn l mo mp">app/<br/>|-- application.module.ts<br/>|-- requests.ts<br/>|-- modules/<br/>    |-- users/<br/>        |-- users.module.ts<br/>         -- users.service.ts<br/>    |-- authentication<br/>        |-- authentication.module.ts<br/>         -- authentication.controller.ts<br/>         -- refresh-tokens.repository.ts<br/>         -- tokens.service.ts<br/>         -- jwt.guard.ts<br/>         -- jwt.strategy.ts<br/>|-- models/<br/>    |-- user.model.ts<br/>    |-- refresh-token.model.ts</span></pre><p id="6ea7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有几个文件我们还没有讨论，比如<code class="fe mr ms mt mi b">requests.ts</code>和<code class="fe mr ms mt mi b">jwt.guard.ts</code>，但是它们的用法在后面会更明显。</p><p id="cda6" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当然，一切都可以定制，以适应您的应用程序的结构，您甚至可以选择为<code class="fe mr ms mt mi b">tokens</code>创建一个单独的模块，或者创建一个或多个附加文件夹，以进一步分离您的存储库和服务。</p><h2 id="110d" class="lf lg jd bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated">用户和令牌</h2><p id="4b74" class="pw-post-body-paragraph ka kb jd kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">现在我们已经设计好了应用程序的结构，我们可以进入重要的部分——逻辑。首先，我们可能应该谈谈用户，因为他们是身份验证的核心。</p><p id="d656" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将使用最简单形式的<code class="fe mr ms mt mi b">User</code>模型，它包含两个属性——一个<code class="fe mr ms mt mi b">username</code>和一个<code class="fe mr ms mt mi b">password</code>,但是可以很容易地进行修改以添加您可能需要的任何附加信息。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="643f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模型定义相当简单，但是你可以在这里阅读更多关于Sequelize的类型脚本实现。</p><p id="7259" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，我们还将创建一个<code class="fe mr ms mt mi b">RefreshToken</code>模型，它将允许我们为每个用户存储可重用的刷新令牌，同时还支持设置到期日期和可撤销性。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="2332" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mr ms mt mi b">user_id</code>列当然指的是拥有权的用户，<code class="fe mr ms mt mi b">is_revoked</code>提供了立即撤销令牌的能力，<code class="fe mr ms mt mi b">expires</code>提供了自动撤销的时间戳。<em class="mw">从技术上来说，</em>我们不一定需要包含一个<code class="fe mr ms mt mi b">expires</code>字段，因为我们将在刷新令牌中嵌入到期日期，但是将它存储在数据库中允许我们在将来有选择地清除到期的令牌。</p><p id="8985" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模型已经完成，但是我们需要一种方法来存储和检索它们的数据。让我们创建两个存储库类来提供可重用的功能。</p><p id="4052" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们提前考虑，我们将需要一些方法——一个根据用户ID查找用户以生成刷新令牌，一个根据用户登录时的用户名查找用户，最后一个方法创建新用户进行注册。</p><p id="6838" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如前所述，我们将这个类称为<code class="fe mr ms mt mi b">UsersRepository</code>，其实现类似于下面的内容。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="3879" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果这是你第一次在NestJS中看到使用序列模型的类，一定要在这里查看它们的参考指南<a class="ae ja" href="https://docs.nestjs.com/techniques/database#models" rel="noopener ugc nofollow" target="_blank"/>，特别是关于构造函数注入的参考。</p><p id="d850" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mr ms mt mi b">findForId(id)</code>和<code class="fe mr ms mt mi b">create(username, password)</code>都是不言自明的，而<code class="fe mr ms mt mi b">findByUsername(username)</code>可能会稍微复杂一点，因为添加了支持不区分大小写的用户名登录的序列函数。幸运的是，这些内置函数中的每一个都在<a class="ae ja" href="https://sequelize.org/master/manual/model-querying-basics.html" rel="noopener ugc nofollow" target="_blank">序列文档</a>中进行了描述，以便快速参考。</p><p id="29c1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们将服务和控制器中的一切联系在一起之前，让我们为我们的刷新令牌添加最后一个存储库。我们将需要创建令牌的能力，以及通过其ID找到一个令牌。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="7d17" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，相当简单。我们将创建一个新的<code class="fe mr ms mt mi b">RefreshToken</code>，将它与一个<code class="fe mr ms mt mi b">User</code>相关联，并基于<code class="fe mr ms mt mi b">ttl</code>参数设置到期日期，指定令牌到期前的秒数。</p><p id="3fa5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">顺便提一下——在第一个存储库中，我们使用了Sequelize的<a class="ae ja" href="https://www.npmjs.com/package/sequelize-typescript#repository-mode-1" rel="noopener ugc nofollow" target="_blank">存储库模式</a>，但是使用了刷新令牌的静态访问方法。后者允许从模型类中直接访问像<code class="fe mr ms mt mi b">find</code>和<code class="fe mr ms mt mi b">findOne</code>这样的方法，而存储库模式允许更好的关注点分离——但是这两种方法都是正确的。</p><h2 id="95fd" class="lf lg jd bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated">服务层</h2><p id="f4c4" class="pw-post-body-paragraph ka kb jd kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">数据库逻辑已经完成。我们已经创建了创建和检索新用户及其刷新令牌的方法，但是我们需要在我们的存储库和API控制器之间的最后一层——我们的服务，它将提供连接两者的业务逻辑。</p><p id="0867" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们想要创建可重用的逻辑来生成访问和刷新令牌，这就是我们的<code class="fe mr ms mt mi b">TokensService</code>发挥作用的地方。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="4f93" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们更深入地看看我们正在实施什么。</p><p id="2358" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们将通过注入之前创建的<code class="fe mr ms mt mi b">RefreshTokensRepository</code>类来设置我们的类。我们还将注入Nest的内置<code class="fe mr ms mt mi b"><a class="ae ja" href="https://github.com/nestjs/jwt/blob/master/lib/jwt.service.ts" rel="noopener ugc nofollow" target="_blank">JwtService</a></code>类，该类为jwt的签名和解码提供了围绕<code class="fe mr ms mt mi b"><a class="ae ja" href="https://www.npmjs.com/package/jsonwebtoken" rel="noopener ugc nofollow" target="_blank">jsonwebtoken</a></code>的包装函数。我们还将设置一个常量变量，声明将在我们生成的所有令牌之间共享的声明——类似于刷新和访问。虽然它们不是绝对必要的，但是它们可以为您的令牌提供额外的验证。所有潜在索赔都记录在<a class="ae ja" href="https://tools.ietf.org/html/rfc7519#section-4.1.1" rel="noopener ugc nofollow" target="_blank"> JWT RFC </a>中。</p><p id="cfe2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">方法上。我们的第一种方法<code class="fe mr ms mt mi b">generateAccessToken</code>是两种方法中比较简单的一种。给定一个<code class="fe mr ms mt mi b">User</code>，我们可以要求我们的注入<code class="fe mr ms mt mi b">JwtService</code>用我们的<code class="fe mr ms mt mi b">BASE_OPTIONS</code>声明签署一个访问令牌，以及一个附加的<code class="fe mr ms mt mi b">subject</code>声明(简称为<code class="fe mr ms mt mi b">sub</code>，它将标识为其生成令牌的用户。这将被嵌入到JWT中，允许我们以后解码它，并根据他们的ID从数据库中快速检索用户。</p><p id="811f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能想知道这是否安全。谢天谢地，JWT的有效载荷在设计上是不可变的。由于有效载荷是通过其内容的散列来验证的，因此被潜在黑客或不法分子修改的有效载荷将被服务器视为无效，我们稍后将会看到这一点。</p><p id="387d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将把签名的JWT作为一个字符串返回，稍后在API控制器中返回给客户机。</p><p id="46f5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">至于剩下的方法——<code class="fe mr ms mt mi b">generateRefreshToken</code>——我们将使用非常相似的逻辑来签署我们的刷新令牌。假设该方法接受一个<code class="fe mr ms mt mi b">expiresIn</code>参数，我们将再次把它传递给签名选项，允许我们指定刷新令牌的到期日期。此外，我们需要包含<code class="fe mr ms mt mi b">jwtid</code>声明(简称为<code class="fe mr ms mt mi b">jit</code>，顾名思义，它的功能是嵌入令牌的ID。就像我们可以通过<code class="fe mr ms mt mi b">subject</code>声明来查找<code class="fe mr ms mt mi b">User</code>一样，我们稍后也可以通过从声明中解码的ID来轻松地提取<code class="fe mr ms mt mi b">RefreshToken</code>。</p><p id="ac55" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设这些方法已经就位，我们可以进一步扩展这个类。最初生成访问和刷新令牌的逻辑已经准备好了，我们还缺少一些从刷新令牌生成访问令牌的方法。</p><p id="20d8" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们给<code class="fe mr ms mt mi b">TokensService</code>类添加一些额外的方法。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="6c0a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">五种新方法，但它们各自实现了更大难题的一小部分，使它们更容易破译。</p><p id="1249" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们先来看看<code class="fe mr ms mt mi b">decodeRefreshToken</code>，它被传递了一个字符串——也称为编码的JWT。我们将再次使用内置的<code class="fe mr ms mt mi b">JwtService</code>，但这次使用的是<code class="fe mr ms mt mi b">verifyAsync</code>，它将解码JWT令牌并以对象形式返回其有效载荷。</p><p id="2867" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">说到——我们应该定义我们期望的有效载荷是什么样的。我们将使用一个TypeScript接口，用两个属性将其命名为<code class="fe mr ms mt mi b">RefreshTokenPayload</code>:<code class="fe mr ms mt mi b">jti</code>和<code class="fe mr ms mt mi b">sub</code>，它们是我们之前传递给<code class="fe mr ms mt mi b">signAsync</code>的完整声明的正确版本，分别是<code class="fe mr ms mt mi b">jwtid</code>和<code class="fe mr ms mt mi b">subject</code>。这两个属性将返回与令牌签名时嵌入的<em class="mw">完全相同的</em>值。</p><p id="6313" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能还会注意到，我们在解码令牌时有意从<code class="fe mr ms mt mi b">jsonwebtoken</code>中捕获内置的<code class="fe mr ms mt mi b">TokenExpiredError</code>。正如我们前面提到的，我们不一定需要在数据库中存储到期日期，因为这个逻辑将确保JWT中嵌入的到期日期是有效的。我们还将捕捉任何额外的错误，并以控制器能够理解的格式返回它们。</p><p id="7dab" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另外两个方法<code class="fe mr ms mt mi b">getUserFromRefreshTokenPayload</code>和<code class="fe mr ms mt mi b">getStoredTokenFromRefreshTokenPayload</code>相当简单明了，几乎完全按照它们的名字来做。给定我们之前定义的解码后的<code class="fe mr ms mt mi b">RefreshTokenPayload</code>，这些方法将简单地从有效载荷中提取必要的字段，并分别找到和返回<code class="fe mr ms mt mi b">User</code>或<code class="fe mr ms mt mi b">RefreshToken</code>。和以前一样，如果字段不在解码后的有效载荷中，我们将在这里抛出异常。</p><p id="b3e9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有了解码刷新令牌并从数据库中检索其相关令牌和用户记录的能力，我们可以将这一功能结合起来创建我们的<code class="fe mr ms mt mi b">resolveRefreshToken</code>方法，该方法将解码并从数据库中返回<code class="fe mr ms mt mi b">RefreshToken</code>和<code class="fe mr ms mt mi b">User</code>模型，假设令牌是有效的，并且通过了我们已经实施的所有附加检查。</p><p id="99ee" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">给定字符串形式的刷新令牌，我们将解码有效负载并从数据库中获取<code class="fe mr ms mt mi b">RefreshToken</code>。假设令牌存在，并且它的<code class="fe mr ms mt mi b">is_revoked</code>字段没有被切换，我们将能够在返回用户和令牌之前从数据库中检索用户。</p><p id="217f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的最后一个方法<code class="fe mr ms mt mi b">createAccessTokenFromRefreshToken</code>中，我们可以简单地使用我们刚刚实现的<code class="fe mr ms mt mi b">resolveRefreshToken</code>方法，根据<code class="fe mr ms mt mi b">sub</code>从刷新令牌中检索<code class="fe mr ms mt mi b">User</code>，然后为该用户生成一个新的访问令牌。</p><p id="2291" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">代币？完成了。用户？差不多了。</p><p id="4023" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们创建一个超级简单的<code class="fe mr ms mt mi b">UsersService</code>来为我们之前创建的<code class="fe mr ms mt mi b">UsersRepository</code>提供额外的功能。</p><p id="3136" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就个人而言，我喜欢使用服务类来处理业务逻辑，使用存储库来与数据库交互，但是这完全取决于您自己的偏好。在这种情况下，我将使用服务层来处理请求本身和数据库之间的交互。在我们创建这个服务之前，更重要的是在我们创建我们的控制器之前，我们需要定义我们的HTTP请求体，为此我们将利用<a class="ae ja" href="https://github.com/typestack/class-validator" rel="noopener ugc nofollow" target="_blank">类验证器</a>，与许多其他特性一样，Nest提供了<a class="ae ja" href="https://docs.nestjs.com/techniques/validation#auto-validation" rel="noopener ugc nofollow" target="_blank">一流的支持</a>。</p><p id="b44a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将在我们的<code class="fe mr ms mt mi b">requests.ts</code>文件中设置我们的请求，但是您可以选择以您喜欢的任何结构将这些请求分成几个文件。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a83a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所有三个请求类都是不言自明的，一个提供登录功能，另一个提供注册，最后一个需要一个<code class="fe mr ms mt mi b">refresh_token</code>,这将允许我们生成一个新的访问令牌。</p><p id="fa72" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请求已经定义好了，所以让我们创建我们的<code class="fe mr ms mt mi b">UsersService</code>类。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="ff33" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每种方法本质上都是现有逻辑的包装器，但是实现起来不那么冗长，易于重用。<code class="fe mr ms mt mi b">validateCredentials</code>方法使用bcrypt的<code class="fe mr ms mt mi b"><a class="ae ja" href="https://www.npmjs.com/package/bcrypt#to-check-a-password" rel="noopener ugc nofollow" target="_blank">compare</a></code>函数将用户存储在数据库中的散列密码与他们试图用来登录的密码进行比较。最后一个<em class="mw"> new </em>方法<code class="fe mr ms mt mi b">createUserFromRequest</code>从前面定义的请求中获取一个<code class="fe mr ms mt mi b">RegisterRequest</code>对象，验证用户名的唯一性，然后将它和密码传递给<code class="fe mr ms mt mi b">UsersRepository</code>以创建一个新用户。最后两个方法只是将调用代理到我们的<code class="fe mr ms mt mi b">UsersRepository</code>中，这避免了我们以后必须注入存储库<em class="mw">和</em>服务。</p><h2 id="e938" class="lf lg jd bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated">API控制器路由</h2><p id="a952" class="pw-post-body-paragraph ka kb jd kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">业务逻辑<strong class="kc je">完成。那太累人了。是时候将每个组件组合在一起，创建最重要的部分—路由。在这种情况下，我们将只使用一个控制器——我们的<code class="fe mr ms mt mi b">AuthenticationController</code>提供注册、登录和刷新我们的用户及其令牌的方法。</strong></p><p id="95e2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可能希望从我们的<code class="fe mr ms mt mi b">register</code>端点开始，因为尝试登录或刷新甚至不存在的用户是没有意义的！</p><p id="24dd" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们通过注入前面的<code class="fe mr ms mt mi b">UsersService</code>和<code class="fe mr ms mt mi b">TokensService</code>以及实现我们的<code class="fe mr ms mt mi b">register</code>方法来设置我们的<code class="fe mr ms mt mi b">AuthenticationController</code>。我们还想添加Nest的<code class="fe mr ms mt mi b">@Controller()</code>装饰器，在<code class="fe mr ms mt mi b">/api/auth</code>设置控制器的基本路径，使我们的注册端点在<code class="fe mr ms mt mi b">/api/auth/register</code>作为POST请求可用。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="4318" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与其他逻辑一样，我们保持事情简单。我们通过将请求体作为包含我们的<code class="fe mr ms mt mi b">username</code>和<code class="fe mr ms mt mi b">password</code>属性的<code class="fe mr ms mt mi b">RegisterRequest</code>传递给我们的<code class="fe mr ms mt mi b">UsersService</code>来创建用户，它将负责创建我们的新用户。然后，我们将获取新创建的用户并生成一个访问令牌，以及一个将在30天后到期的刷新令牌。</p><p id="b58b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还向控制器添加了一个名为<code class="fe mr ms mt mi b">buildResponsePayload</code>的私有帮助器方法，接受用户、访问令牌和可选的刷新令牌作为参数。我们将多次重用这个函数来构建一个格式化的有效负载，作为来自每个身份验证端点的响应返回。在这样做的时候，我们还定义了我们的<code class="fe mr ms mt mi b">AuthenticationPayload</code>接口，表示我们期望每次调用这个方法时接收到的确切结构。</p><p id="9c53" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以注册用户了，让我们添加一个让他们登录的方法，也可以通过POST请求在<code class="fe mr ms mt mi b">/api/auth/login</code>获得。该逻辑与注册端点几乎相同，但是它不是创建用户，而是从用户名和密码中解析。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="75f3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们只需要回顾一下<code class="fe mr ms mt mi b">login</code>方法的前几行。由于我们需要在检索用户后验证密码，我们将首先尝试使用之前创建的<code class="fe mr ms mt mi b">UsersService</code>方法，通过用户名找到<code class="fe mr ms mt mi b">User</code>记录。</p><p id="780b" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设用户存在，我们将尝试将输入的密码与数据库中的散列密码进行匹配，再次使用我们的<code class="fe mr ms mt mi b">UsersService</code>类中的<code class="fe mr ms mt mi b">validateCredentials</code>方法。</p><p id="1ec5" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果用户不存在或者密码不匹配，我们将抛出一个<code class="fe mr ms mt mi b">UnauthorizedException</code>来通知用户用户名或密码无效。否则，我们将继续使用与我们用来为新注册用户生成访问和刷新令牌的<em class="mw">完全相同的</em>逻辑。</p><p id="cf18" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">快好了！让我们创建最后一个端点来刷新用户— <code class="fe mr ms mt mi b">/api/auth/refresh</code>也可以作为POST请求使用。这个端点将在主体中接受一个<code class="fe mr ms mt mi b">refresh_token</code>,我们将使用它来识别用户并生成新的访问令牌。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="5538" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">多亏了我们的<code class="fe mr ms mt mi b">TokensService</code>，这个方法中的逻辑非常简单。我们需要从请求体中提取出<code class="fe mr ms mt mi b">refresh_token</code>，并将其传递给我们的<code class="fe mr ms mt mi b">createAccessTokenFromRefreshToken</code>方法，该方法将返回<code class="fe mr ms mt mi b">User</code>，以及字符串形式的新的和编码的访问令牌。同样，我们可以构建响应负载，但是这次没有额外的<code class="fe mr ms mt mi b">refreshToken</code>参数。您也可以选择每次都生成一个新的刷新令牌，但是出于本文的目的，我们暂时坚持重用刷新令牌。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="59ac" class="lf lg jd bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated">模块注册</h2><p id="96a7" class="pw-post-body-paragraph ka kb jd kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">控制器搞定！此时，我们可以对它进行测试，但是我们需要首先在我们的模块中注册所有的服务、存储库和控制器。</p><p id="ecba" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们选择使用两个模块，我们的<code class="fe mr ms mt mi b">AuthenticationModule</code>和<code class="fe mr ms mt mi b">UsersModule</code>，我们只需要在开始应用程序之前配置和注册这两个模块。</p><p id="6fb9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们先设置我们的<code class="fe mr ms mt mi b">UsersModule</code>，因为前者将依赖于它。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="e93e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你以前在NestJS中注册过一个<a class="ae ja" href="https://docs.nestjs.com/modules" rel="noopener ugc nofollow" target="_blank">模块</a>，这个语法应该很熟悉。<code class="fe mr ms mt mi b">UsersService</code>和<code class="fe mr ms mt mi b">UsersRepository</code>都被设置为提供者，然后被导出供其他模块使用。<code class="fe mr ms mt mi b">User</code>模型也已经通过Sequelize导入，因此它可以被那些类解析。</p><p id="d0f9" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注册了它的依赖项后，我们还可以设置我们的<code class="fe mr ms mt mi b">AuthenticationModule</code>。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="a59e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">与之前类似，我们将设置我们的<code class="fe mr ms mt mi b">TokensService</code>和<code class="fe mr ms mt mi b">RefreshTokensRepository</code>为提供者，并注册我们之前的<code class="fe mr ms mt mi b">AuthenticationController</code>。<code class="fe mr ms mt mi b">RefreshToken</code>也将像<code class="fe mr ms mt mi b">User</code>模型一样被导入，以及在此之前注册的<code class="fe mr ms mt mi b">UsersModule</code>依赖项。</p><p id="7dfc" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于我们的<code class="fe mr ms mt mi b">TokensService</code>依赖于Nest的内置<code class="fe mr ms mt mi b">JwtService</code>,<code class="fe mr ms mt mi b">JwtModule</code>也需要在模块中注册使用。我们可以查看文档中的选项，但是我们将特别需要指定一个<code class="fe mr ms mt mi b">secret</code>以及<code class="fe mr ms mt mi b">signOptions.expiresIn</code>，它指的是<em class="mw">访问</em>令牌的生命周期(不是刷新令牌！).该参数接受一个以秒为单位指定生命周期的整数，或者一个时间跨度，如分别代表五分钟或六十秒的<code class="fe mr ms mt mi b">5m</code>或<code class="fe mr ms mt mi b">60s</code>。当然,<code class="fe mr ms mt mi b">secret</code>应该是私有的，永远不要暴露在GitHub仓库或最终用户面前。计划使用Nest建议的<a class="ae ja" href="https://docs.nestjs.com/techniques/configuration" rel="noopener ugc nofollow" target="_blank">配置设置</a>，或者您自己的实现来私有存储密钥。</p><p id="08e4" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，在测试之前，您需要注册这两个模块以及您的<code class="fe mr ms mt mi b">ApplicationModule</code>中的模型。</p><p id="287a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它们可以简单地添加到类内的<code class="fe mr ms mt mi b">imports</code>数组中。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="5b2a" class="lf lg jd mi b gy mm mn l mo mp">// application.module.ts<br/>...</span><span id="3ee8" class="lf lg jd mi b gy mq mn l mo mp">imports: [<br/>  UsersModule,<br/>  AuthenticationModule,<br/>],</span><span id="6564" class="lf lg jd mi b gy mq mn l mo mp">...</span></pre><p id="c0b7" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请参见<a class="ae ja" href="https://docs.nestjs.com/techniques/database#sequelize-integration" rel="noopener ugc nofollow" target="_blank">嵌套文档</a>注册Sequelize模块，包括主机、密码等。还有你的模特班。</p><p id="2e26" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">模块？注册了。</p><h2 id="7a7b" class="lf lg jd bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated">准备好了吗</h2><p id="4ef2" class="pw-post-body-paragraph ka kb jd kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">假设应用程序按照Nest文档中的建议正确地设置了一个<code class="fe mr ms mt mi b">main.ts</code>文件，它应该能够成功地启动并注册我们已经创建的所有类。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="0522" class="lf lg jd mi b gy mm mn l mo mp">$ nest start --watch</span></pre><p id="dd9f" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们测试一下我们的注册端点。我们还假设我们的服务器运行在本地主机端口3000上。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="79bc" class="lf lg jd mi b gy mm mn l mo mp">curl http://127.0.0.1:3000/api/auth/register \<br/>  -H "Content-Type: application/json" \<br/>  --data '{"username": "jsmith", "password": "test123"}'</span></pre><p id="4c32" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设它工作正常，我们应该看到一个包含用户数据、访问令牌及其相应的刷新令牌的响应。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="01f9" class="lf lg jd mi b gy mm mn l mo mp">{<br/>   "status": "success",<br/>   "data": {<br/>      "user": {<br/>         "username": "jsmith"<br/>      },<br/>      "payload": {<br/>         "type": "bearer",<br/>         "token": "eyJ......HNA",<br/>         "refresh_token": "eyJ......UEk"<br/>      }<br/>   }<br/>}</span></pre><p id="f40e" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看起来不错！让我们测试一下登录端点。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="1b80" class="lf lg jd mi b gy mm mn l mo mp">curl http://127.0.0.1:3000/api/auth/login \<br/>  -H "Content-Type: application/json" \<br/>  --data '{"username": "jsmith", "password": "test123"}'</span></pre><p id="4489" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是完全相同的响应，但是当然使用了不同的访问和刷新令牌。在我们结束之前，让我们尝试一下刷新端点。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="3d32" class="lf lg jd mi b gy mm mn l mo mp">curl http://127.0.0.1:3000/api/auth/refresh \<br/>  -H "Content-Type: application/json" \<br/>  --data '{"refresh_token": "eyJ......UEk"}'</span></pre><p id="bfa1" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对此的响应是类似的，但是缺少新的刷新令牌，因为我们选择了<em class="mw">而不是</em>来生成新的刷新令牌。当然，您可以选择每次都生成一个新的刷新令牌。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="7272" class="lf lg jd mi b gy mm mn l mo mp">{<br/>   "status": "success",<br/>   "data": {<br/>      "user": {<br/>         "username": "jsmith"<br/>      },<br/>      "payload": {<br/>         "type": "bearer",<br/>         "token": "eyJ......HNA",<br/>      }<br/>   }<br/>}</span></pre><h2 id="9f88" class="lf lg jd bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated">认证路由</h2><p id="fdc2" class="pw-post-body-paragraph ka kb jd kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">现在怎么办？我们已经生成了访问令牌和刷新令牌，甚至使用刷新令牌来生成访问令牌。</p><p id="8e50" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以在这里结束，但是如何进行认证请求呢？</p><p id="7dda" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">实施身份验证的全部目的是识别用户或访问受保护的资源，如用户的个人资料、订单历史或任何其他不能公开的特征。</p><p id="9933" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们扩展@nestjs/jwt构建的<code class="fe mr ms mt mi b">JwtGuard</code>和<code class="fe mr ms mt mi b">JwtStrategy</code>实现，而不是为每个方法重新实现访问令牌检查。</p><p id="8cca" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将在认证模块中创建<code class="fe mr ms mt mi b">JwtStrategy</code>作为<code class="fe mr ms mt mi b">jwt.strategy.ts</code>。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="1904" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在类构造函数中，我们指定了与之前第一次配置<code class="fe mr ms mt mi b">JwtModule</code>时相似的选项。应该指定相同的秘密，以及相同的令牌生命周期。我们还添加了<code class="fe mr ms mt mi b">jwtFromRequest</code>选项来指定在哪里可以访问访问令牌，在这种情况下使用<code class="fe mr ms mt mi b">Authorization</code>头，通过内置于<code class="fe mr ms mt mi b">passport-jwt</code>文档<a class="ae ja" href="http://www.passportjs.org/packages/passport-jwt/" rel="noopener ugc nofollow" target="_blank">中的<code class="fe mr ms mt mi b">ExtractJwt.fromAuthHeaderAsBearerToken</code>以及其他可能的提取选项。</a></p><p id="9711" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们还定义了我们的<code class="fe mr ms mt mi b">AccessTokenPayload</code>，它提供了与前面定义的<code class="fe mr ms mt mi b">RefreshTokenPayload</code>相同的功能，用于访问刷新令牌的解码有效负载。访问令牌的有效负载将被传递到<code class="fe mr ms mt mi b">validate</code>函数中，该函数是<code class="fe mr ms mt mi b">passport-jwt</code>的包装器，用于检索<code class="fe mr ms mt mi b">User</code>记录。</p><p id="2a45" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们将从有效负载中提取<code class="fe mr ms mt mi b">sub</code>属性，再次简称为<code class="fe mr ms mt mi b">subject</code>，它标识了访问令牌所代表的用户ID。假设ID是有效的，我们可以从我们的<code class="fe mr ms mt mi b">UsersService</code>获取用户并返回它。现在可以通过控制器中的<code class="fe mr ms mt mi b">@Req()</code>装饰器在HTTP请求中访问用户。</p><p id="f958" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在添加认证路由之前，我们还需要添加一个<code class="fe mr ms mt mi b">JwtGuard</code>，它将为路由提供实际的认证保护。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="c1a3" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这只是对<a class="ae ja" href="https://docs.nestjs.com/techniques/authentication#extending-guards" rel="noopener ugc nofollow" target="_blank"> Nest的认证守卫</a>的一个扩展，如果<code class="fe mr ms mt mi b">err</code>或<code class="fe mr ms mt mi b">info</code>被传递给<code class="fe mr ms mt mi b">handleRequest</code>就会抛出一个错误，或者如果用户由于某种原因为空，可能会抛出自己的<code class="fe mr ms mt mi b">UnauthorizedException</code>。</p><p id="7a5d" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc je">重要提示:</strong><code class="fe mr ms mt mi b">JwtGuard</code>需要添加到您的<code class="fe mr ms mt mi b">AuthenticationModule</code>中的提供者列表中，以便注册和使用。</p><p id="8063" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的警卫已经注册，并准备验证用户。让我们在我们的<code class="fe mr ms mt mi b">AuthenticationController</code>中添加一个认证路由，以返回登录用户的配置文件。</p><figure class="md me mf mg gt ip"><div class="bz fp l di"><div class="mu mv l"/></div></figure><p id="eabf" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<code class="fe mr ms mt mi b">@Req()</code>装饰器，我们将能够访问请求，由于附加在方法上的额外的<code class="fe mr ms mt mi b">@UseGuards(JWTGuard)</code>，请求现在被注入了登录的<code class="fe mr ms mt mi b">User</code>。我们的防护将使用访问令牌自动验证和认证用户，然后在请求中使其可访问。然后，我们可以使用用户的ID来查找他们的数据库记录，并将其返回给客户端。</p><p id="a4a2" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们试试看。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="6d74" class="lf lg jd mi b gy mm mn l mo mp">curl http://127.0.0.1:3000/api/auth/me \<br/>  -H "Content-Type: application/json" \<br/>  -H "Authorization: Bearer eyJ......UEk"</span></pre><p id="8e49" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">成功！该响应非常类似于我们的身份验证有效负载，但是只返回用户的信息，没有任何额外的令牌。</p><pre class="md me mf mg gt mh mi mj mk aw ml bi"><span id="d447" class="lf lg jd mi b gy mm mn l mo mp">{<br/>   "status": "success",<br/>   "data": {<br/>      "username": "jsmith"<br/>   }<br/>}</span></pre><p id="0d11" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，您可以轻松保护任何资源。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="1619" class="lf lg jd bd lh li lj dn lk ll lm dp ln kl lo lp lq kp lr ls lt kt lu lv lw lx bi translated">包扎</h2><p id="82e8" class="pw-post-body-paragraph ka kb jd kc b kd ly kf kg kh lz kj kk kl ma kn ko kp mb kr ks kt mc kv kw kx ig bi translated">身份验证不是一个简单的话题——因此这篇文章相当冗长，但是涵盖了在Nest中实现这样一个系统最有问题的部分，并试图尽可能地简化它。</p><p id="e5fa" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">肯定会有我错过的东西，或者可以进一步澄清的观点，或者甚至可以用完全不同(或者更好)的方式实现的逻辑。)way but Nest、Passport、Sequelize和这里使用的所有其他包提供了容易访问且非常有用的文档，非常有用。如果所有的代码样本都不是清晰的小片段，它们可以在<a class="ae ja" href="https://gist.github.com/jengel3/6a49a25b2fc2eb56fcf8b38f5004ea2c" rel="noopener ugc nofollow" target="_blank">这里</a>或者<a class="ae ja" href="https://github.com/jengel3/nestjs-auth-example" rel="noopener ugc nofollow" target="_blank">样本库</a>一起查看。</p><p id="1b7a" class="pw-post-body-paragraph ka kb jd kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想在Vue中使用这个实现，我在这里<a class="ae ja" href="https://medium.com/swlh/jwt-authentication-in-vue-nuxt-the-right-way-486e333b1d71" rel="noopener">写了一整篇文章，记住了这个确切的设置。</a></p></div></div>    
</body>
</html>