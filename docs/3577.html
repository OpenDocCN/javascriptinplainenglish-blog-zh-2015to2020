<html>
<head>
<title>How to add code splitting to your Angular app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何将代码拆分添加到Angular应用程序中</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-add-code-splitting-to-your-angular-app-d9c363ac5cae?source=collection_archive---------5-----------------------#2020-10-10">https://javascript.plainenglish.io/how-to-add-code-splitting-to-your-angular-app-d9c363ac5cae?source=collection_archive---------5-----------------------#2020-10-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/612b98cc320cc3e116faca19c0926012.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgrhrlBgwSBUK_956Hesqg.jpeg"/></div></div></figure><p id="9f12" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">随着web应用程序功能的增长，我们也看到了它们的捆绑包大小的增长。一方面，我们需要为很酷的新功能发布更多代码。另一方面，我们也需要第三方库和他们的代码来让一切工作。</p><p id="a94d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果呢？巨大的初始包大小，因此，更多的加载时间。这反过来会导致更多的用户离开你的应用，从而导致业务损失。代码分割是处理这个问题的一种有用的技术。</p><h1 id="6c55" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">什么是代码拆分？</h1><p id="c28f" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated"><em class="lw">“代码分割是将代码分割成不同的包或组件，然后按需或并行加载。”— </em> <a class="ae lx" href="https://developer.mozilla.org/en-US/docs/Glossary/Code_splitting#:~:text=While%20the%20total%20amount%20of,be%20dynamically%20loaded%20at%20runtime." rel="noopener ugc nofollow" target="_blank"> <em class="lw"> MDN网络文档</em> </a></p><p id="d669" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">换句话说，您将您的应用程序划分成更小的包，并使您的初始包尽可能小。然后，当用户需要时，可以下载某个特性的包。另一种说法是延迟加载。</p><p id="dc5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这篇文章中，我将介绍三种对Angular应用进行代码拆分的方法——在模块、组件或包的级别。</p><h1 id="b1d3" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">模块级代码拆分</h1><p id="9bc4" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">这是对Angular应用程序进行代码拆分的最好方法之一。</p><p id="a534" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Angular中的模块通常是指可以由导航路线分隔的不同部分。</p><p id="f9ed" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">例如，如果我们正在建立一个学校管理应用程序，我们可以有一个模块来管理学术，一个模块来管理体育等。</p><p id="cd14" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">假设我们称我们的学术模块为<code class="fe ly lz ma mb b">AcademicsModule</code>。在我们的应用程序中创建它之后，下一步是为它添加一条路线。我们需要做的就是在我们的路由配置中指定以下内容。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="2498" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">确保您的<code class="fe ly lz ma mb b">AcademicsModule</code>没有被导入到您的任何其他模块中，否则它可能会包含在您的主包中。使用上面的代码，webpack将识别import语句，并为包含代码及其依赖项的模块创建一个单独的包。</p><p id="6c74" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一旦用户导航到/academics路径，<code class="fe ly lz ma mb b">AcademicsModule</code>就会被延迟加载。</p><p id="cee9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">关于模块上代码分割的更多细节，请查看Minko Gechev的这篇优秀文章。</p><div class="mi mj gp gr mk ml"><a href="https://web.dev/route-level-code-splitting-in-angular/" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">角度路由级代码拆分</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">通过使用路由级代码分割来提高应用程序的性能！这篇文章解释了如何设置路由级别…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">网络开发</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz jt ml"/></div></div></a></div><h1 id="b4ed" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">组件级代码拆分</h1><p id="7a00" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">组件是Angular app的构建块，粒度比模块高。虽然我们应该总是努力使组件简单和可重用，但有时这是不可能的。您的组件可能会使用大量的服务，或者在其中包含子组件。在初始包中包含这样的组件会不必要地增加应用程序的臃肿。</p><h1 id="c759" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">如何在Angular中对组件进行代码拆分？</h1><p id="3959" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">嗯，以前没那么容易。但是有了棱角分明的常春藤，就方便多了。与模块一样，我们将使用webpack动态导入语句。</p><h2 id="8ebb" class="na ku in bd kv nb nc dn kz nd ne dp ld kg nf ng lh kk nh ni ll ko nj nk lp nl bi translated">动态导入ala webpack</h2><p id="d1a6" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">动态导入是webpack的一个特性，通过它webpack可以识别模块、组件等。它们需要延迟加载，并在编译时为它们创建单独的包。</p><p id="cb3b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在运行时，import语句解析为一个Promise，因此应用程序应该使用async/await组合或Promise.then来等待它。然后，导入的模块可以在您的代码中使用。</p><p id="004c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">欲了解更多信息，请点击这里查看<a class="ae lx" href="https://webpack.js.org/guides/lazy-loading/" rel="noopener ugc nofollow" target="_blank"> webpack官方文档</a>。</p><p id="32c1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">看看下面的学校管理应用程序的ReportCardComponent的代码示例。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="1691" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后是你的模板文件。</p><pre class="mc md me mf gt nm mb nn no aw np bi"><span id="b323" class="na ku in mb b gy nq nr l ns nt">&lt;ng-template [ngComponentOutlet]="dynamicComponent"&gt;<br/>&lt;/ng-template&gt;</span></pre><p id="21fd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以我们在这里做的是声明一个组件类型变量——它将包含我们的惰性加载组件。然后我们使用一个函数来加载我们想要延迟加载的<code class="fe ly lz ma mb b">ReportCardComponent</code>,并将它赋给这个变量。</p><p id="d7b9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，我们使用Angular提供的<code class="fe ly lz ma mb b">ngComponentOutlet</code>指令并在那里指定我们的变量。这将在组件加载后立即将其添加到我们的UI中。我们可以随时调用该函数，无需将它与路线变更相关联！这使得它成为以组件的形式动态加载我们的应用程序的一种非常灵活的方式。</p><p id="a7ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">还有很多内容超出了本文的范围。如果你对此感兴趣，可以看看<a class="nu nv ep" href="https://medium.com/u/b889ae02aa26?source=post_page-----d9c363ac5cae--------------------------------" rel="noopener" target="_blank"> Netanel Basal </a>的这篇精彩文章。他解释了以这种方式动态加载组件的不同方式。</p><div class="mi mj gp gr mk ml"><a href="https://netbasal.com/welcome-to-the-ivy-league-lazy-loading-components-in-angular-v9-e76f0ee2854a" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">欢迎来到常春藤联盟:Angular v9中的延迟加载组件</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">用Ivy延迟加载组件</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">netbasal.com</p></div></div><div class="mu l"><div class="nw l mw mx my mu mz jt ml"/></div></div></a></div><h1 id="b187" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">封装级代码拆分</h1><p id="1c0b" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">最后，但同样重要的是，我们还可以在npm包级别应用代码拆分。通常，在构建一个特性时，我们会求助于使用现有的第三方javascript库。</p><p id="244b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这很方便，可以节省你的时间！</p><p id="a722" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">但是如果依赖项很大，会增加初始加载时间。如果你使用依赖的唯一地方是在应用程序的特定部分，这尤其成问题。为什么我们要为所有用户预先加载这个，而大多数用户甚至不需要它？</p><p id="7b82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一个显而易见的事实，当用户需要时，这些库应该被延迟加载。开发人员包含javascript库的典型方式是使用单独的服务，并在文件顶部使用静态导入语句，就像这样(这是针对PDFMake库的)。</p><pre class="mc md me mf gt nm mb nn no aw np bi"><span id="9377" class="na ku in mb b gy nq nr l ns nt">import pdfMake from 'pdfmake/build/pdfmake';<br/>import pdfFonts from 'pdfmake/build/vfs_fonts';<br/>pdfMake.vfs = pdfFonts.pdfMake.vfs;</span></pre><p id="e148" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的问题是这会将库添加到主包中。如果要应用代码拆分，请使用下面的方法。</p><figure class="mc md me mf gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="37df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这确保了PDFMake库只在用户需要时，在调用loadPdfMaker函数时才被加载。可以添加一个加载器来给用户一个可视的指示。还要注意加载的库是如何保存为服务变量供将来使用的。</p><p id="a4cf" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这种技术可以用于几乎所有的包，如果你有一个大的库，拖下你的应用程序，它会变得非常灵活。</p><p id="cd9a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">要了解更多细节和详细的工作代码示例，请查看我不久前发表的关于以这种方式将<strong class="jx io"> PDFMake </strong>添加到Angular应用程序中的<a class="ae lx" href="https://zoaibkhan.com/blog/generate-pdf-in-angular-with-pdfmake/" rel="noopener ugc nofollow" target="_blank">帖子</a>。</p><div class="mi mj gp gr mk ml"><a href="https://zoaibkhan.com/blog/generate-pdf-in-angular-with-pdfmake/" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd io gy z fp mq fr fs mr fu fw im bi translated">使用PDFMake以角度生成PDF "</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">最近，我为一个客户开发了一个功能，包括从他的Angular web应用程序生成一个PDF文档…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">zoaibkhan.com</p></div></div><div class="mu l"><div class="nx l mw mx my mu mz jt ml"/></div></div></a></div><h1 id="095c" class="kt ku in bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="3151" class="pw-post-body-paragraph jv jw in jx b jy lr ka kb kc ls ke kf kg lt ki kj kk lu km kn ko lv kq kr ks ig bi translated">总之，Angular中的这三种代码拆分技术打开了一扇可能性的大门。我们可以为新用户提供一个轻薄智能的初始应用，同时在用户需要时按需加载复杂的功能。</p><p id="9129" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在哪里使用模块，组件和包，取决于你作为一个开发者，在某种程度上，取决于你的应用程序的结构。好好用，有很棒的灯塔评分当奖品！</p><p id="3b59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我希望这篇文章对你的编码之旅有所帮助。</p><p id="9c43" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">感谢阅读。</p><p id="abe8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">再见:)</p></div><div class="ab cl ny nz hr oa" role="separator"><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od oe"/><span class="ob bw bk oc od"/></div><div class="ig ih ii ij ik"><p id="cc98" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">本帖原载于zoaibkhan.com<em class="lw"><a class="ae lx" href="https://zoaibkhan.com/blog/how-to-add-code-splitting-to-your-angular-app/" rel="noopener ugc nofollow" target="_blank">T5。关注我的</a></em> <a class="ae lx" href="https://twitter.com/zoaibdev" rel="noopener ugc nofollow" target="_blank"> <em class="lw">推特</em> </a> <em class="lw">了解更多！</em></p></div></div>    
</body>
</html>