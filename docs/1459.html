<html>
<head>
<title>Easy Logging with the Morgan Express Middleware</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Morgan Express中间件轻松登录</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/easy-logging-with-the-morgan-express-middleware-4569182ffda4?source=collection_archive---------1-----------------------#2020-03-18">https://javascript.plainenglish.io/easy-logging-with-the-morgan-express-middleware-4569182ffda4?source=collection_archive---------1-----------------------#2020-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c74b87f53740cbc65887b2d2328d3abb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wqUh05R1KfD0j7AQ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@andriklangfield?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andrik Langfield</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="209a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">日志记录是任何应用程序的重要组成部分。我们想知道正在进行什么活动，并在问题出现时寻找信息来解决问题。</p><p id="072b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何使用<code class="fe lb lc ld le b">morgan</code>中间件在Express应用程序中添加日志。</p><h1 id="b022" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">因素</h1><p id="17e8" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">中间件让我们传入两个参数。第一个是<code class="fe lb lc ld le b">format</code>，第二个是<code class="fe lb lc ld le b">options</code>物体。</p><h2 id="344d" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">格式</h2><p id="e599" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">format</code>是一个字符串。例如，我们可以传入<code class="fe lb lc ld le b">'tiny'</code>来显示最少的信息。</p><p id="8c09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以传入一个字符串，其中包含我们想要显示的字段，如1:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="a812" class="mi lg iq le b gy nc nd l ne nf">morgan(':method :url :status');</span></pre><p id="0135" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">format</code>也可以是如下自定义格式函数:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="4988" class="mi lg iq le b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const morgan = require('morgan')<br/>const app = express();</span><span id="c8c6" class="mi lg iq le b gy ng nd l ne nf">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="aade" class="mi lg iq le b gy ng nd l ne nf">morgan((tokens, req, res) =&gt; {<br/>  return [<br/>    tokens.method(req, res),<br/>    tokens.url(req, res),<br/>    tokens.status(req, res),<br/>  ].join(' ')<br/>})</span><span id="e0cf" class="mi lg iq le b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send('foo');<br/>});</span><span id="f6c0" class="mi lg iq le b gy ng nd l ne nf">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="7f5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了同样的东西:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="9f5b" class="mi lg iq le b gy nc nd l ne nf">morgan(':method :url :status');</span></pre><p id="61f0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">传递给<code class="fe lb lc ld le b">morgan</code>函数返回值的函数。</p><h2 id="e67a" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">选择</h2><p id="1f10" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">morgan</code>接受<code class="fe lb lc ld le b">options</code>对象中的几个属性。</p><p id="b2e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">立即</strong></p><p id="9217" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">immediate</code>记录请求而不是响应。不会记录响应中的数据。</p><p id="8370" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">跳过</strong></p><p id="6712" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确定何时跳过日志记录的函数。</p><p id="cb14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">流</strong></p><p id="2f3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">写入日志行的输出流，默认为<code class="fe lb lc ld le b">process.stdout</code>。</p><h2 id="9132" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">预定义格式</h2><p id="e4fb" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><strong class="kf ir">合起来</strong></p><p id="f399" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">标准Apache组合日志输出:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="2ce0" class="mi lg iq le b gy nc nd l ne nf">:remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent"</span></pre><p id="6487" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">常见的</strong></p><p id="2fce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">标准Apache通用日志输出:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="8423" class="mi lg iq le b gy nc nd l ne nf">:remote-addr - :remote-user [:date[clf]] ":method :url HTTP/:http-version" :status :res[content-length]</span></pre><p id="8023" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">开发</strong></p><p id="d337" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">开发用日志。对于服务器错误代码，<code class="fe lb lc ld le b">:status</code>令牌将显示为红色，对于客户端错误代码显示为黄色，对于重定向代码显示为青色，对于其他代码显示为无色。</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="91b6" class="mi lg iq le b gy nc nd l ne nf">:method :url :status :response-time ms - :res[content-length]</span></pre><p id="b5af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">短</strong></p><p id="bc43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">比默认值短，包括响应时间。</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="d81c" class="mi lg iq le b gy nc nd l ne nf">:remote-addr :remote-user :method :url HTTP/:http-version :status :res[content-length] - :response-time ms</span></pre><p id="1b5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">微小的</strong></p><p id="57c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最小输出:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="fa57" class="mi lg iq le b gy nc nd l ne nf">:method :url :status :res[content-length] - :response-time ms</span></pre><h1 id="9a3c" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">代币</h1><p id="3bdd" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以创建新的令牌来记录我们需要的字段。</p><p id="d4b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="544e" class="mi lg iq le b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const morgan = require('morgan')<br/>const app = express();</span><span id="55ea" class="mi lg iq le b gy ng nd l ne nf">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="5a4e" class="mi lg iq le b gy ng nd l ne nf">morgan.token('type', (req, res) =&gt; req.headers['content-type'])</span><span id="9121" class="mi lg iq le b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send('foo');<br/>});</span><span id="1d9f" class="mi lg iq le b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="13fa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe lb lc ld le b">:type</code>将记录<code class="fe lb lc ld le b">req.headers[‘content-type’]</code>。</p><p id="8635" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是内置在<code class="fe lb lc ld le b">morgan</code>中的令牌:</p><ul class=""><li id="b772" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated"><code class="fe lb lc ld le b">:date[format]</code> —采用UTC格式的日期。可用的格式有:通用长格式的<code class="fe lb lc ld le b">clf</code>(如<code class="fe lb lc ld le b">10/Oct/2000:13:55:36 +0000</code>)；ISO 8601格式的<code class="fe lb lc ld le b">iso</code>(如<code class="fe lb lc ld le b">2000–10–10T13:55:36.000</code>)；RFC 1123格式的<code class="fe lb lc ld le b">web</code>(如<code class="fe lb lc ld le b">Tue, 10 Oct 2000 13:55:36 GMT</code>)</li><li id="a173" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe lb lc ld le b">:http-version</code> —请求的HTTP版本</li><li id="114c" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe lb lc ld le b">:method</code> —请求的HTTP方式</li><li id="8b80" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe lb lc ld le b">:referreer</code> —请求的引用者标题。这将使用标准拼写错误的参考者标题(如果存在)，否则将记录参考者</li><li id="5524" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe lb lc ld le b">:remote-addr</code>——请求的远程地址。这将使用<code class="fe lb lc ld le b">req.ip</code>。否则标准<code class="fe lb lc ld le b">req.connection.remoteAddress</code>值</li><li id="8e54" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe lb lc ld le b">:remote-user</code> —基本授权的用户认证部分</li><li id="3148" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe lb lc ld le b">:req[header]</code> —请求的给定<code class="fe lb lc ld le b">header</code>。如果不存在，将记录为<code class="fe lb lc ld le b">-</code></li><li id="62ca" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe lb lc ld le b">:res[header]</code> —给定的响应<code class="fe lb lc ld le b">header</code>。如果不存在，将记录为<code class="fe lb lc ld le b">-</code></li><li id="48d1" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe lb lc ld le b">:response-time[digits]</code> —请求进入<code class="fe lb lc ld le b">morgan</code>和写入响应头之间的时间，单位为毫秒。</li><li id="5ba3" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe lb lc ld le b">:status</code> —响应状态。如果请求/响应周期在响应发送到客户端之前完成，则状态将为空</li><li id="0d25" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe lb lc ld le b">:url</code> —请求的网址。如果存在，将使用<code class="fe lb lc ld le b">req.originalUrl</code>否则将使用<code class="fe lb lc ld le b">req.url</code>。</li><li id="b6d6" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe lb lc ld le b">:user-agent</code> —请求的<code class="fe lb lc ld le b">User-Agent</code>头的内容</li></ul><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/2cc6d37fe8dc625f43c64f953597db17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IbCUzBeYBDAg-gn9"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ingle_jake?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jake Ingle</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c9fd" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">morgan.compile(格式)</h1><p id="5d22" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">该方法将格式字符串编译成<code class="fe lb lc ld le b">format</code>函数，供<code class="fe lb lc ld le b">morgan</code>使用。</p><p id="e476" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">格式字符串是表示单个日志行的字符串，可以使用标记语法。</p><p id="e26a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">令牌参照<code class="fe lb lc ld le b">:token-name</code>。如果令牌接受参数，我们可以将其传递到<code class="fe lb lc ld le b">[]</code>。</p><h1 id="0ae9" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">例子</h1><h2 id="a4d3" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">简单示例</h2><p id="673d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">morgan</code>的简单使用如下:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="327e" class="mi lg iq le b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const morgan = require('morgan')<br/>const app = express();</span><span id="5c1a" class="mi lg iq le b gy ng nd l ne nf">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="2f4f" class="mi lg iq le b gy ng nd l ne nf">app.use(morgan('combined'));</span><span id="625b" class="mi lg iq le b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send('foo');<br/>});</span><span id="2866" class="mi lg iq le b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="479b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们会得到类似这样的结果:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="1059" class="mi lg iq le b gy nc nd l ne nf">::ffff:172.18.0.1 - - [28/Dec/2019:01:04:22 +0000] "GET / HTTP/1.1" 304 - "<a class="ae kc" href="https://repl.it/languages/express" rel="noopener ugc nofollow" target="_blank">https://repl.it/languages/express</a>" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36"</span></pre><h2 id="8bf3" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">将日志写入文件</h2><p id="d355" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以通过设置<code class="fe lb lc ld le b">option</code>对象的<code class="fe lb lc ld le b">stream</code>选项将日志写入文件，并将其传递给第二个参数，如下所示:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="6fd7" class="mi lg iq le b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const morgan = require('morgan')<br/>const app = express();<br/>const fs = require('fs')<br/>const path = require('path')<br/>const appLogStream = fs.createWriteStream(path.join(__dirname, 'app.log'), { flags: 'a' })</span><span id="78a2" class="mi lg iq le b gy ng nd l ne nf">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="5900" class="mi lg iq le b gy ng nd l ne nf">app.use(morgan('combined', { stream: appLogStream}));</span><span id="6770" class="mi lg iq le b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send('foo');<br/>});</span><span id="397a" class="mi lg iq le b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="1fa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="d5c0" class="mi lg iq le b gy nc nd l ne nf">::ffff:172.18.0.1 - - [28/Dec/2019:01:06:44 +0000] "GET / HTTP/1.1" 304 - "<a class="ae kc" href="https://repl.it/languages/express" rel="noopener ugc nofollow" target="_blank">https://repl.it/languages/express</a>" "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.88 Safari/537.36"</span></pre><p id="72cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">app.log</code>中。</p><h2 id="b13b" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">旋转原木</h2><p id="087d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">通过设置对象的<code class="fe lb lc ld le b">interval</code>属性，我们可以在原木之间旋转。</p><p id="5177" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="7945" class="mi lg iq le b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const morgan = require('morgan')<br/>const app = express();<br/>const fs = require('fs')<br/>const path = require('path')<br/>const accessLogStream = fs.createWriteStream(path.join(__dirname, 'app.log'), { flags: 'a' })</span><span id="c58d" class="mi lg iq le b gy ng nd l ne nf">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="e531" class="mi lg iq le b gy ng nd l ne nf">app.use(morgan('combined', {<br/>  interval: '7d',<br/>  stream: accessLogStream<br/>}));</span><span id="b8a1" class="mi lg iq le b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send('foo');<br/>});</span><span id="106a" class="mi lg iq le b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="d4e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每周轮换原木。</p><h2 id="ec0f" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">自定义日志条目格式</h2><p id="8670" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以定义自己的令牌并记录如下:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="2803" class="mi lg iq le b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const morgan = require('morgan')<br/>const app = express();<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));<br/>app.use(morgan(':id :method :url :date[iso]'))</span><span id="993c" class="mi lg iq le b gy ng nd l ne nf">morgan.token('id', (req) =&gt; req.id);</span><span id="fab6" class="mi lg iq le b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  req.id = 1;<br/>  res.send('foo');<br/>});</span><span id="2d40" class="mi lg iq le b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="2249" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，由于我们将<code class="fe lb lc ld le b">req.id</code>设置为1，我们得到:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="8a01" class="mi lg iq le b gy nc nd l ne nf">1 GET / 2019-12-28T01:11:07.646Z</span></pre><p id="0dce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">1</code>在第一列中，因为我们在<code class="fe lb lc ld le b">:method</code>之前的格式字符串中首先指定了<code class="fe lb lc ld le b">:id</code>。</p><h1 id="33b6" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="c137" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">morgan</code>是一个易于使用的快速应用程序日志。它是一个中间件，我们可以指定我们的日志格式和数据，用令牌登录每个条目。</p><p id="83f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了记录我们想要的预置令牌，我们可以使用<code class="fe lb lc ld le b">token</code>方法定义自己的令牌。</p></div></div>    
</body>
</html>