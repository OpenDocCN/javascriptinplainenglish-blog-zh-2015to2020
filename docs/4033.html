<html>
<head>
<title>Best of Modern JavaScript — Proxies and Object Operations</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华—代理和对象操作</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-proxies-and-object-operations-4c1adc657757?source=collection_archive---------15-----------------------#2020-11-11">https://javascript.plainenglish.io/best-of-modern-javascript-proxies-and-object-operations-4c1adc657757?source=collection_archive---------15-----------------------#2020-11-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b224de06637bdd2a3de32f2b2a37fea7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vvXhNSi2P36l8gXn"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@kmitchhodge?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">K. Mitch Hodge</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8b67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究使用JavaScript代理的元编程。</p><h1 id="f6a5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">包装内置构造函数的实例</h1><p id="2098" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用代理来包装内置构造函数的实例。</p><p id="2db0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c1a7" class="mn lc iq mj b gy mo mp l mq mr">const target = new Date();<br/>const handler = {};<br/>const proxy = new Proxy(target, handler);</span></pre><p id="e45a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是如果我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c616" class="mn lc iq mj b gy mo mp l mq mr">console.log(proxy.getDate());</span></pre><p id="a438" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到“未捕获的类型错误:这不是一个日期对象。”因为我们在代理上调用了<code class="fe ms mt mu mj b">getDate</code>，而不是原来的<code class="fe ms mt mu mj b">Date</code>实例。</p><p id="03bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，代理可以透明地用数组包装。</p><p id="d349" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2a71" class="mn lc iq mj b gy mo mp l mq mr">const p = new Proxy(new Array(), {});<br/>p.push('foo');<br/>console.log(p.length);</span></pre><p id="c7d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe ms mt mu mj b">Array</code>构造函数创建了一个代理。</p><p id="83cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">处理程序对象是一个空对象。</p><p id="a921" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe ms mt mu mj b">push</code> with向数组中插入一个条目。</p><p id="f9ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它与代理一起工作。</p><p id="4046" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而我们得到的<code class="fe ms mt mu mj b">length</code>跟我们预料的一样。</p><p id="129b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于不能用代理透明包装的对象，我们可以修改处理程序，让它做我们期望的事情。</p><p id="6b8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="80f5" class="mn lc iq mj b gy mo mp l mq mr">const handler = {<br/>  get(target, propKey, receiver) {<br/>    if (typeof target[propKey] === 'function') {<br/>      return target[propKey].bind(target);<br/>    }<br/>    return target[propKey]<br/>  },<br/>};</span><span id="9792" class="mn lc iq mj b gy mv mp l mq mr">const target = new Date();<br/>const proxy = new Proxy(target, handler);</span></pre><p id="7549" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe ms mt mu mj b">target</code>的<code class="fe ms mt mu mj b">propKey</code>方法。</p><p id="accb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe ms mt mu mj b">get</code>方法中，我们检查<code class="fe ms mt mu mj b">target[propKey]</code>的类型是否是<code class="fe ms mt mu mj b">'function'</code>。</p><p id="fe39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是，那么我们用<code class="fe ms mt mu mj b">bind</code>改变<code class="fe ms mt mu mj b">this</code>的值，这样函数将具有正确的值<code class="fe ms mt mu mj b">this</code>。</p><p id="9661" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们只是原样返回值。</p><p id="5ec2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们可以在对象上调用<code class="fe ms mt mu mj b">getDate</code>方法，没有问题:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d92e" class="mn lc iq mj b gy mo mp l mq mr">const handler = {<br/>  get(target, propKey, receiver) {<br/>    if (typeof target[propKey] === 'function') {<br/>      return target[propKey].bind(target);<br/>    }<br/>    return target[propKey]<br/>  },<br/>};</span><span id="5f5b" class="mn lc iq mj b gy mv mp l mq mr">const target = new Date();<br/>const proxy = new Proxy(target, handler);</span><span id="5d1d" class="mn lc iq mj b gy mv mp l mq mr">console.log(proxy.getDate());</span></pre><h1 id="62d3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">代理的用例</h1><p id="c6e2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用代理来记录对象的操作。</p><p id="d079" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2979" class="mn lc iq mj b gy mo mp l mq mr">const handler = {<br/>  get(target, propKey, receiver) {<br/>    console.log(target[propKey])<br/>    if (typeof target[propKey] === 'function') {<br/>      return target[propKey].bind(target);<br/>    }<br/>    return target[propKey]<br/>  },<br/>};</span><span id="4cda" class="mn lc iq mj b gy mv mp l mq mr">class Person {<br/>  constructor(firstName, lastName) {<br/>    this.firstName = firstName;<br/>    this.lastName = lastName;<br/>  }<br/>  toString() {<br/>    return `Person(${this.firstName}, ${this.lastName})`;<br/>  }<br/>}</span><span id="3d80" class="mn lc iq mj b gy mv mp l mq mr">const target = new Person('jane', 'smith');<br/>const proxy = new Proxy(target, handler);</span><span id="7e82" class="mn lc iq mj b gy mv mp l mq mr">console.log(proxy.toString());</span></pre><p id="1ff5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">跟踪对象操作。</p><p id="ff8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了<code class="fe ms mt mu mj b">toString</code>方法的结构。</p><p id="a870" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到返回的结果。</p><p id="7312" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用代理来警告未知的属性。</p><p id="cc91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b5db" class="mn lc iq mj b gy mo mp l mq mr">const target = {};<br/>const handler = {<br/>  get(target, propKey, receiver) {<br/>    if (!(propKey in target)) {<br/>      throw new Error('property does not exist');<br/>    }<br/>    return target[propKey];<br/>  }<br/>};</span><span id="851f" class="mn lc iq mj b gy mv mp l mq mr">const proxy = new Proxy(target, handler);<br/>console.log(proxy.foo);</span></pre><p id="b799" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有一个拥有<code class="fe ms mt mu mj b">get</code>方法的<code class="fe ms mt mu mj b">handler</code>对象。</p><p id="15f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在其中，我们使用<code class="fe ms mt mu mj b">in</code>操作符来检查是否有名为<code class="fe ms mt mu mj b">propKey</code>的属性。</p><p id="6765" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于在<code class="fe ms mt mu mj b">target</code>中没有<code class="fe ms mt mu mj b">foo</code>属性，我们得到‘未捕获的错误:属性不存在’。</p><p id="9f3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个方便的特性，JavaScript对象本身没有这个特性。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/e6edb5ac657528117750fbe8e7f39a88.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uux69FZK016JuxU5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@stephanieharvey?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Stephanie Harvey</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6df1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="4d09" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用代理以各种方式记录对象操作和拦截对象操作。</p><p id="7811" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>