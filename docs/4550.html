<html>
<head>
<title>The Final Guide On Promises and Asynchronous JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">关于承诺和异步JavaScript的最终指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-final-guide-on-promises-js-putting-together-the-building-blocks-one-by-one-9ec313b4b9ad?source=collection_archive---------11-----------------------#2020-12-20">https://javascript.plainenglish.io/the-final-guide-on-promises-js-putting-together-the-building-blocks-one-by-one-9ec313b4b9ad?source=collection_archive---------11-----------------------#2020-12-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e34e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">这是一个详细的指南，介绍如何编写带有回调、承诺、异步等待等功能的异步代码</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/892aaa7e75a86cea0643762ecffa1ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2HDSLgcS5HVDpkZXSN5SYg.jpeg"/></div></div></figure><p id="b838" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">许多承诺的文件缺少一些重要的细节。在这篇文章中，我们将尝试涵盖这些细节，并使逻辑完美无瑕。不要记住单个应用程序。学习幕后的逻辑。在此之后，你将能够完全掌握承诺的概念。</p><p id="a05e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">不要因为内容太多而感到不知所措。我花了很长时间才彻底理解这一切。慢慢来，一点一点消化。</p><p id="9f5d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以让我们开始吧。</p><h2 id="6ff8" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">一个问题</h2><p id="008b" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">假设我们有两个数字x和y，我们想在三秒钟后计算总和(这是一个不切实际的场景，但可以用于教育目的)并打印出来。</p><p id="ee73" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你可能想写这样的东西:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="40af" class="lk ll in mj b gy mn mo l mp mq">let x = 5;<br/>let y = 6;<br/>let result;</span><span id="2192" class="lk ll in mj b gy mr mo l mp mq">setTimeout( ()=&gt; {result = x+y; console.log(result)}, 3000)</span></pre><p id="075c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以用另一种方法解决。利用承诺。</p><p id="2a5e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">承诺对于异步编程非常有用。特别是对于承诺链，它解决了“回调地狱”问题(一个接一个地嵌套在前一个完成时按顺序执行的函数(任务)序列)。</p><p id="ccd3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们将从零开始深入了解什么是承诺，我们将通过一些练习来实践。</p><h1 id="1748" class="ms ll in bd lm mt mu mv lp mw mx my ls jt mz ju lv jw na jx ly jz nb ka mb nc bi translated">第一部分。承诺的基础</h1><h2 id="98e1" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">定义、语法、分解构件</h2><p id="b729" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">承诺是一个对象，它由<strong class="kq io">包装一个任务函数，并在其执行的整个过程中对其进行处理。</strong></p><p id="b31a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">基本语法:</strong></p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="f131" class="lk ll in mj b gy mn mo l mp mq">let examplePromise = new Promise( taskFunction );</span><span id="17aa" class="lk ll in mj b gy mr mo l mp mq">examplePromise.then(callbackSuccess, callbackFailure);</span></pre><p id="c88b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"><em class="nd">promise . then<br/></em></strong>promise一般<strong class="kq io">与“then”</strong>法连用(后面我们还会看到不与“then”连用的情况)。</p><p id="9807" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那么，什么是<strong class="kq io">“任务功能”、“回调成功”、“回调失败”</strong>？这些都是声明和履行承诺的重要因素。这些都是函数。他们必须遵守一些规范。更详细地一个接一个:</p><h2 id="7430" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">任务功能</h2><p id="7d0d" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated"><strong class="kq io"> taskFunction </strong>(从现在开始我们将一直称之为“任务函数”)是一个如下所示的函数:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="e9de" class="lk ll in mj b gy mn mo l mp mq">function taskFunction(resolve,reject) { <br/>     if ( condition ) {<br/>        resolve(result)<br/>     }  else  {<br/>        reject(new Error("error!"))<br/>     }<br/>}</span></pre><p id="4b48" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="nd">它接受两个参数作为输入。这两个函数</em> </strong>我们都没有定义。我们可以给他们一些名字。通常<strong class="kq io"> <em class="nd">化解</em></strong><em class="nd"/><strong class="kq io"><em class="nd">拒绝</em> </strong>(或<em class="nd">成功</em>和<em class="nd">失败</em>等)。这些是Promise中的内部内置函数，我们只能标记它们。</p><p id="11c7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">解决</strong>和<strong class="kq io">拒绝</strong>在履行承诺的<strong class="kq io">管道</strong>中起主要作用。它们将是在Promise的“then”方法中发送的结果的处理程序。现在不用担心，我们将在下一节看到这一点。<br/>现在只知道<strong class="kq io"> resolve和reject将我们想要转发的结果或错误放在它们的括号中</strong>(这种意义将在后面说明)。</p><p id="0932" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们得到了想要的结果，我们通过resolve发送它。如果我们得到一个错误，我们通过拒绝发送它。</p><p id="8723" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如:假设我们想获取一些数据。如果任务成功，我们将数据保存在<em class="nd"> result </em>变量中，并写入“<strong class="kq io"> resolve(result) </strong>”。通过<em class="nd">结果</em>变量引用的数据将被向前发送。如果取数据失败，我们将发送一个错误“<strong class="kq io"> reject(新错误(‘取数据失败’)</strong>”。(图片很快就清晰了)。</p><p id="33e8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">当taskFunction遇到resolve或reject时，它停止执行，</strong>忽略剩余的代码行。</p><p id="4234" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">补充说明:taskFunction不需要像上面的代码那样有条件结构。重要的是它向前发送了一些数据，所以你总会在taskFunction的声明中找到<strong class="kq io"> resolve(someResult) </strong>(或者reject(some)但是你不会在实际应用中只找到这个，只有在教育的例子中，下面我后面会用到一些)。通常你甚至找不到一个reject，要么是因为任务不能失败(对两个我们已经知道的数字求和，例如:不可能发生错误)，要么是因为即使没有reject函数，错误也可以被传递，而只是将它扔进任务函数的主体中(现在不重要:如果你不理解这句话，不要担心，我们稍后会看到)。</p><h2 id="d2e8" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak">回调成功</strong></h2><p id="d981" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">处理任务函数“callbackSuccess”的成功(或解析/解决)的函数将管理将被传递的结果(请等待下一节以了解整体情况)。因此，在定义它时，它可以有一个参数，该参数将假定从承诺传递的结果的值。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="72f3" class="lk ll in mj b gy mn mo l mp mq">function callbackSuccess(result) {<br/>   // some operations to be made on "result"<br/>}</span></pre><p id="50f7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> callbackSuccess的输入参数引用了resolve传递下来的内容(或者，换句话说，它包装在括号内的内容)。<br/> </strong>简而言之:假设taskFunction以一个resolve结束:比如说在encounters中，在代码中，“resolve(3)”。该函数结束执行，并向前发送值“3”。在这种情况下，callbackSuccess会将值3: result = 3赋给参数result。</p><h2 id="bc5b" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak">回调失败</strong></h2><p id="2fa7" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">这类似于回调成功。只是输入的参数将引用<em class="nd">拒绝</em>传递的内容:一个错误。(注意:我们只在出错的情况下使用callbackFailure。它可以传递其他值，但在实际应用中没有用处)。</p><p id="cbd3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，我们已经分别讨论了每个组件(如果还不明白，不要担心，一些部分将在下一节中链接)，我们可以看到它们是如何一起工作的。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><h2 id="7a82" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">基本用法:执行承诺的管道。</h2><p id="7455" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我们已经看到了承诺的基本定义和用法:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="deb6" class="lk ll in mj b gy mn mo l mp mq">let examplePromise = new Promise( taskFunction );</span><span id="18a6" class="lk ll in mj b gy mr mo l mp mq">examplePromise.then(callbackSuccess, callbackFailure);</span></pre><p id="254a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">以及如何定义流程中涉及的功能。<br/>现在让我们关注一下执行代码:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="19b9" class="lk ll in mj b gy mn mo l mp mq">examplePromise.then(callbackSuccess, callbackFailure);</span></pre><p id="c7ab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这段代码将为承诺打开一个执行管道。(这只是我的术语，你可能在别处找不到)。</p><p id="2c4f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里有<strong class="kq io">以下事情依次发生:</strong></p><ol class=""><li id="44bf" class="nl nm in kq b kr ks ku kv kx nn lb no lf np lj nq nr ns nt bi translated">示例Promise将执行正在包装的taskFunction。</li><li id="8e6d" class="nl nm in kq b kr nu ku nv kx nw lb nx lf ny lj nq nr ns nt bi translated">taskFunction，在某个时刻执行结束时，当第一次遇到一个关键函数resolve或reject时发生，或者在reject之外抛出一些错误(我们提醒它关闭taskFunction的执行)。<br/>此时，结果通过resolve(或错误通过reject)传递。这将作为输入参数发送给callbackSuccess(分别为callbackError)。</li><li id="cde5" class="nl nm in kq b kr nu ku nv kx nw lb nx lf ny lj nq nr ns nt bi translated">只有在这一点上，callbackSuccess才会被执行(在resolve的情况下。在拒绝回调失败的情况下)，将通过resolve传递的值作为输入参数(在拒绝的情况下，输入将是通过reject传递的错误)。请注意，在callbackSuccess和callbackFailure之间只会执行一个。从不打扰。此外，还要注意“回调处理程序”的执行(我们用这个术语表示成功时的callbackSuccess或失败时的callbackFailure)只有在taskFunction完成执行后才开始。</li></ol><h2 id="e219" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">示例/练习</h2><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="69e6" class="lk ll in mj b gy mn mo l mp mq">let examplePromise = new Promise( (res,rej) =&gt; { <br/>      setTimeout( ()=&gt; res(3), 3000)<br/>})</span><span id="c7be" class="lk ll in mj b gy mr mo l mp mq">examplePromise.then( (result) =&gt; {console.log(result)} )</span></pre><p id="964a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是一个简化的例子，我们不使用callbackFailure，因为任务肯定会成功(我们可以省略callbackFailure的声明)。</p><p id="017e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请注意，我们立即编写了taskFunction作为Promise构造函数的参数。我们可以在外面定义。我一般都是发现里面定义的。</p><p id="e565" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将在三秒钟后在控制台中打印出值3。在前三行中，我们定义了承诺和任务函数。</p><p id="6860" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后在最后一行，我们开始承诺的执行管道。</p><p id="5425" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">1.首先它被执行<code class="fe nz oa ob mj b">taskfunction</code>。<br/> 2。callbackSuccess将等待taskFunction完成。也就是三秒钟之内。那么resolve将向下传递值3。因此，结果将采用值3: <code class="fe nz oa ob mj b">result=3</code>。<br/> 3。最后<code class="fe nz oa ob mj b">callbackSuccess</code>被处决。<code class="fe nz oa ob mj b">callbackSuccess</code>是功能:<code class="fe nz oa ob mj b">(result) =&gt; {console.log(result)}</code></p><h2 id="1ac2" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">解决最初的问题。第一次天真的尝试。</h2><p id="d0e0" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">现在，看了这个例子，我们准备用promises解决上面讨论的初始问题(3秒钟后对x和y求和)。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="52c2" class="lk ll in mj b gy mn mo l mp mq">let x = 5;<br/>let y = 6;</span><span id="56c4" class="lk ll in mj b gy mr mo l mp mq">let sumAfterAWhile = new Promise( (res, rej) =&gt; {<br/>   setTimeout( ()=&gt;{res(x+y)}, 3000 )<br/>})</span><span id="39e9" class="lk ll in mj b gy mr mo l mp mq">sumAfterAWhile.then((result) =&gt; {console.log(result)})</span></pre><p id="43ce" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">3秒钟后，taskFunction将通过resolve函数(在上面的代码中缩写为<em class="nd"> res </em>)发送x和y之和x+y作为结果。</p><p id="74da" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们可以写得更好:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="e576" class="lk ll in mj b gy mn mo l mp mq">sumAfterAWhile.then((result) =&gt; {console.log(result)})</span><span id="22ae" class="lk ll in mj b gy mr mo l mp mq">// We can write it as:</span><span id="cef3" class="lk ll in mj b gy mr mo l mp mq">sumAfterAWhile.then(console.log) </span></pre><p id="75ec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为什么？因为console.log已经是一个把一个东西作为输入的函数对象了。</p><p id="ae06" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">备注:如上所述，<em class="nd"> then方法不需要callbackFailure函数</em>。在这种情况下，默认情况下设置为null。</p><p id="1c72" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还有一个问题。我们不在任何地方存储结果。随着教程的深入，我们将对代码进行改进，并获得处理这种情况的工具。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><h1 id="c093" class="ms ll in bd lm mt oc mv lp mw od my ls jt oe ju lv jw of jx ly jz og ka mb nc bi translated">第二部分。承诺连锁前的一些重要事实</h1><h2 id="07f5" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">Promise的执行管道不会中断主代码</h2><p id="76a1" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">假设我们有以下情况:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="1cc8" class="lk ll in mj b gy mn mo l mp mq">let waitAWhile = new Promise((res,rej) =&gt; {<br/>   setTimeout( ()=&gt;{res(5)}; 3000)<br/>})</span><span id="ac17" class="lk ll in mj b gy mr mo l mp mq">waitAWhile.then( (result) =&gt; {console.log(result)} )</span><span id="7756" class="lk ll in mj b gy mr mo l mp mq">console.log(7)</span></pre><p id="bc97" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">代码是逐行读取的。当承诺的执行得到满足时，执行就开始了。但是这是否阻塞了主执行呢？不会。它会打开一个新线程，在那里执行承诺，而主线程会继续逐行读取和执行代码。换句话说，在这种情况下，它将立即打印7，三秒钟后打印5。</p><p id="561e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它不会执行以下操作:执行承诺，等待3秒钟。打印5，打印5后，打印7。</p><p id="b3a9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们继续说<strong class="kq io">承诺执行是异步的。<br/>当遇到一些可能需要一些时间的异步操作时，比如promise执行(promise后跟then方法)，主线会打开一个新的分支，操作将在那里执行。与此同时，主线不会中断。</strong></p><h2 id="b2f2" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">承诺状态:已解决和已拒绝(以及待定)。并承诺价值(有人称之为结果)。</h2><p id="140d" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">我们说过承诺可以被解决或拒绝。这取决于承诺正在包装的taskFunction的结果。</p><p id="43e3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">尝试在浏览器的控制台中编写以下内容:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="aa1e" class="lk ll in mj b gy mn mo l mp mq">let examplePromise = new Promise((res,rej) =&gt; {<br/>    res(3)<br/>})</span><span id="90c6" class="lk ll in mj b gy mr mo l mp mq">examplePromise // same as console.log(examplePromise)</span></pre><p id="f1c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这会给你打印<code class="fe nz oa ob mj b">Promise {&lt;resolved&gt;: 3}</code>。</p><p id="d019" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">括号&lt;&gt;内的参数是状态。返回值是3。</p><p id="0c06" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">以下，</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="a65d" class="lk ll in mj b gy mn mo l mp mq">let examplePromise = new Promise((res,rej) =&gt; {<br/>    rej(new Error("issue!!!"))<br/>})</span><span id="1bc9" class="lk ll in mj b gy mr mo l mp mq">examplePromise // same as console.log(examplePromise)</span></pre><p id="e73f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">将产生结果<code class="fe nz oa ob mj b">Promise {&lt;rejected&gt;: Error : issue!!! …}</code>。因此状态被拒绝。并且该值是错误的。</p><p id="c267" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">还有待定状态，例如:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="1d7b" class="lk ll in mj b gy mn mo l mp mq">let examplePromise = new Promise((res, rej) =&gt; {<br/>    setTimeout(() =&gt; { res(3) }, 3000)<br/>})</span><span id="4e6f" class="lk ll in mj b gy mr mo l mp mq">examplePromise</span></pre><p id="0021" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将产生一个没有值的挂起状态(或者，确切地说，具有未定义的值)。待定状态只是暂时的。挂起状态意味着正在等待taskFunction完成其执行。然后，它将达到最终状态:已解决或已拒绝。</p><p id="7de6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">它们为什么重要？嗯，尤其是在处理承诺的时候，你会关心它们的状态以及它们在接下来的执行中的价值。<br/><strong class="kq io"><em class="nd">状态</em>决定执行哪个回调</strong>(如果已解决，则执行成功回调，如果已拒绝，则执行失败回调，如果未决，则不执行任何操作，直到状态变为已解决或已拒绝)。</p><p id="5754" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"><em class="nd">值/结果</em>决定将什么作为输入参数传递给callbackHandler。</strong></p><h2 id="1915" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak">常见错误:我们无法保存带有引用承诺的变量的解析结果。</strong></h2><p id="db15" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">假设我们想保存一段时间后承诺返回的结果。例如，下面的承诺在3秒钟后解析为值“hi”。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="83e9" class="lk ll in mj b gy mn mo l mp mq">let examplePromise = new Promise((res,rej) =&gt; {<br/>    setTimeout( ()=&gt; {res("hi")}, 3000) <br/>})</span></pre><p id="3eb3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您想保存值“hi ”,您可能会尝试执行以下操作:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="e5b7" class="lk ll in mj b gy mn mo l mp mq">result = examplePromise</span></pre><p id="3c10" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这样不行。结果将是状态为待定且值未定义的承诺。</p><p id="98b0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过resolve函数包装的值将只发送给“then”方法中的callbackHandlers。这是我们继续处理这些值的唯一方法(async/await将解决这个问题。见下文):他们在承诺中出生，在执行过程中死亡。承诺的执行分支随着它的局部变量而诞生和消亡。</p><p id="4251" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">解决这个问题的一种方法是采用以下方法:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="8acf" class="lk ll in mj b gy mn mo l mp mq">let finalResult;</span><span id="a071" class="lk ll in mj b gy mr mo l mp mq">examplePromise.then( (result) =&gt; { result = finalResult} )</span></pre><p id="7a86" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在将存储结果的变量外部初始化。然后让callbackSuccess函数处理结果:它将附加到finalResult之外的变量，结果只存在于Promise.then的执行管道中。</p><p id="f122" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这并不是很酷，因为我们希望尽可能减少外部定义的变量数量。Async/await将帮助我们解决这个问题。</p><p id="86f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">看到这里，我们可以尝试改善最初的问题。我们可以再做一次尝试</p><h2 id="bf40" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">改进初始问题的解决。第二次天真的尝试。</h2><p id="9685" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">留给我们一个改进的问题:我们如何存储x+y的和？正如最后一段所示，这不是一个无关紧要的问题。我们将引入一个外部变量来存储结果。Promise.then的回调成功将处理引用。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="fea7" class="lk ll in mj b gy mn mo l mp mq">let x = 5;<br/>let y = 6;<br/>let sum;    // Improvement here</span><span id="bdb9" class="lk ll in mj b gy mr mo l mp mq">let sumAfterAWhile = new Promise( (res, rej) =&gt; {<br/>   setTimeout( ()=&gt;{res(x+y)}, 3000 )<br/>})</span><span id="f7dd" class="lk ll in mj b gy mr mo l mp mq">function callbackSuccess(result) {<br/>     sum = result;    // referencing here<br/>     console.log(result)<br/>}</span><span id="871c" class="lk ll in mj b gy mr mo l mp mq">sumAfterAWhile.then(callbackSuccess) // Execution here<br/></span></pre><p id="c7f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在让我们暂时搁置这个问题。我们用承诺链来结束承诺的话题。在谈到async/await之后(在链接承诺之后)，我们将对这个问题进行最后的改进。对这个问题的改进不会使用任何承诺链，所以如果你不耐烦看到这个问题的结束，你可以跳到async/await。但是不要避免承诺链，因为这是一个非常重要的话题，如果你想建立网站，你必须知道。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><h1 id="1c79" class="ms ll in bd lm mt oc mv lp mw od my ls jt oe ju lv jw of jx ly jz og ka mb nc bi translated">第三部分。承诺链</h1><p id="e120" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">为了结束承诺部分，让我们深入到承诺链中。阅读这篇文章会让你更好地理解<strong class="kq io">为什么你应该使用承诺而不是回电</strong>。</p><h2 id="7906" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">链接简介</h2><p id="dce2" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated"><strong class="kq io">动机:</strong>在现实场景中，我们可能想要获取一些数据。这可能需要一些时间。数据取出后，我们想进行其他操作，如提取数据中的某些特定信息，对其进行操作等...</p><p id="4f96" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这最好在打开的Promise管道内完成，因为，正如我们在上面看到的，当执行管道关闭时，我们会丢失管道内的所有内部变量。除非使用一些外部变量。即使在这种情况下，我们也无法在主代码中确切地知道数据何时被提取，那么涉及数据的操作如何在管道之外继续呢？</p><p id="d72e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">于是，解决方案似乎很自然地是保持承诺执行管道的畅通，并在执行的这条线索中一个接一个地进行操作。</strong>所以我们有了承诺链的概念。作为示例代码的直观概念:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="91e0" class="lk ll in mj b gy mn mo l mp mq"><br/>Promise.then(handlers1).then(handlers2)</span></pre><p id="cd62" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">更容易记住的是<strong class="kq io"> Promise.then.then </strong>(最终更多then)。</p><p id="65ed" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">一个简单的例子:</strong>(不是现实场景，仅用于学习目的)。<strong class="kq io"> <br/> </strong>假设我们要等待3秒钟，然后对两个数字x和y求和。再过3秒钟，我们要将结果乘以10并打印出来。<br/>代码将是(如果您现在不理解，请不要担心。到这一部分结束时，一切都会很清楚):</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="f04d" class="lk ll in mj b gy mn mo l mp mq">let x = 1;<br/>let y = 2;</span><span id="fb46" class="lk ll in mj b gy mr mo l mp mq">let firstTask = new Promise((res, rej) =&gt; {<br/>    setTimeout(() =&gt; {res(x+y)}, 3000) //wait 3s and then resolve<br/>})</span><span id="712d" class="lk ll in mj b gy mr mo l mp mq">function secondTask(result) {<br/>    return new Promise((res, rej) =&gt; {<br/>        setTimeout(() =&gt; {res(10*result)}, 3000)// w. 3s &amp; resolve.<br/>    })<br/>}</span><span id="9762" class="lk ll in mj b gy mr mo l mp mq">firstTask.then(secondTask).then(console.log)</span></pre><p id="6a3d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这将在6秒后打印30 (= 3*10)。我们连锁了两次行动。在解释完概念后，我们将分析代码。</p><p id="518c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Promises chaining的主要思想是Promise(taskFunction)将执行taskFunction，直到它被解决(或拒绝)。</p><p id="66da" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一个随后的“<em class="nd">然后“</em>”，使用回调处理程序(即回调成功和回调失败，如果指定的话)将处理结果。</p><p id="cf5a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">随后，第二个随后的“<em class="nd">then”</em>将接收来自前一个then的内容，并使用其callbackSuccess函数处理它(最终也是一个callbackFailure)。诸如此类。<strong class="kq io">理解下面的<em class="nd">【然后】</em>如何收到结果</strong>是这一部分的主要目的。</p><h2 id="0960" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">承诺，那就是承诺</h2><p id="3b4b" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">第一个重要事实。当我们有一个Promise对象，并对其应用“then”方法时，不仅taskFunction和callbackHandlers会被执行。<strong class="kq io">Promise . then返回另一个Promise对象。如果你不相信，你可以在你的游戏机上测试一下:</strong></p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="8a72" class="lk ll in mj b gy mn mo l mp mq">let examplePromise = new Promise((res, rej) =&gt; {<br/>      res(2)<br/>})</span><span id="0be8" class="lk ll in mj b gy mr mo l mp mq">console.log(examplePromise.then((result) =&gt; { return result+2 }))<br/>// still a Promise!</span></pre><p id="0e58" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">但是，这应该是合理的:t <strong class="kq io"> he then方法毕竟是一种适用于允诺对象的方法</strong>。因此，如果我们想继续应用other then，拥有类似于Promise.then.then的东西，那么Promise.then应该返回一个承诺(或将其视为承诺本身)，这确实是有意义的。</p><p id="0685" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">从现在开始，我们可以把承诺对象“<strong class="kq io">Promise . then”</strong>称为“<strong class="kq io"> then-Promise </strong>”。这将有助于我们区分主要的原始承诺，我们将称之为<strong class="kq io">“主要承诺”。所以在上面的例子中，examplePromise是我们的主承诺，而examplePromise.then(...)是我们当时的承诺。</strong></p><p id="9974" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nd">为了理解链条是如何运作的，把我们得到的理解为</em> <strong class="kq io"> <em class="nd">那么——承诺(解决了吗？被拒绝了吗？用哪些价值观？)</em> </strong> <em class="nd">，来自main-Promise和handlers函数(callbackSuccess，callbackFailure)。</em></p><p id="d674" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当我们弄清楚当时承诺的状态(已解决、已拒绝、待定)和价值时，我们就弄清楚了当时承诺的一切。那么让我们看看如何推导它们。</p><p id="11d6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了弄清楚<strong class="kq io">那么承诺</strong>是什么，我们需要了解3种不同的一般情况。</p><h2 id="834b" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">第一种情况</h2><p id="c4a8" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated"><em class="nd">callbackHandler返回任何非承诺的内容(callback handler中不会出现任何错误，无论是callbackSuccess还是callbackFailure)。随后,“then-Promise”的状态将为SOLVED，值为callbackHandler返回的值。</em></p><p id="75b1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nd">术语小议</em>:</p><p id="c3b9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nd">如果你一直对我使用的</em><strong class="kq io"><em class="nd">callback handler</em></strong><em class="nd">这个词感到困惑。对于callbackHandler，如果主承诺成功，我引用callbackSuccess，在这种情况下，将执行callbackSuccess。如果主承诺被拒绝，我称之为callbackFailure，在这种情况下，将执行callbackFailure。他们中只有一个会被处决。</em></p><p id="439a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们假设主承诺解决了任务函数。由于成功，回调成功将被执行。callbackSuccess，如果返回任何不是承诺的内容(并且没有引发任何错误),那么then-Promise将被解析(状态为resolved ),其值正好是返回值(如果callbackSuccess函数没有返回任何内容)。则它是未定义的值)。</p><p id="3462" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">即使主承诺被拒绝(状态被拒绝)并且将要被调用的回调失败没有引发/抛出任何错误，这种行为也是正确的。</p><p id="714d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这种情况下，如果callbackFailure没有抛出任何错误/异常，并且状态总是已解决，则该值将是callback failure返回的值。</p><p id="9f88" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">示例1:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="60a5" class="lk ll in mj b gy mn mo l mp mq">let examplePromise = new Promise((res, rej) =&gt; {<br/>      res(2)<br/>})</span><span id="e4cc" class="lk ll in mj b gy mr mo l mp mq">examplePromise.then(console.log) // the then-Promise</span></pre><p id="1223" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">“then-Promise”是一个<em class="nd">已解决的</em>承诺，值为<em class="nd">未定义的</em>，因为callbackSuccess(在本例中是console.log函数)不返回任何内容。</p><p id="d8a8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">示例2:使用回调失败</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="8d07" class="lk ll in mj b gy mn mo l mp mq">let examplePromise = new Promise((res, rej) =&gt; {<br/>      rej(2)<br/>})</span><span id="47be" class="lk ll in mj b gy mr mo l mp mq">examplePromise.then(console.log, console.log) // the then-Promise</span></pre><p id="1984" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">注意，callbackSuccess和callbackFailure都是console.log函数。</p><p id="e57b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">首先，这种情况下，主-诺会被拒绝！(任务函数代码中的rej(2))。因此将执行回调失败。但是console.log不会引发任何错误。所以…我们在这种情况下。</p><p id="c90d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">那时的承诺会是什么？</p><p id="a56f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">then-Promise是值未定义的已解决的承诺。<br/>已解决，因为无论执行什么(无论是成功还是失败的回调)，如果回调中没有出现错误，callbackHandler函数的返回值(如果有的话)将确定then-Promise的状态。</p><p id="bd32" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">未定义，因为console.log函数不返回任何内容。</p><p id="de02" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nd">小提示:</em>对于那些想知道我们为什么设置reject一个不是错误的值(2)的人来说，通常不是这样。在实际应用中，你总是拒绝错误。</p><h2 id="256e" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">第二种情况</h2><p id="e95d" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated"><em class="nd">如果callbackHandler(无论是成功还是失败的回调)在执行过程中抛出一个错误，“then-Promise”将被拒绝，并给出错误的值。</em></p><p id="4ae9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">示例:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="2e6f" class="lk ll in mj b gy mn mo l mp mq">let examplePromise = new Promise((res, rej) =&gt; {<br/>      res(2)<br/>})</span><span id="bf3a" class="lk ll in mj b gy mr mo l mp mq">function successCallback(result) {<br/>   throw new Error('throwing an error!')<br/>}</span><span id="2108" class="lk ll in mj b gy mr mo l mp mq">examplePromise.then(successCallback) // the then-Promise</span></pre><p id="0ad7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">主承诺的解析值为2。因此将执行successCallback(我们甚至没有定义failureCallback)。我们可以看到successCallback函数引发了一个错误(对于那些不知道的人，语法“抛出新错误(..)”会引发错误。这是你需要知道的全部)。注意:我们在successCallback中抛出了错误！我们可以随时随地抛出错误。如果我们在failureCallback中抛出错误，情况也是如此。</p><p id="b4ff" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这种情况下，当时的承诺将是一个被拒绝的承诺，并重视提出的错误。(状态:已拒绝；值:抛出的错误)。</p><p id="8905" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">即使taskFunction以拒绝结束，调用failureCallback，并且failureCallback抛出错误，也会出现相同的输出。</p><p id="7343" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">小提示:稍后会有更多关于错误的细节。它们其实并不重要。现在专注于逻辑，不要迷失在细节中。下面我也会讨论一些次要的事情，比如:吸收错误，捕捉等等… </p><h2 id="df1a" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">第三种情况:callbackHandler返回一个承诺(并且没有产生错误)。在这种情况下，当时的承诺将完全是返回的承诺。</h2><p id="4616" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">这个例子正是我们在本部分开始时展示的例子。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="966a" class="lk ll in mj b gy mn mo l mp mq">let x = 1;<br/>let y = 2;</span><span id="0cd1" class="lk ll in mj b gy mr mo l mp mq">let mainPromise = new Promise((res, rej) =&gt; {<br/>    setTimeout(() =&gt; {res(x+y)}, 3000) //wait 3s and then resolve<br/>})</span><span id="df8a" class="lk ll in mj b gy mr mo l mp mq">function secondTask(result) {<br/>    return new Promise((res, rej) =&gt; {<br/>        setTimeout(() =&gt; {res(10*result)}, 3000)// w. 3s &amp; resolve.<br/>    })<br/>}</span><span id="90b9" class="lk ll in mj b gy mr mo l mp mq">mainPromise.then(secondTask).then(console.log)</span></pre><p id="2f74" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们从回答几个问题开始:作为练习，你应该先回答。然后读解。</p><p id="178a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">【Q1】</strong>then-Promise，本例中是承诺对象“mainPromise.then(secondTask)”，是解决还是拒绝？<br/><strong class="kq io">【Q2】</strong>用哪个值？<br/><strong class="kq io">【Q3)</strong>当时的承诺是立即解决/拒绝，还是先待定？</p><p id="1016" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">答案:</strong></p><p id="85c6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当时的承诺是一个承诺。具体来说，我们在第三种情况下:successCallback(也可能是failureCallback)，在本例中是secondTask函数，返回一个承诺。因此，当时的承诺将完全是承诺返回。这将是一个值为30的已解决承诺(几秒钟后)。</p><p id="c9fc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当时的承诺在三秒钟后被实例化。这是因为主承诺仍未解决。只有在值为3的情况下，3秒后才会解决。</p><p id="3a0c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一旦then-Promise被初始化，在3秒钟内，该承诺将处于未决状态。在这3秒钟后，它将被求解，值为30。<br/>最后，第二个也是最后一个“然后”(。然后(console.log))，将值30作为输入发送给callbackSuccess函数，在本例中是console.log。</p><h2 id="bfb0" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">回到连锁经营的大背景:</h2><p id="f537" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated"><strong class="kq io">问题化简:代替main-Promise.then，</strong> <em class="nd">我们化简为:</em> <strong class="kq io"> then-Promise.then，</strong>为<em class="nd">“then-Promise = main-Promise . then”</em>。我们完全知道如何只处理一个？</p><p id="2432" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，如果我们有主承诺和4，然后，我们可以一个接一个地减少它。首先，理解什么是“当时的承诺”。所以一旦想通了，我们就会有一个“然后承诺”和3个然后。然后我们可以继续重复同样的逻辑。</p><p id="bf6d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">链接部分到此结束。</p><p id="f5ac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">一旦你有了更多的“然后”，你就知道如何一个接一个地减少，通过一次又一次地弄清楚“然后的承诺”。因此，链接过程变成了一个循环过程，你只需要知道一个过程，这就简化了开始时看到的承诺基础。</p><p id="ea3e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你应该锻炼。试着想象一些包含要执行的任务过程的练习。试着算出你需要多少，以及如何将问题分解成单个的任务。</p><p id="c6a7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这些题目并不容易，强烈建议通过练习来掌握它们。</p><p id="db65" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果你愿意，我可以在最后列一份练习清单。</p><h2 id="134a" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">包扎</h2><p id="330a" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">因此，一些承诺链接的管道是根据单个承诺过程进行回收的。管道将在最后一次<em class="nd">然后</em>的最后一次回调后结束。<br/> <strong class="kq io"> <em class="nd">破除承诺链:知道如何计算出当时承诺的地位和价值。</em> </strong></p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><h1 id="4a2f" class="ms ll in bd lm mt oc mv lp mw od my ls jt oe ju lv jw of jx ly jz og ka mb nc bi translated">第四部分。异步/等待前的一些观察和评论。(这并不那么重要，但只是为了完整起见。)</h1><p id="f33f" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">在此，我们提出一些上面没有讨论过的小观察结果。这些只是一些最后的装饰，如果你没有消化以前的概念，我不建议你去看。</p><h2 id="7bea" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">我们可以抛出一个错误，而不是通过拒绝发送错误</h2><p id="5998" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">即本承诺:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="1dad" class="lk ll in mj b gy mn mo l mp mq">let throwing = new Promise((res, rej)=&gt; {<br/>     throw new Error('issue!')<br/>})</span></pre><p id="a475" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个承诺:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="e7f6" class="lk ll in mj b gy mn mo l mp mq">let rejecting = new Promise((res,rej) =&gt; {<br/>     rej(new Error('issue!'))<br/>})</span></pre><p id="0875" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">完全一样的承诺。两者都具有相同的被拒绝状态和相同的错误值。</p><p id="26d1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这意味着，如果我们用一些处理程序附加“然后”方法，两者的行为将完全相同:回调失败将被执行，相同的错误被发送下去。</p><p id="ea6d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以抛出错误或拒绝错误是可以互换的。<br/>有些人只喜欢抛出错误，从不使用拒绝功能。</p><h2 id="8709" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">抛出错误不同于返回错误</h2><p id="e473" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">这适用于承诺链。假设我们有一个承诺，然后，然后，假设第一个承诺，有了回调处理程序，将“返回(新的错误(‘问题！’)) )".当时的承诺不会被视为被拒绝！以下内容不会使“当时的承诺”成为被拒绝的承诺。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="d157" class="lk ll in mj b gy mn mo l mp mq">callbackHandler(input) {<br/>     //.... some code...<br/>     //<br/>    return new Error('issue!')<br/>}</span></pre><p id="8883" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们必须抛出错误！</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="121d" class="lk ll in mj b gy mn mo l mp mq">callbackHandler(input) {<br/>     //.... some code...<br/>     // if failed: </span><span id="b348" class="lk ll in mj b gy mr mo l mp mq">     throw new Error('type of error...')<br/><br/>     // eventually other code<br/>}</span></pre><h2 id="9695" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">链中的捕捉和吸收错误。</h2><p id="3a76" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">您可能听说过承诺的捕获方法。它只接受一个函数作为输入:在被拒绝的情况下的回调失败。</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="1e93" class="lk ll in mj b gy mn mo l mp mq">catch(callbackFailure) {...}</span></pre><p id="13fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nd"> catch(f) </em>法等同于<em class="nd"> then(null，f) </em>法。</p><p id="cb2b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通常情况下，常见的做法是:通常只对callbackSuccess使用<em class="nd"> then </em>方法，省略callbackFailure。为了管理错误/拒绝，我们使用了catch。例如，我们可以有一个以下类型的链:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="40b3" class="lk ll in mj b gy mn mo l mp mq">Promise.then(cS1).then(cS2).catch(cF1).then(cS3).catch(cF2)<br/></span></pre><p id="cd8b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">其中cS代表回呼成功，cF代表回呼失败。</p><p id="ffde" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nd">当错误通过回调失败被“捕获”时，它从承诺链接的执行管道中消失。</em>此外，如果发生错误，它会被向下发送，直到满足捕获条件(如果有)并处理该错误。</p><p id="68a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的示例中，如果cS1中发生错误，则。那么(cS2)“不会处理这个问题，会将其发送给”。catch(cF1)"，即吸收错误。</p><p id="49ab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">总是在链的末端放一个钩是一个好的习惯。</strong></p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="dae4" class="lk ll in mj b gy mn mo l mp mq">Promise.then(cS1).then(cS2)</span></pre><p id="be00" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这条链子不会处理任何错误。如果承诺中发生错误，随后该错误将被发送至“当时承诺”和“当时承诺”，因为它从未被处理过。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><h1 id="7ae8" class="ms ll in bd lm mt oc mv lp mw od my ls jt oe ju lv jw of jx ly jz og ka mb nc bi translated">第五部分。异步/等待</h1><p id="6059" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">以前，我们预计在执行承诺链的管道中处理的数据在那里只是生与死，不能直接引用它。</p><p id="4310" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Async/Await解决了这个问题。</p><h2 id="a328" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated">句法</h2><p id="3a0d" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">Async放在函数声明之前:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="ec2b" class="lk ll in mj b gy mn mo l mp mq">async function saveResult(input) {</span><span id="6f4e" class="lk ll in mj b gy mr mo l mp mq">    let waitPromise = new Promise((res, rej) =&gt; {<br/>         setTimeout(() =&gt; resolve(input), 5000)<br/>    });</span><span id="c661" class="lk ll in mj b gy mr mo l mp mq">    let result = await waitPromise; </span><span id="2073" class="lk ll in mj b gy mr mo l mp mq">    console.log(result);<br/>}</span><span id="bf59" class="lk ll in mj b gy mr mo l mp mq">saveResult('hi') // Will print hi after 5 seconds.</span></pre><p id="b0fb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Await用在带有异步声明的函数中，放在承诺之前。</p><p id="96ec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Await允许停止函数的执行，直到承诺被解决或拒绝。这意味着await下面的任何其他行(我指的是async函数中的内部代码)都不会被读取，直到Promise被求解，此时resolution的值将被返回(这不会停止函数的执行)并存储在result变量中。</p><p id="f8ee" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在上面的例子中，变量<em class="nd">结果</em>将是解析的值，只有在承诺已经解析之后。这样一来:</p><p id="b7e4" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">我们正在捕捉“承诺”管道的最终数据。<br/> </strong>终于注意到我们不需要那么一个许诺的方法。我们可以有一连串的承诺(正如我们所看到的，这是一个“然后-然后-…-承诺”)。在这种情况下，await返回这个长管道的最终值。</p><p id="090a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，<strong class="kq io">用async声明的函数相对于外部代码是异步的。</strong></p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="2679" class="lk ll in mj b gy mn mo l mp mq">saveResult('hi')</span><span id="1521" class="lk ll in mj b gy mr mo l mp mq">console.log(2)</span></pre><p id="e229" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一行正在执行并打开一个新线程(上面定义的异步函数)。主线程不会停止:紧接其后的一行被读取。</p><p id="f38a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所以值2会立即打印出来。5秒钟后，输出值“hi ”,因为异步函数“saveResult”的执行发生在另一个执行分支中。</p><h2 id="2780" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv lb lw lx ly lf lz ma mb mc bi translated"><strong class="ak">最后让我们改进我们最初的问题</strong></h2><p id="2462" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">现在我们已经看到了async/await，代码可以改进:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="811b" class="lk ll in mj b gy mn mo l mp mq">let x = 5;<br/>let y = 6;</span><span id="2cdd" class="lk ll in mj b gy mr mo l mp mq">let sumAfterAWhile = new Promise( (res, rej) =&gt; {<br/>   setTimeout( ()=&gt;{res(x+y)}, 3000 )<br/>})</span><span id="e39f" class="lk ll in mj b gy mr mo l mp mq">async function success() {<br/>     let sum = await sumAfterAWhile;  <br/>     console.log(sum);<br/>     return sum<br/>}</span><span id="78fa" class="lk ll in mj b gy mr mo l mp mq">success() // prints and returns the sum after 3 seconds.</span></pre><p id="cc81" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">其他改进:</strong></p><p id="a798" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，我们可能希望将x和y作为自由参数。我们可以将x和y作为异步函数的参数，并嵌套承诺:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="c470" class="lk ll in mj b gy mn mo l mp mq">async function success(x,y) {</span><span id="a031" class="lk ll in mj b gy mr mo l mp mq">     let sumAfterAWhile = new Promise( (res, rej) =&gt; {<br/>         setTimeout( ()=&gt;{res(x+y)}, 3000 )<br/>     })     </span><span id="1923" class="lk ll in mj b gy mr mo l mp mq">     let sum = await sumAfterAWhile;  </span><span id="ff8d" class="lk ll in mj b gy mr mo l mp mq">     console.log(sum);<br/>     return sum<br/>}</span></pre><p id="5282" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io">最后一点提示:</strong>如果不使用async/await，我们可以使用常见的技术— <strong class="kq io">在函数中包装承诺。</strong>我们可以用“special function . then”代替“Promise.then”，其中special function是一个返回承诺的函数。因此，如果我们想将x和y设置为特定函数的输入参数，我们会得到这样的结果:</p><pre class="kd ke kf kg gt mi mj mk ml aw mm bi"><span id="d6ea" class="lk ll in mj b gy mn mo l mp mq">function particolarFunction(x,y) {<br/>     return new Promise((res,rej) =&gt; {<br/>           setTimeout( ()=&gt;{res(x+y)}; 3000) <br/>     })<br/>}</span><span id="9f4b" class="lk ll in mj b gy mr mo l mp mq">particularFunction(5,6).then(console.log) </span><span id="f077" class="lk ll in mj b gy mr mo l mp mq">// IF we named the particularFunction as sumAfterAWhile, <br/>// The code becomes immediately explicit and this is desirable.</span></pre><p id="8b85" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">尽管如此，仍然存在从管道中保存临时数据的问题。这就是为什么async/await是首选。</p><h1 id="7b6e" class="ms ll in bd lm mt mu mv lp mw mx my ls jt mz ju lv jw na jx ly jz nb ka mb nc bi translated">结论</h1><p id="590c" class="pw-post-body-paragraph ko kp in kq b kr md jo kt ku me jr kw kx mf kz la lb mg ld le lf mh lh li lj ig bi translated">如果你已经通读了这篇文章(并有望理解)，那么恭喜你！我希望这有所帮助。这是艰难而漫长的。但现在你应该觉得自己是承诺大师了！</p><p id="b422" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下次再见，祝你愉快！</p><p id="a78c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="nd"> PS。这篇长文可能有一些错误。如有任何更正，不胜感激。</em></p></div></div>    
</body>
</html>