<html>
<head>
<title>The dangers of deep equal assertions in Chai.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Chai.js中深度等同断言的危险</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-dangers-of-deep-equal-assertions-in-chai-js-f25a212f671f?source=collection_archive---------4-----------------------#2020-10-29">https://javascript.plainenglish.io/the-dangers-of-deep-equal-assertions-in-chai-js-f25a212f671f?source=collection_archive---------4-----------------------#2020-10-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5002" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">深度等同断言实现起来更快，但通常会带来危险的注意力缺失</h2></div><p id="5ac5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你的团队中有人说过这样的话吗？<em class="ky">单元测试涵盖了该值，但我们将其与错误值进行了比较！”</em></p><p id="3f9f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我听到的大多数时候，都有一个深刻的平等主张。<strong class="ke io">chai . js中的Deep equal断言实现起来非常简单和快速</strong>——当我可以对一个对象进行深度比较，并且可以很容易地在测试中复制粘贴时，为什么要逐个属性地编写断言呢？— <strong class="ke io">但是这样做，开发者错过了一个机会去问自己:这个房产的价值真的是<em class="ky">应该的吗？</em></strong></p></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lm ln di lo bf lp"><div class="gh gi lg"><img src="../Images/88838100bed4053b5cba2100fcdf6d0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KPj1bk0_VJjihgKwfND_3Q.png"/></div></div></figure><p id="5ee0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">考虑一个<code class="fe ls lt lu lv b">person</code>对象，它是由一个转换函数产生的，其中包含一些业务逻辑。让我们想象一下，属性<code class="fe ls lt lu lv b">isActive</code>是由该函数中的一些内部检查决定的。</p><p id="5154" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常，开发人员只是调试或<code class="fe ls lt lu lv b">console.log</code>一下<code class="fe ls lt lu lv b">person</code>对象的内容，然后很高兴地把它们扔进一个<code class="fe ls lt lu lv b">deep.equal</code>比较中，就像这样:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Copy pasting is easy!</figcaption></figure><p id="19de" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">“我的单元测试通过了，一切都好！”</em></p><p id="b096" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不幸的是，开发人员没有花任何时间去真正地考虑对象中的每一个属性。原来<code class="fe ls lt lu lv b">isActive</code>应该是<code class="fe ls lt lu lv b">true</code>，当团队中有人意识到错误时，伤害已经造成了。</p><p id="847b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意自我，也请注意你们所有人:<strong class="ke io">不要懒惰</strong>。花点额外的时间去<strong class="ke io">真的，真的想想每一个断言</strong>:</p><figure class="lh li lj lk gt ll"><div class="bz fp l di"><div class="lw lx l"/></div><figcaption class="ly lz gj gh gi ma mb bd b be z dk">Spend some quality time asserting every property with care and love!</figcaption></figure><h1 id="f51a" class="mc md in bd me mf mg mh mi mj mk ml mm jt mn ju mo jw mp jx mq jz mr ka ms mt bi translated">柴何时进行深度相等比较？</h1><p id="e47c" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">Chai.js进行这种比较有两种方式:</p><ul class=""><li id="b235" class="mz na in ke b kf kg ki kj kl nb kp nc kt nd kx ne nf ng nh bi translated"><code class="fe ls lt lu lv b">expect(o1).to.<strong class="ke io">eql</strong>(o2)</code>:断言<em class="ky"> o1 </em>使用<a class="ae ni" href="https://github.com/chaijs/deep-eql" rel="noopener ugc nofollow" target="_blank">自己的深度相等算法</a>与<em class="ky"> o2 </em>深度相等。别名<code class="fe ls lt lu lv b">eqls</code>。</li><li id="e536" class="mz na in ke b kf nj ki nk kl nl kp nm kt nn kx ne nf ng nh bi translated"><code class="fe ls lt lu lv b">expect(o1).to.<strong class="ke io">deep.equal</strong>(o2)</code>:和以前一样，有一个很重要的区别。这使得深度相等比较也可以用于链中的任何其他断言。</li></ul></div><div class="ab cl kz la hr lb" role="separator"><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le lf"/><span class="lc bw bk ld le"/></div><div class="ig ih ii ij ik"><p id="7e2f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">投资好单元测试，你晚上会睡得更好！</strong></p></div></div>    
</body>
</html>