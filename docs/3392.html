<html>
<head>
<title>Fibonacci JavaScript Algorithms Performance Comparison</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">斐波那契JavaScript算法性能比较</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/fibonacci-javascript-implementations-comparison-fd09190f5b79?source=collection_archive---------4-----------------------#2020-09-25">https://javascript.plainenglish.io/fibonacci-javascript-implementations-comparison-fd09190f5b79?source=collection_archive---------4-----------------------#2020-09-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6d9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我有一些空闲时间，正在浏览一些编程概念，遇到了著名的<a class="ae kl" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">斐波那契数列</a>。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/ba4edab4278ab7dc4cc4dfaab89942f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*Zo-Wh0fnTlTqHpw3JR21tg.png"/></div></div></figure><p id="9e86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然我不知道确切的公式，但我知道可以用黄金比例计算出一个特定的数列。当我搜索这个的时候，我没有发现这个实现和“其他”实现之间的任何计算比较。所以我决定花点时间自己做。如果没有别的，我希望这篇文章能帮助某人破解这个永恒的面试问题。</p><p id="edd4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将探索不同的实现，并使用NodeJS比较它们的执行时间。这些实现是:</p><ul class=""><li id="9363" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">递归的</li><li id="6064" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">记忆递归</li><li id="bbe2" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">动态编程</li><li id="37ac" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">黄金比例</li></ul><h1 id="e861" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">递归实现</h1><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="fe29" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里没有火箭科学，如果你熟悉递归，这是一个非常简单的方法。然而，一旦输入变得更大，JS调用栈将开始受到影响。注意，例如，为了执行fibonacci(5 ),算法执行fibonacci(3) 3次。请参见下图。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi mm"><img src="../Images/94b56a517d2013814923f5c991c3986c.png" data-original-src="https://miro.medium.com/v2/resize:fit:720/format:webp/0*qK8HqZDGRRr50e8R.png"/></div></figure><h1 id="1333" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">记忆递归</h1><p id="fe42" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">为了缓解前面的问题，我们可以通过添加一个简单的内存状态来改进当前的解决方案，该状态可以防止两次计算相同的值。简单的缓存管理。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="14de" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这种方法改进了执行时间，但是增加了内存使用，因为我们将所有以前的值存储在内存中。一旦我们开始增加输入，内存分配将不得不增加到一定的阈值，我们将开始开发内存问题。请注意，我们使用递归机制，因此调用堆栈也会受到影响。</p><h1 id="1255" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">动态规划</h1><p id="83c4" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">动态编程方法有点不同。它使用自上而下的方式运行。动态编程，因为我们使用了一个变量池，从第一次迭代到最后一次迭代，内存不会增加。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="b5c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为这种方法是100%迭代的，所以没有递归，所以callstack不会受到影响。这种方法适用于每一个输入(尽管我们可能会受到最大整数值的限制)。</p><h1 id="47ac" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">黄金比例</h1><p id="fdc9" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">黄金比例计算，顾名思义，允许我们只使用一个计算来计算特定指数的斐波那契数列。这些是我用作来源的一些网站:【Fibonacci.com&amp;<a class="ae kl" href="https://www.mathsisfun.com/numbers/golden-ratio.html" rel="noopener ugc nofollow" target="_blank">MathIsFun.com</a><a class="ae kl" href="https://fibonacci.com/golden-ratio/#:~:text=The%20Golden%20Ratio%20formula%20is,sqrt%205)%2F2%20~%201.618.&amp;text=Therefore%2C%20phi%20%3D%200.618%20and%201%2FPhi." rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="1b68" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个计算是线性的。我们做同样的计算。尽管执行时间可能会因每次计算而有所不同(记住javascript并不适合复数运算)。</p><h1 id="83b0" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结果</h1><p id="615c" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">一个GitHub回购与所有这种情况可以找到<a class="ae kl" href="https://github.com/JMGomes/JSFibonacci" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><p id="d5c5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我使用NodeJS <a class="ae kl" href="https://nodejs.org/api/process.html#process_process_hrtime_time" rel="noopener ugc nofollow" target="_blank"> process.hrtime() </a>来计算每个算法的<a class="ae kl" href="https://github.com/JMGomes/JSFibonacci/blob/a3eb5a5ef647bcc315a4acd0556da70c69dd2027/aux/auxFunctions.js#L7" rel="noopener ugc nofollow" target="_blank">执行时间。另外</a><a class="ae kl" href="https://github.com/JMGomes/JSFibonacci/blob/a3eb5a5ef647bcc315a4acd0556da70c69dd2027/aux/auxFunctions.js#L12" rel="noopener ugc nofollow" target="_blank">将结果导出到。csv 文件</a>所以我很容易使用一个简单的谷歌表单创建图表。</p><p id="3a45" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还要创建一个<a class="ae kl" href="https://github.com/JMGomes/JSFibonacci/blob/a3eb5a5ef647bcc315a4acd0556da70c69dd2027/aux/auxFunctions.js#L41" rel="noopener ugc nofollow" target="_blank">小测试函数</a>来保证所有的实现都是正确的。</p><p id="7e47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了提高可见性，我必须创建3个不同的数据集来比较这些实现:</p><ul class=""><li id="a662" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">40的输入</li><li id="4e14" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">15k的输入</li><li id="2960" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated">10M输入</li></ul><p id="ce1d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意:所有的执行时间值都以毫秒为单位。</p><h2 id="0ace" class="mt ln iq bd lo mu mv dn ls mw mx dp lw jy my mz ma kc na nb me kg nc nd mi ne bi translated">40的输入</h2><p id="de9c" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">您可以在这里查看结果<a class="ae kl" href="https://github.com/JMGomes/JSFibonacci/blob/master/inputsTo40.csv" rel="noopener ugc nofollow" target="_blank"/></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/5a3484fabd307df2b3f0046fc082a9e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*fM9Bdo8V4HAkTsKk37THzg.png"/></div></figure><p id="9478" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在此图中，我们可以看到简单递归解决方案的执行时间迅速增加。这是意料之中的。让我们看看进一步加大投入会发生什么。</p><h2 id="75db" class="mt ln iq bd lo mu mv dn ls mw mx dp lw jy my mz ma kc na nb me kg nc nd mi ne bi translated">15k的输入</h2><p id="a4ad" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">对于这个数据集，我删除了简单的递归实现。</p><p id="544d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里查看结果<a class="ae kl" href="https://github.com/JMGomes/JSFibonacci/blob/master/inputsTo15k.csv" rel="noopener ugc nofollow" target="_blank"/></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/7e3e23402dd8f46347ed79d81f84c167.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*nKwwneCbjUCrHNuUBpTHSg.png"/></div></figure><p id="4325" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">内存方法在1k输入附近有一个巨大的尖峰，当输入达到7.5k时再次出现。另一个是动态方法在10k左右，我现在无法解释这些。</p><p id="c115" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是有一件事发生了，一旦输入达到12.5k，我们就开始有调用堆栈问题了。我想我可以增加堆栈的大小来允许执行继续进行，但这并不理想。</p><h2 id="5e0b" class="mt ln iq bd lo mu mv dn ls mw mx dp lw jy my mz ma kc na nb me kg nc nd mi ne bi translated">10M输入</h2><p id="f5a8" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">对于这个数据集，我只使用了动态方法和黄金比例计算。这是事情开始变得有趣的时候。结果数据可以在这里找到<a class="ae kl" href="https://github.com/JMGomes/JSFibonacci/blob/master/inputsTo10M.csv" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/aff031171a59c9f1ecf241ae6e4b7392.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*cVj3uD1ndfooU7xJ6-DlLg.png"/></div></figure><p id="579a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">动态方法适用于10M。我相信，只要我们不达到最大整数值，动态方法就会起作用。</p><p id="60e7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，比较动态(14334768毫秒)和黄金比例(614毫秒)的执行时间，我们观察到减少了23k倍！</p><h1 id="c704" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="ca0d" class="pw-post-body-paragraph jn jo iq jp b jq mn js jt ju mo jw jx jy mp ka kb kc mq ke kf kg mr ki kj kk ij bi translated">正如我们所料:</p><ul class=""><li id="1176" class="ky kz iq jp b jq jr ju jv jy la kc lb kg lc kk ld le lf lg bi translated">简单的递归方法只对非常有限的输入有效；</li><li id="1f0c" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated"><strong class="jp ir">使用缓存的递归方法工作得更好，但是调用堆栈问题将会存在；</strong></li><li id="3a97" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated"><strong class="jp ir">动态方法执行时间随输入线性增加，但仍能为大量数据提供结果</strong></li><li id="2d99" class="ky kz iq jp b jq lh ju li jy lj kc lk kg ll kk ld le lf lg bi translated"><strong class="jp ir">黄金分割法提供了一种几乎与执行时间成线性关系的解决方案。</strong></li></ul><p id="375d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我个人不建议任何人用JS做大数运算！</p><p id="3d09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你感兴趣的话，我创建了一个GitHub repo，它包含了创建<em class="ms">的所有实现和辅助功能。csv </em>文件，所以任何人都可以玩。看看这个。</p><div class="ng nh gp gr ni nj"><a href="https://github.com/JMGomes/JSFibonacci" rel="noopener  ugc nofollow" target="_blank"><div class="nk ab fo"><div class="nl ab nm cl cj nn"><h2 class="bd ir gy z fp no fr fs np fu fw ip bi translated">JMGomes/JSFibonacci</h2><div class="nq l"><h3 class="bd b gy z fp no fr fs np fu fw dk translated">JS斐波那契实现代码库，有4个不同的实现斐波那契序列计算器</h3></div><div class="nr l"><p class="bd b dl z fp no fr fs np fu fw dk translated">github.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx kw nj"/></div></div></a></div><p id="5cb3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最有可能的是，没有人会要求你开发一个斐波那契数计算器。然而，我不会说谎，我有一些探索的乐趣。</p><p id="4f9c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">希望你在某种程度上对此感兴趣。</p><p id="8af5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">非常感谢。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi ny"><img src="../Images/a19215ff3357d8fa6be422fee08b6c2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gMDKfljTAeZBspACRMvlyA@2x.png"/></div></div><figcaption class="nz oa gj gh gi ob oc bd b be z dk"><a class="ae kl" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank">Subscribe to Decoded, the official In Plain English YouTube channel</a></figcaption></figure></div></div>    
</body>
</html>