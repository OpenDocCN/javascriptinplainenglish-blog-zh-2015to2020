<html>
<head>
<title>Rendering Arrays in React Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在React组件中呈现数组</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rendering-arrays-in-react-components-744373ad4db5?source=collection_archive---------4-----------------------#2020-03-12">https://javascript.plainenglish.io/rendering-arrays-in-react-components-744373ad4db5?source=collection_archive---------4-----------------------#2020-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/717de80c413b4309f0d635e9af535d14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FZFe_WEa-EyVBiKY"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@bamin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Pierre Bamin</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bcd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建前端视图的库。它有一个庞大的图书馆生态系统与之合作。此外，我们可以用它来增强现有的应用程序。</p><p id="13e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何在React组件中呈现列表。</p><h1 id="8a05" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">列表和键</h1><p id="968c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过调用数组的<code class="fe me mf mg mh b">map</code>方法将列表转换成HTML。</p><p id="767a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想将一组数字显示为一个列表，我们可以这样写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="39ba" class="mq lc iq mh b gy mr ms l mt mu">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>  }</span><span id="c58a" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        {[1, 2, 3, 4, 5].map(num =&gt; (<br/>          &lt;span&gt;{num}&lt;/span&gt;<br/>        ))}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="5097" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们在<code class="fe me mf mg mh b">[1, 2, 3, 4, 5]</code>数组上调用了<code class="fe me mf mg mh b">map</code>。在<code class="fe me mf mg mh b">map</code>方法的回调中，我们返回了一个包含数字的<code class="fe me mf mg mh b">span</code>，我们对每个元素都做了同样的处理。</p><p id="22cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7661" class="mq lc iq mh b gy mr ms l mt mu">12345</span></pre><p id="b4ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">显示在屏幕上。</p><p id="d08d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将它赋给一个变量，然后将其传递给<code class="fe me mf mg mh b">ReactDOM.render</code>方法，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c095" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="d2ec" class="mq lc iq mh b gy mv ms l mt mu">const nums = [1, 2, 3, 4, 5].map(num =&gt; &lt;span&gt;{num}&lt;/span&gt;);</span><span id="61d2" class="mq lc iq mh b gy mv ms l mt mu">const rootElement = document.getElementById("root");<br/>ReactDOM.render(nums, rootElement);</span></pre><p id="6436" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会展示同样的商品。</p><p id="0e1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以在<code class="fe me mf mg mh b">render</code>方法中使用相同的代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ae9e" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="e8a0" class="mq lc iq mh b gy mv ms l mt mu">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>  }</span><span id="043a" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    const nums = [1, 2, 3, 4, 5].map(num =&gt; &lt;span&gt;{num}&lt;/span&gt;);<br/>    return &lt;div&gt;{nums}&lt;/div&gt;;<br/>  }<br/>}</span><span id="53f7" class="mq lc iq mh b gy mv ms l mt mu">const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App /&gt;, rootElement);</span></pre><h1 id="1b13" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">键</h1><p id="da3e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们呈现列表时，我们应该为每个呈现的元素提供一个<code class="fe me mf mg mh b">key</code> prop值，以便React可以识别哪些项目已经更改、添加或删除。</p><p id="7a62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它给元素一个稳定的身份。我们应该通过使用一个字符串来选择一个键，这个字符串在它的兄弟列表中唯一地标识一个列表项。</p><p id="eb57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">键应该是字符串值。</p><p id="9f84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想要呈现待办事项列表，我们应该选择<code class="fe me mf mg mh b">id</code>字段作为<code class="fe me mf mg mh b">key</code>的值，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2b2c" class="mq lc iq mh b gy mr ms l mt mu">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      todos: [<br/>        { id: 1, text: "eat" },<br/>        { id: 2, text: "drink" },<br/>        { id: 3, text: "sleep" }<br/>      ]<br/>    };<br/>  }</span><span id="e26e" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        {this.state.todos.map(todo =&gt; (<br/>          &lt;p key={todo.id.toString()}&gt;{todo.text}&lt;/p&gt;<br/>        ))}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="d610" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们使用了<code class="fe me mf mg mh b">key={todo.id.toString()}</code>属性将<code class="fe me mf mg mh b">key</code>设置为被转换为字符串的<code class="fe me mf mg mh b">todo</code>的<code class="fe me mf mg mh b">id</code>。</p><p id="4edc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们的项目没有稳定的身份，我们可以使用索引作为最后的手段:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2127" class="mq lc iq mh b gy mr ms l mt mu">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      todos: [{ text: "eat" }, { text: "drink" }, { text: "sleep" }]<br/>    };<br/>  }</span><span id="9e17" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        {this.state.todos.map((todo, index) =&gt; (<br/>          &lt;p key={index.toString()}&gt;{todo.text}&lt;/p&gt;<br/>        ))}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="18ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">index</code>始终可用，并且对于每个数组元素都是唯一的，因此它可以用作<code class="fe me mf mg mh b">key</code>属性的值。</p><h1 id="f605" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用键提取组件</h1><p id="b8a5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们渲染组件，我们应该将<code class="fe me mf mg mh b">key</code>道具放在组件中，而不是被渲染的元素中。</p><p id="da6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，以下是对<code class="fe me mf mg mh b">key</code>道具的不正确使用:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d295" class="mq lc iq mh b gy mr ms l mt mu">function TodoItem({ todo }) {<br/>  return &lt;p key={todo.id.toString()}&gt;{todo.text}&lt;/p&gt;;<br/>}</span><span id="9c71" class="mq lc iq mh b gy mv ms l mt mu">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      todos: [<br/>        { id: 1, text: "eat" },<br/>        { id: 2, text: "drink" },<br/>        { id: 3, text: "sleep" }<br/>      ]<br/>    };<br/>  }</span><span id="a885" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        {this.state.todos.map(todo =&gt; (<br/>          &lt;TodoItem todo={todo} /&gt;<br/>        ))}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="4271" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">TodoItem</code>组件中，我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8fdd" class="mq lc iq mh b gy mr ms l mt mu">&lt;p key={todo.id.toString()}&gt;{todo.text}&lt;/p&gt;;</span></pre><p id="12a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe me mf mg mh b">key</code>道具。我们不希望它在那里，因为我们不需要识别一个独特的<code class="fe me mf mg mh b">li</code>，因为它已经与外界隔离了。相反，我们想确定一个独特的<code class="fe me mf mg mh b">TodoItem</code>。</p><p id="c3f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="214b" class="mq lc iq mh b gy mr ms l mt mu">function TodoItem({ todo }) {<br/>  return &lt;p&gt;{todo.text}&lt;/p&gt;;<br/>}</span><span id="dae2" class="mq lc iq mh b gy mv ms l mt mu">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      todos: [<br/>        { id: 1, text: "eat" },<br/>        { id: 2, text: "drink" },<br/>        { id: 3, text: "sleep" }<br/>      ]<br/>    };<br/>  }</span><span id="a113" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        {this.state.todos.map(todo =&gt; (<br/>          &lt;TodoItem todo={todo} key={todo.id.toString()} /&gt;<br/>        ))}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="3376" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该在通过<code class="fe me mf mg mh b">map</code>的回调返回的项目中添加键。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/fb379c14484ba3f757274201ee2d0096.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2Bx6Kg6Jch2jp_UD"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@zburival?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zbynek Burival</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="0719" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">键只需要在同级中是唯一的</h1><p id="4986" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">键只需要在同级元素中是唯一的。</p><p id="4763" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="354a" class="mq lc iq mh b gy mr ms l mt mu">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      posts: [<br/>        { id: 1, text: "eat" },<br/>        { id: 2, text: "drink" },<br/>        { id: 3, text: "sleep" }<br/>      ],<br/>      comments: [<br/>        { id: 1, text: "eat" },<br/>        { id: 2, text: "drink" },<br/>        { id: 3, text: "sleep" }<br/>      ]<br/>    };<br/>  }</span><span id="f769" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        &lt;div&gt;<br/>          {this.state.posts.map(post =&gt; (<br/>            &lt;p key={post.id.toString()}&gt;{post.text}&lt;/p&gt;<br/>          ))}<br/>        &lt;/div&gt;<br/>        &lt;div&gt;<br/>          {this.state.comments.map(comment =&gt; (<br/>            &lt;p key={comment.id.toString()}&gt;{comment.text}&lt;/p&gt;<br/>          ))}<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    );<br/>  }</span></pre><p id="7b23" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<code class="fe me mf mg mh b">posts</code>和<code class="fe me mf mg mh b">comments</code>不在同一个<code class="fe me mf mg mh b">div</code>中渲染，因此<code class="fe me mf mg mh b">key</code>值可能会重叠。</p><p id="bc6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">key</code>道具不会传递给组件。如果我们在一个组件中需要相同的值，我们必须使用不同的名称。</p><h1 id="c5b2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在JSX嵌入地图()</h1><p id="1023" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在花括号之间嵌入直接调用<code class="fe me mf mg mh b">map</code>的表达式。</p><p id="2fbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3b68" class="mq lc iq mh b gy mr ms l mt mu">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>  }</span><span id="18e5" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;div&gt;<br/>        {[1, 2, 3, 4, 5].map(num =&gt; (<br/>          &lt;span key={num.toString()}&gt;{num}&lt;/span&gt;<br/>        ))}<br/>      &lt;/div&gt;<br/>    );<br/>  }<br/>}</span></pre><h1 id="16e4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="1fd9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用JavaScript array的<code class="fe me mf mg mh b">map</code>方法将值映射到React元素或组件。</p><p id="6648" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了帮助React识别唯一的元素，我们应该为呈现的每个条目向<code class="fe me mf mg mh b">key</code> prop传递一个唯一的字符串。</p><p id="440c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它应该被传递给由<code class="fe me mf mg mh b">map</code>的回调返回的任何东西，因为它们是必须由React唯一标识的项目。</p><p id="e6f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，键在直接兄弟中必须是唯一的。其他地方可以有相同的键值。</p></div></div>    
</body>
</html>