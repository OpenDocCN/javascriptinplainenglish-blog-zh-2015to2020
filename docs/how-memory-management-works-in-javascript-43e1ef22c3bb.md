# JavaScript 中内存管理的工作原理

> 原文：<https://javascript.plainenglish.io/how-memory-management-works-in-javascript-43e1ef22c3bb?source=collection_archive---------0----------------------->

## JavaScript 的基础知识

## 一本通过闭包、作用域和其他相关事物理解引用的指南，你可能是初学者，也可能不是。

![](img/d7382e4b2fee368f7b8d21a11204aecc.png)

老实说，我是那些在阅读整个文档之前尝试做一些事情的人之一…大多数时候，它工作得很好，如果我卡住了，我会打开文档并检查我的问题的答案。

但是最近，我在使用 React 应用程序处理 JavaScript 引用时遇到了一些问题，并且不太容易发现，因为我的代码没有以可预测的方式产生变化。

它是关于一些我认为我正在掌握的东西，但是我很久以前读过关于它的文章和文档，我已经忘记了一些关于它的事情。

这些问题对我帮助很大，我学到了一些我已经错过很长时间的东西，一些被认为是基础的东西…即使我是一名程序员已经很多年了。我想和你分享我今天学到的东西。

**这一期是关于理解 JavaScript 中的内存管理，**特别是通过作用域。

# JavaScript 内存管理解释

好的，为了理解 JS 内存，我们需要记住下面文章中的两条规则，它们非常简单:

*   **原始类型** *(字符串、数字、布尔)* **作为副本传递给函数参数。**
*   **对象作为函数参数的引用被传递**
*   **函数**和**数组**(也是 null，但这是出于历史原因保留的一个 bug，它并不像其他两个那样是可变的)**被 JavaScript 认为是对象**

您可以在您的浏览器控制台中尝试这个`typeof []`来验证该行为，您将最终得到被打印的`object`。

## JavaScript 中的引用是如何工作的以及如何解释它

你在下面看到的是一般的 JavaScript 引擎，不管是框架还是环境，但是我们将在后面看到为什么这对于 ReactJS 和 hooks 来说是乏味的。

```
const someObject = { a: 5 };
const someArray = [1, 2];
```

你可能会认为下面的语句是在`{ a: 5 }`引用位置(内存位置)创建的`someObject`，但实际上，你应该把它理解为`someObject`变量对对象`{ a: 5 }`引用的引用点。

上述语句可以分解如下

```
| const someObject   | =                   | { a: 5 };
| const someArray    | =                   | [1, 2]
| variable reference | assignment operator | object Reference
```

也可以看看那两个增加更多解释的要点: [**这个**](https://gist.github.com/siwalikm/dbf0e71f6e7e3406369b2cff1a6eb416) 和 [**这个**](https://gist.github.com/rtablada/81507edfdfce8063be9a7728c7ae7135) 。

好了，现在我们有了基础，让我们看看为什么如果理解不好会有问题。

# JavaScript 闭包和引用

**快速记住闭包**

> [闭包](https://en.wikipedia.org/wiki/Closure_(computer_programming))是一个记住其外部变量并能访问它们的函数。在 JavaScript 中，几乎所有的函数自然都是闭包。

使用 JavaScript 时，你每次都在使用闭包和管理作用域，通过这样做，你需要理解引用是如何工作的。

在闭包里，有一个**词汇环境**的概念，它保存不同范围的值。我这里就不展开那么多了如果你想了解更多，**随意在这里** 阅读详情 [**。**](https://javascript.info/closure#lexical-environment)

**带参数的➡️原语类型被作为副本传递**。下面是一个简单的例子。

在下面的例子中，修改`a`或`b`对范围 2 内的`arg`没有任何副作用。同样在范围 2 内修改`arg`对`a`还是`b`没有影响。

**记住:**范围用括号`{ }`分隔。

```
// Scope 1
let a = 5;
let b = "hello";function test(arg) {
  // Scope 2
  arg = "Something else";
}test(a)
test(b)
```

**➡️对象被作为引用传递，**我们将通过闭包与突变和赋值来研究这一点。

## JavaScript 中带闭包的赋值与变异

因为闭包和回调是 JavaScript 编程和事件驱动编程的核心，所以你会在很多时候依赖这些东西。

在下面的示例中，有一个 quick NodeJS 片段，它将模拟向注册了主题的用户显示消息的行为。但是这段代码有点动态:

*   在程序执行过程中，订阅的用户会发生变化。我每隔 10 秒使用一个`setInterval`函数**来模拟这个。有时添加一个感兴趣的用户，有时删除一个。**
*   每秒钟，我们都会向订阅用户发送一条随机消息。

在文件的最后，有两个`setInterval`函数负责改变我们的订阅用户数组。由于名为`startListeningForMessages`的闭包函数，我们还创建了一个可变范围。

**让我们试试代码**

请随意使用你自己的 NodeJS 环境或者这个托管在云中的环境:[https://repl.it/languages/nodejs](https://repl.it/languages/nodejs)

**脚本使用说明**

尝试在第一个`setInterval`取消注释的情况下启动程序，然后反转并取消注释第二个，并注释第一个。

你看出区别了吗？

## 说明

*   **在第一个区间**中，什么也没有显示。那是因为我们在替换数组的引用。即使作为引用传递了`listeningUsers`自变量仍然指向旧的`interestedUsers`指针引用。这样`interestedUsers`被重新分配，而旧的`interestedUsers`仍然存在，但不能被垃圾收集，因为引用仍然存在，也不能在闭包范围之外被访问。这可能是内存泄漏，但在我们的例子中，情况更糟，因为我们在兴趣列表中不再同步。
*   在第二个间歇，事情发生了变化。这是因为我们使用了数组对象的变异方法。这样，引用不会改变，但数组中的元素会改变。通过这样做，我们不会因为闭包函数而丢失上下文。

这就是为什么你应该总是问自己是否应该改变或重新分配一些东西，并在使用范围外变量时考虑副作用。

## **这也适用于物体！**

对于一个几乎相同的对象，如果你在闭包函数中编辑了对象的一个键，这是可以的，因为你仍然指向同一个引用。但是如果你在函数内部重新赋值对象，你就失去了引用。

# React hooks 呢？

同样的事情在这里，因为只有当调用 setter 后`Object.is`比较返回 false 时`useState`才会导致重新渲染。如果你使用`useState`而不改变引用，你的 UI 将不会得到更新。

这就是为什么我们通常在状态改变时请求 useEffect 和 clean closure 作用域，但有时这样做，在用新值取消订阅/重新订阅期间，您可能会丢失事件侦听器中的一些事件。当有对象状态或数组状态时，这也很重要