<html>
<head>
<title>Complex form state using React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React挂钩的复杂表单状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/complex-form-state-using-react-hooks-4ca1ac3181f?source=collection_archive---------5-----------------------#2019-09-17">https://javascript.plainenglish.io/complex-form-state-using-react-hooks-4ca1ac3181f?source=collection_archive---------5-----------------------#2019-09-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="ca20" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">替代<strong class="ak"> this.setState() </strong>的优点</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/be373847515f7929d3fcc30a1b4ba142.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kEPCQNY4dwVyaFuLEwJcNQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">is every body hooked yet ? <a class="ae ks" href="https://cdn-media-1.freecodecamp.org/images/1*0MgGEfZfLO91g1Oa2h3ebQ@2x.png" rel="noopener ugc nofollow" target="_blank">Image Credits — Free Code Camp</a></figcaption></figure><p id="5527" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，<strong class="kv io"> React hooks </strong>发布已经有一段时间了。从表面上看，每个人都为他们着迷。嗯，我明白。因为我也是你们中的一员。<em class="lp">钩子让我着迷！</em></p><p id="7757" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">钩子允许我们创建更小的、可组合的、可重用的、更易管理的React组件。</p><p id="c009" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有时你可能使用钩子来管理表单状态，使用<strong class="kv io"> useState </strong>或<strong class="kv io"> useReducer。</strong></p><p id="997a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，让我们考虑一个场景，其中您必须管理一个具有多个表单输入的复杂表单状态，表单输入可以是几种不同的类型，如文本、数字、日期输入。表单状态甚至可以有嵌套信息，例如用户的地址信息，它有自己的子字段，如<em class="lp"> address.addressLine1 </em>、<em class="lp"> address.addressLine2 </em>等。</p><p id="6c13" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">也许你还需要根据当前状态更新表单状态，比如切换按钮。</p><p id="d3ca" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，如果您对每个单独的表单字段使用<strong class="kv io"> useState </strong>，那么您就能够基于当前状态计算新的状态。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="211f" class="lv lw in lr b gy lx ly l lz ma">const [modalActive, updateModal] = useState(false)<br/>.<br/>.<br/>.<br/>// new state based on previous<br/>updateModal(prev =&gt; !prev)</span></pre><p id="cc56" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，如果你有太多的单个表单字段，比如100+，(<strong class="kv io"> YESS！！。我管理着100多个表单字段</strong>，这种方法并不友好。</p><p id="bd5a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">想象一下！！..</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="cff7" class="lv lw in lr b gy lx ly l lz ma">const [firstName, setFirstName] = useState('')<br/>const [middleName, setMiddleName] = useState('')<br/>const [lastName, setLastName] = useState('')<br/>.<br/>.<br/>.<br/>.</span></pre><p id="40d6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">编写不同的使用状态，然后为每个字段使用单独的更新函数是不实际的。</p><p id="7fa1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，我们的另一个选择是钩子。</p><p id="2c73" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我们看一个例子。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="e284" class="lv lw in lr b gy lx ly l lz ma">const initialState = {<br/>  firstName: '',<br/>  lastName: ''<br/>};</span><span id="f7d1" class="lv lw in lr b gy mb ly l lz ma">function reducer(state, action) {<br/>  switch (action.type) {<br/>    case 'firstName':<br/>      return { firstName: action.payload };<br/>    case 'lastName':<br/>      return { lastName: action.payload };<br/>    default:<br/>      throw new Error();<br/>  }<br/>}</span><span id="6e3f" class="lv lw in lr b gy mb ly l lz ma">function Counter() {<br/>  const [state, dispatch] = useReducer(reducer, initialState);</span><span id="04b4" class="lv lw in lr b gy mb ly l lz ma">return (<br/>    &lt;&gt;<br/>      &lt;input<br/>        type="text"<br/>        name="firstName"<br/>        placeholder="First Name"<br/>        onChange={(event) =&gt; {<br/>          dispatch({<br/>           type: 'firstName',<br/>           payload: event.target.value<br/>          })<br/>        }}<br/>        value={state.firstName} /&gt;<br/>      &lt;input<br/>        type="text"<br/>        name="lastName"<br/>        placeholder="Last Name"<br/>        onChange={(event) =&gt; {<br/>          dispatch({<br/>           type: 'lastName',<br/>           payload: event.target.value<br/>          })<br/>        }}<br/>        value={state.lastName} /&gt;<br/>   &lt;/&gt;<br/>  );<br/>}</span></pre><p id="456b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">诶！！，不好。</p><p id="38c0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你不可能为reducer中的那些<strong class="kv io"> n </strong>数量的表单字段编写每个用例。</p><p id="58f5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是<strong class="kv io"> useReducer </strong>中使用的reducer函数只是一个返回更新状态对象的普通函数。所以，我们可以做得更好。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="91e0" class="lv lw in lr b gy lx ly l lz ma">function reducer(state, action) {<br/>  // field name and value are retrieved from event.target<br/>  const { name, value } = action<br/>  <br/>  // merge the old and new state<br/>  return { ...state, [name]: value }<br/>}</span></pre><p id="86aa" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，这看起来是一个更好和更清洁的减速器。</p><p id="1b7d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是…这不允许我们在用回调函数调用更新函数时根据当前状态计算新状态。就像我们能做的一样..</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="1e4e" class="lv lw in lr b gy lx ly l lz ma">this.setState((prev) =&gt; ({ isActive: !prev }))</span><span id="c8f3" class="lv lw in lr b gy mb ly l lz ma">// or</span><span id="373c" class="lv lw in lr b gy mb ly l lz ma">const [modalActive, updateModal] = useState(false)<br/>.<br/>.<br/>.<br/>updateModal(prev =&gt; !prev)</span></pre><p id="861b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，如何更新嵌套状态，如<em class="lp"> address.addressLine1，address.pinCode. </em></p><p id="0baf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好吧！！。关于使用不太理想的方法来管理复杂的表单状态，我们已经讨论了很多。</p><p id="8040" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我向你展示解决方案。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mc md l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">ta da!!</figcaption></figure><p id="2a32" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以，这是处理这种复杂表单场景的完整源代码。</p><p id="29d7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我来稍微解释一下减速器(<strong class="kv io"> enhancedReducer </strong> :P)的功能。</p><p id="da66" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">reducer函数接收两个参数，第一个参数是更新前的当前状态。当您调用<strong class="kv io"> updateState / dispatch </strong>函数来更新减速器状态时，会自动提供该参数。reducer函数的第二个参数是您用来调用<strong class="kv io"> updateState </strong>函数的值，它不必是{ type: 'something '，payload: 'something' }形式的典型<em class="lp"> redux操作对象</em>。它可以是任何东西，数字、字符串、对象甚至函数。</p><p id="7a75" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是我们正在利用的。如果<strong class="kv io"> updateArg </strong>是一个函数，我们用当前状态调用它来计算新的状态。我们从这个函数返回的任何对象都成为我们的新状态。</p><p id="4363" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果updateArg是一个普通的旧Javascript对象，那么有两种情况。</p><p id="01ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1- <strong class="kv io">该对象没有_path和_value属性— </strong>，因此是一个普通的更新对象，就像我们给this.setState的一样。因此，您可以用一个包含您想要更新的状态片段的新对象来调用<strong class="kv io"> updateState </strong>，它会将其与旧对象合并，并返回新状态。</p><p id="88c1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2- <strong class="kv io">对象具有_path和_value属性— </strong>当使用具有这两个属性的对象调用updateState函数时。我们将此视为特殊情况，其中<strong class="kv io"> _path </strong>表示嵌套的字段路径。以字符串形式，例如:“address.pinCode”或表示路径的数组[“address”，“pinCode”]。</p><p id="577a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，我们如何使用这样的路径表示来更新对象中的嵌套字段呢？。我们使用<strong class="kv io">lodash’</strong>s<strong class="kv io">set</strong>方法。它接受两种路径形式作为update和object的有效输入。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="f174" class="lv lw in lr b gy lx ly l lz ma">set(objectToUpdate, path, newValue)</span><span id="51f7" class="lv lw in lr b gy mb ly l lz ma">const state = {<br/>  name: {<br/>   first: '',<br/>   middle: '',<br/>   last: ''<br/>  }<br/>}</span><span id="dac3" class="lv lw in lr b gy mb ly l lz ma">// and to update, for eg: first name.<br/>// both ways of path are correct.</span><span id="dd3e" class="lv lw in lr b gy mb ly l lz ma">set(state, 'name.first', 'Aditya')<br/>set(state, ['name', 'first'], 'Aditya')</span></pre><p id="e6fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是，<strong class="kv io"> set </strong>方法就地改变对象，并且不返回新的副本，但是在React world中，变化检测依赖于<strong class="kv io">不变性</strong>，一个新的数据副本，在内存中有一个新的位置。</p><p id="dc54" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">因此，为了绕过这一点，我们使用<strong class="kv io"> immer，</strong>以一种易于使用的形式帮助处理Javascript对象的不变性。</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="b6c9" class="lv lw in lr b gy lx ly l lz ma">import produce from 'immer'</span><span id="47a7" class="lv lw in lr b gy mb ly l lz ma">produce(state, draft =&gt; {<br/>  set(draft, _path, _value);<br/>});</span></pre><p id="0012" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">从<strong class="kv io"> </strong>产生</strong>函数immer <strong class="kv io"> </strong>将对象作为它的第一个参数，在我们的例子中是当前状态，它的第二个参数是一个函数，它接收对象的<strong class="kv io">草稿副本</strong>以进行变异，无论您在草稿状态下在这个函数内部修改什么，都是在<strong class="kv io">副本</strong>上完成的，而不是实际输入对象的<strong class="kv io">状态</strong>就地完成。然后自动返回<strong class="kv io">新对象</strong>和<strong class="kv io">更新后的</strong>数据。</p><p id="4106" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是我们的增强型减速器:D</p><p id="3759" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">仅仅</p><pre class="kd ke kf kg gt lq lr ls lt aw lu bi"><span id="276a" class="lv lw in lr b gy lx ly l lz ma">yarn add lodash immer</span></pre><p id="4419" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">尽情享受吧。</p><p id="ad66" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">gist中的例子可以进一步细化，在<strong class="kv io"> enhancedReducer </strong>中处理更多的边缘情况，并且可以通过映射表单规范对象来缩短表单字段代码，以动态地创建它，并减少代码重复和其他一些事情。</p><p id="9ee9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有些读者可能对这种方法有不同的看法。所以，我们可以随时讨论。</p><p id="696d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">也许你们中的一些人会有一个问题，如果我们这么想复制<strong class="kv io"> this.setState </strong>，那么为什么不也有setState第二个参数回调函数，在状态更新后执行一些操作。嗯，这还不够明确！我们将采用先做这个，后做那个的方法。我们将一步一步地告诉代码，如何做某事。而不是简单的告诉它做什么。我会使用<strong class="kv io"> useEffect </strong>而不是回调函数和how to do方法，因为那是声明性的，<em class="lp">对变化做出反应。</em></p><p id="8dc9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">声明式与命令式，函数式编程完全是另一个话题，我将在以后分享。</p><p id="6b58" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">资源—</p><div class="me mf gp gr mg mh"><a href="https://lodash.com/docs/4.17.15#set" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd io gy z fp mm fr fs mn fu fw im bi translated">Lodash文档</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">编辑描述</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">lodash.com</p></div></div></div></a></div><div class="me mf gp gr mg mh"><a href="https://github.com/immerjs/immer" rel="noopener  ugc nofollow" target="_blank"><div class="mi ab fo"><div class="mj ab mk cl cj ml"><h2 class="bd io gy z fp mm fr fs mn fu fw im bi translated">immerjs/immer</h2><div class="mo l"><h3 class="bd b gy z fp mm fr fs mn fu fw dk translated">通过简单地修改“年度突破”的当前树获胜者，创建下一个不可变的状态树…</h3></div><div class="mp l"><p class="bd b dl z fp mm fr fs mn fu fw dk translated">github.com</p></div></div><div class="mq l"><div class="mr l ms mt mu mq mv km mh"/></div></div></a></div></div></div>    
</body>
</html>