<html>
<head>
<title>How JWT works? The implementation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JWT是如何运作的？实施</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-jwt-works-in-depth-354cb5dc360d?source=collection_archive---------3-----------------------#2020-06-04">https://javascript.plainenglish.io/how-jwt-works-in-depth-354cb5dc360d?source=collection_archive---------3-----------------------#2020-06-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b26b24def70eb09271f24f4ea42d26c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IALQqvNTXxexyUW0HB4fwA.png"/></div></div></figure><div class=""/><div class=""><h2 id="5fcb" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">让我们构建一个NodeJS库来创建、签名和验证JWT令牌</h2></div><h1 id="f4eb" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">JWT的工作方式——实施</h1><p id="593f" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">为什么以及如何工作？让我们构建一个NodeJS库来创建、签名和验证JWT令牌。</p><p id="9f87" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">在本文中，我们将重点构建一个简单的JWT库，用于处理JSON Web令牌的签名和验证。</p><h1 id="6f76" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">什么是JSON Web令牌(JWT)？</h1><p id="e7f1" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">JSON Web Token (JWT)是一个开放标准(<a class="ae mj" href="https://tools.ietf.org/html/rfc7519" rel="noopener ugc nofollow" target="_blank"> RFC 7519 </a>)，用于在端点之间以JSON对象的形式安全地传输信息。</p><p id="5e19" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">JWT由三个主要部分组成，报头、有效载荷和签名，每个部分都用点分隔。我们将简要介绍这些不同的部分。</p><h1 id="36b7" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">页眉</h1><p id="d76a" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">标头通常指定签名算法和令牌类型。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="916b" class="mw kr jb mn b gy mx my l mz na">{<br/>  "alg": "HS256",<br/>  "typ": "JWT"<br/>}</span></pre><p id="fb00" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated"><code class="fe mk ml mm mn b">alg</code> -标识用于生成签名的算法，HS256表示该令牌使用HMAC-SHA256进行签名。<code class="fe mk ml mm mn b">typ</code>——指令牌类型</p><p id="5423" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">这个JSON被字符串化，然后被base64url编码。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="3b27" class="mw kr jb mn b gy mx my l mz na">const header = {<br/>  "alg": "HS256",<br/>  "typ": "JWT"<br/>};</span><span id="bae7" class="mw kr jb mn b gy nb my l mz na">const encodedHeader = base64url.encode(JSON.stringify(header));</span></pre><h1 id="9e28" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">有效载荷</h1><p id="6e8d" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">第二部分是令牌的有效负载，它包含一组声明和应用程序识别用户所需的任何元数据。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="2bc3" class="mw kr jb mn b gy mx my l mz na">{<br/>  "name": "John",<br/>  "iat": 1591024013,<br/>  "exp": 1892023997<br/>}</span></pre><p id="dea5" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">此示例具有标准发布时间声明(<code class="fe mk ml mm mn b">iat</code>)、到期时间声明(<code class="fe mk ml mm mn b">exp</code>)和自定义声明<code class="fe mk ml mm mn b">name</code>。然后，有效负载对象被字符串化并进行base64Url编码，形成JWT的第二部分。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="74a2" class="mw kr jb mn b gy mx my l mz na">const payload = {<br/>  "name": "John",<br/>  "iat": 1591024013,<br/>  "exp": 1892023997<br/>};<br/>const encodedPayload = base64url.encode(JSON.stringify(payload));</span></pre><h1 id="fe5a" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">签名</h1><p id="fc26" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">JWT的第三部分也是最后一部分是签名。它由经过编码的报头、经过编码的有效载荷、秘密字符串和应用报头中指定的算法组成。</p><p id="3ae0" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">如果我们使用HMAC SHA256算法，签名将以如下方式创建:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="89f7" class="mw kr jb mn b gy mx my l mz na">HMACSHA256(encodedHeader + "." + encodedPayload, secret)</span></pre><p id="b446" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">通过向我们的令牌字符串添加签名，可以验证所提供令牌的所有权和完整性。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="d605" class="kq kr jb bd ks kt nj kv kw kx nk kz la kh nl ki lc kk nm kl le kn nn ko lg lh bi translated">让我们构建一个简单的节点。JS库</h1><p id="9ce0" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">如果你想快速一瞥最终结果，你可以看看这个<a class="ae mj" href="https://github.com/alexcambose/jwt" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p><p id="f3dd" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">首先，我们需要创建一个新的NodeJS项目。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="507e" class="mw kr jb mn b gy mx my l mz na">npm init -y</span></pre><p id="cdc3" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">一旦完成，您应该在您的目录中准备好一个<em class="no"> package.json </em>。这意味着您可以开始安装项目所需的依赖项。</p><p id="b12d" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">我们将需要Lodash和Base64模块。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="3f9b" class="mw kr jb mn b gy mx my l mz na">npm i -S base64url lodash</span></pre><h1 id="0c50" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">我们的入口</h1><p id="687f" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">让我们首先创建一个index.js文件，它将导出我们的两个主要函数，<code class="fe mk ml mm mn b">verify</code>和<code class="fe mk ml mm mn b">sign</code>。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="9cd3" class="mw kr jb mn b gy mx my l mz na">// index.js<br/>const verify = require('./verify');<br/>const sign = require('./sign');</span><span id="95f4" class="mw kr jb mn b gy nb my l mz na">module.exports = {<br/>  verify,<br/>  sign,<br/>};</span></pre><h1 id="17a8" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">符号功能</h1><p id="601b" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们需要一个函数，它接受一个有效载荷、一个秘密和一些附加选项，并返回一个JWT。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1b82" class="mw kr jb mn b gy mx my l mz na">// sign.js<br/>module.exports  = (payloadData, secret, options = {}) =&gt; {<br/>};</span></pre><p id="5fc5" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">由于options对象可以包含报头和有效载荷参数/声明，我们只需要在必要的时候过滤和添加它们。为了简单起见，我将使用洛达什的<code class="fe mk ml mm mn b">pick</code>和<code class="fe mk ml mm mn b">omit</code>函数。顾名思义，<code class="fe mk ml mm mn b">_.pick(object, ['key1', 'key2', ...])</code>函数将获取一个对象和一个键数组，并将返回一个只包含数组中指定的键的新对象。<code class="fe mk ml mm mn b">omit</code>功能与<code class="fe mk ml mm mn b">pick</code>相反。更多信息请参见<a class="ae mj" href="https://lodash.com/docs/4.17.15#pick" rel="noopener ugc nofollow" target="_blank">选择</a>和<a class="ae mj" href="https://lodash.com/docs/4.17.15#omit" rel="noopener ugc nofollow" target="_blank">省略</a>的正式文件。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">A starting point for the sign function</figcaption></figure><p id="c7ed" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">在设置了报头和有效载荷之后，是时候看看我们如何生成签名了。在本指南中，我们将重点介绍如何使用HMACSHA256算法生成签名。这可以使用本机<code class="fe mk ml mm mn b">crypto</code>模块来完成。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="6768" class="mw kr jb mn b gy mx my l mz na">const crypto =  require('crypto');<br/>// ...<br/>const signature = crypto.createHmac('sha256', secret).update(`${encodedHeader}.${encodedPayload}`).digest('base64');</span></pre><p id="957f" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">一些潜在的小改进是根据<code class="fe mk ml mm mn b">exp</code>索赔中提供的秒数自动计算有效期，并在没有指定秘密的情况下自动将标题<code class="fe mk ml mm mn b">alg</code>设置为<code class="fe mk ml mm mn b">none</code>。</p><p id="4710" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">计算<code class="fe mk ml mm mn b">exp</code>索赔时:</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="fedb" class="mw kr jb mn b gy mx my l mz na">if (options.exp) {<br/>  options.exp += Math.round(new Date().getTime() / 1000);<br/>}</span></pre><p id="d4bc" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">并且在没有提供秘密的情况下自动将<code class="fe mk ml mm mn b">alg</code>设置为无(并且返回没有签名的令牌)</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="1444" class="mw kr jb mn b gy mx my l mz na">if (!secret || header.alg === 'none') {<br/>  header.alg = 'none';<br/>  const encodedHeader = base64url(JSON.stringify(header));</span><span id="e5f7" class="mw kr jb mn b gy nb my l mz na">return `${encodedHeader}.${encodedPayload}.`;<br/>}</span></pre><p id="78ca" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">最终的工作代码如下所示:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">The final sign function</figcaption></figure></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="3410" class="kq kr jb bd ks kt nj kv kw kx nk kz la kh nl ki lc kk nm kl le kn nn ko lg lh bi translated">验证功能</h1><p id="4ddb" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">验证功能需要获取一个令牌和一个秘密，并检查签名是否正确。尽管不一定是必需的，我们也可以对有效载荷进行base64Url解码，以便进一步使用。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="9dd8" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">签名验证意味着，如果我们用秘密对给定的头和有效载荷签名，结果将与令牌中提供的签名相同。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="675c" class="mw kr jb mn b gy mx my l mz na">// recalculate the signature based on the header and payload<br/>const signature = crypto.createHmac('sha256', secret).update(`${tokenHeader}.${tokenPayload}`).digest('base64');</span><span id="4e42" class="mw kr jb mn b gy nb my l mz na">// the essential part, checking if the signatures match<br/>if (base64url.fromBase64(signature) !== tokenSignature) {<br/>  throw new Error('Invaid signature');<br/>}</span></pre><p id="a7d8" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">我将再次指出，签名基本上是一个哈希函数，它采用header+load+secret作为输入，其中一个部分的任何更改都会完全改变生成的哈希。</p><p id="4190" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">除了检查签名是否正确以及我们增加了<code class="fe mk ml mm mn b">exp</code>理赔计算外，我们还可以在这里检查基于当前日期令牌是否仍然有效。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="fc24" class="mw kr jb mn b gy mx my l mz na">// if the `exp` claim is set, verify if it's not expired<br/>if (payload.exp &amp;&amp; payload.exp &lt; Date.now()) {<br/>  throw new Error('Expired token');<br/>}</span></pre><p id="bf5f" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">最终的验证函数如下所示:</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">The verify function</figcaption></figure></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h2 id="f65d" class="mw kr jb bd ks nv nw dn kw nx ny dp la lr nz oa lc lv ob oc le lz od oe lg of bi translated">演示</h2><p id="4753" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">让我们尝试创建一个令牌，然后使用我们的新函数对其进行验证。</p><figure class="mo mp mq mr gt is"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="nr ns gj gh gi nt nu bd b be z dk">Demo of signing and verifying a token</figcaption></figure><p id="ec4c" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">请注意，这还不是最终的实现，我强烈建议您坚持使用已经构建好的模块，因为在创建、签名和验证JWT时，还有更多的事情需要考虑。本文旨在让您对内核的工作原理有一个初步的了解。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="7c3b" class="kq kr jb bd ks kt nj kv kw kx nk kz la kh nl ki lc kk nm kl le kn nn ko lg lh bi translated">让我们构建一个简单的NodeJS库</h1><p id="bc88" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">如果你想快速一瞥最终结果，你可以看看这个<a class="ae mj" href="https://github.com/alexcambose/jwt" rel="noopener ugc nofollow" target="_blank"> GitHub repo </a>。</p><p id="f1ff" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">首先，我们需要创建一个新的NodeJS项目。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="b23b" class="mw kr jb mn b gy mx my l mz na">npm init -y</span></pre><p id="4f7c" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">一旦完成，您应该在您的目录中准备好一个<em class="no"> package.json </em>。这意味着您可以开始安装项目所需的依赖项。</p><p id="6bbd" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">我们将需要Lodash和Base64模块。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="2567" class="mw kr jb mn b gy mx my l mz na">npm i -S base64url lodash</span></pre><h1 id="ebe6" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">我们的入口</h1><p id="40ae" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">让我们首先创建一个index.js文件，它将导出我们的两个主要函数，<code class="fe mk ml mm mn b">verify</code>和<code class="fe mk ml mm mn b">sign</code>。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="5437" class="mw kr jb mn b gy mx my l mz na">// index.js<br/>const verify = require('./verify');<br/>const sign = require('./sign');</span><span id="6e81" class="mw kr jb mn b gy nb my l mz na">module.exports = {<br/>  verify,<br/>  sign,<br/>};</span></pre><h1 id="36bf" class="kq kr jb bd ks kt ku kv kw kx ky kz la kh lb ki lc kk ld kl le kn lf ko lg lh bi translated">符号功能</h1><p id="b22f" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">我们需要一个函数，它接受一个有效载荷、一个秘密和一些附加选项，并返回一个JWT。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="3933" class="mw kr jb mn b gy mx my l mz na">// sign.js<br/>module.exports  = (payloadData, secret, options = {}) =&gt; {<br/>};</span></pre><p id="c5cf" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">由于options对象可以包含头部和有效负载参数/声明，我们只需要在必要时过滤和添加它们。出于简单的原因，我将使用Lodash的<code class="fe mk ml mm mn b">pick</code>和<code class="fe mk ml mm mn b">omit</code>函数。顾名思义，<code class="fe mk ml mm mn b">_.pick(object, ['key1', 'key2', ...])</code>函数将接受一个对象和一个键数组，并将返回一个只包含数组中指定键的新对象。<code class="fe mk ml mm mn b">omit</code>功能与<code class="fe mk ml mm mn b">pick</code>相反。欲了解更多信息，请参见官方文件<a class="ae mj" href="https://lodash.com/docs/4.17.15#pick" rel="noopener ugc nofollow" target="_blank">选择</a>和<a class="ae mj" href="https://lodash.com/docs/4.17.15#omit" rel="noopener ugc nofollow" target="_blank">省略</a>。</p><p id="81d7" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">符号功能的起点</p><p id="edec" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">在设置了头部和有效载荷之后，是时候看看我们如何生成签名了。在本指南中，我们将重点介绍如何使用HMACSHA256算法生成签名。这可以使用本机<code class="fe mk ml mm mn b">crypto</code>模块来完成。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="2373" class="mw kr jb mn b gy mx my l mz na">const crypto =  require('crypto');<br/>// ...<br/>const signature = crypto.createHmac('sha256', secret).update(`${encodedHeader}.${encodedPayload}`).digest('base64');</span></pre><p id="6ea0" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">一些潜在的小改进将是根据<code class="fe mk ml mm mn b">exp</code>声明中提供的秒数自动计算到期日期，并在没有指定秘密的情况下自动将标题<code class="fe mk ml mm mn b">alg</code>设置为<code class="fe mk ml mm mn b">none</code>。</p><p id="8ccf" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">用于计算<code class="fe mk ml mm mn b">exp</code>索赔</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="dfdb" class="mw kr jb mn b gy mx my l mz na">if (options.exp) {<br/>  options.exp += Math.round(new Date().getTime() / 1000);<br/>}</span></pre><p id="23f2" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">并且在没有提供秘密的情况下自动将<code class="fe mk ml mm mn b">alg</code>设置为none(并且还返回没有签名的令牌)</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="98d7" class="mw kr jb mn b gy mx my l mz na">if (!secret || header.alg === 'none') {<br/>  header.alg = 'none';<br/>  const encodedHeader = base64url(JSON.stringify(header));</span><span id="559f" class="mw kr jb mn b gy nb my l mz na">return `${encodedHeader}.${encodedPayload}.`;<br/>}</span></pre><p id="6fba" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">最终的工作代码如下所示:</p><p id="24fe" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">最终符号函数</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="05bf" class="kq kr jb bd ks kt nj kv kw kx nk kz la kh nl ki lc kk nm kl le kn nn ko lg lh bi translated">验证功能</h1><p id="bf74" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">verify函数需要一个令牌和一个秘密，并检查签名是否正确。尽管不是必须的，我们也可以对有效载荷进行base64Url解码，以备将来使用。</p><p id="ca18" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">签名验证意味着，如果我们用秘密对给定的报头和有效载荷进行签名，结果将与令牌中提供的签名相同。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="dcd5" class="mw kr jb mn b gy mx my l mz na">// recalculate the signature based on the header and payload<br/>const signature = crypto.createHmac('sha256', secret).update(`${tokenHeader}.${tokenPayload}`).digest('base64');</span><span id="50fc" class="mw kr jb mn b gy nb my l mz na">// the essential part, checking if the signatures match<br/>if (base64url.fromBase64(signature) !== tokenSignature) {<br/>  throw new Error('Invaid signature');<br/>}</span></pre><p id="65c0" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">我要再次指出，签名基本上是一个散列函数，它以报头+有效载荷+秘密作为输入，其中任何一部分的改变都会完全改变结果散列。</p><p id="6b8b" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">除了检查签名是否正确之外，由于我们添加了<code class="fe mk ml mm mn b">exp</code>索赔计算，我们还可以在这里检查基于当前日期的令牌是否仍然有效。</p><pre class="mo mp mq mr gt ms mn mt mu aw mv bi"><span id="a247" class="mw kr jb mn b gy mx my l mz na">// if the `exp` claim is set, verify if it's not expired<br/>if (payload.exp &amp;&amp; payload.exp &lt; Date.now()) {<br/>  throw new Error('Expired token');<br/>}</span></pre><p id="89bf" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">最终的验证函数如下所示:</p><p id="27a5" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">验证功能</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h2 id="bc95" class="mw kr jb bd ks nv nw dn kw nx ny dp la lr nz oa lc lv ob oc le lz od oe lg of bi translated">演示</h2><p id="ae87" class="pw-post-body-paragraph li lj jb lk b ll lm kc ln lo lp kf lq lr ls lt lu lv lw lx ly lz ma mb mc md ij bi translated">让我们尝试创建一个令牌，然后使用我们的新函数来验证它。</p><p id="3962" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">签名和验证令牌的演示</p><p id="cd30" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">请注意，这还不是最终的实现，我强烈建议您坚持使用已经构建好的模块，因为在创建、签名和验证JWT时，还有更多的事情需要考虑。本文旨在让您对内核的工作原理有一个初步的了解。</p><p id="9b9d" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">你可以在<a class="ae mj" href="https://github.com/alexcambose/jwt" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到源代码。</p><p id="733d" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated">感谢阅读！</p><p id="4116" class="pw-post-body-paragraph li lj jb lk b ll me kc ln lo mf kf lq lr mg lt lu lv mh lx ly lz mi mb mc md ij bi translated"><em class="no">附:如果你喜欢这篇文章，点击推荐按钮或与朋友分享，这将意味着很多。</em></p></div></div>    
</body>
</html>