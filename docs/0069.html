<html>
<head>
<title>How to detect a sequence of keystrokes in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何检测JavaScript中的击键序列</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-detect-a-sequence-of-keystrokes-in-javascript-83ec6ffd8e93?source=collection_archive---------3-----------------------#2019-01-28">https://javascript.plainenglish.io/how-to-detect-a-sequence-of-keystrokes-in-javascript-83ec6ffd8e93?source=collection_archive---------3-----------------------#2019-01-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1c53bb452c74363fc6a0f0d6d692c4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3w4fVWLvNPtxYDq0"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@lemonzandtea?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aleksandar Cvetanovic</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6b59" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript最常用的特性之一是它能够对用户与网页交互时可能发生的各种事件做出反应。事实上，这正是JavaScript出现时的想法，通过添加一些交互性来使网页变得动态。有了JavaScript，我们可以在用户点击页面的特定部分、按键、鼠标移动、页面加载、元素聚焦等情况下做出反应。</p><blockquote class="ky kz la"><p id="7638" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">查看MDN页面，获取所有可用JavaScript事件的列表<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/Events" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="84c4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">即使今天JavaScript可以用来做更多的事情，这种为网页添加交互性的基本功能仍然被广泛用于为用户提供丰富有趣的体验。</p><p id="42e5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在本文中，我们将研究如何使用JavaScript对键盘事件做出反应，特别是如何对用户输入的特定按键序列做出反应。因此，当用户按下一个组合键时，网页可能会显示一些内容，比如打开一个菜单或一个模式，它可以改变页面的样式或执行任何其他你可以想象的JavaScript功能范围内的操作。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi lf"><img src="../Images/f4abeb98fbe904c36875c91e54088893.png" data-original-src="https://miro.medium.com/v2/resize:fit:768/1*mY6ZUX9rxe6bPEirIjpOZw.gif"/></div></figure><p id="5d8e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lb">在我们开始之前，我只想指出我使用了ES6的一些特性，如</em><code class="fe lk ll lm ln b"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" rel="noopener ugc nofollow" target="_blank"><em class="lb">const</em></a></code><em class="lb"/><code class="fe lk ll lm ln b"><a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="noopener ugc nofollow" target="_blank"><em class="lb">let</em></a></code><em class="lb">，</em> <a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> <em class="lb">传播运算符</em> </a> <em class="lb"> ( </em> <code class="fe lk ll lm ln b"><em class="lb">...</em></code> <em class="lb">)，</em> <a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank"> <em class="lb">箭头函数</em> </a> <em class="lb">，</em> <a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_2015_support_in_Mozilla" rel="noopener ugc nofollow" target="_blank"> <em class="lb">等。如果您不熟悉这些，请查看提供的链接了解更多信息。</em></a></p><h1 id="7c79" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">我们在建造什么？</h1><p id="ced5" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">对于本文，我决定让页面上的一个元素根据用户输入的按键顺序改变其背景图像。所以我们基本上是处理造型，没有太花哨。我们还将添加一些文本更新，以使演示更加丰富，并为用户提供更多信息。</p><p id="84ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我的想法是使用旧FPS游戏《毁灭战士2》中用作作弊代码的关键序列。基本上，当用户键入一个组合键时，游戏会给用户带来一些好处，比如更多的弹药，更多的健康，刀枪不入等等。</p><p id="018c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们将要构建的示例中，我们将使页面上某个元素的背景图像根据用户键入的按键序列而改变。你可以在这里看到并尝试演示<a class="ae jz" href="https://gruximillian.github.io/sequential-keybinding/" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="cf35" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">基本项目</h1><p id="992f" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">为了只关注JavaScript，我为这个项目创建了完整的HTML和CSS，并链接了只包含控制台日志的JavaScript文件，以确保它能够工作。你可以在这里下载初始项目文件<a class="ae jz" href="https://github.com/Gruximillian/sequential-keybinding/tree/01-project-structure" rel="noopener ugc nofollow" target="_blank">或者你可以创建你自己的文件，如果你愿意的话。</a></p><p id="fa0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是我们最初拥有的JavaScript内容的快速分解。</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="8d8b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这非常简单，我们在文档中添加一个事件监听器，等待DOM完全加载，然后调用回调函数。回调函数目前只有<code class="fe lk ll lm ln b">'use strict'</code>语句和一个控制台日志来验证文件是否正确链接到HTML页面。</p><blockquote class="ky kz la"><p id="e937" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">我们可以省略这个事件侦听器和传递给它的回调，但是脚本文件应该放在<code class="fe lk ll lm ln b">body</code> HTML元素的末尾，以确保当javascript开始执行时DOM被完全加载。如果你选择这样做，请随意。这只是我喜欢的做法，好处是它还将所有JavaScript代码封装到一个函数中，避免了全局范围的污染。</p></blockquote><h2 id="b6ef" class="mt lp in bd lq mu mv dn lu mw mx dp ly kl my mz mc kp na nb mg kt nc nd mk ne bi translated">聆听关键事件</h2><p id="2900" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">下一步是检测用户何时按键。我们使用与添加<code class="fe lk ll lm ln b">DOMContentLoaded</code>事件监听器相同的方法，但是现在我们将指定一个不同的事件名称。有三个<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/Events#Keyboard_Events" rel="noopener ugc nofollow" target="_blank">键盘事件</a>我们可以指定:<code class="fe lk ll lm ln b">keydown</code>、<code class="fe lk ll lm ln b">keyup</code>和<code class="fe lk ll lm ln b">keypress</code>。</p><ul class=""><li id="6cb4" class="nf ng in kc b kd ke kh ki kl nh kp ni kt nj kx nk nl nm nn bi translated"><code class="fe lk ll lm ln b">keydown</code> -按键时立即触发</li><li id="1ef5" class="nf ng in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated"><code class="fe lk ll lm ln b">keyup</code> -释放按键时触发</li><li id="c532" class="nf ng in kc b kd no kh np kl nq kp nr kt ns kx nk nl nm nn bi translated"><code class="fe lk ll lm ln b">keypress</code> -按住键的同时持续发射</li></ul><p id="c1a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从这个描述中我们可以立即看出<code class="fe lk ll lm ln b">keypress</code>绝对不适合我们的目的。那就只剩下<code class="fe lk ll lm ln b">keydown</code>和<code class="fe lk ll lm ln b">keyup</code>了。在我们的例子中，这两种方法都很好，但在不同的情况下，其中一种可能比另一种更合适，所以你需要评估情况并做出相应的选择。</p><p id="12af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们在这里能注意到的唯一区别是，如果我们使用<code class="fe lk ll lm ln b">keyup</code>，可能会感觉有点滞后，而<code class="fe lk ll lm ln b">keydown</code>确实感觉反应很快。我会选择<code class="fe lk ll lm ln b">keydown</code>，但是既然用<code class="fe lk ll lm ln b">keyup</code>也能达到同样的效果，那就随意使用你更喜欢的事件吧。</p><p id="5713" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们添加事件监听器并删除控制台日志:</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="38e5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里有两件重要的事情需要注意。首先，我们已经向<code class="fe lk ll lm ln b">addEventListener</code>提供了<code class="fe lk ll lm ln b">keydown</code>事件名称，并且我们正在向事件处理程序回调函数提供<code class="fe lk ll lm ln b">event</code>参数。我们将需要那个<code class="fe lk ll lm ln b">event</code>参数来检查哪个键被按下了。</p><p id="cbe0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，要获取被按下的键，我们可以访问<code class="fe lk ll lm ln b">event</code>对象的<code class="fe lk ll lm ln b">key</code>属性:</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><blockquote class="ky kz la"><p id="63b2" class="ka kb lb kc b kd ke kf kg kh ki kj kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="kc io">提示:</strong>要查看<code class="fe lk ll lm ln b">event</code>对象的哪些属性可用，只需执行<code class="fe lk ll lm ln b">console.log(event)</code>并查看记录的对象。我知道这似乎是显而易见的，但如果你是一个初学者，你可能会尝试在网上寻找可用的选项，这很好，但答案通常只是一个控制台日志。</p></blockquote><p id="c4be" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">得到<code class="fe lk ll lm ln b">event.key</code>后，我们将其转换为小写，因为让这些快捷键不区分大小写会很好。不会每次都这样，但这次，完全没问题。</p><p id="0582" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您打开浏览器控制台，单击页面上的后退并尝试键入一些内容，您可以看到您按下的键已记录到控制台。但是如果你注意的话，你可能会注意到它记录了任何被按下的键，比如<code class="fe lk ll lm ln b">Enter</code>、<code class="fe lk ll lm ln b">Delete</code>、<code class="fe lk ll lm ln b">Backspace</code>等等。也被记录下来。这很好，也很有用，但在这种情况下，我只想使用字母和数字。</p><p id="84a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，让我们检查被按下的键是字母还是数字。</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="2ce7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通过创建包含我们感兴趣的所有字符的<code class="fe lk ll lm ln b">charList</code>变量，我们能够检查<code class="fe lk ll lm ln b">key</code>是否出现在<code class="fe lk ll lm ln b">charList</code>字符串中，如果没有，我们简单地从函数返回而不记录字符。</p><p id="da76" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们正在监听按键事件，并且能够只过滤我们感兴趣的按键，是时候看看如何保存输入的按键序列了。</p><h2 id="db40" class="mt lp in bd lq mu mv dn lu mw mx dp ly kl my mz mc kp na nb mg kt nc nd mk ne bi translated">保存输入的按键序列</h2><p id="8549" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">为了保存输入的按键序列，我们需要添加一个变量来存储该序列，并且我们可以在感兴趣的每个按键事件上更新该变量。</p><p id="547a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用一个字符串来连接键，但是我们也可以使用一个数组来存储单独的键作为数组项。在这个简单的用例中，我们使用什么并不重要，但是我将使用数组方法。</p><p id="5fac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在需要连接大量字符串的情况下，数组方法是字符串连接的一种推荐方法，它还允许我们在需要时使用所有的数组方法。</p><p id="098c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们创建一个名为<code class="fe lk ll lm ln b">buffer</code>的变量，最初是一个空数组，并将新密钥推入其中。</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="bdf0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们在<code class="fe lk ll lm ln b">keydown</code>事件监听器中定义了<code class="fe lk ll lm ln b">buffer</code>数组，它将在每次按键时被重置，输入的按键序列将会丢失。因此，我们需要在<code class="fe lk ll lm ln b">keydown</code>事件监听器之外定义它。现在我们能够保存所有输入的密钥。</p><p id="6a55" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，如果我们查看日志，我们可以注意到，现在我们一直在保存键，并且数组只是随着新键的按下而增长。查看gif下图看结果。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nt"><img src="../Images/cc1b0d81774df8b2dec8e3cb94fbf82a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*Xi38dQwHETPTMx9Bs4WkDQ.gif"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">We are constantly adding keystrokes into the buffer array</figcaption></figure><p id="c76b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看在写入“hello”和一些延迟之后，当我继续输入时，它仍然具有数组中所有先前的值。这对我们想要的东西不是很有用。在用户输入最后一个键之后经过一定时间后，重置输入键的列表将是有益的。</p><p id="6abd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了实现这个条件，我们可以使用最后两次按键之间的时间间隔。如果这个时间间隔长于指定的时间量，那么我们将重置<code class="fe lk ll lm ln b">buffer</code>数组。让我们接下来做那件事。</p><h2 id="2af1" class="mt lp in bd lq mu mv dn lu mw mx dp ly kl my mz mc kp na nb mg kt nc nd mk ne bi translated">限制按键之间的时间间隔</h2><p id="3d18" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">为此，我们需要比较上次击键和当前击键发生的时间，然后检查它们之间的时间是否大于某个期望的时间延迟，比如1秒、0.5秒，只要你觉得最方便。</p><p id="e353" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们至少需要一个新变量来保存最后一次击键的时间。为了能够检查该值，我们需要在事件侦听器之外定义变量，然后在击键发生后更新它。</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="9e11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们引入了两个新变量，<code class="fe lk ll lm ln b">lastKeyTime</code>和<code class="fe lk ll lm ln b">currentTime</code>。我们可以只用<code class="fe lk ll lm ln b">lastKeyTime</code>来做，但是有了<code class="fe lk ll lm ln b">currentTime</code>变量就更容易推理了。让我们看看我们在这里做了什么。</p><p id="5893" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们定义了<code class="fe lk ll lm ln b">lastKeyTime</code>变量并用一个当前时间值初始化它。我们必须初始化它，因为我们需要一些值来执行下面的计算。我们可以在这里使用零作为值，但是为了保持一致，我们使用当前的时间值。</p><p id="b746" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，我们定义了<code class="fe lk ll lm ln b">currentTime</code>变量，并用当前时间初始化它。此时有人可能会问为什么两个变量有相同的值？！记住这些只是初始值，至少对于<code class="fe lk ll lm ln b">lastKeyTime</code>是这样的。我们需要在每次击键后更新该值。注意<code class="fe lk ll lm ln b">lastKeyTime</code>是在事件监听器之外初始化的，也就是说，只初始化一次，而<code class="fe lk ll lm ln b">currentTime</code>会在每次击键时重新初始化。</p><p id="42af" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们有了一个重要的部分，检查击键之间是否经过了足够的时间。如果有，我们要重置<code class="fe lk ll lm ln b">buffer</code>变量，这个数组保存用户按下的字符。</p><p id="4b53" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了进行检查，我们只需从<code class="fe lk ll lm ln b">currentTime</code>变量中减去<code class="fe lk ll lm ln b">lastKeyTime</code>，并检查结果是否大于某个数字。在本例中，该数字是1000，即1000毫秒或1秒。这是一个很好的起始值，以后可以更改它来更好地调整体验。</p><p id="f223" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，如果条件<code class="fe lk ll lm ln b">currentTime - lastKeyTime &gt; 1000</code>为真，我们将<code class="fe lk ll lm ln b">buffer</code>重置为空数组:<code class="fe lk ll lm ln b">buffer = []</code>；之后，<code class="fe lk ll lm ln b">buffer</code>将收到一个新的密钥，但它将是数组中唯一的一个。</p><p id="3464" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们需要做的最后一件事是更新<code class="fe lk ll lm ln b">lastKeyTime</code>值。我们简单地将其值设置为与<code class="fe lk ll lm ln b">currentTime</code>值相同。在下一次击键时，<code class="fe lk ll lm ln b">lastKeyTime</code>将保存上一次击键发生的时间，而<code class="fe lk ll lm ln b">currentTime</code>将获得一个新值。</p><h2 id="795b" class="mt lp in bd lq mu mv dn lu mw mx dp ly kl my mz mc kp na nb mg kt nc nd mk ne bi translated">更新背景图像</h2><p id="f802" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">最后，我们准备做我们想要做的，根据用户输入的按键顺序改变背景。</p><p id="04a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果用户输入了正确的键序列，我们需要抓取页面上的一个元素，并根据用户输入更新其背景。看来我们需要检查一下正确的按键顺序。</p><p id="8f83" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然在大多数情况下这几乎肯定是对的，但在这种情况下没有必要。这个问题的本质允许我们跳过检查，如果键序列不正确会发生什么。</p><p id="2583" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我这么说是什么意思？我来详细解释一下。</p><p id="ea6b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们想用CSS改变背景图片，我们需要更新图片的url。如果图像的名称与按键序列相同，那么我们需要做的就是读取输入，使其成为一个字符串，并将其设置为背景图像的url。</p><p id="3d93" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有趣的是，如果图像不存在，背景就不会显示出来。这意味着，如果我们确实显示了一个图像，然后输入了与现有图像url不匹配的内容，背景图像就会消失。</p><p id="893d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，我可以接受，因此不需要检查url是否正确。但是如果我们想保留当前显示的图像，那么检查将是必要的。让我们用最简单的方法，也就是不用那张支票。</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ac2f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经移除了<code class="fe lk ll lm ln b">console.log</code>，并添加了一个查询来获取显示背景的元素，在下一行中我们应用了背景url。</p><p id="b711" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该url结构将取决于您的项目结构，在这种情况下，图像位于“images”文件夹中，并且是jpg格式。这里需要注意的是，我们需要从<code class="fe lk ll lm ln b">buffer</code>数组中创建一个字符串，这样它就可以在图像url中使用。我们只需用一个空字符作为连接字符<code class="fe lk ll lm ln b">buffer.join('')</code>来连接数组元素。</p><p id="c615" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样我们就实现了本文的主要目标。现在，用户可以尝试输入正确的键序列，如果成功，背景将会改变。我们所做的是简单和功能，可以很容易地纳入任何项目。</p><p id="906f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是还是有可能做一些改进的。所以，如果你想在代码中有更多的灵活性，请继续阅读。</p><h1 id="f7aa" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">改进项目</h1><p id="c407" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">从整体上看我们的代码，我们会发现我们使用了一些“全局”变量。全局的意思是，它们在我们脚本的顶层上下文中，包含在<code class="fe lk ll lm ln b">DOMContentLoaded</code>事件监听器函数中，所有其余的代码都在这里，这意味着它们将与我们脚本的顶层上下文中的其他变量混合在一起。</p><p id="5a1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是变量<code class="fe lk ll lm ln b">buffer</code>和<code class="fe lk ll lm ln b">lastKeyTime</code>的声明不能放在<code class="fe lk ll lm ln b">keydown</code>事件监听器里面，因为那会在每次击键时重置它们并破坏功能。</p><h2 id="9fcb" class="mt lp in bd lq mu mv dn lu mw mx dp ly kl my mz mc kp na nb mg kt nc nd mk ne bi translated">将代码包装成一个函数</h2><p id="acdb" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">为了隔离控制关键事件的代码，我们可以将变量和<code class="fe lk ll lm ln b">keydown</code>事件监听器放入一个单独的函数中。</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="0427" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样一来，我们的<code class="fe lk ll lm ln b">keyMapper</code>函数就完全独立于脚本中的其他代码，甚至可以从另一个文件中导入，以使事情更加清晰。但是现在我们有了这个功能，我们可以看到其他改进的可能性。</p><h2 id="6e84" class="mt lp in bd lq mu mv dn lu mw mx dp ly kl my mz mc kp na nb mg kt nc nd mk ne bi translated">移除硬编码值</h2><p id="dc67" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">为了使函数更加灵活，我们可以做的一件重要事情是删除我们使用的任何硬编码值，而是将它们作为参数传递给函数。</p><p id="18ca" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要的硬编码的最重要的值是背景容器元素的选择器(<code class="fe lk ll lm ln b">#background</code>)，图像url的组成部分，以及检查中的时间延迟值<code class="fe lk ll lm ln b">if (currentTime - lastKeyTime &gt; 1000)</code>。还有一个<code class="fe lk ll lm ln b">charList</code>变量，但是尽管我们也可以将它作为参数传递，并精确地控制允许哪些字符，但为了简化起见，我们可以暂时不使用它。</p><p id="5be6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相反，我们可以用<code class="fe lk ll lm ln b">charList</code>将它从事件监听器中移出，放到<code class="fe lk ll lm ln b">keyMapper</code>函数中，以避免在每次击键时都声明它。所以，让我们做所有这些改变。</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="fdec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在,<code class="fe lk ll lm ln b">keyMapper</code>函数有四个参数，这使我们能够更容易地定制它。现在，当一个函数有三个以上的参数时，它开始感觉有点笨拙，很容易忘记或混淆一些。我们稍后会解决这个问题，但是现在让我们先这样做。</p><h2 id="4c13" class="mt lp in bd lq mu mv dn lu mw mx dp ly kl my mz mc kp na nb mg kt nc nd mk ne bi translated">创建一个回调函数</h2><p id="c92b" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">我们脚本的预期动作是更新页面上元素的背景。这发生在脚本的最后一行。但是也许你希望在用户输入一个特定的按键序列后发生完全不同的事情，也许播放一个声音，打开一个对话框或者你能想到的任何事情。</p><p id="2858" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们当前版本的脚本中，我们只能更新背景。但是，如果我们能够很容易地告诉我们的脚本我们是否想要做其他事情，也就是说，使用<code class="fe lk ll lm ln b">keyMapper</code>函数来执行我们已经定义的特定函数，那就太好了。为了做到这一点，我们可以定义一个函数，传递给<code class="fe lk ll lm ln b">keyMapper</code>函数，然后从那里执行它。</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="3b02" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，新的<code class="fe lk ll lm ln b">keyMapper</code>函数接受了一个参数(dooh！)，<code class="fe lk ll lm ln b">callback</code>，这是一个按键按下后我们想要执行的功能。在<code class="fe lk ll lm ln b">keyMapper</code>函数的最后一行，我们调用了<code class="fe lk ll lm ln b">callback</code>函数，并传递给它一些它需要的变量。当调用<code class="fe lk ll lm ln b">keyMapper</code>时，我们传递给它名为<code class="fe lk ll lm ln b">updateBackground</code>的函数，它是在<code class="fe lk ll lm ln b">keyMapper</code>函数之后声明的。</p><p id="de2c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">函数<code class="fe lk ll lm ln b">updateBackground</code>基本上包含了我们已经删除的<code class="fe lk ll lm ln b">keyMapper</code>的最后两行。这样，我们就完全分离了保存按键序列和获取该序列后执行的操作。</p><p id="26d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们编写一个新函数，并将其作为回调传递给<code class="fe lk ll lm ln b">keyMapper</code>而不是<code class="fe lk ll lm ln b">updateBackground</code>函数，我们可以得到完全不同的行为。</p><h2 id="9fe0" class="mt lp in bd lq mu mv dn lu mw mx dp ly kl my mz mc kp na nb mg kt nc nd mk ne bi translated">后退一步</h2><p id="d0fc" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">开始困扰我的一件事是，我们现在有五个参数用于<code class="fe lk ll lm ln b">keyMapper</code>函数，四个参数用于<code class="fe lk ll lm ln b">updateBackground</code>函数，并且<code class="fe lk ll lm ln b">updateBackground</code>的所有参数在传递给<code class="fe lk ll lm ln b">updateBackground</code>函数之前也被传递给<code class="fe lk ll lm ln b">keyMapper</code>函数。</p><p id="21d2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然我们已经将回调函数从<code class="fe lk ll lm ln b">keyMapper</code>函数中分离出来，那么在<code class="fe lk ll lm ln b">updateBackground</code>函数中简单地硬编码所需的值是有意义的，因为这样我们将包含回调函数中所需的所有信息，并且我们可以只用一个参数调用它，即<code class="fe lk ll lm ln b">keyMapper</code>提供的键序列。</p><p id="1711" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这也意味着只有两个参数可以调用<code class="fe lk ll lm ln b">keyMapper</code>函数，即<code class="fe lk ll lm ln b">keystrokeDelay</code>和<code class="fe lk ll lm ln b">callback</code>函数。以下是更新后的脚本:</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="1ed7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，它看起来更清晰了，功能和参数被很好地分开了。</p><p id="431b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">不过，我们可以做得比这更好。</p><p id="fadc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可能已经注意到在<code class="fe lk ll lm ln b">keyMapper</code>函数中还有另一个硬编码的字符串，即<code class="fe lk ll lm ln b">keydown</code>事件名称。如果我们决定让<code class="fe lk ll lm ln b">keyMapper</code>处理<code class="fe lk ll lm ln b">keyup</code>事件，我们需要直接在函数内部修改它。这不一定是一个大问题，但如果我们也能控制波谷参数，那就太好了。</p><p id="7656" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，我们给<code class="fe lk ll lm ln b">keyMapper</code>函数添加第三个参数？</p><p id="d4dd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以这样做，但让我们更进一步，让它只是一个参数。我们来介绍一下…</p><h2 id="721a" class="mt lp in bd lq mu mv dn lu mw mx dp ly kl my mz mc kp na nb mg kt nc nd mk ne bi translated">选项对象</h2><p id="5485" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">为函数提供参数的一个非常好的方法是为对象提供保存参数值的属性。在有许多参数要传递给函数的情况下，尤其是在这些参数是可选的并且表示函数的某种配置的情况下，这是非常有用的。</p><p id="76b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们需要添加的<code class="fe lk ll lm ln b">keyMapper</code>函数、<code class="fe lk ll lm ln b">keystrokeDelay</code>和新的<code class="fe lk ll lm ln b">eventType</code>的参数看起来确实像配置值。使用对象向函数传递参数的一个额外好处是参数的顺序无关紧要。</p><p id="c8ab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在可以这样做:</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ec8c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lk ll lm ln b">options</code>对象现在保存要监听的事件的名称和击键之间的时间延迟。在<code class="fe lk ll lm ln b">keyMapper</code>函数中，我们也有这两行:</p><pre class="lg lh li lj gt nu ln nv nw aw nx bi"><span id="0868" class="mt lp in ln b gy ny nz l oa ob">const eventType = options &amp;&amp; options.eventType || 'keydown';<br/>const keystrokeDelay = options &amp;&amp; options.keystrokeDelay || 1000;</span></pre><p id="a793" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是我们使参数可选的地方。如果值是通过<code class="fe lk ll lm ln b">options</code>对象提供的，它们将被使用，如果不是，我们将使用缺省值。您可以通过更改<code class="fe lk ll lm ln b">options</code>对象中的值来进行测试。您可以在调用<code class="fe lk ll lm ln b">keyMapper</code>函数时完全省略<code class="fe lk ll lm ln b">options</code>对象，它仍将使用默认值。</p><p id="8d4f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们也可以通过options对象传递回调函数，但是因为没有这个函数，我们就没有任何合理的功能，所以将它作为一个单独的必需参数传递似乎更好。</p><p id="8b5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一个需要注意的变化是<code class="fe lk ll lm ln b">keyMapper</code>函数的参数顺序颠倒了。没有必要这样做，但是如果一个参数是可选的，它通常在必需的参数之后提供，否则如果你想省略可选的<code class="fe lk ll lm ln b">options</code>参数，你需要像这样调用<code class="fe lk ll lm ln b">keyMapper</code>函数:</p><pre class="lg lh li lj gt nu ln nv nw aw nx bi"><span id="8a27" class="mt lp in ln b gy ny nz l oa ob">keyMapper(null, updateBackground); // null is the value for the options object</span></pre><h2 id="9012" class="mt lp in bd lq mu mv dn lu mw mx dp ly kl my mz mc kp na nb mg kt nc nd mk ne bi translated">添加状态管理</h2><p id="67ea" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">不，这不会是redux或任何其他状态管理库，为这样的小脚本添加整个库是愚蠢的。我们将简单地将保存脚本状态的变量<code class="fe lk ll lm ln b">buffer</code>和<code class="fe lk ll lm ln b">lastKeyTime</code>组织到一个对象中，并在每次更改时更新它。</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="4ed1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在键序列和最后一次击键的时间被保存为<code class="fe lk ll lm ln b">state</code>对象的<code class="fe lk ll lm ln b">buffer</code>属性和<code class="fe lk ll lm ln b">lastKeyTime</code>属性。在每次击键时，我们将<code class="fe lk ll lm ln b">buffer</code>属性复制到本地<code class="fe lk ll lm ln b">buffer</code>变量中，并相应地更新该变量。</p><p id="3715" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">之后，用本地<code class="fe lk ll lm ln b">buffer</code>变量和<code class="fe lk ll lm ln b">currentTime</code>变量更新状态。最后，用当前的<code class="fe lk ll lm ln b">buffer</code>值调用<code class="fe lk ll lm ln b">callback</code>。</p><p id="dde2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里需要注意的一点是，我们从不直接更新现有的状态对象及其<code class="fe lk ll lm ln b">buffer</code>属性，而是总是为<code class="fe lk ll lm ln b">state</code>创建新对象，为<code class="fe lk ll lm ln b">buffer</code>创建新数组。这被称为状态的不可变更新，并且是更新状态的优选方式。我们从不改变以前的值/对象，我们总是给状态分配新的值/对象。</p><p id="cbd5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该行:<code class="fe lk ll lm ln b">buffer = [key];</code>在击键间隔时间超过<code class="fe lk ll lm ln b">keystrokeDelay</code>定义的情况下重置<code class="fe lk ll lm ln b">buffer</code>。</p><p id="172c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第<code class="fe lk ll lm ln b">buffer = […state.buffer, key];</code>行使用扩展操作符<code class="fe lk ll lm ln b">...</code>用来自状态缓冲区的值填充新数组，然后我们将当前键添加到数组中。这样，缓冲区就更新了。</p><p id="3808" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，行<code class="fe lk ll lm ln b">state = {buffer: buffer, lastKeyTime: currentTime};</code>通过给新对象分配新的<code class="fe lk ll lm ln b">buffer</code>和<code class="fe lk ll lm ln b">lastKeyTime</code>值来更新<code class="fe lk ll lm ln b">state</code>。</p><p id="c6b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在最后一个代码示例中，我删除了字符测试，因为它并没有真正改善脚本的功能，但是当然，您可以随时添加自己的检查来控制脚本的行为。</p><h1 id="aeb3" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">最后一击</h1><p id="2c40" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">我们的剧本现在完成了。我们可以设置选项，创建任何我们想要的回调函数，状态不断更新。总的来说，我们的<code class="fe lk ll lm ln b">keyMapper</code>函数现在非常灵活。</p><p id="0752" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您仔细查看浏览器中的页面，您会注意到在左侧有一列包含一些信息。在该列的下部，您可以看到用户输入的按键序列(“一些按键”)和用户反馈消息(“还没有任何东西”)的占位符。这些目前都没有用，但我们可以很容易地改变这一点。有多种方法可以做到这一点。</p><p id="e2cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最简单的方法是给回调函数<code class="fe lk ll lm ln b">updateBackground</code>添加更多的功能。但是这将会改变函数的功能，它的名字将不能正确描述它的功能。</p><p id="bb7c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们可以在另一个函数中编写新代码，并从<code class="fe lk ll lm ln b">updateBackground</code>函数中调用该函数。这并不是理想的解决方案，但总比直接把与更新背景无关的新代码添加到<code class="fe lk ll lm ln b">updateBackground</code>函数中要好。我们是这样做的:</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="9e0b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一种方法是简单地用<code class="fe lk ll lm ln b">updateUI</code>函数作为回调函数第二次调用<code class="fe lk ll lm ln b">keyMapper</code>:</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="ddce" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当谈到功能分离时，这稍微好一点，但是我们现在有两个事件侦听器，它们基本上做同样的事情。</p><p id="e520" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我们对于关键事件只有一个事件监听器，然后在事件发生时调用我们想要的所有函数，那就太好了。</p><p id="a5b7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以做到这一点，我们只需要将所有这些函数提供给<code class="fe lk ll lm ln b">keyMapper</code>函数，最好的方法是传递一个数组，该数组将保存我们希望在键事件发生时执行的所有回调函数的引用。更新代码来实现这一点非常简单:</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="6079" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，<code class="fe lk ll lm ln b">keyMapper</code>函数现在接收一个函数引用数组:</p><pre class="lg lh li lj gt nu ln nv nw aw nx bi"><span id="fea0" class="mt lp in ln b gy ny nz l oa ob">keyMapper([updateBackground, updateUI], options);</span></pre><p id="9e3e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后在每次<code class="fe lk ll lm ln b">buffer</code>更新时，所有这些函数都会被调用:</p><pre class="lg lh li lj gt nu ln nv nw aw nx bi"><span id="e610" class="mt lp in ln b gy ny nz l oa ob">callbackList.forEach(callback =&gt; callback(buffer));</span></pre><p id="ffb5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为关键事件添加新功能现在就像编写一个函数来执行我们想要的功能，并在我们调用它时将其引用传递给<code class="fe lk ll lm ln b">keyMapper</code>函数一样简单。</p><h2 id="9b04" class="mt lp in bd lq mu mv dn lu mw mx dp ly kl my mz mc kp na nb mg kt nc nd mk ne bi translated">更新(2019年2月21日)</h2><p id="7459" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">评论中提到，用户可以输入一个像<code class="fe lk ll lm ln b">../myimage</code>这样的路径，这将访问目录结构中上一级的某个文件…如果它存在的话。为了避免使用除字母和数字以外的任何字符，这几行被添加到<code class="fe lk ll lm ln b">updateBackground</code>功能中:</p><pre class="lg lh li lj gt nu ln nv nw aw nx bi"><span id="2d6e" class="mt lp in ln b gy ny nz l oa ob">const validKeys = keySequence.every(key =&gt; !isNaN(parseInt(key)) || key.toLowerCase() !== key.toUpperCase());</span><span id="19c6" class="mt lp in ln b gy oc nz l oa ob">if (!validKeys) return;</span></pre><p id="8618" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另外，<code class="fe lk ll lm ln b">keyMapper</code>函数现在返回没有转换成小写的键。这种转换现在发生在需要这样做的回调函数中，比如<code class="fe lk ll lm ln b">updateUI</code>函数。</p><h2 id="d828" class="mt lp in bd lq mu mv dn lu mw mx dp ly kl my mz mc kp na nb mg kt nc nd mk ne bi translated"><strong class="ak">更新(2019年2月15日)——JavaScript说这是真的(0 ==假)，这(' ==假)</strong></h2><p id="7cf1" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">在<a class="ae jz" href="https://medium.com/@Shrekgrinch/might-want-to-consider-dumping-the-truthy-checking-for-the-options-parameters-4fe666d5909d" rel="noopener">评论</a>中提醒我在JavaScript中使用真值求值的危险后，我决定解决这个问题并修复有问题的部分。</p><p id="8f13" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">问题在于以下几个方面:</p><pre class="lg lh li lj gt nu ln nv nw aw nx bi"><span id="f3de" class="mt lp in ln b gy ny nz l oa ob">const eventType = options &amp;&amp; options.eventType || 'keydown';<br/>const keystrokeDelay = options &amp;&amp; options.keystrokeDelay || 1000;</span></pre><p id="2f9f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我已经提到的，这将使用来自options对象的值，如果它存在，如果它不存在，那么它将使用默认值。除了它不会在所有情况下都这样做。如果由于某种原因<code class="fe lk ll lm ln b">options.eventType</code>和<code class="fe lk ll lm ln b">options.keystrokeDelay</code>的值被评估为falsy，那么这些值将不会被使用，它将跳转到默认值。</p><p id="49c7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果这些属性不存在，我们期望得到值<code class="fe lk ll lm ln b">undefined</code>，这将评估为假，然后我们将使用默认值。值<code class="fe lk ll lm ln b">null</code>也可以评估为false，这也是可以的。</p><p id="47a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们没有考虑变量的类型。这是因为，根据变量的类型，我们可能会出现其他错误值。</p><p id="5982" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们期望第一个属性<code class="fe lk ll lm ln b">options.eventType</code>是一个字符串。但是如果是空字符串呢？JavaScript说，在这种比较中，空字符串的计算结果应该是<code class="fe lk ll lm ln b">false</code>。这意味着，如果我们将一个空字符串传递给<code class="fe lk ll lm ln b">options.eventType</code>属性，我们仍然会得到默认的<code class="fe lk ll lm ln b">keydown</code>事件，因为空字符串的计算结果为false。但是，如果我们什么都不通过，那就行不通了！因此，如果在这种情况下，它实际上对我们有利的工作失败的检查，并使用默认的<code class="fe lk ll lm ln b">keydown</code>事件类型。那很好。</p><p id="d5ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第二个属性<code class="fe lk ll lm ln b">options.keystrokeDelay</code>应该是一个数字。在数字的情况下，JavaScript说零应该计算为<code class="fe lk ll lm ln b">false</code>。如果我们想为延迟值传递零，它将不会被接受，它将回落到默认的1000毫秒。但是另一方面，我听到你说“谁能输入得这么快，以至于应该考虑零值呢？”。你是对的，在这种情况下，所有这些都是没有意义的，我们一次只能听一个键。</p><p id="2b35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以，我们在这里也很好，不需要做任何事情？实际上不是。如果提供的数字是负数呢？它当然不会回到过去，在按键发生之前就做出反应，但一旦按键发生，它就会做出反应。基本上，它与将值设置为零是一样的，但是它通过了真实性测试。我们现在看到，我们需要另一个条件，我们需要大于零的数字。现在，我们解决了这个问题，但是如果有人传递像10这样的数字呢？10ms够你连两个键击吗？对我来说不是，这是肯定的。我几乎做不到250毫秒的延迟。从我的角度来看，作为这个应用程序的开发者，我认为没有理由让延迟小于我连接两次击键所需的最小延迟。所以我决定将延迟限制在最少300毫秒。</p><p id="fa60" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是<code class="fe lk ll lm ln b">keyMapper</code>函数的更新代码:</p><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="mr ms l"/></div></figure><p id="25cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我添加了一个函数<code class="fe lk ll lm ln b">hasProperty</code>,它将检查对象上是否存在属性，只有在检查通过后，我们才能继续下一步检查。在<code class="fe lk ll lm ln b">delay</code>线上，你也可以看到<code class="fe lk ll lm ln b">options.keystrokeDelay &gt;= 300</code>检查，它将延迟限制在300毫秒。</p><p id="d2ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我想提到的最后一件事是，如果我们为我们的代码编写适当的测试，我在这一更新部分中谈论的这些问题都可以首先避免。例如，当我们考虑函数可以为<code class="fe lk ll lm ln b">eventType</code>属性获得什么可能的输入时，我们很容易想到空字符串的问题。对于<code class="fe lk ll lm ln b">keystrokeDelay</code>属性也是如此，当考虑可能的输入时，我们可以很快意识到使用零、负数甚至太小的数字都不好。</p><h1 id="689a" class="lo lp in bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml bi translated">结论</h1><p id="9e02" class="pw-post-body-paragraph ka kb in kc b kd mm kf kg kh mn kj kk kl mo kn ko kp mp kr ks kt mq kv kw kx ig bi translated">尽管对特定按键序列作出反应的基本功能是一项简短而简单的任务，但我想更进一步，展示我们如何真正实现一个灵活的功能，使我们能够进行更多的控制。我们通过将回调函数列表和一个选项对象传递给<code class="fe lk ll lm ln b">keyMapper</code>函数实现了这一点。</p><p id="91c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，您可以通过提供更多选项并将代码添加到与这些新选项相关的函数中，使函数更加可定制。</p><p id="250f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">根据你的需要，你可以随意扩展。当然，这样做要合理，因为你希望你的代码可读性强，容易推理。</p><p id="bd2c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望这篇文章给了你一些如何在你的项目中使用它的想法，如果你愿意，请随时在评论中分享它们。</p><p id="9aee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的阅读，新年快乐！</p></div></div>    
</body>
</html>