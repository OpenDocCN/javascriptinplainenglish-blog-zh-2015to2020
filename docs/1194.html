<html>
<head>
<title>JavaScript Type Checking with Flow — Interfaces</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用流接口进行JavaScript类型检查</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-type-checking-with-flow-interfaces-cf6bc61edc16?source=collection_archive---------8-----------------------#2020-02-10">https://javascript.plainenglish.io/javascript-type-checking-with-flow-interfaces-cf6bc61edc16?source=collection_archive---------8-----------------------#2020-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/eebb3781385e3526e22beaae06db00da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dfMpDOCNG01li7SK"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@iamdavid_10?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David Švihovec</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5671" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Flow是一个由脸书开发的类型检查器，用于检查JavaScript数据类型。它有许多内置的数据类型，我们可以用它们来注释变量和函数参数的类型。</p><p id="c0e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何创建接口，通过为多种类型定义公共结构来创建相互兼容的多种类型。</p><h1 id="8ebb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么我们需要界面？</h1><p id="b67b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们需要接口，因为流中的类型是名义上的类型。这意味着它们通过名称来识别，所以我们不能用一种类型替换另一种类型，即使它们具有相同的结构。</p><p id="ce27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2d34" class="mn lc iq mj b gy mo mp l mq mr">class A {<br/>  foo() { return 'a'; }<br/>}</span><span id="6e98" class="mn lc iq mj b gy ms mp l mq mr">class B {<br/>  foo() { return 'b'; }<br/>}</span><span id="5c17" class="mn lc iq mj b gy ms mp l mq mr">const foo: A = new B();</span></pre><p id="f7b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将得到一个错误，因为<code class="fe mt mu mv mj b">A</code>和<code class="fe mt mu mv mj b">B</code>被认为是不兼容的，尽管它们具有相同的结构。</p><p id="4bad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接口可以解决这个问题，因为实现相同接口的两种类型将被认为是相同的:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f32d" class="mn lc iq mj b gy mo mp l mq mr">interface Foo {<br/>  foo(): string;<br/>}</span><span id="ddbc" class="mn lc iq mj b gy ms mp l mq mr">class A implements Foo{<br/>  foo() { return 'a'; }<br/>}</span><span id="2103" class="mn lc iq mj b gy ms mp l mq mr">class B implements Foo{<br/>  foo() { return 'b'; }<br/>}</span><span id="b11d" class="mn lc iq mj b gy ms mp l mq mr">const foo: Foo = new A();<br/>const bar: Foo = new B();</span></pre><p id="5ab1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在代码中，我们将变量或常量的类型设置为接口，然后我们可以将其设置为实现接口的任何类型。</p><p id="1b09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了实现一个接口，我们使用了<code class="fe mt mu mv mj b">implements</code>关键字。这加强了实现接口的类的结构。</p><p id="0438" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以在一个类中实现多个接口。例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="98c4" class="mn lc iq mj b gy mo mp l mq mr">interface Foo {<br/>  foo(): string;<br/>}</span><span id="ecbe" class="mn lc iq mj b gy ms mp l mq mr">interface Bar {<br/>  bar(): number;<br/>}</span><span id="899c" class="mn lc iq mj b gy ms mp l mq mr">class A implements Foo, Bar{<br/>  foo() { return 'a'; }<br/>  bar() { return 1; }<br/>}</span></pre><p id="334b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe mt mu mv mj b">A</code>类需要在<code class="fe mt mu mv mj b">Foo</code>和<code class="fe mt mu mv mj b">Bar</code>接口中都有所有的东西。</p><h1 id="f63f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">接口语法</h1><p id="b739" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">正如我们在上面看到的，我们用关键字<code class="fe mt mu mv mj b">intreface</code>定义了一个接口。例如，我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d7f3" class="mn lc iq mj b gy mo mp l mq mr">interface Foo {</span><span id="edb8" class="mn lc iq mj b gy ms mp l mq mr">}</span></pre><p id="635f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下代码来添加方法:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="eb67" class="mn lc iq mj b gy mo mp l mq mr">interface Foo {<br/>  fooMethod(value: string): number;<br/>}</span></pre><p id="01f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后实现<code class="fe mt mu mv mj b">Foo</code>的任何东西都必须实现<code class="fe mt mu mv mj b">fooMethod</code>，它必须接受一个字符串并返回一个数字。</p><p id="a96d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以添加如下属性:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="841d" class="mn lc iq mj b gy mo mp l mq mr">interface Foo {<br/>  prop: number;<br/>}</span></pre><p id="6aea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以通过编写以下内容使其可选:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="92c2" class="mn lc iq mj b gy mo mp l mq mr">interface <!-- -->Foo <!-- -->{<br/>  prop?: <!-- -->number<!-- -->;<br/>}</span></pre><p id="edd9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接口也可以用索引器属性动态化，我们可以这样定义:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c77d" class="mn lc iq mj b gy mo mp l mq mr">interface Foo {<br/>  [prop: string]: number;<br/>}</span></pre><h1 id="42bb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">接口泛型</h1><p id="3ad3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们还可以向接口添加泛型类型参数。例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ba0c" class="mn lc iq mj b gy mo mp l mq mr">interface Foo&lt;A, B, C&gt; {<br/>  foo: A;<br/>  bar(val: B): C;  <br/>}</span></pre><p id="e77e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们想要使用接口时，我们可以添加实类型来代替泛型类型标记，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7a8e" class="mn lc iq mj b gy mo mp l mq mr">interface Foo&lt;A, B, C&gt; {<br/>  foo: A;<br/>  bar(val: B): C;  <br/>}</span><span id="c053" class="mn lc iq mj b gy ms mp l mq mr">let foo: Foo&lt;number, boolean, string&gt; = {<br/>  foo: 1,<br/>  bar(val: boolean){<br/>    return '';<br/>  }<br/>};</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/e854b863446b93cf7400f3bde3cfb992.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*x7lhONlM00WaxllA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@christianw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christian Wiediger</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3b16" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使接口属性只读和只写</h1><p id="dbb8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过在属性前面添加一个<code class="fe mt mu mv mj b">+</code>符号来使接口中的属性成为只读的。例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="84bf" class="mn lc iq mj b gy mo mp l mq mr">interface Foo {<br/>  +foo: number; <br/>  -bar: number;<br/>}</span></pre><p id="77f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<code class="fe mt mu mv mj b">foo</code>设为只读，将<code class="fe mt mu mv mj b">bar</code>设为只写。</p><p id="025e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只读属性不能被重新分配，所以给定我们上面定义的<code class="fe mt mu mv mj b">Foo</code>接口，如果我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="91d2" class="mn lc iq mj b gy mo mp l mq mr">let obj: Foo = {<br/>  foo: 1,<br/>  bar: 2<br/>}</span><span id="5aa1" class="mn lc iq mj b gy ms mp l mq mr">obj.foo = 2;</span></pre><p id="cf56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会得到一个错误。</p><p id="9036" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只写属性只能被写入，所以我们可以给它赋值:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="934b" class="mn lc iq mj b gy mo mp l mq mr">let obj: Foo = {<br/>  foo: 1,<br/>  bar: 2<br/>}<br/>obj.bar = 2;</span></pre><p id="5753" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们会得到一个错误，如果我们写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="b8b4" class="mn lc iq mj b gy mo mp l mq mr">let y = obj.bar;</span></pre><p id="db3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们只能写入它，而不能读取它的值。</p><p id="2496" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Flow中，接口允许我们定义契约来让其他类实现接口。实现给定接口的类的任何实例都被认为具有兼容的类型。</p><p id="58f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了接口，我们还可以将属性设置为可写和可读。此外，我们可以添加通用类型标记，以便可以重用不同类型的接口。</p><p id="f610" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以向具有索引属性的接口添加动态属性。</p></div></div>    
</body>
</html>