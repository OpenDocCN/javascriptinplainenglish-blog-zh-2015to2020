<html>
<head>
<title>An Introductory to Design Patterns — Create Your Own PubSub Library</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">设计模式入门——创建自己的PubSub库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-pubsub-pattern-33e0e9269bf9?source=collection_archive---------2-----------------------#2019-09-14">https://javascript.plainenglish.io/the-pubsub-pattern-33e0e9269bf9?source=collection_archive---------2-----------------------#2019-09-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7701" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript中的行为设计模式</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/085c4cd271265c9c969c00c600354991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NNBaRmLqMRqxjX1r"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@chernus_tr?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Taras Chernus</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://www.webtips.dev/intro-to-design-patterns-create-your-own-pubsub-library"><div class="gh gi kw"><img src="../Images/49b88c019e9dabb1d8ec32390ba21ac9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*7f4_DYl5W9oa0v9EUcqLYg.png"/></div></a></figure><p id="e059" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">当我们谈论设计模式时，我们指的是软件开发中常见问题的解决方案。</p><p id="2b2e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">模式是关于可重用性的，可重用性帮助我们解决整个程序中可能出现的架构问题，而不管它是用什么语言实现的。因此，它们并不特别依赖于JavaScript，而是独立于语言的。</p><p id="c35c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">设计模式分为三种不同的类型。这些被称为<strong class="kz ir">创造</strong>、<strong class="kz ir">结构</strong>和<strong class="kz ir">行为</strong>模式。每种类型我们都有很多不同的。本文中我们感兴趣的一个被称为发布-订阅或简称为PubSub，通常也称为观察者。</p><p id="f811" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它们经常互换使用，但我们必须区分两者，因为它们并不完全相同。但是在深入研究差异之前，让我们看看它应该解决什么样的问题？</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="aafe" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">问题是</h1><p id="fc2b" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">当我们的应用程序中有不同的模块，我们想在它们之间共享一些数据，但又不想让它们直接依赖于彼此时，问题就出现了。我们需要一个链接来创建一个通信通道。</p><p id="ac03" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">给你一个实际的例子，假设我们有一个销售产品的电子商务网站。我们有<code class="fe mx my mz na b">filtersModule.js</code>处理过滤功能，这显示在多个页面上；<code class="fe mx my mz na b">listView.js</code>和<code class="fe mx my mz na b">gridView.js</code>。每当过滤器更新时，我们都希望通知这两个文件有关更改的信息，这样我们就可以相应地更新产品列表。这可以通过多种方式解决，其中之一就是使用PubSub或Observer模式。现在回到差异。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="a200" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">观察者vs发布者</h1><p id="7c90" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">为了理解两者之间的区别，我们需要先回顾一些命名约定。</p><p id="d546" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们从观察者开始。在观察者模式中，我们有一个<strong class="kz ir">主题</strong>，它跟踪它的依赖者，称为<strong class="kz ir">观察者。</strong>主体可以通知他们任何状态变化，作为回报，观察者可以为我们执行代码块。</p><p id="f4c0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在PubSub中，我们有一个名为<strong class="kz ir"> publisher </strong>的发送者，不像在Observer模式中，他们不持有对他们的观察者(名为<strong class="kz ir"> subscribers、</strong>subscriber)的任何引用，也不被编程为直接向预定义的接收者发送消息。</p><p id="26d0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">强调两者之间的核心区别:在观察者模式中，观察者和主体是相互意识到的，他们被联系在一起。特定的消息被发送给特定的观察者，而在PubSub中，发布者和订阅者不需要互相了解。可以订阅任何已发布的活动。在灵活性方面，PubSub更符合。</p><p id="a585" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nb">如果你对更多的设计模式感兴趣，在</em><a class="ae kv" href="https://www.dofactory.com/javascript/design-patterns" rel="noopener ugc nofollow" target="_blank"><em class="nb">dofactory.com</em></a><em class="nb">中有一个非常整洁的集合，有定义、图表和深入的例子。</em></p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="62c6" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">蓝图</h1><p id="8e2f" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">让我们深入编码。首先，让我们看看我们想要的最终结果是什么。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a6b0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">每当过滤器发生变化时，我们都希望在<code class="fe mx my mz na b">filtersModule.js</code>中发布一个名为<code class="fe mx my mz na b">filterUpdated</code>的事件，传入一个包含所有与变化的过滤器相关的数据的<code class="fe mx my mz na b">data</code>对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="b9df" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在<code class="fe mx my mz na b">gridView.js</code>中，我们通过订阅来监听这个事件，并且我们想要执行一个回调函数，在这个函数中我们对接收到的正在发布的数据进行操作。稍后在我们的应用程序中，每当用户导航到一个没有过滤的页面时，我们也想通过取消订阅<code class="fe mx my mz na b">filterUpdated</code>事件来删除订阅。也就是说，我们已经可以看到我们将需要什么方法。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="1364" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">骷髅</h1><p id="3194" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">从最终结果可以清楚地看出，我们想要一个<code class="fe mx my mz na b">EventService</code>对象，有三种不同的方法；<code class="fe mx my mz na b">publish</code>、<code class="fe mx my mz na b">subscribe</code>和<code class="fe mx my mz na b">unsubscribe</code>。但是这三种方法如何逻辑地结合起来创造我们想要的行为呢？</p><p id="077b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">基本上，我们希望有一个订阅列表，在那里我们跟踪每一个<code class="fe mx my mz na b">subscribe</code>事件。我们还希望有一个关联的<code class="fe mx my mz na b">callback</code>函数，它应该作为第二个参数传递给<code class="fe mx my mz na b">EventService.subscribe()</code>。每当我们用相同的事件名调用publish时，我们只是执行与之相关的函数。取消订阅一个事件仅仅意味着我们想从我们的订阅列表中删除它。为了跟踪每个事件，我们将使用一个额外的属性。姑且称之为<code class="fe mx my mz na b">subscriptions</code>。</p><p id="d3e6" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">考虑到这一点，我们来布置一下基本结构:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="a205" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了让它更灵活一点，假设我们还想处理多个事件订阅和带有名称空间的事件。当我们对同一个事件有多个订阅时，命名一个事件是很有用的，但是我们希望每个订阅者有不同的功能，我们也希望容易地跟踪它们。您可以在上面的例子中看到这个功能被用于<code class="fe mx my mz na b">subscribe</code>方法。</p><p id="5dd2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">从现在开始，我们可以开始一个接一个地实现每一个方法，从最困难的部分开始，也就是订阅事件的处理。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="5843" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">订阅事件</h1><p id="06cf" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">每当我们进行订阅时，我们想要做的就是在我们的<code class="fe mx my mz na b">subscriptions</code>对象中用事件的名称创建一个新的属性。从一些简单的声明和预检查开始:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="9c0f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们首先需要从参数中获取事件。从示例中可以看出，我们可以预期它是由空格分隔的事件列表。因此，为了收集所有事件，我们简单地将<code class="fe mx my mz na b">event</code>参数用空格分开。我们还需要注意命名空间事件。为此，我们将使用<code class="fe mx my mz na b">eventArray</code>变量。最后，我们做一个小检查；回调是强制性的，所以如果没有提供回调，我们将抛出一个错误。</p><p id="9dc4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下一步实际上是循环遍历我们的<code class="fe mx my mz na b">events</code>数组，并在<code class="fe mx my mz na b">subscriptions</code>下用事件名称本身创建一个节点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="fb2b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果没有提供名称空间，我们可以让它的值为<code class="fe mx my mz na b">undefined</code>。基于这一点，我们可以用下面的代码扩展我们的subscribe方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="7912" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们再次做了一些预防措施。我们首先在第10行检查当前索引是否是一个命名空间事件。在这种情况下，我们可以用它填充我们的<code class="fe mx my mz na b">eventArray</code>变量，例如:<code class="fe mx my mz na b">event.namespace</code>变成<code class="fe mx my mz na b">['event', 'namespace']</code>。</p><p id="cb48" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">接下来，我们需要检查我们是否已经订阅了该事件。这是我们在第14行做的。如果没有，我们为它创建一个空数组。对于名称，我们或者使用<code class="fe mx my mz na b">eventArray[0]</code>，它保存了命名空间事件的基本名称，或者在它未定义的情况下，我们使用<code class="fe mx my mz na b">singleEvent</code>。现在每当我们做<code class="fe mx my mz na b">subscribe('event')</code>时，我们应该在<code class="fe mx my mz na b">subscriptions</code>对象上获得一个<code class="fe mx my mz na b">event</code>属性。</p><p id="4f16" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">作为第18行的最后一步，我们希望确保名称空间是惟一的，并且不会被错误地覆盖。通过遍历我们的订阅列表并检查其中一个实例名称空间是否与我们传递的<code class="fe mx my mz na b">event</code>参数中的名称空间匹配，我们可以消除以下情况:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="98c3" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">剩下要做的就是创建订阅的主体，这可以用3行代码完成:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="83ce" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是我们从第24行到第27行所做的事情。我们创建一个新对象，并赋予它一个<code class="fe mx my mz na b">callback</code>属性，该属性将是函数参数中提供的回调。我们还给它一个<code class="fe mx my mz na b">namespace</code>属性，它可以是<code class="fe mx my mz na b">undefined</code>或者是我们为事件提供的名称空间。最后一步，我们清空了<code class="fe mx my mz na b">eventArray</code>变量，这样我们可以在下一次迭代中重用它。现在我们可以开始实现取消订阅功能了。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="c756" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">取消订阅事件</h1><p id="dd4f" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">就像认购一样，退订也可以从同一个基数开始；</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0f4c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们首先基于<code class="fe mx my mz na b">event</code>参数创建一个<code class="fe mx my mz na b">events</code>数组，我们还声明了一个<code class="fe mx my mz na b">eventArray</code>变量，这次没有任何值。然后我们开始循环我们的事件，并在每次迭代中将当前事件名赋给<code class="fe mx my mz na b">eventArray</code>。</p><p id="97cd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">接下来，我们需要检查订阅是否存在，如果存在，我们需要遍历事件，因为我们可以对同一个事件有多个订阅。这给我们留下了:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="72a8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在第8行，我们检查我们想要取消订阅的事件是否确实存在。由于我们拆分了在第2行得到的<code class="fe mx my mz na b">event</code>参数，我们可以确保<code class="fe mx my mz na b">currentEvent</code>将是一个数组，因此我们将事件名称称为<code class="fe mx my mz na b">eventArray[0]</code>，即使我们没有对<code class="fe mx my mz na b">currentEvent</code>变量使用split。之后，我们可以开始循环播放。这是必要的，因为我们可能只想删除命名空间实例，而不是整个订阅本身。为了实际检查我们是否将要删除一个命名空间事件，我们需要一个if语句来检查<code class="fe mx my mz na b">eventArray[1]</code>是否存在。如果是，我们知道我们正在取消订阅一个命名空间事件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="fdc1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">否则，我们可以删除<code class="fe mx my mz na b">this.subscriptions</code>中的节点。之后我们还需要<code class="fe mx my mz na b">break</code>才能从循环中跳出。剩下要做的就是检查当前订阅实例的<code class="fe mx my mz na b">namespace</code>，如果它与<code class="fe mx my mz na b">eventArray[1]</code>中的值匹配，我们就在<code class="fe mx my mz na b">j</code>的索引处拼接数组。这是在第13行完成的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="0f8e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我还包括了另一个if语句，从第16行开始。它的工作是确定给定订阅是否只剩下一个实例。如果我们要删除那个唯一的实例，我们实际上可以删除整个事件本身，这意味着:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="bfee" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后一步，我们现在要做的就是实现发布事件的功能，这样就可以触发相应的回调函数。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="0564" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">发布事件</h1><p id="4f97" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">如果你做到了这一步，恭喜你，你已经度过了最困难的阶段！🎉可能整个等式中最简单的部分就是发布事件。我们所要做的就是遍历我们的<code class="fe mx my mz na b">subscription</code>列表，如果我们找到传入的事件名称，我们就用传入的数据执行它的回调属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="74c5" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于循环，我们可以使用一个简单的<code class="fe mx my mz na b">for ... in</code>语句。为了确保我们只遍历它自己的属性，我们可以把所有的东西都放在一个if里面。这就是line:3应该做的事情。然后在第4行，我们可以检查传入的事件是否与当前键匹配，如果匹配，调用<code class="fe mx my mz na b">callback</code>属性并传入从函数的第二个参数得到的<code class="fe mx my mz na b">data</code>。</p><p id="dab0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果一切都做得正确，在你的控制台中运行<code class="fe mx my mz na b">EventService.publish('filterUpdated', data);</code>应该会立即给你一个带有传入数据的<code class="fe mx my mz na b">console.log</code>。</p><p id="35ee" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">到目前为止，您应该对如何实现发布-订阅行为设计模式有了很好的理解。恭喜你走到这一步！🙌在结束之前，我想给你一些关于设计模式的建议。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="ba0e" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">要记住的事情</h1><p id="ca0c" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">首先也是最重要的，不要让模式成为一把寻找钉子的锤子。不引入新模式就能解决的问题，就应该解决。</p><p id="70e2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">凡事都有取舍，模式也是如此。虽然它在很多情况下可以帮助您，但从负面来看，它增加了代码的复杂性和整个包的大小。</p><p id="83d0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你应该总是努力让你的代码尽可能的简单，<em class="nb">(记住KISS原则——保持简单，笨蛋)</em>并且只在你看到需要的时候使用一个模式。</p><p id="2ca9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然而，如果你这样做了，不要重新发明轮子，使用已经存在的模式作为解决方案。现在我将继续发表这个故事。☕️</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://medium.com/@ferencalmasi/membership"><div class="gh gi ne"><img src="../Images/e66c4cd6d9849ac0bd245f3fc39b65c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZ9xuLqLkbqUG65sgVB3gg.png"/></div></a></figure></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://webtips.dev/"><div class="gh gi kw"><img src="../Images/b45217f6440baa2b2825bd85db7c0e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*wZZT979Ntsv1lD6NED6JRw.png"/></div></a></figure><p id="e8d9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir">订阅我们的YouTube频道</strong> </a> <strong class="kz ir">获取更多类似内容！</strong></p><p id="dbea" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nb">更多内容看</em> <a class="ae kv" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kz ir"> <em class="nb">说白了. io </em> </strong> </a></p></div></div>    
</body>
</html>