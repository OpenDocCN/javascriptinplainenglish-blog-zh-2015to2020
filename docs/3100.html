<html>
<head>
<title>How to Implement Merge Sort in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中实现合并排序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-merge-sort-in-javascript-764d640050b3?source=collection_archive---------9-----------------------#2020-08-28">https://javascript.plainenglish.io/how-to-implement-merge-sort-in-javascript-764d640050b3?source=collection_archive---------9-----------------------#2020-08-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="437b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何实现这个众所周知的算法</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3de65c4cba9458dcc6b02752a77bf1b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Ymu7pvCovCFYeAJR"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@iurte?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Iker Urteaga</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dff4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了描述合并排序，让我们打个比方。</p><p id="8683" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设你有一块可以拆开的乐高积木。每个子块都有自己的数字，你不断打破，打破，直到有一个块彼此，有自己的数字。</p><p id="0f28" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">下面的图表展示了它的外观:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi lp"><img src="../Images/2f55d9348f98966bc7d2f852236a19f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/1*Rjy7GtVPDt2KqrPteE0T0A.png"/></div></figure><p id="9cbd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">要理解合并排序，您必须记住以下几点:</p><ul class=""><li id="facd" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated">合并排序</li><li id="1b90" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated">合并</li></ul><p id="8d8e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">以下是要遵循的步骤:</p><ul class=""><li id="02f2" class="lq lr in kv b kw kx kz la lc ls lg lt lk lu lo lv lw lx ly bi translated"><strong class="kv io">步骤1: </strong>创建一个名为mergeSort的函数。</li><li id="01fc" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated"><strong class="kv io">第二步:</strong>在mergeSort中，创建左右子数组，取元素的前半部分，复制到左子数组中。将元素的后一半复制到右边的子数组中。</li><li id="0239" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated"><strong class="kv io">第三步:</strong>用左子数组递归调用归并排序(函数本身)</li><li id="f640" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated"><strong class="kv io">步骤4: </strong>用右子数组递归调用归并排序(函数本身)</li><li id="cb47" class="lq lr in kv b kw lz kz ma lc mb lg mc lk md lo lv lw lx ly bi translated"><strong class="kv io">第五步:</strong>调用merge with left subarray，right subarray，原数组本身，with size of left array，and the size of the right array。</li></ul><p id="51c6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在Merge函数中，您将比较左右子数组中的元素，I和j分别作为跟踪每个数组中要比较的当前元素的索引。</p><p id="4f05" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><code class="fe me mf mg mh b">i</code>和<code class="fe me mf mg mh b">j</code>始于<code class="fe me mf mg mh b">0</code>。您还有另一个索引，<code class="fe me mf mg mh b">k</code>，它用于跟踪我们正在移入新元素的最新索引。如果是当前的<code class="fe me mf mg mh b">left_arr[i] &lt; right_arr[j]</code>，移动<code class="fe me mf mg mh b">left_arr[i] to arr[k]</code>，增加I和<code class="fe me mf mg mh b">k</code>，否则移动<code class="fe me mf mg mh b">right_arr[j]</code>到<code class="fe me mf mg mh b">arr[k]</code>，增加j和k</p><h2 id="6ffb" class="mi mj in bd mk ml mm dn mn mo mp dp mq lc mr ms mt lg mu mv mw lk mx my mz na bi translated">下面是合并排序的代码:</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="5219" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这里，如果少于2个元素，我们甚至不需要排序。我们将一半的元素放入<code class="fe me mf mg mh b">left_arr</code>，另一半放入<code class="fe me mf mg mh b">right_arr</code>。然后我们调用<code class="fe me mf mg mh b">mergeSort</code>并进一步划分为每个子数组— <code class="fe me mf mg mh b">merge</code>是实际将事物分类在一起的部分。</p><h2 id="c79b" class="mi mj in bd mk ml mm dn mn mo mp dp mq lc mr ms mt lg mu mv mw lk mx my mz na bi translated">下面是合并的代码:</h2><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="0a26" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如前所述，左和右索引允许我们跟踪当前元素来检查左和右子数组。我们比较这些值，并将较小的值移入原始数组。无论我们应该从哪个数组中移出较小的元素，我们都将索引I或j加1，k也加1。</p><p id="c4f1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一旦全部完成，其中一个数组将留下要复制的元素。如果左边的子数组还有元素，我们将剩余的元素复制到原始数组中。否则，我们将右边子数组中的其余元素复制到原始数组中。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nd"><img src="../Images/a7f3d671d06481db6831796b5b079f06.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*i0mG_LIkedDaGXgf"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@headwayio?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Headway</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6e4b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">对于那些正忙于准备面试的人来说，你可能已经想到了这些问题:快速排序和合并排序在空间和复杂度方面有什么区别？</p><p id="9f49" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，quicksort在最差性能上是o(n)，在平均性能上是o(n log n)。每次都有可能需要对每个元素进行透视和分区。它不需要额外的内存，所以在内存方面它是o(1)。</p><p id="612b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">关于快速排序的更多信息，你可以在这里阅读我的文章:</p><div class="ne nf gp gr ng nh"><a href="https://medium.com/weekly-webtips/explanation-of-quick-sort-8f7e12f57194" rel="noopener follow" target="_blank"><div class="ni ab fo"><div class="nj ab nk cl cj nl"><h2 class="bd io gy z fp nm fr fs nn fu fw im bi translated">快速排序的解释</h2><div class="no l"><h3 class="bd b gy z fp nm fr fs nn fu fw dk translated">在本文中，我将讨论快速排序&amp;您需要知道的所有组件。</h3></div><div class="np l"><p class="bd b dl z fp nm fr fs nn fu fw dk translated">medium.com</p></div></div><div class="nq l"><div class="nr l ns nt nu nq nv km nh"/></div></div></a></div><p id="855f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另一方面，合并排序将总是o(n log n)，最差或平均性能。然而，合并排序总是需要分配左右子数组，所以在内存方面是o(n)。</p><p id="a2ff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这就是合并排序的方式。现在轮到你练习这些算法，了解它们是如何工作的。</p></div></div>    
</body>
</html>