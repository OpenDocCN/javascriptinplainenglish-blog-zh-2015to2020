# JavaScript 选择排序

> 原文：<https://javascript.plainenglish.io/javascript-selection-sort-1840cd043b52?source=collection_archive---------10----------------------->

## 我们来整理一下

![](img/9bdec8162bf4056613075329eeeb5d3e.png)

Photo by [Kelly Sikkema](https://unsplash.com/@kellysikkema?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

上周，我写了一篇关于冒泡排序的博客。继续我学习排序算法的旅程，让我们进行下一步，看看选择排序。

与比较相邻元素的冒泡排序不同，选择排序的工作方式是遍历数组，找到最小(或最大，取决于是按升序还是降序排序)的元素，并将其移动到数组的开头。从这里开始，它循环遍历除已经设置好的元素之外的所有元素，直到遍历完整个数组。

# 分步示例

## 预期结果

升序排序
输入:[4，2，5，1，3，6]
输出:[1，2，3，4，5，6]

## 第一次迭代

让我们遍历数组，找到最小值，并跟踪它的索引。我们从第一个元素(索引 0)开始。

minIndex = 0
[ **4** ，2，5，1，3，6]

4 大于 2，所以现在 minIndex = 1
[4， **2** ，5，1，3，6]

2 小于 5，所以 minIndex = 1
[4， **2** ，5，1，3，6]

2 大于 1，所以 minIndex = 3
[4，2，5， **1** ，3，6]

1 小于 3，所以 minIndex = 3
[4，2，5， **1** ，3，6]

1 小于 6，所以 minIndex = 3
[4，2，5， **1** ，3，6]

我们已经确定最小值在索引 3 处。我们将把索引为 0 的元素与最小索引处的元素进行交换。现在数组看起来是这样的:
[ **1** ，2，5， **4** ，3，6]

## 第二次迭代

因为我们已经在索引 0 处放置了最小的数字，所以我们从索引 1 开始迭代，以找到数组中第二个最小的数字。

minIndex = 1
[1， **2** ，5，4，3，6]

2 < 5, minIndex = 1
[1， **2** ，5，4，3，6]

2 < 4, minIndex = 1
[1， **2** ，5，4，3，6]

2 < 3, minIndex = 1
[1， **2** ，5，4，3，6]

2 < 6, minIndex = 1
[1， **2** ，5，4，3，6]

minIndex 从未更改，所以我们不需要执行交换。

## 第三次迭代

从索引 2 开始。

minIndex = 2
[1，2， **5** ，4，3，6]

5 > 4，minIndex = 3
[1，2，5， **4** ，3，6]

4 > 3，minIndex = 4
[1，2，5，4， **3** ，6]

3< 6, minIndex = 4
【1，2，5，4， **3** ，6】

交换 5 和 3，数组现在看起来是这样的:
【1，2， **3** ，4， **5** ，6】

## 最终迭代

即使我们的数组已经排序了，我们仍然要为索引 3 和 4 遍历数组 2 次(当我们到达索引 5 的最后一个元素时，*它必须是最大值*，所以我们不需要再次迭代)。

# 密码

是写代码的时候了！

```
function selectionSort(arr){
    for(let i = 0; i < arr.length - 1; i++){
        let minIndex = i; for(let j = i + 1; j < arr.length; j++){
            if(arr[j] < arr[minIndex]){
                minIndex = j;
            }
        } if(i !== minIndex){
            let temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp; 
        }
    } return arr;
};
```

## 解释代码

因为我们知道我们需要检查数组中的每个元素，所以我们设置了一个`for`循环来运行数组的长度减 1，因为当我们到达最后一个元素时，我们知道它已经排序了。每次迭代，`minIndex`的起始值将是该索引处的数字。因此，对于第一次迭代，`minIndex`将是 0，对于第二次它将是 1，就像我们的一步一步的例子。

从那里我们需要检查之后的所有元素*，这就是为什么我们的嵌套`for`循环有从`i + 1`开始的`j`。当它遍历其余元素时，如果它们中的任何一个小于索引`i`处的值，它将改变`minIndex`来反映这一点。*

一旦我们跳出嵌套的`for`循环，回到第一个循环，我们检查`minIndex`是否仍然等于`i`。如果不相等，这意味着在嵌套循环中的某个点，我们发现一个值小于索引`i`处的值，我们需要交换这些值。

类似于冒泡排序中的交换，我们声明一个名为`temp`的变量来保存当前在索引`i`处的内容，然后我们将索引`i`处的值更改为最小值。之后，我们将原来位于索引`i` ( `temp`)的值分配给原来最小值所在的位置。有效地交换元素。

# 时间和空间复杂性

## 时间复杂度

与冒泡排序不同，我们不必每次迭代都从数组的开头开始，因为每次迭代我们都将一个元素放在正确的位置。这意味着每次外`for`循环迭代，内`for`循环将少运行 1 次。

这意味着在我们的例子中，数组中有 6 个元素，

在第一次迭代中，我们经历了 5 个元素。第二天我们经历了 4 次。第三天，我们经历了 3。第四天我们经历了 2。最后我们还剩 1 个。

所以 5 + 4 + 3 + 2 + 1 = 15。

另一种思考方式是(6 *(6–1))/2 = 15。

所以根据我们的输入 n * (n-1) * 1/2

然而，当从大 O 符号的角度考虑这一点时，我们将考虑是什么导致了最高的增长率，因此这简化为 O(n)。最佳情况、最差情况和一般情况都是 O(n ),因为不管数组是否已经排序，选择排序将继续对给定的输入运行相同的次数。

## 空间复杂性

就像冒泡排序一样，选择排序就地排序。这意味着该算法占用的内存空间不依赖于输入，空间复杂度为 O(1)。换句话说，时间不变。

# 不稳定排序算法

选择排序是一种不稳定的排序算法。让我们花点时间来谈谈这意味着什么。不稳定意味着数组中相同的两个值不一定会保持排序后的顺序。对于充满数字或字符串等原始数据类型的数组来说，这没有太大意义。

然而，让我们考虑我们正在排序一个对象数组，代表学生。我们想按等级对它们进行排序，但是我们当前的数组是按字母顺序排序的。在按成绩排序的同时，我们也希望保持字母顺序。以便所有一年级的学生按字母顺序出现，然后所有二年级的学生按字母顺序出现，依此类推。

```
let studentArr = [{name: "Al Cooper" , grade: 4}, {name: "Bobby Tables" , grade: 4}, {name: "Gracie Hopper" , grade: 3}]
```

如果我们将数组传递给选择排序，它会输出

```
[{name: "Gracie Hopper" , grade: 3}, {name: "Bobby Tables" , grade: 4}, {name: "Al Cooper" , grade: 4}]
```

哦不！我们想让鲍比·表在阿尔·库珀之后出现。不幸的是，选择排序只会考虑等级，首先将格雷西移到列表的前面，将艾尔移到她的位置。从那里开始，它们按等级排序，因此算法不会再交换。也就是说，尽管 Al 和 Bobby 都是 4 年级的，但是他们的排列顺序和我们原来的不同。

# 总之…

选择排序是另一个简单的排序算法，你通常不会看到在现实世界中使用。这是因为像冒泡排序一样，它具有 O(n)时间复杂度，并且不能很好地扩展到大型列表。它的好处是它在小列表上表现很好，并且它是常数时间。除此之外，其他一些排序算法，如堆排序，都是基于选择排序的。