<html>
<head>
<title>How To Create A Binary Heap In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JavaScript创建二进制堆</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-a-binary-heap-in-javascript-e1e6f6446ff9?source=collection_archive---------16-----------------------#2020-12-21">https://javascript.plainenglish.io/how-to-create-a-binary-heap-in-javascript-e1e6f6446ff9?source=collection_archive---------16-----------------------#2020-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7024" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript数据结构系列的第7部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/48b8d050a30db5490db7f120c9f3509c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RvZ045Hpp9y6Qw1m"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@toddquackenbush?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Todd Quackenbush</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5b3e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这篇文章中，我们将看看另一种类型的数据结构，二进制堆。如果你不熟悉树木，我建议你先看看下面的文章。</p><div class="ls lt gp gr lu lv"><a href="https://medium.com/javascript-in-plain-english/binary-search-trees-with-javascript-715df954b33" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">使用JavaScript的二分搜索法树</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">JavaScript数据结构系列的第5部分</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="15f9" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">MaxBinaryHeap与MinBinaryHeap</h1><p id="969a" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">二进制堆是一种具有附加规则的二叉树。要快速复习；二叉树是由具有父子关系的节点组成的数据结构。每个父节点最多可以有两个子节点。在二进制堆中，有两个附加规则:</p><ol class=""><li id="9299" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nt nu nv nw bi translated">树的所有级别都必须按顺序填写。如果树的最后一级没有填充，则从左到右填充树的节点。</li></ol><p id="c26f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.有两种方法可以将数据存储在树中:</p><ul class=""><li id="31f2" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nx nu nv nw bi translated">MaxBinaryHeap父值必须大于子值。下图显示了最大二进制堆。如您所见，根值是100，每个子值(19和36)都小于父值。我们可以对树中的每个节点进行同样的检查。只要子属性小于父属性，左属性或右属性的顺序并不重要。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ny"><img src="../Images/c8c38e46ceed0703259336017bfed1f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1002/format:webp/1*XSchy2OiWWwlkPNhhoKVBg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://en.wikipedia.org/wiki/Binary_heap" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Binary_heap</a></figcaption></figure><ul class=""><li id="28d3" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nx nu nv nw bi translated">MinBinaryHeap父值必须小于子值。下图显示了一个最小二进制堆。根值为1，每个子节点(2和3)都大于父节点。这同样适用于树中的每个值。只要子属性多于父属性，左属性或右属性的顺序并不重要。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nz"><img src="../Images/3c51e888aeec8f204307013529411ced.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*uPjdDf5xa-OVUA_UhOW8Xg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://en.wikipedia.org/wiki/Binary_heap" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Binary_heap</a></figcaption></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="6bd6" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">使用数组表示堆</h1><p id="fb82" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">存储二进制堆最简单的方法是使用数组。这涉及到一些数学问题，但不用担心；一旦我们理解了基本方程，使用它们就简单了。</p><p id="a566" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了找到任何父元素(n)的子元素，我们将使用以下等式:</p><ul class=""><li id="32a6" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nx nu nv nw bi translated">左侧子节点:(2 * n) + 1</li><li id="93a2" class="no np iq ky b kz oa lc ob lf oc lj od ln oe lr nx nu nv nw bi translated">右子节点:(2 * n) + 2</li></ul><p id="1d29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了找到任何子节点(n)的父节点，我们将使用下面的等式:</p><ul class=""><li id="72bc" class="no np iq ky b kz la lc ld lf nq lj nr ln ns lr nx nu nv nw bi translated">父节点:Math.floor((n - 1) / 2)</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/284208fbc9354a13a5a30ea61e853945.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ps_t5FR3NeZQiLo6BpWuNQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://en.wikipedia.org/wiki/Heap_(data_structure)" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Heap_(data_structure)</a></figcaption></figure><p id="7c94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看上面的图片，它显示了一个最大的二进制堆。我们可以用我们的方程，把我们的二进制堆表示成一个数组。<code class="fe og oh oi oj b">[100, 19, 36, 17, 12, 25, 5, 9, 15, 6, 11, 13, 8, 1, 4]</code></p><p id="fefb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们的根值100存储在数组的索引0处。使用我们的等式，我们可以在数组的索引1和2处找到两个孩子，19岁和36岁。</p><p id="407c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">左子节点:(2 * 0) + 1 = 1 <br/>右子节点:(2 * 0) + 2 = 2</p><p id="c558" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，如果我们可以看看19作为一个父值，我们看到19有两个孩子，17和12。使用我们的等式，我们将看到这两个节点位于数组中的索引3和4处。</p><p id="5d8a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">左子节点:(2 * 1) + 1 = 3 <br/>右子节点:(2 * 1) + 2 = 4</p><p id="0b12" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们想找到任何节点的父节点，我们可以使用我们的另一个方程Math.floor((n - 1) / 2)。例如，让我们看看存储在索引4中的值12。父代是值19，它存储在索引1中。</p><p id="de72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">math . floor((4-1)/2)= math . floor(1.5)= 1</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="92d5" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">构建我们的二进制堆类</h1><p id="30e8" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">在下面的例子中，我们将构建一个最大二进制堆。一旦您理解了如何构建它，就可以用类似的方式创建一个最小二进制堆。首先，我们将创建一个类，并将其命名为MaxBinaryHeap。这将有一个名为values的属性，它将被初始化为一个空数组。</p><pre class="kg kh ki kj gt ok oj ol om aw on bi"><span id="67ee" class="oo ms iq oj b gy op oq l or os">class MaxBinaryHeap {<br/>  constructor() {<br/>    this.values = [];<br/>  }<br/>}</span></pre><h2 id="5183" class="oo ms iq bd mt ot ou dn mx ov ow dp nb lf ox oy nd lj oz pa nf ln pb pc nh pd bi translated">插入我们的二进制堆</h2><p id="22ee" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">让我们首先来看看如何向max二进制堆中添加值。第一步是将值推到值数组的末尾。push方法将把值放在堆中的下一个位置。记住我们堆的第一条规则:<em class="pe">树的所有层次都必须按顺序填充。如果树的最后一级没有填充，则从左到右填充树的节点。</em></p><p id="3692" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们需要做一个泡泡效果。这意味着我们将比较插入的值和父值。如果插入的值大于父值，我们将切换这些值。我们将继续这样做，直到插入的值位于正确的位置。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pf pg l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Inserting into our Binary Heap</figcaption></figure><h2 id="6f9d" class="oo ms iq bd mt ot ou dn mx ov ow dp nb lf ox oy nd lj oz pa nf ln pb pc nh pd bi translated">从二进制堆中移除</h2><p id="db02" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">当从二进制堆中移除时，我们通常会移除根值。这意味着，在最大二进制堆中，我们删除的是最大值，而在最小二进制堆中，我们删除的是最小值。在我们的例子中，我们将调用我们的方法extractMax。</p><p id="60eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们将首先用数组中的最后一个值交换根值。然后，我们将做一个泡沫下降的效果。因为我们的新根可能不在正确的位置，我们将比较这个值和它的子节点。无论哪个孩子更大，我们都要和他的父母交换。我们将继续这样做，直到值处于正确的位置。最后，我们将返回最大值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="pf pg l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Removing from our Binary Heap</figcaption></figure></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><h1 id="b9cf" class="mr ms iq bd mt mu mv mw mx my mz na nb jw nc jx nd jz ne ka nf kc ng kd nh ni bi translated">包扎</h1><p id="bdd6" class="pw-post-body-paragraph kw kx iq ky b kz nj jr lb lc nk ju le lf nl lh li lj nm ll lm ln nn lp lq lr ij bi translated">感谢阅读！希望您现在已经了解了二进制堆以及如何在max二进制堆中插入和移除。如果您想为最小二进制堆实现这一点，您需要做的只是更改一些操作符和几行代码。</p><p id="d471" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">二进制堆对于排序和实现其他数据结构很有用，我们将在本系列的下一部分看到优先级队列。就大O符号而言，二进制堆在插入和删除方面表现出色。都有一个大O的O(log N)。</p><p id="1ee2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想继续学习吗？看看下面这篇关于深度优先搜索和广度优先搜索的文章。</p><div class="ls lt gp gr lu lv"><a href="https://medium.com/javascript-in-plain-english/tree-traversal-with-javascript-29b57d61d486" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">用JavaScript遍历树</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">JavaScript数据结构系列的第6部分</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="ph l mg mh mi me mj kp lv"/></div></div></a></div></div></div>    
</body>
</html>