<html>
<head>
<title>Verifying JSON Web Tokens with Express-JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Express-JWT验证JSON Web令牌</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/verifying-json-web-tokens-with-express-jwt-1ae147aa9bd3?source=collection_archive---------2-----------------------#2020-03-24">https://javascript.plainenglish.io/verifying-json-web-tokens-with-express-jwt-1ae147aa9bd3?source=collection_archive---------2-----------------------#2020-03-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f167b82d0e2a5523f140eb83bf328968.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fmm-LsgA0SgQ0fuz"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@gabrielbenois?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gabriel Benois</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="08df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着单页面应用程序和纯API后端的使用，JSON web token(jwt)已经成为向我们的应用程序添加身份验证功能的一种流行方式。</p><p id="fdfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看如何用Express-JWT验证JSON web令牌。</p><h1 id="8794" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">装置</h1><p id="0fc7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">express-jwt</code>作为节点包提供。要安装它，我们运行:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c971" class="mq lc iq mh b gy mr ms l mt mu">npm install express-jwt</span></pre><h1 id="ab21" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用</h1><p id="010a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">express-jwt</code>包中包含的<code class="fe me mf mg mh b">jwt</code>函数来验证令牌。</p><p id="7f2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">jwt</code>是一个中间件功能，所以我们不必创建自己的中间件来验证令牌。</p><p id="bf4d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用<code class="fe me mf mg mh b">jwt</code>功能:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bb2b" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const jsonwebtoken = require('jsonwebtoken');<br/>const jwt = require('express-jwt');<br/>const app = express();</span><span id="55a5" class="mq lc iq mh b gy mv ms l mt mu">const secret = 'secret';</span><span id="5c33" class="mq lc iq mh b gy mv ms l mt mu">app.post('/auth', (req, res) =&gt; {<br/>  const token = jsonwebtoken.sign({ foo: 'bar' }, secret);<br/>  res.send(token);<br/>})</span><span id="6907" class="mq lc iq mh b gy mv ms l mt mu">app.get('/protected', jwt({ secret }), (req, res) =&gt; {<br/>  res.send('protected');<br/>})</span><span id="266e" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="d73a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们调用了<code class="fe me mf mg mh b">jsonwebtoken.sign</code>来在<code class="fe me mf mg mh b">auth</code>路由中发布令牌。</p><p id="e51c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过将<code class="fe me mf mg mh b">Bearer</code>和我们的令牌放入授权请求头来调用<code class="fe me mf mg mh b">protected</code>路由。</p><p id="ec9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">授权头的一个例子是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7c10" class="mq lc iq mh b gy mr ms l mt mu">Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIiLCJpYXQiOjE1Nzk0NzczMDd9.QW7FOvyJQ36dir0199nJTv07VhlNo9_cItGTkdyJeK8</span></pre><p id="7427" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果令牌无效或者不存在，那么我们会得到一个错误。</p><p id="c257" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以检查其他字段，如<code class="fe me mf mg mh b">audience</code>或<code class="fe me mf mg mh b">issuer</code>，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="31c9" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const jsonwebtoken = require('jsonwebtoken');<br/>const jwt = require('express-jwt');<br/>const app = express();</span><span id="fa19" class="mq lc iq mh b gy mv ms l mt mu">const secret = 'secret';<br/>const audience = 'http://myapi/protected';<br/>const issuer = 'http://issuer';</span><span id="c6d3" class="mq lc iq mh b gy mv ms l mt mu">app.post('/auth', (req, res) =&gt; {<br/>  const token = jsonwebtoken.sign({ foo: 'bar' }, secret, { audience, issuer });<br/>  res.send(token);<br/>})</span><span id="f9bf" class="mq lc iq mh b gy mv ms l mt mu">app.get('/protected', jwt({ secret, audience, issuer }), (req, res) =&gt; {<br/>  res.send('protected');<br/>})</span><span id="8ddf" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="b99f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们将<code class="fe me mf mg mh b">audience</code>和<code class="fe me mf mg mh b">issuer</code>添加到了<code class="fe me mf mg mh b">sign</code>方法调用的第三个参数中的对象，该对象包含了我们想要添加到颁发的令牌中的选项。</p><p id="4f6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">protected</code>路径中，我们用传递给<code class="fe me mf mg mh b">jwt</code>的options对象中的<code class="fe me mf mg mh b">audience</code>和<code class="fe me mf mg mh b">issuer</code>添加了<code class="fe me mf mg mh b">jwt</code>中间件。</p><p id="34e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果令牌具有与代码匹配的<code class="fe me mf mg mh b">secret</code>、<code class="fe me mf mg mh b">audience</code>和<code class="fe me mf mg mh b">issuer</code>，那么<code class="fe me mf mg mh b">protected </code>路由返回<code class="fe me mf mg mh b">protected</code>响应。否则，我们会得到一个错误。</p><p id="40c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以验证用Base64编码的密码生成的令牌，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9a42" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const jsonwebtoken = require('jsonwebtoken');<br/>const jwt = require('express-jwt');<br/>const app = express();</span><span id="1317" class="mq lc iq mh b gy mv ms l mt mu">const secret = 'secret';</span><span id="9db6" class="mq lc iq mh b gy mv ms l mt mu">app.post('/auth', (req, res) =&gt; {<br/>  const token = jsonwebtoken.sign({ foo: 'bar' }, new Buffer(secret, 'base64'));<br/>  res.send(token);<br/>})</span><span id="15e5" class="mq lc iq mh b gy mv ms l mt mu">app.get('/protected', jwt({ secret: new Buffer(secret, 'base64') }), (req, res) =&gt; {<br/>  res.send('protected');<br/>})</span><span id="6895" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="338c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们将<code class="fe me mf mg mh b">new Buffer(secret, ‘base64’)</code>传递给了<code class="fe me mf mg mh b">sign</code>方法的第二个参数，该方法从Base64编码的秘密生成一个令牌。</p><p id="3397" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">protected</code>路由处理程序中，我们可以用同样的秘密调用<code class="fe me mf mg mh b">jwt</code>中间件函数来验证令牌。</p><p id="361a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了验证使用RSA私钥生成的令牌，我们可以编写以下代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="60f2" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const jsonwebtoken = require('jsonwebtoken');<br/>const jwt = require('express-jwt');<br/>const fs = require('fs');<br/>const app = express();</span><span id="d81f" class="mq lc iq mh b gy mv ms l mt mu">const publicKey = fs.readFileSync('public.pub');</span><span id="4489" class="mq lc iq mh b gy mv ms l mt mu">app.post('/auth', (req, res) =&gt; {<br/>  const privateKey = fs.readFileSync('private.key');<br/>  const token = jsonwebtoken.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' });<br/>  res.send(token);<br/>})</span><span id="ffe6" class="mq lc iq mh b gy mv ms l mt mu">app.get('/protected', jwt({ secret: publicKey }), (req, res) =&gt; {<br/>  res.send('protected');<br/>})</span><span id="88f1" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="96ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">令牌是在<code class="fe me mf mg mh b">auth</code>路由中生成的，方法是从文件系统上的一个文件中读取私钥，然后使用该私钥通过<code class="fe me mf mg mh b">sign</code>方法对令牌进行签名。</p><p id="4096" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以使用与用于生成令牌的私钥相对应的公钥，通过编写以下内容来验证令牌:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a9d4" class="mq lc iq mh b gy mr ms l mt mu">jwt({ secret: publicKey })</span></pre><p id="58bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要访问解码后的令牌，我们可以如下使用<code class="fe me mf mg mh b">req.user</code>属性:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0a71" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const jsonwebtoken = require('jsonwebtoken');<br/>const jwt = require('express-jwt');<br/>const app = express();<br/>const secret = 'secret';</span><span id="7f06" class="mq lc iq mh b gy mv ms l mt mu">app.post('/auth', (req, res) =&gt; {<br/>  const token = jsonwebtoken.sign({ foo: 'bar' }, secret);<br/>  res.send(token);<br/>})</span><span id="747c" class="mq lc iq mh b gy mv ms l mt mu">app.get('/protected', jwt({ secret }), (req, res) =&gt; {<br/>  res.send(req.user);<br/>})</span><span id="a3d1" class="mq lc iq mh b gy mv ms l mt mu">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="9b0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">protected</code>路线中，我们返回<code class="fe me mf mg mh b">req.user</code>作为回应。那么我们应该得到这样的结果:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c656" class="mq lc iq mh b gy mr ms l mt mu">{<br/>    "foo": "bar",<br/>    "iat": 1579478314<br/>}</span></pre><p id="60a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在回复内容中。</p><p id="8086" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过如下设置<code class="fe me mf mg mh b">requestProperty</code>属性来改变解码后的令牌所附加的属性:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d7c6" class="mq lc iq mh b gy mr ms l mt mu">app.get('/protected', jwt({ secret, requestProperty: 'auth' }), (req, res) =&gt; {<br/>  res.send(req.auth);<br/>})</span></pre><p id="7f50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到与前一个例子相同的响应。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/b74fa5d4ebd14fd65dc0f4efd2697425.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NRj16YYcYFbL4mwn"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Priscilla Du Preez</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4a53" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="a71a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">express-jwt</code>中间件来验证我们的JSON web令牌。</p><p id="b527" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它接受一个秘密和其他令牌选项，如<code class="fe me mf mg mh b">audience</code>和<code class="fe me mf mg mh b">issuer</code>，如果验证成功，则将解码后的令牌设置为Express request对象。</p><p id="6a24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果验证不成功，则返回一个错误。</p><p id="6bcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它支持对称和非对称加密算法。</p></div></div>    
</body>
</html>