<html>
<head>
<title>JavaScript Events Handlers— onfocus, oncancel, and oncanplay</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript事件处理程序— onfocus、oncancel和oncanplay</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-events-handlers-onfocus-oncancel-and-oncanplay-e62dfca93dca?source=collection_archive---------2-----------------------#2020-01-24">https://javascript.plainenglish.io/javascript-events-handlers-onfocus-oncancel-and-oncanplay-e62dfca93dca?source=collection_archive---------2-----------------------#2020-01-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn js jt ju jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi jr"><img src="../Images/b8b112e5fee38596a1fe45fcfb7135d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wSI9RAyJCJCvJhOj"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk">Photo by <a class="ae kg" href="https://unsplash.com/@akeenster?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Abigail Keenan</a> on <a class="ae kg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="faad" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">在JavaScript中，事件是应用程序中发生的动作。它们是由各种事情触发的，比如输入、提交表单、调整大小等元素变化，或者应用程序运行时发生的错误等。我们可以分配事件处理程序来处理这些事件。发生在DOM元素上的事件可以通过为相应事件的DOM对象的属性分配一个事件处理程序来处理。在本文中，我们将看看<code class="fe jn jo jp jq b">onfocus</code>、<code class="fe jn jo jp jq b">oncancel</code>和<code class="fe jn jo jp jq b">oncanplay</code>事件处理程序。</p><h1 id="8da4" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">专注</h1><p id="f5eb" class="pw-post-body-paragraph kh ki iq kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le ij bi translated"><code class="fe jn jo jp jq b">document</code>对象的<code class="fe jn jo jp jq b">onfocus</code>属性让我们为<code class="fe jn jo jp jq b">focus</code>事件设置一个事件处理程序，这与<code class="fe jn jo jp jq b">blur</code>事件相反。当用户在HTML元素上设置焦点时，触发<code class="fe jn jo jp jq b">focus</code>事件。如果我们想让焦点事件触发非输入元素，我们必须给它加上<code class="fe jn jo jp jq b">tabindex</code>属性。那个属性添加了什么，我们可以用计算机的Tab键来关注它。例如，我们可以通过编写以下代码将<code class="fe jn jo jp jq b">onfocus</code>事件处理程序附加到<code class="fe jn jo jp jq b">document</code>对象:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="b229" class="mq lg iq jq b gy mr ms l mt mu">document.onfocus = () =&gt; {<br/>  console.log('focus');<br/>}</span></pre><p id="669b" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我们还可以通过将<code class="fe jn jo jp jq b">event</code>参数添加到事件处理函数中来获取触发焦点事件的<code class="fe jn jo jp jq b">Event</code>对象，如以下代码所示:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="4691" class="mq lg iq jq b gy mr ms l mt mu">document.onfocus = (event) =&gt; {<br/>  console.log(event);<br/>}</span></pre><p id="8030" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后，当我们在页面内外点击时，我们会从上面的代码中得到类似下面这样的输出:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="8fda" class="mq lg iq jq b gy mr ms l mt mu">bubbles: false<br/>​cancelBubble: false<br/>​cancelable: false<br/>​composed: true<br/>​currentTarget: null<br/>​defaultPrevented: false<br/>​detail: 0<br/>​eventPhase: 0<br/>​explicitOriginalTarget: &lt;html&gt;<br/>​isTrusted: true<br/>​layerX: 0<br/>​layerY: 0<br/>​originalTarget: HTMLDocument <a class="ae kg" href="https://fiddle.jshell.net/_display/" rel="noopener ugc nofollow" target="_blank">https://fiddle.jshell.net/_display/</a><br/>​rangeOffset: 0<br/>​rangeParent: null<br/>​relatedTarget: null<br/>​returnValue: true<br/>​srcElement: HTMLDocument <a class="ae kg" href="https://fiddle.jshell.net/_display/" rel="noopener ugc nofollow" target="_blank">https://fiddle.jshell.net/_display/</a><br/>​target: HTMLDocument <a class="ae kg" href="https://fiddle.jshell.net/_display/" rel="noopener ugc nofollow" target="_blank">https://fiddle.jshell.net/_display/</a><br/>​timeStamp: 1463<br/>​type: "focus"<br/>​view: Window <a class="ae kg" href="https://fiddle.jshell.net/_display/" rel="noopener ugc nofollow" target="_blank">https://fiddle.jshell.net/_display/</a><br/>​which: 0</span></pre><p id="5147" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">上面的输出是<code class="fe jn jo jp jq b">Event</code>对象的属性和相应的值。要查看关于<code class="fe jn jo jp jq b">Event</code>对象的更多细节，我们可以看看以前的文章。</p><h1 id="02d1" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">癌症</h1><p id="f446" class="pw-post-body-paragraph kh ki iq kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le ij bi translated">为了处理<code class="fe jn jo jp jq b">dialog</code>元素关闭时的情况，我们可以使用<code class="fe jn jo jp jq b">oncancel</code>事件处理程序，因为<code class="fe jn jo jp jq b">cancel</code>事件是在它关闭时触发的。用<code class="fe jn jo jp jq b">oncancel</code>事件处理程序处理该事件可以防止它冒泡，所以父处理程序不会得到该事件的通知。一次只能给一个对象分配一个<code class="fe jn jo jp jq b">oncancel</code>处理器。然而，如果我们使用<code class="fe jn jo jp jq b">addEventListener</code>将事件处理函数附加到我们的元素上，那么我们就可以避开这个限制。例如，我们可以在下面的代码中使用它:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="4db7" class="mq lg iq jq b gy mr ms l mt mu">const dialog = document.getElementById('dialog');<br/>const openButton = document.getElementById('open-button');<br/>openButton.onclick = () =&gt; {<br/>  dialog.showModal();<br/>};</span><span id="6aae" class="mq lg iq jq b gy mv ms l mt mu">dialog.oncancel = (event) =&gt; {<br/>  console.log('cancel');<br/>  console.log(event);<br/>}</span></pre><p id="0147" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后我们必须将<code class="fe jn jo jp jq b">dialog</code>元素添加到我们的HTML代码中:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="d124" class="mq lg iq jq b gy mr ms l mt mu">&lt;button id='open-button'&gt;<br/>  Open Dialog<br/>&lt;/button&gt;<br/>&lt;dialog id="dialog"&gt;<br/>  &lt;form method="dialog"&gt;<br/>    &lt;p&gt;<br/>      Dialog<br/>    &lt;/p&gt;<br/>    &lt;menu&gt;<br/>      &lt;button id="cancel-button" value="cancel"&gt;Cancel&lt;/button&gt;<br/>      &lt;button id="confirmBtn" value="default"&gt;Confirm&lt;/button&gt;<br/>    &lt;/menu&gt;<br/>  &lt;/form&gt;<br/>&lt;/dialog&gt;</span></pre><p id="af3f" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">在上面的代码中，我们向HTML添加了一个<code class="fe jn jo jp jq b">dialog</code>元素，并使用<code class="fe jn jo jp jq b">getElementById</code>方法获取HTML <code class="fe jn jo jp jq b">dialog</code>元素的DOM元素，这使我们有了以下方法:</p><ul class=""><li id="098a" class="mw mx iq kj b kk kl ko kp ks my kw mz la na le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">close()</code> —关闭<code class="fe jn jo jp jq b">dialog</code>元素的对话框实例方法。一个可选的字符串可以作为参数传入，它更新<code class="fe jn jo jp jq b">dialog</code>的<code class="fe jn jo jp jq b">returnValue</code>，这对于指示用户使用哪个按钮关闭它很有用。</li><li id="10cf" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">show()</code> —一个无模式显示对话框的对话框实例方法，这意味着我们仍然允许来自外部的交互。这不需要争论。</li><li id="c8e5" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">showModal()</code> —一个对话框实例方法，将对话框作为模态显示在任何其他对象之上。它与::background伪元素一起显示在顶层。与对话框外的元素的交互被阻止，并且不能与对话框外的内容进行交互。</li></ul><p id="9e1d" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><code class="fe jn jo jp jq b">dialog</code> DOM元素还具有以下值属性:</p><ul class=""><li id="8934" class="mw mx iq kj b kk kl ko kp ks my kw mz la na le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">open</code> —反映<code class="fe jn jo jp jq b">open</code> HTML属性的布尔属性，该属性指示对话框是否为交互而打开。</li><li id="1fee" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated"><code class="fe jn jo jp jq b">returnValue</code> —设置并返回对话框返回值的字符串属性。我们可以直接给它赋值，也可以向<code class="fe jn jo jp jq b">close</code>方法传递一个参数来设置这个属性。</li></ul><p id="edb9" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我们不需要调用<code class="fe jn jo jp jq b">close()</code>方法来关闭对话框。有个按钮就够了。此外，我们不必单击按钮来关闭对话框，我们也可以按键盘上的Esc键来关闭对话框。</p><p id="847b" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">注意在Firefox上默认情况下<code class="fe jn jo jp jq b">dialog</code>元素是不启用的。要在Firefox中使用它，我们必须在<code class="fe jn jo jp jq b">about:config</code>页面中将<code class="fe jn jo jp jq b">dom.dialog_element.enabled</code>设置为<code class="fe jn jo jp jq b">true</code>。Chrome默认启用了这个功能。然后，如果我们单击刚才制作的“打开对话框”按钮，我们将看到一个本机浏览器对话框。然后，如果我们按下Esc键关闭对话框，那么<code class="fe jn jo jp jq b">cancel</code>事件将被触发，我们分配给<code class="fe jn jo jp jq b">dialog.oncancel</code>的事件处理函数将运行。事件处理函数的<code class="fe jn jo jp jq b">event</code>参数将获得一个<code class="fe jn jo jp jq b">Event</code>对象，其中包含关于<code class="fe jn jo jp jq b">cancel</code>事件源的信息，也就是我们的<code class="fe jn jo jp jq b">dialog</code>元素。因此，在我们的<code class="fe jn jo jp jq b">console.log</code>输出中，我们将得到类似如下的内容:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="9342" class="mq lg iq jq b gy mr ms l mt mu">bubbles: false<br/>cancelBubble: false<br/>cancelable: true<br/>composed: false<br/>currentTarget: null<br/>defaultPrevented: false<br/>eventPhase: 0<br/>isTrusted: true<br/>path: (5) [dialog#dialog, body, html, document, Window]<br/>returnValue: true<br/>srcElement: dialog#dialog<br/>target: dialog#dialog<br/>timeStamp: 1102.240000385791<br/>type: "cancel"</span></pre><p id="6691" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">要查看关于<code class="fe jn jo jp jq b">Event</code>对象属性的更多细节，我们可以查看本系列的前几部分。</p><figure class="mi mj mk ml gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi nk"><img src="../Images/c2cb15cc5d4d56e331557b1293f53b6a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GfKaYubPoK9vNeQX"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk">Photo by <a class="ae kg" href="https://unsplash.com/@wbayreuther?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">William Bayreuther</a> on <a class="ae kg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="1e1b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在线播放</h1><p id="0d51" class="pw-post-body-paragraph kh ki iq kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le ij bi translated">当我们想要处理<code class="fe jn jo jp jq b">canplay</code>事件时，我们可以给<code class="fe jn jo jp jq b">oncanplay</code>属性分配一个事件处理函数。当用户代理可以播放媒体，但估计没有加载足够的数据来播放媒体直到其结束而不必停止以进一步缓冲内容时，触发<code class="fe jn jo jp jq b">canplay</code>事件。例如，我们可以将它用于视频，以查看是否下载了足够的视频部分来播放，直到结束，我们可以首先将视频元素添加到HTML代码中:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="5e55" class="mq lg iq jq b gy mr ms l mt mu">&lt;video width="320" height="240" controls id='video'&gt;<br/>  &lt;source src="<a class="ae kg" href="https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4" rel="noopener ugc nofollow" target="_blank">https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4</a>" type="video/mp4"&gt;<br/>&lt;/video&gt;</span></pre><p id="59bf" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后在我们的JavaScript代码中，我们可以添加以下代码来检查视频是否下载了足够的内容来播放:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="4020" class="mq lg iq jq b gy mr ms l mt mu">const video = document.getElementById('video');<br/>video.oncanplay = (event) =&gt; {<br/>  console.log(event);<br/>}</span></pre><p id="5652" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我们还可以通过在视频DOM节点上使用<code class="fe jn jo jp jq b">addEventListener</code>方法来附加<code class="fe jn jo jp jq b">canplay</code>事件监听器，如以下代码所示:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="2546" class="mq lg iq jq b gy mr ms l mt mu">const video = document.getElementById('video');<br/>video.addEventListener('canplay', (event) =&gt; {<br/>  console.log(event);<br/>});</span></pre><p id="d11d" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">无论哪种方式，我们都可以通过使用媒体元素(包括视频和音频元素)的<code class="fe jn jo jp jq b">readyState</code>属性来检查是否已经下载了足够多的媒体部分，以便完成它。<code class="fe jn jo jp jq b">readyState</code>可以有以下可能值之一:</p><ul class=""><li id="260a" class="mw mx iq kj b kk kl ko kp ks my kw mz la na le nb nc nd ne bi translated">常量<code class="fe jn jo jp jq b">HAVE_NOTHING </code>或数字<code class="fe jn jo jp jq b">0</code> —没有关于媒体资源的信息</li><li id="bb30" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated">常量<code class="fe jn jo jp jq b">HAVE_METADATA</code>或数字<code class="fe jn jo jp jq b">1</code> —媒体资源的足够部分已经被下载，元数据属性被初始化。在本州或更远的地方寻找不会引发异常</li><li id="ea98" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated">常量<code class="fe jn jo jp jq b">HAVE_CURRENT_DATA</code>或数字<code class="fe jn jo jp jq b">2</code> —当前播放位置有足够的数据，但不足以实际播放一帧以上</li><li id="3d69" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated">常数<code class="fe jn jo jp jq b">HAVE_FUTURE_DATA</code>或数字<code class="fe jn jo jp jq b">3</code>——下载了当前播放位置的足够数据，以及至少播放到未来一点的足够数据，这意味着至少2帧视频。</li><li id="392f" class="mw mx iq kj b kk nf ko ng ks nh kw ni la nj le nb nc nd ne bi translated">常数<code class="fe jn jo jp jq b">HAVE_ENOUGH_DATA</code>或数字<code class="fe jn jo jp jq b">4</code>——有足够的数据可用，下载速率足够高，媒体可以不间断地播放到结束。</li></ul><p id="ad88" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我们可以通过编写以下代码来获取视频元素的<code class="fe jn jo jp jq b">readyState</code>属性:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="3788" class="mq lg iq jq b gy mr ms l mt mu">const video = document.getElementById('video');<br/>video.oncanplay = (event) =&gt; {<br/>  console.log(event.target.readyState);<br/>}</span></pre><p id="6f0e" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如果我们的视频可以一直播放，我们应该有4个记录在<code class="fe jn jo jp jq b">console.log</code>输出中。</p><p id="aae8" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><code class="fe jn jo jp jq b">document</code>对象的<code class="fe jn jo jp jq b">onfocus</code>属性让我们为<code class="fe jn jo jp jq b">focus</code>事件设置一个事件处理程序。我们可以用它来检查我们的元素是否是焦点。为了关注非输入元素，我们可以给它添加一个<code class="fe jn jo jp jq b">tabindex</code>属性。为了处理<code class="fe jn jo jp jq b">dialog</code>元素关闭时的情况，我们可以使用<code class="fe jn jo jp jq b">oncancel</code>事件处理程序。当按下键盘上的Esc键时，触发相应的事件，即<code class="fe jn jo jp jq b">cancel</code>事件。当我们想要处理<code class="fe jn jo jp jq b">canplay</code>事件时，我们可以为<code class="fe jn jo jp jq b">oncanplay</code>属性分配一个事件处理函数，该事件是当用户代理可以播放媒体时触发的，但估计没有足够的数据加载来播放媒体直到其结束，而不必停止以获得更多的内容缓冲。我们可以通过检查media元素中的<code class="fe jn jo jp jq b">readyState</code>来检查媒体是否下载了足够的数据来播放。</p></div></div>    
</body>
</html>