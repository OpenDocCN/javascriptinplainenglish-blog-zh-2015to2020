<html>
<head>
<title>Object-Oriented JavaScript — Async Scripts and Namespacing</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的JavaScript——异步脚本和命名空间</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-oriented-javascript-async-scripts-and-namespacing-5fe20e24c31e?source=collection_archive---------9-----------------------#2020-11-24">https://javascript.plainenglish.io/object-oriented-javascript-async-scripts-and-namespacing-5fe20e24c31e?source=collection_archive---------9-----------------------#2020-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e0ceb04f04abd4f42d12a5c87c6146cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NAKddByclKVrRaoI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jcbesser?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Besser</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1578" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些基本的编码和设计模式。</p><h1 id="4931" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步JavaScript加载</h1><p id="6fdd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">默认情况下，脚本标签是同步加载的。</p><p id="2bfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着它们按照在代码中添加的顺序加载。</p><p id="3a61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们可以将脚本标签移到页面底部，这样我们就可以先看到HTML内容。</p><p id="6d4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">HTML5有<code class="fe me mf mg mh b">defer</code>属性让我们异步加载脚本，但是是按照它们被添加的顺序。</p><p id="04c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dafb" class="mq lc iq mh b gy mr ms l mt mu">&lt;script defer src="script.js"&gt;&lt;/script&gt;</span></pre><p id="5d1f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是在脚本的底部添加了<code class="fe me mf mg mh b">defer</code>属性。</p><p id="76e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">旧的浏览器不支持这一点，但是我们可以通过用JavaScript加载我们的脚本来做同样的事情。</p><p id="42e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9fe1" class="mq lc iq mh b gy mr ms l mt mu">&lt;script&gt;<br/>  (function() {<br/>    const s = document.createElement('script');<br/>    s.src = 'script.js';<br/>    document.getElementsByTagName('head')[0].appendChild(s);<br/>  }());</span><span id="75b5" class="mq lc iq mh b gy mv ms l mt mu">&lt;/script&gt;</span></pre><p id="5c0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建一个脚本元素，将<code class="fe me mf mg mh b">src</code>值设置为脚本路径，并将其作为<code class="fe me mf mg mh b">head</code>标签的子标签。</p><h1 id="d4a5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">名称空间</h1><p id="7530" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将一个对象添加到应用程序的名称空间中。</p><p id="35b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们的应用程序中就不会有这么多全局变量。</p><p id="0a42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3f65" class="mq lc iq mh b gy mr ms l mt mu">let APP = APP || {};</span></pre><p id="8003" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个<code class="fe me mf mg mh b">MYAPP</code>名称空间。</p><p id="6656" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过编写以下内容向其添加属性:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1e58" class="mq lc iq mh b gy mr ms l mt mu">APP.event = {};</span></pre><p id="35ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以向<code class="fe me mf mg mh b">event</code>属性添加属性:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3132" class="mq lc iq mh b gy mr ms l mt mu">APP.event = {<br/>  addListener(el, type, fn) {<br/>    // .. <br/>  },<br/>  removeListener(el, type, fn) {<br/>    // ...<br/>  },<br/>  getEvent(e) {<br/>    // ...<br/>  }<br/>  // ... <br/>};</span></pre><h1 id="124f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">命名空间构造函数</h1><p id="2cc5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将构造函数放在命名空间对象中。</p><p id="2235" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8eed" class="mq lc iq mh b gy mr ms l mt mu">APP.dom = {};<br/>APP.dom.Element = function(type, properties) {<br/>  const tmp = document.createElement(type);<br/>  //...<br/>  return tmp;<br/>};</span></pre><p id="5fdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe me mf mg mh b">Element</code>构造函数来创建一些对象。</p><h1 id="863f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">命名空间()方法</h1><p id="cbd0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建一个<code class="fe me mf mg mh b">namespace</code>方法来动态创建我们的名称空间。</p><p id="b967" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7ea8" class="mq lc iq mh b gy mr ms l mt mu">APP.namespace = (name) =&gt; {<br/>  const parts = name.split('.');<br/>  let current = APP;<br/>  for (const part of parts) {<br/>    if (!current[part]) {<br/>      current[part] = {};<br/>    }<br/>    current = current[part];<br/>  }<br/>};</span></pre><p id="ecc5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了一个<code class="fe me mf mg mh b">namespace</code>方法，它采用由点分隔的单词组成的字符串。</p><p id="1945" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们通过循环将属性添加到<code class="fe me mf mg mh b">current</code>对象中。</p><p id="1377" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们定义了它，我们就可以通过编写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f561" class="mq lc iq mh b gy mr ms l mt mu">APP.namespace('foo.bar.baz');</span><span id="4223" class="mq lc iq mh b gy mv ms l mt mu">console.log(APP);</span></pre><p id="8b5c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在控制台日志中看到了<code class="fe me mf mg mh b">foo.bar.baz</code>属性。</p><h1 id="4c5b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">初始化时分支</h1><p id="edf4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">不同的浏览器可能具有实现相同功能的不同功能。</p><p id="b6c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以检查它们，并通过检查哪个存在来添加我们想要的功能，然后将存在的功能添加到我们的名称空间对象中。</p><p id="c2da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d64f" class="mq lc iq mh b gy mr ms l mt mu">let APP = {};</span><span id="b75e" class="mq lc iq mh b gy mv ms l mt mu">if (window.addEventListener) {<br/>  APP.event.addListener = function(el, type, fn) {<br/>    el.addEventListener(type, fn, false);<br/>  };<br/>  APP.event.removeListener = function(el, type, fn) {<br/>    el.removeEventListener(type, fn, false);<br/>  };<br/>} else if (document.attachEvent) {<br/>  APP.event.addListener = function(el, type, fn) {<br/>    el.attachEvent(`on${type}`, fn);<br/>  };<br/>  APP.event.removeListener = function(el, type, fn) {<br/>    el.detachEvent(`on${type}`, fn);<br/>  };<br/>} else {<br/>  APP.event.addListener = function(el, type, fn) {<br/>    el[`on${type}`] = fn;<br/>  };<br/>  APP.event.removeListener = function(el, type) {<br/>    el[`on${type}`] = null;<br/>  };<br/>}</span></pre><p id="89c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们检查不同版本的<code class="fe me mf mg mh b">addEventListener</code>和<code class="fe me mf mg mh b">removeEventListener</code>以及它们的等价物，并将它们放入我们的名称空间中。</p><p id="56e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将所有的特性检测代码放在一个地方，这样我们就不必重复那么多次。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/8437d2c405537173f0364d98dfcdf429.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7EmHdVFp5DM9AR7B"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@vincentiu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Vincentiu Solomon</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="9c5b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d7ac" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建名称空间对象来使我们的代码远离全局名称空间。</p><p id="9104" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript脚本可以异步加载。</p><p id="a6b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>