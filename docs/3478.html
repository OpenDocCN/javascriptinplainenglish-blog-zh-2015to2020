<html>
<head>
<title>Concrete Examples of Dependency Injection in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中依赖注入的具体例子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/examples-of-dependency-injection-in-react-73b5f7a9f407?source=collection_archive---------5-----------------------#2020-10-02">https://javascript.plainenglish.io/examples-of-dependency-injection-in-react-73b5f7a9f407?source=collection_archive---------5-----------------------#2020-10-02</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b0db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">依赖注入是控制反转的一种形式。组件依赖关系的创建不是组件内部的一部分。它们是在组件的公共接口上定义的。它们允许解耦设计，并使测试更容易。</p><p id="72dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这些接缝允许用一个具体实现替换另一个具体实现。它们还允许在测试过程中用模仿或伪造来替代依赖。</p><p id="6ebf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这篇文章是关于在React中使用依赖注入的经验教训。</p><h2 id="191d" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">吸取的经验教训</strong></h2><p id="3ff0" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">我学到的最大教训是，面向公众的React接缝是组件的道具和子组件。</p><p id="2b2c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Props定义了组件将在其内部引用和利用的特定依赖关系。家长将确定这些道具的具体实现。可以在子组件中默认一个属性，而不通过父组件传递任何东西，但是，这仍然意味着这些属性是在面向公众的接口中定义的，而不是隐藏在组件本身的内部。</p><p id="f5dc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">组件的子组件是另一个接缝。当使用composition构造组件时，您可以定义为给定的父组件呈现哪些子组件。当您需要重新组织结构并将一个多态子组件替换为另一个多态子组件时，您不需要改变父组件的内部来实现这一点。</p><h2 id="600f" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">案例分析</strong></h2><p id="f988" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">让我们来谈谈这是如何使测试变得更容易的。假设我们有一个馅饼公司的web应用程序。在我们的应用程序中，我们有一个用户可以填写来订购馅饼的表单。</p><p id="1ac1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们的代码中，我们希望构建一个名为OrderPie的组件，它连接到数据存储并在页面上显示用户名，另一个名为PieForm的组件显示表单并允许用户提交订单详细信息。该表单有各种验证，以确保用户提供所有必需的信息。</p><p id="99b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请注意，示例中有一些伪代码，用于隐藏与数据存储、路由和端点调用相关的无关实现细节。这将允许我们关注React组件本身的结构。</p><h2 id="5749" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">例1:表单解耦</strong></h2><p id="9f12" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">现在，假设我们正在测试OrderPie组件，确保用户在提交表单时被重定向到订单预览页面。这个测试不关心用户点了什么或者用户是否输入了所有需要的数据。它只想确保用户在提交表单时被发送到正确的页面。</p><p id="158f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">将表单作为道具传递给组件允许我们定义一个协作者。</p><p id="6466" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TestForm和PieForm组件也是多态的。它们在数量、命名和类型方面包含相同的道具，并且可以在不破坏任何功能的情况下相互替换。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/c91c9598dc9fd70fa46810da9d2c5cb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*J_vlwCbNhNXHNfZo-3BWSw.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The test injects a fake form that has no validation rules for form submission</figcaption></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ls"><img src="../Images/a03e09c07c3b7f6fd7991b75e1a08c1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1344/format:webp/1*9VKoZP6BMdTQ2_fcfhrZfA.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The application code injects a different form with rules for validating data</figcaption></figure><p id="65b7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这允许我们在产品代码中使用真实的表单，在测试代码中使用虚假的表单。这也允许我们对这个特性进行单元测试，而不需要处理真实表单及其验证的昂贵的集成测试。</p><h2 id="d8ab" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">示例2:解耦端点动作</strong></h2><p id="2aca" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">假设我们还需要测试OrderPie组件调用端点来发布/Pie的能力。这个测试不涉及实际的端点调用本身，而只是在表单提交时进行。</p><p id="a9ae" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们在OrderPie组件本身中直接调用这个动作，它将是组件内部工作的一部分。我们不能窥探这个函数来确保它被调用的原因与私有函数不能被测试和类中的具体实现不能被替换的原因是一样的。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/b20b8408455234f15790e27c1a47df75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*ZfhQD0Gvo1t3S6uVjPCExg.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The test injects a spy for the orderAction prop</figcaption></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/91a34c75656e18a7af1a62b2935ef20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*wf2wKevsPCjLPrbY-FfXjg.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The application code injects an orderPie function that makes real http calls</figcaption></figure><p id="376e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们反转控件并通过道具传递这个动作时，我们现在可以监视它并确保它在该调用的时候被调用。我们也可以用一个假的动作来代替，这样单元测试就不会在表单提交时进行真正的端点调用。</p><h2 id="19a6" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">示例3:分离组件的渲染</strong></h2><p id="8705" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">在最后一个例子中，假设我们还需要测试应用程序的能力，以防止用户在账单拖欠时订购馅饼。该应用程序将显示待处理费用页面，而不是显示饼状图订单。</p><p id="dab6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了遵守组合和单一责任原则，我们将构建一个名为CheckForOutstandingCharges的组件，它的唯一职责是从商店获取用户的账单历史，并决定是否重定向到待处理费用页面。该测试并不关心当没有拖欠时确切地显示什么组件，只关心它们确实显示了。</p><p id="86cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们希望能够在产品代码中呈现实际的OrderPie组件，并在单元测试中呈现一个假组件。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/2530aedb2340a4acfcb6251ff9981e87.png" data-original-src="https://miro.medium.com/v2/resize:fit:1278/format:webp/1*QlVfu5YDbZYEmMAsr9D8mQ.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The tests injects a fake child component to see if it renders when a user has pending charges</figcaption></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="lw lx di ly bf lz"><div class="gh gi lv"><img src="../Images/743f5a8483f96e04ae12fd85e0e7402d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/1*lpLEpu2BNmxwH9jkyKy7DA.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">The application code injects a real component in the children</figcaption></figure><p id="bf7b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当测试CheckForOutstandingCharges组件时，我们可以隔离我们的范围，以确保该组件的行为是独立的。我们可以检查当没有拖欠时它的孩子被呈现，当有拖欠时用户被重定向到期望的页面。应用程序的结构和孩子到底是什么，不是我们所关心的。</p><h2 id="071b" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated"><strong class="ak">总之</strong></h2><p id="e70a" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">这种设计的好处是，您可以避免对特性进行集成测试。由于组件中定义良好、面向公众的接缝，您可以利用解耦的、粒度的、更快、更容易的单元测试。</p></div></div>    
</body>
</html>