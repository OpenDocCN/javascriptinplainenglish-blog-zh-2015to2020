<html>
<head>
<title>Object Mutability in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的对象可变性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-ways-to-fix-object-mutability-6b0cbdeab28b?source=collection_archive---------6-----------------------#2019-09-21">https://javascript.plainenglish.io/javascript-ways-to-fix-object-mutability-6b0cbdeab28b?source=collection_archive---------6-----------------------#2019-09-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f18dcd36edcdf3728e31f67be7c70f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wIrETgDEJ8o_30iLESqw9A.png"/></div></div></figure><p id="898e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">JavaScript是动态类型语言，这意味着类型不像其他面向对象语言那样在编译时定义。JavaScript提供了两种数据类型分类。</p><ol class=""><li id="d310" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated">原始值</li><li id="9212" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated">参考值</li></ol><blockquote class="lh li lj"><p id="8559" class="jv jw lk jx b jy jz ka kb kc kd ke kf ll kh ki kj lm kl km kn ln kp kq kr ks ig bi translated"><strong class="jx io">原语值:<br/> </strong>在JavaScript中，原语是指不是对象也没有方法的数据。有7种原始数据类型:字符串、数字、布尔、空、未定义、符号、bigint。</p><p id="8e98" class="jv jw lk jx b jy jz ka kb kc kd ke kf ll kh ki kj lm kl km kn ln kp kq kr ks ig bi translated">大多数情况下，原语值直接在语言实现的最低层表示。</p><p id="a456" class="jv jw lk jx b jy jz ka kb kc kd ke kf ll kh ki kj lm kl km kn ln kp kq kr ks ig bi translated">所有的原语都是<strong class="jx io">不可变的</strong>，也就是说，它们不能被改变。重要的是不要把原语本身与被赋予原语值的变量混淆。可以给变量重新分配一个新值，但是不能像改变对象、数组和函数那样改变现有值。— <a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" rel="noopener ugc nofollow" target="_blank">来源— MDN </a></p></blockquote><p id="e464" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">打破上面的定义，这仅仅意味着在原始值的情况下，它在内存中为定义的变量创建并分配一个固定的位置。原始值存储在<a class="ae lo" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">堆栈</strong> </a> <strong class="jx io"> </strong>中，名称本身足够直观，可以理解为是一个数据堆栈<strong class="jx io"> </strong>，具有<strong class="jx io"> LIFO </strong>，即第一个操作中的最后一个。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="7f21" class="ly lz in lu b gy ma mb l mc md"><em class="lk">// Primitive Values..</em></span><span id="3c6b" class="ly lz in lu b gy me mb l mc md"><em class="lk">let</em> testString = 'Hello World';</span><span id="2037" class="ly lz in lu b gy me mb l mc md"><em class="lk">let</em> testString1 = testString;</span><span id="af56" class="ly lz in lu b gy me mb l mc md">console.log('testString:', testString);<em class="lk"> // Hello World</em></span><span id="2650" class="ly lz in lu b gy me mb l mc md">console.log('testNumber:', testString1 );<em class="lk"> // Hello World</em></span><span id="f7ff" class="ly lz in lu b gy me mb l mc md">testString1  = 123;</span><span id="4ba3" class="ly lz in lu b gy me mb l mc md">console.log('testString:', testString);<em class="lk"> // Hello World</em></span><span id="92f4" class="ly lz in lu b gy me mb l mc md">console.log('testNumber:', testString1 );<em class="lk"> // 123</em></span></pre><p id="59dd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们在上面的代码片段中看到的，它复制、粘贴并在堆栈上分配一个新位置。</p><figure class="lp lq lr ls gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mf"><img src="../Images/b88853accff96f53486151717e509759.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d7kBTAQWL0exM-Wxx8OBYA.png"/></div></div></figure><p id="1b88" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">参考值:</strong></p><p id="301d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">引用值是存储在堆中的对象。<a class="ae lo" href="https://en.wikipedia.org/wiki/Heap_(data_structure)" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">堆</strong> </a>是一种不同于<a class="ae lo" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank"> <strong class="jx io">堆</strong> </a>的内存。Heap <strong class="jx io"> </strong>访问时间稍长，在数据动态变化的情况下能够容纳更多的数据。堆是这样一种内存，其中的元素不像在堆栈中那样一个接一个地存储，而是随机存储，因此每个元素都有自己的地址。引用值主要是对象和数组(它们是对象的类型)。为了在JavaScript中维护数组和对象，我们同时使用堆栈和堆。</p><p id="1a7e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">下面的代码片段显示了对象的可变性。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="6235" class="ly lz in lu b gy ma mb l mc md"><em class="lk">// Reference Values ..</em></span><span id="eb04" class="ly lz in lu b gy me mb l mc md"><em class="lk">let</em> testObject = {</span><span id="c432" class="ly lz in lu b gy me mb l mc md">name : 'Chandler',</span><span id="0d6f" class="ly lz in lu b gy me mb l mc md">age: 28,</span><span id="67bf" class="ly lz in lu b gy me mb l mc md">address: 'New York'</span><span id="ca57" class="ly lz in lu b gy me mb l mc md">};</span><span id="3f53" class="ly lz in lu b gy me mb l mc md"><em class="lk">let</em> testObject1 = testObject;</span><span id="193e" class="ly lz in lu b gy me mb l mc md">console.log('testObject:', testObject.name);<em class="lk">    // Chandler</em></span><span id="a560" class="ly lz in lu b gy me mb l mc md">console.log('testObject1:', testObject1.name);<em class="lk">  // Chandler</em></span><span id="66d4" class="ly lz in lu b gy me mb l mc md">testObject1.name = 'Janice';</span><span id="7e06" class="ly lz in lu b gy me mb l mc md">console.log('testObject:', testObject.name);<em class="lk">    // Janice</em></span><span id="494e" class="ly lz in lu b gy me mb l mc md">console.log('testObject1:', testObject1.name);<em class="lk"> // Janice</em></span></pre><figure class="lp lq lr ls gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="7233" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在这里，我们看到两个对象包含与属性相关的相同值，这是因为对象以特殊方式处理，即堆栈上的内存块保存该对象的内存地址(指针),该地址又存储在堆中。</p><figure class="lp lq lr ls gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mi"><img src="../Images/a38f5b868251ae168f044d130ab079f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ty0eEGvhDLlsOdFlAOxOqw.png"/></div></div></figure><p id="5cc3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">正如我们在上面的表示中看到的，当一个对象通过赋值创建时，它不会分配新的内存块，而是创建一个新的指针块并推送到堆栈上，两个指针都指向内存中的同一个位置，导致指向内存中元素位置的变量发生变化。</p><p id="1234" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看看数组在改变时的行为。</p><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="c1c0" class="ly lz in lu b gy ma mb l mc md"><em class="lk">// lets us check what if we push on Array</em></span><span id="6c33" class="ly lz in lu b gy me mb l mc md"><em class="lk">let</em> testObject = {</span><span id="ec18" class="ly lz in lu b gy me mb l mc md">name : 'Chandler',</span><span id="e82f" class="ly lz in lu b gy me mb l mc md">age: 28,</span><span id="f714" class="ly lz in lu b gy me mb l mc md">address: 'New York',</span><span id="5826" class="ly lz in lu b gy me mb l mc md">friends: ['Monica', 'Ross', 'Joey']</span><span id="3a97" class="ly lz in lu b gy me mb l mc md">};</span><span id="b61c" class="ly lz in lu b gy me mb l mc md"><em class="lk">let</em> testObject1 = testObject;<br/>testObject1.friends.push('Racheal');<br/>console.log('testObject:', testObject.friends);</span><span id="b177" class="ly lz in lu b gy me mb l mc md"><em class="lk">// ['Monica', 'Ross', 'Joey', 'Racheal']</em></span><span id="29b9" class="ly lz in lu b gy me mb l mc md">console.log('testObject1:', testObject1.friends);</span><span id="8f83" class="ly lz in lu b gy me mb l mc md"><em class="lk">// ['Monica', 'Ross', 'Joey', 'Racheal']</em></span></pre><figure class="lp lq lr ls gt jo"><div class="bz fp l di"><div class="mg mh l"/></div></figure><p id="2d19" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以用多种方法避免可变性</p><ul class=""><li id="137b" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks mj kz la lb bi translated">ES5 Object.assign : <br/>该方法用于将所有可枚举的自身属性的值从一个或多个源对象复制到一个目标对象。</li></ul><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="c024" class="ly lz in lu b gy ma mb l mc md"><em class="lk">const</em> testObject2 = Object.assign({}, testObject);</span><span id="4813" class="ly lz in lu b gy me mb l mc md">testObject2.name = 'Paul';</span><span id="01d6" class="ly lz in lu b gy me mb l mc md">console.log(testObject.name);<em class="lk"> // Chandler</em></span><span id="0d78" class="ly lz in lu b gy me mb l mc md">console.log(testObject2.name);<em class="lk"> // Paul</em></span></pre><ul class=""><li id="b774" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks mj kz la lb bi translated">ES5 Array slice():<br/>slice()方法将一个数组的一部分的浅拷贝返回到一个从开始到结束(不包括结束)选择的新数组对象中，其中begin和end表示该数组中项的索引。原始数组不会被修改。</li></ul><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="ec95" class="ly lz in lu b gy ma mb l mc md"><em class="lk">const</em> testObject2 = Object.assign({}, testObject);</span><span id="e5d1" class="ly lz in lu b gy me mb l mc md">testObject2.friends = testObject.friends.slice();</span><span id="8afc" class="ly lz in lu b gy me mb l mc md">testObject2.friends.push('George');</span><span id="3c24" class="ly lz in lu b gy me mb l mc md">console.log(testObject.friends);</span><span id="fb1f" class="ly lz in lu b gy me mb l mc md"><em class="lk">// [ 'Monica', 'Ross', 'Joey', 'Racheal' ]</em></span><span id="e3ce" class="ly lz in lu b gy me mb l mc md">console.log(testObject2.friends);</span><span id="9431" class="ly lz in lu b gy me mb l mc md"><em class="lk">// [ 'Monica', 'Ross', 'Joey', 'Racheal', 'George' ]</em></span></pre><ul class=""><li id="52c3" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks mj kz la lb bi translated">ES6 <a class="ae lo" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> spread </a> operator: <br/>这个方法将自己的可枚举属性从一个提供的对象复制到一个新的对象中。</li></ul><pre class="lp lq lr ls gt lt lu lv lw aw lx bi"><span id="a322" class="ly lz in lu b gy ma mb l mc md"><em class="lk">// ES6 spread operator for Objects.</em></span><span id="7311" class="ly lz in lu b gy me mb l mc md"><em class="lk">let</em> testObject = {</span><span id="bae0" class="ly lz in lu b gy me mb l mc md">name : 'Chandler',</span><span id="53ad" class="ly lz in lu b gy me mb l mc md">age: 28,</span><span id="4cf4" class="ly lz in lu b gy me mb l mc md">address: 'New York'</span><span id="9f79" class="ly lz in lu b gy me mb l mc md">};</span><span id="02a2" class="ly lz in lu b gy me mb l mc md"><em class="lk">const</em> testObject2 = {...testObject};<br/>testObject2.name = 'Paul';</span><span id="d50a" class="ly lz in lu b gy me mb l mc md">console.log('testObject:', testObject.name);<em class="lk">    // Janice</em></span><span id="6855" class="ly lz in lu b gy me mb l mc md">console.log('testObject1:', testObject2.name);<em class="lk"> // Paul</em></span><span id="6b11" class="ly lz in lu b gy me mb l mc md"><em class="lk">// ES6 spread operator for Arrays.</em></span><span id="15ca" class="ly lz in lu b gy me mb l mc md"><em class="lk">const</em> testObject2 = {...testObject};</span><span id="6dbf" class="ly lz in lu b gy me mb l mc md">testObject2.friends = [...testObject.friends];</span><span id="4062" class="ly lz in lu b gy me mb l mc md">testObject2.friends.push('George');</span><span id="44d0" class="ly lz in lu b gy me mb l mc md">console.log(testObject.friends);</span><span id="00f1" class="ly lz in lu b gy me mb l mc md"><em class="lk">// [ 'Monica', 'Ross', 'Joey', 'Racheal' ]</em></span><span id="ac48" class="ly lz in lu b gy me mb l mc md">console.log(testObject2.friends);</span><span id="1932" class="ly lz in lu b gy me mb l mc md"><em class="lk">// [ 'Monica', 'Ross', 'Joey', 'Racheal', 'George' ]</em></span></pre><ul class=""><li id="0124" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks mj kz la lb bi translated">使用<a class="ae lo" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank">Loadash</a>T7】_。clone(value) <br/>该方法创建所提供值的浅层副本。<br/> _。cloneDeep(value) <br/>这个方法类似于clone，只是它递归地克隆值。</li></ul><blockquote class="mk"><p id="b72e" class="ml mm in bd mn mo mp mq mr ms mt ks dk translated">注意:默认情况下，除了_之外的所有方法。cloneDeep创建数据的浅层副本。</p></blockquote><p id="328e" class="pw-post-body-paragraph jv jw in jx b jy mu ka kb kc mv ke kf kg mw ki kj kk mx km kn ko my kq kr ks ig bi translated">我希望通过这篇文章，我能够区分原始值和参考值。</p><p id="fbab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你觉得这篇文章很有帮助并且喜欢它，请随意与你的朋友和同事分享。</p><p id="c991" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你有任何问题、建议或想要联系我吗？在LinkedIN<a class="ae lo" href="https://www.linkedin.com/in/muneer-zargar-fe-dev/" rel="noopener ugc nofollow" target="_blank">上给我留言或者在下面评论。</a></p><p id="e2c4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我也可以在推特上通过@zargarmuneer90找到我。</p></div></div>    
</body>
</html>