<html>
<head>
<title>9 Upcoming Canvas 2D Features to Look Forward to</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">9即将推出的画布2D功能值得期待</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/9-upcoming-canvas-2d-features-to-look-forward-to-a18d17647568?source=collection_archive---------10-----------------------#2020-12-29">https://javascript.plainenglish.io/9-upcoming-canvas-2d-features-to-look-forward-to-a18d17647568?source=collection_archive---------10-----------------------#2020-12-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="75d8" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">今天可以在Chrome上预览，很快会在其他浏览器上推出</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3cce43186c6bb145cbd196b88687061d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*w7atiVvNfl_4VK1R"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@danielkcheung?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daniel Cheung</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8fe7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Canvas API提供了一种使用JavaScript和HTML <code class="fe lp lq lr ls b"><a class="ae ks" href="http://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas" rel="noopener ugc nofollow" target="_blank">&lt;canvas&gt;</a></code>元素在web上绘制图形的方法，主要关注2D图形。作为一个通用的位图操作框架，它可以用于动画、游戏图形、实时视频处理、数据可视化、图像操作等等。</p><p id="b554" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是不幸的是，引用<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" rel="noopener ugc nofollow" target="_blank"> MDN Web文档</a>:<em class="lt">“Canvas API非常强大，但并不总是易于使用。”</em></p><p id="f5bb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是因为画布2D是一个相对低级的光栅图形API，其中视觉需要在像素级进行操作，交互需要手动管理。例如，要绘制一个圆角矩形，您可以使用DOM或SVG用一行HTML和最少的CSS简单地声明它，但是您需要使用画布2D编写至少10行JavaScript来完成同样的工作:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Achieving a rounded rectangle using DOM, SVG, and Canvas 2D. Code by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><p id="ebdb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">批评者会认为，不仅画布2D更难使用，而且SVG或DOM与CSS还可以做画布2D能做的一切，甚至更多。然而，Canvas 2D在抽象方面的不足在底层控制和性能增益方面得到了弥补……大多数时候。一些画布2D API，比如从<code class="fe lp lq lr ls b">&lt;canvas&gt;</code>获取像素数据的<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getImageData" rel="noopener ugc nofollow" target="_blank">getImageData</a></code>，对于某些用例来说可能太慢了。</p><p id="17e9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">作为解决这些问题的第一步，Canvas 2D API正在更新9个新特性集。你甚至可以今天就尝试(大部分)它们！前往Chrome上的<code class="fe lp lq lr ls b">chrome://flags</code>(我个人试过87版)，打开实验画布2D API特性标志:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lw"><img src="../Images/557af6dcfed6636bbe5d7685bc8a4c2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rQ_aGSDM-qqAX0FFxH7JQA.png"/></div></div></figure><p id="84db" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所有这些新特性都计划被添加到官方规范中，所以你可以期待它们最终也能在其他浏览器上使用。您也可以在此阅读更多内容并了解最新动态<a class="ae ks" href="https://github.com/fserb/canvas2d" rel="noopener ugc nofollow" target="_blank">。以下部分提供了这些新功能的概述。</a></p><h1 id="83e6" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">赶上CSS</h1><p id="fde0" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">现代浏览器实现了一组丰富的呈现功能，其中许多功能都可以在CSS中获得。下面的新API弥补了这一差距，为开发人员提供了更多的能力。</p><h2 id="9d52" class="mu ly in bd lz mv mw dn md mx my dp mh lc mz na mj lg nb nc ml lk nd ne mn nf bi translated">圆锥梯度</h2><p id="bcf5" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated"><code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createLinearGradient" rel="noopener ugc nofollow" target="_blank">createLinearGradient()</a></code>和<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/createRadialGradient" rel="noopener ugc nofollow" target="_blank">createRadialGradient()</a></code>现在存在于画布2D API中。它们分别类似于CSS <code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient()" rel="noopener ugc nofollow" target="_blank">linear-gradient()</a></code>和<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/CSS/radial-gradient()" rel="noopener ugc nofollow" target="_blank">radial-gradient()</a></code>。有了新的API，你将能够使用<code class="fe lp lq lr ls b">createConicGradient(startAngle, centerX, centerY)</code>，它类似于CSS <code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/CSS/conic-gradient()" rel="noopener ugc nofollow" target="_blank">conic-gradient()</a></code>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Demonstration of Canvas 2D’s createLinearGradient(), createRadialGradient(), and the new createConicGradient(startAngle, centerX, centerY). Code by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/f71954a156bbee1467f6edecf33a993f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*iUihyrJgE49Fi75_XqVhxA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The output of the above <a class="ae ks" href="https://jsfiddle.net/wlouie1/cs91rkq4/" rel="noopener ugc nofollow" target="_blank">JSFiddle</a> if the browser supports createConicGradient(). Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><h2 id="c0e5" class="mu ly in bd lz mv mw dn md mx my dp mh lc mz na mj lg nb nc ml lk nd ne mn nf bi translated">文本修饰符</h2><p id="73fb" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">CSS支持一系列文本操作和字体选项，这些选项在今天的画布上是没有的，比如<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing" rel="noopener ugc nofollow" target="_blank">letter-spacing</a></code>、<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/CSS/word-spacing" rel="noopener ugc nofollow" target="_blank">word-spacing</a></code>、<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-variant" rel="noopener ugc nofollow" target="_blank">font-variant</a></code>、<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-kerning" rel="noopener ugc nofollow" target="_blank">font-kerning</a></code>、<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/CSS/font-stretch" rel="noopener ugc nofollow" target="_blank">font-stretch</a></code>、<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration" rel="noopener ugc nofollow" target="_blank">text-decoration</a></code>、<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-underline-position" rel="noopener ugc nofollow" target="_blank">text-underline-position</a></code>和<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/CSS/text-rendering" rel="noopener ugc nofollow" target="_blank">text-rendering</a></code>。新的API改变了这一点，它为画布2D添加了CSS类似方法:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Demonstration of Canvas 2D’s new Text Modifier APIs. Code by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/83fe149e2a021a3b4ca634805471faf4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*9tiOKO8UP05-e4dqjIf1cg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The output of the above <a class="ae ks" href="https://jsfiddle.net/wlouie1/mxhL0c8e/" rel="noopener ugc nofollow" target="_blank">JSFiddle</a> depending on browser support. The above is from Chrome 87 with the new APIs turned on. Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><h2 id="8f2e" class="mu ly in bd lz mv mw dn md mx my dp mh lc mz na mj lg nb nc ml lk nd ne mn nf bi translated">透视变换</h2><p id="d956" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">画布2D也可以三维！好的，更像2.5D。不仅现有的<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/scale" rel="noopener ugc nofollow" target="_blank">scale</a></code>、<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/translate" rel="noopener ugc nofollow" target="_blank">translate</a></code>和<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/rotate" rel="noopener ugc nofollow" target="_blank">rotate</a></code>函数得到了<a class="ae ks" href="https://github.com/fserb/canvas2D/blob/master/spec/perspective-transforms.md" rel="noopener ugc nofollow" target="_blank">的增强</a>，现有的<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/transform" rel="noopener ugc nofollow" target="_blank">transform</a></code>和<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setTransform" rel="noopener ugc nofollow" target="_blank">setTransform</a></code>函数也将接受CSS可用于执行透视(非仿射)变换的相同4x4变换矩阵。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ni"><img src="../Images/94b78f2bd29808f2a5b0c4fe17077460.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*IzgxD5i3_HhNRDkBDxwAGQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Screenshot of example CSS perspective transform from <a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/perspective()" rel="noopener ugc nofollow" target="_blank">MDN Web Docs</a>. The same would be easily achievable using Canvas 2D with the new APIs, but it seems Chrome 87 has not implemented it yet.</figcaption></figure><h2 id="3bee" class="mu ly in bd lz mv mw dn md mx my dp mh lc mz na mj lg nb nc ml lk nd ne mn nf bi translated">圆角矩形</h2><p id="0325" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">圆角矩形是非常常用的，但是它们在今天却出奇的难画，正如本文开头的<a class="ae ks" href="https://jsfiddle.net/wlouie1/g5vLtuhd/" rel="noopener ugc nofollow" target="_blank"> JSFiddle </a>所展示的。使用新的画布2D <code class="fe lp lq lr ls b">roundRect()</code>函数，实现圆角矩形只需要一个绘图调用:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lu lv l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Demonstration of Canvas 2D’s roundRect(). Code by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/dcd174893317c8bf62ade591de702570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1030/format:webp/1*Zb2tb595l5PLD0-yxlmT6g.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The output of the above <a class="ae ks" href="https://jsfiddle.net/wlouie1/bLse8v7d/" rel="noopener ugc nofollow" target="_blank">JSFiddle</a> if the browser supports roundRect(). Image by <a class="ae ks" href="https://wilsonlouie.medium.com/" rel="noopener">Author</a>.</figcaption></figure><h1 id="540b" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">改善人体工程学</h1><p id="2c5d" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">对于某些常见的使用模式，添加了简单的内置功能。</p><h2 id="2125" class="mu ly in bd lz mv mw dn md mx my dp mh lc mz na mj lg nb nc ml lk nd ne mn nf bi translated">重置</h2><p id="f464" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">如今没有清理画布的规范方法。如果您过去使用过Canvas，您可能至少完成了以下工作之一:</p><pre class="kd ke kf kg gt nk ls nl nm aw nn bi"><span id="3305" class="mu ly in ls b gy no np l nq nr"><strong class="ls io">const</strong> canvas = document.createElement('canvas');<br/><strong class="ls io">const</strong> ctx = canvas.getContext('2d');<br/><br/>// Doesn't reset the path<br/>ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);<br/><br/>// Not performant<br/>ctx.fillStyle = "white";<br/>ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);<br/><br/>// Works, but feels wrong...<br/>ctx.canvas.width = ctx.canvas.width;<br/><br/>// Best way today<br/>ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);<br/>ctx.beginPath();</span></pre><p id="c3a7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可能也在某个时候质疑过:为什么不能有一个<code class="fe lp lq lr ls b">reset()</code>函数呢？不要再怀疑了，因为新的API正在提供这样的功能:一个<code class="fe lp lq lr ls b">reset()</code>函数，它在一次调用中清除画布、重置路径、重置转换和转换堆栈:</p><pre class="kd ke kf kg gt nk ls nl nm aw nn bi"><span id="e000" class="mu ly in ls b gy no np l nq nr">ctx.<strong class="ls io">reset</strong>();</span></pre><h2 id="1171" class="mu ly in bd lz mv mw dn md mx my dp mh lc mz na mj lg nb nc ml lk nd ne mn nf bi translated">数组颜色输入</h2><p id="4a21" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">使用画布2D设置颜色的当前方法是构建字符串:</p><pre class="kd ke kf kg gt nk ls nl nm aw nn bi"><span id="57d3" class="mu ly in ls b gy no np l nq nr"><strong class="ls io">const</strong> canvas = document.createElement('canvas');<br/><strong class="ls io">const</strong> ctx = canvas.getContext('2d');<br/><br/><strong class="ls io">ctx</strong>.fillStyle = 'rgba(255, 127, 0, 0.5)';<br/><strong class="ls io">ctx</strong>.strokeStyle = 'rgb(255, 0, 0)';</span></pre><p id="9fef" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你想制作颜色变化的动画，这会很烦人。新的API允许通过一系列浮点来指定RGB和RGBA颜色，通过255:</p><pre class="kd ke kf kg gt nk ls nl nm aw nn bi"><span id="2e15" class="mu ly in ls b gy no np l nq nr"><strong class="ls io">const</strong> canvas = document.createElement('canvas');<br/><strong class="ls io">const</strong> ctx = canvas.getContext('2d');<br/><br/>ctx.fillStyle = [1.0, 0.5, 0.0, 0.5];<br/>ctx.strokeStyle = [1.0, 0.0, 0.0];</span></pre><p id="dd59" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">指定色彩空间的能力正在开发中。</p><h2 id="934f" class="mu ly in bd lz mv mw dn md mx my dp mh lc mz na mj lg nb nc ml lk nd ne mn nf bi translated">SVG过滤器</h2><p id="9cf0" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">今天在2D画布上使用SVG过滤器实际上是可能的，但是它很笨重，并且不适用于网络工作者:</p><pre class="kd ke kf kg gt nk ls nl nm aw nn bi"><span id="7b78" class="mu ly in ls b gy no np l nq nr">&lt;<strong class="ls io">svg</strong>&gt;<br/>  &lt;<strong class="ls io">defs</strong>&gt;<br/>    &lt;<strong class="ls io">filter</strong> id="someFilter"&gt;<br/>      ...<br/>    &lt;/<strong class="ls io">filter</strong>&gt;<br/>  &lt;/<strong class="ls io">defs</strong>&gt;<br/>&lt;/<strong class="ls io">svg</strong>&gt;<br/>&lt;<strong class="ls io">script</strong>&gt;<br/>  ctx.filter = "url('#someFilter')";<br/>&lt;/<strong class="ls io">script</strong>&gt;</span></pre><p id="bbeb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了新的API，您将能够为过滤器使用编程性的面向对象接口(例如来自<a class="ae ks" href="https://github.com/fserb/canvas2D/blob/master/spec/filters.md" rel="noopener ugc nofollow" target="_blank">草案规范</a>):</p><pre class="kd ke kf kg gt nk ls nl nm aw nn bi"><span id="f560" class="mu ly in ls b gy no np l nq nr">// Javascript example<br/><strong class="ls io">const</strong> canvas = document.createElement('canvas');<br/><strong class="ls io">const</strong> ctx = canvas.getContext('2d');<br/><br/>// Create filter primitives<br/><strong class="ls io">const</strong> turbulence = new CanvasFilter.Turbulence(<br/>  0.05 /* base frequency */, 2 /* numOctaves */);<br/><strong class="ls io">const</strong> displacementMap = new CanvasFilter.DisplacementMap(<br/>  turbulence /* displacement map */, 30 /* strength */);<br/><strong class="ls io">const</strong> blur = new CanvasFilter.GaussianBlur(2 /* std deviation */);<br/><br/>/*<br/>  Create overall filter, the first primitive will get drawing operations as input<br/>  the output of each primitive will be sent to the input of the following element<br/>  in the array. The final element will output to the screen.<br/><br/>  Here the final filter graph will look like this:<br/><br/>                          turbulence<br/>                              |<br/>  canvasDrawOps -----&gt; displacementMap -------&gt; blur ------&gt; screen<br/>*/<br/>ctx.filter = new CanvasFilter.Sequence([displacementMap, blur]);<br/><br/>// Draw with created filter<br/>ctx.fillStyle = "magenta";<br/>ctx.fillRect(10, 10, 300, 200);<br/><br/>// Modify filter<br/>turbulence.baseFrequency = 1.5; // Denser noise pattern<br/>blur.stdDeviation = 0.5; // Less blur<br/><br/>ctx.filter = new CanvasFilter.Sequence([displacementMap, blur]);<br/>// or, with an update function, just ctx.filter.update()<br/><br/>// Draw on top with modified filter<br/>ctx.fillStyle = "cyan";<br/>ctx.beginPath();<br/>ctx.arc(160, 110, 80, 0, 2 * Math.PI);<br/>ctx.fill();</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ns"><img src="../Images/b398339bc4aa9617e0089120fe0d16c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:702/format:webp/1*jbvUP9Y6WA3tg660ug7sfg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">The output from the above code if the new Canvas 2D filter APIs are available. It seems Chrome 87 has not implemented this yet. Image from the <a class="ae ks" href="https://github.com/fserb/canvas2D/blob/master/spec/filters.md" rel="noopener ugc nofollow" target="_blank">draft spec</a>.</figcaption></figure><h1 id="5813" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">提供更好的性能</h1><p id="9f98" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">最后，许多开发人员抱怨在某些用例中很难(有时是不可能)优化Canvas 2D的性能。</p><h2 id="a4f8" class="mu ly in bd lz mv mw dn md mx my dp mh lc mz na mj lg nb nc ml lk nd ne mn nf bi translated">会经常阅读</h2><p id="5db3" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">在某些使用情况下，尤其是在应用和游戏中，有必要在高频下操纵像素值。这通常是通过<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/getImageData" rel="noopener ugc nofollow" target="_blank">getImageData</a></code>频繁访问像素值来实现的。但是，对于这种情况，此操作可能太慢。</p><p id="4634" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">新的API给<code class="fe lp lq lr ls b"><a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext" rel="noopener ugc nofollow" target="_blank">CanvasRenderingContext2DSettings</a></code>增加了一个<code class="fe lp lq lr ls b">willReadFrequently</code>选项，允许开发者发出画布会被大量阅读的信号。然后，浏览器可以在内部优化读取访问:</p><pre class="kd ke kf kg gt nk ls nl nm aw nn bi"><span id="b71a" class="mu ly in ls b gy no np l nq nr"><strong class="ls io">const</strong> canvas = document.createElement('canvas');<br/><strong class="ls io">const</strong> ctx = canvas.getContext('2d', { <strong class="ls io">willReadFrequently</strong>: true });<br/>ctx.getImageData(0, 0, 200, 200).data;</span></pre><p id="3ec7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这个功能早在火狐中就被引入了，但是它被正式添加到规范中。</p><h2 id="7e0c" class="mu ly in bd lz mv mw dn md mx my dp mh lc mz na mj lg nb nc ml lk nd ne mn nf bi translated">语境缺失</h2><p id="7d37" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">Canvas 2D上下文丢失是一个<a class="ae ks" href="https://github.com/whatwg/html/issues/4809" rel="noopener ugc nofollow" target="_blank">长期存在的问题</a>，尤其是在移动或低端设备上，很容易耗尽资源，例如GPU内存，并引发该问题。一旦用户重新关注页面，就没有优雅的方法来处理这个问题了……直到现在。有了新的API，您可以告诉Canvas在出现问题时自动重新初始化其上下文:</p><pre class="kd ke kf kg gt nk ls nl nm aw nn bi"><span id="5e47" class="mu ly in ls b gy no np l nq nr"><strong class="ls io">const</strong> canvas = document.createElement('canvas');<br/><strong class="ls io">const</strong> ctx = canvas.getContext('2d');<br/><br/>canvas.addEventListener('contextlost', redraw);<br/>canvas.addEventListener('contextrestored', redraw);</span></pre><h1 id="4c98" class="lx ly in bd lz ma mb mc md me mf mg mh jt mi ju mj jw mk jx ml jz mm ka mn mo bi translated">结论</h1><p id="c80b" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">无论您是第一次接触Canvas 2D，已经使用它多年，还是一直在避免使用它，我希望您对这些即将发布的Canvas 2D API感到兴奋。同样，您可以阅读更多内容，并在此处了解最新动态。快乐编码！</p></div></div>    
</body>
</html>