<html>
<head>
<title>Memoization in JavaScript Explained With Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用例子解释JavaScript中的记忆化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/memoization-in-javascript-explained-with-examples-e3d75321514c?source=collection_archive---------6-----------------------#2020-12-30">https://javascript.plainenglish.io/memoization-in-javascript-explained-with-examples-e3d75321514c?source=collection_archive---------6-----------------------#2020-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7d68" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解JavaScript中记忆化的概念</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/72ef4d061874f00ccfa06e385eee5fe1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*S27eB77MpSyxxvdg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@baciutudor?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tudor Baciu</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f63f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="3a10" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">就性能而言，JavaScript中的函数有时会非常昂贵。因此，你的代码可能会非常慢，这会降低你的网站或应用程序的体验。记忆化是一种常用的技术，可以用来显著提高代码速度。它使用缓存来存储结果，以便后续调用耗时的函数时不会在另一时间执行相同的工作。</p><p id="2e63" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在本文中，我们将通过例子介绍JavaScript中记忆化的概念。让我们开始吧。</p><h1 id="c8bc" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">什么是记忆化？</h1><p id="9ce5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">记忆是建立一个函数的过程，这个函数能够记住它以前计算的结果或值。这是一种优化技术，我们缓存函数结果。</p><p id="1824" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们使用一个<em class="mp">记忆</em>函数来计算这个函数，如果它在最后的计算中已经用相同的参数执行过。这样可以节省时间，但是也有不好的一面，那就是我们会消耗更多的内存来保存之前的结果。</p><h1 id="a01f" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">实现记忆功能</h1><p id="1a73" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">JavaScript中的内存化概念用于缓存函数结果，以加速执行缓慢或耗时的函数调用。</p><p id="bc19" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果结果没有被缓存，我们将执行函数并缓存结果。让我们举一个求一个数的平方的例子。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="9f3c" class="mv kx iq mr b gy mw mx l my mz">const square = () =&gt; {<br/>    let cache = {}; // set cache</span><span id="a119" class="mv kx iq mr b gy na mx l my mz">    return (<strong class="mr ir">value</strong>) =&gt; {<br/>        // if exists in cache return from cache<br/>        if (value <strong class="mr ir">in</strong> cache) {<br/>            console.log("Fetching from cache");<br/>            return <strong class="mr ir">cache[value]</strong>;<br/>        } else {<br/>            // If not in cache perform operation<br/>            console.log("Performing expensive query");<br/>            const result = value * value;<br/>            cache[value] = result; // store the value in cache<br/>            return <strong class="mr ir">result</strong>; // return result<br/>        }<br/>    }<br/>}<br/><br/>const sq = square();<br/>console.log(sq(21)); // Performing expensive query, 441<br/>console.log(sq(21)); // Fetching from cache, 441</span></pre><p id="9d2f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如上所述，我们创建了一个函数<code class="fe nb nc nd mr b">square</code>，然后添加了一个变量<code class="fe nb nc nd mr b">cache</code>，并将其设置为一个空对象，以便在其中缓存结果。</p><p id="ebfe" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在函数方块中，我们有一个内部函数来检查缓存中的结果。如果它在缓存中可用，它将返回它。如果不可用，它将把它添加到缓存中，然后返回它。</p><p id="b085" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果您不习惯ES6语法，这里还有一个例子:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="f478" class="mv kx iq mr b gy mw mx l my mz">function memoize(fn) {<br/>  const cache = {};</span><span id="ced5" class="mv kx iq mr b gy na mx l my mz">return function (param) {<br/>    // if exists in cache return from cache<br/>    if (cache[param]) {<br/>      console.log('cached');<br/>      return cache[param];</span><span id="704a" class="mv kx iq mr b gy na mx l my mz">    // If not in cache perform operation<br/>    } else {<br/>      let result = fn(param);<br/>      cache[param] = result;<br/>      console.log(`not cached`);<br/>      return result;<br/>    }<br/>  }<br/>}<br/><br/>const toUpper = (str ="")=&gt; str.toUpperCase();<br/><br/>const toUpperMemoized = memoize(toUpper);<br/><br/>console.log(toUpperMemoized("abcdef")); //not cached ABCDEF<br/>toUpperMemoized("abcdef"); // cached ABCDEF</span></pre><p id="d57d" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">在上面的例子中，我们有一个缓存变量来存储结果。该函数在缓存中进行检查。如果结果可用，它将以大写字母返回。如果没有，它会将它添加到缓存中，然后以大写字母返回结果。</p><h1 id="31cb" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">为什么或何时使用记忆？</h1><p id="3093" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">JavaScript中的记忆化用于:</p><ol class=""><li id="a795" class="ne nf iq lq b lr mk lu ml lx ng mb nh mf ni mj nj nk nl nm bi translated">昂贵的函数调用。例如，执行输出可能不会改变的网络调用的函数，或者具有大量计算的函数。</li></ol><p id="ebc9" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">2.纯函数(给定相同的输入，函数输出保持不变)。</p><p id="a6ff" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">3.输入范围有限但经常出现的函数。</p><h1 id="9602" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><p id="f61b" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">记忆化将结果存储在内存中，因此应该避免在完全不同的情况下多次调用同一个函数。</p><p id="c098" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢您阅读本文，希望您觉得有用。如果有，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="lq ir">订阅我们的YouTube频道</strong> </a> <strong class="lq ir">获取更多类似内容！</strong></p><h1 id="c943" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">更多阅读</h1><div class="nn no gp gr np nq"><a href="https://medium.com/javascript-in-plain-english/the-methods-some-and-every-in-javascript-8b303a36eaae" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ir gy z fp nv fr fs nw fu fw ip bi translated">JavaScript中的一些和所有方法</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">了解一些高阶函数。</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe kp nq"/></div></div></a></div></div></div>    
</body>
</html>