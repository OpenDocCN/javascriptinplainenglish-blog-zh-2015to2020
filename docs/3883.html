<html>
<head>
<title>OpenLayers and three.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenLayers和three.js</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/openlayers-and-three-js-99c904eed76c?source=collection_archive---------4-----------------------#2020-10-31">https://javascript.plainenglish.io/openlayers-and-three-js-99c904eed76c?source=collection_archive---------4-----------------------#2020-10-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/83c4fdfe1d40e88054b53163d099ad97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q3yOer9ANt60djuanhTezA.jpeg"/></div></div></figure><div class=""/><p id="0014" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最近，我考虑为一个项目创建一个在线3D地球仪。Three.js是一个令人惊叹的库，互联网上有许多资源可以创建视觉上令人惊叹的地球仪。但是我也想拥有OpenLayers丰富的映射功能。</p><p id="0dea" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">虽然有用于此目的的库，但我想探索这两个库的可能性，而不受一个软件包解决方案的限制。可能性是无穷无尽的。我们开始吧。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="b7a4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">第一步是使用three.js创建一个3D球体。这里没有什么复杂的，只是一些注意事项:</p><ul class=""><li id="35bb" class="la lb iy jx b jy jz kc kd kg lc kk ld ko le ks lf lg lh li bi translated">我们使用正交相机，因为透视不适合这种事情。</li><li id="f304" class="la lb iy jx b jy lj kc lk kg ll kk lm ko ln ks lf lg lh li bi translated">我们集成了轨道控制，以便能够在地球上旋转和缩放。</li></ul><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="c6cb" class="lx ly iy lt b gy lz ma l mb mc">var camera = new THREE.OrthographicCamera(<br/>  -window.innerWidth / 4,<br/>  window.innerWidth / 4,<br/>  window.innerHeight / 4,<br/>  -window.innerHeight / 4,<br/>  1,<br/>  1000<br/>);</span><span id="8a22" class="lx ly iy lt b gy md ma l mb mc">camera.position.set(0, 0, 100);</span><span id="97e5" class="lx ly iy lt b gy md ma l mb mc">var controls = new THREE.OrbitControls(camera, renderer.domElement);</span><span id="be1f" class="lx ly iy lt b gy md ma l mb mc">var globe = new THREE.Mesh(<br/>  new THREE.SphereGeometry(90, 64, 64),<br/>  new THREE.MeshPhongMaterial()<br/>);</span></pre><figure class="lo lp lq lr gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi me"><img src="../Images/b6ccf204b12d941164c7e80e224bc549.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p92BRuaGSOIkIFwhow576g.jpeg"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">A three.js scene with a sphere, orbit controls and orthographic camera.</figcaption></figure><p id="a896" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，我们添加一个简单的OpenLayers地图，这是有趣的开始。Three.js有一个方法可以将画布元素作为纹理放到网格对象中。它基本上与基本纹理类相同，但是它接受canvas元素作为输入，并且默认情况下将needsUpdate属性设置为true。OpenLayers有一个map事件，当渲染完成时，我们可以从该事件中获取地图画布。在事件内部，我们将地图画布设置为球体的纹理，并将球体材质的needsUpdate属性设置为true。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="93ba" class="lx ly iy lt b gy lz ma l mb mc">map.on("rendercomplete", function () {<br/>var mapContainer = document.getElementById('map');</span><span id="f0cc" class="lx ly iy lt b gy md ma l mb mc">var mapCanvas = mapContainer.getElementsByTagName('canvas')[0];</span><span id="2cb0" class="lx ly iy lt b gy md ma l mb mc">var texture = new THREE.CanvasTexture(mapCanvas);<br/>  globe.material.map = texture;<br/>  globe.material.needsUpdate = true;<br/>});</span></pre><figure class="lo lp lq lr gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi me"><img src="../Images/031afac8aeb00262508ae6498a0d0c9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*izcvyVvOlBPNbGjWlAKGmw.jpeg"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">An OpenLayers map projected on a three.js sphere.</figcaption></figure><p id="dd57" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">起初，结果相当糟糕。我们必须做的一件事是改变OpenLayers视图的投影。这是因为OpenLayers默认使用EPSG:3857球面墨卡托，它将坐标投影到2D表面，从而在极点处拉伸地图。这对于平面视图来说很好，但是对于球体，我们需要EPSG:4326或类似的东西，它使用椭球2D坐标系。改变OpenLayers视图的投影系统非常简单。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="236f" class="lx ly iy lt b gy lz ma l mb mc">var view = new ol.View({<br/>  projection: "EPSG:4326",<br/>  extent: [-180, -90, 180, 90],<br/>  center: [0, 0],<br/>  zoom: 2<br/>});</span></pre><p id="643a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这张地图看起来好多了，但我们还是漏掉了一些部分。这是因为画布不会渲染整个地图。为了解决这个问题，我们必须强制画布视图显示整个地图。以度为单位的地图边界为[-180，-90，180，90]，因此宽度和高度的比例为2:1。将地图元素的宽度和高度分别设置为1000像素和500像素，可以正确地在画布上渲染整个地图，并最终渲染我们的球体纹理。我们还隐藏了地图，这样就不会遮挡3d视图(希望可以节省资源)。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="f6d4" class="lx ly iy lt b gy lz ma l mb mc">&lt;div id="container"&gt;<br/>  &lt;div id="map" style="position: fixed; visibility:hidden; width: 1000px; height:500px;"&gt;&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><figure class="lo lp lq lr gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi me"><img src="../Images/c71ea17eedfbdbd56c610e7dc0daa5f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ezaQaNFQYbERRMu9wZ-TYw.jpeg"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">An OpenLayers map correctly projected on a three.js sphere.</figcaption></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="7448" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样更好。我们现在有了一个正确应用了OpenLayers地图的3D地球。但是还有一个问题。我们不能缩放球体并获得更好的地图分辨率，这意味着更多的瓷砖。我尝试了几种方法来实现这一点，但似乎最有效的方法是在three.js相机的特定缩放级别下增加画布的大小。这是有意义的，因为球体上的缩放需要更高分辨率的纹理。</p><p id="fe73" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为此，我们可以使用OrbitControls结束事件。在事件中，我们可以让摄像机缩放，并在特定的缩放级别上改变画布的大小。我们使用三种变焦情况进行测试，但显然更多的情况是适用的。请注意，每当我们更改地图元素的大小时，都需要在地图上调用updateSize()方法。此外，因为当我们缩小地图尺寸时，视图不会缩小，所以我们必须重置视图分辨率(或缩放级别)。您可以使用view.getResolution()方法获得每个地图大小的分辨率，并使用这些值再次设置分辨率。最后，为了提高效率，我们不希望每次缩放改变时都触发，所以我们需要一种方法来限制每次轨道控制改变时的大小改变。在这里，我使用相机缩放的Math.floor来获取整数值，并使用一个临时变量来存储当前宽度，但是您可以通过几种方式获得类似的结果。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="b839" class="lx ly iy lt b gy lz ma l mb mc">var currentWidth = 1000;<br/>controls.addEventListener("end", function (event) {<br/>switch (Math.floor(camera.zoom)) {<br/>    case 1:<br/>      document.getElementById("map").style.width = "1000px";<br/>      document.getElementById("map").style.height = "500px";<br/>      if (currentWidth !== 1000) {<br/>        map.updateSize();<br/>        view.setResolution(0.36);<br/>        currentWidth = 1000;<br/>      }<br/>      break;<br/>    case 2:<br/>      document.getElementById("map").style.width = "2000px";<br/>      document.getElementById("map").style.height = "1000px";<br/>      if (currentWidth !== 2000) {<br/>        map.updateSize();<br/>        view.setResolution(0.225);<br/>        currentWidth = 2000;<br/>      }<br/>      break;<br/>    case 3:<br/>      document.getElementById("map").style.width = "4000px";<br/>      document.getElementById("map").style.height = "2000px";<br/>      if (currentWidth !== 4000) {<br/>        map.updateSize();<br/>        view.setResolution(0.18);<br/>        currentWidth = 4000;<br/>      }<br/>      break;<br/>    default:<br/>      break;<br/>  }<br/>});</span></pre><figure class="lo lp lq lr gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mj"><img src="../Images/949f902e9b688b3928bd1a840e123c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C4a2Q5PvZey_07KDZ0A7KA.jpeg"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">An OpenLayers map on a three.js sphere with zoom functionality.</figcaption></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="99cd" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">而且越来越好了。我们现在有一个带开放层的3D地球仪，在上面我们可以缩放并获得更好的分辨率。但是还有最后一个问题。我们从全世界下载瓷砖。这是一个非常繁重的过程，当调用tiles loading时，它会使场景非常滞后。为了解决这个问题，我们可以在切片图层上使用setExtent方法，并将切片加载限制在感兴趣的特定区域。为了做到这一点，我们必须找到相机当前正看着球体的地图坐标。有一个聪明的方法可以做到这一点。</p><p id="d7e1" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，我们使用three.js的Raycaster类来获取屏幕中心的球体交点(因此也是摄像机的交点)。由此，我们可以得到相机中心当前正对着的地图画布的UV位置。将UV坐标乘以画布的像素大小，我们得到画布上相应的像素。幸运的是，OpenLayers有一个非常有用的函数，getCoordinateFromPixel，通过它我们可以从画布像素获得地图上的坐标(x，y)。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="47ac" class="lx ly iy lt b gy lz ma l mb mc">var raycaster = new THREE.Raycaster();<br/>controls.addEventListener("end", function (event) {<br/>raycaster.setFromCamera({ x: 0, y: 0 }, camera);</span><span id="fbc2" class="lx ly iy lt b gy md ma l mb mc">let intersects = raycaster.intersectObject(globe);</span><span id="9115" class="lx ly iy lt b gy md ma l mb mc">let x = -map.getCoordinateFromPixel([<br/>    intersects[0].uv.x * currentWidth,<br/>    (intersects[0].uv.y * currentWidth) / 2<br/>  ])[1];<br/>  let y = map.getCoordinateFromPixel([<br/>    intersects[0].uv.x * currentWidth,<br/>    (intersects[0].uv.y * currentWidth) / 2<br/>  ])[0];</span><span id="4507" class="lx ly iy lt b gy md ma l mb mc">});</span></pre><p id="9c20" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">最后，为了得到范围，我们在中心定义一个半径为20度的圆(这将取决于我们需要的范围的大小，并且它可以根据不同的相机缩放级别动态变化)。从圆特征，我们得到的范围，我们传递给OSM层。结果看起来相当不错。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="c008" class="lx ly iy lt b gy lz ma l mb mc">var circle = new ol.Feature({<br/>    geometry: new ol.geom.Circle([y, x], 20)<br/>  });</span><span id="31d4" class="lx ly iy lt b gy md ma l mb mc">var circleSource = new ol.source.Vector({<br/>    features: [circle]<br/>  });</span><span id="98f9" class="lx ly iy lt b gy md ma l mb mc">osm.setExtent(circleSource.getExtent());</span></pre><figure class="lo lp lq lr gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi mj"><img src="../Images/77444c02bdc0b4aaaf1a267caec96c70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AFDjto6g4mRSmBBynYhHWA.jpeg"/></div></div><figcaption class="mf mg gj gh gi mh mi bd b be z dk">An OpenLayers map on a three.js sphere with extent restriction.</figcaption></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="fd27" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">作为最后的润色，我们可以添加第二个OSM层来覆盖我们焦点区域周围的黑色纹理。为了限制该层的图块加载，我们将该层源的maxZoom属性设置为2。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="0eff" class="lx ly iy lt b gy lz ma l mb mc">new ol.layer.Tile({<br/>      extent: [-180, -90, 180, 90],<br/>      source: new ol.source.OSM({<br/>        maxZoom: 2<br/>      })<br/>    }),</span></pre><p id="28f8" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在在一个three.js 3D球体上有了一个全功能的OpenLayers地图。这开启了3D映射的许多可能性。令人惊讶的是，我们只用几行代码就能做到这一点，并且在我们的武库中拥有两个伟大的库的能力和特性。</p><figure class="lo lp lq lr gt ip"><div class="bz fp l di"><div class="mk ml l"/></div></figure></div></div>    
</body>
</html>