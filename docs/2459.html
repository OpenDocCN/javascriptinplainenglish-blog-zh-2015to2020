<html>
<head>
<title>Writing Defensive JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写防御性JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/writing-defensive-javascript-c6d42940d30f?source=collection_archive---------2-----------------------#2020-06-26">https://javascript.plainenglish.io/writing-defensive-javascript-c6d42940d30f?source=collection_archive---------2-----------------------#2020-06-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/cb16131c53dc4986c2dc331ab81c9241.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PzXoT0E8j74N2YBv.jpg"/></div></div></figure><h2 id="fd2b" class="jy jz iq bd ka kb kc dn kd ke kf dp kg kh ki kj kk kl km kn ko kp kq kr ks kt bi translated">你会听到很多程序员开玩笑说JavaScript不是“真正的”编程语言。</h2><p id="dd13" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">除了没有基于类的继承系统，JS也是动态类型的，不像C#，Java，Scala…你知道，所有那些真正的编程语言。但是速度，灵活性和易用性是我们写JS的原因！该死的类型！</p><p id="820f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">当然，JS提供的灵活性是有代价的，如果您使用的是Typescript，其中一些可能会被忽略，但是在编写代码时使用下面的防御策略可以为您节省一个讨厌的bug(这也押韵，所以您知道这是真的😉).</p><h1 id="bf59" class="lu jz iq bd ka lv lw lx kd ly lz ma kg mb mc md kk me mf mg ko mh mi mj ks mk bi translated"><strong class="ak">使用默认参数</strong></h1><p id="2770" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">如果你有一个依赖于某个参数的函数，那么你应该考虑在你的函数签名中使用默认参数。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="ded6" class="jy jz iq mq b gy mu mv l mw mx">const addNameToNameArray = (name, nameArray) =&gt; {<br/>  if(name.length){<br/>   nameArray.push(name)<br/>  }<br/>  return nameArray<br/>}</span></pre><p id="b61b" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">够简单吧？我们取一个名字和一个名字数组，然后简单地将名字添加到数组中，如果数组中有名字的话。然而，我们在这里做了一些假设，这个名字将是一个具有<code class="fe my mz na mq b">length</code>属性的类型，并且我们的<code class="fe my mz na mq b">nameArray</code>将是一个数组。如果这些条件中的任何一个得不到满足，我们将会惨败。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="5899" class="jy jz iq mq b gy mu mv l mw mx">const addNameToNameArray = (name = '', nameArray = []) =&gt; {<br/>  if(name.length){<br/>   nameArray.push(name)<br/>  }<br/>  return nameArray<br/>}</span></pre><p id="9705" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">啊，好多了。现在我们可以晚上睡觉了，因为知道这个无用的函数一旦被部署就不会中断生产，即使它是用一个丢失的参数调用的。</p><h1 id="19a7" class="lu jz iq bd ka lv lw lx kd ly lz ma kg mb mc md kk me mf mg ko mh mi mj ks mk bi translated"><strong class="ak">使用对象作为参数</strong></h1><p id="2a3e" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">你的团队有一个很好的小函数，接受3个参数，用它做一些简单的逻辑，从第三方服务获取一些数据。但那是过去的事了，现在这个小函数几乎认不出来了，并且有6个参数传递给它。现在，通常一个论点多于，我不知道，比如说3个论点，会有一股代码味，但有些时候你无法避免。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="61d0" class="jy jz iq mq b gy mu mv l mw mx">const createUser = (name, date, profileId, dataId, dataType, apiKey) =&gt; {<br/>  const user = {<br/>   name,<br/>   profileId<br/>  };</span><span id="bafc" class="jy jz iq mq b gy nb mv l mw mx">  const formattedDate = moment(date).unix();<br/>  thirdPartyAPI.fetch(user, formattedDate, dataId, dataType, apiKey)<br/>}</span><span id="4131" class="jy jz iq mq b gy nb mv l mw mx">createUser('Bob', '04/20/20', 1, 123, 1234, 'story', 'abc123')</span></pre><p id="899c" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">像这样的函数的危险在于参数的顺序很重要，如果其中任何一个不正确，我们就有破坏API调用的风险。更多的论点，意味着更多的犯错空间。几乎不可避免的是，一些开发人员会调用这个函数，<code class="fe my mz na mq b">profileId</code>将取代<code class="fe my mz na mq b">dataId</code>。这不会破坏你的程序，因为它们都可能是数字或字符串，但是它们不正确的顺序会从API中给你错误的数据，或者更糟，就是不能工作。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="83dc" class="jy jz iq mq b gy mu mv l mw mx">const createUser = ({name, date, profileId, dataId, dataType, apiKey}) =&gt; {<br/>  const user = {<br/>   name,<br/>   profileId<br/>  };</span><span id="e547" class="jy jz iq mq b gy nb mv l mw mx">const formattedDate = moment(date).unix();<br/>  thirdPartyAPI.fetch(user, formattedDate, dataId, dataType, apiKey)<br/>}</span><span id="ee18" class="jy jz iq mq b gy nb mv l mw mx">createUser({<br/>  name: 'Bob',<br/>  date: '04/20/20',<br/>  profileId: 1,<br/>  dataId: 123,<br/>  dataType: 'story'<br/>  apiKey: '123abc'<br/>})</span></pre><p id="ac39" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">嘣。使用对象，我们实际上减少了开发人员的认知负担，并确保我们的参数是显式设置的。对于超过4个参数的函数，我觉得必须使用一个对象。</p><h1 id="ad1e" class="lu jz iq bd ka lv lw lx kd ly lz ma kg mb mc md kk me mf mg ko mh mi mj ks mk bi translated"><strong class="ak">可选链接</strong></h1><p id="0fde" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">我们在JavaScript中处理了很多对象。许多人错误地认为JavaScript中的一切都是对象，这是众所周知的。嗯，这并不完全正确，但我们确实经常与他们和他们的属性打交道，如果不小心的话，挖掘有用的信息可能会很痛苦，而且有点危险。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="c700" class="jy jz iq mq b gy mu mv l mw mx">const hat = user.outfit.hat;</span></pre><p id="7327" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">无害对吗？嗯，如果我们的用户对象没有属性<code class="fe my mz na mq b">outfit</code>或者属性是<code class="fe my mz na mq b">undefined</code>，那么我们就有问题了。</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="858c" class="jy jz iq mq b gy mu mv l mw mx">TypeError: Cannot read property 'hat' of undefined</span></pre><p id="ab1f" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">现在，确保我们不会出现这种错误的第一步是在每一层检查下一个属性是否存在，这样我们就会陷入编写不性感的代码</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="015a" class="jy jz iq mq b gy mu mv l mw mx">const hat = user &amp;&amp; user.outfit &amp;&amp; user.outfit.hat || 'hat';</span></pre><p id="ff5a" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">我们觉得写这个有点悲伤，而且一点也不性感。幸运的是，借助Babel的力量，JS开发人员可以利用Ruby和Coffeescript开发人员多年来拥有的优势:可选链接</p><pre class="ml mm mn mo gt mp mq mr ms aw mt bi"><span id="7e50" class="jy jz iq mq b gy mu mv l mw mx">const hat = user?.outfit?.hat || 'hat'</span></pre><p id="777d" class="pw-post-body-paragraph ku kv iq kw b kx lp kz la lb lq ld le kh lr lg lh kl ls lj lk kp lt lm ln lo ij bi translated">嗯，令人满意。现在，如果我们的遍历在任何一点失败，我们的操作将短路并返回<code class="fe my mz na mq b">undefined</code>。代码更安全，可读性更好。</p><h1 id="8e34" class="lu jz iq bd ka lv lw lx kd ly lz ma kg mb mc md kk me mf mg ko mh mi mj ks mk bi translated"><strong class="ak">最好的进攻就是良好的防守</strong></h1><p id="5f8a" class="pw-post-body-paragraph ku kv iq kw b kx ky kz la lb lc ld le kh lf lg lh kl li lj lk kp ll lm ln lo ij bi translated">对我来说，写很多防御性的JavaScript只是简单地设置逻辑安全措施来保护你的代码免受你可能不期望但会接受的输入。希望这些建议能防止你在周六凌晨3点被叫醒去修复产品中的一个bug！</p></div></div>    
</body>
</html>