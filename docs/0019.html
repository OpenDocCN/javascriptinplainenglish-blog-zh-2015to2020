<html>
<head>
<title>Criei o mesmo app em React e Vue. Eis as diferenças.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在 React 和 Vue 中创建了相同的应用程序。这就是差异。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/criei-o-mesmo-app-em-react-e-vue-eis-as-diferen%C3%A7as-2455d86d173c?source=collection_archive---------0-----------------------#2018-08-08">https://javascript.plainenglish.io/criei-o-mesmo-app-em-react-e-vue-eis-as-diferen%C3%A7as-2455d86d173c?source=collection_archive---------0-----------------------#2018-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e643" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Sunil Sandhu的原文翻译:“我在React和Vue中创建了完全相同的应用程序。这里是差异”。</h2></div><p id="6a97" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我目前的工作环境中使用 Vue,我已经对它的工作原理有了很好的了解。然而,我很好奇围栏另一边的草是什么样子的——在这种情况下,草是React。</p><blockquote class="ky kz la"><p id="926b" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="ke io">翻译注释!</strong>与原作者不同,我,马塞尔,主要在使用 React 的团队中工作。我保持了相同的文本语义,只做了一些语言修改和一些技术上的调整。</p></blockquote><p id="5234" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我阅读了React文档并观看了几个教程视频,虽然它们很棒,但我真正想要的是了解React与Vue的不同之处。通过“不同”,我并不是说它们都有<em class="lb">虚拟DOM</em>,或者它们在渲染页面时的样子。我希望有人花时间解释代码并告诉我发生了什么!我想找到一篇解释这些差异的文章,以便Vue或React(或Web开发作为一个整体)的新手可以更好地理解两者之间的差异。</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lf"><img src="../Images/0331756fcac7b55cc163bb9f9ccf9681.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tqpZoG9qMeVd9j7KhAnsBg.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Quem se saiu melhor?</figcaption></figure><p id="e432" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我决定尝试并合理地构建一个标准的<em class="lb">“To Do”</em>(“待办事项列表”)应用程序,允许用户在列表中添加和删除项目。这两个应用程序都是使用它们的标准 CLI 创建的(React 的 <code class="fe lv lw lx ly b">create-react-app</code> 和 Vue 的 <code class="fe lv lw lx ly b">vue-cli</code>)。CLI 是 T10 Command Line Interface (T11) 的缩写。是的</p><h1 id="be6c" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">顺便说一句,这个介绍已经比我预期的要长。因此,让我们先快速浏览一下应用程序的外观:</h1><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mr"><img src="../Images/f57904d2cda5bc95cd7ea8992a566bed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5akH63qjVWPgkLhvqTj8RQ.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Vue vs React: A Força Irresistível encontra O Objeto Imóvel</figcaption></figure><p id="2c82" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">两者的CSS代码是完全相同的,但它们的位置存在差异。考虑到这一点,我们接下来看一下文件结构:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ms"><img src="../Images/5df6f8eb70a759639f4f33e25b15282f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zi-9tagj8f4_E_euZx88Zw.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Quem se saiu melhor?</figcaption></figure><p id="6af8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你会发现它们的结构也几乎相同。这里唯一的区别是,React 应用程序有三个 CSS 文件,而 Vue 应用程序没有一个。主要原因是因为在<code class="fe lv lw lx ly b">create-react-app</code>中,React 组件将有一个附带的文件来保存其样式,而在<code class="fe lv lw lx ly b">vue-cli</code>中,样式在组件文件中声明。</p><p id="aaf7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后,两者都达到了相同的目的,没有什么可说的,除了你可以继续在React或Vue中以不同的方式构建你的CSS之外。这实际上归结为个人偏好——你会听到很多关于如何构建CSS的社区讨论。目前,我们只会遵循两个 CLI 定义的结构。</p><p id="d884" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但在我们继续之前,让我们快速了解一下典型的 Vue 和 React 组件:</p><figure class="lg lh li lj gt lk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi mt"><img src="../Images/51ecae174d06b6dac0187e8addbaaff7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xCv2Mi3EnNHtf0-rV847oA.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Vue à esquerda. React à direita.</figcaption></figure><p id="5333" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们进入详细的细节!</p><h1 id="aa08" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">我们如何改变数据?</h1><p id="efc3" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">首先,什么是“数据转换”?听起来有点技术性吧?基本上,这意味着只更改我们存储的数据。因此,如果我们想将一个人的名字的值从“John”更改为“Mark”,我们将“改变数据”。所以这里是React和Vue之间的关键区别。虽然Vue本质上创建了一个数据对象,其中数据可以自由更新,但React创建了一个状态对象,在该对象中需要更多的手工操作来执行更新。React实现了这种额外的手臂工作是有充分理由的,我们很快就会到达那里。我们来看看 Vue 的 <strong class="ke io"> data 对象 </strong> 和 React 的 <strong class="ke io"> state 对象 </strong>:</p><div class="lg lh li lj gt ab cb"><figure class="mz lk na nb nc nd ne paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><img src="../Images/0a2b61c8f7bab49fa0f2f17d8b9dd5df.png" data-original-src="https://miro.medium.com/v2/resize:fit:602/format:webp/1*6hKxuX8sBLNJ3-K1Dn4FkQ.png"/></div></figure><figure class="mz lk nf nb nc nd ne paragraph-image"><img src="../Images/5ae676863a7a39e31d3330e3a70cb8c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:584/format:webp/1*TVFL2_e6R5WD9Z-kZtNPOQ.png"/><figcaption class="lr ls gj gh gi lt lu bd b be z dk ng di nh ni">Objeto data do Vue à esquerda. Objeto state do React à direita.</figcaption></figure></div><p id="fafb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以看到我们在两者中传递了相同的数据,但它们只是命名不同。因此,将初始数据传递给我们的组件的方法非常相似。但是,正如我们之前提到的,我们将在 Vue 和 React 中以不同的方式更改这些数据。</p><p id="8103" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们有一个名为<strong class="ke io">的数据name:‘Sunil’</strong>。</p><p id="cd6a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在Vue中,我们通过调用<strong class="ke io">this.name</strong>来引用它。我们也可以通过调用<strong class="ke io">this.name = 'John' </strong>来更新它。这将改变我的名字约翰。我不知道被称为约翰的感觉如何,但它确实发生了!↓ ↓</p><blockquote class="ky kz la"><p id="5278" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="ke io">翻译注释!事实上,我的名字是马塞尔,但是......它发生了!<em class="in"> </em></strong></p></blockquote><p id="e9a6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在 React 中,我们可以通过调用 <strong class="ke io"> this.state.name </strong> 来引用相同的数据。现在关键的区别是我们不能简单地写成 <strong class="ke io"> this.state.name </strong> = 'John',因为 React 有一些限制来防止这种简单而粗心的突变。因此,在 React 中,我们会写出 <strong class="ke io"> this.setState({ name: 'John' }) </strong> 。</p><p id="581f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然这基本上与Vue中的相同,但额外的写入存在,因为Vue默认每次更新数据的新部分时都会执行自己的<code class="fe lv lw lx ly b">setState</code>版本。简而言之,React 需要 <code class="fe lv lw lx ly b">setState</code> 并将更新的数据作为参数传递,而 Vue 假设您希望在更新对象中的值时已经这样做了。那么,为什么 React 关心这一点,为什么 <code class="fe lv lw lx ly b">setState</code> 是必要的?让我们让<a class="ae nj" href="https://medium.com/@revanth0212" rel="noopener">Revanth Kumar</a>解释一下:</p><blockquote class="ky kz la"><p id="4e39" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">这是因为 React 想要在生命周期中重新运行某些事件(例如组件即将获得新属性时,是否应该更新,是否应该更新,是否更新),每当状态发生变化时。它知道您在调用 setState 函数时发生了突变。如果你直接更改状态,React 将不得不花费大量的工作来观察这些更改,并决定要调用哪些生命周期步骤。所以为了简单起见,React 使用 setState。</p></blockquote><figure class="lg lh li lj gt lk gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/2bf46dd5f8c2b698b27a73020f14aac5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1136/format:webp/1*MthaY_KQR7sXYhUSLow-jA.jpeg"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Ele sabia melhor</figcaption></figure><p id="8920" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经有了突变,让我们更深入地了解我们如何在两个“<em class="lb"> To Do </em>”应用程序的待办事项列表中添加新项目。</p><h1 id="ba7d" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">如何在活动列表中创建新项目?</h1><blockquote class="ky kz la"><p id="060a" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated"><strong class="ke io">翻译注释!</strong> 代码没有翻译,所以不要将英语表达“to do”(在<code class="fe lv lw lx ly b"><em class="in">todo</em></code>代码中,粗体或灰色背景,其翻译为“to do”)与葡萄牙语单词“all”(“integer”的同义词)混淆,也不要将“date”(写在代码中,意思是“data”)这个词混为一谈,这是一个假的同源(即,它并不意味着“日期”时间单位)。</p></blockquote><h2 id="52c0" class="nl ma in bd mb nm nn dn mf no np dp mj kl nq nr ml kp ns nt mn kt nu nv mp nw bi translated">React:</h2><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="f9ff" class="nl ma in ly b gy ob oc l od oe">createNewToDoItem = () =&gt; {<br/>    <strong class="ly io">this</strong>.setState(oldState =&gt; {<br/>        return {<br/>            list: [ ...oldState.list, { oldState.todo } ],<br/>            todo: ''<br/>        };<br/>    });<br/>};</span></pre><h2 id="8c19" class="nl ma in bd mb nm nn dn mf no np dp mj kl nq nr ml kp ns nt mn kt nu nv mp nw bi translated">React 是如何到达的?</h2><p id="2251" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">在 React 中,我们的 <em class="lb"> input </em> 字段有一个 <code class="fe lv lw lx ly b">value </code> 属性。这个<code class="fe lv lw lx ly b">value</code>是通过使用一些函数自动更新,这些函数将所有内容组合在一起,以创建一个<strong class="ke io">双向绑定</strong>(如果你以前从未听说过<em class="lb">双向绑定</em>,在下面的“Vue如何做到这一点”部分有更详细的解释)。我们通过一个<code class="fe lv lw lx ly b">onChange</code>函数创建了这种形式的双向链接,该函数在其值改变时(即用户在其中键入内容)将侦听与此<em class="lb">input</em>字段关联的事件。让我们快速浏览一下这个领域,看看发生了什么:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="af25" class="nl ma in ly b gy ob oc l od oe">&lt;input type="text" <br/>       value={<strong class="ly io">this</strong>.state.todo} <br/>       onChange={<strong class="ly io">this</strong>.handleInput}/&gt;</span></pre><p id="d787" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lv lw lx ly b">handleInput</code>函数在<code class="fe lv lw lx ly b">input</code>的值改变时执行。这会更新状态对象内的<code class="fe lv lw lx ly b">todo</code>,将其定义为<em class="lb">input</em>字段内的任何内容。这个功能将是:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="d9b4" class="nl ma in ly b gy ob oc l od oe">handleInput = e =&gt; {<br/>  <strong class="ly io">this</strong>.setState({<br/>    todo: e.target.value<br/>  });<br/>};</span></pre><p id="435d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在,每当用户在页面上按 + 按钮来添加一个新项目时,函数 <strong class="ke io"> createNewToDoItem </strong> 本质上将通过将匿名函数传递给它来执行<code class="fe lv lw lx ly b">this.setState</code>。该匿名函数负责更改状态,并接收旧的状态对象(T1),其中包含当前列表(T13) list(T14)和值(T15) all(T16)(由函数(T17) handleInput(T18))更新),然后返回一个新对象,该对象包含以前的整个列表(T20),但这次也包含末尾的<strong class="ke io"> all(T22)。整个列表是通过 <em class="lb"> 扩展 </em> 运算符添加的(如果您以前从未见过它,请使用 Google — 这是 ES6 语法)。</strong></p><p id="a0a1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后,我们将 <strong class="ke io"> all </strong> 定义为空的 <em class="lb"> string </em>,这会自动更新 <strong class="ke io"> input 元素的 <strong class="ke io"> value </strong> 属性,从而清除该字段。</strong></p><h2 id="9215" class="nl ma in bd mb nm nn dn mf no np dp mj kl nq nr ml kp ns nt mn kt nu nv mp nw bi translated">VUE:</h2><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="1dd4" class="nl ma in ly b gy ob oc l od oe">createNewToDoItem() {<br/>    <strong class="ly io">this</strong>.list.push(<br/>        {<br/>            'todo': <strong class="ly io">this</strong>.todo<br/>        }<br/>    );<br/>    <strong class="ly io">this</strong>.todo = '';<br/>}</span></pre><h2 id="ab53" class="nl ma in bd mb nm nn dn mf no np dp mj kl nq nr ml kp ns nt mn kt nu nv mp nw bi translated">Vue是如何到达这里的?</h2><p id="e9e0" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">在Vue中,我们的input字段有一个名为<code class="fe lv lw lx ly b">v-model</code>的处理程序。这允许我们进行 <em class="lb"> 双向绑定 </em> 。让我们快速查看输入字段,然后我们将解释发生了什么:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="ac67" class="nl ma in ly b gy ob oc l od oe">&lt;input type="text" v-model="todo"/&gt;</span></pre><p id="217a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lv lw lx ly b">v-model</code>将该字段的输入连接到我们在名为<code class="fe lv lw lx ly b">todo</code>的对象<code class="fe lv lw lx ly b">data</code>中的键。当页面加载时,我们将<code class="fe lv lw lx ly b">todo</code>定义为一个空的<em class="lb">string</em>,例如:<strong class="ke io">all:''</strong> 。如果它已经有任何数据,如<strong class="ke io">all:'在此处放置文本'</strong>,我们的输入字段将被加载到字段内已经“在此处放置文本”。无论如何,让我们把它看作是从一个空的<em class="lb">string</em>开始。我们在 <em class="lb"> input </em> 字段中输入的任何文本都将链接到 <strong class="ke io"> all </strong> 的值。这实际上是双向链接(<code class="fe lv lw lx ly b">input</code>字段可以更新对象<code class="fe lv lw lx ly b">data</code>,而<code class="fe lv lw lx ly b">data</code>可以更新字段<code class="fe lv lw lx ly b">input</code>)。</p><p id="c003" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后再次查看Vue <strong class="ke io"> createNewToDoItem </strong>中的函数代码块,我们看到我们将来自<strong class="ke io">all </strong>的内容添加到<em class="lb">array </em><strong class="ke io">list </strong>中,然后清除<strong class="ke io">all </strong>到空的<em class="lb">string </em>。</p><h1 id="5668" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">如何从列表中删除?</h1><h2 id="4356" class="nl ma in bd mb nm nn dn mf no np dp mj kl nq nr ml kp ns nt mn kt nu nv mp nw bi translated">React:</h2><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="ea1d" class="nl ma in ly b gy ob oc l od oe">deleteItem = indexToDelete =&gt; {<br/>    <strong class="ly io">this</strong>.setState(({ list }) =&gt; ({<br/>      list: list.filter((toDo, index) =&gt; index !== indexToDelete)<br/>    }));<br/>};</span></pre><h2 id="5aca" class="nl ma in bd mb nm nn dn mf no np dp mj kl nq nr ml kp ns nt mn kt nu nv mp nw bi translated">React 是如何到达的?</h2><p id="8faf" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">虽然函数<code class="fe lv lw lx ly b">deleteItem</code>位于<strong class="ke io">ToDo.js</strong>中,但我可以很容易地在<strong class="ke io">ToDoItem.js</strong>中引用它,因为我传递了函数<strong class="ke io">deleteItem</strong>作为属性:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="f407" class="nl ma in ly b gy ob oc l od oe">&lt;ToDoItem deleteItem={this.deleteItem.bind(this, key)}/&gt;</span></pre><p id="d695" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这向前传递方法,使其可供子组件访问。在这里,您将看到我们还“绑定”(给出 <code class="fe lv lw lx ly b">bind</code>no) <strong class="ke io">this </strong> 通过将其作为参数传递给<strong class="ke io">key </strong>参数,以便以后函数可以区分哪一个<strong class="ke io">ToDoItem</strong>试图触发删除并触发聚合器组件的更新生命周期。因此,在<strong class="ke io">ToDoItem</strong>的组件中,我们执行以下操作:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="1891" class="nl ma in ly b gy ob oc l od oe">&lt;div className=”ToDoItem-Delete” onClick={this.props.deleteItem}&gt;-&lt;/div&gt;</span></pre><p id="a1f1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我所要做的就是将父组件传递的函数引用为 <strong class="ke io"> this.props.deleteItem </strong> 。</p><h2 id="a863" class="nl ma in bd mb nm nn dn mf no np dp mj kl nq nr ml kp ns nt mn kt nu nv mp nw bi translated">VUE:</h2><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="a6d7" class="nl ma in ly b gy ob oc l od oe">onDeleteItem(todo){<br/>  <strong class="ly io">this</strong>.list = <strong class="ly io">this</strong>.list.filter(item =&gt; item !== todo);<br/>}</span></pre><h2 id="d37d" class="nl ma in bd mb nm nn dn mf no np dp mj kl nq nr ml kp ns nt mn kt nu nv mp nw bi translated">Vue 是如何到达的?</h2><p id="9788" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">在 Vue 中需要稍微不同的方法。这个<code class="fe lv lw lx ly b">onDeleteItem</code>在对象<code class="fe lv lw lx ly b">data</code>的范围内,我们基本上需要在这里做三件事:</p><p id="1f46" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先,在我们想要调用函数的元素中,我们这样做:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="a396" class="nl ma in ly b gy ob oc l od oe">&lt;div class=”ToDoItem-Delete” @click=”deleteItem(todo)”&gt;-&lt;/div&gt;</span></pre><p id="a289" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此,我们必须在子组件中创建一个发送函数作为方法(在本例中为<strong class="ke io">ToDoItem.vue</strong>),如下所示:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="4efd" class="nl ma in ly b gy ob oc l od oe">deleteItem(todo) {<br/>    <strong class="ly io">this</strong>.$emit('delete', todo);<br/>}</span></pre><p id="a5e5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外,你会注意到,我们实际上是通过在<strong class="ke io">ToDo.vue</strong>中添加<strong class="ke io">ToDoItem.vue</strong>来引用一个函数:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="3aec" class="nl ma in ly b gy ob oc l od oe">&lt;ToDoItem v-for="todo in list" <br/>          :todo="todo" <br/>          <strong class="ly io">@delete="onDeleteItem" //</strong> &lt;-- isso aqui :)<br/>          :key="todo.id" /&gt;</span></pre><p id="9b0d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这被称为“事件侦听器”(或<em class="lb">事件侦听器</em>)。它会注意发射器被“<em class="lb"> delete </em>”中的<em class="lb">string </em>触发的任何场合。如果它听到这个,它会触发我们的函数 <strong class="ke io"> onDeleteItem </strong> 。这个函数位于<strong class="ke io">ToDo.vue</strong>而不是<strong class="ke io">ToDoItem.vue</strong>中,如上所示,它只会过滤数据对象内的<em class="lb">array</em><strong class="ke io"> list</strong>以删除点击的项目。</p><p id="a10f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里值得注意的是,在Vue的例子中,我可以简单地将<strong class="ke io"> $emit </strong>部分写入监听器<strong class="ke io"> @click </strong> ,如下所示:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="02e7" class="nl ma in ly b gy ob oc l od oe">&lt;div class=”ToDoItem-Delete” @click=”$emit(‘delete’, todo)”&gt;-&lt;/div&gt;</span></pre><p id="64ff" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将把步骤的数量从3个减少到2个,但这只是个人偏好。</p><p id="4edf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之,React 中的子组件可以通过 <strong class="ke io"> this.props </strong> 访问父组件的函数(只要组件传递 <strong class="ke io"> props </strong> 属性,这是一个相当标准的做法,你会在其他 React 示例中多次遇到这种情况);在Vue中,您必须发出通常在父组件中收集的子事件。</p><h1 id="946c" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">如何传递事件侦听器?</h1><h2 id="86b9" class="nl ma in bd mb nm nn dn mf no np dp mj kl nq nr ml kp ns nt mn kt nu nv mp nw bi translated">React:</h2><p id="1b3c" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">对于像点击事件这样的简单事情,我们可以直接进入点。以下是我们如何为一个按钮创建一个单击事件的示例,该事件在<code class="fe lv lw lx ly b">list</code>中创建一个新的“<em class="lb"> To Do </em>”项:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="c423" class="nl ma in ly b gy ob oc l od oe">&lt;div className=”ToDo-Add” onClick={this.createNewToDoItem}&gt;+&lt;/div&gt;</span></pre><p id="8469" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里超级容易,基本上就是我们使用纯JS处理<code class="fe lv lw lx ly b">onClick</code>的方式。只要按下“Enter”键,就可以设置一个<em class="lb">事件侦听器</em>。这基本上需要一个事件<code class="fe lv lw lx ly b">onKeyPress</code>来由标签<code class="fe lv lw lx ly b">input</code>处理,例如:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="6296" class="nl ma in ly b gy ob oc l od oe">&lt;input type=”text” onKeyPress={this.handleKeyPress}/&gt;</span></pre><p id="0bbd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个函数基本上在每次识别Enter键时都会触发函数<strong class="ke io">createNewToDoItem</strong>,就像这样:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="a41d" class="nl ma in ly b gy ob oc l od oe">handleKeyPress = (e) =&gt; {</span><span id="8043" class="nl ma in ly b gy of oc l od oe">  if (e.key === ‘Enter’) {</span><span id="ed5d" class="nl ma in ly b gy of oc l od oe">    this.createNewToDoItem();</span><span id="ddf8" class="nl ma in ly b gy of oc l od oe">  }</span><span id="76a7" class="nl ma in ly b gy of oc l od oe">};</span></pre><h2 id="f593" class="nl ma in bd mb nm nn dn mf no np dp mj kl nq nr ml kp ns nt mn kt nu nv mp nw bi translated">VUE:</h2><p id="445b" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">在Vue中,它更直接。我们只需使用 <strong class="ke io"> @ </strong> 符号,然后使用我们想要的 <em class="lb"> 事件侦听器 </em> 类型。因此,例如,要添加click事件侦听器,我们可以这样写:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="d6fb" class="nl ma in ly b gy ob oc l od oe">&lt;div class=”ToDo-Add” @click=”createNewToDoItem()”&gt;+&lt;/div&gt;</span></pre><p id="b002" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Note <strong class="ke io">@click</strong>实际上是<strong class="ke io">v-on:click</strong>的缩写。Vue与<em class="lb">事件侦听器</em>的酷处在于,您可以将它们链接在一起,例如<code class="fe lv lw lx ly b">.once</code>可以防止该侦听器多次触发。当谈到编写特定按键事件时,还有其他一些缩写。在Vue中,我可以简单地写:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="6bd4" class="nl ma in ly b gy ob oc l od oe">&lt;input type=”text” v-on:keyup.enter=”createNewToDoItem”/&gt;</span></pre><p id="d218" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我注意到在 React 中花了更长的时间。</p><h1 id="7b39" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">我们如何将数据传递给子组件?</h1><h2 id="f120" class="nl ma in bd mb nm nn dn mf no np dp mj kl nq nr ml kp ns nt mn kt nu nv mp nw bi translated">React:</h2><p id="d26f" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">在 React 中,我们在实例化时将属性对象 <code class="fe lv lw lx ly b">props</code> 传递给子组件,例如:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="4e20" class="nl ma in ly b gy ob oc l od oe">&lt;ToDoItem key={key} item={todo} /&gt;</span></pre><p id="6eee" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里我们看到 <code class="fe lv lw lx ly b">props</code> 的两个成员传递给 <strong class="ke io"> ToDoItem </strong> 组件。从现在开始,我们将通过<strong class="ke io">this.props</strong>引用子代中的数据。因此,要访问此属性 <strong class="ke io"> all </strong>,我们只需调用 <strong class="ke io"> this.props.item </strong> 。</p><h2 id="2e74" class="nl ma in bd mb nm nn dn mf no np dp mj kl nq nr ml kp ns nt mn kt nu nv mp nw bi translated">VUE:</h2><p id="2c23" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">在 Vue 中,我们以类似的方式将属性传递给子组件。如在:</p><pre class="lg lh li lj gt nx ly ny nz aw oa bi"><span id="6fb5" class="nl ma in ly b gy ob oc l od oe">&lt;ToDoItem v-for="todo in list" <br/>            :todo="todo"<br/>            :key="todo.id"<br/>            @delete="onDeleteItem" /&gt;</span></pre><p id="9f5f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后这些可以通过名称在子实例中引用 - 因此,在我们的例子中,<strong class="ke io">“全部”</strong>。</p><h1 id="94ad" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">如何将数据发送回父组件?</h1><h2 id="3810" class="nl ma in bd mb nm nn dn mf no np dp mj kl nq nr ml kp ns nt mn kt nu nv mp nw bi translated">React:</h2><p id="628c" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">首先,我们将函数传递给子函数,使其成为其对象<code class="fe lv lw lx ly b">props</code>中的一个属性。然后我们以某种方式调用子,例如委派给<strong class="ke io">onClick</strong>,通过引用<strong class="ke io">this.props</strong>,就像我们在“如何从列表中删除”一节中看到的那样用<strong class="ke io">this.props.deleteItem</strong> 。这将触发父组件中声明的函数。</p><h2 id="592b" class="nl ma in bd mb nm nn dn mf no np dp mj kl nq nr ml kp ns nt mn kt nu nv mp nw bi translated">VUE:</h2><p id="a901" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">在我们的子组件中,我们只需编写一个函数,该函数将值返回到父函数。在这个父组件中,我们编写了一个函数,该函数在发出该值时会侦听,该值可以在函数调用期间触发。我们在“如何从列表中删除”一节中也看到了一个例子。</p><h1 id="f3ad" class="lz ma in bd mb mc md me mf mg mh mi mj jt mk ju ml jw mm jx mn jz mo ka mp mq bi translated">准备好了!↓</h1><p id="74df" class="pw-post-body-paragraph kc kd in ke b kf mu jo kh ki mv jr kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">我们已经看到了如何添加,删除和更改数据,将数据从表单传递到属性,从父组件传递到子组件,反之亦然,并使用<em class="lb">事件侦听器</em>触发突变。当然,React 和 Vue 之间还有其他一些细微差别,但我希望本文的内容有助于为理解两者的工作原理提供更多基础。</p></div><div class="ab cl og oh hr oi" role="separator"><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol om"/><span class="oj bw bk ok ol"/></div><div class="ig ih ii ij ik"><blockquote class="ky kz la"><p id="4481" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">原文: <a class="ae nj" href="https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd" rel="noopener">https://medium.com/javascript-in-plain-english/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd </a></p></blockquote></div></div>    
</body>
</html>