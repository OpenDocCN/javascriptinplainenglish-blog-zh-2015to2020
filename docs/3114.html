<html>
<head>
<title>Node.js Best Practices — Errors, Code, and Resources</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—错误、代码和资源</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-best-practices-errors-code-and-resources-ba6673fdf6af?source=collection_archive---------7-----------------------#2020-08-30">https://javascript.plainenglish.io/node-js-best-practices-errors-code-and-resources-ba6673fdf6af?source=collection_archive---------7-----------------------#2020-08-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9836806d8e760596aa322bfae14c4005.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jO7K380rRo26huDv"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@scottwebb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Scott Webb</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8364" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看在编写节点应用程序时应该遵循的一些最佳实践。</p><h1 id="f868" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">正确处理错误和异常</h1><p id="4718" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该在我们的Express应用程序上正确处理错误和异常。</p><p id="0ef5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在同步代码或异步函数中，我们可以使用try-catch:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3461" class="mn lc iq mj b gy mo mp l mq mr">async function foo() {<br/>  try {<br/>    const baz = await bar()<br/>    return baz<br/>  } catch (err) {<br/>    console.error(err);<br/>  }<br/>}</span></pre><p id="c73a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想捕捉中间件中的错误，我们可以创建自己的中间件来捕捉错误。</p><p id="fee8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9b90" class="mn lc iq mj b gy mo mp l mq mr">function errorHandler(err, req, res, next) {<br/>  console.error(err)<br/>  res.status(err.status || 500).send(err.message)<br/>}</span><span id="7327" class="mn lc iq mj b gy ms mp l mq mr">router.use(errorHandler)</span></pre><p id="f79f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe mt mu mv mj b">errorHandler</code>中间件来捕捉在它之前添加的其他中间件的错误。</p><p id="306b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe mt mu mv mj b">errorHandler</code>调用<code class="fe mt mu mv mj b">router.use</code>或<code class="fe mt mu mv mj b">app.use</code>来处理错误。</p><h1 id="77dd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">小心内存泄漏</h1><p id="2c50" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该注意内存泄漏，这样我们的应用程序才不会耗尽内存。</p><p id="585c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果持续增加内存使用量，那就不好了。</p><p id="b6d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着应用程序一直在使用内存。</p><p id="7587" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有像<a class="ae kc" href="https://github.com/sematext/sematext-agent-express#configure-agent" rel="noopener ugc nofollow" target="_blank"> Sematext Agent Express </a>模块这样的应用程序，可以让我们观察应用程序的CPU和内存使用情况。</p><p id="c58f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">借助该产品包，我们可以将其与以下产品集成:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9fd8" class="mn lc iq mj b gy mo mp l mq mr">const { stMonitor, stLogger, stHttpLoggerMiddleware } =<br/>require('sematext-agent-express')<br/>stMonitor.start() </span><span id="2494" class="mn lc iq mj b gy ms mp l mq mr">const express = require('express')<br/>const app = express()<br/>app.use(stHttpLoggerMiddleware)</span></pre><p id="903c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们的应用程序启动时，我们只需调用<code class="fe mt mu mv mj b">stMonitor.start()</code>开始用Sematext进行监控。</p><p id="c4cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Scout等其他工具也向我们展示了每行代码的内存使用情况。</p><p id="f3b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以看到哪些使用了更多的内存，以及使用更多内存的次数。</p><p id="217f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些还可以监控每个请求的性能问题。</p><h1 id="ad04" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Java Script语言</h1><p id="32d6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以改进Express应用程序的JavaScript代码，使其更易于测试和维护。</p><h1 id="785e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">纯函数</h1><p id="83a3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">纯函数是让let返回某个东西，不改变任何外部状态的函数。</p><p id="e2e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们向它们传递相同的参数，那么它们将总是返回相同的值。</p><p id="12bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得他们的行为可以预测，简化了每个人的生活。</p><p id="52ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以创建新的对象，而不是用pie函数改变现有的对象。</p><p id="e177" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript中纯函数的一些例子包括数组实例的<code class="fe mt mu mv mj b">map</code>和<code class="fe mt mu mv mj b">filter</code>方法等等。</p><h1 id="b6af" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对象参数</h1><p id="eef6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了使用参数，我们应该减少函数中的参数数量。</p><p id="ea53" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个简单的方法是给我们的函数添加一个对象参数。</p><p id="34c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用析构将属性析构为变量。</p><p id="2132" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就不必担心参数的顺序。</p><p id="ecd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="77e1" class="mn lc iq mj b gy mo mp l mq mr">const foo = ({ a, b, c }) =&gt; {<br/>  const sum = a + b + c;<br/>  return sum;<br/>}</span></pre><p id="d80f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需将<code class="fe mt mu mv mj b">a</code>、<code class="fe mt mu mv mj b">b</code>和<code class="fe mt mu mv mj b">c</code>参数作为变量使用。</p><h1 id="163d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">编写测试</h1><p id="579a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">测试对于捕捉回归非常有用。</p><p id="a601" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，如果我们改变我们的代码，我们可以放心，如果现有的测试通过，我们没有杀死任何现有的代码。</p><p id="8242" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用JavaScript，有很多测试框架，包括Mocha，Chai，Jasmine，Jest。</p><p id="4f0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用它们中的任何一个来进行测试。</p><p id="a045" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了柴，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0b69" class="mn lc iq mj b gy mo mp l mq mr">const chai = require('chai')<br/>const expect = chai.expect</span><span id="2c7b" class="mn lc iq mj b gy ms mp l mq mr">const foo = require('./src/foo')</span><span id="66a2" class="mn lc iq mj b gy ms mp l mq mr">describe('foo', function () {<br/>  it('should be a function', function () {<br/>    expect(foo).to.be.a('function')<br/>  })<br/>})</span></pre><p id="f4e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">导入<code class="fe mt mu mv mj b">foo</code>文件并用Chai对其进行测试。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ae797275ff40384a498be1c5f3af23ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7gYxur0KPlZjaVSA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@alexmachado?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alex Machado</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e581" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="2ed6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该适当地处理异常。</p><p id="2b91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用测试来防止错误。</p><p id="a7e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">纯函数和对象参数也有助于我们编写更干净的代码。</p><h2 id="4ceb" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated"><strong class="ak">简明英语JavaScript</strong></h2><p id="a5dc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>