<html>
<head>
<title>Bring RethinkDB’s realtime magic to the frontend with GraphQL</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用GraphQL将RethinkDB的实时魔力带到前端</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/bring-rethinkdbs-realtime-magic-to-the-frontend-with-graphql-1995cf20144f?source=collection_archive---------4-----------------------#2020-09-03">https://javascript.plainenglish.io/bring-rethinkdbs-realtime-magic-to-the-frontend-with-graphql-1995cf20144f?source=collection_archive---------4-----------------------#2020-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/ac1926e81c94a57d3ea3218c0d20d917.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qarRixM-Lgc1JNx--rX3Kw.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by Nicolas Picard on Unsplash</figcaption></figure><div class=""/><p id="b035" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在<a class="ae la" href="https://medium.com/swlh/build-a-chat-app-with-socket-io-and-rethinkdb-df10c5c27bb1" rel="noopener">最近的一篇帖子</a>中，我们探讨了RethinkDB的内置反应性如何非常适合用Socket.io编写聊天应用。在这篇文章中，你将学习如何使用GraphQL订阅，以在前端访问RethinkDB的反应性。</p><p id="2ef6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">RethinkDB是一个实时文档数据库。它易于使用且无模式，就像MongoDB一样。此外，您可以订阅查询并在数据更改时得到通知，这使它成为实时应用程序的最佳选择。</p><blockquote class="lb lc ld"><p id="7b6c" class="kc kd le ke b kf kg kh ki kj kk kl km lf ko kp kq lg ks kt ku lh kw kx ky kz ij bi translated">你也可以试试<a class="ae la" href="https://rethink-chat-graphql.herokuapp.com/" rel="noopener ugc nofollow" target="_blank">运行app </a>，或者查看<a class="ae la" href="https://github.com/mostlytyped/rethink-chat-graphql" rel="noopener ugc nofollow" target="_blank">代码库</a>。</p></blockquote><h1 id="268e" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">应用程序设置</h1><p id="6ff3" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">我们将构建一个Node.js应用程序，因此您需要安装<code class="fe ml mm mn mo b">node</code>和<code class="fe ml mm mn mo b">npm</code>。如果你想把你的应用程序部署到Heroku上，你还需要一个Heroku账户，并安装他们的CLI。要在本地运行您的应用程序，您需要<a class="ae la" href="https://rethinkdb.com/" rel="noopener ugc nofollow" target="_blank">安装并运行一个RethinkDB实例</a>。</p><p id="7bab" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们将使用一个简单的Node.js服务器和一个Vue.js前端。由于前端需要构建，我们将使用<a class="ae la" href="https://cli.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue CLI </a>创建一个Vue应用程序:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="af51" class="mx lj jf mo b gy my mz l na nb">$ vue create -d rethink-chat<br/>$ cd rethink-chat</span></pre><p id="dfcb" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将创建一个节点项目，创建一个Vue.js框架，并初始化一个git存储库。</p><h1 id="ff85" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">准备一个Heroku应用</h1><p id="bce2" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">为了将应用程序部署到Heroku，我们需要创建一个Heroku应用程序:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="7466" class="mx lj jf mo b gy my mz l na nb">$ heroku create</span></pre><p id="9303" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们还需要一个RethinkDB实例来存储和订阅用户之间发送的聊天消息。您可以通过<a class="ae la" href="https://www.rethinkdb.cloud/" rel="noopener ugc nofollow" target="_blank"> RethinkDB Cloud插件</a>来完成此操作，如下所示:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="f69e" class="mx lj jf mo b gy my mz l na nb">$ heroku addons:create rethinkdb</span></pre><blockquote class="lb lc ld"><p id="873b" class="kc kd le ke b kf kg kh ki kj kk kl km lf ko kp kq lg ks kt ku lh kw kx ky kz ij bi translated">RethinkDB Cloud附加组件目前处于alpha版本。为您的Heroku帐户电子邮件申请邀请。</p></blockquote><h1 id="8e03" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">构建服务器</h1><p id="ac5c" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">我们将在<code class="fe ml mm mn mo b">server</code>目录中创建我们的服务器。首先，让我们创建目录并安装所需的依赖项:</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="dd69" class="mx lj jf mo b gy my mz l na nb">$ mkdir server<br/>$ npm install rethinkdb apollo-server-express graphql morgan lorem-ipsum</span></pre><p id="b91f" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在，让我们设置Node.js服务器。创建一个<code class="fe ml mm mn mo b">index.js</code>文件，并添加下面的服务器框架。我们使用Express.js服务器来服务前端，使用Apollo GraphQL服务器来访问和订阅聊天消息。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2ad5" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个框架提供了一个来自<code class="fe ml mm mn mo b">dist</code>文件夹的静态前端。这是我们稍后将创建的已编译的Vue.js应用程序所在的位置。此外，我们的服务器需要做三件事:</p><ol class=""><li id="d63b" class="ne nf jf ke b kf kg kj kk kn ng kr nh kv ni kz nj nk nl nm bi translated">处理与RethinkDB数据库的连接</li><li id="67d4" class="ne nf jf ke b kf nn kj no kn np kr nq kv nr kz nj nk nl nm bi translated">设置阿波罗服务器</li><li id="3b3d" class="ne nf jf ke b kf nn kj no kn np kr nq kv nr kz nj nk nl nm bi translated">创建一个包含类型定义和解析器的GraphQL模式</li></ol><h1 id="d73b" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">重新思考数据库连接</h1><p id="4708" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">我们懒惰地管理我们的RethinkDB连接，也就是说，我们只在实际需要时才创建(重新)连接。连接参数是从环境变量中解析出来的，或者使用默认值。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="dc6c" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Heroku上，RethinkDB Cloud插件将设置环境变量。对于本地运行的RethinkDB实例，缺省值应该有效。</p><h1 id="7c59" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">Apollo GraphQL服务器安装</h1><p id="252c" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">如前所述，前端是静态的。然而，我们确实需要访问聊天室中的数据。这将由使用最多的GraphQL服务器Apollo来处理。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="8888" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将使用模式文件中定义的类型定义和解析创建一个Apollo服务器(下一节)。我们还连接到RethinkDB，并将连接传递给我们的GraphQL上下文，以便它可以用于任何传入的请求。</p><h1 id="b8af" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">创建一个GraphQL模式</h1><p id="6a97" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">服务器的主要逻辑在于定义GraphQL类型并实现它们的解析器。我们需要能够执行三种不同的操作，即</p><ul class=""><li id="0158" class="ne nf jf ke b kf kg kj kk kn ng kr nh kv ni kz ns nk nl nm bi translated">在房间中查询聊天消息</li><li id="d2a5" class="ne nf jf ke b kf nn kj no kn np kr nq kv nr kz ns nk nl nm bi translated">向房间发送聊天信息</li><li id="9d7d" class="ne nf jf ke b kf nn kj no kn np kr nq kv nr kz ns nk nl nm bi translated">在房间中订阅新的聊天消息</li></ul><p id="bdf2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">首先，我们创建GraphQL类型。这由一个<code class="fe ml mm mn mo b">Chat</code>消息类型和三个提到的动作组成，即<code class="fe ml mm mn mo b">chats</code>查询、<code class="fe ml mm mn mo b">sendChat</code>变异和<code class="fe ml mm mn mo b">chatAdded</code>订阅。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="2cd2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">其次，我们需要解析这些动作，即实现它们调用的代码。查询和变异相当简单，实现为一个简单的RethinkDB查询。然而，订阅需要异步迭代器。这基本上是一个将RethinkDB魔术变成GraphQL订阅魔术的咒语。用更通俗的术语来说，异步迭代器包装了RethinkDB变更提要，因此我们可以通过GraphQL订阅它。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="14e8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">设置好服务器后，让我们转到前端。</p><h1 id="a113" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">创建前端</h1><p id="48dc" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">我们已经创建了将用于前端的Vue.js应用程序框架。然而，由于我们的服务器实现了标准的GraphQL后端，您也可以使用React或任何其他支持GraphQL的前端框架。</p><p id="1860" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的前端将使用两个视图，一个用于主页，一个用于聊天室，以及在两者之间导航的路由器。为此，让我们向Vue框架添加一个路由器，并安装所有必需的依赖项。将路由器添加到Vue应用程序将警告您未提交的更改(无论如何继续)，并询问您是否想要历史模式(否)。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="c8b5" class="mx lj jf mo b gy my mz l na nb">$ vue add router<br/>$ npm install apollo-client apollo-link-http apollo-link-ws apollo-cache-inmemory vue-apollo<br/>$ npm install sass sass-loader --save-dev</span></pre><p id="71d6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的Vue应用程序位于<code class="fe ml mm mn mo b">src</code>文件夹中，结构如下:入口点在<code class="fe ml mm mn mo b">main.js</code>中，从<code class="fe ml mm mn mo b">graphql.js</code>获取GraphQL客户端配置。我们的主文件还挂载了显示由<code class="fe ml mm mn mo b">router/index.js</code>中的路由器选择的视图的<code class="fe ml mm mn mo b">App.vue</code>。我们的应用程序包含两个视图，<code class="fe ml mm mn mo b">views/Home.vue</code>和<code class="fe ml mm mn mo b">views/ChatRoom.vue</code>。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="c5f6" class="mx lj jf mo b gy my mz l na nb">src<br/>├── main.js<br/>├── graphql.js<br/>├── App.vue<br/>├── router<br/>│   └── index.js<br/>└── views<br/>    ├── Home.vue<br/>    └── ChatRoom.vue</span></pre><h1 id="a5a4" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">主应用程序和路由器</h1><p id="8ee7" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">第一步，让我们修改在骨架Vue应用中初始化的主应用、主视图和路由器文件。在<code class="fe ml mm mn mo b">main.js</code>中，我们导入了我们将进一步定义的Apollo GraphQL客户端，并将其添加到我们的Vue应用程序中。此外，我们还将为用户创建一个随机的聊天用户名。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="3ba0" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的<code class="fe ml mm mn mo b">App.vue</code>甚至比骨架更简单，它只是显示了路由器视图，并有一些样式。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="4cea" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在我们的<code class="fe ml mm mn mo b">router/index.js</code>中，我们基本上用“房间”路线代替了“关于”路线。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="fbe8" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在主视图中，我们删除了<code class="fe ml mm mn mo b">HelloWorld</code>组件，并添加了一个允许我们加入房间的表单。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="e745" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">既然我们已经用我们需要的部分填充了框架，让我们来处理前端、GraphQL客户端和聊天室视图的真正内容。</p><h1 id="9656" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">GraphQL客户端</h1><p id="6acc" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">当我们的前端加载时，我们需要启动GraphQL客户端。在我们的例子中，我们使用最常用的GraphQL客户端Apollo，它与<code class="fe ml mm mn mo b">vue-apollo</code>包有很好的Vue.js集成。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="6ca2" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">因为我们将使用GraphQL订阅，所以我们的Apollo设置比通常要复杂一些。这是因为普通的GraphQL应该通过HTTP执行，但是订阅更新将通过WebSocket推送。</p><h1 id="4422" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">聊天室视图</h1><p id="3d84" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">前端的最后一块将是<code class="fe ml mm mn mo b">ChatRoom</code>视图。在这里，我们实际上开始使用我们刚刚初始化的GraphQL客户端。这个视图基本上显示了一个列表，其中包含了<code class="fe ml mm mn mo b">chats</code>变量中的所有条目，并提供了一个向后端发送聊天消息的表单。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="949e" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe ml mm mn mo b">sendMessage</code>方法被绑定到<code class="fe ml mm mn mo b">sendChat</code> GraphQL突变。至于<code class="fe ml mm mn mo b">chats</code>变量，绑定就有点复杂了。我们将它绑定到GraphQL <code class="fe ml mm mn mo b">chats</code>查询，此外，我们使用<code class="fe ml mm mn mo b">chatAdded</code>订阅来保持变量最新。</p><p id="24c6" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我们有了一个工作的服务器和前端。我们需要做的最后一件事是，当我们运行应用程序时，确保RethinkDB数据库中确实存在<code class="fe ml mm mn mo b">chats</code>表。</p><h1 id="0782" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">数据库迁移</h1><p id="b826" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">没有<code class="fe ml mm mn mo b">chats</code>表格，应用程序无法运行。因此，我们需要一个添加表的数据库迁移。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="13b4" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这个迁移检查<code class="fe ml mm mn mo b">chats</code>表是否存在，如果它不存在，就创建它。</p><h1 id="c96d" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">一个简单的聊天机器人</h1><p id="b3b5" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">正如我们所看到的，RethinkDBs的一个重要特性是其固有的反应能力，允许我们订阅查询。当创建一个简单的聊天机器人时，这个特性也很方便。机器人只需要订阅<code class="fe ml mm mn mo b">chats</code>表中的变化，并在适当的时候做出反应。</p><p id="1ea7" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">每当用<code class="fe ml mm mn mo b">@lorem</code>提示时，我们的Lorem bot将回复随机的Lorem Ipsum部分。机器人订阅了<code class="fe ml mm mn mo b">chats</code>表，并扫描消息的开头。如果是以<code class="fe ml mm mn mo b">@lorem</code>开头，会回复同室留言。</p><figure class="mp mq mr ms gt is"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="4043" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">将应用程序部署到Heroku</h1><p id="b2c1" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">为了将我们的工作应用程序和bot部署到Heroku，我们需要创建一个<code class="fe ml mm mn mo b">Procfile</code>。这个文件基本上告诉Heroku运行什么进程。</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="4af5" class="mx lj jf mo b gy my mz l na nb">// Procfile</span><span id="df65" class="mx lj jf mo b gy nt mz l na nb">release: node server/migrate.js<br/>web: node server/index.js<br/>lorem-bot: node server/lorem-bot.js</span></pre><p id="7815" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">Heroku将<code class="fe ml mm mn mo b">release</code>和<code class="fe ml mm mn mo b">web</code>进程分别识别为发布时运行的命令和主web应用程序。<code class="fe ml mm mn mo b">lorem-bot</code>进程只是一个工作进程，可以有任何名称。</p><p id="bb8d" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用以下命令将应用程序部署到Heroku</p><pre class="mp mq mr ms gt mt mo mu mv aw mw bi"><span id="80fd" class="mx lj jf mo b gy my mz l na nb">$ git add .<br/>$ git commit -m 'Working rethink-chat app'<br/>$ git push heroku master</span></pre><blockquote class="lb lc ld"><p id="f917" class="kc kd le ke b kf kg kh ki kj kk kl km lf ko kp kq lg ks kt ku lh kw kx ky kz ij bi translated">您需要在Heroku应用程序中手动启用<code class="fe ml mm mn mo b">lorem-bot</code>流程。您可以在“资源”选项卡上执行此操作。</p></blockquote><h1 id="d1a2" class="li lj jf bd lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf bi translated">结论</h1><p id="94a3" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">在不到15分钟的时间里，我们设法用一个简单的机器人创建并部署了一个聊天应用程序。这显示了RethinkDB的强大和易用性。订阅查询的能力使得构建一个反应式应用程序变得很容易，并且可以很容易地与GraphQL集成。此外，Heroku使部署变得轻而易举，有了RethinkDB Cloud插件，您将永远不必亲自管理数据库服务器的繁琐工作。</p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><p id="4628" class="pw-post-body-paragraph kc kd jf ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="le">原载于2020年9月3日</em><a class="ae la" href="https://www.rethinkdb.cloud/2020/09/03/rethinkdb-chat-graphql.html" rel="noopener ugc nofollow" target="_blank"><em class="le">https://www . rethinkdb . cloud</em></a><em class="le">。</em></p><h2 id="dcfa" class="mx lj jf bd lk ob oc dn lo od oe dp ls kn of og lw kr oh oi ma kv oj ok me ol bi translated">简单英语的JavaScript</h2><p id="2510" class="pw-post-body-paragraph kc kd jf ke b kf mg kh ki kj mh kl km kn mi kp kq kr mj kt ku kv mk kx ky kz ij bi translated">你知道我们有三份出版物和一个YouTube频道吗？在<a class="ae la" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ke jg">plain English . io</strong></a>找到一切的链接！</p></div></div>    
</body>
</html>