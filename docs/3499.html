<html>
<head>
<title>Object-Oriented JavaScript — Constructors and Shorthands</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的JavaScript——构造器和快捷键</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-oriented-javascript-constructors-and-shorthands-95fdb824cddc?source=collection_archive---------7-----------------------#2020-10-04">https://javascript.plainenglish.io/object-oriented-javascript-constructors-and-shorthands-95fdb824cddc?source=collection_archive---------7-----------------------#2020-10-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d86129c770ff377204551fd16ff800b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2XPNTHdAXSG1NlW6"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@tjscalzo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tim Scalzo</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8fdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看构造函数和对象简称。</p><h1 id="24b1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构造函数属性</h1><p id="b785" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">constructor</code>属性是实例对象的一部分。</p><p id="7de6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它包含对构造函数的引用。</p><p id="13ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3bb6" class="mq lc iq mh b gy mr ms l mt mu">function Person(name, occupation) {<br/>  this.name = name;<br/>  this.occupation = occupation;<br/>  this.whoAreYou = function() {<br/>    return `${this.name} ${this.occupation}`<br/>  };<br/>}</span><span id="4e4c" class="mq lc iq mh b gy mv ms l mt mu">const jane = new Person('jane', 'writer');</span></pre><p id="108e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="56d0" class="mq lc iq mh b gy mr ms l mt mu">jane.constructor</span></pre><p id="3934" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">是<code class="fe me mf mg mh b">Person</code>构造函数。</p><h1 id="def9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">运算符的实例</h1><p id="7fb5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">instanceof</code>操作符让我们检查对象是否是用给定的构造函数创建的。</p><p id="3622" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="641d" class="mq lc iq mh b gy mr ms l mt mu">jane instanceof Person</span></pre><p id="5f5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe me mf mg mh b">true</code>。</p><p id="521b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们写下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="458d" class="mq lc iq mh b gy mr ms l mt mu">jane instanceof Object</span></pre><p id="be38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那也是<code class="fe me mf mg mh b">true</code>。</p><h1 id="ae3f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">返回对象的函数</h1><p id="e57b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">返回对象的函数称为工厂函数。</p><p id="105a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过编写以下代码来创建工厂函数:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2f05" class="mq lc iq mh b gy mr ms l mt mu">function factory(name) {<br/>  return {<br/>    name<br/>  };<br/>}</span></pre><p id="c561" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以这样称呼它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3520" class="mq lc iq mh b gy mr ms l mt mu">const james = factory('james');</span></pre><p id="e6e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们得到<code class="fe me mf mg mh b">james.names</code>就是<code class="fe me mf mg mh b">'james'</code>。</p><p id="d01d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也可以编写构造函数来返回一个对象，而不是返回一个<code class="fe me mf mg mh b">this</code>的实例。</p><p id="176a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c6ad" class="mq lc iq mh b gy mr ms l mt mu">function C() {<br/>  this.a = 1;<br/>  return {<br/>    b: 2<br/>  };<br/>}</span></pre><p id="ab3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么如果我们调用构造:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="66de" class="mq lc iq mh b gy mr ms l mt mu">const c = new C()</span></pre><p id="a577" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5371" class="mq lc iq mh b gy mr ms l mt mu">{b: 2}</span></pre><h1 id="2c2b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">传递物体</h1><p id="e2bc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将对象传递给函数。</p><p id="d449" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d4e5" class="mq lc iq mh b gy mr ms l mt mu">const reset = function(o) {<br/>  o.count = 0;<br/>};</span></pre><p id="9fae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2f74" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  count: 100<br/>}<br/>reset(obj);<br/>console.log(obj);</span></pre><p id="136b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c1f5" class="mq lc iq mh b gy mr ms l mt mu">{count: 0}</span></pre><p id="9793" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从控制台日志中。</p><h1 id="8bfd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">比较对象</h1><p id="4fee" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不能用<code class="fe me mf mg mh b">===</code>比较对象，因为如果它们有相同的引用，它只返回<code class="fe me mf mg mh b">true</code>。</p><p id="faa8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c254" class="mq lc iq mh b gy mr ms l mt mu">const james = {<br/>  breed: 'cat'<br/>};<br/>const mary = {<br/>  breed: 'cat'<br/>};</span></pre><p id="b7bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8392" class="mq lc iq mh b gy mr ms l mt mu">james === mary</span></pre><p id="7c93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回<code class="fe me mf mg mh b">false</code>，即使它们具有完全相同的属性。</p><p id="9441" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回<code class="fe me mf mg mh b">true</code>的唯一方式是我们将一个对象赋给另一个对象。</p><p id="cae4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ce3c" class="mq lc iq mh b gy mr ms l mt mu">const james = {<br/>  breed: 'cat'<br/>};<br/>const mary = james;</span></pre><p id="928c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="db41" class="mq lc iq mh b gy mr ms l mt mu">james === mary</span></pre><p id="cbda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回<code class="fe me mf mg mh b">true</code>。</p><h1 id="a64f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">ES6对象文字</h1><p id="d88f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">ES6为我们提供了一个更短的定义对象文字的语法。</p><p id="5a25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8a3f" class="mq lc iq mh b gy mr ms l mt mu">let foo = 1<br/>let bar = 2<br/>let obj = {<br/>  foo: foo,<br/>  bar: bar<br/>}</span></pre><p id="0376" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以简化为:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3a13" class="mq lc iq mh b gy mr ms l mt mu">let foo = 1<br/>let bar = 2<br/>let obj = {<br/>  foo,<br/>  bar<br/>}</span></pre><p id="c762" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以简化方法。</p><p id="fd03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8262" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  prop: 1,<br/>  modifier: function() {<br/>    console.log(this.prop);<br/>  }<br/>}</span></pre><p id="bcfb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="39d2" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  prop: 1,<br/>  modifier() {<br/>    console.log(this.prop);<br/>  }<br/>}</span></pre><p id="edfe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用计算属性键。</p><p id="553c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5991" class="mq lc iq mh b gy mr ms l mt mu">let vehicle = "car";<br/>let car = {<br/>  [`${vehicle}_model`]: "toyota"<br/>}</span></pre><p id="8e4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以对方法做同样的事情。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/55f565164387cb436be91c32320f84a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g_RzPuxas3mtRmjb"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ingle_jake?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jake Ingle</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7ba5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="19af" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对象文字可以用不同的方式编写。</p><p id="8a78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">constructor</code>属性和<code class="fe me mf mg mh b">instanceof</code>来检查构造函数。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/787be6c671be8d345dc786dad8729ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-sOyyG8NoRbKpCG_y4Cmw@2x.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank">Subscribe to Decoded, our official YouTube channel!</a></figcaption></figure></div></div>    
</body>
</html>