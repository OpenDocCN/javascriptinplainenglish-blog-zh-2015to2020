<html>
<head>
<title>JavaScript object immutability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript对象不变性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-object-immutability-b6d7b1e0297?source=collection_archive---------2-----------------------#2019-09-09">https://javascript.plainenglish.io/javascript-object-immutability-b6d7b1e0297?source=collection_archive---------2-----------------------#2019-09-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="c5fd" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解所有这些是如何工作的</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/aad9e4b42aeaaeefb6146db110e2d39c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2tF29_S2OiYfREAoRyKHaA.jpeg"/></div></div></figure><p id="32ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在JavaScript中有三种方法可以实现对象的不变性。</p><ul class=""><li id="e3db" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">object . prevent extension(obj)；</li><li id="6286" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">object . seal(obj)；</li><li id="eaf2" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">object . freeze(obj)；</li></ul><p id="8f37" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了理解JavaScript中对象不变性的工作原理，你必须首先理解任何对象的属性是如何用<strong class="kt ir"> <em class="mb">描述的</em> </strong> <em class="mb">。</em></p></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="7f30" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">属性描述符</h1><p id="4996" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">JavaScript中的对象有属性，从ES5开始，所有属性都用<strong class="kt ir"> <em class="mb">属性描述符</em> </strong>来描述。您可以通过以下方式获取任何对象中属性的描述符</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="04cc" class="nl mk iq nh b gy nm nn l no np">Object.getOwnPropertyDescriptor(obj, 'property');</span></pre><p id="3747" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这返回的是一个包含属性值及其特征的对象，<em class="mb">如何描述</em>。这是你如何使用它</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="5e0a" class="nl mk iq nh b gy nm nn l no np">const obj = {<br/>    x: 'some value of x'<br/>}</span><span id="5c43" class="nl mk iq nh b gy nq nn l no np">const descriptors = Object.getOwnPropertyDescriptor(obj, 'x');</span><span id="c992" class="nl mk iq nh b gy nq nn l no np">console.log(descriptors);</span><span id="e11c" class="nl mk iq nh b gy nq nn l no np">/* Returns<br/>Object { <br/>    value: 'some value of x', <br/>    writable: true, <br/>    enumerable: true, <br/>    configurable: true <br/>}*/</span></pre><p id="eb90" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">默认情况下，对象属性描述符(即可写、可配置和可枚举)都设置为真。我们将在这一部分详细讨论每一个问题。</p><p id="f697" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">要更改属性的描述符，可以使用<code class="fe nr ns nt nh b">Object.defineProperty(obj, prop, descriptor)</code>方法。它需要的三个参数是</p><ul class=""><li id="2e4f" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated"><strong class="kt ir"> obj: </strong>要定义属性的对象</li><li id="9ce0" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated"><strong class="kt ir">属性:</strong>要定义或修改的属性名</li><li id="c279" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated"><strong class="kt ir">描述符:</strong>被定义或修改的属性的描述符。</li></ul><p id="6964" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mb">有一点需要注意的是，当使用</em> <code class="fe nr ns nt nh b"><em class="mb">defineProperty</em></code> <em class="mb">方法给</em> <strong class="kt ir"> <em class="mb">对象添加</em> </strong> <em class="mb">属性时，新属性的描述符默认为</em> <strong class="kt ir"> <em class="mb">假</em> </strong> <em class="mb">。在上面的例子中，所有描述符都被默认设置为真的原因是因为我们没有使用</em> <code class="fe nr ns nt nh b"><em class="mb">defineProperty</em></code> <em class="mb">方法来定义‘x’。与上面的例子相比，考虑下面的例子。</em></p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="3f0a" class="nl mk iq nh b gy nm nn l no np">const obj1 = {};</span><span id="2443" class="nl mk iq nh b gy nq nn l no np">Object.defineProperty(obj1, 'prop1', {<br/>  value: 42,<br/>});</span><span id="0c8d" class="nl mk iq nh b gy nq nn l no np">const descriptors = Object.getOwnPropertyDescriptor(obj1, 'prop1');</span><span id="2e37" class="nl mk iq nh b gy nq nn l no np">console.log(descriptors);</span><span id="0f84" class="nl mk iq nh b gy nq nn l no np">/* Returns<br/>Object { <br/>    value: 42, <br/>    writable: false, <br/>    enumerable: false, <br/>    configurable: false <br/>}*/</span></pre><h2 id="6747" class="nl mk iq bd ml nu nv dn mp nw nx dp mt la ny nz mv le oa ob mx li oc od mz oe bi translated">可写的</h2><p id="325a" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">当可写描述符设置为true <em class="mb">，</em>时，您可以为属性赋值和重新赋值。这里有一个例子</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="5896" class="nl mk iq nh b gy nm nn l no np">let myObject = {<br/>    x: 'someValue'<br/>};</span><span id="c44f" class="nl mk iq nh b gy nq nn l no np">myObject.x = 'some other value';<br/>myObject.x = 52;</span></pre><p id="2a1a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一切按预期运行。然而，当<strong class="kt ir">可写描述符</strong>的值设置为false时，您将无法更改该值。</p><p id="75b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看这将如何工作。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="13c6" class="nl mk iq nh b gy nm nn l no np">let myObject = { x: 52 }; // writable is true</span><span id="d16e" class="nl mk iq nh b gy nq nn l no np">Object.defineProperty(myObject, 'x', {<br/>    writable: false<br/>});</span><span id="9514" class="nl mk iq nh b gy nq nn l no np">// The following will silently fail<br/>myObject.x = 42;</span></pre><p id="c1c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当重新分配属性值时，除非您打开了<code class="fe nr ns nt nh b">'use strict'</code> <em class="mb">(严格模式)</em>，否则重新分配会自动失败。如果打开了严格模式，JavaScript将抛出一个错误，告诉您该属性是只读的。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="8234" class="nl mk iq nh b gy nm nn l no np">Error: "x" is read-only</span></pre><h2 id="c0c2" class="nl mk iq bd ml nu nv dn mp nw nx dp mt la ny nz mv le oa ob mx li oc od mz oe bi translated">可配置的</h2><p id="7fcc" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">当这个描述符设置为true时，您可以更改属性的描述符。这里有一个例子</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="03e7" class="nl mk iq nh b gy nm nn l no np">let myObj = {<br/>    x: 52<br/>};</span><span id="3040" class="nl mk iq nh b gy nq nn l no np">// By default the configurable descriptor on 'x' is set to true so you can do the following i.e. you can configure it.</span><span id="8051" class="nl mk iq nh b gy nq nn l no np">Object.defineProperty(myObj, x, {<br/>    enumerable: false<br/>});</span></pre><p id="0d5a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，当<strong class="kt ir">可配置描述符</strong>设置为false时，您将无法更改属性描述符<em class="mb">(除了</em> <strong class="kt ir"> <em class="mb">可写</em> </strong> <em class="mb">和</em> <strong class="kt ir"> <em class="mb">值</em> </strong> <em class="mb">，您将无法配置属性)。不仅如此，你也不能从对象中删除属性。当您希望防止代码的其他部分意外删除某个属性时，这尤其有用。这是它看起来的样子</em></p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="0e9a" class="nl mk iq nh b gy nm nn l no np">let myObj = { x: 32 };</span><span id="5124" class="nl mk iq nh b gy nq nn l no np">Object.defineProperty(myObj, 'x', {<br/>    configurable: false<br/>});</span><span id="19ca" class="nl mk iq nh b gy nq nn l no np">// Other than the 'writable' and 'value' descriptors, you can't re-configure this property;</span><span id="9b08" class="nl mk iq nh b gy nq nn l no np">// You also can't delete the property<br/>delete myObj.x;</span></pre><p id="d0ea" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在将可配置描述符设置为false之后，如果您试图在严格模式下重新配置一个属性，它将抛出以下错误</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="dc91" class="nl mk iq nh b gy nm nn l no np">'use strict';</span><span id="d998" class="nl mk iq nh b gy nq nn l no np">const object1 = { x: 2 };</span><span id="3760" class="nl mk iq nh b gy nq nn l no np">Object.defineProperty(object1, 'x', {<br/>  configurable: false<br/>});</span><span id="9486" class="nl mk iq nh b gy nq nn l no np">Object.defineProperty(object1, 'x', {<br/>  enumerable: false<br/>});</span><span id="b9d4" class="nl mk iq nh b gy nq nn l no np">// Error: can't redefine non-configurable property "x"</span></pre><p id="74ed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当你试图删除属性时，它会抛出</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="3ba2" class="nl mk iq nh b gy nm nn l no np">'use strict';</span><span id="9517" class="nl mk iq nh b gy nq nn l no np">const object1 = { x: 2 };</span><span id="5be6" class="nl mk iq nh b gy nq nn l no np">Object.defineProperty(object1, 'x', {<br/>  configurable: false<br/>});</span><span id="0f09" class="nl mk iq nh b gy nq nn l no np">delete object1.x;<br/>console.log(object1.x);</span><span id="2eaf" class="nl mk iq nh b gy nq nn l no np">// Error: property "x" is non-configurable and can't be deleted</span></pre><h2 id="f8c8" class="nl mk iq bd ml nu nv dn mp nw nx dp mt la ny nz mv le oa ob mx li oc od mz oe bi translated">可列举的</h2><p id="0e06" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">当此描述符设置为true时，将在迭代对象键时读取该属性。这意味着密钥将出现在<code class="fe nr ns nt nh b">Object.keys()</code>中的<code class="fe nr ns nt nh b">for…in</code>循环中。这里有一个例子</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="3296" class="nl mk iq nh b gy nm nn l no np">const obj = {<br/>    x: 52 //enumerable is true<br/>};</span><span id="e307" class="nl mk iq nh b gy nq nn l no np">Object.defineProperty(obj, 'a’, {<br/>    value: 1 // enumerable is false<br/>});</span><span id="e05d" class="nl mk iq nh b gy nq nn l no np">Object.defineProperty(obj, 'b’, {<br/>    value: 1, <br/>    enumerable: true // self explanatory<br/>});</span><span id="e36a" class="nl mk iq nh b gy nq nn l no np">obj.c = 53; // When creating properties by setting them, the descriptors are defaulted to true.</span><span id="f7c7" class="nl mk iq nh b gy nq nn l no np">for (key in obj) {<br/>    console.log(key) // x, b, c<br/>}</span><span id="654a" class="nl mk iq nh b gy nq nn l no np">console.log(Object.keys(obj)); // [x, b, c]</span></pre><p id="577a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您还可以通过对对象使用<code class="fe nr ns nt nh b">propertyIsEnumerable </code>方法来检查属性是否是可枚举的，如下所示</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="d63f" class="nl mk iq nh b gy nm nn l no np">obj.propertyIsEnumerable('x'); // true<br/>obj.propertyIsEnumerable('a'); // false<br/>obj.propertyIsEnumerable('b'); // true<br/>obj.propertyIsEnumerable('c'); // true</span></pre></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="0b88" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">对象不变性</h1><p id="8a8b" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">终于！既然我们知道了对象属性是如何工作的，以及它们是如何被描述的，那么理解对象不变性是如何工作的就非常容易了。实现不同级别的对象不变性的三种方法是</p><ul class=""><li id="9959" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">Object.preventExtensions()</li><li id="9fcb" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">Object.seal()</li><li id="d40a" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">Object.freeze()</li></ul><p id="e5f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些方法本质上利用属性描述符来使对象不可变。让我们一个一个来看</p><h2 id="9b38" class="nl mk iq bd ml nu nv dn mp nw nx dp mt la ny nz mv le oa ob mx li oc od mz oe bi translated">Object.preventExtensions()</h2><p id="1903" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">默认情况下，对象是可扩展的，这意味着可以向它们添加属性。要检查一个对象是否是可扩展的，你可以像这样使用<code class="fe nr ns nt nh b">isExtensible </code>方法</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="8c61" class="nl mk iq nh b gy nm nn l no np">const someObject = {};<br/>Object.isExtensible(someObject); // true</span></pre><p id="8b98" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这可以通过使用像这样的<code class="fe nr ns nt nh b">preventExtensions </code>方法来改变</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="d086" class="nl mk iq nh b gy nm nn l no np">Object.preventExtensions(someObject);<br/>Object.isExtensible(someObject); // false</span></pre><p id="d151" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，当您尝试向该对象添加属性时，将会抛出一个错误</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="67d0" class="nl mk iq nh b gy nm nn l no np">Object.defineProperty(someObject, 'nProp', { value: 52 });<br/>//  <!-- -->Error: can't define property "nProp": Object is not extensible</span></pre><p id="4c2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当您希望对象的用户能够使用它做任何事情，但不添加更多属性时，这非常有用。</p><p id="27e6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">注:</strong>这里要注意的一点是<code class="fe nr ns nt nh b">Object.preventExtensions()</code>只阻止属性给对象它自己。您仍然可以向对象的<code class="fe nr ns nt nh b">[[Prototype]]</code>添加属性。JavaScript中的<code class="fe nr ns nt nh b">[[Get]]</code>和<code class="fe nr ns nt nh b">[[Put]]</code>算法如何工作是另一篇<a class="ae of" href="https://medium.com/@haseebkhan_90/javascript-property-accesses-5a1bebf351cf?source=friends_link&amp;sk=12598e8824cb095f33ca04a202b3efbb" rel="noopener">文章</a>的主题。</p><h2 id="1c29" class="nl mk iq bd ml nu nv dn mp nw nx dp mt la ny nz mv le oa ob mx li oc od mz oe bi translated">Object.seal()</h2><p id="a8d0" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">该方法调用对象上的<code class="fe nr ns nt nh b">Object.preventExtensions()</code>，并将所有属性的可配置描述符设置为false。这确保了你的对象的用户不能添加更多的属性或者从对象中删除<em class="mb">(删除)</em>属性。这里有一个例子</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="e012" class="nl mk iq nh b gy nm nn l no np">const obj = {<br/>  x: 42<br/>};</span><span id="55f9" class="nl mk iq nh b gy nq nn l no np">Object.seal(obj);</span><span id="2cdb" class="nl mk iq nh b gy nq nn l no np">obj.x = 52;<br/>console.log(obj.x); // 52</span><span id="cbb3" class="nl mk iq nh b gy nq nn l no np">delete obj.x; // cannot delete when sealed<br/>console.log(obj.x); // 52</span><span id="09cd" class="nl mk iq nh b gy nq nn l no np">Object.defineProperty(obj, 'y', { value: 24 });<br/>//  <!-- -->Error: can't define property "y": Object is not extensible</span></pre><h2 id="d41a" class="nl mk iq bd ml nu nv dn mp nw nx dp mt la ny nz mv le oa ob mx li oc od mz oe bi translated">Object.freeze()</h2><p id="fb32" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">这就像它听起来的那样。它通过使用Object.preventExtensions、Object.seal冻结对象，并使所有属性的可写描述符为false。这是你所能拥有的最高形式的不变性。它防止向其中添加新属性，防止移除现有属性，防止更改现有属性的可枚举性、可配置性或可写性，并防止更改现有属性的值。此外，它还防止修改对象的<code class="fe nr ns nt nh b">[[Prototype]]</code>。</p><pre class="kg kh ki kj gt ng nh ni nj aw nk bi"><span id="4e89" class="nl mk iq nh b gy nm nn l no np">'use strict';</span><span id="baba" class="nl mk iq nh b gy nq nn l no np">const obj = { <br/>    x: 52 <br/>};</span><span id="4949" class="nl mk iq nh b gy nq nn l no np">Object.freeze(obj);</span><span id="ad50" class="nl mk iq nh b gy nq nn l no np">obj.x = 32;<br/>// Error: "x" is read-only</span><span id="cd94" class="nl mk iq nh b gy nq nn l no np">obj.y = 52; <br/>// Error: can't define property "y": Object is not extensible</span><span id="4689" class="nl mk iq nh b gy nq nn l no np">Object.defineProperty(obj, 'y', { value: 52 });<br/>// Error: can't define property "y": Object is not extensible</span><span id="f3d4" class="nl mk iq nh b gy nq nn l no np">Object.defineProperty(obj, 'x', { enumerable: false });<br/>// <!-- -->Error: can't redefine non-configurable property "x"</span><span id="354f" class="nl mk iq nh b gy nq nn l no np">Object.defineProperty(obj, 'x', { writable: true});<br/>// <!-- -->Error: can't redefine non-configurable property "x"</span></pre></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h1 id="50c9" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">结论</h1><p id="8246" class="pw-post-body-paragraph kr ks iq kt b ku nb jr kw kx nc ju kz la nd lc ld le ne lg lh li nf lk ll lm ij bi translated">一旦你知道不同的属性描述符是如何工作的，并随着不同的方法而改变，理解<strong class="kt ir">对象不变性</strong>就变得容易多了。现在，您应该已经了解了不同的可用属性描述符，如何修改它们，修改它们的副作用，以及如何在对象不变性中使用它们。现在，您还应该知道可以用来实现不同级别的对象不变性的三种方法，以及它们在幕后是如何工作的。</p><p id="1442" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">您以前是否修改过属性描述符？让对象不可变怎么样？请在下面的评论中告诉我你对这些东西的体验，以及你在使用它们时遇到的任何问题。</p><p id="7e8f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">干杯！</p></div></div>    
</body>
</html>