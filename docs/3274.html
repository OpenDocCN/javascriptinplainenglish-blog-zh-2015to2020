<html>
<head>
<title>The Modern Way to Style with Styled Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用样式化组件设计样式的现代方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-modern-way-to-style-with-styled-components-c3c51b750b5f?source=collection_archive---------2-----------------------#2020-09-15">https://javascript.plainenglish.io/the-modern-way-to-style-with-styled-components-c3c51b750b5f?source=collection_archive---------2-----------------------#2020-09-15</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6e61" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">深入了解样式化组件的强大功能</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b1d3033393fddf1a2491fcddd7cd75e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*haMEQHfMceoIpoEs30wzuA.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@grakozy" rel="noopener ugc nofollow" target="_blank">Greg Rakozy</a> on <a class="ae ks" href="https://unsplash.com/" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4b75" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">我的旅程</h1><p id="7af6" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">像许多人一样，我第一次开始使用内联CSS设计React。这是来自样式表的调整，但我真的很喜欢定义本地化样式和利用Javascript力量的能力。当然，也有一些问题，比如性能和缺乏伪选择器支持，但是总体来说我很满意，没有令人信服的理由或不足来寻找另一种方式来设计我的组件。</p><p id="f8ef" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">当我第一次接触到<a class="ae ks" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank">风格的组件</a>时，我有点担心它的好处，因为我已经习惯内联CSS很久了。毕竟，React documentation(当时)仍然对所有的例子使用内联CSS。当我原型化这个框架时，我发现了内联CSS和传统样式表之间的两全其美。</p><h1 id="da72" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">样式组件</h1><p id="cea3" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">尽管定义非常不同，但样式化组件的行为基本上类似于React组件。它们都以props作为HTML的输入和输出。</p><p id="7adb" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">让我们以这个按钮组件为例，它的样式类似于<a class="ae ks" href="https://getbootstrap.com/docs/4.0/components/buttons/" rel="noopener ugc nofollow" target="_blank"> Bootstrap的按钮</a>的样式。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="35d2" class="mr ku in mn b gy ms mt l mu mv">import styled from 'styled-components';</span><span id="b309" class="mr ku in mn b gy mw mt l mu mv">const Button = styled.button`<br/>  display: inline-block;<br/>  padding: 6px 12px;<br/>  font-size: 16px;<br/>  font-family: Arial, sans-serif;<br/>  line-height: 1.5;<br/>  color: white;<br/>  background-color: #6c757d;<br/>  border: none;<br/>  border-radius: 4px;</span><span id="ae39" class="mr ku in mn b gy mw mt l mu mv">  :not(:disabled) {<br/>    cursor: pointer;<br/>  }</span><span id="9fdd" class="mr ku in mn b gy mw mt l mu mv">  :hover {<br/>    background-color: #5a6268;<br/>  }<br/>`;</span></pre><p id="ca1b" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">导入<code class="fe mx my mz mn b">styled</code>组件工厂，并使用模板文字(<code class="fe mx my mz mn b">`...`</code>)生成带有样式的按钮。该工厂支持所有有效的<a class="ae ks" href="https://github.com/styled-components/styled-components/blob/master/packages/styled-components/src/utils/domElements.js" rel="noopener ugc nofollow" target="_blank"> HTML元素</a>，无论是<code class="fe mx my mz mn b">div</code>、<code class="fe mx my mz mn b">h1</code>、<code class="fe mx my mz mn b">p</code>等。类似地，模板文本中的样式接受所有有效的CSS，因此您可以疯狂使用复杂的<a class="ae ks" href="https://www.w3schools.com/cssref/css_selectors.asp" rel="noopener ugc nofollow" target="_blank"> CSS选择器</a>。</p><h1 id="d6c4" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">使用</h1><p id="4e20" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">一旦被定义，它们的行为就完全像React组件，并且以完全相同的方式使用——JSX。毕竟，样式化组件只是带有某种样式的React组件。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="1989" class="mr ku in mn b gy ms mt l mu mv">const App = () =&gt; {<br/>  return (<br/>    &lt;Button onClick={() =&gt; alert('clicked!')} type="button"&gt;<br/>      Button<br/>    &lt;/Button&gt;<br/>  );<br/>};</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi na"><img src="../Images/0191cc13eb43a15687de2edd2e3edfab.png" data-original-src="https://miro.medium.com/v2/resize:fit:420/format:webp/1*eKhZlI1WH59MqtEowHGLTA.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Styled Component Button</figcaption></figure><p id="9a80" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">就像React组件一样，Styled组件也接受props，并以完全相同的方式定义。样式化的组件会将所有(有效的)DOM属性传递给DOM。</p><h1 id="e5da" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">内部构件</h1><p id="7d0a" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">好吧，这是怎么回事？内部正在发生什么神奇的过程？</p><ol class=""><li id="3fe2" class="nb nc in ln b lo mh lr mi lu nd ly ne mc nf mg ng nh ni nj bi translated">在渲染时，样式化组件将基于定义的样式生成唯一的类名。</li><li id="211d" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated">样式化组件将在HTML头中注入一个样式标签(<code class="fe mx my mz mn b">&lt;style&gt;</code>)，将惟一的类名映射到定义的样式。</li><li id="6baf" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg ng nh ni nj bi translated">样式化组件将使用唯一的类名呈现元素。</li></ol><p id="22b8" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">对于我们的例子，这些步骤将导致DOM结构看起来像这样。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="3b62" class="mr ku in mn b gy ms mt l mu mv">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>  &lt;head&gt;<br/>    &lt;style data-styled="active" data-styled-version="5.2.0"&gt;<br/>      .bAeiQF {<br/>          display: inline-block;<br/>          padding: 6px 12px;<br/>          font-size: 16px;<br/>          font-family: Arial, sans-serif;<br/>          line-height: 1.5;<br/>          color: white;<br/>          background-color: #6c757d;<br/>          border: none;<br/>          border-radius: 4px;<br/>      }<br/>      .bAeiQF:not(:disabled) {<br/>          cursor: pointer;<br/>      }<br/>      .bAeiQF:hover {<br/>          background-color: #5a6268;<br/>      }<br/>    &lt;/style&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>  &lt;div id="root"&gt;<br/>    &lt;button type="button" class="sc-bdnylx bPvsWA"&gt;<br/>      Button<br/>    &lt;/button&gt;<br/>  &lt;/div&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><h1 id="d348" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">扩展组件</h1><p id="5ba9" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">组件工厂也可以用来扩展现有的样式。它可以接受一个样式化的组件，并以类似React的高阶组件的方式返回一个新的组件。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="eca4" class="mr ku in mn b gy ms mt l mu mv">const PrimaryButton = styled(Button)`<br/>  background-color: #007bff;<br/>  :hover {<br/>    background-color: #0069d9;<br/>  }<br/>`;</span><span id="8607" class="mr ku in mn b gy mw mt l mu mv">const App = () =&gt; {<br/>  return (<br/>    &lt;PrimaryButton onClick={() =&gt; alert('clicked!')} type="button"&gt;<br/>      Primary<br/>    &lt;/Button&gt;<br/>  );<br/>};</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi np"><img src="../Images/838d52e94235e4598dd13fc8e5aedfa7.png" data-original-src="https://miro.medium.com/v2/resize:fit:552/format:webp/1*S9ifZlJ2nNS-LCjz95ukpQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Extended Style Button</figcaption></figure><p id="22ce" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">使用<code class="fe mx my mz mn b">styled</code>作为一个函数将产生一个新的样式化组件，该组件具有来自<code class="fe mx my mz mn b">Button</code>组件的样式和模板文本中定义的新样式。如果样式冲突，新样式优先。所有道具(带<code class="fe mx my mz mn b">$</code>前缀的除外；参见<a class="ae ks" href="#362b" rel="noopener ugc nofollow">造型道具</a>)也将被传递给底层组件。</p><p id="10af" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">类似地，<code class="fe mx my mz mn b">styled</code>组件工厂可以通过小的修改来扩展React组件。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="d597" class="mr ku in mn b gy ms mt l mu mv">const ButtonComponent = ({ className }) =&gt; {<br/>  return (<br/>    &lt;Button<br/>      className={className}<br/>      onClick={() =&gt; alert('clicked!')}<br/>      type="button"<br/>    &gt;<br/>      Primary<br/>    &lt;/Button&gt;<br/>  );<br/>};</span><span id="c429" class="mr ku in mn b gy mw mt l mu mv">const PrimaryButton = styled(ButtonComponent)`<br/>  background-color: #007bff;<br/>  :hover {<br/>    background-color: #0069d9;<br/>  }<br/>`;</span></pre><p id="f074" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">实现这一点的一个关键附加功能是<code class="fe mx my mz mn b">className</code>支柱。扩展样式的组件将设置<code class="fe mx my mz mn b">className</code>并在渲染时将其传递给React组件。这个<code class="fe mx my mz mn b">className</code>将映射到定义的样式，就像它如何处理样式化的组件一样。因此，如果没有<code class="fe mx my mz mn b">className</code>，样式将无法应用。</p><h1 id="1579" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">可组合的样式</h1><p id="86db" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">样式组件还允许我们定义可重用的样式，这些样式可以组合成样式组件。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="e8c2" class="mr ku in mn b gy ms mt l mu mv">import styled, { css } from 'styled-components';</span><span id="ab7c" class="mr ku in mn b gy mw mt l mu mv">const blackFont = css`<br/>  color: black;<br/>`;</span><span id="b8fb" class="mr ku in mn b gy mw mt l mu mv">const WarningButton = styled(Button)`<br/>  background-color: #ffc107;<br/>  :hover {<br/>    background-color: #e0a800;<br/>  }<br/>  ${blackFont}<br/>`;</span><span id="cd2c" class="mr ku in mn b gy mw mt l mu mv">const App = () =&gt; {<br/>  return (<br/>    &lt;WarningButton onClick={() =&gt; alert('clicked!')} type="button"&gt;<br/>      Warning<br/>    &lt;/WarningButton&gt;<br/>  );<br/>};</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/04ca9ee8530439a6976756c9105bcc44.png" data-original-src="https://miro.medium.com/v2/resize:fit:568/format:webp/1*MqeBmC_uCSC-p6_IwQZy6Q.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Composed Style Button</figcaption></figure><p id="0e5a" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">在这里，<code class="fe mx my mz mn b">blackFont</code>是一个通用的样式。它是使用<code class="fe mx my mz mn b">css</code>助手用模板文字定义的。<code class="fe mx my mz mn b">WarningButton</code>和任何其他样式的组件都可以包含这种带有美元符号花括号语法的样式，以合并两个模板文字。</p><h1 id="362b" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">造型道具</h1><p id="20b3" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">此外，样式组件本身可以使用道具来修改样式。</p><pre class="kd ke kf kg gt mm mn mo mp aw mq bi"><span id="115d" class="mr ku in mn b gy ms mt l mu mv">import styled, { css } from 'styled-components';</span><span id="d05d" class="mr ku in mn b gy mw mt l mu mv">const SuccessButton = styled(Button)`<br/>  ${props =&gt;<br/>    props.$success<br/>      ? css`<br/>          background-color: #28a745;<br/>          :hover {<br/>            background-color: #218838;<br/>          }<br/>        `<br/>      : ''}<br/>`;</span><span id="32d3" class="mr ku in mn b gy mw mt l mu mv">const App = () =&gt; {<br/>  return (<br/>    &lt;SuccessButton<br/>      $success<br/>      onClick={() =&gt; alert('clicked!')}<br/>      type="button"<br/>    &gt;<br/>        Success<br/>    &lt;/SuccessButton&gt;<br/>  );<br/>};</span></pre><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/3b84edb2c0ff0c830de8516217923ec5.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*HFl9hq0fcMS1oHR1XuNgDg.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Styling Props Button</figcaption></figure><p id="cea2" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">在这里，<code class="fe mx my mz mn b">Button</code>组件被扩展为采用一个<code class="fe mx my mz mn b">$success</code>属性，如果设置为true，该属性将有条件地设置成功样式(使用可组合样式)。</p><p id="0a0e" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">虽然造型道具不需要<code class="fe mx my mz mn b">$</code>前缀，但我强烈推荐。通常，所有的props都被传递给底层组件(DOM元素、React组件或样式化组件)。名称以<code class="fe mx my mz mn b">$</code>为前缀的属性称为瞬态属性，仅由定义的样式组件使用，不会传递给底层组件。这就非常清楚哪些道具是用于造型的，哪些道具是用于底层组件的。</p></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><h1 id="786c" class="kt ku in bd kv kw nz ky kz la oa lc ld jt ob ju lf jw oc jx lh jz od ka lj lk bi translated">最后的想法</h1><p id="ee31" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">Styled Components为样式化提供了一个简单而奇妙的界面。它使用核心React原则增强了开发人员对CSS的体验。它与React集成得如此之好，以至于我不禁想知道React为什么不直接集成它——它就是这么好。我再也不会回到我以前的造型方式了。</p></div><div class="ab cl ns nt hr nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ig ih ii ij ik"><h1 id="c0a8" class="kt ku in bd kv kw nz ky kz la oa lc ld jt ob ju lf jw oc jx lh jz od ka lj lk bi translated">资源</h1><ul class=""><li id="5afc" class="nb nc in ln b lo lp lr ls lu oe ly of mc og mg oh nh ni nj bi translated"><a class="ae ks" href="https://styled-components.com/" rel="noopener ugc nofollow" target="_blank">官方风格组件文档</a></li><li id="52c9" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg oh nh ni nj bi translated"><a class="ae ks" href="https://github.com/mjchang/medium/tree/master/styled-components-1" rel="noopener ugc nofollow" target="_blank"> Github回购本文</a></li><li id="50b1" class="nb nc in ln b lo nk lr nl lu nm ly nn mc no mg oh nh ni nj bi translated"><a class="ae ks" href="https://codesandbox.io/s/github/mjchang/medium/tree/master/styled-components-1" rel="noopener ugc nofollow" target="_blank">本文的CodeSandbox】</a></li></ul></div></div>    
</body>
</html>