<html>
<head>
<title>JavaScript new features in ES2020(ES11)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2020(ES11)中的JavaScript新特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/new-javascript-features-in-es2020-c2d76acf9c5a?source=collection_archive---------0-----------------------#2020-02-18">https://javascript.plainenglish.io/new-javascript-features-in-es2020-c2d76acf9c5a?source=collection_archive---------0-----------------------#2020-02-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b5c0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简短、有用的JavaScript课程——让它变得简单。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6b424bcba20ddd192d8c6cd0e1e1026f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LeYBjLHr6kmYIoSx-aHdDA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image of two monitors with code in their screens</figcaption></figure><p id="9893" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在本文中，我们将回顾ES2020的一些最新功能。</p><p id="4fc2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">其中一些是:</p><ul class=""><li id="5efc" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">私有类变量</li><li id="adbd" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">承诺。都解决了</li><li id="1245" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">字符串.原型.匹配</li><li id="b6a0" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">可选链接运算符</li><li id="e535" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">动态导入</li><li id="0ef9" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">BigInt</li></ul><p id="651e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意:所有的例子都已经在Chrome版本79中测试过了</p><h2 id="9965" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">私有类变量</h2><p id="1ee9" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">通过在变量或函数前面添加一个简单的散列符号，我们可以将它们完全保留给类内部使用。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="e6fe" class="mf mg iq ne b gy ni nj l nk nl">class Person {<br/>  #born = 1980<br/>  age() { console.log(2020 - this.#born) }<br/>}</span><span id="d724" class="mf mg iq ne b gy nm nj l nk nl">const person1 = new Person()<br/>person1.age() // 40</span><span id="8730" class="mf mg iq ne b gy nm nj l nk nl">console.log(person1.#born)<br/>//Uncaught SyntaxError: Private field '#born' must be declared in an     <br/>//enclosing class</span></pre><h2 id="52cd" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">承诺。都解决了</h2><p id="45d5" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">自从ES6中引入了promises，JavaScript已经支持了两个promise组合子:静态方法Promise.all和Promise.race。现在，ES2020中添加了Promise.allSettled。</p><p id="9d64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不像Promise.all或Promise.race分别在任何承诺被拒绝或解决时短路，Promise.allSettled运行所有承诺，而不考虑任何承诺的拒绝。</p><ul class=""><li id="7886" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">Promise.allSettled不会短路ES2020中添加的</li><li id="5d08" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">在ES6中增加了输入值被拒绝时的所有短路</li><li id="0ab1" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">在ES6中增加了输入值稳定时Promise.race短路</li></ul><p id="17e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了Promise.allSettled，我们可以创建一个新的承诺，只有当传递给你的所有承诺都完成时，它才会回来。因此，它将为我们提供一个矩阵，其中包含每个承诺的数据。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a524" class="mf mg iq ne b gy ni nj l nk nl">const promiseOne = new Promise((resolve, reject) =&gt;  <br/>                       setTimeout(resolve, 3000));</span><span id="a018" class="mf mg iq ne b gy nm nj l nk nl">const promiseTwo = new Promise((resolve, reject) =&gt; <br/>                       setTimeout(reject, 3000));</span><span id="292f" class="mf mg iq ne b gy nm nj l nk nl">Promise.allSettled([promiseOne, promiseTwo]).then(data =&gt; console.log(data));<br/>Promise {&lt;pending&gt;}</span><span id="0da0" class="mf mg iq ne b gy nm nj l nk nl">//(2) [{…}, {…}]<br/>//0: {status: "fulfilled", value: undefined}<br/>//1: {status: "rejected", reason: undefined}<br/>//length: 2</span></pre><h2 id="9ded" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">字符串.原型.匹配</h2><p id="bf91" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">给定一个字符串和一个正则表达式，matchAll()方法返回一个迭代器，该迭代器包含与一个字符串匹配的所有结果和正则表达式，包括<a class="ae nn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges" rel="noopener ugc nofollow" target="_blank">捕获组</a>。</p><p id="a8d7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">语法:str.matchAll(regexp)</p><ul class=""><li id="44b2" class="lr ls iq kx b ky kz lb lc le lt li lu lm lv lq lw lx ly lz bi translated">regexp:正则表达式对象。</li><li id="90a2" class="lr ls iq kx b ky ma lb mb le mc li md lm me lq lw lx ly lz bi translated">返回值:一个<a class="ae nn" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noopener ugc nofollow" target="_blank">迭代器</a>(不是可重启的可迭代)。</li></ul><p id="821b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用带有全局/g标志的<strong class="kx ir"> match() </strong>时，捕获组被忽略:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="6c95" class="mf mg iq ne b gy ni nj l nk nl">const regexp = /g(ro)(up(\d?))/g;</span><span id="d7aa" class="mf mg iq ne b gy nm nj l nk nl">const groups = 'group1group2group3';</span><span id="2338" class="mf mg iq ne b gy nm nj l nk nl">groups.<strong class="ne ir">match</strong>(regexp);</span><span id="7b15" class="mf mg iq ne b gy nm nj l nk nl">//(3) ["group1", "group2", "group3"]<br/>//0: "group1"<br/>//1: "group2"<br/>//2: "group3"</span></pre><p id="c48a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<strong class="kx ir"> matchAll </strong>，您可以访问捕获组:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="b8ae" class="mf mg iq ne b gy ni nj l nk nl">const regexp = /g(ro)(up(\d?))/g;</span><span id="3584" class="mf mg iq ne b gy nm nj l nk nl">const someString = 'group1group2group3';</span><span id="9af0" class="mf mg iq ne b gy nm nj l nk nl">const array = [...someString.<strong class="ne ir">matchAll</strong>(regexp)];</span><span id="6536" class="mf mg iq ne b gy nm nj l nk nl">array<br/>//(3) [Array(4), Array(4), Array(4)]<br/>//0: (4) ["group1", "ro", "up1", "1", index: 0, input: //"group1group2group3", groups: undefined]</span><span id="1078" class="mf mg iq ne b gy nm nj l nk nl">//1: (4) ["group2", "ro", "up2", "2", index: 6, input: //"group1group2group3", groups: undefined]</span><span id="692c" class="mf mg iq ne b gy nm nj l nk nl">//2: (4) ["group3", "ro", "up3", "3", index: 12, input: //"group1group2group3", groups: undefined]</span><span id="3106" class="mf mg iq ne b gy nm nj l nk nl">//length: 3</span></pre><h2 id="4078" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">可选链接运算符</h2><p id="cd32" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">长的属性访问链很容易出错，在每一步检查属性的存在变成了一个深度嵌套的结构。</p><p id="de0c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一个简单汽车对象的例子:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="c887" class="mf mg iq ne b gy ni nj l nk nl">let car = {<br/>  engine : {<br/>    consumption: 10<br/>  }<br/>}</span></pre><p id="0579" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设我们想获得消费。我们可以这样做:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="3a74" class="mf mg iq ne b gy ni nj l nk nl">let consumption = car.engine.consumption<br/>//console.log(consumption)<br/>//10 Ok, no problem here.</span></pre><p id="c10c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是如果引擎是空的会怎么样呢？如果我们试图访问消费，我们将获得一个错误。所以，我们要先查一下物业。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="1a96" class="mf mg iq ne b gy ni nj l nk nl">let car = {<br/>}<br/>car.engine.consumption;</span><span id="7aee" class="mf mg iq ne b gy nm nj l nk nl">//Uncaught TypeError: Cannot read property 'consumption' of  <br/>//undefined</span><span id="de4f" class="mf mg iq ne b gy nm nj l nk nl">//Before ES2020</span><span id="61f7" class="mf mg iq ne b gy nm nj l nk nl">//Check if exists<br/>let consumption = car.engine ? car.engine.consumption : undefined<br/>//console.log(consumption )<br/>//undefined</span><span id="4df2" class="mf mg iq ne b gy nm nj l nk nl">/////or/////</span><span id="047e" class="mf mg iq ne b gy nm nj l nk nl">let car = {<br/>}</span><span id="e2fa" class="mf mg iq ne b gy nm nj l nk nl">//Check if exists<br/>let consumption;<br/>if(car.engine &amp;&amp; car.engine.consumption){<br/>  let consumption = cat.engine.consumption<br/>}else{<br/>  let consumption = undefined<br/>}</span><span id="2e5e" class="mf mg iq ne b gy nm nj l nk nl">console.log(consumption)<br/>//undefined</span></pre><p id="621b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是可行的，但这样做是很清楚的:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="5b53" class="mf mg iq ne b gy ni nj l nk nl">let car = {<br/>}</span><span id="1184" class="mf mg iq ne b gy nm nj l nk nl">let consumption = car.engine?.consumption</span><span id="fc4c" class="mf mg iq ne b gy nm nj l nk nl">console.log(consumption);<br/>//undefined</span></pre><p id="8ef4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你也可以链可选链:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="0e2a" class="mf mg iq ne b gy ni nj l nk nl">let car = null;<br/>let consumption = car?.engine?.consumption<br/>console.log(consumption);</span></pre><p id="73b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如，可选的链接作用于数组或函数调用。</p><p id="c488" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">设array = null</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="093c" class="mf mg iq ne b gy ni nj l nk nl">//This makes sure that array exists before trying to access the //first element.<br/>let car1 = array?.[1];</span></pre><p id="bccf" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是一个可选的链接操作符，简单而且非常有用！</p><h2 id="4039" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">动态导入</h2><p id="940b" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">动态导入()引入了一种新的类似函数的导入形式，与静态导入相比，它释放了新的功能，例如，我们可以在延迟加载中使用它。</p><p id="be70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">请考虑位于的以下内容。/greetingsModule.js:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="ea74" class="mf mg iq ne b gy ni nj l nk nl">//greetingsModule.js</span><span id="08e7" class="mf mg iq ne b gy nm nj l nk nl">export hello () =&gt; console.log("Hello World!");</span></pre><p id="cf17" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里我们静态导入并使用。/greetings模块. js模块:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="6b66" class="mf mg iq ne b gy ni nj l nk nl">//main.js</span><span id="4c85" class="mf mg iq ne b gy nm nj l nk nl">import * as greet from './ greetingsModule.js’;</span><span id="dee6" class="mf mg iq ne b gy nm nj l nk nl">greet.hello();<br/>//Hello World!</span></pre><p id="67a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">静态导入语法只能在文件的顶层使用。</p><p id="a17e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">相反，使用动态导入，<strong class="kx ir"> import(module </strong>)表达式加载模块并返回一个承诺，该承诺解析为包含其所有导出的模块对象。<strong class="kx ir">同样，你可以在代码</strong>的任何地方调用它。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="1882" class="mf mg iq ne b gy ni nj l nk nl">...</span><span id="bd50" class="mf mg iq ne b gy nm nj l nk nl">if( 1 === 1){</span><span id="6d4a" class="mf mg iq ne b gy nm nj l nk nl"><strong class="ne ir">import(’./greetingsModule.js’).then( (greet) =&gt; {<br/>             greet.hello();<br/>            // Hello World!<br/>         });<br/>}</strong></span><span id="4e0a" class="mf mg iq ne b gy nm nj l nk nl">...</span></pre><p id="d1ac" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">或者您可以使用async/await:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="3cd1" class="mf mg iq ne b gy ni nj l nk nl">...</span><span id="617b" class="mf mg iq ne b gy nm nj l nk nl">async function load() {<br/>    let greet = await import(’./greetingsModule.js’);<br/>    greet.hello(); <br/>    // Hello!<br/>  }</span><span id="1c85" class="mf mg iq ne b gy nm nj l nk nl">...</span></pre><p id="283a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">静态导入和动态导入()都很有用。每一种都有其使用案例。使用静态导入，例如，对于初始依赖关系。在其他情况下，考虑使用动态导入特性按需加载依赖项。</p><h2 id="2d98" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">BigInt</h2><p id="2d68" class="pw-post-body-paragraph kv kw iq kx b ky my jr la lb mz ju ld le na lg lh li nb lk ll lm nc lo lp lq ij bi translated">BigInt是一个新的内置对象，它提供了一种表示大于2^(53的整数的方法)–1。JavaScripts Number对固定范围的数字有严格的限制，不能正确处理大整数。BigInt的新特性解决了这个问题，这个问题在处理重要值的不同领域可能是一个相当大的问题。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a66b" class="mf mg iq ne b gy ni nj l nk nl">console.log(Number.MAX_SAFE_INTEGER);<br/>//9007199254740991</span><span id="665e" class="mf mg iq ne b gy nm nj l nk nl">const max = Number.MAX_SAFE_INTEGER;</span><span id="bac1" class="mf mg iq ne b gy nm nj l nk nl">console.log(max +1);<br/>//9007199254740992  -&gt; Correct value!</span><span id="c070" class="mf mg iq ne b gy nm nj l nk nl">console.log(max +10);<br/>//900719925474<strong class="ne ir">1000  </strong>-&gt; <strong class="ne ir">Incorrect value</strong>! (1001)</span></pre><p id="beb0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以用新的BigInt数据类型来解决这个问题。<strong class="kx ir">在数字末尾加上字母‘n’</strong>:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="28d7" class="mf mg iq ne b gy ni nj l nk nl">const myBigNumber = 9007199254740991n;</span><span id="78ba" class="mf mg iq ne b gy nm nj l nk nl">console.log(myBigNumber +1n);<br/>//9007199254740992n  -&gt; Correct value!</span><span id="339f" class="mf mg iq ne b gy nm nj l nk nl">console.log(myBigNumber +10n);<br/>//900719925474<strong class="ne ir">1001</strong>n  -&gt; <strong class="ne ir">Correct value!</strong></span><span id="b478" class="mf mg iq ne b gy nm nj l nk nl">//Note:</span><span id="e967" class="mf mg iq ne b gy nm nj l nk nl">console.log(myBigNumber +10);</span><span id="8c16" class="mf mg iq ne b gy nm nj l nk nl">//Error: you cannot mix BigInt and other types, use explicit //conversions.</span><span id="9ee4" class="mf mg iq ne b gy nm nj l nk nl">//Correct way: You have to add the letter 'n' on the end of the //number</span></pre><p id="2d77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">更多尽在<a class="ae nn" href="https://medium.com/javascript-in-plain-english/javascript-es2019-es10-in-a-nutshell-cae6f7524519" rel="noopener"><strong class="kx ir">es 2019(ES10)</strong></a>中的JavaScript新特性</p><h2 id="1b07" class="mf mg iq bd mh mi mj dn mk ml mm dp mn le mo mp mq li mr ms mt lm mu mv mw mx bi translated">非常感谢你阅读我！保重！</h2></div></div>    
</body>
</html>