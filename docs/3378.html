<html>
<head>
<title>Two ways to visit every node in a web page using JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用JavaScript访问网页中每个节点的两种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/walking-the-dom-7a1123fb67da?source=collection_archive---------3-----------------------#2020-09-24">https://javascript.plainenglish.io/walking-the-dom-7a1123fb67da?source=collection_archive---------3-----------------------#2020-09-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="48b0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">漫步大教堂</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/b9bf90fc6ad2308162ee89064147c72f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_0sIRmxKp6rejvgu"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@frostroomhead?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rodion Kutsaev</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c09d" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">介绍</h1><p id="bae7" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">文档对象模型(DOM)是HTML文档的分层表示，可用于浏览器中运行的JavaScript。DOM将网页描述为节点树，节点树本身可以包含其他节点。文档的<code class="fe mk ml mm mn b">html</code>节点包含一个<code class="fe mk ml mm mn b">head</code>节点和一个<code class="fe mk ml mm mn b">body</code>。反过来，每个都包含自己的一组节点，依此类推。</p><p id="5be9" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">对这种结构的有用操作包括按顺序访问每个节点。例如，为了对页面使用的HTML元素进行分类，我们可以依次访问每个节点，跟踪我们遇到的元素。</p><p id="4239" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">在本文中，我将介绍两种解决这个一般性问题的方法。它们都使用了<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Node" rel="noopener ugc nofollow" target="_blank"> DOM节点接口</a>的以下属性:</p><ul class=""><li id="64e5" class="mt mu iq lq b lr mo lu mp lx mv mb mw mf mx mj my mz na nb bi translated"><code class="fe mk ml mm mn b">firstChild</code></li><li id="e40a" class="mt mu iq lq b lr nc lu nd lx ne mb nf mf ng mj my mz na nb bi translated"><code class="fe mk ml mm mn b">nextSibling</code></li></ul><p id="eaf9" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">此外，出于将被阐明的原因，第二种方法利用了附加的属性:</p><ul class=""><li id="8abf" class="mt mu iq lq b lr mo lu mp lx mv mb mw mf mx mj my mz na nb bi translated"><code class="fe mk ml mm mn b">parentNode</code></li></ul><p id="5c10" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">这两个示例都将利用回调函数，该函数将被视为占位符，用于处理您可能实际想要在每个节点上执行的任何工作。</p><h1 id="81e5" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">递归的</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/af0a161fd70a085081033ce530e0c772.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4cSTYiEVE9_NLU_A"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@seimesa?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mario Mesaglio</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f3f7" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">我首先介绍递归方法，因为尽管从一般意义上来说这是一种不太为人所知的技术，但是在遍历DOM时，它通常是默认的。</p><h2 id="8834" class="ni kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">一般递归</h2><p id="aed1" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">递归是计算机编程中的一个重要概念，可以开玩笑地定义为“参见:递归”。它指的是函数调用自身的行为，如下面计算数字阶乘的函数:</p><pre class="kg kh ki kj gt nu mn nv nw aw nx bi"><span id="55bb" class="ni kx iq mn b gy ny nz l oa ob">function <strong class="mn ir">factorial</strong>(n) {<br/>    if (n == 0) return 1; else return n * <strong class="mn ir">factorial</strong>(n - 1);<br/>}</span></pre><p id="6f9e" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">这种函数通过有效地将它们的问题简化为平凡的基本情况来工作。在上面的例子中，基础案例是<code class="fe mk ml mm mn b">n == 0</code>；0的阶乘是1。如果您对一个示例值执行这个函数(2是最快和最有用的！)，它的工作原理很快就变得显而易见了。事实上，<em class="oc">递归揭示了它本身固有于‘阶乘’本身的定义中</em>，尽管也可以应用迭代方法。</p><h2 id="8c97" class="ni kx iq bd ky nj nk dn lc nl nm dp lg lx nn no li mb np nq lk mf nr ns lm nt bi translated">递归和DOM</h2><p id="1da2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">对于DOM，我们可以利用它的层次结构来应用递归方法。基本上，访问一个节点意味着应用我们的回调函数(做我们感兴趣的任何实际工作)，然后访问节点的第一个子节点(如果它有一个子节点)，然后访问节点的下一个兄弟节点(如果它有一个子节点)。</p><pre class="kg kh ki kj gt nu mn nv nw aw nx bi"><span id="009f" class="ni kx iq mn b gy ny nz l oa ob">function <strong class="mn ir">visit_nodes_recursive</strong>(callback, node) {<br/>    node = node || document;<br/>    callback.call(null, node);</span><span id="333c" class="ni kx iq mn b gy od nz l oa ob">    if (node.firstChild)<br/>        <strong class="mn ir">visit_nodes_recursive</strong>(callback, node.firstChild);</span><span id="a8e5" class="ni kx iq mn b gy od nz l oa ob">    if (node.nextSibling)<br/>        <strong class="mn ir">visit_nodes_recursive</strong>(callback, node.nextSibling);<br/>}</span></pre><p id="3f7a" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">递归调用<strong class="lq ir">以粗体</strong>突出显示。用技术术语来说，这是一种<a class="ae kv" href="https://en.wikipedia.org/wiki/Depth-first_search" rel="noopener ugc nofollow" target="_blank">深度优先搜索</a>；实际上，这意味着我们的文档的节点是按照它们在文档的HTML源代码中出现的顺序被访问的。</p><h1 id="6516" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">重复的</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/f85e69e63705a6547b0a20da353debb0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*sEjqTmZLpfuQg3d7"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brett Jordan</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="eb0d" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">程序员通常更熟悉迭代方法，因为它指的是执行一组指令的更明显的方式:我们重复一个过程直到完成。下面是节点访问函数的迭代版本:</p><pre class="kg kh ki kj gt nu mn nv nw aw nx bi"><span id="d94e" class="ni kx iq mn b gy ny nz l oa ob">function visit_nodes_iterative(callback, node) {<br/>    node = node || document;</span><span id="f13a" class="ni kx iq mn b gy od nz l oa ob">    do {<br/>        callback.call(null, node);</span><span id="bcd8" class="ni kx iq mn b gy od nz l oa ob">        <strong class="mn ir">node = node.firstChild || node.nextSibling || function() {<br/>            while ((node = node.parentNode) &amp;&amp; !node.nextSibling);<br/>            return node ? node.nextSibling : null;<br/>        }();</strong><br/>    } while (node);<br/>}</span></pre><p id="76af" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">首先要注意的是，虽然两个版本的长度大致相同，但迭代方法更加复杂。如前所述，递归函数的一个主要优点是它通常可以降低复杂性。</p><p id="327d" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">这里所有的复杂性都在于用粗体字突出显示的部分<strong class="lq ir">，该部分每次都围绕主<code class="fe mk ml mm mn b">do ... while</code>循环推进“当前”节点。同样，使用深度优先的搜索顺序，这与递归方法非常相似:</strong></p><pre class="kg kh ki kj gt nu mn nv nw aw nx bi"><span id="8c91" class="ni kx iq mn b gy ny nz l oa ob">node = node.firstChild ||</span></pre><p id="4aed" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">如果当前节点有子节点，则移动到第一个子节点，否则:</p><pre class="kg kh ki kj gt nu mn nv nw aw nx bi"><span id="695e" class="ni kx iq mn b gy ny nz l oa ob">node.nextSibling ||</span></pre><p id="9744" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">移动到节点的下一个同级，如果它有一个同级的话。但是，如果它既没有子节点也没有兄弟节点，它实际上就是一个“死胡同”，有时被称为“叶”节点，与更广泛的“树”类比中的“分支”节点形成对比。</p><p id="916c" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">在这种情况下，我们需要“后退”并返回到我们<em class="oc">仍能</em>继续“前进”的节点。这是匿名函数调用执行的工作:</p><pre class="kg kh ki kj gt nu mn nv nw aw nx bi"><span id="c758" class="ni kx iq mn b gy ny nz l oa ob">function() {<br/>    while ((node = node.parentNode) &amp;&amp; !node.nextSibling);<br/>    return node ? node.nextSibling : null;<br/>}();</span></pre><p id="0cf9" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">在单行的<code class="fe mk ml mm mn b">while</code>循环中，当前节点向上移动到它自己的父节点，但是一旦新节点有了兄弟节点(或者根本没有父节点，我们又回到了文档的最顶端)，循环就会终止。值得注意的是，我们只看兄弟姐妹，不看孩子，因为<em class="oc">我们已经在从孩子到父母的方向上旅行了</em>。一旦“回溯”完成，这个匿名函数要么返回它成功找到的下一个兄弟节点，要么返回一个<code class="fe mk ml mm mn b">null</code>值来指示<em class="oc">没有</em>合适的节点可以继续——也就是说，我们已经到了文档的末尾。</p><p id="c916" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">同样，如果这不清楚，请尝试用一个示例HTML文件手动跟踪它:从文档级开始(它包含一个表示<code class="fe mk ml mm mn b">html</code>元素的节点)，然后跟踪<code class="fe mk ml mm mn b">node</code>如何被设置到<code class="fe mk ml mm mn b">head</code>元素，然后是它的每个子元素，最后返回到<code class="fe mk ml mm mn b">body</code>元素，依此类推。</p><h1 id="cc41" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">标杆管理</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/36d6b282eccb1d029c7fc9cb913a03e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*K_sm-a2cgW8bC0X4"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@marcojodoin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Marc-Olivier Jodoin</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8ce8" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">每种方法都执行相同的工作量——访问DOM中的每个节点——但是有一种方法更容易理解:这是递归的一大胜利。然而，哪种方法是<em class="oc">更快</em>？为了解决这个问题，我们可以试着对问题进行推理，但是从测量一些结果开始更容易。</p><p id="c29e" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">使用<a class="ae kv" href="https://benchmarkjs.com/" rel="noopener ugc nofollow" target="_blank">基准库</a>，我对一个简单文档的每个功能进行了测试，结果如下:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/9f718310e838022fb4c8d400b74feeac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PbYiNsVKnjt1xCzgU2U7wg.png"/></div></div></figure><p id="eba8" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">换句话说，迭代函数以每秒23.4万次运算的速度执行，而递归函数处理了17.4万次。迭代函数速度更快，但幅度不大。</p><h1 id="3569" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">结论</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/e1b89fc6b0ec56961b1545783e7002c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*YKh-4smhtBwfW67j"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f3d5" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">理解迭代和递归方法之间的区别是很重要的，特别是每一种方法做得最好。递归通常更直接，也更容易使用；如果其他人可能会阅读我们编写的代码，那么使用它似乎是一种好的方式！另一方面，迭代可能要复杂得多，因为它必须跟踪递归代表我们管理的状态。</p><p id="480f" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">然而，管理函数调用栈及其相关状态是有代价的，递归通常比迭代慢——但不一定慢很多。与以往一样，测试我们的代码以了解这些差异有多显著是很重要的，同样重要的是要认识到何时优化速度不是一个需求。</p><p id="b3f7" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated">最后，DOM是为每一种方法精心设计的。<code class="fe mk ml mm mn b">firstNode</code>和<code class="fe mk ml mm mn b">nextSibling</code>属性是我们遍历DOM所需要的全部，即使看起来我们在某个时候需要一个所有孩子的列表(碰巧的是，<em class="oc">也是</em>可用的！)</p><p id="1b1a" class="pw-post-body-paragraph lo lp iq lq b lr mo jr lt lu mp ju lw lx mq lz ma mb mr md me mf ms mh mi mj ij bi translated"><em class="oc">这里展示的所有代码都可以在</em> <a class="ae kv" href="https://github.com/bobbykjack/walking-the-dom" rel="noopener ugc nofollow" target="_blank"> <em class="oc">的github资源库</em> </a>中找到。</p></div></div>    
</body>
</html>