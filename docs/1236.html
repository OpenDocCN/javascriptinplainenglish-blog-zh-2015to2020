<html>
<head>
<title>More Rxjs Transformation Operators — Group and Map</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更多Rxjs变换运算符-分组和地图</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/more-rxjs-transformation-operators-group-and-map-7a2a8b5fb08?source=collection_archive---------2-----------------------#2020-02-16">https://javascript.plainenglish.io/more-rxjs-transformation-operators-group-and-map-7a2a8b5fb08?source=collection_archive---------2-----------------------#2020-02-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/150efd175f2b7b93cb2e30f8f06fb7ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*E38Rc4aTsXJMY3eD"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rayhennessy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ray Hennessy</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d24a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rxjs是一个用于进行反应式编程的库。创建操作符对于从各种数据源生成供观察者订阅的数据非常有用。</p><p id="1fde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看一些转换操作符，如<code class="fe lb lc ld le b">groupBy</code>、<code class="fe lb lc ld le b">map</code>、<code class="fe lb lc ld le b">mapTo</code>和<code class="fe lb lc ld le b">mergeMap</code>。</p><h1 id="be35" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">分组依据</h1><p id="e662" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">groupBy</code>操作符获取源观测值发出的值，然后根据我们为它们设置的标准对它们进行分组。</p><p id="8baf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要4个参数。第一个是<code class="fe lb lc ld le b">keySelector</code>，这是一个为每个项目提取密钥的函数。</p><p id="229c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是<code class="fe lb lc ld le b">elementSelector</code>的可选参数，这是一个为每个项目提取返回元素的函数。</p><p id="989e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三个参数是<code class="fe lb lc ld le b">durationSelector</code>，这是一个可选函数，返回一个可观察值来确定每个组应该存在多长时间。</p><p id="ab7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，最后一个参数是<code class="fe lb lc ld le b">subjectSelector</code>，它是一个可选函数，返回一个主题。</p><p id="d332" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f777" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { groupBy, reduce, mergeMap } from "rxjs/operators";</span><span id="b673" class="mq lg iq le b gy mv ms l mt mu">const observable = of(<br/>  { id: 1, name: "John" },<br/>  { id: 2, name: "Jane" },<br/>  { id: 2, name: "Mary" },<br/>  { id: 1, name: "Joe" },<br/>  { id: 3, name: "Don" }<br/>).pipe(<br/>  groupBy(p =&gt; p.id),<br/>  mergeMap(group$ =&gt; group$.pipe(reduce((acc, cur) =&gt; [...acc, cur], [])))<br/>);</span><span id="98da" class="mq lg iq le b gy mv ms l mt mu">observable.subscribe(val =&gt; console.log(val));</span></pre><p id="3f26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们调用了<code class="fe lb lc ld le b"> groupBy(p =&gt; p.id)</code>来对从<code class="fe lb lc ld le b">of</code>发出的可被<code class="fe lb lc ld le b">id</code>观察到的项目进行分组。</p><p id="97bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们有:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7434" class="mq lg iq le b gy mr ms l mt mu">mergeMap(group$ =&gt; group$.pipe(reduce((acc, cur) =&gt; [...acc, cur], [])))</span></pre><p id="2a7f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将分组的项目放在一起，由一个可观测的物体发射。</p><h1 id="5fe2" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">地图</h1><p id="4419" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">map</code>操作符让我们将源可观察对象发出的值映射到其他值，并将结果值作为可观察对象发出。</p><p id="09dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它最多需要两个参数。第一个参数是<code class="fe lb lc ld le b">project</code>函数，这是必需的。该函数获取源可观测值的发射值及其索引，然后通过操作这些返回我们想要的结果。</p><p id="6c02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是可选的。它是<code class="fe lb lc ld le b">thisArg</code>，用于为第一个参数中的<code class="fe lb lc ld le b">project</code>函数定义<code class="fe lb lc ld le b">this</code>值。</p><p id="a3fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3ce0" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { map } from "rxjs/operators";</span><span id="5f96" class="mq lg iq le b gy mv ms l mt mu">const observable = of(1, 2, 3);<br/>const newObservable = observable.pipe(map(val =&gt; val ** 2));<br/>newObservable.subscribe(x =&gt; console.log(x));</span></pre><p id="dc0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码从<code class="fe lb lc ld le b">observable</code>获取发出的值，然后通过<code class="fe lb lc ld le b">pipe</code>操作符将其传递给<code class="fe lb lc ld le b">map</code>操作符。在回调中，我们传入了<code class="fe lb lc ld le b">map</code>操作符，我们对最初发出的值取2的幂。</p><p id="c2b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以订阅一个发出新值的可观察对象，我们得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7f04" class="mq lg iq le b gy mr ms l mt mu">1<br/>4<br/>9</span></pre><p id="99d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记录在案。</p><h1 id="50de" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">地图</h1><p id="4fad" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">mapTo</code>算子为任何源可观测的发射值发射给定的常数值。</p><p id="dd7a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要一个参数，即要发出的值。</p><p id="8b72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="fd94" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { mapTo } from "rxjs/operators";</span><span id="27be" class="mq lg iq le b gy mv ms l mt mu">const observable = of(1, 2, 3);<br/>const newObservable = observable.pipe(mapTo("foo"));<br/>newObservable.subscribe(x =&gt; console.log(x));</span></pre><p id="bb6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将所有值从<code class="fe lb lc ld le b">observable</code>映射到值<code class="fe lb lc ld le b">'foo'</code>，所以我们得到了<code class="fe lb lc ld le b">'foo'</code> 3次，而不是1、2和3次。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/3ff0898beb0be64a943bc8646c2e1fe9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vlA_zZKwn40qBLIT"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@thejoshhoward?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Josh Howard</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="bcc7" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">合并地图</h1><p id="780a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">mergeMap</code>操作符从一个源可观察对象获取值，然后让我们将它与另一个可观察对象的值结合起来。</p><p id="7cac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最多需要3个参数。第一个是一个<code class="fe lb lc ld le b">project</code>函数，用于投射值并返回一个新的可观察值。</p><p id="13b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是一个可选参数，它带有一个<code class="fe lb lc ld le b">resultSelector</code>。我们可以传入一个函数来选择从结果中发出的值。</p><p id="feb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三个参数是<code class="fe lb lc ld le b">concurrency</code>，这是一个可选参数，指定并发订阅的输入可观察值的最大数量。默认是<code class="fe lb lc ld le b">Number.POSITIVE_INFINITY</code>。</p><p id="34d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="5ab5" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { mergeMap, map } from "rxjs/operators";</span><span id="0e52" class="mq lg iq le b gy mv ms l mt mu">const nums = of(1, 2, 3);<br/>const result = nums.pipe(mergeMap(x =&gt; of(4, 5, 6).pipe(map(i =&gt; x + i))));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="c387" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将从从<code class="fe lb lc ld le b">nums</code>可观察对象发出的3个值中获取值，然后通过<code class="fe lb lc ld le b">pipe</code>操作符将这些值传递给<code class="fe lb lc ld le b">mergeMap</code>的回调函数。<code class="fe lb lc ld le b">x</code>将具有来自<code class="fe lb lc ld le b">nums</code>的值。</p><p id="4fb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在回调中，我们有了<code class="fe lb lc ld le b">of(4, 5, 6)</code>可观察值，这些值来自<code class="fe lb lc ld le b">nums</code>可观察值的组合。<code class="fe lb lc ld le b">i</code>具有来自<code class="fe lb lc ld le b">of(4, 5, 6)</code>的可观测值，因此我们将来自两个可观测值相加。我们得到1 + 4，1 + 5，1 + 6，2 + 4，2 + 5，2 + 6等等。</p><p id="d65f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终，我们应该得到以下输出:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a58f" class="mq lg iq le b gy mr ms l mt mu">5<br/>6<br/>7<br/>6<br/>7<br/>8<br/>7<br/>8<br/>9</span></pre><p id="8512" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">groupBy</code>操作符获取由源可观测值发出的值，然后根据我们为它们设置的标准对它们进行分组。我们可以将它与<code class="fe lb lc ld le b">mergeMap</code>结合使用，将由<code class="fe lb lc ld le b">groupBy</code>操作符分组的结果组合成一个可观察的结果。</p><p id="db7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">map</code>操作符让我们将源可观测值发出的值映射到其他值，并将结果值作为可观测值发出。</p><p id="3ddb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">mapTo</code>算子为任何源可观测的发射值发射给定的常数值。</p><p id="2436" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后,<code class="fe lb lc ld le b">mergeMap</code>运算符从一个源可观测值中提取值，然后让我们将其与另一个可观测值相结合。然后我们得到一个可观测值，两个可观测值结合在一起。</p></div></div>    
</body>
</html>