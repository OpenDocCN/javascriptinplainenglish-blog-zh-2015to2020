<html>
<head>
<title>Best Features of ES2018 — New Regex Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2018的最佳功能—新的正则表达式功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-features-of-es2018-new-regex-features-a79d04416af3?source=collection_archive---------6-----------------------#2020-10-01">https://javascript.plainenglish.io/best-features-of-es2018-new-regex-features-a79d04416af3?source=collection_archive---------6-----------------------#2020-10-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d88176dc28caf6944de50aa3f397fbfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tbkOmZ1tbgQy0a8g"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@shttefan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">SHTTEFAN</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ad57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解ES2018的最佳特性。</p><h1 id="ef86" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Regex属性转义</h1><p id="479c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Unicode有属性，这些属性是描述它的元数据。</p><p id="431b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有像<code class="fe me mf mg mh b">Lowercase_Letter</code>描述小写字母、<code class="fe me mf mg mh b">White_space</code>描述空格等属性。</p><p id="2c99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几种类型的属性。</p><p id="80c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">枚举属性是一个属性值，它的值很少，并且被命名。</p><p id="ccdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">General_Category</code>是一个枚举属性。</p><p id="aab1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关闭枚举属性ios集合值固定的枚举属性。</p><p id="6680" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">布尔属性是值为<code class="fe me mf mg mh b">true</code>或<code class="fe me mf mg mh b">false</code>的封闭枚举属性。</p><p id="bdcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数值属性的值是实数。</p><p id="c652" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">字符串值属性是其值为字符串的属性。</p><p id="3dd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">目录属性是一个枚举属性，可以随着Unicode的变化而扩展。</p><p id="d103" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">杂项属性是其值不是上述任何一个值的属性。</p><p id="198a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有各种匹配属性和属性值。</p><p id="5363" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性是松散匹配的，所以<code class="fe me mf mg mh b">General_Category</code>被认为和<code class="fe me mf mg mh b">GeneralCategory</code>以及其他变体一样。</p><h1 id="106b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">正则表达式的Unicode属性转义</h1><p id="1a42" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">\p</code>字符对Unicode属性进行转义。</p><p id="4ea6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这必须与<code class="fe me mf mg mh b">/u</code>标志一起使用，以启用Unicode模式。</p><p id="e5cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">\p</code>与没有Unicode模式的<code class="fe me mf mg mh b">p</code>相同。</p><p id="48d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3660" class="mq lc iq mh b gy mr ms l mt mu">const result = /^\p{White_Space}+$/u.test(' ')</span></pre><p id="24c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe me mf mg mh b">result</code>将会是<code class="fe me mf mg mh b">true</code>。</p><p id="97a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着<code class="fe me mf mg mh b">\p{White_Space}</code>匹配空白。</p><p id="fe1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这比常规的正则表达式模式更具描述性。</p><p id="d035" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="74fd" class="mq lc iq mh b gy mr ms l mt mu">const result = /^\p{Letter}+$/u.test('abc')</span></pre><p id="b0cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来匹配字母。</p><p id="a032" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了匹配希腊字母，我们写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1f6a" class="mq lc iq mh b gy mr ms l mt mu">const result = /^\p{Script=Greek}+$/u.test('μ')</span></pre><p id="e153" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将拉丁字母与:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="91a3" class="mq lc iq mh b gy mr ms l mt mu">const result = /^\p{Script=Latin}+$/u.test('ç')</span></pre><p id="007f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也可以匹配长代理字符:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bd18" class="mq lc iq mh b gy mr ms l mt mu">const result = /^\p{Surrogate}+$/u.test('\u{D83D}')</span></pre><h1 id="605f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">回顾断言</h1><p id="3d03" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">后视断言是正则表达式中的一个构造，它指定当前位置的周围环境应该是什么样子。</p><p id="4455" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e90e" class="mq lc iq mh b gy mr ms l mt mu">const RE_DOLLAR_PREFIX = /(?&lt;=\$)\d+/g;</span><span id="b5d4" class="mq lc iq mh b gy mv ms l mt mu">const result = '$123'.replace(RE_DOLLAR_PREFIX, '456');</span></pre><p id="3c8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe me mf mg mh b">(?&lt;=\$)</code>组来寻找前面有美元符号的数字。</p><p id="c5af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们调用<code class="fe me mf mg mh b">replace</code>替换号码时，我们只是替换号码。</p><p id="ce01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用那个正则表达式搜索带有<code class="fe me mf mg mh b">$</code>和其后数字的东西。</p><p id="e848" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe me mf mg mh b">result</code>就是<code class="fe me mf mg mh b">'$456'</code>。</p><p id="3339" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果前缀应该是先前匹配的一部分，则这不起作用。</p><p id="6393" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以添加一个<code class="fe me mf mg mh b">!</code>来添加一个负的后视断言。,</p><p id="fbc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f43e" class="mq lc iq mh b gy mr ms l mt mu">const RE_DOLLAR_PREFIX = /(?&lt;!\$)baz/g;</span><span id="49a7" class="mq lc iq mh b gy mv ms l mt mu">const result = '&amp;baz'.replace(RE_DOLLAR_PREFIX, 'qux');</span></pre><p id="ab81" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正则表达式查找前面没有美元符号的<code class="fe me mf mg mh b">baz</code>。</p><p id="6424" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们像以前那样调用了<code class="fe me mf mg mh b">replace</code>,我们会返回<code class="fe me mf mg mh b">'&amp;qux’</code>,因为<code class="fe me mf mg mh b">$</code>不在字符串中。</p><h1 id="b81c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe me mf mg mh b">s</code>(<code class="fe me mf mg mh b">dotAll</code>)Regex标志</h1><p id="cbf2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">dotAll dlag是regex中的<code class="fe me mf mg mh b">.</code>标志的一个实例。</p><p id="c673" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正则表达式中的<code class="fe me mf mg mh b">.</code>与行结束符不匹配。</p><p id="ab54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6fe7" class="mq lc iq mh b gy mr ms l mt mu">/^.$/.test('\n')</span></pre><p id="0c13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe me mf mg mh b">false</code>。</p><p id="e822" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了匹配行结束符，我们必须:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e004" class="mq lc iq mh b gy mr ms l mt mu">/^[^]$/.test('\n')</span></pre><p id="f9ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">匹配除无字符或以下字符以外的所有内容:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="63ce" class="mq lc iq mh b gy mr ms l mt mu">/^[\s\S]$/.test('\n')</span></pre><p id="1c5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">匹配空格或非空格。</p><p id="5414" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有各种各样的行结束字符。</p><p id="d096" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们包括:</p><ul class=""><li id="b8b3" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">U+000A换行(左前)(<code class="fe me mf mg mh b">\n</code>)</li><li id="5c12" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">U+000D回车(CR) ( <code class="fe me mf mg mh b">\r</code>)</li><li id="87d5" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">U+2028行分隔符</li><li id="680a" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">U+2029段落分隔符</li></ul><p id="02f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于ES2018，我们可以使用<code class="fe me mf mg mh b">/s</code>标志来匹配以行结束符结尾的内容:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="365f" class="mq lc iq mh b gy mr ms l mt mu">const result = /^.$/s.test('\n')</span></pre><p id="f78e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以<code class="fe me mf mg mh b">result</code>应该是<code class="fe me mf mg mh b">true</code>。</p><p id="e27f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">长名字是<code class="fe me mf mg mh b">dotAll</code>。</p><p id="0fdf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5c50" class="mq lc iq mh b gy mr ms l mt mu">/./s.dotAll</span></pre><p id="a357" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且返回<code class="fe me mf mg mh b">true</code>。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/56b53ddbc317dc9f4877aa1e4368b3fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bIjvfmyDi1Nl4PAP"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@imclyde?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clyde RS</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="9983" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="6f8b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Regex属性转义、lookbehind断言和dotAll标志是JavaScript regexes中新增加的功能，可以匹配各种特殊情况。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nl"><img src="../Images/787be6c671be8d345dc786dad8729ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-sOyyG8NoRbKpCG_y4Cmw@2x.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank">Subscribe to Decoded, our official YouTube channel!</a></figcaption></figure></div></div>    
</body>
</html>