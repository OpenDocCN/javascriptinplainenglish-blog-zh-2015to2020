<html>
<head>
<title>Downloading and Saving binary files using React Native with Expo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React Native with Expo下载和保存二进制文件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/downloading-and-saving-binary-files-using-react-native-with-expo-451b46cb0cc7?source=collection_archive---------0-----------------------#2020-09-04">https://javascript.plainenglish.io/downloading-and-saving-binary-files-using-react-native-with-expo-451b46cb0cc7?source=collection_archive---------0-----------------------#2020-09-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/1892f012d8098f2fce91856163a1df51.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/1*XPh_49PBYqmVCob6qiLJpA.gif"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Printing dialog in my app JiffyCV</figcaption></figure><p id="ecb5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我正在构建的应用程序(JiffyCV) 的一个关键部分是为你已经创建的文档生成一个PDF，但是当实现PDF的保存时，没有太多的文档，所以我打算写一些，希望这可以帮助其他人将这个功能添加到他们的应用程序中。</p><p id="3f56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了在我的应用程序中下载并保存PDF，我必须执行以下流程:</p><ul class=""><li id="573f" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated">使用axios向服务器发出请求</li><li id="74c9" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">使用Buffer将响应数据转换为base64字符串</li><li id="74da" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">获取文件的保存路径</li><li id="ceac" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">将文件写入路径，以便共享</li><li id="8f8a" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">启动设备的共享功能来共享文件</li><li id="b16c" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated">然后，用户可以选择将文件保存到文件系统或在其他地方共享</li></ul><h1 id="4400" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">使用的库</h1><p id="8b8c" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">实现上述流程需要许多库，大多数是普遍需要的，但<code class="fe mo mp mq mr b">axios</code>更多的是个人偏好。</p><p id="32b9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这些库是:</p><ul class=""><li id="b9aa" class="kx ky iq ka b kb kc kf kg kj kz kn la kr lb kv lc ld le lf bi translated"><strong class="ka ir"> axios </strong> —用于向服务器发出请求</li><li id="690e" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> jest-mock-axios </strong> —用于在测试期间模拟服务器响应</li><li id="6cb5" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir">缓冲区</strong> —用于将来自服务器的响应转换为base64字符串</li><li id="5138" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> expo-file-system </strong> —用于在共享文件之前将文件保存到应用程序的文档存储中</li><li id="0544" class="kx ky iq ka b kb lg kf lh kj li kn lj kr lk kv lc ld le lf bi translated"><strong class="ka ir"> expo-sharing </strong> —允许用户将文件共享/保存到设备</li></ul><h1 id="2bb3" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">从服务器获取文件</h1><p id="ee5c" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">我的应用程序使用一个无服务器的功能，通过puppeteer创建一个PDF，然后返回PDF对象。</p><p id="4a11" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">来自无服务器函数的响应是base64编码的，但是我使用的是<code class="fe mo mp mq mr b">axios</code>的<code class="fe mo mp mq mr b">arraybuffer</code> responseType，这意味着我需要使用<code class="fe mo mp mq mr b">buffer</code>将它们转换成base64字符串，我可以用它在本地创建文件。</p><p id="fdd2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是我发现的唯一有效的<code class="fe mo mp mq mr b">axios</code>方法，但是如果你有更好的方法，请留下你的解决方案的评论。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Making the request to the server and returning a base64 string of the response’s data</figcaption></figure><h1 id="6ff1" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">将文件保存到应用程序的文档存储</h1><p id="f1fe" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">一旦我们有了想要保存的PDF的base64字符串，我们需要创建保存文件的路径，并将其保存到应用程序的文档目录中。</p><p id="0b84" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以通过使用来自<code class="fe mo mp mq mr b">expo-file-system</code>的<code class="fe mo mp mq mr b">documentDirectory</code>属性首先获取应用程序的文档目录来获取保存文件的路径。然后你需要添加文件名来保存文件。</p><p id="9f82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">文档目录将有<code class="fe mo mp mq mr b">/</code>后缀，所以没有必要将它包含在您的文件名中，您将需要确保您的文件名是URI编码的，如果不是，您可能会将半个文件名显示给用户。</p><p id="c008" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">获取保存文件的路径后，您可以从<code class="fe mo mp mq mr b">expo-file-system</code>调用<code class="fe mo mp mq mr b">writeAsStringAsync</code>传递文件名，文件的base64表示，当您使用base64时，您需要传递一个选项对象，其<code class="fe mo mp mq mr b">encoding</code>属性设置为<code class="fe mo mp mq mr b">EncodingType.Base64</code>。</p><h2 id="cff0" class="my lm iq bd ln mz na dn lr nb nc dp lv kj nd ne lz kn nf ng md kr nh ni mh nj bi translated">允许用户共享/保存文件</h2><p id="5a2c" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">这个部分相对简单，因为您只需要将应用程序文档库中保存文件的路径传递给<code class="fe mo mp mq mr b">expo-sharing</code>的<code class="fe mo mp mq mr b">shareAsync</code>功能。这将弹出对话框，允许用户将文件保存到他们的设备上，或者通过他们手机上安装的应用程序共享文件。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Saving the file to the app’s document directory and then using that fileUri to allow them to share it</figcaption></figure><h1 id="ad02" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">测试流量</h1><p id="4e86" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">为了测试对带有<code class="fe mo mp mq mr b">axios</code>的服务器的调用，您可以使用<code class="fe mo mp mq mr b">jest-mock-axios</code>库，该库允许断言某个端点被调用，也允许断言响应值。</p><p id="1825" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b">jest-mock-axios</code>拦截服务器响应的方式并不是最优雅的解决方案，因为它需要您在调用axios代码后定义拦截的响应，但是一旦您掌握了流程的窍门，它就可以很好地工作。</p><p id="bcd1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用<code class="fe mo mp mq mr b">jest-mock-axios</code>时，记住每次测试后都要调用<code class="fe mo mp mq mr b">mockAxios.reset()</code>非常重要，就好像你不响应一样，存根不会像预期的那样工作。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">Testing the calls to the server made via axios</figcaption></figure><p id="ac31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦对服务器的调用及其响应被模拟，那么您就需要模拟<code class="fe mo mp mq mr b">expo-file-system</code>和<code class="fe mo mp mq mr b">expo-sharing</code>模块，以便控制<code class="fe mo mp mq mr b">documentDirectory</code>、<code class="fe mo mp mq mr b">writeAsStringAsync</code>和<code class="fe mo mp mq mr b">shareAsync</code>调用的行为。</p><p id="1b83" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如下图所示，您可以使用标准的<code class="fe mo mp mq mr b">jest.mock</code>方法。只要模块模型返回一个带有你正在调用的函数的属性的对象，那么它就会工作。如果你想控制每个函数的行为方式或者断言该函数被调用，那么使用一个命名的模拟并使用<code class="fe mo mp mq mr b">mockImplementation</code>可以改变行为。</p><figure class="ms mt mu mv gt jr"><div class="bz fp l di"><div class="mw mx l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">By mocking out the expo-file-system and expo-sharing modules we can make sure they are called after the PDF file is generated.</figcaption></figure><h1 id="8d3b" class="ll lm iq bd ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi bi translated">摘要</h1><p id="f449" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">使用<code class="fe mo mp mq mr b">expo-file-system</code>和<code class="fe mo mp mq mr b">expo-sharing</code>的组合允许容易地实现测试解决方案，并且用户能够决定他们想要对文件做什么，这是一个非常好的用户体验，因为他们可能不总是希望保存它，而是通过另一个应用程序发送它。</p><h2 id="150e" class="my lm iq bd ln mz na dn lr nb nc dp lv kj nd ne lz kn nf ng md kr nh ni mh nj bi translated">简单英语的JavaScript</h2><p id="56f4" class="pw-post-body-paragraph jy jz iq ka b kb mj kd ke kf mk kh ki kj ml kl km kn mm kp kq kr mn kt ku kv ij bi translated">你知道我们有三份出版物和一个YouTube频道吗？在<a class="ae kw" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank">T3【plain English . ioT5】找到一切的链接！</a></p></div></div>    
</body>
</html>