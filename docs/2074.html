<html>
<head>
<title>Mastering Call/Apply/Bind in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">掌握JavaScript中的调用/应用/绑定</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/mastering-call-apply-bind-in-js-94b9d91b3f0e?source=collection_archive---------8-----------------------#2020-05-17">https://javascript.plainenglish.io/mastering-call-apply-bind-in-js-94b9d91b3f0e?source=collection_archive---------8-----------------------#2020-05-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="be82" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">真正理解三种被误解的JS方法的实用指南</h2></div><p id="b6ec" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript的一个最重要的方面是许多开发人员都不确定的，在JavaScript开发人员进入更高级的概念之前，需要明确这一点。</p><p id="1f4b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个主题在某种程度上是必不可少的，对于JavaScript开发人员来说，理解如何调用函数、“this”关键字和上下文范例、你正在玩的区域几乎是必须的。在讨论这些问题时，我决定提供尽可能多的例子，因为文献缺少一些方面和用例。</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/dffbdcdfdc744bb37bc778c4851f9d67.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2MVUv0UhJ9XT95QS"/></div></div><figcaption class="lk ll gj gh gi lm ln bd b be z dk">Photo by <a class="ae lo" href="https://unsplash.com/@mr_vero?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Irvan Smith</a> on <a class="ae lo" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5ef2" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">“这个”是什么？</h1><p id="827b" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">在我们进入主要问题之前，最好先谈一谈“这个”关键词。“This”关键字指的是上下文，它取决于在哪里操作。</p><p id="b600" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当“this”单独使用或在函数中使用时，它自动引用全局对象，即函数的所有者。但是当模式为“严格”时，它是未定义的。</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="fadf" class="mr lq in mn b gy ms mt l mu mv">console.log(this);<br/><em class="mw">// logs global Object</em></span><span id="16a8" class="mr lq in mn b gy mx mt l mu mv"><br/>function test() {<br/>    console.log(this)<br/>}</span><span id="01b8" class="mr lq in mn b gy mx mt l mu mv">test(); <br/><em class="mw">// logs global Object</em></span></pre><p id="8f83" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果在对象文本中操作，方法和实际上下文的所有者就是对象本身。</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="d69e" class="mr lq in mn b gy ms mt l mu mv">var obj = {<br/>    test: function() {<br/>        console.log(this)<br/>    }<br/>}<br/><br/>obj.test();<br/><em class="mw">// logs obj</em></span></pre><h1 id="8d4e" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">函数调用</h1><p id="393b" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">在JavaScript中有多种执行函数的方法。定义了函数之后，最好的方法就是在任何时候用它的名字调用它。</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="8ed1" class="mr lq in mn b gy ms mt l mu mv">function test() {<br/>    console.log(this)<br/>}<br/><br/><em class="mw">// invoke the function as a function </em><br/>test();<br/><em class="mw">// logs global object</em></span><span id="02ed" class="mr lq in mn b gy mx mt l mu mv"><br/><br/><em class="mw">// or use a named function </em><br/>var test = function() {<br/>    console.log("test")<br/>}<br/><br/>test();</span></pre><p id="0dac" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">调用函数的另一种方法是在对象文字中定义函数，从而将函数表示为对象方法。</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="107e" class="mr lq in mn b gy ms mt l mu mv"><em class="mw">// object literal notation<br/>var obj = {<br/>    a: 1,<br/>    b: 2,<br/>    test: function() {<br/>        console.log(this)<br/>    }<br/>}<br/><br/>// invoke the function as a method<br/>obj.test();<br/>// logs obj {a: 1, b: 2, test: ƒ}</em></span></pre><p id="aa18" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您想使用构造函数逻辑和“new”操作符来调用一个函数时，您实际上是在创建一个新的对象，而不是创建一个新的函数，因为函数是JavaScript中的对象。</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="1f68" class="mr lq in mn b gy ms mt l mu mv"><em class="mw">// invoked with a function constructor</em><br/>function test() {<br/>}<br/><br/><em class="mw">// use new operator to create a new object</em><br/>var obj = new test();</span></pre><p id="3fcb" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还有另一种通过DOM事件处理程序调用函数的方法。当您向DOM元素注册事件侦听器时，从现在起上下文就是元素本身。</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="5bd7" class="mr lq in mn b gy ms mt l mu mv">var button = document.createElement('button');<br/>button.addEventListener(function(){<br/>    console.log(this)<br/>});<br/><em class="mw">// logs button</em></span></pre><p id="1d7a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，上下文隐式绑定在所有者上，在某种程度上，它主要与调用者相关。换句话说，“这个”的价值是由其语境决定的。但是如果您想使用另一个指定的上下文呢？您可能希望使用与另一个上下文相关的函数或方法。当你想改变上下文时该怎么做？但是首先，我们为什么要改变背景呢？</p><h1 id="3f1a" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">致电/申请/绑定的动机</h1><p id="1d33" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">有时我们想使用属于另一个对象或上下文的方法或函数。为了避免重复或耦合，我们可能想要调用或使用另一个没有复制的方法。</p><p id="535d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们用一个例子来讨论这个问题:</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="fd02" class="mr lq in mn b gy ms mt l mu mv">function test(param) {<br/>    <em class="mw">console</em>.log(this.name + "-" + param)<br/>}</span></pre><p id="ab2d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该函数接受参数“param ”,并记录“上下文”的“名称”属性以及附加的“param”值。不管内部逻辑如何，想象一下，这个函数是基于某种通用目的编写的，需要被其他对象或上下文使用。如果像下面这样经常使用这个函数，</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="de91" class="mr lq in mn b gy ms mt l mu mv">test("test");<br/><br/><em class="mw">// logs "-test"</em></span></pre><p id="afe0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出会很奇怪。而是根据上面提供的信息进行思考；由于函数是在全局上下文中定义的(此时属于窗口)，因此this.name将引用window.name，此时window . name为空字符串。</p><p id="c702" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一方面，认为这个效用函数将被另一个上下文使用，比如一个对象。该对象还有一个名称属性:</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="9002" class="mr lq in mn b gy ms mt l mu mv">var human = {"name":"javascript", "surname": "developer"}</span></pre><p id="4055" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但问题是如何将这个函数和对象相互关联，以便函数内部的内部逻辑绑定到显式提供的对象。</p><p id="fb9c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是<strong class="ke io"> Function.prototoype.call </strong>和<strong class="ke io"> Function.prototype.apply </strong>方法出现的地方。这些方法调用一个提供了“this”值和某种意义上的参数的函数。主要区别在于提供参数的方式。Call()接受列表形式的参数(用逗号分隔), Apply()接受参数数组。</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="4de5" class="mr lq in mn b gy ms mt l mu mv">func.call([thisArg[, arg1, arg2, ...argN]])<br/><em class="mw">// an optional thisArg for the bound context<br/>// an optional list of arguments followed</em><br/><br/><br/>func.apply(thisArg, [ argsArray])<br/><em class="mw">// thisArg for the bound context<br/>// an optional array-like object as argsArray</em></span></pre><p id="ca28" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些方法允许为要展示的函数/方法定义“this”的新值。通过这些函数，我们只需编写一次方法，就可以提供不同的对象，而无需重写方法。</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="4c7b" class="mr lq in mn b gy ms mt l mu mv">var myMethod = function () {<br/>    console.log(this.location)<br/>}</span><span id="76a6" class="mr lq in mn b gy mx mt l mu mv">var place1 = {location: 'Istanbul'}<br/>var place2 = {location: 'Izmir'}<br/></span><span id="9233" class="mr lq in mn b gy mx mt l mu mv">myMethod()<br/><em class="mw">// logs window.location</em><br/></span><span id="f315" class="mr lq in mn b gy mx mt l mu mv">myMethod.call()<br/><em class="mw">// logs window.location since no this value is bound<br/></em></span><span id="62b1" class="mr lq in mn b gy mx mt l mu mv">myMethod.call(place1)<br/><em class="mw">// logs Istanbul</em><br/></span><span id="bd76" class="mr lq in mn b gy mx mt l mu mv">myMethod.apply(place2)<br/><em class="mw">// logs Izmir</em></span></pre><p id="4a6f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">调用和应用在很多情况下都得到了最好的实践。</p><h2 id="a122" class="mr lq in bd lr my mz dn lv na nb dp lz kl nc nd mb kp ne nf md kt ng nh mf ni bi translated">链接构造函数</h2><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="4976" class="mr lq in mn b gy ms mt l mu mv">function Animal(name, type) {<br/>    this.name = name<br/>    this.type = type<br/>}<br/></span><span id="b3e0" class="mr lq in mn b gy mx mt l mu mv">function Pet(name, type, skill) {<br/>    <em class="mw">//this.name = name</em><br/>    <em class="mw">//this.type = type</em><br/><br/>    <em class="mw">// instead of replicating the same properties</em><br/>    Animal.call(this, name, type)<br/>    <em class="mw">// or Animal.apply(this, [name, type])</em><br/>    this.skill = skill<br/>}</span><span id="a248" class="mr lq in mn b gy mx mt l mu mv"><br/>var animal = new Animal('lion', 'wild')<br/><em class="mw">// {name: "lion", type: "wild"}</em></span><span id="037c" class="mr lq in mn b gy mx mt l mu mv"><br/>var bird = new Pet('parrot', 'domestic', 'speak')<br/><em class="mw">// {name: "parrot", type: "domestic", skill: "speak"}</em></span></pre><h2 id="1a0e" class="mr lq in bd lr my mz dn lv na nb dp lz kl nc nd mb kp ne nf md kt ng nh mf ni bi translated">调用内置函数</h2><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="ee7c" class="mr lq in mn b gy ms mt l mu mv">let values = [1,2,3,4,5]</span><span id="5fd5" class="mr lq in mn b gy mx mt l mu mv"><br/>Object.prototype.toString.call(values)<br/><em class="mw">// "[object Array]"<br/>// a good method to find the type of a variable !</em></span><span id="dd54" class="mr lq in mn b gy mx mt l mu mv"><br/>Math.max.apply(null, values)<br/><em class="mw">// 5</em></span><span id="2c91" class="mr lq in mn b gy mx mt l mu mv"><br/>Array.prototype.splice.call(values,0,1)<br/><em class="mw">// returns [1]<br/>// and values array becomes -&gt; [2, 3, 4, 5]</em></span></pre><h2 id="9874" class="mr lq in bd lr my mz dn lv na nb dp lz kl nc nd mb kp ne nf md kt ng nh mf ni bi translated">调用匿名函数</h2><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="27da" class="mr lq in mn b gy ms mt l mu mv">(function(){<br/>    console.log(this.name)<br/>})()<br/><em class="mw">// self invoking function with no parameters or context supplied<br/>// logs window.name in browser<br/></em></span><span id="7dcd" class="mr lq in mn b gy mx mt l mu mv"><br/>(function(){<br/>    console.log(this.name)<br/>}).call({name:'test'})<br/><em class="mw">// logs "test"<br/>// calling an anonymous function with a bound "this"<br/></em></span><span id="1c2a" class="mr lq in mn b gy mx mt l mu mv"><br/>(function(param){<br/>    console.log(this.name + param)<br/>}).apply({name: 'test'},[3])<br/><em class="mw">// logs test3<br/>// calling an anonymous function with bound object and a param</em></span></pre><p id="39d1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个简单的工作室:</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="a999" class="mr lq in mn b gy ms mt l mu mv">const myMethod = function (param = "district") {<br/>    console.log(`${this.location} ${param}`)<br/>}<br/>let place1 = {<br/>    location: 'Istanbul',<br/>    myMethod: myMethod<br/>}<br/>let place2 = {<br/>    location: 'Izmir',<br/>    myMethod: myMethod<br/>}<br/><br/>myMethod.apply(place1, ["Bayrampasa"])<br/><em class="mw">// Istanbul Bayrampasa</em><br/><br/>myMethod.call(place1)<br/><em class="mw">// Istanbul district</em><br/><br/>place2.myMethod()<br/><em class="mw">// Izmir district</em><br/><br/>place1.myMethod.call(place2, "Gaziemir")<br/><em class="mw">// Izmir Gaziemir</em></span></pre><p id="aa9a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">至于<strong class="ke io"> Function.prototype.bind </strong>，<strong class="ke io"> </strong>它创建了一个新函数，其“this”与所提供的对象以及所提供的参数列表绑定在一起。一旦使用了带有绑定属性的“bind ”,就有了一个新的函数可以调用。</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="0f90" class="mr lq in mn b gy ms mt l mu mv">newFunc = func.bind(thisArg[, arg1[, arg2[, ...argN]]])</span></pre><p id="5fde" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请注意，参数是按列表顺序排列的，就像提供给“call”函数的参数一样。</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="ead8" class="mr lq in mn b gy ms mt l mu mv">const myMethod = function (param = "district") {<br/>    console.log(`${this.location} ${param}`)<br/>}<br/>let place1 = {<br/>    location: 'Istanbul'<br/>}<br/>let place2 = {<br/>    location: 'Izmir'<br/>}<br/><br/><em class="mw">// create a new function</em><br/>let yourMethod = myMethod.bind(place1)<br/><br/>yourMethod()              // Istanbul district<br/>yourMethod('Bayrampasa')  // Istanbul Bayrampasa<br/><br/>let theirMethod = myMethod.bind(place2,'Gaziemir')<br/>theirMethod()             // Izmir Gaziemir<br/>theirMethod('Buca')       // Izmir Gaziemir<br/>theirMethod.call(place1)  // Izmir Gaziemir<br/>// ! note that once the corresponding values are bound,<br/>// Remaining arguments are ignored.</span></pre><p id="2269" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">绑定函数的一些用法如下:</p><h2 id="22c9" class="mr lq in bd lr my mz dn lv na nb dp lz kl nc nd mb kp ne nf md kt ng nh mf ni bi translated">绑定函数创建</h2><p id="24e6" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">绑定函数主要用于生成绑定函数，将函数打包成较短的格式，以备将来使用。同样，函数的快捷方式也可以用这种方法产生。</p><p id="2b13" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">另一方面，当需要使用时，可以通过产生较短的语法来实现变量、对象文字或方法的缓存。有一个在许多开发人员中广泛传播的简单错误，即当稍后调用时，应该使用方法的原始“this”。</p><p id="34b1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个问题导致“This”丢失，并可能导致不寻常的后果。解决方案是在绑定函数时提供原始上下文。</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="3780" class="mr lq in mn b gy ms mt l mu mv">const circle = {<br/>    value: Math.PI,<br/>    calculate: function(r) {<br/>        return 2*this.value*r<br/>    }<br/>}<br/><br/>let perimeter = circle.calculate(2)<br/><em class="mw">// 12.56</em><br/><br/>const perimeterFinder = circle.calculate<br/>perimeterFinder(2)<br/><em class="mw">// logs NaN, guess what we lost THIS !!!<br/>// it returns 2*undefined*2 -&gt; NaN</em><br/><br/>const truePerimeterFinder = circle.calculate.bind(circle)<br/>truePerimeterFinder(2)<br/><em class="mw">// logs 12.56</em><br/><br/><em class="mw">// if you are to use 3 as PI ?</em><br/>const newPerimeterFinder = circle.calculate.bind({value:3})<br/>newPerimeterFinder(2)<br/><em class="mw">// logs 12</em></span></pre><h2 id="e868" class="mr lq in bd lr my mz dn lv na nb dp lz kl nc nd mb kp ne nf md kt ng nh mf ni bi translated">具有初始设置参数的绑定函数</h2><p id="b341" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">当函数被打包时，一些参数或上下文可以容易地被绑定或设置，覆盖任何可能的参数。</p><pre class="kz la lb lc gt mm mn mo mp aw mq bi"><span id="3ab5" class="mr lq in mn b gy ms mt l mu mv">const calculations = {<br/>    accumulatorForAdd: 0,<br/>    accumulatorForMult: 1,<br/>    add: function(a, b) {<br/>        return this.accumulatorForAdd + a + b<br/>    },<br/>    multiply: function(a, b) {<br/>        return this.accumulatorForMult * a * b<br/>    }<br/>}<br/><br/>calculations.add(1,2)  <em class="mw">// returns 3</em><br/><br/>let calc1 = calculations.add.bind(calculations)<br/>calc1(2,3)   <em class="mw">// returns 5</em><br/><br/>let calc2 = calculations.add.bind(calculations, 1)<br/><em class="mw">// the first parameter (a) is occupied and set to 1.<br/>// if extra arguments are supplied, will be evaluated as followers</em><br/>calc2(4,9)  <em class="mw">// returns 5, second parameter (b) will be 4.</em><br/><br/>let calc3 = calculations.multiply.bind({accumulatorForMult: 2})<br/>calc3(3,4)  <em class="mw">// returns 2*3*4 = 24 since accumulatorForMult is bound</em><br/><br/>let calc4 = calculations.multiply.bind(calculations, 3)<br/>calc4(5,6)  <em class="mw">// returns 1*3*5 = 15 where second parameter is ignored</em></span></pre></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><p id="ce72" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于JS开发人员来说，跟上框架和库开发中取得的毁灭性进步每天都变得越来越具有挑战性。但是，如果您深入研究这些结构的实际实现，您会发现熟悉的JavaScript方法正在承担这一负担。调用/应用/绑定三部曲显然是这些代码段背后最重要的负担之一。</p><h1 id="51b8" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">用简单英语写的便条</h1><p id="aafe" class="pw-post-body-paragraph kc kd in ke b kf mh jo kh ki mi jr kk kl mj kn ko kp mk kr ks kt ml kv kw kx ig bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae lo" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io"> plainenglish.io </strong> </a>找到所有这些内容——关注我们的出版物并<a class="ae lo" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ke io">订阅我们的YouTube频道</strong> </a> <strong class="ke io">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>