<html>
<head>
<title>React Native Component Library — Making things theme-able</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React本地组件库——让事物主题化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-component-library-making-things-theme-able-82cfee4993ac?source=collection_archive---------5-----------------------#2019-09-07">https://javascript.plainenglish.io/react-native-component-library-making-things-theme-able-82cfee4993ac?source=collection_archive---------5-----------------------#2019-09-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="34e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为React原生组件库的一部分，我一直在构建一个遗留React原生应用程序，以使维护更容易，我一直在重构组件处理样式的方式。</p><p id="c082" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最初的复杂组件有一个样式表来覆盖它包含的所有较小的组件，当我将这些较小的组件分解到组件库中时，我只是复制了这个样式表，并删除了该组件未使用的样式。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">An example component with separate stylsheet</figcaption></figure><p id="917a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这种方法导致每个组件都有一个样式表，由于原始样式表从未重用过任何样式，因此它声明有许多重复的样式。</p><p id="a16a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">与我一起工作的团队表示，由于不同样式表的数量，最初的样式实现有点笨拙，他们更喜欢与他们习惯使用的CSS样式表类似的东西。</p><p id="257d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于需要重构实现，我认为更好的方法是将代码库中的所有样式提取到一个对象中，该对象将使用组件库中的层次结构。</p><p id="877d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用这种方法，位于<code class="fe kt ku kv kw b">src/inputs/pokemonPicker/Cell</code>的组件需要一个名为<code class="fe kt ku kv kw b">background</code>的样式对象，它将使用主题对象中的<code class="fe kt ku kv kw b">inputs.pokemonPicker.Cell.background</code>属性。</p><p id="466a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这将允许我通过将公共值提取到主题中的其他样式定义中并更新组件以使用这些值来删除重复的样式。</p><h1 id="517d" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">访问组件中的主题</h1><p id="5e0c" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">将所有组件样式移入一个对象的主要挑战之一是，如何使组件可以访问该对象，而不必将该属性传递给每个组件，然后再传递给其子组件。</p><p id="0f4e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">使用<a class="ae ma" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank"> React上下文挂钩</a>可以很容易做到这一点，因为它允许您将组件包装在一个更高阶的组件(HOC)中，该组件将从上下文中获取主题，并将其作为道具传递给包装的组件。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Context Providing component and withTheme HOC</figcaption></figure><p id="d290" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后，将上下文提供组件添加到组件层次结构的顶部，并设置主题属性，主题HOC将把该属性传递给它所包装的组件。</p><p id="6a95" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一旦设置了上下文，就需要将主题属性添加到组件<code class="fe kt ku kv kw b">propTypes</code>定义中。</p><p id="e801" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以根据需要设置主题属性，或者如果您想提供一个默认值(这样您就不需要依赖于传递主题来进行测试)，您可以在<code class="fe kt ku kv kw b">defaultProps</code>中设置主题。</p><p id="ec8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，我在使用defaultProps方法时遇到的一个问题是，我在库中提供了一个围绕表单输入的通用主题，它从来没有接收过默认的主题属性，所以当我在组件中分解Props对象时，我必须为主题设置一个默认值。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Providing a default value to props de-structure or using defaultProps will allow a default theme to be used when the component isn’t wrapped by the withTheme HOC</figcaption></figure><h1 id="658e" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">主题的好处</h1><p id="dc4e" class="pw-post-body-paragraph jk jl in jm b jn lv jp jq jr lw jt ju jv lx jx jy jz ly kb kc kd lz kf kg kh ig bi translated">从样式表转移到主题对象的最大好处是，现在每个组件的代码都更加清晰，而且主题对象遵循与组件库相同的层次结构，因此更容易看到样式背后的逻辑。</p><p id="7442" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二是改变主题的能力。</p><figure class="ki kj kk kl gt km gh gi paragraph-image"><div class="gh gi mb"><img src="../Images/386af694ff3c9ef927df562615c6f53c.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/1*Pd5-kW_jDfLKg2WpC6h64g.gif"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">The dark mode override object made only 8 changes but the styles changes are drastic</figcaption></figure><p id="02e7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了展示主题允许对应用程序进行广泛的风格更改是多么容易，我创建了一个override对象，该对象将对现有主题应用“黑暗模式”,并使用<code class="fe kt ku kv kw b">deepmerge</code>创建一个新主题。</p><figure class="ki kj kk kl gt km"><div class="bz fp l di"><div class="kn ko l"/></div><figcaption class="kp kq gj gh gi kr ks bd b be z dk">Creating a ‘dark mode’ theme using deepmerge</figcaption></figure><p id="b2a2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">由于主题只是一个JavaScript对象，这也为应用程序提供了从网络服务器下载不同主题的机会，并为应用程序提供基于季节或事件的风格变化。</p></div></div>    
</body>
</html>