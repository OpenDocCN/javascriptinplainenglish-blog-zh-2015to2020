<html>
<head>
<title>Creating reusable custom React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建可重用的自定义React挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-useful-custom-react-hooks-2ad125e36a32?source=collection_archive---------0-----------------------#2019-09-08">https://javascript.plainenglish.io/creating-useful-custom-react-hooks-2ad125e36a32?source=collection_archive---------0-----------------------#2019-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/3ae1ec108de7619d27ca729ad5757506.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uZ8WSki-46Kkls1TefrLIQ.jpeg"/></div></div></figure><div class=""/><p id="5762" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从React 16.8 <strong class="ka jc">开始，你不再需要类组件</strong>来处理<strong class="ka jc">状态逻辑</strong>。现在的做法是这样的:</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi kw"><img src="../Images/a081e5cc85620a5a5c26bbfdcddeab81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iFQWI72Vpr3q_eZdukgsHA.png"/></div></div></figure><p id="8717" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码在一个功能组件(以前被称为“无状态功能组件”)上完美地工作，这为我们构建项目的方式带来了许多新的可能性。</p><p id="8404" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最常用的钩子是<strong class="ka jc">使用状态</strong>和<strong class="ka jc">使用效果。如果你对这些都不熟悉，我建议你阅读React Hooks上的官方文档。</strong></p><p id="7c47" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但不止于此。为了充分利用这个新特性，我们可以编写<strong class="ka jc">定制的react钩子</strong>，以便<strong class="ka jc">在组件之间重用</strong>逻辑。让我们看看几个真实的例子。</p><blockquote class="lc ld le"><p id="d19e" class="jy jz lf ka b kb kc kd ke kf kg kh ki lg kk kl km lh ko kp kq li ks kt ku kv ij bi translated">您可以在现有项目上使用下面的代码，或者通过在终端上运行“create-react-app custom-hooks-project”来创建一个新项目。</p></blockquote><h1 id="e45d" class="lj lk jb bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated"><strong class="ak">用react钩子创建无限卷轴</strong></h1><p id="a941" class="pw-post-body-paragraph jy jz jb ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">假设您想要呈现一个包含许多条目的表格。您可能不希望react一次呈现所有内容，这样会导致页面非常长，用户甚至可能无法看到页面的底部。一个可能的解决方案是实现一个<strong class="ka jc">无限滚动</strong>表，在用户向下滚动时呈现新的条目。</p><ol class=""><li id="8dae" class="mm mn jb ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">编辑文件<strong class="ka jc"> App.js </strong> ( <a class="ae lb" href="https://gist.github.com/pflevy/9ccbdd86a75d800446c549225c642c05.js" rel="noopener ugc nofollow" target="_blank">要旨</a></li></ol><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk"><strong class="ak">App.js</strong></figcaption></figure><p id="c236" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">上面的代码从web上加载一些假数据，并将其显示在HTML表中。所有的行元素一次呈现，如果您有一个很长的项目列表，这是不好的。为了解决这个问题，我们可以一次呈现30个项目，每次用户点击页面底部时再呈现10个项目。</p><p id="3403" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们要在<strong class="ka jc"> App.js </strong>文件上实现这个逻辑，然后需要在另一个组件上重用它，就会有代码冗余。<br/>多亏了React钩子，我们可以在一个单独的<strong class="ka jc">定制钩子</strong>上实现逻辑，并在任何需要的地方使用它。</p><blockquote class="lc ld le"><p id="6aae" class="jy jz lf ka b kb kc kd ke kf kg kh ki lg kk kl km lh ko kp kq li ks kt ku kv ij bi translated">创建定制钩子的命名约定是以单词“<strong class="ka jc"> use </strong>开始，例如useCustomHookName。这对于react检查钩子是否违反<a class="ae lb" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank">规则很重要。</a></p></blockquote><p id="eee8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> 2。</strong>创建自定义react钩子文件<strong class="ka jc">使用InfiniteScroll.js </strong> ( <a class="ae lb" href="https://gist.github.com/pflevy/67957a25877133e45edd4c7e33d796cf" rel="noopener ugc nofollow" target="_blank">要点</a>)</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk"><strong class="ak">useInfiniteScroll.js</strong></figcaption></figure><p id="bc0e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个创建的钩子接受两个参数:</p><ul class=""><li id="8393" class="mm mn jb ka b kb kc kf kg kj mo kn mp kr mq kv nb ms mt mu bi translated"><strong class="ka jc"> start </strong>:开始渲染的元素个数。</li><li id="14e8" class="mm mn jb ka b kb nc kf nd kj ne kn nf kr ng kv nb ms mt mu bi translated"><strong class="ka jc">步调</strong>:后续要渲染的元素数量。</li></ul><p id="5d2e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">默认情况下，它们分别设置为30和10。这意味着您可以调用钩子而不传递任何参数，这些值将被使用。</p><p id="7898" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">逻辑非常简单:用户每次点击页面底部时，自定义钩子返回的值(将是我们想要呈现的元素数量)就会增加<strong class="ka jc"> pace </strong>变量。</p><blockquote class="lc ld le"><p id="7ba3" class="jy jz lf ka b kb kc kd ke kf kg kh ki lg kk kl km lh ko kp kq li ks kt ku kv ij bi translated">确保最初呈现的元素数量允许垂直滚动。</p></blockquote><p id="a935" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在剩下要做的就是在App.js组件中使用新创建的react钩子。用下面的代码替换App.js以前的代码:</p><p id="1c09" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> 3。</strong>更新文件<strong class="ka jc"> App.js </strong> ( <a class="ae lb" href="https://gist.github.com/pflevy/4f292936ff823cffc7447abdaa9aad0a.js" rel="noopener ugc nofollow" target="_blank">要点</a>)</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Updated <strong class="ak">App.js</strong></figcaption></figure><p id="4411" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以在控制台上运行'<strong class="ka jc"> npm start' </strong>来测试应用程序。它应该按如下方式工作:</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/51d788fd93c273119870271f80ff53f2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*qZ2jagZWOWWGHY-OSYmQ6g.gif"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk">Infinite Scroll hook in practice</figcaption></figure><h1 id="4df2" class="lj lk jb bd ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg bi translated">创建实时firebase数据库条目监听器</h1><p id="d6c0" class="pw-post-body-paragraph jy jz jb ka b kb mh kd ke kf mi kh ki kj mj kl km kn mk kp kq kr ml kt ku kv ij bi translated">让我们用这个把它变得更复杂。如果你还没有试过Firebase的实时数据库，我建议你试试。他们让建立一个免费的在线数据库和后端服务变得非常容易，这样你就可以专注于前端开发。</p><p id="4400" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您需要设置方面的帮助，您可以遵循此<a class="ae lb" href="https://medium.com/swlh/real-time-iot-app-with-react-firebase-esp8266-e2e673efd1bf#152d" rel="noopener">链接</a>上的步骤。</p><blockquote class="lc ld le"><p id="c950" class="jy jz lf ka b kb kc kd ke kf kg kh ki lg kk kl km lh ko kp kq li ks kt ku kv ij bi translated">在<!-- -->的情况下，您不想创建自己的数据库，但是尝试这个例子，您可以取消我在配置文件中提供的数据的注释。</p></blockquote><p id="187c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设您有一个带有实时数据库的firebase帐户，现在是时候创建配置文件了。但是首先，通过运行“npm install firebase - save”在您的项目上安装firebase。</p><ol class=""><li id="aeed" class="mm mn jb ka b kb kc kf kg kj mo kn mp kr mq kv mr ms mt mu bi translated">创建配置文件<strong class="ka jc"> database.js </strong> ( <a class="ae lb" href="https://gist.github.com/pflevy/2e015861e4ac4c50786e53cb35751309" rel="noopener ugc nofollow" target="_blank">要点</a></li></ol><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk"><strong class="ak">database.js</strong></figcaption></figure><p id="2571" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该文件支持连接到您的数据库，从现在起，每次您想要对文件执行数据库操作，例如插入新条目、编辑以前的条目等，请确保您从“导入firebase”。/database.js" 文件，而不是来自“firebase”包。</p><p id="465b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">配置好数据库后，您现在可以访问它的一些方法，如push、put、remove等。如果需要帮助，您可以阅读完整的文档，对于本例，您将需要'<strong class="ka jc"> push </strong>'将数据插入数据库，并需要'<strong class="ka jc"> on </strong>'实时检索这些数据。</p><p id="eb85" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2.创建文件<strong class="ka jc">使用数据库条目. js </strong> ( <a class="ae lb" href="https://gist.github.com/pflevy/3ab3668b062812252f7d0c0a8279774d" rel="noopener ugc nofollow" target="_blank">要点</a>)</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk"><strong class="ak">useDatabaseEntry.js</strong></figcaption></figure><p id="1cf8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当从firebase检索数据时，您会得到一个由firebase自动生成的唯一键索引的<strong class="ka jc">对象</strong>。问题是。map()函数仅适用于数组。这个自定义钩子所做的是<strong class="ka jc">从firebase中检索数据并将其转换成一个数组</strong>，这样就可以很容易地将它映射到我们的表中。</p><p id="f15f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">3.编辑文件<strong class="ka jc"> App.js </strong> ( <a class="ae lb" href="https://gist.github.com/pflevy/6955e7c85e7afa1a40873dfe6705d9d7" rel="noopener ugc nofollow" target="_blank">要点</a>)</p><figure class="kx ky kz la gt is"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mx my gj gh gi mz na bd b be z dk"><strong class="ak">App.js</strong></figcaption></figure><p id="61eb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在App.js文件中，有一个按钮<strong class="ka jc">将</strong>数据推送到firebase，useDatabaseEntry接收所需的条目作为参数，并返回一个包含该条目数据的数组。</p><p id="50bc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其优点是，您现在可以使用这个新钩子<strong class="ka jc">从firebase数据库的任何条目</strong>中直接<strong class="ka jc">作为数组</strong>检索实时数据，这使得它很容易被映射到一个表中。</p><blockquote class="lc ld le"><p id="2ddd" class="jy jz lf ka b kb kc kd ke kf kg kh ki lg kk kl km lh ko kp kq li ks kt ku kv ij bi translated">如果<!-- -->你想练习，试着点击几次按钮插入更多的数据，并利用上面例子中定义的useInfiniteScroll。</p></blockquote><p id="a174" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">结果如下:</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/46683eb915faf3669605a01076da1f12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*j51UC9BPz__H0tW__9tZOw.gif"/></div></figure></div><div class="ab cl ni nj hu nk" role="separator"><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn no"/><span class="nl bw bk nm nn"/></div><div class="ij ik il im in"><p id="235e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望这些例子通过创建更多的“通用”逻辑，与其他组件一起重复使用，帮助您在可用性方面构建您未来的项目思维。通过将<strong class="ka jc">应该做什么</strong>和<strong class="ka jc">应该如何做</strong>区分开来，这使得代码更加清晰。</p><p id="51c6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">谢谢你的阅读！</p></div></div>    
</body>
</html>