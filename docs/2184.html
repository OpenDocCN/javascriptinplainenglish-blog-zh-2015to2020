<html>
<head>
<title>JavaScript Best Practices— Parsing Numbers, Promises, Unicode and Regex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—解析数字、承诺、Unicode和Regex</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-parsing-numbers-promises-unicode-and-regex-a608dc8df8?source=collection_archive---------9-----------------------#2020-05-27">https://javascript.plainenglish.io/javascript-best-practices-parsing-numbers-promises-unicode-and-regex-a608dc8df8?source=collection_archive---------9-----------------------#2020-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a3ebf86da3bab5624d000705ecdbdca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ROcrSvtTGDNTOdnO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@alex_makarov?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alex Makarov</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2b10" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种非常宽容的语言。编写运行但有错误的代码很容易。</p><p id="2136" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究更好地解析数字的方法，在异步函数中要求<code class="fe lb lc ld le b">await</code>，并在正则表达式中添加一个Unicode标志。</p><h1 id="a688" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">调用解析时添加基数参数</h1><p id="294c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">JavaScript <code class="fe lb lc ld le b">parseInt</code>函数接受第二个参数，该参数具有被解析数字的基数。基数是数字的<code class="fe lb lc ld le b">0x</code>前缀。</p><p id="ac6a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在ES5之前，<code class="fe lb lc ld le b">parsseInt</code>自动检测八进制文字，这使得任何带有0的内容在被解析为八进制数而不是十进制数之前都是0。</p><p id="c718" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，ES5或更高版本改变了这种行为，现在前导为0的数字被解析为十进制数。</p><p id="52dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是显式地指定<code class="fe lb lc ld le b">parseInt</code>函数仍然是一个好主意，这样每个人都知道我们要把数字串解析成什么样的数字。</p><p id="034b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不是编写以下代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="dba9" class="mq lg iq le b gy mr ms l mt mu">const num = parseInt("021");</span></pre><p id="19eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该编写以下代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="a381" class="mq lg iq le b gy mr ms l mt mu">const num = parseInt("021", 10);</span></pre><p id="97a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数中的<code class="fe lb lc ld le b">10</code>确保<code class="fe lb lc ld le b">parseInt</code>将<code class="fe lb lc ld le b">'021'</code>解析为十进制数，这样它或任何开发人员都不会与它被解析的内容相混淆。</p><p id="8f11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此<code class="fe lb lc ld le b">num</code>为21。</p><p id="fae7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以指定它被解析为八进制文字，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0a49" class="mq lg iq le b gy mr ms l mt mu">const num = parseInt("021", 8);</span></pre><p id="2fa7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe lb lc ld le b">num</code>是17，因为八进制<code class="fe lb lc ld le b">021</code>是17作为十进制数。</p><h1 id="da1e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">没有没有<code class="fe lb lc ld le b">await</code>表达式的异步函数</h1><p id="8888" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在JavaScript中，<code class="fe lb lc ld le b">async</code>函数是一个内部有一系列承诺并且只返回一个承诺的函数。</p><p id="dbe4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有任何<code class="fe lb lc ld le b">await</code>表达式的<code class="fe lb lc ld le b">async</code>函数只是用我们放在<code class="fe lb lc ld le b">return</code>语句之后的任何东西来返回一个承诺，或者如果我们没有返回任何里面的东西，则返回一个解析为<code class="fe lb lc ld le b">undefined</code>的承诺。</p><p id="ad07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有必要让<code class="fe lb lc ld le b">async</code>函数里面没有<code class="fe lb lc ld le b">await</code>表达式，因为我们要么没有在里面运行任何承诺代码，要么我们在承诺之前忘记了<code class="fe lb lc ld le b">await</code>，所以它们不会被正确地链接。</p><p id="6c40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论哪种方式，我们都应该纠正这些情况。如果只是同步代码，那么我们不需要把它们放在<code class="fe lb lc ld le b">async</code>函数中。</p><p id="b448" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们忘记了与<code class="fe lb lc ld le b">await</code>的承诺，那么我们应该把<code class="fe lb lc ld le b">await</code>放在承诺的前面。</p><p id="2e62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们不应该有这样的代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4382" class="mq lg iq le b gy mr ms l mt mu">const foo = async () =&gt; {<br/>  return 'foo';<br/>}</span></pre><p id="c907" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们写下这样的内容:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f16f" class="mq lg iq le b gy mr ms l mt mu">const getMichael = async () =&gt; {<br/>  const response = await fetch('https://api.agify.io/?name=michael');<br/>  const data = await response.json();<br/>  return data;<br/>}</span></pre><p id="096e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码是调用API的异步函数，这是promises的常见用法。</p><p id="8165" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，它返回从API获得的数据。</p><p id="50ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们在异步函数中抛出一个错误，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3b76" class="mq lg iq le b gy mr ms l mt mu">const error = async () =&gt; {<br/>  throw new Error("error");<br/>}</span></pre><p id="04bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将上面的代码替换为:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3973" class="mq lg iq le b gy mr ms l mt mu">const error = () =&gt; Promise.reject(new Error("error"))</span></pre><p id="c937" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们都做出了被拒绝的承诺。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/44281f70e77414c75381b54e2e4f8715.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GJcaXJ3Y9jx49liE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@stanyw?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Stan W.</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="89b2" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在正则表达式上使用<code class="fe lb lc ld le b">u</code>标志</h1><p id="0ae8" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">有了添加到正则表达式末尾的<code class="fe lb lc ld le b">u</code>标志，我们可以正确解析UTF-16字符，包括表情符号和扩展字符集中的其他字符。</p><p id="8dc2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还会抛出语法错误，以便我们了解它们。如果没有<code class="fe lb lc ld le b">u</code>标志，如果正则表达式中有语法错误，就不会抛出语法错误。</p><p id="e30d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，它让我们在早期发现错误，而不是在定义正则表达式之后运行代码。</p><p id="18d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，不要像下面这样编写代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ec99" class="mq lg iq le b gy mr ms l mt mu">const a = /foo/;<br/>const b = new RegExp('foo');</span></pre><p id="d52b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该这样写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="b726" class="mq lg iq le b gy mr ms l mt mu">const a = /foo/u;<br/>const b = new RegExp('foo', 'u');</span></pre><h1 id="6ee0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="5de7" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">当我们调用<code class="fe lb lc ld le b">parseInt</code>时，基数参数应该被添加，这样它将总是被解析为我们想要的那种数字。</p><p id="47ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还消除了从<code class="fe lb lc ld le b">parseInt</code>返回哪种数字时的任何模糊性。</p><p id="a671" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有<code class="fe lb lc ld le b">await</code>表达式的异步函数可能不需要在异步函数中。</p><p id="af3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应该在正则表达式文字或对象之后添加<code class="fe lb lc ld le b">u</code>标志，这样我们就可以更早地发现正则表达式的语法错误，并正确检查UTF-16字符集中的字符。</p><h1 id="d246" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><strong class="ak">简明英语团队的笔记</strong></h1><p id="57c5" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae kc" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kf ir">JavaScript in Plain English</strong></a><a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>—谢谢，继续学习！</p><p id="41bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还推出了一个YouTube，希望你能通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的简明英语频道</strong> </a>来支持我们</p><p id="7805" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往,“简明英语”希望帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>