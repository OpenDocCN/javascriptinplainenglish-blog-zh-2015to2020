<html>
<head>
<title>Factories Are STILL Better Than Classes In JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">工厂仍然比JavaScript中的类要好</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/factories-are-still-better-than-classes-in-javascript-47f15071904e?source=collection_archive---------1-----------------------#2020-11-24">https://javascript.plainenglish.io/factories-are-still-better-than-classes-in-javascript-47f15071904e?source=collection_archive---------1-----------------------#2020-11-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="36a5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">更新了为什么在JavaScript中应该使用工厂而不是类的想法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f6a4ccc1dc749a7c79bd36780db18bf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EMUmpO8W-Qg3T8kLjWHKig.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://www.pexels.com/@pixabay?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"><strong class="bd kw">Pixabay</strong></a> from <a class="ae kv" href="https://www.pexels.com/photo/adolescent-adult-beauty-blur-459971/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank"><strong class="bd kw">Pexels</strong></a></figcaption></figure><p id="7359" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">写完JS 中的<a class="ae kv" href="https://medium.com/javascript-in-plain-english/why-factories-are-better-than-classes-in-javascript-1248b600b6d4" rel="noopener">为什么工厂比类好，我得到了大量的反馈和指正。</a></p><p id="400c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们借此机会深入研究一下这些建议，以我自己的知识为基础，同时也让任何不熟悉JavaScript的人受益。</p><p id="7d78" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">就当这是对原帖的反驳和延伸吧。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="44aa" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">类实例的公共属性带来了安全问题(以及如何避免)</h1><p id="76ca" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated"><a class="ae kv" href="https://codepen.io/chris898/pen/eYdONbe" rel="noopener ugc nofollow" target="_blank">代码笔1 </a>。</p><p id="bb5a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我最初提出JS类实例容易受到外部属性改变的影响，并认为这是一个缺点。</p><p id="cbfd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">例如，给定一个类<code class="fe mx my mz na b">Car</code>，我们用<code class="fe mx my mz na b">new</code>创建一个实例，并调用<code class="fe mx my mz na b">drive</code>方法。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="c4b1" class="nf mb iq na b gy ng nh l ni nj">class Car {<br/>  constructor(maxSpeed){<br/>    this.maxSpeed = maxSpeed;<br/>  }<br/>  drive(){<br/>    console.log(`driving ${this.maxSpeed} mph!`)<br/>  }<br/>  honk(){<br/>    console.log(`honk!!!`)<br/>  }<br/>}</span><span id="300e" class="nf mb iq na b gy nk nh l ni nj">const car1 = new Car(120)<br/>car1.drive()<br/>#=&gt; "driving 120 mph!"</span></pre><p id="5a2e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">是<code class="fe mx my mz na b">“driving 120 mph!”</code>。到目前为止一切顺利。</p><h2 id="3561" class="nf mb iq bd mc nl nm dn mg nn no dp mk lg np nq mm lk nr ns mo lo nt nu mq nv bi translated">公共属性和函数可以在初始化后更改</h2><p id="d990" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">不仅可以更改对象属性，这些更改还会影响方法的输出。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="e1ed" class="nf mb iq na b gy ng nh l ni nj">car1.maxSpeed = 300<br/>car1.drive()<br/>#=&gt; "driving 300 mph!"</span></pre><p id="26f7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">甚至整个方法都可以被覆盖。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="bb44" class="nf mb iq na b gy ng nh l ni nj">car1.drive = function(){console.log('parked')}<br/>car1.drive()<br/>#=&gt; "parked"</span></pre><p id="4dbe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在大多数情况下，从外部编辑属性和方法似乎是不受欢迎的行为。</p><p id="2503" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">公平地说，这就是JavaScript的本意。但话虽如此，有意的行为并不总是等同于“伟大”或理想的行为。</p><h2 id="6dcc" class="nf mb iq bd mc nl nm dn mg nn no dp mk lg np nq mm lk nr ns mo lo nt nu mq nv bi translated">有防止改变属性的策略</h2><p id="194e" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated"><a class="ae kv" href="https://codepen.io/chris898/pen/BaLBoOZ?editors=1112" rel="noopener ugc nofollow" target="_blank">代码笔2 </a>。</p><p id="f36f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一个建议是通过使用“getter”函数来防止改变值。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="05a0" class="nf mb iq na b gy ng nh l ni nj">class Car {<br/>  constructor(maxSpeed){<br/>    this.defMaxSpeed = maxSpeed;<br/>  }<br/><strong class="na ir">  get maxSpeed(){<br/>    return this.defMaxSpeed<br/>  }</strong><br/>  <br/>  drive(){<br/>    console.log(`driving ${this.maxSpeed} mph!`)<br/>  }<br/>  honk(){<br/>    console.log(`honk!!!`)<br/>  }<br/>}</span></pre><p id="2568" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">注意我们已经添加了<code class="fe mx my mz na b">get maxSpeed()</code>。对象现在将用一个<code class="fe mx my mz na b">this.defMaxSpeed</code>属性初始化，而不是用一个<code class="fe mx my mz na b">this.maxSpeed</code>属性。</p><p id="485c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这可以防止改变的<code class="fe mx my mz na b">maxSpeed</code>影响<code class="fe mx my mz na b">drive()</code>方法。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="b7c0" class="nf mb iq na b gy ng nh l ni nj">const car1 = new Car(120)<br/>car1.drive()<br/>#=&gt; "driving 120 mph!"</span><span id="82a9" class="nf mb iq na b gy nk nh l ni nj">car1.maxSpeed = 300<br/>car1.drive()<br/>#=&gt; "driving 120 mph!"</span></pre><p id="ae00" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">也就是说，我们可以通过从外部更新<code class="fe mx my mz na b">defMaxSpeed</code>来解决这个问题。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="1750" class="nf mb iq na b gy ng nh l ni nj">car1.defMaxSpeed = 300<br/>car1.drive()<br/>#=&gt; "driving 300 mph!"</span></pre><p id="5cb7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我想我们可以想出一个复杂的不可猜测的属性名，但这也会使编码变得不那么有趣。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="285b" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">类实例遭受与“这”相关的范围混淆(以及如何避免它)</h1><p id="4409" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated"><a class="ae kv" href="https://codepen.io/chris898/pen/LYRPRaj?editors=1111" rel="noopener ugc nofollow" target="_blank">代码笔3 </a>。</p><p id="4d4f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">对于JavaScript新手来说,“this”关键字可能会让人感到困惑。</p><p id="5ca7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">下面是一个调用<code class="fe mx my mz na b">$(‘button’).click(car1.drive)</code>返回的例子:</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="e31f" class="nf mb iq na b gy ng nh l ni nj">=&gt; “driving undefined mph!” </span></pre><p id="97d0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">而不是预期的<code class="fe mx my mz na b">“driving 120 mph!”</code>。</p><p id="3112" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated"><em class="nw">原因是</em> <code class="fe mx my mz na b"><em class="nw">this.maxSpeed</em></code> <em class="nw">中的</em> <code class="fe mx my mz na b"><em class="nw">this</em></code> <em class="nw">不再指实例本身。</em></p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="95ac" class="nf mb iq na b gy ng nh l ni nj"><strong class="na ir">//////////<br/>// html //<br/>//////////</strong></span><span id="3fa8" class="nf mb iq na b gy nk nh l ni nj">&lt;button&gt;Drive&lt;/button&gt;</span><span id="bbea" class="nf mb iq na b gy nk nh l ni nj"><strong class="na ir">/////////<br/>// css //<br/>/////////</strong></span><span id="1986" class="nf mb iq na b gy nk nh l ni nj">button {<br/> cursor: pointer;<br/> appearance: none;<br/> border-radius: 4px;<br/> font-size: 1.25rem;<br/> padding: 0.75rem 1rem;<br/> border: 1px solid navy;<br/> background-color: dodgerblue;<br/> color: white;<br/>}</span><span id="e026" class="nf mb iq na b gy nk nh l ni nj"><strong class="na ir">////////<br/>// js //<br/>////////<br/></strong>class Car {<br/>  constructor(maxSpeed){<br/>    this.maxSpeed = maxSpeed;<br/>  }<br/>  drive(){<br/>    console.log(`driving ${this.maxSpeed} mph!`)<br/>  }<br/>  honk(){<br/>    console.log(`honk!!!`)<br/>  }<br/>}<br/>const car1 = new Car(120)</span></pre><p id="715b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在点击按钮触发<code class="fe mx my mz na b">drive()</code>的三种不同方式中，只有最后一种感觉简单明了。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="9bd3" class="nf mb iq na b gy ng nh l ni nj">$('button').click(car1.drive)<br/>$('button').click(car1.drive.bind(car1))<br/>$('button').click(_ =&gt; car1.drive())</span><span id="ec97" class="nf mb iq na b gy nk nh l ni nj">#=&gt; "driving undefined mph!"<br/>#=&gt; "driving 120 mph!"<br/>#=&gt; "driving 120 mph!"</span></pre><p id="244b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我最初的想法是使用工厂来完全跳过“this ”,但事实证明有一种简单的方法来解决“this”和类的范围问题。</p><h2 id="2a16" class="nf mb iq bd mc nl nm dn mg nn no dp mk lg np nq mm lk nr ns mo lo nt nu mq nv bi translated"><strong class="ak">这可以通过箭头函数</strong>解决</h2><p id="5fbc" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated"><a class="ae kv" href="https://codepen.io/chris898/pen/BaLBjNY?editors=1111" rel="noopener ugc nofollow" target="_blank">密码笔4 </a>。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="df51" class="nf mb iq na b gy ng nh l ni nj">class Car {<br/>  constructor(maxSpeed){<br/>    this.maxSpeed = maxSpeed;<br/>  }<br/>  drive = () =&gt; {<br/>    console.log(`driving ${this.maxSpeed} mph!`)<br/>  }<br/>}</span><span id="7e12" class="nf mb iq na b gy nk nh l ni nj">const car1 = new Car(120)<br/>$('button').click(car1.drive)<br/>#=&gt; "driving 120 mph!"</span></pre><p id="50a2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">注意这个问题是如何通过把<code class="fe mx my mz na b">drive(){...}</code>换成<code class="fe mx my mz na b">drive = () =&gt; {...}</code>来解决的。按钮点击现在与<code class="fe mx my mz na b">$(‘button’).click(car1.drive)</code>一起工作。</p><p id="37ea" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在我看来，这似乎是一个很好的解决方案。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="878d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">工厂有额外的内存开销</h1><p id="86df" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">这是无可辩驳的。</p><p id="6246" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">类实例占用的内存更少。这是因为每个唯一的方法只存在一次——在类原型上。</p><p id="16bf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">相比之下，工厂在每个实例上创建每个方法的副本。当我们看一家工厂时，这一点变得很明显。</p><pre class="kg kh ki kj gt nb na nc nd aw ne bi"><span id="4a77" class="nf mb iq na b gy ng nh l ni nj">const Car = (ms) =&gt; {<br/>  const maxSpeed = ms<br/>  <br/>  return {<br/>    drive: () =&gt; console.log(`driving ${maxSpeed} mph!`),<br/>  } <br/>}</span></pre><p id="87cd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里工厂返回一个内部有函数的对象。每个对象内部都有相同的复制函数。</p><p id="6931" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果实例化10k以上的对象，这可能会占用大量内存(我希望有一种简单的方法来测试这一点)。</p><p id="178e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">也就是说，我怀疑在日常开发中，我们需要在浏览器中生成10k个相同对象的频率。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="6f9c" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">工厂和类不是苹果之间的比较</h1><p id="9032" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">我比较了班级和工厂，但这并不完全公平。</p><p id="c2f7" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它们是两种不同的“东西”，来自两种不同的编码范例。</p><p id="0c69" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">工厂遵循函数式编程范式，纯粹是为了实例化对象(实例或类)。</p><p id="d7e9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">类遵循面向对象的编程范式，实际上是对象的模板。</p><p id="91fa" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我已经提到的另一个论点是，所有与类有关的“问题”都只是语言的工作方式。</p></div><div class="ab cl lt lu hu lv" role="separator"><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly lz"/><span class="lw bw bk lx ly"/></div><div class="ij ik il im in"><h1 id="459d" class="ma mb iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">结论</h1><p id="fd79" class="pw-post-body-paragraph kx ky iq kz b la ms jr lc ld mt ju lf lg mu li lj lk mv lm ln lo mw lq lr ls ij bi translated">作为一个JavaScript新手，我确实发现工厂更简单，不容易产生副作用。</p><p id="cc96" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">虽然这可能是由于缺乏理解和经验，但我一直认为我们应该在简单性方面比性能更胜一筹。为什么编码不应该是初学者友好的？</p><p id="40fd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你不同意或可以在这里补充任何东西，我洗耳恭听的反馈！</p><p id="47e9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">一如既往，继续编码！</p></div></div>    
</body>
</html>