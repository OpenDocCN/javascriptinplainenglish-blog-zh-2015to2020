<html>
<head>
<title>Why Proxy is a Gem in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么代理是JavaScript中的瑰宝？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-proxies-in-javascript-are-fantastic-db100ddc10a0?source=collection_archive---------0-----------------------#2020-07-02">https://javascript.plainenglish.io/why-proxies-in-javascript-are-fantastic-db100ddc10a0?source=collection_archive---------0-----------------------#2020-07-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0e0f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">4个实际例子帮助您掌握JavaScript的这一强大特性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/17f660f29f28236d1c7a166085487039.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ok51b2bP1XoBNDbs"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@cebbbinghaus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christopher Robin Ebbinghaus</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="24ca" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">什么是代理？它到底是做什么的？在解释这一点之前，让我们看一个真实世界的例子。</p><p id="370e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们每个人在日常生活中都有很多事情要做，比如看邮件、收快递等等。有些时候，我们可能会感到有些焦虑:我们的邮件列表中有大量的垃圾邮件，需要花费大量的时间来筛选；收到的货物中可能有恐怖分子放置的炸弹，威胁到我们的安全。</p><p id="83b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这时你可能需要一个忠诚的管家。你希望管家帮你做以下事情:在你开始阅读之前，让它检查你的收件箱并删除所有垃圾邮件；当你收到包裹时，让它用专业设备检查包裹，确保里面没有炸弹。</p><p id="30d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，管家是我们的代理。当我们试图做某事时，管家为我们做了额外的事情。</p><p id="77b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们回到JavaScript。我们知道JavaScript是面向对象的编程语言，没有对象就写不出代码。但是JavaScript对象总是裸着运行的，你可以用它们做任何事情。很多时候，这使得我们的代码不太安全。</p><p id="dd9c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ECMAScript2015中引入的代理功能。通过代理，我们可以为对象找到一个忠实的管家，帮助我们增强对象的原有功能。</p><p id="e347" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在最基本的层面上，使用代理的语法如下所示:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="32d1" class="lx ly iq lt b gy lz ma l mb mc">// This is a normal object<br/>let obj = {a: 1, b:2}</span><span id="0172" class="lx ly iq lt b gy md ma l mb mc">// Configure obj with a housekeeper using Proxy<br/>let objProxy = new Proxy(obj, handler)</span></pre><p id="44d7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是一个代码提示。因为我们还没有写处理程序，所以这段代码暂时不会正确运行。</p><p id="4a4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于一个人来说，我们可能会有阅读邮件、收取快递等操作。，管家可以帮我们做。对于一个对象，我们可以读取属性、设置属性等等，这些也可以通过代理对象来增强。</p><p id="3535" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在处理程序中，我们可以列出我们想要代理的动作。例如，如果我们想在控制台中打印出一条语句，同时获取一个对象属性，我们可以这样写:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi me"><img src="../Images/c4d10e637fe06d839fb3670ebab30aed.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L90zE976_kc8dCLbu571kw.png"/></div></div></figure><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="d860" class="lx ly iq lt b gy lz ma l mb mc">let obj = {a: 1, b:2}<br/>// Use Proxy syntax to find a housekeeper for the object<br/>let objProxy = new Proxy(obj, {<br/>  get: function(item, property, itemProxy){<br/>    console.log(`You are getting the value of '${property}' property`)<br/>    return item[property]<br/>  }<br/>})</span></pre><p id="8651" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们的处理程序是:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="891c" class="lx ly iq lt b gy lz ma l mb mc">{<br/>  get: function(item, property, itemProxy){<br/>    console.log(`You are getting the value of '${property}' property`)<br/>    return item[propery]<br/> }</span></pre><p id="5456" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们试图读取对象的属性时，get函数就会执行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mf"><img src="../Images/6282b423ce29a11574f4209a3801c2da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bPZ7vKc_1Rt3mcud7U8GAw.png"/></div></div></figure><p id="4eef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mg mh mi lt b">get</code>函数可以接受三个参数:</p><ul class=""><li id="e43f" class="mj mk iq ky b kz la lc ld lf ml lj mm ln mn lr mo mp mq mr bi translated"><code class="fe mg mh mi lt b">item</code>:是物体本身。</li><li id="87f1" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated"><code class="fe mg mh mi lt b">proerty</code>:您正在尝试读取的物业名称。</li><li id="51be" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated"><code class="fe mg mh mi lt b">itemProxy</code>:是我们刚刚创建的管家对象。</li></ul><p id="21cb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mx">你可能在别处读过关于Proxy的教程，你会注意到我对参数的命名与他们不同。我这样做是为了更接近我之前的例子，以帮助您理解。我希望这对你有用。</em></p><p id="9cd5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么<code class="fe mg mh mi lt b">get</code>函数的返回值就是读取这个属性的结果。因为我们还不想改变任何东西，所以我们只返回原始对象的属性值。</p><p id="f2a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有必要，我们也可以改变结果。例如，我们可以这样做:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi my"><img src="../Images/890856cc9f95e9711aacda7989996949.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ms77uDLGnqnYFMPWhYaFOw.png"/></div></div></figure><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="1845" class="lx ly iq lt b gy lz ma l mb mc">let obj = {a: 1, b:2}</span><span id="c1bf" class="lx ly iq lt b gy md ma l mb mc">let objProxy = new Proxy(obj, {<br/>  get: function(item, property, itemProxy){<br/>    console.log(`You are getting the value of '${property}' property`)<br/>    return item[property] * 2<br/>  }<br/>})</span></pre><p id="fb59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是读取其属性的结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/17b15c21a6cb5b0bc71eeeff992c4c64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UqcZhlCdBKFz_vvUvhaOdw.png"/></div></div></figure><p id="01d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将通过真实的例子来说明这个技巧的实际应用。</p><p id="2527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了拦截对属性的读取，我们还可以拦截对属性的修改。像这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi na"><img src="../Images/98be623432a5643a3424faa8c7e3fe23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BX_fPkMAosNAt1t9gBnxGw.png"/></div></div></figure><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="2b73" class="lx ly iq lt b gy lz ma l mb mc">let obj = {a: 1, b:2}</span><span id="29b1" class="lx ly iq lt b gy md ma l mb mc">let objProxy = new Proxy(obj, {<br/>  set: function(item, property, value, itemProxy){<br/>    console.log(`You are setting '${value}' to '${property}' property`)<br/>    item[property] = value<br/>  }<br/>})</span></pre><p id="5604" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们试图设置对象的属性值时，set函数被触发。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nb"><img src="../Images/9933af20140d9b99e5aa37268a2b3bb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8Z3n0byrTY7tE8pMAzNE0Q.png"/></div></div></figure><p id="574a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为我们需要在设置属性值时传递一个额外的值，所以上面的<code class="fe mg mh mi lt b">set</code>函数比<code class="fe mg mh mi lt b">get</code>函数多接受一个参数。</p><p id="7277" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了拦截对属性的读取和修改，Proxy还可以拦截对对象的总共13个操作。</p><p id="3d8d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">它们是:</p><ul class=""><li id="3145" class="mj mk iq ky b kz la lc ld lf ml lj mm ln mn lr mo mp mq mr bi translated"><strong class="ky ir"> get(item，propKey，itemProxy): </strong>拦截对象属性的读取操作，如<code class="fe mg mh mi lt b">obj.a</code>、<code class="fe mg mh mi lt b">ojb['b']</code></li><li id="7b9c" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated"><strong class="ky ir"> set(item，propKey，value，itemProxy): </strong>拦截对象属性的设置操作，如<code class="fe mg mh mi lt b">obj.a = 1</code>。</li><li id="5f5a" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated"><strong class="ky ir"> has(item，propKey): </strong>拦截<code class="fe mg mh mi lt b">propKey in objProxy</code>的运算，返回一个布尔值。</li><li id="4ec5" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated"><strong class="ky ir"> deleteProperty(item，propKey): </strong>拦截<code class="fe mg mh mi lt b">delete proxy[propKey]</code>的操作，返回一个布尔值。</li><li id="7b4e" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated"><strong class="ky ir"> ownKeys(item): </strong>拦截<code class="fe mg mh mi lt b">Object.getOwnPropertyNames(proxy)</code>、<code class="fe mg mh mi lt b">Object.getOwnPropertySymbols(proxy)</code>、<code class="fe mg mh mi lt b">Object.keys(proxy)</code>、<code class="fe mg mh mi lt b">for...in</code>等操作，返回一个数组。方法返回所有目标对象自身属性的属性名，而<code class="fe mg mh mi lt b">Object.keys()</code>的返回结果只包含目标对象自身的可枚举属性。</li><li id="8f4b" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated"><strong class="ky ir">getOwnPropertyDescriptor(item，propKey): </strong>拦截<code class="fe mg mh mi lt b">Object.getOwnPropertyDescriptor(proxy, propKey)</code>的操作，返回属性的描述符。</li><li id="d484" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated"><strong class="ky ir"> defineProperty(item，propKey，propDesc): </strong> Intercepter这些操作:<code class="fe mg mh mi lt b">Object.defineProperty(proxy, propKey, propDesc）</code>，<code class="fe mg mh mi lt b">Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li><li id="0271" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated"><strong class="ky ir">prevent extensions(item):</strong>拦截<code class="fe mg mh mi lt b">Object.preventExtensions(proxy)</code>的操作，返回一个布尔值。</li><li id="b970" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated"><strong class="ky ir"> getPrototypeOf(item): </strong>拦截<code class="fe mg mh mi lt b">Object.getPrototypeOf(proxy)</code>的操作，返回一个对象。</li><li id="17f1" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated"><strong class="ky ir"> isExtensible(item): </strong>截取<code class="fe mg mh mi lt b">Object.isExtensible(proxy)</code>的操作，返回一个布尔值。</li><li id="c970" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated"><strong class="ky ir"> setPrototypeOf(item，proto): </strong>拦截<code class="fe mg mh mi lt b">Object.setPrototypeOf(proxy, proto)</code>的操作，返回一个布尔值。</li></ul><p id="92ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果目标对象是一个函数，还有两个额外的操作需要拦截</p><ul class=""><li id="0a50" class="mj mk iq ky b kz la lc ld lf ml lj mm ln mn lr mo mp mq mr bi translated"><strong class="ky ir"> apply(item，object，args): </strong>拦截函数调用操作，如<code class="fe mg mh mi lt b">proxy(...args)</code>、<code class="fe mg mh mi lt b">proxy.call(object, ...args)</code>、<code class="fe mg mh mi lt b">proxy.apply(...)</code>。</li><li id="e1de" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated"><strong class="ky ir"> construct(item，args): </strong>拦截代理实例作为构造函数调用的操作，比如<code class="fe mg mh mi lt b">new proxy(...args)</code>。</li></ul><p id="f4f2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有些拦截不常用，就不赘述了。现在让我们进入现实世界的例子，看看代理实际上能为我们做什么。</p></div><div class="ab cl nc nd hu ne" role="separator"><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh ni"/><span class="nf bw bk ng nh"/></div><div class="ij ik il im in"><h1 id="3179" class="nj ly iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">1.实现数组的负索引</h1><p id="f3b3" class="pw-post-body-paragraph kw kx iq ky b kz oa jr lb lc ob ju le lf oc lh li lj od ll lm ln oe lp lq lr ij bi translated">我们知道其他一些编程语言，比如Python，支持对数组的负索引访问。</p><p id="9d0c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">负索引以数组的最后一个位置为起点，向前计数。比如:</p><ul class=""><li id="d295" class="mj mk iq ky b kz la lc ld lf ml lj mm ln mn lr mo mp mq mr bi translated">arr[-1]是数组的最后一个元素。</li><li id="c3d4" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated">arr[-3]是数组中倒数第三个元素。</li></ul><p id="156a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多人认为这是一个非常有用的特性，但不幸的是，JavaScript目前不支持负索引语法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/ad027999da6c5634cc2d0d0d413900b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7r8nmX6eSLv8O8tol7TpUg.png"/></div></div></figure><p id="4418" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是JavaScript中强大的代理给了我们元编程的能力。</p><p id="e6da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以将数组包装成代理对象。当用户试图访问负索引时，我们可以通过代理的get方法拦截这个操作。然后，根据之前定义的规则，将负索引转换为正索引，访问完成。</p><p id="aef6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们从一个基本操作开始:截取数组属性的读取。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/6daabb0a1e1bf77f75375b9b7b735a7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NYhrjKwPuyH9N8JHof79vg.png"/></div></div></figure><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="c54f" class="lx ly iq lt b gy lz ma l mb mc">function negativeArray(array) {<br/>  return new Proxy(array, {<br/>    get: function(item, propKey){<br/>      console.log(propKey)<br/>      return item[propKey]<br/>    }<br/>  })<br/>}</span></pre><p id="23ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的函数可以包装一个数组，所以让我们看看它是如何使用的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/38b27b014fa1b4e6e13b9215425b0787.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AWFMkRaYp3bBy07CzsHmfQ.png"/></div></div></figure><p id="d878" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，我们对数组属性的读取确实被拦截了。</p><p id="9c50" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意:<em class="mx">JavaScript中的对象只能有一个字符串或符号类型的键。当我们写</em> <code class="fe mg mh mi lt b"><em class="mx">arr[1]</em></code> <em class="mx">的时候，其实就是在访问</em> <code class="fe mg mh mi lt b"><em class="mx">arr[‘1’]</em></code> <em class="mx">。关键是字符串</em> <code class="fe mg mh mi lt b"><em class="mx">‘1’</em></code> <em class="mx">，而不是数字</em> <code class="fe mg mh mi lt b"><em class="mx">1</em></code> <em class="mx">。</em></p><p id="b4be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在我们需要做的是:当用户试图访问一个属性，这个属性是一个数组的索引，并且发现它是一个负索引时，那么拦截并相应地处理它；如果属性不是一个指数，或者如果指数是正的，我们不做任何事情。</p><p id="398b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结合以上需求，我们可以编写下面的模板代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/1a6991d166c72b3d7b6070de282ca3d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eG8N0J6bAnNfXgMB3YGzYQ.png"/></div></div></figure><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="6e79" class="lx ly iq lt b gy lz ma l mb mc">function negativeArray(array) {<br/>  return new Proxy(array, {<br/>    get: function(target, propKey){<br/>      if(/** the propKey is a negative index */){<br/>        // translate the negative index to positive<br/>      }<br/>      return target[propKey]<br/>  })<br/>}</span></pre><p id="cf97" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们如何识别负指数呢？很容易出错，所以我要说得更详细一些。</p><p id="22e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，Proxy的get方法会拦截对数组所有属性的访问，包括对数组的一个索引的访问和对数组其他属性的访问。仅当属性名可以转换为整数时，才执行访问数组中元素的操作。我们实际上需要截取这个操作来访问数组中的元素。</p><p id="46b2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过检查一个数组的属性是否可以转换成整数来确定它是否是一个索引。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="d17f" class="lx ly iq lt b gy lz ma l mb mc">Number(propKey) != NaN &amp;&amp; Number.isInteger(Number(propKey))</span></pre><p id="bcde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以，完整的代码可以写成这样:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/447f70d4daa38a1607985830513861c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYN3aeMbtPmo66ig3fRRmg.png"/></div></div></figure><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="511c" class="lx ly iq lt b gy lz ma l mb mc">function negativeArray(array) {<br/>  return new Proxy(array, {<br/>    get: function(target, propKey){<br/>      if (Number(propKey) != NaN &amp;&amp; Number.isInteger(Number(propKey)) &amp;&amp; Number(propKey) &lt; 0) {<br/>        propKey = String(target.length + Number(propKey));<br/>      }<br/>      return target[propKey]<br/>    }<br/>  })<br/>}</span></pre><p id="45a0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/6b231e166716e976fcd177e5e9d4b024.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YLLg2GTg3yn5yX0Psf0oLQ.png"/></div></div></figure><h1 id="01cd" class="nj ly iq bd nk nl ol nn no np om nr ns jw on jx nu jz oo ka nw kc op kd ny nz bi translated">2.数据有效性</h1><p id="889f" class="pw-post-body-paragraph kw kx iq ky b kz oa jr lb lc ob ju le lf oc lh li lj od ll lm ln oe lp lq lr ij bi translated">众所周知，javascript是一种弱类型语言。通常，当一个对象被创建时，它是裸运行的。任何人都可以修改。</p><p id="d27b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是大多数情况下，对象的属性值需要满足某些条件。例如，记录用户信息的对象在其年龄字段中应该有一个大于0的整数，通常小于150。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="e4bf" class="lx ly iq lt b gy lz ma l mb mc">let person1 = {<br/>  name: 'Jon',<br/>  age: 23<br/>}</span></pre><p id="a7b3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，默认情况下，JavaScript不提供安全机制，您可以随意更改该值。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="f594" class="lx ly iq lt b gy lz ma l mb mc">person1.age = 9999<br/>person1.age = 'hello world'</span></pre><p id="0ac7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了使我们的代码更加安全，我们可以用代理来包装我们的对象。我们可以截取对象的set操作，验证age字段的新值是否符合规则。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/660933610e74e61ef3c93a3c821c2cb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OvDxnDCV2SVLe8RnPbTNgQ.png"/></div></div></figure><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="95e9" class="lx ly iq lt b gy lz ma l mb mc">let ageValidate = {<br/>  set (item, property, value) {<br/>    if (property === 'age') {<br/>      if (!Number.isInteger(value) || value &lt; 0 || value &gt; 150) {<br/>        throw new TypeError('age should be an integer between 0 and 150');<br/>      }<br/>    }<br/>    item[property] = value<br/>  }<br/>}</span></pre><p id="d5d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们尝试修改这个属性的值，我们可以看到我们设置的保护机制正在工作。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/93fe6aa3a373430757d00461a21e5064.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_zTey6rh47UXCnvI7sTuDQ.png"/></div></div></figure><h1 id="52a0" class="nj ly iq bd nk nl ol nn no np om nr ns jw on jx nu jz oo ka nw kc op kd ny nz bi translated">3.关联属性</h1><p id="9918" class="pw-post-body-paragraph kw kx iq ky b kz oa jr lb lc ob ju le lf oc lh li lj od ll lm ln oe lp lq lr ij bi translated">很多时候，一个对象的属性是相互关联的。例如，对于存储用户信息的对象，其<a class="ae kv" href="https://en.wikipedia.org/wiki/Postal_code" rel="noopener ugc nofollow" target="_blank">邮政编码</a>和位置是两个高度相关的属性。当用户的邮政编码确定后，他的位置也就确定了。</p><p id="f7ef" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了适应不同国家的读者，我在这里使用一个虚拟的例子。假设位置和邮政编码具有以下关系:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="092d" class="lx ly iq lt b gy lz ma l mb mc">JavaScript Street  --  232200</span><span id="fcbf" class="lx ly iq lt b gy md ma l mb mc">Python Street -- 234422</span><span id="4846" class="lx ly iq lt b gy md ma l mb mc">Golang Street -- 231142</span></pre><p id="08f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是用代码表达他们关系的结果。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="04b3" class="lx ly iq lt b gy lz ma l mb mc">const location2postcode = {<br/>  'JavaScript Street': 232200,<br/>  'Python Street': 234422,<br/>  'Golang Street': 231142<br/>}</span><span id="92fa" class="lx ly iq lt b gy md ma l mb mc">const postcode2location = {<br/>  '232200': 'JavaScript Street',<br/>  '234422': 'Python Street',<br/>  '231142': 'Golang Street'<br/>}</span></pre><p id="224b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后看一个例子:</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="752c" class="lx ly iq lt b gy lz ma l mb mc">let person = {<br/>  name: 'Jon'<br/>}</span><span id="d72a" class="lx ly iq lt b gy md ma l mb mc">person.postcode = 232200</span></pre><p id="c035" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们希望能够在设置<code class="fe mg mh mi lt b">person.postcode=232200</code>时自动触发<code class="fe mg mh mi lt b">person.location='JavaScript Street'</code>。</p><p id="4bb0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是解决方案:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/de6bd50fc4bfd9bc9e149b1a68aa9fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sYLbfeJx4syeXbPcb5NqHg.png"/></div></div></figure><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="e523" class="lx ly iq lt b gy lz ma l mb mc">let postcodeValidate = {<br/>  set(item, property, value) {<br/>    if(property === 'location') {<br/>      item.postcode = location2postcode[value]<br/>      <br/>    }<br/>    if(property === 'postcode'){<br/>      item.location = postcode2location[value]<br/>    }<br/>  }<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ot"><img src="../Images/a1e0c474c34265e0fdd1f3073d31047e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYAiZQEKUzqjt4p4wqz2iw.png"/></div></div></figure><p id="7a61" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们将<code class="fe mg mh mi lt b">postcode</code>和<code class="fe mg mh mi lt b">location</code>绑定在一起。</p><h1 id="e85c" class="nj ly iq bd nk nl ol nn no np om nr ns jw on jx nu jz oo ka nw kc op kd ny nz bi translated">4.私有财产</h1><p id="6f7f" class="pw-post-body-paragraph kw kx iq ky b kz oa jr lb lc ob ju le lf oc lh li lj od ll lm ln oe lp lq lr ij bi translated">我们知道JavaScript从来不支持私有属性。这使得我们在编写代码的时候无法合理地管理访问权限。</p><p id="f633" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，JavaScript社区的惯例是以字符<code class="fe mg mh mi lt b">_</code>开头的字段被视为私有属性。</p><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="0cb4" class="lx ly iq lt b gy lz ma l mb mc">var obj = {<br/>  a: 1,<br/>  _value: 22<br/>}</span></pre><p id="c1e8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述<code class="fe mg mh mi lt b">_value</code>房产被视为私有。但是，需要注意的是，这只是一个约定，在语言层面没有这样的规则。</p><p id="c1a2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了代理，我们可以模拟私有属性特性。</p><p id="0dae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">与普通房产相比，私有房产具有以下特点:</p><ul class=""><li id="efc3" class="mj mk iq ky b kz la lc ld lf ml lj mm ln mn lr mo mp mq mr bi translated">无法读取此属性的值</li><li id="b3c9" class="mj mk iq ky b kz ms lc mt lf mu lj mv ln mw lr mo mp mq mr bi translated">当用户试图访问对象的键时，该属性不明显</li></ul><p id="9d39" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们可以检查前面提到的代理的13个拦截操作，并看到有3个操作需要被拦截。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ou"><img src="../Images/b6caf3d1647c42a51aa2bae587aff2ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJXxkljdQ0pGXHEB2R-fLg.png"/></div></div></figure><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="699c" class="lx ly iq lt b gy lz ma l mb mc">function setPrivateField(obj, prefix = "_"){<br/>  return new Proxy(obj, {<br/>    // Intercept the operation of `propKey in objProxy`<br/>    has: (obj, prop) =&gt; {},</span><span id="3031" class="lx ly iq lt b gy md ma l mb mc">    // Intercept the operations such as `Object.keys(proxy)`<br/>    ownKeys: obj =&gt; {},</span><span id="8add" class="lx ly iq lt b gy md ma l mb mc">    //Intercepts the reading operation of object properties<br/>    get: (obj, prop, rec) =&gt; {})<br/>    });<br/>}</span></pre><p id="70b6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，我们将适当的判断语句添加到模板中:如果发现用户试图访问以<code class="fe mg mh mi lt b">_</code>开头的字段，访问将被拒绝。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ov"><img src="../Images/d6376b9ba6c90c708fa958a72c314173.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3pUBtQQ-KM5IaeJtFdzglg.png"/></div></div></figure><pre class="kg kh ki kj gt ls lt lu lv aw lw bi"><span id="f552" class="lx ly iq lt b gy lz ma l mb mc">function setPrivateField(obj, prefix = "_"){<br/>  return new Proxy(obj, {<br/>    has: (obj, prop) =&gt; {<br/>      if(typeof prop === "string" &amp;&amp; prop.startsWith(prefix)){<br/>        return false<br/>      }<br/>      return prop in obj<br/>    },<br/>    ownKeys: obj =&gt; {<br/>      return Reflect.ownKeys(obj).filter(<br/>        prop =&gt; typeof prop !== "string" || !prop.startsWith(prefix)<br/>      )<br/>    },<br/>    get: (obj, prop) =&gt; {<br/>      if(typeof prop === "string" &amp;&amp; prop.startsWith(prefix)){<br/>        return undefined<br/>      }<br/>      return obj[prop]<br/>    }<br/>  });<br/>}</span></pre><p id="e835" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ow"><img src="../Images/97e173d1beff3c10bd718e40fa8457fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rpwNzSYQyaGKbWdqIsYniQ.png"/></div></div></figure></div></div>    
</body>
</html>