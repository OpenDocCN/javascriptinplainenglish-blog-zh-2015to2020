<html>
<head>
<title>Using the React-Redux useSelector Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用React-Redux useSelector挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-the-react-redux-useselector-hook-778b24d9f693?source=collection_archive---------0-----------------------#2020-05-01">https://javascript.plainenglish.io/using-the-react-redux-useselector-hook-778b24d9f693?source=collection_archive---------0-----------------------#2020-05-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fece6f40b4ff9b7cc6408df24e16fea0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wPxNhaeN8gj0dh7c"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mercantile?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clark Street Mercantile</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9552" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了Redux，我们可以用它在JavaScript应用程序的中央位置存储数据。它可以单独工作，当与React-Redux结合使用时，它也是一个受欢迎的React应用程序状态管理解决方案。</p><p id="48f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看新的钩子React-Redux钩子API。</p><h1 id="0ab5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在React Redux应用程序中使用useSelector挂钩</h1><p id="4bab" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">钩子API由<code class="fe me mf mg mh b">useSelector</code>、<code class="fe me mf mg mh b">useDispatch</code>和<code class="fe me mf mg mh b">useStore</code>钩子组成。</p><p id="b621" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">useSelector</code>挂钩使用一个<code class="fe me mf mg mh b">selector</code>函数从存储中选择数据，并使用另一个函数<code class="fe me mf mg mh b">equalityFn</code>在返回结果之前对它们进行比较，并确定如果来自前一状态和当前状态的数据不同，何时进行渲染。</p><p id="8572" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该调用采用以下格式:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e43a" class="mq lc iq mh b gy mr ms l mt mu">const result : any = useSelector(selector : Function, equalityFn? : Function)</span></pre><p id="7223" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相当于connect中的<code class="fe me mf mg mh b">mapStateToProps</code>。将以整个Redux存储状态作为唯一参数来调用选择器。</p><p id="d878" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">选择器函数可以返回任何值作为结果，而不仅仅是一个对象。选择器的返回值将作为<code class="fe me mf mg mh b">useSelector</code>钩子的返回值。</p><p id="cbcb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个动作被分派时，<code class="fe me mf mg mh b">useSelector</code>将对先前的选择器结果值和当前值做一个简单的比较。</p><p id="5127" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">selector</code>函数不接受<code class="fe me mf mg mh b">ownProps</code>参数。道具可以通过关闭或使用curried选择器来使用。</p><p id="56c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可能在一个函数组件中多次调用<code class="fe me mf mg mh b">useSelector</code>。每个调用都会创建一个对Redux store的单独订阅。React更新批处理行为将导致同一组件中的多个<code class="fe me mf mg mh b">useSelector</code>返回新值，应该只在一次重新呈现中返回。</p><h1 id="f319" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">相等比较和更新</h1><p id="20ba" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">将调用提供的选择器函数，其结果将从<code class="fe me mf mg mh b">useSelector</code>钩子返回。如果选择器运行并返回相同的结果，则可能会返回缓存的结果。</p><p id="029f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">useSelector</code>仅当选择器结果与上一次结果不同时，才强制重新渲染。</p><p id="06f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与<code class="fe me mf mg mh b">connect</code>不同，后者对<code class="fe me mf mg mh b">mapState</code>调用的结果使用浅层相等检查来确定是否需要重新渲染。</p><p id="2043" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想从存储中检索多个值，我们可以多次调用<code class="fe me mf mg mh b">useSelector</code>,每次调用返回一个字段值，使用Reselect或类似的库来创建一个内存化的选择器，该选择器返回一个对象中的多个值，但当其中一个值发生变化时返回一个新的对象。</p><p id="babb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用React-Redux中的<code class="fe me mf mg mh b">shallowEqual</code>函数作为<code class="fe me mf mg mh b">useSelector</code>的<code class="fe me mf mg mh b">equalityFn</code>参数。</p><p id="4ba0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用<code class="fe me mf mg mh b">useSelector</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a9a6" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { Provider, useSelector, useDispatch } from "react-redux";<br/>import { createStore } from "redux";<br/>function count(state = 0, action) {<br/>  switch (action.type) {<br/>    case "INCREMENT":<br/>      return state + 1;<br/>    case "DECREMENT":<br/>      return state - 1;<br/>    default:<br/>      return state;<br/>  }<br/>}</span><span id="67d7" class="mq lc iq mh b gy mv ms l mt mu">const store = createStore(count);</span><span id="d9d1" class="mq lc iq mh b gy mv ms l mt mu">function App() {<br/>  const count = useSelector(state =&gt; state);<br/>  const dispatch = useDispatch();</span><span id="a99a" class="mq lc iq mh b gy mv ms l mt mu">  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;button onClick={() =&gt; dispatch({ type: "INCREMENT" })}&gt;Increment&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; dispatch({ type: "DECREMENT" })}&gt;Decrement&lt;/button&gt;<br/>      &lt;p&gt;{count}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="9d2d" class="mq lc iq mh b gy mv ms l mt mu">const rootElement = document.getElementById("root");<br/>ReactDOM.render(<br/>  &lt;Provider store={store}&gt;<br/>    &lt;App /&gt;<br/>  &lt;/Provider&gt;,<br/>  rootElement<br/>);</span></pre><p id="d853" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们像往常一样创建了商店。然后在<code class="fe me mf mg mh b">App</code>组件中，我们使用<code class="fe me mf mg mh b">useSelector</code>钩子通过传入<code class="fe me mf mg mh b">state =&gt; state</code>函数来获取<code class="fe me mf mg mh b">count</code>。</p><p id="2505" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe me mf mg mh b">dispatch</code>函数传递给<code class="fe me mf mg mh b">useDispatch</code>。</p><p id="7d61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">useSelect</code>钩子的第二个参数如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dbbf" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { Provider, useSelector, useDispatch, shallowEqual } from "react-redux";<br/>import { createStore } from "redux";<br/>function count(state = 0, action) {<br/>  switch (action.type) {<br/>    case "INCREMENT":<br/>      return state + 1;<br/>    case "DECREMENT":<br/>      return state - 1;<br/>    default:<br/>      return state;<br/>  }<br/>}<br/>const store = createStore(count);<br/>function App() {<br/>  const count = useSelector(state =&gt; state, shallowEqual);<br/>  const dispatch = useDispatch();<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;button onClick={() =&gt; dispatch({ type: "INCREMENT" })}&gt;Increment&lt;/button&gt;<br/>      &lt;button onClick={() =&gt; dispatch({ type: "DECREMENT" })}&gt;Decrement&lt;/button&gt;<br/>      &lt;p&gt;{count}&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(<br/>  &lt;Provider store={store}&gt;<br/>    &lt;App /&gt;<br/>  &lt;/Provider&gt;,<br/>  rootElement<br/>);</span></pre><p id="5e6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React-Redux有一个<code class="fe me mf mg mh b">shallowEqual</code>函数来比较数据，以确定何时更新数据。我们还可以定义自己的函数来比较以前和当前的状态，以确定更新。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/d0994d962a6b109b9768fd92cd82781e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vN-zoAkmWvIGHHPH"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@tmwd?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Artem Gavrysh</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7c68" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="81bc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">useSelector</code>钩子从React组件中的Redux存储中获取数据。</p><p id="fe3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要两个参数。第一个参数是返回状态的函数，第二个参数是检查前一个和当前状态是否相等以确定何时更新的函数。</p><h2 id="41e4" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="82ae" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="a6f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>