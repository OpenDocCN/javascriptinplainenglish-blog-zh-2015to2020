<html>
<head>
<title>Node.js Best Practices — Syntax Issues</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js最佳实践—语法问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-best-practices-syntax-issues-ec3a57a16218?source=collection_archive---------6-----------------------#2020-08-11">https://javascript.plainenglish.io/node-js-best-practices-syntax-issues-ec3a57a16218?source=collection_archive---------6-----------------------#2020-08-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fb54677f553040d70bda4d3b36227b14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*-vC6fXpG7jEW8y_y"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@lightupphotos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cristina Anne Costello</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f06b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将探讨在编写Node应用程序时应该遵循的一些最佳实践。</p><h1 id="5db8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在同一行上启动代码块的花括号</h1><p id="5431" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">大括号应该与开始语句在同一行。</p><p id="7308" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3f2a" class="mn lc iq mj b gy mo mp l mq mr">function foo() <br/>{<br/>  // code block<br/>}</span></pre><p id="3331" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="67d0" class="mn lc iq mj b gy mo mp l mq mr">function foo() {<br/>  // code block<br/>}</span></pre><p id="18b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这有助于我们避免意外结果。</p><p id="0190" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8323" class="mn lc iq mj b gy mo mp l mq mr">function foo()<br/>{<br/>  return;<br/>  { <br/>    bar: "fantastic"<br/>  };<br/>}</span></pre><p id="8df7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe ms mt mu mj b">return</code>和对象被认为是分开的。</p><p id="203e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们把开头的花括号放在<code class="fe ms mt mu mj b">return</code>旁边，那么它们将被认为是一个陈述。</p><h1 id="cf91" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">正确区分报表</h1><p id="55cb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该适当地分开陈述。</p><p id="4771" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c7e0" class="mn lc iq mj b gy mo mp l mq mr">function doThing() {<br/>  // ...<br/>}<br/><br/>doThing()</span><span id="8922" class="mn lc iq mj b gy mv mp l mq mr">const items = [1, 2, 3]<br/>items.forEach(console.log)</span></pre><p id="65aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，我们应该避免拼写错误，比如:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c428" class="mn lc iq mj b gy mo mp l mq mr">const m = new Map()<br/>const a = [1,2,3]<br/>[...m.values()].forEach(console.log)</span></pre><p id="9173" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后两行被认为是相同的语句，将引发语法错误。</p><p id="0cd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个例子是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e1d9" class="mn lc iq mj b gy mo mp l mq mr">const count = 2<br/>(function foo() {<br/>  // do something<br/>}())</span></pre><p id="c751" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">2被认为是一个新行上带有括号的函数。</p><p id="1c8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免所有这些问题，我们应该用分号把它们分开。</p><h1 id="61fe" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">说出我们的职能</h1><p id="8635" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该给函数命名，以便在调试时可以按名称跟踪函数。</p><p id="3d4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们发现匿名函数的内存消耗存在严重问题，则使用核心转储进行调试可能是一个挑战。</p><h1 id="be2f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对变量、常量、函数和类使用命名约定</h1><p id="8da9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">变量、常量、函数和类的命名约定应遵循通用约定。</p><p id="cb56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">命名常量、变量和函数时应使用小写camel。</p><p id="00e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上camel大小写应用于类。</p><p id="ddf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这有助于我们区分普通变量或函数和类。</p><p id="23d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们应该使用描述性名称，但要保持简短。</p><h1 id="6758" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">比起let，更喜欢const，抛弃var</h1><p id="8085" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mj b">var</code>不能再用来声明变量了。</p><p id="02f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们的范围很微妙。</p><p id="91ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">let</code>和<code class="fe ms mt mu mj b">const</code>都是区块划分的，所以能找到它们的地方很清楚。</p><p id="93b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">const</code>比<code class="fe ms mt mu mj b">let</code>更好，因为我们不能将它们重新分配给新值。</p><h1 id="33a2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">首先需要模块，而不是内部函数</h1><p id="8c64" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">模块应该在模块的顶部是必需的，以便我们可以在模块加载时发现错误和其他问题。</p><p id="c77b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它们是内部函数，那么只有当我们运行代码时，才能看到<code class="fe ms mt mu mj b">require</code>的问题。</p><p id="f85f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以这不是个好主意。</p><p id="9b2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，<code class="fe ms mt mu mj b">require</code> s由Node同步运行，所以如果它们花费很长时间，那么它们可能会阻塞<code class="fe ms mt mu mj b">require</code>之后的代码。</p><h1 id="f2ce" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">按文件夹要求模块，而不是直接按文件</h1><p id="f610" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该放置一个<code class="fe ms mt mu mj b">index.js</code>文件，它公开了模块的间隔，这样消费者就可以通过它。</p><p id="cc41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们可以创建一个界面，在不违反合约的情况下使未来的更改变得更容易。</p><p id="684a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="dacd" class="mn lc iq mj b gy mo mp l mq mr">module.exports.foo = require("./foo");<br/>module.exports.bar = require("./bar");</span></pre><p id="66d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="beea" class="mn lc iq mj b gy mo mp l mq mr">module.exports.foo = require("./foo/foo.js");<br/>module.exports.bar = require("./bar/bar.js");</span></pre><p id="c753" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以避免直接在文件夹中导入JavaScript模块。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/70b679ee0b20fdd75b4d062b6f4b3a14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ndNuujCk5Oa5bUZf"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@xianggao?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Xiang Gao</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="87eb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="e972" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该考虑语法变化，使我们的生活更容易，并避免错误。</p><h2 id="1041" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="cf97" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>