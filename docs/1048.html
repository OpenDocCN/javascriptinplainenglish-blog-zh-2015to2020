<html>
<head>
<title>Write a Better Deep Clone Function in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript写一个更好的深度克隆函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/write-a-better-deep-clone-function-in-javascript-d0e798e5f550?source=collection_archive---------1-----------------------#2020-01-21">https://javascript.plainenglish.io/write-a-better-deep-clone-function-in-javascript-d0e798e5f550?source=collection_archive---------1-----------------------#2020-01-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="92e4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你的面试官问你这个问题，其实是想考察你的后续知识。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/acafae27435092388194f960585c6c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1E5VWYs6e01OyIRg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@hishahadat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Shahadat Rahman</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0776" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">网上有很多关于深度克隆的文章，但说实话，作为面试官，我觉得很多代码实现都是不合格的。现在我从面试官的角度给大家展示一下如何回答这个问题。</p><p id="429c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在阅读本文之前，问自己三个问题:</p><ul class=""><li id="8d6b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">你真的明白深度克隆是什么意思吗？</li><li id="55f0" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在面试官眼中，怎样的深度克隆功能才算合格？</li><li id="bc77" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如何写出更好的深度克隆函数？</li></ul><p id="0977" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本文将带您逐步了解创建更好的深度克隆函数的过程。</p><h1 id="8a1e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">深层克隆和浅层克隆的定义</h1><p id="b9a8" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">虽然深度克隆已经讨论过很多次了，但是很多读者还是不太熟悉这个概念，所以我再介绍一下。</p><p id="7c69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浅克隆尽可能少地重复。集合的浅层克隆是集合结构的副本，而不是元素。使用浅层克隆，两个集合现在共享单独的元素。</p><p id="b70e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">深度克隆复制一切。集合的深层克隆是两个集合，其中原始集合中的所有元素都被复制。</p><p id="6bd4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">浅层克隆:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nd"><img src="../Images/fff3fbe3012d94aee590ce823a3fad0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*skszDzvbXznciGqT_TeF0g.png"/></div></div></figure><p id="6b5d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">深层克隆:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/4cad1242ed303fc6ff267fec5a9d6093.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zsDcbwKpb3JCo7SnlwKysg.png"/></div></div></figure><p id="df6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们切入正题:</p><h1 id="b2d4" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">乞丐版</h1><p id="5089" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在不使用第三方库的情况下，我们想要深度复制一个对象最常见的方法就是使用这个方法。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="9e10" class="nk mh iq ng b gy nl nm l nn no">JSON.parse(JSON.stringify(target));</span></pre><p id="764b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法非常简单，可以在大多数应用程序中使用，但是它仍然有一些缺点，比如复制函数、循环引用等等。</p><p id="467c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很明显，光说这些是过不了面试的。接下来，让我们手动实现一个深度复制功能。</p><h1 id="6c80" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">基本版本</h1><p id="0ac9" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">如果是浅层克隆，我们可以很容易地编写下面的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="2e00" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">创建一个新对象，遍历要克隆的目标对象，然后添加要克隆的目标对象的属性，并返回。</p><p id="46e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果是深度克隆，考虑到我们复制的目标对象不知道它有多深，我们可以使用递归来解决问题，并稍微重写代码:</p><ul class=""><li id="724c" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如果它是原始数据类型，就不需要进一步的复制，我们可以直接返回它</li><li id="a51c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">如果是引用类型，那么我们可以创建一个新对象，遍历需要克隆的目标对象，在执行深度复制后，将需要克隆的目标对象的属性依次添加到新对象中</li></ul><p id="7746" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">很容易理解，如果有更深的对象可以递归，直到属性是原始类型，那么我们就完成了一个简单的深度复制:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="93e0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们可以测试这个函数。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="6a6d" class="nk mh iq ng b gy nl nm l nn no">const target = {<br/>    field1: 1,<br/>    field2: undefined,<br/>    field3: 'value',<br/>    field4: {<br/>        child: 'child',<br/>        child2: {<br/>            child2: 'child2'<br/>        }<br/>    }<br/>};</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/27c34db5add9a3399a332bf382bf575c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JX5eECalJ4N9P1Tdm1T7Qg.png"/></div></div></figure><p id="1bf6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是最基本版本代码的深层拷贝，允许你向面试官展示你可以递归地解决问题。但显然它有很多缺陷，比如没有考虑数组。</p><h1 id="2514" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">考虑数组</h1><p id="4420" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在以前的版本中，我们只考虑普通对象进行初始化，所以我们只需要稍微修改一下初始化代码，使其与数组兼容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e1be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后添加一个新的测试。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="a103" class="nk mh iq ng b gy nl nm l nn no">const target = {<br/>    field1: 1,<br/>    field2: undefined,<br/>    field3: {<br/>        child: 'child'<br/>    },<br/>    field4: [2, 4, 8]<br/>};</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/002e3f92b8b5b2cc9dfc969419065555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GxnTNFD3ToVP3dZ4YPsv1A.png"/></div></div></figure><p id="e2bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，没问题。我们的代码离伟大又近了一小步。</p><h1 id="f582" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">循环引用</h1><p id="1f62" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">如果我们执行以下测试案例:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="6349" class="nk mh iq ng b gy nl nm l nn no">const target2 = {<br/>    field1: 1,<br/>    field2: undefined,<br/>    field3: {<br/>        child: 'child'<br/>    },<br/>    field4: [2, 4, 8]<br/>};<br/>target2.target2 = target2;</span></pre><p id="e334" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以看到以下结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/5fbcb800be00da1cc04bdb9e51d11acd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ASZkV13dyBqeJ32ka-J9iQ.png"/></div></div></figure><p id="18f7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，堆栈内存溢出是由递归进入无限循环引起的。</p><p id="d851" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">原因是上面的对象有一个循环引用，其中对象的属性直接或间接引用自身:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/0d871ba7933840208df82bb0b107b236.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lU5MNVynqxvLngDfD_lg0A.png"/></div></div></figure><p id="0029" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决循环引用问题，我们可以创建一个额外的存储空间来存储当前对象和被复制对象之间的关系。当我们需要复制当前对象时，我们首先去存储空间查找我们是否已经复制了这个对象，如果是就返回，如果不是就继续复制，这巧妙地解决了循环引用问题。</p><p id="18cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个存储空间，需要能够以键-值的形式存储数据，并且键可以是引用类型，所以我们可以选择Map。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b58d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要执行上面的测试用例:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/cb38b9fdc62df5773e905fb681503d5e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vuTZvbV6tPFUDLChgylKUQ.png"/></div></div></figure><p id="ff2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，执行是无错误的。</p><h1 id="219b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">通过WeakMap改进代码</h1><p id="c773" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">接下来，我们可以用一个<code class="fe nw nx ny ng b">WeakMap</code>代替<code class="fe nw nx ny ng b">Map</code>来让代码变得更好。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="7752" class="nk mh iq ng b gy nl nm l nn no">function clone(target, map = new WeakMap()) {<br/>    // ...<br/>};</span></pre><p id="52af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们为什么要这么做？WeakMap是这样做的:</p><blockquote class="nz oa ob"><p id="99d3" class="kw kx oc ky b kz la jr lb lc ld ju le od lg lh li oe lk ll lm of lo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="noopener ugc nofollow" target="_blank"/><code class="fe nw nx ny ng b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">WeakMap</strong></a></code><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap" rel="noopener ugc nofollow" target="_blank">对象是一个键/值对的集合，其中的键被弱引用。键必须是对象，值可以是任意值。</a></p></blockquote><p id="3650" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那什么是弱引用呢？</p><blockquote class="nz oa ob"><p id="b0ae" class="kw kx oc ky b kz la jr lb lc ld ju le od lg lh li oe lk ll lm of lo lp lq lr ij bi translated">在计算机编程中，与强引用不同，<strong class="ky ir">弱引用</strong>是不保护被引用对象不被垃圾收集器收集的引用。弱引用仅引用了<em class="iq">的对象——意味着“到达该对象的每个引用链包括至少一个弱引用作为链接”——被认为是<em class="iq">弱可达的，</em>并且可以被视为不可达的，因此可以在任何时候被收集。一些垃圾收集语言具有或支持各种级别的弱引用，如C#、Java、Lisp、OCaml、Perl、Python和PHP版本以来。</em></p></blockquote><p id="7dfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们通过<code class="fe nw nx ny ng b">const obj = {}</code>创建一个对象时，默认创建一个强引用对象。我们必须手动放置<code class="fe nw nx ny ng b">obj = null</code>，以便垃圾收集机制释放它。但如果是弱引用对象，垃圾回收机制会自动帮我们释放。</p><p id="d0da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如:如果我们使用一个<code class="fe nw nx ny ng b">Map</code>，那么对象之间就有很强的引用关系:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="4447" class="nk mh iq ng b gy nl nm l nn no">let obj = { name : 'Jon Snow'}</span><span id="4e8b" class="nk mh iq ng b gy og nm l nn no">const target = new Map();</span><span id="3700" class="nk mh iq ng b gy og nm l nn no">target.set(obj,'a man from Game of Thrones');</span><span id="cde4" class="nk mh iq ng b gy og nm l nn no">obj = null;</span></pre><p id="121d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">即使我们手动释放了<code class="fe nw nx ny ng b">obj</code>，<code class="fe nw nx ny ng b">target</code>仍然对<code class="fe nw nx ny ng b">obj</code>有很强的引用，所以它的内存无法释放。</p><p id="8bd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以切换到<code class="fe nw nx ny ng b">WeakMap</code>:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="e3c1" class="nk mh iq ng b gy nl nm l nn no">let obj = { name : 'Jon Snow'}</span><span id="7ea6" class="nk mh iq ng b gy og nm l nn no">const target = new WeakMap();</span><span id="c2ca" class="nk mh iq ng b gy og nm l nn no">target.set(obj,'a man from Game of Thrones');</span><span id="d007" class="nk mh iq ng b gy og nm l nn no">obj = null;</span></pre><p id="c6f6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果是<code class="fe nw nx ny ng b">WeakMap</code>，<code class="fe nw nx ny ng b">target</code>和<code class="fe nw nx ny ng b">obj</code>有弱引用关系。<code class="fe nw nx ny ng b">obj</code>将在下次执行垃圾收集机制时被释放。</p><p id="a98e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下，如果我们复制一个非常大的对象，使用<code class="fe nw nx ny ng b">Map</code>会导致非常大的内存消耗，我们需要手动清除贴图的属性来释放内存，而<code class="fe nw nx ny ng b">WeakMap</code>将帮助我们解决这个问题。</p><p id="322a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">之前很多人不明白<code class="fe nw nx ny ng b">WeakMap</code>和弱引用是什么意思。通过这个例子，希望能帮助你理解以上两个概念。</p><p id="0122" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了能够考虑循环引用，你已经向面试官展示了你在考虑整个事情。如果你能用一个<code class="fe nw nx ny ng b">WeakMap</code>来解决问题，并且清楚地向面试官解释你为什么这么做，那么你的代码在面试官眼里应该是合格的。</p><h1 id="8c57" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">性能优化</h1><p id="5407" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在上面的代码中，我们使用<code class="fe nw nx ny ng b">for in</code>来遍历数组和对象。其实<code class="fe nw nx ny ng b">for in</code>在遍历的时候效率非常低。让我们比较三个常见环路<code class="fe nw nx ny ng b">for</code>、<code class="fe nw nx ny ng b">while</code>和<code class="fe nw nx ny ng b">for in</code>的性能:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/fb086002119d587ed6e4dbd0dfdf1e33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46SwGki4YZOV-BvS7nBbvg.png"/></div></div></figure><p id="eb6c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如您所看到的，<code class="fe nw nx ny ng b">while</code>效果最好，因此我们可以想出一个办法将<code class="fe nw nx ny ng b">for in</code>遍历改为<code class="fe nw nx ny ng b">while</code>遍历。</p><p id="d363" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，让我们用<code class="fe nw nx ny ng b">while</code>来实现一个可以遍历数组的工具函数。</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="0f44" class="nk mh iq ng b gy nl nm l nn no">function forEach(array, iteratee) {<br/>    let index = -1;<br/>    const length = array.length;<br/>    while (++index &lt; length) {<br/>        iteratee(array[index], index);<br/>    }<br/>    return array;<br/>}</span></pre><p id="2880" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数有两个参数，一个是数组，另一个是处理数组中元素的回调函数。回调函数接收两个参数:值和索引。</p><p id="4385" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来重写我们的克隆函数:遍历一个数组时，用<code class="fe nw nx ny ng b">forEach</code>直接遍历；当遍历一个对象时，使用<code class="fe nw nx ny ng b">Object.keys</code>检索该对象的所有键进行遍历:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c442" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以做一个性能测试:</p><pre class="kg kh ki kj gt nf ng nh ni aw nj bi"><span id="91ee" class="nk mh iq ng b gy nl nm l nn no">const target = {<br/>    field1: 1,<br/>    field2: undefined,<br/>    field3: {<br/>        child: 'child'<br/>    },<br/>    field4: [2, 4, 8],<br/>    f: { f: { f: { f: { f: { f: { f: { f: { f: { f: { f: { f: {} } } } } } } } } } } },<br/>};</span><span id="c416" class="nk mh iq ng b gy og nm l nn no">target.target = target;</span><span id="7d47" class="nk mh iq ng b gy og nm l nn no">console.time();<br/>const result = clone1(target);<br/>console.timeEnd();</span><span id="73d2" class="nk mh iq ng b gy og nm l nn no">console.time();<br/>const result2 = clone2(target);<br/>console.timeEnd();</span></pre><p id="f054" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(<em class="oc">为了避免你的误解，方便你复制代码，我又写了相关函数。</em>)</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="e10b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">结果:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/8e28d1bda47da67e50911cafc608c78b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z5GfkNqyedDG7cgh0N_JIg.png"/></div></div></figure><p id="cbc2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，我们的性能优化是有效的。</p><h1 id="6bb7" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">其他数据类型</h1><p id="b0a5" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">在上面的代码中，我们只考虑了普通对象和数组对象，实际上所有的引用类型远不止这两个。</p><p id="7c57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对象可以是数组、函数、映射等。当我们尝试深度克隆时，它们是不同的。如果我们想得到对象的具体类型，应该怎么做？</p><p id="36d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ECMAScript具有以下规则:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oj"><img src="../Images/6424c37e0cb5f39675a052580d90b8f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*68gc-uLUOYyDqHfs.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">From EcmaScript</figcaption></figure><p id="ae1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于不同的对象，调用<em class="oc">object . prototype . tostring</em>时会返回不同的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/5ced0eafd503a56f246f57cdbb36aabf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-KYFV9bh0aJwlIms.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">From Chrome‘s Console</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/b2363afd92626b14fd9c2cd8226f914a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*u3bjXpm1Ja2pQEMLChHiNw.png"/></div></div></figure><p id="defe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">而且<em class="oc">object . prototype . tostring()</em>的返回值始终是'<strong class="ky ir"> <em class="oc">【对象</em></strong><em class="oc">'</em>+'<strong class="ky ir"><em class="oc">标签</em></strong><em class="oc">'</em>+'<strong class="ky ir"><em class="oc">]</em></strong>'。如果只想要中间的<em class="oc">标签</em>，可以通过正则表达式或者<em class="oc">string . prototype . slice()</em>删除两边的字符。</p><p id="d557" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们可以写这个函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="7b6f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于任何特定的类型，我们简单地把它们分成两类:</p><ul class=""><li id="49af" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">可以继续遍历的类型，比如Map，Set。</li><li id="36fe" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">不能继续遍历的类型，比如函数。</li></ul><p id="9fcd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们应该为它们编写不同的代码。</p><h2 id="ebf3" class="nk mh iq bd mi om on dn mm oo op dp mq lf oq or ms lj os ot mu ln ou ov mw ow bi translated">可以继续遍历的类型</h2><p id="990f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">普通对象和数组对象是可以连续遍历的数据类型。我们之前已经讨论过了。另外，<code class="fe nw nx ny ng b">Map</code>和<code class="fe nw nx ny ng b">Set</code>可以继续穿越。这里只讨论这四种情况。至于其他情况，你可以自己去探索。</p><p id="d099" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nw nx ny ng b">Map</code>和<code class="fe nw nx ny ng b">Set</code>的遍历非常简单。它们都提供了<code class="fe nw nx ny ng b">forEach</code>方法来遍历。所以我们只需要稍微修改一下前面的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="afe4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了方便，我还在上面的代码中写了测试用例，下面是上面代码的运行结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ox"><img src="../Images/ea0f5ceeacf858e943311fc1f95aba49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tUzoCshmeH0FbRjoHEsfrg.png"/></div></div></figure><h2 id="a949" class="nk mh iq bd mi om on dn mm oo op dp mq lf oq or ms lj os ot mu ln ou ov mw ow bi translated">不能继续遍历的类型</h2><p id="574f" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">其他数据类型，如<code class="fe nw nx ny ng b">Boolean</code>、<code class="fe nw nx ny ng b">Number</code>、<code class="fe nw nx ny ng b">String</code>、<code class="fe nw nx ny ng b">Date</code>和<code class="fe nw nx ny ng b">Error</code>，它们本身是不可遍历的，所以我们可以直接使用它们的构造函数和原始数据来创建一个新的对象。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><h1 id="0bd8" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">结论</h1><p id="9637" class="pw-post-body-paragraph kw kx iq ky b kz my jr lb lc mz ju le lf na lh li lj nb ll lm ln nc lp lq lr ij bi translated">下面是最终的代码和测试:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="np nq l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oy"><img src="../Images/5d6d9987e96b7ee72b6813883d9df40d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*izVJrizvOhTrx5yXxCEV7A.png"/></div></div></figure><p id="da10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如你所见，在《深度克隆》中隐藏着许多知识。只有深入全面的思考，才能从众多面试官中脱颖而出。</p></div></div>    
</body>
</html>