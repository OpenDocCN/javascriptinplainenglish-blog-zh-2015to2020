<html>
<head>
<title>How to implement loose coupling, high cohesion in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中实现松耦合、高内聚</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implementing-loose-coupling-high-cohesion-with-classes-in-javascript-422c52bfbec?source=collection_archive---------0-----------------------#2020-03-29">https://javascript.plainenglish.io/implementing-loose-coupling-high-cohesion-with-classes-in-javascript-422c52bfbec?source=collection_archive---------0-----------------------#2020-03-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6e5550c187f829a030e6fbe4026564f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C2crElnGWQ3IeSS5yZ6czg.jpeg"/></div></div></figure><p id="254c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">开发人员应该努力编写干净、可维护的代码。编程中要学习的一个关键原则是如何实现松耦合和高内聚。</p><p id="c190" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在本文中，我们将使用JavaScript类来实现这些设计模式，并讨论为什么它们使代码更易于维护。</p><p id="dc82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您可以在此处查看资源库中的代码示例:</p><p id="fd20" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://gitlab.com/sundry/javascript/gamelib" rel="noopener ugc nofollow" target="_blank">https://gitlab.com/sundry/javascript/gamelib</a></p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="944e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">什么是松耦合？</p><blockquote class="lb lc ld"><p id="4ad3" class="jv jw le jx b jy jz ka kb kc kd ke kf lf kh ki kj lg kl km kn lh kp kq kr ks ig bi translated">松散耦合指的是一个代码组件对另一个代码组件的内部工作有多少了解。如果它依赖于对某个组件了解太多，那么它被认为是高度耦合的。当一个组件不太了解其他组件的内部工作时，它被认为是松散耦合的。</p></blockquote><p id="cde5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">什么是高凝聚力？</p><blockquote class="lb lc ld"><p id="b476" class="jv jw le jx b jy jz ka kb kc kd ke kf lf kh ki kj lg kl km kn lh kp kq kr ks ig bi translated">高内聚指的是定义非常好的组件。这意味着它只服务于一个目的，而且它很好地实现了这个目的。如果你有一个从数据库读取数据、发送电子邮件、打印文档的组件，那么它就没有高内聚。每一个都应该被分离成它自己的组件。通过让一个组件只做一件事，您可以获得很多好处，比如只测试您需要的东西，分离关注点，以及易于维护。</p></blockquote><p id="0df2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们可以用类在JavaScript中实现这些特性。您也可以使用函数，但是在本文中，我们将演示如何使用类和依赖注入。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="884f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于这个例子，我已经开始了一个小游戏库，它将使用HTML画布来绘制某些形状。为了演示这些原理，我将在画布上绘制形状，例如圆形和正方形。</p><p id="24a1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，让我们从展示一个以不可维护的方式实现一切的类开始。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="5a6c" class="lr ls in ln b gy lt lu l lv lw">export default class Shape {<br/>  constructor(props) {<br/>    this._type = props.type;<br/>    this._text = props.text || '';<br/>    this._transform = props.transform || { x: 0, y: 0 };<br/>    this._radius = props.radius || 20;<br/>    this._width = props.width || 0;<br/>    this._height = props.height || 0;<br/>  }</span><span id="d1d5" class="lr ls in ln b gy lx lu l lv lw">  update({ context }) {<br/>    context.beginPath();<br/>    switch (this._type) {<br/>      case 'circle':<br/>       context.arc(<br/>         this._transform.x,<br/>         this._transform.y,<br/>         this._radius,<br/>         0,<br/>         2 * Math.PI<br/>       );<br/>       context.fill();<br/>       context.stroke();<br/>       break;<br/>     case 'square':<br/>       context.fillRect(<br/>         this._transform.x,<br/>         this._transform.y,<br/>         this._width,<br/>         this._height<br/>       );<br/>       break;<br/>     default:<br/>       break;<br/>   }<br/>}</span></pre><p id="e47a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">仔细阅读这段代码，我们可以看到它是一个类，接受一种形状，绘制形状的x和y坐标，如果是圆形，接受半径，如果是正方形，接受宽度和高度。</p><p id="275a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">该类还有一个更新方法，该方法使用开关来确定要绘制的形状类型。</p><p id="d34c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个类使用了一种类型，将它耦合到某种类型的形状上，从而引入了依赖关系。对于每种类型的形状，我们都必须在我们的形状类中实现它自己的规则。通过在一个类中实现每种类型的形状，我们不需要松散耦合和高内聚。</p><p id="fd82" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果我们要实现每个形状，文件将成为维护的负担。例如，如果我们想对circle实现进行更改，我们需要读取我们甚至不关心的代码。此外，我们可能会对square实现产生副作用。</p><p id="a5d4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">圆必须知道宽度和高度，这是更大的开销，因为它只需要知道半径。广场的反面。它需要知道宽度和高度，但不知道半径。通过这样做，我们引入了甚至没有被有效使用的代码。</p><p id="37bd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">因此，让我们重构它，以显示类和继承，以及这如何也能导致高度耦合的组件。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="ab68" class="lr ls in ln b gy lt lu l lv lw">export default class Shape {<br/>  constructor(props) {<br/>    this._transform = props.transform || { x: 0, y: 0 };<br/>  }</span><span id="a421" class="lr ls in ln b gy lx lu l lv lw">  update({ context }) {}<br/>}</span></pre><p id="8de9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个父类不需要知道它是什么类型的形状，它只需要知道一个变换。但是由于我们正在演示继承，任何子组件现在都与父类高度耦合。如果父母有任何变化，都会影响到孩子。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="6de0" class="lr ls in ln b gy lt lu l lv lw">import Shape from './Shape';</span><span id="627a" class="lr ls in ln b gy lx lu l lv lw">export default class Circle extends Shape {<br/>  constructor(props) {<br/>    super(props);<br/>    this._radius = props.radius || 20;<br/>  }</span><span id="6108" class="lr ls in ln b gy lx lu l lv lw">  update({ context }) {<br/>    context.beginPath();<br/>    context.arc(<br/>      this._transform.x,<br/>      this._transform.y,<br/>      this._radius,<br/>      0,<br/>      2 * Math.PI<br/>    );<br/>    context.fill();<br/>    context.stroke();<br/>  }<br/>}</span></pre><p id="6b2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Circle类不需要知道它是什么类型。它已经知道了。它有很高的凝聚力，因为它只关心画一个圆。如果我们在圆形类中改变任何东西，都不会在方形类中产生任何副作用。然而，由于它必须从Shape类继承，它现在必须了解父类的内部工作方式。</p><p id="e542" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">所以让我们一起去掉Shape类，创建一个可以注入到每个形状中的Transform类。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="f307" class="lr ls in ln b gy lt lu l lv lw">export default class Transform {<br/>  _x = 0;<br/>  _y = 0;<br/>  constructor(props) {<br/>    this._x = props.x || 0;<br/>    this._y = props.y || 0;<br/>  }<br/>  get x() {<br/>    return this._x;<br/>  }<br/>  set x(x) {<br/>    this._x = x;<br/>  }<br/>  get y() {<br/>    return this._y;<br/>  }<br/>  set y(y) {<br/>    this._y = y;<br/>  }<br/>}</span></pre><p id="549d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以重写我们的Square类来使用将要注入的Transform类。</p><pre class="li lj lk ll gt lm ln lo lp aw lq bi"><span id="e26b" class="lr ls in ln b gy lt lu l lv lw">export default class Square {<br/>  constructor(props) {<br/>    this._width = props.width || 0;<br/>    this._height = props.height || 0;<br/>    this._transform = props.transform;<br/>  }</span><span id="2ba6" class="lr ls in ln b gy lx lu l lv lw">  update({ context }) {<br/>    context.beginPath();<br/>    context.fillRect(<br/>      this._transform.x,<br/>      this._transform.y,<br/>      this._width,<br/>      this._height<br/>    );<br/>  }<br/>}</span></pre><p id="16fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在我们可以注入所需的任何类型的转换。我们与父Shape类的耦合度不高，并且我们具有高度的内聚性，因为我们有不同的关注点，并且将逻辑与Square和Circle类分开。</p><p id="e361" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">结果:</p><figure class="li lj lk ll gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ly"><img src="../Images/3cccec3ab5124b14479d150c9cfea6cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-n83dKTRZRvLVFrJBx1LOA.png"/></div></div></figure><p id="e1ee" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">非常现代的艺术，如果我这么说的话。</p></div><div class="ab cl ku kv hr kw" role="separator"><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz la"/><span class="kx bw bk ky kz"/></div><div class="ig ih ii ij ik"><p id="65f3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">总之，使用松耦合和高内聚的原则编写代码的原因是，我们可以将我们的逻辑分成不同的关注点，维护代码而不会产生副作用和可测试性，并且不用编写完成所有事情的庞大组件。</p></div></div>    
</body>
</html>