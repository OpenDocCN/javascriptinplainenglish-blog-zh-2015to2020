# JavaScript 生成器的基础知识

> 原文：<https://javascript.plainenglish.io/the-basics-of-javascript-generators-f89c9b0e8d72?source=collection_archive---------0----------------------->

## 快速浏览 ES6 的最佳功能之一

![](img/77bd054c5e31245cd5026bbed339bafe.png)

Photo by [Markus Spiske](https://unsplash.com/@markusspiske?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

ES6 生成器函数是那些可以在中间停止执行并从同一点继续执行的函数。这些函数不返回单个值；相反，它们能够返回多个值。它们基于迭代器的概念。

# 没有发电机功能的生活

下面是一个没有生成器的简单函数。普通的 JavaScript 函数一被调用就开始执行。这些函数在任何其他代码执行之前运行完成。

我们通常认为函数会在其他 JavaScript 函数运行之前完成执行。一个正常的函数开始执行，只有当执行完成时才暂停。

函数可以在下列情况之一中停止执行:

1.  编译器到达函数的末尾。
2.  它遇到了`return`关键字。
3.  该函数抛出错误或异常。

# 发电机:我们不一样！

![](img/f05c34868e8d542c3676e7071bf33473.png)

Photo by [Cinn](https://unsplash.com/@cinn?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

在生成器的情况下，这些函数能够返回多个值，并且它们可能不会完全执行。功能执行可以部分触发。它可以在中间停止执行并继续另一个任务，过一会儿，从它停止的地方继续执行该功能。在我们继续之前，让我们看一个生成器的基本例子。

生成器函数可以暂停并恢复一次或多次，这使得它们很有趣，并且与普通函数非常不同。当函数暂停时，它允许其他函数和代码执行。默认情况下，生成器是异步的。

上面的代码包含一个简单的生成器实现。当调用生成器时，它返回一个*迭代器*。`function`关键字后的`*****` 表示它是一个生成器，迭代器从函数返回。这个迭代器不会自己获取结果。它需要从外部触发。

# 发电机:告诉我什么时候可以开始

一旦迭代器被创建，我们需要触发这个迭代器从生成器获取数据。我们可以通过在返回的迭代器上调用`next` 方法来从生成器函数中检索值，从而继续执行函数。每次在迭代器上调用`next()`函数时，它都会执行该函数，直到到达下一个`yield`关键字。在每个`yield`之后，它停止进一步处理。

一旦执行停止，我们需要在迭代器上重新触发`next`函数。当迭代器上的`next`函数被触发时，它继续执行，直到遇到下一个`yield`，并给出`2`作为输出。

# 发电机:不要告诉我停止

ES6 发电机功能不能从外部中断。除非在执行过程中遇到`yield`，否则不能停止发电机。如果生成器函数不包含任何`yield`关键字，它将像一个正常函数一样执行到完成。

# 从生成器中获取值

在下面的程序中，当在返回的迭代器上遇到`next()`时，它继续执行生成器函数。它开始执行该功能，并在遇到第一个`yield`时在第 3 行停止。`yield`关键字可以向调用的`next()`函数返回值。在这种情况下，第一个`yield`关键字将返回一个值`1`以及表示生成器执行是否完成的标志。

由于生成器仍未完成，它将返回标志值`done`作为`false`。`yield`返回包含`value`和`done`作为键的键/值对。

因此返回的输出是:`{ value: 1, done: false }`

`1`表示与`yield`关键字成对出现的值，因为生成器可以生成更多的值，所以`done`属性仍然为假。

在迭代器上可以多次调用`next`函数，标志`done` 将指示生成器是否完成。一旦发生器完成执行，所有进一步的输出将显示`done`标志的值为`true`，字段`value`为`undefined`。

调用`next`函数将恢复发生器的执行，直到下一个`yield`可用。在第 24 行，所有的`yield`关键字都用完了，所以在这种情况下，返回值将是`undefined`(因为函数不返回任何东西)，并且`done`标志设置为`true`。

# **在生成器**中使用 R `**eturn**` **关键字**

一个生成器函数可以有一个`return`语句。生成器函数一遇到`return`关键字，就将`done`标志更新为`true`，即使我们在函数中有更多的`yield`关键字，生成器也会被认为是完整的。

一旦`return`关键字被执行，所有其他的`yield`将返回`undefined`并将`done`标志设置为`true`。

# **将值传递给“下一个”函数**

我们已经看到，当我们向关键字`yield`传递一个值时，它将该值返回给调用函数`next`。但是，生成器支持双向通信。`next`功能也可以将数据传递给生成器。

在下面的代码中，您可以看到在第 15 行，我们将一个参数传递给了`next`函数。现在让我们来理解这行代码是如何执行的。

以下是第一次给`next()`打电话时的事件:

1.  当迭代器上第一次调用`next`时，生成器开始执行。
2.  生成器代码一直执行，直到遇到第一个`yield`关键字。
3.  它返回传递给`yield`函数的内容。

输出:`{ value: 1, done: false }`

当`next(10)`被调用时:

1.  传递的参数代替了`yield 1`。

所以实际上，生成器中的第 3 行变成了`let x = 10`。

2.它进一步执行该功能，直到遇到下一个`yield`。

3.它用 10 替换`x`的值，并返回结果值(10 +1)。

输出:`{ value: 11, done: false }`

在`next()`的以下调用中:

1.  由于没有进一步的`yield`关键字，它返回`undefined`作为返回值。
2.  并且由于生成器已经完成，所以`done`标志被设置为`true`。

输出:`{ value: undefined, done: false }`

# **使用 for … of 循环**

因为生成器函数返回迭代器，所以这些迭代器可以在`for` … `of`循环中使用。迭代器将遍历生成器函数中的所有值。传递给`yield`关键字的参数将作为一个值传递给迭代器。

我希望您现在对使用生成器函数更加熟悉了。生成器很神奇，可以解决各种用例场景。尝试在您当前的应用程序中找到生成器会使事情变得更简单的场景。希望这篇文章对你有帮助！

*更多内容请看*[*plain English . io*](http://plainenglish.io/)