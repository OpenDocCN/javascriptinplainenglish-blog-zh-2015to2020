<html>
<head>
<title>Reacting to Observables with MobX-React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用MobX-React对可观察到的事物做出反应</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reacting-to-observables-with-mobx-react-96ec97e5f9c2?source=collection_archive---------2-----------------------#2020-04-11">https://javascript.plainenglish.io/reacting-to-observables-with-mobx-react-96ec97e5f9c2?source=collection_archive---------2-----------------------#2020-04-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a0104e5a15e589be34fc957a2dab9946.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*KZ0PtwK1uqxbcsIS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jens_johnsson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jens Johnsson</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3f48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将MobX与MobX-React一起使用，通过观察MobX可观察对象和更改可观察数据来管理状态。</p><p id="47c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何创建一个可观察对象，并在React组件中直接使用它。</p><h1 id="91c0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建可观察对象并在React组件中使用它们</h1><p id="c180" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们必须安装<code class="fe me mf mg mh b">mobx</code>和<code class="fe me mf mg mh b">mobx-react</code>包来创建可观察对象，并在React组件中使用它们。</p><p id="ff06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以编写以下代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="197e" class="mq lc iq mh b gy mr ms l mt mu">npm i mobx mobx-react</span></pre><p id="73b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以创建我们的可观察对象和一个使用它的React组件，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="51b9" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { observer } from "mobx-react";<br/>import { observable } from "mobx";</span><span id="16f8" class="mq lc iq mh b gy mv ms l mt mu">const countData = observable({<br/>  count: 0<br/>});</span><span id="9ba2" class="mq lc iq mh b gy mv ms l mt mu">const App = observer(({ countData }) =&gt; (<br/>  &lt;&gt;<br/>    &lt;button onClick={() =&gt; countData.count++}&gt;Increment&lt;/button&gt;<br/>    &lt;p&gt;{countData.count}&lt;/p&gt;<br/>  &lt;/&gt;<br/>));<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App countData={countData} /&gt;, rootElement);</span></pre><p id="b2d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们通过编写以下内容创建了<code class="fe me mf mg mh b">countData</code>可观察对象:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e0e1" class="mq lc iq mh b gy mr ms l mt mu">const countData = observable({<br/>  count: 0<br/>});</span></pre><p id="8e2e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将能够获得React组件中的最新状态，然后将它作为React组件的道具传入。</p><p id="6726" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了让我们的React组件监视来自可观察对象的最新值，并让我们在组件内部更改它的值，我们编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f45a" class="mq lc iq mh b gy mr ms l mt mu">const App = observer(({ countData }) =&gt; (<br/>  &lt;&gt;<br/>    &lt;button onClick={() =&gt; countData.count++}&gt;Increment&lt;/button&gt;<br/>    &lt;p&gt;{countData.count}&lt;/p&gt;<br/>  &lt;/&gt;<br/>));<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App countData={countData} /&gt;, rootElement);</span></pre><p id="f2dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码从可观察的<code class="fe me mf mg mh b">countData</code>中得到<code class="fe me mf mg mh b">countData</code>道具。然后在<code class="fe me mf mg mh b">onClick</code>处理程序中，我们只是传递函数来改变它的值。</p><p id="8f1c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们引用最后一行中的<code class="fe me mf mg mh b">App</code>组件时，我们只是将<code class="fe me mf mg mh b">countData</code>可观察对象作为<code class="fe me mf mg mh b">countData</code>道具的值传入。</p><p id="9eb2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">countData.count++</code>将改变可观察的状态，然后从道具中获得最新值。</p><p id="205e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用带有类组件的<code class="fe me mf mg mh b">countData</code>可观察对象，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7031" class="mq lc iq mh b gy mr ms l mt mu">import React from "react";<br/>import ReactDOM from "react-dom";<br/>import { observer } from "mobx-react";<br/>import { observable } from "mobx";</span><span id="1eed" class="mq lc iq mh b gy mv ms l mt mu">const countData = observable({<br/>  count: 0<br/>});</span><span id="4d7b" class="mq lc iq mh b gy mv ms l mt mu">@observer<br/>class App extends React.Component {<br/>  render() {<br/>    return (<br/>      &lt;&gt;<br/>        &lt;button onClick={() =&gt; countData.count++}&gt;Increment&lt;/button&gt;<br/>        &lt;p&gt;{countData.count}&lt;/p&gt;<br/>      &lt;/&gt;<br/>    );<br/>  }<br/>}</span><span id="ada8" class="mq lc iq mh b gy mv ms l mt mu">const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App countData={countData} /&gt;, rootElement);</span></pre><p id="eb45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">唯一的区别是它是一个具有render方法的类组件，并且我们使用了<code class="fe me mf mg mh b">observer</code> decorator而不是<code class="fe me mf mg mh b">observer</code>函数。</p><h1 id="8a5e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用上下文传递观察值</h1><p id="1506" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用React上下文API将可观察对象的值传递给另一个组件。</p><p id="fe0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="15ab" class="mq lc iq mh b gy mr ms l mt mu">import React, { useContext } from "react";<br/>import ReactDOM from "react-dom";<br/>import { observer } from "mobx-react";<br/>import { observable } from "mobx";</span><span id="6169" class="mq lc iq mh b gy mv ms l mt mu">const countData = observable({<br/>  count: 0<br/>});</span><span id="4f4a" class="mq lc iq mh b gy mv ms l mt mu">const CountContext = React.createContext();</span><span id="7ef1" class="mq lc iq mh b gy mv ms l mt mu">const Counter = observer(() =&gt; {<br/>  const countData = useContext(CountContext);<br/>  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={() =&gt; countData.count++}&gt;Increment&lt;/button&gt;<br/>      &lt;p&gt;{countData.count}&lt;/p&gt;<br/>    &lt;/&gt;<br/>  );<br/>});</span><span id="67a2" class="mq lc iq mh b gy mv ms l mt mu">const App = ({ countData }) =&gt; (<br/>  &lt;CountContext.Provider value={countData}&gt;<br/>    &lt;Counter /&gt;<br/>  &lt;/CountContext.Provider&gt;<br/>);</span><span id="cf2b" class="mq lc iq mh b gy mv ms l mt mu">const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App countData={countData} /&gt;, rootElement);</span></pre><p id="bed1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有<code class="fe me mf mg mh b">CountContext</code>。我们通过书写来创造它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="13c1" class="mq lc iq mh b gy mr ms l mt mu">const CountContext = React.createContext();</span></pre><p id="5423" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">App</code>中，我们包含了<code class="fe me mf mg mh b">CountContext</code>组件，这样我们就可以通过传入<code class="fe me mf mg mh b">countData</code>属性来获得<code class="fe me mf mg mh b">countData</code>可观察值，该属性的值设置为<code class="fe me mf mg mh b">countData</code>可观察值。</p><p id="5831" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">Counter</code>组件中，我们调用内部有函数组件的<code class="fe me mf mg mh b">observer</code>函数。</p><p id="8c72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在组件内部，我们使用<code class="fe me mf mg mh b">useContext</code>钩子从<code class="fe me mf mg mh b">CountContext</code>获取值。</p><p id="2e9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在handler函数中，我们传入按钮的<code class="fe me mf mg mh b">onClick</code>属性，我们改变了<code class="fe me mf mg mh b">count</code>的值，这将自动改变<code class="fe me mf mg mh b">countData</code>可观察对象中的值，并设置为<code class="fe me mf mg mh b">countData.count</code>的值。</p><p id="e4f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当我们点击增量按钮时，它下面的数字会上升。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/9331fc4ae2235b21490abbb2cd117b19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EPd8I1tKIWjLJTzT"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@fivepointseven?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Max Rovensky</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f3d5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在本地组件状态中存储可观察值</h1><p id="21d8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们还可以在React组件中使用Observables作为本地状态。</p><p id="37c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以通过传入一个函数来使用<code class="fe me mf mg mh b">useState</code>钩子，该函数返回一个可观察的对象，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1897" class="mq lc iq mh b gy mr ms l mt mu">import React, { useState } from "react";<br/>import ReactDOM from "react-dom";<br/>import { observer } from "mobx-react";<br/>import { observable } from "mobx";</span><span id="18d3" class="mq lc iq mh b gy mv ms l mt mu">const App = observer(() =&gt; {<br/>  const [countData] = useState(() =&gt;<br/>    observable({<br/>      count: 0<br/>    })<br/>  );</span><span id="4c0b" class="mq lc iq mh b gy mv ms l mt mu">  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={() =&gt; countData.count++}&gt;Increment&lt;/button&gt;<br/>      &lt;p&gt;{countData.count}&lt;/p&gt;<br/>    &lt;/&gt;<br/>  );<br/>});<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App /&gt;, rootElement);</span></pre><p id="3574" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们通过传入一个函数来使用<code class="fe me mf mg mh b">useState</code>钩子，该函数返回一个具有<code class="fe me mf mg mh b">count</code>属性的可观察对象。然后我们将它赋给了<code class="fe me mf mg mh b">countData</code>变量。</p><p id="c63b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们这样做了，<code class="fe me mf mg mh b">countData.count</code>将被<code class="fe me mf mg mh b">onClick</code>处理程序更新，当我们单击Increment按钮时，我们将看到<code class="fe me mf mg mh b">countData.count</code>值自动更新。</p><p id="ea92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们单击“增量”按钮，那么值将会上升。</p><p id="8e90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们真的不需要使用MobX可观察对象来存储本地状态，除非涉及复杂的计算，因为MobX会针对这些进行优化。</p><p id="4f97" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以使用MobX来存储带有类组件的本地状态，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="50ab" class="mq lc iq mh b gy mr ms l mt mu">import React, { useState } from "react";<br/>import ReactDOM from "react-dom";<br/>import { observer } from "mobx-react";<br/>import { observable } from "mobx";</span><span id="3521" class="mq lc iq mh b gy mv ms l mt mu">@observer<br/>class App extends React.Component {<br/>  @observable count = 0;</span><span id="328d" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;&gt;<br/>        &lt;button onClick={() =&gt; this.count++}&gt;Increment&lt;/button&gt;<br/>        &lt;p&gt;{this.count}&lt;/p&gt;<br/>      &lt;/&gt;<br/>    );<br/>  }<br/>}<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App /&gt;, rootElement);</span></pre><p id="3bbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有<code class="fe me mf mg mh b">this.count</code>，这是一个可观察的字段。在<code class="fe me mf mg mh b">onClick</code>监听器中，我们只需直接修改<code class="fe me mf mg mh b">this.count</code>，然后它就会反映在<code class="fe me mf mg mh b">p</code>标签之间的<code class="fe me mf mg mh b">this.count</code>中。</p><p id="556b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">@observer</code>自动执行<code class="fe me mf mg mh b">memo</code>或<code class="fe me mf mg mh b">shouldComponentUpdate</code>，这样就不会有任何不必要的重新渲染。</p><h1 id="92f8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="039b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用MobX Observable来存储React应用程序的状态或React组件的状态。</p><p id="b150" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使用它来存储React app的状态，我们可以将一个可观察对象作为一个属性传递给一个组件，或者我们可以使用上下文API将数据发送给不同的组件。</p><p id="ee98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以通过在函数组件中使用<code class="fe me mf mg mh b">useState</code>钩子和在类组件中使用<code class="fe me mf mg mh b">observable</code>装饰器来使用它存储本地状态。</p><h2 id="cd70" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">JavaScript用简单的英语写的一个注释:</h2><p id="d9ef" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们总是有兴趣帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，<strong class="kf ir">用你的中级用户名发送电子邮件到submissions@javascriptinplainenglish.com</strong><a class="ae kc" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"/></a>，我们会将你添加为作者。</p><p id="269f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还推出了三种新的出版物！请关注我们的新出版物:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"> <strong class="kf ir"> AI in Plain English </strong> </a>，<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p></div></div>    
</body>
</html>