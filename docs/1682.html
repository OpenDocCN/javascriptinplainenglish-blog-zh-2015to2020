<html>
<head>
<title>Introduction to Shared Workers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">共享工作者简介</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-shared-workers-533d9abe9de3?source=collection_archive---------2-----------------------#2020-04-14">https://javascript.plainenglish.io/introduction-to-shared-workers-533d9abe9de3?source=collection_archive---------2-----------------------#2020-04-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/74e47e15a24b45b852bd868fb740dde4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*haGRJbBI7tNdnw9W"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@brookecagle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brooke Cagle</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2976" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">共享工作器是特殊的web工作器，可以由多个浏览器上下文访问，如浏览器标签、窗口、iframes或其他工作器等。</p><p id="484d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">他们不同于敬业的员工，因为他们是<code class="fe lb lc ld le b">SharedWorkers</code>的实例，并且具有不同的全球范围。</p><p id="855b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">根据同源策略，所有浏览器上下文必须在同一个域中。</p><p id="913c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究shared和workers的特征以及如何创建它们。</p><h1 id="5e5d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">共享工作者的特征</h1><p id="ac56" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">专用工作器和共享工作器的区别在于专用工作器只能由一个脚本访问。即使每个页面在不同的窗口中运行，多个脚本也可以访问共享工作器。</p><p id="d721" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得多个脚本之间的通信更加灵活。</p><p id="7f19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">访问工人的脚本可以通过使用<code class="fe lb lc ld le b">SharedWorker.port</code>属性创建的<code class="fe lb lc ld le b">MessagePort</code>对象来访问工人。如果使用<code class="fe lb lc ld le b">addEventListener</code>附加<code class="fe lb lc ld le b">onmessage</code>事件，则使用<code class="fe lb lc ld le b">start</code>方法手动启动端口。</p><p id="07dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当端口启动时，多个脚本可以向worker发送消息，并分别使用<code class="fe lb lc ld le b">port.postMessage</code>和<code class="fe lb lc ld le b">port.onmessage</code>处理发送的消息。</p><p id="4800" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除此之外，脚本仍然通过向工作器发送消息来与共享工作器通信，并通过脚本从工作器获取消息。</p><p id="98eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">SharedWorker</code>构造函数还接受一个选项对象，该对象包含以下选项:</p><ul class=""><li id="b081" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated"><code class="fe lb lc ld le b">type</code>:指定要创建的worker类型的字符串。该值可以是<code class="fe lb lc ld le b">classic</code>或<code class="fe lb lc ld le b">module</code>，默认为<code class="fe lb lc ld le b">classic</code>。</li><li id="1285" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><code class="fe lb lc ld le b">credentials</code>:指定工作者使用的凭证类型的字符串。该值可以是<code class="fe lb lc ld le b">omit</code>(不需要凭证)、<code class="fe lb lc ld le b">same-origin</code>或<code class="fe lb lc ld le b">include</code>。如果未指定，则<code class="fe lb lc ld le b">type</code>为<code class="fe lb lc ld le b">class</code>，默认为<code class="fe lb lc ld le b">omit</code>。</li><li id="f296" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated"><code class="fe lb lc ld le b">name</code>:指定代表工作器范围的<code class="fe lb lc ld le b">SharedWorkerGlobalScope</code>的标识名的字符串。主要用于调试。</li></ul><p id="6b99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果不允许启动workers，比如URL无效或者违反了同源策略，构造函数将抛出一个<code class="fe lb lc ld le b">SecurityError</code>。</p><p id="cf64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果工作脚本的MIME类型不正确，将引发<code class="fe lb lc ld le b">NetworkError</code>。</p><p id="b9ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">SyntaxError</code>引发的是工作人员的URL无法解析。</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/ec3598b55da4a6ee97b97c18e10f2f2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4rP3icp4ElA0RLHW"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@icons8?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Icons8 Team</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="98d8" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建和使用共享工作器</h1><p id="b4e0" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以创建一个共享的工人，使用它没有太多的麻烦。首先，我们必须创建一个共享工作者。然后我们必须创建脚本来使用它。最后，我们添加HTML，这样我们就可以用它做一些事情。</p><p id="dcde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先创建一个<code class="fe lb lc ld le b">scripts</code>文件夹并添加一个<code class="fe lb lc ld le b">sharedWorker.js</code>文件:</p><pre class="mx my mz na gt nb le nc nd aw ne bi"><span id="0f8f" class="nf lg iq le b gy ng nh l ni nj">onconnect = (ev) =&gt; {<br/>  const [port] = ev.ports;</span><span id="c558" class="nf lg iq le b gy nk nh l ni nj">  port.onmessage = e =&gt; {<br/>    const [first, second] = e.data;<br/>    let sum = +first + +second;<br/>    if (isNaN(sum)) {<br/>      port.postMessage("Both inputs should be numbers");<br/>    }<br/>    else {<br/>      const workerResult = `Result: ${sum} `;<br/>      port.postMessage(workerResult);<br/>    }<br/>  };<br/>};</span></pre><p id="99da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们将一个<code class="fe lb lc ld le b">onconnect </code>处理程序分配给了<code class="fe lb lc ld le b">onconnect </code>属性。然后在处理函数内部，我们得到共享工作器用来与其他脚本通信的端口。</p><p id="58c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们将一个事件处理程序分配给从<code class="fe lb lc ld le b">onconnect</code>处理程序的参数中获得的<code class="fe lb lc ld le b">port</code>的<code class="fe lb lc ld le b">onmesaage</code>属性。然后我们可以从<code class="fe lb lc ld le b">onmessage </code>处理程序的参数中获取数据并计算总和。</p><p id="dcfc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在处理程序中，我们检查从外部脚本发送的两个数据是否都是数字，如果是，就把数字加在一起，然后发送给脚本。</p><p id="ee12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想用<code class="fe lb lc ld le b">addEventListener</code>给<code class="fe lb lc ld le b">message</code>事件添加一个监听器，而不是给<code class="fe lb lc ld le b">onmessage</code>分配一个事件处理程序，我们必须在最后调用<code class="fe lb lc ld le b">onconnect</code>事件处理程序中的<code class="fe lb lc ld le b">port.start();</code>。</p><p id="cd68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，我们向外部脚本发回一条消息，表明发送的数据不是一个数字。</p><p id="4370" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在<code class="fe lb lc ld le b">script.js</code>中创建一个<code class="fe lb lc ld le b">main.js</code>和<code class="fe lb lc ld le b">main2.js</code>并添加:</p><pre class="mx my mz na gt nb le nc nd aw ne bi"><span id="0fef" class="nf lg iq le b gy ng nh l ni nj">const sharedWorker = new SharedWorker("scripts/sharedWorker.js");<br/>const first = document.getElementById("number1");<br/>const second = document.getElementById("number2");<br/>const result = document.getElementById("result");<br/>sharedWorker.port.start();<br/>first.onkeyup = () =&gt; {<br/>  sharedWorker.port.postMessage([first.value, second.value]);<br/>};</span><span id="1a3b" class="nf lg iq le b gy nk nh l ni nj">second.onkeyup = () =&gt; {<br/>  sharedWorker.port.postMessage([first.value, second.value]);<br/>};</span><span id="d422" class="nf lg iq le b gy nk nh l ni nj">sharedWorker.port.onmessage = e =&gt; {<br/>  result.textContent = e.data;<br/>};</span></pre><p id="86df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们从将要创建的HTML文件中获取输入，然后将其发送给我们的共享工作者。我们必须使用共享工作器的<code class="fe lb lc ld le b">port</code>来完成这项工作，就像我们使用<code class="fe lb lc ld le b"> sharedWorker.port.postMessage</code>一样。</p><p id="0560" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在:</p><pre class="mx my mz na gt nb le nc nd aw ne bi"><span id="e575" class="nf lg iq le b gy ng nh l ni nj">sharedWorker.port.onmessage = e =&gt; {<br/>  result.textContent = e.data;<br/>};</span></pre><p id="e971" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们取回从共享工作者发送的数据。</p><p id="2d9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">main.js</code>和<code class="fe lb lc ld le b">main2.js</code>做同样的事情，但是它们被不同的页面使用。</p><p id="3c5e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，创建<code class="fe lb lc ld le b">index.html</code>和<code class="fe lb lc ld le b">index2.html</code>并添加:</p><pre class="mx my mz na gt nb le nc nd aw ne bi"><span id="e37b" class="nf lg iq le b gy ng nh l ni nj">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Add Worker&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;form&gt;<br/>      &lt;div&gt;<br/>        &lt;label for="number1"&gt;First Number&lt;/label&gt;<br/>        &lt;input type="text" id="number1" value="0" /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div&gt;<br/>        &lt;label for="number2"&gt;Second Number&lt;/label&gt;<br/>        &lt;input type="text" id="number2" value="0" /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/form&gt;<br/>    &lt;p id="result"&gt;Result&lt;/p&gt;<br/>    &lt;script src="scripts/main.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="4c56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们得到:</p><figure class="mx my mz na gt jr gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/206536bf430642e36de0677bb990cf03.png" data-original-src="https://miro.medium.com/v2/resize:fit:646/format:webp/1*RfsDoXFdEuvbPRWTQb3bkg.png"/></div></figure><p id="e46e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们走到<code class="fe lb lc ld le b">index.html</code>或者<code class="fe lb lc ld le b">index2.html</code>的时候。我们应该能够在两页上进行计算，而不会互相干扰。</p><p id="d31c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个共享工作者和创建一个专注的工作者没有太大的区别。构造函数参数完全相同。唯一的区别是我们可以在多个脚本中使用它，并且我们需要让<code class="fe lb lc ld le b">port</code>对象在外部脚本和共享工作器之间进行通信。</p><p id="be25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">用简单英语写的JavaScript笔记</strong></p><p id="9a25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们总是有兴趣帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的中级用户名发邮件到submissions@javascriptinplainenglish.com<a class="ae kc" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir"/></a>给我们，我们会把你添加为作者。</p><p id="0872" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还推出了三种新的出版物！请关注我们的新出版物，表达对它们的爱:<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>—谢谢，继续学习！</p></div></div>    
</body>
</html>