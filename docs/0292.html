<html>
<head>
<title>JavaScript: Property accesses</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript:属性访问</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-property-accesses-5a1bebf351cf?source=collection_archive---------0-----------------------#2019-09-13">https://javascript.plainenglish.io/javascript-property-accesses-5a1bebf351cf?source=collection_archive---------0-----------------------#2019-09-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="74fe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何在引擎盖下执行属性访问</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/098fabbf8823a1fd1ee7daf99937917a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_ro1hTAoAaRw-br8TAkEqQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jyoung?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jonathon Young</a> on <a class="ae kv" href="https://unsplash.com/search/photos/property-access?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="68f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注意:</strong> <em class="ls">这篇文章有些超前，假设你对什么是</em> <code class="fe lt lu lv lw b"><em class="ls">[[Prototype]]</em></code> <em class="ls">及其工作原理有所了解。</em></p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><p id="f41d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您使用过JavaScript，那么您很可能遇到过对象和属性访问。这是它的样子</p><pre class="kg kh ki kj gt me lw mf mg aw mh bi"><span id="b294" class="mi mj iq lw b gy mk ml l mm mn">// object literal<br/>const obj = {<br/>    x: 52<br/>};</span><span id="497f" class="mi mj iq lw b gy mo ml l mm mn">// property access<br/>obj.x;</span></pre><p id="e95e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe lt lu lv lw b">obj.x</code>称为属性访问。这段代码实际上对<code class="fe lt lu lv lw b">obj</code>执行了一个<code class="fe lt lu lv lw b">[[Get]]</code>操作。让我们来看看它是如何工作的</p><h1 id="955d" class="mp mj iq bd mq mr ms mt mu mv mw mx my jw mz jx na jz nb ka nc kc nd kd ne nf bi translated">[[获取]]</h1><p id="7644" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">内置操作首先查看有问题的对象是否具有属性。如果在对象上找到属性，则返回值。所以，如果我们考虑上面的例子，它将返回52。</p><pre class="kg kh ki kj gt me lw mf mg aw mh bi"><span id="1ce4" class="mi mj iq lw b gy mk ml l mm mn">console.log(obj.x); //52</span></pre><p id="53df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">非常简单直接。然而，如果在对象中没有找到属性，<code class="fe lt lu lv lw b">[[Get]]</code>算法遍历<code class="fe lt lu lv lw b">[[Prototype]]</code>链，看看是否能在那里找到属性。无论如何，如果它没有找到被请求属性的值，它将返回值<code class="fe lt lu lv lw b">undefined</code>。</p><p id="2bbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注</strong> : <em class="ls">关于</em> <code class="fe lt lu lv lw b"><em class="ls">[[Prototype]]</em></code> <em class="ls">的讨论链条很长，如果我试图把它塞进这里，我会做得不公平。我将把它留到以后的文章中。现在，如果您不熟悉</em> <code class="fe lt lu lv lw b"><em class="ls">[[Prototype]]</em></code> <em class="ls">链，只需知道每个对象都有一个名为</em> <code class="fe lt lu lv lw b"><em class="ls">[[Prototype]]</em></code> <em class="ls">的属性，它是在创建对象时创建的，并被赋予对另一个对象的引用。每条</em> <code class="fe lt lu lv lw b"><em class="ls">[[Prototype]]</em></code> <em class="ls">链条的顶端都是</em> <code class="fe lt lu lv lw b"><em class="ls">Object</em></code> <em class="ls">基型的原型。我知道，如果你不熟悉的话会很困惑，但是我保证，我会在后面的帖子里讨论这个问题。</em></p><p id="b635" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将它分解，并通过一些例子来看看它是如何工作的</p><ol class=""><li id="b1b1" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated"><code class="fe lt lu lv lw b">[[Get]]</code>首先在对象中查找值。在这种情况下，会找到该属性，并将返回值</li></ol><pre class="kg kh ki kj gt me lw mf mg aw mh bi"><span id="0256" class="mi mj iq lw b gy mk ml l mm mn">const obj = {<br/>    x: 52<br/>};</span><span id="8e5d" class="mi mj iq lw b gy mo ml l mm mn">obj.x; //52</span></pre><p id="8f51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.如果它在对象中找不到属性，它会遍历<code class="fe lt lu lv lw b">[[Prototype]]</code>链来寻找值。<em class="ls">在下面的示例中</em> <code class="fe lt lu lv lw b"><em class="ls">Object.create()</em></code> <em class="ls">创建了一个新的对象，该对象是<code class="fe lt lu lv lw b"><em class="ls">y</em></code><code class="fe lt lu lv lw b"><em class="ls">[[Prototype]]</em></code><em class="ls">链接到传入的源对象。</em> <code class="fe lt lu lv lw b">mObj</code>没有<code class="fe lt lu lv lw b">x</code>属性，但<code class="fe lt lu lv lw b">x</code>存在于[[原形]]链中。</em></p><pre class="kg kh ki kj gt me lw mf mg aw mh bi"><span id="7142" class="mi mj iq lw b gy mk ml l mm mn">const obj = {<br/>    x: 52<br/>};</span><span id="6a20" class="mi mj iq lw b gy mo ml l mm mn">const mObj = Object.create(obj);</span><span id="dcf8" class="mi mj iq lw b gy mo ml l mm mn">mObj.x; // 52;</span></pre><p id="e93d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.如果它无论如何都找不到被请求的属性，它将返回值<code class="fe lt lu lv lw b">undefined</code>。</p><pre class="kg kh ki kj gt me lw mf mg aw mh bi"><span id="f334" class="mi mj iq lw b gy mk ml l mm mn">const obj = {<br/>    x: 52<br/>};</span><span id="864a" class="mi mj iq lw b gy mo ml l mm mn">const mObj = Object.create(obj);</span><span id="cc4b" class="mi mj iq lw b gy mo ml l mm mn">mObj.x; // 52<br/>mObj.y; // undefined</span></pre><p id="29b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注:</strong> <em class="ls">在引擎盖下，对</em> <code class="fe lt lu lv lw b"><em class="ls">[[Get]]</em></code>的操作为 <code class="fe lt lu lv lw b"><em class="ls">mObj.y</em></code> <em class="ls">做了一点更多的“工作”，因为它不得不通过所有的</em> <code class="fe lt lu lv lw b"><em class="ls">[[Prototype]]</em></code> <em class="ls">环节去寻找</em> <code class="fe lt lu lv lw b"><em class="ls">y</em></code> <em class="ls">。</em></p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="6efb" class="mp mj iq bd mq mr nu mt mu mv nv mx my jw nw jx na jz nx ka nc kc ny kd ne nf bi translated">[[Put]]</h1><p id="a04c" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">不用说，如果有一个运算符来获取一个属性的值，那么显然就有一个运算符来设置一个属性的值。考虑以下示例</p><pre class="kg kh ki kj gt me lw mf mg aw mh bi"><span id="45ff" class="mi mj iq lw b gy mk ml l mm mn">const obj = {<br/>    x: 52<br/>};</span><span id="dfb8" class="mi mj iq lw b gy mo ml l mm mn">obj.x = 32;</span><span id="74de" class="mi mj iq lw b gy mo ml l mm mn">obj.x; // 32</span></pre><p id="cdc5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，当给一个属性赋值时，很容易会认为<code class="fe lt lu lv lw b">[[Put]]</code>操作被执行，并且赋值，或者创建属性，然后赋值。没那么简单。有许多因素决定了<code class="fe lt lu lv lw b">[[Put]]</code>运算符的行为，最明显的是属性是否存在于对象上。</p><p id="37f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看看当找到属性时会发生什么:</p><ol class=""><li id="9e93" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">如果属性是<strong class="ky ir"> <em class="ls">访问器描述符</em> </strong>，则调用setter <em class="ls">(在本文后面的getter&amp;setter一节中讨论)。</em></li><li id="f93b" class="nl nm iq ky b kz nz lc oa lf ob lj oc ln od lr nq nr ns nt bi translated">如果属性是一个数据描述符，且<strong class="ky ir">可写描述符</strong>设置为false，则除非在<code class="fe lt lu lv lw b">strict</code>模式下运行，否则将无声地失败。在<code class="fe lt lu lv lw b">strict</code>模式下抛出错误。我在关于<a class="ae kv" href="https://medium.com/javascript-in-plain-english/javascript-object-immutability-b6d7b1e0297" rel="noopener">对象不变性的帖子中谈到了<strong class="ky ir">数据描述符</strong>。</a></li><li id="6716" class="nl nm iq ky b kz nz lc oa lf ob lj oc ln od lr nq nr ns nt bi translated">否则，将属性的值设置为正常值。</li></ol><p id="a704" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，当在对象上找不到属性时会发生什么呢？如果你阅读<code class="fe lt lu lv lw b">[[Get]]</code>操作是如何工作的，你可能已经猜到了，但是它不仅仅是<code class="fe lt lu lv lw b">[[Prototype]]</code>链接扫描，还有更多的规则。</p><p id="8c4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有三(3)条规则来确定如果在所讨论的对象上找不到属性，则<code class="fe lt lu lv lw b">[[Put]]</code>操作将如何工作:</p><ol class=""><li id="ef76" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr nq nr ns nt bi translated">如果数据访问器属性在<code class="fe lt lu lv lw b">[[Prototype]]</code>链<strong class="ky ir">和</strong>中的任何位置被发现，其可写描述符<em class="ls">(这里讨论的</em><a class="ae kv" href="https://medium.com/javascript-in-plain-english/javascript-object-immutability-b6d7b1e0297" rel="noopener"><em class="ls"/></a><em class="ls">)如果<strong class="ky ir">不是</strong>设置为假，那么在所讨论的对象上创建<strong class="ky ir"> <em class="ls">阴影属性</em> </strong> <em class="ls"> </em>，并且在那里设置值。</em></li><li id="2b9a" class="nl nm iq ky b kz nz lc oa lf ob lj oc ln od lr nq nr ns nt bi translated">如果在<code class="fe lt lu lv lw b">[[Prototype]]</code>链<strong class="ky ir">和</strong>中的任何位置找到数据访问器属性，并且它的可写描述符<em class="ls">(这里讨论的是</em><a class="ae kv" href="https://medium.com/javascript-in-plain-english/javascript-object-immutability-b6d7b1e0297" rel="noopener"><em class="ls"/></a><em class="ls">)</em><strong class="ky ir">被设置为false，那么赋值将无声地失败，并且<strong class="ky ir"> <em class="ls">影子属性</em> </strong>将不会<strong class="ky ir"/>被创建。</strong></li><li id="d3af" class="nl nm iq ky b kz nz lc oa lf ob lj oc ln od lr nq nr ns nt bi translated">如果属性在<code class="fe lt lu lv lw b">[[Prototype]]</code>链中的位置更高，并且它是<strong class="ky ir"> <em class="ls">设置器</em> </strong>，那么set函数总是被调用。一个<strong class="ky ir"> <em class="ls">阴影属性</em> </strong>将不会在所讨论的对象上创建。当检索所述属性的值时，<code class="fe lt lu lv lw b">[[Get]]</code>操作将遍历<code class="fe lt lu lv lw b">[[Prototype]]</code>链并从中检索值。</li></ol><p id="756d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">注:</strong> <em class="ls">一</em> <strong class="ky ir"> <em class="ls">影子属性</em> </strong> <em class="ls">是一种既存在于物体本身又存在于更高的</em> <code class="fe lt lu lv lw b"><em class="ls">[[Prototype]]</em></code> <em class="ls">链中的属性。考虑一个名为</em> <code class="fe lt lu lv lw b"><em class="ls">x</em></code> <em class="ls">的属性，对象上的</em> <code class="fe lt lu lv lw b"><em class="ls">x</em></code> <em class="ls">属性会直接遮蔽可能出现在</em> <code class="fe lt lu lv lw b"><em class="ls">[[Prototype]]</em></code> <em class="ls">链中较高位置的任何</em> <code class="fe lt lu lv lw b"><em class="ls">x</em></code> <em class="ls">属性，因为查找obj.x会直接返回对象(链中最低的)的值，而不是查找链中较高的值。考虑以下示例</em></p><pre class="kg kh ki kj gt me lw mf mg aw mh bi"><span id="f5f8" class="mi mj iq lw b gy mk ml l mm mn">const obj = {<br/>  x: 52<br/>};</span><span id="dbb5" class="mi mj iq lw b gy mo ml l mm mn">const mObj = Object.create(obj);</span><span id="bf00" class="mi mj iq lw b gy mo ml l mm mn">// Here's how the following assignment works<br/>// Since x isn't on mObj <br/>// [[Put]] Traverses the [[Prototype]] chain<br/>// Finds the property  on obj<br/>// Creates a shadow property on mObj<br/>// Assigns the shadow property value of 32<br/>mObj.x = 32;</span><span id="a852" class="mi mj iq lw b gy mo ml l mm mn">// Since x now exists on both mObj and obj <br/>// when we do a retrieval of x from mObj <br/>// the value 32 will be returned.<br/>mObj.x; // 32, because x now exists on mObj<br/>obj.x; // 52, nothing changes</span></pre></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="360e" class="mp mj iq bd mq mr nu mt mu mv nv mx my jw nw jx na jz nx ka nc kc ny kd ne nf bi translated">吸气剂和沉降剂</h1><p id="06d0" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">到目前为止，您应该知道<code class="fe lt lu lv lw b">[[Put]]</code>和<code class="fe lt lu lv lw b">[[Get]]</code>操作完全控制了值的设置和检索以及操作的实际工作方式。</p><p id="8b83" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ES5引入了一种方法，通过Getters和Setters在每个属性的基础上覆盖这些功能。您可以通过使用<code class="fe lt lu lv lw b">Object.defineProperty()</code>方法来定义Getters和Setters。如果你读过我关于<a class="ae kv" href="https://medium.com/javascript-in-plain-english/javascript-object-immutability-b6d7b1e0297" rel="noopener">对象不变性</a>的帖子，你会对下面的例子很熟悉。</p><pre class="kg kh ki kj gt me lw mf mg aw mh bi"><span id="a37b" class="mi mj iq lw b gy mk ml l mm mn">const obj = {</span><span id="e3e3" class="mi mj iq lw b gy mo ml l mm mn">    //A getter for property x<br/>    get x() {<br/>        return this._x;<br/>    }, </span><span id="460d" class="mi mj iq lw b gy mo ml l mm mn">    //A setter for property y<br/>    set y(value) {<br/>        this._x = value;<br/>    }<br/>};</span><span id="0980" class="mi mj iq lw b gy mo ml l mm mn">Object.defineProperty(obj, 'y', {<br/>    <br/>    //A getter for y<br/>    get: function() {<br/>        return this._y;<br/>    }, </span><span id="7408" class="mi mj iq lw b gy mo ml l mm mn">    // A setter for y<br/>    set: function(value) {<br/>        this._y = value;<br/>    }<br/>});</span><span id="66df" class="mi mj iq lw b gy mo ml l mm mn">obj.x; // undefined <br/>obj.x = 52; <br/>obj.x; // 52</span><span id="b3b3" class="mi mj iq lw b gy mo ml l mm mn">obj.y; // undefined <br/>obj.y = 32; <br/>obj.y; // 32</span></pre><p id="d2f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，我们通过以下方式在对象上创建属性</p><ul class=""><li id="60bd" class="nl nm iq ky b kz la lc ld lf nn lj no ln np lr oe nr ns nt bi translated">使用对象文字</li><li id="a30d" class="nl nm iq ky b kz nz lc oa lf ob lj oc ln od lr oe nr ns nt bi translated">使用显式定义</li></ul><p id="3063" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论哪种方式，我们创建的属性实际上并不保存属性值，而是在访问时调用一个隐藏函数来获取或设置属性值。</p><p id="fd4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本质上，getter是调用隐藏函数来获取值的对象的属性，setter是调用隐藏函数来设置值的对象的属性。</p><p id="4e2e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你为一个属性定义了一个getter或者setter或者两者，它就变成了一个<strong class="ky ir"> <em class="ls">访问器描述符</em> </strong>，你不需要为它们定义<code class="fe lt lu lv lw b">value</code>或者<code class="fe lt lu lv lw b">writable</code>描述符。</p></div><div class="ab cl lx ly hu lz" role="separator"><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc md"/><span class="ma bw bk mb mc"/></div><div class="ij ik il im in"><h1 id="9875" class="mp mj iq bd mq mr nu mt mu mv nv mx my jw nw jx na jz nx ka nc kc ny kd ne nf bi translated">结论</h1><p id="0ac2" class="pw-post-body-paragraph kw kx iq ky b kz ng jr lb lc nh ju le lf ni lh li lj nj ll lm ln nk lp lq lr ij bi translated">这篇文章讲述了<code class="fe lt lu lv lw b">[[Put]]</code>和<code class="fe lt lu lv lw b">[[Get]]</code>操作如何设置或获取属性值。我们研究了在对象上找到属性时和在两个操作中都没有找到属性时应用的不同规则。我们还看了如何使用Getters和Setters以及它们是如何工作的。</p><p id="a067" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以现在你应该对所有这些是如何工作的有一个透彻的理解。让我知道你的财产访问的经验。你在使用它时遇到困难了吗？你有没有在你的代码中遇到过一些对你来说没有意义的关于属性访问的怪异之处？让我们在下面的评论中讨论吧。</p><p id="c9d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">干杯！</p></div></div>    
</body>
</html>