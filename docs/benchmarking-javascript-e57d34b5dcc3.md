# JavaScript 基准测试

> 原文：<https://javascript.plainenglish.io/benchmarking-javascript-e57d34b5dcc3?source=collection_archive---------7----------------------->

![](img/0dd3f99eb992649a0b3348ac7913b62d.png)

Photo by [Mathew Schwartz](https://unsplash.com/@cadop?utm_source=medium&utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&utm_medium=referral)

使用 JavaScript，时间分辨率的最精细粒度是毫秒。

因此，了解在一行代码中花费了多少时间需要一种提供足够可测量时间的方法。

比如，我们计算一个`Math.log10()`运算能有多快？

简单地在这个操作周围放置计时器将返回 0 毫秒——没有可测量的时间。实际上，我要调用这个操作 10 万次，才能得到一个有意义的 2 到 3 毫秒的时间。

一些浏览器具有高分辨率的时间戳，如 Google Chrome，其中可以报告毫秒级的分数。

但是为了达到精度，需要累积多个样本。

## 设置计时器

首先，我们需要构建如何测量时间。

作为一个参数，`iterations`定义循环将执行多少次要测量的操作。操作时间的计算方法是用总时间除以迭代次数。

## 优化执行时间

接下来，我们需要调整执行时间以获得可靠的样本。在上面 100k 次迭代的例子中，我的测试每次总时间在 2 到 3 毫秒之间波动。这实际上是相当大的差异:

*   在总执行时间为 2 毫秒的情况下，这个函数需要 0.00002 毫秒(20 纳秒)，每秒钟可以调用 50，000，000 次
*   在总执行时间为 3 毫秒的情况下，这个函数需要 0.00003 毫秒(30 纳秒)，每秒可以调用 33，333，333 次

这相当于每秒钟超过 1660 万次运算。

由于代码的优先级，我们永远不会达到完美的运行时一致性。通过计算运行平均样本的标准偏差，可以自动调整迭代次数；然而，为了简化这个例子，我将迭代次数增加了 10 次，直到达到大约 50 毫秒的时间。

运行以上程序现在提供了一个连续的样品组:

```
total: 60, time: 0.0000006000, op/sec: 1666666666
total: 53, time: 0.0000005300, op/sec: 1886792452
total: 59, time: 0.0000005900, op/sec: 1694915254
total: 56, time: 0.0000005600, op/sec: 1785714285
total: 52, time: 0.0000005200, op/sec: 1923076923
```

从上面的样本集来看，迭代 1 亿次平均需要 56 毫秒，这意味着`Math.log10`函数的时间大约是 0.00000056 毫秒(0.56 纳秒)，每秒能够执行大约 1，791，433，116 次。

## 异步执行

启动应用程序后，性能可能会立即下降，或者受到垃圾收集的影响。为了获得更真实的执行样本，请避免在测试之间运行到完成。

这里，我们在测试之间休眠 50 毫秒，以提供一个短暂的冷却时间。

## 测试中的覆盖率

这个`Math.log10()`例子很简单，但是到目前为止，我们已经反复测试了只将`0`的一个值传递给返回`-Infinity`的函数。

一定要考虑输入参数如何改变执行时间。

在这个循环中，我们可以方便地将`for`循环的索引值作为`Math.log10(i)`传递给函数。

## 基线时间

利用循环来获得足够的可测量时间意味着计算开销在这个测试中没有考虑。不仅我们的测试函数在执行，而且`for`循环本身也在增加索引值。

重要的是要准确地分离出我们要计时的内容。

因此，我们需要测量循环本身花费了多少时间，并从总时间中减去基线时间。

现在，我们的测试时间考虑了循环，只显示了花费在 log 函数上的时间。

```
total: 11, time: 0.0000001100, op/sec:  9090909090
total:  6, time: 0.0000000600, op/sec: 16666666666
total:  8, time: 0.0000000800, op/sec: 12500000000
total:  8, time: 0.0000000800, op/sec: 12500000000
```

一定要积累足够多的样本，因为当测量小段代码时，测试的执行速度可能会比基线更快。这导致了负时间:

```
total: -1, time: -0.0000000100, op/sec: -100000000000
```

这些离群值应该被扔掉。

## 编译器优化

最后，考虑编译器或 JavaScript 运行时本身应用的任何优化也很重要。

像 Babel 这样的代码转换器可以重写代码，或者像提升循环不变代码运动这样的优化可以自动应用。如果代码被提升到循环之外，实际上不会测试任何东西。