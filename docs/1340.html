<html>
<head>
<title>Dependency Injection in Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度依赖性注入</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-hierarchical-injection-system-4b80e5cc9dac?source=collection_archive---------6-----------------------#2020-03-03">https://javascript.plainenglish.io/angular-hierarchical-injection-system-4b80e5cc9dac?source=collection_archive---------6-----------------------#2020-03-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/dd39707bceba260ada560f05aa88dfc8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qnXFzSclPScSDjveJmwkHA.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@abyss_?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">patrick lanza</a> on <a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="fb76" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Angular DI利用了一个分层的注入系统，因此嵌套的注入器能够创建自己的服务实例。因此，<strong class="kf jh"> <em class="lb"> Angular定期创建嵌套的注入器。</em>T3】</strong></p><blockquote class="lc"><p id="64bb" class="ld le jg bd lf lg lh li lj lk ll la dk translated">分层依赖注入系统允许我们为依赖关系定义不同的边界或范围，并遵循组件树结构。</p></blockquote><p id="7cee" class="pw-post-body-paragraph kd ke jg kf b kg lm ki kj kk ln km kn ko lo kq kr ks lp ku kv kw lq ky kz la ij bi translated">默认情况下，注册到Angular的服务是应用程序范围的，但是我们也可以创建隔离到组件子集的服务。</p><p id="48c7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">一旦Angular创建了一个指定了提供者的组件的新实例，它也将为该实例创建一个新的子注入器。<br/>类似地，新NgModule在运行时的延迟加载也会触发带有自己的提供者的注入器的创建。</em></p><p id="fd68" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为子模块和组件注入器是相互独立的，所以它们也将为所提供的服务创建自己独立的实例。</p><p id="a9af" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当Angular销毁一个NgModule或component实例时，它也会销毁该注入器以及该注入器的服务实例。然而，由于注入器继承，我们仍然可以将应用程序范围的服务注入到这些组件中。</p><p id="e77a" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">组件的注入器是其父组件的注入器的子组件，并且从所有祖先注入器一直继承到应用程序的根注入器。Angular可以注入该谱系中任何注入器所提供的服务。</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lr"><img src="../Images/08d292506f6de8325fc2a7b50a5418d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DW4Xa8HmpAiuiD7IEwa1Pg.png"/></div></div></figure><h1 id="af27" class="lw lx jg bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">注射器等级</h1><h2 id="2c00" class="mu lx jg bd ly mv mw dn mc mx my dp mg ko mz na mk ks nb nc mo kw nd ne ms nf bi translated">模块注入器层次结构</h2><p id="537f" class="pw-post-body-paragraph kd ke jg kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated"><strong class="kf jh"> <em class="lb"> @NgModule() </em> </strong>或<strong class="kf jh"><em class="lb">@ injective()</em></strong>注释在此层次中用于配置ModuleInjector。</p><p id="4408" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"><em class="lb">injective():</em></strong>@ injective()装饰器标识一个服务类。当我们在服务本身的<strong class="kf jh"><em class="lb">@ injective()</em></strong>装饰器中指定提供者时(通常在应用程序根级别)，CLI的生产构建所使用的优化工具可以执行<strong class="kf jh">树摇动</strong>。</p><p id="5e3f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它删除我们的应用程序不使用的服务。树抖动导致更小的束尺寸。</p><pre class="ls lt lu lv gt nl nm nn no aw np bi"><span id="cb1c" class="mu lx jg nm b gy nq nr l ns nt">import { Injectable } from '@angular/core';</span><span id="1d78" class="mu lx jg nm b gy nu nr l ns nt">@Injectable({<br/>  providedIn: 'root'  // &lt;--provides this service in the root ModuleInjector<br/>})</span><span id="f70d" class="mu lx jg nm b gy nu nr l ns nt">export class LoggerService {<br/>  name = 'Logger';<br/>}</span></pre><p id="0a2f" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> <em class="lb"> @NgModule()提供者数组:</em> </strong>我们还可以使用非根NgModule的providers元数据选项在模块级别配置提供者。通过这种方式，我们可以将提供者的范围限制在该模块上。</p><p id="8704" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这相当于在@ Injectable()元数据中指定非根模块，只是通过提供者提供的服务不是树摇动的。</p><p id="82d7" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> <em class="lb">文件- &gt; src/app/app.module.ts(提供者)</em> </strong></p><pre class="ls lt lu lv gt nl nm nn no aw np bi"><span id="31ae" class="mu lx jg nm b gy nq nr l ns nt">providers: [<br/>  { provide: LocationStrategy, useClass: HashLocationStrategy }<br/>]</span></pre><h2 id="9d8f" class="mu lx jg bd ly mv mw dn mc mx my dp mg ko mz na mk ks nb nc mo kw nd ne ms nf bi translated">元素注入器层次结构</h2><p id="518b" class="pw-post-body-paragraph kd ke jg kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">它是为每个DOM元素隐式创建的。除非在<strong class="kf jh"> <em class="lb"> @Directive() </em> </strong>或<strong class="kf jh"> <em class="lb"> @Component() </em> </strong>的providers属性中配置，否则ElementInjector默认为空。</p><p id="caca" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就能够将提供者的范围限制在一个组件及其子组件上。</p><pre class="ls lt lu lv gt nl nm nn no aw np bi"><span id="1992" class="mu lx jg nm b gy nq nr l ns nt">import { Component } from '@angular/core';<br/>import { LoggerService } from './logger.service';</span><span id="918d" class="mu lx jg nm b gy nu nr l ns nt">@Component({<br/>  selector: 'app-component',<br/>  providers: [ LoggerService ],<br/>  templateUrl: './app.component.html'<br/>})<br/>export class AppComponent { }</span></pre><p id="f394" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不管它是组件还是指令，我们都可以使用providers属性来配置提供者。一旦完成，它将属于该组件或指令的ElementInjector。</p><p id="4b26" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个层次结构中，当我们在一个组件中提供服务后，该服务将通过该组件实例的ElementInjector可用。</p><h1 id="3321" class="lw lx jg bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">结论</h1><p id="ac33" class="pw-post-body-paragraph kd ke jg kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated">Angular以其强大的依赖注入系统而闻名。使用依赖注入有很多好处，包括在我们的应用程序中更直接的测试策略和依赖管理。</p><p id="69a5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用Angular的依赖注入系统，我们可以创建称为服务的特殊类，允许我们在组件和功能之间共享逻辑和数据</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><h2 id="193d" class="mu lx jg bd ly mv mw dn mc mx my dp mg ko mz na mk ks nb nc mo kw nd ne ms nf bi translated">参考</h2><p id="7c50" class="pw-post-body-paragraph kd ke jg kf b kg ng ki kj kk nh km kn ko ni kq kr ks nj ku kv kw nk ky kz la ij bi translated"><a class="ae jd" href="https://angular.io/" rel="noopener ugc nofollow" target="_blank"> Angular.io </a></p></div></div>    
</body>
</html>