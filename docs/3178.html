<html>
<head>
<title>JavaScript Lazy Evaluation: Iterables &amp; Iterators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript惰性求值:可迭代程序和迭代器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-lazy-evaluation-iterables-iterators-e0770a5de96f?source=collection_archive---------2-----------------------#2020-09-07">https://javascript.plainenglish.io/javascript-lazy-evaluation-iterables-iterators-e0770a5de96f?source=collection_archive---------2-----------------------#2020-09-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="d5df" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">JavaScript Alpha指南</h2><div class=""/><div class=""><h2 id="6858" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">可迭代和迭代器。惰性评估算法的基本构件。让我们看看它们是由什么组成的，以及它们有什么用处。</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/243b4c8e490766a8b7a858dd7e5f5f86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IHgR0oteU7BWxcUJAtiCjA.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">JavaScript lazy evaluation: Iterables &amp; Iterators</figcaption></figure><p id="3db9" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">懒评测，每个函数式程序员的梦遗。很快，我们就会看到发电机。但是首先，让我们了解什么是迭代器和可迭代对象，因为对我来说，它们是生成器的先决条件。</p><h1 id="3d5f" class="lx ly in bd lz ma mb mc md me mf mg mh kc mi kd mj kf mk kg ml ki mm kj mn mo bi translated">懒惰评估</h1><p id="ee6a" class="pw-post-body-paragraph lb lc in ld b le mp jx lg lh mq ka lj lk mr lm ln lo ms lq lr ls mt lu lv lw ig bi translated"><strong class="ld ix">惰性求值</strong>意味着将表达式的求值延迟到需要的时候。惰性评估有时被称为<strong class="ld ix">按需调用</strong>。</p><p id="eba5" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">懒惰评估的反义词是<strong class="ld ix">热切评估</strong>。这是大多数编程语言中使用的评估策略。</p><p id="4da8" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">惰性评估可以:</p><ul class=""><li id="40ac" class="mu mv in ld b le lf lh li lk mw lo mx ls my lw mz na nb nc bi translated">定义潜在的无限数据结构</li><li id="6cdc" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated">通过避免不必要的计算来提高性能</li><li id="a5d7" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated">为希望其元素可供公众访问的数据结构定制迭代行为</li></ul><h1 id="84a5" class="lx ly in bd lz ma mb mc md me mf mg mh kc mi kd mj kf mk kg ml ki mm kj mn mo bi translated">迭代器</h1><p id="cb9e" class="pw-post-body-paragraph lb lc in ld b le mp jx lg lh mq ka lj lk mr lm ln lo ms lq lr ls mt lu lv lw ig bi translated">JavaScript中的<strong class="ld ix">迭代器</strong>(因为<a class="ae ni" href="http://es6-features.org/#IteratorForOfOperator" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ix"> ECMAScript 6 </strong> </a>)使得惰性求值和创建用户定义的数据序列成为可能。</p><p id="206d" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated"><strong class="ld ix">迭代</strong>是一种遍历数据的机制。迭代器是遍历数据结构元素的指针，称为<strong class="ld ix"> Iterable </strong>。产生一系列值的指针。</p><p id="6d74" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">迭代器是一个可以被迭代的对象。它抽象了一个数据容器，使其行为像一个可迭代的对象。</p><p id="9c1b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">迭代器不会在实例化时计算每一项的值。下一个值仅在请求时生成。这很有用，尤其是对于大型数据集或无限数量元素的序列。</p><h1 id="855b" class="lx ly in bd lz ma mb mc md me mf mg mh kc mi kd mj kf mk kg ml ki mm kj mn mo bi translated">可重复的</h1><p id="541d" class="pw-post-body-paragraph lb lc in ld b le mp jx lg lh mq ka lj lk mr lm ln lo ms lq lr ls mt lu lv lw ig bi translated">Iterables是希望公众可以访问其元素的数据结构。</p><p id="7c10" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">许多API接受iterables，例如:</p><ul class=""><li id="a905" class="mu mv in ld b le lf lh li lk mw lo mx ls my lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">new Map([iterable])</code></li><li id="9fbe" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">new WeakMap([iterable])</code></li><li id="f672" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">new Set([iterable])</code></li><li id="ebf4" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">new WeakSet([iterable])</code></li><li id="131d" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">Promise.all([iterable])</code></li><li id="419a" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">Promise.race([iterable])</code></li><li id="7861" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">Array.from([iterable])</code></li></ul><p id="be68" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">也有期望可迭代的语句和表达式，例如:</p><ul class=""><li id="770f" class="mu mv in ld b le lf lh li lk mw lo mx ls my lw mz na nb nc bi translated"><code class="fe nj nk nl nm b"><strong class="ld ix">for ... of</strong></code>(循环)</li><li id="cb97" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b"><strong class="ld ix">...</strong></code>(传播算子)</li><li id="466e" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">const <strong class="ld ix">[a, b, ..]</strong> = iterable;</code>(解构分配)</li><li id="d306" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b"><strong class="ld ix">yield*</strong></code>(发电机委托)</li></ul><p id="4f43" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">JavaScript中已经有许多内置的可迭代对象:<br/> <code class="fe nj nk nl nm b">String</code>、<code class="fe nj nk nl nm b">Array</code>、<code class="fe nj nk nl nm b">TypedArray</code>、<code class="fe nj nk nl nm b">Map</code>、<code class="fe nj nk nl nm b">Set</code>。</p><h1 id="d639" class="lx ly in bd lz ma mb mc md me mf mg mh kc mi kd mj kf mk kg ml ki mm kj mn mo bi translated">迭代协议</h1><p id="d5d6" class="pw-post-body-paragraph lb lc in ld b le mp jx lg lh mq ka lj lk mr lm ln lo ms lq lr ls mt lu lv lw ig bi translated"><strong class="ld ix">迭代器</strong>和<strong class="ld ix">迭代器</strong>符合<a class="ae ni" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ix">迭代</strong> <strong class="ld ix">协议</strong> </a>。</p><blockquote class="nn"><p id="6f74" class="no np in bd nq nr ns nt nu nv nw lw dk translated">协议是一组接口和使用它们的规则。</p></blockquote><p id="0bf6" class="pw-post-body-paragraph lb lc in ld b le nx jx lg lh ny ka lj lk nz lm ln lo oa lq lr ls ob lu lv lw ig bi translated">迭代器符合<strong class="ld ix">迭代器协议</strong>。可迭代符合<strong class="ld ix">可迭代协议</strong>。</p><h2 id="d696" class="oc ly in bd lz od oe dn md of og dp mh lk oh oi mj lo oj ok ml ls ol om mn it bi translated">可迭代协议</h2><p id="cd95" class="pw-post-body-paragraph lb lc in ld b le mp jx lg lh mq ka lj lk mr lm ln lo ms lq lr ls mt lu lv lw ig bi translated">Iterable协议允许JavaScript对象定义或定制它们的迭代行为。</p><p id="5004" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">要使一个对象成为可迭代的，它必须实现一个可通过<code class="fe nj nk nl nm b">Symbol.iterator</code>访问的迭代器方法。这个方法是迭代器的工厂。</p><p id="829c" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">使用TypeScript，iterable协议如下所示:</p><pre class="km kn ko kp gt on nm oo op aw oq bi"><span id="4cea" class="oc ly in nm b gy or os l ot ou">interface Iterable {<br/>  [Symbol.iterator]() : Iterator;<br/>}</span></pre><p id="9fbd" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated"><code class="fe nj nk nl nm b">[Symbol.iterator]()</code>是一个零参数函数。它在iterable对象上被调用，这意味着您可以通过<code class="fe nj nk nl nm b">this</code>访问iterable。它可以是常规函数，也可以是生成器函数。</p><h2 id="2667" class="oc ly in bd lz od oe dn md of og dp mh lk oh oi mj lo oj ok ml ls ol om mn it bi translated">迭代器协议</h2><p id="038f" class="pw-post-body-paragraph lb lc in ld b le mp jx lg lh mq ka lj lk mr lm ln lo ms lq lr ls mt lu lv lw ig bi translated">迭代器协议定义了产生值序列的标准方法。</p><p id="0c32" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">一个对象要成为迭代器，它必须实现一个<code class="fe nj nk nl nm b">next()</code>方法。可选地，迭代器可以实现一个<code class="fe nj nk nl nm b">return()</code>方法，我们将在本文后面讨论。</p><p id="8e90" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">使用TypeScript，迭代协议如下所示:</p><pre class="km kn ko kp gt on nm oo op aw oq bi"><span id="32c2" class="oc ly in nm b gy or os l ot ou">interface Iterator {<br/>    next() : IteratorResult;<br/>    return?(value?: any): IteratorResult;<br/>}</span></pre><p id="2a88" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">其中<code class="fe nj nk nl nm b">IteratorResult</code>是:</p><pre class="km kn ko kp gt on nm oo op aw oq bi"><span id="7496" class="oc ly in nm b gy or os l ot ou">interface IteratorResult {<br/>    value?: any;<br/>    done: boolean;<br/>}</span></pre><ul class=""><li id="a316" class="mu mv in ld b le lf lh li lk mw lo mx ls my lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">done</code>通知消费者迭代器是否已被使用，<code class="fe nj nk nl nm b">false</code>表示仍有值要生成，<code class="fe nj nk nl nm b">true</code>表示迭代器已到达其末尾</li><li id="dd6f" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">value</code>可以是任何JavaScript值，它是向消费者公开的值</li></ul><p id="f571" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">当<code class="fe nj nk nl nm b">done</code>为真时，可以省略<code class="fe nj nk nl nm b">value</code>。</p><h2 id="1d38" class="oc ly in bd lz od oe dn md of og dp mh lk oh oi mj lo oj ok ml ls ol om mn it bi translated">放在一起</h2><p id="c585" class="pw-post-body-paragraph lb lc in ld b le mp jx lg lh mq ka lj lk mr lm ln lo ms lq lr ls mt lu lv lw ig bi translated">要可视化iterable和iterator之间的连接，请参见下图。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ov"><img src="../Images/2c466bb942748b966629eb84ae0a5a3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1TdSAot8QvmidIw8lQ7pEQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">The connection between iterable and iterator</figcaption></figure><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ow"><img src="../Images/40d455ed760676d291346f96d6ee1cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwJuXAHygbSZF3fT3RRyfw@2x.png"/></div></div></figure><h1 id="d1e6" class="lx ly in bd lz ma mb mc md me mf mg mh kc mi kd mj kf mk kg ml ki mm kj mn mo bi translated">⌨️表演时间</h1><p id="5a93" class="pw-post-body-paragraph lb lc in ld b le mp jx lg lh mq ka lj lk mr lm ln lo ms lq lr ls mt lu lv lw ig bi translated">好了，理论到此为止。让我们看一些例子。我们将从一些基本的例子开始，然后一点一点地添加我们到目前为止学到的东西，使事情变得更有趣。</p><h2 id="d27a" class="oc ly in bd lz od oe dn md of og dp mh lk oh oi mj lo oj ok ml ls ol om mn it bi translated">范围迭代器</h2><p id="3b84" class="pw-post-body-paragraph lb lc in ld b le mp jx lg lh mq ka lj lk mr lm ln lo ms lq lr ls mt lu lv lw ig bi translated">让我们从一个非常基本的迭代器开始，<code class="fe nj nk nl nm b">createRangeIterator</code>迭代器。</p><p id="8984" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">我们手动调用<code class="fe nj nk nl nm b">it.next()</code>来获得下一个<code class="fe nj nk nl nm b">IteratorResult</code>。最后一次调用返回<code class="fe nj nk nl nm b">{ done: true }</code>，这意味着迭代器现在被消耗掉了，不会再产生更多的值。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Simple iterator</figcaption></figure><h2 id="a895" class="oc ly in bd lz od oe dn md of og dp mh lk oh oi mj lo oj ok ml ls ol om mn it bi translated">可迭代范围迭代器</h2><p id="bfe6" class="pw-post-body-paragraph lb lc in ld b le mp jx lg lh mq ka lj lk mr lm ln lo ms lq lr ls mt lu lv lw ig bi translated">在本文的前面，我提到过JavaScript中的一些语句和表达式需要iterables。正因为如此，我们之前的例子在使用<code class="fe nj nk nl nm b">for ... of</code>循环时就不起作用了。</p><p id="9b95" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">但是创建一个同时符合<strong class="ld ix">迭代器</strong>和<strong class="ld ix">可迭代</strong>协议的对象是很容易的。</p><p id="753b" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">为了形象化这一点，请参见下图。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi oz"><img src="../Images/f4b83fe1b47be35de1f9f964a5eef9ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UWjzovTCbTj2nCMRyYB0KQ.png"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">An object that is both iterable and iterator</figcaption></figure><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Iterable iterator</figcaption></figure><h2 id="f98e" class="oc ly in bd lz od oe dn md of og dp mh lk oh oi mj lo oj ok ml ls ol om mn it bi translated">无限序列迭代器</h2><p id="708d" class="pw-post-body-paragraph lb lc in ld b le mp jx lg lh mq ka lj lk mr lm ln lo ms lq lr ls mt lu lv lw ig bi translated">迭代器可以表达无限大小的序列，因为它们只在你需要时才计算值。</p><p id="7594" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">注意不要在无限迭代器上使用扩展运算符(<code class="fe nj nk nl nm b">...</code>)。JavaScript会尝试消耗迭代器，因为迭代器是无限的，所以它永远不会到达终点。相反，你的应用会崩溃，因为你会耗尽内存。</p><p id="b633" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">此外,<code class="fe nj nk nl nm b">for ... of</code>循环在这样的iterable上将是无止境的。确保退出循环。否则，你也会耗尽内存。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Infinite iterator</figcaption></figure><h2 id="bf4c" class="oc ly in bd lz od oe dn md of og dp mh lk oh oi mj lo oj ok ml ls ol om mn it bi translated">结束迭代器</h2><p id="240e" class="pw-post-body-paragraph lb lc in ld b le mp jx lg lh mq ka lj lk mr lm ln lo ms lq lr ls mt lu lv lw ig bi translated">前面我们提到迭代器可以选择一个<code class="fe nj nk nl nm b">return()</code>方法。当迭代器直到末尾才被迭代时，使用该方法，并让迭代器进行清理。</p><p id="e3e6" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated"><code class="fe nj nk nl nm b">for ... of</code>循环可以通过以下方式提前终止迭代:</p><ul class=""><li id="42d1" class="mu mv in ld b le lf lh li lk mw lo mx ls my lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">break</code></li><li id="b720" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">continue</code>(当你用标签继续外循环时)</li><li id="3ac3" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">throw</code></li><li id="784a" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">return</code></li></ul><p id="bfdd" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">以下构造关闭未被消费的迭代器:</p><ul class=""><li id="0c7d" class="mu mv in ld b le lf lh li lk mw lo mx ls my lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">for ... of</code></li><li id="fa96" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">yield*</code></li><li id="8412" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated">解构</li><li id="6fec" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">Array.from</code></li><li id="2810" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">Map(), Set(), WeakMap(), WeakSet()</code></li><li id="fa3c" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><code class="fe nj nk nl nm b">Promise.all(), Promise.race()</code></li></ul><p id="e282" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">摘自<a class="ae ni" href="https://2ality.com/2015/02/es6-iteration.html" rel="noopener ugc nofollow" target="_blank">https://2ality.com/2015/02/es6-iteration.html</a>。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Iterator cleanup through return()</figcaption></figure><ul class=""><li id="b5f6" class="mu mv in ld b le lf lh li lk mw lo mx ls my lw mz na nb nc bi translated">如果你知道迭代器已经到达终点，你可以手动调用<code class="fe nj nk nl nm b">cleanup()</code>函数。</li><li id="4cb4" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated">如果有一个突然的完成，那么<code class="fe nj nk nl nm b">return()</code>就会开始为我们做清理工作。</li></ul><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ow"><img src="../Images/40d455ed760676d291346f96d6ee1cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwJuXAHygbSZF3fT3RRyfw@2x.png"/></div></div></figure><h1 id="0751" class="lx ly in bd lz ma mb mc md me mf mg mh kc mi kd mj kf mk kg ml ki mm kj mn mo bi translated">💥额外的</h1><p id="3ae5" class="pw-post-body-paragraph lb lc in ld b le mp jx lg lh mq ka lj lk mr lm ln lo ms lq lr ls mt lu lv lw ig bi translated">如果你已经做到这一步了，我们再补充一些额外的东西。</p><h2 id="ee68" class="oc ly in bd lz od oe dn md of og dp mh lk oh oi mj lo oj ok ml ls ol om mn it bi translated">组合子</h2><p id="b1a0" class="pw-post-body-paragraph lb lc in ld b le mp jx lg lh mq ka lj lk mr lm ln lo ms lq lr ls mt lu lv lw ig bi translated">组合子是组合现有的可重复项来创建新的可重复项的函数。可重复的组合。</p><p id="375a" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">正因为如此，我们能够创建许多实用函数。<code class="fe nj nk nl nm b">map</code>或者<code class="fe nj nk nl nm b">filter</code>怎么样？看到下面的代码，给它一分钟的时间来理解。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="ox oy l"/></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Combinators</figcaption></figure><p id="0f27" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">耶！代码太多了。很快我们将会看到如何使用<strong class="ld ix">生成器</strong>和<strong class="ld ix">函数式编程概念</strong>来重构这一切。您会惊讶于所有这些代码可以变得多么紧凑。</p><p id="5ba6" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">保持安全，保持关注，并留意我即将到来的文章，我们仍然有很多要涵盖。</p><p id="cf02" class="pw-post-body-paragraph lb lc in ld b le lf jx lg lh li ka lj lk ll lm ln lo lp lq lr ls lt lu lv lw ig bi translated">下次见。<strong class="ld ix">🐺阿尔法，完毕。</strong></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ow"><img src="../Images/40d455ed760676d291346f96d6ee1cca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dwJuXAHygbSZF3fT3RRyfw@2x.png"/></div></div></figure><h1 id="46b3" class="lx ly in bd lz ma mb mc md me mf mg mh kc mi kd mj kf mk kg ml ki mm kj mn mo bi translated">资源</h1><ul class=""><li id="4d27" class="mu mv in ld b le mp lh mq lk pa lo pb ls pc lw mz na nb nc bi translated"><a class="ae ni" href="https://exploringjs.com/es6/ch_iteration.html" rel="noopener ugc nofollow" target="_blank">https://exploringjs.com/es6/ch_iteration.html</a></li><li id="a1b5" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><a class="ae ni" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Guide/Iterators _ and _ Generators</a></li><li id="0915" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><a class="ae ni" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" rel="noopener ugc nofollow" target="_blank">https://developer . Mozilla . org/en-US/docs/Web/JavaScript/Reference/Iteration _ protocols</a></li><li id="2161" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><a class="ae ni" href="https://swizec.com/blog/finally-a-practical-use-case-for-javascript-generators/" rel="noopener ugc nofollow" target="_blank">https://swi zec . com/blog/finally-a-practical-use-case-for-JavaScript-generators/</a></li><li id="81ed" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><a class="ae ni" href="https://2ality.com/2015/02/es6-iteration.html" rel="noopener ugc nofollow" target="_blank">https://2ality.com/2015/02/es6-iteration.html</a></li><li id="0660" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><a class="ae ni" href="https://www.freecodecamp.org/news/how-and-why-you-should-use-python-generators-f6fb56650888/" rel="noopener ugc nofollow" target="_blank">https://www . freecodecamp . org/news/how-and-why-you-should-use-python-generators-f6fb 56650888/</a></li><li id="ad77" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><a class="ae ni" href="https://vegibit.com/iterators-in-es6/#:~:text=ES6%20now%20has%20what's%20known,that%20returns%20an%20iterator%20object" rel="noopener ugc nofollow" target="_blank">https://vegi bit . com/iterators-in-ES6/#:~:text = ES6 % 20 now % 20 has % 20 what % 20 known，that % 20 returns % 20 an % 20 iterator % 20 object</a>。</li><li id="1904" class="mu mv in ld b le nd lh ne lk nf lo ng ls nh lw mz na nb nc bi translated"><a class="ae ni" href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/Lazy_evaluation</a></li></ul></div></div>    
</body>
</html>