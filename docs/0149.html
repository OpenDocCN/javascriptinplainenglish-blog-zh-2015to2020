<html>
<head>
<title>Here’s that resource on JavaScript closures you were looking for</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">这是您正在寻找的关于JavaScript闭包的资源</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/heres-that-resource-on-javascript-closures-you-were-looking-for-95e82b8108f2?source=collection_archive---------1-----------------------#2019-05-14">https://javascript.plainenglish.io/heres-that-resource-on-javascript-closures-you-were-looking-for-95e82b8108f2?source=collection_archive---------1-----------------------#2019-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/3bed7e2beff19e83d4d4abb7420e6dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*7IF3YOUltCeOS8MF2m97sw.png"/></div></figure><div class=""/><p id="0a1e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">观众</em>:任何想以实用的方式学习闭包的人，尤其是那些想尝试编码练习来证明自己已经学会的人。这并不意味着深奥的计算机科学术语。</p><p id="4bb4" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当我还是讲师的时候，JavaScript学习者经常问我学习某个主题的资源。我通常没有什么特别喜欢的，特别是因为我非常喜欢自己寻找这种资源的<em class="ks">过程</em>；我认为努力本身是有帮助的，特别是当你使用多种资源时，因为你可以从多个角度看到教授的主题。但是有一个话题被问得最多，那就是闭包。所以我决定创建一个资源来指引人们。</p><h2 id="e03b" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">症结所在</h2><p id="3806" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">闭包是一种通过传递/返回函数来提供对作用域的受控访问的方式(否则这是不可能的)。</p><p id="f525" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">JavaScript中的所有函数都是闭包。如果您已经编写了一些JavaScript，那么您可能已经编写了闭包而没有意识到这一点(见上一点)。好消息是，闭包比解释起来更容易编写/使用。如果你尝试一下，它们也更容易学习，而不仅仅是阅读它们，所以这篇文章将允许你自己尝试一下。我将给出一些闭包的实际用例，以及测试您理解的编码挑战。</p><h1 id="9ae6" class="lr ku ix bd kv ls lt lu ky lv lw lx lb ly lz ma le mb mc md lh me mf mg lk mh bi translated">审查:范围</h1><p id="d3e1" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">要理解闭包，你必须理解作用域。谢天谢地，这很简单。范围意味着您可以访问哪些值。如果你可以访问某个值，我们说它“在范围内”，否则我们说它“在范围外”。对于任何函数，它可以访问直接在函数内部或外部创建的任何变量，但不能访问嵌套函数内部的变量。不幸的是,“在作用域内/在作用域外”的说法似乎与规则背道而驰，但事实就是如此:在嵌套函数中创建的变量在作用域外，而在函数外创建的值在函数的作用域内。(我省略了ES6的块范围概念，因为块不是一等公民，这意味着它们不能像函数那样被传递。)</p><p id="920e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你想知道，从计算机的角度来看，没有“超出范围”这种东西。对计算机来说，值要么在范围内，要么未知。换句话说，您永远不会看到“超出范围”的错误，您只会得到类似“myVariable is not defined”的错误。只有阅读源代码的人才能看到超出范围的值。</p><p id="30be" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">尝试在这个repl.it中使用scope。在表示它们不起作用的行中添加注释，按下绿色的run按钮，然后观察错误。</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">You can play with this code to try things! Press the green Run button to run the code and see the output in the lower half.</figcaption></figure><p id="20c6" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有一个范围链的概念。作用域链只是指当你在函数自身作用域之外查看它的包含作用域，或者在<em class="ks">它的</em>包含作用域之外，等等。我不会再提到它了，只要把作用域链中所有可访问的值都看作“在作用域内”就足够了。</p><p id="a039" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">顺便说一句，如果你看到不在任何函数中的代码，它被认为是全局的，你仍然可以以同样的方式考虑它:就好像<code class="fe ms mt mu mv b">function() {</code>在第0行，右括号<code class="fe ms mt mu mv b">}</code>在最后一行之后。规则不会改变。</p><p id="8f8e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">关于范围有趣的一点是，它可以在代码运行之前确定，这意味着范围在运行时不能改变。</p><p id="c2c2" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">想打个比方吗？Scope就像一个由一系列同心墙组成的城堡，每一层都被提升了一个级别。从每一层你都可以看到外面，但是从外面你看不到里面。</p><figure class="mi mj mk ml gt is gh gi paragraph-image"><div role="button" tabindex="0" class="mx my di mz bf na"><div class="gh gi mw"><img src="../Images/764e6f3e1097cdc393a913341bde268d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*lbsYbRuSkjib8KYn"/></div></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">See how you can see out from the inner sections, but you can’t see in? — Photo by <a class="ae nb" href="https://unsplash.com/@suicide_chewbacca?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ashwini Chaudhary</a> on <a class="ae nb" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="89c7" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">思考:当然，你必须能够访问函数外部的值，否则任何函数怎么能引用其他函数呢？在下面的场景中，<code class="fe ms mt mu mv b">b</code>因为规则可以调用<code class="fe ms mt mu mv b">a</code>，否则<code class="fe ms mt mu mv b">b</code>连<code class="fe ms mt mu mv b">a</code>都调用不了，那我们会在哪里？！</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="1d7a" class="kt ku ix mv b gy ng nh l ni nj">function a() {<br/>  // stuff<br/>}</span><span id="32f8" class="kt ku ix mv b gy nk nh l ni nj">function b() {<br/>  a()<br/>}</span></pre><h1 id="75c2" class="lr ku ix bd kv ls lt lu ky lv lw lx lb ly lz ma le mb mc md lh me mf mg lk mh bi translated">让我们违反范围规则！我们第一次结案</h1><p id="d22b" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">首先，仔细检查您是否理解了这一点:在JavaScript中，函数可以传递，就像数字或字符串一样。我们可以将它们作为参数传递，也可以从函数中返回。</p><p id="e3fe" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">明白了吗？很好。因为这就是闭包让我们访问我们不应该被允许访问的变量的方式。</p><p id="846f" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">看看这个。我们第一次结案。它不应该与我们的范围规则一起工作，但是它完全工作。</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Don’t forget you can run this code with the green Run button</figcaption></figure><p id="e699" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">大家讨论一下。我们调用<code class="fe ms mt mu mv b">outer</code>，它声明了一个局部变量<code class="fe ms mt mu mv b">x</code>。然后我们声明一个函数<code class="fe ms mt mu mv b">inner</code>，它可以访问自身外部的值，即<code class="fe ms mt mu mv b">x</code>。然后，我们将<code class="fe ms mt mu mv b">inner</code>传递给函数<code class="fe ms mt mu mv b">other</code>(此时，<code class="fe ms mt mu mv b">fn</code>和<code class="fe ms mt mu mv b">inner</code>是对同一个函数的引用)。接下来<code class="fe ms mt mu mv b">other</code>调用<code class="fe ms mt mu mv b">fn</code>。由于<code class="fe ms mt mu mv b">fn</code> <em class="ks">是</em> <code class="fe ms mt mu mv b">inner</code>，它可以访问<code class="fe ms mt mu mv b">x</code>，并且能够<code class="fe ms mt mu mv b">console.log</code>它。</p><p id="4e50" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">需要说明的是，<code class="fe ms mt mu mv b">inner</code> <em class="ks">是</em>的闭包。它是一个闭包，因为1)它是一个函数，2)它被传递并从其他地方调用。这个“其他地方”通常不会访问<code class="fe ms mt mu mv b">x</code>。它仍然没有完全的访问权限，唯一的访问权限是调用我们的函数<code class="fe ms mt mu mv b">inner</code>，在函数内部我们可以对<code class="fe ms mt mu mv b">x</code>做任何我们想做的事情。在这种情况下，我们控制台记录它，但我们可以做任何我们想做的事情。我们创造了它，我们控制着它，这就是闭包的力量。</p><p id="dc61" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">令人惊讶的是，我们实际上根本没有违反我们的范围规则。函数<code class="fe ms mt mu mv b">other</code>不访问<code class="fe ms mt mu mv b">x</code>，它只是调用名为<code class="fe ms mt mu mv b">inner</code>(通过<code class="fe ms mt mu mv b">fn</code>)的函数，而<em class="ks"/>可以访问<code class="fe ms mt mu mv b">x</code>。我们得到了一个教训:函数在它们被创建的范围内运行，而不是在它们被调用的地方运行。</p><p id="a512" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以，你可能听说过不同方式的闭包。我听过的一种方法是“从其他函数返回的函数”，这不一定是真的(例如，如果闭包是通过函数参数传递的)，也不能解释它们在编程中的价值。</p><p id="482c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">尝试更多:</em>在上面的repl.it演示区域中，我们创建了一个名为<code class="fe ms mt mu mv b">inner</code>的独立函数，然后在下面一行将其传递给<code class="fe ms mt mu mv b">other</code>函数。我们不必这样做，可以传递一个匿名函数。看看你能不能做到，还有<a class="ae nb" href="https://repl.it/@tylercollier/first-closure-anonymous" rel="noopener ugc nofollow" target="_blank">点击这里查看答案</a>。</p><h1 id="4fdb" class="lr ku ix bd kv ls lt lu ky lv lw lx lb ly lz ma le mb mc md lh me mf mg lk mh bi translated">它还活着！</h1><p id="39f4" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">通常，当<code class="fe ms mt mu mv b">outer</code>函数结束时(意味着它的最后一行被运行)，在它内部创建的所有局部值都不再可访问。但是现在我们有一个特殊的情况。我们有一个使用本地值<code class="fe ms mt mu mv b">x</code>的函数<code class="fe ms mt mu mv b">inner</code>，这个函数正在其他地方使用(<code class="fe ms mt mu mv b">other</code>)。即使在调用了<code class="fe ms mt mu mv b">fn</code>之后，我们也可以再次调用它，并且仍然可以访问<code class="fe ms mt mu mv b">x</code>。让我们看看下面的实际情况。在这个场景中，我们不仅要记录<code class="fe ms mt mu mv b">x</code>，还要修改它。</p><p id="c61d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你理解引用的概念，你就会知道如果你创建一个局部引用，比如一个数组，并把它传递给另一个函数，那么这个值本身就可以继续存在。但是，局部变量还是“死”了。</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="403c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在<code class="fe ms mt mu mv b">inner</code>函数中，我们现在有了<code class="fe ms mt mu mv b">x++</code>。每次调用我们的函数，x都会递增，然后被记录。因为这里调用了一次，所以x会从5变成6。</p><p id="db6e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><em class="ks">试一下:</em>在上面的repl.it中，试着从<code class="fe ms mt mu mv b">other</code>多打几个电话给<code class="fe ms mt mu mv b">fn()</code>，看看x的值变化。</p><h1 id="7c67" class="lr ku ix bd kv ls lt lu ky lv lw lx lb ly lz ma le mb mc md lh me mf mg lk mh bi translated">闭包为什么有用？</h1><p id="5280" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">前面我说过闭包提供了对作用域的受控访问。但是我们关心的范围是什么呢？变量。描述闭包价值的另一种方式是:闭包允许我们有效地创建<em class="ks">私有</em>变量。JavaScript中没有关键字<em class="ks"> private </em>，但是如果我们有局部变量，由于作用域的规则，它们不能从外部改变，所以它们实际上是私有的。</p><p id="28c9" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">私有变量为什么好？</p><p id="50d4" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">私有变量允许我们做事情，没有人能决定我们怎么做。假设我们没有这个能力去做私有变量。假设我写了一个函数，在中间，我计算了一些值，我把它放在一个变量里，因为它不能是私有的，所以它是公共的。你决定这个值因为某种原因对你有用，你开始写代码调用我的函数，然后使用这个值。后来，我改变了我的函数，我不再计算/创造那个值。嘣，你的代码坏了！但是如果我允许私有变量，你的代码将不能使用我的代码值(除非我选择公开它们)。因此，您的代码将不会依赖于我的代码；没有引入依赖性。我们称之为封装。</p><p id="fee4" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">当它们是私有的时，这意味着在声明它们的函数内部是唯一可以修改它们的地方，这意味着我们必须检查可能存在的错误的源代码数量大大减少。让我们考虑私有变量的反面，在JavaScript中是对象属性。如果你传递一个对象，任何接收到该对象的代码都可能改变这些属性，这意味着如果有更多地方的属性发生改变，你的程序可能更难调试。冻结对象或禁止属性被更改的情况很少见，但在技术上是可能的。现在你知道为什么这样做了:更少的错误。</p><p id="5187" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我忽略了全局变量，<a class="ae nb" href="https://stackoverflow.com/a/485020/135101" rel="noopener ugc nofollow" target="_blank">它们是坏的</a>，原因完全相同，只是问题被放大了，因为任何代码都可以修改全局变量。</p><p id="10b8" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你来自面向对象的编程背景，这个解释<a class="ae nb" href="http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html" rel="noopener ugc nofollow" target="_blank">闭包和对象是等价的</a>的故事可能会有帮助。</p><h2 id="56f9" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">实际例子</h2><p id="cc58" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">如果您熟悉React，您可能一直在使用闭包，但并没有意识到这一点。如果你不熟悉React，目前你需要知道的是我们可以分别构建两个网页(组件),它们不应该知道彼此内部发生了什么。每个组件都可以有自己的状态，一个组件不能直接改变另一个组件的状态。</p><p id="efbc" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在下面的代码中，我们有自己的组件App，它使用了一个按钮组件。我们的应用程序中有一些状态，叫做counter。按钮组件不能直接改变App的状态。但是如果你点击按钮，计数器就会增加。不知何故，一个组件变异了另一个。为什么允许这样做？</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="nl mn l"/></div></figure><p id="a22b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">答案是按钮组件没有直接改变App的状态。我们给按钮组件一个闭包(通过onClick prop传递的匿名函数)，当按钮被单击时，它调用闭包。换句话说，应用程序组件在按钮的请求下改变了自己的状态。</p><p id="78e6" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在下一节中，有几个更实际的闭包用例。</p><h1 id="a248" class="lr ku ix bd kv ls lt lu ky lv lw lx lb ly lz ma le mb mc md lh me mf mg lk mh bi translated">我们来谈谈封闭这个词</h1><p id="7e89" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">人们经常将闭包描述为“封闭”一些变量的代码。我觉得这个描述对没有更深背景的程序员没什么用，所以对大多数人来说，我会说忽略这个定义。但是另一种说法是，如果一个函数不使用在它自身之外定义的变量，它就不是闭包，因为没有什么需要封闭的。</p><p id="b700" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果你回头看看前面的“我们的第一次闭包”代码，不幸的是，许多人会说<code class="fe ms mt mu mv b">outer</code>“封闭”了在其中创建的变量，他们甚至会在函数周围画一些虚线，试图直观地表示它。但问题是，<code class="fe ms mt mu mv b">outer</code>不是闭包，<code class="fe ms mt mu mv b">inner</code>才是，而且，它不封闭在 <code class="fe ms mt mu mv b">outer</code>内创建的变量<em class="ks">，而是封闭在</em> <code class="fe ms mt mu mv b">inner</code>外的变量<em class="ks">。为了更好地理解和形象化它，继续阅读。</em></p><h1 id="429a" class="lr ku ix bd kv ls lt lu ky lv lw lx lb ly lz ma le mb mc md lh me mf mg lk mh bi translated">闭包是“快照”吗？</h1><p id="2c41" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">我还听说闭包被描述为“它们环境的快照”，宝丽来相机的照片打印被描述为<code class="fe ms mt mu mv b">outer</code>功能的每次使用。我认为宝丽来图片的想法令人困惑，因为就像照相机捕捉某个时间点的事物一样，它暗示了变量当前<em class="ks">值</em>的快照。但是闭包与值无关，而是与范围有关。</p><p id="c3ea" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但是为什么要用“环境”这个词呢？因为每次我们调用<code class="fe ms mt mu mv b">outer</code>函数时，都会创建一个有自己变量的新环境。(需要明确的是，环境这个词是描述性的，而不是技术术语。)如果你想要一个环境的视觉图像，那就是图中虚线所示的东西:</p><figure class="mi mj mk ml gt is gh gi paragraph-image"><div class="gh gi io"><img src="../Images/3bed7e2beff19e83d4d4abb7420e6dcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:662/format:webp/1*7IF3YOUltCeOS8MF2m97sw.png"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">The inner function has closed over these other values. Each call to outer creates a new environment of the variables inside outer.</figcaption></figure><p id="9799" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">如果我们调用<code class="fe ms mt mu mv b">outer</code>两次，每个都有自己的<code class="fe ms mt mu mv b">y</code>，每个<code class="fe ms mt mu mv b">y</code>都有自己的值。在下面的例子中，我们将展示如何返回一个闭包，我们将调用这个闭包来显示不同的值。</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="f207" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们来分解一下上面的。我们调用了两次<code class="fe ms mt mu mv b">outer</code>函数。因为它返回一个函数，所以每个对<code class="fe ms mt mu mv b">outer</code>的调用都建立了自己的环境，每个环境都有一个变量<code class="fe ms mt mu mv b">x</code>。那个<code class="fe ms mt mu mv b">x</code>变量每次从5开始，但是因为我们调用了<code class="fe ms mt mu mv b">inner1</code> 3次，所以它最终是8。因为我们只调用了一次<code class="fe ms mt mu mv b">inner2</code>，所以它的<code class="fe ms mt mu mv b">x</code>是6。</p><h2 id="cc54" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">挑战:初始化价值观</h2><p id="3448" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">在上面的例子中，<code class="fe ms mt mu mv b">x</code>总是从5开始。如果我们想动态地设置它，有时是5，有时是99，等等，会怎么样呢？看你能不能想出来<a class="ae nb" href="https://repl.it/@tylercollier/initializing-values" rel="noopener ugc nofollow" target="_blank">在这里查答案</a>。</p><h1 id="f1b5" class="lr ku ix bd kv ls lt lu ky lv lw lx lb ly lz ma le mb mc md lh me mf mg lk mh bi translated">模块模式</h1><p id="76b3" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">如果我们的闭包做了<code class="fe ms mt mu mv b">x++</code>，这意味着无论谁使用它，每次都只能增加x。没别的了。但是如果我们也想让他们做其他事情呢？比如，如果我们想让他们增加x，或者重置它，就这样？好吧，我们只需要再来一次闭合复位。这就是模块模式:多重闭包。在JavaScript中，我们不是传递或返回单个函数，而是使用一个对象，其中多个属性都是函数。让我们来看看它的实际应用:</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="32ac" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可以看到我不再使用名字<code class="fe ms mt mu mv b">outer</code>作为外部函数，因为我们不再有单一的<code class="fe ms mt mu mv b">inner</code>函数。我们返回一个对象，其中每个值都是一个闭包的函数。</p><p id="10fb" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为什么叫模块？模块(在生活中)是自己做一些事情，然后与它们插入的一些系统交互的东西。例如，你可以在你的公寓里安装一台窗式空调。它自己冷却空气，然后将空气送入室内。我们的模块的值是孤立存在的，唯一可以与之交互的方式是通过它公开的函数(也称为“公共”函数)。如果我们记录由<code class="fe ms mt mu mv b">makeModule</code>返回的值，我们会看到<code class="fe ms mt mu mv b">increment</code>和<code class="fe ms mt mu mv b">reset</code>，但是我们不会看到<code class="fe ms mt mu mv b">x</code>。</p><h2 id="4e3a" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">挑战:制作自己的模块</h2><p id="c79a" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">尝试从头开始制作和使用自己的模块。您可以<a class="ae nb" href="https://repl.it/languages/javascript" rel="noopener ugc nofollow" target="_blank">使用这个链接创建一个新的repl.it </a>。你的目标是创建一个计数器，类似于我们一直在做的。允许动态设置起始值。该模块应该公开两个函数:<code class="fe ms mt mu mv b">reset </code>将值设置为初始值，以及<code class="fe ms mt mu mv b">decrement</code>将值减少5。<a class="ae nb" href="https://repl.it/@tylercollier/make-your-own-module-answer" rel="noopener ugc nofollow" target="_blank">看到这里的回答</a>。</p><h1 id="18f5" class="lr ku ix bd kv ls lt lu ky lv lw lx lb ly lz ma le mb mc md lh me mf mg lk mh bi translated">闭包的实际用途</h1><h2 id="01dd" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">排名第一的私人价值</h2><p id="2e8b" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">正如前面React例子中所描述的，当您需要私有变量时，闭包是非常有用的。考虑一下，我们没有使用闭包，而是使用了一个类。它只是创建了一个所有值都可以公开更改的对象。</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Class version of Employee</figcaption></figure><p id="c196" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们创建了一个雇员类。我们在<code class="fe ms mt mu mv b">setJobType</code>方法中编写了代码，只允许两个值，“worker”和“manager”。但是对象上的所有值都是公共的，可以被任何代码更改。未显示:我们甚至可以从对象中删除<code class="fe ms mt mu mv b">jobType</code>键！</p><p id="a273" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在比较一下使用模块模式的多个闭包:</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="mm mn l"/></div><figcaption class="mo mp gj gh gi mq mr bd b be z dk">Closure version of Employee</figcaption></figure><p id="79e9" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为了能够获取值，我们必须使用getter，为了设置作业类型，我们必须使用它的setter，因为所有的数据都是私有的。我们不能将作业类型设置为任意值。这是好事。</p><h2 id="0289" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">#2获取价值</h2><p id="66e4" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">您一直都在这么做，但是可能没有意识到您正在使用闭包。每当你创建一个函数，并在函数内部使用外部的值时，你已经捕获了那个值并创建了一个“适当的闭包”。这个术语，恰当的结束，不是任何人都有的定义，但是它很有用。我认为它就像术语“真子集”，它区别于术语子集，后者可能是真子集，也可能不是。如果一个函数不使用在它外部定义的值，那么你不会称它为闭包。</p><p id="5a5c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">获取值的一些常见示例如下:</p><p id="55af" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ms mt mu mv b">setTimeout</code></p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="9d30" class="kt ku ix mv b gy ng nh l ni nj">const message = 'hello from a closure'</span><span id="fb9c" class="kt ku ix mv b gy nk nh l ni nj">setTimeout(() =&gt; {<br/>  console.log(message)<br/>}, 1000)</span><span id="9120" class="kt ku ix mv b gy nk nh l ni nj">// or, same thing on one line<br/>setTimeout(() =&gt; console.log(message), 1000)</span></pre><p id="405c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们传递给<code class="fe ms mt mu mv b">setTimeout</code>的函数是一个闭包。它关闭变量<code class="fe ms mt mu mv b">message</code>。</p><p id="0184" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">试图在没有闭包的情况下有意义地使用setTimeout是困难的！您可以在控制台记录一个字符串文字，如“计时器命中”。但除此之外，您可能会在回调中引用一个变量，该变量存在于setTimeout通常无法访问的范围内。请记住，内置的setTimeout函数本身是在某个外部作用域(在某个其他文件中)中声明的，无法“进入”您赋予它的函数。</p><p id="d3c3" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ms mt mu mv b">(array).map</code></p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="ba01" class="kt ku ix mv b gy ng nh l ni nj">const colors = [<br/>  { name: 'Pink', hex: '#ffc0cb'},<br/>  { name: 'Red', hex: '#ff0000' }<br/>]</span><span id="1229" class="kt ku ix mv b gy nk nh l ni nj">const date = Date.now()</span><span id="5355" class="kt ku ix mv b gy nk nh l ni nj">const colorsWithDate = colors.map(color =&gt; {<br/>  return { ...color, createdAt: date }<br/>})</span></pre><p id="8816" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">在这里，我们通过向<code class="fe ms mt mu mv b">.map</code>传递闭包来关闭<code class="fe ms mt mu mv b">date</code>。</p><p id="a159" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><code class="fe ms mt mu mv b">(array).filter</code></p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="34e8" class="kt ku ix mv b gy ng nh l ni nj">const regex = /^T/<br/>const names = ['Timothy', 'Alicia', 'Tre']<br/>const namesStartingWithT = names.filter(name =&gt; regex.test(name))</span></pre><p id="9b98" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">琐事:我们在上面关闭了什么变量？</p><h2 id="f723" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">#3构建其他函数的函数</h2><p id="5863" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">这里真正的术语是“高阶函数”，意思是接受一个函数和/或返回一个函数的函数。我们已经讨论过将其他函数作为参数的函数，比如接受闭包的<code class="fe ms mt mu mv b">setTimeout</code>、<code class="fe ms mt mu mv b">(array).map</code>、<code class="fe ms mt mu mv b">(array).filter</code>，所以我想专门讨论返回函数的函数(这会创建一个闭包)。我们可以把这些函数构造器叫做函数包装器，或者，如果它们接受一个函数并做一些除了调用原始函数之外的事情。</p><p id="7f9b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">示例A:日志包装器</strong></p><p id="4f6b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里有一个我经常遇到的恼人的情况。你设置一个按钮点击处理程序来做一些简单的事情，它是一个不需要花括号的箭头函数。</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="84bc" class="kt ku ix mv b gy ng nh l ni nj">let x = 0<br/>button.addEventListener('click', () =&gt; x++)</span></pre><p id="e105" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你运行你的程序，但你的应用程序似乎不工作。您想知道您的处理程序是否正在运行。也许有什么东西拦截了你的鼠标点击？谁知道呢。所以您添加了这样一条日志消息:</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="8485" class="kt ku ix mv b gy ng nh l ni nj">let x = 0<br/>button.addEventListener('click', () =&gt; {<br/>  console.log('incrementing x')<br/>  x++<br/>})</span></pre><p id="e8ae" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">嗯，这有点烦人！我们必须加上花括号，因为我们需要运行两条语句。但是如果我们有这个功能呢:</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="7396" class="kt ku ix mv b gy ng nh l ni nj">function logWrap(fn) {<br/>  return function(...args) {<br/>    console.log('Got here')<br/>    return fn(...args)<br/>  }<br/>}</span></pre><p id="a36a" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后，我们可以这样做:</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="37d7" class="kt ku ix mv b gy ng nh l ni nj">let x = 0<br/>button.addEventListener('click', logWrap(() =&gt; x++))</span></pre><p id="5b49" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">清爽！当我们发现我们正在处理的任何问题并且不再需要日志记录时，添加和删除就简单多了。</p><p id="916e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">缺点是，如果我们用它来包装多个函数，它总是说<code class="fe ms mt mu mv b">Got here</code>，所以很难判断哪个函数导致了日志。但是如果我们这样做呢:</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="596d" class="kt ku ix mv b gy ng nh l ni nj">function logWrap(message, fn) {<br/>  return function(...args) {<br/>    console.log(message)<br/>    return fn(...args)<br/>  }<br/>}</span></pre><p id="d3a1" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我们可以这样使用它:</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="ab46" class="kt ku ix mv b gy ng nh l ni nj">let x = 0<br/>plus.addEventListener('click', logWrap('incrementing', () =&gt; x++))<br/>minus.addEventListener('click', logWrap('decrementing', () =&gt; x--))</span></pre><p id="4106" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">现在我们有了自定义消息，不需要花括号了。</p><p id="e17f" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">但实际上最好像下面这样构建它:</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="4953" class="kt ku ix mv b gy ng nh l ni nj">function logWrap(message) {<br/>  return function(fn) {<br/>    return function (...args) {<br/>      console.log(message)<br/>      return fn(...args)<br/>    }<br/>  }<br/>}</span><span id="a640" class="kt ku ix mv b gy nk nh l ni nj">// Use like this<br/>plus.addEventListener('click', logWrap('incrementing')(() =&gt; x++))</span></pre><p id="70da" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你看出区别了吗？现在<code class="fe ms mt mu mv b">logWrap</code>只接受一条消息，我们必须调用它，将函数传递给wrap。这种方式可以说更复杂，那么有什么好处呢？如果我们只做<code class="fe ms mt mu mv b">logWrap(‘decrementing’, someFunction)</code>一次，但是我们发现自己需要<code class="fe ms mt mu mv b">logWrap(‘incrementing’, someFunction)</code>很多次呢？写出来会变老。我们可以利用稍微复杂一点的logWrap函数来构建一个新的自定义函数，专门用于记录“增量”，如下所示:</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="adf9" class="kt ku ix mv b gy ng nh l ni nj">const logIncrementing = logWrap('incrementing')</span></pre><p id="7900" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">然后我们会这样使用它:</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="8579" class="kt ku ix mv b gy ng nh l ni nj">plus.addEventListener('click', logIncrementing(() =&gt; x++)))</span></pre><p id="9110" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">多棒啊。</p><p id="b57f" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">示例B:去抖</strong></p><p id="a388" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">去抖一个函数就是暂停这个函数运行一段时间，通常是为了让它不会在应该运行之前运行。一个很好的例子是在谷歌文档中，当你写东西时，它不会在每次击键后自动保存，因为那样会很浪费。它会等待一两秒钟，直到你暂停输入，然后保存。</p><p id="2a2e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设我们有一个文本框，我们想保存使用现有的<code class="fe ms mt mu mv b">save</code>函数输入的内容，但是只有在用户停止输入一秒钟之后。下面是我们如何在不使用单独的去抖功能的情况下实现这一点。</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="nl mn l"/></div></figure><p id="c7cc" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里我们已经使用了两个闭包，对<code class="fe ms mt mu mv b">addEventListener</code>的回调和对<code class="fe ms mt mu mv b">setTimeout</code>的回调。但是这里需要注意的是，我们有一个额外的变量(<code class="fe ms mt mu mv b">timeoutId1</code>和<code class="fe ms mt mu mv b">timeoutId2</code>)用于我们需要做的每个去抖。</p><p id="e4a4" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这是一个独立的去抖功能。</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="nl mn l"/></div></figure><p id="234b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">(由于CodeSandbox的自动格式化，格式看起来有些不同)</p><p id="1157" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">注意，我们用<code class="fe ms mt mu mv b">debounce</code>函数包装了对<code class="fe ms mt mu mv b">addEventListener</code>的回调，该函数返回一个闭包。这意味着每一个都有自己的环境或局部变量。结果是更干净的代码，因为我们没有像在上面的代码中那样让局部变量“弄乱”我们的范围。</p><h2 id="02b1" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">#4立即调用函数表达式(IIFEs)</h2><p id="67b9" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">您不能执行以下操作(注意后面的括号)，但假设您可以:</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="7295" class="kt ku ix mv b gy ng nh l ni nj">const someButton = document.getElementById('someButton')<br/>function() {<br/>  const a = 1<br/>  const b = -3<br/>  const c = -10<br/>  const divisor = 2 * a</span><span id="04bf" class="kt ku ix mv b gy nk nh l ni nj">  const ans1 = (-b + ) / divisor<br/>  const ans2 = (-b - Math.sqrt(Math.pow(b, 2) - 4*a*c)) / divisor<br/>  someButton.onclick = () =&gt; alert(`Answer is ${ans1} or ${ans2}`)<br/>}()</span></pre><p id="9e0b" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这样做的好处是什么？</p><p id="4340" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">事实证明，如果我们先用parens包装函数，我们就能做到。所以这个作品:<code class="fe ms mt mu mv b">(function() { console.log('hi') })()</code>。这种技术被称为立即调用函数表达式(IIFE)。好处是，我们可以创建尽可能多的变量，它们只存在于生命(这是一个闭包)内部，不会“泄漏”到闭包存在的范围内。甚至功能本身也只是暂时存在！如果我们有多个生命，这意味着每个生命都可以创建具有相同变量名的变量，它们不会冲突。得心应手！</p><p id="7bdb" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">为什么这是一个终结？这和运行任何一个命名函数没什么区别。我们不能从外部看到函数的内部，但是当我们运行它时，函数本身可以访问它的值。该函数可以访问在其外部创建的值，比如<code class="fe ms mt mu mv b">someButton</code>。</p><p id="1321" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">由于Webpack、Browserify等打包工具的出现，IIFEs在客户端JavaScript中已经不像以前那么流行了。我们曾经在一个页面上包含多个<code class="fe ms mt mu mv b">&lt;script&gt;</code>标签，每个标签都在全局范围内工作。如果一个脚本声明了一个名为<code class="fe ms mt mu mv b">someValue</code>的<code class="fe ms mt mu mv b">var</code>，那么后面的任何脚本都可以使用这个值。很容易创建难以理解变量从何而来或为什么要创建变量的意大利面条式代码，但这通常与其他脚本的集成有关。像Webpack这样的Bundler工具允许你将代码包装到不同的文件中，每个文件成为它自己的模块。它是怎么做到的？它所做的只是将代码包装在生活中。当你写道:</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="c79c" class="kt ku ix mv b gy ng nh l ni nj">const message = 'hello'<br/>export default () =&gt; console.log(message)</span></pre><p id="2752" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">Webpack有效地将其转化为:</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="ae8f" class="kt ku ix mv b gy ng nh l ni nj">(function() {<br/>  const message = 'hello'<br/>  return () =&gt; console.log(message)<br/>})()</span></pre><p id="d056" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">所以当我们写下:</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="af83" class="kt ku ix mv b gy ng nh l ni nj">import myModule from './MyModule'<br/>// Now use myModule here...</span></pre><p id="bd1d" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">…就好像我们写道:</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="e16a" class="kt ku ix mv b gy ng nh l ni nj">const myModule = (function() {<br/>  const message = 'hello'<br/>  return () =&gt; console.log(message)<br/>})()<br/>// Now use myModule here...</span></pre><p id="f9e1" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">您可以看到在<code class="fe ms mt mu mv b">MyModule</code>文件中声明的任何变量都不会影响它们被导入的位置。我们不能用<code class="fe ms mt mu mv b">message</code>，比如；它是模块私有的。</p><p id="ee57" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">我说生活没有以前那么普遍了。但是生活仍然有它的位置:</p><p id="9236" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">反应中的生命</strong></p><p id="b5ea" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">你可能听说过不能在React的<code class="fe ms mt mu mv b">render</code>方法中使用<code class="fe ms mt mu mv b">if</code>语句。但是你可以，如果你用生命！看看这个:</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="nl mn l"/></div></figure><p id="7811" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">生命可以干净地重新定义，例如setTimeout </strong></p><p id="ad1e" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">假设您想要覆盖setTimeout函数，以便所有超时控制台在运行之前记录一些消息。出于我们已经讨论过的原因，利用生命是件好事。其他代码仍然一如既往地使用<code class="fe ms mt mu mv b">setTimeout</code>，但是我们的闭包现在是唯一可以访问原始<code class="fe ms mt mu mv b">setTimeout</code>的代码！</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="c591" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">有趣的事实:如果你使用块作用域，那么在ES6中不需要生命。你基本上可以做和这样的生活一样的事情，使用一个匿名块:</p><pre class="mi mj mk ml gt nc mv nd ne aw nf bi"><span id="e510" class="kt ku ix mv b gy ng nh l ni nj">const someButton = document.getElementById('someButton')<br/>{<br/>  const a = 1<br/>  const b = -3<br/>  const c = -10<br/>  const divisor = 2 * a</span><span id="c906" class="kt ku ix mv b gy nk nh l ni nj">  const ans1 = (-b + ) / divisor<br/>  const ans2 = (-b - Math.sqrt(Math.pow(b, 2) - 4*a*c)) / divisor<br/>  someButton.onclick = () =&gt; alert(`Answer is ${ans1} or ${ans2}`)<br/>}<br/>// Could not access a, b, c, etc here</span></pre><p id="a95a" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">虽然我从没见过这样做的。我不确定为什么。</p><h1 id="6eee" class="lr ku ix bd kv ls lt lu ky lv lw lx lb ly lz ma le mb mc md lh me mf mg lk mh bi translated">自我测试</h1><p id="c900" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">你现在理解闭包了吗？试试这些练习。</p><h2 id="d714" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">测试1:通过一个闭包</h2><p id="88fa" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">请参见本回复中的说明:</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="54c0" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是答案:<a class="ae nb" href="https://repl.it/@tylercollier/test-yourself-set-timeout-answer" rel="noopener ugc nofollow" target="_blank">链接</a></p><h2 id="f98e" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">测试2:进行切换</h2><p id="c012" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">请参见此codesandbox中的说明:</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="nl mn l"/></div></figure><p id="4aa3" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是答案:<a class="ae nb" href="https://codesandbox.io/s/z21rqw4vm4" rel="noopener ugc nofollow" target="_blank">链接</a></p><h2 id="dce8" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">测试3:模块模式</h2><p id="9b82" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">记住模块模式仅仅意味着通过一个对象返回多个闭包。该对象有多个属性，每个属性都是一个访问函数局部变量的函数。</p><p id="2e85" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">挑战:创建一个<code class="fe ms mt mu mv b">makePlayer</code>函数，它采用一个<code class="fe ms mt mu mv b">name</code>和一个起始<code class="fe ms mt mu mv b">points</code>值。它应该有名字、点数和“级别”的私有变量，这是一个字符串，用于让人们根据他们的点数来了解一个玩家有多好。你应该可以调用<code class="fe ms mt mu mv b">getName</code>、<code class="fe ms mt mu mv b">getPoints</code>、<code class="fe ms mt mu mv b">getLevel</code>，以及一个加10分的<code class="fe ms mt mu mv b">levelUp</code>函数。如果玩家的积分低于10，他们就是“菜鸟”，低于20就是“中级”，20以上就是“大师”。</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="3b59" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">下面是答案:<a class="ae nb" href="https://repl.it/@tylercollier/test-yourself-module-answer" rel="noopener ugc nofollow" target="_blank">链接</a></p><h2 id="b3e0" class="kt ku ix bd kv kw kx dn ky kz la dp lb kf lc ld le kj lf lg lh kn li lj lk ll bi translated">测试4:快速路由处理器</h2><p id="c49a" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">你熟悉快递吗？如果是这样，你知道你写的每个路由处理器都是闭包吗？试试这个。在下面的repl.it中，为返回数字的根路由(<code class="fe ms mt mu mv b">/</code>)编写一个GET处理程序。此外，为<code class="fe ms mt mu mv b">/</code>编写一个POST处理程序，允许某人发布一个新号码。新的数字应该是一个JSON对象，键为<code class="fe ms mt mu mv b">number</code>，数字为值。</p><figure class="mi mj mk ml gt is"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="efdf" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated">这里回答:<a class="ae nb" href="https://repl.it/@tylercollier/test-yourself-express-route-handler-answer" rel="noopener ugc nofollow" target="_blank">链接</a></p><p id="969c" class="pw-post-body-paragraph ju jv ix jw b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ij bi translated"><strong class="jw iy">想提交测试？很难想出好的、清晰的、简洁的、包含的例子，所以如果你有一些分享在评论中，我希望看到它们！</strong></p><h1 id="9fc6" class="lr ku ix bd kv ls lt lu ky lv lw lx lb ly lz ma le mb mc md lh me mf mg lk mh bi translated">承认</h1><p id="3af6" class="pw-post-body-paragraph ju jv ix jw b jx lm jz ka kb ln kd ke kf lo kh ki kj lp kl km kn lq kp kq kr ij bi translated">在我的研究中，埃内科·阿朗索第一个用一句简洁的话解释了什么是<em class="ks">和</em>闭包为什么有价值。你可以在这里阅读他的<a class="ae nb" href="https://www.quora.com/What-is-a-closure/answer/Eneko-Alonso" rel="noopener ugc nofollow" target="_blank"> Quora回答</a>。我把他的措辞变成了我的定义，开始了这篇文章。</p></div></div>    
</body>
</html>