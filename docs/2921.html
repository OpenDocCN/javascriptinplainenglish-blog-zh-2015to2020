<html>
<head>
<title>JavaScript Tips — Rounding and JSON</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript技巧—舍入和JSON</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-tips-rounding-and-json-d1e0b5c1ec20?source=collection_archive---------2-----------------------#2020-08-06">https://javascript.plainenglish.io/javascript-tips-rounding-and-json-d1e0b5c1ec20?source=collection_archive---------2-----------------------#2020-08-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f67cd0112f4b7afe46d5cf8f66de6688.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JaGpbK2dfB0Dl65s"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@elishavision?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Elizeu Dias</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="38ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些在编写JavaScript代码时应该遵循的技巧。</p><h1 id="c02e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将数字舍入到N位小数</h1><p id="da5a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">toFixed</code>方法来舍入数字。</p><p id="6d49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将舍入到的小数位数作为参数。</p><p id="d4f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2143" class="mq lc iq mh b gy mr ms l mt mu">let num = 2.575949004696;<br/>num = num.toFixed(3);</span></pre><p id="0290" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回一个带有舍入数字的字符串。</p><p id="d7e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们得到<code class="fe me mf mg mh b">“2.576”</code>作为<code class="fe me mf mg mh b">num</code>的新值。</p><h1 id="121b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">浮点问题</h1><p id="8ae2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该意识到，添加浮点数可能不会得到我们预期的结果。</p><p id="0b07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5f16" class="mq lc iq mh b gy mr ms l mt mu">0.1 + 0.2 === 0.3</span></pre><p id="0b8d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe me mf mg mh b">false</code>。</p><p id="230b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为浮点数是64位二进制数。</p><p id="5e4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">转换会给我们带来差异。</p><p id="722c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了解决这个问题，我们使用了<code class="fe me mf mg mh b">toFixed</code>或者<code class="fe me mf mg mh b">toPrecision</code>方法。</p><h1 id="c0cf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用for-in循环时检查对象的属性</h1><p id="ab48" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">用<code class="fe me mf mg mh b">hasOwnProperty</code>方法检查对象的属性。</p><p id="2f73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dc60" class="mq lc iq mh b gy mr ms l mt mu">for (let name in object) {<br/>  if (object.hasOwnProperty(name)) {<br/>    // ...<br/>  }<br/>}</span></pre><p id="0c93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe me mf mg mh b">hasOwnProperty</code>检查属性是否在对象本身，而不是它的原型。</p><h1 id="0a8c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">逗点算符</h1><p id="5a38" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">逗号运算符总是返回列表中的最后一项。</p><p id="798b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7587" class="mq lc iq mh b gy mr ms l mt mu">const a = (100, 99);</span></pre><p id="e0d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">a</code>就是99。</p><h1 id="705f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">需要计算或查询的缓存变量</h1><p id="5533" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了加速我们的应用程序，我们应该尽可能缓存变量。</p><p id="a8cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1808" class="mq lc iq mh b gy mr ms l mt mu">const navRight = document.querySelector('#right'); <br/>const navLeft = document.querySelector('#left'); <br/>const navUp = document.querySelector('#up'); <br/>const navDown = document.querySelector('#down');</span></pre><p id="8f22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们不会在任何地方使用变量，而是一直查询DOM。</p><h1 id="a8bc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在将参数传递给isFinite()之前，请对其进行验证</h1><p id="5c9d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们检查一个表达式是否返回一个有限的数字。</p><p id="c62b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9e29" class="mq lc iq mh b gy mr ms l mt mu">isFinite("foo")</span></pre><p id="d54c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回<code class="fe me mf mg mh b">false</code>。</p><p id="0076" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9b4b" class="mq lc iq mh b gy mr ms l mt mu">isFinite(10)</span></pre><p id="b09f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回<code class="fe me mf mg mh b">true</code>。</p><h1 id="bb4b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用JSON进行序列化和反序列化</h1><p id="d8e1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">JSON</code>对象来序列化和反序列化JSON。</p><p id="4824" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将对象转换成JSON，我们使用了<code class="fe me mf mg mh b">JSON.stringify</code>。</p><p id="8fc3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将JSON字符串解析成对象，我们使用了<code class="fe me mf mg mh b">JSON.parse</code>。</p><p id="d11b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过写来使用<code class="fe me mf mg mh b">JSON.stringify</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8f01" class="mq lc iq mh b gy mr ms l mt mu">const str = JSON.stringify(obj)</span></pre><p id="75b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它返回字符串化的JSON对象。</p><p id="7cc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以传入额外的参数，使字符串更具可读性:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8d55" class="mq lc iq mh b gy mr ms l mt mu">const str = JSON.stringify(obj, undefined, 2);</span></pre><p id="8c91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三个参数包含要缩进的空格数。</p><p id="b589" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将JSON字符串解析为对象，我们编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="794f" class="mq lc iq mh b gy mr ms l mt mu">const obj = JSON.parse(str)</span></pre><p id="fca9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">str</code>是JSON字符串。</p><h1 id="7c6d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免使用eval()或函数构造函数</h1><p id="de1d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该避免使用<code class="fe me mf mg mh b">eval</code>和<code class="fe me mf mg mh b">Function</code>构造函数，因为它们都从字符串中运行代码。</p><p id="1632" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个安全风险，因为我们可以向它传递恶意的字符串。</p><p id="91b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">字符串中的代码无法优化，也很难调试。</p><h1 id="c913" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免使用with()</h1><p id="ccb1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">不应该使用，因为范围会引起混淆。</p><p id="930a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变量可以在全局范围内插入，这也不好。</p><p id="240c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果两个变量在一个<code class="fe me mf mg mh b">with</code>语句中有相同的名字，它可以覆盖这个值。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1b02e0b7aa17587ea778d17c91e366ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*A4ksf7QrxCPVaOen"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@khachiksimonian?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Khachik Simonian</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="bda9" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="3414" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript中有些东西我们应该避免。</p><p id="7dfe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用标准库来舍入数字和操纵JSON。</p><h2 id="7f8f" class="mq lc iq bd ld mv mw dn lh mx my dp ll ko mz na lp ks nb nc lt kw nd ne lx nf bi translated">简单英语的JavaScript</h2><p id="a05a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>