<html>
<head>
<title>How To Do Multithreading With Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Node.js实现多线程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-do-multithreading-with-node-js-207aabdaddfb?source=collection_archive---------2-----------------------#2020-12-31">https://javascript.plainenglish.io/how-to-do-multithreading-with-node-js-207aabdaddfb?source=collection_archive---------2-----------------------#2020-12-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="9eb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">随着版本13的发布，Node.js能够进行多线程处理。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/619bac5b261181465de66213a412c4ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XX-DmkhMjdr3AyDpvlk0Aw.png"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">This cover has been designed using resources from <a class="ae ky" href="https://www.freepik.com/" rel="noopener ugc nofollow" target="_blank">Freepik.com</a></figcaption></figure><h1 id="080a" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">介绍</h1><p id="7c28" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">大多数JavaScript开发人员认为Node.js是单线程的，它通过非阻塞异步回调进程来处理多个操作，并且不支持多线程，但是它不再有效了。在Node.js版本13中，有一个名为工作线程的新模块来实现多线程。</p><p id="85f7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尽管非阻塞异步回调可以非常有效地处理多个操作，但是像加密这样需要大量CPU利用率的函数会阻塞其他进程，对于这种情况，Node.js的性能是很弱的。工作线程模块通过隔离该函数克服了这个弱点，该函数将较高的CPU使用率放入一个单独的线程中，并在后台处理它，不会阻塞任何其他进程。</p><h1 id="ef9b" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated"><strong class="ak">实施</strong></h1><p id="8eda" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">通常在Node.js中，主线程处理所有的操作。借助一个例子，这里演示了如何创建另一个线程来处理一个操作。这个例子有两个API，第一个API将在主线程上处理函数，另一个API将在单独的线程上处理函数。下面的代码片段显示了该示例的基本结构。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="a12c" class="mh la in md b gy mi mj l mk ml">/*<br/>*  File Name: index.js<br/>*  Description: This is the main thread<br/>*/</span><span id="d00b" class="mh la in md b gy mm mj l mk ml">const express = require("express");</span><span id="8c28" class="mh la in md b gy mm mj l mk ml">const app = express();<br/>const port = 3000;</span><span id="74f3" class="mh la in md b gy mm mj l mk ml">app.get("/", (req, res) =&gt; {<br/>res.send("Process function on main thread.");<br/>});</span><span id="24dc" class="mh la in md b gy mm mj l mk ml">app.get("/seprate-thread", (req, res) =&gt; {<br/>res.send("Process function on seprate thread.");<br/>});</span><span id="ed85" class="mh la in md b gy mm mj l mk ml">app.listen(port, () =&gt; {<br/>console.log(`Example app listening at <a class="ae ky" href="http://localhost:${port}`);" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}`);</a><br/>});</span></pre><p id="029c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为第一步，我们在主线程上添加一个函数，作为下一步，我们在另一个线程上添加相同的函数。使用的函数将是getSum，它将返回作为参数给出的极限值的累计总和。将getSum函数添加到主线程后，代码片段如下所示。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="92ca" class="mh la in md b gy mi mj l mk ml">/*<br/>*  File Name: index.js<br/>*  Description: This is the main thread<br/>*/</span><span id="f8ad" class="mh la in md b gy mm mj l mk ml">const express = require("express");</span><span id="b299" class="mh la in md b gy mm mj l mk ml">const app = express();<br/>const port = 3000;</span><span id="2a15" class="mh la in md b gy mm mj l mk ml">const getSum = (limit) =&gt; {<br/>let sum = 0;<br/>for (let i = 0; i &lt; limit; i++) {<br/>     sum += i;<br/>}<br/>return sum;<br/>};</span><span id="108f" class="mh la in md b gy mm mj l mk ml">app.get("/", (req, res) =&gt; {</span><span id="699c" class="mh la in md b gy mm mj l mk ml">const result = getSum(1000);<br/>res.send(`Processed function getSum on main thread and result: ${result}`);</span><span id="53f2" class="mh la in md b gy mm mj l mk ml">});</span><span id="c148" class="mh la in md b gy mm mj l mk ml">app.get("/seprate-thread", (req, res) =&gt; {<br/>res.send("Process function getSum on seprate thread.");<br/>});</span><span id="5d13" class="mh la in md b gy mm mj l mk ml">app.listen(port, () =&gt; {<br/>console.log(`Example app listening at <a class="ae ky" href="http://localhost:${port}`);" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}`);</a><br/>});</span></pre><p id="6675" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一步是在另一个线程上添加相同的函数，它可以如下进行。</p><ul class=""><li id="624a" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">将工作线程模块导入主线程。</li></ul><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="0354" class="mh la in md b gy mi mj l mk ml">const { Worker } = require("worker_threads");</span></pre><ul class=""><li id="fea6" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">创建另一个文件，seprateThread.js，用于定义在另一个线程上运行的函数getSum。</li><li id="14c5" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">创建工作线程模块的实例，并提供新创建文件的路径名。</li></ul><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="23b8" class="mh la in md b gy mi mj l mk ml">const seprateThread = new Worker(__dirname + "/seprateThread.js");</span></pre><ul class=""><li id="c569" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">开始新的线程</li></ul><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="2a97" class="mh la in md b gy mi mj l mk ml">seprateThread.on("message", (result) =&gt; {<br/>res.send(`Processed function getSum on seprate thread:  ${result}`);<br/>});</span></pre><ul class=""><li id="2d69" class="mn mo in jm b jn jo jr js jv mp jz mq kd mr kh ms mt mu mv bi translated">向新线程发送数据。</li></ul><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="2e73" class="mh la in md b gy mi mj l mk ml">seprateThread.postMessage(1000);</span></pre><p id="4371" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，主线程将像下面的代码片段一样。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="293e" class="mh la in md b gy mi mj l mk ml">/*<br/>*  File Name: index.js<br/>*  Description: This is the main thread<br/>*/</span><span id="7a90" class="mh la in md b gy mm mj l mk ml">const express = require("express");<br/>const { Worker } = require("worker_threads");</span><span id="c483" class="mh la in md b gy mm mj l mk ml">const app = express();<br/>const port = 3000;</span><span id="ee1e" class="mh la in md b gy mm mj l mk ml">const getSum = (limit) =&gt; {<br/>let sum = 0;<br/>for (let i = 0; i &lt; limit; i++) {<br/>     sum += i;<br/>}<br/>return sum;<br/>};</span><span id="a211" class="mh la in md b gy mm mj l mk ml">app.get("/", (req, res) =&gt; {</span><span id="9235" class="mh la in md b gy mm mj l mk ml">const result = getSum(1000);<br/>res.send(`Processed function getSum on main thread and result: ${result}`);</span><span id="8f0c" class="mh la in md b gy mm mj l mk ml">});</span><span id="179b" class="mh la in md b gy mm mj l mk ml">app.get("/seprate-thread", (req, res) =&gt; {</span><span id="54fc" class="mh la in md b gy mm mj l mk ml">const seprateThread = new Worker(__dirname + "/seprateThread.js");<br/>seprateThread.on("message", (result) =&gt; {<br/>res.send(`Processed function getSum on seprate thread: ${result}`);<br/>});<br/>seprateThread.postMessage(1000);</span><span id="b332" class="mh la in md b gy mm mj l mk ml">});</span><span id="1159" class="mh la in md b gy mm mj l mk ml">app.listen(port, () =&gt; {<br/>console.log(`Example app listening at <a class="ae ky" href="http://localhost:${port}`);" rel="noopener ugc nofollow" target="_blank">http://localhost:${port}`);</a><br/>});</span></pre><p id="e965" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，从主线程创建了一个新的线程。让我们把getSum函数放在新创建的线程上，这样就在文件seprateThread.js上定义了该函数。检查以下代码以供参考。</p><pre class="kj kk kl km gt mc md me mf aw mg bi"><span id="d7bb" class="mh la in md b gy mi mj l mk ml">/*<br/>*  File Name: seprateThread.js<br/>*  Description: This is another thread<br/>*/</span><span id="ab18" class="mh la in md b gy mm mj l mk ml">const { parentPort } = require("worker_threads");</span><span id="de13" class="mh la in md b gy mm mj l mk ml">const getSum = (limit) =&gt; {<br/>  let sum = 0;<br/>  for (let i = 0; i &lt; limit; i++) {<br/>    sum += i;<br/>  }<br/>  return sum;<br/>};</span><span id="88a4" class="mh la in md b gy mm mj l mk ml">parentPort.on("message", (limit) =&gt; {<br/> const result = getSum(limit);<br/> parentPort.postMessage(result);<br/>});</span></pre><p id="94d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，您可以看到主线程用来与子线程通信的<code class="fe nb nc nd md b">seprateThread.postMessage()</code>函数。同样，子线程使用<code class="fe nb nc nd md b">parentPort.postMessage()</code>与主线程通信。下图说明了子线程和主线程之间的通信。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/3f6fa707d131ffa8468623c769b5c520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1132/format:webp/1*ydQqBzkh6FO4WUwHtGF7zA.png"/></div></figure><h1 id="6025" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">特征</h1><ul class=""><li id="7f3b" class="mn mo in jm b jn lx jr ly jv nf jz ng kd nh kh ms mt mu mv bi translated">每个线程都有独立的v8引擎。</li><li id="886a" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">子线程可以相互通信。</li><li id="4a7f" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">子线程可以共享相同的内存。</li><li id="4cd2" class="mn mo in jm b jn mw jr mx jv my jz mz kd na kh ms mt mu mv bi translated">启动新线程时，初始值可以作为选项传递。</li></ul><h1 id="c176" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">结论</h1><p id="cb26" class="pw-post-body-paragraph jk jl in jm b jn lx jp jq jr ly jt ju jv lz jx jy jz ma kb kc kd mb kf kg kh ig bi translated">本文的目的是简要介绍Node.js上多线程的基本实现。Node.js中的多线程与传统的多线程略有不同。建议对于大量I/O操作，主线程比工作线程做得更好。要了解关于多线程的更多信息，请参考Node.js官方<a class="ae ky" href="https://nodejs.org/api/worker_threads.html" rel="noopener ugc nofollow" target="_blank">文档</a>和此处可用示例的源代码。</p><div class="ni nj gp gr nk nl"><a href="https://github.com/krishheii/Multithreading" rel="noopener  ugc nofollow" target="_blank"><div class="nm ab fo"><div class="nn ab no cl cj np"><h2 class="bd io gy z fp nq fr fs nr fu fw im bi translated">krish heii/多线程</h2><div class="ns l"><h3 class="bd b gy z fp nq fr fs nr fu fw dk translated">多线程使用Node.js .通过在GitHub上创建一个账号，为krish heii/多线程开发做贡献。</h3></div><div class="nt l"><p class="bd b dl z fp nq fr fs nr fu fw dk translated">github.com</p></div></div><div class="nu l"><div class="nv l nw nx ny nu nz ks nl"/></div></div></a></div></div></div>    
</body>
</html>