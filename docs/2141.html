<html>
<head>
<title>JavaScript coercion in 8 minutes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">8分钟JavaScript强制</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-coercion-in-8-minutes-60544a962d71?source=collection_archive---------7-----------------------#2020-05-23">https://javascript.plainenglish.io/javascript-coercion-in-8-minutes-60544a962d71?source=collection_archive---------7-----------------------#2020-05-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><h2 id="ccf1" class="il im in bd b dl io ip iq ir is it dk iu translated" aria-label="kicker paragraph">第一部分</h2><div class=""/><div class=""><h2 id="79a4" class="pw-subtitle-paragraph jt iw in bd b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dk translated">钻出来的强制概念！</h2></div><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/36ce71b69ed9dc00c656f4f948fb17ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x3l55V89muzuP3oOOSxKuw.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Photo by <a class="ae lb" href="https://unsplash.com/@baciutudor?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Tudor Baciu</a> on <a class="ae lb" href="https://unsplash.com/s/photos/advanced-javascript-consepts?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4719" class="lc ld in bd le lf lg lh li lj lk ll lm kc ln kd lo kf lp kg lq ki lr kj ls lt bi translated">JavaScript中的本机函数</h1><blockquote class="lu lv lw"><p id="ebe4" class="lx ly lz ma b mb mc jx md me mf ka mg mh mi mj mk ml mm mn mo mp mq mr ms mt ig bi translated">JavaScript有原生函数。</p></blockquote><p id="9a17" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">除了原始值，还有<strong class="ma ix">基础对象</strong>。什么是<a class="ae lb" href="https://www.ecma-international.org/ecma-262/#sec-fundamental-objects" rel="noopener ugc nofollow" target="_blank">的根本对象</a>？在旧版本的specs中你找不到这个名字，因为这是一个相对较新的术语，在过去，我们称它们为<strong class="ma ix">内置对象</strong>(又名<strong class="ma ix">本地函数</strong>)。今天，在现代编程方法中，最好将它们称为基本对象。</p><p id="0a30" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated"><strong class="ma ix">基本对象不是像其他类型一样的类型。这部分可能很难理解，尤其是对初学者来说。在强类型语言(如C#或Java)中，我们也有类似的情况，我们有一个原语值的对象表示，以及与原语类型相关的行为。</strong></p><p id="32f5" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated"><strong class="ma ix">我们可以把原生函数分成两组。</strong>第一组是我们在声明它们时使用“new”关键字的那些(<em class="lz">对象</em>、<em class="lz">数组</em>、<em class="lz">函数</em>、<em class="lz">日期</em>、<em class="lz"> RegExp </em>和<em class="lz">错误</em>)。第二组是我们使用的没有“new”关键字的那些(<em class="lz">字符串</em>、<em class="lz">数字</em>和<em class="lz">布尔</em>)。</p><p id="8b45" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">结论:<strong class="ma ix">我们没有实例化<em class="lz">字符串</em>、<em class="lz">数字</em>和<em class="lz">布尔</em>。</strong></p><p id="2d1c" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated"><strong class="ma ix">永远不要将【new】关键字与<em class="lz">布尔</em>、<em class="lz">数字</em>和<em class="lz">字符串</em>一起使用！</strong>事实是，我们可以将它与“new”关键字一起使用，但会出现“错误”——这在我们讨论<strong class="ma ix">强制</strong>时很明显。请认真对待这个警告，不要陷入无法将类型强制转换为原始类型的境地！<strong class="ma ix">只使用它们，而且只使用，而且只使用喜欢的功能！</strong></p><p id="7ba9" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">我将给出几个使用“新”关键字的例子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="7c25" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">结论:<strong class="ma ix">使用带有<em class="lz">日期的“new”关键字是有意义的，例如</em>，因为这是声明它的唯一方式。</strong></p><h1 id="8a1b" class="lc ld in bd le lf lg lh li lj lk ll lm kc ln kd lo kf lp kg lq ki lr kj ls lt bi translated">抽象操作</h1><blockquote class="lu lv lw"><p id="9f54" class="lx ly lz ma b mb mc jx md me mf ka mg mh mi mj mk ml mm mn mo mp mq mr ms mt ig bi translated">这些操作不是ECMAScript语言的一部分…</p></blockquote><p id="c269" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">根据ECMAScript 的说法，抽象操作不是语言规范的一部分。我们不能避免谈论这些操作- <strong class="ma ix">,它们是JavaScript引擎的构建模块。</strong>他们是来帮我们处理<a class="ae lb" href="https://www.ecma-international.org/ecma-262/#sec-type-conversion" rel="noopener ugc nofollow" target="_blank">型转换</a>的。</p><p id="e513" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">传统上，<strong class="ma ix">抽象操作执行类型转换</strong>——强制。很简单，不是吗？那么，转换是如何进行的呢？</p><h2 id="3718" class="mz ld in bd le na nb dn li nc nd dp lm mu ne nf lo mv ng nh lq mw ni nj ls it bi translated">原始的</h2><blockquote class="lu lv lw"><p id="e15e" class="lx ly lz ma b mb mc jx md me mf ka mg mh mi mj mk ml mm mn mo mp mq mr ms mt ig bi translated">抽象操作<em class="in"> ToPrimitive </em>接受一个输入参数和一个可选参数<em class="in"> PreferredType </em>，并将其输入参数转换为非对象类型。</p></blockquote><p id="ad69" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">ECMAScript中指出的第一个抽象操作是<a class="ae lb" href="https://www.ecma-international.org/ecma-262/#sec-toprimitive" rel="noopener ugc nofollow" target="_blank"><em class="lz">to primitive</em></a><em class="lz">。</em>这个操作很直观，把一个非原语类型强制转换成一个原语类型。<strong class="ma ix">每个非原语类型(对象、数组、函数等。)可以要挟成原语。</strong></p><p id="a32b" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">正如我所说，抽象操作不是语言的一部分，所以它们不像我们可以调用的函数。事实上，它们是JavaScript引擎内部的方法。我们不能随意称呼它们，所以不能说它们是有形的东西。这就是为什么我们称它们为抽象的原因——它们是JS概念的一部分。</p><p id="47ea" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">让我们一步一步地了解这个概念。我们有一些不是原始的东西，我们需要它变成原始的。为了实现这一点，我们需要一个<strong class="ma ix">算法(一组步骤)</strong>。进行这种类型转换的完美算法是<em class="lz">到本原</em>运算。<em class="lz">top primitive</em>就像一个采用可选类型(参数)的函数，称为<strong class="ma ix">提示</strong>。</p><p id="97d2" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">只有两种可能的暗示。如果我们正在做一个数字运算，并且它调用<em class="lz">来初始化</em>，猜猜会发生什么？提示是要将<em class="lz">号船</em>号。记住，这不是保证一个数字，我的想法是在那里使用它。第二种情况是当我们使用字符串时，发生了<em class="lz"> ToPrimitive </em>。当然，提示是发送<em class="lz">字符串</em>。</p><p id="5b5b" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">最后你可以指定你喜欢做数字还是字符串(甚至你什么都不想说——<strong class="ma ix">返回任何你能</strong>的图元)。</p><p id="422d" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">让事情变得可靠。算法(本质上)是递归的。那是什么意思？如果一个操作的返回(<em class="lz"> ToPrimitive </em>)不是我们所期望的，那么<strong class="ma ix">将被调用，直到它得到期望的结果</strong>(原始类型)，或者<strong class="ma ix">在某些情况下返回一个错误</strong>。</p><p id="7df8" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">结论:<strong class="ma ix">在幕后有很多递归操作。</strong></p><h2 id="d27b" class="mz ld in bd le na nb dn li nc nd dp lm mu ne nf lo mv ng nh lq mw ni nj ls it bi translated">valueOf()与toString()</h2><blockquote class="lu lv lw"><p id="f871" class="lx ly lz ma b mb mc jx md me mf ka mg mh mi mj mk ml mm mn mo mp mq mr ms mt ig bi translated"><em class="in"> valueOf() </em>和<em class="in"> toString() </em>可以改变它们的presedence。</p></blockquote><p id="1cf0" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">在幕后，我们还有另外两个方法，它们可以在任何非原语上使用。这两个函数是:<em class="lz"> valueOf() </em>和<em class="lz"> toString() </em>。它是如何融入一个关于<em class="lz">原始</em>的故事的？让我们找出答案。</p><p id="9314" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">首先，我们有两个方法可以在任何非原语(对象、函数、数组等)上使用。).这两种方法是:<em class="lz"> valueOf() </em>和<em class="lz"> toString() </em>。因此，流程是下一步。如果你告诉我<strong class="ma ix">提示是一个数字</strong>，那么我将首先调用<em class="lz"> valueOf() </em>。如果这给了我一个原始人，那就是它！如果这没有返回一个原语，我们将调用<em class="lz"> toString() </em>。然后我们会得到本原或非本原。如果我们得到一个非原语，那么它将会导致一个错误。</p><p id="7610" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">结论:<strong class="ma ix">在决定抛出错误之前，JavaScript同时调用了<em class="lz"> valueOf() </em>和<em class="lz"> toString() </em>。</strong></p><p id="f927" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">第二种情况是当我们告诉提示是一个字符串时，那么第一个调用的方法是<em class="lz"> toString() </em>。如果给了我们原语，比如string(这是应该的)，我们将使用它并尝试调用<em class="lz"> valueOf() </em>方法。</p><p id="5a32" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">结论:<strong class="ma ix">如果我们要使用一个不是原语的东西，在原语是强制的地方，它最终会用<em class="lz"> ToPrimitive </em>算法强制它。</strong></p><h2 id="975e" class="mz ld in bd le na nb dn li nc nd dp lm mu ne nf lo mv ng nh lq mw ni nj ls it bi translated">ToString</h2><p id="cefc" class="pw-post-body-paragraph lx ly in ma b mb nk jx md me nl ka mg mu nm mj mk mv nn mn mo mw no mr ms mt ig bi translated"><em class="lz"> ToString </em>操作顾名思义。它接受一个值，并以字符串的形式给出这个值的表示。<em class="lz"> ToString </em>是一个简单的操作，在<a class="ae lb" href="https://www.ecma-international.org/ecma-262/#sec-tostring" rel="noopener ugc nofollow" target="_blank"> ECMAScript </a>中有简单的解释。</p><p id="2fb5" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">让我给你看一些例子，看看它们是什么和产生后的字符串表示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="28f5" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">这些表示大部分都是预期的，预期负零！？负零不知何故变成了零，我们知道这种行为，JS - <strong class="ma ix">胁迫骗子</strong>中的拐角案例之一。其他一切(null、布尔值、未定义、浮点数)都有预期的结果。</p><p id="ff9d" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">结论:<strong class="ma ix">结果如预期，除了一个拐角情况(负零)。</strong></p><p id="588f" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">当我们谈到对象和类对象类型时，事情就有点不同了。如果我们在一个对象上调用<em class="lz"> ToString </em>，它将使用<em class="lz"> String </em>提示调用<em class="lz"> ToPrimitive </em>。我们说过它将最终调用<em class="lz"> toString() </em>，如果它存在，它将使用<em class="lz"> valueOf() </em>。我们知道那个命令！</p><p id="2829" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated"><strong class="ma ix">记住</strong>，它将首先调用<em class="lz"> toString </em>，如果它存在，那么它将使用的<em class="lz">值。这就是它的顺序。让我们来看一些例子。首先，我们将研究数组:</em></p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="156c" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">数组有它们自己的序列化和<em class="lz"> toString() </em>，它们总是产生相同的结果。结果有时会令人困惑。例如，<em class="lz"> String() </em>将显示与空数组相同的效果。检测类型的唯一方法是猜测。然而，我们有责任接受这个事实。另一个简单的决定是在字符串化<em class="lz"> null </em>和<em class="lz"> undefined </em>数组成员时返回nil。现在，我将给出几个对象示例:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e0c9" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">对象来了，一堆问题也来了。对象序列化是模糊的和不可理解的。对象和数组一样，都有自己的<em class="lz"> toString() </em>方法，这带来了一片模糊。我们在数组中丢失了方括号，但是在对象上添加了(<em class="lz">前往顶部并读取杯子上写的内容，然后返回此处</em>)。我知道这是个愚蠢的决定。</p><p id="9c4a" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">我们会原谅他们，但是这是什么意思呢？严格类型的语言最有可能影响JS。于是，采用了这种做法。第一个对象词表示一个类型，第二个表示该类型的名称。</p><p id="25a3" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">有两种方法可以解决这个问题。第一个是覆盖自定义对象的字符串标签:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="4178" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">如果我们想区分一个空的和非空的对象，我们可以使用<em class="lz"> JSON.stringify() </em>方法:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="db74" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">这种方法不是典型的<a class="ae lb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Meta_programming" rel="noopener ugc nofollow" target="_blank">元编程</a>(支持ES6形式)使用<a class="ae lb" href="https://www.ecma-international.org/ecma-262/#sec-proxy-objects" rel="noopener ugc nofollow" target="_blank">代理</a>和<a class="ae lb" href="https://www.ecma-international.org/ecma-262/#sec-reflect-object" rel="noopener ugc nofollow" target="_blank">反射</a>对象，我们一直都是这样做的。</p><p id="f716" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">结论:<strong class="ma ix">支持元编程，可以添加自己定制的部件。</strong></p><h2 id="ce02" class="mz ld in bd le na nb dn li nc nd dp lm mu ne nf lo mv ng nh lq mw ni nj ls it bi translated">ToNumber</h2><p id="bff3" class="pw-post-body-paragraph lx ly in ma b mb nk jx md me nl ka mg mu nm mj mk mv nn mn mo mw no mr ms mt ig bi translated">我们得到了另一个抽象操作- <em class="lz"> ToNumber </em>。这个更有趣一点，因为有更多的死角案例。每次我们必须做一个数字运算，而我们没有得到数字，我们将调用<em class="lz">来得到数字</em>。让我们看一些例子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="8749" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">大多数结果看起来是合理的，但是空字符串("")会发生什么呢？为什么会强制为零？这是JS引擎最大的错误之一吗？空字符串表示缺少值。据我所知，这是字符串类型中缺少值的唯一表示。那么，它为什么会变成有效数(0)呢？我们已经有了一个表示无效数字的方法，它就是<em class="lz"> NaN </em>。</p><p id="66c9" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">结论:<strong class="ma ix">除了空字符串之外，数值化工作正常！</strong></p><p id="b6ae" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">现在让我们看看它是如何处理布尔值的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="38d4" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">有趣的一个！所以，T <em class="lz"> rue </em>返回1，F <em class="lz"> alse </em>返回0。<strong class="ma ix">我们一直以为FALSE是持有0，TRUE是持有1 — </strong>这大概是大多数人的预期。</p><p id="0ca6" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">为什么他们用<em class="lz"> NaN </em>带<em class="lz"> undefined </em>，而不用<em class="lz"> null </em>？好吧，这是一个不可理解的遗漏。有什么条件？秘密就在于<em class="lz">本原</em>法。</p><p id="554f" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated"><em class="lz"> ToNumber </em>将null视为对象类型，并通过<em class="lz"> Number </em>提示(<a class="ae lb" href="https://www.ecma-international.org/ecma-262/#sec-toprimitive" rel="noopener ugc nofollow" target="_blank"> 7.1.1 </a>)调用<em class="lz"> ToPrimitive </em>。剩下的我们都知道了。首先是<em class="lz"> valueOf() </em>在唤起，然后是<em class="lz"> toString() </em>。在对象的情况下，<em class="lz"> valueOf() </em>会返回自身，然后<em class="lz"> toString() </em>会发生。</p><p id="fe62" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">这个提示是直接输入到<em class="lz"> toString() </em>中的数字并不重要。对象的数值化就像它的字符串化一样。那是一个艰难的抉择，但它已经摆在面前，我们必须接受它。最后，它会产生字符串。</p><p id="301b" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">结论:<strong class="ma ix">我们想要一个“原始”数字，但我们得到的是一个“原始”字符串。</strong></p><p id="1994" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">我再举几个例子，这样你就能清楚地理解这个逻辑了:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="59bd" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">你还记得<em class="lz"> ToString </em>是如何工作的吗？哲学也是一样。首先，它强制为一个空字符串，然后空字符串产生零。同<em class="lz">空</em>和<em class="lz">未定义</em>。它变成一个空字符串，然后空字符串被强制为零。</p><p id="e7db" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">对于有数字的数组，情况就很清楚了。它首先强制一个字符串(“3，6，9”)。第二步，<strong class="ma ix">算法会把它强制为一个数字</strong>，结果会是一个<em class="lz"> NaN </em>。我们也可以在这里使用一个补丁:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><h2 id="9bee" class="mz ld in bd le na nb dn li nc nd dp lm mu ne nf lo mv ng nh lq mw ni nj ls it bi translated">托布勒安</h2><p id="8d0d" class="pw-post-body-paragraph lx ly in ma b mb nk jx md me nl ka mg mu nm mj mk mv nn mn mo mw no mr ms mt ig bi translated"><em class="lz"> ToBoolean </em>是我们要检查的最后一个操作。<strong class="ma ix">顺便说一下，这四个操作正是我们要找的。</strong>还有很多操作，今天就不说了。如果你感兴趣，请访问specs。</p><p id="9c95" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">每当我们有一个非布尔值，并且我们在一个需要布尔值的地方使用，这个操作就会发生。<strong class="ma ix">操作与其他的相同。</strong>这个操作算法少，查找多。</p><p id="0774" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">我们在规格中有一个查找表。falsy值为:" "—(空字符串)，<em class="lz"> 0 </em>，<em class="lz"> -0 </em>，<em class="lz"> null </em>，<em class="lz"> NaN </em>，<em class="lz"> false </em>，<em class="lz">未定义</em>。他们总是要挟要假的。很短的名单，是吧？没有列在这个列表上的所有其他值都是真实的。我给你举几个例子来说明问题:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="abf0" class="pw-post-body-paragraph lx ly in ma b mb mc jx md me mf ka mg mu mi mj mk mv mm mn mo mw mq mr ms mt ig bi translated">结论:<strong class="ma ix">用falsy表判断值是否为假，否则为真。</strong></p><h2 id="902e" class="mz ld in bd le na nb dn li nc nd dp lm mu ne nf lo mv ng nh lq mw ni nj ls it bi translated"><strong class="ak">简明英语团队的笔记</strong></h2><p id="4950" class="pw-post-body-paragraph lx ly in ma b mb nk jx md me nl ka mg mu nm mj mk mv nn mn mo mw no mr ms mt ig bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae lb" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ma ix">plain English . io</strong></a>上找到所有这些信息——关注我们的出版物并<a class="ae lb" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ma ix">订阅我们的YouTube频道</strong> </a> <strong class="ma ix">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>