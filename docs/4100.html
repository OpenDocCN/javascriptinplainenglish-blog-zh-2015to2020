<html>
<head>
<title>Next.js SSR vs. SSG &amp; Incrementalism</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">next . js SSR vs SSG &amp;渐进性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/next-js-ssr-vs-ssg-incrementalism-pt-1-2-490bce12d97?source=collection_archive---------5-----------------------#2020-11-16">https://javascript.plainenglish.io/next-js-ssr-vs-ssg-incrementalism-pt-1-2-490bce12d97?source=collection_archive---------5-----------------------#2020-11-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1227" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第一部分</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fad5bf1fc425b205ea4f1c713540e033.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GTsv8vKfDQQov5jH"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@florianolv?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Florian Olivo</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9aad" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最近，我一直在和<a class="ae ks" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>一起工作。它帮助你在服务器上预渲染你的站点的能力是非常强大的。在深入Next.js及其预渲染方法的任何细节之前，让我们后退一步，一般性地讨论基本的客户端渲染和服务器端渲染。</p><p id="1676" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">之后，<a class="ae ks" href="https://medium.com/javascript-in-plain-english/next-js-ssr-vs-ssg-incrementalism-pt-2-2-3928757e9dc" rel="noopener">点击这里</a>查看第2部分，在这里我们将通过示例更深入地探究Next.js预渲染策略。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><p id="b5cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在过去的几年里，我已经开发了几个<a class="ae ks" href="https://create-react-app.dev/" rel="noopener ugc nofollow" target="_blank"> Create React App </a> (CRA)应用，心智模型是这样的:</p><ol class=""><li id="72f7" class="lw lx in kv b kw kx kz la lc ly lg lz lk ma lo mb mc md me bi translated">当您运行<code class="fe mf mg mh mi b">npm run build</code>时，您的React代码、样式等。被打包成一个(或几个)javascript包</li><li id="9c73" class="lw lx in kv b kw mj kz mk lc ml lg mm lk mn lo mb mc md me bi translated">在新构建的JS包旁边有一个框架HTML页面，JS包含在HTML中</li><li id="4397" class="lw lx in kv b kw mj kz mk lc ml lg mm lk mn lo mb mc md me bi translated">将这个结构放入一个CDN /静态托管站点，浏览器就可以请求全部内容(这很酷——不需要web服务器来管理站点的加载)</li><li id="dac9" class="lw lx in kv b kw mj kz mk lc ml lg mm lk mn lo mb mc md me bi translated">当浏览器获得这个包时，屏幕将是空白的，直到这个包加载所有的JS，创建React虚拟DOM，将HTML绘制到屏幕上，并最终使页面与JS的其余部分交互(这是因为框架HTML文件还没有任何东西要显示，所以浏览器需要做所有的工作来使它可视化)</li><li id="8b00" class="lw lx in kv b kw mj kz mk lc ml lg mm lk mn lo mb mc md me bi translated">^这是<em class="mo">客户端渲染= </em> <strong class="kv io"> <em class="mo"> CSR </em> </strong></li></ol><p id="9019" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最近，我一直在做一些<a class="ae ks" href="https://nextjs.org/" rel="noopener ugc nofollow" target="_blank"> Next.js </a>项目，故事发生了很大变化。在《下一个世界》中，一切都是关于<em class="mo">预渲染</em>，这与<strong class="kv io"> CSR </strong>正好相反。<a class="ae ks" href="https://nextjs.org/docs/basic-features/pages#pre-rendering" rel="noopener ugc nofollow" target="_blank">直从源头</a>:</p><blockquote class="mp mq mr"><p id="6736" class="kt ku mo kv b kw kx jo ky kz la jr lb ms ld le lf mt lh li lj mu ll lm ln lo ig bi translated">Next.js <strong class="kv io">预渲染</strong>每一页。这意味着Next.js预先为每个页面生成HTML，而不是全部由客户端JavaScript完成。预渲染可以提高性能和SEO。</p></blockquote><p id="ec2d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">太棒了。在这个世界上，我们卸下了浏览器的重担。浏览器不必解包JS包，只是构造虚拟DOM并最终在屏幕上绘制一些东西，Next将在服务器端生成一些实际的HTML，这样当用户访问某个页面时，浏览器将接收到直接的HTML，它可以超快地将HTML放到屏幕上。让我们更深入地讨论一下通用服务器端渲染…</p><h1 id="28fa" class="mv mw in bd mx my mz na nb nc nd ne nf jt ng ju nh jw ni jx nj jz nk ka nl nm bi translated">服务器端渲染(SSR)</h1><p id="b636" class="pw-post-body-paragraph kt ku in kv b kw nn jo ky kz no jr lb lc np le lf lg nq li lj lk nr lm ln lo ig bi translated"><a class="ae ks" href="https://medium.com/@neightjones/next-js-ssr-vs-ssg-incrementalism-pt-2-2-3928757e9dc" rel="noopener">我的下一篇文章</a>将着眼于next.js中用于预渲染的现代技术，但让我们首先讨论传统的SSR(SSR是Next的“预渲染”的一个组件)。在SSR中，就像我上面提到的，服务器现在负责生成实际的HTML并发送给客户机。在最简单的情况下，想象一个完全静态的“关于我们”页面，也就是说，没有交互——只有一些HTML和CSS。服务器可以很容易地将它发送出去，因为它已经准备好了。</p><p id="4821" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是一个从数据库中列出一堆产品的页面会怎么样呢？这就是像<a class="ae ks" href="https://handlebarsjs.com/" rel="noopener ugc nofollow" target="_blank">手柄</a>这样的模板语言的用武之地。例如，您可以创建一个具有一些特殊循环语法的HTML <em class="mo">模板</em>，以便在请求时，服务器可以从数据库中获取所有产品，将它们一个接一个地添加到HTML模板中，然后将那个<em class="mo">水合</em> HTML发送到浏览器。每个请求都会要求服务器完成这项工作，所以您总是可以在客户端获得最新的数据库结果。</p><p id="ef12" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">预示着，如果我们可以获得SSR的好处，而不需要每次都去web服务器并让它工作，会怎么样？</p><h1 id="747f" class="mv mw in bd mx my mz na nb nc nd ne nf jt ng ju nh jw ni jx nj jz nk ka nl nm bi translated">快速回顾:CSR与SSR</h1><p id="be2f" class="pw-post-body-paragraph kt ku in kv b kw nn jo ky kz no jr lb lc np le lf lg nq li lj lk nr lm ln lo ig bi translated"><strong class="kv io">T9】💻CSR优点&amp;缺点缺点</strong></p><ol class=""><li id="777a" class="lw lx in kv b kw kx kz la lc ly lg lz lk ma lo mb mc md me bi translated">利:像CRA这样的工具生成的javascript包可以放在CDN中。这意味着它位于全球的边缘位置，因此用户可以超级快速地获得它</li><li id="4b57" class="lw lx in kv b kw mj kz mk lc ml lg mm lk mn lo mb mc md me bi translated">教授:在最初的工作流程中，不需要担心网络服务器(只需要从浏览器到CDN再回来)…尽管如果你的应用和AJAX中有一些交互部分，这些当然会影响到你的后端服务器</li><li id="f969" class="lw lx in kv b kw mj kz mk lc ml lg mm lk mn lo mb mc md me bi translated">缺点:尽管能够从附近的数据中心快速获得这个包，但在处理完所有javascript以最终创建虚拟DOM并绘制到屏幕上之前，您的浏览器甚至不能显示任何内容</li><li id="5886" class="lw lx in kv b kw mj kz mk lc ml lg mm lk mn lo mb mc md me bi translated">缺点:传统上，你在这里会遇到SEO的问题，因为网络爬虫只会看到你的包含JS包的“空白”HTML页面(最终会发展成一堆HTML，但还不是时候)。看起来这可能会成为一个小问题，例如谷歌首先处理javascript(？)</li></ol><p id="38a3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io"> <em class="mo"> ☁️ SSR优点&amp;缺点</em> </strong></p><ol class=""><li id="6621" class="lw lx in kv b kw kx kz la lc ly lg lz lk ma lo mb mc md me bi translated">优点:在服务器上生成的HTML适合浏览器。浏览器在呈现准备显示的HTML时速度很快。除此之外，浏览器不需要获得一个巨大的包，而是只需要将要被浏览的HTML</li><li id="b376" class="lw lx in kv b kw mj kz mk lc ml lg mm lk mn lo mb mc md me bi translated">利:搜索引擎优化没有问题，因为这是传统的做法(网络爬虫会直接看到来自服务器的HTML)</li><li id="c8a7" class="lw lx in kv b kw mj kz mk lc ml lg mm lk mn lo mb mc md me bi translated">缺点:在纯SSR中，服务器为来自客户端的每个请求构建一个页面，服务器参与加载每个页面，并且服务器可能会做很多工作(如果有10个请求进来，它需要生成10个HTML页面来返回)</li><li id="c00e" class="lw lx in kv b kw mj kz mk lc ml lg mm lk mn lo mb mc md me bi translated">反对:对于严格意义上的SSR，CDN级别没有缓存任何内容。服务器总是为每个请求生成HTML</li></ol><h1 id="a303" class="mv mw in bd mx my mz na nb nc nd ne nf jt ng ju nh jw ni jx nj jz nk ka nl nm bi translated">接下来— Next.js预渲染策略</h1><p id="d2a1" class="pw-post-body-paragraph kt ku in kv b kw nn jo ky kz no jr lb lc np le lf lg nq li lj lk nr lm ln lo ig bi translated">这只是SSR故事的开始。Next.js将预渲染的想法提升到了<em class="mo">的下一个</em>级别。超越我上面描述的传统SSR，Next增加了另一种方法，<em class="mo">静态站点生成，</em>以及一些额外的动态层。是的，静态站点有时表现得像动态站点。</p><p id="2f80" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">查看我的下一篇文章，了解更多关于Next.js中的静态生成，包括增量静态生成:</p><div class="ns nt gp gr nu nv"><a href="https://medium.com/javascript-in-plain-english/next-js-ssr-vs-ssg-incrementalism-pt-2-2-3928757e9dc" rel="noopener follow" target="_blank"><div class="nw ab fo"><div class="nx ab ny cl cj nz"><h2 class="bd io gy z fp oa fr fs ob fu fw im bi translated">next . js SSR vs SSG &amp;渐进性</h2><div class="oc l"><h3 class="bd b gy z fp oa fr fs ob fu fw dk translated">第二部分</h3></div><div class="od l"><p class="bd b dl z fp oa fr fs ob fu fw dk translated">medium.com</p></div></div><div class="oe l"><div class="of l og oh oi oe oj km nv"/></div></div></a></div></div></div>    
</body>
</html>