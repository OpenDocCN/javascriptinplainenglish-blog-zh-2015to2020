<html>
<head>
<title>JavaScript &amp; React fundamentals for Interviews</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面试的JavaScript和React基础</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-react-fundamentals-for-interviews-381f7d42f5dc?source=collection_archive---------1-----------------------#2020-04-03">https://javascript.plainenglish.io/javascript-react-fundamentals-for-interviews-381f7d42f5dc?source=collection_archive---------1-----------------------#2020-04-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="cd7d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何解决有关call()、apply()等问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4eb1f11442681c152c80415d00163726.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*BwY2y_Jlf1LlVytT.jpg"/></div></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="fde0" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">JavaScript中的变量声明</h1><p id="4207" class="pw-post-body-paragraph lq lr iq ls b lt lu jr lv lw lx ju ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated"><em class="mm">区别</em><code class="fe mn mo mp mq b"><em class="mm">var</em></code><em class="mm"/><code class="fe mn mo mp mq b"><em class="mm">let</em></code><em class="mm">&amp;</em><code class="fe mn mo mp mq b"><em class="mm">const</em></code></p><ul class=""><li id="7fb0" class="mr ms iq ls b lt mt lw mu lz mv md mw mh mx ml my mz na nb bi translated">使用<code class="fe mn mo mp mq b">const</code>分配的变量是只读的，这意味着一旦使用<code class="fe mn mo mp mq b">const</code>初始化，它们就不能被重新分配</li><li id="0132" class="mr ms iq ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">在新的JS版本中引入另外两个关键字<code class="fe mn mo mp mq b">const</code> &amp; <code class="fe mn mo mp mq b">let</code>的主要原因是允许程序员为他们定义的变量决定范围选项</li></ul><p id="6c70" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><strong class="ls ir"> &gt;所有这些关键字的范围字</strong></p><p id="c974" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><code class="fe mn mo mp mq b">var</code>:声明变量的函数</p><p id="4c5e" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><code class="fe mn mo mp mq b">let</code> &amp; <code class="fe mn mo mp mq b">const</code>:声明变量的块</p><pre class="kg kh ki kj gt nk mq nl nm aw nn bi"><span id="b174" class="no kz iq mq b gy np nq l nr ns">Block scopes are what you get when you use if statements, for statements or write code inside curly brackets</span></pre><p id="b6ad" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><strong class="ls ir"> &gt;举例:设vs var in for循环</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><pre class="kg kh ki kj gt nk mq nl nm aw nn bi"><span id="bc02" class="no kz iq mq b gy np nq l nr ns">0 'inside for loop'<br/>1 'inside for loop'<br/>2 'inside for loop'<br/>3 'inside for loop'<br/>4 'inside for loop'<br/>5 'outside for loop'</span></pre><p id="8e65" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated">如果您用<code class="fe mn mo mp mq b">let</code>替换<code class="fe mn mo mp mq b">var</code>，您将得到错误<code class="fe mn mo mp mq b">ReferenceError: i is not defined</code>，因为<code class="fe mn mo mp mq b">let</code>是一个块范围，而<code class="fe mn mo mp mq b">i</code>只能在花括号内访问</p><p id="2bb2" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><strong class="ls ir"> &gt;经验法则</strong></p><ul class=""><li id="8602" class="mr ms iq ls b lt mt lw mu lz mv md mw mh mx ml my mz na nb bi translated">不要使用<code class="fe mn mo mp mq b">var</code>，因为<code class="fe mn mo mp mq b">let</code>和<code class="fe mn mo mp mq b">const</code>更具体</li><li id="8213" class="mr ms iq ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">默认为<code class="fe mn mo mp mq b">const</code>，因为它不能被重新赋值或重新声明</li><li id="f60e" class="mr ms iq ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">当您想在将来重新分配变量时，使用<code class="fe mn mo mp mq b">let</code></li><li id="e28f" class="mr ms iq ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">总是喜欢使用<code class="fe mn mo mp mq b">let</code>而不是<code class="fe mn mo mp mq b">var</code>和<code class="fe mn mo mp mq b">const</code>而不是<code class="fe mn mo mp mq b">let</code></li></ul></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="a6a3" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">对象析构</h1><p id="050d" class="pw-post-body-paragraph lq lr iq ls b lt lu jr lv lw lx ju ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated"><strong class="ls ir"> &gt;对象析构</strong></p><ul class=""><li id="a094" class="mr ms iq ls b lt mt lw mu lz mv md mw mh mx ml my mz na nb bi translated">当你必须从你的状态或者你的组件中的属性中访问大量的属性时，你可以在JavaScript中使用<strong class="ls ir">析构</strong>赋值，而不是一个一个地把它们赋值给一个变量</li></ul><p id="91f3" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><em class="mm">使用</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="b78d" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><em class="mm">而不是</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="99a5" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><strong class="ls ir"> &gt;对象析构别名</strong></p><p id="6e2d" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated">您可以使用别名重命名它们</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><pre class="kg kh ki kj gt nk mq nl nm aw nn bi"><span id="e88e" class="no kz iq mq b gy np nq l nr ns">Jhon // which is <strong class="mq ir">student.name</strong></span></pre><p id="11a5" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><strong class="ls ir"> &gt;物体析构反应状态</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="2095" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi">&amp;</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a5a3" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><strong class="ls ir"> &gt;剩余破坏</strong></p><ul class=""><li id="a306" class="mr ms iq ls b lt mt lw mu lz mv md mw mh mx ml my mz na nb bi translated">它通常用于分割一个对象的一部分，但保留另一个对象的剩余属性</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="7274" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">扩展运算符</h1><p id="dd11" class="pw-post-body-paragraph lq lr iq ls b lt lu jr lv lw lx ju ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">Spread操作符实际上将数组的内容扩展到它的元素中，这样就可以进行连接等操作。更容易的</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="bed7" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><em class="mm">相当于</em></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="cf21" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><strong class="ls ir"> &gt;为什么Spread运算符在React中如此得心应手</strong></p><ul class=""><li id="b399" class="mr ms iq ls b lt mt lw mu lz mv md mw mh mx ml my mz na nb bi translated">您可以很容易地在两个数组中间添加一些元素</li></ul><pre class="kg kh ki kj gt nk mq nl nm aw nn bi"><span id="3721" class="no kz iq mq b gy np nq l nr ns">[...a, 'something', ...b];</span></pre><ul class=""><li id="4908" class="mr ms iq ls b lt mt lw mu lz mv md mw mh mx ml my mz na nb bi translated">您可以使用此运算符克隆阵列</li></ul><pre class="kg kh ki kj gt nk mq nl nm aw nn bi"><span id="e012" class="no kz iq mq b gy np nq l nr ns">clone = [...a];</span></pre><ul class=""><li id="bab3" class="mr ms iq ls b lt mt lw mu lz mv md mw mh mx ml my mz na nb bi translated">您可以使用Spread运算符轻松地组合两个对象，并向该对象添加额外的属性</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="033e" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">数组函数</h1><p id="6d03" class="pw-post-body-paragraph lq lr iq ls b lt lu jr lv lw lx ju ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated">箭头函数是用JavaScript编写函数的一种更简洁的方式</p><p id="259b" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><strong class="ls ir"> &gt;箭头函数有一个隐式返回</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="fbe2" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><em class="mm">与</em>相同</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="08e2" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><strong class="ls ir">T48】经验法则</strong></p><ul class=""><li id="c2d7" class="mr ms iq ls b lt mt lw mu lz mv md mw mh mx ml my mz na nb bi translated">如果函数体中只有一个语句，那么你可以省略<code class="fe mn mo mp mq b">return</code>关键字和花括号</li><li id="c0bd" class="mr ms iq ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">在开头省略<code class="fe mn mo mp mq b">function</code>关键字</li><li id="3c03" class="mr ms iq ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">如果只有一个参数，也可以省略参数括号</li></ul></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="5f92" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">` this '关键字&amp;绑定</h1><p id="9890" class="pw-post-body-paragraph lq lr iq ls b lt lu jr lv lw lx ju ly lz ma mb mc md me mf mg mh mi mj mk ml ij bi translated"><strong class="ls ir">T49】隐式绑定</strong></p><ul class=""><li id="90ed" class="mr ms iq ls b lt mt lw mu lz mv md mw mh mx ml my mz na nb bi translated">当使用点符号来调用一个对象或一个类的对象中的函数时，我们说<code class="fe mn mo mp mq b">this</code>被隐式绑定了</li><li id="b935" class="mr ms iq ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">点号  <em class="mm"> </em>左边的东西就是<code class="fe mn mo mp mq b">this</code></li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="7ee6" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><strong class="ls ir"> &gt;显式绑定</strong></p><p id="13aa" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated">独立函数可以在调用时显式绑定到对象</p><p id="1344" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><strong class="ls ir"> &gt;调用()</strong></p><ul class=""><li id="4fb9" class="mr ms iq ls b lt mt lw mu lz mv md mw mh mx ml my mz na nb bi translated">使用<code class="fe mn mo mp mq b">call()</code>函数将函数<code class="fe mn mo mp mq b">printName()</code>显式绑定到<code class="fe mn mo mp mq b">Developer</code>类的<code class="fe mn mo mp mq b">me</code>对象</li><li id="44a8" class="mr ms iq ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">如果调用<code class="fe mn mo mp mq b">printName()</code>时没有绑定任何对象，它会将名字和姓氏打印为未定义，因为<code class="fe mn mo mp mq b">this</code>是未定义的</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="a6ec" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><strong class="ls ir"> &gt;应用()</strong></p><ul class=""><li id="2fbe" class="mr ms iq ls b lt mt lw mu lz mv md mw mh mx ml my mz na nb bi translated">可以使用<strong class="ls ir"> call() </strong>将参数传递给函数</li><li id="517e" class="mr ms iq ls b lt nc lw nd lz ne md nf mh ng ml my mz na nb bi translated">但是，如果您不想单独传递每个参数，而是将所有参数作为一个数组传递，您可以使用<strong class="ls ir"> apply() </strong>函数</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="8185" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><strong class="ls ir"> &gt; bind() </strong></p><p id="bbba" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated">当在一个函数上被调用时，<code class="fe mn mo mp mq b">.bind()</code>设置一个<code class="fe mn mo mp mq b">this</code>上下文并返回一个绑定了<code class="fe mn mo mp mq b">this</code>上下文的新函数</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f0c9" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><strong class="ls ir"> &gt;新装订</strong></p><p id="ae57" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated"><code class="fe mn mo mp mq b">this</code>可以像在类中一样在函数中显式定义</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><h1 id="4b63" class="ky kz iq bd la lb lc ld le lf lg lh li jw lj jx lk jz ll ka lm kc ln kd lo lp bi translated">希望你在面试和求职中好运</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/d3093507596fff16eb71bdf2f3226ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ySu9Rem5PEQDfEI-"/></div></div><figcaption class="nw nx gj gh gi ny nz bd b be z dk">Photo by <a class="ae oa" href="https://unsplash.com/@freetousesoundscom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Free To Use Sounds</a> on <a class="ae oa" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e9e5" class="pw-post-body-paragraph lq lr iq ls b lt mt jr lv lw mu ju ly lz nh mb mc md ni mf mg mh nj mj mk ml ij bi translated">【JavaScript用简单的英语写的一句话:我们总是乐于帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的中级用户名发邮件到submissions@javascriptinplainenglish.com<a class="ae oa" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">给我们，我们会把你添加为作者。</a></p></div></div>    
</body>
</html>