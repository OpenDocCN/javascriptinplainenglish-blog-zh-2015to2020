<html>
<head>
<title>The Decorator Design Pattern in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的装饰设计模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-decorator-design-pattern-in-javascript-6aee27837dbd?source=collection_archive---------1-----------------------#2020-03-09">https://javascript.plainenglish.io/the-decorator-design-pattern-in-javascript-6aee27837dbd?source=collection_archive---------1-----------------------#2020-03-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0710" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">在装饰者的帮助下对你的代码进行基准测试和优化</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/a3bbce6ed52a53dafe532f5de8a42179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2wrMcyTHCn7OKDjAyuDTYg.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae kv" href="https://unsplash.com/?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://www.webtips.dev/the-decorator-design-pattern-in-javascript"><div class="gh gi kw"><img src="../Images/c19cb3069af1beba3c93258d9fcfe139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*-PVzecNs3s4ZbJsdsgIsGA.png"/></div></a></figure><p id="67ec" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你以前使用过Angular或者Mobx，你应该已经对decorators比较熟悉了，因为他们经常使用它们。他们长期以来一直是其他语言的一部分，但是他们也来到了<a class="ae kv" href="https://github.com/tc39/proposal-decorators" rel="noopener ugc nofollow" target="_blank"> JavaScript </a>。</p><p id="7cad" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">今天，我们已经可以将它们用于polyfillers或编译器，如<a class="ae kv" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>。如果你不熟悉装修工，我们正在谈论以下内容:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/e41cb9670a13dbf11a840be7cfe5bff4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*qHJLxYVeIjqVu9vFcc_WfA.png"/></div></figure><p id="e991" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里的<code class="fe lu lv lw lx b">@observable</code>是一个装饰器，它负责用附加功能包装这两个属性。那么它们是如何被创造出来的呢？</p><p id="d06a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们先退一步，定义一下一般的设计模式是什么。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="1283" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">什么是设计模式？</h1><p id="e0b6" class="pw-post-body-paragraph kx ky iq kz b la mx jr lc ld my ju lf lg mz li lj lk na lm ln lo nb lq lr ls ij bi translated">设计模式是软件开发中常见问题的测试解决方案。不同的模式可以分为三个不同的类别:创造型、结构型和行为型。</p><p id="4665" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我已经写过JavaScript中常用的行为设计模式<a class="ae kv" href="https://www.webtips.dev/intro-to-design-patterns-create-your-own-pubsub-library" rel="noopener ugc nofollow" target="_blank">PubSub模式</a>。现在是时候讨论一种用于向对象动态添加增强功能的结构模式了。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="bce8" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">装饰模式的概念</h1><p id="72dd" class="pw-post-body-paragraph kx ky iq kz b la mx jr lc ld my ju lf lg mz li lj lk na lm ln lo nb lq lr ls ij bi translated">我们已经看到了装修工的样子。它们用一个符号<code class="fe lu lv lw lx b">@</code>表示，后面跟有装饰者的名字。装饰器实际上只是高阶函数的语法糖。它们本质上是将一个方法或属性包装到另一个函数中，该函数扩展了它的原始功能。</p><p id="64bf" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它可以简单到添加日志，也可以复杂到为用户组定义访问权限。值得一提的是，您只能将decorators附加到类声明、方法、属性或参数上。这就是为什么你会看到在整个教程中使用的对象。</p></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="0057" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">创造装饰者</h1><p id="1d2b" class="pw-post-body-paragraph kx ky iq kz b la mx jr lc ld my ju lf lg mz li lj lk na lm ln lo nb lq lr ls ij bi translated">要使用decorator，您需要首先用decorator插件设置<a class="ae kv" href="https://babeljs.io/" rel="noopener ugc nofollow" target="_blank"> Babel </a>。它会把你的代码向下转换到ES6，这样浏览器就能正确地解析它。如果你只想试验装修工但不想配置任何东西，可以在巴别塔官方网站上使用<a class="ae kv" href="https://babeljs.io/repl/" rel="noopener ugc nofollow" target="_blank"> Repl </a>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nc"><img src="../Images/2333ecc78e3709100170739d106d202e.png" data-original-src="https://miro.medium.com/v2/resize:fit:820/format:webp/1*GL_KW5Y-qvmRVPhV5NJFMg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Don’t forget to set the decorators mode to legacy if using Repl</figcaption></figure><p id="e28d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">那么什么是装修工呢？—decorator实际上只是一些函数，它们将三个参数作为参数:</p><ul class=""><li id="38be" class="nd ne iq kz b la lb ld le lg nf lk ng lo nh ls ni nj nk nl bi translated"><code class="fe lu lv lw lx b">object</code>:我们要定义属性的对象</li><li id="05ed" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated"><code class="fe lu lv lw lx b">property</code>:我们要修改的对象的属性或方法的名称</li><li id="764b" class="nd ne iq kz b la nm ld nn lg no lk np lo nq ls ni nj nk nl bi translated"><code class="fe lu lv lw lx b">descriptor</code>:描述新的属性或方法应该如何表现</li></ul><p id="1888" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果你曾经使用过<code class="fe lu lv lw lx b"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" rel="noopener ugc nofollow" target="_blank">Object.defineProperty</a></code>，你可能会发现两者之间的一些相似之处。让我们看一个非常简单的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="ebd1" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们有一个带有<code class="fe lu lv lw lx b">greet</code>方法的对象，我们想覆盖这个方法的主体。我们用装饰器对函数进行了注释。要创建这个装饰器，只需创建一个同名的函数，它带有我们讨论过的三个参数。将<code class="fe lu lv lw lx b">descriptor.value</code>分配给一个新功能会覆盖原来的功能，我们会在控制台中重新获得<code class="fe lu lv lw lx b">Hello Patrick!</code>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nt"><img src="../Images/90735f7a8b1a82eb8b548d6eaae5b4a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1116/format:webp/1*2YtsM0A633wFSsizK1P4qA.png"/></div></figure><p id="2972" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在让我们看两个更实际的例子:一个用于测试性能，另一个用于提高性能。</p><h2 id="c470" class="nu mg iq bd mh nv nw dn ml nx ny dp mp lg nz oa mr lk ob oc mt lo od oe mv of bi translated">@时间装饰者</h2><p id="8b8c" class="pw-post-body-paragraph kx ky iq kz b la mx jr lc ld my ju lf lg mz li lj lk na lm ln lo nb lq lr ls ij bi translated">假设我们有一个函数来获取第一个<code class="fe lu lv lw lx b">n</code>三角数，我们想知道生成它们所需的时间:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="9fba" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们有一个带循环的简单函数，我们想修饰它。所以我们创建了一个名为<code class="fe lu lv lw lx b">@time</code>的新装饰器:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="c474" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这一次，我们不想覆盖整个函数体，而是希望用附加功能来扩展它。所以我们从在<code class="fe lu lv lw lx b">descriptor.value</code>中存储原始函数开始。</p><p id="8ff9" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们可以使用析构来获取传递给原始函数的所有可用属性，并获取函数返回值，然后存储在<code class="fe lu lv lw lx b">originalValue</code>中。这是我们最终的回报。我们将所有东西包装在<code class="fe lu lv lw lx b">console.time</code>中，它测量函数运行所花费的时间。</p><p id="0378" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果我们使用装饰器并调用该函数，我们会将以下内容打印到控制台:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/f86e5b8d16c4d27019642852f9076115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1338/format:webp/1*wLb2OGINYLqyh8dQfEQEqg.png"/></div></figure><p id="3980" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在想象这是用前100万组数字完成的。时间增加了，所以我们想用另一个装饰器来优化这个函数:</p><h2 id="3055" class="nu mg iq bd mh nv nw dn ml nx ny dp mp lg nz oa mr lk ob oc mt lo od oe mv of bi translated">@memoize decorator</h2><p id="ad3c" class="pw-post-body-paragraph kx ky iq kz b la mx jr lc ld my ju lf lg mz li lj lk na lm ln lo nb lq lr ls ij bi translated">如果你没有听说过memoization，那就是缓存以前的结果。因此，我们可以返回缓存的值，而不是为以前的执行重新运行计算。</p><p id="0164" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，我们再次创建了另一个名为<code class="fe lu lv lw lx b">memoize</code>的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="a5c0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在这个函数中，我们可以创建一个<code class="fe lu lv lw lx b">cache</code>对象来存储以前的值。然后，我们可以根据传递给函数的参数，为名为的属性获取或分配一个新值。这将确保我们有唯一的属性，并且只有一个值将被分配给一组结果。</p><p id="7089" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果我们已经有一个缓存的值，我们返回它。否则，我们执行原始函数。</p><p id="474a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在我们需要将两个装饰器分配给calculate函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div></figure><p id="59bc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，我们想调用<code class="fe lu lv lw lx b">@time</code>，然后调用<code class="fe lu lv lw lx b">@memoize</code>。如果我们再次运行该方法两次，我们会发现第一次运行需要大约100毫秒，但第二次只需要大约0.014毫秒，因为结果是从缓存中请求的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/00ae5ec3a242d97fdfbd3518dd927058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-BdhXu-X4FcctZa3P-eU9g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">This is roughly a 99.98% decrease in time.</figcaption></figure></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><h1 id="a36c" class="mf mg iq bd mh mi mj mk ml mm mn mo mp jw mq jx mr jz ms ka mt kc mu kd mv mw bi translated">摘要</h1><p id="bfd1" class="pw-post-body-paragraph kx ky iq kz b la mx jr lc ld my ju lf lg mz li lj lk na lm ln lo nb lq lr ls ij bi translated">当然，这样的例子不胜枚举。你可以给对象添加额外的属性，或者将它用于更复杂的情况，比如Angular的<code class="fe lu lv lw lx b">@Component</code>或者Mobx的<code class="fe lu lv lw lx b">@observable</code>或者<code class="fe lu lv lw lx b">@observer</code>。</p><p id="f6ee" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因为我们正在讨论函数调用，所以您也可以通过向decorators传递值来使用它们:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nr ns l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Just as Angular does for the @Component decorator</figcaption></figure><p id="e41d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你最喜欢的装饰者的用例是什么？你以前用过吗？请在下面的评论中告诉我们。感谢您通读，编码快乐！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://medium.com/@ferencalmasi/membership"><div class="gh gi oi"><img src="../Images/e66c4cd6d9849ac0bd245f3fc39b65c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZ9xuLqLkbqUG65sgVB3gg.png"/></div></a></figure></div><div class="ab cl ly lz hu ma" role="separator"><span class="mb bw bk mc md me"/><span class="mb bw bk mc md me"/><span class="mb bw bk mc md"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://www.webtips.dev/intro-to-design-patterns-create-your-own-pubsub-library"><div class="gh gi kw"><img src="../Images/d9ac2e33edb11c25af97058c6084dc8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*-ebmbmPy8KpBHH1CfoBTGQ.png"/></div></a></figure></div></div>    
</body>
</html>