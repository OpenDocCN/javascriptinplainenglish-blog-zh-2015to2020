<html>
<head>
<title>The Fastest Way to Remove a Specific Item from an Array in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中从数组中移除特定项的最快方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-remove-a-specific-item-from-an-array-in-javascript-a49b108404c?source=collection_archive---------0-----------------------#2020-04-20">https://javascript.plainenglish.io/how-to-remove-a-specific-item-from-an-array-in-javascript-a49b108404c?source=collection_archive---------0-----------------------#2020-04-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="5ec4" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">性能测试一个<code class="fe iy iz ja jb b">for</code>回路对<code class="fe iy iz ja jb b">.indexOf</code>和<code class="fe iy iz ja jb b">splice</code>对<code class="fe iy iz ja jb b">.filter</code></h2><div class=""/><div class=""><h2 id="c785" class="pw-subtitle-paragraph ka jd iq bd b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dk translated">我演示了如何使用<code class="fe iy iz ja jb b">.indexOf</code>和<code class="fe iy iz ja jb b">.splice</code>从数组中移除一个项目。然后，我比较了一个<code class="fe iy iz ja jb b">for</code>循环和<code class="fe iy iz ja jb b">.filter</code>方法的性能。</h2></div><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ks"><img src="../Images/7c5f998c8876dc92550a3b5724b1a3e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iEmJMi4k9RgOO2ET"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Photo by <a class="ae li" href="https://unsplash.com/@simmerdownjpg?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jackson Simmer</a> on <a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="44d2" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi mf translated"><span class="l mg mh mi bm mj mk ml mm mn di">JavaScript中的一个常见问题是，使用内置JavaScript方法从数组中移除值的最快方法是什么(<a class="ae li" href="https://snipcart.com/blog/learn-vanilla-javascript-before-using-js-frameworks" rel="noopener ugc nofollow" target="_blank"> vanilla JS </a>)。</span></p><p id="3f6d" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">换句话说，修改数组使其不再包含特定值的最快方法。</p><p id="ef96" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">本文测试了用JavaScript从数组中移除特定项的4种不同方法的性能。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="b9d2" class="mv mw iq bd mx my mz na nb nc nd ne nf kj ng kk nh km ni kn nj kp nk kq nl nm bi translated">从数组中移除项目</h1><p id="ea2c" class="pw-post-body-paragraph lj lk iq ll b lm nn ke lo lp no kh lr ls np lu lv lw nq ly lz ma nr mc md me ij bi translated">解决这个问题的一个方法是使用<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf" rel="noopener ugc nofollow" target="_blank">Array.prototype.indexOf()</a></code>查找值的索引，然后使用<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice" rel="noopener ugc nofollow" target="_blank">Array.prototype.splice()</a></code>删除该项:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="a32e" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">注意，如果没有找到索引，<code class="fe iy iz ja jb b">.indexOf</code>返回-1，但是<code class="fe iy iz ja jb b">.splice</code>将-1的索引解释为数组中的最后一项，<a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-select-a-range-from-an-array-in-javascript-96a163fe8f34" rel="noopener">就像</a> <code class="fe iy iz ja jb b"><a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-select-a-range-from-an-array-in-javascript-96a163fe8f34" rel="noopener">.slice</a></code>一样。</p><p id="1fb0" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">下面的代码使用<code class="fe iy iz ja jb b"><a class="ae li" href="https://medium.com/javascript-in-plain-english/what-does-the-question-mark-mean-in-javascript-code-353cfadcf760" rel="noopener">?</a></code> <a class="ae li" href="https://medium.com/javascript-in-plain-english/what-does-the-question-mark-mean-in-javascript-code-353cfadcf760" rel="noopener">问号运算符</a>是等效的:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="e1f4" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果您真的不介意在找到值时搜索整个数组两次会影响性能，您也可以编写一行程序:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="d582" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">所有这些方法都只删除给定值的第一个实例:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2401" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我将在本文后面讨论删除所有匹配项的选项。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="a524" class="mv mw iq bd mx my mz na nb nc nd ne nf kj ng kk nh km ni kn nj kp nk kq nl nm bi translated"><code class="fe iy iz ja jb b">for</code>循环怎么样？</h1><p id="1ff5" class="pw-post-body-paragraph lj lk iq ll b lm nn ke lo lp no kh lr ls np lu lv lw nq ly lz ma nr mc md me ij bi mf translated"><span class="l mg mh mi bm mj mk ml mm mn di">从数组中移除一个项目的一个非常好的选择是使用<code class="fe iy iz ja jb b">for</code>循环，尽管在您的代码中可能更难读取:</span></p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="fd43" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">为了使其等同于使用<code class="fe iy iz ja jb b">.indexOf</code>并且只移除第一个实例，我使用了一个变量来跟踪该值是否已经被移除。</p><p id="65d1" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">以下操作将删除所有使用<code class="fe iy iz ja jb b">.indexOf</code>和<code class="fe iy iz ja jb b">.splice</code>的实例:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0785" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">下面将使用<code class="fe iy iz ja jb b">for</code>循环删除所有实例:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ns nt l"/></div></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="f3ae" class="mv mw iq bd mx my mz na nb nc nd ne nf kj ng kk nh km ni kn nj kp nk kq nl nm bi translated">哪个更快？</h1><p id="c431" class="pw-post-body-paragraph lj lk iq ll b lm nn ke lo lp no kh lr ls np lu lv lw nq ly lz ma nr mc md me ij bi mf translated"><span class="l mg mh mi bm mj mk ml mm mn di"> P </span>使用<a class="ae li" href="https://jsperf.com/removing-an-item-from-an-array/" rel="noopener ugc nofollow" target="_blank">进行性能测试这些jsPerf测试用例</a>显示了从数组中移除项目的两种方法之间的巨大差异:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nu"><img src="../Images/72471e0ed76b206561a2805ae2381255.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sqc7jqSHFaCsy4Nz_c2IPA.png"/></div></div></figure><p id="9d5d" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><strong class="ll je">使用</strong> <code class="fe iy iz ja jb b"><strong class="ll je">for</strong></code> <strong class="ll je">循环出现的速度比<code class="fe iy iz ja jb b">.indexOf</code>和<code class="fe iy iz ja jb b">.splice</code>快2.5倍。</strong></p><p id="43e8" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">当移除匹配值的所有实例时，这种差异被放大了，我在<a class="ae li" href="https://jsperf.com/removing-all-items-from-an-array" rel="noopener ugc nofollow" target="_blank">这些jsPerf测试用例</a>中对其进行了测试:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nv"><img src="../Images/ac137a44f144ae17592982883219eb8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Cg30RCbOIqclZha94kNDhA.png"/></div></div></figure><p id="e551" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如您所见，<strong class="ll je"/><code class="fe iy iz ja jb b"><strong class="ll je">for</strong></code><strong class="ll je">循环比<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/while" rel="noopener ugc nofollow" target="_blank">while</a></code> <a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/while" rel="noopener ugc nofollow" target="_blank">循环</a>以非常低效的方式使用<code class="fe iy iz ja jb b">.indexOf</code>和<code class="fe iy iz ja jb b">.splice</code>快5倍</strong>。</p><p id="0294" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">但这些结果具有误导性，因为处理器仍在每毫秒(4，000，000 ops/sec)处理4000个操作。</p><p id="d2bf" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">正如您将在后面看到的，当处理10，000个项目的大数组时，<code class="fe iy iz ja jb b">.indexOf</code>和<code class="fe iy iz ja jb b">.splice</code>实际上比<code class="fe iy iz ja jb b">for</code>循环有更好的性能。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="b718" class="mv mw iq bd mx my mz na nb nc nd ne nf kj ng kk nh km ni kn nj kp nk kq nl nm bi translated"><code class="fe iy iz ja jb b">.filter</code>怎么样？</h1><p id="f700" class="pw-post-body-paragraph lj lk iq ll b lm nn ke lo lp no kh lr ls np lu lv lw nq ly lz ma nr mc md me ij bi mf translated">提到内置的<code class="fe iy iz ja jb b"><a class="ae li" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" rel="noopener ugc nofollow" target="_blank">Array.prototype.filter()</a></code>方法是公平的，它是JavaScript的<a class="ae li" href="https://medium.com/javascript-in-plain-english/what-are-javascript-programming-paradigms-3ef0f576dfdb" rel="noopener">函数式编程</a>工具之一。</p><p id="de10" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">下面是一个使用<code class="fe iy iz ja jb b">.filter</code>从数组中移除所有项的示例，它返回一个过滤后的数组，其中包含与给定条件匹配的值:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="2211" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">从好的方面来看，filter产生了更少的代码。但是有多快呢？</p><p id="b53b" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在<a class="ae li" href="https://jsperf.com/removing-all-items-from-an-array-with-filter/" rel="noopener ugc nofollow" target="_blank">这些jsPerf测试用例</a>中，我将<code class="fe iy iz ja jb b">.filter</code>与使用<code class="fe iy iz ja jb b">.indexOf</code>和<code class="fe iy iz ja jb b">.splice</code>的超慢速<code class="fe iy iz ja jb b">while</code>循环以及超快速<code class="fe iy iz ja jb b">for</code>循环进行了比较:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nw"><img src="../Images/9267f29bcda8898e61b8d5791fec5781.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FH3g3DJwbAW7TBy6_yvFog.png"/></div></div></figure><p id="1acf" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如您所见，<code class="fe iy iz ja jb b">.filter()</code>是一个不错的选择——一个<code class="fe iy iz ja jb b">for</code>循环要快一点，但是<code class="fe iy iz ja jb b">.filter()</code>对于从一个数组中移除所有匹配的值来说是很好的。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="e927" class="mv mw iq bd mx my mz na nb nc nd ne nf kj ng kk nh km ni kn nj kp nk kq nl nm bi translated">大数组中哪个最快？</h1><p id="7286" class="pw-post-body-paragraph lj lk iq ll b lm nn ke lo lp no kh lr ls np lu lv lw nq ly lz ma nr mc md me ij bi mf translated">当然，上面的数据研究的是微小的数组——我的浏览器每秒钟能处理400万次循环。速度很快。</p><p id="976c" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果我们使用一个更大的数组，比如说10，000个条目，会怎么样？在这种情况下，性能在很大程度上取决于您正在处理的数据。</p><p id="0cf0" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">在一个10，000个项目的数组中，目标(数字5，000)只被发现一次，带有<code class="fe iy iz ja jb b">.indexOf</code>和<code class="fe iy iz ja jb b">.splice</code> <a class="ae li" href="https://jsperf.com/removing-all-items-from-a-large-array" rel="noopener ugc nofollow" target="_blank">的<code class="fe iy iz ja jb b">while</code>循环实际上赢了</a>:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi nx"><img src="../Images/be9fe6102795e81fc61ff615a6b4585a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AEjVbijJ1brJK8dPcaN6Lg.png"/></div></div></figure><p id="85e3" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">对于这个用例，<code class="fe iy iz ja jb b">.filter</code>是一个大输家，因为<code class="fe iy iz ja jb b">for</code>循环大约快5倍。但是<code class="fe iy iz ja jb b">.indexOf</code>和<code class="fe iy iz ja jb b">.splice</code>比<code class="fe iy iz ja jb b">for</code>循环快两倍以上。</p><p id="c555" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">与之相比，在一个10，000项的数组中，目标(数字5，000)与数组中的其他项一样。结果<a class="ae li" href="https://jsperf.com/removing-all-items-large-array-half-matches" rel="noopener ugc nofollow" target="_blank">与</a>完全相同:</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi ny"><img src="../Images/99e6d336171a374d637460ce69d679b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VATTm0Wm0f_UCMo2PBrqnw.png"/></div></div></figure><p id="a8db" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">思考这些数字意味着什么。filter处理10，000个项目的数组只需要0.25毫秒，仍然非常快。</p><p id="23af" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">带回家的信息是<strong class="ll je">不要搞</strong> <a class="ae li" href="https://wiki.c2.com/?PrematureOptimization" rel="noopener ugc nofollow" target="_blank"> <strong class="ll je">过早优化</strong> </a>。</p><p id="ab6f" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">尽可能使用可读性最好的代码，然后只在必要时进行优化。</p></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="0134" class="mv mw iq bd mx my mz na nb nc nd ne nf kj ng kk nh km ni kn nj kp nk kq nl nm bi translated">如何避免变异？</h1><p id="d05b" class="pw-post-body-paragraph lj lk iq ll b lm nn ke lo lp no kh lr ls np lu lv lw nq ly lz ma nr mc md me ij bi mf translated"><span class="l mg mh mi bm mj mk ml mm mn di"> N </span>注意<code class="fe iy iz ja jb b">Array.prototype.splice()</code>在处修改数组<a class="ae li" href="https://www.interviewcake.com/concept/javascript/in-place" rel="noopener ugc nofollow" target="_blank">，一般对性能有好处，但是你可以得到</a><a class="ae li" href="https://techblog.commercetools.com/mutating-objects-what-can-go-wrong-7b89d4b8b1ac" rel="noopener ugc nofollow" target="_blank">副作用</a>(bug)。</p><p id="8844" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">请注意，修改一个对象，也称为<a class="ae li" href="https://github.com/jhusain/eslint-plugin-immutable" rel="noopener ugc nofollow" target="_blank">变异它</a>，有时被认为是糟糕的代码实践，因为有可能产生副作用。</p><p id="c612" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">甚至有一个<a class="ae li" href="https://eslint.org/" rel="noopener ugc nofollow" target="_blank"> ESLint </a>插件(<a class="ae li" href="https://github.com/jhusain/eslint-plugin-immutable" rel="noopener ugc nofollow" target="_blank">ESLint-plugin-immutable</a>)可以完全禁用所有对象突变——这是一个防止错误的好主意。</p><p id="d9ee" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">但是，如何在不改变原始数组的情况下从数组中移除一个项呢？您只需要将<a class="ae li" href="https://levelup.gitconnected.com/how-to-copy-an-array-in-javascript-with-array-from-298c7e66eebc" rel="noopener ugc nofollow" target="_blank">制作成数组</a>的一个浅层副本:</p><figure class="kt ku kv kw gt kx"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="01ad" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">循环方法已经避免了突变，因为您正在将项目T2到一个新的数组中。这本质上是数组的浅表副本。</p><p id="1d50" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果由于数组中的嵌套对象或数组，您需要进行深度复制，那么请查看我的文章<a class="ae li" href="https://medium.com/javascript-in-plain-english/how-to-deep-copy-objects-and-arrays-in-javascript-7c911359b089" rel="noopener">在JavaScript中深度复制数组</a>:</p><div class="nz oa gp gr ob oc"><a href="https://medium.com/javascript-in-plain-english/how-to-deep-copy-objects-and-arrays-in-javascript-7c911359b089" rel="noopener follow" target="_blank"><div class="od ab fo"><div class="oe ab of cl cj og"><h2 class="bd je gy z fp oh fr fs oi fu fw jd bi translated">如何在JavaScript中深度复制对象和数组</h2><div class="oj l"><h3 class="bd b gy z fp oh fr fs oi fu fw dk translated">复制对象或数组的常用方法只能进行浅层复制，所以深度嵌套的引用是个问题…</h3></div><div class="ok l"><p class="bd b dl z fp oh fr fs oi fu fw dk translated">medium.com</p></div></div><div class="ol l"><div class="om l on oo op ol oq lc oc"/></div></div></a></div></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><h1 id="081f" class="mv mw iq bd mx my mz na nb nc nd ne nf kj ng kk nh km ni kn nj kp nk kq nl nm bi translated">结论</h1><p id="b20f" class="pw-post-body-paragraph lj lk iq ll b lm nn ke lo lp no kh lr ls np lu lv lw nq ly lz ma nr mc md me ij bi mf translated">现在你明白了如何结合使用<code class="fe iy iz ja jb b">.indexOf</code>和<code class="fe iy iz ja jb b">.splice</code>从JavaScript数组中删除一个条目，从而改变数组。</p><p id="4634" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">为了避免数组变异，可以做一个浅拷贝或者使用一个<code class="fe iy iz ja jb b">for</code>循环。</p><p id="dc9a" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">如果您需要从数组中移除每个匹配值，或者只是使用<code class="fe iy iz ja jb b">.filter</code>来过滤匹配项，那么<code class="fe iy iz ja jb b">for</code>循环也是一个很好的选择。</p><p id="b267" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">虽然对于小型阵列，组合<code class="fe iy iz ja jb b">.indexOf</code>和<code class="fe iy iz ja jb b">.splice</code>比使用<code class="fe iy iz ja jb b">for</code>循环要慢，但是对于大型阵列，性能会有所不同。</p><p id="11fb" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">我建议在您的代码中使用可读性最强的版本:</p><ul class=""><li id="042c" class="or os iq ll b lm ln lp lq ls ot lw ou ma ov me ow ox oy oz bi translated"><code class="fe iy iz ja jb b">.indexOf</code>和<code class="fe iy iz ja jb b">.splice</code>仅删除值的第一个实例</li><li id="841c" class="or os iq ll b lm pa lp pb ls pc lw pd ma pe me ow ox oy oz bi translated"><code class="fe iy iz ja jb b">.filter</code>从数组中删除一个值的每个实例</li></ul><p id="4dd7" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这些方法本质上比<code class="fe iy iz ja jb b">for</code>循环更加<a class="ae li" href="https://dev.to/woubuc/self-documenting-is-a-myth-and-how-to-make-your-code-self-documenting-3h2n" rel="noopener ugc nofollow" target="_blank">自文档化</a>，在<code class="fe iy iz ja jb b">for</code>循环中，您需要编写注释来解释您的代码。</p><p id="b8ab" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">为了在从大型数组中移除项目时获得最佳性能，请考虑使用<code class="fe iy iz ja jb b">.indexOf</code>和<code class="fe iy iz ja jb b">.splice</code>，因为这种方法非常快。</p><p id="7f1a" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">编码快乐！😄🥴😂</p><figure class="kt ku kv kw gt kx gh gi paragraph-image"><div role="button" tabindex="0" class="ky kz di la bf lb"><div class="gh gi pf"><img src="../Images/10e0b401f1158a4226d9116133456d89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*J2Rk9-p4dKnbYQ0S"/></div></div><figcaption class="le lf gj gh gi lg lh bd b be z dk">Photo by <a class="ae li" href="https://unsplash.com/@polarmermaid?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anne Nygård</a> on <a class="ae li" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure></div><div class="ab cl mo mp hu mq" role="separator"><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt mu"/><span class="mr bw bk ms mt"/></div><div class="ij ik il im in"><p id="0a4b" class="pw-post-body-paragraph lj lk iq ll b lm ln ke lo lp lq kh lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated"><a class="ae li" href="https://www.linkedin.com/in/derek-austin/" rel="noopener ugc nofollow" target="_blank">德里克·奥斯汀博士</a>是《职业规划:如何在6个月内成为一名成功的6位数程序员 》一书的作者，该书现已在亚马逊上架。</p></div></div>    
</body>
</html>