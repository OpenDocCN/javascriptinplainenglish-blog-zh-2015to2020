<html>
<head>
<title>JavaScript Best Practices — Mutations and Security</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—突变和安全性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-mutations-and-security-89b543bd473b?source=collection_archive---------7-----------------------#2020-06-24">https://javascript.plainenglish.io/javascript-best-practices-mutations-and-security-89b543bd473b?source=collection_archive---------7-----------------------#2020-06-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2608034a5f81e581141b4d774ec07e66.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*DaEP6-MnLNQYtiVf"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@joshstyle?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">JOSHUA COLEMAN</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8293" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，JavaScript应用程序也必须写得很好。</p><p id="9a1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们以后会遇到各种各样的问题。</p><p id="0a6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究为什么以及如何避免突变和复杂性。</p><p id="9e84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们还关注安全问题。</p><h1 id="5b82" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用代理</h1><p id="46c3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">代理给对象操作增加了副作用，所以我们可能希望避免它们以降低复杂性。</p><p id="1c46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="680f" class="mn lc iq mj b gy mo mp l mq mr">const handler = {<br/>  get(target, key) {<br/>    return Math.max(target[key], Infinity);<br/>  }<br/>};<br/>const object = new Proxy(variable, handler);<br/>object.a;</span></pre><p id="e364" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们创建了一个函数:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="412f" class="mn lc iq mj b gy mo mp l mq mr">const bigProperty = (target, key) =&gt; {<br/>  return Math.min(target[key], Infinity);<br/>}<br/>positiveProperty(object, 'a');</span></pre><h1 id="2cbb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">减少Rest参数的使用</h1><p id="8a51" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Rest参数非常方便，因为我们可以向函数传递任意数量的参数。</p><p id="5253" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，最好有明确的参数，因为它们更容易处理。</p><p id="290d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">带有rest参数的函数不太适合currying，因为参数的数量不确定。</p><p id="d3a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，不使用:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="44a0" class="mn lc iq mj b gy mo mp l mq mr">const sum = (...nums) =&gt; {<br/>  return nums.reduce((a, b) =&gt; a + b);<br/>}</span></pre><p id="12a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="584f" class="mn lc iq mj b gy mo mp l mq mr">const sum = (nums) =&gt; {<br/>  return nums.reduce((a, b) =&gt; a + b);<br/>}</span></pre><p id="be64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">nums</code>是第二个例子中的数组。</p><p id="770a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在一个数组中有一个固定的参数比有无限多个参数要好。</p><h1 id="2531" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">减少这个的使用</h1><p id="faeb" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用<code class="fe ms mt mu mj b">this</code>应该减少，因为使用<code class="fe ms mt mu mj b">this</code>意味着我们有一个突变的内部状态。</p><p id="877b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，<code class="fe ms mt mu mj b">this</code>在JavaScript中也很混乱。</p><p id="bc0b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们使用它，它将是一片混乱。<code class="fe ms mt mu mj b">this</code>的值根据作用域而变化。</p><h1 id="9723" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">投掷的使用</h1><p id="d241" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该过多地使用<code class="fe ms mt mu mj b">throw</code>。它应该保留给我们在应用程序中无法解决的问题。</p><p id="1ac1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还应该用于最关键的错误，以便每个人都可以立即看到它们。</p><p id="30cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在其他情况下，我们可能希望返回数据，而不是在我们的函数中。</p><p id="9fc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="93d7" class="mn lc iq mj b gy mo mp l mq mr">const throwAnError = () =&gt; {<br/>  throw new Error('error');<br/>}</span></pre><p id="bc40" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="85a6" class="mn lc iq mj b gy mo mp l mq mr">const returnAnError() {<br/>  return new Error('error');<br/>}</span></pre><h1 id="1849" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有未使用的表达式</h1><p id="14cd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们的代码中不应该有任何未使用的表达式。</p><p id="0810" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以像这样的事情:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4aef" class="mn lc iq mj b gy mo mp l mq mr">1 + 2</span></pre><p id="312b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不应该出现在我们的代码中，因为它毫无用处。</p><p id="46d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该将表达式赋给一个变量，或者将它们作为函数的参数传入，以便使用它们。</p><p id="d532" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6fab" class="mn lc iq mj b gy mo mp l mq mr">const sum = 1 + 2;</span></pre><h1 id="9f14" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有字段值</h1><p id="3a98" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">字段是无用的，因为它只是将存储在对象中的值转换成原始值。</p><p id="0b4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一种迂回且令人困惑的创建原始值的方式。</p><p id="7f0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们应该只创建原始值。</p><p id="9cbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以与其写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9ecc" class="mn lc iq mj b gy mo mp l mq mr">const obj = {<br/>  value: 200,<br/>  valueOf() { return this.value; }<br/>};</span></pre><p id="8ff4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0d77" class="mn lc iq mj b gy mo mp l mq mr">const a = 200;</span></pre><h1 id="a280" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">总是错误地使用new</h1><p id="ff5c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mj b">Error</code>是一个构造函数，所以我们应该和<code class="fe ms mt mu mj b">new</code>一起使用。</p><p id="7664" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，如果不使用类语法，很容易跳过<code class="fe ms mt mu mj b">new</code>。</p><p id="d05f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们把它忘在其他地方，我们会得到意想不到的结果。</p><p id="9e25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以为了保持一致，我们应该在任何地方使用<code class="fe ms mt mu mj b">new</code>，包括当我们创建<code class="fe ms mt mu mj b">Error</code>对象的时候。</p><p id="fb12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4e5c" class="mn lc iq mj b gy mo mp l mq mr">throw Error('foo');</span></pre><p id="4214" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="fa74" class="mn lc iq mj b gy mo mp l mq mr">throw new Error('foo');</span></pre><h1 id="ed42" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">安全风险</h1><p id="c04a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">像正则表达式这样的东西存在安全风险。</p><p id="5df7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在使用它们时应该小心，以免它们破坏我们的应用程序。</p><h1 id="aeda" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">正则表达式DoS和Node.js</h1><p id="afae" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">Node.js在针对长字符串检查大型正则表达式方面存在问题。</p><p id="a2df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些大表达式阻塞了事件循环，因此我们的应用程序将被暂停，直到代码结束运行。</p><p id="757a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为Node.js大部分是单线程的，所以我们会遇到大正则表达式检查的问题。</p><p id="5126" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">具有某些属性的正则表达式，比如具有重复的分组，会比其他的产生更多的问题。</p><p id="3bb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们有一个电子邮件正则表达式，如:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9f09" class="mn lc iq mj b gy mo mp l mq mr">/^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/</span></pre><p id="52ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">，那么Node.js根据这个正则表达式检查字符串的速度会很慢。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/d3037e7dbd087c632201c1ce3a4005dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*jvkeIQr5aOn7_vqh"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@scottwebb?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Scott Webb</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="ed35" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="1598" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该大部分时间使用代理来简化代码。</p><p id="efe1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">应尽量减少使用<code class="fe ms mt mu mj b">this</code>,以减少混乱和出错的机会。</p><p id="b331" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们应该在使用正则表达式之前检查它是否会停止Node.js程序。</p><h2 id="3edf" class="mn lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">简单英语的JavaScript</h2><p id="daff" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？在<a class="ae kc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir"> plainenglish.io </strong> </a>和<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">找到他们订阅我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>