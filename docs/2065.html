<html>
<head>
<title>JavaScript Best Practices— Padding, Exponentiation, and Spread</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—填充、求幂和扩散</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-padding-exponentiation-and-spread-e326f873998?source=collection_archive---------16-----------------------#2020-05-16">https://javascript.plainenglish.io/javascript-best-practices-padding-exponentiation-and-spread-e326f873998?source=collection_archive---------16-----------------------#2020-05-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f088944bcf54a2f33ee8105954da8f77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q6Br5NIM7KnFIG7P"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mermalade?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unda Tiltina</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="03c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种非常宽容的语言。编写可以运行但有错误的代码很容易。</p><p id="ef9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究语句之间的填充、取幂和扩展。</p><h1 id="4722" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">语句之间的填充行</h1><p id="84f4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不需要所有语句之间都有空行。我们只需要不相关的语句组之间的空行。</p><p id="02c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，对函数中的语句进行分组的一种方法是编写如下代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="863a" class="mn lc iq mj b gy mo mp l mq mr">for (let i = 0; i &lt; 10; i++) {<br/>  console.log(i);<br/>}</span><span id="9e6d" class="mn lc iq mj b gy ms mp l mq mr">for (let j = 0; j &lt; 5; j++) {<br/>  console.log(i);<br/>}</span></pre><p id="ea24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们在2个<code class="fe mt mu mv mj b">for</code>循环之间有一个空行，因为每个循环都是它自己的逻辑组。</p><p id="4bd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需要在要分组的语句组之间有一个空行。空行告诉我们，他们应该作为一个群体来阅读。</p><p id="cdb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，空行是对空间的浪费，我们可以删除它们以节省垂直空间。</p><h1 id="81ea" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用<code class="fe mt mu mv mj b">Math.pow</code>与<code class="fe mt mu mv mj b">**</code>操作符</h1><p id="bb73" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe mt mu mv mj b">Math.pow</code>是一种让我们在从第一个版本到当前版本的所有JavaScript版本中做幂运算的方法。</p><p id="d68f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它接受两个参数，即底数和指数，并返回底数的给定指数。</p><p id="b012" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e4ec" class="mn lc iq mj b gy mo mp l mq mr">const a = Math.pow(2, 3);</span></pre><p id="44e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe mt mu mv mj b">a</code>是8，因为2是3的幂。</p><p id="ca64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它也适用于分数幂和负幂。例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5809" class="mn lc iq mj b gy mo mp l mq mr">const a = Math.pow(2, 0.5);</span></pre><p id="4494" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并得到<code class="fe mt mu mv mj b">a</code>为1.4142135623730951。我们也可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a857" class="mn lc iq mj b gy mo mp l mq mr">const a = Math.pow(2, -1);</span></pre><p id="364b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并得到<code class="fe mt mu mv mj b">a</code>为0.5。</p><p id="9eb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以用表达式代替数字，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="96f9" class="mn lc iq mj b gy mo mp l mq mr">const x = 1,<br/>  y = 2,<br/>  z = 3;<br/>const a = Math.pow(x + y, z);</span></pre><p id="7c34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe mt mu mv mj b">a</code>是27，因为<code class="fe mt mu mv mj b">x</code>是1，<code class="fe mt mu mv mj b">y</code>是2，<code class="fe mt mu mv mj b">c</code>是3，所以我们将基数3提升到3的幂。</p><p id="d64b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ES2015引入了指数运算符。用<code class="fe mt mu mv mj b">**</code>表示。</p><p id="24ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用它来做幂运算，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6bbb" class="mn lc iq mj b gy mo mp l mq mr">const a = 2 ** 3;</span></pre><p id="9fdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并得到<code class="fe mt mu mv mj b">a</code>为8。</p><p id="fb02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe mt mu mv mj b">**</code>运算符，分数、负幂和指数都如我们所预期的那样工作。例如，我们可以给他们写信如下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="99f4" class="mn lc iq mj b gy mo mp l mq mr">const a = 2 ** 0.5;<br/>const b = 2 ** -1;</span></pre><p id="4d79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于表达式，我们可以写成:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ab96" class="mn lc iq mj b gy mo mp l mq mr">const x = 1,<br/>  y = 2,<br/>  z = 3;<br/>const a = (x + y) ** z;</span></pre><p id="60ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，使用取幂操作符更短，我们得到的结果是一样的，而且比调用一个我们不需要调用的方法更易读。</p><p id="5b5b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们节省了大量的输入并做同样的事情，所以我们应该使用取幂操作符而不是调用<code class="fe mt mu mv mj b">Math.pow</code>来做取幂操作。</p><h1 id="5e19" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">调用时使用对象扩展运算符<code class="fe mt mu mv mj b">Object.assign</code></h1><p id="48c2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">从ES2018开始，扩展操作符在对象上工作。它允许我们对对象进行浅层复制，或者将多个对象合并成一个新对象。</p><p id="f877" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在ES6和ES2017之间，我们必须使用<code class="fe mt mu mv mj b">Object.assign</code>将多个对象合并成一个，或者对其进行浅层复制。</p><p id="bbce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用<code class="fe mt mu mv mj b">Object.assign</code>，我们通过编写以下代码来制作一个对象的浅层副本:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="35cf" class="mn lc iq mj b gy mo mp l mq mr">const foo = {<br/>  a: 1<br/>};<br/>const bar = Object.assign({}, foo);</span></pre><p id="ed02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们定义了<code class="fe mt mu mv mj b">foo</code>对象。然后我们调用了<code class="fe mt mu mv mj b">Object.assign</code>，用一个空对象作为第一个参数，用<code class="fe mt mu mv mj b">foo</code>对象作为第二个参数来返回<code class="fe mt mu mv mj b">foo</code>对象的一个浅层副本。</p><p id="f8b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浅层复制是指只复制顶级属性。嵌套对象仍然引用原始对象。</p><p id="e72b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们记录表达式<code class="fe mt mu mv mj b">foo === bar</code>，它返回<code class="fe mt mu mv mj b">false</code>，这意味着<code class="fe mt mu mv mj b">foo</code>和<code class="fe mt mu mv mj b">bar</code>没有在内存中引用同一个对象。因此，我们知道我们做了对象的浅层拷贝。</p><p id="c0f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">Object.assign</code>的第一个参数是要复制到的目标对象，其余的参数是我们想要复制到目标对象中的源对象，我们想要多少就有多少。</p><p id="d217" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了用<code class="fe mt mu mv mj b">Object.assign</code>将多个对象合并在一起，我们只需将更多的对象作为参数传递给它。</p><p id="39c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f7d6" class="mn lc iq mj b gy mo mp l mq mr">const foo = {<br/>  a: 1<br/>};<br/>const baz = {<br/>  b: 2<br/>};<br/>const qux = {<br/>  c: 3<br/>};<br/>const bar = Object.assign({}, foo, baz, qux);</span></pre><p id="072a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe mt mu mv mj b">bar</code>就是<code class="fe mt mu mv mj b">{a: 1, b: 2, c: 3}</code>。</p><p id="5c22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">spread运算符使这变得更简单。有了它，我们就不用调用函数来合并和制作对象的浅层副本了。我们所要做的就是使用spread运算符，用<code class="fe mt mu mv mj b">...</code>表示如下:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="ea0d" class="mn lc iq mj b gy mo mp l mq mr">const foo = {<br/>  a: 1<br/>};<br/>const baz = {<br/>  b: 2<br/>};<br/>const qux = {<br/>  c: 3<br/>};<br/>const bar = {<br/>  ...foo,<br/>  ...baz,<br/>  ...qux<br/>};</span></pre><p id="49b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码也将所有的对象合并成一个，就像我们对上面的<code class="fe mt mu mv mj b">Object.assign</code>所做的一样。</p><p id="bef7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此我们得到<code class="fe mt mu mv mj b">bar</code>是<code class="fe mt mu mv mj b">{a: 1, b: 2, c: 3}</code>。</p><p id="8e8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以制作一个对象的浅层副本，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="71fb" class="mn lc iq mj b gy mo mp l mq mr">const foo = {<br/>  a: 1<br/>};<br/>const bar = {<br/>  ...foo,<br/>};</span></pre><p id="ce62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe mt mu mv mj b">bar</code>是<code class="fe mt mu mv mj b">{ a: 1 }</code>，但是<code class="fe mt mu mv mj b">foo</code>和<code class="fe mt mu mv mj b">bar</code>与<code class="fe mt mu mv mj b">===</code>运算符相比不相等，因为它们不引用同一个对象。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/e807f9f66205baf9e743b7c6d9588865.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wT5Ol_EE8ILh17lG"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@louishansel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Louis Hansel @shotsoflouis</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8897" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="e7e6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">应该使用扩展和取幂运算符，而不是它们的旧版本。</p><p id="32ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不需要在每个语句后都加一行。我们需要在一组要组合在一起的语句后添加一个新的空行。</p><h2 id="6fcc" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">简明英语团队的笔记</strong></h2><p id="358f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae kc" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kf ir">JavaScript in Plain English</strong></a><a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>—谢谢，继续学习！</p><p id="4751" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还推出了一个YouTube，希望你能通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的简明英语频道</strong> </a>来支持我们</p><p id="8b6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往,“简明英语”希望帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>