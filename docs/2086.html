<html>
<head>
<title>3 Ways to Improve Type Safety in Jest Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Jest测试中提高类型安全性的3种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/3-ways-to-improve-type-safety-in-jest-tests-42957a362668?source=collection_archive---------7-----------------------#2020-05-18">https://javascript.plainenglish.io/3-ways-to-improve-type-safety-in-jest-tests-42957a362668?source=collection_archive---------7-----------------------#2020-05-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/4be8e59a3a76e91ef2c4d307e5fcadf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tHO89ZHB_gcb2PA5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@mmayyer?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">marcos mayer</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6ad8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在单元测试中忽略类型安全和使用类型断言或ts-ignore注释通常更容易。随着时间的推移，这可能会导致过时的测试，并降低他们在生产中捕捉bug的能力。下面是一些使用Jest作为测试框架来引入更好的类型安全的方法。</p><h1 id="2b9a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">1.在强制转换之前将对象分配给分部类型</h1><p id="c728" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">假设我们有一个对象类型，它有很多属性，比如复杂的React组件的配置选项或属性。</p><p id="a779" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">忽略这一点的简单方法是将测试值转换为所需的类型。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="125b" class="mn lc iq mj b gy mo mp l mq mr">type Properties = {a: <em class="ms">string</em>, b: <em class="ms">number, //...</em>}</span><span id="a0cb" class="mn lc iq mj b gy mt mp l mq mr">const identity = (properties: Properties) =&gt; properties</span><span id="cba2" class="mn lc iq mj b gy mt mp l mq mr"><em class="ms">// Error: Argument of type '{}' is not assignable to parameter of type 'Properties'.<br/></em>identity({});</span><span id="b2f7" class="mn lc iq mj b gy mt mp l mq mr">// No errors with type assertion<br/>expect(identity({} as Properties)).toEqual({})<br/>expect(identity({a: 123} as Properties).toEqual({a: 123})</span></pre><p id="61cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个更好的方法是将测试对象分配给<code class="fe mu mv mw mj b">Partial</code>版本，这样对于我们选择提供的属性，值仍然被类型检查。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="08ea" class="mn lc iq mj b gy mo mp l mq mr"><em class="ms">// Error: Type 'number' is not assignable to type 'string | undefined'.ts(2322)<br/></em><strong class="mj ir">const testProperties: Partial&lt;Properties&gt; = {a: 123};</strong></span><span id="75e6" class="mn lc iq mj b gy mt mp l mq mr">expect(identity(testProperties as Properties))<br/>  .toEqual(testProperties);</span></pre><h1 id="bfaa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">2.向<strong class="ak"> jest提供一个类型参数。类的模拟泛型</strong></h1><p id="184e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">给定一个接受类型<code class="fe mu mv mw mj b">User</code>并返回用户名的函数，我们可以指定<code class="fe mu mv mw mj b">jest.fn()</code>来替换模拟类。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0e63" class="mn lc iq mj b gy mo mp l mq mr">class User {<br/>   public name: <em class="ms">string</em>;<br/>}</span><span id="99e8" class="mn lc iq mj b gy mt mp l mq mr">const getName = (user: User) =&gt; user.name<br/>const randomObject = {<br/>   name: 12345,<br/>   doesNotExist: ''<br/>}</span><span id="0c35" class="mn lc iq mj b gy mt mp l mq mr">const userMock = jest.fn().mockReturnValue(randomObject)</span><span id="0ae0" class="mn lc iq mj b gy mt mp l mq mr">// No errors despite the wrong types<br/>expect(getName(userMock)).toEqual('kaylie')</span></pre><p id="0b84" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一行似乎会导致类型错误，因为用<code class="fe mu mv mw mj b">randomObject</code>直接调用getName会导致类型错误。这是因为Jest mock类型默认为<em class="ms"> any </em>，不提供相同的类型安全。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="89aa" class="mn lc iq mj b gy mo mp l mq mr">// node_modules/@types/jest/index.d.ts</span><span id="07ca" class="mn lc iq mj b gy mt mp l mq mr">interface Mock&lt;<strong class="mj ir">T = <em class="ms">any</em>, Y extends <em class="ms">any</em>[] = <em class="ms">any</em></strong>&gt; extends Function, MockInstance&lt;T, Y&gt; <br/>{<br/>     new (...args: Y): T;<br/>     (...args: Y): T;<br/>}</span></pre><p id="fb7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是当我们将<code class="fe mu mv mw mj b">User</code>传递给泛型类型参数时，我们通过额外的属性检查获得了更好的类型安全性。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9825" class="mn lc iq mj b gy mo mp l mq mr">const typedUserMock: jest.Mock&lt;User&gt; = jest.fn()</span><span id="3973" class="mn lc iq mj b gy mt mp l mq mr">// Argument of type '{ name: number; doesNotExist: string; }' is not // assignable to parameter of type 'User'. Types of property 'name' // are incompatible.<br/>typedUserMock.mockReturnValue(randomObject)</span><span id="d29f" class="mn lc iq mj b gy mt mp l mq mr"><strong class="mj ir">typedUserMock.mockReturnValue({<br/>   name: 'kaylie'<br/>})</strong></span><span id="b71b" class="mn lc iq mj b gy mt mp l mq mr">// Type safe, and passes!<br/>expect(getName(typedUserMock)).toEqual('kaylie')</span></pre><h1 id="0bf6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">3.将ReturnType与jest结合使用。模拟函数</h1><p id="ab7e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">这里还有一个简单的例子，一个名为<code class="fe mu mv mw mj b">filter</code>的函数将另一个函数作为参数。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c04d" class="mn lc iq mj b gy mo mp l mq mr">type Predicate = () =&gt; <em class="ms">boolean</em></span><span id="c68f" class="mn lc iq mj b gy mt mp l mq mr">const filter = (predicate: Predicate) =&gt; {</span><span id="31eb" class="mn lc iq mj b gy mt mp l mq mr">     predicate()</span><span id="b8d6" class="mn lc iq mj b gy mt mp l mq mr">}</span></pre><p id="9e22" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们想写一个单元测试，当filter被调用时断言谓词被调用。我们希望确保<code class="fe mu mv mw mj b">mockPredicate</code>与原始类型定义具有相同的签名。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="45e4" class="mn lc iq mj b gy mo mp l mq mr">const mockPredicate = jest.fn()</span><span id="09e5" class="mn lc iq mj b gy mt mp l mq mr">// Error: <em class="ms">Type 'number' is not assignable to type 'boolean'.ts(2322)</em><br/>filter(() =&gt; 1)</span><span id="0bb5" class="mn lc iq mj b gy mt mp l mq mr">// No errors<br/>filter(mockPredicate.mockReturnValue(1)<strong class="mj ir">)</strong></span></pre><p id="8847" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与前面的例子类似，我们需要向泛型<code class="fe mu mv mw mj b">jest.Mock</code>参数传递一个参数，但是这次使用正确的返回类型。</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="50d0" class="mn lc iq mj b gy mo mp l mq mr">type Predicate = () =&gt; <em class="ms">boolean</em></span><span id="9dea" class="mn lc iq mj b gy mt mp l mq mr"><strong class="mj ir">const typedMockPredicate: jest.Mock&lt;ReturnType&lt;Predicate&gt;&gt; = <br/>jest.fn();</strong></span><span id="3f8d" class="mn lc iq mj b gy mt mp l mq mr">// Error: Argument of type '1' is not assignable to parameter of type 'boolean'.ts(2345)<br/>filter(typedMockPredicate.mockReturnValue(1))</span><span id="ade0" class="mn lc iq mj b gy mt mp l mq mr">// OK!<br/>filter(typedMockPredicate.mockReturnValue(true))</span><span id="66b6" class="mn lc iq mj b gy mt mp l mq mr">expect(typedMockPredicate).toHaveBeenCalled()</span></pre></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><p id="72d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">尽管示例使用了简单的Jest模拟，但是您也应该能够将它应用于Jest间谍和模块模拟。如果你正在寻找一种功能更全面的方法，请查看<a class="ae kc" href="https://typescript-tdd.github.io/ts-auto-mock/" rel="noopener ugc nofollow" target="_blank"> ts-auto-mock </a>。感谢阅读！</p><h2 id="4f26" class="mn lc iq bd ld ne nf dn lh ng nh dp ll ko ni nj lp ks nk nl lt kw nm nn lx no bi translated"><strong class="ak">简明英语笔记</strong></h2><p id="b978" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们推出了一个YouTube频道吗？我们制作的每个视频都旨在教给你一些新的东西。点击此处 查看我们，并确保订阅该频道😎</p></div></div>    
</body>
</html>