<html>
<head>
<title>Object-Oriented JavaScript — Errors and Iterables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向对象的JavaScript —错误和可重复项</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-oriented-javascript-errors-and-iterables-82b808c231a9?source=collection_archive---------11-----------------------#2020-11-06">https://javascript.plainenglish.io/object-oriented-javascript-errors-and-iterables-82b808c231a9?source=collection_archive---------11-----------------------#2020-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/25cecddc76b046e1ab26f2bf5f5eea62.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Tjf3jQE5xVDS627e"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@maxchen2k?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Max Chen</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a06d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript部分是面向对象的语言。</p><p id="7b04" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要学习JavaScript，我们必须学习JavaScript的面向对象部分。</p><p id="6eb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究error对象和iterables。</p><h1 id="787c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">错误对象</h1><p id="5f59" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">遇到错误时，JavaScript抛出<code class="fe me mf mg mh b">Error</code>对象。</p><p id="7352" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们包括各种构造函数。</p><p id="6371" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们包括<code class="fe me mf mg mh b">EvalError</code>、<code class="fe me mf mg mh b">RangeError</code>、<code class="fe me mf mg mh b">ReferenceError</code>、<code class="fe me mf mg mh b">SyntaxError</code>、<code class="fe me mf mg mh b">TypeError</code>和<code class="fe me mf mg mh b">URIError</code>。</p><p id="312b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有这些构造函数都继承自<code class="fe me mf mg mh b">Error</code>。</p><p id="55e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将可能抛出错误的代码放在<code class="fe me mf mg mh b">try</code>块中。</p><p id="2159" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且我们可以在<code class="fe me mf mg mh b">catch</code>块中捕捉错误。</p><p id="7110" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8d1c" class="mq lc iq mh b gy mr ms l mt mu">try {<br/>  foo();<br/>} catch (e) {<br/>  //...<br/>}</span></pre><p id="0d26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe me mf mg mh b">foo</code>抛出一个错误，那么<code class="fe me mf mg mh b">catch</code>模块将捕获该错误。</p><p id="ecdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">e</code>抛出了错误对象。</p><p id="f221" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">e.name</code>得到名字，用<code class="fe me mf mg mh b">e.message</code>得到消息。</p><p id="301d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以添加一个<code class="fe me mf mg mh b">finally</code>子句来运行代码，而不管是否抛出错误。</p><p id="71b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a619" class="mq lc iq mh b gy mr ms l mt mu">try {<br/>  foo();<br/>} catch (e) {<br/>  //...<br/>} finally {<br/>  console.log('finally');<br/>}</span></pre><h1 id="1710" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">ES6迭代器和生成器</h1><p id="7c4d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">迭代器和生成器是ES6的新构造。</p><p id="1f15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们让我们创建各种类型的可迭代对象并使用它们。</p><h1 id="ee16" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">For…of循环</h1><p id="5337" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">for…of循环让我们可以遍历任何类型的可迭代对象。</p><p id="822e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以用它来循环遍历一个数组:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8245" class="mq lc iq mh b gy mr ms l mt mu">const iter = [1, 2];<br/>for (const i of iter) {<br/>  console.log(i);<br/>}</span></pre><p id="276f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bbb4" class="mq lc iq mh b gy mr ms l mt mu">1<br/>2</span></pre><p id="60ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在循环标题中使用了<code class="fe me mf mg mh b">const</code>，这样我们就不能将循环变量<code class="fe me mf mg mh b">i</code>重新分配给其他变量。</p><p id="21e4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以对字符串等其他可迭代对象做同样的事情:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d03a" class="mq lc iq mh b gy mr ms l mt mu">for (const i of 'foo') {<br/>  console.log(i);<br/>}</span></pre><p id="55ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到单个字符作为<code class="fe me mf mg mh b">i</code>的值。</p><p id="74eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">for…of循环用于迭代。</p><h1 id="5bdf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">迭代器和可迭代对象</h1><p id="3f4c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">迭代器是公开<code class="fe me mf mg mh b">next</code>以获取集合的下一个条目的对象。</p><p id="f7a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用生成器函数创建一个迭代器。</p><p id="ff78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="370c" class="mq lc iq mh b gy mr ms l mt mu">function* genFunc() {<br/>  yield 1;<br/>  yield 2;<br/>  yield 3;<br/>}</span></pre><p id="ca1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">yield</code>通过调用<code class="fe me mf mg mh b">next</code>返回迭代器中我们想要返回的下一项。</p><p id="a7e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们调用了<code class="fe me mf mg mh b">next</code>，那么发电机功能将被暂停。</p><p id="426e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过书写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e80d" class="mq lc iq mh b gy mr ms l mt mu">const gen = genFunc();<br/>console.log(gen.next());<br/>console.log(gen.next());<br/>console.log(gen.next());<br/>console.log(gen.next());</span></pre><p id="448f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e7dd" class="mq lc iq mh b gy mr ms l mt mu">{value: 1, done: false}<br/>{value: 2, done: false}<br/>{value: 3, done: false}<br/>{value: undefined, done: true}</span></pre><p id="7f77" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到每个调用产生的每个项目。</p><p id="bfd6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">value</code>有生成的值，而<code class="fe me mf mg mh b">done</code>告诉我们生成器是否完成了值的生成。</p><p id="e876" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">iterable是定义其迭代行为的对象。</p><p id="4e3a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们可以与for…of循环一起用于迭代。</p><p id="d872" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">内置的可迭代对象包括数组和字符串。</p><p id="ab8c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有iterable对象都有<code class="fe me mf mg mh b">@@itrerator</code>方法，该方法有以<code class="fe me mf mg mh b">Symbol.iterator</code>为键的属性。</p><p id="5197" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它必须用<code class="fe me mf mg mh b">next</code>方法返回一个迭代器。</p><p id="17af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以最简单的方法是使用生成器，这样我们就可以调用<code class="fe me mf mg mh b">next</code>并返回值。</p><p id="318d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下代码来创建一个iterable:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a537" class="mq lc iq mh b gy mr ms l mt mu">const obj = {<br/>  *[Symbol.iterator]() {<br/>    yield 1;<br/>    yield 2;<br/>    yield 3;<br/>  }<br/>}</span></pre><p id="e342" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过编写以下代码来使用for…of循环:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5fc5" class="mq lc iq mh b gy mr ms l mt mu">for (const i of obj) {<br/>  console.log(i);<br/>}</span></pre><p id="492e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="586e" class="mq lc iq mh b gy mr ms l mt mu">1<br/>2<br/>3</span></pre><p id="9919" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">记录在案。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/d6c057f05b3a0c1f3e1fc0421d229276.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q2hH0Mtj00uSOEH5"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@henmankk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Keagan Henman</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="840d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="952f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">ES6可迭代对象，如数组和字符串，使用迭代器返回它所拥有的值。</p><p id="946d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也可以用for…of循环迭代它们。</p><p id="a3f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何代码都可能抛出错误对象，我们可以用try-catch-finally捕获它们。</p><p id="abf2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>