<html>
<head>
<title>Implement middleware pattern in Azure Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Azure函数中实现中间件模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implement-middleware-pattern-in-azure-functions-d8e9f94626a5?source=collection_archive---------6-----------------------#2019-01-04">https://javascript.plainenglish.io/implement-middleware-pattern-in-azure-functions-d8e9f94626a5?source=collection_archive---------6-----------------------#2019-01-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="dd51" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何在Azure函数中实现中间件模式来保持我们的函数整洁</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/8cf58b9b91de9b53a623751b19941a58.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bsubw8LlLNr-8VpbEotOjw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Movement — Ph: <a class="ae ks" href="https://www.pexels.com/@weekendplayer" rel="noopener ugc nofollow" target="_blank">Burak K</a></figcaption></figure><p id="bcc3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><em class="lp">也可用</em> <a class="ae ks" href="https://medium.com/@emanuelcasco/implementando-middlewares-enazure-functions-f3b1d13881ac" rel="noopener"> <em class="lp">西班牙语</em> </a> <em class="lp">。</em></p><h1 id="d838" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">介绍</h1><p id="e1eb" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">我写这篇文章来分享我在<a class="ae ks" href="https://azure.microsoft.com/en-us/services/functions/" rel="noopener ugc nofollow" target="_blank"> Azure Functions </a>中实现中间件模式的经验。</p><p id="7c29" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Azure Functions是一种无服务器的计算服务，使您能够按需运行代码<em class="lp">而无需显式管理基础架构。</em></p><p id="c4f0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">无服务器计算的最大优势是您可以<strong class="kv io">专注于构建应用</strong> <strong class="kv io">而不必担心服务器的供应或维护</strong>。您可以只为对您的业务真正重要的事情编写代码。</p><p id="7306" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是在现实世界的应用程序中，您必须处理业务逻辑之外的一些常见技术问题，比如输入解析和验证、输出序列化、错误处理等等。</p><p id="f9a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">通常，所有这些必要的代码最终会污染您的功能中的纯业务逻辑代码，<strong class="kv io">使得代码更难阅读和维护</strong>。</p><p id="fc1b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">像<a class="ae ks" href="http://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>、<a class="ae ks" href="http://fastify.io/" rel="noopener ugc nofollow" target="_blank"> Fastify </a>或者<a class="ae ks" href="https://hapijs.com/" rel="noopener ugc nofollow" target="_blank">哈比神</a>这样的Web框架，已经利用<a class="ae ks" href="https://en.wikipedia.org/wiki/Middleware" rel="noopener ugc nofollow" target="_blank">中间件模式</a>解决了这个问题。这种模式允许开发人员将这些常见的技术问题隔离成<em class="lp"/><em class="lp">修饰</em>主要业务逻辑代码的<em class="lp"/>。</p><h1 id="7d39" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">履行</h1><p id="0ee1" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">在决定在我的项目中实现这个模式之后，我做了一个小的搜索来检查是否有人已经实现了类似的解决方案。</p><p id="6285" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">可惜我找到的几个解决方案都不符合我的需求，所以我决定自己实现。</p><p id="9edd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Azure中间件就是这样诞生的。</p><div class="mn mo gp gr mp mq"><a href="https://www.npmjs.com/package/azure-middleware" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">azure中间件</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">Azure函数的Node.js中间件引擎</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">www.npmjs.com</p></div></div><div class="mz l"><div class="na l nb nc nd mz ne km mq"/></div></div></a></div><h1 id="f3d7" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">它是如何工作的</h1><h2 id="e39e" class="nf lr in bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">确认</h2><p id="ff05" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">在无服务器架构中，<strong class="kv io">必须能够将每个功能的正确行为确定为单独的代码段</strong>。因此，为了避免意外行为，重要的是确保函数输入属于它的域。</p><p id="e9dc" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了完成这个任务<a class="ae ks" href="https://www.npmjs.com/package/azure-middleware" rel="noopener ugc nofollow" target="_blank">，Azure中间件</a>使用了<a class="ae ks" href="https://github.com/hapijs/joi" rel="noopener ugc nofollow" target="_blank"> Joi </a>。它允许我们定义一个模式并检查输入消息是否有效。</p><p id="a5e2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">使用<code class="fe nr ns nt nu b">validate</code>方法，您可以定义用于验证消息的方案。如果你的函数被无效消息调用，那么会抛出一个异常，你的函数不会被执行。</p><pre class="kd ke kf kg gt nv nu nw nx aw ny bi"><span id="98b9" class="nf lr in nu b gy nz oa l ob oc">module.exports = new MiddlewareHandler()<br/>   .validate(invalidJoiSchema)<br/>   .use(functionHandler)<br/>   .catch(errorHandler)<br/>   .listen();</span></pre><h2 id="f883" class="nf lr in bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">函数链接</h2><p id="6dcc" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated"><code class="fe nr ns nt nu b">use</code>方法用于链接不同的函数处理程序或中间件，如<em class="lp">“步骤”</em>。它需要一个函数处理程序作为参数。</p><p id="d284" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">每个中间件按照定义功能的顺序依次执行。当调用<code class="fe nr ns nt nu b">context.next</code>时，信息流传递到链的下一个元素。</p><pre class="kd ke kf kg gt nv nu nw nx aw ny bi"><span id="bc6e" class="nf lr in nu b gy nz oa l ob oc">module.exports = new MiddlewareHandler()<br/>   .validate(schema)<br/>   .use((ctx, msg) =&gt; {<br/>      ctx.log.info('Print first');<br/>      ctx.next();<br/>   })<br/>   .use((ctx, msg) =&gt; {<br/>      ctx.log.info('Print second');<br/>      ctx.done();<br/>   })<br/>   .catch(errorHandler)<br/>   .listen();</span></pre><blockquote class="od oe of"><p id="d547" class="kt ku lp kv b kw kx jo ky kz la jr lb og ld le lf oh lh li lj oi ll lm ln lo ig bi translated"><code class="fe nr ns nt nu b">next</code>是注入<code class="fe nr ns nt nu b">context</code>的方法。它用于迭代中间件链。</p></blockquote><h2 id="f542" class="nf lr in bd ls ng nh dn lw ni nj dp ma lc nk nl mc lg nm nn me lk no np mg nq bi translated">错误处理</h2><p id="4a5f" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">错误处理是非常相似的，因为它在像<a class="ae ks" href="http://expressjs.com/" rel="noopener ugc nofollow" target="_blank"> Express </a>这样的web框架中工作。当抛出异常时，将执行中间件链中的第一个错误处理程序。而之前的所有函数处理程序都将被忽略。</p><p id="8844" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，您可以使用<code class="fe nr ns nt nu b">next</code>跳转到下一个错误处理程序。如果这个方法接收一个参数作为第一个参数，那么它将被作为一个错误处理。</p><p id="abf0" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，您可以使用<code class="fe nr ns nt nu b">context.next</code>跳转到下一个错误处理程序。如果此方法接收一个非零值作为第一个参数，它将被作为错误处理。</p><p id="ab7c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">与函数处理程序不同，错误处理程序接收错误作为第一个参数。</p><pre class="kd ke kf kg gt nv nu nw nx aw ny bi"><span id="c313" class="nf lr in nu b gy nz oa l ob oc">module.exports = new MiddlewareHandler()<br/>   .use((ctx, msg) =&gt; {<br/>      ctx.log.info('Hello world');<br/>      ctx.next('ERROR!');<br/>   })<br/>   .use((ctx, msg) =&gt; {<br/>      ctx.log.info('Not executed :(');<br/>      ctx.next();<br/>   })<br/>   .catch((error, ctx, msg) =&gt; {<br/>      ctx.log.info(errors); // ERROR!<br/>      ctx.next();<br/>   })<br/>   .listen();</span></pre><h1 id="40d9" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">包裹</h1><p id="9e2c" class="pw-post-body-paragraph kt ku in kv b kw mi jo ky kz mj jr lb lc mk le lf lg ml li lj lk mm lm ln lo ig bi translated">这个包还在开发中，我有一些改进它的想法。但是，如果你有任何建议，请不要怀疑，联系我，让我知道它！</p><div class="mn mo gp gr mp mq"><a href="https://www.npmjs.com/package/azure-middleware" rel="noopener  ugc nofollow" target="_blank"><div class="mr ab fo"><div class="ms ab mt cl cj mu"><h2 class="bd io gy z fp mv fr fs mw fu fw im bi translated">azure中间件</h2><div class="mx l"><h3 class="bd b gy z fp mv fr fs mw fu fw dk translated">Azure函数的Node.js中间件引擎</h3></div><div class="my l"><p class="bd b dl z fp mv fr fs mw fu fw dk translated">www.npmjs.com</p></div></div><div class="mz l"><div class="oj l nb nc nd mz ne km mq"/></div></div></a></div><p id="649e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">感谢阅读。如果你对此有想法，一定要留下评论。</p><p id="9782" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">你可以在<a class="ae ks" href="https://www.linkedin.com/in/emanuelcasco/" rel="noopener ugc nofollow" target="_blank"> Twitter </a>、<a class="ae ks" href="https://github.com/emanuelcasco" rel="noopener ugc nofollow" target="_blank"> Github </a>或者<a class="ae ks" href="https://www.linkedin.com/in/emanuelcasco/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我。</p></div></div>    
</body>
</html>