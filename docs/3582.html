<html>
<head>
<title>Removing Duplicate Objects in a JavaScript Array</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">删除JavaScript数组中的重复对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/removing-duplicate-objects-in-a-javascript-array-b05258bcded?source=collection_archive---------10-----------------------#2020-10-10">https://javascript.plainenglish.io/removing-duplicate-objects-in-a-javascript-array-b05258bcded?source=collection_archive---------10-----------------------#2020-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c2ed61ced0f7816cc4433769a0fd7029.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CWWsGrCu_TsKmIkx"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jentheodore?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jen Theodore</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="414a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">删除数组中的重复对象可能需要一些努力。</p><p id="1d86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不像从数组中删除重复的原始值那么简单。</p><p id="fedf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何从数组中移除重复的对象。</p><h1 id="9d3f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">消除数组中的重复值</h1><p id="03c0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">删除重复值很简单。</p><p id="8557" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是把它转换成一个集合，然后把它传播回一个数组。</p><p id="b931" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2151" class="mn lc iq mj b gy mo mp l mq mr">const arr = ['foo', 'bar', 'foo'];<br/>const uniqueArr = [...new Set(arr)];</span></pre><p id="1e79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe ms mt mu mj b">[“foo”, “bar”]</code>作为<code class="fe ms mt mu mj b">uniqueArr</code>的值。</p><p id="e6ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不适用于对象，因为只有引用相同的对象才被认为是相同的。</p><h1 id="ae5d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建没有重复的新数组</h1><p id="8ad4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">删除重复条目的一种方法是创建一个没有重复条目的新数组。</p><p id="462c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有以下数组:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f8d5" class="mn lc iq mj b gy mo mp l mq mr">const persons = [{<br/>    firstName: 'jane',<br/>    lastName: 'snith',<br/>    age: 20<br/>  },<br/>  {<br/>    firstName: 'bob',<br/>    lastName: 'jones',<br/>    age: 33,<br/>  },<br/>  {<br/>    firstName: 'jane',<br/>    lastName: 'snith',<br/>    age: 20<br/>  },<br/>];</span></pre><p id="70af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以用唯一的条目检查数组中每个对象的存在。</p><p id="baeb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它不存在，我们把它放入数组中，并赋予唯一的值。</p><p id="1f3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以编写以下代码:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2457" class="mn lc iq mj b gy mo mp l mq mr">const uniquePersons = [];</span><span id="26cd" class="mn lc iq mj b gy mv mp l mq mr">for (const p of persons) {<br/>  if (!contains(uniquePersons, p)) {<br/>    uniquePersons.push(p);<br/>  }<br/>}</span><span id="06c5" class="mn lc iq mj b gy mv mp l mq mr">function contains(arr, person) {<br/>  return arr.find(<br/>    (a) =&gt; a.firstName === person.firstName &amp;&amp; a.lastName === person.lastName &amp;&amp; a.age === person.age);<br/>}</span></pre><p id="c037" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe ms mt mu mj b">uniquePersons</code>数组来保存数组条目和来自<code class="fe ms mt mu mj b">persons</code>数组的唯一条目。</p><p id="b7e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果该项目存在于<code class="fe ms mt mu mj b">arr</code>数组中，则<code class="fe ms mt mu mj b">contains</code>函数返回。</p><p id="7472" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">person</code>是我们想要检查的来自<code class="fe ms mt mu mj b">persons</code>的对象。</p><p id="a65a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe ms mt mu mj b">arr.find</code>，条件是我们要返回来检查<code class="fe ms mt mu mj b">person</code>的属性以确定存在。</p><p id="ee0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在for-of循环中，我们只调用<code class="fe ms mt mu mj b">uniquePersons</code>上的<code class="fe ms mt mu mj b">push</code>来添加<code class="fe ms mt mu mj b">persons</code>中不存在的项目。</p><p id="ce2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，<code class="fe ms mt mu mj b">uniquePersons</code>是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6a56" class="mn lc iq mj b gy mo mp l mq mr">[<br/>  {<br/>    "firstName": "jane",<br/>    "lastName": "snith",<br/>    "age": 20<br/>  },<br/>  {<br/>    "firstName": "bob",<br/>    "lastName": "jones",<br/>    "age": 33<br/>  }<br/>]</span></pre><h1 id="7ba5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe ms mt mu mj b">Using filter()</code></h1><p id="2c2e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">从数组中删除重复对象的另一种方法是使用<code class="fe ms mt mu mj b">filter</code>方法来检查该对象是否是该对象的第一个实例。</p><p id="6b26" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6f19" class="mn lc iq mj b gy mo mp l mq mr">const uniquePersons = persons.filter(<br/>  (m, index, ms) =&gt; getFirstIndex(ms, m) === index);</span><span id="f548" class="mn lc iq mj b gy mv mp l mq mr">function getFirstIndex(arr, person) {<br/>  return arr.findIndex(<br/>    (a) =&gt; a.firstName === person.firstName &amp;&amp; a.lastName === person.lastName &amp;&amp; a.age === person.age);<br/>}</span></pre><p id="6645" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">鉴于我们有</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="25d1" class="mn lc iq mj b gy mo mp l mq mr">const persons = [{<br/>    firstName: 'jane',<br/>    lastName: 'snith',<br/>    age: 20<br/>  },<br/>  {<br/>    firstName: 'bob',<br/>    lastName: 'jones',<br/>    age: 33,<br/>  },<br/>  {<br/>    firstName: 'jane',<br/>    lastName: 'snith',<br/>    age: 20<br/>  },<br/>];</span></pre><p id="376e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为<code class="fe ms mt mu mj b">persons</code>的值。</p><p id="b563" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们创建了接受一个<code class="fe ms mt mu mj b">arr</code>数组和<code class="fe ms mt mu mj b">person</code>对象的<code class="fe ms mt mu mj b">getFirstIndex</code>方法。</p><p id="0ca1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在函数内部，我们调用<code class="fe ms mt mu mj b">findIndex</code>来返回数组条目的第一个索引，给定值为<code class="fe ms mt mu mj b">person.firstName</code>、<code class="fe ms mt mu mj b">person.lastName</code>和<code class="fe ms mt mu mj b">person.age</code>。</p><p id="bf27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe ms mt mu mj b">filter</code>回调中，我们可以调用<code class="fe ms mt mu mj b">getFirstIndex</code>来比较<code class="fe ms mt mu mj b">index</code>和返回的索引。</p><p id="09bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它们不同，那么我们知道这个对象是重复的，所以它将被丢弃。</p><p id="eeb7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们得到同样的结果。</p><h1 id="1079" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">创建一个地图并将其转换回数组</h1><p id="f0a9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">另一种删除条目的方法是从数组创建一个映射，然后将其转换回数组。</p><p id="c44c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="46ae" class="mn lc iq mj b gy mo mp l mq mr">const map = new Map();</span><span id="c75c" class="mn lc iq mj b gy mv mp l mq mr">for (const p of persons) {<br/>  map.set(JSON.stringify(p), p);<br/>}</span><span id="f1f0" class="mn lc iq mj b gy mv mp l mq mr">const uniquePersons = [...map.values()]</span></pre><p id="e6cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设<code class="fe ms mt mu mj b">person</code>与其他例子相同。</p><p id="26ee" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是用<code class="fe ms mt mu mj b">set</code>方法将物品添加到地图中。如果键为值，则为对象的字符串版本，非字符串版本为值。</p><p id="4541" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于字符串可以和<code class="fe ms mt mu mj b">===</code>进行比较，所以重复的会被覆盖。</p><p id="3689" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过使用<code class="fe ms mt mu mj b">map.values()</code>并使用spread操作符来将这些项扩展回数组。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/0f64cab6a759bca7837c585f19c2ee1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*X0wOHdFjsWNddQ5T"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@alschim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alexander Schimmeck</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="dfa1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="a604" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">删除重复的对象比删除重复的原始值需要更多的工作。</p><p id="3345" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">数组方法和映射使这变得更容易。</p><p id="7dfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>