<html>
<head>
<title>Securing React Native with OAuth</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用OAuth保护React Native</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/securing-react-native-with-oauth-75fceaa5f3c8?source=collection_archive---------6-----------------------#2020-09-03">https://javascript.plainenglish.io/securing-react-native-with-oauth-75fceaa5f3c8?source=collection_archive---------6-----------------------#2020-09-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="40eb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何设置React本机应用程序来使用OAuth</h2></div><p id="be0d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本教程中，我们将设置一个React本机应用程序来使用OAuth。我们将使用FusionAuth进行Auth，但是React本机代码应该可以与任何OAuth兼容的服务器一起工作。</p><p id="e7a4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们将安装和配置FusionAuth。然后我们将建立一个React本地项目。然后，我们将从React本机应用程序中执行授权代码授权。最后，我们将从OIDC端点请求信息。有了这些数据，我们将在React本地应用程序中显示用户的电子邮件。</p><p id="13fa" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是很多，但乘坐会很有趣。准备好出发了吗？</p><h1 id="a2b9" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">要求</h1><p id="fdbf" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">以下是您需要开始的内容:</p><ul class=""><li id="69e9" class="ly lz iq kh b ki kj kl km ko ma ks mb kw mc la md me mf mg bi translated">节点版本&gt; = 8.0</li><li id="5e67" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">VScode或任何其他文本编辑器</li><li id="c125" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated"><code class="fe mm mn mo mp b">git</code></li><li id="fd4e" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated"><code class="fe mm mn mo mp b">npx</code></li><li id="9f3d" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">Xcode，如果为iOS构建</li><li id="f61e" class="ly lz iq kh b ki mh kl mi ko mj ks mk kw ml la md me mf mg bi translated">自制(可选)</li></ul><h1 id="91ab" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">你需要知道的关于OAuth的事情</h1><p id="a572" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">如果您是web开发人员，您可能对OAuth很熟悉。在网络开发方面，我们有三个参与者:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="1915" class="my lc iq mp b gy mz na l nb nc">The browser -&gt; The server -&gt; The OAuth server</span></pre><p id="b6f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">浏览器与服务器对话，服务器与OAuth服务器对话。OAuth服务器生成提供给服务器的访问令牌。服务器将它们安全地存储在会话中，并在需要时将它们传递给其他API进行授权。这是我们在用OAuth 保护React应用程序时使用的架构。</p><p id="2ff8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，随着移动设备的出现，事情发生了一些变化。相应的场景可能是这样的:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="c3b1" class="my lc iq mp b gy mz na l nb nc">The mobile device -&gt; The server -&gt; The OAuth server</span></pre><p id="b427" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，这种架构可以简化。可以删除服务器；移动设备可以直接从OAuth服务器处理回调。在本教程中，我们将使用授权码授予PKCE扩展。下面是来自RFC 8252 的建议<a class="ae nd" href="https://tools.ietf.org/html/rfc8252#page-5" rel="noopener ugc nofollow" target="_blank">流程，这是我们将要实现的。</a></p><figure class="mq mr ms mt gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ne"><img src="../Images/fc976325731f07ae4359267158989051.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7GhKnGAajNfBnUro.png"/></div></div></figure><p id="9f98" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，让我们配置OAuth服务器并设置我们的编码环境。</p><h1 id="bfa0" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">将FusionAuth设置为您的身份验证提供者</h1><p id="cf45" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">为了设置FusionAuth，请遵循<a class="ae nd" href="https://fusionauth.io/docs/v1/tech/5-minute-setup-guide" rel="noopener ugc nofollow" target="_blank"> 5分钟设置指南</a>。它既简单又快捷。默认情况下，OAuth服务器将运行在地址<code class="fe mm mn mo mp b"><a class="ae nd" href="http://localhost:9011." rel="noopener ugc nofollow" target="_blank">http://localhost:9011</a></code> <a class="ae nd" href="http://localhost:9011." rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="f1e0" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">配置FusionAuth应用程序</h1><p id="3f61" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">在这一步，我们将配置一个FusionAuth应用程序。这不同于FusionAuth服务器实例或React本机应用程序。在FusionAuth中，应用程序是用户可以登录的任何东西。要对此进行配置，请登录到FusionAuth管理界面并导航到“应用程序”。从那里，创建一个新的应用程序。</p><p id="e8fd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，导航到“OAuth”选项卡，添加一个重定向URI<code class="fe mm mn mo mp b">fusionauth-demo:/oauthredirect</code>。稍后，我们将在React本机应用程序中使用这个重定向URL。</p><p id="b075" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，请注意“客户端Id”的值；我们以后也需要它。点击<em class="nm">保存</em>。正确配置后，应用程序详细信息屏幕应如下所示:</p><figure class="mq mr ms mt gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ne"><img src="../Images/907ed0ee8927ef859bc4b9c92400567a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sdPGTubgy-O5oyp6.png"/></div></div></figure><p id="ef3d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">确保将您的用户注册到新的应用程序中。这样做会在用户和新创建的应用程序之间创建一个关系。</p><figure class="mq mr ms mt gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ne"><img src="../Images/7b1b3b8108780551a986352726af0570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DDCeaguRMn-iGyPe.png"/></div></div></figure><p id="7a59" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您愿意，您可以在“用户”选项卡中添加更多用户，但请确保将他们注册到您的新应用程序中。现在，我们继续设置React本地项目。</p><h1 id="a5dc" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">设置React本机开发环境</h1><p id="2e44" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">由于我们将使用React本机命令行界面(CLI)进行开发，因此我们必须安装React本机开发环境。有关安装说明，请遵循<a class="ae nd" href="https://reactnative.dev/docs/environment-setup" rel="noopener ugc nofollow" target="_blank">官方文档</a>。你也要确保你选择了<code class="fe mm mn mo mp b">react-native-cli</code>而不是<code class="fe mm mn mo mp b">expo</code>。这些说明还会引导您启动应用程序，所以如果您是React Native的新手，请务必阅读它们。</p><p id="4d34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还需要为iOS、Android或两者安装开发环境。我们还将使用<a class="ae nd" href="https://brew.sh/" rel="noopener ugc nofollow" target="_blank"> brew </a>来安装所需的软件包。如果您正在跟进，请确保安装了<code class="fe mm mn mo mp b">brew</code>，或者以不同的方式安装软件包。</p><h1 id="0639" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">iOS环境</h1><p id="e4fd" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">首先，我们将安装watchman，它用于在文件发生变化时自动重建文件:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="7b8d" class="my lc iq mp b gy mz na l nb nc">brew install watchman</span></pre><p id="4fbf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们需要安装Xcode CLI工具，这些工具通常是不存在的，并且不能用<code class="fe mm mn mo mp b">brew</code>来完成。若要安装，请打开Xcode并导航到“偏好设置”，然后导航到“位置”。选择命令行工具的Xcode版本，如下图所示:</p><figure class="mq mr ms mt gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ne"><img src="../Images/385e9d9ed049eac2965aa2ee91483a57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Qk1GZqXCns6zFJr_.png"/></div></div></figure><p id="563d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">iOS蓄势待发。</p><h1 id="9768" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">Android环境</h1><p id="fc21" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">对于Android，需要JDK 8，因为其他版本可能会导致错误。我们可以从Oracle网站或使用<code class="fe mm mn mo mp b">brew</code>下载该版本，如下面的代码片段所示:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="53ae" class="my lc iq mp b gy mz na l nb nc">brew cask install adoptopenjdk/openjdk/adoptopenjdk8</span></pre><p id="f125" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要下载并安装<a class="ae nd" href="https://developer.android.com/studio/install" rel="noopener ugc nofollow" target="_blank"> Android studio </a>。</p><p id="9c7d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们需要在系统路径中配置<code class="fe mm mn mo mp b">ANDROID_HOME</code>环境变量。我们可以在我们的<code class="fe mm mn mo mp b">$HOME/.bash_profile</code>或<code class="fe mm mn mo mp b">$HOME/.bashrc</code>中添加以下几行。如果你用的是zsh，文件是<code class="fe mm mn mo mp b">~/.zprofile</code>或者<code class="fe mm mn mo mp b">~/.zshrc</code>。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="6635" class="my lc iq mp b gy mz na l nb nc">export ANDROID_HOME=$HOME/Library/Android/sdk<br/>export PATH=$PATH:$ANDROID_HOME/emulator<br/>export PATH=$PATH:$ANDROID_HOME/tools<br/>export PATH=$PATH:$ANDROID_HOME/tools/bin<br/>export PATH=$PATH:$ANDROID_HOME/platform-tools</span></pre><p id="fc66" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，Android平台的设置已经完成。</p><h1 id="387c" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">反应本地项目设置</h1><p id="6904" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">我们现在将创建一个新的React本地项目。首先，创建一个目录来包含我们所有的代码，然后<code class="fe mm mn mo mp b">cd</code>到那个目录。选择应用程序名称；我们选择了<code class="fe mm mn mo mp b">RNfusionauth</code>，并将在整个教程中使用这个名字。</p><p id="4237" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行此命令创建基本项目文件和配置:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="16d5" class="my lc iq mp b gy mz na l nb nc">react-native init RNfusionauth</span></pre><p id="5901" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在构建应用程序时，我们将对这些文件进行额外的修改。</p><h1 id="7674" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">安装<code class="fe mm mn mo mp b">react-native-app-auth</code>以与OAuth 2.0和OpenId连接服务器通信</h1><p id="cfc1" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">我们的应用程序的一个关键依赖项是<code class="fe mm mn mo mp b"><a class="ae nd" href="https://github.com/FormidableLabs/react-native-app-auth" rel="noopener ugc nofollow" target="_blank">react-native-app-auth</a></code>包。这在<a class="ae nd" href="https://github.com/openid/AppAuth-iOS" rel="noopener ugc nofollow" target="_blank"> AppAuth-iOS </a>和<a class="ae nd" href="https://github.com/openid/AppAuth-Android" rel="noopener ugc nofollow" target="_blank">app auth-Android</a>SDK之间建立了一座桥梁，用于与<a class="ae nd" href="https://tools.ietf.org/html/rfc6749" rel="noopener ugc nofollow" target="_blank"> OAuth 2.0 </a>和<a class="ae nd" href="http://openid.net/specs/openid-connect-core-1_0.html" rel="noopener ugc nofollow" target="_blank"> OpenID Connect </a>提供者进行通信。</p><p id="6054" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个库应该支持任何实现了<a class="ae nd" href="https://tools.ietf.org/html/rfc6749#section-2.2" rel="noopener ugc nofollow" target="_blank"> OAuth2规范</a>的服务器，就像FusionAuth一样。</p><p id="a6c3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个包支持授权码授权，并默认启用PKCE扩展。这很重要，因为移动设备不是<a class="ae nd" href="https://tools.ietf.org/html/rfc6749#section-2.1" rel="noopener ugc nofollow" target="_blank">【机密客户端】</a>，我们希望确保恶意行为者无法拦截我们的授权代码。</p><p id="7648" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要安装<code class="fe mm mn mo mp b">react-native-app-auth</code>，请在项目目录中运行以下命令:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="69c4" class="my lc iq mp b gy mz na l nb nc">yarn add react-native-app-auth</span></pre><p id="97a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用这个库将帮助我们快速安全地构建OAuth集成。它负责RFC 8252规定的许多步骤；我们只需确保启动该流程(步骤1)并接收和存储访问令牌(步骤6)。提醒一下，这是来自RFC的图表:</p><figure class="mq mr ms mt gt nf gh gi paragraph-image"><div role="button" tabindex="0" class="ng nh di ni bf nj"><div class="gh gi ne"><img src="../Images/ad65270ce47809214e55cc298987dafa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*dG0Dkgk3DB0wrNY_.png"/></div></div></figure><h1 id="68bf" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">设置iOS授权</h1><p id="47fb" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">现在，我们将为React本机应用程序的iOS版本配置auth。基本内容将在下面介绍，但是如果你想了解更多关于其他选项的信息，请查看<a class="ae nd" href="https://github.com/FormidableLabs/react-native-app-auth#setup" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="71c0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要通过运行如下所示的命令来安装cacao pod:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="c096" class="my lc iq mp b gy mz na l nb nc">cd ios ; pod install</span></pre><p id="7f57" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们需要用Xcode打开React原生项目。编辑<code class="fe mm mn mo mp b">info.plist</code>文件并注册重定向URL方案，如下面的代码片段所示:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="c0f6" class="my lc iq mp b gy mz na l nb nc">&lt;key&gt;CFBundleURLTypes&lt;/key&gt;<br/> &lt;array&gt;<br/>   &lt;dict&gt;<br/>     &lt;key&gt;CFBundleURLName&lt;/key&gt;<br/>     &lt;string&gt;com.your.app.identifier&lt;/string&gt;<br/>     &lt;key&gt;CFBundleURLSchemes&lt;/key&gt;<br/>     &lt;array&gt;<br/>       &lt;string&gt;fusionauth.demo&lt;/string&gt;<br/>     &lt;/array&gt;<br/>   &lt;/dict&gt;<br/> &lt;/array&gt;</span></pre><p id="d586" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里，<code class="fe mm mn mo mp b">CFBundleURLSchemes</code>定义了这个应用程序处理的URL方案。我们正在注册的方案<code class="fe mm mn mo mp b">fusionauth.demo</code>应该看起来很熟悉，因为我们配置了FusionAuth来重定向到一个包含该方案的URL。如果你在这里修改它，你也应该在那里修改它。</p><p id="e4b0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一步是更改<code class="fe mm mn mo mp b">AppDelegate.h</code>文件，以包含所需的导入和属性:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="f175" class="my lc iq mp b gy mz na l nb nc">#import &lt;React/RCTBridgeDelegate.h&gt;<br/>#import &lt;UIKit/UIKit.h&gt;<br/>#import "RNAppAuthAuthorizationFlowManager.h"<br/>@interface AppDelegate : UIResponder &lt;UIApplicationDelegate, RCTBridgeDelegate, RNAppAuthAuthorizationFlowManager&gt;</span><span id="0f8b" class="my lc iq mp b gy nn na l nb nc">@property (nonatomic, strong) UIWindow *window;<br/>@property(nonatomic, weak)id&lt;RNAppAuthAuthorizationFlowManagerDelegate&gt;authorizationFlowManagerDelegate;<br/>@end</span></pre><h1 id="3bf2" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">为Android设置身份验证</h1><p id="b340" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">对于Android，我们需要额外的配置来捕获<a class="ae nd" href="https://github.com/openid/AppAuth-android#capturing-the-authorization-redirect" rel="noopener ugc nofollow" target="_blank">授权重定向</a>。向<code class="fe mm mn mo mp b">android/app/build.gradle</code>文件中的<code class="fe mm mn mo mp b">defaultConfig</code>对象添加以下属性:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="61d8" class="my lc iq mp b gy mz na l nb nc">android {<br/> defaultConfig {<br/>   manifestPlaceholders = [<br/>     appAuthRedirectScheme: 'fusionauth.demo'<br/>   ]<br/> }<br/>}</span></pre><p id="9309" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的<code class="fe mm mn mo mp b">appAuthRedirectScheme</code>、<code class="fe mm mn mo mp b">fusionauth.demo</code>是另一个方案定义，和iOS一样。如果您在这里修改它，您应该在FusionAuth管理界面和iOS配置中修改它。</p><p id="a0af" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，当我们开始开发Android应用程序时，一个新的问题出现了。在Mac上开发和调试Android应用很困难，因为模拟器并不完全受支持。在其他问题中，与iOS模拟器相比，模拟器速度较慢。</p><p id="5765" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更好的解决方案是使用实际的Android移动设备。当您这样做时，如何将运行在本地主机上的FusionAuth服务器连接到wifi或蜂窝网络上的设备？解决方案是使用ngrok之类的本地隧道服务。</p><h2 id="83e9" class="my lc iq bd ld no np dn lh nq nr dp ll ko ns nt ln ks nu nv lp kw nw nx lr ny bi translated">设置ngrok</h2><p id="5db0" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">ngrok使我们能够在本地服务和互联网之间进行代理。你需要<a class="ae nd" href="https://ngrok.com/download" rel="noopener ugc nofollow" target="_blank">下载</a>它，然后安装它。通过运行以下命令连接您的帐户。它会将我们的auth token添加到默认的<code class="fe mm mn mo mp b">ngrok.yml</code>文件中，这将允许我们访问更多的特性和更长的会话时间。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="e540" class="my lc iq mp b gy mz na l nb nc">./ngrok authtoken Your key</span></pre><p id="3dbf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">运行隧道将在ngrok仪表板的<a class="ae nd" href="https://dashboard.ngrok.com/status/tunnels" rel="noopener ugc nofollow" target="_blank">状态页面</a>中列出。</p><p id="cd53" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们要开始HTTP隧道转发到<code class="fe mm mn mo mp b">localhost</code>和端口<code class="fe mm mn mo mp b">9011</code>，FusionAuth在那里监听。运行以下命令启动ngrok代理:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="43e9" class="my lc iq mp b gy mz na l nb nc">./ngrok http 9011</span></pre><p id="bc36" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将获得一个随机的URL，它将流量转发到我们的FusionAuth实例。它会有点像<code class="fe mm mn mo mp b">https://ce2f267ff5a5.ngrok.io</code>。使用这个，我们可以配置我们的Android设备与FusionAuth的本地实例进行通信。出于一致性的考虑，我们也将为我们的iOS应用程序使用这个URL，即使iOS模拟器可以不通过隧道连接到本地主机。</p><p id="3c70" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以继续编码了。</p><h1 id="267c" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">编写React本机应用程序以使用OAuth和FusionAuth</h1><p id="a149" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">最后是代码！如果您想跳过这一步，请从<a class="ae nd" href="https://github.com/fusionauth/fusionauth-example-react-native" rel="noopener ugc nofollow" target="_blank"> GitHub库</a>获取Apache2许可代码。</p><p id="7631" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总的来说，我们将在<code class="fe mm mn mo mp b">App.js</code>文件中构建我们的逻辑和视图。对于一个更大的项目，您可以将这些代码拆分成组件，但是对于我们的教程，拥有一个文件会使事情变得更简单。然而，我们将使用库来管理授权和数据的安全存储。</p><p id="5d07" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面是我们完成后<code class="fe mm mn mo mp b">App.js</code>的样子(别担心，看起来很多，但我们会解释大部分):</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="b242" class="my lc iq mp b gy mz na l nb nc">import React, { useState, useCallback, useMemo } from 'react';<br/>import { Alert, StyleSheet, View, Image, Text, TouchableOpacity } from 'react-native';<br/>import { authorize, prefetchConfiguration } from 'react-native-app-auth';<br/>import * as Keychain from 'react-native-keychain';<br/>const defaultAuthState = {<br/>  hasLoggedInOnce: false,<br/>  provider: '',<br/>  accessToken: '',<br/>  accessTokenExpirationDate: '',<br/>  refreshToken: ''<br/>};<br/>export default () =&gt; {<br/>  const [authState, setAuthState] = useState(defaultAuthState);<br/>  const [userinfo, setuserinfo] = useState(null)<br/>  React.useEffect(() =&gt; {<br/>    prefetchConfiguration({<br/>      warmAndPrefetchChrome: true,<br/>      ...configs.fusionauth<br/>    });<br/>  }, []);<br/>  const configs = {<br/>    fusionauth: {<br/>      issuer: 'https://ce25267ff5a5.ngrok.io',<br/>      clientId: '253eb7aa-687a-4bf3-b12b-26baa40eecbf',<br/>      redirectUrl: 'fusionauth.demo:/oauthredirect',<br/>      additionalParameters: {},<br/>      scopes: ['offline_access'],<br/>    }<br/>  }</span><span id="0b93" class="my lc iq mp b gy nn na l nb nc">  const getAccesstoken = async () =&gt; {<br/>    try {<br/>      // Retrieve the credentials<br/>      const credentials = await Keychain.getGenericPassword();<br/>      if (credentials) {</span><span id="3d3a" class="my lc iq mp b gy nn na l nb nc">        return credentials.password</span><span id="1609" class="my lc iq mp b gy nn na l nb nc">      } else {<br/>        console.log('No credentials stored');<br/>      }<br/>    } catch (error) {<br/>      console.log("Keychain couldn't be accessed!", error);<br/>    }<br/>  }<br/>  const getUser = async () =&gt; {<br/>    try {<br/>      const access_token = await getAccesstoken();<br/>      if (access_token !== null) {<br/>        fetch(configs.fusionauth.issuer + "/oauth2/userinfo", {<br/>          method: "GET",<br/>          headers: {<br/>            Authorization: "Bearer " + access_token,<br/>          },<br/>        })<br/>          .then((response) =&gt; response.json())<br/>          .then((json) =&gt; {<br/>            console.log(json);<br/>            setuserinfo(json);<br/>          })<br/>          .catch((error) =&gt; {<br/>            console.error(error);<br/>          });<br/>      }<br/>    } catch (e) {<br/>      console.log(e);<br/>    }<br/>  };<br/>  const handleAuthorize = useCallback(<br/>    async () =&gt; {<br/>      try {<br/>        const newAuthState = await authorize(configs.fusionauth);<br/>        console.log(newAuthState)<br/>        setAuthState({<br/>          hasLoggedInOnce: true,<br/>          ...newAuthState<br/>        });<br/>        await Keychain.setGenericPassword('accessToken', newAuthState.accessToken);<br/>      } catch (error) {<br/>        Alert.alert('Failed to log in', error.message);<br/>      }<br/>    },<br/>    [authState]<br/>  );<br/></span><span id="a7aa" class="my lc iq mp b gy nn na l nb nc">  return (<br/>    &lt;View style={styles.container}&gt;<br/>      &lt;Image<br/>        source={require('./fusionauth.png')}<br/>      /&gt;<br/>      {authState.accessToken ? (<br/>        &lt;TouchableOpacity<br/>          style={styles.button}<br/>          onPress={() =&gt; getUser()}<br/>        &gt;<br/>          &lt;Text style={styles.buttonText}&gt;Get User&lt;/Text&gt;<br/>        &lt;/TouchableOpacity&gt;<br/>      ) : (&lt;TouchableOpacity<br/>        style={styles.button}<br/>        onPress={() =&gt; handleAuthorize()}</span><span id="555a" class="my lc iq mp b gy nn na l nb nc">      &gt;<br/>        &lt;Text style={styles.buttonText}&gt;Login with FusionAuth&lt;/Text&gt;<br/>      &lt;/TouchableOpacity&gt;)}<br/>      {userinfo ? (<br/>        &lt;View style={styles.userInfo}&gt;<br/>          &lt;View&gt;<br/>            &lt;Text style={styles.userInfoText}&gt;<br/>              Username:{userinfo.given_name}<br/>            &lt;/Text&gt;<br/>            &lt;Text style={styles.userInfoText}&gt;&lt;/Text&gt;<br/>            &lt;Text style={styles.userInfoText}&gt;Email:{userinfo.email}&lt;/Text&gt;<br/>            &lt;Text style={styles.userInfoText}&gt;&lt;/Text&gt;</span><span id="f4f2" class="my lc iq mp b gy nn na l nb nc">          &lt;/View&gt;<br/>        &lt;/View&gt;<br/>      ) : (<br/>          &lt;View&gt;&lt;/View&gt;<br/>        )}</span><span id="3d33" class="my lc iq mp b gy nn na l nb nc">    &lt;/View&gt;<br/>  );</span><span id="0e36" class="my lc iq mp b gy nn na l nb nc">}<br/></span><span id="1a29" class="my lc iq mp b gy nn na l nb nc">const styles = StyleSheet.create({<br/>  container: {<br/>    flexDirection: "column",<br/>    backgroundColor: "grey",<br/>    flex: 1,<br/>    alignItems: "center",<br/>    justifyContent: "space-evenly",<br/>  },<br/>  button: {<br/>    backgroundColor: "#f58321",<br/>    padding: 20<br/>  },<br/>  buttonText: {<br/>    color: "#000",<br/>    fontSize: 20,<br/>  },<br/>  userInfo: {<br/>    height: 300,<br/>    width: 300,<br/>    alignItems: "center",<br/>  },<br/>  userInfoText: {<br/>    color: "#fff",<br/>    fontSize: 18,<br/>  },<br/>  errorText: {<br/>    color: "#fff",<br/>    fontSize: 18,<br/>  },<br/>  profileImage: {<br/>    height: 64,<br/>    width: 64,<br/>    marginBottom: 32,<br/>  },<br/>});</span></pre><p id="a145" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们需要向<code class="fe mm mn mo mp b">App.js</code>添加必要的导入:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="c9ed" class="my lc iq mp b gy mz na l nb nc">//...<br/>import React, { useState, useCallback, useMemo } from 'react';<br/>import { Alert } from 'react-native';<br/>import { authorize, refresh, revoke, prefetchConfiguration } from 'react-native-app-auth';<br/>//...</span></pre><p id="07a9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，我们需要创建一个<code class="fe mm mn mo mp b">configs</code>对象。这将包含应用程序的客户端id等详细信息:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="c97d" class="my lc iq mp b gy mz na l nb nc">//...<br/>const configs = {<br/>  fusionauth: {<br/>    issuer: 'https://ce25267ff5a5.ngrok.io', <br/>    clientId: '253eb7aa-687a-4bf3-b12b-26baa40eecbf',<br/>    redirectUrl: 'fusionauth.demo:/oauthredirect',<br/>    additionalParameters: {},<br/>    scopes: ['offline_access'],<br/>  }<br/>}<br/>//...</span></pre><p id="efd0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">更多关于配置参数的信息，因为这是您需要在代码中更改的内容。<code class="fe mm mn mo mp b">issuer</code>是FusionAuth服务器的URL您可以看到，我们已经将其设置为ngrok URL。<code class="fe mm mn mo mp b">clientId</code>是我们从FusionAuth管理用户界面获取的ID。</p><p id="3778" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mm mn mo mp b">redirectUrl</code>是我们在FusionAuth应用程序中设置的URL，使用了我们在配置iOS和Android时使用的方案。值<code class="fe mm mn mo mp b">oauthredirect</code>是react native app auth库定义的回调路径。确保使用您的配置值更新该对象中的<code class="fe mm mn mo mp b">issuer</code>和<code class="fe mm mn mo mp b">clientId</code>键。</p><p id="d2c7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以添加任何额外的参数(本例中没有)。如果您需要自定义范围，这也是添加它们的地方。我们正在请求<code class="fe mm mn mo mp b">offline_access</code>范围，以便OAuth服务器将返回一个<code class="fe mm mn mo mp b">refresh_token</code>。如果我们当前的访问令牌过期，此类令牌可用于请求额外的访问令牌。</p><p id="6618" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">接下来，在文件中创建一个默认的auth state对象。这将被修改，因为我们的用户首先查看React本机应用程序，然后进行身份验证。这包含像令牌值和到期日期这样的信息。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="055f" class="my lc iq mp b gy mz na l nb nc">//...<br/>const defaultAuthState = {<br/>  hasLoggedInOnce: false,<br/>  provider: '',<br/>  accessToken: '',<br/>  accessTokenExpirationDate: '',<br/>  refreshToken: ''<br/>};</span><span id="eb01" class="my lc iq mp b gy nn na l nb nc">const [authState, setAuthState] = useState(defaultAuthState);<br/>//...</span></pre><p id="2c3a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们准备配置接收令牌的代码。</p><h1 id="e4b8" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">配置React本机OAuth授权</h1><p id="8e21" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">让我们创建获取令牌的函数；这将使用先前创建的<code class="fe mm mn mo mp b">configs</code>对象。它还将使用<code class="fe mm mn mo mp b">react-native-app-auth</code>包中的<code class="fe mm mn mo mp b">authorize</code>函数。它将完成所有繁重的工作，并与OAuth服务器连接。该函数的实现如下:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="aee1" class="my lc iq mp b gy mz na l nb nc">//...<br/>const handleAuthorize = useCallback(<br/>  async provider =&gt; {<br/>    try {<br/>      const newAuthState = await authorize(configs.fusionauth);</span><span id="765c" class="my lc iq mp b gy nn na l nb nc">      setAuthState({<br/>        hasLoggedInOnce: true,<br/>        ...newAuthState<br/>      });<br/>    } catch (error) {<br/>      Alert.alert('Failed to log in', error.message);<br/>    }<br/>  },<br/>  [authState]<br/>);<br/>//...</span></pre><p id="3800" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mm mn mo mp b">newAuthState</code>是从<code class="fe mm mn mo mp b">authorize</code>函数返回的，因为我们可以将我们的身份验证状态设置为该返回值。现在我们有了与FusionAuth接口的代码，所以我们想给用户一个调用代码的方法。</p><h1 id="fd32" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">构建用户界面</h1><p id="d21d" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">所以，我们需要创建一个用户界面(UI)。我们将创建一个简单的UI来开始身份验证。用户登录后，我们将显示访问令牌。一旦用户成功登录，FusionAuth就会提供访问令牌。</p><p id="20a5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，您通常不希望简单地显示或存储访问令牌。您需要它是因为它允许您的应用程序进行其他API调用，通常是为了收集更多信息以显示给用户。在本教程的后面，我们将使用访问令牌从OpenID连接端点检索用户信息，并在我们的应用程序中显示这些信息。</p><p id="b5b6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以向API提供令牌，让应用程序发送电子邮件、记录待办事项或下订单。然而，我们今天不会构建这些集成。</p><p id="bc93" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要设置用户界面，将其添加到<code class="fe mm mn mo mp b">App.js</code>:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="d39c" class="my lc iq mp b gy mz na l nb nc">//...<br/>return (<br/>  &lt;View style={styles.container}&gt;<br/>    &lt;Image<br/>      source={require('./fusionauth.png')}<br/>    /&gt;<br/>    {authState.accessToken ? (<br/>      &lt;View style={styles.userInfo}&gt;<br/>        &lt;View&gt;<br/>          &lt;Text style={styles.userInfoText}&gt;<br/>            accessToken<br/>          &lt;/Text&gt;<br/>          &lt;Text style={styles.userInfoText}&gt;<br/>            {authState.accessToken}<br/>          &lt;/Text&gt;<br/>          &lt;Text style={styles.userInfoText}&gt;<br/>            accessTokenExpirationDate<br/>          &lt;/Text&gt;<br/>          &lt;Text style={styles.userInfoText}&gt;<br/>            {authState.accessTokenExpirationDate}<br/>          &lt;/Text&gt;<br/>        &lt;/View&gt;<br/>      &lt;/View&gt;<br/>    ) : (<br/>        &lt;TouchableOpacity<br/>          style={styles.button}<br/>          onPress={() =&gt; handleAuthorize()}<br/>        &gt;<br/>          &lt;Text style={styles.buttonText}&gt;<br/>            Login with FusionAuth&lt;/Text&gt;<br/>          &lt;/TouchableOpacity&gt;<br/>      )}<br/>  &lt;/View&gt;<br/>);</span></pre><p id="6224" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该应用程序将显示两种状态之一，这取决于我们是否有一个<code class="fe mm mn mo mp b">accessToken</code>。现在，我们可以通过在终端中键入<code class="fe mm mn mo mp b">npx react-native run-ios</code>来运行iOS模拟器中的应用程序:</p><figure class="mq mr ms mt gt nf"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="c310" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以通过修改<code class="fe mm mn mo mp b">styles</code>对象和添加更多CSS来改善应用程序的外观和感觉，但是我们将把这些留给读者作为练习。遵循最佳实践，请注意移动应用程序打开系统浏览器进行用户身份验证，而不是webview或嵌入式用户代理。</p><h1 id="8cb5" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">安全存储JWT</h1><p id="ae9a" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">一旦用户成功通过身份验证，我们将拥有一个访问令牌，可能还有一个刷新令牌，应该安全地存储起来。访问令牌是一个JSON Web令牌，也称为JWT。在典型的React Native client存储选项<code class="fe mm mn mo mp b">Asyncstorage</code>中存储像JWT这样的敏感数据是一种糟糕的做法。我们可以使用第三方包来访问iOS钥匙扣和Android安全存储，这是一个更好的选择。</p><p id="298c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有很多选择，但是强大的团队，我们正在使用的<code class="fe mm mn mo mp b">react-native-app-auth</code>包的创建者，推荐<code class="fe mm mn mo mp b"><a class="ae nd" href="https://github.com/oblador/react-native-keychain" rel="noopener ugc nofollow" target="_blank">react-native-keychain</a></code>。通过运行以下命令来安装它:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="9e90" class="my lc iq mp b gy mz na l nb nc">yarn add react-native-keychain</span></pre><p id="a2dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要在成功认证后存储访问令牌，请将其添加到<code class="fe mm mn mo mp b">App.js</code>文件中:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="1b19" class="my lc iq mp b gy mz na l nb nc">//...<br/>try {<br/>  const newAuthState = await authorize(configs.fusionauth);<br/>  console.log(newAuthState)<br/>  setAuthState({<br/>    hasLoggedInOnce: true,<br/>    ...newAuthState<br/>  });<br/>  await Keychain.setGenericPassword('accessToken', newAuthState.accessToken);<br/>} catch (error) {<br/>  Alert.alert('Failed to log in', error.message);<br/>}<br/>//...</span></pre><p id="f401" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以前，我们调用<code class="fe mm mn mo mp b">setAuthState</code>将JWT存储在内存中，但是现在我们安全地存储它以备将来调用。这是我们为此添加的代码行:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="df38" class="my lc iq mp b gy mz na l nb nc">//...<br/>await Keychain.setGenericPassword('accessToken', newAuthState.accessToken);<br/>//...</span></pre><p id="ec85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以这种方式存储令牌的另一面是，我们必须在返回密钥之前创建一个函数来检查凭证。如果它不在那里，我们就返回<code class="fe mm mn mo mp b">null</code>:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="b997" class="my lc iq mp b gy mz na l nb nc">//...<br/>const getAccesstoken = async () =&gt; {<br/>  try {<br/>    // Retrieve the credentials<br/>    const credentials = await Keychain.getGenericPassword();<br/>    if (credentials) {<br/>      return credentials.password<br/>    } else {<br/>      console.log('No credentials stored');<br/>    }<br/>  } catch (error) {<br/>    console.log("Keychain couldn't be accessed!", error);<br/>  }<br/>}<br/>//...</span></pre><p id="334a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，我们可以在获得访问令牌后，安全地存储和检索JWT。接下来，让我们看看我们可以用令牌做什么。</p><h1 id="dbde" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">检索有关已验证用户的更多信息</h1><p id="385d" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">因为我们有了访问令牌，所以现在可以从FusionAuth检索用户数据。当然，您也可以使用访问令牌来调用其他服务或API，但这超出了本教程的范围。</p><p id="9d3f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检索用户信息，在<code class="fe mm mn mo mp b">App.js</code>文件中创建一个名为<code class="fe mm mn mo mp b">getUser</code>的新函数。在其中，我们将构造一个URL并从存储中检索访问令牌，然后我们将调用一个端点来获取用户信息。</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="c300" class="my lc iq mp b gy mz na l nb nc">//...<br/>const getUser = async () =&gt; {<br/>  try {<br/>    const access_token = await getAccesstoken();<br/>    if (access_token !== null) {<br/>      fetch(configs.fusionauth.issuer+"/oauth2/userinfo", {<br/>        method: "GET",<br/>        headers: {<br/>          Authorization: "Bearer " + access_token,<br/>        },<br/>      })<br/>        .then((response) =&gt; response.json())<br/>        .then((json) =&gt; {<br/>          console.log(json);<br/>          setuserinfo(json);<br/>        })<br/>        .catch((error) =&gt; {<br/>          console.error(error);<br/>        });<br/>    }<br/>  } catch (e) {<br/>    console.log(e);<br/>  }<br/>};<br/>//...</span></pre><p id="5c73" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当然，如果不显示数据，获取数据就没什么意思了。让我们更新UI以显示我们对用户的了解:</p><pre class="mq mr ms mt gt mu mp mv mw aw mx bi"><span id="58c4" class="my lc iq mp b gy mz na l nb nc">//...<br/>    {userinfo ? (<br/>      &lt;View style={styles.userInfo}&gt;<br/>        &lt;View&gt;<br/>          &lt;Text style={styles.userInfoText}&gt;<br/>            Username:{userinfo.given_name}<br/>          &lt;/Text&gt;<br/>          &lt;Text style={styles.userInfoText}&gt;&lt;/Text&gt;<br/>          &lt;Text style={styles.userInfoText}&gt;Email:{userinfo.email}&lt;/Text&gt;<br/>          &lt;Text style={styles.userInfoText}&gt;&lt;/Text&gt;</span><span id="1dff" class="my lc iq mp b gy nn na l nb nc">        &lt;/View&gt;<br/>      &lt;/View&gt;<br/>    ) : (<br/>        &lt;View&gt;&lt;/View&gt;<br/>    )}<br/>//...</span></pre><p id="387b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这个UI片段中，我们检查是否有<code class="fe mm mn mo mp b">userinfo</code>。如果是这样，我们将显示用户的名字和电子邮件地址；该数据是从FusionAuth检索的。这里有一个视频，展示了仿真器执行这些更改后的代码:</p><figure class="mq mr ms mt gt nf"><div class="bz fp l di"><div class="nz oa l"/></div></figure><p id="777d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是了。您已经成功地配置了一个React本机应用程序来与FusionAuth进行交互。我们已经对用户进行了身份验证，安全地存储了他们的访问令牌，并显示了来自该用户的信息。</p><h1 id="b4bd" class="lb lc iq bd ld le lf lg lh li lj lk ll jw lm jx ln jz lo ka lp kc lq kd lr ls bi translated">结论</h1><p id="3db8" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">本教程是关于移动认证信息的过山车。我们能够执行授权并从OAuth服务器获取用户数据。提醒一下，React原生项目的<a class="ae nd" href="https://github.com/fusionauth/fusionauth-example-react-native" rel="noopener ugc nofollow" target="_blank">代码可以在Github上获得。</a></p><p id="b4dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望你喜欢这个教程。你有什么意见或问题吗？请把它们贴在下面。</p><p id="aac8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">编码快乐！</p><h2 id="4872" class="my lc iq bd ld no np dn lh nq nr dp ll ko ns nt ln ks nu nv lp kw nw nx lr ny bi translated">简单英语的JavaScript</h2><p id="9a7d" class="pw-post-body-paragraph kf kg iq kh b ki lt jr kk kl lu ju kn ko lv kq kr ks lw ku kv kw lx ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae nd" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kh ir">！</strong></p></div></div>    
</body>
</html>