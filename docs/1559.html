<html>
<head>
<title>Create your first web component using vanilla JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用普通JavaScript创建您的第一个web组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/create-your-first-web-component-using-vanilla-javascript-82a50cc742b0?source=collection_archive---------1-----------------------#2020-04-01">https://javascript.plainenglish.io/create-your-first-web-component-using-vanilla-javascript-82a50cc742b0?source=collection_archive---------1-----------------------#2020-04-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4018" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">仅使用基本的Web组件API</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6b424bcba20ddd192d8c6cd0e1e1026f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LeYBjLHr6kmYIoSx-aHdDA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image with two monitors with no visible code</figcaption></figure><p id="81bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Web组件是低级浏览器特征的集合，它允许我们编写封装的、模块化的、可重用的HTML元素。web组件可以在任何支持基本HTML和JavaScript的Web标准环境中工作，我们可以在用不同技术构建的应用程序中重用。</p><p id="8e70" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了遵循这个指南，你可以使用在线代码编辑器，比如<a class="ae lr" href="https://jsbin.com" rel="noopener ugc nofollow" target="_blank"> jsbin </a>，并且最好了解以下基本知识:</p><ul class=""><li id="f398" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">HTML、CSS和Javascript。</li><li id="f8ed" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">Javascript模块</li><li id="4558" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">箭头功能</li></ul><p id="555e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Web组件的主要功能有:</p><ul class=""><li id="3cd9" class="ls lt iq kx b ky kz lb lc le lu li lv lm lw lq lx ly lz ma bi translated">自定义元素</li><li id="cc80" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">模板</li><li id="d81b" class="ls lt iq kx b ky mb lb mc le md li me lm mf lq lx ly lz ma bi translated">阴影DOM</li></ul><p id="bed5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们将逐步构建我们的定制组件<my-component>。</my-component></p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="00c3" class="ml mm iq mh b gy mn mo l mp mq">&lt;my-component&gt;<br/>    &lt;h1&gt;Hello world!&lt;/h1&gt;<br/>&lt;/my-component&gt;</span></pre><p id="fcf8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">目前，你的浏览器不理解<my-component>标签。当浏览器发现类似<my-component>的未知HTML标签时，它会将其呈现为一个内联元素，并继续呈现下一个元素。使用自定义元素API，我们可以告诉浏览器如何处理新的HTML标签。</my-component></my-component></p><p id="de77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们在元素的底部添加一个脚本标签:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="60e9" class="ml mm iq mh b gy mn mo l mp mq">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>    &lt;body&gt;<br/>        &lt;h1&gt;Hello world!&lt;/h1&gt;<br/>     &lt;script&gt;<br/>      /*the code of our <br/>       component go here.<br/>      */<br/>     &lt;/script&gt;<br/>    &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="f70d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了创建自定义元素，我们将创建一个扩展HTMLElement类的类。这个类是支持所有其他HTML原生元素的基础，比如<input/>元素。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="1acf" class="ml mm iq mh b gy mn mo l mp mq">class MyComponent extends HTMLElement{<br/>  connectedCallback() {<br/>     console.log('my component is connected!');<br/>  }<br/>}</span></pre><p id="0614" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在构建了我们的类之后，我们可以通过在定制元素注册中心定义它来用一个标记名连接它。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="6ec1" class="ml mm iq mh b gy mn mo l mp mq">customElements.define('my-component', MyComponent);</span></pre><p id="4122" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当浏览器实例化我们的定制标签时，它触发一些生命周期回调。为简单起见，我们将看到的唯一生命周期方法是<connectedcallback>和<disconnectedcallback>，如下所示:</disconnectedcallback></connectedcallback></p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="41dc" class="ml mm iq mh b gy mn mo l mp mq">class MyComponent extends HTMLElement{<br/>    constructor() {<br/>      super();<br/>      /*called when the class is <br/>      instantiated<br/>      */<br/>    }</span><span id="d16a" class="ml mm iq mh b gy mr mo l mp mq"><strong class="mh ir">connectedCallback</strong>() {<br/>     /*called when the element is <br/>      connected to the page.<br/>      This can be called multiple <br/>      times during the element's<br/>      lifecycle.<br/>      for example when using drag&amp;drop<br/>      to move elements around<br/>     */<br/>   }</span><span id="6a76" class="ml mm iq mh b gy mr mo l mp mq"><strong class="mh ir">disconnectedCallback</strong>() {<br/>   /*called when the element<br/>     is disconnected from the page<br/>   */<br/>}</span></pre><p id="f38a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因为我们的类是从HTMLElement类扩展而来的，所以当它被实例化时，类实例就是一个实际的动态DOM元素。注意，常规DOM元素的所有方法和属性也存在于此。</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="2dec" class="ml mm iq mh b gy mn mo l mp mq">class MyComponent extends HTMLElement{<br/>    connectedCallback() {<br/>        this.style.color = 'red';<br/>    }<br/>}</span></pre><p id="9526" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">为了响应用户输入，我们可以向我们的元素或它的一个子元素添加一个事件监听器。让我们添加一个在单击时改变项目颜色的按钮:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="d43b" class="ml mm iq mh b gy mn mo l mp mq">class MyComponent extends HTMLElement{<br/>  constructor() {<br/>   super();<br/>   this.addEventListener('click',      <br/>   () =&gt; {<br/>         this.style.color === 'red'<br/>         ? this.style.color = 'blue':<br/>          this.style.color = 'red';<br/>   });<br/>  }  <br/>  connectedCallback() {<br/>      this.style.color = 'blue';<br/>  }<br/>}</span></pre><p id="6ce7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果代码:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="e367" class="ml mm iq mh b gy mn mo l mp mq">&lt;!DOCTYPE html&gt;</span><span id="9996" class="ml mm iq mh b gy mr mo l mp mq">&lt;html&gt;<br/>&lt;body&gt;</span><span id="fd98" class="ml mm iq mh b gy mr mo l mp mq">&lt;my-component&gt;<br/>    &lt;h1&gt;Hello Rick!&lt;/h1&gt;<br/>&lt;/my-component&gt;</span><span id="f78b" class="ml mm iq mh b gy mr mo l mp mq">&lt;script&gt;<br/> class MyComponent extends HTMLElement  <br/> {<br/>    constructor() {<br/>      super();<br/>      this.addEventListener('click',<br/>      () =&gt; {<br/>         this.style.color === 'red'<br/>         ? this.style.color = 'blue':<br/>          this.style.color = 'red';<br/>       });<br/>    }</span><span id="5d96" class="ml mm iq mh b gy mr mo l mp mq">    connectedCallback() {<br/>      /*called when the element is <br/>        connected to the page<br/>      */<br/>      this.style.color = 'blue';<br/>    }<br/> }</span><span id="4c27" class="ml mm iq mh b gy mr mo l mp mq">customElements.define('my-component', MyComponent);</span><span id="4b24" class="ml mm iq mh b gy mr mo l mp mq">&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="e61c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于Web组件，我们通常想做的不仅仅是设置一些样式。当用户与组件交互时，我们通常需要呈现组件的更多部分，并更新组件的一些部分。</p><p id="88d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">浏览器为我们提供了一个<template>元素来有效地做到这一点。这个元素允许我们预先设置HTML的一部分的结构，并在需要时有效地克隆它。这样做比每次重新创建相同的HTML结构要快。</template></p><p id="1502" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们在body标签内创建一个<template>:</template></p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="6925" class="ml mm iq mh b gy mn mo l mp mq">&lt;template&gt;<br/>    &lt;h1&gt;Hello Rick!&lt;/h1&gt;<br/>&lt;/template&gt;</span></pre><p id="a63d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们所看到的，“你好，里克！”不再呈现在页面上，因为它内部没有表示或执行任何内容。</p><p id="4ffa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们现在可以恢复并使用它作为模板。我们通过导入来克隆它的内容，并将克隆的元素添加到组件的子组件中。</p><p id="413d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果代码:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="9ccd" class="ml mm iq mh b gy mn mo l mp mq">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;body&gt;</span><span id="7fc2" class="ml mm iq mh b gy mr mo l mp mq">&lt;template&gt;<br/>    &lt;h1&gt;Hello Rick!&lt;/h1&gt;<br/>&lt;/template&gt;</span><span id="376a" class="ml mm iq mh b gy mr mo l mp mq"><strong class="mh ir">&lt;my-component&gt;&lt;/my-component&gt;</strong></span><span id="c3d9" class="ml mm iq mh b gy mr mo l mp mq">&lt;script&gt;<br/> class MyComponent extends HTMLElement {<br/> <br/>  constructor() {<br/>    super();<br/>    this.addEventListener('click',<br/>    () =&gt; {<br/>         this.style.color === 'red'<br/>         ? this.style.color = 'blue':<br/>          this.style.color = 'red';<br/>    });<br/>  }</span><span id="9a06" class="ml mm iq mh b gy mr mo l mp mq">connectedCallback() {<br/>   /*called when the element is <br/>        connected to the page<br/>   */</span><span id="95c7" class="ml mm iq mh b gy mr mo l mp mq">this.style.color = 'blue';</span><span id="2b0f" class="ml mm iq mh b gy mr mo l mp mq">const template = <br/>    document.<br/>      querySelector('template');<br/>    <br/>    <strong class="mh ir">const clone = <br/>    <em class="ms">document</em>.<br/>      importNode(template.content,    <br/>      true);<br/>    <br/>    this.appendChild(clone);</strong><br/>  }<br/> }</span><span id="7d7f" class="ml mm iq mh b gy mr mo l mp mq">customElements.define('my-component', MyComponent);</span><span id="02f8" class="ml mm iq mh b gy mr mo l mp mq">&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="b1f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Web组件给了我们使用"<strong class="kx ir"> ShadowDOM </strong>的能力，这个特性现在已经内置到浏览器中，所以如果我们向组件的ShadowDOM添加子元素，它们将不会是我们元素的子元素。然而，相反，它们将被包裹在一个阴影根中。</p><p id="4f49" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个影子根是一种特殊类型的DOM节点，它封装了其中的元素。在这个影子根中定义的样式、脚本和其他元素不会泄漏出去，反之亦然，因此我们实现了封装。</p><p id="45c3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢shadow root，我们可以保证我们的组件总是以相同的方式工作，不管环境如何，因此，我们可以创建可重用的组件。</p><p id="a2df" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">要在我们的组件中使用shadow root，请用this . attach shadow({ mode:' open ' })和this . shadow root . append child(clone)替换以下行:</p><p id="eb3b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最终结果代码:</p><pre class="kg kh ki kj gt mg mh mi mj aw mk bi"><span id="5ee2" class="ml mm iq mh b gy mn mo l mp mq">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>&lt;body&gt;</span><span id="2e4d" class="ml mm iq mh b gy mr mo l mp mq">&lt;template&gt;<br/>    &lt;h1&gt;Hello Rick!&lt;/h1&gt;<br/>&lt;/template&gt;</span><span id="6168" class="ml mm iq mh b gy mr mo l mp mq"><strong class="mh ir">&lt;my-component&gt;&lt;/my-component&gt;</strong></span><span id="496d" class="ml mm iq mh b gy mr mo l mp mq">&lt;script&gt;</span><span id="1331" class="ml mm iq mh b gy mr mo l mp mq">class MyComponent extends HTMLElement {</span><span id="57da" class="ml mm iq mh b gy mr mo l mp mq">constructor() {<br/>    super();<br/>    this.addEventListener('click',<br/>    () =&gt; {<br/>         this.style.color === 'red'<br/>         ? this.style.color = 'blue':<br/>          this.style.color = 'red';<br/>    });<br/>   }</span><span id="a3d5" class="ml mm iq mh b gy mr mo l mp mq">connectedCallback() {<br/>  /*called when the element is <br/>    connected to the page<br/>  */</span><span id="7f89" class="ml mm iq mh b gy mr mo l mp mq">this.style.color = 'blue';<br/> <br/>  const template = <br/>   document.querySelector('template');<br/>    <br/>  const clone =    <br/>  document.<br/>  importNode(template.content, true);<br/>   <br/>  //this.appendChild(clone);</span><span id="9246" class="ml mm iq mh b gy mr mo l mp mq"><strong class="mh ir">this.attachShadow({ mode: 'open' });         <br/>  this.shadowRoot.appendChild(clone); </strong><br/>   }<br/> }</span><span id="8bcc" class="ml mm iq mh b gy mr mo l mp mq">customElements.define('my-component', MyComponent);</span><span id="0e86" class="ml mm iq mh b gy mr mo l mp mq">&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><h2 id="4533" class="ml mm iq bd mt mu mv dn mw mx my dp mz le na nb nc li nd ne nf lm ng nh ni nj bi translated">结论</h2><p id="acfc" class="pw-post-body-paragraph kv kw iq kx b ky nk jr la lb nl ju ld le nm lg lh li nn lk ll lm no lo lp lq ij bi translated">这里我们已经看到了如何使用普通的JavaScript构建一个基本的Web组件。您可以只使用基本的web组件API来编写Web组件。如果您希望保持低依赖性，使用基本API可能是一个不错的选择。否则，建议使用轻量级库来帮助提高开发人员的体验并减少样板文件。</p><p id="ee3e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">【JavaScript用简单英语写的一句话:我们总是乐于帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的中级用户名发邮件到submissions@javascriptinplainenglish.com<a class="ae lr" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">给我们，我们会把你添加为作者。</a></p><p id="f9aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果你喜欢这篇文章，可以考虑通过我的<a class="ae lr" href="https://kesk.medium.com/membership" rel="noopener">个人资料</a>订阅Medium。谢谢大家！</p></div></div>    
</body>
</html>