<html>
<head>
<title>The 6 tools that changed JavaScript for me</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">改变我的JavaScript的6个工具</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-6tools-that-changed-javascript-for-me-3ee1faf40585?source=collection_archive---------0-----------------------#2020-05-04">https://javascript.plainenglish.io/the-6tools-that-changed-javascript-for-me-3ee1faf40585?source=collection_archive---------0-----------------------#2020-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="4b63" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">我花了很长时间寻找驯服JavaScript的工具，并且找到了它们</h2><div class=""/><div class=""><h2 id="2fd6" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">3个主流，2个默默无闻，1个正在崛起</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/50a1703b2984c8ea6e20d356dbbd9d0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PXEGRfrXgM0-MJ7aXafx9A.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@askonya?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Anna Elfimova</a> on <a class="ae le" href="https://unsplash.com/s/photos/happy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="89a3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我已经用静态类型的语言编码很多年了，我从汇编语言开始，到C语言，经过Visual Basic和C#，但是当我转向JavaScript时，我对软件的所有理解都改变了。</p><h1 id="d4e7" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">我对JavaScript的第一次体验</h1><p id="a4ab" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">当我第一次决定尝试JavaScript时，我用Sublime Text编码，它完全是关于文本编辑、多光标、微插件的，打开速度比Visual Studio快得多；我不需要等待智能感知或编译器，我输入，保存，代码就可以运行了，瞧！</p><p id="8c8d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">脚本语言的速度很快，但有一件小事也发生了变化:<strong class="lh ja">我的手指每小时可以输入的错误数量激增</strong>。</p><p id="bc1f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我喜欢C#，我喜欢IDE，智能感知，自动完成，并诚实地利用“面向编译器的开发”了很多。我只是通过阅读编译器和Intellisense在我出错时指出的内容来学习。</p><p id="fc0b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如您现在可能认为的那样，我很快对来自静态类型和编译语言的JavaScript有了一种偏见:语法很奇怪，没有任何东西可以缓存我的错误，当时的作用域很乱，库缺乏自动发现能力(没有智能感知)，承诺不存在，框架也没有像今天这样被采用。</p><h1 id="9f28" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">我的第一个框架</h1><p id="ad78" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在我第一次使用JavaScript多年后，当我主要使用C#时，我找到了一份全职使用AngularJS的工作。我觉得AngularJS使项目更加结构化，并将编程中常见的“良好实践”带到了JavaScript中。</p><p id="de5d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在2年的时间里，那个项目教会了我许多关于JavaScript的课程，但我仍然觉得没有什么事情像我预期的那样顺利。</p><h1 id="167f" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">不可解析的JavaScript</h1><p id="1df5" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我觉得JavaScript是不可驯服的:运行时异常仍然是一种规范，我的大部分代码大部分时间都在重复，可读性仍然是一个问题，表达意图不仅是一个挑战，也是一种奢侈，我过去编程经验中的知识似乎很少能在JavaScript中很好地工作，最糟糕的是:我仍然觉得自己是一个糟糕的JavaScript程序员。</p><p id="dfb4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在尝试应用我的面向对象编程知识以及从C#到JavaScript的其他好东西时，我一直关注着一切是如何转变的，这花了我一段时间，但就在结束之前，我决定改变我的想法。</p><h1 id="f230" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">忘却一切</h1><p id="2eab" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我进入了一种新的思维状态，我的前提如下:<em class="my">将面向对象的编程原则和设计模式应用于JavaScript是浪费时间，JavaScript并不完全是为此而设计的，我会努力做我认为最好的事情，忘掉OOP。</em></p><p id="a0d3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我开始积累自己的一套好的实践，过了一段时间，我开始觉得我有机会尝试JavaScript了；最后，我开始编写更少的代码，更少的错误，进行有用的抽象，一切开始变得美好，与此同时，我遇到了一篇文章，关于…函数式编程。</p><h1 id="4724" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">函数式编程</h1><p id="73da" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在贪婪地阅读了我所能找到的关于函数式编程的一切之后，我设法将我的每一个好的JavaScript实践映射到一个函数式编程概念，但是函数式编程不仅包含了我所有的经验，而且超出了我最大的梦想。</p><p id="ec0d" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我开始应用和展示每一个概念，每一个提交，每一个新手的错误，我的团队一点都没有意识到这一点，我们已经应用OOP将近2年了，随着AngularJS，在项目结束时改变范例是必然的死亡，我纠正并继续使用OOP。谢天谢地，项目结束了，我可以进入一份新工作，一份团队有更多函数式编程经验的新工作。</p><p id="1753" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在工作之余，我练习函数式编程，并试图发现如何使用每一个可用的库。我终于感觉到了对JavaScript的控制，为了获得对JavaScript的控制，我必须放弃它。</p><h1 id="a9b6" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">放弃JavaScript</h1><p id="82a2" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在学习了一些函数式编程的基础知识后，我决定尝试其他比AngularJS更适合FP的框架(此时Angular 2已经出现了)。</p><p id="2ca7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我开始接触现代框架，接触到榆树，我喜欢榆树！TypeScript呢？我真不敢相信我会如此高兴再次使用微软工具，尽管我完全放弃了Windows。这段时间正是我所需要的。</p><p id="241a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">回想起来，在用我自己的方式尝试了一些事情之后，我可以绝对肯定，我在JavaScript上的糟糕表现很大一部分是因为我自己缺乏与我思考软件的自然方式更相关的工具知识，因此，在使用公司的技术堆栈时，我感觉自己像一条离开水的鱼。</p><p id="2a05" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在给你我目前的工具链之前，给你一个建议:自己练习你想掌握的语言，没有任何强加的限制，之后，找一份符合你偏好的工作，否则，你可能会感到痛苦，因为你将为自己使用错误的工具，因此，永远不会发挥你的潜力。</p><h1 id="29ac" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">我的JavaScript工具链</h1><p id="db21" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">您肯定知道其中的一些工具，但是为了完整起见，我将尝试对所有这些工具进行简要的解释。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi mz"><img src="../Images/fc97ca51ed8d7795c7f6b692fb851060.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UTzlUEJy0fWpVz0oS5PT6Q.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Banner from <a class="ae le" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">TypeScript home page</a></figcaption></figure><h1 id="faee" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">以打字打的文件</h1><p id="c315" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">从<a class="ae le" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">他们自己的主页</a>:</p><blockquote class="na nb nc"><p id="eca4" class="lf lg my lh b li lj ka lk ll lm kd ln nd lp lq lr ne lt lu lv nf lx ly lz ma ij bi translated">TypeScript是JavaScript的类型化超集，它编译成普通JavaScript。</p></blockquote><p id="5da5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">是什么让我在每个项目中都使用TypeScript？</p><h2 id="e50a" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">编译错误</h2><p id="77fa" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">在编译时捕获错误是一件好事，这需要几秒钟吗？值得。愚蠢的错误、无法解释的运行时错误、出现得太晚的错误所带来的挫败感降低了我对这一职业的热爱，但打字稿再次带来了快乐。</p><h2 id="ba14" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">类型</h2><p id="8ae7" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">表现力和依从性，意图和一致性，设计和力量，类型需要时间来掌握，但男孩，他们是值得的。每一个。单身。时间。我太想念打字了。TypeScript既兼容面向对象类型，也兼容函数类型，太棒了。</p><p id="1018" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当你有了类型，那么多的对话就消失了，你为那些试图理解和使用你的代码的人节省了那么多时间，你变得能够发现整个库的用途而不需要阅读手册，并且你可以确信，由于类型约束，事情将会按照它们应该被使用的方式被使用。</p><p id="e7da" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">TypeScript中的类型还有很长的路要走，但是今天的类型系统已经为前端带来了如此强大的功能。没有一个类型系统感觉就像试图用脚跑赢一辆赛车。它提供了JavaScript所缺少的工程感，我使用类型来设计和执行接口的正确使用，我花在编写类型安全的每一个小时(好吧，这主要是我的看法)。</p><h2 id="7f69" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">减少了我的挫败感</h2><p id="d0c0" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">多亏了TypeScript，我每小时的错误，因此我的挫折感，大大减少了，只是这一部分使它是值得的。</p><p id="16de" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">TypeScript也随着版本变得越来越好，它很快采用了新的ECMAScript特性。</p><p id="9d7e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">所以，是的，我放弃了用普通的JavaScript编码，我觉得这对我的理智是一种危险。TypeScript拥有JavaScript的所有优点，并有许多机制使JavaScript实际上是可行的。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nr"><img src="../Images/c7cf5acb2aa42aaf9103e65a33b543c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kGYrdJAakKWlTufc"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Banner from <a class="ae le" href="https://twitter.com/code" rel="noopener ugc nofollow" target="_blank">@code Twitter</a></figcaption></figure><h1 id="5382" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">Visual Studio代码</h1><p id="d21d" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">这不是一个IDE，而是一个文本编辑器，最好的文本前端编辑器，从<a class="ae le" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank">他们的主页</a>:</p><blockquote class="na nb nc"><p id="7288" class="lf lg my lh b li lj ka lk ll lm kd ln nd lp lq lr ne lt lu lv nf lx ly lz ma ij bi translated">代码编辑。重新定义。免费。基于开源构建。到处跑。</p></blockquote><p id="2ddb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我为什么选择VSCode？</p><h2 id="1819" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">到处跑</h2><p id="415b" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">这种说法是正确的，我已经在我需要使用的每个操作系统上可靠地使用了VSCode，它速度很快，到处都有好东西，不需要担心平台支持。</p><h2 id="b142" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">智能感知</h2><p id="e41b" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">是的。用JavaScript它能创造奇迹，但是用TypeScript，它就像上帝一样，快速、可靠，并且在编译之前就能发现错误！我认为这是VSCode最好的特性之一，它就像有了另一双眼睛。</p><h2 id="3d0f" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">减少了我的挫败感</h2><p id="c4bd" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">Sublime当时的每个插件都很慢，并且缺乏智能感知，VSCode很快，并且随着发布会越来越快，我真的很惊讶这么好的软件是免费的。</p><p id="609a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">一切按预期运行，它拥有我能想到的所有特性，那些不应该是核心的，都是扩展，老实说掌握它是值得的。</p><p id="1967" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后，用一句话来描述我的VSCode代码体验:我没有抱怨。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ns"><img src="../Images/8da6a281bbf0d2fee4a60b77e63b892b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*DwBQYynZOfW-w0Iz.jpg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Banner from <a class="ae le" href="https://xpgraph.com/react-is-the-new-black" rel="noopener ugc nofollow" target="_blank">Xpgraph blog post</a></figcaption></figure><h1 id="5049" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">反应</h1><p id="dd9d" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">来自<a class="ae le" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">他们的主页</a>:</p><blockquote class="na nb nc"><p id="d272" class="lf lg my lh b li lj ka lk ll lm kd ln nd lp lq lr ne lt lu lv nf lx ly lz ma ij bi translated">用于构建用户界面的JavaScript库</p></blockquote><p id="5fe3" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如前所述，我从AngularJS开始，这是一个包含完整电池的前端框架，但对我来说，做出反应是不可避免的，原因如下:</p><h2 id="eb93" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">不是一个框架</h2><p id="2ff9" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">没错，它不是一个框架，这是我最喜欢的事情之一，我通常编写小程序，我不需要一个大框架，我只需要一点酱帮我构建小ui。</p><h2 id="ba7b" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">包含函数式编程</h2><p id="bb82" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">最大的卖点是React包含了函数式编程，符合我对JavaScript的新看法。</p><p id="ace4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">React努力做到简洁，我对此表示赞赏；React用最少的语法表达复杂的概念，像<code class="fe nt nu nv nw b">useState</code>和高阶组件就是几个例子，说明拥有正确的抽象比拥有一堆可能最终会用错的工具要好得多。</p><h2 id="fe95" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">全部加起来+打字稿</h2><p id="c684" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我不使用Svelte或Vue的原因是我不喜欢模板，我喜欢类型。在模板文件中，你没有类型脚本，也没有JavaScript，你有类似模板脚本的东西，一些帮助你做事情的特别标记，非类型化的，对每件事情都有不同的推理。</p><p id="d198" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我确实喜欢React的全部特性。意思是我用<a class="ae le" href="https://cssinjs.org/?v=v10.1.1" rel="noopener ugc nofollow" target="_blank"> JSS </a>代替CSS，用<a class="ae le" href="https://www.typescriptlang.org/docs/handbook/jsx.html" rel="noopener ugc nofollow" target="_blank"> TSX </a>代替HTML + JS，在TypeScript中，所有CSS、HTML、JS都在一个文件中，我喜欢它，一切都有智能感知、编译错误、类型，没有上下文切换。</p><p id="11fa" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在我看来，小组件是CSS + HTML + JS的混合体，将它们都合并到TypeScript中对我有利。</p><p id="16d8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">更好的一面呢？它的性能随着每个新版本不断提高，更多的JSS被传输到静态CSS，更多的TSX被优化，等等，所以你可以习惯性地编程，随着时间的推移，传输程序提高了输出。</p><p id="117b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在我工作过的公司中，我们在小程序中编写高层次的概念，而不是低层次的东西，我相信公司不会付钱给程序员来优化任何东西，他们想要快速可用和可靠的软件。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nx"><img src="../Images/15de5af5298142e991ae378084cf1951.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V7InF0j5-3nDQ6_2lIgezg.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@paxsonwoelber?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Paxson Woelber</a> on <a class="ae le" href="https://unsplash.com/s/photos/ram?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7d85" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">拉姆达</h1><p id="c950" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">现在让我们变得奇怪，我不指望你知道这个，从<a class="ae le" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank">他们的主页</a>:</p><blockquote class="na nb nc"><p id="63a1" class="lf lg my lh b li lj ka lk ll lm kd ln nd lp lq lr ne lt lu lv nf lx ly lz ma ij bi translated">面向JavaScript程序员的实用函数库。</p></blockquote><p id="b1e9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我可以写几个小时关于Ramda的文章，我会尝试总结为什么我在我的项目中100%使用Ramda的最大卖点:</p><h2 id="d8ce" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">连接</h2><p id="b3d0" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">很多人曾经或正在使用Lodash 作为他们的工具带，但Lodash对我来说是一个大问题，所有的论点都是落后的。如果你考虑可组合的软件，你会很快意识到如果你想组合两个Lodash函数，你需要一个中间的“辅助”变量。我宁愿不要。</p><p id="7f01" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">另一方面，Ramda的设计考虑到了构图，在curry和pipe的帮助下，关注精心制作的统一界面。</p><h2 id="3110" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">代码可重用性</h2><p id="2830" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我在上面抱怨过总是重复代码，大部分代码都是小的实用函数，如果我开始另一个项目，我必须重新编写它们，所以我在寻找一个好的实用程序库。</p><p id="5756" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在我几乎不考虑抽象函数，使它们更加可重用，因为所有通用的可重用函数都在Ramda中，有一个非常强大的功能优先的接口。</p><h2 id="e749" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">纯函数，无副作用且不可变</h2><p id="a08a" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">多用途皮带应该包含纯粹的功能，这意味着这些功能需要:没有副作用，并且将数据视为不可变的。这些东西与实用程序库不一致，见鬼，甚至在JavaScript内置数组函数中也不一致，不信我？看看这个:</p><pre class="kp kq kr ks gt ny nw nz bn oa ob bi"><span id="6787" class="oc mc iq nw b be od oe l of og">import { sort, asc } from 'ramda';<br/><br/>console.group('Native sort');<br/><br/>const naiveArray = [3, 2, 1];<br/>console.log(naiveArray.sort());<br/>console.log(naiveArray); // [1, 2, 3] &lt;- should be 3, 2, 1... but it isn't<br/><br/>console.groupEnd();<br/><br/>console.group('Ramda sort');<br/><br/>const iCareAboutThisArray = [3, 2, 1];<br/>console.log(sort(asc)(iCareAboutThisArray)); // [1, 2, 3]<br/>console.log(iCareAboutThisArray); // [3, 2, 1] &lt;- thanks Ramda!<br/><br/>console.groupEnd();</span></pre><p id="18ea" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果在应用了<code class="fe nt nu nv nw b">sort</code>之后，你还指望<code class="fe nt nu nv nw b">naiveArray</code>行为保持不变，你能估计出发现它需要多长时间吗？好吧，对不起，我不想让你癫痫发作。</p><p id="9347" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在我的每一段代码中，我都非常重视这些东西，所以Ramda在每个函数中内置这些东西的事实是…令人惊讶的。</p><h2 id="d195" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">换能器</h2><p id="7fe7" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">传感器的实用描述；</p><p id="559c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">换能器消除了组合多个阵列功能的性能损失。</p><p id="6774" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我认为图像胜于文字，传感器很难理解:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oh"><img src="../Images/3df784dff7eef335d48d4dffd5751b86.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*meLQNDykFfSKjv0mJcgQYQ.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk"><a class="ae le" href="https://jsperf.com/native-vs-ramad-vs-lodash-vs-immutable" rel="noopener ugc nofollow" target="_blank">https://jsperf.com/native-vs-ramad-vs-lodash-vs-immutable</a></figcaption></figure><p id="9833" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Ramda充满了传感器函数，这意味着它非常有性能，你可以堆叠多个<code class="fe nt nu nv nw b">filter</code>、<code class="fe nt nu nv nw b">map</code>和21个其他函数，它只会迭代数组并应用函数一次，而不是N次。</p><h2 id="394e" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">缺少一样东西</h2><p id="3f87" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">Ramda很棒，但是所有的好东西都是有代价的…如果你想打字稿的话。</p><p id="d51e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">Ramda的类型的类型、类型推断、类型解析的复杂程度是通过屋顶的；最重要的是，主要贡献者对TypeScript根本不感兴趣。</p><p id="62b1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">他们似乎是一群了不起的开发人员，在不需要TypeScript的情况下驯服了JavaScript，对将这个了不起的库移植到TypeScript毫无兴趣。</p><p id="ceea" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">那么它是如何与TypeScript一起工作的呢？值得庆幸的是，其他开发人员承担了向库提供类型的任务，他们非常精通TypeScript类型系统(我几乎不理解那些签名)，但似乎每个版本都工作得更好。</p><p id="0500" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">提供准确且可推断的TypeScript类型是一项艰巨的挑战，这些类型不会出现在对JavaScript高级类型特性进行了大量改进的库中，但它们正在实现，大多数函数现在都可以在TypeScript中无缝使用，但最高级的函数需要一些帮助来确定类型的结果。</p><p id="c765" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">尽管如此，Ramda仍然是我有幸使用过的制作最好的实用程序库之一，在我驯服JavaScript的旅程中，它让我思考了很多。谢谢，拉姆达。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/0a0fca025852a694895d10f7edb2b892.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eRWla9Y7mMYpytbo8QBl7g.png"/></div></div></figure><h1 id="b5b3" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">FP-TS</h1><p id="f297" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">虽然只要我们停留在JavaScript领域，Ramda就是一个令人惊奇的解决方案，但是一旦我完全采用了TypeScript，它就变得……难以使用，类型推断也不太好，所以我寻找其他考虑到TypeScript的解决方案，或者更好的是用TypeScript编写的解决方案。</p><p id="f7f7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">幸运的是我在他们的主页上找到了图书馆的奇迹fp-ts:</p><blockquote class="na nb nc"><p id="73a2" class="lf lg my lh b li lj ka lk ll lm kd ln nd lp lq lr ne lt lu lv nf lx ly lz ma ij bi translated">TypeScript中的类型函数编程</p><p id="bd7d" class="lf lg my lh b li lj ka lk ll lm kd ln nd lp lq lr ne lt lu lv nf lx ly lz ma ij bi translated">在TypeScript中为开发人员提供流行的模式和来自类型化函数语言的可靠抽象。</p></blockquote><p id="83d5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">fp-ts是一个杰作，老实说，它给TypeScript带来了这么多，而且以一种不引人注目的方式，它的类型完全符合习惯。</p><p id="b552" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为什么我在100%的项目中使用fp-ts？</p><h2 id="bdcf" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">管</h2><p id="3294" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我故意避免谈论Ramda的<code class="fe nt nu nv nw b">pipe</code>,因为fp-ts版本对TypeScript来说更习惯，一般来说更智能，因为类型分析的本质是从左到右的。</p><p id="b410" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是没有管道的代码:</p><pre class="kp kq kr ks gt ny nw nz bn oa ob bi"><span id="29ad" class="oc mc iq nw b be od oe l of og"><br/>function main() {<br/>  const text = "hello";<br/>  const aux = doubleSay(text);<br/>  const aux1 = capitalize(aux);<br/>  const aux2 = exclaim(aux1);<br/><br/>  return aux2;<br/>}<br/><br/>console.log(main()); // Hello, Hello!<br/><br/>function main2() {<br/>  return exclaim(capitalize(doubleSay("hello")));<br/>}<br/><br/>console.log(main2()); // Hello, Hello!<br/><br/>function doubleSay(text: string) {<br/>  return text + ", " + text;<br/>}<br/><br/>function capitalize(text: string) {<br/>  return text[0].toUpperCase() + text.substring(1);<br/>}<br/><br/>function exclaim(text: string) {<br/>  return text + "!";<br/>}</span></pre><p id="42f6" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在<code class="fe nt nu nv nw b">main</code>中，我需要有中间变量来分配中间结果，而在<code class="fe nt nu nv nw b">main2</code>中，从右到左读取执行顺序相当笨拙。</p><p id="8d8a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是拉姆达管道的代码:</p><pre class="kp kq kr ks gt ny nw nz bn oa ob bi"><span id="ec6f" class="oc mc iq nw b be od oe l of og">import { pipe } from 'ramda';<br/><br/>function main() {<br/>  return pipe(<br/>    doubleSay,<br/>    capitalize,<br/>    exclaim)<br/>    ('hello');<br/>}<br/><br/>console.log(main()); // =&gt; 'Hello, hello!'<br/><br/>function doubleSay(text: string) {<br/>  return str + ', ' + str;<br/>}<br/><br/>function capitalize(text: string) {<br/>  return str[0].toUpperCase() + str.substring(1);<br/>}<br/><br/>function exclaim(text: string) {<br/>  return str + '!';<br/>}</span></pre><p id="80f0" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">使用pipe，我们不需要中间变量，所有的数据流，但是，当使用Ramda的<code class="fe nt nu nv nw b">pipe</code>时，TypeScript大多数时候会产生错误，因为输入值被放在最后，因此，无法推断出第一个函数的输入是什么，等等，因为TypeScript从左到右进行推断，并且对于Ramda的<code class="fe nt nu nv nw b">pipe</code>来说，推断应该从左到右和从右到左进行，Ramda的<code class="fe nt nu nv nw b">pipe</code>类似于Haskell等函数式语言的类型推断系统中的常见功能</p><p id="29b7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在看fp-ts版的<code class="fe nt nu nv nw b">pipe</code>:</p><pre class="kp kq kr ks gt ny nw nz bn oa ob bi"><span id="7c2f" class="oc mc iq nw b be od oe l of og">import { pipe } from 'fp-ts/lib/pipeable';<br/><br/>function main() {<br/>  return pipe(<br/>    'hello',<br/>    doubleSay,<br/>    capitalize,<br/>    exclaim<br/>  );<br/>}<br/><br/>console.log(main()); // =&gt; 'Hello, hello!'<br/><br/>function doubleSay(text: string) {<br/>  return str + ', ' + str;<br/>}<br/><br/>function capitalize(text: string) {<br/>  return str[0].toUpperCase() + str.substring(1);<br/>}<br/><br/>function exclaim(text: string) {<br/>  return str + '!';<br/>}</span></pre><p id="3d33" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">不同的是<code class="fe nt nu nv nw b">fp-ts</code>把<code class="fe nt nu nv nw b">pipe</code>的输入放在第一位，让TypeScript推理很开心。在JavaScript领域，Ramdas的方法是100%有效的惯用代码，但TypeScript缺乏从右到左的推理使其“无效”或通常难以使用，所以我通常倾向于使用fp-ts版本的<code class="fe nt nu nv nw b">pipe</code>而不是Ramda的。</p><h2 id="a6fd" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">选项，TasksEither和其他FP数据结构</h2><p id="411e" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我很自豪地宣布，我很少再遇到<code class="fe nt nu nv nw b">undefined</code>和<code class="fe nt nu nv nw b">null</code>错误了，因为最终，我有了一个习惯的、完全受支持的<code class="fe nt nu nv nw b">Option</code>实现。</p><p id="f3c1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe nt nu nv nw b">Option</code>基本上是一个数据包装器，表示可能有也可能没有值。</p><p id="90fb" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">另一方面，<code class="fe nt nu nv nw b">Either</code>，允许更容易地分叉代码，事情可以向左或向右。</p><p id="07dc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">让我给你举个例子:</p><pre class="kp kq kr ks gt ny nw nz bn oa ob bi"><span id="e3fe" class="oc mc iq nw b be od oe l of og">type Context = {<br/>  token?: string;<br/>  log: (token: string) =&gt; string;<br/>};<br/><br/>function logging(ctx: Context): 'no-token-error' | 'log-error' | 'no-errors' {<br/>  const result = ctx.log(ctx.token);<br/><br/>  // ...<br/><br/>  return 'no-errors';<br/>}</span></pre><p id="74e9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">哦，多好的代码啊。这么小的代码不会有什么问题。</p><pre class="kp kq kr ks gt ny nw nz bn oa ob bi"><span id="4790" class="oc mc iq nw b be od oe l of og">type Context = {<br/>  token?: string;<br/>  log: (token: string) =&gt; string;<br/>};<br/><br/>function logging(ctx: Context): 'no-token-error' | 'log-error' | 'no-errors' {<br/>  const result = ctx.log(ctx.token);<br/><br/>  // ...<br/><br/>  return 'no-errors';<br/>}<br/><br/>console.log(logging({<br/>  // token: undefined<br/>  log: (token) =&gt; {<br/>    throw new Error('no token');<br/>  }<br/>})); // Error: no token<br/><br/>console.log(logging({<br/>  token: '@codingedgar',<br/>  log: (token) =&gt; {<br/>    throw new Error('random error')<br/>  }<br/>})); // Error: random error<br/><br/>console.log(logging({<br/>  token: '@codingedgar',<br/>  log: (token) =&gt; 'good code'<br/>})); // no-errors</span></pre><p id="c0ba" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">除了一切。但我们没那么傻，我们可以改进，扔点<code class="fe nt nu nv nw b">if</code>和<code class="fe nt nu nv nw b">try...catch</code>表情就都搞定了。</p><pre class="kp kq kr ks gt ny nw nz bn oa ob bi"><span id="48db" class="oc mc iq nw b be od oe l of og">type Context = {<br/>  token?: string;<br/>  log: (token: string) =&gt; string;<br/>};<br/><br/>function logging(ctx: Context): 'no-token-error' | 'log-error' | 'no-errors' {<br/>  if (!ctx.token) {<br/>    return 'no-token-error'; // early return due to no token<br/>  } else {<br/>    try {<br/>      let result = ctx.log(ctx.token);<br/>      // ...<br/>      return 'no-errors'; // success branch<br/>    } catch (e) {<br/>      return 'log-error'; // late return due error<br/>    }<br/>  }<br/>}<br/><br/>console.log(logging({<br/>  // token: undefined<br/>  log: (token) =&gt; {<br/>    throw new Error('no token');<br/>  }<br/>})); // Error: no token<br/><br/>console.log(logging({<br/>  token: '@codingedgar',<br/>  log: (token) =&gt; {<br/>    throw new Error('random error')<br/>  }<br/>})); // Error: random error<br/><br/>console.log(logging({<br/>  token: '@codingedgar',<br/>  log: (token) =&gt; 'good code'<br/>})); // no-errors</span></pre><p id="af2b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在成功了。通过这个例子，我向你展示了JavaScript和TypeScript都不能指导你检查这种情况，也许TypeScript用<code class="fe nt nu nv nw b">--strictNullChecks</code>会有一点帮助，但是函数返回类型不能代表错误但这还不是全部，分支都搞砸了，我返回早期错误和晚期错误，以及中间的成功？现在看看这个:</p><pre class="kp kq kr ks gt ny nw nz bn oa ob bi"><span id="ec62" class="oc mc iq nw b be od oe l of og">import { pipe } from 'fp-ts/lib/pipeable';<br/>import * as O from 'fp-ts/lib/Option';<br/>import * as E from 'fp-ts/lib/Either';<br/><br/>type Context = {<br/>  token: O.Option&lt;string&gt;;<br/>  log: (token: string) =&gt; E.Either&lt;Error, string&gt;;<br/>};<br/><br/>function logging(ctx: Context): 'no-token-error' | 'log-error' | 'no-errors' {<br/>  return pipe(<br/>    ctx.token,<br/>    O.map( // only if token exists execute this function<br/>      token =&gt; ctx.log(token) // for sure there's a token<br/>    ),<br/>    O.fold(<br/>      () =&gt; 'no-token-error' as const, // if no token<br/>      E.fold(<br/>        () =&gt; 'log-error' as const, // if log error returned error<br/>        result =&gt; {<br/>          // ...<br/>          return 'no-errors' as const; // if log succeeded<br/>        }<br/>      )<br/>    ) // all returns at the end<br/>  );<br/>}<br/><br/>console.log(logging({<br/>  // token: undefined<br/>  log: (token) =&gt; {<br/>    throw new Error('no token');<br/>  }<br/>})); // Error: no token<br/><br/>console.log(logging({<br/>  token: '@codingedgar',<br/>  log: (token) =&gt; {<br/>    throw new Error('random error')<br/>  }<br/>})); // Error: random error<br/><br/>console.log(logging({<br/>  token: '@codingedgar',<br/>  log: (token) =&gt; 'good code'<br/>})); // no-errors</span></pre><p id="5b17" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">正如你在这个例子中看到的，<code class="fe nt nu nv nw b">Option</code>和<code class="fe nt nu nv nw b">Either</code>都强迫我们以一种显式的方式处理分支，没有“遗漏分支”，我们可以用<code class="fe nt nu nv nw b">Either</code>的左分支来表示错误，我们只在最后返回。</p><p id="fec1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果预计会出现“错误”，为什么要使用<code class="fe nt nu nv nw b">try...catch</code>？这是预期的行为，<code class="fe nt nu nv nw b">try...catch</code>是“意外出错”的惯用说法，但对于预期的逻辑分支，要么是完美的抽象，事情可以向左(错误)或向右(成功)。</p><p id="730f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这些数据结构帮助我们构建更高级的数据流模式，比如铁路编程，如果你不知道我在说什么，看看这个页面:<a class="ae le" href="https://fsharpforfunandprofit.com/rop/" rel="noopener ugc nofollow" target="_blank">https://fsharpforfunandprofit.com/rop/</a>。</p><p id="7e74" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最后但同样重要的是，我将提到<code class="fe nt nu nv nw b">TaskEither</code>，任务基本上是围绕<code class="fe nt nu nv nw b">Promise</code>的包装器，但是有了更单一的接口，这个奇怪的词是什么意思？这意味着它更适合一个标准接口，而不是那些奇怪的Promise实例方法，比如<code class="fe nt nu nv nw b">then</code>，你可以使用已经建立的<code class="fe nt nu nv nw b">map</code>、<code class="fe nt nu nv nw b">chain</code>、<code class="fe nt nu nv nw b">ap</code>、<code class="fe nt nu nv nw b">fold</code>等等。</p><p id="6ec8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">好吧，如果你还不熟悉函数式编程，当然<code class="fe nt nu nv nw b">ap</code>和<code class="fe nt nu nv nw b">fold</code>在你的代码库中还没有很好地建立起来，但是一旦你熟悉了，你会注意到函数的一致性，所有的意思都是一样的，不管封闭的数据结构是什么，你都不会在意你是映射一个<code class="fe nt nu nv nw b">Array</code>、<code class="fe nt nu nv nw b">Object</code>、<code class="fe nt nu nv nw b">Option</code>、<code class="fe nt nu nv nw b">Either</code>还是<code class="fe nt nu nv nw b">TaskEither</code>，<code class="fe nt nu nv nw b">map</code>的意思是一样的，它有每个数据结构的细节，但是<code class="fe nt nu nv nw b">map</code>是<code class="fe nt nu nv nw b">map</code>在所有的情况下，你都是一致的</p><p id="d606" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这些只是一堆函数式数据结构中的3个，它们使你的代码真正表达意图，更简洁，最终更可靠。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oj"><img src="../Images/27218fba5fdf1bc3a5cf6e89a420034e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z_CssddC35sFTtx6T-DuOQ.png"/></div></div></figure><h1 id="0b17" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">x状态</h1><p id="ebf5" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">让我介绍一下XState，它应该已经取代了Redux。从<a class="ae le" href="https://xstate.js.org/docs/" rel="noopener ugc nofollow" target="_blank">他们的主页</a>:</p><blockquote class="na nb nc"><p id="9f31" class="lf lg my lh b li lj ka lk ll lm kd ln nd lp lq lr ne lt lu lv nf lx ly lz ma ij bi translated">现代网络的JavaScript和类型脚本<a class="ae le" href="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener ugc nofollow" target="_blank">有限状态机</a>和<a class="ae le" href="http://www.inf.ed.ac.uk/teaching/courses/seoc/2005_2006/resources/statecharts.pdf" rel="noopener ugc nofollow" target="_blank">状态图</a>。</p></blockquote><p id="3cf7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">很久以来，我的Redux商店缺少了一些东西，我试图制作一些小的中间件来帮助我驯服Redux，但它感觉…不完整。直到我中了头彩，找到了XState。</p><p id="093e" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为什么我在100%的React项目中使用XState？</p><h2 id="b36a" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">有限状态机</h2><p id="b7ca" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我的问题是Redux只是图片的一半，没有注意到我在每个React组件中制作小状态机，并使用Redux实现扩展状态(或无限状态)，一旦我发现XState，我所有的设计问题都遇到了一个有价值的竞争者。</p><p id="d4cc" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">应该显示按钮吗？启用？显示文本A还是B？所有这些“领域”规范只不过是一些状态，有限的，预先指定的；如果您显式地编写这样的状态，那么读取和升级组件就成了一件乐事。</p><p id="a5e7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">使用AngularJS和templates，我的状态由一堆交织在一起的变量组成，这些变量是无法读取的；使用React和Redux，所有数据都在一个地方，但状态不以任何方式表示，而是对数据的解释，但使用XState，我的状态实际上是显式的。看看这台机器:</p><pre class="kp kq kr ks gt ny nw nz bn oa ob bi"><span id="a9eb" class="oc mc iq nw b be od oe l of og">const fetchMachine = Machine({<br/>  id: 'fetch',<br/>  initial: 'idle',<br/>  context: {<br/>    retires: 0<br/>  },<br/>  states: {<br/>    idle: {<br/>      on: {<br/>        FETCH: 'loading'<br/>      }<br/>    },<br/>    loading: {<br/>      on: {<br/>        RESOLVE: 'success',<br/>        REJECT: 'failure'<br/>      }<br/>    },<br/>    success: {<br/>      type: 'final'<br/>    },<br/>    failure: {<br/>      on: {<br/>        RETRY: {<br/>          target: 'loading',<br/>          actions: assign({<br/>            retires: (context) =&gt; context.retires + 1<br/>          })<br/>        }<br/>      }<br/>    }<br/>  }<br/>});</span></pre><p id="bcb8" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果你像我一样是一个图形人，也许可以尝试使用XState可视化工具:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ok"><img src="../Images/235ca6e8b1b54f2082caa7aae8bd4b76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3yhKmBzQFkMFtkswsVSiwg.png"/></div></div></figure><p id="ab52" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我需要向你解释这台机器的行为吗？不，我没有。它就在那里，肉眼可见，没有怪异的曼波舞。</p><h1 id="9250" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">希望你喜欢</h1><p id="3f05" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我希望我的旅程能对你有所帮助。如果你喜欢这篇文章，也许你会喜欢<a class="ae le" href="http://eepurl.com/hg7AeP" rel="noopener ugc nofollow" target="_blank">订阅我的简讯</a>和其他的:</p><ol class=""><li id="5d94" class="ol om iq lh b li lj ll lm lo on ls oo lw op ma oq or os ot bi translated"><a class="ae le" href="https://medium.com/javascript-in-plain-english/narrated-by-test-cases-redux-action-retry-b2e004c4c823" rel="noopener">通过测试用例叙述:Redux Action Retry </a>，在本文中，你会发现TypeScript、ramda和fp-ts在运行。</li><li id="825f" class="ol om iq lh b li ou ll ov lo ow ls ox lw oy ma oq or os ot bi translated"><a class="ae le" href="https://medium.com/javascript-in-plain-english/you-should-never-use-an-arrow-function-in-any-of-these-two-situations-8bc2fbbc39b8" rel="noopener">避免箭头功能的两种情况</a>。</li><li id="44e9" class="ol om iq lh b li ou ll ov lo ow ls ox lw oy ma oq or os ot bi translated">管理层是如何限制你作为开发人员的潜力的。</li></ol><h2 id="84bc" class="ng mc iq bd md nh ni dn mh nj nk dp ml lo nl nm mn ls nn no mp lw np nq mr iw bi translated">用简单英语写的JavaScript的注释</h2><p id="3850" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae le" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="lh ja">AI in Plain English</strong></a><a class="ae le" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="lh ja">UX in Plain English</strong></a><a class="ae le" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="lh ja">Python in Plain English</strong></a><strong class="lh ja"/>——谢谢，继续学习！</p><p id="a82a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们还推出了一个YouTube，希望你能通过<a class="ae le" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="lh ja">订阅我们的英语频道</strong> </a>来支持我们</p><p id="bfb9" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">一如既往,“简明英语”希望帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae le" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja">submissions @ plain English . io</strong></a><strong class="lh ja"/>，并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>