# 如何用 JavaScript 创建自定义事件监听器

> 原文：<https://javascript.plainenglish.io/event-listeners-in-javascript-7c241fb74976?source=collection_archive---------9----------------------->

## 在您的代码库中，创建自定义事件监听器有什么用处？

![](img/a167256bf1fdbe9df41922e9690180cc.png)

浏览器环境中的 JavaScript 使用事件驱动架构。这意味着我们可以执行我们的代码来响应某些用户行为，如点击按钮或聚焦输入。

这里重要的是，DOM(文档对象模型)是一个为我们提供与文档交互的访问的系统，我们的代码并不直接相连。我们需要我们的系统能够响应不同的 DOM 事件，事件侦听器是我们将系统耦合到 DOM 以使其具有交互性的方式。

这里的想法是能够连接两个系统，以便能够响应彼此的行为。

因此，假设您有一个大型代码库，其中有不同的独立组件执行不同的任务，您可能希望在它们之间有一个通信媒介，这就是事件监听器的作用。

在这种情况下，我们可以创建自己的事件，并将代码绑定到事件上，以便以后需要时触发。

这种系统的粘合剂将是一个全局对象，我们可以将所有这些函数附加到它上面，并用一个键来引用它们。这个键可以在以后需要时触发这些功能。

最初的任务是创建一个类，它可以用所有需要的方法返回一个对象。如果只需要一个实例，还可以为同一个实例创建一个简单的对象。

之后，我们需要的第一个重要方法是在一个特定的事件上附加一个回调函数，我们可以根据自己的喜好给它命名。

在这个方法中，我们根据事件的名称创建一个对象属性，它将保存一个回调函数的数组，当事件被触发时，可以调用这些函数。

在操作现有属性的同时，保持检查以确保您没有针对原型链中的任何现有属性。

假设我们使用**‘on’**方法将*回调 1、回调 2 和回调 3* 附加到一个名为**‘logger’**的事件，我们应该有如下输出:

```
{'logger':[callback1, callback2, callback3 ]}
```

一旦我们发出这个事件，我们应该调用并执行附加到这个事件的所有回调函数，为此我们可以使用如下所示的方法:

当发出一个特定的事件时，我们也可以将一些**信息作为与该事件相关的参数**传递给回调函数。

通常这对于事件处理来说是很好的，但是使用事件处理程序的一个缺点或副作用是，只要代码在运行，全局对象就会一直保持活动状态，并且无论您在事件中附加什么函数，以及通过闭包附加到事件上的数据，都不会被垃圾收集器收集。这里有一个小例子:

这里， **deleteData** 函数重新分配变量 **maindata** ，但是定义的对象仍然通过 **eventhandler** 保持引用，可以通过在任何时候发出事件来检查，如上例所示。

为了避免这样的内存泄漏，我们需要在不需要回调的时候立即删除它们，可以这样做，如下所示:

如果不再需要事件，我们还可以添加一个方法来删除事件属性本身。

喜欢这篇文章吗？如果有，通过 [**订阅获取更多类似内容解码，我们的 YouTube 频道**](https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true) **！**

以上是我的观点，如果你需要一个 npm 包，这里有相同的链接:

[](https://www.npmjs.com/package/mini-event-handler) [## 迷你事件处理程序

### “迷你事件处理程序”为您提供了一个可以用来构造事件处理程序的类。返回的对象是…

www.npmjs.com](https://www.npmjs.com/package/mini-event-handler)