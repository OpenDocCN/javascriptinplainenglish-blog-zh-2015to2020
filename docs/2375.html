<html>
<head>
<title>3 Ways to Prepopulate Your Vue.js Global Store’s State</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">预填充Vue.js全球商店状态的3种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/3-ways-to-prepopulate-your-vue-js-global-stores-state-2fd46e0123a2?source=collection_archive---------5-----------------------#2020-06-18">https://javascript.plainenglish.io/3-ways-to-prepopulate-your-vue-js-global-stores-state-2fd46e0123a2?source=collection_archive---------5-----------------------#2020-06-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/dcad033c7c1157f76558b6c447844ac0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*keUnz7VkHY3IYAf_jWYYSg.jpeg"/></div></div></figure><p id="0039" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当您构建出<a class="ae kw" href="https://vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vue.js </a>应用程序，并且它们开始达到一定的规模时，您可能会遇到全局状态管理的需求。方便的是，核心开发团队为Vue.js应用程序提供了事实上的状态管理库<a class="ae kw" href="https://vuex.vuejs.org/" rel="noopener ugc nofollow" target="_blank"> Vuex </a>。</p><p id="72ca" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">入门非常简单，我假设您已经熟悉了Vuex的实现。这个帖子毕竟不是关于入门的。如果你需要的话，我建议你查看一下<a class="ae kw" href="https://vuex.vuejs.org/" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="e83a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Vuex使管理全局数据存储变得更加简单，对于下面的例子，我们假设我们有一个看起来像这样的存储:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="1b78" class="lg lh iq lc b gy li lj l lk ll">import Vue from 'vue'<br/>import Vuex from 'vuex'</span><span id="5420" class="lg lh iq lc b gy lm lj l lk ll">Vue.use(Vuex)</span><span id="b100" class="lg lh iq lc b gy lm lj l lk ll">const store = new Vuex.Store({<br/>  state: {<br/>    user: null<br/>  },<br/>  mutations: {<br/>    setUser (state, user) {<br/>      state.user = user<br/>    }<br/>  },<br/>})</span></pre><p id="4e09" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">商店的状态以一个空的<code class="fe ln lo lp lc b">user</code>对象和一个可以更新状态的<code class="fe ln lo lp lc b">setUser</code>变异开始。然后，在我们的应用程序中，我们可能希望显示用户的详细信息:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="c8ab" class="lg lh iq lc b gy li lj l lk ll">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;p v-if="user"&gt;Hi {{ user.name }}, welcome back!&lt;/p&gt;<br/>    &lt;p v-else&gt;You should probably log in.&lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="6980" class="lg lh iq lc b gy lm lj l lk ll">&lt;script&gt;<br/>export default {<br/>  computed {<br/>    user() {<br/>      return this.$store.state.user<br/>    }<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="fa9f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，当应用程序加载时，如果用户已经登录，它会向用户显示一条欢迎消息。否则，它会告诉他们需要登录。我知道这是一个微不足道的例子，但是希望您遇到过类似的情况。</p><p id="431d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你像我一样，问题来了:</p><blockquote class="lq lr ls"><p id="aa47" class="jy jz lt ka b kb kc kd ke kf kg kh ki lu kk kl km lv ko kp kq lw ks kt ku kv ij bi translated"><em class="iq">如何在应用加载前将数据添加到我的商店？</em></p></blockquote><p id="8a9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">嗯，有几个选择。</p><h1 id="1932" class="lx lh iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">设置初始状态</h1><p id="5bdf" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">预填充全局存储最简单的方法是在创建存储时设置初始状态:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="4e0b" class="lg lh iq lc b gy li lj l lk ll">import Vue from 'vue'<br/>import Vuex from 'vuex'</span><span id="a915" class="lg lh iq lc b gy lm lj l lk ll">Vue.use(Vuex)</span><span id="3d08" class="lg lh iq lc b gy lm lj l lk ll">const store = new Vuex.Store({<br/>  state: {<br/>    user: { name: "Austin" }<br/>  },<br/>  mutations: {<br/>    setUser (user) {<br/>      state.user = user<br/>    }<br/>  }<br/>})</span></pre><p id="24f8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">显然，这只有在您提前知道用户的详细信息时才有效。当我们构建应用程序时，我们可能不知道用户的名字，但是还有另一个选择。</p><p id="60f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，我们可以利用<code class="fe ln lo lp lc b"><a class="ae kw" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank">localStorage</a></code>来保存用户信息的副本。当他们登录时，您在<code class="fe ln lo lp lc b">localStorage</code>中设置详细信息，当他们登录我们的时，您从<code class="fe ln lo lp lc b">localStorage</code>中删除详细信息。</p><p id="e511" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当应用程序加载时，您可以从<code class="fe ln lo lp lc b">localStorage</code>获取用户详细信息并进入初始状态:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="199b" class="lg lh iq lc b gy li lj l lk ll">import Vue from 'vue'<br/>import Vuex from 'vuex'</span><span id="c03a" class="lg lh iq lc b gy lm lj l lk ll">Vue.use(Vuex)</span><span id="880f" class="lg lh iq lc b gy lm lj l lk ll">const store = new Vuex.Store({<br/>  state: {<br/>    user: localStorage.get('user')<br/>  },<br/>  mutations: {<br/>    setUser (user) {<br/>      state.user = user<br/>    }<br/>  }<br/>})</span></pre><p id="0032" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果您正在处理的数据不需要非常严格的安全限制，那么这种方法非常有效。我推荐使用<code class="fe ln lo lp lc b"><a class="ae kw" href="https://github.com/robinvdvleuten/vuex-persistedstate" rel="noopener ugc nofollow" target="_blank">vuex-persistedstate</a></code>库来帮助实现自动化。</p><p id="0ac2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，您不应该在<code class="fe ln lo lp lc b">localStorage</code>中存储非常敏感的数据，如身份验证令牌，因为它可能成为XSS攻击的目标<a class="ae kw" href="https://codeburst.io/web-storage-and-xss-attacks-4f83b0d08725" rel="noopener" target="_blank">。因此，我们的例子对用户名有效，但对auth token之类的东西无效。这些应该只存储在内存中(仍然可以是Vuex，只是不持久)。</a></p><h1 id="80d3" class="lx lh iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">当应用装载时请求数据</h1><p id="2238" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">现在让我们说，无论出于什么原因，我们不想在<code class="fe ln lo lp lc b">localStorage</code>中存储数据。我们的下一个选择可能是让我们的初始状态为空，并允许我们的应用程序挂载。一旦安装了应用程序，我们可以向服务器发出一些HTTP请求来获取数据，然后更新全局状态:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="895f" class="lg lh iq lc b gy li lj l lk ll">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;p v-if="user"&gt;Hi {{ user.name }}, welcome back!&lt;/p&gt;<br/>    &lt;p v-else&gt;You should probably log in.&lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="9eab" class="lg lh iq lc b gy lm lj l lk ll">&lt;script&gt;<br/>export default {<br/>  computed {<br/>    user() {<br/>      return this.$store.state.user<br/>    }<br/>  },<br/>  async mounted() {<br/>    const user = await getUser() // Assume getUser returns a user object with a name property<br/>    this.$store.commit('setUser', user)<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="c58b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这很好，但现在我们有一个奇怪的用户体验。应用程序将加载并发送请求，但是当用户等待请求返回时，他们会看到“您可能需要登录”当请求返回时，假设他们有一个登录的会话，该消息很快变成“嗨<code class="fe ln lo lp lc b">{{ user.name }}</code>，欢迎回来！”。这种闪光看起来很滑稽。</p><p id="7e9d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要修复这种闪烁，我们可以在请求发出时简单地显示一个加载元素:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="4286" class="lg lh iq lc b gy li lj l lk ll">&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;p v-if="loading"&gt;Loading...&lt;/p&gt;<br/>    &lt;p v-else-if="user"&gt;Hi {{ user.name }}, welcome back!&lt;/p&gt;<br/>    &lt;p v-else&gt;You should probably log in.&lt;/p&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="0b47" class="lg lh iq lc b gy lm lj l lk ll">&lt;script&gt;<br/>export default {<br/>  data: () =&gt; ({<br/>    loading: false<br/>  }),<br/>  computed {<br/>    user() {<br/>      return this.$store.state.user<br/>    }<br/>  },<br/>  async mounted() {<br/>    this.loading = true<br/>    const user = await fetch('/user').then(r =&gt; r.json()) // Assume getUser returns a user object with a name property<br/>    this.$store.commit('setUser', user)<br/>    this.loading = false<br/>  }<br/>}<br/>&lt;/script&gt;</span></pre><p id="d72b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请记住，这是一个非常简单的例子。在您的系统中，您可能有一个用于加载动画的专用组件，并且您可能有一个<code class="fe ln lo lp lc b"><a class="ae kw" href="https://router.vuejs.org/api/#router-view" rel="noopener ugc nofollow" target="_blank">&lt;router-view&gt;</a></code>组件来代替这里的用户消息。您也可以选择从Vuex操作发出HTTP请求。这个概念仍然适用。</p><h1 id="33aa" class="lx lh iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">在应用程序加载前请求数据</h1><p id="b28e" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">我要看的最后一个例子是发出与上一个类似的HTTP请求，但是等待请求返回，并在应用程序有机会加载之前更新存储库。</p><p id="99bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们记住Vuex存储只是一个具有一些属性和方法的对象，我们可以像对待任何其他JavaScript对象一样对待它。</p><p id="8be3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以将我们的存储导入到我们的<code class="fe ln lo lp lc b">main.js</code>文件中(或者您的应用程序的入口点),并在挂载应用程序之前调用我们的HTTP请求:</p><pre class="kx ky kz la gt lb lc ld le aw lf bi"><span id="5ba2" class="lg lh iq lc b gy li lj l lk ll">import Vue from "vue"<br/>import store from "./store"<br/>import App from "./App.vue"</span><span id="9be8" class="lg lh iq lc b gy lm lj l lk ll">fetch('/user')<br/>  .then(r =&gt; r.json())<br/>  .then((user) =&gt; {<br/>    store.commit('setUser', user)<br/>    new Vue({<br/>      store,<br/>      render: (h) =&gt; h(App),<br/>    }).$mount("#app")<br/>  })<br/>  .catch((error) =&gt; {<br/>    // Don't forget to handle this<br/>  })</span></pre><p id="de47" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种方法的好处是，在应用程序加载之前，可以将需要从API获取的数据预加载到全局存储中。这是避免前面提到的janky跳转或管理一些加载逻辑问题的一种便捷方式。</p><p id="0d3f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">然而……</strong></p><p id="b944" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个重要的警告。的确，当HTTP请求挂起时，您不必担心显示加载微调器，但同时，您的应用程序中没有显示任何内容。如果你的应用是一个单页应用，那么你的用户可能会一直盯着一个空白的页面，直到请求返回。</p><p id="c238" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，您并没有真正解决延迟问题，只是决定在等待数据时显示什么样的UI体验。</p><h1 id="cf14" class="lx lh iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">结束语</h1><p id="280b" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">对于哪种方法是最好的，我没有任何硬性规定。实际上，您可以使用这三种方法，这取决于您获取的数据以及您的应用程序的需求。</p><p id="03e5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我还应该提到，虽然我的例子是发出<code class="fe ln lo lp lc b">fetch</code>请求，然后使用Vuex变异直接提交到存储。您可以很容易地使用Vuex动作来实现<code class="fe ln lo lp lc b">fetch</code>。您也可以将这些相同的原则应用于任何其他状态管理工具，比如Vue.observable。</p><p id="c3c5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是现在，如果你有任何意见或问题，请让我知道。<a class="ae kw" href="https://twitter.com/Stegosource" rel="noopener ugc nofollow" target="_blank">推特</a>是联系我的好地方，你可以<a class="ae kw" href="https://3bb5fb5a.sibforms.com/serve/MUIEAAOwgrWtf43Lfv80ES_hibAhazPDEy4w9IxRIda1b8g1GNnmHYkDfvIKG-Ox35EtWkJfMyCMBTQ3nG2msGhc3WnHa7XKfkgBzYdL3ASbIEckbn47QtJDIvpOskWQuRIXYI-7dVuM5F25yKdcJch7VN8aAbrpEn8_PMXWpqENTJ6r9bOZgHj6vnAQwHDsdwXDOZIonAP3x3vx" rel="noopener ugc nofollow" target="_blank">注册时事通讯</a>获取更多类似的更新。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="279f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="lt">原载于</em><a class="ae kw" href="https://austingil.com/3-ways-prepopulate-vue-js-global-stores-state/" rel="noopener ugc nofollow" target="_blank"><em class="lt">https://austingil.com</em></a></p></div></div>    
</body>
</html>