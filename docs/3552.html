<html>
<head>
<title>I Built the Same App With React and Preact. Here are the differences</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我用React和Preact构建了相同的应用程序。以下是不同之处</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/i-built-the-same-app-with-react-and-preact-here-are-the-differences-b0da382a6f72?source=collection_archive---------2-----------------------#2020-10-08">https://javascript.plainenglish.io/i-built-the-same-app-with-react-and-preact-here-are-the-differences-b0da382a6f72?source=collection_archive---------2-----------------------#2020-10-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5549" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及测量的大小、性能和实现</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/c1546d6dea76520ba688614fc292a93e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iRh-PCoI6NflmHD4czgorQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: the author</figcaption></figure><p id="27e5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">听说过<a class="ae lr" href="https://preactjs.com/" rel="noopener ugc nofollow" target="_blank"> Preact </a>吗？这是一个React.js的替代品，它称赞自己小得多，因此速度更快。尽管对React.js的兼容性很高。</p><p id="29b1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想知道Preact到底有多有用，所以我在React.js和Preact中构建了完全相同的应用程序。然后，我在一场公平的竞争中衡量了这两个应用程序的大小、差异和性能。</p><p id="9370" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从使用这两个库时的差异开始，然后我们来看看应用程序代码&amp;测量性能。玩得开心！</p><h1 id="3ee5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">创建反应项目和预反应项目</h1><p id="2f06" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">对于React.js，应该已经知道了:<code class="fe mp mq mr ms b">npm install -g create-react-app</code>和<code class="fe mp mq mr ms b">create-react-app &lt;project-name&gt;</code>，要开始在项目目录中工作，只需<code class="fe mp mq mr ms b">cd /&lt;project-name&gt;</code>——我们开始编辑文件。</p><p id="5e85" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在让我们创建Preact项目:<code class="fe mp mq mr ms b">npm install -g preact-cli</code>，然后是<code class="fe mp mq mr ms b">preact create default &lt;project-name&gt;</code>——默认是我们将要使用的启动模板的名称。</p><h1 id="e2e2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">Preact项目的文件结构</h1><pre class="kg kh ki kj gt mt ms mu mv aw mw bi"><span id="039a" class="mx lt iq ms b gy my mz l na nb">.<br/>├── README.md<br/>├── package-lock.json<br/>├── package.json<br/>├── src<br/>│ ├── assets<br/>│ ├── components<br/>│ ├── index.js<br/>│ ├── manifest.json<br/>│ ├── routes<br/>│ │ ├── home<br/>│ │ │ ├── index.js<br/>│ │ │ └── style.css<br/>│ │ ├── index.js<br/>│ │ └── style.css<br/>│ ├── style<br/>│ ├── sw.js<br/>│ └── template.html</span></pre><p id="3578" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如您所见，Preact中的文件结构本质上要复杂得多。有一个“资源，零部件，管线与样式”文件夹。是的，你没听错——一个routes文件夹，因为路由器默认在板上。</p><p id="ef3f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">HTML模板在源文件夹中保存为<code class="fe mp mq mr ms b">template.html </code>，而不是<code class="fe mp mq mr ms b">public/index.html</code>。</p><h1 id="76bf" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">HTML模板</h1><p id="71e0" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">这个模板是整个React和Preact应用程序构建的HTML外壳。两者语法不同，结构也不同。在React.js中把整个app挂载在<code class="fe mp mq mr ms b">&lt;div id="root"&gt;&lt;/div&gt;</code>中，然而在Preact中，使用了一种模板语言:<br/> <code class="fe mp mq mr ms b">&lt;body&gt; &lt;% preact.bodyEnd %&gt; &lt;/body&gt;</code>。此外，还有对文档头部区域的直接支持。</p><h1 id="019d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用挂钩</h1><p id="28d8" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">当我第一次尝试创建Preact项目时，我在钩子上遇到了一些问题——确保Preact在新版本中。那么他们应该得到支持，没有问题。我使用Preact项目的10.3.2版本和React.js的16.13.1版本</p><p id="b1b8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Preact中的钩子是分开存储的，因此它们的导入需要与React.js中的略有不同:<code class="fe mp mq mr ms b">import { useState } from "preact/hooks"</code>。</p><p id="760a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在React.js: <code class="fe mp mq mr ms b">import { useState } from "react"</code>。</p><h1 id="7457" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">代码</h1><p id="2ebe" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">让我自己感到惊讶的是——我们可以对两个项目使用完全相同的代码。我以为Preact中至少会有一些小的变化，但是没有。因为不同的文件结构，只有导入发生了变化——仅此而已。下面是在React.js和Preact中运行的代码。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">App.js</figcaption></figure><p id="f08c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">下面是代码中发生的事情:</strong></p><ul class=""><li id="2bc2" class="ne nf iq kx b ky kz lb lc le ng li nh lm ni lq nj nk nl nm bi translated">我们为待办事项列表创建一个状态。这个状态将是一个数组。在此之下，我为新todo的输入创建了一个状态。如果在文本字段中输入了内容，第二个状态将被写入此状态。</li><li id="dc1a" class="ne nf iq kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated"><code class="fe mp mq mr ms b">SaveNewTodo</code>函数获取新输入的todo，并将其置于现有todo的状态。这样就可以在不删除现有todoss的情况下扩展todo。</li><li id="319e" class="ne nf iq kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated">JSX部分首先检查todo数组的长度是否为0，即todo列表是否为空。</li><li id="1775" class="ne nf iq kx b ky nn lb no le np li nq lm nr lq nj nk nl nm bi translated">使用map函数，我们从数组中呈现所有的todos。为了有序，每个待办事项前面都有一行。</li></ul><p id="ae63" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这基本上是全部代码。没什么复杂的，但是它很好地显示了React和Preact是多么的兼容。</p><p id="da1f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在React.js和Preact中，index.js中的app组件被导入并呈现。</p><h1 id="6a55" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">基准预测和反应</h1><p id="2af6" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">在这两个应用程序中，我使用了完全相同的CSS代码，还调整了HTML模板，以便完全相同的应用程序应该出来。</p><h2 id="b583" class="mx lt iq bd lu ns nt dn ly nu nv dp mc le nw nx me li ny nz mg lm oa ob mi oc bi translated">应用的大小</h2><p id="fdf9" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Preact宣传自己说它比React.js小得多，这是真的——下面是Network选项卡的结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/384a1f6138b940e556ac6896ffb9fb75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sj6cusVdFo23-Y494jeX1A.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Preact App</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oe"><img src="../Images/881a47125d169650a26cd2f287d1e5fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q1RgJG-D9WHcGxYUlD5RJg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">React.js App</figcaption></figure><p id="24e6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们所看到的，Preact应用程序只有一半大小。</p><h2 id="3e06" class="mx lt iq bd lu ns nt dn ly nu nv dp mc le nw nx me li ny nz mg lm oa ob mi oc bi translated">表演</h2><p id="1f6b" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Preact在这里也是领先的。测试是用Lighthouse录制的，Preset是低端手机。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/b133e980d52892ca3599988fcd6f674e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9S2elXle62rHFg-2pSfdWw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Preact App</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/4f8b1781547ca2ff20f3044a3110b583.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oMMbMAEFs2Lrm_IchskOlQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">React.js App</figcaption></figure><p id="3f63" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Preact在各方面都更胜一筹。这两个应用程序的数字当然都在绿色范围内，因为它不是一个特别复杂的应用程序。</p><p id="2c42" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果您调用摘要，您可以很容易地看到应用程序的整体性能取决于哪些因素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/d66445fd21e4c0265a2d434cc5cf1052.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SY_rXUid2GjiDMF53F3jnA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Preact App</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/1834586a02c607e5c0fc85729a5a70f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8-lx9eGaSv17hYsXXirMQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">React.js App</figcaption></figure><p id="7cfa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">React.js的加载时间逻辑上更长，因为应用程序也更大。在app没有足够加载之前，当然是不能渲染的。此外，引用JavaScript文件的脚本在更大的React应用程序中更复杂，但呈现同样复杂，至少在这个todo list应用程序中是如此。<br/>我认为如果Preact有更快的渲染过程会令人惊讶——但事实并非如此。在另一个基准测试中，我发现Preact的渲染过程更快。</p><div class="kg kh ki kj gt ab cb"><figure class="oi kk oj ok ol om on paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/93f7d2e49204f8cf406a777505e754a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:594/format:webp/1*HOb7ERFiidy0kgHxe-Tr_w.png"/></div></figure><figure class="oi kk oo ok ol om on paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/dffb51b671831d220140e89196573916.png" data-original-src="https://miro.medium.com/v2/resize:fit:612/format:webp/1*O5gaGqfUMZZEEmiEjjkppw.png"/></div></figure><figure class="oi kk op ok ol om on paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><img src="../Images/075063c6909f4277a11d0cfd2dacafe5.png" data-original-src="https://miro.medium.com/v2/resize:fit:796/format:webp/1*8sjVO0OzkaVrmxs-gsKUPg.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk oq di or os">Source: <a class="ae lr" href="https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html" rel="noopener ugc nofollow" target="_blank">https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html</a></figcaption></figure></div><h1 id="0f61" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">总结</h1><p id="fce4" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">Preact在性能方面可能优于React至少对于可以在两个库中实现的应用程序来说是如此。但是你能用Preact做多少事情，用React.js能做什么并不在本文讨论范围之内。值得看一下文档，看看Preact对您的下一个项目是否有意义。</p><p id="b6ec" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="http://eepurl.com/hacY0v" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">加入我的邮件列表保持联系</strong> </a></p><p id="3638" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">关于框架及其性能的更多信息:</p><div class="ot ou gp gr ov ow"><a href="https://medium.com/javascript-in-plain-english/javascript-frameworks-performance-60f71d321693" rel="noopener follow" target="_blank"><div class="ox ab fo"><div class="oy ab oz cl cj pa"><h2 class="bd ir gy z fp pb fr fs pc fu fw ip bi translated">框架永远不会像普通JavaScript那样快</h2><div class="pd l"><h3 class="bd b gy z fp pb fr fs pc fu fw dk translated">在大多数情况下——这很好</h3></div><div class="pe l"><p class="bd b dl z fp pb fr fs pc fu fw dk translated">medium.com</p></div></div><div class="pf l"><div class="pg l ph pi pj pf pk kp ow"/></div></div></a></div></div></div>    
</body>
</html>