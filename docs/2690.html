<html>
<head>
<title>Node.js Tips — Mongoose Find, Script, Shell Commands, and AWS Region</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—mongose查找、脚本、Shell命令和AWS区域</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-mongoose-find-script-shell-commands-and-aws-region-d59b0b48aa13?source=collection_archive---------13-----------------------#2020-07-14">https://javascript.plainenglish.io/node-js-tips-mongoose-find-script-shell-commands-and-aws-region-d59b0b48aa13?source=collection_archive---------13-----------------------#2020-07-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bc8b71d8f7f413b31af46c45116a5470.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*F0KQ8FjD5Cr2mhZn"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">fPhoto by <a class="ae kc" href="https://unsplash.com/@rayhennessy?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ray Hennessy</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d879" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="26a8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将变量从Jade模板文件传递到脚本文件</h1><p id="8eee" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要将Jade模板中的变量传递给脚本，我们可以插入脚本代码。</p><p id="634c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="96a3" class="mn lc iq mj b gy mo mp l mq mr">app.get('/', (req, res) =&gt; {<br/>  res.render( 'index', { layout: false, name: 'bar' } );<br/>});</span></pre><p id="ec50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">index.jade</code></p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f7fd" class="mn lc iq mj b gy mo mp l mq mr">script.<br/>  name="#{name}";</span></pre><p id="4437" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用了<code class="fe ms mt mu mj b">script</code>标签，并在<code class="fe ms mt mu mj b">index.jad</code>中插入了<code class="fe ms mt mu mj b">name</code>变量。</p><h1 id="14fd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">猫鼬选择一个特定的领域与寻找</h1><p id="0868" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过将字段名作为参数传递来选择带有<code class="fe ms mt mu mj b">find</code>的特定字段。</p><p id="f9d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a5fd" class="mn lc iq mj b gy mo mp l mq mr">app.get('/name', (req, res, next) =&gt; {<br/>  dbSchemas.Foo.find({}, 'name', (err, val) =&gt; {<br/>    if(err) {<br/>      return next(err);<br/>    }<br/>    res.send(val);<br/>  });<br/>});</span></pre><p id="0562" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过将字段名作为第二个参数传递来选择一个<code class="fe ms mt mu mj b">Foo</code>文档的<code class="fe ms mt mu mj b">name</code>字段。</p><h1 id="5df1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步瀑布和异步系列的区别</h1><p id="71ec" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">让我们将结果传递给下一个函数。</p><p id="09c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">async.series</code>将所有结果传递给最终回调。</p><h1 id="c35a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为Node.js编写异步函数</h1><p id="fa16" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们编写回调函数，将错误对象的<code class="fe ms mt mu mj b">err</code>和<code class="fe ms mt mu mj b">result</code>作为参数。</p><p id="3e52" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="adb0" class="mn lc iq mj b gy mo mp l mq mr">file.read('/foo.txt', (err, result) =&gt; {<br/>  if (err) {<br/>    return console.log(err);<br/>  }<br/>  doSomething(result);<br/>});</span></pre><p id="0403" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回调之前的参数是我们想在<code class="fe ms mt mu mj b">read</code>中使用的任何参数。</p><p id="04b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回调是一个节点样式的回调，第一个参数是<code class="fe ms mt mu mj b">err</code>对象。</p><p id="1f86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">result</code>有第二个参数的计算结果。</p><h1 id="f041" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Node.js AWS SDK中配置区域</h1><p id="fed7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe ms mt mu mj b">AWS.config.update</code>方法配置AWS区域。</p><p id="65e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="90d8" class="mn lc iq mj b gy mo mp l mq mr">const AWS = require('aws-sdk');<br/>AWS.config.update({ region: 'us-east-1' });</span></pre><p id="19ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">配置该区域。</p><h1 id="7fcf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将参数传递给承诺函数</h1><p id="18f4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了向promise函数传递参数，我们创建了一个函数，它接受我们想要的参数并返回其中的promise。</p><p id="9867" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9245" class="mn lc iq mj b gy mo mp l mq mr">const login = (username, password) =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    //...<br/>    if (success) {<br/>      resolve("success");<br/>    } else {<br/>      reject(new Error("error"));<br/>    }<br/>  });<br/>}</span></pre><p id="cb24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们通过使用<code class="fe ms mt mu mj b">Promise</code>构造函数返回承诺。</p><p id="4394" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">username</code>和<code class="fe ms mt mu mj b">password</code>是我们传入的参数。</p><p id="a9ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f09d" class="mn lc iq mj b gy mo mp l mq mr">login(username, password)<br/>  .then(result =&gt; {<br/>    console.log(result);<br/>  })</span></pre><p id="484b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe ms mt mu mj b">then</code>来获取传递给<code class="fe ms mt mu mj b">resolve</code>的值。</p><h1 id="5794" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Node.js执行Shell命令</h1><p id="0dae" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要在节点应用程序中运行shell命令，我们可以使用<code class="fe ms mt mu mj b">child_process</code>模块。</p><p id="812b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2651" class="mn lc iq mj b gy mo mp l mq mr">const spawn = require('child_process').spawn;<br/>const child = spawn('ls', ['-l']);<br/>let resp = "";</span><span id="e4c1" class="mn lc iq mj b gy mv mp l mq mr">child.stdout.on('data', (buffer) =&gt; { <br/>  resp += buffer.toString() <br/>});</span><span id="b814" class="mn lc iq mj b gy mv mp l mq mr">child.stdout.on('end', () =&gt; { <br/>  console.log(resp) <br/>});</span></pre><p id="90cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe ms mt mu mj b">child_process</code>的<code class="fe ms mt mu mj b">spawn</code>方法。</p><p id="6fae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将命令作为第一个参数传递给<code class="fe ms mt mu mj b">spawn</code>。</p><p id="1e8f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">命令行参数作为第二个参数。</p><p id="ea0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe ms mt mu mj b">child.stdout.on</code>方法观察结果。</p><p id="3931" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们监听<code class="fe ms mt mu mj b">'data'</code>事件以获得输出，并连接发送的部分。</p><p id="7a54" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当它结束时，我们听<code class="fe ms mt mu mj b">'end'</code>来得到整个结果。</p><h1 id="e979" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">监控Node.js应用程序的内存使用情况</h1><p id="3334" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用node-memwatch包来监视节点应用程序的内存使用情况。</p><p id="b668" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过运行以下命令来安装它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="bb25" class="mn lc iq mj b gy mo mp l mq mr">npm install memwatch</span></pre><p id="4dbb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7323" class="mn lc iq mj b gy mo mp l mq mr">const memwatch = require('memwatch');<br/>memwatch.on('leak', (info) =&gt; { <br/>  //...<br/>});</span></pre><p id="1947" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe ms mt mu mj b">on</code>方法来监视内存泄漏。</p><p id="055e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">info</code>有关于泄密的信息。</p><p id="2760" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它大概是这样的:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="59cd" class="mn lc iq mj b gy mo mp l mq mr">{ <br/>  start: Fri, 29 Jun 2020 15:12:13 GMT,<br/>  end: Fri, 29 Jun 2020 16:12:33 GMT,<br/>  growth: 67984,<br/>  reason: 'heap growth over 5 consecutive GCs (20s) - 11.67 mb/hr' <br/>}</span></pre><p id="619d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它将向我们展示内存使用的增长。</p><p id="3310" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一些方法可以观察堆的使用情况，并区分不同时间的内存使用情况。</p><p id="7578" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">内置的<code class="fe ms mt mu mj b">process</code>模块有<code class="fe ms mt mu mj b">memoryUsage</code>方法来获取我们app的内存使用情况。</p><p id="dc80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7380" class="mn lc iq mj b gy mo mp l mq mr">process.memoryUsage();</span></pre><p id="9db3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来获取内存使用情况。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/ae008e33cf21c5387105bf3d6bb5be08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nHm8hSvFV33kvRni"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@karaozgur?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ozgur Kara</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2d93" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="6451" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过<code class="fe ms mt mu mj b">process</code>模块或第三方模块观察内存使用情况。</p><p id="1c25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了将数据传递给Jade模板中的脚本标记，我们可以插入代码。</p><p id="4220" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想要一个带有自己参数的承诺，我们可以在函数中返回一个承诺。</p><p id="e054" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Mongoose可以用来查找给定字段的数据。</p></div></div>    
</body>
</html>