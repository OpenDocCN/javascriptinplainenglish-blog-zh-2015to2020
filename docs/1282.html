<html>
<head>
<title>The Definitive Guide to React Class vs Functional Components.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React类与功能组件的权威指南。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-definitive-guide-to-react-class-vs-functional-components-481b1157ed08?source=collection_archive---------3-----------------------#2020-02-24">https://javascript.plainenglish.io/the-definitive-guide-to-react-class-vs-functional-components-481b1157ed08?source=collection_archive---------3-----------------------#2020-02-24</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="dec6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">* *以下信息是来自Dan Abramov、Sophie Alpert和React文档的信息汇总。** </em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/206a490f002a46a219472161a02ae4b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*NwQQN_YPRu7QskBM.png"/></div></div></figure><h1 id="24c7" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">A.演示:类组件的主要问题</h1><p id="eca7" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">请打开此codesandbox链接到侧面:<a class="ae ly" href="https://codesandbox.io/s/classvsfunctional-0g863" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/classvsfunctional-0g863</a>并执行以下操作:</p><ol class=""><li id="584f" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated">在丹的个人资料中，<strong class="jm io">点击</strong>的“关注(班级)”按钮。</li><li id="d86c" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">在3秒钟内，<strong class="jm io">使用页面顶部的下拉菜单将</strong>用户资料更改为Sophie。</li><li id="3354" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">警告文本<strong class="jm io">错误地</strong>显示为“跟随索菲”</li></ol><p id="07a0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你用“跟随(功能)”按钮重复上述步骤，警报文本应该<strong class="jm io">正确地</strong>读作“跟随丹”<br/> <br/>让我们仔细看看我们的类组件中的<code class="fe mn mo mp mq b">showMessage</code>方法:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/60866d96457818003ff320020b93cd47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*cSSgONSYkzZKAkdydjpXVw.png"/></div></figure><p id="7c9e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个类方法从<code class="fe mn mo mp mq b">this.props.user</code>中读取。道具在React中应该被视为不可变，不应该直接变异。然而，JavaScript中的<code class="fe mn mo mp mq b">this</code>一直是可变的。如果您回到codesandbox示例并查看ProfilePageClass.js中的构造函数，您会注意到<code class="fe mn mo mp mq b">showMessage</code>函数的<code class="fe mn mo mp mq b">this</code>上下文已经被绑定(因此这不是bug的原因)。当类组件在绑定到类组件的<code class="fe mn mo mp mq b">this</code>上下文的请求完成之前重新呈现时，就会出现问题。<code class="fe mn mo mp mq b">showMessage</code>回调没有绑定到任何特定的渲染，因此会丢失正确的属性。</p><h1 id="6535" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">这个问题可以用两种方法解决:</h1><p id="94d0" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated"><strong class="jm io">选项1) </strong>早读<code class="fe mn mo mp mq b">this.props</code>，将提取的值显式传递给回调函数:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/0975ca9f792949889f843b3a828285b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*7T28tlr6KRNt4WZqxCOV1g.png"/></div></figure><p id="f795" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，这种方法使代码更加冗长，增加了复杂性，特别是如果<code class="fe mn mo mp mq b">showMessage</code>函数还调用了<code class="fe mn mo mp mq b">this.props</code>中包含的不同函数。<br/> <br/> <br/> <strong class="jm io">选项2) </strong>渲染时使用闭包捕捉道具:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/3884b5a4f682e8d26f071fbc1e5f2025.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*5KdanLgqMdS_vMD2PkwFiA.png"/></div></figure><p id="e819" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过这种方式，它里面的任何代码(包括<code class="fe mn mo mp mq b">showMessage</code>)都可以保证看到特定渲染的正确道具。如果我们通过删除代码周围的类“shell”来简化代码，它就变成了:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/73da118de05287b1892416e71bef5b81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*sPf9zt9P2_ssfAKNC-kefQ.png"/></div></figure><h2 id="2958" class="ms kw in bd kx mt mu dn lb mv mw dp lf jv mx my lj jz mz na ln kd nb nc lr nd bi translated">类组件和功能组件的最大区别是功能组件在渲染时捕获道具。</h2><p id="1cb9" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">为了使用<strong class="jm io">有状态</strong>功能组件，需要React 16.8+和React钩子的使用。</p><h1 id="e960" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">B.对有状态组件使用钩子的优点</h1><h2 id="81d5" class="ms kw in bd kx mt mu dn lb mv mw dp lf jv mx my lj jz mz na ln kd nb nc lr nd bi translated">1)避免组件层次结构的不必要嵌套</h2><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/247892c55654b02cf759931c82930fa0.png" data-original-src="https://miro.medium.com/v2/resize:fit:686/format:webp/1*B4OgEw-tB51pH0qxVL3Ung.png"/></div></figure><p id="a333" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">(vanilla) React中跨组件共享代码的主要模式是上下文API、高阶组件和呈现道具模式的组合。这些模式在某些情况下很好，但是也有不好的一面，为了使用它们，你必须重组你的组件。在更复杂的情况下，这会导致“包装地狱”，组件树变得非常嵌套。这使得很难通过应用程序跟踪数据流。</p><p id="4f80" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的代码片段显示了类和功能组件的常见用例的并排比较，其中主题和区域设置被提供给组件。在类组件的例子中，每次我们通过<code class="fe mn mo mp mq b">Context.Consumer</code>访问主题和区域设置时，都会出现一个额外的嵌套层(它将在整个应用程序的组件中重复)。而在功能组件的例子中，没有嵌套，因为我们现在可以使用<code class="fe mn mo mp mq b">useContext</code>钩子。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nf"><img src="../Images/401070427bc2dce3dcce2db5bad23a2d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AyBK2204KaDmahGBs81KwQ.png"/></div></div></figure><h2 id="424e" class="ms kw in bd kx mt mu dn lb mv mw dp lf jv mx my lj jz mz na ln kd nb nc lr nd bi translated">2)更容易跨组件重用逻辑</h2><p id="bfb8" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">类组件通过生命周期方法管理副作用。正因为如此，每一个单独的任务都必须被拆分成不同的生命周期方法。相比之下，我们可以根据功能组件的功能对副作用进行分组。<br/> <br/> <em class="ki">管理副作用的类组件示例:</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ng"><img src="../Images/a670e2e22784d0f7ae310ecacaa40b0d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kKODQTgGEUD_gyBsEocFIg.png"/></div></div></figure><p id="d90b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有几点需要注意:</p><ul class=""><li id="686e" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh nh mf mg mh bi translated">设置和更新<code class="fe mn mo mp mq b">document.title</code>的代码是重复的，因为类组件迫使我们在组件生命周期中分割逻辑。</li><li id="6294" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh nh mf mg mh bi translated">在<code class="fe mn mo mp mq b">componentDidMount()</code>中，我们有两个不相关的方法，这使得孤立地测试它们变得更加困难。</li></ul><p id="9cfd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="ki">管理副作用的功能组件示例:</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ng"><img src="../Images/7e7350442bf8a2363e6832dee56d2c44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6kr_qZtTYx6fJ9k7ckG4Mw.png"/></div></div></figure><p id="cea4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过使用钩子和将我们的副作用按功能分组，以上两个问题就解决了。此外，因为<code class="fe mn mo mp mq b">useEffect()</code>只是一个函数，<strong class="jm io">我们现在可以提取它并创建一个定制的钩子来跨组件重用。</strong></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ni"><img src="../Images/038c55a92ae90f176c3d5f0cd719d3fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fO04B7PVcIsKRQ14pYVazw.png"/></div></div></figure><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi ni"><img src="../Images/03c7dedfd9f0c1e79b8abb0f659c9a3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rEapW0yrvdQmupJUQeI-Sg.png"/></div></div></figure><p id="06c8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过钩子，我们还可以提取和重用常见的事件处理程序:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nj"><img src="../Images/259ea79302fa294fdf34ebd2a9f10695.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_B2aLTtE0hyQ3P4iLbr1pQ.png"/></div></div></figure><p id="17a5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">提取它们之后，我们现在可以在功能组件中使用它们，如下所示:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi nk"><img src="../Images/b294c8943c0a688eb99aa69f3a7e4489.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*V_3M1aSDVO3De55NEug-NA.png"/></div></div></figure><h2 id="6cc0" class="ms kw in bd kx mt mu dn lb mv mw dp lf jv mx my lj jz mz na ln kd nb nc lr nd bi translated">3)开发人员和编译器的开销更少</h2><p id="099b" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">有了功能组件的使用，开发人员不需要像第一节中提到的那样担心在渲染时捕获道具，也不需要担心<code class="fe mn mo mp mq b">this</code>上下文的改变和绑定。另外，<strong class="jm io">React编译器不能像优化功能组件那样完全优化类组件</strong>。虽然性能差异并不显著，但随着代码库的增长，这种差异会越来越大。其他需要注意的是，React编译器不能完全缩小类组件，并且热重载对于类组件来说不太可靠。</p><h1 id="bd47" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">C.其他考虑</h1><p id="86ca" class="pw-post-body-paragraph jk jl in jm b jn lt jp jq jr lu jt ju jv lv jx jy jz lw kb kc kd lx kf kg kh ig bi translated">1)钩子覆盖了类的绝大多数常见用例。目前还没有与<code class="fe mn mo mp mq b">getSnapshotBeforeUpdate()</code>或<code class="fe mn mo mp mq b">componentDidCatch</code>生命周期方法等价的方法，但是React团队正在努力在不久的将来将它们包含进来。一些第三方库目前可能与钩子不兼容。但是，大多数广泛使用的库都支持钩子，因为类组件和函数组件可以在同一个应用程序中使用，所以这可能不是问题。<br/> 3)在函数组件中，所有的函数声明都是在重新呈现时重新创建的，而在类组件中，函数存储在类的原型中。这是一个可以忽略的性能差异，功能组件的整体性能比类组件略好(即使这是非常小的，性能也不是使用钩子的主要优势)。</p><h2 id="bdec" class="ms kw in bd kx mt mu dn lb mv mw dp lf jv mx my lj jz mz na ln kd nb nc lr nd bi translated">建议:对于新的开发，使用功能组件代替类组件，原因如下:</h2><ul class=""><li id="aed2" class="lz ma in jm b jn lt jr lu jv nl jz nm kd nn kh nh mf mg mh bi translated">在渲染时捕获道具</li><li id="55e8" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh nh mf mg mh bi translated">更扁平的组件层次结构树和更简单的组件代码</li><li id="bc21" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh nh mf mg mh bi translated">通过定制挂钩&lt;= biggest benefit</li></ul><p id="ffec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">For an existing codebase, it is <strong class="jm io">轻松地跨组件重用逻辑</strong>不是高优先级将类组件转换为功能组件，除了代码库的标准化。</p><p id="7cc1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有关更多信息:</p><ul class=""><li id="3fd8" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh nh mf mg mh bi translated"><a class="ae ly" href="https://overreacted.io/how-are-function-components-different-from-classes/" rel="noopener ugc nofollow" target="_blank">https://overreated . io/how-are-function-components-different-from-classes/</a></li><li id="3cfa" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh nh mf mg mh bi translated"><a class="ae ly" href="https://www.youtube.com/watch?v=dpw9EHDh2bM" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=dpw9EHDh2bM</a></li><li id="609b" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh nh mf mg mh bi translated"><a class="ae ly" href="https://reactjs.org/docs/hooks-faq.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/hooks-faq.html</a></li></ul></div></div>    
</body>
</html>