<html>
<head>
<title>Decorators between Class-based and Prototype-based programming languages</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">基于类和基于原型的编程语言之间的装饰器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/decorators-between-class-based-and-prototype-based-programming-languages-ee8a1c854411?source=collection_archive---------8-----------------------#2020-04-04">https://javascript.plainenglish.io/decorators-between-class-based-and-prototype-based-programming-languages-ee8a1c854411?source=collection_archive---------8-----------------------#2020-04-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/06c49226e173aabc7d7f488390aee37d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FxfyQ0xTNIqXw86ADPC1cA.jpeg"/></div></div></figure><div class=""/><p id="9dc8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">OOP和原型语言之间的区别集中在重用原则(称为继承)上，它是通过基于原型的编程语言中重用对象的过程(称为原型继承)和重用对象类或对象蓝图的过程(称为类继承)来实现的。</p><p id="89db" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">装饰器是一种设计模式，它允许以动态方式将行为添加到对象中，而不必更改该对象的实现。装饰器被认为是<strong class="ka jc">结构设计模式</strong>。一个重要的注意事项是，装饰器遵循<strong class="ka jc">开闭原则</strong>。</p><p id="c7f7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">基于类的编程语言和基于原型的编程语言实现装饰模式是不同的，因为它们的本质不同。我将在本文中讨论用Javascript和C#编程语言实现装饰模式。并考虑一些现实生活场景来使用它们。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="277b" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">C#中的装饰器</h1><p id="b5f4" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">C#中的装饰器可以用两种方法来应用:</p><p id="e31f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">1-从目标类继承并有一个setter方法来设置装饰器中目标类实例，或者通过构造函数绕过目标类作为装饰器类的依赖项。然后在被覆盖的函数中，我们调用带有附加修饰的目标类函数。下一个UML解释说:</p><figure class="mh mi mj mk gt is gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/94d0b5c3ff1aa506a6ef00e95573794e.png" data-original-src="https://miro.medium.com/v2/resize:fit:862/1*kg5OXYrKTMse-1AUH7MJrQ.gif"/></div></figure><p id="3b4a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">该图摘自:</p><div class="ip iq gp gr ir ml"><a href="https://www.dofactory.com/net/decorator-design-pattern" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jc gy z fp mq fr fs mr fu fw ja bi translated">装饰者</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">动态地将附加责任附加到对象上。装饰者为子类化提供了一个灵活的选择…</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">www.dofactory.com</p></div></div><div class="mu l"><div class="mv l mw mx my mu mz ix ml"/></div></div></a></div><p id="e4fa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可以通过这个链接了解更多关于装饰的方法。</p><p id="1ef1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">2-使用C#属性来简化其用法。ASP.NET Web API中装饰器非常著名的例子是HTTP动词装饰器，它是用C#属性设计的，用来装饰控制器动作，当它被调用时被缩短为一个特定的HTTP动词。请注意，装饰不会自动添加到目标类函数中，但是应该存在另一个组件，它会在调用目标函数之前或之后，或者在初始化类之前或之后调用装饰函数。该组件将使用反射来检测这些装饰器(属性)。</p><p id="7e2d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，我在使用属性装饰器的职业生涯中遇到的另一个例子是在Web API动作上使用授权属性，如下所示:</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Example of Decorations through C# Attributes</figcaption></figure><h1 id="1fa5" class="ld le jb bd lf lg ng li lj lk nh lm ln lo ni lq lr ls nj lu lv lw nk ly lz ma bi translated">Javascript中的装饰器</h1><p id="dc34" class="pw-post-body-paragraph jy jz jb ka b kb mb kd ke kf mc kh ki kj md kl km kn me kp kq kr mf kt ku kv ij bi translated">Javascript中的Decorators只是编写一个函数，通过扩展其功能来修改特定类或方法的原型。</p><p id="cd84" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">从下一篇文章中，您可以确切地知道它在ES5中的样子:</p><div class="ip iq gp gr ir ml"><a href="https://medium.com/better-programming/learn-about-decorators-in-javascript-d19c8795e8a" rel="noopener follow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jc gy z fp mq fr fs mr fu fw ja bi translated">了解JavaScript中的装饰器</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">用漂亮的增强装饰你的代码</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">medium.com</p></div></div><div class="mu l"><div class="nl l mw mx my mu mz ix ml"/></div></div></a></div><p id="7266" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">而且只是关于下面的功能:</p><pre class="mh mi mj mk gt nm nn no np aw nq bi"><span id="36d3" class="nr le jb nn b gy ns nt l nu nv"><strong class="nn jc">function</strong> <strong class="nn jc">decoratorName</strong>(target) { // do something with ‘target’ … }</span></pre><p id="39a3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ES6函数装饰器是一个表达式，它返回函数并接受一个目标(静态成员的类的构造函数或实例成员的类的原型)、成员名和属性描述符作为参数。</p><p id="2c8c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">ES6类装饰器应用于类的构造函数，可以用来观察、修改或替换类定义。class decorator的表达式将在运行时作为一个函数调用，被修饰类的构造函数是它唯一的参数。</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Example of Class decorator</figcaption></figure><p id="51be" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当<code class="fe nw nx ny nn b">@sealed</code>被执行时，它将密封构造函数和它的原型。</p><p id="6af9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">装饰器的另一个例子是delay decorator:</p><figure class="mh mi mj mk gt is"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Example of Function decorator</figcaption></figure><p id="6ae3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在撰写本文时，ES6中的decorators还处于试验阶段，可能会随着时间的推移而改变，但是在Babel中，虽然它是TypeScript中的一个原生特性，但您需要做一些配置来启用它。</p><p id="debd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Angular大量使用decorator，您可以查看下一篇文章，了解该框架中所有可用的decorator:</p><div class="ip iq gp gr ir ml"><a href="https://medium.com/@madhavmahesh/list-of-all-decorators-available-in-angular-71bdf4ad6976" rel="noopener follow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jc gy z fp mq fr fs mr fu fw ja bi translated">Angular中所有可用的@ Decorators列表</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">Angular中所有装饰器的列表及其用法。</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">medium.com</p></div></div><div class="mu l"><div class="nz l mw mx my mu mz ix ml"/></div></div></a></div><p id="f918" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在撰写本文时，ES6中的decorators还处于试验阶段，可能会随着时间的推移而改变，但是在Babel中，虽然它是TypeScript中的一个原生特性，但您需要做一些配置来启用它。</p><p id="4d86" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一本非常好的读物，关于Javascript中装饰者的更多细节，你可以点击下一个链接:</p><div class="ip iq gp gr ir ml"><a href="https://itnext.io/a-minimal-guide-to-ecmascript-decorators-55b70338215e" rel="noopener  ugc nofollow" target="_blank"><div class="mm ab fo"><div class="mn ab mo cl cj mp"><h2 class="bd jc gy z fp mq fr fs mr fu fw ja bi translated">ECMAScript装饰器和对象属性描述符的简明指南</h2><div class="ms l"><h3 class="bd b gy z fp mq fr fs mr fu fw dk translated">对JavaScript中“装饰者”提议的简短介绍，包括基本示例和一点关于ECMAScript的内容</h3></div><div class="mt l"><p class="bd b dl z fp mq fr fs mr fu fw dk translated">itnext.io</p></div></div><div class="mu l"><div class="oa l mw mx my mu mz ix ml"/></div></div></a></div></div></div>    
</body>
</html>