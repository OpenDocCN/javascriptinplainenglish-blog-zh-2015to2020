<html>
<head>
<title>A Redux walkthrough for beginners</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">面向初学者的Redux演练</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/redux-walkthrough-b11dbfb48d61?source=collection_archive---------3-----------------------#2019-10-07">https://javascript.plainenglish.io/redux-walkthrough-b11dbfb48d61?source=collection_archive---------3-----------------------#2019-10-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="a365" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在React世界中，状态管理已经走过了漫长的道路。我们可以在组件级、Redux或React钩子上使用本地状态。我学习了组件级和Redux的本地状态，并在我的辅助项目中实现了它们。在我学习Redux期间，我理解了每个概念的作用，但不理解它的整体流程。每当我学习一个新的Redux概念时，我都练习键入必要的代码，直到它成为肌肉记忆但未能看到全貌。每个概念是如何融入Redux的整体范围的？</p><p id="23f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在我们开始这篇博客的其余部分之前，我想对我的技术教练Jeff说一声，因为他对Redux的评论减轻了我99.9%的困惑。</p><p id="6469" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">请注意:</strong>本演练并不是关于Redux机制的详尽自述。这意味着从头到尾展示Redux本身的整体实现，以及概念之间的联系。这也是我理解Redux帮助我记忆的方式。你可能有的任何问题都可以在<a class="ae ki" href="https://react-redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux文档</a>中找到。</p><h1 id="6fbc" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">安装Redux和React-Redux</h1><p id="b317" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">为了开始演练，我们需要安装Redux和React-Redux。根据Redux文档:</p><blockquote class="lm ln lo"><p id="eeeb" class="jk jl lp jm b jn jo jp jq jr js jt ju lq jw jx jy lr ka kb kc ls ke kf kg kh ig bi translated">React Redux 7.1需要React 16.8.3或更高版本。</p><p id="32aa" class="jk jl lp jm b jn jo jp jq jr js jt ju lq jw jx jy lr ka kb kc ls ke kf kg kh ig bi translated">要在React应用程序中使用React Redux:</p></blockquote><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="2e83" class="mc kk in ly b gy md me l mf mg">npm install react-redux</span></pre><p id="4131" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还需要安装redux:</p><pre class="lt lu lv lw gt lx ly lz ma aw mb bi"><span id="5034" class="mc kk in ly b gy md me l mf mg">npm install redux</span></pre><p id="0166" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">到目前为止，一切顺利。</p><h1 id="4146" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">冗余流量</h1><p id="c585" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">在我们开始实现Redux之前，对Redux流有一个整体的了解是有益的。理解这个流程帮助我理解了逻辑是如何以及为什么从A点到b点的。</p><p id="caa8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">以下是Redux流程的流程图:</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/c55cf8d46d4c78dc6bc153603aef6301.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*WnvpoWw797mw9HnnVXq9Ww.jpeg"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk">Redux Flow Chart</figcaption></figure><p id="2cc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">不要担心一开始会有很多东西需要接受。随着博客的深入，流程图的适用部分将会突出显示。当我们沿着流程图往下走时，会有截图和要点的混合。截屏的目的是展示文件结构，这是我在使用Redux时学到的最佳实践。</p><p id="9830" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在演练中，我将制作一份购物清单。这是我在技术面试中看到并要求做的一个很常见的例子。我知道使用组件状态管理将会更加有效和简单，因为这是一个单页面应用程序，但是它没有忽略Redux将会实现相同结果的事实。</p><h1 id="9a24" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">创建和链接Redux存储</h1><p id="2e64" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">让我们从流程图的顶部开始。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/c10df2db2422af7ccf782199d9aa52ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*W3MZnYTy6MbSw4Pyj36kKA.jpeg"/></div></figure><p id="0a9f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您可以将Redux和应用程序视为两个独立的实体。应用程序的状态存在于Redux存储中，而应用程序不直接知道它的状态，这与组件状态管理不同。为了桥接Redux和应用程序，从React-Redux库中导入提供者组件(如第6行所示)并将应用程序包装在一个<code class="fe mp mq mr ly b">&lt;Provider /&gt;</code>标记中(如第13–15行所示)。我们还将<code class="fe mp mq mr ly b">store</code>属性设置为在第10行创建的store变量。</p><figure class="lt lu lv lw gt mi"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f679" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">根据<a class="ae ki" href="https://react-redux.js.org/api/provider" rel="noopener ugc nofollow" target="_blank">文件</a>，</p><blockquote class="lm ln lo"><p id="49a7" class="jk jl lp jm b jn jo jp jq jr js jt ju lq jw jx jy lr ka kb kc ls ke kf kg kh ig bi translated"><code class="fe mp mq mr ly b">&lt;Provider /&gt;</code>使Redux <code class="fe mp mq mr ly b">store</code>对任何已经被包装在<code class="fe mp mq mr ly b">connect()</code>函数中的嵌套组件可用。</p><p id="3221" class="jk jl lp jm b jn jo jp jq jr js jt ju lq jw jx jy lr ka kb kc ls ke kf kg kh ig bi translated">由于React Redux应用程序中的任何React组件都可以连接，大多数应用程序将在顶层呈现一个<code class="fe mp mq mr ly b">&lt;Provider&gt;</code>，整个应用程序的组件树都在其中。</p><p id="4f5d" class="jk jl lp jm b jn jo jp jq jr js jt ju lq jw jx jy lr ka kb kc ls ke kf kg kh ig bi translated">通常，您不能使用连接的组件，除非它嵌套在<code class="fe mp mq mr ly b">&lt;Provider&gt;</code>中。</p></blockquote><p id="1780" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么<code class="fe mp mq mr ly b">createStore</code>和<code class="fe mp mq mr ly b">groceryListReducer</code>呢？</p><p id="4485" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">一个<code class="fe mp mq mr ly b">store</code>是Redux保存应用程序状态的地方。这意味着存储可以同时保存多个不同的状态。当应用程序扩展并在多个不同的组件上有多个不同的状态时，这尤其有用。注意Redux应该只有<strong class="jm io"> <em class="lp">一个</em> </strong>店铺。</p><p id="d9c5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mp mq mr ly b">createStore</code>创建一个新的<code class="fe mp mq mr ly b">store</code>，其中您必须至少在其参数中传递一个reducing函数。该减少功能应返回基于该动作的新状态。(本演练稍后将详细讨论这些操作)。我在第7行导入了<code class="fe mp mq mr ly b">createStore</code>函数，在第10行创建了一个新商店，并在创建新商店时将<code class="fe mp mq mr ly b">groceryListReducer</code>作为参数传递。</p><p id="af84" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mp mq mr ly b">groceryListReducer</code>是我创建的一个减速器函数。这是在第8行导入的，用作<code class="fe mp mq mr ly b">createStore</code>的参数。通常reducer函数包含在它们自己的文件夹中。下面是我在其他应用程序和<code class="fe mp mq mr ly b">groceryListReducer</code>功能中使用Redux时使用的文件夹结构截图。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mu"><img src="../Images/c94bb9235d2c7baa16a0320a2baca3b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2WRE2mqx-BmDTE8oCHrSDQ.png"/></div></div></figure><p id="3472" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在不要担心<code class="fe mp mq mr ly b">groceryListReducer</code>函数做什么。这个截屏的目的是显示文件结构和reducer函数的存在，以便创建商店。我们将在讨论<code class="fe mp mq mr ly b">mapDispatchToProps</code>时深入探讨。</p><h1 id="205d" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">mapStateToProps</h1><p id="cf95" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">让我们看看流程图的左分支。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/84e18c4fb06e62de22760530ac850f8b.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*fW9M3IySOLr_Cm3onp6u5w.jpeg"/></div></figure><p id="5d42" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mp mq mr ly b">mapStateToProps</code>是一个函数，它接受一个参数，传统上称为状态，并返回一个对象。返回的对象将作为道具包含在调用<code class="fe mp mq mr ly b">mapStateToProps</code>的组件中。下面是实现<code class="fe mp mq mr ly b">mapStateToProps</code>之前App.js文件的要点。</p><figure class="lt lu lv lw gt mi"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="007a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果您按原样运行，下面的屏幕截图将显示在窗口和控制台中:</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mz"><img src="../Images/32d0f232339ec94390effbc599d8899d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pzFNTbFKw3wQHYZgsHAJCw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk">Before Implementing mapStateToProps</figcaption></figure><p id="bf91" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们创建<code class="fe mp mq mr ly b">mapStateToProps</code>函数并在应用程序中实现它(第15–19行)。</p><figure class="lt lu lv lw gt mi"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="1ab0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是创建<code class="fe mp mq mr ly b">mapStateToProps</code>函数后的窗口和控制台截图:</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mz"><img src="../Images/6fb275058a40d35537044b33393a0344.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EWZSxU8vtTCYKHsubD4Hzg.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk">After Implementing mapStateToProps</figcaption></figure><p id="fe68" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是等等…道具里没有还原状态。怎么回事？</p><p id="ff13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是因为Redux存储与组件本身之间没有连接。为了让组件连接到Redux存储，组件需要用<code class="fe mp mq mr ly b">connect()</code>函数包装。</p><p id="49e1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可能想知道，<code class="fe mp mq mr ly b">&lt;Provider /&gt;</code>和<code class="fe mp mq mr ly b">connect() </code>函数有什么区别？为了简化起见，<code class="fe mp mq mr ly b">&lt;Provider /&gt;</code>让组件<strong class="jm io"> <em class="lp">访问</em> </strong>到Redux存储(就像看门人一样),而<code class="fe mp mq mr ly b">connect()</code>函数是Redux存储和组件之间的桥梁，或者说<strong class="jm io"> <em class="lp">连接</em> </strong>离子。</p><p id="9cc9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于<code class="fe mp mq mr ly b">connect()</code>函数的深入解释，您可以阅读它的<a class="ae ki" href="https://react-redux.js.org/api/connect" rel="noopener ugc nofollow" target="_blank">文档</a>，但是出于本演练的目的，要知道它是一个<a class="ae ki" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank">高阶组件</a>，它最多接受两个参数<code class="fe mp mq mr ly b">mapStateToProps</code>和/或<code class="fe mp mq mr ly b">mapDispatchToProps</code>。第一个参数指向<code class="fe mp mq mr ly b">mapStateToProps</code>，第二个参数指向<code class="fe mp mq mr ly b">mapDispatchToProps</code>。</p><p id="c7b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们对<code class="fe mp mq mr ly b">connect()</code>有了一个大致的了解，让我们将它实现到应用程序中。</p><figure class="lt lu lv lw gt mi"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6d6f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在第4行中，<code class="fe mp mq mr ly b">connect()</code>函数是从React-Redux导入的。在第25行中，<code class="fe mp mq mr ly b">connect()</code>函数用<code class="fe mp mq mr ly b">mapStateToProps </code>函数包装了App组件。下面的截图是实现<code class="fe mp mq mr ly b">connect()</code>功能后的窗口和控制台。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mz"><img src="../Images/1a7c0adae1b55657d48447fb138258b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nkz64jO1LVxXlB1VvbfKUw.png"/></div></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk">Implemented Connect Function</figcaption></figure><p id="0594" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">万岁！我们的道具终于有了还原状态！我们现在可以像操作React组件中的任何其他属性一样操作这个属性中的数据。</p><p id="6af7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但是国家从何而来？</p><h1 id="8bed" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">减速器功能中的状态</h1><p id="7d44" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">这是从我们的<code class="fe mp mq mr ly b">groceryListReducer</code>传来的！</p><figure class="lt lu lv lw gt mi"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="ml mm gj gh gi mn mo bd b be z dk">Grocery List Reducer Function</figcaption></figure><p id="88db" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上面的要旨与“创建和链接Redux Store”一节中提到的reducer函数截图相同。<code class="fe mp mq mr ly b">state</code>的默认值是对象<code class="fe mp mq mr ly b">{currentItems: [‘bananas’, ‘cereal’, ‘bread’, ‘milk’]}</code>。</p><p id="8d61" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">这个状态，或者说这个减速器功能的第一个自变量，就是</strong> <code class="fe mp mq mr ly b"><strong class="jm io">mapStateToProps</strong></code> <strong class="jm io">功能所指的地方。</strong></p><p id="516d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然这个演练有点操之过急，但下面的流程图突出了<code class="fe mp mq mr ly b">mapStateToProps</code>、减速器功能和组件道具之间的相关性。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/6982b18505c50ab2005db37f03443e8e.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*0M_-LIo5AGG-cwTWoDl00g.jpeg"/></div></figure><h1 id="6e0d" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated"><strong class="ak"> mapDispatchToProps </strong></h1><p id="29ce" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">是时候看看流程图的右边分支了。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/be8961cb1552fec5238660658dd2c7c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*VHOaaXAx7Fls4iFXd4FyBQ.jpeg"/></div></figure><p id="bd50" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mp mq mr ly b">mapDispatchToProps</code>是一个函数，允许您创建在被调用时被调度的函数。那些创建的功能也是组件道具。这可能一开始听起来有点混乱，所以让我们一步一步来。</p><p id="7ad5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，让我们创建<code class="fe mp mq mr ly b">mapDispatchToProps</code>函数，并通过<code class="fe mp mq mr ly b">connect()</code>函数将其连接到组件。</p><figure class="lt lu lv lw gt mi"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="6402" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">注意:</strong>如果您的组件只需要调度功能，您可以将<code class="fe mp mq mr ly b">mapStateToProps</code>替换为<code class="fe mp mq mr ly b">null</code>，如下所示:</p><p id="218b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe mp mq mr ly b">connect(null, mapDispatchToProps)(YOUR COMPONENT NAME HERE)</code></p><p id="3ab1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的要点中，第25–29行创建了<code class="fe mp mq mr ly b">mapDispatchToProps</code>函数。它返回一个对象，它的键是<code class="fe mp mq mr ly b">addItem</code>，而它的值是一个回调函数。这个回调函数<strong class="jm io"> <em class="lp">调度</em> </strong>一个<strong class="jm io"> <em class="lp">动作</em> </strong>名为<code class="fe mp mq mr ly b">actionIsToAddTheNewItem</code>，其参数为<code class="fe mp mq mr ly b">newItem</code>。</p><h1 id="37fb" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">将DispatchToProps映射到操作</h1><p id="541a" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">进入流程图的下一步:</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/8eb300d99ef209f8157b7e902f73e742.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*K8PR0_gSWfIM0Jv1g3Zqyw.jpeg"/></div></figure><p id="f4e0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">目前，在演练的这一点上，应该会出现一个错误，指出没有定义<code class="fe mp mq mr ly b">actionToAddTheNewItem</code>。所以，我们来定义一下。因为这是一个动作，我通常会将我的动作放在一个单独的文件夹中，类似于我对reducing函数所做的。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div role="button" tabindex="0" class="mv mw di mx bf my"><div class="gh gi mz"><img src="../Images/b86a55f35833a2068da2b2a80bf1e0d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2udB8AX0P6FQ6Gh3EBIX0A.png"/></div></div></figure><p id="b645" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">创建动作后，记得将其导入到适当的组件文件中(在本例中是App.js)。</p><p id="be6a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常，一个动作返回一个具有两个键值对的对象:一个键为<code class="fe mp mq mr ly b">type</code>，另一个键为<code class="fe mp mq mr ly b">payload</code>。<code class="fe mp mq mr ly b">type</code>键是一个保留键/字，其<strong class="jm io"> <em class="lp">必须与减速器功能中的</em> </strong>匹配，以便执行正确的动作。<code class="fe mp mq mr ly b">payload</code>键是为了完成所述动作而发送的数据本身。</p><p id="c0e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面的要点显示了已完成的<code class="fe mp mq mr ly b">actionIsToAddTheNewItem</code>。</p><figure class="lt lu lv lw gt mi"><div class="bz fp l di"><div class="ms mt l"/></div></figure><h1 id="da90" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">发送至减速器至开关/外壳</h1><p id="e5ec" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">这移动到流程图的下一步。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/2c660c606e6813d0d9a60f3c1d70eb93.png" data-original-src="https://miro.medium.com/v2/resize:fit:802/format:webp/1*pGuEBNGZ1jim5VXI06K1hg.jpeg"/></div></figure><p id="968d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在将根据reducer函数中的开关情况逻辑来执行分派的动作。这就是<code class="fe mp mq mr ly b">groceryListReducer</code>功能的第二个参数的目的。由于<code class="fe mp mq mr ly b">groceryListReducer</code>函数目前没有<code class="fe mp mq mr ly b">"NEWITEM”</code>的case，应该和<code class="fe mp mq mr ly b">actionIsToAddTheNewItem</code>函数中的<code class="fe mp mq mr ly b">type</code>一样，所以我们来添加一下。这显示在下面要点的第6–9行。</p><figure class="lt lu lv lw gt mi"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="2254" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在所有reducer函数中，每种情况都根据预期的动作返回新的状态。对于这种情况，<code class="fe mp mq mr ly b">“ADDITEM”</code>应该返回一个新的状态，从有效载荷中添加新的项目(即<code class="fe mp mq mr ly b">action.payload</code>)。通过spread操作符复制和创建项目当前状态的新数组，并将新项目追加到新数组的末尾，来执行此操作。由于使用了相同的关键字<code class="fe mp mq mr ly b">currentItems</code>，旧的<code class="fe mp mq mr ly b">currentItem</code>状态(在分派动作之前)被新的<code class="fe mp mq mr ly b">currentItem</code>状态(在完成动作之后)覆盖。</p><h1 id="c2e7" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">执行派单</h1><p id="8185" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">现在已经完成了<code class="fe mp mq mr ly b">mapDispatchToProps </code>函数、动作和reducer函数，我们如何分派一个动作呢？分派动作通常在事件发生时发生(例如，点击、提交、onChange等)。)</p><p id="2292" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了演示这一点，让我们制作一个表单，向当前的杂货列表中添加一个新项目。</p><figure class="lt lu lv lw gt mi"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="0b8c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上述要点的返回部分，添加了新代码来呈现当前的项目列表，在底部添加了一个表单，并通过本地状态管理使输入字段成为受控组件。可以通过Redux管理输入的状态，但是为了一致性和简单性，我们将只管理条目的状态。</p><p id="c1ad" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">目前，该窗口看起来像下面的截图。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi na"><img src="../Images/da2e8b130ddee8d73fb51e99e15eaf71.png" data-original-src="https://miro.medium.com/v2/resize:fit:610/format:webp/1*1amHTRyw_IKJ6WTIyPDjmw.png"/></div></figure><p id="98a6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下面是组件的道具截图。</p><figure class="lt lu lv lw gt mi gh gi paragraph-image"><div class="gh gi nb"><img src="../Images/df4a3b9559112b3bf622afd7102b70f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:814/format:webp/1*gbHQvQpUVrPdEKGsQbTvpA.png"/></div></figure><p id="b7c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从截图来看，<code class="fe mp mq mr ly b">addItem</code>调度员在我们的道具里。在提交表单时，应该执行<code class="fe mp mq mr ly b">addItem</code>调度程序，使新项目附加到我们的<code class="fe mp mq mr ly b">currentItems</code>属性中，然后呈现在列表的底部。</p><figure class="lt lu lv lw gt mi"><div class="bz fp l di"><div class="ms mt l"/></div></figure><p id="f6c7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第31行的表单中添加了一个<code class="fe mp mq mr ly b">onSubmit</code>属性。<code class="fe mp mq mr ly b">onSubmit</code>属性指的是第16–20行上的一个名为<code class="fe mp mq mr ly b">handleSubmit</code>的回调函数。<code class="fe mp mq mr ly b">handleSubmit</code>函数停止post动作的默认执行，然后执行<code class="fe mp mq mr ly b">addItem</code>调度程序。<code class="fe mp mq mr ly b">addItem</code>调度程序执行“调度减速器至开关/机箱”一节中解释的流程。新项目将被追加到Redux存储中。当新的项目被添加到Redux存储中时，React将被ping到状态已被更改，导致重新呈现，并因此在列表的底部呈现新的项目。</p><h1 id="771e" class="kj kk in bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg bi translated">结论</h1><p id="6cb4" class="pw-post-body-paragraph jk jl in jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh ig bi translated">Redux有很多小步骤。困难不在于理解每一步，而是所有这些步骤是如何结合在一起的。第一次尝试不懂Redux也不用担心。我绝对没有。我花了整整三天时间才掌握Redux，更不用说执行它了。本演练的目的是尝试了解每个步骤如何适应Redux的整体流程，并成为一个独立的代码。</p><p id="0e0c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">希望这个演练有助于澄清您对Redux的理解！如果这让你更加困惑，欢迎来到编码生活！</p></div></div>    
</body>
</html>