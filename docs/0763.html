<html>
<head>
<title>A Tale of Tests and Fools in the Land of Asynchronicity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步土地上测试和傻瓜的故事</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-tale-of-tests-and-fools-in-the-land-of-asynchronicity-1d3d626352f?source=collection_archive---------8-----------------------#2019-12-06">https://javascript.plainenglish.io/a-tale-of-tests-and-fools-in-the-land-of-asynchronicity-1d3d626352f?source=collection_archive---------8-----------------------#2019-12-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9f1037f697e0afc31f67545a8b154385.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bKkDIW7gpbyGknnNLdML2Q.png"/></div></div></figure><blockquote class="jv jw jx"><p id="d9c0" class="jy jz ka kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">第一个原则是你不能欺骗自己——而你是最容易被欺骗的人。— <em class="in">理查德·费曼</em></p></blockquote><p id="158b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi la translated"><span class="l lb lc ld bm le lf lg lh li di"> T </span>他的故事在2018年初展开，当时我正试图理清JavaScript(特别是NodeJS) <a class="ae lj" href="https://nodejs.org/es/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank">事件循环</a>。</p><h2 id="5b8b" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated">单线程宇宙</h2><p id="5162" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">大多数现代(以及古老)语言都为开发人员提供了一种工具，来管理我们当前使用的多核、多处理器机器。通常，人们可以很容易地“fork()”进程和/或使用<a class="ae lj" href="https://en.wikipedia.org/wiki/Thread_(computing)" rel="noopener ugc nofollow" target="_blank">线程</a>。当然，一旦你进入<a class="ae lj" href="https://en.wikipedia.org/wiki/Concurrency_(computer_science)" rel="noopener ugc nofollow" target="_blank">并发</a>仙境，你就开始需要<a class="ae lj" href="https://en.wikipedia.org/wiki/Inter-process_communication" rel="noopener ugc nofollow" target="_blank">进程间通信</a> (IPC)原语，比如<a class="ae lj" href="https://en.wikipedia.org/wiki/Lock_(computer_science)" rel="noopener ugc nofollow" target="_blank">锁</a>和<a class="ae lj" href="https://en.wikipedia.org/wiki/Semaphore_(programming)" rel="noopener ugc nofollow" target="_blank">信号量</a>；顺便提一下，它是大多数标准库和OS的API(如POSIX)的一部分。一些语言甚至已经提供了线程池。<a class="ae lj" href="https://www.ponylang.io" rel="noopener ugc nofollow" target="_blank">和</a><a class="ae lj" href="https://akka.io" rel="noopener ugc nofollow" target="_blank"/><a class="ae lj" href="https://elixirschool.com/en/lessons/advanced/concurrency/" rel="noopener ugc nofollow" target="_blank">中的少数</a> <a class="ae lj" href="https://en.wikipedia.org/wiki/Erlang_(programming_language)" rel="noopener ugc nofollow" target="_blank">他们</a>在揭开<a class="ae lj" href="https://en.wikipedia.org/wiki/Actor_model" rel="noopener ugc nofollow" target="_blank">演员模型</a>并发的奇迹时，推动了抽象的边界。</p><p id="d6ed" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">但是JavaScript不是其中之一…</p><p id="d0d2" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">出于历史原因，JavaScript生活在这个舒适的单线程应用程序世界中(这个世界<a class="ae lj" href="http://www.informit.com/articles/article.aspx?p=1193856" rel="noopener ugc nofollow" target="_blank">可能会让</a> Donald Knuth高兴)。一个指令接着一个指令，一个接着一个，一个接着一个……都是按顺序的，都是完全确定的；所有这些都是根据99%的开发人员对计算机应该如何工作的心理模型得出的。如果不是因为一个小细节，这是一个简单而有效的抽象:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="29b2" class="lk ll in mn b gy mr ms l mt mu">+------------------------------------+-----------------+<br/>|                                    |  Latency (ns)   |<br/>+------------------------------------+-----------------+<br/>| L1 cache reference                 |            0.5  |<br/>| Branch mispredict                  |            5.0  |<br/>| L2 cache reference                 |            7.0  |<br/>| Mutex lock/unlock                  |           25.0  |<br/>| Main memory reference              |          100.0  |<br/>| Compress 1K bytes with Zippy       |        3,000.0  |<br/>| Send 1K bytes over 1 Gbps network  |       10,000.0  |<br/>| Read 4K randomly from SSD          |      150,000.0  |<br/>| Read 1 MB sequentially from memory |      250,000.0  |<br/>| Round trip within same datacenter  |      500,000.0  |<br/>| Read 1 MB sequentially from SSD    |    1,000,000.0  |<br/>| Disk seek                          |   10,000,000.0  |<br/>| Read 1 MB sequentially from disk   |   20,000,000.0  |<br/>| Send packet CA &gt; Netherlands &gt; CA  |  150,000,000.0  |<br/>+------------------------------------+-----------------+</span></pre><p id="4c2d" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">你看，做事需要<em class="ka">时间</em>。我们可能正在做CPU密集型或I/O密集型的工作。但是JavaScript <em class="ka">的东西</em>往往不是被CPU绑定，而是被I/O绑定。这很自然:它是<em class="ka">网络的</em>语言，所以大部分时间它都是通过这个我们称之为互联网的大网络来操纵资源。</p><p id="92e2" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">一个单线程应用程序一次只能做一件事:要么它在等待(被阻塞)一个资源变得可用(比如从CA的一个服务器下载3Mb)，要么它在屏幕上计算一些花哨的动画。但是<em class="ka">不是</em>两者都有。你看到泡菜了吗？</p><p id="477e" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">快进到委员会和邮件列表中的一些潜在讨论，一个简单的解决方案出现了:如果JavaScript正在做的大多数事情都受到I/O的限制，那么将I/O从用户那里抽象出来(并可能利用多线程)，同时保持用户的应用程序是单线程的。换句话说，使I/O非阻塞。</p><p id="25e3" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">如果你<em class="ka">真的</em>注意，这个<em class="ka">本身</em>绝对不能解决任何问题。人们可以抽象出I/O，也就是说，人们可以说<em class="ka">“在我继续生活的时候为我取这个吧”</em>但是应用程序仍然需要一种方法来知道一个资源已经可用:<em class="ka">“这是您所请求的，我的主”</em>。如果应用程序的单线程很忙，100%专注于做其他事情，它怎么会被I/O子系统打扰呢？</p><p id="4ced" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">嗯，它不能…</p><p id="1ded" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">为了解决第二个难题，我们必须认识到大多数JavaScript脚本(双关语)并不总是在做事。当用户点击某些东西时，他们可能正在做一些事情；或者滚动页面；或者每秒60次，如果动画以每秒60帧的速度出现。否则，脚本(通常)应该是空闲的。并且正是在这种空闲期间，I/O子系统可以利用中断流。<em class="ka">瞧着吧</em><a class="ae lj" href="https://nodejs.org/es/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank">事件循环</a>诞生了。</p><h2 id="5ee7" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated"><strong class="ak">事件循环</strong></h2><p id="b6aa" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">一个事件循环只是…一个(无止境？)循环。它的确是按照一定的顺序<em class="ka">填充</em>，当它到最后的时候，它又重新开始。根据<a class="ae lj" href="https://nodejs.org/es/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained" rel="noopener ugc nofollow" target="_blank"> Node.js文档</a>，事件循环是这样的:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="df92" class="lk ll in mn b gy mr ms l mt mu">   ┌───────────────────────────┐<br/>┌─&gt;│           timers          │<br/>│  └─────────────┬─────────────┘<br/>│  ┌─────────────┴─────────────┐<br/>│  │     pending callbacks     │<br/>│  └─────────────┬─────────────┘<br/>│  ┌─────────────┴─────────────┐<br/>│  │       idle, prepare       │<br/>│  └─────────────┬─────────────┘      ┌───────────────┐<br/>│  ┌─────────────┴─────────────┐      │   incoming:   │<br/>│  │           poll            │&lt;─────┤  connections, │<br/>│  └─────────────┬─────────────┘      │   data, etc.  │<br/>│  ┌─────────────┴─────────────┐      └───────────────┘<br/>│  │           check           │<br/>│  └─────────────┬─────────────┘<br/>│  ┌─────────────┴─────────────┐<br/>└──┤      close callbacks      │<br/>   └───────────────────────────┘</span></pre><p id="ed1c" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">这些阶段中的每一个都有一个由<a class="ae lj" href="https://en.wikipedia.org/wiki/Callback_(computer_programming)" rel="noopener ugc nofollow" target="_blank">回调</a>组成的<a class="ae lj" href="https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)" rel="noopener ugc nofollow" target="_blank"> FIFO队列</a>来执行。尽管每个阶段都有其特殊性，但它的回调都是按顺序执行的，直到(a)它的队列已经用尽，或者(b)达到了回调的最大数量；之后，事件循环将移动到下一阶段，<em class="ka">令人厌烦的</em>。</p><h2 id="bf8e" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated"><strong class="ak">打电话给我也许</strong></h2><p id="cf64" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated"><em class="ka">“先生您说的这些</em> <strong class="kb io">回调</strong> <em class="ka">。一个</em> <strong class="kb io">回调</strong> <em class="ka">到底是什么鬼？</em>“这个问题问得好，我的朋友；我非常高兴你询问了如此奇妙的发明！顾名思义，<a class="ae lj" href="https://en.wikipedia.org/wiki/Callback_(computer_programming)" rel="noopener ugc nofollow" target="_blank">回调</a>是一种给<em class="ka">某物</em>，通常是给<em class="ka">另一物</em>一个function⁴，并期望它回调……一旦它决定这样做。换句话说，这就像是在说:“<em class="ka">请在你认为合适的时候执行这个”⁵。如果您曾经用JavaScript编写过代码，您肯定会立即认出这种模式:</em></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4dc1" class="lk ll in mn b gy mr ms l mt mu">setInterval(function() { console.log(“Another one bites the dust”) }, 1000)</span></pre><p id="cc6d" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">“function() {…}”部分是我们的回调函数，而“setInterval”的主要作用是将它添加到定时器的FIFO中。这里还有一个:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e3d9" class="lk ll in mn b gy mr ms l mt mu">document.getElementById(“myBtn”).onclick = function() { console.log(“We Click ^.^” ) }</span></pre><p id="dccc" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">这是一种不同类型的回调(需要一个<a class="ae lj" href="https://en.wikipedia.org/wiki/Document_Object_Model)" rel="noopener ugc nofollow" target="_blank"> DOM </a>)，但是适用相同的原则。回调被添加到某个FIFO中，一旦用户点击按钮，它就会被调用。下面是一些使用I/O的示例:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="58a0" class="lk ll in mn b gy mr ms l mt mu">require('fs').readFile('./data.csv', function read(err, data) {<br/>    console.log(data)<br/>})</span><span id="4004" class="lk ll in mn b gy mv ms l mt mu">console.log("I win!?")</span></pre><p id="ad6d" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">作为对读者的一个练习，先想想你期望屏幕上出现什么:文件的内容，或者句子<strong class="kb io">“我赢了！?"</strong>。</p><h2 id="16a9" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated">你的观点是… </h2><p id="892d" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">确实，我跑题了。因此，2018年初，我<a class="ae lj" href="https://stackoverflow.com/questions/50382553/asynchronous-bounded-queue-in-js-ts-using-async-await" rel="noopener ugc nofollow" target="_blank">试图理解</a>基于非阻塞单线程事件循环的JavaScript是如何工作的。我的需求很简单:a)让一对生产者/消费者交换消息，b)通过一个有限的缓冲区，c)如果没有消息可供消费，消费者将<em class="ka">仅</em>阻塞，d)如果缓冲区已满，生产者将<em class="ka">仅</em>阻塞。这意味着要实现如下内容:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="8fda" class="lk ll in mn b gy mr ms l mt mu">class AsyncQueue&lt;T&gt; {<br/>    private queue = Array&lt;T&gt;()<br/>    <br/>    constructor(public readonly maxSize: number) { }</span><span id="6513" class="lk ll in mn b gy mv ms l mt mu">    async enqueue(x: T) {<br/>        if (this.queue.length &gt; this.maxSize) {<br/>            // Block until available<br/>        }</span><span id="b29b" class="lk ll in mn b gy mv ms l mt mu">        this.queue.unshift(x)<br/>    }</span><span id="88a6" class="lk ll in mn b gy mv ms l mt mu">    async dequeue() {<br/>        if (this.queue.length == 0) {<br/>            // Block until available<br/>        }</span><span id="3ebe" class="lk ll in mn b gy mv ms l mt mu">        return this.queue.pop()!<br/>    }<br/>}</span></pre><p id="4f14" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">开发者俱乐部的第一条规则是:你不要谈论开发者俱乐部。第二条规则是:<strong class="kb io">不管你手头有什么问题，别人已经尝试过了…比你更好…处理它！</strong></p><h2 id="ce82" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated"><strong class="ak">生产者-消费者问题</strong></h2><p id="ba4d" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">这也不例外，因为人们可以很容易地在维基百科中找到<a class="ae lj" href="https://en.wikipedia.org/wiki/Producer–consumer_problem" rel="noopener ugc nofollow" target="_blank">生产者-消费者问题</a>。可能有人已经有了一个现成的“npm”图书馆。但是我在努力学习，而不仅仅是继续我的生活。所以，在研究了这个问题之后，我学到了两件事:</p><ol class=""><li id="c80f" class="mw mx in kb b kc kd kg kh kx my ky mz kz na kw nb nc nd ne bi translated">写错误的实现是非常容易的(不是吧，夏洛克)。的确，“一个<em class="ka"/><a class="ae lj" href="https://en.wikipedia.org/wiki/Producer–consumer_problem#Inadequate_implementation" rel="noopener ugc nofollow" target="_blank"><em class="ka">不充分的解决方案</em> </a> <em class="ka">可能会导致死锁，此时两个进程都在等待被唤醒”</em>；</li><li id="93be" class="mw mx in kb b kc nf kg ng kx nh ky ni kz nj kw nb nc nd ne bi translated">解决这个问题最简单的方法就是使用Semaphore⁶。</li></ol><h2 id="575b" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated"><strong class="ak">一个带有信号量的支线任务</strong></h2><p id="6545" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">解释信号量最简单的方法是想象你试图把车停在拥挤的商场里。旗语允许人们在还有车位的时候进入公园(我们称之为许可证)。一旦它到达<strong class="kb io">零点</strong>，不幸的是:你将不得不<strong class="kb io">等待</strong>。直到有人离开公园，<strong class="kb io">给</strong>一个空闲的位置。换句话说，信号量遵循以下约定:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="bea5" class="lk ll in mn b gy mr ms l mt mu">interface AsyncSemaphore {<br/>    signal(): void<br/>    async wait(): Promise&lt;void&gt;<br/>}</span></pre><p id="ee2b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">你会问为什么“wait()”标记为“async ”?因为我不想阻塞我的代码<em class="ka">直到</em>信号量显示现在有空闲的停车位。记住:我们生活在一个<strong class="kb io">单线程</strong>世界中，所有的<em class="ka">用户域代码</em>，包括我们信号量的实现，都被以同样的方式对待，运行在同一个线程中。信号量不可能<em class="ka">甚至检查</em>是否有空闲空间，因为我们<em class="ka">被阻塞</em>在队列中等待这样的事情发生。所以，是的，会出现死锁。解决方案是传递一个回调，说:“<em class="ka">嘿，一旦有我可以使用的许可证，就打电话给我”</em>。如果你不明白回调之间的关系，<a class="ae lj" href="https://en.wikipedia.org/wiki/Futures_and_promises" rel="noopener ugc nofollow" target="_blank">承诺</a>和<a class="ae lj" href="https://en.wikipedia.org/wiki/Async/await" rel="noopener ugc nofollow" target="_blank">异步/等待</a>，就是学习时间了。因此，我找到了第一个解决异步信号量挑战的方法:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="4374" class="lk ll in mn b gy mr ms l mt mu">class AsyncSemaphore {<br/>    private promises = Array&lt;() =&gt; void&gt;()</span><span id="15b3" class="lk ll in mn b gy mv ms l mt mu">    constructor(private permits: number) {}</span><span id="338a" class="lk ll in mn b gy mv ms l mt mu">    signal() {<br/>        this.permits += 1<br/>        if (this.promises.length &gt; 0) this.promises.pop()()<br/>    }</span><span id="b1ba" class="lk ll in mn b gy mv ms l mt mu">    async wait() {<br/>        if (this.permits == 0 || this.promises.length &gt; 0)<br/>            await new Promise(r =&gt; this.promises.unshift(r))<br/>        this.permits -= 1<br/>    }<br/>}</span></pre><h2 id="a7ef" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated"><strong class="ak">生产者-消费者:第二部分</strong></h2><p id="42d0" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">生产者-消费者问题的后续解决方案简单地用两个信号量跟踪队列的状态:` emptyCount ',队列中空位置的数量，和` fullCount ',队列中元素的数量。必须保持两个不变量:(1)‘empty count’必须总是小于或等于队列中空位的实际数量，以及(2)‘full count’必须总是小于或等于队列中项目的实际数量。如果想放宽缓冲区的大小(从而允许无限长的队列)，那么单个信号量就足够了。这正是我开始的地方:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7018" class="lk ll in mn b gy mr ms l mt mu">class AsyncQueue&lt;T&gt; {<br/>    private queue = Array&lt;T&gt;()<br/>    private waitingEnqueue: AsyncSemaphore</span><span id="26f0" class="lk ll in mn b gy mv ms l mt mu">    constructor(readonly maxSize: number) {<br/>        this.waitingEnqueue = new AsyncSemaphore(0)<br/>    }</span><span id="ed3a" class="lk ll in mn b gy mv ms l mt mu">    async enqueue(x: T) {<br/>        this.queue.unshift(x)<br/>        this.waitingEnqueue.signal()<br/>    }</span><span id="7c37" class="lk ll in mn b gy mv ms l mt mu">    async dequeue() {<br/>        await this.waitingEnqueue.wait()<br/>        return this.queue.pop()!<br/>    }<br/>}</span></pre><p id="c2d9" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">以我的代码为荣，我做了一些测试，回答了我自己在Stackoverflow⁷上的问题，一切都很好。我用下面的句子结束了我的帖子:“<em class="ka">我仍然不确定这不会在没有广泛测试的情况下重新引入微妙的错误”。</em></p></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><h2 id="665a" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated">测试的故事</h2><p id="4990" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">回到我们的主题:我们如何知道实现是正确的？到今天为止，我有11票赞成这个问题，6票赞成这个答案。的确，这看起来并不是一个紧迫的问题。但是我最近给了我的学生同样的挑战，这样我们就可以分享用头撞墙的快乐。他们在Stackoverflow上找到了我的解决方案，并原样复制粘贴了代码<em class="ka">和⁸ </em>，这并不奇怪。</p><p id="2b3a" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">我测试过吗？我当然有！在某个时候，我甚至提供了一个“统计测试”,随意生成“enqueues()”和“dequeues()”的随机排列:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ec75" class="lk ll in mn b gy mr ms l mt mu">async function testAsyncQueueBehavior(nOps: number):Promise&lt;Boolean&gt; {<br/>    const result = new Array&lt;number&gt;()<br/>    const q = new AsyncQueue&lt;number&gt;()</span><span id="c1b6" class="lk ll in mn b gy mv ms l mt mu">    const enqueue = (m: number) =&gt; q.enqueue(m)<br/>    const dequeue = () =&gt; q.dequeue()<br/>    const promises = Array&lt;Promise&lt;void&gt;&gt;()</span><span id="f646" class="lk ll in mn b gy mv ms l mt mu">    let enqueues = 0<br/>    let dequeues = 0</span><span id="2194" class="lk ll in mn b gy mv ms l mt mu">    // Do a random permutation of enqueing and dequeing<br/>    for (let i = 0; i &lt; nOps; i += 1) {<br/>        if (Math.random() &gt; 0.5) {<br/>            enqueues += 1<br/>            enqueue(enqueues)<br/>        } else {<br/>            dequeues += 1<br/>            promises.push(dequeue().then(v =&gt; { result.push(v) }))<br/>        }<br/>    }</span><span id="ae9c" class="lk ll in mn b gy mv ms l mt mu">    const pending = Math.min(enqueues, dequeues)<br/>    await Promise.all(promises.slice(0, pending))</span><span id="697f" class="lk ll in mn b gy mv ms l mt mu">    // Length should be equal minimum between enqueues and dequeues<br/>    const isLengthOk = pending === result.length</span><span id="35c2" class="lk ll in mn b gy mv ms l mt mu">    // Messages should be ordered<br/>    const isSorted = isArraySorted(result)</span><span id="8035" class="lk ll in mn b gy mv ms l mt mu">    return isLengthOk &amp;&amp; isSorted<br/>}</span></pre><p id="bbe3" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">据我所知，我的代码反复通过了这些测试。我的学生在他们自己的实现中使用这个，直到他们最终找到我的代码。他们使用了它，到目前为止没有人抱怨。</p><h2 id="a741" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated"><strong class="ak">论人类的直觉</strong></h2><p id="7c90" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">我喜欢认为我们的大脑有一种类似于<a class="ae lj" href="https://en.wikipedia.org/wiki/Generative_adversarial_network" rel="noopener ugc nofollow" target="_blank">生成对抗网络</a> (GAN)的工作模式。我大脑的一部分(T2代码猴子T3)正在产生解决方案；有时比我的手指打字还快。IDE、REPL、编译器的类型系统、测试……所有这些系统都是为了指导<em class="ka">代码猴子</em>确保他做好自己的<em class="ka">事情</em>。这是我的“生成性”神经网络。</p><p id="1122" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">然后是第二部分，它不能控制我的手指。它位于后台，浏览代码，并给我提供一个微弱的信号——实际上更像是一种感觉——如果我做了正确的事情。这是我的“歧视性”网络。</p><p id="f90e" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">丹尼尔·卡内曼在他的畅销书《思考，快与慢》中提到了两种思维模式之间的二分法:“系统1”是快速的、本能的和情绪化的；“系统2”更慢，更谨慎，更有逻辑性。我不确定卡尼曼系统和我的比喻是否完全吻合，但是…</p><p id="f20b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">一直以来，我的<em class="ka">辨别</em>系统不断告诉我:你的解决方案可能有问题，但我不知道是什么问题。这怎么可能呢？考试通过了，学生们没有抱怨。</p><h2 id="e807" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated"><strong class="ak">愚人的故事</strong></h2><p id="8b39" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">最终，我把完全相同的问题交给了我的朋友兼同事安德烈·雷斯蒂沃。他抓起自己信赖的ThinkPad，开始不停地编码。在某种程度上，他认为已经找到了一个不使用信号量的解决方案。我声称，在某个地方，不知何故，他会模仿相同的信号量逻辑；只是伪装成别的东西。我提供了我的测试函数，正如我所预料的那样，它失败了。</p><p id="e949" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">问题是，我们不只是希望它失败。我们想知道<em class="ka">它是如何失败的，所以我们开始在控制台上追踪导致失败的特定排列:一百次该死的“enqueue()”和“dequeue()”调用。我们认为这很愚蠢。好吧，就试着把最大操作次数缩至四次(因为…原因)，一直运行测试直到失败。如果失败，则执行以下操作序列:</em></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="1446" class="lk ll in mn b gy mr ms l mt mu">Dequeue() // #1<br/>Enqueue()<br/>Dequeue() // #2<br/>Dequeue() // #3</span></pre><p id="47e2" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">手头的具体问题是，他的实现没有像预期的那样阻塞#2，而是触发了#1和#2的回调。安德烈开玩笑说:“好吧，问题出在你的测试上！”</p><p id="6131" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">为我辩护，这样的假设并没有使他的实现工作得更好。我们一丝不苟地找出了失败的原因。但是这让我想到:<em class="ka">我有多确定在测试我自己的代码时这种特殊的排列曾经发生过？在我不知道的情况下，还有哪些错误的排列可能潜伏在周围？</em></p><p id="f72a" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">我教<em class="ka">软件工程</em>的正式方法已经有几年了。我们使用的工具之一是Daniel Jackson的<a class="ae lj" href="http://alloytools.org" rel="noopener ugc nofollow" target="_blank">合金分析器</a>，它<em class="ka">提供了一种声明性的规范语言，用于表达软件系统的结构约束和行为</em>。用Alloy实现一个完整的系统是一件痛苦的事情，但是我在使用它的时候总是很享受:它给了我具体的<em class="ka">反例</em>。</p><p id="28ad" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">此外，丹尼尔被这个“<em class="ka">小范围假设”</em>所吸引，认为这是对Alloy结果信心的基础。本质上，它声称“<em class="ka">大多数不一致模型在小范围内都有反例”</em>。还记得我们缩小反例的策略吗？似乎我们的直觉也相信这个假设是正确的。</p><p id="8924" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">但是我<strong class="kb io">不会</strong>在Alloy中实现消费者-生产者问题，原因有两个:(1)这是一个众所周知的问题，已经被证明是正确解决的，(2)我对测试它的<em class="ka">抽象解决方案</em>不感兴趣，但是我的<em class="ka">具体实现</em>，以及JavaScript的EventLoop等等。</p><h2 id="00f6" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated"><strong class="ak">基于属性的测试</strong></h2><p id="be4b" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">还记得开发者俱乐部的第二条规则吗？我来给你介绍一下<a class="ae lj" href="https://www.npmjs.com/package/fast-check" rel="noopener ugc nofollow" target="_blank">快检</a>。这个库允许你检查代码中属性的真实性。你会问，什么是财产？嗯，就像<em class="ka">对于所有(x，y，…)比如前提条件(x，y，…)成立，性质(x，y，…)为真</em>。</p><p id="de2b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">让我们提供一个简单的例子。假设您刚刚编写了一个惊人的函数，它检查某个特定的<em class="ka">模式</em>是否出现在给定的字符串中:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="72a0" class="lk ll in mn b gy mr ms l mt mu">const contains = (text, pattern) =&gt; text.indexOf(pattern) &gt;= 0;</span></pre><p id="574b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">通常你会写一些测试，比如:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="37e6" class="lk ll in mn b gy mr ms l mt mu">assert(contains('Look ma, no tests', 'tests'))<br/>assert(contains('Look ma, no tests', 'ma'))<br/>assert(contains('Look ma, no tests', 'Look'))</span></pre><p id="7bc6" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">你应该什么时候停止？你凭什么相信它对任何(所有)人都有效？)字符串和子字符串的组合？是什么让你确定你不是在测试你所知道的<em class="ka">的结果</em>起作用(即使有点subconsciously)⁹？这是泡菜。</p><p id="6836" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">对于基于属性的测试，您应该写:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="343c" class="lk ll in mn b gy mr ms l mt mu">const fc = require('fast-check')<br/>fc.assert(fc.property(fc.string(), text =&gt; contains(text, text)))</span></pre><p id="1a2d" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">快速检查基于<em class="ka">套利</em>的概念。一个任意的T是T的生成器，它怎么知道如何生成T呢？嗯，有人(可能是你)以这样一种方式编码它，给定一个随机数，它将产生随机‘t’的确定性均匀分布。快速检查已经为我们提供了<a class="ae lj" href="https://github.com/dubzzz/fast-check/blob/master/documentation/1-Guides/Arbitraries.md" rel="noopener ugc nofollow" target="_blank">内置的任意性</a>来生成自然数、布尔值、字符串和数组等等。然后，由它的内部引擎(使用“property()”调用)来检查我们的属性是否对任何任意输入都有效。</p><p id="0c9c" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">如果它所做的只是产生随机的东西，它不会比我的“统计测试”更好。所以它做了一些额外的聪明的事情。首先，fast-check也相信<em class="ka">小范围假设</em>:套利行为可能<em class="ka">在统计上偏向典型的问题情境</em>。在整数的情况下，你知道的演练:<strong class="kb io"> 0 </strong>、<strong class="kb io"> 1 </strong>、<strong class="kb io"> -1 </strong>、<strong class="kb io">-无穷大</strong>和<strong class="kb io">+无穷大</strong>是通常的疑点。第二，由“任意”T&gt;生成的值也可以提供“收缩(prev: Ts):流&lt;Ts&gt;”函数，一旦找到反例，该函数可以用于收缩T18反例。</p><h2 id="adac" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated">一个异步信号的测试</h2><p id="5a5b" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">让我们为异步信号量实现一个测试。我们从指定如何生成测试开始:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="b5b1" class="lk ll in mn b gy mr ms l mt mu">import { assert, asyncProperty, nat as aNat, array as anArray, boolean as aBoolean } from 'fast-check'</span><span id="66da" class="lk ll in mn b gy mv ms l mt mu">assert(<br/>    asyncProperty(<br/>        aNat(10),<br/>        anArray(aBoolean().map(b =&gt; b ? 'S' : 'W'), 100),<br/>        async (size, ops) =&gt; testSemaphore(size, ops)),<br/>        { numRuns: 1000 })</span></pre><p id="47bc" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">我们基本上要说的是，我们想要生成任意的信号量，允许多达10个，以及任意的“wait()”和“signal()”序列。该序列可以很容易地从任意的布尔数组(最大为100)中导出，其中“真”被映射到“信号()”,“假”被映射到“等待()”。然后，我们测试我们的信号量的<em class="ka">良好行为</em>:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7ea9" class="lk ll in mn b gy mr ms l mt mu">async function testSemaphore(size: number, ops: Array&lt;'S' | 'W'&gt;) {<br/>    const sem = new AsyncSemaphore(size)<br/>    const res = Array&lt;boolean&gt;()<br/>    const promises = Array&lt;Promise&lt;void&gt;&gt;()</span><span id="0234" class="lk ll in mn b gy mv ms l mt mu">    let signals = 0, waits = 0</span><span id="235c" class="lk ll in mn b gy mv ms l mt mu">    for (const op of ops) {<br/>        if (op === 'S') {<br/>            signals += 1<br/>            sem.signal()<br/>        } else {<br/>            waits += 1<br/>            promises.push(sem.wait().then(() =&gt; { res.push(true) }))<br/>        }<br/>    }</span><span id="7c1f" class="lk ll in mn b gy mv ms l mt mu">    await Promise.all(promises.slice(0, signals + size))<br/>    <br/>    return res.length === Math.min(signals + size, waits)<br/>}</span></pre><p id="4f1d" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">换句话说，给定“signal()”和“wait()”操作的任何序列，只能有和“signal()”一样多的“wait()”被解决，加上初始许可。</p><h2 id="e18a" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated"><strong class="ak">找到了！</strong></h2><p id="9ceb" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">我一运行它，就得到以下结果:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f2f6" class="lk ll in mn b gy mr ms l mt mu">catch Error: Property failed after 4 tests <br/>{ seed: 1474060413, path: "3:0:1:0:1:2:1:1:0:3", endOnFailure: true } <br/>Counterexample: [0,["W","S","W"]] <br/>Shrunk 9 time(s) <br/>Got error: Property failed by returning false</span></pre><p id="1806" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">所以，不仅我的信号量没有按预期工作(！)但是反例简单得令人尴尬:在用“permissions = 0”初始化的信号量上有“wait()”、“signal()”、“wait()”。为什么！？</p><h2 id="b1a7" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated">夏洛克，我们需要你的服务</h2><p id="3605" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">罪魁祸首是事件循环。谢谢，下一位…</p><p id="437f" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">哦，你想知道更多细节？好吧，让我们从分析这个特殊例子的“结果”数组开始。它的大小是两个，而它应该只有一个。这意味着这些承诺:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="7828" class="lk ll in mn b gy mr ms l mt mu">promises.push(sem.wait().then(() =&gt; { res.push(true) }))</span></pre><p id="5ee4" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">…找到了一个既能被处决的方法；这又意味着这条线:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f6b2" class="lk ll in mn b gy mr ms l mt mu">if (this.promises.length &gt; 0) this.promises.pop()!()</span></pre><p id="ef7a" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">…可能已经被执行了至少一次。但这没有任何意义:“信号()”方法只有一个用途！<em class="ka">追溯</em>执行的时间到了:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f2fd" class="lk ll in mn b gy mr ms l mt mu">Wait received <br/>Promised created <br/>Signal received <br/>Increase Permits<br/>Promise resolved<br/>Wait received<br/>Decrease the permits <br/>Decrease the permits</span></pre><p id="3430" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">因此，事情是这样的:在收到“等待”()之后，我们期待它会创造一个承诺(因为“许可== 0”)。然后，我们期待它<em class="ka">减少</em>的许可。但事实并非如此。相反，在承诺创建后，接收到“信号()”后，它会将“许可”增加到1，然后检查未决的承诺。它找到最后一个并解决它。在这一点上，人们可以<em class="ka">也</em>预期许可会减少，因为承诺之后的代码的执行会继续。但是不！相反，当接收到最终的“等待()”时，它检查“许可== 0 ”(这出乎意料地为假)，通过减少许可而不产生承诺来解决，然后未决许可减少两次。<em class="ka">唷！</em></p><p id="46b0" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">这里发生的是，我们的“等待()”实现有问题:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="26a1" class="lk ll in mn b gy mr ms l mt mu">if (this.permits == 0 || this.promises.length &gt; 0) {<br/>    await new Promise(r =&gt; { this.promises.unshift(r) })<br/>}</span><span id="062c" class="lk ll in mn b gy mv ms l mt mu">this.permits -= 1</span></pre><p id="5999" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">这个例子中只有一个承诺，而“等待”关键字的结果是将程序的其余部分作为“回调”推送到某个事件循环阶段的先进先出。这包括关键的“这个.许可-= 1”。程序按顺序进行，承诺被“信号()”解决的事实并不意味着之前的回调马上就被解决了。事实上，它没有……代码继续直接执行到第二个“等待()”,在那里“允许”还没有减少。</p><p id="82d0" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">在那里，您被<strong class="kb io">事件循环怪物</strong>咬伤。</p><h2 id="59eb" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated"><strong class="ak">async信号量的修正</strong></h2><p id="1cae" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">有了我们的基于属性的测试，很容易改变代码，看看会发生什么。通过两行代码的“排列”解决了这个问题，这不无讽刺意味:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6b5a" class="lk ll in mn b gy mr ms l mt mu">async wait() {<br/>    this.permits -= 1<br/>    if (this.permits &lt; 0 || this.promises.length &gt; 0)<br/>        await new Promise(r =&gt; this.promises.unshift(r))<br/>}</span></pre><p id="edcf" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">一旦调用“wait()”时，我们做的第一件事就是减少许可。我们还将条件更改为“允许”测试AsyncQueue </p><h2 id="a005" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated">我们从编写如何生成测试开始:</h2><p id="e536" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">并以类似的方式继续:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="633c" class="lk ll in mn b gy mr ms l mt mu">assert(<br/>    asyncProperty(<br/>        anArray(aBoolean().map(b =&gt; b ? 'E' : 'D'), 1000), <br/>        async (ns) =&gt; testAsyncQueueBehavior(ns)), <br/>        { numRuns: 100 })</span></pre><p id="1a9b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">在这里，我们要寻找两个属性，而不是一个:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="5501" class="lk ll in mn b gy mr ms l mt mu">async function testAsyncQueueBehavior(ops: Array&lt;'E' | 'D'&gt;): Promise&lt;boolean&gt; {<br/>    const result = new Array&lt;number&gt;()<br/>    const q = new AsyncQueue&lt;number&gt;()<br/>    const promises = Array&lt;Promise&lt;void&gt;&gt;()</span><span id="1018" class="lk ll in mn b gy mv ms l mt mu">    let enqueues = 0, dequeues = 0</span><span id="bd0d" class="lk ll in mn b gy mv ms l mt mu">    for (const op of ops) {<br/>        if (op === 'E') { <br/>            enqueues += 1 <br/>            q.enqueue(enqueues)<br/>        } else {<br/>            dequeues += 1 <br/>            promises.push(q.dequeue().then(v =&gt; { result.push(v) }))<br/>        }<br/>    }</span><span id="4bdf" class="lk ll in mn b gy mv ms l mt mu">    const pending = Math.min(enqueues, dequeues) <br/>    await Promise.all(promises.slice(0, pending))</span><span id="f82e" class="lk ll in mn b gy mv ms l mt mu">    // Length should be equal minimum between enqueues and dequeues<br/>    const isLengthOk = pending === result.length</span><span id="b0cb" class="lk ll in mn b gy mv ms l mt mu">    // Messages should be ordered<br/>    const isSorted = isArraySorted(result)</span><span id="b427" class="lk ll in mn b gy mv ms l mt mu">    return isLengthOk &amp;&amp; isSorted<br/>}</span></pre><p id="e23b" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">成功“出列”()的数量等于“入队”和“出列”之间的最小值；和</p><ol class=""><li id="246a" class="mw mx in kb b kc kd kg kh kx my ky mz kz na kw nb nc nd ne bi translated">所有“出列()”都按顺序求解(从而保留了FIFO属性)。</li><li id="648e" class="mw mx in kb b kc nf kg ng kx nh ky ni kz nj kw nb nc nd ne bi translated">快速检查找不到反例。</li></ol><p id="5b3d" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated"><strong class="ak">结语</strong></p></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><h2 id="f16d" class="lk ll in bd lm ln lo dn lp lq lr dp ls kx lt lu lv ky lw lx ly kz lz ma mb mc bi translated">做<em class="ka">正确的事情</em>和做<em class="ka">正确的事情</em>之间有微妙的区别。测试允许我们指定，对于非常特定的条件，我们的结果就是我们期望的结果。但是<em class="ka">的规格</em>，在<em class="ka">正确的事情</em>的意义上，远远超出了测试所能达到的。属性的自动检查是一种提高<em class="ka">置信度</em>的方法，我们的测试捕获了<em class="ka">更多的</em>规范；这是一种<em class="ka">间接</em>的方式来增加对我们程序<em class="ka">正确性</em>的信任。但是不要欺骗你自己:绝对没有什么能够告诉你你的规范是否正确。</h2><p id="bccd" class="pw-post-body-paragraph jy jz in kb b kc md ke kf kg me ki kj kx mf km kn ky mg kq kr kz mh ku kv kw ig bi translated">尽管Donald Knuth是一个超出我们大多数能力的天才，但他在2008年的一次采访中说了以下(不幸的)话:<em class="ka">“让我这么说吧:在过去的50年里，我编写了一千多个程序，其中许多都很庞大。在这些程序中，我想不出有哪五个会因为并行或多线程而得到显著增强。当然，举例来说，多处理器对TeX毫无帮助…</em></p></div><div class="ab cl nk nl hr nm" role="separator"><span class="nn bw bk no np nq"/><span class="nn bw bk no np nq"/><span class="nn bw bk no np"/></div><div class="ig ih ii ij ik"><p id="15fe" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">实际上，它需要两种<em class="ka">类型</em>的时间:做<em class="ka">的时间</em>它，和<em class="ka">沟通</em>它的时间。为了这个咆哮的所有目的，总时间是这两件事的总和。</p><p id="3b57" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">除非你考虑<a class="ae lj" href="https://en.wikipedia.org/wiki/Polling_(computer_science)" rel="noopener ugc nofollow" target="_blank">轮询</a>和<a class="ae lj" href="https://en.wikipedia.org/wiki/Busy_waiting" rel="noopener ugc nofollow" target="_blank">忙-等待</a>作为解决方案。</p><p id="fde7" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">⁴一些顽固的语言，像Java，很长一段时间都不知道如何传递函数作为参数。因此，这些可怜的家伙用一个众所周知的接口将这些函数包装在一个(可能是匿名的)类中，实例化一个对象，然后传递该对象。对于所有预期的目的——尽管适当的<a class="ae lj" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" rel="noopener ugc nofollow" target="_blank">闭包</a>解决了范围和环境限制——我们也可以调用这些回调。</p><p id="0843" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">⁵为什么我坚持使用“决定”和“找到合适的”这样的词？为什么不简单地说“当你完成的时候”？因为这不是真的。</p><p id="dd2c" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">⁶嗯了一声，<em class="ka">两个</em>旗语。</p><p id="e43d" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">⁷:这实际上比你想象的更常见。</p><p id="fd58" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">⁸:这本身并不是一件坏事。这个挑战是<a class="ae lj" href="https://github.com/hugoferreira/asso-pipes-and-stuff-v19" rel="noopener ugc nofollow" target="_blank">大型演习</a>的一部分，这个想法是让他们思考一件事是<em class="ka">认为</em>你理解异步，另一件事是<em class="ka">意识到</em>我们毕竟只是人类。</p><p id="3339" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi translated">⁹:这是一个导致TDD短句之一的难题:在编写实现之前<em class="ka">编写测试。</em></p><p id="ba8a" class="pw-post-body-paragraph jy jz in kb b kc kd ke kf kg kh ki kj kx kl km kn ky kp kq kr kz kt ku kv kw ig bi">⁹ It’s a pickle that lead to one of the TDD tennets: you write your tests <em class="ka">before</em> you write your implementation.</p></div></div>    
</body>
</html>