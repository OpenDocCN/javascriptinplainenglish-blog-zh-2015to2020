<html>
<head>
<title>JavaScript Best Practices for Writing More Robust Code — Type Checks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更健壮的代码类型检查的JavaScript最佳实践</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-for-writing-more-robust-code-type-checks-aee4c80e495c?source=collection_archive---------9-----------------------#2020-05-14">https://javascript.plainenglish.io/javascript-best-practices-for-writing-more-robust-code-type-checks-aee4c80e495c?source=collection_archive---------9-----------------------#2020-05-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/65bbd7e11aece48a3ebba35bdbbd7d13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*1kcrq9H1cyUA48Tp"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@tales_of_light?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Frans Daniels</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="50a9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="22ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何在JavaScript中正确地进行类型检查，这样我们在运行应用程序时就不会遇到数据类型错误。</p><h1 id="abc2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">运算符的类型</h1><p id="a728" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">typeof</code>操作符来检查原始数据类型和一些对象类型，比如函数。</p><p id="3886" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些检查是必要的，以便我们知道我们正在处理正确类型的数据。例如，当我们实际上想要将数字加在一起时，我们不想将<code class="fe me mf mg mh b">+</code>操作符与字符串一起使用。</p><p id="0ba8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使用它，我们在想要检查的值前添加<code class="fe me mf mg mh b">typeof</code>。<code class="fe me mf mg mh b">typeof</code>操作符返回的可能值如下:</p><ul class=""><li id="8ed5" class="mi mj iq kf b kg kh kk kl ko mk ks ml kw mm la mn mo mp mq bi translated">未定义— <code class="fe me mf mg mh b">"undefined"</code></li><li id="e050" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">空— <code class="fe me mf mg mh b">"object"</code></li><li id="fa6f" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">布尔型— <code class="fe me mf mg mh b">"boolean"</code></li><li id="3e2f" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">数量— <code class="fe me mf mg mh b">"number"</code></li><li id="eb56" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">BigInt(ECMAScript 2020中的新功能)——<code class="fe me mf mg mh b">"bigint"</code></li><li id="193a" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">字符串— <code class="fe me mf mg mh b">"string"</code></li><li id="bf41" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">符号(ECMAScript 2015中的新功能)——<code class="fe me mf mg mh b">"symbol"</code></li><li id="2fb5" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">函数对象(在ECMA-262术语中实现[[调用]])—<code class="fe me mf mg mh b">"function"</code></li><li id="b44b" class="mi mj iq kf b kg mr kk ms ko mt ks mu kw mv la mn mo mp mq bi translated">任何其他对象— <code class="fe me mf mg mh b">"object"</code></li></ul><p id="11a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些是<code class="fe me mf mg mh b">typeof</code>可以返回的所有可能的类型名字符串。除了<code class="fe me mf mg mh b">'object'</code>和<code class="fe me mf mg mh b">'function'</code>之外，大多数都是原始值类型。</p><p id="beac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意<code class="fe me mf mg mh b">typeof null</code>返回<code class="fe me mf mg mh b">'object'</code>。这是一个bug，但是由于它破坏了太多的现有代码而无法纠正，所以它保持原样。</p><p id="1e70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以使用<code class="fe me mf mg mh b">typeof</code>操作符进行以下检查:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="9886" class="ne lc iq mh b gy nf ng l nh ni">typeof 3 === 'number';<br/>typeof 3.1 === 'number';<br/>typeof(40) === 'number';<br/>typeof Math.LN2 === 'number';<br/>typeof Infinity === 'number';<br/>typeof NaN === 'number';</span></pre><p id="64cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上代码全部返回<code class="fe me mf mg mh b">true</code>。从上面的代码中我们可以看到，当我们使用数字、<code class="fe me mf mg mh b">Infinity</code>和<code class="fe me mf mg mh b">NaN</code>作为操作数时，它们都返回类型<code class="fe me mf mg mh b">'number'</code>。</p><p id="6ba0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">BigInt检查的一个示例如下:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="83f3" class="ne lc iq mh b gy nf ng l nh ni">typeof 41n === 'bigint';</span></pre><p id="889d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">BigInts在数字文字后面有一个<code class="fe me mf mg mh b">n</code>，以区别于普通数字。而且，它们只能是整数，大多数情况下只能对其他BigInts进行操作。</p><p id="5d64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要检查字符串，我们可以编写如下代码:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="2cc5" class="ne lc iq mh b gy nf ng l nh ni">typeof '' === 'string';<br/>typeof 'bla' === 'string';<br/>typeof `template` === 'string';</span></pre><p id="6dae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这对普通字符串和模板字符串都适用。</p><p id="9071" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检查布尔值，我们可以写:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="3d6f" class="ne lc iq mh b gy nf ng l nh ni">typeof true === 'boolean';<br/>typeof false === 'boolean';<br/>typeof Boolean(0) === 'boolean';<br/>typeof !!(1) === 'boolean';</span></pre><p id="4482" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Boolean()</code>和<code class="fe me mf mg mh b">!!</code>做同样的事情。它们都将参数或操作数转换为布尔值。以上表情全部返回<code class="fe me mf mg mh b">true</code>。</p><p id="dbd8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检查符号，我们可以写:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="7c83" class="ne lc iq mh b gy nf ng l nh ni">typeof Symbol() === 'symbol'<br/>typeof Symbol('foo') === 'symbol'<br/>typeof Symbol.iterator === 'symbol'</span></pre><p id="c6c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上表达式均返回<code class="fe me mf mg mh b">true</code>。</p><p id="1e61" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检查函数，我们可以写:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="2ac1" class="ne lc iq mh b gy nf ng l nh ni">typeof () =&gt; {} === 'function';<br/>typeof class C {} === 'function';<br/>typeof Math.sin === 'function';</span></pre><p id="1c94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，由于类只是JavaScript中构造函数的语法糖，所以类在与<code class="fe me mf mg mh b">typeof</code>一起使用时会返回<code class="fe me mf mg mh b">'function'</code>。以上表达式均返回<code class="fe me mf mg mh b">true</code>。</p><p id="4196" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了检查某物是否是一个对象，我们可以这样写:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="a5ea" class="ne lc iq mh b gy nf ng l nh ni">typeof {a: 1} === 'object';<br/>typeof [1, 2, 3] === 'object';<br/>typeof new Date() === 'object';</span></pre><p id="2ff5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以上表达式均返回<code class="fe me mf mg mh b">true</code>。</p><p id="423d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该对原始值使用包装器对象，所以下面这些是无用的和混乱的:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="a73f" class="ne lc iq mh b gy nf ng l nh ni">typeof new Boolean(true) === 'object'; <br/>typeof new Number(1) === 'object'; <br/>typeof new String('abc') === 'object';</span></pre><p id="91d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有3个表达式都是<code class="fe me mf mg mh b">true</code>，因为它们都有类型<code class="fe me mf mg mh b">'object'</code>。这不是对象文字的问题，因为它们返回我们期望的类型。</p><p id="ee8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，它们并没有比文字做得更好，所以我们应该避免使用构造函数来定义原始值。</p><p id="ee79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从ES2015开始，<code class="fe me mf mg mh b">typeof</code>运算符不再处理未声明的变量。</p><p id="66a8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果没有声明<code class="fe me mf mg mh b">foo</code>，那么在ES2015或更高版本中，那么<code class="fe me mf mg mh b">typeof foo</code>将在我们的代码中抛出一个错误。</p><p id="af15" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而在ES2015之前，如果变量未声明，<code class="fe me mf mg mh b">typeof foo</code>返回<code class="fe me mf mg mh b">undefined</code>。</p><p id="43be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于块范围的变量或常量，我们只能在声明变量时对它们进行操作。例如，以下内容:</p><pre class="mw mx my mz gt na mh nb nc aw nd bi"><span id="5871" class="ne lc iq mh b gy nf ng l nh ni">typeof foo === 'undefined';<br/>let foo;</span></pre><p id="b95d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">会给我们一个<code class="fe me mf mg mh b">ReferenceError</code>。</p><p id="d237" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们在使用<code class="fe me mf mg mh b">typeof</code>操作符时应该小心，这样我们就不会在检查过程中导致更多的崩溃。</p><figure class="mw mx my mz gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/36dcba132ca1627f00324bb561e29a83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*g7Yixc1UQu3WCn_b"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@davidclode?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">David Clode</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="19f5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="68ee" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">操作符让我们主要在原始值上进行类型检查。然而，我们也可以用它来检查一个函数或类是否是一个函数。</p><p id="f608" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其他类型的对象将返回带有<code class="fe me mf mg mh b">typeof</code>操作符的<code class="fe me mf mg mh b">'object'</code>，所以它不是很有用。</p><h2 id="5acb" class="ne lc iq bd ld nk nl dn lh nm nn dp ll ko no np lp ks nq nr lt kw ns nt lx nu bi translated">来自简明英语团队的一封信</h2><p id="d1b8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae kc" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kf ir">JavaScript in Plain English</strong></a><a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>—谢谢，继续学习！我们还推出了一个YouTube，希望你能通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的简明英语频道</strong> </a>来支持我们</p><p id="a112" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往,“简明英语”希望帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>