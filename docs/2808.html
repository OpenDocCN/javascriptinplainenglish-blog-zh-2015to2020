<html>
<head>
<title>ES5 vs ES6+ JavaScript Performance Comparisons</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES5与ES6+ JavaScript性能比较</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/es5-vs-es6-performance-comparisons-c3606a241633?source=collection_archive---------0-----------------------#2020-07-26">https://javascript.plainenglish.io/es5-vs-es6-performance-comparisons-c3606a241633?source=collection_archive---------0-----------------------#2020-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d3fb" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用ES5和ES6+比较一些常见的对象、数组、函数和字符串功能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/82098b00f2210a785353c47d710d3731.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZbwvQvHPJdXktA9a"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jpvalery?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jp Valery</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="1f57" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">在接下来的几周里，我将调查我们的Angular应用程序最近遇到的一些性能问题。</h2><p id="f95a" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">在今天简单浏览了一下代码并对RxJS做了一些调整后，我注意到一些普通的旧JavaScript(嗯，是TypeScript)可以做一些修饰。</p><p id="ac54" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">现在，作为一个前端应用程序，大部分的速度下降可能更多地与太多太频繁的重新渲染有关，但我想用一些统计数据来武装自己，看看对我们的JavaScript代码的改进会带来多大的不同，特别是从<a class="ae kv" href="https://es5.github.io/" rel="noopener ugc nofollow" target="_blank"> ES5 </a>风格代码迁移到<a class="ae kv" href="http://es6-features.org/#Constants" rel="noopener ugc nofollow" target="_blank"> ES6 </a> +。</p><p id="ea13" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">下面，我们将比较Chrome和Firefox中使用ES5和ES6+的一些常见操作。</p><p id="dc0f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">由于<a class="ae kv" href="https://www.google.com/intl/en_au/chrome/" rel="noopener ugc nofollow" target="_blank"> Chrome </a>使用<a class="ae kv" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank"> V8 JavaScript引擎</a>，其结果可能会被转移到新的<a class="ae kv" href="https://www.microsoft.com/en-us/edge" rel="noopener ugc nofollow" target="_blank"> Edge </a>浏览器，以及<a class="ae kv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>，因为它们使用相同的引擎。</p><p id="83e7" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">火狐使用了<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" rel="noopener ugc nofollow" target="_blank">蜘蛛猴</a> JavaScript运行时引擎。</p><p id="717b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">现在做一些测试。</p><h2 id="92a1" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">多个“如果”条件与可选链接</h2><p id="64a9" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">对象:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="d257" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const </strong>job = {<br/>  "summary": {<br/>    "total_actions": 4,<br/>    "finished_actions": 4<br/>  },<br/>  "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>  "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>  "description": "Job from our export",<br/>  "created_at": "2020-07-15T10:24:40.975000000Z",<br/>  "status": "finished",<br/>  "tags": {<br/>    "export_id": [<br/>      "8848c5d8-fd44-43c0-b7f2-1428d0f4891a" <br/>    ]<br/>  }<br/>}</span></pre><p id="bc1b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">现在，在我的特定场景中，<code class="fe mz na nb mr b">tags</code>可能不在那里，即使在那里，<code class="fe mz na nb mr b">tags</code>中的<code class="fe mz na nb mr b">export_id</code>也是可选的。我想检查我感兴趣的导出ID是否在我们从服务器接收的作业的<code class="fe mz na nb mr b">export_id</code>属性中。</p><p id="f7ca" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">让我们将此分为两个比较:</p><ol class=""><li id="46c8" class="nc nd iq lu b lv ml ly mm lf ne lj nf ln ng mk nh ni nj nk bi translated">检查<code class="fe mz na nb mr b">job.tags</code>是否存在，随后<code class="fe mz na nb mr b">job.tags.export_id</code>是否存在</li><li id="6f9f" class="nc nd iq lu b lv nl ly nm lf nn lj no ln np mk nh ni nj nk bi translated">检查<code class="fe mz na nb mr b">job.tags.export_id</code>是否包含我们感兴趣的出口ID</li></ol><p id="576a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="ff1f" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">if</strong> (job.tags &amp;&amp; job.tags.export_id) {<br/>    // do nothing<br/>}</span><span id="a513" class="kw kx iq mr b gy nq mw l mx my">vs.</span><span id="e4ec" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">if</strong> (job.tags?.export_id) {<br/>    // do nothing<br/>}</span></pre><p id="c8cb" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/20582a73e39afbd72abbb2372073bb9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lGIIsLi9IYfVx5gkIa1-Hw.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/16801c485ef12d74fbe61b8e37a8bd1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xC0MKihX7RzICT1tAXJozA.png"/></div></div></figure><p id="a3ec" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">测试这里:<a class="ae kv" href="https://jsperf.com/if-statements-vs-optional-chaining" rel="noopener ugc nofollow" target="_blank">https://jsperf.com/if-statements-vs-optional-chaining</a></p><p id="8000" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">Firefox略有不同，但Chrome大同小异。让我们看看当我们使用<code class="fe mz na nb mr b">indexOf</code>和<code class="fe mz na nb mr b">includes</code>时会发生什么。</p><p id="485a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a3a9" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">if</strong> (job.tags &amp;&amp; job.tags.export_id &amp;&amp; job.tags.export_id.indexOf("8848c5d8-fd44-43c0-b7f2-1428d0f4891a") &gt; -1) {<br/>    // do nothing<br/>}</span><span id="c83f" class="kw kx iq mr b gy nq mw l mx my">vs.</span><span id="eded" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">if</strong> (job.tags?.export_id?.includes("8848c5d8-fd44-43c0-b7f2-1428d0f4891a")) {<br/>    // do nothing<br/>}</span></pre><p id="ea1c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/df963bbc29897663361130d43207a941.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*L2FoY9ZBtpyA_o2APa9Fbg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/56edee50dd38881263d1d2081c385e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j1ld6bpcCAAlMit1Tf_iRg.png"/></div></div></figure><p id="166e" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">测试这里:<a class="ae kv" href="https://jsperf.com/indexof-versus-includes" rel="noopener ugc nofollow" target="_blank">https://jsperf.com/indexof-versus-includes</a></p><p id="2f84" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">有意思。在这种情况下，情况正好相反。Firefox和Chrome的实现非常相似，但是Chrome更喜欢ES6的T2功能。</p><p id="443c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">鉴于搭载V8 JavaScript引擎的Chrome要快得多，这种转变绝对值得。</p><p id="295c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">实际上，<code class="fe mz na nb mr b">includes</code> <em class="nu">应该比</em>表现得更好，因为它的功能比<code class="fe mz na nb mr b">indexOf</code>少，因为你不知道你要搜索的项目的索引。</p><h2 id="90f7" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">检查一个项目是否存在于一个大的基元数组中</h2><p id="fd30" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">阵列:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1df2" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">let</strong> jobs = [];</span><span id="6f5f" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">for </strong>(let i = 0; i &lt; 10000; i++) {<br/>  jobs.push(i)<br/>}</span></pre><p id="cf77" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="af94" class="kw kx iq mr b gy mv mw l mx my">jobs.indexOf(8888) &gt; -1</span><span id="c015" class="kw kx iq mr b gy nq mw l mx my">versus</span><span id="9042" class="kw kx iq mr b gy nq mw l mx my">jobs.includes(8888)</span></pre><p id="2e2a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/820e5f28497aed960815a06aa05e2230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkkL7xTe_PGRq5EjPC4MqQ.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/ceb9b8d7e200e049f91328fc5eaabbb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*myjm9cNwHmngltRyaNl6PQ.png"/></div></div></figure><p id="a02c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在此测试:<a class="ae kv" href="https://jsperf.com/item-exists-in-a-large-array-of-primitives" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/item-exists-in-a-large-array-of-primitives</a></p><p id="2d13" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">正如所料，包括两种浏览器中的wins。让我们来测试一下，如果我们测试更靠近数组开头的东西，会有什么不同。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/7d1e8a7a7630707dd5f63e31b4983775.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UwEeHmsM2q2GvEHRwVK-JA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/de1e2d611a2c2b870b02c25c77428bdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qpjGLkfB50j0zQuWcsf1kA.png"/></div></div></figure><p id="45de" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在此测试:<a class="ae kv" href="https://jsperf.com/item-exists-in-a-large-array-of-primitives-early-find" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/item-exists-in-a-large-array-of-primitives-early-find</a></p><p id="d401" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在带有V8引擎的Chrome中，当项目在数组的开头被找到时，<code class="fe mz na nb mr b">includes</code>销毁<code class="fe mz na nb mr b">indexOf</code>。不过，它在Firefox和Spidermonkey中只是稍微快了一点。</p><p id="f7c8" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">如果数组不包含我们的项目呢？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/aaaaa12006a7e53dca955f35154d2c05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IdmzMzDIjh6J6U-UXKxHZw.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/8376bc1045ab80f5977944b68dc2776b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D8nJLwkA4AqI4GncEcurDg.png"/></div></div></figure><p id="ec56" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在此测试:<a class="ae kv" href="https://jsperf.com/item-does-not-exist-in-a-large-array-of-primitives" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/item-do-not-exist-in-a-large-array-of-primitives</a></p><p id="b1f1" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在两个引擎中，这两种方法的时间非常相似，当使用includes在整个原语数组中搜索数组中不存在的数字时，Firefox的性能稍好一些。</p><h2 id="58e3" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">小对象的浅层复制</h2><p id="7a00" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">为了不变性，你经常想要复制或“克隆”对象，这样你就不会修改原始对象。JavaScript不提供本机“深度”克隆，所以我们将使用新旧JavaScript语法执行一些测试，制作一些小的和大的对象的浅层副本。</p><p id="d629" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">对象:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a56b" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const </strong>job = {<br/>  "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>  "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>  "description": "Job from our export",<br/>  "created_at": "2020-07-15T10:24:40.975000000Z",<br/>  "status": "finished",<br/>}</span></pre><p id="17d2" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="543b" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const </strong>newJob = Object.assign({}, job);</span><span id="728a" class="kw kx iq mr b gy nq mw l mx my">vs.</span><span id="c469" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">const </strong>newJob = { ... job }</span></pre><p id="4182" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/cc33793282c67bf64cfa0163e22614f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RCe4vDjcUtML0Nn9rIW_Bw.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/3570ee41b4f16b7215563211e8d866c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nxtGjAkBWTNRpPW32gGskQ.png"/></div></div></figure><p id="e4aa" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">测试这里:<a class="ae kv" href="https://jsperf.com/object-assign-versus-spread" rel="noopener ugc nofollow" target="_blank">https://jsperf.com/object-assign-versus-spread</a></p><p id="2877" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">Chrome比Firefox有更大的不同，但更现代的语法在两种浏览器中都明显更快。</p><h2 id="6a6d" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">较大对象的浅层复制</h2><p id="3b77" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">让我们用一个更大的物体试试。</p><p id="2d16" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">对象:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="5e9e" class="kw kx iq mr b gy mv mw l mx my">Large randomly generated object, contains some nested properties and arrays</span></pre><p id="c3c2" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c5bf" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const </strong>newJob = Object.assign({}, job);</span><span id="5165" class="kw kx iq mr b gy nq mw l mx my">vs.</span><span id="018b" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">const </strong>newJob = { ... job }</span></pre><p id="f740" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/95e63a39cd3031700159d7a27d3084f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*w6KpCS9mFqtNcp7F5xyltQ.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nz"><img src="../Images/a92fb8439201613feaedb43db7c2b897.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vhOWsfInYHPnWpJsKx0Y5w.png"/></div></div></figure><p id="51e8" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在这里测试:<a class="ae kv" href="https://jsperf.com/shallow-copy-larger-object-object-assign-vs-spread" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/shallow-copy-large-object-object-assign-vs-spread</a></p><p id="92e7" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果类似于浅拷贝一个小对象。Chrome及其V8引擎似乎通过spread运算符进行了大规模优化。</p><h2 id="b72c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">小基元数组的浅层复制</h2><p id="92f7" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">阵列:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2223" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const </strong>job = [1, 2, 3, 4, 5]</span></pre><p id="2a6c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="d69e" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const </strong>newJob = job.slice();</span><span id="411c" class="kw kx iq mr b gy nq mw l mx my">vs.</span><span id="334b" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">const </strong>newJob = [ ... job ]</span></pre><p id="537c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/9e26b142a891514bca26fabdddce3579.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HKW6oINE0WNbXTj-j78mYA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/786c442952fbf99e709a3be49f53befd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qGw1Pbh7-bWSpNhH8G-fNA.png"/></div></div></figure><p id="3615" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">测试这里:<a class="ae kv" href="https://jsperf.com/shallow-copy-slice-vs-spread/3" rel="noopener ugc nofollow" target="_blank">https://jsperf.com/shallow-copy-slice-vs-spread/3</a></p><p id="76af" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">好吧，很明显谁会赢得这场比赛。使用<code class="fe mz na nb mr b">slice</code>的老方法比Chrome和Firefox中的新方法要快得多。</p><h2 id="0fe5" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">较大基元数组的浅层复制</h2><p id="270e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">阵列:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="bcd9" class="kw kx iq mr b gy mv mw l mx my">Array containing a mixture of 20000 primitives</span></pre><p id="fed7" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="d3c4" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const </strong>newJob = job.slice();</span><span id="1bd3" class="kw kx iq mr b gy nq mw l mx my">vs.</span><span id="56e2" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">const </strong>newJob = [ ... job ]</span></pre><p id="6181" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/0acbe295a0e49810c53207681bbce530.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IunRxyTwGw5rHaallF5k6w.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oa"><img src="../Images/090b3542a7d7cd08f68fbfd22c4b293e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ZUAlrBtS29Q3iEsvT9g5A.png"/></div></div></figure><p id="7497" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">测试这里:<a class="ae kv" href="https://jsperf.com/shallow-copy-large-array-slice-vs-spread" rel="noopener ugc nofollow" target="_blank">https://jsperf.com/shallow-copy-large-array-slice-vs-spread</a></p><p id="75bf" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">好的，这里有几件事需要注意。对于更大的数组来说，<code class="fe mz na nb mr b">slice</code>和新的<code class="fe mz na nb mr b">spread</code>操作符之间的比较是一样的，因为新的操作符在两种浏览器中都大打折扣。这种差异在Firefox中更加明显，无论使用哪种方法，Firefox在处理大型数组的浅层复制时都显得力不从心。</p><h2 id="0b42" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">小型对象数组的浅层复制</h2><p id="6064" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">阵列:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="82a5" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const</strong> job = [<br/>  {<br/>    "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>    "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>    "description": "Job from our export",<br/>    "created_at": "2020-07-15T10:24:40.975000000Z",<br/>    "status": "finished",<br/>  },<br/>  {<br/>    "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>    "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>    "description": "Job from our export",<br/>    "created_at": "2020-07-15T10:24:40.975000000Z",<br/>    "status": "finished",<br/>  },<br/>  {<br/>    "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>    "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>    "description": "Job from our export",<br/>    "created_at": "2020-07-15T10:24:40.975000000Z",<br/>    "status": "finished",<br/>  },<br/>  {<br/>    "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>    "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>    "description": "Job from our export",<br/>    "created_at": "2020-07-15T10:24:40.975000000Z",<br/>    "status": "finished",<br/>  },<br/>  {<br/>    "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>    "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>    "description": "Job from our export",<br/>    "created_at": "2020-07-15T10:24:40.975000000Z",<br/>    "status": "finished",<br/>  }<br/>  <br/>]</span></pre><p id="3d55" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="81f3" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const </strong>newJob = job.slice();</span><span id="8a3d" class="kw kx iq mr b gy nq mw l mx my">vs.</span><span id="f2c2" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">const </strong>newJob = [ ... job ]</span></pre><p id="c1d1" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/f67b592340933c330233523f751bbaac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IJ4YgL_qerHUV21Ea-zPXw.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/6b4403efc417174adf45b71faa554bb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LnEFTagIvOUXzu0of1NPMg.png"/></div></div></figure><p id="588d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在这里测试:<a class="ae kv" href="https://jsperf.com/shallow-array-copying-small-array-of-objects" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/shallow-array-copy-small-array-of-objects</a></p><p id="77e6" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">类似于复制小数组图元的结果，只是Chrome中两种方法之间的差异没有那么明显。</p><h2 id="8421" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">大型对象数组的浅层复制</h2><p id="81d0" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">阵列:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a256" class="kw kx iq mr b gy mv mw l mx my">Array containing 10000 of the following objects:</span><span id="f576" class="kw kx iq mr b gy nq mw l mx my">{<br/>    "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>    "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>    "description": "Job from our export",<br/>    "created_at": "2020-07-15T10:24:40.975000000Z",<br/>    "status": "finished",<br/>}</span></pre><p id="e0df" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="af58" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const </strong>newJob = job.slice();</span><span id="a761" class="kw kx iq mr b gy nq mw l mx my">vs.</span><span id="63cb" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">const </strong>newJob = [ ... job ]</span></pre><p id="5194" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/b7a6296d85edf9d6de189fc9a7a39c3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XIZuDZ3zxvJTcE8crqBPHA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/463ab3a0f2619ab3f2bc83cb7a640c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bCjvBtEXBSC0vijrU3MeBA.png"/></div></div></figure><p id="1eaa" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在此测试:<a class="ae kv" href="https://jsperf.com/shallow-copying-of-large-array-of-objects" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/shallow-copy-of-large-array-of-objects</a></p><p id="371c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">有趣的是，在Chrome中浅层复制大量对象的情况下，<code class="fe mz na nb mr b">slice</code>的效率似乎下降了，而<code class="fe mz na nb mr b">spread</code>的效率似乎提高了。</p><h2 id="1da1" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">浅层复制大数组并追加对象</h2><p id="3a07" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">阵列:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7be2" class="kw kx iq mr b gy mv mw l mx my">Array containing 10000 of the following objects:</span><span id="e712" class="kw kx iq mr b gy nq mw l mx my">{<br/>    "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>    "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>    "description": "Job from our export",<br/>    "created_at": "2020-07-15T10:24:40.975000000Z",<br/>    "status": "finished",<br/>}</span></pre><p id="813a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="fdd7" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const</strong> newJob = job.slice().push({<br/>      "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>      "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>      "description": "Job from our export",<br/>      "created_at": "2020-07-15T10:24:40.975000000Z",<br/>      "status": "finished",<br/>})</span><span id="840e" class="kw kx iq mr b gy nq mw l mx my">versus</span><span id="1b4a" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">const</strong> newJob = [ ... job, {<br/>      "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>      "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>      "description": "Job from our export",<br/>      "created_at": "2020-07-15T10:24:40.975000000Z",<br/>      "status": "finished",<br/>}]</span></pre><p id="b56f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/713862e19948e530a1e8985d144de799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tbsj4HmeFIv60S9-kkcXYw.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/bbff121513dc6895455ee2edb91a914c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1sz9RKjrqogX-ZnIHrftsw.png"/></div></div></figure><p id="79e9" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在此测试:<a class="ae kv" href="https://jsperf.com/shallow-copying-of-large-array-of-objects-and-push" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/shallow-copy-of-large-array-of-objects-and-push</a></p><p id="4521" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">再次，<code class="fe mz na nb mr b">slice</code>和<code class="fe mz na nb mr b">push</code>在两个浏览器中都把奖杯带回家。</p><h2 id="0e6f" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">浅层复制大数组和前置对象</h2><p id="de6c" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">阵列:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="68f2" class="kw kx iq mr b gy mv mw l mx my">Array containing 10000 of the following objects:</span><span id="ccca" class="kw kx iq mr b gy nq mw l mx my">{<br/>    "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>    "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>    "description": "Job from our export",<br/>    "created_at": "2020-07-15T10:24:40.975000000Z",<br/>    "status": "finished",<br/>}</span></pre><p id="b86f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7630" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const</strong> newJob = job.slice().unshift({<br/>      "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>      "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>      "description": "Job from our export",<br/>      "created_at": "2020-07-15T10:24:40.975000000Z",<br/>      "status": "finished",<br/>})</span><span id="8858" class="kw kx iq mr b gy nq mw l mx my">versus</span><span id="262e" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">const</strong> newJob = [ {<br/>      "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>      "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>      "description": "Job from our export",<br/>      "created_at": "2020-07-15T10:24:40.975000000Z",<br/>      "status": "finished",<br/>}, ... job ]</span></pre><p id="105c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/3ed62887674f8bf350adf6289473e628.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DjG72mYAkj1sb5i-_zsEXg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/e935f5b3994b0e1079924fd75471cd00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HheJBHZIH0xXo1lXjUNdQw.png"/></div></div></figure><p id="a24a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在此测试:<a class="ae kv" href="https://jsperf.com/shallow-copying-of-large-array-of-objects-and-unshift" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/shallow-copy-of-large-array-of-objects-and-un shift</a></p><p id="f6bf" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">ES5的<code class="fe mz na nb mr b">slice</code>和<code class="fe mz na nb mr b">unshift</code>也比ES6的<code class="fe mz na nb mr b">spread</code>语法在将一个对象添加到一个大的对象数组中时表现得更好。</p><h2 id="b64e" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">连接两个小型基元数组</h2><p id="6bb5" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">阵列:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="d9f3" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const </strong>job = [1, 2, 3, 4, 5]<br/><strong class="mr ir">const </strong>toAdd = [6, 7, 8, 9, 10]</span></pre><p id="732e" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b310" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const</strong> result = job.concat(toAdd)</span><span id="8ffb" class="kw kx iq mr b gy nq mw l mx my">versus </span><span id="b33f" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">const</strong> result = [ ...job, ...toAdd]</span></pre><p id="07f2" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/4888331d18c436c0c7965f4a306451e0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jL2PWeXftaTIWAbYKrlmNQ.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/2d885b2e3199edc714ba3f5a51ed0974.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9aZmBN5hoXVeSUmPM9aw6g.png"/></div></div></figure><p id="ed14" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在这里测试:<a class="ae kv" href="https://jsperf.com/concatenating-two-small-arrays-of-primitives" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/concatenating-two-small-arrays-of-primitives</a></p><p id="5d42" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">ES6 <code class="fe mz na nb mr b">spread</code>在Chrome中速度更快，只有一个小数组(5个元素)。</p><h2 id="b548" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">连接两个大型基元数组</h2><p id="24cf" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">阵列:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="bc90" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">let</strong> jobs = [];<br/><strong class="mr ir">let </strong>toAdd = []</span><span id="248a" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">for </strong>(let i = 0; i &lt; 10000; i++) {<br/>  jobs.push(i)<br/>  toAdd.push(i)<br/>}</span></pre><p id="e29f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="2c97" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const</strong> result = jobs.concat(toAdd)</span><span id="4764" class="kw kx iq mr b gy nq mw l mx my">versus</span><span id="2bdf" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">const</strong> result = [ ...jobs, ...toAdd]</span></pre><p id="9cdc" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/5c28267a072e5ce6a0a4cd18d5dc7eb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y1hyOwS7GmkFAKpFDqEyOg.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/af300f1e426ed8e6229842cef06c76d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VTcW8fSTMcGPZ8zvTAOzBQ.png"/></div></div></figure><h2 id="62e5" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">连接两个小的对象数组</h2><p id="71b6" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">阵列:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="1b6e" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">let</strong> jobs = [];<br/><strong class="mr ir">let </strong>toAdd = []</span><span id="6204" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">for </strong>(let i = 0; i &lt; 5; i++) {<br/>  jobs.push({<br/>    "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>    "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>    "description": "Job from our export",<br/>    "created_at": "2020-07-15T10:24:40.975000000Z",<br/>    "status": "finished",<br/>  })</span><span id="0a67" class="kw kx iq mr b gy nq mw l mx my">  toAdd.push({<br/>    "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>    "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>    "description": "Job from our export",<br/>    "created_at": "2020-07-15T10:24:40.975000000Z",<br/>    "status": "finished",<br/>  })<br/>}</span></pre><p id="c72f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="89d6" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const</strong> result = jobs.concat(toAdd)</span><span id="a2af" class="kw kx iq mr b gy nq mw l mx my">versus</span><span id="7e36" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">const</strong> result = [ ...jobs, ...toAdd]</span></pre><p id="4721" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/86fb42e2d132f7e0297a9968ff22f629.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*v3I0X87khUJI3BrB5nUHuw.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/58c62c111ebf3a4f48ba128bd84d11e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dJ_aViOF6N_kRrVeH0Z9nA.png"/></div></div></figure><p id="81c3" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">ES6 <code class="fe mz na nb mr b">spread</code>在Chrome中有一个小的对象数组(5个元素)更快。</p><h2 id="c8b9" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">连接两个大型对象数组</h2><p id="31b2" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">阵列</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c44d" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">let</strong> jobs = [];<br/><strong class="mr ir">let </strong>toAdd = []</span><span id="4d42" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">for </strong>(let i = 0; i &lt; 10000; i++) {<br/>  jobs.push({<br/>    "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>    "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>    "description": "Job from our export",<br/>    "created_at": "2020-07-15T10:24:40.975000000Z",<br/>    "status": "finished",<br/>  })</span><span id="92a7" class="kw kx iq mr b gy nq mw l mx my">  toAdd.push({<br/>    "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>    "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>    "description": "Job from our export",<br/>    "created_at": "2020-07-15T10:24:40.975000000Z",<br/>    "status": "finished",<br/>  })<br/>}</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/2030e7e10b5c6b6e13c9d5a30ef782c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dBDOr9_GU94_urpJFHgVVQ.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/23b9730968322fddc7935806252e02e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bJqamxrSx9v5hlB6i9enLw.png"/></div></div></figure><p id="f322" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在这里测试:<a class="ae kv" href="https://jsperf.com/concatenating-two-large-arrays-of-objects" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/concatenating-two-large-arrays-of-objects</a></p><p id="a126" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">当处理更大的对象数组时，ES5的<code class="fe mz na nb mr b">concat</code>比ES6的<code class="fe mz na nb mr b">spread</code>快得多。</p><h2 id="b79a" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">在一个小的基元数组中查找元素</h2><p id="0bad" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">ES6引入了<code class="fe mz na nb mr b">find</code>方法来搜索数组中想要的元素。对于ES5，我们必须使用filter并获得结果的第0个元素。让我们比较一下这两者的性能。</p><p id="08cf" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a03f" class="kw kx iq mr b gy mv mw l mx my">[1, 2, 3, 4, 5].filter(<strong class="mr ir">function </strong>(x) { return x &gt; 3; })[0];</span><span id="9fd0" class="kw kx iq mr b gy nq mw l mx my">versus</span><span id="ba55" class="kw kx iq mr b gy nq mw l mx my">[1, 2, 3, 4, 5].find(x =&gt; x &gt; 3)</span></pre><p id="e018" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/f2d366fc0f1060ccbb8593a873d00226.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gUJpoQsKT2eiy3LEmgs8Mw.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/50eb3e724fe0f0522ea338715d65558b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sz3-t8iF1Yf70ylMDhUDBQ.png"/></div></div></figure><p id="9f0c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在这里测试:<a class="ae kv" href="https://jsperf.com/finding-an-element-in-a-small-array-of-primitives/2" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/finding-an-element-in-a-small-array-of-primitives/2</a></p><p id="5869" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">ES6 <code class="fe mz na nb mr b">find</code>比使用<code class="fe mz na nb mr b">filter</code>并返回第0个找到的元素要快得多并不奇怪，因为<code class="fe mz na nb mr b">find</code>一旦找到一个元素就会短路，而<code class="fe mz na nb mr b">filter</code>会返回<em class="nu">所有符合条件的</em>元素。</p><h2 id="3fa1" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">在大量图元中查找元素</h2><p id="3d95" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">让我们用一个更大的数组来试试上面的方法。</p><p id="c321" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">阵列:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="9ea0" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">let</strong> jobs = [];<br/>    <br/><strong class="mr ir">for</strong> (<strong class="mr ir">let</strong> i = 0; i &lt; 10000; i++) {<br/>   jobs.push(i)<br/>}</span></pre><p id="c018" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="bec2" class="kw kx iq mr b gy mv mw l mx my">jobs.filter(<strong class="mr ir">function</strong> (x) { return x &gt; 8888; })[0];</span><span id="77e2" class="kw kx iq mr b gy nq mw l mx my">versus</span><span id="c095" class="kw kx iq mr b gy nq mw l mx my">jobs.find(x =&gt; x &gt; 8888)</span></pre><p id="bf4e" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/e91833f9d2953710be5fc884f7f22388.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*B41WXE356dR-6tVnXaEnqA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/c6526b15d7bbec77908a7e52f6123f17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gfHrLZJ5WzgoK3n8Pj_l8Q.png"/></div></div></figure><p id="4e90" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在这里测试:<a class="ae kv" href="https://jsperf.com/finding-an-element-in-a-large-array-of-primitives" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/finding-an-element-in-a-large-array-of-primitives</a></p><p id="74e9" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">ES6 <code class="fe mz na nb mr b">find</code>在两种浏览器中都更快，但是当我们在寻找数组末尾的东西时，对于更大的数组，速度没有那么快。</p><h2 id="6cc3" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">串联小字符串</h2><p id="533e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">这里有一个非常常见的场景，我们使用的任何解决方案都不太可能是昂贵的，但是比较使用在每个单词之间添加+的“旧”语法和模板文字会很有趣。</p><p id="e6f0" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">要连接的变量:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="a076" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const</strong> dog = 'dog';<br/><strong class="mr ir">const</strong> fox = 'fox';</span></pre><p id="078f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c5d3" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const </strong>expression = 'The quick brown ' + fox + ' jumped over the lazy ' + dog + '.'</span><span id="99a5" class="kw kx iq mr b gy nq mw l mx my">versus</span><span id="669b" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">const </strong>expression = `The quick brown ${fox} jumped over the lazy ${dog}.`</span></pre><p id="8356" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/fc31864d404d5eec1d7f8d8204bed6b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VPHhsshxeQdHgf3pJFprkA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nx"><img src="../Images/bd9d32ddce64b1ad31265caae5dba85a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cMxvo4QSv616Q0j83GSByQ.png"/></div></div></figure><p id="e78d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在这里测试:<a class="ae kv" href="https://jsperf.com/concatenating-strings-plus-vs-template-literal" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/concating-strings-plus-vs-template-literal</a></p><p id="1b68" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">有点令人惊讶的是，Chrome和V8引擎在模板文字方面做得不好，但每秒6800万次操作不太可能在大多数应用程序中产生影响。</p><h2 id="0f63" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">串联大字符串</h2><p id="8aeb" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">让我们尝试将相同的变量插入到更大的字符串中。</p><p id="0bbe" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">要连接的变量:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="c8eb" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">const</strong> dog = 'dog';<br/><strong class="mr ir">const</strong> fox = 'fox';</span></pre><p id="0c58" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">逻辑是:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="21f8" class="kw kx iq mr b gy mv mw l mx my">Insert the two variables 'dog' and 'fox' at the same places into a 32000 long string</span></pre><p id="e6b3" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><p id="3402" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">太大无法张贴，见此链接<a class="ae kv" href="https://jsperf.com/concatenating-large-strings" rel="noopener ugc nofollow" target="_blank">https://jsperf.com/concatenating-large-strings</a></p><p id="1c7d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">测试这里:<a class="ae kv" href="https://jsperf.com/concatenating-large-strings" rel="noopener ugc nofollow" target="_blank">https://jsperf.com/concatenating-large-strings</a></p><p id="7931" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">大型字符串的性能与小型字符串几乎相同，Chrome的V8引擎更倾向于使用+来连接，而Firefox的Spidermonkey引擎两者都不喜欢。</p><h2 id="f936" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">默认功能参数值基本功能</h2><p id="888e" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">ES6增加了在函数签名本身中指定默认函数参数值的能力。让我们来看看一个基本函数的性能比较。</p><p id="1a1c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">函数调用:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="5a99" class="kw kx iq mr b gy mv mw l mx my">squareNumber(undefined);</span></pre><p id="c01a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="39f0" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">function</strong> squareNumber(numberToSquare) {<br/>    if (numberToSquare == undefined || numberToSquare == null) {<br/>        numberToSquare = 1; <br/>    }<br/>        <br/>    return numberToSquare * numberToSquare;<br/>}</span><span id="97ca" class="kw kx iq mr b gy nq mw l mx my">versus</span><span id="4ffd" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">function </strong>squareNumber(numberToSquare = 1) {</span><span id="6131" class="kw kx iq mr b gy nq mw l mx my">    return numberToSquare * numberToSquare;</span><span id="e3a0" class="kw kx iq mr b gy nq mw l mx my">}</span></pre><p id="2c6a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/5756caef862642cb2f017b6417bfc084.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*flcBrQJqge5MmCrGJTydEw.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nr"><img src="../Images/f9124807bd401ef5737cc1efaf3592fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mjb9PLGS2EcXNuyxY6cfdw.png"/></div></div></figure><p id="3789" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在这里测试:<a class="ae kv" href="https://jsperf.com/default-function-parameter-values-basic-function/2" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/default-function-parameter-values-basic-function/2</a></p><p id="5b3e" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在任一浏览器中，这两种解决方案几乎没有区别。</p><h2 id="c096" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用小对象解构对象赋值</h2><p id="42d6" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">有时我们想从一个对象的单个属性中创建变量。ES6为此引入了一些新的语法糖。</p><p id="d71b" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">对象:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="b2b3" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">function</strong> getJob() {<br/>     <strong class="mr ir">return</strong> {<br/>      "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>      "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>      "description": "Job from our export",<br/>      "created_at": "2020-07-15T10:24:40.975000000Z",<br/>      "status": "finished",<br/>    }<br/>}</span></pre><p id="110f" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="ad0b" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">var</strong> job = getJob();<br/><strong class="mr ir">var</strong> updated_at = job.updated_at;<br/><strong class="mr ir">var</strong> job_id = job.job_id;<br/><strong class="mr ir">var</strong> description = job.description;<br/><strong class="mr ir">var</strong> created_at = job.created_at;<br/><strong class="mr ir">var</strong> status = job.status;</span><span id="b33b" class="kw kx iq mr b gy nq mw l mx my">versus </span><span id="2cf5" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">var</strong> { updated_at, job_id, description, created_at, status } = getJob();</span></pre><p id="504c" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oc"><img src="../Images/1eb0dd4226318e0765e66b271a6e937f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F-0Gw_S0tBHr9rbv82HpvA.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/b93e4ea252e915aea836063d1e961155.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZkVkCBbFUELtCDBrZ7OkVg.png"/></div></div></figure><p id="4f5e" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">此处测试:<a class="ae kv" href="https://jsperf.com/destructuring-assignment-object" rel="noopener ugc nofollow" target="_blank">https://jsperf.com/destructuring-assignment-object</a></p><p id="b096" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">Chrome的性能非常相似，但是Firefox的ES6语法要快一些。也许额外变量(<code class="fe mz na nb mr b">job</code>)的创建会稍微减慢它的速度。</p><h2 id="0682" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用小对象深度解构对象赋值</h2><p id="55d5" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">让我们看看上面是如何处理一些更深层次的属性的。</p><p id="3283" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">对象:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="7031" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">function</strong> getJob() {<br/>     <strong class="mr ir">return</strong> {<br/>        metadata: {<br/>          "updated_at": "2020-07-15T10:24:42.364000000Z",<br/>          "job_id": "4b1733e7-c8e0-4fdd-a7f1-13d3ab725c92",<br/>          "description": "Job from our export",<br/>          "created_at": "2020-07-15T10:24:40.975000000Z",<br/>          "status": "finished"<br/>        }<br/>    }<br/>  }</span></pre><p id="ac80" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="17d8" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">var</strong> job = getJob();<br/><strong class="mr ir">var</strong> updated_at = job.metadata.updated_at;<br/><strong class="mr ir">var</strong> job_id = job.metadata.job_id;<br/><strong class="mr ir">var</strong> description = job.metadata.description;<br/><strong class="mr ir">var</strong> created_at = job.metadata.created_at;<br/><strong class="mr ir">var</strong> status = job.metadata.status;</span><span id="133e" class="kw kx iq mr b gy nq mw l mx my">versus</span><span id="7a98" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">var</strong> { <br/>  metadata: { updated_at, job_id, description, created_at, status },<br/>} = getJob();</span></pre><p id="3298" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nw"><img src="../Images/4e94d75cbd7f229d836085d9c39b0ce7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c2-3zlBVLWToLXGMwcDbyQ.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/4cc400eea658ecf7abc501d840983053.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iId0bJwqKPTFKV-OkvBasw.png"/></div></div></figure><p id="0d47" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在这里测试:<a class="ae kv" href="https://jsperf.com/destructuring-assignment-object-deep" rel="noopener ugc nofollow" target="_blank">https://jsperf.com/destructuring-assignment-object-deep</a></p><p id="05d1" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">这里没有太多内容，但是随着我们越来越深入，我们在Firefox中的速度可能会变慢。</p><h2 id="8b4c" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">用小对象进行非常深的析构对象赋值</h2><p id="b457" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">让我们试着从一个嵌套很深的对象中获取一个属性。</p><p id="e763" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">对象:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="e58f" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">function</strong> getJob() {<br/>    <strong class="mr ir">return</strong> {<br/>        "castle": {<br/>            "recently": {<br/>                "name": {<br/>                    "brain": {<br/>                        "parent": "every"<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="fad3" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="5f5f" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">var</strong> parent = getJob().castle.recently.name.brain.parent;</span><span id="0631" class="kw kx iq mr b gy nq mw l mx my">versus</span><span id="7846" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">var </strong>{ <br/>     castle: { recently: { name: { brain: { parent } } } } <br/>} = getJob();</span></pre><p id="42b4" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/e7d2a2f9036f19e237941669fd76fe7e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GHRmvN1BMdFxO-AhuECa1A.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/450087568030d87b907a05e7bc63833a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x0TwpEvU-zR2I6lnWQuL-Q.png"/></div></div></figure><p id="6c7d" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在这里测试:<a class="ae kv" href="https://jsperf.com/variable-assignment-vs-es6-shorthand-deep-object" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/variable-assignment-vs-es6-速记-深度-对象</a></p><p id="f242" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">当提取<em class="nu">一个</em>属性时，使用深度析构的速记语法在两种浏览器中都稍微快了一些。</p><h2 id="c473" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">具有小对象的非常深的析构对象赋值—多个属性</h2><p id="4bec" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">让我们用一个类似于上面的对象来试一下，只是检索多个属性。</p><p id="9ab5" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">对象:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="06e1" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">function</strong> getJob() {<br/>    <strong class="mr ir">return</strong> {<br/>        "castle": {<br/>            "recently": {<br/>                "name": {<br/>                    "brain": {<br/>                        "parent": "every",</span><span id="48eb" class="kw kx iq mr b gy nq mw l mx my">                        "foo": "bar",</span><span id="9179" class="kw kx iq mr b gy nq mw l mx my">                        "javascript": "isFun"<br/>                    }<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><p id="79f9" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">竞争者:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="54a3" class="kw kx iq mr b gy mv mw l mx my"><strong class="mr ir">var</strong> job = getJob();<br/><strong class="mr ir">var </strong>parent = job.castle.recently.name.brain.parent;<br/><strong class="mr ir">var </strong>foo = job.castle.recently.name.brain.foo;<br/><strong class="mr ir">var </strong>javascript = job.castle.recently.name.brain.javascript;</span><span id="a37f" class="kw kx iq mr b gy nq mw l mx my">versus</span><span id="eceb" class="kw kx iq mr b gy nq mw l mx my"><strong class="mr ir">var </strong>{ <br/>     castle: { recently: { name: { brain: { parent, foo, javascript } } } } <br/>} = getJob();</span></pre><p id="9d81" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">结果是:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/f3a52b157cb7c061c35ccb3cad87ee4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4FZBtaYVY5FRkICLqlm1fQ.png"/></div></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/a78e71e6332f276329240d3fce3fed50.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5vshXluzizvPIIm2GmN9PA.png"/></div></div></figure><p id="c232" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">在这里测试:<a class="ae kv" href="https://jsperf.com/variable-assignments-vs-es6-shorthand-deep-object" rel="noopener ugc nofollow" target="_blank">https://jsperf . com/variable-assignments-vs-es6-速记-深度-对象</a></p><p id="23d9" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">当从一个深层对象中提取多个变量时，结果还是一样的。</p><h1 id="956d" class="oe kx iq bd ky of og oh lb oi oj ok le jw ol jx li jz om ka lm kc on kd lq oo bi translated">外卖食品</h1><ol class=""><li id="899b" class="nc nd iq lu b lv lw ly lz lf op lj oq ln or mk nh ni nj nk bi translated">当搜索大小数组数字时，ES6的<code class="fe mz na nb mr b">includes</code>胜过<code class="fe mz na nb mr b">indexOf</code>，随着<a class="ae kv" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank"> Chrome的V8 JavaScript引擎</a>(与<a class="ae kv" href="https://nodejs.org/en/" rel="noopener ugc nofollow" target="_blank"> Node.js </a>使用的引擎相同)性能大大提高，我们搜索的数字越接近数组的开始</li><li id="abe7" class="nc nd iq lu b lv nl ly nm lf nn lj no ln np mk nh ni nj nk bi translated">当使用ES6扩展时，浅层复制小和大的<em class="nu">对象</em>在两个引擎中都更快(Chrome的V8，<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" rel="noopener ugc nofollow" target="_blank"> Firefox的Spidermonkey </a>),即<code class="fe mz na nb mr b">var myNewObject = { ...myObject }</code>超过<code class="fe mz na nb mr b">myNewObject = Object.assign({}, myObject)</code></li><li id="bc06" class="nc nd iq lu b lv nl ly nm lf nn lj no ln np mk nh ni nj nk bi translated">在Chrome和Firefox中，使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="noopener ugc nofollow" target="_blank"> slice </a>即<code class="fe mz na nb mr b">var myNewArray = myArray.slice()</code> over <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> spread </a> <code class="fe mz na nb mr b">var myNewArray = [ ...myArray ]</code>来浅层复制小型和大型<em class="nu">数组</em>原语和小型对象数组要快得多。然而，在Chrome中浅层复制一个包含10000个小对象的数组，这两种方法的效果是一样的。火狐还是比较喜欢<code class="fe mz na nb mr b">slice</code></li><li id="e5ad" class="nc nd iq lu b lv nl ly nm lf nn lj no ln np mk nh ni nj nk bi translated">当处理大型对象数组(10000个元素)时，<code class="fe mz na nb mr b">myArray.slice().push</code>和<code class="fe mz na nb mr b">myArray.slice.unshift()</code>在两种浏览器中的表现都比它们的ES6对手<code class="fe mz na nb mr b">[ ...myArray, newObject ]</code>和<code class="fe mz na nb mr b">[ newObject, ...myArray]</code>要好</li><li id="1b7b" class="nc nd iq lu b lv nl ly nm lf nn lj no ln np mk nh ni nj nk bi translated">在Chrome中，使用<code class="fe mz na nb mr b">[ ...myArray, ...mySecondArray ]</code>连接对象的小数组和原语的小数组(5个元素)要比使用<code class="fe mz na nb mr b">myArray.concat(mySecondArray)</code>快得多，在Firefox中也是如此</li><li id="2481" class="nc nd iq lu b lv nl ly nm lf nn lj no ln np mk nh ni nj nk bi translated">在两种浏览器中，使用<code class="fe mz na nb mr b">[ ...myArray, ...mySecondArray ]</code>连接大型对象数组和大型原语数组(10000个元素)要比使用<code class="fe mz na nb mr b">myArray.concat(mySecondArray)</code>慢得多<em class="nu"/></li><li id="e099" class="nc nd iq lu b lv nl ly nm lf nn lj no ln np mk nh ni nj nk bi translated">使用ES6的<code class="fe mz na nb mr b">find</code>代替ES5的<code class="fe mz na nb mr b">filter</code>并返回找到的第0个元素对于大数组和小数组来说要快得多</li><li id="60f8" class="nc nd iq lu b lv nl ly nm lf nn lj no ln np mk nh ni nj nk bi translated">与在字符串和变量之间使用+相比，Chrome在使用模板文字语法连接字符串时速度较慢</li></ol><p id="f87e" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">感谢您的阅读，我希望这能让您对ES5和ES6+在执行类似功能时的性能有所了解。</p><p id="ab61" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">如果您对如何改进上述测试有任何建议，或者您希望我测试一些不同的场景，请留下评论。</p><p id="417a" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">干杯，</p><p id="49dc" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">抢劫</p><p id="1b74" class="pw-post-body-paragraph ls lt iq lu b lv ml jr lx ly mm ju ma lf mn mc md lj mo mf mg ln mp mi mj mk ij bi translated">参考资料:</p><ol class=""><li id="bee2" class="nc nd iq lu b lv ml ly mm lf ne lj nf ln ng mk nh ni nj nk bi translated">用jsPerf完成的所有测试—<a class="ae kv" href="https://jsperf.com/browse/robertdempsey" rel="noopener ugc nofollow" target="_blank">https://jsperf.com/browse/robertdempsey</a></li><li id="463a" class="nc nd iq lu b lv nl ly nm lf nn lj no ln np mk nh ni nj nk bi translated"><a class="ae kv" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank"> V8 JavaScript引擎</a></li><li id="9426" class="nc nd iq lu b lv nl ly nm lf nn lj no ln np mk nh ni nj nk bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" rel="noopener ugc nofollow" target="_blank">蜘蛛猴JavaScript引擎</a></li><li id="acab" class="nc nd iq lu b lv nl ly nm lf nn lj no ln np mk nh ni nj nk bi translated"><a class="ae kv" href="http://es6-features.org/#Constants" rel="noopener ugc nofollow" target="_blank">此处发现的ES6特性</a></li></ol><h2 id="69c6" class="kw kx iq bd ky kz la dn lb lc ld dp le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">简单英语的JavaScript</h2><p id="f111" class="pw-post-body-paragraph ls lt iq lu b lv lw jr lx ly lz ju ma lf mb mc md lj me mf mg ln mh mi mj mk ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="lu ir">！</strong></p></div></div>    
</body>
</html>