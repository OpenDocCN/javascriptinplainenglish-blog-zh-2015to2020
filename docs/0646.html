<html>
<head>
<title>I created the exact same app in React and Svelte. Here are the differences.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在React和Svelte中创建了完全相同的应用程序。以下是不同之处。</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/i-created-the-exact-same-app-in-react-and-svelte-here-are-the-differences-c0bd2cc9b3f8?source=collection_archive---------0-----------------------#2019-11-21">https://javascript.plainenglish.io/i-created-the-exact-same-app-in-react-and-svelte-here-are-the-differences-c0bd2cc9b3f8?source=collection_archive---------0-----------------------#2019-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bc6e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">反应vs苗条。最后一个并列代码对比！因为你已经听到了关于苗条的大惊小怪，现在你想知道炒作是怎么回事。</h2></div><p id="c4b8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在工作中使用过React之后，我对它有了相当扎实的理解。然而，我听说过Svelte——一种新的JavaScript框架，最近开始在web开发领域获得关注。作为一名好奇的Web开发人员，我一直很想知道栅栏另一边的草是什么样的——在这种情况下，草是细长的。</p><p id="0bb1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我读了苗条的医生，看了几个视频，虽然它们很有用，但我真正想知道的是苗条和反应有什么不同。我说的<em class="lb">【不同】</em>，并不是指诸如Svelte是否使用了虚拟DOM或者它如何渲染页面之类的事情。我希望有人花时间解释一下，如果我用苗条的身材写了同样的东西，我的React代码会是什么样子！我想找一篇花时间解释这一点的文章，以便刚刚接触React或Svelte(或整个Web开发)的人能够更好地理解这两者之间的区别。</p><p id="329b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，我找不到任何解决这个问题的方法。所以我意识到，我必须自己动手建造它，才能看到相似之处和不同之处。在这样做的时候，我想我应该把整个过程记录下来，这样一篇关于这个的文章就会最终存在。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/cd68816de76d1e85f410b75b3bf5083a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ob02GMVKhUQJH9YqQLdoWA.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">React vs Svelte: A new challenger approaches!</figcaption></figure><p id="76d4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我决定尝试构建一个相当标准的待办事项应用程序，允许用户在列表中添加和删除项目。这两款应用都是使用CLIs构建的(<code class="fe ls lt lu lv b">create-react-app</code>用于React，<code class="fe ls lt lu lv b">sveltejs/template</code>用于Svelte)。</p><p id="acb4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">顺便说一下,<em class="lb"> CLI代表命令行界面。🤓</em></p><h1 id="9c4a" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">无论如何，这个介绍已经比我预期的要长了。让我们先来快速了解一下这两款应用的外观:</h1><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mo"><img src="../Images/36279429d0f160f44ef980cd08b4e0f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9polCAouiiVgAEHpR2JKSA.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">React vs Svelte. The two apps look the same, but does the code look the same too?</figcaption></figure><p id="df7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两个应用程序的CSS代码完全相同，但是它们的位置不同。记住这一点，接下来让我们看看这两个应用程序的文件结构:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi mp"><img src="../Images/7946552ef5421522ad2e1a3055cbf996.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_gnEpGffXWx0RhoRBP__w.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">React on the left. Svelte on the right.</figcaption></figure><p id="41f6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会看到它们的结构在这里有很大的不同。</p><p id="96f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React在<strong class="kh ir"> src </strong>文件夹中拥有所有组件、样式和资产，而Svelte要求资产直接位于<strong class="kh ir"> public </strong>文件夹中。您还会注意到没有任何<strong class="kh ir">。这是因为样式是在<strong class="kh ir">中定义的。纤细的</strong>文件(稍后会详细介绍)。</strong></p><p id="bba6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还会注意到——对于Svelte——有一些用于汇总的<strong class="kh ir">配置</strong>文件。对于那些不知道的人，Rollup基本上是一个Webpack等价物，Svelte选择使用它。</p><p id="0cff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，你会注意到在<strong class="kh ir">公共</strong>文件夹中已经有一些<strong class="kh ir">包</strong>文件。这些是我在我的本地主机上试着提供苗条的ToDo应用程序后创建的。与React不同，Svelte的CLI会在您尝试启动本地服务器时自动生成这些文件。这些实际上是提供给你的文件，是来自<strong class="kh ir">的所有代码的编译。苗条的</strong>文件。</p><p id="3d34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是Svelte反应不同的一个关键点。在React中，如果你要编译你的代码以便准备好发送到产品并在线发布，你通常会在你的<strong class="kh ir">公共</strong>文件中结束类似的结构，但是在开发时，如果你要将你的React ToDo应用程序提供给本地服务器，你不会看到这些<strong class="kh ir">捆绑</strong>文件， 当你的代码被Webpack编译，然后在你的本地主机上提供给你——并且有效地位于缓存中的某个地方，而Rollup编译苗条的代码并使它在<strong class="kh ir"> public </strong>文件夹中对你可见。 这里引起的另一个区别是React的Webpack设置允许热模块重新加载(这基本上意味着代码将在您的浏览器中非常快速地更新，因为您在开发期间进行了更新。对于Svelte的Rollup设置，这是不可能的，因为每当你点击保存按钮对代码进行更新时，那些<strong class="kh ir">包</strong>文件就会被有效地重新编译，尽管速度很快。</p><p id="914d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终，文件结构和编译方法实现了同样的事情，只是方式不同。</p><p id="1488" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">喜欢这篇文章吗？如果有，获取更多类似内容通过</em> <a class="ae mq" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lb">订阅解码，我的YouTube频道</em> </strong> </a> <strong class="kh ir"> <em class="lb">！</em>T25】</strong></p><p id="575d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">暂时回到React的CSS设置，没什么可说的，您不能继续前进，以不同的方式构造您的CSS，以采用将您的样式放在与组件相同的文件中的东西。真的归结为个人喜好。您将会听到来自开发社区的关于CSS应该如何构建的大量讨论，特别是关于React，因为有许多CSS-in-JS解决方案，如styled-components和emotion。顺便说一下，CSS-in-JS就是字面上的意思。虽然这些都很有用，但现在，我们将只遵循两个CLI中的结构。</p><h2 id="7258" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">在我们继续之前，让我们快速看一下一个典型的React和like组件是什么样子的:</h2><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi nd"><img src="../Images/dfc8e4076bf386354da696df17aa4f5d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jusfKFvNcq_XyV6UsOMNKA.png"/></div></div></figure><p id="1cab" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们进入本质的细节！</p><h1 id="5286" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">创建新的应用程序</h1><h2 id="40f4" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">反应</h2><p id="fb52" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">使用npm，在您的终端/命令行中运行以下命令:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="fab6" class="mr lx iq lv b gy nn no l np nq">npx create-react-app react-todo</span></pre><p id="f7e0" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将为您创建一个名为“react-todo”的项目，其中包含您开始工作所需的一切。我们对为本文创建的应用程序使用了相同的过程。</p><h2 id="a5d7" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">苗条的</h2><p id="a1b0" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">使用npm，在您的终端/命令行中运行以下命令:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="9871" class="mr lx iq lv b gy nn no l np nq">npx <!-- -->degit sveltejs/template svelte-todo</span></pre><p id="d25f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将为您创建一个名为“svelte-todo”的项目，其中包含您开始所需的一切。我们对为本文创建的应用程序使用了相同的过程。</p><h1 id="c7b8" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">我们如何改变数据？</h1><p id="761c" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">但是首先，我们所说的“变异数据”是什么意思？听起来有点专业，不是吗？它基本上只是意味着改变我们已经存储的数据。所以，如果我们想把一个人的名字从约翰改成马克，我们就要“改变数据”。因此，我们改变数据的方式展示了React和Svelte之间的关键区别。</p><p id="a277" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然Svelte本质上允许数据自由更新(例如，我们可以将项目推入数据数组，重新分配我们的数据等)，但React通过所谓的状态挂钩来处理这一点。</p><p id="8a9f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看下图中两者的设置，然后我们将解释接下来会发生什么:</p><div class="ld le lf lg gt ab cb"><figure class="nr lh ns nt nu nv nw paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><img src="../Images/1453657ea24e55aeb25742efb9dadba8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/0*NNgqC-aO4mx_kkoV.png"/></div></figure><figure class="nr lh nx nt nu nv nw paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><img src="../Images/963651df3d4c21746c6a7647f23b4cd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*jDw9djDXDxGbVoZLA8PYFg.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk ny di nz oa">React on the left. Svelte on the right.</figcaption></figure></div><p id="d42e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，您可以看到，我们将相同的数据传递给了两者，但结构略有不同。</p><p id="43ca" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用React——或者至少从2019年开始——我们通常会通过一系列挂钩来处理状态。如果你以前没有见过这种类型的概念，这些可能看起来有点奇怪。基本上，它的工作方式如下:</p><p id="50d1" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们想要创建一个待办事项列表。我们可能需要创建一个名为<code class="fe ls lt lu lv b">list</code>的变量，它可能需要一个字符串或者对象的数组(如果我们想给每个<code class="fe ls lt lu lv b">todo</code>字符串一个ID或者一些其他的东西。我们可以通过写<code class="fe ls lt lu lv b">const [list, setList] = useState([])</code>来设置这个。这里我们使用了React称之为钩子的东西useState。这基本上让我们在组件中保持本地状态。</p><p id="4750" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，你可能已经注意到我们在<code class="fe ls lt lu lv b">useState()</code>中传递了一个空数组<code class="fe ls lt lu lv b">[]</code>。我们放在里面的是我们希望<code class="fe ls lt lu lv b">list</code>最初被设置的值，在我们的例子中，我们希望它是一个空数组。然而，你会从上面的图片中看到，我们在数组内部传入了一些数据，这些数据最终成为了<code class="fe ls lt lu lv b">list</code>的初始化数据。想知道<code class="fe ls lt lu lv b">setList</code>是干什么的？稍后会有更多关于这个的内容！</p><p id="0928" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用Svelte，你会注意到我们有两个变量要输出。这些文件位于我们的<strong class="kh ir"> ToDo.svelte </strong>文件中，但是如果我们愿意，也可以放在route <strong class="kh ir"> App.svelte </strong>文件中更高的位置。</p><p id="606b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论如何，让我们再看一看它们，然后我们会解释这是怎么回事:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="2bbd" class="mr lx iq lv b gy nn no l np nq">export let todo = "";<br/>export let list = [<br/>  { id: 1, text: "clean the house" },<br/>  { id: 2, text: "buy eggs" }<br/>];</span></pre><p id="04e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以对于Svelte，如果我们想在我们的文件中引用像<code class="fe ls lt lu lv b">todo</code>和<code class="fe ls lt lu lv b">list</code>这样的东西，我们需要在同一个文件的某个地方创建一个对它们的引用。</p><p id="f009" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与React或大多数其他JavaScript没有什么不同，无论是通过创建变量、导入变量，还是将变量作为道具传递给组件。这里的不同之处在于，我们实际上是在创建新的变量(<em class="lb">与</em> <code class="fe ls lt lu lv b"><em class="lb">let</em></code> <em class="lb">，而不是</em> <code class="fe ls lt lu lv b"><em class="lb">const</em></code> <em class="lb">，因为那样会阻止我们对其进行变异——或者如果我们想从技术上了解</em> <code class="fe ls lt lu lv b"><em class="lb">const</em></code> <em class="lb">如何工作</em>)的话，可以对其进行重新分配。我之所以提到我们必须创建新的变量，是因为你稍后会注意到，我们必须在我们想要引用它们的每个文件中这样做，即使它们已经作为道具传递了。基本上，Svelte会将值传递给那些新创建的变量。如果你感到困惑，就继续读下去，当我们以后再次提到它时，你会看到它是如何工作的。</p><p id="5416" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么，我们如何在我们苗条的应用程序中引用可变数据呢？</p><p id="d431" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">好吧，假设我们有一些名为<code class="fe ls lt lu lv b">name</code>的数据，它被赋予了一个值<code class="fe ls lt lu lv b">‘Sunil<strong class="kh ir">’</strong></code>。</p><p id="8e1f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Svelte中，这个<code class="fe ls lt lu lv b">let name = Sunil</code>，要么在一个组件中被创建并作为道具传递给另一个组件，要么在创建它的组件内部被使用。不管我们如何使用<code class="fe ls lt lu lv b">name</code>，我们都可以通过简单地重新分配<code class="fe ls lt lu lv b">name</code>来更新它。所以我可以写<code class="fe ls lt lu lv b">name = ‘John'</code>，我们可以在UI的屏幕上看到更新。我不确定我被叫做约翰是什么感觉，但是嘿，事情发生了！😅</p><p id="0a94" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在React中，由于我们有用<code class="fe ls lt lu lv b">useState()</code>创建的更小的状态片段，很可能我们会按照<code class="fe ls lt lu lv b">const [name, setName] = useState('Sunil')</code>的思路创建一些东西。在我们的应用程序中，我们将通过简单地调用<code class="fe ls lt lu lv b">name</code>来引用相同的数据。现在这里的关键区别是，我们不能简单地编写<code class="fe ls lt lu lv b">name = ‘John’</code>，因为React有适当的限制来防止这种容易的、无忧无虑的变异。所以在React中，我们会写<code class="fe ls lt lu lv b">setName('John')</code>。这就是<code class="fe ls lt lu lv b">setName</code>位发挥作用的地方。基本上，在<code class="fe ls lt lu lv b">const [name, setName] = useState('Sunil')</code>中，它创建了两个变量，一个成为<code class="fe ls lt lu lv b">const name = 'Sunil'</code>，而第二个<code class="fe ls lt lu lv b">const setName</code>被赋予一个函数，使<code class="fe ls lt lu lv b">name</code>能够用一个新值重新创建。</p><p id="1b63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Effectively React和Svelte在这里做着同样的事情，即创建可以更新的数据。默认情况下，每当有数据更新时，Svelte本质上结合了自己版本的<code class="fe ls lt lu lv b">name</code>和<code class="fe ls lt lu lv b">setName</code>。所以简而言之，React要求你用里面的值调用<code class="fe ls lt lu lv b">setName()</code>来更新状态，Svelte假设如果你曾经试图更新出现在DOM中的值(即我们可以在浏览器屏幕上看到的值)。那么为什么React还要费心从函数中分离出值，为什么还需要<code class="fe ls lt lu lv b">useState()</code>？这是因为这意味着无论何时状态改变，它都需要重新渲染。它会知道状态已经改变，因为调用了useState函数。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi ob"><img src="../Images/f91dae598f3505286c6d90a6c36b9f5c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*XyX9aVsjdVTFEoWX.png"/></div></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Bean knew best.</figcaption></figure><p id="601d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经有了一些变化，让我们看看如何在我们的待办事项应用程序中添加新的项目，从而进入本质。</p><h1 id="5411" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">我们如何创建新的待办事项？</h1><h2 id="a2aa" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">反应:</h2><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="c889" class="mr lx iq lv b gy nn no l np nq"><strong class="lv ir">const createNewToDoItem = () =&gt; {</strong></span><span id="d655" class="mr lx iq lv b gy oc no l np nq">  const newId = list.length ? <br/>                Math.max.apply(null, list.map(t =&gt; t.id)) + 1 :<br/>                1;</span><span id="152c" class="mr lx iq lv b gy oc no l np nq">  const newToDo = { id: newId, text: toDo };  <br/>  setList([...list, newToDo]);<br/>  setToDo("");</span><span id="0ae6" class="mr lx iq lv b gy oc no l np nq"><strong class="lv ir">};</strong></span></pre><h2 id="f191" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">React是怎么做到的？</h2><p id="f5c8" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">在React中，我们的输入字段有一个名为<strong class="kh ir"> value的属性。</strong>每当这个值通过所谓的<strong class="kh ir"> onChange事件监听器</strong>改变时，这个值就会自动更新。JSX(基本上是HTML的一种变体)如下所示:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="1dc9" class="mr lx iq lv b gy nn no l np nq">&lt;input type="text" <br/>       value={toDo} <br/>       onChange={handleInput}/&gt;</span></pre><p id="a80f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以每次值改变时，它更新状态。<code class="fe ls lt lu lv b">handleInput</code>函数看起来像这样:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="ed92" class="mr lx iq lv b gy nn no l np nq"><strong class="lv ir">const handleInput = (e) =&gt; {</strong><br/>  setToDo(e.target.value);<br/><strong class="lv ir">};</strong></span></pre><p id="f11f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，每当用户按下页面上的<strong class="kh ir"> + </strong>按钮来添加新项目时，就会触发<strong class="kh ir">createnewdoitem</strong>功能。让我们再来看一下这个函数，以分解正在发生的事情:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="fcda" class="mr lx iq lv b gy nn no l np nq"><strong class="lv ir">const createNewToDoItem = () =&gt; {</strong></span><span id="4958" class="mr lx iq lv b gy oc no l np nq">  const newId = list.length ? <br/>                Math.max.apply(null, list.map(t =&gt; t.id)) + 1 :<br/>                1;</span><span id="91e9" class="mr lx iq lv b gy oc no l np nq">  const newToDo = { id: newId, text: toDo };  <br/>  setList([...list, newToDo]);<br/>  setToDo("");</span><span id="12bc" class="mr lx iq lv b gy oc no l np nq"><strong class="lv ir">};</strong></span></pre><p id="de9f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本质上，<code class="fe ls lt lu lv b">newId</code>函数基本上是创建一个新的ID，我们将赋予新的<code class="fe ls lt lu lv b">toDo</code>项目。<code class="fe ls lt lu lv b">newToDo</code>变量是一个对象，它有一个<code class="fe ls lt lu lv b">id</code>键，键的值来自<code class="fe ls lt lu lv b">newId</code>。它还有一个<code class="fe ls lt lu lv b">text</code>键，将来自<code class="fe ls lt lu lv b">toDo</code>的值作为其值。这与输入值改变时更新的<code class="fe ls lt lu lv b">toDo</code>相同。</p><p id="ee84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们运行<code class="fe ls lt lu lv b">setList</code>函数，并传入一个数组，该数组包含我们的整个<code class="fe ls lt lu lv b">list</code>以及新创建的<code class="fe ls lt lu lv b">newToDo</code>。</p><p id="4b21" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe ls lt lu lv b">...list</code>位看起来很奇怪，那么开头的三个点就是所谓的spread运算符，它基本上传递来自<code class="fe ls lt lu lv b">list</code>的所有值，但作为单独的项，而不是简单地将整个项数组作为数组传递。迷茫？如果是这样，我强烈推荐阅读spread，因为它很棒！</p><p id="1aa2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，最后我们运行<code class="fe ls lt lu lv b">setToDo()</code>并传入一个空字符串。这使得我们的输入值为空，准备好输入新的toDos。</p><h2 id="d376" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">苗条:</h2><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="9dd4" class="mr lx iq lv b gy nn no l np nq"><strong class="lv ir">createNewToDoItem() {</strong></span><span id="d924" class="mr lx iq lv b gy oc no l np nq">  const newId = list.length ? <br/>                Math.max.apply(null, list.map(t =&gt; t.id)) + 1 :<br/>                1;<br/> <br/>  list.push({ id: newId, text: todo });<br/>  todo = "";</span><span id="d871" class="mr lx iq lv b gy oc no l np nq"><strong class="lv ir">}</strong></span></pre><h2 id="ad51" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">斯维尔特是怎么做到的？</h2><p id="d50d" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">在Svelte中，我们的<strong class="kh ir">输入</strong>字段有一个名为<strong class="kh ir"> bind:value </strong>的句柄。这允许我们做一些被称为<strong class="kh ir">双向绑定</strong>的事情。让我们快速查看一下我们的输入字段，然后我们将解释这是怎么回事:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="94a4" class="mr lx iq lv b gy nn no l np nq">&lt;input type="text" bind:value={todo} /&gt;</span></pre><p id="b0d3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> bind:value </strong>将这个字段的输入绑定到一个我们称为<code class="fe ls lt lu lv b">todo</code>的变量。当页面加载时，我们将<code class="fe ls lt lu lv b">todo</code>设置为空字符串，如下:<code class="fe ls lt lu lv b">let todo = ‘’</code>。如果这里已经有了一些数据，比如<code class="fe ls lt lu lv b">let todo = ‘add some text here’</code><strong class="kh ir"/>，我们的输入字段就会加载一些已经在输入字段里面的文本<strong class="kh ir"><em class="lb"/></strong>。无论如何，回到空字符串，我们在输入字段中输入的任何文本都会绑定到<code class="fe ls lt lu lv b">todo</code>的值。这是有效的双向绑定(输入字段可以更新<code class="fe ls lt lu lv b">todo</code>并且<code class="fe ls lt lu lv b">todo</code>可以更新输入字段)。</p><p id="1b38" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以回头看看前面的<strong class="kh ir">createnewdoitem()</strong>代码块，我们看到我们将<code class="fe ls lt lu lv b">todo</code> <strong class="kh ir"> </strong>的内容推入<code class="fe ls lt lu lv b">list</code> <strong class="kh ir"> </strong>数组<strong class="kh ir"> </strong>，然后将<code class="fe ls lt lu lv b">todo</code> <strong class="kh ir"> </strong>更新为空字符串。</p><p id="2d62" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还使用了React示例中使用的相同的<code class="fe ls lt lu lv b">newId()</code>函数。</p><h1 id="bce1" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">我们如何从列表中删除？</h1><h2 id="9ddf" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">反应:</h2><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="cfda" class="mr lx iq lv b gy nn no l np nq"><strong class="lv ir">const deleteItem = (item) =&gt; {</strong><br/>  setList(list.filter((todo) =&gt; todo.id !== id));<br/><strong class="lv ir">};</strong></span></pre><h2 id="58e3" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">React是怎么做到的？</h2><p id="1741" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">因此，虽然<code class="fe ls lt lu lv b">deleteItem()</code>函数位于<strong class="kh ir"> ToDo.js </strong>内，但我可以很容易地在<strong class="kh ir"> ToDoItem.js </strong>内引用它，首先，将<code class="fe ls lt lu lv b">deleteItem()</code> <strong class="kh ir"> </strong>函数作为道具传递给<code class="fe ls lt lu lv b">&lt;ToDoItem/&gt;</code>:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="62da" class="mr lx iq lv b gy nn no l np nq">&lt;ToDoItem deleteItem={deleteItem}/&gt;</span></pre><p id="b53c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这首先将功能向下传递，使孩子可以访问它。然后，在<strong class="kh ir"> ToDoItem </strong>组件中，我们执行以下操作:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="f5d5" class="mr lx iq lv b gy nn no l np nq">&lt;button className="ToDoItem-Delete" <br/>        onClick={() =&gt; deleteItem(item.id)}&gt; - &lt;/button&gt;</span></pre><p id="9bb6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要引用父组件中的函数，我只需引用<strong class="kh ir"> props.deleteItem </strong>。现在你可能已经注意到，在代码示例中，我们只是写了<code class="fe ls lt lu lv b">deleteItem</code>而不是<code class="fe ls lt lu lv b">props.deleteItem</code>。这是因为我们使用了一种被称为<strong class="kh ir">析构</strong>的技术，它允许我们获取<strong class="kh ir">道具</strong>对象的一部分，并将它们分配给变量。所以在我们的<strong class="kh ir"> ToDoItem.js </strong>文件中，我们有如下内容:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="6201" class="mr lx iq lv b gy nn no l np nq"><strong class="lv ir">const ToDoItem = (props) =&gt; {</strong><br/>  const { item, deleteItem } = props;<br/><strong class="lv ir">}</strong></span></pre><p id="4651" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这为我们创建了两个变量，一个叫做<code class="fe ls lt lu lv b">item</code>，它被赋予与<code class="fe ls lt lu lv b">props.item</code>相同的值，另一个叫做<code class="fe ls lt lu lv b">deleteItem</code>，它被赋予来自<code class="fe ls lt lu lv b">props.deleteItem</code>的值。我们可以通过简单地使用<code class="fe ls lt lu lv b">props.item</code>和<code class="fe ls lt lu lv b">props.deleteItem</code>来避免整个析构过程，但是我认为这值得一提！</p><h2 id="7600" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">苗条:</h2><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="6309" class="mr lx iq lv b gy nn no l np nq">const deleteItem = id =&gt; {<br/>  list = list.filter(item =&gt; item.id !== id);<br/>};</span></pre><h2 id="3f48" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">斯维尔特是怎么做到的？</h2><p id="a1c9" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">在Svelte中部署了非常相似的方法。在我们的<strong class="kh ir"> ToDo.svelte </strong>文件中，我们将<code class="fe ls lt lu lv b">deleteItem</code>函数传递给<code class="fe ls lt lu lv b">&lt;ToDoItem/&gt;</code>，如下所示:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="65cb" class="mr lx iq lv b gy nn no l np nq">&lt;ToDoItem {item} deleteItem={deleteItem}/&gt;</span></pre><p id="edbb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在我们的<strong class="kh ir"> ToDoItem.svelte </strong>文件中，我们通过写<code class="fe ls lt lu lv b">export let deleteItem;</code>在文件顶部创建一个变量引用。这允许我们像平常一样引用<code class="fe ls lt lu lv b">deleteItem</code>。最后，我们将函数传递给<strong class="kh ir"> ToDoItem.svelte </strong>中的“删除”按钮，如下所示:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="c667" class="mr lx iq lv b gy nn no l np nq">&lt;button class=”ToDoItem-Delete” <br/>        on:click={() =&gt; deleteItem(item.id)}&gt; - &lt;/button&gt;</span></pre><p id="6f0c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，我们的“删除”按钮与我们在React中使用的按钮完全相同。</p><h1 id="c1b9" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">我们如何传递DOM事件侦听器？</h1><h2 id="beac" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">反应:</h2><p id="a6d0" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">诸如点击事件等简单事件的事件侦听器是直接的。以下是我们如何为创建新ToDo项目的按钮创建click事件的示例:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="668e" class="mr lx iq lv b gy nn no l np nq">&lt;button className=”ToDo-Add” onClick={createNewToDoItem}&gt;+&lt;/button&gt;.</span></pre><p id="8092" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里非常简单，看起来就像我们用普通JavaScript处理onclick一样。</p><h2 id="1425" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">苗条:</h2><p id="3ba7" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">在苗条的时候，它也是非常直截了当的。我们简单地在:句柄上使用<strong class="kh ir">，然后使用我们想要的事件监听器的类型。例如，要添加一个点击事件监听器，我们可以写<strong class="kh ir"> on:click </strong>，如下例所示:</strong></p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="5f12" class="mr lx iq lv b gy nn no l np nq">&lt;button class="ToDo-Add" on:click={createNewToDoItem}&gt;+&lt;/button&gt;</span></pre><p id="ee6a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">苗条事件监听器的一个很酷的事情是，你也可以把一堆东西链接到它们上面，比如<strong class="kh ir"> once </strong>防止事件监听器被触发不止一次。</p><h1 id="3b1d" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">我们如何将数据/道具传递给子组件？</h1><h2 id="8c4f" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">反应:</h2><p id="4a1b" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">在react中，我们在创建子组件时将道具传递给子组件。比如:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="8b38" class="mr lx iq lv b gy nn no l np nq">&lt;ToDoItem key={key.id} item={todo} /&gt;</span></pre><p id="2307" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们看到两个道具被传递给了<strong class="kh ir"> ToDoItem </strong>组件。从这一点开始，我们现在可以通过this.props在子组件中引用它们。因此要访问<strong class="kh ir"> item.todo </strong> prop，我们只需调用<strong class="kh ir"> props.item </strong>。</p><h2 id="3e84" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">苗条:</h2><p id="1636" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">苗条的话，差不多也是这样:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="f2b5" class="mr lx iq lv b gy nn no l np nq">&lt;ToDoItem {item} on:deleteItem={deleteItem} /&gt;</span></pre><p id="c131" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里的一个不同之处是，我们不必将一个键传递给我们的<strong class="kh ir"> ToDoItem </strong>，而是先保留这个想法，因为我们将在稍后讨论这个问题。</p><p id="c8eb" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个不同是，我们可以通过简单地编写<code class="fe ls lt lu lv b">{item}</code>来传递<code class="fe ls lt lu lv b">item</code>。这是因为道具名称和实际道具具有相同的名称。写<code class="fe ls lt lu lv b">item={item}</code>也是一样的，但是我的苗条设置自动将其修改为简单的<code class="fe ls lt lu lv b">{item}</code>。</p><p id="f06a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦完成，我们必须在我们的<strong class="kh ir"> ToDoItem.svelte </strong>文件中创建一个名为<code class="fe ls lt lu lv b">item</code>的变量，方法是将<code class="fe ls lt lu lv b">export let item;</code>写到文件的<strong class="kh ir"> &lt;脚本&gt; </strong>部分的顶部。这样我们可以在文件中引用<code class="fe ls lt lu lv b">item</code>,而不会因为试图引用一个不存在的变量而出错。这里你要记住的是，在编译过程中，Svelte会检查我们的<strong class="kh ir"> ToDoItem </strong>是否被传递了一个名为<code class="fe ls lt lu lv b">item</code>的道具。在我们的例子中，它有，所以作为道具传递的<code class="fe ls lt lu lv b">item</code>的值将被分配给我们的<code class="fe ls lt lu lv b">export let item;</code>。这使得我们的应用程序能够像我们期望的那样工作。然后可以在孩子中通过它们的名字引用它们——所以在我们的例子中，是<strong class="kh ir">‘todo</strong>’。</p><h1 id="197b" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">我们如何将数据发送回父组件？</h1><h2 id="c58c" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">反应:</h2><p id="3f12" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">我们首先将函数传递给子组件，在调用子组件的地方将它作为一个道具进行引用。然后我们通过引用<strong class="kh ir">props . whateverthefunction称为</strong>——或者<strong class="kh ir">whateverthefunction称为</strong>(如果我们使用了析构的话),通过任何方式在子节点上添加函数调用，比如<strong class="kh ir"> onClick </strong>。这将触发父组件中的函数。我们可以在“如何从列表中删除”一节中看到整个过程的示例。</p><h2 id="a649" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">苗条:</h2><p id="6d48" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">这与React中的处理方式非常相似。我们可以在“如何从列表中删除”一节中看到整个过程的示例。</p><h1 id="eb17" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">我们如何在组件内部循环数据？</h1><h2 id="ff17" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">反应</h2><p id="0c7c" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">在React中，我们通常使用更高阶的函数，如<code class="fe ls lt lu lv b">map()</code>、<code class="fe ls lt lu lv b">filter()</code>等来循环遍历数据，将数据传递给html元素或子组件。这是我们在代码中实现它的方式:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="5438" class="mr lx iq lv b gy nn no l np nq"><strong class="lv ir">{list.map((item) =&gt; {</strong><br/>   <strong class="lv ir">return</strong> &lt;ToDoItem key={item.id} <br/>                    item={item} <br/>                    deleteItem={deleteItem} /&gt;;<br/><strong class="lv ir">})}</strong></span></pre><p id="7db4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这与我们在常规JavaScript中使用它们的方式非常相似。</p><h2 id="9456" class="mr lx iq bd ly ms mt dn mc mu mv dp mg ko mw mx mi ks my mz mk kw na nb mm nc bi translated">苗条的</h2><p id="a65e" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">在Svelte中，我们用的是<code class="fe ls lt lu lv b">#each</code>，专门针对Svelte的。这是一种循环数据的方法。这是我们在代码中实现它的方式:</p><pre class="ld le lf lg gt nj lv nk nl aw nm bi"><span id="3b64" class="mr lx iq lv b gy nn no l np nq"><strong class="lv ir">{#each list as item, i (item.id)}</strong><br/>  &lt;ToDoItem {item} on:deleteItem={deleteItem} /&gt;<br/><strong class="lv ir">{/each}</strong></span></pre><p id="c6b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会注意到，然后我们取我们的<code class="fe ls lt lu lv b">list</code>变量，并在它后面跟随<code class="fe ls lt lu lv b">as item</code>。这基本上就是说，以我们的<code class="fe ls lt lu lv b">list</code>为例，把它分解成我们称之为<code class="fe ls lt lu lv b">item</code>的单个项目。然后我们给每个<code class="fe ls lt lu lv b">item</code>一个我们称之为<code class="fe ls lt lu lv b">i</code>的索引，然后在我们想要使用的索引后面的括号中写下，在这种情况下，就是我们的<code class="fe ls lt lu lv b">item.id</code>。你还会注意到，我们不需要在这里传递一个<code class="fe ls lt lu lv b">key</code>给我们的<code class="fe ls lt lu lv b">&lt;ToDoItem/&gt;</code>，因为Svelte无论如何都会分配它。</p><h1 id="13f0" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">我们做到了！🎉</h1><p id="dc8d" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">我们已经了解了如何添加、删除和更改数据，如何以props的形式将数据从父节点传递到子节点，以及如何以事件侦听器的形式将数据从子节点发送到父节点。当然，React和Svelte之间还有许多其他的小差异和怪癖，但是希望这篇文章的内容有助于为理解它们如何处理东西提供一点基础。</p><p id="e113" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您对本文中使用的样式感兴趣，并想制作您自己的等效作品，请随时这样做！👍</p><h1 id="fdf7" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">Github链接到两个应用程序:</h1><p id="25bc" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">react ToDo:<a class="ae mq" href="https://github.com/sunil-sandhu/react-todo-2019" rel="noopener ugc nofollow" target="_blank">https://github.com/sunil-sandhu/react-todo-2019</a></p><p id="8479" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">苗条的托多:<a class="ae mq" href="https://github.com/sunil-sandhu/svelte-todo" rel="noopener ugc nofollow" target="_blank">https://github.com/sunil-sandhu/svelte-todo</a></p><h1 id="fa90" class="lw lx iq bd ly lz ma mb mc md me mf mg jw mh jx mi jz mj ka mk kc ml kd mm mn bi translated">比较Svelte和Vue呢？</h1><p id="0131" class="pw-post-body-paragraph kf kg iq kh b ki ne jr kk kl nf ju kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">很高兴你问了！以下是链接:</p><p id="59f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae mq" href="https://medium.com/@sunilsandhu/i-created-the-exact-same-app-in-vue-and-svelte-here-are-the-differences-c649f8d4ce0a" rel="noopener">https://medium . com/@ sunilsandhu/I-created-the-exact-same-app-in-vue-and-svelte-here-are-the-differences-c 649 F8 d 4 ce 0a</a></p></div></div>    
</body>
</html>