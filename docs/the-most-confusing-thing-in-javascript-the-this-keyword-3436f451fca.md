# JavaScript 中最令人困惑的事情:“this”关键字

> 原文：<https://javascript.plainenglish.io/the-most-confusing-thing-in-javascript-the-this-keyword-3436f451fca?source=collection_archive---------0----------------------->

![](img/f196b7162aa43a6776d1152e0cba378a.png)

你知道那些你一遍又一遍学习的概念，然而不管你记了多少笔记，它们似乎都从你的记忆中消失了？

JavaScript 中的关键字`this`对我来说就是这些概念中的一个，直到我最终花了一个下午来理解代码的内部工作，而不是绝望地试图记住影响`this`值的 4 种类型的“绑定”(默认、隐式、显式和“新”)。

喝杯咖啡，带上你的聚焦帽，和我一起度过接下来的 15 分钟，你也会最终明白`this`这个关键词是什么。

# 编译时间与运行时间

编写代码不需要对编译器和运行时有深刻的理解，如果你在 21 世纪学会了编码，可能就不会有人向你强行灌输操作系统理论了(特别是如果你受过非正式的培训)。

但是要理解 JavaScript 中的`this`关键字，我们至少需要对编译时和运行时的区别有一个基本的了解。

所有语言在编译和执行代码的方式上都略有不同，但是 JavaScript 在这方面有点独特。由于 JavaScript 在浏览器中运行，所以需要一次性编译并执行；而且要快！与 C 语言不同，在 C 语言中，我们必须先编译代码，然后运行代码，这种“一体化”的魔力让 JavaScript 引擎(通常是 Chrome 这样的浏览器)看起来好像是一个完成所有事情的实体。

# 但是打住，我不确定我知道什么是“编译”？

你可能已经读过这个词一千遍了，但是它到底是什么意思呢？

编译可以从两个方面来理解:

1.  作为一个*过程*
2.  作为*时间点*

让我们在屏幕上显示一些代码来更好地理解这一点。

```
function simpleFunction() {
    console.log("I am a useless function");
}simpleFunction();
```

定义为一个*过程*，这段代码的编译是从你现在在屏幕上看到的内容到计算机可以执行的 1 和 0(二进制代码)的*过程*。

具体如何发生是由编译器自己定义的，但可能是这样的:

1.  嗯……我先看到“功能”这个词。这是 JavaScript 语言语法的一部分吗？没错。好吧，我们继续。
2.  刚刚看到“函数”这个关键词，那么下一个词“simpleFunction”一定是它的名字。这个名字符合我的标准吗？它没有任何奇怪的字符或空格，所以没错！下一个！
3.  我看到一个“{”，这是我看到“function”和“simpleFunction”后可能会想到的。这里一切都好。
4.  这个叫“控制台”的东西是什么？不太确定，但肯定是个物件。让我们看看一个“.”接下来。
5.  啊，在那里！的“.”意味着某种方法即将到来。
6.  是的，“日志”是在“控制台”上调用的方法。不知道它是否真的存在，但那不是我的工作！向前移动！
7.  我看到一个“(”字符。我希望如此，因为在此之前我刚刚看到了一个名为“log”的方法。我们现在必须定义这个方法的参数。
8.  我看到一串“我是无用函数”。嗯，不知道这有什么意义，但这是有效的字符串语法，所以我接受它。
9.  这里是右括号“)”，后面是“；”。这个方法做好了，有效！
10.  而现在，我看到一个“}”。这意味着我的函数定义现在完成了！
11.  我又看到“simpleFunction”带“()”。这是调用之前声明的函数的有效方法。
12.  就是这样！没有更多的令牌可以解析。这个程序是编译的。

在通读了这段想象中的与编译器的对话后，你可以看到编译器的工作是遍历一个程序，看符号(也叫“记号”)，根据语言规范确定它们是否有意义。如果编译器看到下面的代码，它会发疯并抛出一个错误，而不把代码编译成 1 和 0:

```
variable myvariable = 1;
```

对话是这样进行的:

1.  我看到一个词“变量”。这一行的开头没有“const”、“let”或“var”，所以这必须是一个隐式声明的变量。我不爱它，但技术上它是有效的！
2.  哇哦哇哦哇哦等等。我对之前的行很满意，但是现在我看到了“我的变量”。这不是有效的 JavaScript 语法。我抛出一个 SyntaxError！

从上面的例子中你可以发现，当我们在一个*过程*的环境中看编译时，它都是关于读取代码，验证代码，并将其转换成计算机可以执行的东西。

但是许多有经验的开发人员会谈论这个叫做“编译时间”的东西，这是在一个*时间点*的上下文中查看编译。

这很难理解，因为正如你所看到的，编译更多的是一个过程，而不是一个时间点。

当您听到“编译时间”时，这实际上指的是在您点击 compile 之前的时刻，或者在我们使用 JavaScript 的情况下，运行程序。

所以实际上，“编译时”是“在编译器转换代码之前，我们的代码是什么样子”的另一种说法。

# 运行时间

编译器在确保你的代码具有正确的语法结构方面做得很好，但是它并不真正检查以确保代码工作。

```
invalidFunction();
```

如果您在 JavaScript 控制台中运行它，您将得到`ReferenceError`，因为编译器编译了代码，但是当 JavaScript 引擎试图运行它时，它在任何地方都找不到声明`invalidFunction`。

所以运行时就是程序被执行的时候，它包括调用栈、内存位置等。

# “运行时”与“运行时”

我认为事情变得混乱的地方是在网上缺乏对短语“运行时”和单词“运行时”的区分。

我们知道“运行时间”是程序开始执行的时间，但是我们还没有问*它在哪里执行。*

我可以打开谷歌浏览器，在开发者工具中，进入控制台。一旦到了那里，我就可以编写和执行 JavaScript 代码了。

我也可以在我的电脑上打开终端，键入`node`，我将进入 NodeJS 控制台，在那里我可以编写和执行代码。

我在两个不同的运行时编写了相同的代码。

但是为什么我们需要不同的运行时呢？

因为 Windows 电脑不同于 Mac 电脑，Mac 电脑不同于浏览器。具体来说，它们的硬件组件以及高级代码(如 JavaScript)需要编译成的汇编语言是不同的！

当 JavaScript 被编译成计算机可以运行的 1 和 0 时，它需要记住它所处的运行时环境。如果不这样做，可能会导致 Mac 上发生 Windows 低级系统调用，这显然是行不通的！

# 回到“这个”关键词

因此，我们讨论了在不同的上下文中，编译和运行时意味着不同的东西。作为一个过程，编译指的是将代码从开发人员编写的内容转换为计算机读取的内容。计算机读取的内容发生在运行时的过程中，并且根据“运行时环境”而不同。

但是为了理解 JavaScript 中的`this`关键字，我们必须从*时间点*的上下文来考虑运行时和编译时。

# 静态(词法)与动态范围

*原因*我们必须从*时间点*的上下文来看待编译时和运行时，因为变量和函数的*值*完全取决于它们是在运行时定义的还是在编译时定义的！

理解静态(词法)和动态范围是在`this`关键字开始有意义之前你必须理解的最后一项！

## 什么是“范围”？

如果你还在读这篇文章，你可能已经知道什么是作用域了。看一下下面的代码:

```
let a = 1;function printA() {
    a = 2;
    console.log(a)
}printA(); // 2
console.log(a) // 1
```

当我们调用`printA()`时，它将首先在`printA`函数的范围内寻找`a`的值，由于该值存在，它将打印该值。

由于`console.log`语句不能访问`printA`的作用域，它必须在全局作用域中查找，这是它唯一可以访问的作用域。

换句话说，JavaScript 引擎将在当前范围内查找变量，如果找不到，它将查找一个范围。如果它到达了`global`范围，但仍然找不到变量，那么将抛出一个`ReferenceError`，因为该变量不存在。

下面是这个过程的一个人为例子:

```
let globalVariable = 2;function outer() {
    middle();
    function middle() {
        inner();
        function inner() {
            console.log(globalVariable);
        }
    }
}outer(); // 2
inner(); // ReferenceError: inner is not defined
```

当我们调用`outer`函数时，该函数调用调用内部函数的中间函数。当调用内部函数时，它首先在自己的范围内寻找`globalVariable`的值。它找不到它，所以它看起来在`middle`的范围内。它又找不到它，所以它看起来在`outer`的范围内。它找不到它，所以它最终在全球范围内寻找。它会在那里找到它并打印一个值 2。

另一方面，当我们从全局范围调用`inner`函数时，会抛出一个`ReferenceError`！

这是因为 JavaScript(以及几乎任何语言)中的作用域只有一种工作方式。在这种情况下，`inner`的作用域被“封装”了，因此全局作用域甚至不知道`inner()`函数的存在。

## 有道理，但为什么？

您可能没有意识到这一点，但很可能，您使用的所有编程语言都实现了静态或“词汇”范围——包括 JavaScript。我刚才解释的是*静态范围规则*。

但是还有另一种类型的作用域叫做动态作用域，它在运行时*分配变量的值！让我们看看另一个计划，记住我们刚刚学到的东西。*

```
*let x;
x = 1;function a() {
    x = 2;
}function b() {
    let x;
    a();
}b();// With Lexical scope, this will print 2
// With dynamic scope, this will print 1
console.log(x);a();// With Lexical scope, this will print 2
// With dynamic scope, this will print 2
console.log(x);*
```

*如果我们实际上用词汇(“静态”)范围的 JavaScript 语言运行，无论我们调用哪个函数，我们都会为 x 打印一个值 2。这是因为函数`a`会始终将变量 x 重新分配为值 2。*

*但是对于动态范围，我们必须从调用堆栈的角度来考虑。我知道这很令人困惑(因此，为什么大多数语言不是动态类型的，为什么大多数人不理解 JavaScript `this`关键字)，但是让我们来浏览一下。*

*在这个程序中，调用堆栈首先用全局作用域`x`变量填充，该变量被设置为 1。然后我们调用`b()`，将变量`x`从`function b()`的范围推送到调用栈。我们的调用堆栈如下所示:*

```
*x (function b scope)
x (global scope)*
```

*请注意，虽然它们被命名为同一个变量，但两个`x`变量都占据了它们自己的内存段，并被赋予了它们自己的值。*

*因此在这一点上，我们称之为`a()`，它设定了`x=2`。*

*但是*它设定了哪个* x？？*

*在词汇作用域语言中，我们到达函数`a`，我们看不到变量声明。由于没有变量声明，编译器查找一个作用域，找到在全局作用域中声明的 x。然后，它将这个全局`x`变量赋值为 2。*

*对于动态范围，值 2 被赋给位于调用堆栈顶部*的变量`x`。如果您还记得的话，在`function b`作用域中的`x`位于堆栈的顶部，这意味着值 2 将被赋给它。**

*因此，当我们从全局范围打印 x 的值时，它仍然是值 1！*

*但是当我们从全局范围调用`a()`时，事情发生了一些变化。这一次，我们的调用堆栈如下所示:*

```
*x (global scope)*
```

*因此，值 2 将被赋给全局范围内的变量`x`，我们将打印出值 2！*

# *重绕*

*太多了。*

*我们为什么会在这里？嗯，为了理解 JavaScript `this`关键字，您必须了解动态范围变量的思维模式。为了理解动态范围的变量，你必须理解什么是静态范围的变量。要理解静态范围的变量，你需要知道编译器做什么。*

*对我来说，这听起来像是一大堆知识！*

*不管怎样，回顾一下:*

*   *JavaScript 是一种静态作用域语言，这意味着变量值基于它们的“编译时”条件进行计算。变量可以“向上作用域”求值，但不能“向下作用域”(即嵌套函数可以使用全局变量，但全局函数不能使用封装变量)*
*   *JavaScript `this`关键字的行为方式类似于动态范围，但并不完全相同。尽管如此，理解动态范围将有助于您理解`this`关键字。*
*   *如果你完全迷失了，可能是因为你还没有准备好这种类型的讨论。我花了很多年才理解了这些概念，并且需要大量的编程和实践。如果是这种情况，您可以在将来重新阅读这篇文章。*

# *最后。`this`关键字解释*

*就像动态范围依赖于运行时调用栈的顺序一样，`this`关键字依赖于调用栈来确定`this`是哪个“上下文”的一部分。*

*`this`有 4 种“绑定”方式。我们将从最容易的开始，然后努力做到最难的。*

# *`new`关键字*

*这个很简单。当使用`new`关键字声明一个函数的新实例时，`this`将总是引用声明的函数。*

```
*function myFunction() {
    var a = 2;

    this.a = a;
}var a = 4;var functionInstance = new myFunction();console.log(functionInstance.a) // 2*
```

*上面的`this`关键字指的是`myFunction`对象，它分配了一个等于 2 的`a`属性。尽管`functionInstance`的调用点在全局范围内，但是`new`关键字会覆盖任何关于`this`的规则，并且显式绑定到新的函数实例。*

*我认为这是识别`this`代表什么的最简单的情况，因为它是如此明确。*

# *显式绑定*

*这种类型的`this`绑定非常类似于`new`关键字，但是在您试图同时使用这种方法和`new`关键字的情况下，`new`关键字将优先。*

*实际上有多种方法可以显式绑定`this`的值，但有些方法比其他方法更过时。为简单起见，我们只看其中一种方式，这是最常见的。*

*通过使用存在于所有 JavaScript 函数中的`bind()`原型函数，您可以显式地分配一个对象来表示`this`的值。*

```
*function myFunction() {
    console.log(this.a);
}var explicitlyBoundObject = {
    a: 2
};var a = 4;var functionInstance = myFunction.bind(explicitlyBoundObject);functionInstance(); // 2*
```

*与关键字`new`一样，显式绑定允许您完全消除动态范围的概念，并从您的头脑中调用堆栈，并确切地知道`this`代表什么。*

*稍后，我们将看到这里有一些例外，但是为了简单起见，从表面上看，就拿上面的例子来说吧。*

# *默认绑定*

*默认绑定比`new`和显式绑定稍微复杂一点，因为有一些您可能没有预料到的细微差别。*

*一个很好的经验法则是:**如果一个函数以“正常”的方式被调用，那么它有默认绑定** `**this**` **引用全局作用域**。*

*当我说“正常”时，我指的是如下所示的函数调用:*

```
*function myFunction() {
    console.log("does something");
}// Call function "normally"
myFunction();*
```

*只有三种方法可以调用这个函数，如下所示:*

*所以如果你看到一个被称为“正常”的函数，你可以合理地假设`this`指的是全局对象。如果使用 NodeJS 控制台，全局对象将是`global`，如果使用浏览器控制台，全局对象将是`window`。*

*在我看来，当考虑默认绑定时，有两件事会让程序员迷惑。*

1.  *“严格”模式*
2.  *`const`关键字*
3.  *嵌套函数*

*从“严格”模式开始:*

```
*function myFunction() {
    'use strict'   
    console.log(this.a)
}var a = 2;
myFunction(); // undefined*
```

*`this`未定义，因为在 JavaScript 中使用严格模式会使全局范围不可用。严格模式的目的是迫使开发人员注意范围、安全性和其他最佳编码实践，实现这一点的方法之一是限制全局对象的使用。*

*现在，对于`const`这个关键词:*

```
*function myFunction() {
    console.log(this.a);
}const a = 2;
myFunction(); // undefined*
```

*使用`const`关键字不会使变量在全局对象上可用。要看到这一点，打开谷歌浏览器，进入控制台。键入以下内容:*

```
*var a1 = 2;
const a2 = 2;// In a browser, window is the global object
// In a NodeJS console, you would replace "window" with "global"
window.a1 // 2
window.a2 // undefined*
```

*最后，嵌套函数:*

*谈了这么多关于调用栈和调用点的内容，您可能会看一下上面的代码，并推断出`this`代表的不是全局对象。打印`this.a`时，调用栈顶部有 f3()，表示`f1()`的“调用地点”在`f2()`。换句话说，即使`f1()`在全局范围内执行，也不意味着它的调用地点在全局范围内。调用地点在`f2()`范围内。*

*知道了这一点，你可能会猜测`this.a`的值应该是 6，因为这是打印`this.a`时`f1()`的调用位置处`a`的值。*

*但事实并非如此。由于`f1()`是作为一个“普通”函数调用被调用的，所以它的作用域总是全局的，因此在上面的代码中`this.a`等于 2。*

# *隐式结合*

*最后，是`this`变得有点混乱的部分。如果我们调用一个函数作为一个对象的属性，`this`的值完全基于函数的调用位置。*

```
*var obj1 = {
    color: 'green',
    func: () => {
        console.log(this.color); // undefined
    }
}var obj2 = {
    color: 'green',
    func: function () {
        console.log(this.color); // green
    }
}obj1.func(); // undefined
obj2.func(); // green*
```

*在上面的例子中，我展示了两个概念，对于`this`的隐式绑定，您必须理解这两个概念。显然，这两个函数都是从全局范围调用的，但是如果您确定了真正的调用位置，它就在每个对象的上下文中，因此，`this`的值就是上下文对象。*

*在第二个函数调用`obj2.func()`中，结果并不令人惊讶。我们已经确定这个函数的调用点是`obj2`对象，它的属性`color`等于绿色。*

*第一个函数调用有点令人困惑，它与函数属性的语法有关。ES6 中引入了胖箭头功能。与普通的函数声明不同，胖箭头函数中的`this`关键字遵循词法(与“静态”同义)作用域规则，而不是动态作用域规则，在动态作用域规则中，我们必须查看调用堆栈并确定调用位置以确定`this`的值。*

*所以胖箭头函数中的`this`的值是全局对象，不具备`color`的属性。*

*胖箭头函数对`this`的处理为开发人员解决了一个问题，最好用例子来说明。*

*基于前面的例子，你可能会猜测`this.color`等于绿色。但是如果你还记得关于[默认绑定](https://dillinger.io/#default-binding)的章节，如果我们“正常地”调用一个函数(即`myAsyncFunction`已经被正常地调用了)，`this`将代表全局对象。为了解决这个问题，JavaScript 开发人员使用了如下方法:*

*Assigning `this` to `self`*

*通过将`this`的值赋给一个变量，同时我们可以访问它，我们可以将它传递给回调函数并使用它。*

*显然，这是一种人为的使用`this`的方式。还有一个更好的方法，它涉及到 ES6 的胖箭头功能:*

*使用这种模式需要对关键字`this`有相当深刻的理解，并且让你想知道为什么有人会首先去找麻烦？*

# *为什么首先使用`this`？*

*在所有这些解释之后，你可能想知道为什么有人会不厌其烦地在他们的代码中使用`this`？*

*尽管这完全是个人观点，但我看不出有什么过分令人信服的理由来为我写的 JavaScript 使用`this`关键字。就我个人而言，我写了很多与应用相关的 JavaScript，在很多情况下，很多人可能会看到，也可能不知道`this`是如何工作的。为了让每个人都处于一个公平的竞争环境中，我发现尽可能在我的代码中去掉`this`是更好的选择。也就是说，如果我正在为一个库/框架编写更健壮的 JavaScript 代码，我可能会有不同的看法。*

*也就是说，有一个令人信服的理由来彻底了解`this`是如何工作的。无论你发起多大规模的反对在代码库中使用`this`的运动，总会有代码库利用它。因此，不管您是否选择在您的代码库中实现`this`，您肯定需要知道它是如何工作的。*

*至此，我希望这个对关键字`this`的深入探究能帮助你理解，就像它帮助我一样。另外，我很想听听你对`this`关键词的看法。我们应该使用它吗？为什么？*