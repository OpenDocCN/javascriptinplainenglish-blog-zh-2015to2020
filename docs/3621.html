<html>
<head>
<title>The Secrets of JavaScript Object for Performance Optimization</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript对象优化性能的秘密</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/exploration-of-javascript-object-for-performance-optimization-70b20246ab9e?source=collection_archive---------2-----------------------#2020-10-13">https://javascript.plainenglish.io/exploration-of-javascript-object-for-performance-optimization-70b20246ab9e?source=collection_archive---------2-----------------------#2020-10-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/292776b1046e1160ed8d122d3e170c71.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IAA30o1g_aQM3xl5tqdqMA.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">High-speed Aircraft (source: <a class="ae kc" href="https://pixabay.com/" rel="noopener ugc nofollow" target="_blank">Pixabay</a>)</figcaption></figure><h1 id="2f5d" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">JavaScript中的原语和对象</h1><p id="d59e" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">JavaScript包含两种基本的数据类型:<strong class="ld ir">原语和对象</strong>。定义不可变值(不能被改变)的数据类型是<strong class="ld ir">原语</strong>。它们没有方法，存储在堆栈中，通过值进行比较。有7种原始数据类型:字符串、数字、bigint、布尔、空、未定义、符号。</p><p id="c628" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">其余的都是<strong class="ld ir">的对象</strong>。它们是由文字创建的可变数据类型(可以改变),通过引用进行比较。它们是属性、对象和键之间的映射以及值的集合。键是字符串(或符号)，值可以是任何值。函数、<strong class="ld ir">数组</strong>、日期和其他一切都是对象。</p><h1 id="6c2c" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">V8和d8</h1><p id="9e59" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><a class="ae kc" href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine)" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ir"> V8 </strong> </a>是Google开源的高性能JavaScript和WebAssembly程序/解释器，用C++编写。它在Chrome和Node.js中使用。分析和优化技术基于V8引擎，该引擎实现了隐藏类&amp;内联缓存。其他JavaScript引擎实现了类似的方法或隐藏的类变体。Safari <a class="ae kc" href="https://en.wikipedia.org/wiki/WebKit#JavaScriptCore" rel="noopener ugc nofollow" target="_blank"> JavaScriptCore </a>有<em class="me">结构</em>。<a class="ae kc" href="https://en.wikipedia.org/wiki/Chakra_(JScript_engine)" rel="noopener ugc nofollow" target="_blank">微软Edge的脉轮核心</a>有<a class="ae kc" href="http://abchatra.github.io/Type/" rel="noopener ugc nofollow" target="_blank"> <em class="me">型</em> </a>。火狐的蜘蛛猴有<em class="me">的形状。</em></p><p id="5136" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated"><a class="ae kc" href="https://v8.dev/docs/d8" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ir"> d8 </strong> </a>是与v8 JavaScript引擎打包在一起的命令行环境。d8对于在本地运行一些JavaScript或调试对v8的更改非常有用。在这篇博文中，用d8分析了v8中对象的全貌。</p><h1 id="cf5f" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">对象分析</h1><p id="472f" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们定义一个名为“test”的对象，并通过d8调试它。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="74d6" class="mo ke iq mk b gy mp mq l mr ms">var test = {<br/> a: “foo”,<br/> b: “bar”,<br/> 0: “foo”,<br/> 1: “bar”<br/>}</span></pre><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mt"><img src="../Images/20feff4f5fd86c7a1d08520c067a4001.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RR29L2HhzbJXt_7EMK6HsA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Fig. Object details in d8 shell</figcaption></figure><h2 id="8930" class="mo ke iq bd kf mu mv dn kj mw mx dp kn lm my mz kr lq na nb kv lu nc nd kz ne bi translated">调查的结果</h2><ul class=""><li id="dbd4" class="nf ng iq ld b le lf li lj lm nh lq ni lu nj ly nk nl nm nn bi translated"><strong class="ld ir">用值“foo”和“bar”分别命名属性a </strong> &amp; <strong class="ld ir"> b </strong>。</li><li id="fac5" class="nf ng iq ld b le no li np lm nq lq nr lu ns ly nk nl nm nn bi translated"><strong class="ld ir">索引属性</strong>称为<strong class="ld ir">元素</strong>从0到16，其中0 &amp; 1分别持有【foo】&amp;【bar】。</li><li id="3fa2" class="nf ng iq ld b le no li np lm nq lq nr lu ns ly nk nl nm nn bi translated"><strong class="ld ir">原型</strong>信息。</li><li id="7a7c" class="nf ng iq ld b le no li np lm nq lq nr lu ns ly nk nl nm nn bi translated"><strong class="ld ir">贴图</strong>(指针指向<strong class="ld ir">隐藏类</strong>)。</li></ul><p id="ad56" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">JavaScript中的命名属性和索引属性是分开处理的。它们有不同的使用模式，并存储在不同的存储位置。</p><h1 id="9556" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">性能因素-财产访问时间</h1><p id="23dc" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">在像Java这样具有强类型的低级编程语言中，对象的完整信息在编译时是已知的，因为对象属性在运行时不会改变。指向对象属性的指针可以存储在内存位置的连续缓冲区中，每个节点之间有固定的偏移量，并且可以知道对象的长度/大小。在这种情况下，属性访问并不昂贵，并且可以通过一条指令来完成:在给定的内存偏移量下，加载内容。</p><h2 id="a2a1" class="mo ke iq bd kf mu mv dn kj mw mx dp kn lm my mz kr lq na nb kv lu nc nd kz ne bi translated">隐藏类</h2><p id="4a6a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">像<strong class="ld ir"> JavaScript </strong>这样的动态类型语言中的属性访问机制不同于强类型语言，在强类型语言中，对象属性会在运行时发生变化。这需要计算量很大的动态查找。在V8中，该对象有一个与之相关的<strong class="ld ir">隐藏类</strong>，其工作方式类似于Java中的固定对象布局，只是它们是在运行时创建的，并随着对象的变化而动态更新。</p><p id="b84e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">隐藏类主要通过两种方式为v8引擎服务。首先，属性访问机制<strong class="ld ir">不需要动态查找</strong>。第二，隐藏类为对象的形状提供了一个标识符，这是<strong class="ld ir"> V8优化编译器和内联缓存</strong>的一个非常重要的组成部分。</p><h2 id="7f21" class="mo ke iq bd kf mu mv dn kj mw mx dp kn lm my mz kr lq na nb kv lu nc nd kz ne bi translated">隐藏类转换</h2><p id="e61d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">隐藏类取决于属性添加到对象的顺序。然而，添加数组索引属性并不会改变隐藏类。当属性改变时，隐藏类知道要引用哪个隐藏类。如果同一个属性被添加到共享同一个隐藏类的两个对象中，则两个对象都会接收同一个新的隐藏类以及与之相关的所有优化。如果对象的属性被更改，则检查对象隐藏类的转换信息。</p><p id="cb3a" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">让我们考虑一个名为Point的函数，并定义两个对象p1和p2。隐藏类的转换是通过一系列的过程发生的。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="1012" class="mo ke iq mk b gy mp mq l mr ms">1. function Point(x, y) {<br/>2.   this.x = x;<br/>3.   this.y = y;<br/>4. }<br/>5. <br/>6. p1 = new Point(1,2);<br/>7. p2 = new Point(3,4);</span></pre><ul class=""><li id="4dc6" class="nf ng iq ld b le lz li ma lm nt lq nu lu nv ly nk nl nm nn bi translated">当一个函数被声明时，该函数的对象指针被形成，并且隐藏类<strong class="ld ir"> HC0 </strong>(隐藏类0)被创建。</li><li id="8f5b" class="nf ng iq ld b le no li np lm nq lq nr lu ns ly nk nl nm nn bi translated">第6行:当代码被执行形成对象p1时，它指向隐藏类<strong class="ld ir"> HC0 </strong>。</li><li id="7a22" class="nf ng iq ld b le no li np lm nq lq nr lu ns ly nk nl nm nn bi translated">第2行:增加新属性<strong class="ld ir"> x </strong>后，形成新的隐藏类<strong class="ld ir"> HC1 </strong>。同样，当属性<strong class="ld ir"> y </strong>被添加时，另一个隐藏类<strong class="ld ir"> HC2 </strong>被创建。</li><li id="3f28" class="nf ng iq ld b le no li np lm nq lq nr lu ns ly nk nl nm nn bi translated">第7行:在形成对象p2时，不创建新的隐藏类，但是隐藏类指针将依次指向<strong class="ld ir"> HC0 </strong>、<strong class="ld ir"> HC1、</strong>和<strong class="ld ir"> HC2 </strong>。</li></ul><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nw"><img src="../Images/97f1d307e3ea87486c14a4309b126cc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mk3pAQ-tAo-4q-Xo"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Fig. Hidden Class Transition</figcaption></figure><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="0bbc" class="mo ke iq mk b gy mp mq l mr ms"><strong class="mk ir">Optimization Takeaways</strong></span><span id="72b5" class="mo ke iq mk b gy nx mq l mr ms"><strong class="mk ir">Initialize objects member in the same order to avoid creating extra hidden class so that the same hidden class can be shared. It is inefficient to create hidden class whenever a property is added.</strong></span><span id="426d" class="mo ke iq mk b gy nx mq l mr ms"><strong class="mk ir">Adding properties to object after instantiation will cause hidden class transitions. Instead, assign all of the object properties during instantiation (as much as possible).</strong></span></pre><h2 id="88a0" class="mo ke iq bd kf mu mv dn kj mw mx dp kn lm my mz kr lq na nb kv lu nc nd kz ne bi translated">内嵌缓存</h2><p id="70a0" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">v8使用了另一种优化机制，称为<strong class="ld ir"> </strong> <a class="ae kc" href="https://en.wikipedia.org/wiki/Inline_caching" rel="noopener ugc nofollow" target="_blank"> <strong class="ld ir">内联缓存</strong> </a>。<strong class="ld ir"> <em class="me"> </em>对象访问位置<em class="me"> </em> </strong>是程序中对象属性被访问(读或写)的任何位置。当需要访问一个对象属性时，v8必须查找与之相关的隐藏类(对象)以确定偏移量。这是一个计算量很大的过程。</p><p id="3383" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">内联缓存的概念基于经验公式，即在任何站点访问的对象通常都有相同的隐藏类，并且相应的处理程序(用于访问对象属性)被缓存。在对同一个隐藏类的同一个方法的两次成功调用之后，它生成<strong class="ld ir">处理程序例程</strong>。V8为内联高速缓存执行一种线外方法。它不是直接特殊化机器码，而是创建一个称为IC Vector的每函数数据结构。对于函数中的每个对象访问位置，IC Vector包含一个或多个包含元组(HC Addr，HC Handler)的槽。HC Address是指向隐藏类的指针，Handler是为隐藏类执行操作的指针。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ny"><img src="../Images/0ab87cd5d2100ad96818eb590df8a1fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ocGZvgrtGw5b9jWA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Fig. IC Vector with 3 different access sites</figcaption></figure><p id="2aea" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">一开始，IC向量是空的。随着执行的进行，只要遇到对象访问站点，IC向量就会被填充。仅遇到单个隐藏类的对象的对象访问站点是<strong class="ld ir">单态的。</strong>如果站点遇到多个隐藏类的对象，那么它就是<strong class="ld ir">多态</strong>。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="f67f" class="mo ke iq mk b gy mp mq l mr ms"><strong class="mk ir">Optimization Takeaway</strong></span><span id="a5b8" class="mo ke iq mk b gy nx mq l mr ms"><strong class="mk ir">Prefer monomorphic over the polymorphic object access site for better performance. Prefer function call with same type of objects.</strong></span></pre><h1 id="94b8" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">Inobject、Normal和字典属性</h1><h2 id="e9f3" class="mo ke iq bd kf mu mv dn kj mw mx dp kn lm my mz kr lq na nb kv lu nc nd kz ne bi translated">InObject属性</h2><p id="d890" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们重新审视一下我们之前调试的测试对象。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="1252" class="mo ke iq mk b gy mp mq l mr ms">var test = {<br/> a: “foo”,<br/> b: “bar”,<br/> 0: “foo”,<br/> 1: “bar”<br/>}</span></pre><p id="364d" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">Inobject属性直接存储在对象中。它们是v8中最快的属性，因为它们可以被直接访问。inobject属性的数量由对象的初始大小预先确定。</p><h2 id="9e88" class="mo ke iq bd kf mu mv dn kj mw mx dp kn lm my mz kr lq na nb kv lu nc nd kz ne bi translated">正常/快速属性</h2><p id="e5d6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们向“test”对象添加两个属性:c和d，并调试它。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="2533" class="mo ke iq mk b gy mp mq l mr ms">test.c = 'i am late';<br/>test.d = 'i am too late';</span></pre><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nz"><img src="../Images/00cf16008302ed5033b6d8a352ca63d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7P-ogh3asFU9YAO3Z05L6w.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Fig. Object Details with Inobject and Normal properties</figcaption></figure><h2 id="299f" class="mo ke iq bd kf mu mv dn kj mw mx dp kn lm my mz kr lq na nb kv lu nc nd kz ne bi translated">调查的结果</h2><p id="cce6" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">属性' c '和' d '在属性[0]和属性[1]中标记，这与' a '和' b '不同。</p><p id="26b5" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果属性是在初始化之后添加的(比如我们例子中的c和d)，它们会被附加到属性存储中。这些是<strong class="ld ir">正常/快速属性</strong>。属性存储增加了一个间接层，但可以独立增长。在这种情况下，必须查询描述符数组才能获得属性在属性存储中的实际位置。</p><h2 id="833e" class="mo ke iq bd kf mu mv dn kj mw mx dp kn lm my mz kr lq na nb kv lu nc nd kz ne bi translated">字典属性</h2><p id="6e2a" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">让我们从先前的“test”对象中删除命名属性“a ”,并再次调试它。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="99bf" class="mo ke iq mk b gy mp mq l mr ms">delete test[a];</span></pre><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oa"><img src="../Images/739432843447b2310cb567c87726e5fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-6-qb3SRTsMHzDo56cBSYg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Fig. Dictionary properties in d8 shell</figcaption></figure><h2 id="5f2a" class="mo ke iq bd kf mu mv dn kj mw mx dp kn lm my mz kr lq na nb kv lu nc nd kz ne bi translated">调查的结果</h2><p id="1179" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">对象中的属性“b”被转换为字典属性。DictionaryProperties和dict_index存在于属性存储中。</p><p id="d96f" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">如果从对象中添加和删除属性，会产生大量的时间和内存开销来维护描述符数组和隐藏类。它现在有一个自包含的字典作为属性存储。所有元信息不再存储在隐藏类的描述符数组中，而是直接存储在属性字典中。可以在不更新隐藏类的情况下添加和删除属性。由于内联缓存不处理字典属性，<strong class="ld ir">字典属性通常比快速属性</strong>慢。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="5fc6" class="mo ke iq mk b gy mp mq l mr ms"><strong class="mk ir">Optimization Takeaway</strong></span><span id="0b21" class="mo ke iq mk b gy nx mq l mr ms"><strong class="mk ir">V8 tries to avoid the dictionary mode</strong> <strong class="mk ir">because they hamper the optimization such as inline caches</strong>. <strong class="mk ir">Inobject properties are the fastest one. Donot add or delete object property in the runtime if possible.</strong></span></pre><h1 id="0035" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">阵列优化</h1><h2 id="62b8" class="mo ke iq bd kf mu mv dn kj mw mx dp kn lm my mz kr lq na nb kv lu nc nd kz ne bi translated">元素—数组索引属性</h2><p id="695d" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated"><strong class="ld ir">元素</strong>在数组中最为突出，用于不同的数组原型方法。<strong class="ld ir">它们存储在与命名属性不同的内存位置。</strong>按键只是用来推断位置。JavaScript中的属性名被隐式转换为字符串，即使我们使用它时它们被指定为数字。</p><p id="3c5e" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">V8 跟踪元素类型，这有助于数组优化。在引擎级别，进行了更精确的区分。有<a class="ae kc" href="https://cs.chromium.org/chromium/src/v8/src/elements-kind.h?l=14&amp;rcl=ec37390b2ba2b4051f46f153a8cc179ed4656f5d" rel="noopener ugc nofollow" target="_blank"> 21种不同的元素种类</a>有它们自己特定的优化方法。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6d36" class="mo ke iq mk b gy mp mq l mr ms"><strong class="mk ir">Optmization Takeaway</strong></span><span id="166a" class="mo ke iq mk b gy nx mq l mr ms"><strong class="mk ir">Prefer array over array like objects. This can boost up performance. Avoid reading beyond the length of array which create expensive prtotype chain look up.</strong></span></pre><h2 id="7459" class="mo ke iq bd kf mu mv dn kj mw mx dp kn lm my mz kr lq na nb kv lu nc nd kz ne bi translated">包装与多孔</h2><p id="9e78" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">首先，v8在对象后备存储保存元素的方式上有很大的区别，不管它是打包的还是有洞的。如果你删除或不定义，在对象后备存储器<strong class="ld ir">中会产生空洞。在数组中创建漏洞会导致引擎在原型链中进行代价高昂的查表，这使得代价很高<a class="ae kc" href="https://github.com/BibekShah09/javascript-object-analysis/tree/master/03_elements-access-procedure" rel="noopener ugc nofollow" target="_blank">此处解释</a>。</strong></p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="cf9a" class="mo ke iq mk b gy mp mq l mr ms"><strong class="mk ir">Optimization Takeaway</strong></span><span id="1760" class="mo ke iq mk b gy nx mq l mr ms"><strong class="mk ir">Avoid loading uninitialized (null) elements. Donot delete elements from array which will create holes. v8 has to perform additional checks and can go through the expensive table lookup in prototype chain. Instead, remove the elements from arrary.</strong></span></pre><h2 id="c81a" class="mo ke iq bd kf mu mv dn kj mw mx dp kn lm my mz kr lq na nb kv lu nc nd kz ne bi translated">SMI、Double和常规元素</h2><p id="d39c" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">SMI代表一个小整数。Doubles是浮点数和整数，不能用SMI表示。如果它不能用SMI和Double表示，那么它就是正则元素。</p><h2 id="58aa" class="mo ke iq bd kf mu mv dn kj mw mx dp kn lm my mz kr lq na nb kv lu nc nd kz ne bi translated">元素的过渡</h2><p id="2b43" class="pw-post-body-paragraph lb lc iq ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">元素转换总是单向的，在元素晶格中从更特定的类型转换到不太特定的类型。它不能反转为更具体的类型。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="2d22" class="mo ke iq mk b gy mp mq l mr ms">const array = [1, 2, 3]; // PACKED_SMI_ELEMENTS<br/>array.push(4.44); // PACKED_DOUBLE_ELEMENTS<br/>array.push('x'); // PACKED_ELEMENTS</span><span id="7886" class="mo ke iq mk b gy nx mq l mr ms">const newArray = [1, 2, 3];<br/>delete newArray[1]; // HOLEY_SMI_ELEMENTS<br/>newArray.push(3.33); // HOLEY_DOUBLE_ELEMENTS<br/>newArray.push('x'); // HOLEY_ELEMENTS</span></pre><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/f9d9a8da1ae40b1bd8aeab9751018099.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*584mP_xR0WYeytbfNQVwoQ.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Fig. Element transition in v8 Engine</figcaption></figure><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="91a3" class="mo ke iq mk b gy mp mq l mr ms"><strong class="mk ir">Optimization Takeaway</strong></span><span id="18b6" class="mo ke iq mk b gy nx mq l mr ms"><strong class="mk ir">SMI elements outperform Double and Regular elements. It is better to stick to a more specific type and avoid element transitions if possible.</strong></span></pre><p id="33d9" class="pw-post-body-paragraph lb lc iq ld b le lz lg lh li ma lk ll lm mb lo lp lq mc ls lt lu md lw lx ly ij bi translated">参考此<a class="ae kc" href="https://github.com/BibekShah09/javascript-object-analysis" rel="noopener ugc nofollow" target="_blank"> Github Repo </a>了解完整的设置和结果。</p><h1 id="aa17" class="kd ke iq bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">参考</h1><ol class=""><li id="ebd8" class="nf ng iq ld b le lf li lj lm nh lq ni lu nj ly oc nl nm nn bi translated"><a class="ae kc" href="https://v8.dev/blog" rel="noopener ugc nofollow" target="_blank"> https://v8.dev </a></li><li id="201d" class="nf ng iq ld b le no li np lm nq lq nr lu ns ly oc nl nm nn bi translated"><a class="ae kc" href="https://github.com/sq/JSIL/wiki/Optimizing-dynamic-JavaScript-with-inline-caches" rel="noopener ugc nofollow" target="_blank">https://github . com/sq/JSIL/wiki/Optimizing-dynamic-JavaScript-with-inline-cache</a></li><li id="4a99" class="nf ng iq ld b le no li np lm nq lq nr lu ns ly oc nl nm nn bi translated"><a class="ae kc" href="https://courses.cs.washington.edu/courses/cse501/15sp/papers/ahn.pdf" rel="noopener ugc nofollow" target="_blank">https://courses . cs . Washington . edu/courses/CSE 501/15sp/papers/Ahn . pdf</a></li><li id="5be0" class="nf ng iq ld b le no li np lm nq lq nr lu ns ly oc nl nm nn bi translated">【https://iacoma.cs.uiuc.edu/iacoma-papers/pldi19_2.pdf T4】</li><li id="89d5" class="nf ng iq ld b le no li np lm nq lq nr lu ns ly oc nl nm nn bi translated"><a class="ae kc" href="https://gist.github.com/twokul/9501770" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/twokul/9501770</a></li><li id="590a" class="nf ng iq ld b le no li np lm nq lq nr lu ns ly oc nl nm nn bi translated"><a class="ae kc" href="https://github.com/danbev/learning-v8#object" rel="noopener ugc nofollow" target="_blank">https://github.com/danbev/learning-v8#object</a></li><li id="83e4" class="nf ng iq ld b le no li np lm nq lq nr lu ns ly oc nl nm nn bi translated"><a class="ae kc" href="https://mathiasbynens.be/notes/shapes-ics" rel="noopener ugc nofollow" target="_blank">https://mathiasbynens.be/notes/shapes-ics</a></li><li id="0144" class="nf ng iq ld b le no li np lm nq lq nr lu ns ly oc nl nm nn bi translated"><a class="ae kc" href="https://erdem.pl/2019/08/v-8-function-optimization" rel="noopener ugc nofollow" target="_blank">https://erdem.pl/2019/08/v-8-function-optimization</a></li><li id="4a29" class="nf ng iq ld b le no li np lm nq lq nr lu ns ly oc nl nm nn bi translated"><a class="ae kc" href="https://github.com/davidmarkclements/v8-perf" rel="noopener ugc nofollow" target="_blank">https://github.com/davidmarkclements/v8-perf</a></li></ol></div></div>    
</body>
</html>