<html>
<head>
<title>Best Features of ES2018 — Regex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2018的最佳特性— Regex</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-features-of-es2018-regex-b04f98dd4bed?source=collection_archive---------12-----------------------#2020-09-30">https://javascript.plainenglish.io/best-features-of-es2018-regex-b04f98dd4bed?source=collection_archive---------12-----------------------#2020-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/744c5310cfdc20fd90ce8e6a8750901e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_LBCzyRTnTcx1_Ek"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jamesbold?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Bold</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4d42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了很大的改进。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在使用它比以往任何时候都愉快。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解ES2018的最佳功能。</p><h1 id="9007" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">编号的捕获组</h1><p id="7e13" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">编号的捕获组让我们可以用正则表达式将字符串分开。</p><p id="3bb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是获得团体比赛的老方法。</p><p id="fb75" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与字符串匹配的正则表达式返回匹配的对象。</p><p id="cd1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们可以通过它的索引得到每个部分。,</p><p id="b1ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4d87" class="mn lc iq mj b gy mo mp l mq mr">const PHONE_REGEX = /([0-9]{3})-([0-9]{3})-([0-9]{4})/;</span><span id="aad5" class="mn lc iq mj b gy ms mp l mq mr">const matchObj = PHONE_REGEX.exec('123-456-7890');</span></pre><p id="723d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有3个抓捕小组。2个3位数字，1个4位数字。</p><p id="7cff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以根据每个组的索引得到它。</p><p id="58c7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">命名捕获组的问题是我们必须计算括号。</p><p id="b77e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们必须从正则表达式模式中知道这些组是什么。</p><p id="3300" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们改变正则表达式，就必须改变代码。</p><h1 id="b0e4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">命名的捕获组</h1><p id="b60e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">S2018为我们提供了一种获取组匹配的新方法。</p><p id="0b64" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e154" class="mn lc iq mj b gy mo mp l mq mr">const PHONE_REGEX = /(?&lt;areaCode&gt;[0-9]{3})-(?&lt;officeCode&gt;[0-9]{3})-(?&lt;number&gt;[0-9]{4})/;</span><span id="ab96" class="mn lc iq mj b gy ms mp l mq mr">const matchObj = PHONE_REGEX.exec('123-456-7890');<br/>console.log(matchObj.groups)</span></pre><p id="5221" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们把名字加到了组里。</p><p id="31d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在<code class="fe mt mu mv mj b">groups</code>属性中找到匹配项。</p><p id="e228" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们会得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="36e8" class="mn lc iq mj b gy mo mp l mq mr">{ areaCode: "123", officeCode: "456", number: "7890" }</span></pre><p id="1130" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为<code class="fe mt mu mv mj b">macthObj.groups</code>的值。</p><p id="83b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们可以破坏匹配:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0797" class="mn lc iq mj b gy mo mp l mq mr">const PHONE_REGEX = /(?&lt;areaCode&gt;[0-9]{3})-(?&lt;officeCode&gt;[0-9]{3})-(?&lt;number&gt;[0-9]{4})/;</span><span id="cde3" class="mn lc iq mj b gy ms mp l mq mr">const matchObj = PHONE_REGEX.exec('123-456-7890');<br/>const {<br/>  areaCode,<br/>  officeCode,<br/>  number<br/>} = matchObj.groups;</span></pre><p id="975a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">命名的捕获组很好，因为更容易识别捕获组。</p><p id="e327" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">匹配的代码是描述性的，因为ID描述了它捕获的内容。</p><p id="3540" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在不改变匹配代码的情况下改变模式。</p><p id="62c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">名字使模式更容易理解。</p><h1 id="5ede" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">回溯参考</h1><p id="41bc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在正则表达式中通过名称引用匹配的组。</p><p id="b1c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7367" class="mn lc iq mj b gy mo mp l mq mr">const REGEX = /^(?&lt;word&gt;[abc]+)\k&lt;word&gt;$/;</span><span id="61ae" class="mn lc iq mj b gy ms mp l mq mr">const matchObj = REGEX.exec('abcabc');<br/>console.log(matchObj.groups)</span></pre><p id="3ecb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后用<code class="fe mt mu mv mj b">marchObj.groups.words</code>拿火柴。</p><p id="7b9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">word</code>具有相同的模式。</p><h1 id="9017" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe mt mu mv mj b">replace()</code></h1><p id="d4d6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以对命名的捕获组使用<code class="fe mt mu mv mj b">replace</code>。</p><p id="337f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7014" class="mn lc iq mj b gy mo mp l mq mr">const PHONE_REGEX = /(?&lt;areaCode&gt;[0-9]{3})-(?&lt;officeCode&gt;[0-9]{3})-(?&lt;number&gt;[0-9]{4})/;</span><span id="67e0" class="mn lc iq mj b gy ms mp l mq mr">console.log('123-456-7890'.replace(PHONE_REGEX,<br/>  '$&lt;areaCode&gt;$&lt;officeCode&gt;$&lt;number&gt;'))</span></pre><p id="38b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用正则表达式调用<code class="fe mt mu mv mj b">replace</code>，用我们想要格式化字符串的模式调用一个字符串。</p><p id="65ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只需获取命名的捕获组，并在没有空格的情况下组合它们。</p><p id="bf56" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="260f" class="mn lc iq mj b gy mo mp l mq mr">'1234567890'</span></pre><p id="854b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">回来了。</p><p id="3f00" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还接受一个回调，该回调将组作为参数之一:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9773" class="mn lc iq mj b gy mo mp l mq mr">const PHONE_REGEX = /(?&lt;areaCode&gt;[0-9]{3})-(?&lt;officeCode&gt;[0-9]{3})-(?&lt;number&gt;[0-9]{4})/;</span><span id="20d7" class="mn lc iq mj b gy ms mp l mq mr">console.log('123-456-7890'.replace(PHONE_REGEX,<br/>  (g0, ac, oc, num, offset, input, {<br/>    areaCode,<br/>    officeCode,<br/>    number<br/>  }) =&gt; `${areaCode}${officeCode}${number}`))</span></pre><p id="507f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后一个参数有组。</p><p id="c4a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且，<code class="fe mt mu mv mj b">ac</code>、<code class="fe mt mu mv mj b">oc</code>、<code class="fe mt mu mv mj b">num</code>为组。</p><p id="c2df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们返回一个新的字符串，这样它就是<code class="fe mt mu mv mj b">replace</code>返回的字符串。</p><p id="e4e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">g0</code>已满串。</p><p id="a879" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">offset</code>指定匹配的位置。</p><p id="b1bb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">input</code>有完整的输入字符串。</p><h1 id="8990" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不匹配的命名组</h1><p id="8ea4" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有不匹配的命名组，那么属性将是<code class="fe mt mu mv mj b">groups</code>属性中的<code class="fe mt mu mv mj b">undefined</code>。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/9eaa87e084e34f6c3c4e3603e2af3959.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pn4An8lSf7DRwE1H"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@devjustesen?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Devin Justesen</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="fbef" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d6e3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">命名捕获组便于命名匹配项，因此我们可以更容易地理解它们，而不必更改匹配代码。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mx"><img src="../Images/787be6c671be8d345dc786dad8729ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-sOyyG8NoRbKpCG_y4Cmw@2x.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk"><a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank">Subscribe to Decoded, our official YouTube channel!</a></figcaption></figure></div></div>    
</body>
</html>