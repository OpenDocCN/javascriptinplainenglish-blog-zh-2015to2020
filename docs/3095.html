<html>
<head>
<title>How does Abstract Equality Comparison work?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">抽象相等比较是如何工作的？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-does-abstract-equality-comparison-work-591eed983666?source=collection_archive---------4-----------------------#2020-08-28">https://javascript.plainenglish.io/how-does-abstract-equality-comparison-work-591eed983666?source=collection_archive---------4-----------------------#2020-08-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="aa7c" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">JavaScript没有不好的部分！</h2><div class=""/><div class=""><h2 id="749a" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">双倍等于比较不是一件神奇的事情——它是一种算法</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/c08ae6a9202e8f766843313dff6606b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GSx5ZkIy8N-JgAfQ981agw.jpeg"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@alexacea?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Alexandru Acea</a> on <a class="ae le" href="https://unsplash.com/s/photos/coding?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><blockquote class="lf lg lh"><p id="5b02" class="li lj lk ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">学习如何写代码的最好方法是写代码。</p><p id="d9ea" class="li lj lk ll b lm ln ka lo lp lq kd lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">— <em class="iq">凯尔·辛普森</em></p></blockquote><p id="da27" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">在我作为JavaScript开发人员的职业生涯之初，<strong class="ll ja">我认为避免学习该技术如何在幕后工作并不是一件坏事</strong>。这似乎行得通，但最终，我的代码是错误的。</p><p id="09cf" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">你必须明白的一件重要事情是强制。我听说过的关于强制的一切都是在博客和书籍中，很少提及<a class="ae le" href="https://www.ecma-international.org/ecma-262" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="f738" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">今天，我知道唯一有效的来源是文档。最后，这是一个逻辑问题，因为<strong class="ll ja">谁比创造语言的人更了解编程语言</strong>？</p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><h1 id="a02f" class="mp mq iq bd mr ms mt mu mv mw mx my mz kf na kg nb ki nc kj nd kl ne km nf ng bi translated">严格的平等和抽象的平等有共同之处</h1><p id="3faf" class="pw-post-body-paragraph li lj iq ll b lm nh ka lo lp ni kd lr mf nj lu lv mg nk ly lz mh nl mc md me ij bi translated">我总是喜欢想象事物，所以我举一个简单的例子:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a78e" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">我有一个字符串<code class="fe no np nq nr b">"Jonny"</code>连接到一个变量<code class="fe no np nq nr b">name1</code>。我可以创建一个<code class="fe no np nq nr b">name1</code>的副本，并将其附加到<code class="fe no np nq nr b">name2</code>。所以当我检查严格等式和抽象等式时，两者都返回相同的结果- <em class="lk"> true </em>。</p><p id="69b3" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated"><strong class="ll ja">事实证明，当类型匹配时，系统会调用triple equals。</strong> <a class="ae le" href="https://www.ecma-international.org/ecma-262/#sec-strict-equality-comparison" rel="noopener ugc nofollow" target="_blank">严格</a>和<a class="ae le" href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison" rel="noopener ugc nofollow" target="_blank">宽松</a>等于当类型相同时两者相等。在这种情况下绝对没有区别！</p><h1 id="b24b" class="mp mq iq bd mr ms ns mu mv mw nt my mz kf nu kg nb ki nv kj nd kl nw km nf ng bi translated">Null和undefined有很多共同点</h1><p id="5896" class="pw-post-body-paragraph li lj iq ll b lm nh ka lo lp ni kd lr mf nj lu lv mg nk ly lz mh nl mc md me ij bi translated">在给出参考之前，我不会给你任何信息。正如我之前所说，唯一合法的来源是docs:</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi nx"><img src="../Images/f22b14e69fd893c04ec008963bf49455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RySElEOX43L08jkfdmljTw.png"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Abstract Equality Comparison (source: <a class="ae le" href="https://www.ecma-international.org/ecma-262/#sec-abstract-equality-comparison" rel="noopener ugc nofollow" target="_blank">ECMAScript Standard</a>)</figcaption></figure><p id="d788" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">如果我们决定将空值和未定义的值与松散相等的值进行比较，我们将得到true，因为空值和未定义的值只强制相等:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="bec4" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">如您所见，该特性非常有益，因为您不必担心两个空值。使用一个值要容易得多。在抽象等式中，JavaScript并没有区分这两种类型——它只是遵循了一种算法。</p><p id="2a00" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">当然，你可以选择威胁<em class="lk"> null </em>和<em class="lk"> undefined </em>为两种不同的类型(<strong class="ll ja">严格相等</strong>)。也许你想知道这个值是空的还是未定义的，但是我不确定你必须做出这样的区分。</p><p id="354f" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">我不喜欢这种方法。这可能是一个浪费时间的过程，尤其是当您使用第三方库时。我不喜欢浏览那种文档，寻找输出是未定义的还是空的。我用loose equals用<em class="lk"> null </em>(或者<em class="lk"> undefined </em>)检查空，就是这样。</p><p id="8075" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">无论该属性是否曾经被创建并被重置回空值，或者它从未被创建，这些都是相同的条件。我认为在上面的例子中使用三重等于没有任何好处，因为你不需要为两个空值的差而伤透脑筋。</p><p id="e197" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">你可能想用棉绒，但那不是一个选项。Linters帮助我们决定我们的代码是否结构良好，这样我们就可以避免错误。这不是为了检查程序是否正确。</p><h1 id="86b3" class="mp mq iq bd mr ms ns mu mv mw nt my mz kf nu kg nb ki nv kj nd kl nw km nf ng bi translated">双等于算法</h1><p id="554d" class="pw-post-body-paragraph li lj iq ll b lm nh ka lo lp ni kd lr mf nj lu lv mg nk ly lz mh nl mc md me ij bi translated">最广为人知的强制是从<em class="lk">字符串</em>到<em class="lk">数字</em>，反之亦然。布尔型强制是常见的，我们将讨论这三种类型及其关系。</p><p id="248b" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">有趣的是，当比较类型之一是数字时，算法总是调用<em class="lk"> ToNumber() </em>。<strong class="ll ja">我们可以得出结论，当我们把数与某物相比较时，它总会试图把那某物要挟给数。</strong></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ny"><img src="../Images/065390eaa1e6b1988f3dcac581febf52.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oOtNceCqlSeA6bafE2cn5A.png"/></div></div></figure><p id="21a4" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">正如我们所看到的，四个不同的地方调用了<em class="lk"> ToNumber() </em>。算法更喜欢把一切都还原成一个数字，然后进行比较。这可能很奇怪，但是<strong class="ll ja">算法就是这样工作的</strong>。知道这一点有助于你理解它，并预测双重相等比较的行为。</p><p id="bc55" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">我一直认为比较<code class="fe no np nq nr b">1</code>和<code class="fe no np nq nr b">"1"</code>可以归结为字符串比较。这不是真的，所以不是比较两个字符串，而是比较两个数字。</p><p id="679f" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">结论:<strong class="ll ja">双等号比较喜欢数字比较。</strong></p><p id="79cc" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">你知道字符串和数字如何比较吗？一会儿我会给你看:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="0f1f" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">条件语句将返回<em class="lk">假</em>。这一次不会发生强制，引擎会直接返回<em class="lk"> false </em>。有一种方法可以解决这个问题，但是使用三重等于:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="54c0" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">使用<a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects" rel="noopener ugc nofollow" target="_blank">基本对象</a>(又名原生函数)<em class="lk"> Number() </em>可以很好地处理这个问题。如果你想变得超级清晰，这是一个不错的功能。我不喜欢这种方法，因为需要写更多的东西。</p><p id="f338" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">有时候明确是有用的。例如，如果您试图阻止JS引擎处理数字:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="dd64" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">最后，如果你想和数字打交道，并且<strong class="ll ja">被比较的值中有一个是数字</strong>，那么你可以自由地使用double equals。在这种情况下，你不必显式，因为<strong class="ll ja">抽象是自明的</strong>。</p><p id="ae4d" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">结论:<strong class="ll ja">如果其中一个比较值是数字，那么它检查第二个比较值是否也是数字。那只代表抽象的平等。</strong></p><p id="606b" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">那是我们处理数字的时候，但是字符串是怎么回事呢？当一个或两个值都是字符串时，它会强制转换为数字吗？<strong class="ll ja">没有！</strong> <strong class="ll ja">看看文档就知道了。</strong>如果它们都是相同的类型(在我们的例子中是字符串)，<strong class="ll ja">它将调用三重等于</strong>。</p><p id="841f" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">例如，可以有一个包含空格的字符串。在这种情况下，你可以使用<code class="fe no np nq nr b">.trim()</code>,因为这是一种修剪所有空白的方法。请记住，这种方法不是一种强迫。</p><p id="4c39" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">结论:<strong class="ll ja">如果字符串是相同的，那么你将得到true(它永远不会调用强制)，否则它们不会。</strong></p><h2 id="96db" class="nz mq iq bd mr oa ob dn mv oc od dp mz mf oe of nb mg og oh nd mh oi oj nf iw bi translated"><strong class="ak">客体也是强制的主体</strong></h2><p id="e905" class="pw-post-body-paragraph li lj iq ll b lm nh ka lo lp ni kd lr mf nj lu lv mg nk ly lz mh nl mc md me ij bi translated">我没有忘记对象，因为它们也参与了强制。看一下文档。<strong class="ll ja">规则№10和№11是我们寻求的规则。</strong>如果我们在对象上应用double equals这不是一个基本类型，我们将调用抽象操作<a class="ae le" href="https://www.ecma-international.org/ecma-262/#sec-toprimitive" rel="noopener ugc nofollow" target="_blank"><em class="lk">ToPrimitive()</em></a><em class="lk">。</em></p><p id="0f1c" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">请记住，double equals只比较基本类型，因此将对象转换为基本类型是必要的。如果我们应用严格等于，我们不会调用<em class="lk"> ToPrimitive() </em>，因为<strong class="ll ja">使用严格等于不允许强制</strong>。</p><p id="b39d" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">它唯一一次对非原语做一些事情是在它们是相同类型的时候(调用严格相等比较)。</p><p id="0dba" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">注意:<strong class="ll ja"><em class="lk"/>是一个固有的递归函数，这意味着它将一直调用，直到返回一个原始类型。</strong></p></div><div class="ab cl mi mj hu mk" role="separator"><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn mo"/><span class="ml bw bk mm mn"/></div><div class="ij ik il im in"><p id="cb0e" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">我在网上找到了一个有趣的例子，我花了一些时间寻找一个解释，说明当你的功能设计得不好时<strong class="ll ja">事情会变得多么严重</strong>:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a611" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">使用double等于it这种情况下<strong class="ll ja">可以给我们意外的好结果</strong>。这只是为了演示，所以我不支持你在你的项目中这样做。让我们来看一下算法:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><p id="a264" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">首先，它尝试比较这两个值。由于<code class="fe no np nq nr b">array</code>不是一个基本类型(它是object类型的一个子类型)，它将调用<em class="lk">top primitive()</em>抽象操作。</p><p id="1d72" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">让我们看一下文档，这样我们就可以理解我们期望抽象操作的返回值是什么。</p><p id="c6cb" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">在我们熟悉这个操作之后，我们知道数组字符串化将会排除括号，并且这个操作的结果将会是<em class="lk"> "42 "。如果数组中有多个值，事情不会以这种方式结束。</em>所以，结果发生在一次事故中。</p><p id="706f" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">结论:<strong class="ll ja">避免做没有任何意义的比较。你不应该用三重相等来解决这个问题。</strong></p><p id="1462" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">看到人们如何抱怨双重平等总是很有趣的。在大多数情况下，这不是一个真正的问题。实际问题是做无意义的比较。如果你比较两个不同的东西，而它偶然有效，那是不明智的。</p><p id="35a7" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated">你不能说JS的设计不好。你能够在这种强制中使用<em class="lk"> ToPrimitive() </em>有很多历史原因。我不确定这是否是一个理想的解决方案，因为它可能会产生不良问题。我相信，说到非原始比较，同一性比较就足够了。</p><p id="372c" class="pw-post-body-paragraph li lj iq ll b lm ln ka lo lp lq kd lr mf lt lu lv mg lx ly lz mh mb mc md me ij bi translated"><strong class="ll ja">我们之所以能够要挟对象，是有很强的历史原因的。</strong>在过去，字符串被表示为对象，而不是原始类型。正因为如此，他们让我们使用<em class="lk"> ToPrimitive()，</em>这样我们就可以拆成一个等价的原语:</p><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="nm nn l"/></div></figure><h1 id="5622" class="mp mq iq bd mr ms ns mu mv mw nt my mz kf nu kg nb ki nv kj nd kl nw km nf ng bi translated">澄清</h1><p id="ac13" class="pw-post-body-paragraph li lj iq ll b lm nh ka lo lp ni kd lr mf nj lu lv mg nk ly lz mh nl mc md me ij bi translated">最后，我想总结一下我们的讨论，并将其分为4条有用的规则:</p><ol class=""><li id="4585" class="ok ol iq ll b lm ln lp lq mf om mg on mh oo me op oq or os bi translated">如果被比较的类型相同，它将使用三重等于。</li><li id="46e2" class="ok ol iq ll b lm ot lp ou mf ov mg ow mh ox me op oq or os bi translated">如果它们中的一个或两个都没有定义或为空，则意味着它们相等。</li><li id="9759" class="ok ol iq ll b lm ot lp ou mf ov mg ow mh ox me op oq or os bi translated">如果强制涉及非基本类型，它们将首先成为基本类型。</li></ol><h2 id="d81b" class="nz mq iq bd mr oa ob dn mv oc od dp mz mf oe of nb mg og oh nd mh oi oj nf iw bi translated"><strong class="ak">简明英语JavaScript</strong></h2><p id="fc10" class="pw-post-body-paragraph li lj iq ll b lm nh ka lo lp ni kd lr mf nj lu lv mg nk ly lz mh nl mc md me ij bi translated">你知道我们有三份出版物和一个YouTube频道吗？在<a class="ae le" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ll ja">plain English . io</strong></a>找到一切的链接！</p></div></div>    
</body>
</html>