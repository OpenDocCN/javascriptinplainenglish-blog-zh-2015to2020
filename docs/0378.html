<html>
<head>
<title>Implementing a Linked List in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript实现一个链表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implementing-a-linked-list-in-javascript-3f71c83487b5?source=collection_archive---------0-----------------------#2019-09-30">https://javascript.plainenglish.io/implementing-a-linked-list-in-javascript-3f71c83487b5?source=collection_archive---------0-----------------------#2019-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="00d8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript中的数据结构介绍</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d5c9b8f10e95c5f3d9956f5407e00cbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YN9Fh_GyWvNkRS6BYPnSig.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@jjying?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">JJ Ying</a> on <a class="ae kv" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="57f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated">在列表中存储数据的最好方式是什么？在计算机科学课程中，链表是学习者首先遇到的数据结构之一。它们是一种抽象的数据类型，其中每个元素指向下一个元素，理论上，这为性能带来了一定的优势。</p><p id="9399" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在C和C++这样的低级语言中，有大量关于链表的信息，它们更有可能被应用。但是，在本文中，我想让其他人——比如自学的开发人员或新手——更容易接触到这些信息，他们更习惯于使用更高级的web开发语言，比如JavaScript。</p><h1 id="0ffc" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">我需要用JavaScript实现一个链表吗？</h1><p id="f193" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">对于一篇关于这个主题的文章来说，这似乎是一个奇怪的答案——但不，你可能不会。</p><p id="de89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">理论上，链表<em class="my">在某些情况下</em>应该比数组快，比如插入新的项目。但是，实际上，他们不是。这是因为数组被JavaScript引擎高度优化了，比如用C++编写的Google V8。除非链接列表被引入到ECMAScript规范中，并被给予同样的优化，否则数组(<a class="ae kv" href="https://medium.com/@bretcameron/how-to-make-your-code-faster-using-javascript-sets-b432457a4a77?source=---------27------------------" rel="noopener">或集合</a>)仍然是最快的选择。</p><h1 id="393b" class="mb mc iq bd md me mf mg mh mi mj mk ml jw mm jx mn jz mo ka mp kc mq kd mr ms bi translated">所以，何必呢？</h1><p id="b615" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">嗯，随着JavaScript成为越来越多程序员的首选语言，重要的计算机科学主题应该用人们熟悉的语言来解释，这似乎是合适的。</p><p id="e633" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">经历这一过程有助于加深我对构建库、编译器甚至整个编程语言的考虑和权衡的了解。这些知识可以帮助我们在生产代码中做出更好的决策，即使我们没有使用链表。</p><p id="2fb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">另外，<a class="ae kv" href="https://www.npmjs.com/package/linked-list" rel="noopener ugc nofollow" target="_blank">这个流行的npm包</a>有超过50，000的周下载量，所以显然有一些需求！</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="47a1" class="mb mc iq bd md me ng mg mh mi nh mk ml jw ni jx mn jz nj ka mp kc nk kd mr ms bi translated">数组和链表有什么区别？</h1><p id="c214" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">数组和链表都是有序的数据集合，但是在规模上，一个提供更有效的数据访问，另一个提供更有效的插入。根据实现的不同，可能还会有其他的不同，但这些是最重要的。</p><h2 id="85cb" class="nl mc iq bd md nm nn dn mh no np dp ml lf nq nr mn lj ns nt mp ln nu nv mr nw bi translated">排列</h2><p id="eaa8" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">数组中的每一项都有一个数字，称为数字索引，允许您访问它。这使得访问元素非常有效。</p><p id="a02b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们有一个四个字符串的列表，<code class="fe nx ny nz oa b">'A'</code>、<code class="fe nx ny nz oa b">'B'</code>、<code class="fe nx ny nz oa b">'C'</code>和<code class="fe nx ny nz oa b">'D'</code>。如果我们将这个列表构造成一个数组，它看起来会像这样:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="29a8" class="nl mc iq oa b gy of og l oh oi">| <strong class="oa ir">Value</strong>: | 'A'  | 'B'  | 'C'  | 'D'  |<br/>|--------|------|------|------|------|<br/>| <strong class="oa ir">Index</strong>: | 0    | 1    | 2    | 3    |</span></pre><h2 id="b206" class="nl mc iq bd md nm nn dn mh no np dp ml lf nq nr mn lj ns nt mp ln nu nv mr nw bi translated">链表</h2><p id="4bca" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">每个元素指向下一个元素，而不是使用数字索引。我们不必在每次插入或删除元素时都更新数字索引。特别是，在链表中插入元素比在数组中插入元素更有效。</p><p id="debe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下面是我们的列表看起来的样子，结构像一个链表:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="49ef" class="nl mc iq oa b gy of og l oh oi">| <strong class="oa ir">Value</strong>: | 'A'  | 'B'  | 'C'  | 'D'  |<br/>|--------|------|------|------|------|<br/>| <strong class="oa ir">Next</strong>:  | 'B'  | 'C'  | 'D'  | null |</span></pre></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="3df0" class="mb mc iq bd md me ng mg mh mi nh mk ml jw ni jx mn jz nj ka mp kc nk kd mr ms bi translated">用JavaScript实现一个链表</h1><p id="56eb" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">那么，我们如何在JavaScript中实现一个链表呢？Oleksii Trekhleb的<a class="ae kv" href="https://github.com/trekhleb/javascript-algorithms" rel="noopener ugc nofollow" target="_blank">优秀的JavaScript算法库</a>有一个很好的实现。在本文中，我们将使用Trekhleb的实现作为我们自己的链表的基础，但是我们将在几个重要的方面对它进行更改，通过…</p><ul class=""><li id="dac3" class="oj ok iq ky b kz la lc ld lf ol lj om ln on lr oo op oq or bi translated">添加一个附加方法(<code class="fe nx ny nz oa b">includes</code>)，</li><li id="2121" class="oj ok iq ky b kz os lc ot lf ou lj ov ln ow lr oo op oq or bi translated">添加一个附加属性(<code class="fe nx ny nz oa b">size</code>)，并由</li><li id="0591" class="oj ok iq ky b kz os lc ot lf ou lj ov ln ow lr oo op oq or bi translated">使Trekhleb的一些现有方法(如<code class="fe nx ny nz oa b">constructor</code>函数)更加通用。</li></ul><p id="b0f0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在我们进入代码之前，在您最喜欢的IDE中打开一个新文件夹，并创建三个新的JavaScript文件:<code class="fe nx ny nz oa b">index.js</code>、<code class="fe nx ny nz oa b">LinkedList.js</code>和<code class="fe nx ny nz oa b">LinkedListNode.js</code>。将我们的<code class="fe nx ny nz oa b">LinkedList</code>和单个节点作为单独的类是一个很好的实践，所以首先我们将构建我们的节点类，所以我们将从<code class="fe nx ny nz oa b">LinkedListNode.js</code>开始。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="31ec" class="mb mc iq bd md me ng mg mh mi nh mk ml jw ni jx mn jz nj ka mp kc nk kd mr ms bi translated">第1部分:类构造函数</h1><h2 id="831a" class="nl mc iq bd md nm nn dn mh no np dp ml lf nq nr mn lj ns nt mp ln nu nv mr nw bi translated">LinkedListNode</h2><p id="c3a4" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">每个节点都需要保存自己的值和列表中下一个节点的值，所以我们可以在类构造函数中将每个节点指定为一个属性:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="95a7" class="nl mc iq oa b gy of og l oh oi">class LinkedListNode {<br/>  constructor(value, next) {<br/>    <em class="my">this</em>.value = value;<br/>    <em class="my">this</em>.next = next || null;<br/>  }<br/>}</span><span id="3f7c" class="nl mc iq oa b gy ox og l oh oi">module.exports = LinkedListNode</span></pre><p id="4f4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们的<code class="fe nx ny nz oa b">LinkedListNode</code>课所需要的！回到<code class="fe nx ny nz oa b">index.js</code>，我们可以导入我们的新类并试用它:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="7dbb" class="nl mc iq oa b gy of og l oh oi">const LinkedListNode = require('./LinkedListNode');</span><span id="3961" class="nl mc iq oa b gy ox og l oh oi">console.log(new LinkedListNode(3));<br/>console.log(new LinkedListNode(3, 10));<br/>console.log(new LinkedListNode('string', true));</span></pre><h2 id="e744" class="nl mc iq bd md nm nn dn mh no np dp ml lf nq nr mn lj ns nt mp ln nu nv mr nw bi translated">链接列表构造函数</h2><p id="8c28" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">现在，让我们进入<code class="fe nx ny nz oa b">LinkedList.js</code>，这将是一个更大的类。我们将开始研究构造函数。我们希望在内存中保存第一个条目(T15)和最后一个条目(T16)，默认情况下是T17。</p><p id="9f82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这个实现，我还希望将列表的<code class="fe nx ny nz oa b">size</code>保存在内存中，这样就可以很容易地找出列表中一次有多少项:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="8ea0" class="nl mc iq oa b gy of og l oh oi">const LinkedListNode = require('./LinkedListNode');</span><span id="1c1c" class="nl mc iq oa b gy ox og l oh oi">class LinkedList {<br/>  constructor() {<br/>    <em class="my">this</em>.size = 0;<br/>    <em class="my">this</em>.head = null;<br/>    <em class="my">this</em>.tail = null;<br/>  }<br/>}</span><span id="ba42" class="nl mc iq oa b gy ox og l oh oi">module.exports = LinkedList</span></pre><p id="7eec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请注意，以下所有代码——除非另有说明——都将在<code class="fe nx ny nz oa b">LinkedList</code>类中。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="128c" class="mb mc iq bd md me ng mg mh mi nh mk ml jw ni jx mn jz nj ka mp kc nk kd mr ms bi translated">第2部分:添加新条目</h1><h2 id="ccb3" class="nl mc iq bd md nm nn dn mh no np dp ml lf nq nr mn lj ns nt mp ln nu nv mr nw bi translated">预先考虑</h2><p id="4240" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">在测试新类之前，我们需要一种添加新值的方法。我们将从一个<code class="fe nx ny nz oa b">prepend</code>方法开始，将值添加到列表的前面，类似于<code class="fe nx ny nz oa b">Array.unshift</code>:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="d660" class="nl mc iq oa b gy of og l oh oi">prepend(value) {<br/>  <em class="my">this</em>.size += 1;</span><span id="855d" class="nl mc iq oa b gy ox og l oh oi">  const newNode = new LinkedListNode(value, <em class="my">this</em>.head);</span><span id="3612" class="nl mc iq oa b gy ox og l oh oi">  <em class="my">this</em>.head = newNode;<br/>  if (!<em class="my">this</em>.tail) <em class="my">this</em>.tail = newNode;<br/>  return <em class="my">this</em>;<br/>}</span></pre><ul class=""><li id="40a8" class="oj ok iq ky b kz la lc ld lf ol lj om ln on lr oo op oq or bi translated">首先，我们基于提供的值和当前的<code class="fe nx ny nz oa b">head</code>节点定义一个新节点。</li><li id="ca05" class="oj ok iq ky b kz os lc ot lf ou lj ov ln ow lr oo op oq or bi translated">然后，我们更新<code class="fe nx ny nz oa b">head</code>来等于这个新节点。</li><li id="6e99" class="oj ok iq ky b kz os lc ot lf ou lj ov ln ow lr oo op oq or bi translated">第三，如果没有指定<code class="fe nx ny nz oa b">tail</code>(因为这是列表中的第一项)，那么<code class="fe nx ny nz oa b">head</code>和<code class="fe nx ny nz oa b">tail</code>应该是相同的。</li><li id="923d" class="oj ok iq ky b kz os lc ot lf ou lj ov ln ow lr oo op oq or bi translated">最后，我们用<code class="fe nx ny nz oa b"><em class="my">this</em></code>返回整个<code class="fe nx ny nz oa b">LinkedList</code>。</li></ul><h2 id="1962" class="nl mc iq bd md nm nn dn mh no np dp ml lf nq nr mn lj ns nt mp ln nu nv mr nw bi translated">附加</h2><p id="6fa8" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">我们还希望有一种方法将元素添加到列表的末尾，类似于<code class="fe nx ny nz oa b">Array.push</code>。要做到这一点，还需要几个步骤:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="ba47" class="nl mc iq oa b gy of og l oh oi">append(value) {<br/><em class="my">  this</em>.size += 1;</span><span id="2c2a" class="nl mc iq oa b gy ox og l oh oi">  const newNode = new LinkedListNode(value);</span><span id="2bf1" class="nl mc iq oa b gy ox og l oh oi">  if (!<em class="my">this</em>.head) {<br/>    <em class="my">this</em>.head = newNode;<br/>    <em class="my">this</em>.tail = newNode;<br/>    return <em class="my">this</em>;<br/>  };</span><span id="f2b8" class="nl mc iq oa b gy ox og l oh oi"><em class="my">  this</em>.tail.next = newNode;<br/>  <em class="my">this</em>.tail = newNode;<br/>  return <em class="my">this</em>;<br/>}</span></pre><ul class=""><li id="f6dd" class="oj ok iq ky b kz la lc ld lf ol lj om ln on lr oo op oq or bi translated">像以前一样，我们从创建一个<code class="fe nx ny nz oa b">new LinkedListNode</code>开始，但是这次我们不需要指定第二个参数(因为没有下一个值)。</li><li id="ffdc" class="oj ok iq ky b kz os lc ot lf ou lj ov ln ow lr oo op oq or bi translated">如果这是列表中的第一个元素，我们也要更新<code class="fe nx ny nz oa b"><em class="my">this</em>.head</code>，我们可以提前返回函数。</li><li id="24f0" class="oj ok iq ky b kz os lc ot lf ou lj ov ln ow lr oo op oq or bi translated">最后，我们需要更改当前最终节点的<code class="fe nx ny nz oa b">next</code>属性，然后在末尾插入我们的<code class="fe nx ny nz oa b">newNode</code>。</li></ul><p id="3164" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要了解发生了什么，我建议回到<code class="fe nx ny nz oa b">index.js</code>中，尝试向我们的列表添加值。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="97f2" class="mb mc iq bd md me ng mg mh mi nh mk ml jw ni jx mn jz nj ka mp kc nk kd mr ms bi translated">第3部分:与数组相互转换</h1><p id="93f4" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">为了方便起见，应该可以在构造函数中提供一个数组，并按照这个顺序获得一个<code class="fe nx ny nz oa b">LinkedList</code>项——类似于<code class="fe nx ny nz oa b">Set</code>构造函数。</p><h2 id="1e8d" class="nl mc iq bd md nm nn dn mh no np dp ml lf nq nr mn lj ns nt mp ln nu nv mr nw bi translated">from数组</h2><p id="ecea" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">首先，让我们创建一个<code class="fe nx ny nz oa b">fromArray</code>方法，其中我们<code class="fe nx ny nz oa b">append</code>数组中的每一项:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="5242" class="nl mc iq oa b gy of og l oh oi">fromArray(values) {<br/>  values.forEach(value =&gt; <em class="my">this</em>.append(value));<br/>  return <em class="my">this</em>;<br/>}</span></pre><h2 id="7960" class="nl mc iq bd md nm nn dn mh no np dp ml lf nq nr mn lj ns nt mp ln nu nv mr nw bi translated">构造器</h2><p id="52a1" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">接下来，我们可以在<code class="fe nx ny nz oa b">constructor</code>中触发我们的新方法:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="7420" class="nl mc iq oa b gy of og l oh oi">constructor(value) {<br/>  <em class="my">this</em>.size = 0;<br/>  <em class="my">this</em>.head = null;<br/>  <em class="my">this</em>.tail = null;</span><span id="6a78" class="nl mc iq oa b gy ox og l oh oi">  if (value) {<br/>    if (Array.isArray(value)) return <em class="my">this</em>.fromArray(value);<br/>    return new TypeError(value + ' is not iterable');<br/>  };</span><span id="e0ac" class="nl mc iq oa b gy ox og l oh oi">  return <em class="my">this</em>;<br/>}</span></pre><p id="a0d2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果一个数组被传递，我们运行<code class="fe nx ny nz oa b">fromArray</code>方法。如果传递的不是数组，而是一个值，我们返回一个<code class="fe nx ny nz oa b">TypeError</code>。如果没有提供值，我们将<code class="fe nx ny nz oa b"><em class="my">this</em>.head</code>和<code class="fe nx ny nz oa b"><em class="my">this</em>.tail</code>设置为<code class="fe nx ny nz oa b">null</code>，就像之前一样。</p><h2 id="0054" class="nl mc iq bd md nm nn dn mh no np dp ml lf nq nr mn lj ns nt mp ln nu nv mr nw bi translated">toArray</h2><p id="556b" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">我们还需要一种方法将链表转换回数组。</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="9839" class="nl mc iq oa b gy of og l oh oi">toArray(useNodes = false) {<br/>  const nodes = [];<br/>  let currentNode = <em class="my">this</em>.head;<br/>  while (currentNode) {<br/>    nodes.push(useNodes ? currentNode : currentNode.value);<br/>    currentNode = currentNode.next;<br/>  };<br/>  return nodes;<br/>}</span></pre><p id="590d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个方法包含一个名为<code class="fe nx ny nz oa b">useNodes</code>的参数，当<code class="fe nx ny nz oa b">true</code>时，它将使用每个<code class="fe nx ny nz oa b">LinkedListNode</code>对象填充数组，而不仅仅是值，这对于调试很有帮助。</p><p id="f83a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">回到<code class="fe nx ny nz oa b">index.js</code>，我们可以测试不同之处:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="a4ae" class="nl mc iq oa b gy of og l oh oi">const LinkedList = require('./LinkedList');</span><span id="70ed" class="nl mc iq oa b gy ox og l oh oi">let list = new LinkedList([1, 2, 3]);</span><span id="5ebf" class="nl mc iq oa b gy ox og l oh oi">console.log(list.toArray());<br/>console.log(list.toArray(true));</span></pre></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="9fc3" class="mb mc iq bd md me ng mg mh mi nh mk ml jw ni jx mn jz nj ka mp kc nk kd mr ms bi translated">第4部分:删除条目</h1><h2 id="8b49" class="nl mc iq bd md nm nn dn mh no np dp ml lf nq nr mn lj ns nt mp ln nu nv mr nw bi translated">删除</h2><p id="d1ea" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated"><code class="fe nx ny nz oa b">delete</code>操作是我们所有链表方法中最复杂的，因为它需要稍微不同的步骤，这取决于是否需要删除头、尾或任何其他节点。</p><p id="d83f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">默认情况下，我们的函数将删除某个值的所有节点。但是我们可以将<code class="fe nx ny nz oa b">true</code>作为第二个参数来传递，只删除我们遇到的具有给定值的第一个节点。</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="6f78" class="nl mc iq oa b gy of og l oh oi">delete(value, deleteOne = false) {<br/>  if (!<em class="my">this</em>.head) return false;<br/>  let deletedNode = null;</span><span id="4bf1" class="nl mc iq oa b gy ox og l oh oi"><em class="my">  // If the head needs to be deleted<br/>  </em>while (<em class="my">this</em>.head &amp;&amp; <em class="my">this</em>.head.value === value) {<br/>    <em class="my">this</em>.size -= 1;<br/>    deletedNode = <em class="my">this</em>.head;<br/>    <em class="my">this</em>.head = <em class="my">this</em>.head.next;<br/>    if (deleteOne) return true;<br/>  };</span><span id="3bdb" class="nl mc iq oa b gy ox og l oh oi">  let currentNode = <em class="my">this</em>.head;</span><span id="4bb2" class="nl mc iq oa b gy ox og l oh oi"><em class="my">  // If any node except the head or tail needs to be deleted<br/>  </em>if (currentNode !== null) {<br/>    while (currentNode.next) {<br/>      if (currentNode.next.value === value) {<br/>        <em class="my">this</em>.size -= 1;<br/>        deletedNode = currentNode.next;<br/>        currentNode.next = currentNode.next.next;<br/>        if (deleteOne) return true;<br/>      } else {<br/>        currentNode = currentNode.next;<br/>      };<br/>    };<br/>  };</span><span id="1aab" class="nl mc iq oa b gy ox og l oh oi"><em class="my">  // If the tail needs to be deleted<br/>  </em>if (<em class="my">this</em>.tail.value === value) {<br/>    <em class="my">this</em>.tail = currentNode;<br/>  };</span><span id="fa32" class="nl mc iq oa b gy ox og l oh oi">  if (deletedNode === null) {<br/>    return false;<br/>  } else {<br/>    return true;<br/>  };<br/>}</span></pre><p id="8556" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对我来说，这段代码清楚地说明了为什么删除项目比插入项目要昂贵得多！</p><h2 id="bbfc" class="nl mc iq bd md nm nn dn mh no np dp ml lf nq nr mn lj ns nt mp ln nu nv mr nw bi translated">删除头</h2><p id="f773" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">删除列表开头或结尾的项目也是有用的。对于第一项，这很简单:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="7aec" class="nl mc iq oa b gy of og l oh oi">deleteHead() {<br/>  if (!<em class="my">this</em>.head) return false;</span><span id="550c" class="nl mc iq oa b gy ox og l oh oi"><em class="my">  this</em>.size -= 1;</span><span id="15f3" class="nl mc iq oa b gy ox og l oh oi">  const deletedHead = <em class="my">this</em>.head;</span><span id="3167" class="nl mc iq oa b gy ox og l oh oi">  if (<em class="my">this</em>.head.next) {<br/>    <em class="my">this</em>.head = <em class="my">this</em>.head.next;<br/>  } else {<br/>    <em class="my">this</em>.head = null;<br/>    <em class="my">this</em>.tail = null;<br/>  }</span><span id="a8b4" class="nl mc iq oa b gy ox og l oh oi">  return true;<br/>}</span></pre><h2 id="299c" class="nl mc iq bd md nm nn dn mh no np dp ml lf nq nr mn lj ns nt mp ln nu nv mr nw bi translated">删除尾巴</h2><p id="767b" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">删除最后一个项目是一个开销更大的操作，因为——当列表中有多个项目时——我们需要遍历整个列表来定位倒数第二个项目。</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="2555" class="nl mc iq oa b gy of og l oh oi">deleteTail() {<br/>  if (<em class="my">this</em>.size === 0) return false;</span><span id="1202" class="nl mc iq oa b gy ox og l oh oi">  if (<em class="my">this</em>.size === 1) {<br/>    if (<em class="my">this</em>.head === null) {<br/>      return false;<br/>    } else {<br/>      <em class="my">this</em>.head = null;<br/>      <em class="my">this</em>.tail = null;<br/>      <em class="my">this</em>.size -= 1;<br/>      return true;<br/>    }<br/>  }</span><span id="761c" class="nl mc iq oa b gy ox og l oh oi">  const deletedTail = <em class="my">this</em>.tail;</span><span id="a3f0" class="nl mc iq oa b gy ox og l oh oi">  let currentNode = <em class="my">this</em>.head;<br/>  while (currentNode.next) {<br/>    if (!currentNode.next.next) {<br/>      <em class="my">this</em>.size -= 1;<br/>      currentNode.next = null;<br/>    } else {<br/>      currentNode = currentNode.next;<br/>    }<br/>  }</span><span id="40b7" class="nl mc iq oa b gy ox og l oh oi"><em class="my">  this</em>.tail = currentNode;<br/>  return deletedTail;<br/>}</span></pre></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="753f" class="mb mc iq bd md me ng mg mh mi nh mk ml jw ni jx mn jz nj ka mp kc nk kd mr ms bi translated">第5部分:访问条目</h1><p id="2b9b" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">在链表中，访问值具有线性时间复杂度，因为我们必须遍历整个列表——总是从第一个条目到最后一个条目。</p><h2 id="13d0" class="nl mc iq bd md nm nn dn mh no np dp ml lf nq nr mn lj ns nt mp ln nu nv mr nw bi translated">包含</h2><p id="a5ae" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">在我们的实现中，我们希望我们的<code class="fe nx ny nz oa b">includes</code>方法接受一个值或者一个<code class="fe nx ny nz oa b">LinkedListNode</code>类的实例。如果具有正确值的元素存在于我们的列表中，它应该返回<code class="fe nx ny nz oa b">true</code>，否则返回<code class="fe nx ny nz oa b">false</code>。</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="5bc9" class="nl mc iq oa b gy of og l oh oi">includes(value) {<br/>  if (!<em class="my">this</em>.head) return false;</span><span id="c2ee" class="nl mc iq oa b gy ox og l oh oi">  let isNode = value.constructor.name === 'LinkedListNode';<br/>  if (isNode) value = value.value;</span><span id="a6f3" class="nl mc iq oa b gy ox og l oh oi">  let currentNode = <em class="my">this</em>.head;</span><span id="5703" class="nl mc iq oa b gy ox og l oh oi">  while (currentNode) {<br/>    if (value !== undefined &amp;&amp; value === currentNode.value) {<br/>      return true;<br/>    };<br/>    currentNode = currentNode.next;<br/>  };</span><span id="ecdb" class="nl mc iq oa b gy ox og l oh oi">  return false;<br/>}</span></pre><h2 id="74ec" class="nl mc iq bd md nm nn dn mh no np dp ml lf nq nr mn lj ns nt mp ln nu nv mr nw bi translated">发现</h2><p id="0f3c" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">我们的<code class="fe nx ny nz oa b">find</code>方法应该返回链表中满足回调函数的第一个元素的值。否则应该返回<code class="fe nx ny nz oa b">undefined</code>。如果提供的回调不是一个函数，我们将抛出一个<code class="fe nx ny nz oa b">TypeError</code>:</p><pre class="kg kh ki kj gt ob oa oc od aw oe bi"><span id="f314" class="nl mc iq oa b gy of og l oh oi">find(callback) {<br/>  if (Object.prototype.toString.call(callback) !== '[object Function]') {<br/>    return new TypeError(callback + ' is not a function');<br/>  };</span><span id="4230" class="nl mc iq oa b gy ox og l oh oi">  if (!<em class="my">this</em>.head) return undefined;<br/>  <br/>  let currentNode = <em class="my">this</em>.head;</span><span id="e59d" class="nl mc iq oa b gy ox og l oh oi">  while (currentNode) {<br/>    if (callback &amp;&amp; callback(currentNode.value)) {<br/>      return currentNode;<br/>    };<br/>    currentNode = currentNode.next;<br/>  };</span><span id="7325" class="nl mc iq oa b gy ox og l oh oi">  return undefined;<br/>}</span></pre></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="891e" class="mb mc iq bd md me ng mg mh mi nh mk ml jw ni jx mn jz nj ka mp kc nk kd mr ms bi translated">结论</h1><p id="c541" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">就这样结束了！</p><p id="3e77" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要查看我们实现的完整代码，请查看GitHub要点。</p><p id="f0d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些方法应该足以涵盖链表的核心用例。当然，有很多方法可以扩展我们的<code class="fe nx ny nz oa b">LinkedLists</code>的功能。如果你有兴趣在我们目前所做的基础上进行构建，你可以尝试添加一个<code class="fe nx ny nz oa b">sort</code>、<code class="fe nx ny nz oa b">filter</code>、<code class="fe nx ny nz oa b">reverse</code>、<code class="fe nx ny nz oa b">forEach</code>、<code class="fe nx ny nz oa b">toString</code>或<code class="fe nx ny nz oa b">clear</code>方法。</p><p id="e9a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望您发现这是对计算机科学的基本数据类型之一的有用介绍，如果您有任何问题或反馈，请随时留下评论。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><h1 id="ffb5" class="mb mc iq bd md me ng mg mh mi nh mk ml jw ni jx mn jz nj ka mp kc nk kd mr ms bi translated">进一步阅读</h1><p id="afda" class="pw-post-body-paragraph kw kx iq ky b kz mt jr lb lc mu ju le lf mv lh li lj mw ll lm ln mx lp lq lr ij bi translated">对于链表的可选JavaScript实现，请查看:</p><div class="oy oz gp gr pa pb"><a href="https://www.npmjs.com/package/linked-list" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">链表</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">小型双向链表。子类化:创建新的链表。创建一个新的this并添加给定的项目数组…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">www.npmjs.com</p></div></div><div class="pk l"><div class="pl l pm pn po pk pp kp pb"/></div></div></a></div><div class="oy oz gp gr pa pb"><a href="https://github.com/trekhleb/javascript-algorithms/blob/master/src/data-structures/linked-list/LinkedList.js" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">trekhleb/JavaScript-算法</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">github.com</p></div></div></div></a></div><p id="a7bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您热衷于学习更多关于用JavaScript编写的数据结构和算法的知识，我强烈建议您看看Oleksii Trekhleb的完整JavaScript算法库:</p><div class="oy oz gp gr pa pb"><a href="https://github.com/trekhleb/javascript-algorithms" rel="noopener  ugc nofollow" target="_blank"><div class="pc ab fo"><div class="pd ab pe cl cj pf"><h2 class="bd ir gy z fp pg fr fs ph fu fw ip bi translated">trekhleb/JavaScript-算法</h2><div class="pi l"><h3 class="bd b gy z fp pg fr fs ph fu fw dk translated">这个库包含许多流行算法和数据结构的基于JavaScript的例子。每个算法和…</h3></div><div class="pj l"><p class="bd b dl z fp pg fr fs ph fu fw dk translated">github.com</p></div></div><div class="pk l"><div class="pq l pm pn po pk pp kp pb"/></div></div></a></div></div></div>    
</body>
</html>