<html>
<head>
<title>How to better organize end-points in your web app</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何更好地组织web应用程序中的端点</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-better-organize-end-points-in-frontend-2cebd39b08c3?source=collection_archive---------8-----------------------#2020-06-21">https://javascript.plainenglish.io/how-to-better-organize-end-points-in-frontend-2cebd39b08c3?source=collection_archive---------8-----------------------#2020-06-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/8d4d36bbed293d932f98632805a1f315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vdoBV0RH2CGWdVuQ9Ivb5g.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@oscrse?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Oscar Nilsson</a> on <a class="ae jd" href="/s/photos/organize-things?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><div class=""><h2 id="1cfd" class="pw-subtitle-paragraph kd jf jg bd b ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku dk translated">在任何应用程序中组织端点都很容易长期维护它们</h2></div><p id="e49a" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">大多数前端应用程序调用API来执行CRUD操作，并且这些端点的数量经常随着我们构建应用程序而增加。那么，如何以更好的方式管理这些端点呢？这就是其中之一。</p><p id="de6c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们从一个简单的例子开始。在这种情况下，我使用了一个简单的角度服务，但是这种方法可以用于任何前端框架或库。</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lr"><img src="../Images/8cfcf9816bde6eccd4b5a49217a6724e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e7FO6bB2mG92B1f0BIyzxw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">A simple Angular service</figcaption></figure><p id="f504" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这里，我们有一个简单的服务，它有两个方法，在方法中有硬编码的端点，可以调用API服务来检索数据。如果一个应用程序有更少的端点，这没问题，但是想象一个有数百个端点的企业应用程序？很难知道一个应用程序调用了什么API，也很难维护它们。</p><p id="4864" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">如何改善？</strong></p><p id="418f" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以做的第一件事是，将所有端点移动到一个不同的文件中，并引用服务中的那些端点。我们这样做之后，情况是这样的:</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lw"><img src="../Images/4ca3d0d9e90ff5900ce1d69b288145da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s6TUpqQvAouNJsoU_QjlOA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Angular service class after refactoring</figcaption></figure><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lx"><img src="../Images/ab938d33964ea672b0706b7f1647d5ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ofGMJfJXIBt5AINEy9Z5zw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">New endpoints file</figcaption></figure><p id="4d4c" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">看起来好多了，对吧？但是，如果您注意到<code class="fe ly lz ma mb b">getNewsData</code>方法，它仍然连接路径参数，这看起来不太好。有两种方法可以让事情变得更好。</p><ol class=""><li id="4044" class="mc md jg kx b ky kz lb lc le me li mf lm mg lq mh mi mj mk bi translated"><strong class="kx jh">用于转换网址的自定义实用函数:<br/> </strong>首先，我们可以通过在端点文件中放置一个占位符值(在这种格式下为<code class="fe ly lz ma mb b">:{paramName}</code>)来将路径参数映射移动到端点文件。在服务方法中，我们可以通过传入URL和一个可选的params对象来调用<code class="fe ly lz ma mb b">transform</code>函数，该对象将用实际值替换所有占位符路径参数。</li></ol><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lx"><img src="../Images/8fd58c23facf4ca8994c847f1cfa511c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wrO_tfWUB2WhohgSEm1rfw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">A simple util that resolves the URL</figcaption></figure><p id="d7e3" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">2.<strong class="kx jh">洛达什模板功能:</strong></p><p id="73b7" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">文档链接:</strong><a class="ae jd" href="https://lodash.com/docs/#template" rel="noopener ugc nofollow" target="_blank">https://lodash.com/docs/#template</a></p><p id="744b" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">示例</strong>:</p><pre class="ls lt lu lv gt ml mb mm mn aw mo bi"><span id="1c0c" class="mp mq jg mb b gy mr ms l mt mu">var compiled = _.template(‘hello &lt;%= user %&gt;!’);<br/>compiled({ ‘user’: ‘fred’ });<br/>// =&gt; ‘hello fred!’</span></pre><p id="e235" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个简单的示例，展示了它的外观。</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lx"><img src="../Images/de4251c81470f26779c57cbe93111610.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uzcr0eoHmvocHxi8KtALWg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Example use case for lodash’s template function</figcaption></figure><p id="d634" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx jh">实体层面分离:</strong></p><p id="2410" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当我们有多个业务实体时，我发现在实体级别组织端点会使它更加清晰。示例实现如下所示。</p><figure class="ls lt lu lv gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lx"><img src="../Images/14a9c80f00640351431337962e4a2f05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GuesiZOQfJN-d-WHHXx0CA.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Maintaining endpoints at entity level</figcaption></figure></div><div class="ab cl mv mw hu mx" role="separator"><span class="my bw bk mz na nb"/><span class="my bw bk mz na nb"/><span class="my bw bk mz na"/></div><div class="ij ik il im in"><p id="6367" class="pw-post-body-paragraph kv kw jg kx b ky kz kh la lb lc kk ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就这样。我希望你会发现这很有用。谢谢你的阅读！继续阅读更有趣的文章。</p><h2 id="2e8d" class="mp mq jg bd nc nd ne dn nf ng nh dp ni le nj nk nl li nm nn no lm np nq nr ns bi translated">简单英语中的JavaScript</h2><p id="7550" class="pw-post-body-paragraph kv kw jg kx b ky nt kh la lb nu kk ld le nv lg lh li nw lk ll lm nx lo lp lq ij bi translated">你知道我们有四种出版物吗？通过<a class="ae jd" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kx jh"/></a>——关注我们的出版物并订阅我们的YouTube频道  <strong class="kx jh">来表达爱意吧！</strong></p></div></div>    
</body>
</html>