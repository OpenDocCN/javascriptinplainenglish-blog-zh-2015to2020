<html>
<head>
<title>RxJs Explained In Plain English</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">RxJs用简单的英语解释</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rxjs-explained-in-plain-english-9d2daa329f34?source=collection_archive---------6-----------------------#2020-09-15">https://javascript.plainenglish.io/rxjs-explained-in-plain-english-9d2daa329f34?source=collection_archive---------6-----------------------#2020-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="49fe" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">反应式编程</h2><div class=""/><div class=""><h2 id="9fe3" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">您应该知道的7个最常用的运算符</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/7b0dc690b97214415f6562e8946b6c9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i_v4yL_gxu9TZJ_vPuBl1g.png"/></div></div></figure><h1 id="29d6" class="la lb iq bd lc ld le lf lg lh li lj lk kf ll kg lm ki ln kj lo kl lp km lq lr bi translated">介绍</h1><p id="b7a9" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">您是否想开始学习RxJs，但却对围绕它的一些术语感到困惑？还是你已经在用了，想用更简单的方式去理解？</p><p id="6209" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">不管怎样，你来对地方了。在这篇文章中，你将学到</p><ul class=""><li id="37b3" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">RxJs中使用的术语</li><li id="2bdb" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">观察者、被观察者、订户和运营商的角色及其责任</li><li id="da76" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">如何使用各种方法创建一个可观察的。</li><li id="751f" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">七个最常用的运算符及其工作原理</li></ul><p id="913e" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">RxJs领域有很多内容要介绍，但这篇文章应该能让你了解图书馆里正在发生的事情。</p><p id="df1e" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">注:</strong> <em class="nh">本帖中用到的所有例子都可以在</em> <a class="ae ni" href="https://github.com/Haseeb90/rxjs-explained-in-plain-english" rel="noopener ugc nofollow" target="_blank"> <em class="nh"> RxJs用通俗英语解释的Git资源库</em> </a> <em class="nh">中找到。</em></p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="5641" class="la lb iq bd lc ld nq lf lg lh nr lj lk kf ns kg lm ki nt kj lo kl nu km lq lr bi translated">术语</h1><p id="3e8e" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">RxJS有几个你应该知道的关键人物</p><ul class=""><li id="578f" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">可观察的—产生一个数据序列(流)</li><li id="9fb0" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">观察者-消耗可观察值</li><li id="416d" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">订户—连接观察者和被观察对象</li><li id="34a3" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">运算符-途中值转换</li><li id="8a3a" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">主体——包括可观察对象和观察者</li></ul><p id="f442" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">注意:</strong> <em class="nh">我不打算在这篇文章中深究主题。有不同类型的主题，涵盖了相当多的内容，所以将在不同的职位。</em></p><h2 id="8d23" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq iw bi translated">网飞类比</h2><p id="d362" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">所有这些术语一开始可能很难理解，所以让我们通过类比来更好地理解每个玩家在大计划中的角色。</p><p id="36e4" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">网飞是内容制作人。该公司有一个网站和一个移动应用程序，可以让人们看到他们的内容。我通过创建一个账户成为这项服务的<em class="nh">用户</em>，一旦我<em class="nh">订阅了</em>网飞，我的家人就可以<em class="nh">观看</em>他们制作的内容。</p><p id="6628" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><em class="nh">可观察对象，</em>在本例中是应用程序，可以调用<em class="nh">观察对象，</em>我的家庭上的某些操作。这些行动是</p><ul class=""><li id="28ed" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">next() —提供并播放流中的下一集<em class="nh"/></li><li id="2975" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">error() —当出现<em class="nh">错误</em>时通知观察者</li><li id="3e13" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">complete() —当季节或系列完成<em class="nh">时通知观察者</em></li></ul><p id="43bf" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">作为订阅者，我必须向可观察对象提供一个观察者，一个观看内容的人，以便可观察对象可以调用观察者的<code class="fe og oh oi oj b">next()</code>、<code class="fe og oh oi oj b">error()</code>和<code class="fe og oh oi oj b">complete()</code>方法。</p><p id="9880" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">记住网飞类比，一个可观察对象有以下责任</p><ul class=""><li id="c280" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">允许<em class="nh">订阅</em>和<em class="nh">取消订阅</em>其流</li><li id="7512" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">向观察者发出<em class="nh">下一个</em>值</li><li id="5fd0" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">如果出现问题，通知观察者<em class="nh">错误</em></li><li id="1c2a" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">并在流完成时通知观察者</li></ul><p id="fed3" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">另一方面，观察者可以决定如何</p><ul class=""><li id="220d" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">处理来自可观察值的下一个值<em class="nh"/></li><li id="1844" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">处理从可观察对象发出的任何<em class="nh">错误</em></li><li id="20d5" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">当可观察对象表示数据流<em class="nh">完成</em>时进行处理</li></ul><p id="6174" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">通过为每一个提供一个函数。</p><p id="587b" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果我们把它想象成一个图表，这就是它的样子</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/db43a826f165b5fa312300ed513ecdd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*dDL3TcE_lLjLiMs_cnzH3A.png"/></div><figcaption class="ol om gj gh gi on oo bd b be z dk">A diagram explaining the relation between Observable, Subscribers and Observers</figcaption></figure></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="d8a8" class="la lb iq bd lc ld nq lf lg lh nr lj lk kf ns kg lm ki nt kj lo kl nu km lq lr bi translated">使用RxJs创建可观察值</h1><p id="61c1" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">在这一节中，我们将看看RxJs提供的一些创建可观察对象的方法。我将首先列出它们，然后我们将深入研究代码。</p><ul class=""><li id="6b23" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">来自()</li><li id="7607" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">Observable.create()或(<code class="fe og oh oi oj b">new Observable(fn)</code>)</li><li id="c873" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">属于()</li></ul><p id="ec8c" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">但是在我们开始观察之前，让我们先快速看一下<em class="nh">观察者</em>是什么样子的。</p><p id="2e8d" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如上所述，观察者选择如何处理被观察对象调用的<em class="nh">方法<code class="fe og oh oi oj b">next()</code>、<code class="fe og oh oi oj b">error()</code>和<code class="fe og oh oi oj b">complete()</code>。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi op"><img src="../Images/bf09029633f817aa25f105253759a90c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UrbEWjZ5Vuos3cSLClpsmw.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">Example of a simple Observer that handles the next(), error() and complete() methods</figcaption></figure><p id="c65c" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">注意:</strong> <em class="nh">没有必要在观察者中实现所有三种方法。至少，一个观察者应该能够掌握</em> <code class="fe og oh oi oj b"><em class="nh">next</em></code> <em class="nh">的方法。</em></p><h2 id="db7d" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq iw bi translated">from()函数</h2><p id="5eb9" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">这种方法能够将各种事物转化为可观察的事物。这包括但不限于数组、承诺和可重复项。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/af8fe34cdffff54ff5ccbee088187330.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LQCSmjVR2mjafIL-dvfqRA.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">Example of how to use from() to convert an Array into an Observable.</figcaption></figure><p id="cee6" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">注意:</strong> <em class="nh">在上面的例子中，我已经显式地定义了一个实现了</em> <code class="fe og oh oi oj b"><em class="nh">next()</em></code> <em class="nh">、</em> <code class="fe og oh oi oj b"><em class="nh">error()</em></code> <em class="nh">和</em> <code class="fe og oh oi oj b"><em class="nh">complete()</em></code> <em class="nh">方法的Observer对象，并将其传递给了subscribe方法。RxJs还允许我们将这些作为函数直接传递给subscribe方法。</em></p><p id="8e96" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">请考虑以下情况。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oq"><img src="../Images/0261deda6957d7bcf6287e00f6c76e2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LbuSzThnnc_TwlKTLKifGg.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">Example showing the subscribe method of an Observable taking functions as arguments.</figcaption></figure><p id="8e93" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">当处理承诺时，<code class="fe og oh oi oj b">from()</code>函数返回一个发出承诺的<em class="nh">解析的</em>值的可观察值。如果承诺被<em class="nh">解析</em>，则从可观察值中发出解析值，否则从承诺中发出<em class="nh">拒绝错误</em>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi or"><img src="../Images/37a248f6623dc5a86813fab50401f581.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ob5bvzcidrNxvu0WKkn9RQ.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">Example of using the from() function to handle Promises as an Observable</figcaption></figure><h2 id="94ee" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq iw bi translated">Observable.create()</h2><p id="2cdb" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated"><code class="fe og oh oi oj b">create()</code>方法将函数作为参数，并将其转换为可观察值。每当观察者<em class="nh">订阅</em>该可观察对象时，该函数就会被执行。该功能参数称为<code class="fe og oh oi oj b">onSubscription</code>。</p><p id="9fc0" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">本质上，这允许我们定义当观察者<em class="nh">订阅</em>这个可观察时会发生什么。这使得<strong class="lu ja">我们的</strong>职责是在<code class="fe og oh oi oj b">onSubscription</code>函数中调用观察者的<code class="fe og oh oi oj b">next()</code>、<code class="fe og oh oi oj b">error()</code>和<code class="fe og oh oi oj b">complete()</code>方法。</p><p id="2479" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">调用<code class="fe og oh oi oj b">onSubscription</code>函数时，<code class="fe og oh oi oj b">Observer</code>是其唯一的参数。</p><p id="3b33" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">注意:</strong><em class="nh"/><code class="fe og oh oi oj b">create()</code><em class="nh">方法已被弃用，您应该使用</em> <code class="fe og oh oi oj b">new Observable()</code> <em class="nh">构造函数来代替。在下面的例子中我使用了</em> <code class="fe og oh oi oj b">new Observable()</code> <em class="nh">构造函数，但是在代码文件中你可以看到</em> <code class="fe og oh oi oj b">Observable.create()</code> <em class="nh">的用法。</em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi os"><img src="../Images/62c8ae81e910e09eb6a8b8073c124ba0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0WRD3fQGpoi8Zz2trC5pUg.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">Example of creating an Observable manually using the constructor method.</figcaption></figure><h2 id="2a28" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq iw bi translated">of()函数</h2><p id="1c41" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">该函数接受任意数量的参数，并返回一个可观察值，该可观察值将每个参数作为可观察序列发出。</p><pre class="kp kq kr ks gt ot oj ou ov aw ow bi"><span id="38b3" class="nv lb iq oj b gy ox oy l oz pa">const { of } = require('rxjs');</span><span id="59f9" class="nv lb iq oj b gy pb oy l oz pa">of(1, 2, 3).subscribe(data =&gt; console.log(data));</span></pre><p id="e6f1" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">注意: <em class="nh">我在这里举了一个非常简单的例子，这个例子也可以在RxJs文档中找到。在这篇文章的后面，你会看到更多的使用方法。</em></p><p id="7964" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在本节中，我们介绍了如何使用三种不同的方法来创建一个可观察对象。当然还有更多方法我们没有在这里介绍，但是可以随意浏览<a class="ae ni" href="https://rxjs-dev.firebaseapp.com/guide/operators" rel="noopener ugc nofollow" target="_blank"> RxJs文档</a>。您可以在创建操作符标题下找到它们。</p><p id="db9b" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在下一节中，我们将看看RxJs提供的最常用的操作符。</p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="1183" class="la lb iq bd lc ld nq lf lg lh nr lj lk kf ns kg lm ki nt kj lo kl nu km lq lr bi translated">RxJs运算符</h1><p id="c79a" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">…只是功能。</p><p id="7d17" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">仅此而已。</p><p id="bd9d" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">它们是具有明确定义的输入和输出的函数。一个算子把一个可观察量作为输入，产生一个可观察量作为输出。它们充当转换功能，转换通过它们的数据。</p><p id="d6c6" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">以Array类为例，它有一个名为<code class="fe og oh oi oj b">map()</code>的内置方法。此方法将函数作为参数，并返回一个包含转换后的值的新数组。</p><p id="68d4" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">同样，RxJs提供了一个名为<code class="fe og oh oi oj b">map()</code>的操作符。像来自数组的<code class="fe og oh oi oj b">map()</code>方法一样，它也接受一个函数作为参数，但是操作符返回一个可以订阅的可观察值。</p><p id="e2d0" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">有两种类型的运算符</p><ul class=""><li id="6876" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">创建操作符——用于<em class="nh">创建</em>一个新的可观察对象。这些是我们在这篇文章的第一部分所涉及的内容。</li><li id="d778" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">可管道化运算符-用于在多个步骤中转换数据。这些将一个可观测值作为输入，并产生一个可观测值作为输出。它们是纯函数。这意味着先前的可观测值保持不变。</li></ul><p id="82de" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">RxJs中有很多可用的操作符，但是有一些你可能会更频繁地使用。</p><p id="5d43" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">以下是您可能会经常使用和看到的7个运算符:</p><ul class=""><li id="0947" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">地图</li><li id="8a72" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">过滤器</li><li id="7b24" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">减少</li><li id="e595" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">串联</li><li id="a115" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">合并</li><li id="2970" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">合并地图</li><li id="6960" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">开关图</li></ul><h2 id="6b53" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq iw bi translated">map()、filter()和reduce()运算符</h2><p id="b4fc" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">如果您过去使用过数组，这些操作符可能听起来非常熟悉。它们以完全相同的方式工作，但是在操作符的情况下，每个操作符都返回一个可观察值。</p><p id="3825" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">考虑以下情况</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pc"><img src="../Images/d8fcd99421d2a3ee22170e32e1819584.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UQrvoYvNlJlqGMB-ZE2cqA.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">Example of how to use the map(), filter() and reduce() Operators in RxJs</figcaption></figure><h2 id="cc26" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq iw bi translated">concat()和merge()运算符</h2><p id="6887" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">…两者都做同样的事情。</p><p id="7423" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">它们都返回一个从每个给定的输入可观察对象中发出值的可观察对象。</p><p id="485d" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">两者的关键区别在于<strong class="lu ja"><em class="nh"/></strong>各自散发的数值如何。<strong class="lu ja"> <em class="nh">如何</em> </strong>将决定您在不同的用例中使用哪一个。</p><p id="5f41" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><code class="fe og oh oi oj b">concat</code>将多个可观察值连接在一起，并依次发出它们的值<strong class="lu ja"><em class="nh"/></strong>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pd"><img src="../Images/09e575cc7039db3ab744b264030e087c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KWEK4xh_J3QFMoaq7RcOvA.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">Example of how to use the concat() Operator using RxJs</figcaption></figure><p id="f214" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><code class="fe og oh oi oj b">merge</code>将多个可观测值结合在一起，并发发出它们的值<strong class="lu ja"><em class="nh"/></strong>。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pe"><img src="../Images/685b0413d694d1d4f5ef5f779ecb9aab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VvUWQP-Bq3XRbiQvteNtrg.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">Example of how to use the merge() Operator using RxJs</figcaption></figure><h2 id="6ea3" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq iw bi translated">mergeMap()运算符</h2><p id="f68d" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">A.又名<code class="fe og oh oi oj b">flatMap()</code>操作符允许我们展平嵌套的可观察对象。</p><p id="47e0" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">让我们继续我们的网飞类比。</p><p id="219c" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">一个系列中有多个<strong class="lu ja">季</strong>是可以观察到的。在每一季中，你有10集<strong class="lu ja">可以观看。这种情况下的10集是嵌套的，可以在每一季中观察到。</strong></p><p id="2ebd" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">要观看整个系列，您首先必须选择(订阅)第一季。然后你要一集一集的选(订阅)，看完。</p><p id="85e8" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果我们不使用<code class="fe og oh oi oj b">mergeMap</code>操作符，这就是我们必须要做的。为了看完整场演出，我们必须有嵌套订阅。</p><p id="8661" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">考虑下面的<em class="nh">(不使用</em> <code class="fe og oh oi oj b"><em class="nh">mergeMap</em></code> <em class="nh"> ) </em></p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pf"><img src="../Images/f05b907ac46ad8a21e1157aedd348eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BPIQIXSWfxkg4mKOdyuI5Q.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">Example of nested subscriptions when not using mergeMap</figcaption></figure><p id="e909" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">下面是从上面的代码中提取的关键内容:</p><pre class="kp kq kr ks gt ot oj ou ov aw ow bi"><span id="e0fb" class="nv lb iq oj b gy ox oy l oz pa">/**<br/>* <strong class="oj ja">Without using mergeMap() we'd need to have nested subscriptions</strong><br/>* to get through the entire series.<br/>*/</span><span id="9672" class="nv lb iq oj b gy pb oy l oz pa">const TheLastKingdom$ = getAllEpisodesForThisSeries();</span><span id="bc42" class="nv lb iq oj b gy pb oy l oz pa">// captures one season at a time<br/>TheLastKingdom$<strong class="oj ja">.subscribe</strong>(seasons =&gt; { <br/>  let currentSeason = '';<br/>  <br/>  seasons<strong class="oj ja">.subscribe</strong>(episode =&gt; {<br/>    // Goes through all episodes before going to the next season</span><span id="305e" class="nv lb iq oj b gy pb oy l oz pa">    console.log(episode);<br/>    currentSeason = episode.season;<br/>  });<br/>  <br/>  console.log(`End of ${currentSeason}...\n`)<br/>});</span></pre><p id="25ef" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><code class="fe og oh oi oj b">mergeMap</code>操作符允许我们展平嵌套的可观察对象，这样我们就不需要<em class="nh">嵌套订阅</em>。</p><p id="d00d" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在我们的类比中，<code class="fe og oh oi oj b">mergeMap</code>将允许我们有一个无缝的体验，每一集将一个接一个地播放，而你不必选择(订阅)下一季。</p><p id="a46a" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">上面代码中的所有内容都保持不变。当使用<code class="fe og oh oi oj b">mergeMap</code>操作符时，最后一部分看起来像这样。</p><pre class="kp kq kr ks gt ot oj ou ov aw ow bi"><span id="fa83" class="nv lb iq oj b gy ox oy l oz pa">const TheLastKingdom$ = getAllEpisodesForThisSeries();</span><span id="c4b6" class="nv lb iq oj b gy pb oy l oz pa">TheLastKingdom$<br/>  .<strong class="oj ja">mergeMap</strong>(seasons =&gt; seasons)<br/>  .subscribe(episode =&gt; console.log(episode));</span></pre><p id="6d56" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"> <code class="fe og oh oi oj b"><a class="ae ni" href="https://rxjs-dev.firebaseapp.com/api/operators/mergeMap#description" rel="noopener ugc nofollow" target="_blank">mergeMap</a></code>运营商的<a class="ae ni" href="https://rxjs-dev.firebaseapp.com/api/operators/mergeMap#description" rel="noopener ugc nofollow" target="_blank">官方文档是这样描述的:</a></p><blockquote class="pg ph pi"><p id="f689" class="ls lt nh lu b lv mo ka lx ly mp kd ma pj mq md me pk mr mh mi pl ms ml mm mn ij bi translated">基于对源可观察对象发出的每个项目应用您提供的函数，返回发出项目的可观察对象，其中该函数返回一个可观察对象，然后合并这些结果可观察对象并发出此合并的结果。</p></blockquote><h2 id="e0ad" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq iw bi translated">switchMap()运算符</h2><p id="3e21" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">还在看网飞吗？</p><p id="b2e4" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">很好。</p><p id="574b" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">让我们继续类比。</p><p id="234d" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">你进入搜索页面，搜索你想看的标题。该应用程序向服务器发送请求以获取该标题的详细信息。现在，您正在等待回应，但这花费的时间太长了。这可能是你这边的网络问题，或者是网飞那边的某个东西花了更长时间。</p><p id="6930" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">不管是什么情况，你会失去耐心，去寻找另一个头衔。这一个马上回来。你正在通读描述，突然你首先搜索的标题突然出现在屏幕上。</p><p id="0742" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">你的经历，被毁了。</p><p id="2d15" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">发生了什么事？为什么第一个标题回来了，并得到显示，即使你不再关心它？</p><p id="383a" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">你的第一个请求从未被取消。不管出于什么原因，它只是花了更长的时间来回应。一旦它做出响应，浏览器就会显示通过的内容。</p><p id="270c" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">要修复这种性质的问题，您可以使用<code class="fe og oh oi oj b">switchMap</code>操作符。让我们看看那会是什么样子。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pm"><img src="../Images/73178f2e3da02d8288e00b9ab8508d08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Okg9KBJ_hSdaEPmqPZTpFQ.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">Example of using the switchMap Operator in RxJs</figcaption></figure><p id="5633" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">它是这样工作的。</p><p id="dbd7" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">源observable，在本例中是<code class="fe og oh oi oj b">showNames$</code>，以一秒钟的间隔发出每个节目的名称。内部可观察对象<code class="fe og oh oi oj b">getSearchedShowDetails$</code>模拟一个HTTP请求，通过在返回响应之前添加一个随机延迟来获取节目的细节。</p><p id="dc0e" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">如果在内部可观察对象得到响应之前，源可观察对象发生了变化，那么内部可观察对象将停止发出先前请求中的项目，并开始发出新请求中的项目。</p><p id="fea0" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">这意味着如果<code class="fe og oh oi oj b">getSearchedShowDetails$</code>的响应时间超过一秒，那么这个节目的细节就不会被显示出来。任何小于或恰好在一秒钟内返回的内容都将被发出。</p><p id="5ced" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">下面是上面代码的输出。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi pn"><img src="../Images/9a0b76a8b69110dbc94d25750ac18890.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TSBlsGUfywNrhNcK7JR6Fw.png"/></div></div><figcaption class="ol om gj gh gi on oo bd b be z dk">Example of the output from the switchMap() operator code</figcaption></figure><p id="8275" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在这种情况下，发出的最后一个值将花费整整三秒钟来响应。那是因为源可观测值在那段时间内没有改变它的值。</p><p id="747c" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated"><strong class="lu ja">注意:</strong> <em class="nh">由于</em> <code class="fe og oh oi oj b"><em class="nh">getSearchedShowDetails$</em></code> <em class="nh">函数的随机延迟，运行</em> <code class="fe og oh oi oj b"><em class="nh">switchMap_operator.js</em></code> <em class="nh">文件中的代码时，输出可能不一样。</em></p></div><div class="ab cl nj nk hu nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ij ik il im in"><h1 id="4475" class="la lb iq bd lc ld nq lf lg lh nr lj lk kf ns kg lm ki nt kj lo kl nu km lq lr bi translated">结论</h1><p id="a607" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">好了，这个帖子到此为止。</p><p id="b440" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">您现在应该对有了很好的理解</p><ul class=""><li id="aed7" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated">RxJs中使用的术语</li><li id="6ea0" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">观察者、被观察者、订户和运营商的角色及其责任</li><li id="b1c7" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">如何使用各种方法创建一个可观察的。</li><li id="297e" class="mt mu iq lu b lv nc ly nd mb ne mf nf mj ng mn my mz na nb bi translated">一些最常用的运算符及其工作原理</li></ul><p id="d489" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">在RxJs的土地上还有很多要介绍的内容，但是这应该会让您了解正在发生的事情。</p><p id="f5e1" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">下次再见，✌️和平</p><p id="4492" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">一定要看看这篇文章的第二部分，它涵盖了错误处理。</p><div class="po pp gp gr pq pr"><a href="https://medium.com/@haseebkhan_90/3-ways-to-handle-errors-in-rxjs-97a04f2ecdc" rel="noopener follow" target="_blank"><div class="ps ab fo"><div class="pt ab pu cl cj pv"><h2 class="bd ja gy z fp pw fr fs px fu fw iz bi translated">RxJs中处理错误的3种方法</h2><div class="py l"><h3 class="bd b gy z fp pw fr fs px fu fw dk translated">使用catchError、retry和retryWhen运算符</h3></div><div class="pz l"><p class="bd b dl z fp pw fr fs px fu fw dk translated">medium.com</p></div></div><div class="qa l"><div class="qb l qc qd qe qa qf ky pr"/></div></div></a></div><p id="a159" class="pw-post-body-paragraph ls lt iq lu b lv mo ka lx ly mp kd ma mb mq md me mf mr mh mi mj ms ml mm mn ij bi translated">资源:</p><ul class=""><li id="95f0" class="mt mu iq lu b lv mo ly mp mb mv mf mw mj mx mn my mz na nb bi translated"><a class="ae ni" href="https://rxjs-dev.firebaseapp.com/guide/operators" rel="noopener ugc nofollow" target="_blank">关于操作员的RxJs文件</a></li></ul><h2 id="664d" class="nv lb iq bd lc nw nx dn lg ny nz dp lk mb oa ob lm mf oc od lo mj oe of lq iw bi translated">简单英语的JavaScript</h2><p id="995f" class="pw-post-body-paragraph ls lt iq lu b lv lw ka lx ly lz kd ma mb mc md me mf mg mh mi mj mk ml mm mn ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae ni" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="lu ja">订阅解码，我们的YouTube频道</strong> </a> <strong class="lu ja">获取更多类似内容！</strong></p></div></div>    
</body>
</html>