<html>
<head>
<title>I created the exact same app in React and Vue. Here are the differences. [2019 Edition]</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我在React和Vue中创建了完全相同的应用程序。以下是不同之处。[2019版]</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2019-edition-42ba2cab9e56?source=collection_archive---------0-----------------------#2019-09-28">https://javascript.plainenglish.io/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2019-edition-42ba2cab9e56?source=collection_archive---------0-----------------------#2019-09-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="257f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React vs Vue。最后是Vue和React的并列代码对比！🎉[针对2019年更新和重写:现在带有React挂钩]</h2></div><p id="99e5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在工作中使用过Vue之后，我对它有了相当扎实的理解。然而，我很好奇栅栏另一边的草是什么样的——这种情况下的草会有什么反应。</p><p id="e807" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">注:这里可以找到这篇文章的新版本:</em><a class="ae lc" href="https://sunilsandhu.com/posts/i-created-the-exact-same-app-in-react-and-vue-2020-edition" rel="noopener ugc nofollow" target="_blank"><strong class="kh ir"><em class="lb">https://sunilsandhu . com/posts/I-created-the-exact-same-app-in-react-and-vue-2020-edition</em></strong></a></p><p id="3065" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我读了React文档，看了一些教程视频，虽然它们都很棒，但我真正想知道的是React和Vue有什么不同。我说的“不同”并不是指他们是否都有虚拟DOMS或者他们如何渲染页面。我希望有人花时间来解释代码！我想找一篇花时间解释这一点的文章，以便刚接触Vue或React(或整个Web开发)的人能够更好地理解这两者之间的区别。</p><p id="25e4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不幸的是，我找不到任何解决这个问题的方法。所以我意识到，我必须自己动手建造它，才能看到相似之处和不同之处。在这样做的时候，我想我应该把整个过程记录下来，这样一篇关于这个的文章就会最终存在。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/c85f1afbf95d7fc38b1b42e2234bfd0f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WRzDZndJCduHwqgOpWmbhQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Who wore it better?</figcaption></figure><p id="6c49" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我决定尝试构建一个相当标准的待办事项应用程序，允许用户在列表中添加和删除项目。这两个应用程序都是使用默认cli构建的(react使用create-react-app，vue使用vue-cli)。顺便说一下，CLI代表命令行界面。🤓</p><p id="a012" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">喜欢这篇文章吗？如果有，获取更多类似内容通过</em> <a class="ae lc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kh ir"> <em class="lb">订阅解码，我的YouTube频道</em> </strong> </a> <strong class="kh ir"> <em class="lb">！</em>T19】</strong></p><h1 id="9078" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">无论如何，这个介绍已经比我预期的要长了。让我们先来快速了解一下这两款应用的外观:</h1><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ml"><img src="../Images/be38aef034d973643aa0bafdc33a1d51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fiKg1ve_EvCP5FIImxXNGQ.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">React vs Vue. The Immovable Object meets the Irresistible Force!</figcaption></figure><p id="f756" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两个应用程序的CSS代码完全相同，但是它们的位置不同。记住这一点，接下来让我们看看这两个应用程序的文件结构:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mm"><img src="../Images/5af971db8a1b084b491a630c8f7225bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_PLsruUOmY05eHumVcXobA.png"/></div></div></figure><p id="29ff" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你会发现它们的结构也几乎相同。这里唯一的区别是React应用程序有两个CSS文件，而Vue应用程序没有。这样做的原因是，在create-react-app中，react组件将有一个附带的文件来保存其样式，而Vue CLI采用一种无所不包的方法，其中样式在实际的组件文件中声明。</p><p id="c296" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">更新:事后看来，拥有三个CSS文件对React来说更有意义，因此App.js、ToDo.js和ToDoItem.js有一个单独的CSS文件</em></p><p id="d743" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最终，它们都实现了同样的事情，没有什么可以说你不能继续在React或Vue中构造不同的CSS。真的归结为个人喜好。您将会听到来自开发社区的关于CSS应该如何构建的大量讨论，特别是关于React，因为有许多CSS-in-JS解决方案，如styled-components和emotion。顺便说一下，CSS-in-JS就是字面上的意思。虽然这些都很有用，但现在，我们将只遵循两个CLI中的结构。</p><p id="19f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是在我们继续之前，让我们快速看一下典型的Vue和React组件是什么样子的:</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi mn"><img src="../Images/b075d3d007f680999260db53dc04654b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bm3dRa5hAHnj89rgm-qoIw.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">React on the left. Vue on the right.</figcaption></figure><p id="944e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们进入本质的细节！</p><h1 id="8014" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">我们如何改变数据？</h1><p id="3874" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">但是首先，我们所说的“变异数据”是什么意思？听起来有点专业，不是吗？它基本上只是意味着改变我们已经存储的数据。所以，如果我们想把一个人的名字从约翰改成马克，我们就要“改变数据”。所以这就是React和Vue的关键区别所在。Vue本质上创建了一个数据对象，其中的数据可以自由更新，而React通过所谓的状态挂钩来处理这个问题。</p><p id="0b7e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们看看下图中两者的设置，然后我们将解释接下来会发生什么:</p><div class="le lf lg lh gt ab cb"><figure class="mt li mu mv mw mx my paragraph-image"><img src="../Images/46023023a79660a8c2219f3bfc0fd953.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*FJUqOfbq4tJfUmYcfEP_6Q.png"/></figure><figure class="mt li mz mv mw mx my paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><img src="../Images/6ccf262bebd9683d12d91edeb175b613.png" data-original-src="https://miro.medium.com/v2/resize:fit:788/format:webp/1*arGsd8bK8QAlQhfUFWAcSA.png"/></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk na di nb nc">React on the left. Vue on the right.</figcaption></figure></div><p id="d003" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，您可以看到，我们将相同的数据传递给了两者，但结构略有不同。</p><p id="bbc8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Vue中，通常会将组件的所有可变数据放在一个<code class="fe nd ne nf ng b">data()</code>函数中，该函数返回一个包含数据的对象(如右图所示)。</p><p id="1525" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用React——或者至少从2019年开始——我们通常会通过一系列挂钩来处理状态。如果你以前没有见过这种类型的概念，这些可能看起来有点奇怪。基本上，它的工作方式如下:</p><p id="9bec" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">假设我们想要创建一个待办事项列表。我们可能需要创建一个名为<code class="fe nd ne nf ng b">list</code>的变量，它可能需要一个字符串或者对象的数组(如果我们想给每个<code class="fe nd ne nf ng b">todo</code>字符串一个ID或者一些其他的东西。我们将通过编写<code class="fe nd ne nf ng b">const [list, setList] = useState([])</code>来设置它。这里我们使用了React称之为钩子的东西useState。这基本上让我们在组件中保持本地状态。</p><p id="9090" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，你可能已经注意到我们在<code class="fe nd ne nf ng b">useState()</code>中传递了一个空数组<code class="fe nd ne nf ng b">[]</code>。我们在里面放的是我们希望<code class="fe nd ne nf ng b">list</code>最初被设置的值，在我们的例子中，我们希望它是一个空数组。然而，你会从上面的图片中看到，我们在数组内部传入了一些数据，这些数据最终成为了<code class="fe nd ne nf ng b">list</code>的初始化数据。想知道<code class="fe nd ne nf ng b">setList</code>是做什么的？稍后会有更多关于这个的内容！</p><h2 id="f6f6" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated"><strong class="ak">那么我们如何在应用程序中引用可变数据呢？</strong></h2><p id="fda2" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">好吧，假设我们有一些名为<code class="fe nd ne nf ng b">name</code>的数据，它被赋予了一个值<code class="fe nd ne nf ng b">‘Sunil<strong class="kh ir">’</strong></code>。</p><p id="33f5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Vue中，它将位于<code class="fe nd ne nf ng b">data()</code>对象的内部，并被称为<code class="fe nd ne nf ng b">name: ‘Sunil'</code>。在我们的应用程序中，我们将通过调用<strong class="kh ir"> </strong> <code class="fe nd ne nf ng b">this.name</code>来引用它。我们也可以通过调用<code class="fe nd ne nf ng b">this.name = ‘John’</code>来更新它。这会把我的名字改成约翰。我不确定我被叫做约翰是什么感觉，但是嘿，事情发生了！😅</p><p id="176c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在React中，由于我们有用<code class="fe nd ne nf ng b">useState()</code>创建的更小的状态片段，很可能我们会按照<code class="fe nd ne nf ng b">const [name, setName] = useState('Sunil')</code>的思路创建一些东西。在我们的应用程序中，我们将通过简单地调用<code class="fe nd ne nf ng b">name</code>来引用相同的数据。现在这里的关键区别是，我们不能简单地编写<code class="fe nd ne nf ng b">name = ‘John’</code>，因为React有适当的限制来防止这种容易的、无忧无虑的变异。所以在React中，我们会写<code class="fe nd ne nf ng b">setName('John')</code>。这就是<code class="fe nd ne nf ng b">setName</code>位发挥作用的地方。基本上，在<code class="fe nd ne nf ng b">const [name, setName] = useState('Sunil')</code>中，它创建了两个变量，一个变成了<code class="fe nd ne nf ng b">const name = 'Sunil'</code>，而第二个<code class="fe nd ne nf ng b">const setName</code>被分配了一个函数，使得<code class="fe nd ne nf ng b">name</code>能够用一个新值重新创建。</p><p id="5611" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Effectively React和Vue在这里做着同样的事情，那就是创建可以更新的数据。默认情况下，每当有数据更新时，Vue都会组合自己版本的<code class="fe nd ne nf ng b">name</code>和<code class="fe nd ne nf ng b">setName</code>。所以简而言之，React要求你用里面的值调用<code class="fe nd ne nf ng b">setName()</code>来更新状态，Vue假设如果你曾经试图更新数据对象里面的值，你会想要这样做。那么，为什么React还要费心将值从函数中分离出来，为什么还需要<code class="fe nd ne nf ng b">useState()</code>？让我们把这个交给<a class="ae lc" href="https://medium.com/@revanth0212" rel="noopener"> Revanth Kumar </a>来解释:</p><blockquote class="nt nu nv"><p id="76f3" class="kf kg lb kh b ki kj jr kk kl km ju kn nw kp kq kr nx kt ku kv ny kx ky kz la ij bi translated">“这是因为React希望在状态改变时重新运行某些生命周期挂钩。当您调用useState函数时，它会知道状态已经改变。如果您直接改变状态，React将不得不做更多的工作来跟踪变化以及运行什么生命周期挂钩等等。所以为了简单起见，React使用了useState。</p></blockquote><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi nz"><img src="../Images/8af27666f806002b3a9c52fb46f4b152.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*N1qdYc-MB9cfAPqTleU8HA.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Bean knew best.</figcaption></figure><p id="065d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们已经有了一些变化，让我们看看如何在我们的待办事项应用程序中添加新的项目，从而进入本质。</p><h1 id="133a" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">我们如何创建新的待办事项？</h1><h2 id="a5ff" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">反应:</h2><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="c93c" class="nh lu iq ng b gy oe of l og oh">const createNewToDoItem = () =&gt; {<br/>  const newId = Math.max(...list.map((t) =&gt; t.id)) + 1<br/>  const newToDo = { id: newId, text: toDo };</span><span id="6b5e" class="nh lu iq ng b gy oi of l og oh">  setList([...list, newToDo]);<br/>  setToDo("");<br/>};</span></pre><h2 id="fef4" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">React是怎么做到的？</h2><p id="562f" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">在React中，我们的输入字段有一个名为<strong class="kh ir"> value的属性。</strong>每当这个值通过所谓的<strong class="kh ir"> onChange事件监听器</strong>改变时，这个值就会自动更新。JSX(基本上是HTML的一种变体)如下所示:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="7506" class="nh lu iq ng b gy oe of l og oh">&lt;input type="text" <br/>       value={toDo} <br/>       onChange={handleInput}/&gt;</span></pre><p id="c136" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以每次值改变时，它更新状态。<code class="fe nd ne nf ng b">handleInput</code>函数看起来像这样:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="bc9a" class="nh lu iq ng b gy oe of l og oh">const handleInput = (e) =&gt; {<br/>  setToDo(e.target.value);<br/>};</span></pre><p id="d092" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，每当用户按下页面上的<strong class="kh ir"> + </strong>按钮来添加新项目时，就会触发<strong class="kh ir">createnewdoitem</strong>功能。让我们再来看一下这个函数，以分解正在发生的事情:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="bc44" class="nh lu iq ng b gy oe of l og oh">const createNewToDoItem = () =&gt; {<br/>  const newId = Math.max(...list.map((t) =&gt; t.id)) + 1<br/>  const newToDo = { id: newId, text: toDo };</span><span id="12e2" class="nh lu iq ng b gy oi of l og oh">  setList([...list, newToDo]);<br/>  setToDo("");<br/>};</span></pre><p id="32f4" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本质上，<code class="fe nd ne nf ng b">newId</code>函数基本上是创建一个新的ID，我们将赋予新的<code class="fe nd ne nf ng b">toDo</code>项目。<code class="fe nd ne nf ng b">newToDo</code>变量是一个对象，它有一个<code class="fe nd ne nf ng b">id</code>键，键的值来自<code class="fe nd ne nf ng b">newId</code>。它还有一个<code class="fe nd ne nf ng b">text</code>键，将来自<code class="fe nd ne nf ng b">toDo</code>的值作为它的值。这与输入值改变时更新的<code class="fe nd ne nf ng b">toDo</code>相同。</p><p id="4b45" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们运行<code class="fe nd ne nf ng b">setList</code>函数，并传入一个数组，该数组包含我们的整个<code class="fe nd ne nf ng b">list</code>以及新创建的<code class="fe nd ne nf ng b">newToDo</code>。</p><p id="063e" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe nd ne nf ng b">...list</code>，位看起来很奇怪，那么开头的三个点就是所谓的spread运算符，它基本上传递来自<code class="fe nd ne nf ng b">list</code>的所有值，但作为单独的项，而不是简单地将整个项数组作为数组传递。迷茫？如果是这样，我强烈推荐阅读spread，因为它很棒！</p><p id="c9a3" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">总之，最后我们运行<code class="fe nd ne nf ng b">setToDo()</code>，传入一个空字符串。这使得我们的输入值为空，准备好输入新的toDos。</p><h2 id="b4e3" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">Vue:</h2><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="d713" class="nh lu iq ng b gy oe of l og oh">createNewToDoItem() {<br/>  const newId = Math.max(...this.list.map(t =&gt; t.id)) + 1;<br/>  <br/>  this.list.push({ id: newId, text: this.todo });<br/>  this.todo = "";<br/>}</span></pre><h2 id="27ea" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">Vue是怎么做到的？</h2><p id="2af6" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">在Vue中，我们的<strong class="kh ir">输入</strong>字段上有一个名为<strong class="kh ir"> v-model </strong>的句柄。这允许我们做一些被称为<strong class="kh ir">双向绑定</strong>的事情。让我们快速查看一下我们的输入字段，然后我们将解释这是怎么回事:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="ac9f" class="nh lu iq ng b gy oe of l og oh">&lt;input type="text" v-model="todo"/&gt;</span></pre><p id="713b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">V-Model将这个字段的输入与我们的数据对象toDoItem中的一个键联系起来。当页面加载时，我们必须将toDoItem设置为一个空字符串，如下:<strong class="kh ir"> todo: '' </strong>。如果这里已经有一些数据，比如<strong class="kh ir"> todo:'在这里添加一些文本'</strong>，我们的输入字段将加载已经在输入字段内的<em class="lb">在这里添加一些文本</em>。无论如何，回到空字符串，我们在输入字段中输入的任何文本都会绑定到<strong class="kh ir"> todo </strong>的值。这实际上是双向绑定(输入字段可以更新数据对象，数据对象可以更新输入字段)。</p><p id="bf55" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以回头看看前面的<strong class="kh ir">createnewdoitem()</strong>代码块，我们看到我们将<strong class="kh ir"> todo </strong>的内容推入<strong class="kh ir">列表</strong>数组<strong class="kh ir"> </strong>中，然后将<strong class="kh ir"> todo </strong>更新为空字符串。</p><p id="bd0c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还使用了React示例中使用的相同的<code class="fe nd ne nf ng b">newId()</code>函数。</p><h1 id="79b2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">我们如何从列表中删除？</h1><h2 id="34a8" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">反应:</h2><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="47d1" class="nh lu iq ng b gy oe of l og oh">const deleteItem = (item) =&gt; {<br/>  setList(list.filter((todo) =&gt; todo !== item));<br/>};</span></pre><h2 id="1437" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">React是怎么做到的？</h2><p id="3731" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">因此，虽然<code class="fe nd ne nf ng b">deleteItem()</code>函数位于<strong class="kh ir"> ToDo.js </strong>内部，但我可以很容易地在<strong class="kh ir"> ToDoItem.js </strong>内部引用它，方法是首先将<strong class="kh ir"> deleteItem() </strong>函数作为道具传递给<strong class="kh ir"> &lt; ToDoItem/ &gt; </strong>:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="c98d" class="nh lu iq ng b gy oe of l og oh">&lt;ToDoItem deleteItem={deleteItem}/&gt;</span></pre><p id="e3b9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这首先将功能向下传递，使孩子可以访问它。然后，在<strong class="kh ir"> ToDoItem </strong>组件中，我们执行以下操作:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="112d" class="nh lu iq ng b gy oe of l og oh">&lt;button className="ToDoItem-Delete" onClick={() =&gt; deleteItem(item)}&gt; - &lt;/button&gt;</span></pre><p id="86bc" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要引用父组件中的函数，我只需引用<strong class="kh ir"> props.deleteItem </strong>。现在你可能已经注意到，在代码示例中，我们只是写了<code class="fe nd ne nf ng b">deleteItem</code>而不是<code class="fe nd ne nf ng b">props.deleteItem</code>。这是因为我们使用了一种被称为<strong class="kh ir">析构</strong>的技术，它允许我们获取<strong class="kh ir">道具</strong>对象的一部分，并将它们分配给变量。因此，在我们的<strong class="kh ir"> ToDoItem.js </strong>文件中，我们有以下内容:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="b216" class="nh lu iq ng b gy oe of l og oh">const ToDoItem = (props) =&gt; {<br/>  const { item, deleteItem } = props;<br/>}</span></pre><p id="bb81" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这为我们创建了两个变量，一个叫做<code class="fe nd ne nf ng b">item</code>，它被赋予与<code class="fe nd ne nf ng b">props.item</code>相同的值，另一个叫做<code class="fe nd ne nf ng b">deleteItem</code>，它被赋予来自<code class="fe nd ne nf ng b">props.deleteItem</code>的值。我们可以通过简单地使用<code class="fe nd ne nf ng b">props.item</code>和<code class="fe nd ne nf ng b">props.deleteItem</code>来避免整个析构过程，但是我认为这值得一提！</p><h2 id="0de2" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">Vue:</h2><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="663a" class="nh lu iq ng b gy oe of l og oh">onDeleteItem(item){<br/>  <strong class="ng ir">this</strong>.list = <strong class="ng ir">this</strong>.list.filter(todo =&gt; todo !== item);<br/>}</span></pre><h2 id="aa94" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">Vue是怎么做到的？</h2><p id="a5e6" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">在Vue中需要一种稍微不同的方法。我们必须做三件事:</p><p id="7f4a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，在我们想要调用函数的元素上:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="2496" class="nh lu iq ng b gy oe of l og oh">&lt;div class=”ToDoItem-Delete” @click=”deleteItem(item)”&gt;-&lt;/div&gt;</span></pre><p id="006b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们必须创建一个emit函数作为子组件内部的方法(在本例中是<strong class="kh ir"> ToDoItem.vue </strong>)，如下所示:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="5bee" class="nh lu iq ng b gy oe of l og oh">deleteItem(item) {<br/>    <strong class="ng ir">this</strong>.$emit('delete', item)<br/>}</span></pre><p id="d92a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与此同时，你会注意到当我们在<strong class="kh ir"> ToDo.vue </strong>内添加<strong class="kh ir"> ToDoItem.vue </strong>时，我们实际上引用了一个<strong class="kh ir">函数</strong>:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="9c83" class="nh lu iq ng b gy oe of l og oh">&lt;ToDoItem v-for="todo in list" <br/>          :todo="todo" <br/>          <strong class="ng ir">@delete="onDeleteItem" //</strong> &lt;-- this :)<br/>          :key="todo.id" /&gt;</span></pre><p id="2e13" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是所谓的自定义事件侦听器。它监听任何使用字符串“delete”触发发出的情况。如果它听到这个消息，就会触发一个名为<strong class="kh ir"> onDeleteItem </strong>的函数。该函数位于<strong class="kh ir"> ToDo.vue，</strong>内，而不是<strong class="kh ir"> ToDoItem.vue </strong>内。这个函数，如前所述，简单地过滤<strong class="kh ir"/><strong class="kh ir">数据对象</strong>中的<strong class="kh ir"> todo数组</strong>，以移除被点击的项目。</p><p id="cd63" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里还值得注意的是，在Vue示例中，我可以简单地在<strong class="kh ir"> @click </strong>侦听器中编写<strong class="kh ir"> $emit </strong>部分，如下所示:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="a463" class="nh lu iq ng b gy oe of l og oh">&lt;div class=”ToDoItem-Delete” @click=”$emit(‘delete’, item)”&gt;-&lt;/div&gt;</span></pre><p id="55e8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这会将步骤数从3个减少到2个，这完全取决于个人偏好。</p><p id="a476" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">简而言之，React中的子组件将通过<strong class="kh ir"> props </strong>访问父函数(假设您正在向下传递props，这是相当标准的做法，您将在其他React示例中多次遇到这种情况)，而在Vue中，您必须从子组件发出事件，这些事件通常将在父组件中收集。</p><h1 id="09af" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">我们如何传递事件侦听器？</h1><h2 id="74ac" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">反应:</h2><p id="104f" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">诸如点击事件等简单事件的事件侦听器是直接的。以下是我们如何为创建新ToDo项目的按钮创建click事件的示例:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="40ab" class="nh lu iq ng b gy oe of l og oh">&lt;button className=”ToDo-Add” onClick={createNewToDoItem}&gt;+&lt;/div&gt;.</span></pre><p id="ee85" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里非常简单，看起来很像我们用普通JS处理内嵌onClick的方式。正如在Vue一节中提到的，每当按下enter按钮时，设置一个事件监听器来处理它要花一点时间。这实际上要求输入标记处理onKeyPress事件，如下所示:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="8382" class="nh lu iq ng b gy oe of l og oh">&lt;input type=”text” onKeyPress={handleKeyPress}/&gt;.</span></pre><p id="ede6" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每当该函数识别出“enter”键被按下时，就会触发<strong class="kh ir">createnewdoitem</strong>函数，如下所示:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="da07" class="nh lu iq ng b gy oe of l og oh">handleKeyPress = (e) =&gt; {<br/>  if (e.key === ‘Enter’) {<br/>    createNewToDoItem();<br/>  }<br/>};</span></pre><h2 id="efe6" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">Vue:</h2><p id="97aa" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">在Vue中，这是非常直接的。我们简单地使用<strong class="kh ir"> @ </strong>符号，然后是我们想要做的事件监听器的类型。例如，要添加一个点击事件监听器，我们可以编写如下代码:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="d894" class="nh lu iq ng b gy oe of l og oh">&lt;button class=”ToDo-Add” @click=”createNewToDoItem()”&gt;+&lt;/div&gt;</span></pre><p id="ba86" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注:<strong class="kh ir"> @click </strong>其实就是简写<strong class="kh ir"> v-on:click </strong>。Vue事件侦听器最酷的一点是，您还可以将许多东西链接到它们上面，比如。once防止事件侦听器被触发多次。在编写处理击键的特定事件侦听器时，也有许多快捷方式。我发现，每当按下enter按钮时，在React中创建一个事件侦听器来创建新的ToDo项会花费相当长的时间。在Vue中，我可以简单地写下:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="d89a" class="nh lu iq ng b gy oe of l og oh">&lt;input type=”text” v-on:keyup.enter=”createNewToDoItem”/&gt;</span></pre><h2 id="9ab6" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">我们如何将数据传递给子组件？</h2><h2 id="87ef" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">反应:</h2><p id="1621" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">在react中，我们在创建子组件时将道具传递给子组件。比如:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="5948" class="nh lu iq ng b gy oe of l og oh">&lt;ToDoItem key={key.id} item={todo} /&gt;</span></pre><p id="83ad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里我们看到两个道具被传递给了<strong class="kh ir"> ToDoItem </strong>组件。从这一点开始，我们现在可以通过this.props在子组件中引用它们。</p><h2 id="4f02" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">Vue:</h2><p id="0f4f" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">在Vue中，我们在创建子组件时将道具传递给子组件。比如:</p><pre class="le lf lg lh gt oa ng ob oc aw od bi"><span id="be3a" class="nh lu iq ng b gy oe of l og oh">&lt;ToDoItem v-for="item in list" <br/>  :item="item" <br/>  @delete="onDeleteItem" <br/>  :key="item.id" /&gt;</span></pre><p id="5877" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完成后，我们将它们传递给子组件中的props数组，如下:<strong class="kh ir"> props: [ 'todo' ] </strong>。然后可以在孩子中通过它们的名字引用它们——所以在我们的例子中，是<strong class="kh ir">‘todo</strong>’。</p><h1 id="e778" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">我们如何将数据发送回父组件？</h1><h2 id="60a3" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">反应:</h2><p id="2a61" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">我们首先将函数传递给子组件，在调用子组件的地方将它作为一个道具进行引用。然后我们通过引用<strong class="kh ir">props . whateverthefunction被称为</strong>——或者<strong class="kh ir">whateverthefunction被称为</strong>(如果我们使用了析构的话),通过任何方式在子节点上添加函数调用，比如<strong class="kh ir"> onClick </strong>。这将触发父组件中的函数。我们可以在“如何从列表中删除”一节中看到整个过程的示例。</p><h2 id="c550" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">Vue:</h2><p id="016d" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">在我们的子组件中，我们只需编写一个函数，将值发送回父函数。在我们的父组件中，我们编写了一个函数来监听何时发出该值，然后触发一个函数调用。我们可以在<em class="lb">“如何从列表中删除”一节中看到整个过程的示例。</em></p><h1 id="8ae9" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">我们做到了！🎉</h1><p id="8ef6" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">我们已经了解了如何添加、删除和更改数据，如何以props的形式将数据从父节点传递到子节点，以及如何以事件侦听器的形式将数据从子节点发送到父节点。当然，React和Vue之间还有许多其他的小差异和怪癖，但是希望本文的内容有助于为理解这两个框架如何处理东西提供一点基础🤓。<strong class="kh ir">如果你喜欢读这篇文章，一定要留下一些掌声来表达你的爱——提示，你可以留下多达50个！</strong></p><p id="c8ed" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您对本文中使用的样式感兴趣，并想制作您自己的等效作品，请随时这样做！👍</p><h2 id="e13e" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">为什么不用Vue合成API？</h2><p id="37d2" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">实际上有这篇文章的更新版本使用它！<a class="ae lc" href="https://sunilsandhu.com/posts/i-created-the-exact-same-app-in-react-and-vue-2020-edition" rel="noopener ugc nofollow" target="_blank">最新版<strong class="kh ir">在此阅读</strong>T7】！但是在你点击链接之前，如果你喜欢这篇文章，请一定留下一些掌声，因为它们有助于支持我们正在做的工作。</a></p><h2 id="89f4" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">Github链接到两个应用程序:</h2><p id="6d74" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">https://github.com/sunil-sandhu/vue-todo-2019</p><p id="9b35" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">react ToDo:<a class="ae lc" href="https://github.com/sunil-sandhu/react-todo-2019" rel="noopener ugc nofollow" target="_blank">https://github.com/sunil-sandhu/react-todo-2019</a></p><h2 id="4800" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">我最近在伦敦网络表演上谈到了这篇文章</h2><p id="d840" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated">看这里的谈话！<a class="ae lc" href="https://www.youtube.com/watch?v=dnNF8szmxXg" rel="noopener ugc nofollow" target="_blank">https://www.youtube.com/watch?v=dnNF8szmxXg</a></p><h2 id="3da7" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">本文的2021版</h2><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-2021-edition-a7ebfc19a9d"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">我在React和Vue中创建了完全相同的应用程序。以下是不同之处。[2021版]</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">React vs Vue。Vue和React的并列代码对比！🎉</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ov l"><div class="ow l ox oy oz ov pa ln om"/></div></div></a></div><h2 id="cffd" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">本文的2020年版本</h2><div class="oj ok gp gr ol om"><a href="https://sunilsandhu.com/posts/i-created-the-exact-same-app-in-react-and-vue-2020-edition" rel="noopener  ugc nofollow" target="_blank"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">我在React和Vue中创建了完全相同的应用程序。以下是不同之处。[2020版]</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">几年前，我决定尝试在React和Vue中构建一个相当标准的Do App。这两个应用程序都是使用…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">sunilsandhu.com</p></div></div><div class="ov l"><div class="pb l ox oy oz ov pa ln om"/></div></div></a></div><h2 id="e333" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">本文的2018版</h2><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/i-created-the-exact-same-app-in-react-and-vue-here-are-the-differences-e9a1ae8077fd"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">我在React和Vue中创建了完全相同的应用程序。以下是不同之处。</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">React vs Vue。最后是Vue和React的并列代码对比！🎉</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ov l"><div class="pc l ox oy oz ov pa ln om"/></div></div></a></div><h2 id="25e1" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">好奇想知道同一个应用程序如何与React和Redux一起工作吗？点击下面的链接了解更多信息:</h2><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/i-created-the-exact-same-app-with-react-and-redux-here-are-the-differences-6d8d5fb98222"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">我在React和Redux中创建了完全相同的应用程序。以下是不同之处。</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">使用Redux的初学者指南以及React with Redux和……内置的确切应用程序的并行代码比较</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ov l"><div class="pd l ox oy oz ov pa ln om"/></div></div></a></div><h2 id="2c1c" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">你听说过苗条吗？嗯，我们也创建了同样的应用程序在苗条了！</h2><div class="oj ok gp gr ol om"><a rel="noopener  ugc nofollow" target="_blank" href="/i-created-the-exact-same-app-in-react-and-svelte-here-are-the-differences-c0bd2cc9b3f8"><div class="on ab fo"><div class="oo ab op cl cj oq"><h2 class="bd ir gy z fp or fr fs os fu fw ip bi translated">我在React和Svelte中创建了完全相同的应用程序。以下是不同之处。</h2><div class="ot l"><h3 class="bd b gy z fp or fr fs os fu fw dk translated">反应vs苗条。最后一个并列代码对比！因为你已经听过关于苗条的大惊小怪，现在你想要…</h3></div><div class="ou l"><p class="bd b dl z fp or fr fs os fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="ov l"><div class="pe l ox oy oz ov pa ln om"/></div></div></a></div><h2 id="6076" class="nh lu iq bd lv ni nj dn lz nk nl dp md ko nm nn mf ks no np mh kw nq nr mj ns bi translated">翻译</h2><p id="a4d7" class="pw-post-body-paragraph kf kg iq kh b ki mo jr kk kl mp ju kn ko mq kq kr ks mr ku kv kw ms ky kz la ij bi translated"><a class="ae lc" href="https://coliss.com/articles/build-websites/operation/javascript/same-app-in-react-and-vue-here-are-the-differences-2019-edition.html" rel="noopener ugc nofollow" target="_blank">日语</a></p><p id="c540" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae lc" href="https://www.vobour.com/%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%99%80-%EB%B7%B0%EC%97%90%EC%84%9C-%EB%98%91%EA%B0%99%EC%9D%80-%EC%95%B1%EC%9D%84-%EB%A7%8C%EB%93%A4%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4-%EC%97%AC%EA%B8%B0-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%B4-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4-2" rel="noopener ugc nofollow" target="_blank">韩语</a></p><p id="4471" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你想把这篇文章翻译成另一种语言，请继续这样做——当它完成时让我知道，以便我可以把它添加到上面的翻译列表中。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi pf"><img src="../Images/787be6c671be8d345dc786dad8729ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-sOyyG8NoRbKpCG_y4Cmw@2x.png"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk"><a class="ae lc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank">Click here to check out Decoded, our official YouTube channel!</a></figcaption></figure></div></div>    
</body>
</html>