<html>
<head>
<title>7 Node.js tools that make life easier + Real World Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让生活更简单的7个Node.js工具+真实世界的例子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/7-nodejs-tools-that-make-life-easier-real-world-examples-60a0ac35dd67?source=collection_archive---------0-----------------------#2020-12-10">https://javascript.plainenglish.io/7-nodejs-tools-that-make-life-easier-real-world-examples-60a0ac35dd67?source=collection_archive---------0-----------------------#2020-12-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/bd11fd62b2446279edd51e2ca1d9a835.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_i_nCqMpR3KpjX0OTAuEIw.png"/></div></div></figure><div class=""/><div class=""><h2 id="ecf7" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">加上现实世界的例子。你会很容易爱上这些网站工程。</h2></div><p id="a90b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">NodeJS。这对你意味着什么？它仅仅是一个后端工具吗？它仅仅是一个制作本地包的工具吗？或者你把它作为一个web服务器使用吗？或者它是创建可重用模块的完美工具吗？还是以上都有？？</p><p id="41bb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">不管你用它做什么——NodeJS毫无疑问是强大的。</p><p id="5d61" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">我们的目标是通过这7个有用且强大的web工程工具，让你的编码生活变得更加简单。老实说，从一开始，NodeJS核心模块中的一些东西就非常复杂，以至于我甚至不知道一些模块是做什么用的，也没有找到用例，它们只是低级工具到实用工具的工具。</p><p id="a68e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">尽管如此，这里我认为是最有用的——毕竟，我不想让你没有好的用例演示就挂掉！</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div class="gh gi lm"><img src="../Images/1e38221d449b50e914e33728c58283a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/0*W2AxQ-S57fQgVhUn.gif"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Lot’s of examples? YES!</figcaption></figure><h1 id="e53c" class="lv lw jb bd lx ly lz ma mb mc md me mf kh mg ki mh kk mi kl mj kn mk ko ml mm bi translated">1.网络服务器</h1><p id="ac29" class="pw-post-body-paragraph kq kr jb ks b kt mn kc kv kw mo kf ky kz mp lb lc ld mq lf lg lh mr lj lk ll ij bi translated">当作为服务器使用时，用于web应用程序开发的NodeJS可能是最有用的功能。用Node创建一个web服务器也非常简单——所以让我们看看如何做。</p><p id="babd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">1.1将下面的代码复制粘贴到您喜欢的代码编辑器中，保存为<strong class="ks jc"> index.js </strong>。请仔细阅读代码中的注释——用双正斜杠(//)标记。</p><figure class="ln lo lp lq gt is"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">nodeJSWebServer.js</figcaption></figure><p id="f859" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">1.2接下来，在VS代码或您打开的任何代码IDE中的终端窗口中，找到<strong class="ks jc"> index.js </strong>文件并运行:<strong class="ks jc">节点</strong> <strong class="ks jc"> index.js —注意</strong>在我的示例中，我的服务器文件被称为<strong class="ks jc"> nodeJSWebServer.js </strong>在上面和下面的示例中，它是<strong class="ks jc"> indexnde.js </strong> —这不是最佳实践，您必须确保您的文件都被称为<strong class="ks jc"> index.js </strong>和</p><p id="2b3d" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">以下是运行此命令的示例和结果:服务器运行在http://127.0.0.1.3000/</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mu"><img src="../Images/1b90452e3c5d17434dece06cca70c34e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I-pD8e2sjOOZwWMPM5UBJw.png"/></div></div></figure><p id="ec3a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">接下来打开您的浏览器，导航到我们指定的主机名和端口，即<a class="ae mv" href="http://127.0.0.1:3000" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:3000 </a>，您将看到您创建的服务器输出的结果如下。简单对吗？？</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mw"><img src="../Images/190d52bab957a123a1f0d24168ce1478.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DxqN3Mqa5l2Q7gA3Z6YXpA.png"/></div></div></figure><p id="41c1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">请记住，对于新手来说，我们在浏览器中看到的是HTTP响应，即HTTP进程给出了什么响应，即浏览器(<strong class="ks jc"> Hello World </strong>)而我们在终端控制台中看到的是服务器响应(服务器运行在<a class="ae mv" href="http://127.0.0.1.3000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1.3000/ </a>)。这是后端和前端或服务器端渲染的最基本和最好的例子。</p><p id="a8db" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这就是纯(几乎)NodeJS的web服务器。当然，我们可以向我们的服务器添加更多内容，并使用其他强大有用的工具，如Express web server来管理——不过，也许以后我们会这样做，这样我们就不会分散注意力。如果你想在自己的项目中使用Github repo，那么它就是https://github.com/gitmasoud/basicnodejsserver。</p><p id="8509" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你是一个视觉学习者，这是我为你制作的一个关于如何做的视频</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mx"><img src="../Images/8afb05da22d85ae749e561d9fd5bc36f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*vH0MwTiJLGOQ1uwsNEH_Yw.gif"/></div></div></figure><h2 id="8e87" class="my lw jb bd lx mz na dn mb nb nc dp mf kz nd ne mh ld nf ng mj lh nh ni ml nj bi translated">2.<strong class="ak">自定义Node.js模块和包—导出和导入</strong></h2><p id="6841" class="pw-post-body-paragraph kq kr jb ks b kt mn kc kv kw mo kf ky kz mp lb lc ld mq lf lg lh mr lj lk ll ij bi translated">让我们首先创建我们自己的本地包，然后创建一个NodeJS模块或一些人所说的包。</p><p id="3863" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了让它变得超级简单，我们将创建一个日期包——它的底层只是一个可重用的NodeJS模块，告诉我们今天的日期，并将其格式化为您当前的语言环境。</p><p id="d555" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">那么为什么要创建自己的模块呢？在软件工程和开发的世界里，独立的模块从早期就被创造出来了，这也是有原因的。</p><p id="e966" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">好处:</p><ul class=""><li id="8447" class="nk nl jb ks b kt ku kw kx kz nm ld nn lh no ll np nq nr ns bi translated">它们帮助你拥有独立的代码片段，很少或很少被关注</li><li id="8be0" class="nk nl jb ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns bi translated">更少的错误，因为更少的调试，因为更少的复杂性</li><li id="1808" class="nk nl jb ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns bi translated">此外，作为一个单元来测试模块个体的能力也是一个前期和后期的辅助——随着软件的增长，这是非常有益的</li><li id="cfe5" class="nk nl jb ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns bi translated">您可以在尽可能多的类和组件中导出和导入它们</li><li id="5b39" class="nk nl jb ks b kt nt kw nu kz nv ld nw lh nx ll np nq nr ns bi translated">你可以为开源运动做出贡献，让你部署在NPM上的模块被全世界使用</li></ul><p id="d341" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><strong class="ks jc">让我们创建我们的模块</strong></p><p id="6858" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">2.1创建一个新文件，将其命名为dateMod.js，并向其中添加以下代码，首先获取今天的日期，然后将其导出。仅此而已。只有两行代码。</p><figure class="ln lo lp lq gt is"><div class="bz fp l di"><div class="ms mt l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">dateMod.js</figcaption></figure><p id="9332" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">2.2我们如何使用它很简单——创建一个新的Nodejs文件，并将其命名为controller.js/your主节点文件(index.js ),添加此代码以导入并调用我们的模块的导出方法:</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="122d" class="my lw jb nz b gy od oe l of og">const getTodaysDate = require('./dateMod.js');<br/>console.log(`Todays date is is ${getTodaysDate}`);</span></pre><p id="29b3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">2.3打开终端或cmd窗口，然后像这样运行上面的文件:</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="e696" class="my lw jb nz b gy od oe l of og">node controller.js </span></pre><p id="2b57" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">或者在下面运行:</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="be96" class="my lw jb nz b gy od oe l of og">node index.js</span></pre><p id="9f3c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">2.4您将在控制台中看到输出:</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="1d0f" class="my lw jb nz b gy od oe l of og">Todays date is Sat Dec 05 2020 19:45:56 GMT+0000 (Greenwich Mean Time)</span></pre><p id="cf00" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Github的回购协议是<a class="ae mv" href="https://github.com/gitmasoud/dateMod" rel="noopener ugc nofollow" target="_blank">https://github.com/gitmasoud/dateMod</a></p><p id="f437" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是一个创建可恢复模块以及如何导出/导入节点模块的视频版本</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi mx"><img src="../Images/2e5f9134fe4a5776e41925a38f03cd4b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*pw9edy-DvfadPW68IVVbmQ.gif"/></div></div></figure><h2 id="bf2b" class="my lw jb bd lx mz na dn mb nb nc dp mf kz nd ne mh ld nf ng mj lh nh ni ml nj bi translated"><strong class="ak"> 3。发布NPM包</strong></h2><p id="fb5f" class="pw-post-body-paragraph kq kr jb ks b kt mn kc kv kw mo kf ky kz mp lb lc ld mq lf lg lh mr lj lk ll ij bi translated">让我们更进一步，把我们之前建立的东西发布到NPM，让全世界看到，并在他们自己的软件应用中使用我们的模块。一旦被推送到NPM，他们就可以通过在任何项目(例如</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="bb06" class="my lw jb nz b gy od oe l of og">npm i dateMod</span></pre><p id="153c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">3.1首先打开终端或VS代码，登录NPM——如果你还没有账户，请先在这里创建一个&gt;<a class="ae mv" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/</a></p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/aa19fb799f258dd86e72ee79e28624d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1264/format:webp/1*KCru0rId3FkHxpykKvYpTA.png"/></div></figure><p id="16ac" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">3.2在同一个内直接为包/模块创建一个新的—这样做更好，这样更简洁，也更准确。</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="75dd" class="my lw jb nz b gy od oe l of og">md livePublishedFolder</span></pre><p id="bd2e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">3.3进入新文件夹:</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="c2b0" class="my lw jb nz b gy od oe l of og">cd livePublishedFolder</span></pre><p id="6006" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">3.4运行npm init来初始化新项目和package.json文件创建</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="e597" class="my lw jb nz b gy od oe l of og">npm init</span></pre><p id="17be" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">遵循所有的步骤</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oi"><img src="../Images/6acb121b64bc71dcf77319fa47dc4868.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qyI2WJQAMUG2JNcHWv1jiQ.png"/></div></div></figure><p id="d290" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">3.5然后在这个目录下添加我们之前创建的模块文件— <strong class="ks jc"> dateMod.js — </strong>你可以把文件复制粘贴进去。你可以进一步修改它，即使你想添加更多的功能或在新的文件中添加新的模块。</p><p id="e284" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">3.6然后运行<strong class="ks jc"> npm publish </strong>，一旦完成，你将会看到你已经上传到npmjs.com的包的版本号。以下显示为<strong class="ks jc"> npm通知版本:1.0.0 </strong></p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oj"><img src="../Images/2c2fecba38a3fdae245619bdb2adecb8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6LPTsGq6krqJjSuEyqlGwg.png"/></div></div></figure><p id="1635" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果您现在等待大约1-10分钟并刷新您的npmjs.com个人资料，您将会看到我们在packages下发布的新模块！</p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ok"><img src="../Images/ea9586cc334115bdb9655682d27dd50e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TCoqHj_zIPAC99whJlmCFg.png"/></div></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Our new module now available as an npm package from NPMJS.com. Anyone worldwide can use it now</figcaption></figure><p id="f6d6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上面的源代码在下面，如何进行端到端的NPM发布在下面的视频中——请注意上面我的文件夹和包名是<strong class="ks jc"> livePublishedFolder </strong>,但是在我下面的视频中这个包名为<strong class="ks jc"> dateMod </strong>,在这里找到<strong class="ks jc"/><a class="ae mv" href="https://www.npmjs.com/package/datemod" rel="noopener ugc nofollow" target="_blank">https://www.npmjs.com/package/datemod</a></p><figure class="ln lo lp lq gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ol"><img src="../Images/192f04eb8d1a0755978606c5c16a566e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*G7BbGdDj5xdzoC0-OHs2Bg.gif"/></div></div></figure><h2 id="a41c" class="my lw jb bd lx mz na dn mb nb nc dp mf kz nd ne mh ld nf ng mj lh nh ni ml nj bi translated">4.<strong class="ak">核心Node.js模块—文档</strong></h2><p id="20d4" class="pw-post-body-paragraph kq kr jb ks b kt mn kc kv kw mo kf ky kz mp lb lc ld mq lf lg lh mr lj lk ll ij bi translated">这是文档中一些非常有用的模块。在我看来，这些可能也是最常用的。我不会在这里给出演示，因为文档中有很好的演示，例如文件系统或查询字符串。但是对于大多数有经验的开发人员来说，这里也没有问题。</p><p id="3f9f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">流——读写数据流<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/stream.htm" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/stream.htm</a>l这里有一个关于如何使用流的视频</p><p id="d09a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">查询字符串—使用URL查询字符串<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/querystring.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/querystring.html</a></p><p id="cb3f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">流程—与所有运行流程的节点深入合作—<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/process.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/process.html</a></p><p id="80af" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">路径和文件-使用路径和文件-<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/path.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/path.html</a></p><p id="f5bd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">操作系统——用这个来查询CPU或内存之类的东西—<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/os.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/os.html</a></p><p id="5e02" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Net —网络方法—<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/net.html#net_socket_connect" rel="noopener ugc nofollow" target="_blank">https://nodejs . org/docs/latest-v 12 . x/API/net . html # net _ socket _ connect</a>—也可以处理服务器事件和套接字。异步网络API，用于创建基于流的TCP或<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/net.html#net_ipc_support" rel="noopener ugc nofollow" target="_blank"> IPC </a>服务器(<code class="fe om on oo nz b"><a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/net.html#net_net_createserver_options_connectionlistener" rel="noopener ugc nofollow" target="_blank">net.createServer()</a></code>)和客户端(<code class="fe om on oo nz b"><a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/net.html#net_net_createconnection" rel="noopener ugc nofollow" target="_blank">net.createConnection()</a></code>)。</p><p id="b65a" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">Package.json修改—通过添加高级特性来创建和扩展您的Package.json文件—<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/packages.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/packages.html</a></p><p id="4fc3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">模块—使用模块的实例—<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/module.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/module.html</a></p><p id="878b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用ES6约定的JS模块—<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/esm.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/esm.html</a></p><p id="1b9f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用标准模块API创建模块—<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/modules.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/modules.html</a></p><p id="979c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">文件系统—广泛处理文件，从读取到上传，再到流式传输和下载文件—<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/fs.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/fs.html</a></p><p id="d462" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">DNS —查找IP和主机名—<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/dns.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/dns.html</a></p><p id="eb02" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">进程外调试—<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/debugger.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/debugger.html</a>—通过<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/debugger.html#debugger_v8_inspector_integration_for_node_js" rel="noopener ugc nofollow" target="_blank"> V8检查器</a>和内置调试客户端访问的进程外调试实用程序</p><p id="ac20" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">压缩文件和流—<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/zlib.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/zlib.html</a></p><p id="b2a6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">子流程—处理正在运行的节点流程的子流程—<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/child_process.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/child_process.html</a></p><p id="5ee0" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">VM —将您的代码作为VM运行—<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/vm.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/vm.html</a>—对于创建抽象和虚拟化代码非常有用，就像它在其他机器上运行一样。</p><p id="77f8" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用核心V8引擎——尝试一些很酷的方法，如堆数据和V8版本等。—<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/v8.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/v8.html</a>—<code class="fe om on oo nz b">v8</code>模块公开了特定于内置于Node.js二进制文件中的<a class="ae mv" href="https://developers.google.com/v8/" rel="noopener ugc nofollow" target="_blank"> V8 </a>版本的API</p><p id="eddd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/url.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/url.html</a>—使用密码、查询字符串、在URL中搜索、获取和设置用户名等。还有更多。</p><h2 id="04c6" class="my lw jb bd lx mz na dn mb nb nc dp mf kz nd ne mh ld nf ng mj lh nh ni ml nj bi translated">5.<strong class="ak">微服务&amp;无服务器功能</strong></h2><p id="7232" class="pw-post-body-paragraph kq kr jb ks b kt mn kc kv kw mo kf ky kz mp lb lc ld mq lf lg lh mr lj lk ll ij bi translated">参赛人员:<a class="ae mv" href="https://expressjs.com/en/guide/using-template-engines.html" rel="noopener ugc nofollow" target="_blank">https://expressjs.com/en/guide/using-template-engines.html</a>，<a class="ae mv" href="https://expressjs.com/en/guide/routing.html" rel="noopener ugc nofollow" target="_blank">https://expressjs.com/en/guide/routing.html</a></p><p id="db66" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">在NodeJS模块之外，没有什么比使用Express和创建无服务器应用和微服务更让我兴奋的了。</p><p id="3c08" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">5.1这里有一个完整的例子:</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="d282" class="my lw jb nz b gy od oe l of og">var express = require('express');<br/>var app = express();<br/><br/>// respond with "hello world" when a GET request is made to the //homepage<br/>app.get('/', function (req, res) {<br/>  res.send('hello world')<br/>})</span></pre><p id="9071" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">如果你愿意，你也可以直接从NodejS服务器和/或Jada或Pug等引擎提供动态前端页面。这对于网页(或任何其他客户端)和服务器之间的两次通信非常有用。</p><p id="1e65" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">5.2这里有一个例子:</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="42c3" class="my lw jb nz b gy od oe l of og">var express = require('express');<br/>var app = express();</span><span id="20be" class="my lw jb nz b gy op oe l of og">//set pug as a View engine to output html<br/>app.set('view engine', 'pug')<br/>//set route and data to be injected into the view<br/>app.get('/', function (req, res) {<br/>  res.render('index', { title: 'Hey', message: 'Hello there!' })<br/>})</span></pre><p id="0719" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">你说我这里的<strong class="ks jc">微服务</strong>怎么样？？不用担心，这里有一个使用GCP Firebase创建干净快速的微服务的例子。一旦你完成了<a class="ae mv" href="http://how to setup microservices with firebase functions" rel="noopener ugc nofollow" target="_blank">的安装</a>，你就可以使用Firebase的函数库在10分钟内创建、部署和调用微服务。你不相信我？点击这里查看我的视频<a class="ae mv" href="https://youtu.be/Mey1dnkJVpE" rel="noopener ugc nofollow" target="_blank"/></p><p id="0ff3" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">5.3下面这段代码创建了一个微服务，并在index.js文件中仅定义了一个名为helloWorld的微服务:</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="9c4e" class="my lw jb nz b gy od oe l of og">exports.helloWorld = functions.https.onRequest((req, res) =&gt; {<br/>  // Grab the a text parameter.<br/>  const qParam = req.query.text;<br/>  <br/>  // Send back a message and send back what was requested<br/>  res.send('Hello world your parameter was: ${qParam} '});<br/>});</span></pre><p id="5fa7" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">只需记住在Firebase函数中——每个函数都是一个微服务或端点(对于遗留开发人员；-) ).</p><h2 id="1fec" class="my lw jb bd lx mz na dn mb nb nc dp mf kz nd ne mh ld nf ng mj lh nh ni ml nj bi translated">6.<strong class="ak"> Utils模块</strong></h2><p id="b2e1" class="pw-post-body-paragraph kq kr jb ks b kt mn kc kv kw mo kf ky kz mp lb lc ld mq lf lg lh mr lj lk ll ij bi translated">参考:<a class="ae mv" href="https://nodejs.org/docs/latest-v12.x/api/util.html" rel="noopener ugc nofollow" target="_blank">https://nodejs.org/docs/latest-v12.x/api/util.html</a></p><p id="1fd6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">顾名思义，这个模块也为模块和应用开发者提供了实用功能。它非常强大。让我们看看它提供的一些功能:</p><p id="68a2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">6.1 util.callbackify()</p><p id="8a35" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe om on oo nz b"><strong class="ks jc">util.callbackify(original)</strong> — adds callbacks to Async or Promise methods. This is useful because it forces responses from the methods and a nice callback is returned. Heres how to add a callback to the fn function and once resolved return the value that it returns i.e. hello world</code></p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="8995" class="my lw jb nz b gy od oe l of og">const util = require('util');<br/><br/>async function fn() {<br/>  return 'hello world';<br/>}<br/>const callbackFunction = util.callbackify(fn);<br/><br/>callbackFunction((err, ret) =&gt; {<br/>  if (err) throw err;<br/>  console.log(ret);<br/>});</span></pre><p id="7ecc" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">6.2 util.deprecate()</p><blockquote class="oq or os"><p id="93d5" class="kq kr ot ks b kt ku kc kv kw kx kf ky ou la lb lc ov le lf lg ow li lj lk ll ij bi translated"><code class="fe om on oo nz b"><strong class="ks jc"><em class="jb">util.deprecate(fn, msg[, code])</em></strong><em class="jb">- Ever wanted to deprecate some of you deep functions? Use this for a clean way to do it as it outputs messages for you too. I never heard of this function before but seems really cool and will useful for large projects. See the exmaple below:</em></code></p></blockquote><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="f254" class="my lw jb nz b gy od oe l of og">const util = require('util');</span><span id="3a87" class="my lw jb nz b gy op oe l of og">exports.obsoleteFunction = util.deprecate(() =&gt; {<br/>  // Do something here.<br/>}, 'obsoleteFunction() is deprecated. Use newShinyFunction() instead.');</span></pre><p id="f17f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">请务必在此查看NodeJS已弃用api的完整列表<a class="ae mv" href="https://nodejs.org/api/deprecations.html#deprecations_list_of_deprecated_apis" rel="noopener ugc nofollow" target="_blank">https://NodeJS . org/API/depreciations . html # depreciations _ list _ of _ depreciated _ API</a></p><p id="26f4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">6.3 util.format()</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="db9e" class="my lw jb nz b gy od oe l of og"><strong class="nz jc">util.format(format[, ...args]) - </strong>m<!-- -->ethod returns a formatted string using the first argument. There's many format specifiers to choose from.</span></pre><p id="af32" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这里有一个如何使用它的例子:</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="f798" class="my lw jb nz b gy od oe l of og">util.formatWithOptions({ colors: true }, 'See object %O', { foo: 42 });<br/>// Returns 'See object { foo: 42 }', where `42` is colored as a number<br/>// when printed to a terminal.</span></pre><p id="6d60" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">更多格式化选项，如CSS或JSON，请参阅完整文档。</p><p id="7a99" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">6.4 util.getSystemErrorName()</p><p id="90a6" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe om on oo nz b"><strong class="ks jc">util.getSystemErrorName(err)</strong>- Return system errors that come from NodeJS API fs.access('file/that/does/not/exist', (err) =&gt; {<br/> const name = util.getSystemErrorName(err.errno);<br/> console.error(name); // ENOENT<br/>});</code></p><p id="fa3b" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">上面是一个试图访问一个不存在的文件的方法。你可以通过管道将错误返回到getSystemErrorName，以便它输出一个错误号，然后在控制台窗口中显示它。</p><p id="6292" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">6.5 util.inspect()</p><p id="bd7f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe om on oo nz b"><strong class="ks jc">util.inspect(object[, options])- </strong></code>检查字符串格式的对象。小心这一点，因为您知道在运行时事情会发生变化。这里有一些如何使用它的例子。你可以看到我们有4个例子。首先，我们有一个名为Foo的类，它获得一个数组类型字符串标签，并注入一个字符串“bar ”,因此通过使用这个方法，我们可以快速检查并获得这个<strong class="ks jc"> Foo [bar] {} </strong>的结果，我们知道一个类定义是否有一个数组字符串。接下来，我们有一个名为Bar的空类，并这样定义'<strong class="ks jc">类Bar {} </strong>'，由于保留的关键字类总是被忽略，所以使用相同的Inspect方法返回<strong class="ks jc"> Bar {} </strong>。我们有一个对象，它有一个使用object类创建对象的定义，当检查时，打印出它是一个null对象，即没有值，我们将一个值传递到数组的查找位置。这是这样打印的<strong class="ks jc">[Object:null prototype][foo]{ }</strong></p><p id="191f" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">6.6 util。IsDeepStrictEqual()</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="dfb2" class="my lw jb nz b gy od oe l of og">class Foo {<br/> get [Symbol.toStringTag]() {<br/> return ‘bar’;<br/> }<br/>}<br/>class Bar {}<br/>const baz = Object.create(null, { [Symbol.toStringTag]: { value: ‘foo’ } });<br/>const workers = { a: 1, b: 2, c: 3};</span><span id="c04f" class="my lw jb nz b gy op oe l of og">console.log(util.inspect(new Foo())); // ‘Foo [bar] {}’<br/>console.log(util.inspect(new Bar())); // ‘Bar {}’<br/>console.log(util.inspect(baz)); // ‘[foo] {}’<br/>console.log(util.inspect(workers));</span><span id="f9d5" class="my lw jb nz b gy op oe l of og"><strong class="nz jc">util.isDeepStrictEqual(val1, val2)</strong> — If deep strict equality exists return true. This doesn’t check just high level values and types but deep too e.g. the object and all its properties, all those properties’ properties and so on etc. etc. Heres an example:</span><span id="8674" class="my lw jb nz b gy op oe l of og">const util = require('util');<br/>const isdeepequal = util.isDeepStrictEqual;<br/>console.log('deep equal is: '+isdeepequal(1,2)); //&lt; change this 1,1 and result will be true</span></pre><p id="eedd" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">6.7效用承诺</p><p id="1901" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><code class="fe om on oo nz b"><strong class="ks jc">util.promisify(original)</strong> — return a version of a callback that returns a promise</code></p><p id="e91e" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下面是我们如何检查文件细节，并以错误优先的回调方式接收这些信息，以及接收返回承诺的版本。在我们的例子中，我们使用非常有用的fs。Stats方法，返回整个stats对象以及文件创建时间(stats.birthtimeMs):</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="6236" class="my lw jb nz b gy od oe l of og">const util = require('util');<br/>const fs = require('fs');<br/><br/>const stat = util.promisify(fs.stat);<br/>stat('.').then((stats) =&gt; {<br/>  // Do something with `stats`<br/>  console.log(stats);<br/>  //read created time<br/>  console.log('this file was create at this time: ' +stats.birthtimeMs);<br/>}).catch((error) =&gt; {<br/>  // Handle the error.<br/>});</span></pre><p id="02d1" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">其他有用的方法包括编码/解码，检查类型是数组还是整型还是日期类型等等。等等。除此之外，您还会了解到——实用程序应该是您编码工具箱的一部分。</p><h2 id="c9d9" class="my lw jb bd lx mz na dn mb nb nc dp mf kz nd ne mh ld nf ng mj lh nh ni ml nj bi translated">7.<strong class="ak"> Worker_threads </strong></h2><p id="7e65" class="pw-post-body-paragraph kq kr jb ks b kt mn kc kv kw mo kf ky kz mp lb lc ld mq lf lg lh mr lj lk ll ij bi translated">这使得可以使用并行执行JavaScript的线程，并执行CPU密集型的JS调用。一个很好的例子是大型数据工作者列表可以极大地提高数据获取和处理的性能。请记住，工作线程只是主线程和一个web工作线程之间的通信，但是不能有多个web工作线程。因此说你只能使用端口1和端口2。所以不适合创建聊天室场景。</p><p id="d844" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这是可行的:</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="597f" class="my lw jb nz b gy od oe l of og">const { port1, port2} = new MessageChannel();<br/>port1.postMessage({ hello: 'world' });</span><span id="c23b" class="my lw jb nz b gy op oe l of og">console.log(receiveMessageOnPort(port2));<br/>// Prints: { message: { hello: 'world' } }</span></pre><p id="2aa4" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">但这并不:</p><pre class="ln lo lp lq gt ny nz oa ob aw oc bi"><span id="d23a" class="my lw jb nz b gy od oe l of og">const { port1, port2, port3 } = new MessageChannel();<br/>port1.postMessage({ hello: 'world' });<br/>port2.postMessage({ hellos: 'worlds' });</span><span id="2c7e" class="my lw jb nz b gy op oe l of og">console.log(receiveMessageOnPort(port3));<br/>// Prints: { message: { hello: 'world' } }</span></pre><div class="ip iq gp gr ir ox"><a href="https://nodejs.org/docs/latest-v12.x/api/worker_threads.html" rel="noopener  ugc nofollow" target="_blank"><div class="oy ab fo"><div class="oz ab pa cl cj pb"><h2 class="bd jc gy z fp pc fr fs pd fu fw ja bi translated">Node.js v15.3.0文档</h2><div class="pe l"><h3 class="bd b gy z fp pc fr fs pd fu fw dk translated">源代码:lib/worker _ threads . js worker _ threads模块支持在…中使用执行JavaScript的线程</h3></div><div class="pf l"><p class="bd b dl z fp pc fr fs pd fu fw dk translated">nodejs.org</p></div></div></div></a></div><p id="92bb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">希望你喜欢这篇文章，请务必与所有感兴趣的人分享，并在这里关注我。</p></div><div class="ab cl pg ph hu pi" role="separator"><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl pm"/><span class="pj bw bk pk pl"/></div><div class="ij ik il im in"><h2 id="8c3a" class="my lw jb bd lx mz na dn mb nb nc dp mf kz nd ne mh ld nf ng mj lh nh ni ml nj bi translated">学生</h2><p id="53c3" class="pw-post-body-paragraph kq kr jb ks b kt mn kc kv kw mo kf ky kz mp lb lc ld mq lf lg lh mr lj lk ll ij bi translated">如果你目前<a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/part-1-how-to-break-into-software-development-the-ultimate-guide-for-university-and-college-358cc17b2cd5">在学院或大学学习，并且想从事编码和软件开发</a>，那么在这里 阅读我的下一篇文章<a class="ae mv" rel="noopener ugc nofollow" target="_blank" href="/part-1-how-to-break-into-software-development-the-ultimate-guide-for-university-and-college-358cc17b2cd5">。</a></p></div></div>    
</body>
</html>