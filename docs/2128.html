<html>
<head>
<title>Recursion Patterns in JS, the Functional way</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JS中的递归模式，函数方式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/recursive-patterns-in-js-the-functional-way-2410d004112e?source=collection_archive---------3-----------------------#2020-05-22">https://javascript.plainenglish.io/recursive-patterns-in-js-the-functional-way-2410d004112e?source=collection_archive---------3-----------------------#2020-05-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/0625dce63787732754fcf2edbe95518d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbU_Fl4QYAkZKm7xjpq8gg.png"/></div></div></figure><div class=""/><p id="76de" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这是一篇关于数组数据结构的函数递归的文章。</p><p id="d4e0" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这篇文章的灵感来自于文章<a class="ae kt" href="https://medium.com/dailyjs/functional-js-with-es6-recursive-patterns-b7d0813ef9e3" rel="noopener">“使用ES6的函数式JS—递归模式</a>”但是这里我们要走一条更深刻的路，并且必须这样做，列表的代数定义是<code class="fe ku kv kw kx b">List = 1+a*List</code></p><blockquote class="ky kz la"><p id="9fd4" class="jv jw lb jx b jy jz ka kb kc kd ke kf lc kh ki kj ld kl km kn le kp kq kr ks ig bi translated">这表示该列表或者是空列表<strong class="jx iz"> [] </strong>或者是元素<strong class="jx iz"> a </strong>和一个较小列表的串联。</p></blockquote><h1 id="d964" class="lf lg iy bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">模式匹配</h1><p id="17af" class="pw-post-body-paragraph jv jw iy jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated">首先，我们可以编写下面的patternMatch方法，它允许我们分离列表的不同部分</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="3c65" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">模式对象是这样的:</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><ol class=""><li id="2c29" class="mo mp iy jx b jy jz kc kd kg mq kk mr ko ms ks mt mu mv mw bi translated">其中在<code class="fe ku kv kw kx b"> pattern.concat(head, tail)</code>方法中，<code class="fe ku kv kw kx b">head</code>是数组的第一个值，如果数组不为空，<code class="fe ku kv kw kx b">tail</code>是数组的其余部分。</li><li id="1354" class="mo mp iy jx b jy mx kc my kg mz kk na ko nb ks mt mu mv mw bi translated">如果其为空，则调用<code class="fe ku kv kw kx b">pattern.empty() </code>。</li></ol><p id="e878" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">定义模式匹配后，我们可以立即定义一些概念，例如数组的第一个元素:</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="db74" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者类似地，数组的尾部:</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="nc mn l"/></div></figure><p id="322e" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">___________________________________</p><h1 id="f8bd" class="lf lg iy bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">功能褶皱</h1><p id="8cb0" class="pw-post-body-paragraph jv jw iy jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated">现在我要定义一个简单但容易混淆的方法。下面的方法在数组上定义了一个catamorphism，或者更常见的名称fold(我将保留名称cata，但是您可以将其命名为Fold)。</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="e71b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">[参数评估通常称为代数。]</p><p id="6937" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里的关键点是:</p><pre class="mi mj mk ml gt nd kx ne nf aw ng bi"><span id="fc96" class="nh lg iy kx b gy ni nj l nk nl">concat: (head, tail) =&gt; evaluation.concat(head, <strong class="kx iz">tail.cata(evaluation)</strong>)</span></pre><p id="5a9b" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们递归地通过评估来评估数组<code class="fe ku kv kw kx b"><strong class="jx iz">tail.cata(evaluation)</strong></code>的<strong class="jx iz">尾部</strong></p><p id="13d4" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="lb">注意:如果对你有帮助的话，你可以将方法重命名为evaluation，这对面向对象的程序员来说可能更有意义:</em></p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="444a" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><a class="ae kt" href="https://en.wikipedia.org/wiki/Catamorphism" rel="noopener ugc nofollow" target="_blank"><strong class="jx iz">Catamorhism/Fold</strong></a><strong class="jx iz">是将一个数组分解成某种其他类型的最通用方式</strong>。<code class="fe ku kv kw kx b">evaluation </code>参数与我们在模式匹配中使用的<code class="fe ku kv kw kx b">pattern </code>具有(几乎)相同的方法:</p><pre class="mi mj mk ml gt nd kx ne nf aw ng bi"><span id="e0f1" class="nh lg iy kx b gy ni nj l nk nl">evaluation= { <br/>  empty: () =&gt; {...},<br/>  concat: (headEval, tailEval) =&gt; {...}<br/>}</span></pre><p id="24ca" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们使用<code class="fe ku kv kw kx b">cata</code>函数来定义数组的长度。</p><h1 id="e36d" class="lf lg iy bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">长度</h1><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="nc mn l"/></div></figure><p id="0294" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为什么会这样？不幸的是，JavaScript没有类型，所以您看不到类型是什么。但是在这个长度代数中，你可能认为一切都是整数:</p><pre class="mi mj mk ml gt nd kx ne nf aw ng bi"><span id="21e6" class="nh lg iy kx b gy ni nj l nk nl">{                               <br/>  empty: () =&gt; 0,                  <br/> concat: (v, r) =&gt; 1 + r          <br/>}</span></pre><blockquote class="ky kz la"><p id="7065" class="jv jw lb jx b jy jz ka kb kc kd ke kf lc kh ki kj ld kl km kn le kp kq kr ks ig bi translated"><strong class="jx iz">我们希望空数组为0，如果它不为空，则加上头部的长度1和其余部分的长度</strong> <code class="fe ku kv kw kx b"><strong class="jx iz">r</strong></code></p></blockquote><p id="437d" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们当然可以不用<code class="fe ku kv kw kx b">cata()</code>而简单地通过模式匹配和递归来实现:</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="nc mn l"/></div></figure><blockquote class="ky kz la"><p id="55cf" class="jv jw lb jx b jy jz ka kb kc kd ke kf lc kh ki kj ld kl km kn le kp kq kr ks ig bi translated"><strong class="jx iz">在某种程度上，我们排除了</strong> <code class="fe ku kv kw kx b"><strong class="jx iz">cata()</strong></code> <strong class="jx iz">方法中的递归。我们可以不用递归来编写定义</strong></p></blockquote><p id="3c37" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们看更多的例子。用于反转阵列</p><h1 id="251b" class="lf lg iy bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">反面的</h1><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="0417" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里我们使用了一个代数来交换第一个值(v)的一部分和数组的其余部分(…r)。</p><h1 id="6eeb" class="lf lg iy bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">过滤器</h1><p id="bdc7" class="pw-post-body-paragraph jv jw iy jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated">我们在这里使用的代数检查列表的头部。如果值不满足过滤器，我们只保留数组的其余部分。</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="nc mn l"/></div></figure><h1 id="0b4a" class="lf lg iy bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">地图</h1><p id="99d1" class="pw-post-body-paragraph jv jw iy jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated">该地图非常默认:</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><h1 id="2efd" class="lf lg iy bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">减少</h1><p id="bccf" class="pw-post-body-paragraph jv jw iy jx b jy md ka kb kc me ke kf kg mf ki kj kk mg km kn ko mh kq kr ks ig bi translated">最后，Reduce是大多数人使用的最接近catamorhism定义的词。(这和<code class="fe ku kv kw kx b">cata</code>一样，只是做了一些重命名和重新安排，我在这里就不做了)。</p><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="mm mn l"/></div></figure><figure class="mi mj mk ml gt ip"><div class="bz fp l di"><div class="nc mn l"/></div></figure><p id="50ba" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx iz">结论</strong>:变形是将一个数组转换成其他类型的最通用的方法。因为潜在的想法可能会让开发人员感到困惑，所以我们使用等价的reduce数组方法。我们可以在像树这样的其他数据结构上使用分类。</p><p id="fd8f" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi">___________________________________</p><p id="f680" class="pw-post-body-paragraph jv jw iy jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你想搜索更多你可以定义cata上的树结构在这篇文章中<a class="ae kt" href="https://medium.com/javascript-in-plain-english/how-to-reverse-a-tree-in-javascript-the-functional-way-440d7106b277" rel="noopener">如何用JavaScript反转一棵树的函数方式</a></p></div></div>    
</body>
</html>