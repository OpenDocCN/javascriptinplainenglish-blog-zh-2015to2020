<html>
<head>
<title>A Simple Explanation of JavaScript Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript类的简单解释</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-simple-explanation-of-javascript-classes-985712a11931?source=collection_archive---------9-----------------------#2020-10-25">https://javascript.plainenglish.io/a-simple-explanation-of-javascript-classes-985712a11931?source=collection_archive---------9-----------------------#2020-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0e74a776ed8011c44b2934fefe999721.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AAA6_tv6koehSqlNurphYg.jpeg"/></div></div></figure><p id="2be4" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以将JavaScript类想象成包含变量和函数房子。我们使用变量存储数字的原因和我们使用类存储函数的原因是一样的；我们希望能够创建一种模式，允许我们以有效的方式重用信息。</p><p id="3cf6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是类是特殊的，因为它们就像一个蓝图，供其他人使用和构建很酷的东西。例如，我可以开设一个名为战士的课程。</p><p id="52f9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我可以通过编写以下代码来“实例化”或创建该类的对象:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="0e4d" class="lf lg iq lb b gy lh li l lj lk">let bruceLee = Warrior.create(“Bruce Lee”);<br/>bruceLee.kick();</span><span id="2905" class="lf lg iq lb b gy ll li l lj lk">// Don’t worry. We’ll get to how to make a class after this quick example.</span></pre><p id="430e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">可以把一个实例化的对象想象成一种产品，比如从传送带上喷出来的可乐。每个对象都有通常的基本属性，如高度和宽度。但是有些东西可能是独特的，比如可乐的味道。</p><p id="0a77" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用Warrior类，我可以创建一个全新的对象，而不必重写kick函数，因为它已经在一个类中定义了。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="28e4" class="lf lg iq lb b gy lh li l lj lk">let chuckNorris = Warrior.create(“Chuck Norris”);<br/>chuckNorris.kick();<br/><br/></span></pre><p id="74bb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们首先如何创建一个类呢？在JavaScript中有几种创建类的方法。我们可以把它们分为旧方法和新方法。一些纯粹主义者更喜欢老方法，但我们会通过那座桥，当我们到达那里。</p><p id="3859" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在JavaScript中创建类最流行的方法是使用function关键字，后跟一个大写的函数名:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8c33" class="lf lg iq lb b gy lh li l lj lk"><br/>function Warrior(){<br/>}</span></pre><p id="5bdc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是我们也可以通过使用对象文字来创建一个类:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="b093" class="lf lg iq lb b gy lh li l lj lk"><br/>let Warrior = new Class({<br/>});<br/></span></pre><p id="04ac" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">或者我们可以通过使用自调用函数来创建一个类:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="d69c" class="lf lg iq lb b gy lh li l lj lk">let Warrior = (function(){<br/>})()</span></pre><p id="e000" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在JavaScript中构建类的新方法是像其他语言一样使用class关键字:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="c480" class="lf lg iq lb b gy lh li l lj lk"><br/>class Warrior{<br/> constructor(){<br/> }<br/>}</span></pre><p id="25c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无论您选择如何创建一个类，类的组件通常都是相同的。对于本教程，我们将使用第一种方法，但是我将向您展示如何使用新的“class”方法来做同样的事情。</p><p id="f836" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">当构建一个类时，你首先要考虑的是这个类的基本特征应该是什么样的。比如你想做一个健身app，你想大概知道用户的姓名，年龄，身高，体重。我们创建的每个新对象(或用户)都应该有这些描述。</p><p id="a0ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将这些信息放在我们称之为构造函数的地方:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="115c" class="lf lg iq lb b gy lh li l lj lk">function User(){<br/>//constructor<br/> this.name;<br/> this.height;<br/> this.age;<br/> this.weight;<br/>}<br/><br/></span></pre><p id="fa07" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:我们使用“this”关键字，因为当创建一个新的用户对象时，我们希望获得实例化对象的值，而不是类本身。</p><p id="99f6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们更进一步，允许某人通过向类添加一个参数来给类赋值:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="6d86" class="lf lg iq lb b gy lh li l lj lk">function User(object){<br/>//constructor<br/> this.name = object.name;<br/> this.height = object.height;<br/> this.age = object.age;<br/> this.weight = object.weight;<br/>}</span></pre><p id="378b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种类型的类构建是一种很好的实践，因为它允许任何调用类的人能够像build-a-bear一样构建他们的对象，而不必担心破坏任何东西或以特定的顺序排列任何东西。例如:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="c716" class="lf lg iq lb b gy lh li l lj lk"><br/>let bob = User({ height:”7'2", age: 30, name:”Mike”, weight: “200 Ibs”})<br/><br/></span></pre><p id="8de8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">假设这个类是完整的，即使它是无序的，这也是可行的，因为我们可以从对象字面量进行调用。</p><p id="6b35" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">请注意，上面的代码无法正常工作，因为我们还没有讨论JavaScript类的下一个方面。</p><h2 id="076c" class="lf lg iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">私人与公共</h2><p id="d1f6" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">类中的数据被组织成私有和公共数据。有些东西是你不希望外人在类内访问的，所以你把它们保持为私有。例如，这可能是一个计算人的身体质量指数的算法。这应该永远保持不变，所以你不想让人们改变它。但是我们确实希望能够改变名称或重量，不是吗？所以数据应该公开。</p><p id="3b31" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面是我们如何在JavaScript中将公共数据与私有数据分开。注意，经典类构造中没有关键字。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="f1e3" class="lf lg iq lb b gy lh li l lj lk"><br/>function User(construct){<br/>//constructor<br/> this.name = construct.name; <br/> this.height = construct.height;<br/> this.age = construct.age;<br/> this.weight = construct.weight;<br/>//private<br/> let bmiMultiple = 703;<br/> let bmi = ()=&gt;{<br/> return (this.weight / (this.height * this.height)) * bmiMultiple;<br/> }<br/>//public<br/> return {<br/> name,<br/> height,<br/> age,<br/> weight,<br/> bmi<br/> }<br/>}<br/></span></pre><p id="7bcb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们试图访问bmiMultiple变量，我们将无法这样做。请注意，由“this”关键字前置的变量是自动“可获取”和“可设置”的。这就是构造函数的要点——允许某人通过设置值立即构建一个对象。</p><p id="534d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">注意</strong>:我在return语句中列出变量，没有像纯ES5中那样添加冒号和值，这是作弊。ES6允许这种简写。请随意混合新旧</p><p id="ec51" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦你实例化了你的类…</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="6c73" class="lf lg iq lb b gy lh li l lj lk"><br/>let bob = User({ height:72, age: 30, name:”Mike”, weight: 200}) // 72 is in inches and 200 is in pounds<br/></span></pre><p id="fdd0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">…然后您可以获取信息和设置信息:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="8b5b" class="lf lg iq lb b gy lh li l lj lk"><br/>bob.name; // Mike<br/>bob.name = “Joe”; // Joe<br/>bob.weight; // 200 <br/>bob.weight = 300;<br/>bob.weight; // 300 Ibs<br/></span></pre><p id="e544" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你应该意识到新的方法(ES6类)不允许你如此容易地分离私有和公共变量/函数。您必须使用一个不规则的下划线来提醒其他开发人员，或者在变量名或函数名前使用一个标签。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="ab17" class="lf lg iq lb b gy lh li l lj lk"><br/> // private property<br/> this.#weightCounter= 0;</span><span id="998b" class="lf lg iq lb b gy ll li l lj lk">// private method (can only be called within the class)<br/> #bmi() {<br/> this.#weightCounter++;<br/> }<br/></span></pre><h2 id="15d0" class="lf lg iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">功能</h2><p id="2fa5" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">如果您研究过我的<a class="ae mi" href="https://www.howtocodejs.com/javascript-functions/" rel="noopener ugc nofollow" target="_blank">函数</a>文章，您会注意到我使用了一个匿名函数，以便“bmi”函数可以无缝地融入return语句。您可以使用普通的函数声明，但是您应该知道您选择的类结构会改变您调用函数的方式。最好尽可能坚持使用匿名函数，因为它们更简洁、可读性更强。</p><p id="efeb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以这样调用我们的函数:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="ab19" class="lf lg iq lb b gy lh li l lj lk"><br/> bob.bmi(); // 27.12<br/></span></pre><h2 id="8e6e" class="lf lg iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">遗产</h2><p id="1572" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">我们应该简单讨论一下继承。最终，你会发现自己需要开设更多针对特定个人的课程。例如，您可能希望创建一个专门针对举重运动员的课程和另一个专门针对跑步运动员的课程。这些类有不同的特征，但是它们仍然和普通用户类有共同点，比如名字，身高等等。</p><p id="363b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可以让CardioUSer从USer类继承，而不只是重写这些变量。有旧的继承方式和新的继承方式。如果你已经用旧的但仍然有效的方法构建了一个类，你会想要做一个“原型继承”我已经写了一篇关于原型的<a class="ae mi" href="https://www.howtocodejs.com/javascript-prototype-chain/" rel="noopener ugc nofollow" target="_blank">文章</a>。当您查看那篇文章时，我将给出一个继承的旧形式的例子。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="80e6" class="lf lg iq lb b gy lh li l lj lk">//constructor<br/>function User(construct){<br/> this.name = construct.name;<br/> this.height = construct.height;<br/> this.age = construct.age;<br/> this.weight = construct.weight;<br/>}<br/>//prototype<br/>User.prototype.bmi = ()=&gt;{<br/> return (this.weight / (this.height * this.height)) * 703;<br/>}<br/> <br/>//inheriting constructor<br/>function CardioUser(object){<br/> User.call(this, object)<br/>}<br/>//prototypical inheritance<br/>CardioUser.prototype = User.prototype;</span><span id="67b3" class="lf lg iq lb b gy ll li l lj lk">let andy = new CardioUser({name:”Joe”, height:72, age: 30, weight: 200});<br/> <br/>andy.bmi();</span></pre><p id="0206" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有很多事情需要解决。我将bmi函数从类中移除，并将其分配给User的原型，然后可以将其传递给CardioUser。这是用JavaScript创建类的最实用的方法。函数本身只作为一个构造函数，而原型包含你想要创建的任何动态函数。</p><p id="9b93" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我通过使用User上的call函数继承了构造函数。</p><p id="568c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据Mozilla的说法，“使用‘call()’,你可以写一次方法，然后在另一个对象中继承它，而不必为新对象重写方法。”第一个参数接受“this”关键字和用于赋值的附加参数。</p><p id="681a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的例子中，我们使用了一个对象，所以我们只需要给object赋值，这将应用到我们继承的构造函数中。</p><p id="fc37" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">之后我把功能从User分配到CardioUSer和wala！CardioUser现在继承了构造函数和函数。</p><p id="5f49" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">新的做事方式要简单得多:</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="e30e" class="lf lg iq lb b gy lh li l lj lk"><br/>class User {<br/> constructor(construct){<br/> this.name = construct.name;<br/> this.height = construct.height;<br/> this.age = construct.age;<br/> this.weight = construct.weight;<br/> }</span><span id="574b" class="lf lg iq lb b gy ll li l lj lk">bmi(){<br/> return (this.weight / (this.height * this.height)) * 703;<br/> }<br/>}</span><span id="c490" class="lf lg iq lb b gy ll li l lj lk">class CardioUSer extends User {<br/> constructor(object){<br/> super(object)<br/> }<br/>}</span><span id="9363" class="lf lg iq lb b gy ll li l lj lk">let bob = new CardioUSer({name:”Joe”, height:72, age: 30, weight: 200});</span><span id="0b5c" class="lf lg iq lb b gy ll li l lj lk">bob.bmi();</span></pre><p id="92ef" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你可能仅仅通过阅读代码就知道发生了什么。我将用户类别扩展到了有氧运动。我没有使用call，而是使用了super，它只需要接受我想赋给我的继承变量的任何内容。在这种情况下，我们使用一个对象文字。</p><h2 id="5f67" class="lf lg iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">Getters和Setters</h2><p id="8ca7" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">如果那些原型的东西让你害怕，你可能最好使用新的ES6类。不可否认，它更干净，而且你实际上可以做其他脚本语言中可用的事情，比如指定getter和setter方法。正如您之前看到的，getter和setter是隐含的，但是使用Es6类我们可以显式地设置它们。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="c3ba" class="lf lg iq lb b gy lh li l lj lk"><br/>set name (name) { <br/>this.name = name; <br/>} <br/> <br/>get name () { <br/>return this.name; <br/>}</span></pre><p id="72d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这种类型的编码是很好的实践，尽管它看起来可能是多余的。做这件事的老方法是写…</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="20be" class="lf lg iq lb b gy lh li l lj lk"><br/>let setName = (name)=&gt; { <br/>this.name = name; <br/>} <br/> <br/>let getName = (name)=&gt; { <br/>return this.name; <br/>}<br/></span></pre><h2 id="80ea" class="lf lg iq bd lm ln lo dn lp lq lr dp ls kj lt lu lv kn lw lx ly kr lz ma mb mc bi translated">结论</h2><p id="4b91" class="pw-post-body-paragraph jy jz iq ka b kb md kd ke kf me kh ki kj mf kl km kn mg kp kq kr mh kt ku kv ij bi translated">我们可以没完没了地谈论课程，但这应该足够了。你知道有基本的构建模块需要去做功能性的应用。但是你可能会问，哪种方法更好呢？旧的还是新的？我发现老方法用起来真的很舒服，只是因为我觉得我没有被ES6类设置的参数所束缚。然而，我确实发现ES6类是值得一看的，它们来自Ruby背景，在那里类是紧凑和可读的。</p><p id="87ee" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我认为人们必须认识到，JavaScript一直是一种功能工具，用于为应用程序添加一些奇特的属性。所以创建大型类结构的想法并不存在。语言设计者只是边走边构建，没有预料到JavaScript会被用于后端。</p><p id="830b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是现在JavaScript已经在越来越多的领域使用，ES6类似乎是为了给来自其他脚本语言的程序员提供安慰而设计的。碰巧的是，新来者可能会发现新的ES6类也更容易理解。相比之下，旧的做事方式似乎有点过时。</p><p id="b54c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，你应该选择最适合你的。当您习惯于用JavaScript编程时，您可能会发现使用旧方法更快。或者你可能不会。这就是语言的美妙之处。各有所好。</p><p id="40d6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae mi" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ka ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="ka ir">！</strong></p><div class="mj mk gp gr ml mm"><a href="https://medium.com/the-open-manuel/learn-code-like-a-chef-not-a-diner-45f38cb758af" rel="noopener follow" target="_blank"><div class="mn ab fo"><div class="mo ab mp cl cj mq"><h2 class="bd ir gy z fp mr fr fs ms fu fw ip bi translated">像厨师而不是用餐者一样学习代码</h2><div class="mt l"><h3 class="bd b gy z fp mr fr fs ms fu fw dk translated">六年前，我想建立自己的网站。所以，我做了一些研究，发现HTML/CSS3、JavaScript和…</h3></div><div class="mu l"><p class="bd b dl z fp mr fr fs ms fu fw dk translated">medium.com</p></div></div><div class="mv l"><div class="mw l mx my mz mv na jw mm"/></div></div></a></div></div></div>    
</body>
</html>