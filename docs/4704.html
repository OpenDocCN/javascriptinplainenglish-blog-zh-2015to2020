<html>
<head>
<title>Different Methods for Data Fetching in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中获取数据的不同方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/data-fetching-in-react-668ef136efd9?source=collection_archive---------10-----------------------#2020-12-31">https://javascript.plainenglish.io/data-fetching-in-react-668ef136efd9?source=collection_archive---------10-----------------------#2020-12-31</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d099" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React中获取数据的6种方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/21da66ad70630afb110f5b156e854e3b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*GygGEfbDSP3AgPfU.jpg"/></div></div></figure><p id="ed4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当谈到在组件视图中显示数据时，我将讨论所有的最佳方法。</p><blockquote class="ln"><p id="a361" class="lo lp iq bd lq lr ls lt lu lv lw lm dk translated">你可以访问<a class="ae lx" href="https://gitlab.com/mohit199thd/react-data-patterns-demo" rel="noopener ugc nofollow" target="_blank"> <strong class="ak"> GitLab </strong> </a>链接来更好地理解我下面展示的例子</p></blockquote><h2 id="2b9a" class="ly lz iq bd ma mb mc dn md me mf dp mg la mh mi mj le mk ml mm li mn mo mp mq bi translated">如何在React中获取数据</h2><p id="2144" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">如果你是一个熟悉构建简单的<strong class="kt ir"> React </strong>项目的初学者，那么你可能已经研究过简单的数据获取方法，而不是处理越来越多的要获取的数据。在您的React之旅中，随着您的发展，您的应用程序将变得更加复杂，使用正确的技术获取数据成为一项需求。使用内置的<strong class="kt ir"> Fetch API、<em class="mw"> Axios、async/await、</em> </strong>等等，在React中获取数据的方法有很多。</p><h1 id="cbb7" class="mx lz iq bd ma my mz na md nb nc nd mg jw ne jx mj jz nf ka mm kc ng kd mp nh bi translated">1.服务器提供的数据</h1><p id="34b2" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">这种方法很简单，在大多数情况下，数据嵌入在从服务器发送的<strong class="kt ir"> HTML </strong>中，效果很好。如果我们需要新数据，您需要手动刷新页面或定期刷新页面。</p><p id="d8b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如:</p><pre class="kg kh ki kj gt ni nj nk nl aw nm bi"><span id="0d27" class="ly lz iq nj b gy nn no l np nq">&lt;meta http-equiv="refresh" content="30"&gt;</span></pre><p id="ba92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个方法与React应用程序不太相关，但是我们可以称这个方法为从服务器向浏览器获取数据的更动态的方法。</p><p id="b58c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">尽管如此，许多<strong class="kt ir">网络应用</strong>使用这个&amp;，以防<strong class="kt ir"> <em class="mw"> JavaScript </em> </strong>被禁用，或者当我们不得不处理旧浏览器时，这甚至是获取数据的最佳方式。</p><h2 id="78e9" class="ly lz iq bd ma mb nr dn md me ns dp mg la nt mi mj le nu ml mm li nv mo mp mq bi translated">React组件如何获取数据</h2><p id="5c68" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">React组件中的数据获取有几种方法。</p><p id="6fc8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">1.从没有数据开始，然后在基于用户的操作(单击按钮)上获取数据。</p><p id="0fde" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.一次加载数据。</p><p id="26bb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">3.定期加载数据</p><p id="a547" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于该组件是完全自主的，没有其他组件可以告知是时候加载一些数据了，所以将在<strong class="kt ir"><em class="mw">componentDidMount()</em></strong>中首次加载数据，并设置一个计时器，该计时器将每7秒读取一次数据。</p><p id="883b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们下面的UserTableAutonomus组件是一个标准的<strong class="kt ir"> React类</strong>组件，</p><h2 id="881e" class="ly lz iq bd ma mb nr dn md me ns dp mg la nt mi mj le nu ml mm li nv mo mp mq bi translated">该状态包括两个字段:</h2><ol class=""><li id="d4a1" class="nw nx iq kt b ku mr kx ms la ny le nz li oa lm ob oc od oe bi translated">boolean<strong class="kt ir"><em class="mw">is fetching</em></strong>初始化为false，因为它还没有获取。</li><li id="15d7" class="nw nx iq kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">一个空的<strong class="kt ir">用户列表，</strong>是它需要获取的数据。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/ed8ccdf031d98119fe91d0c5264f8b41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Uuij9IayoLKnUdN0Yq7JA.png"/></div></div></figure><p id="8c5b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir"> <em class="mw"> render() </em> </strong>方法呈现从状态传递给当前用户的<strong class="kt ir"> <em class="mw"> BootstrapTable </em> </strong>组件。实际的数据获取发生在React生命周期方法的<strong class="kt ir"><em class="mw">componentidmount()</em></strong>中，我们不使用<strong class="kt ir"><em class="mw">componnetWillMount()</em></strong>的原因有两个，首先是它已被弃用<strong class="kt ir"> React 17 </strong> &amp;当我们使用Fetch API或<em class="mw">Axios</em><strong class="kt ir"><em class="mw">componentWillMount()</em></strong>时，渲染会不等它完成就发生</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/a7f16b559e2b61df2c5887b15e55cc18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TxE1wez7ymrHApWatDDL5w.png"/></div></div></figure><p id="8d3b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">componentDidMount()在第一次渲染后被调用，所以我们仍然需要处理第一次空渲染，在这种情况下，我们使用<strong class="kt ir"> <em class="mw">【获取数据】</em> </strong>消息，您也可以在构造函数中选择自己的初始数据获取。</p><p id="00dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，现在我们将在<strong class="kt ir"><em class="mw">componentDidMount()</em></strong>中获取数据，代码只需调用<strong class="kt ir"> <em class="mw"> fetchUsers() </em> </strong>方法，并启动一个计时器，每隔7秒调用<strong class="kt ir"> <em class="mw"> fetchUsers() </em> </strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/acde9fc7b80ced06a83a8c7369070e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-4Ru9MNE0LJFXXzieQnDOw.png"/></div></div></figure><p id="0891" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">当我们的组件离开时，componentWillMount()方法被调用，并且<strong class="kt ir"><em class="mw">clearInterval()</em></strong>将通过将时间间隔设置为空来停止时间间隔。</p><p id="e36f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="mw"> fetchUsers() </em>将isFetching状态变量设置为<strong class="kt ir"> True </strong>，这样一旦获取新数据，组件就会显示“获取数据”消息。然后在获得一些数据后，它设置<strong class="kt ir">为将</strong>取回到<strong class="kt ir">假</strong>。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi on"><img src="../Images/668435b160c80a61d222ad4fa278bafb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tGwweo4FiZfz6el3q5m8wg.png"/></div></div></figure><h1 id="520c" class="mx lz iq bd ma my mz na md nb nc nd mg jw ne jx mj jz nf ka mm kc ng kd mp nh bi translated">2.获取API</h1><p id="2896" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">我已经在函数<strong class="kt ir"><em class="mw">fetchuserswithchapi()</em></strong>中使用了Fetch API，并为变量<strong class="kt ir"> <em class="mw"> fetchUsers </em> </strong>赋值，因此组件只调用<strong class="kt ir"> <em class="mw"> fetchUsers()。</em> </strong></p><p id="96bd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它首先将<strong class="kt ir"><em class="mw">is fetch</em></strong>变量设置为<strong class="kt ir"> true，</strong>然后调用fetch，fetch返回一个promise，promise进一步解析为一个响应，然后response<strong class="kt ir"><em class="mw">JSON()</em></strong>方法返回一个<strong class="kt ir"> JavaScript </strong>对象。</p><p id="a367" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然后，它将<strong class="kt ir"> <em class="mw"> isFetching </em> </strong>重置为false，如果出现错误，catch处理程序会将错误记录到控制台，并在<em class="mw">获取</em>过程完成时重置<strong class="kt ir"> isFetching </strong>变量。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/c3347cfff6ad44e07d896c0554bafdca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wIUqMhIq7J2URHIzeH_HCg.png"/></div></div></figure><h1 id="a906" class="mx lz iq bd ma my mz na md nb nc nd mg jw ne jx mj jz nf ka mm kc ng kd mp nh bi translated">3.使用Axios</h1><p id="8f0b" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">我们将在UserTableRenderProps组件中使用Axios。Axios也有一个类似于Fetch的基于promise的API，但是它省去了JSON解析阶段并处理所有的错误。其中Fetch API返回一个<strong class="kt ir">错误404 </strong>作为正常响应，所以您可能需要检查代码上的响应并自己抛出一个错误。Axios有几乎相似的代码来获取API，但是少了一个步骤和更多的错误处理。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/37adca64795e2517149f4cd4a6b23240.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xE7FFiQoHxw8E3tt_FNpvQ.png"/></div></div></figure><h2 id="cc7b" class="ly lz iq bd ma mb nr dn md me ns dp mg la nt mi mj le nu ml mm li nv mo mp mq bi translated">获取与Axios</h2><p id="597a" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">我们可以使用两者通过<strong class="kt ir"> HTTP </strong>协议与服务器通信，但是哪一个更适合你将取决于你的项目目标。</p><p id="9366" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Fetch API在窗口项目上提供了一个<strong class="kt ir"> <em class="mw"> Fetch() </em> </strong>方法，以及一个用于访问<strong class="kt ir"> HTTP </strong>请求和响应的<strong class="kt ir"> <em class="mw"> JavaScript </em> </strong>接口，fetch只有一个强制参数，即要获取的资源的<strong class="kt ir"> <em class="mw"> URL </em> </strong>，它返回一个可用于检索请求响应的承诺</p><p id="ab99" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">而Axios是一个JavaScript库，能够从<strong class="kt ir"> Node.js </strong>或<strong class="kt ir"> XML &amp;发出HTTP请求，支持ES6版JavaScript中的Promise API。</strong></p><h1 id="6550" class="mx lz iq bd ma my mz na md nb nc nd mg jw ne jx mj jz nf ka mm kc ng kd mp nh bi translated">4.在React中使用Async/Await提取数据</h1><p id="a0ec" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">承诺的改变是对回调的巨大改进，而且可以变得更好。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oq"><img src="../Images/1c2ed18c67d8b06315f823b28abdc0a7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wOSVCjh7AqqtLu-HHFBYMw.png"/></div></div></figure><h1 id="eb76" class="mx lz iq bd ma my mz na md nb nc nd mg jw ne jx mj jz nf ka mm kc ng kd mp nh bi translated">5.从React中的GraphQL API获取</h1><p id="cf1c" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">一个GraphQL后端怎么样？它们通常通过HTTP返回一个JSON，主要区别在于只有一个查询端点来获取数据，而实际请求的数据遵循<strong class="kt ir"> GraphQL </strong>模式。数据获取方法并没有真正区分REST和GraphQL，两者都工作得很好。</p><h1 id="c68c" class="mx lz iq bd ma my mz na md nb nc nd mg jw ne jx mj jz nf ka mm kc ng kd mp nh bi translated">6.用React钩子获取数据</h1><p id="f2e9" class="pw-post-body-paragraph kr ks iq kt b ku mr jr kw kx ms ju kz la mt lc ld le mu lg lh li mv lk ll lm ij bi translated">高阶组件和渲染道具等模式要求您重新构建组件层次结构。<strong class="kt ir"> <em class="mw"> React Hooks </em> </strong>的需求是打破<strong class="kt ir">状态管理</strong>是独立的函数，不需要将状态的圆桩放入类生命周期方法的方孔中。React的特性不需要类，我们可以使用React钩子获取数据。</p><p id="971d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">例如:</p><p id="abfa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在函数<strong class="kt ir"><em class="mw">UserTableReactHooks()</em></strong>中，使用状态钩子用初始状态调用，钩子返回两个值:当前状态和更新它的函数。</p><p id="adda" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了执行像数据获取这样的副作用，我们将使用一个效果钩子。在这种情况下，我们只想运行它一次，所以我们将传递一个函数和一个空数组。数组参数告诉钩子，只有在数组中列出的状态变量发生变化时才应用效果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/f7e29ae13622755fb13a691b604014c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KV5Kze6cvo4-1IUkAAA9Ug.png"/></div></div></figure></div></div>    
</body>
</html>