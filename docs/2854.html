<html>
<head>
<title>Hectic JavaScript Interviews Questions!</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">忙乱的JavaScript面试问题！</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/hectic-javascript-interviews-questions-8fdf7ddd0e53?source=collection_archive---------9-----------------------#2020-07-29">https://javascript.plainenglish.io/hectic-javascript-interviews-questions-8fdf7ddd0e53?source=collection_archive---------9-----------------------#2020-07-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="349a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript是异步的还是同步的？JavaScript是如何工作的？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/180c790ac5f136da81facf52dd03af6c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zxb58UjjW5-Irgkq"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@punttim?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Tim Gouw</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4cda" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多年来，JavaScript发展如此之快，以至于很难归类。今天，我将深入探讨JavaScript是同步的还是异步的，以及幕后的工作流是什么样子的。当然，也给你面试中最常见问题的答案。让我们直接进入文章。</p><h1 id="0be7" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">JavaScript是如何工作的？</h1><p id="09b6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">想象一下在面试中被问到这个问题，或者解释一下JavaScript中<strong class="ky ir">异步和同步的区别？</strong>或者他们可能会让你解释一下<strong class="ky ir">的说法:“JavaScript是一种单线程语言，可以是非阻塞的！'【T3]别担心，我会帮助你解决本文中的问题。</strong></p><p id="7615" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mp">我们不需要知道JavaScript如何在内部工作来编写程序。</em>但是<strong class="ky ir">没有！</strong>学习很重要。我看到许多做了多年开发人员的人却不知道这一点，这就像是一名飞行员不知道飞机如何飞行一样！好吧，这有点戏剧性，但你明白我的意思，所以我们先开始吧。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="a6b9" class="ls lt iq bd lu lv mx lx ly lz my mb mc jw mz jx me jz na ka mg kc nb kd mi mj bi translated">什么是程序？</h1><p id="781d" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">一个程序必须做一些简单的事情:</p><p id="9a2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">分配内存分配内存必须分配内存，否则，我们的计算机上就不能有变量，甚至不能有文件。</p><p id="3d06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解析并执行</strong> <em class="mp"> —它还必须解析并执行脚本，这意味着读取和运行命令。</em></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nc"><img src="../Images/cb4d3fe5dd0d0a1eeaa36bf70eb108da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0WKqKJs1N6bWcSdpLM8T6w.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image Credit- <a class="ae kv" href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine)" rel="noopener ugc nofollow" target="_blank">WikiPedia</a></figcaption></figure><p id="3d73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们还知道chrome中有一个JavaScript引擎<strong class="ky ir"/><a class="ae kv" href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine)" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"/></a>每个浏览器都实现了这个引擎<a class="ae kv" href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine)" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">【V8】</strong></a>和<a class="ae kv" href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine)" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> V8引擎</strong> </a>读取我们编写的JavaScript，并将其转换成浏览器的机器可执行指令。这个引擎由两部分组成:一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">内存堆</strong> </a>和一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Call_stack" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"/></a></p><p id="2a04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">内存堆</strong> </a> <strong class="ky ir">，</strong>这是内存分配发生的地方，然后<strong class="ky ir">调用堆栈是代码被读取和执行的地方</strong>它告诉你你在程序中的位置，所以让我们简化一下，向你展示我的意思。</p><p id="116e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">声明变量时，JavaScript会自动为变量分配内存。</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="b062" class="ni lt iq ne b gy nj nk l nl nm">const a = 100; //allocate memory<br/>const b = 10;<br/>const c = 1; //allocate memory</span></pre><p id="1bed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们刚刚分配了内存，当我们赋值的时候，javascript引擎会记住，哦，是的，a的值是100。我们刚刚用完了<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">内存堆</strong> </a> <strong class="ky ir"> </strong>我可以继续，我可以继续复制粘贴，把这些变量改成B和C，我也可以改变它们的值。这是我们看到的一个问题，当你成为一名开发人员时，你会听到一种叫做<a class="ae kv" href="https://en.wikipedia.org/wiki/Memory_leak#Reference_counting_and_cyclic_references" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">的内存泄漏</strong> </a>，我们在这里所做的是我们已经创建了所有这些变量<strong class="ky ir"> </strong> <a class="ae kv" href="https://www.javatpoint.com/javascript-global-variable" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">全局变量</strong> </a>，它们都在<strong class="ky ir">内存堆中。</strong></p><p id="2e51" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想象一下，如果这一页充满了变量，而不是数字，它们就像一个很大的数组，内存泄漏就会发生。当你有未使用的内存时，比如说我们没有使用变量A，但它是全局变量，因为有未使用的内存，它填满了内存堆，这就是为什么你可能会听到为什么<a class="ae kv" href="http://wiki.c2.com/?GlobalVariablesAreBad" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">全局变量是坏的。</strong>T29】</a></p><p id="6417" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="http://wiki.c2.com/?GlobalVariablesAreBad" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">全局变量是不好的</strong> </a>因为如果我们不忘记自己清理，我们会填满这个内存堆，最终，浏览器将无法正常工作。这就是内存分配。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/4688e2408e40e8ea86a46dbeb4c646d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_tbSVsi7w6xtTUO-pWBcMg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Memory Heap and Call Stack (Photo by- Unsplash)</figcaption></figure><p id="0bc7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们先来谈谈<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/Call_stack" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">调用栈</strong> </a> <strong class="ky ir"> </strong>那是什么呢再用一个调用栈我们可以有这样的东西:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="6083" class="ni lt iq ne b gy nj nk l nl nm">//CALL STACK<br/>console.log(“1”);<br/>console.log(“2”);<br/>console.log(“3”);</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi no"><img src="../Images/1704e0f7d045cd8421234d7674bb16d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1364/format:webp/1*yXVdIn9BV9pGA1one09H8A.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Call Stack Example</figcaption></figure><p id="d8b9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/console" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> Console.log </strong> </a>会走一个，Console.log两个，最后Console.log三个。如果我在浏览器终端运行这段代码，我会得到123。如果你记得那是<strong class="ky ir">调用栈</strong>做的事情？它读取并执行我们的脚本。</p><p id="a72e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们一步一步来:</p><ul class=""><li id="9a0f" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">它读取第一行console.log，并将其放入这个调用堆栈，然后运行它并创建1。</li><li id="4c75" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">然后它说好的，我正在删除第一个console.log，因为我刚刚运行完它。我将把第二个console.log放入我的调用堆栈。把它加到这里，说是，执行，然后把它去掉，弹出来。</li><li id="c165" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">然后获取console.log 3并记录console.log 3，最后删除。</li></ul></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><h1 id="b978" class="ls lt iq bd lu lv mx lx ly lz my mb mc jw mz jx me jz na ka mg kc nb kd mi mj bi translated">同步JavaScript</h1><p id="94e7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><em class="mp"> JavaScript是一种单线程语言，可以是非阻塞的。</em></p><p id="3951" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript是一种<strong class="ky ir">单线程</strong>语言，可以是非阻塞的。单线程意味着它只有一个<strong class="ky ir">调用栈</strong>，一个调用栈一次只做一件事意味着<strong class="ky ir">同步</strong>，正如你所看到的，调用栈是<strong class="ky ir">先入后出</strong>的，所以，调用栈顶部的先运行，然后运行到调用栈之下，再运行到调用栈之下，直到调用栈为空，现在其他语言可以有<strong class="ky ir">多个调用栈</strong>，这些被称为<strong class="ky ir">多线程。</strong></p><p id="da8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您还可以看到，拥有多个调用堆栈是多么有益，这样我们就不会一直等待。那么<strong class="ky ir">为什么JavaScript被设计成单线程？</strong></p><p id="6b4f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，在单线程上运行代码可能非常容易，因为您不必处理多线程环境中出现的复杂场景。</p><p id="afc4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，你可能听说过站点堆栈溢出。如果你是一名开发人员，你每天都在使用它，你有没有想过栈溢出意味着什么？堆栈溢出是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi od"><img src="../Images/569bbfd3c0f755af912a385d78f65ca5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DRBBU9wLVzZ1ppjH95KfCg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Call Stack OverFlow</figcaption></figure><p id="c8dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当一个步骤溢出时，有点像我们讨论的内存泄漏和JavaScript引擎的内存堆如何溢出！栈溢出是指调用栈越来越大，直到没有足够的空间。</p><p id="dade" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们如何做到这一点？我们能重建一个堆栈溢出吗？是的，我可以很快地告诉你们，创建一个函数foo，就像我们在这里一样，这个函数只有foo，我们只是运行我们的foo函数，好吧，这看起来很混乱，但是这里发生了什么呢？这就是所谓的<strong class="ky ir"> </strong> <a class="ae kv" href="https://www.sitepoint.com/recursion-functional-javascript/#:~:text=Recursion%20is%20a%20technique%20for,to%20looping%20is%20the%20default." rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">递归。</strong> </a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/eb7ec304d0a71fb4c2d79cb48c49f6d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*kHNzzWVX_hp6y_5b6msYmw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Recursion example</figcaption></figure><p id="b677" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">递归</strong>意味着一个函数调用它自己，所以如果你看看这个函数，我们运行foo，foo被执行。福所做的是。我们又运行了一遍，所以它只是一遍又一遍地循环，有一个递归，但看不到尽头，对吗？我们不断地将foo添加到调用堆栈中，我们不断地添加它，一遍又一遍，如此等等…</p><p id="0edf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们有一个堆栈溢出，所以如果你想玩得开心，进入你的浏览器，进入你的控制台，运行这样的东西，看看会发生什么，你会得到一个堆栈溢出。</p><p id="ddce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，希望这现在有意义了<strong class="ky ir"> JavaScript引擎V8 </strong>和Chrome有一个<strong class="ky ir">内存堆</strong>和一个<strong class="ky ir">调用栈</strong>。</p><p id="ceb7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在JavaScript是单线程的，一次只执行一条语句，但是有一个问题，如果console.log的第2行是一个很大的任务，我们需要做的可能是遍历一个有数百万项的数组。那里会发生什么？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi of"><img src="../Images/cdcced232120b8c082784e5a1d3ac548.png" data-original-src="https://miro.medium.com/v2/resize:fit:652/format:webp/1*UIb2m5J3TaMs0k2fZkKEtg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Synchronous Example</figcaption></figure><p id="1fed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，使用<strong class="ky ir">同步任务</strong>时，如果我们有一个函数占用了大量时间，它将会阻塞生产线。</p><h1 id="57e9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">示例:</h1><p id="a953" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">想象一下一个自助餐厅，如果所有人都想吃，但鲍比说，等等，伙计们，我必须继续吃，把培根放在我的盘子里，每个人都必须排队，所以，听起来我们需要一些不堵塞的东西。还记得我们在这篇文章中的第一个声明吗？<strong class="ky ir"> <em class="mp"> JavaScript是一种单线程语言，可以是非阻塞的。理想情况下，我们不会等待那些需要时间的事情，那么我们该怎么做呢？</em></strong></p><p id="74a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，<strong class="ky ir">异步</strong>来救援了。我们需要的不仅仅是同步任务。你在想，我们如何完成异步编程任务？</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi og"><img src="../Images/4ec3cc403744b8994b0833834e590f2b.png" data-original-src="https://miro.medium.com/v2/resize:fit:754/format:webp/1*V-aZuRF_OdZp6vX9xHW9ww.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Asynchronous Example</figcaption></figure><p id="158a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嗯，我们可以通过这样做来进行<strong class="ky ir">异步编程</strong>，<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> setTimeout </strong> </a>我们将要讨论的是浏览器中的一个函数，它允许我们创建一个<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">超时</strong> </a>我们可以给它第一个参数是我们想要运行的函数，然后第二个参数是我们想要等待多少秒，假设我想要等待两秒，那么200分钟2000毫秒。如果我现在这样做，让我们进入控制台，看看会发生什么。你也试试看会发生什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/a1529e6fc40e36b8edd05a4949cf549f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*dNH7KtMF6atjOHsYwqenUQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Asynchronous Example Result</figcaption></figure><p id="3393" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">刚刚发生了什么？我们有console . log 1，然后是console.log 3，然后是console.log 2。2秒钟后，看起来我们跳过了整个步骤，然后把它放在最后，你刚刚看到了异步编程。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oi"><img src="../Images/d142969103755b0e65df355e0ffe57ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*etDsDpflHr8sg0JxvSEs7g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">JavaScript Runtime Environment</figcaption></figure><p id="2063" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了理解这一点和刚刚发生的事情，我需要带你到下一部分，这是为了让我们所知的JavaScript运行，让JavaScript引擎通过内存堆和调用栈来运行。我们需要的不仅仅是JavaScript引擎，我们需要所谓的<strong class="ky ir"> JavaScript运行时环境</strong>。</p><p id="ca14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">JavaScript运行时环境</strong>是浏览器的一部分，它包含在浏览器的。他们有额外的东西，在引擎之上，他们有叫做<strong class="ky ir">Web API、</strong>回调队列和事件循环的东西。</p><p id="aa3a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如你在这里看到的，<strong class="ky ir">设置超时</strong>是<strong class="ky ir"> Web API </strong>的一部分，从技术上讲它不是JavaScript的一部分，对吗？这是浏览器给我们的用途，所以我们可以做<strong class="ky ir">异步程序</strong>。</p><p id="0d71" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好的，看这个图表，让我们看看我们是否能弄清楚我们的代码在做什么。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/f56e524188e5af166f6ec92baeb461f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*FKXgF2KerDp1PMFoo7D8_g.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">JavaScript Run Time Environment step by step Example.</figcaption></figure><p id="a81f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以在这里创建自己的调用堆栈，我们将有Web API，然后我们将有一个回调队列和一个事件循环。就像我们在<strong class="ky ir"> JavaScript运行时环境</strong>中一样，这里发生了什么:</p><ul class=""><li id="6552" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">首先，我们将console.log放入调用堆栈并运行，因此我们将console.log记录到浏览器中。</li><li id="3835" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">然后我们将<strong class="ky ir"> Set Timeout </strong>放入我们的调用堆栈，因为我们完成了第一个任务，我们将进入第二个任务，接下来会发生什么呢？如果调用栈说好的，半设置超时，因为设置超时不是JavaScript的一部分，而是Web API的一部分，它有这个特殊的特征，它触发Web API，说设置超时刚刚被捕获，因为我们通知了Web API，我们可以从调用栈中弹出它。</li><li id="b5d5" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">现在web API在这里启动了一个定时器，一个两秒钟的定时器，但是它知道在两秒钟内你必须做一些事情，因为调用栈是空的，JavaScript引擎现在转到console.log 3。并执行此操作，因此现在我们已经完成了1和3，但我们仍然在web API中将超时设置为秒。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/bb088d4aa4cb5aa20aa4c2a44a448765.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*xEC08yIufwjkaHBkWBlRBA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Callback function.</figcaption></figure><ul class=""><li id="7101" class="np nq iq ky b kz la lc ld lf nr lj ns ln nt lr nu nv nw nx bi translated">现在，2秒钟后，当我们的时间限制到了，Web API会说ok SetTimeout应该运行，让我们看看它里面有什么，我们有console.log，那么接下来会发生什么呢？它会说，嘿，设置超时完成了，我们有一个回调，这个回调是我们添加到回调队列中的，它说，嘿，我们必须运行一些东西，我们准备好运行它了。</li><li id="125e" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">最后一部分<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">事件循环</strong> </a>在这里检查并说，嘿，调用堆栈是空的，它一直在检查。如果堆栈是空的，JavaScript引擎上现在没有运行任何东西，它会说，嘿，我们有回调吗？它会检查回调队列，然后说，嗯，那里有什么东西吗，因为调用栈是空的，我们可以在那里放些东西，让它做一些工作，在我们的例子中，我们说，哦，是的，让我把它放入调用栈，现在我们把回调移到调用栈，然后我们运行回调，通过运行我们看到我们有console.log。</li><li id="ac0a" class="np nq iq ky b kz ny lc nz lf oa lj ob ln oc lr nu nv nw nx bi translated">它会说console.log，它会运行这个函数，一旦完成，它会从调用堆栈中弹出这个函数，我们再次完成了回调，所以我们移除它，就这样，我们完成了一切都是空的，我们刚刚运行了这个示例，它会遍历整个<strong class="ky ir"> Web API </strong> <strong class="ky ir">回调队列、</strong> <a class="ae kv" href="http://7- So it's going to say console.log, it's going to run this function and once it's done it's going to pop it out of the call stack and again we're done with the callback so we remove it and there you go, We're done everything is empty and we've just run this Example, it's gonna go through the entire Web API Callback Queue, Event loop. Wooh! There’s was a lot of information but Hopefully, that makes sense to you of Why we noticed this behavior and I want to challenge your understanding here knowing what you know and what I just taught you what happens if I change this Set Timeout to zero? that means zero seconds I'm going to give you a second to think about what will happen.? And Answer yourself." rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">事件循环</strong>。</a></li></ul></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="0026" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">哇哦。有很多信息，但希望你能理解我们为什么会注意到这种行为，我想在这里挑战你的理解，知道你所知道的和我刚刚教你的，如果我把这个<strong class="ky ir"> setTimeout </strong>变为零会发生什么？这意味着零秒，我给你一秒钟，让你想想会发生什么。？并回答自己。</p><p id="7ae4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，如果你能理解这篇文章。实际上，你会有很多人在面试中问这样的问题，你必须解释这是为什么？所以，我希望这对你有意义，你可以在下一次面试中利用这一点。</p><p id="f023" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我举个例子让你更好地理解它。想象一下给你的老师打电话问一个问题:</p><p id="7acc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">同步方式</strong>是你给老师打电话，你在电话上等着，直到老师接电话，问他问题，希望得到答案，所以，你让电话铃响，直到他接起电话，但在此期间你不做任何其他事情。</p><p id="1571" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">异步方式</strong>是指你给老师发一条短信，问一个问题，然后当老师有时间的时候，他或她会回复你，给你打电话，告诉你答案，这样你就可以在这期间做其他事情。</p><p id="d9c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以<strong class="ky ir"> JavaScript是异步的</strong>当你可以给它留言时，一个回电告诉你，嘿，老师先生，当你不太忙的时候，有个消息给你。这就是为什么我们称它为回调函数，在回调队列中，我们回调是为了让他们知道，这里有一些东西在等着你。</p><h1 id="640f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">让我们回顾一下:</h1><p id="4917" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们刚刚学到了什么？<strong class="ky ir"> JavaScript是单线程语言</strong>可以<strong class="ky ir">非阻塞</strong>。它有一个调用栈，一次只做一件事。</p><p id="2057" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了不阻塞<strong class="ky ir">单线程</strong>，它可以与<strong class="ky ir">回调函数</strong>异步，这些回调函数通过<strong class="ky ir">回调队列</strong>在后台运行，然后通过<strong class="ky ir">事件循环</strong>将其带回调用堆栈。所以，下次你被问到这些话题时，你应该有更多的自信来回答这个问题。</p></div><div class="ab cl mq mr hu ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ij ik il im in"><p id="2b87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">我希望这有所帮助！</strong></p></div></div>    
</body>
</html>