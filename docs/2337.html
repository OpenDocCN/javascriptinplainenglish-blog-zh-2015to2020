<html>
<head>
<title>Understanding Temporal Dead Zone in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">理解JavaScript中的时间死区</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/understanding-temporal-dead-zone-in-javascript-53a735a682?source=collection_archive---------4-----------------------#2020-06-14">https://javascript.plainenglish.io/understanding-temporal-dead-zone-in-javascript-53a735a682?source=collection_archive---------4-----------------------#2020-06-14</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/943d1dfdf27af0448ac30c8da0aaf559.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZ8l6zTznQz0kxNfh-K04A.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by Blake Connally on Unsplash</figcaption></figure><p id="61b3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">时态死区是JavaScript中一个高级而有趣的话题。为了理解它是什么以及它是如何工作的，我们需要理解JavaScript中变量声明的不同方式。</p><h1 id="5cf5" class="kx ky in bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">Var、Let和Const</h1><p id="0efb" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">ES6为该语言带来了许多新特性，其中之一是能够使用不同的关键字定义变量，这些关键字之间有细微的差异(<a class="ae ma" href="https://www.ecma-international.org/ecma-262/6.0/#sec-let-and-const-declarations" rel="noopener ugc nofollow" target="_blank">https://www . ECMA-international . org/ECMA-262/6.0/# sec-let-and-const-declarations</a>)。</p><p id="32e9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们可以用三种方式声明变量</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="dd9b" class="mk ky in mg b gy ml mm l mn mo">var name = "Yomesh";<br/>let surname = "Gupta";<br/>const profession = "Software Engineer";</span></pre><p id="a357" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们来了解一下这三者的区别。</p><h2 id="7e45" class="mk ky in bd kz mp mq dn ld mr ms dp lh kk mt mu ll ko mv mw lp ks mx my lt mz bi translated">辖域</h2><p id="5598" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">用最简单的术语来说，作用域就是变量可访问的区域。变量的作用域由其声明的位置控制。让我们考虑一个例子。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="97cf" class="mk ky in mg b gy ml mm l mn mo">function init() {<br/>    var firstname = "Yomesh";<br/>    console.log(firstname); // Yomesh<br/>}<br/>console.log(firstname); // Error</span></pre><p id="74cd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的代码片段中，变量<code class="fe na nb nc mg b">firstname</code>是在函数<code class="fe na nb nc mg b">init</code>中声明的，也就是说，我们可以在这个函数中的任何地方获取或设置变量的值。然而，在函数外部访问同一个变量会导致<code class="fe na nb nc mg b">ReferenceError: firstname is not defined</code>。</p><h2 id="5e4b" class="mk ky in bd kz mp mq dn ld mr ms dp lh kk mt mu ll ko mv mw lp ks mx my lt mz bi translated">范围界定的类型</h2><p id="8c74" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">我们有三种类型的范围界定，即<code class="fe na nb nc mg b">Global</code>、<code class="fe na nb nc mg b">Function</code>和<code class="fe na nb nc mg b">Block</code>范围界定。现在你一定在想这到底意味着什么？别再想了，现在是示范的时候了！</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="fd2e" class="mk ky in mg b gy ml mm l mn mo">// Global Scope<br/>var firstname = "Yomesh";</span><span id="5bb9" class="mk ky in mg b gy nd mm l mn mo">function sayName() {<br/>    console.log(firstname); // firstname is accessible here<br/>}<br/>function nestedSayName() {<br/>    function sayNameNow() {<br/>        console.log(firstname); // firstname is accessible here<br/>    }<br/>    sayNameNow();<br/>}</span><span id="fafb" class="mk ky in mg b gy nd mm l mn mo">sayName(); // console logs "Yomesh"<br/>nestedSayName(); // console logs "Yomesh"</span></pre><p id="af43" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的代码片段中，变量<code class="fe na nb nc mg b">firstname</code>是在函数外部声明的。任何在函数之外声明的变量都属于全局范围，并且可以被代码的所有部分访问。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="2bf0" class="mk ky in mg b gy ml mm l mn mo">// Function Scope<br/>function sayName() {<br/>    var firstname = "Yomesh";<br/>    console.log(firstname); // firstname is accessible here<br/>    function sayNameNow() {<br/>        // firstname is accessible here and we can update it.<br/>        firstname = "Ronaldo";<br/>        console.log(firstname); // Ronaldo<br/>    }<br/>    sayNameNow();<br/>}<br/>sayName();</span></pre><p id="5e8b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的代码片段中，变量<code class="fe na nb nc mg b">firstname</code>在函数<code class="fe na nb nc mg b">sayName</code>中声明。它的作用范围是该函数，即它可以在<code class="fe na nb nc mg b">sayName</code>函数或任何嵌套函数中使用。所有通过<code class="fe na nb nc mg b">var</code>声明的变量都是函数范围的。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="301b" class="mk ky in mg b gy ml mm l mn mo">// Block Scope<br/>function sayName() {<br/>    var condition = true;<br/>    if (condition) {<br/>        let firstname = "Cristiano";<br/>        const surname = "Ronaldo";<br/>        console.log(firstname, surname); // Cristiano Ronaldo<br/>    }<br/>    console.log(firstname, surname); // ReferenceError<br/>}</span></pre><p id="50ae" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的代码片段中，变量<code class="fe na nb nc mg b">firstname</code>和<code class="fe na nb nc mg b">surname</code>是在<code class="fe na nb nc mg b">if</code>代码块创建的范围内声明的。第一个<code class="fe na nb nc mg b">console.log</code>语句正确记录了值，因为变量在该范围内是可访问的。然而，第二个<code class="fe na nb nc mg b">console.log</code>抛出一个错误，因为那里根本不存在变量。</p><h2 id="2953" class="mk ky in bd kz mp mq dn ld mr ms dp lh kk mt mu ll ko mv mw lp ks mx my lt mz bi translated">声明和初始化</h2><p id="a4f6" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">变量声明引入了一个新的标识符。JavaScript解释器在创建阶段创建一个新变量。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="61fd" class="mk ky in mg b gy ml mm l mn mo">var name = "Yomesh"; // allowed<br/>var name = "Cristiano"; // allowed<br/>let surname = "Gupta"; // allowed<br/>let surname = "Ronaldo"; // Error<br/>const profession = "Software Engineer"; // allowed<br/>const profession = "Footballer"; // Error</span></pre><p id="09e6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">通过<code class="fe na nb nc mg b">var</code>声明的任何变量都可以被重复声明任意多次。但是，<code class="fe na nb nc mg b">let</code>和<code class="fe na nb nc mg b">const</code>在各自的作用域内只能声明一次。通过<code class="fe na nb nc mg b">var</code>声明的变量有默认值<code class="fe na nb nc mg b">undefined</code>。通过<code class="fe na nb nc mg b">let</code>和<code class="fe na nb nc mg b">const</code>声明的变量是存在的，但是没有值，并且在赋值之前不能被访问(稍后将详细介绍)。</p><h2 id="ce6d" class="mk ky in bd kz mp mq dn ld mr ms dp lh kk mt mu ll ko mv mw lp ks mx my lt mz bi translated">绑定到全局对象</h2><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="affc" class="mk ky in mg b gy ml mm l mn mo">var firstname = "Yomesh";<br/>let surname = "Gupta";<br/>const profession = "Software Engineer";</span><span id="c412" class="mk ky in mg b gy nd mm l mn mo">// Yomesh Gupta Software Engineer<br/>console.log(firstname, surname, profession);</span><span id="3558" class="mk ky in mg b gy nd mm l mn mo">// Yomesh undefined undefined<br/>console.log(window.firstname, window.surname, window.profession);</span></pre><p id="df17" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在全局范围内通过<code class="fe na nb nc mg b">var</code>关键字声明的变量会自动附加到全局对象上，即浏览器中的<code class="fe na nb nc mg b">window</code>。而<code class="fe na nb nc mg b">let</code>和<code class="fe na nb nc mg b">const</code>就不一样了。</p></div><div class="ab cl ne nf hr ng" role="separator"><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj nk"/><span class="nh bw bk ni nj"/></div><div class="ig ih ii ij ik"><h2 id="7540" class="mk ky in bd kz mp mq dn ld mr ms dp lh kk mt mu ll ko mv mw lp ks mx my lt mz bi translated">理解时间死区</h2><p id="7a4a" class="pw-post-body-paragraph jz ka in kb b kc lv ke kf kg lw ki kj kk lx km kn ko ly kq kr ks lz ku kv kw ig bi translated">JavaScript引擎分两个阶段运行我们的代码——创建阶段和执行阶段。在第一阶段，引擎检查代码并为变量分配内存。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="4423" class="mk ky in mg b gy ml mm l mn mo">console.log(firstname); // undefined<br/>var firstname = "Yomesh";</span></pre><p id="b63c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在同一个阶段，通过<code class="fe na nb nc mg b">var</code>声明的变量被赋予值<code class="fe na nb nc mg b">undefined</code>，这就是为什么在上面的代码片段中，你将得到变量<code class="fe na nb nc mg b">firstname</code>的值为<code class="fe na nb nc mg b">undefined</code>。这也就是我们所说的“<strong class="kb io">吊装</strong>”。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="cb71" class="mk ky in mg b gy ml mm l mn mo">console.log(firstname); // ReferenceError<br/>let firstname = "Yomesh";</span></pre><p id="3d5d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">对于通过<code class="fe na nb nc mg b">let</code>和<code class="fe na nb nc mg b">const</code>声明的变量，它们也被分配了内存，但最初并未赋值<code class="fe na nb nc mg b">undefined</code>，即变量声明确实被提升，但它们在初始化之前会抛出一个错误。让我们考虑一个例子。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="41d6" class="mk ky in mg b gy ml mm l mn mo">/*<br/>  Since variables are hoisted<br/>  it would be equivalent to<br/>  <br/>  let firstname;</span><span id="628a" class="mk ky in mg b gy nd mm l mn mo">  Beginning of the temporal dead zone</span><span id="f95a" class="mk ky in mg b gy nd mm l mn mo">*/<br/>console.log(firstname); // ReferenceError as accessed in the TDZ</span><span id="9d72" class="mk ky in mg b gy nd mm l mn mo">function init() {<br/>...<br/>}</span><span id="9cca" class="mk ky in mg b gy nd mm l mn mo">function processing() {<br/>...<br/>}</span><span id="89c3" class="mk ky in mg b gy nd mm l mn mo">var surname = "Gupta";<br/>var profession = "Software Engineer";<br/>let firstname = "Yomesh"; // Ending of the temporal dead zone</span><span id="d7f8" class="mk ky in mg b gy nd mm l mn mo">console.log(firstname); // Yomesh</span></pre><p id="b9be" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如你所见，变量<code class="fe na nb nc mg b">firstname</code>存在一个区域(时间死区),从变量被提升的地方开始，直到变量被初始化的地方。时间死区是指出代码中错误的好方法。在声明之前访问变量通常是错误的根本原因。</p><p id="413c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在执行阶段，变量被赋予它们的实际值，以后使用它们是完全可以的。</p><pre class="mb mc md me gt mf mg mh mi aw mj bi"><span id="c1fc" class="mk ky in mg b gy ml mm l mn mo">// Accessing `name` here before execution phase assigns the value to the variable would throw a ReferenceError due to TDZ.<br/>// console.log(name);</span><span id="b698" class="mk ky in mg b gy nd mm l mn mo">const name = "Yomesh";</span><span id="1c12" class="mk ky in mg b gy nd mm l mn mo">console.log(name); // Yomesh | Perfectly fine to use here</span></pre><p id="a8a3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">时间死区无处不在。我们考虑了与变量声明相关的例子，但它也存在于像<code class="fe na nb nc mg b">Default Parameters</code>这样的新特性中。</p><p id="ca61" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我希望这篇文章在某种程度上帮助了你，让你更加清晰。请在评论中或点击<a class="ae ma" href="https://www.twitter.com/yomeshgupta" rel="noopener ugc nofollow" target="_blank">此处</a>让我知道你的观点。为了测试你的知识，试试下面的问题:<a class="ae ma" href="https://code.devtools.tech/questions/s/what-would-be-the-output-based-on-temporal-dead-zone---qid---aDXxcPUD7LZNdjBCJYo8/?ref=medium-post-tdz" rel="noopener ugc nofollow" target="_blank">https://code . dev tools . tech/questions/s/what-would-be-the-output-based-on-temporal-dead-zone-qid-adxxcpud 7 lzndjbcjyo 8</a></p></div></div>    
</body>
</html>