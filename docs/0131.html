<html>
<head>
<title>Using Redux with TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Redux与TypeScript一起使用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/demystifying-redux-with-typescript-2f7c64da5d89?source=collection_archive---------0-----------------------#2019-04-21">https://javascript.plainenglish.io/demystifying-redux-with-typescript-2f7c64da5d89?source=collection_archive---------0-----------------------#2019-04-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5f6e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解<strong class="ak"> Redux、</strong>的核心概念以及最佳实践&amp;模式。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/77b68983c7642f903d714dff40e32f8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*_8k4V4NQT_Glh2I6MGvNlA.png"/></div></figure><h1 id="7d15" class="kn ko iq bd kp kq kr ks kt ku kv kw kx jw ky jx kz jz la ka lb kc lc kd ld le bi translated">议程</h1><ol class=""><li id="2753" class="lf lg iq lh b li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">什么是Redux，为什么我们需要它。</li><li id="d729" class="lf lg iq lh b li lx lk ly lm lz lo ma lq mb ls lt lu lv lw bi translated">通过从头开始构建来学习Redux的核心概念</li><li id="a52f" class="lf lg iq lh b li lx lk ly lm lz lo ma lq mb ls lt lu lv lw bi translated">用Redux构建一个Todo应用程序，我们从头开始编写</li></ol></div><div class="ab cl mc md hu me" role="separator"><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh mi"/><span class="mf bw bk mg mh"/></div><div class="ij ik il im in"><h2 id="890e" class="mj ko iq bd kp mk ml dn kt mm mn dp kx lm mo mp kz lo mq mr lb lq ms mt ld mu bi translated">Redux是什么？</h2><p id="f832" class="pw-post-body-paragraph mv mw iq lh b li lj jr mx lk ll ju my lm mz na nb lo nc nd ne lq nf ng nh ls ij bi translated">Redux是一种<em class="ni">数据架构模式</em>，帮助我们在单一窗口系统中管理应用程序数据。</p><p id="95ac" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">简而言之，Redux是孤立处理应用程序数据的最佳实践和模式的集合。</p><h2 id="0126" class="mj ko iq bd kp mk ml dn kt mm mn dp kx lm mo mp kz lo mq mr lb lq ms mt ld mu bi translated">我们为什么需要它？</h2><p id="801e" class="pw-post-body-paragraph mv mw iq lh b li lj jr mx lk ll ju my lm mz na nb lo nc nd ne lq nf ng nh ls ij bi translated">任何前端应用程序的基本构建块都是<em class="ni">组件</em>(它可以是react/angular/web组件或任何框架实现)。我们仍然可以将组件进一步分为<a class="ae no" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">表示组件和</a>容器组件。</p><p id="e455" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">为了给这些组件提供动力，我们需要用数据来推动它。数据在任何应用中都扮演着重要的角色。</p><h2 id="29ab" class="mj ko iq bd kp mk ml dn kt mm mn dp kx lm mo mp kz lo mq mr lb lq ms mt ld mu bi translated"><strong class="ak">现在的问题是我们需要如何管理数据？</strong></h2><p id="1230" class="pw-post-body-paragraph mv mw iq lh b li lj jr mx lk ll ju my lm mz na nb lo nc nd ne lq nf ng nh ls ij bi translated">由于组件相互组合以适应视图端口——如果我们管理组件内部的数据，我们可能会以<em class="ni">数据重复</em>而结束，并且整个应用程序数据可能<em class="ni">没有被规范化</em>并且我们无法获得应用程序状态的<em class="ni">全貌</em>。</p><p id="a081" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">解决方案是用一些经过验证的最佳实践和技术隔离应用程序数据——这是状态管理框架的唯一目的。</p><p id="10cd" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">市场上有许多状态管理框架，如Flux、Redux、Akita、NgRx、MobX等。</p><blockquote class="np nq nr"><p id="e968" class="mv mw ni lh b li nj jr mx lk nk ju my ns nl na nb nt nm nd ne nu nn ng nh ls ij bi translated">我们选择了Redux，因为状态管理工具的核心概念是通用的，它们的书面实现可能有所不同。</p></blockquote><h2 id="728b" class="mj ko iq bd kp mk ml dn kt mm mn dp kx lm mo mp kz lo mq mr lb lq ms mt ld mu bi translated">通过从头开始构建来学习Redux的核心概念</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi nv"><img src="../Images/8d3314c69fa885cc780d9021b9fae1c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BcmtHcMHN6PT7IniIWniHg.png"/></div></div><figcaption class="oa ob gj gh gi oc od bd b be z dk">Redux Core Concepts</figcaption></figure><p id="8b1e" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated"><strong class="lh ir">动作</strong> —动作是一个简单的老式JavaScript对象，指示需要对应用程序数据采取什么动作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="0c95" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">在大多数情况下，Action持有代表唯一动作类型的<code class="fe og oh oi oj b">type</code>,而<code class="fe og oh oi oj b">payload</code>携带附加数据以促进动作。</p><p id="c140" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated"><strong class="lh ir"> Reducer </strong> — Reducer是一个纯函数，它保存了处理各种动作指令的实现逻辑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="ab37" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">将当前状态和动作传递给reducer函数，将使用更新后的状态进行响应。因为它的纯函数——结果，将会被纯函数论元所表达。(即国家、行动)</p><p id="0b2e" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">存储(Store)—存储负责管理应用程序数据，它处理分派的动作——通过将数据传递给缩减器，并保持状态与注册的监听器同步。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="cc17" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">以上是Redux store的最小实现。Store将reducer和初始应用程序数据作为构造函数参数。我们有三种主要的存储方法。他们是，</p><ol class=""><li id="ba89" class="lf lg iq lh b li nj lk nk lm ok lo ol lq om ls lt lu lv lw bi translated"><strong class="lh ir">分派</strong> —帮助消费组件分派动作的方法。一旦一个动作被分派，存储将当前状态和动作传递给reducer并重新分配更新的状态。Dispatcher还遍历所有侦听器回调函数，并通知它们—状态发生了变化。</li><li id="67e1" class="lf lg iq lh b li lx lk ly lm lz lo ma lq mb ls lt lu lv lw bi translated"><strong class="lh ir"> getState </strong> —方法响应当前状态。</li><li id="4159" class="lf lg iq lh b li lx lk ly lm lz lo ma lq mb ls lt lu lv lw bi translated"><strong class="lh ir"> subscribe </strong> —方法帮助消费者注册回调，以便在状态改变时得到通知。</li></ol><blockquote class="np nq nr"><p id="dc01" class="mv mw ni lh b li nj jr mx lk nk ju my ns nl na nb nt nm nd ne nu nn ng nh ls ij bi translated">你可能想知道为什么<code class="fe og oh oi oj b">subscribe</code>函数不响应当前状态，因为<code class="fe og oh oi oj b">getState</code>和<code class="fe og oh oi oj b">subscribe</code>的目的是相互正交的。这里可以看到详细解释<a class="ae no" href="https://github.com/reduxjs/redux/issues/303#issuecomment-125184409" rel="noopener ugc nofollow" target="_blank"/></p></blockquote><p id="4d0d" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">如果您熟悉反应式扩展，我们已经用观察者模式编写了subscribe——Redux store也可以在RxJS API的帮助下编写。您可以在这里找到可观察的商店实现<a class="ae no" href="https://github.com/mohanramphp/redux-with-typescript/blob/master/src/redux/redux-observable.ts" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="87c3" class="mj ko iq bd kp mk ml dn kt mm mn dp kx lm mo mp kz lo mq mr lb lq ms mt ld mu bi translated">用Redux构建一个Todo应用程序，我们从头开始编写</h2><p id="c912" class="pw-post-body-paragraph mv mw iq lh b li lj jr mx lk ll ju my lm mz na nb lo nc nd ne lq nf ng nh ls ij bi translated">在我们使用任何状态管理工具开发web应用程序之前。最好按照下面的路线图，这将有助于流水线的发展。</p><ol class=""><li id="bf2e" class="lf lg iq lh b li nj lk nk lm ok lo ol lq om ls lt lu lv lw bi translated">定义应用数据的<strong class="lh ir">数据结构，不可能声明完整的框架。我同意，但是至少要根据你的用户界面使用计划来构建最小的结构。</strong></li><li id="902e" class="lf lg iq lh b li lx lk ly lm lz lo ma lq mb ls lt lu lv lw bi translated">定义将改变您的应用程序数据的<strong class="lh ir">动作</strong>。</li><li id="8e7d" class="lf lg iq lh b li lx lk ly lm lz lo ma lq mb ls lt lu lv lw bi translated">声明<strong class="lh ir"> Reducer </strong>函数，该函数将应用程序数据和动作作为输入，并以更新后的状态进行响应。</li><li id="072f" class="lf lg iq lh b li lx lk ly lm lz lo ma lq mb ls lt lu lv lw bi translated">通过传递减速器和初始应用数据创建<strong class="lh ir">存储</strong>。</li></ol><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="nw nx di ny bf nz"><div class="gh gi on"><img src="../Images/8566d2bff67002f07c0de5b250bc3c96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sM9kFZ_lgYQrVBgagir0Hw.png"/></div></div></figure><p id="bde4" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">让我们启动todo应用程序，同时考虑用于Todo管理的应用程序数据。我脑海中出现的大致情况是</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="8fd6" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">有了这个想法——让我们看看todo <strong class="lh ir">模型</strong>和todo <strong class="lh ir">应用程序状态</strong></p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="cb17" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">让我们重复驱动我们的应用程序所需的动作。</p><ol class=""><li id="58c2" class="lf lg iq lh b li nj lk nk lm ok lo ol lq om ls lt lu lv lw bi translated">添加待办事项</li><li id="c3a5" class="lf lg iq lh b li lx lk ly lm lz lo ma lq mb ls lt lu lv lw bi translated">删除待办事项</li><li id="d68f" class="lf lg iq lh b li lx lk ly lm lz lo ma lq mb ls lt lu lv lw bi translated">将待办事项切换为完成/未完成</li></ol><p id="6ae7" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">让我们定义下面的动作，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="883f" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated"><strong class="lh ir">动作创建者</strong>——是帮助定义或框定动作对象的人。例如，— <code class="fe og oh oi oj b">AddTodoAction</code>帮助创建一个添加待办事项动作，动作创建者的目的是删除动作对象属性的重复声明。</p><p id="5e26" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">例如，如果我们需要为todo动作添加<code class="fe og oh oi oj b">createdAt</code>属性，假设动作创建者不在那里，那么我们需要在调度动作的任何地方将其声明为动作对象。</p><p id="1a4c" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">让我们声明reducer逻辑来处理这些声明的动作。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="01af" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">让我们实例化我们的存储，</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="ab51" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">最终的DOM实现——使数据从存储区适合视图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="cc3b" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated"><code class="fe og oh oi oj b">todoListElem</code>、<code class="fe og oh oi oj b">addButtonElem </code>和<code class="fe og oh oi oj b">todoInputElem </code>是在Typescript中捕获的用于处理视图的DOM节点。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="oe of l"/></div></figure><p id="6508" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">我们使用store的<code class="fe og oh oi oj b">subscribe</code>函数来重新绘制视图，使用<code class="fe og oh oi oj b">dispatch</code>函数来调度我们声明的动作。</p><p id="b57c" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">浏览代码——应该是不言自明的。</p><h2 id="0e96" class="mj ko iq bd kp mk ml dn kt mm mn dp kx lm mo mp kz lo mq mr lb lq ms mt ld mu bi translated">结论</h2><ul class=""><li id="3738" class="lf lg iq lh b li lj lk ll lm ln lo lp lq lr ls oo lu lv lw bi translated">Redux是最佳实践和模式的集合，它帮助我们以高效的方式管理应用程序数据。</li><li id="fdd4" class="lf lg iq lh b li lx lk ly lm lz lo ma lq mb ls oo lu lv lw bi translated">动作、缩减器、存储是任何状态管理框架的核心基础部分。</li><li id="b264" class="lf lg iq lh b li lx lk ly lm lz lo ma lq mb ls oo lu lv lw bi translated">可以找到完整的源代码和<a class="ae no" href="https://mohanramphp.github.io/redux-with-typescript/" rel="noopener ugc nofollow" target="_blank">现场演示</a></li></ul><p id="1bab" class="pw-post-body-paragraph mv mw iq lh b li nj jr mx lk nk ju my lm nl na nb lo nm nd ne lq nn ng nh ls ij bi translated">如果你喜欢这篇文章或有任何问题，请随时留下评论！🤓</p><div class="op oq gp gr or os"><a href="https://github.com/mohanramphp/redux-with-typescript" rel="noopener  ugc nofollow" target="_blank"><div class="ot ab fo"><div class="ou ab ov cl cj ow"><h2 class="bd ir gy z fp ox fr fs oy fu fw ip bi translated">mohanramphp/redux-with type script</h2><div class="oz l"><h3 class="bd b gy z fp ox fr fs oy fu fw dk translated">使用TypeScript从头构建Redux数据架构模式-mohanramphp/Redux-with-TypeScript</h3></div><div class="pa l"><p class="bd b dl z fp ox fr fs oy fu fw dk translated">github.com</p></div></div><div class="pb l"><div class="pc l pd pe pf pb pg kl os"/></div></div></a></div></div></div>    
</body>
</html>