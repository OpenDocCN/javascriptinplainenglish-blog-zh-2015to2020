<html>
<head>
<title>Typesafe runtime checks against TypeScript interface property names</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Typesafe运行时根据TypeScript接口属性名称进行检查</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/typesafe-checks-against-typescript-interface-property-names-at-runtime-ef2f953a7b6d?source=collection_archive---------4-----------------------#2020-07-26">https://javascript.plainenglish.io/typesafe-checks-against-typescript-interface-property-names-at-runtime-ef2f953a7b6d?source=collection_archive---------4-----------------------#2020-07-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="55c7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用TypeScript，接口只存在于开发期间。尽管如此，有时我们可能希望在运行时引用接口属性名。那我们能做什么？</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/aed64ce884b654d2b7fe08b628d15bdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/format:webp/1*RmhCkNR30Ecf6xox3GrOlw.png"/></div></figure><p id="c5d8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将分享一个既酷又安全的技巧，以便能够在运行时引用接口属性名；也就是说，在TS编译器删除了我们接口的所有痕迹之后很久。</p><h1 id="a3aa" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">TypeScript接口消失</h1><p id="52c4" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">TypeScript接口棒极了。厉害到运行时都不存在。</p><p id="4ad6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">虽然这对于应用程序的包的重量来说很好(您可以在不影响包大小的情况下尽可能多地使用类型)，但有时这很烦人，因为我们仍然希望能够引用其中的一些类型。泛型也是如此，但那是另一个故事了！</p><p id="ac39" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，您可能希望对JSON数据进行运行时验证，以确保<a class="ae lw" href="https://medium.com/@dSebastien/input-validation-with-nestjs-7184ba81af7e" rel="noopener">输入确实符合您的期望</a>。</p><p id="6543" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我不会深入探究接口“为什么”消失的细节，而是将重点放在如何执行在编译时验证的强类型运行时检查，以及如何防止重构。</p><h1 id="531f" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">一个具体的用例</h1><p id="328e" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在我的上一篇文章中，我基于我上周的工作讨论了<a class="ae lw" href="https://medium.com/@dSebastien/input-validation-with-nestjs-7184ba81af7e" rel="noopener">输入验证</a>。在为我当前的项目集成输入验证时，我需要处理部分更新。</p><p id="7a10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">根据定义，部分更新(通常通过HTTP POST或PATCH请求发送)通常只包含应该在服务器端更新的数据的子集。部分更新请求可能包含一个或多个要更新的字段。当然，如果一个给定的字段存在，那么它需要被正确地验证。</p><p id="cb8c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过<a class="ae lw" href="https://medium.com/@dSebastien/input-validation-with-nestjs-7184ba81af7e" rel="noopener">第一层输入验证</a>后，我的REST控制器发送<a class="ae lw" href="https://docs.nestjs.com/recipes/cqrs" rel="noopener ugc nofollow" target="_blank"> CQRS命令</a>，这些命令由命令处理程序负责。</p><p id="a154" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该命令处理器接收部分更新数据，并且必须验证每个字段。在我的例子中，接收到的部分更新是基于如下所示的自定义类型:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lx ly l"/></div></figure><p id="cb3d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，一个更新对象可能包含任何字段，这取决于<code class="fe lz ma mb mc b">T</code>被设置为什么。在这种情况下，类型实际上是一个<code class="fe lz ma mb mc b">PartialUpdate&lt;MeetingDto&gt;</code>。为了举例，我们假设<code class="fe lz ma mb mc b">MeetingDto</code>只有以下属性:<code class="fe lz ma mb mc b">A</code>、<code class="fe lz ma mb mc b">B</code>和<code class="fe lz ma mb mc b">C</code>。</p><p id="7d43" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在伪代码中，我的目标是做以下事情:</p><pre class="km kn ko kp gt md mc me mf aw mg bi"><span id="9c11" class="mh ku iq mc b gy mi mj l mk ml">for each(property of partialUpdateObject) {<br/>  // if property A of PartialUpdate&lt;MeetingDto&gt; is defined<br/>    // then perform validations for A<br/>  // ...<br/>}</span></pre><p id="b886" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者，我可以为每个属性写大量的if检查，但是我可能会漏掉一些；我更喜欢循环播放在场的人。</p><h1 id="041a" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">天真的实现</h1><p id="c222" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">解决方案的最简单表达如下:</p><pre class="km kn ko kp gt md mc me mf aw mg bi"><span id="532a" class="mh ku iq mc b gy mi mj l mk ml">for (const propertyKey of <strong class="mc ir"><em class="mm">Object</em></strong>.keys(command.update)) {<br/>  if("A" === propertyKey) {<br/>    // perform validations for A<br/>  }<br/>}</span></pre><p id="c602" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是如果你像我一样，那么你可能也不会喜欢这样做。你能看出问题吗？对于JS开发人员来说，这可能无关紧要，但是对于喜欢强类型的人来说，这完全是异端邪说。如果“A”属性曾经被重构/重命名；那么这段代码会立即中断，这就不好了。</p><p id="f968" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们能做些什么呢？</p><h1 id="9cb3" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">更清洁的解决方案</h1><p id="5150" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">幸运的是，由于<a class="ae lw" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html" rel="noopener ugc nofollow" target="_blank"> TypeScript 2.1 </a>，我们可以使用<code class="fe lz ma mb mc b">keyof</code>关键字，也称为索引类型查询。使用<code class="fe lz ma mb mc b">keyof</code>，我们可以获得类型<code class="fe lz ma mb mc b">T</code>允许的属性名类型:</p><pre class="km kn ko kp gt md mc me mf aw mg bi"><span id="d7dc" class="mh ku iq mc b gy mi mj l mk ml">type PartialUpdateKeys = keyof PartialUpdate&lt;MeetingDto&gt;; // "A" | "B" | "C" | ...</span></pre><p id="6f05" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们快到了。现在的诀窍是将泛型与<code class="fe lz ma mb mc b">keyof</code>结合起来，使属性名具有强类型，同时仍然能够在运行时与那些属性名进行比较。</p><p id="bc1c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以通过以下自定义类型来实现这一点:</p><pre class="km kn ko kp gt md mc me mf aw mg bi"><span id="d0aa" class="mh ku iq mc b gy mi mj l mk ml">export const propertyOf = &lt;SomeType&gt;(name: keyof SomeType) =&gt; name;</span></pre><p id="7530" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的表达式中，使用<code class="fe lz ma mb mc b">propertyOf</code>时传递的泛型类型与<code class="fe lz ma mb mc b">keyof</code>结合使用，以确保传入的值确实是该类型的有效属性名。最后，在输出中返回传入的名称。</p><p id="8d61" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过使用这个，我们确实可以在运行时引用已知有效的属性名，即使接口已经不存在了。</p><p id="6bbb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是如何使用的:</p><pre class="km kn ko kp gt md mc me mf aw mg bi"><span id="6eee" class="mh ku iq mc b gy mi mj l mk ml">if(propertyOf&lt;PartialUpdate&lt;MeetingDto&gt;&gt;("A") === propertyKey) {<br/>  // do something<br/>}</span></pre><p id="4ece" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这已经感觉更干净(也更安全！).</p><p id="2af7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在还有另一种变体可以使代码可读性稍微好一点:</p><pre class="km kn ko kp gt md mc me mf aw mg bi"><span id="67d6" class="mh ku iq mc b gy mi mj l mk ml">export const propertiesOf = &lt;SomeType&gt;() =&gt; &lt;T extends keyof SomeType&gt;(name: T): T =&gt; name;</span></pre><p id="dced" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该变体可以如下使用:</p><pre class="km kn ko kp gt md mc me mf aw mg bi"><span id="4017" class="mh ku iq mc b gy mi mj l mk ml">const meetingUpdateProperties = propertiesOf&lt;PartialUpdate&lt;MeetingDto&gt;();<br/>...</span><span id="8668" class="mh ku iq mc b gy mn mj l mk ml">if(meetingUpdateProperties("A") === propertyKey) {<br/>  // ...<br/>}</span></pre><p id="c78a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我在StackOverflow上找到了这个技巧:<a class="ae lw" href="https://stackoverflow.com/questions/33547583/safe-way-to-extract-property-names" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/33547583/safe-way-to-extract-property-names</a></p><h1 id="8e33" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h1><p id="4d0d" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">在本文中，我解释了如何针对接口属性名实现安全的运行时属性名检查，即使那些接口在那个时候早已不存在了。</p><p id="d8b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从类型安全的角度来看，这很适合我，使用起来也很安全；那么我们还能要求什么呢？</p><p id="7b70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我很好奇你是否知道其他/更好/更安全的替代方案！</p><p id="ed7d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天到此为止！</p><h1 id="320e" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">喜欢这篇文章吗？</h1><p id="db6a" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">如果你想了解关于软件/Web开发、TypeScript、Angular、React、Vue、Kotlin、Java、Docker/Kubernetes和其他很酷的主题的大量其他很酷的东西，那么不要犹豫<a class="ae lw" href="https://www.amazon.com/Learn-TypeScript-Building-Applications-understanding-ebook/dp/B081FB89BL" rel="noopener ugc nofollow" target="_blank">拿一本我的书</a>并订阅<a class="ae lw" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">我的简讯</a>！</p><h2 id="7dfa" class="mh ku iq bd kv mo mp dn kz mq mr dp ld jy ms mt lh kc mu mv ll kg mw mx lp my bi translated">简单英语的JavaScript</h2><p id="f111" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae lw" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="jp ir">！</strong></p></div></div>    
</body>
</html>