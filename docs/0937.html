<html>
<head>
<title>The Composite Pattern — Design Patterns Meet the Frontend</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">复合模式——设计模式满足前端</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-composite-pattern-design-patterns-meet-the-frontend-2d17e9cf2f58?source=collection_archive---------3-----------------------#2020-01-04">https://javascript.plainenglish.io/the-composite-pattern-design-patterns-meet-the-frontend-2d17e9cf2f58?source=collection_archive---------3-----------------------#2020-01-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/e4447fb06c977cedc33b37c521c7c4f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UiHBunybxap2RRz0f30dCA.jpeg"/></div></div></figure><p id="fe79" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">复合设计模式是一种具有递归性质的结构设计模式。在这篇文章中，我们将深入研究它，希望我们不会重复自己太多。</p><p id="f8d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将讨论几件事情:</p><ul class=""><li id="b52f" class="kw kx iq ka b kb kc kf kg kj ky kn kz kr la kv lb lc ld le bi translated">这是什么？🤔</li><li id="e4da" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">让我们看一个例子🚀</li><li id="89e3" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">我们为什么需要它？😐</li><li id="a5fe" class="kw kx iq ka b kb lf kf lg kj lh kn li kr lj kv lb lc ld le bi translated">让我们看看一些代码！👩‍💻</li></ul><h1 id="fd58" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">这是什么？🤔</h1><p id="8afe" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">复合设计模式是一种结构化设计模式，用于表示数据并将系统中的对象组合成树状结构。</p><p id="d4d8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了理解这种模式是如何工作的，有必要对高层次的概念进行描述。<br/>在我们的系统中，我们将拥有单个对象或复合对象。</p><p id="d86b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mn">单个对象</em>可以被认为是独立的对象，它们将实现与预定义契约相匹配的类似行为。</p><p id="3eea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mn">复合对象</em>由单个对象和/或其他复合对象组成。</p><p id="2a56" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">🤯困惑了吗？</p><p id="5cbf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们把它分解一下。假设我们在商店买了一台打印机。它装在盒子里。当我们打开盒子时，我们看到盒子里有一台打印机，但旁边还有一个盒子。此包装盒包含打印机的电源线和USB适配器。</p><p id="5cc7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以认为打印机本身是一个单一的物体，而盒子是一个复合物体。它<strong class="ka ir">有一个</strong>打印机，它<strong class="ka ir">有另一个</strong>盒子。这个<strong class="ka ir">嵌套的</strong>盒子<strong class="ka ir">有一根</strong>电源线和一个USB适配器，两者都是单个物体，使这个盒子成为一个复合物体。</p><p id="1031" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望这已经使概念更加清晰！☀️</p><p id="00af" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后，这种结构允许我们通过单一的公共接口递归地遍历树，因为它允许我们一致地对待单一对象和对象的组合。</p><h1 id="994e" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">让我们看一个例子🚀</h1><p id="0f66" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">理解这种模式的最好方法肯定是看一个例子。</p><p id="114d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们想象一个假想的任务运行者。🤖</p><p id="6bbc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们向这个任务运行者提供一组<code class="fe mo mp mq mr b">Task Instructions</code>。但是每个<code class="fe mo mp mq mr b">Task Instruction</code>可能有<code class="fe mo mp mq mr b">Sub Task Instructions</code>，每个<code class="fe mo mp mq mr b">Sub Task Instruction</code>可能有自己的<code class="fe mo mp mq mr b">Sub Task Instructions</code>。</p><p id="b8b5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经可以看到，这有可能成为一个递归结构。</p><p id="6f02" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不一定希望任务运行程序在每次执行每个<code class="fe mo mp mq mr b">Instruction</code>时都必须检查它是<code class="fe mo mp mq mr b">Composite Instruction Set</code>还是<code class="fe mo mp mq mr b">Single Instruction</code>。</p><p id="1bcc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b">Composite Instruction Set</code>应该包含任务运行者不需要知道的<code class="fe mo mp mq mr b">Composite Instruction Set</code>或<code class="fe mo mp mq mr b">Single Instruction</code>的子节点列表。</p><p id="847c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因此，为了解决这个问题，我们将定义一个公共的<code class="fe mo mp mq mr b">Instruction</code>接口，包含一个由<code class="fe mo mp mq mr b">Composite Instruction Set</code>和<code class="fe mo mp mq mr b">Single Instruction</code>实现的<code class="fe mo mp mq mr b">execute()</code>方法。</p><p id="ab15" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">任务运行器将遍历调用<code class="fe mo mp mq mr b">execute()</code>方法的<code class="fe mo mp mq mr b">Instructions</code>列表。</p><p id="045b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe mo mp mq mr b">Single Instructions</code>将执行他们的定制逻辑，而<code class="fe mo mp mq mr b">Composite Instruction Sets</code>将遍历他们的子节点并调用他们的<code class="fe mo mp mq mr b">execute()</code>方法。</p><p id="9d9b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">他们不需要知道他们的孩子是<code class="fe mo mp mq mr b">Composite</code>还是<code class="fe mo mp mq mr b">Single Instructions</code>，任务运行者也不需要知道它需要运行的<code class="fe mo mp mq mr b">Instructions</code>的具体构成，这允许了很大的灵活性！</p><p id="d355" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是说明上述示例的图表:</p><figure class="mt mu mv mw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ms"><img src="../Images/f281c57c3e29ac23b89147a17efb9390.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*JT33J2cSqbYMIbtJ.png"/></div></div></figure><h1 id="4b18" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">我们为什么需要它？😐</h1><p id="9703" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">当我们拥有具有相似行为的不同类型的对象或者包含具有相似行为的子对象时，核心问题就出现了。</p><p id="cf7b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在运行所需的逻辑之前进行类型检查是不可取的，因为这将迫使客户端代码与它正在处理的对象的结构紧密耦合，如果需要的话，可能会遍历子对象。</p><p id="ed81" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">相反，我们希望我们的对象本身知道它们自己的逻辑需要什么来执行手边的操作，从而允许我们递归地遍历树状结构，而不需要担心树中的每个叶节点是什么类型。</p><h1 id="5597" class="lk ll iq bd lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh bi translated">让我们看看一些代码！👩‍💻</h1><p id="527a" class="pw-post-body-paragraph jy jz iq ka b kb mi kd ke kf mj kh ki kj mk kl km kn ml kp kq kr mm kt ku kv ij bi translated">以上面的任务运行器为例，让我们把它写成代码。</p><p id="13f7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要一个接口来定义<code class="fe mo mp mq mr b">Single Instructions</code>和<code class="fe mo mp mq mr b">Composite Instructions</code>之间的共同行为。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="03b2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">既然我们已经定义了接口，我们将定义我们的<code class="fe mo mp mq mr b">SingleInstruction</code>和<code class="fe mo mp mq mr b">CompositeInstructionSet</code>类。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="c841" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望我们的<code class="fe mo mp mq mr b">SingleInstructions</code>具有灵活性和可扩展性，允许开发人员创建任务运行者能够理解的定制指令。</p><p id="a6ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如，让我们创建一个总是<code class="fe mo mp mq mr b">return true</code>的日志记录指令，但是输出一个日志。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="e2aa" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在我们已经定义了任务指令的结构，让我们创建任务运行器本身。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="685f" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就这么简单！任务运行程序不需要知道或关心它处理的是什么类型的指令，只要它能调用它的<code class="fe mo mp mq mr b">execute()</code>方法，将繁重的工作交给指令本身！</p><p id="07fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们看看实际运行的代码。</p><figure class="mt mu mv mw gt jr"><div class="bz fp l di"><div class="mx my l"/></div></figure><p id="f7d9" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望看到这段代码后，这种特殊设计模式的威力更加突出！从购物车到递送包含包裹的包裹，它可用于所有方式的树状数据系统！</p><p id="ce60" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">是不是很牛逼！🚀🚀🚀</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="d593" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">希望你多学了一点(<em class="mn">？</em>)关于复合花纹出自这篇文章。</p><p id="da82" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果有任何问题，欢迎在下面提问或在Twitter上联系我:<a class="ae ng" href="https://twitter.com/FerryColum" rel="noopener ugc nofollow" target="_blank"> @FerryColum </a>。</p></div><div class="ab cl mz na hu nb" role="separator"><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne nf"/><span class="nc bw bk nd ne"/></div><div class="ij ik il im in"><p id="40d2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="mn">原载于2020年1月4日</em><a class="ae ng" href="https://dev.to/coly010/the-composite-pattern-design-patterns-meet-the-frontend-445e" rel="noopener ugc nofollow" target="_blank"><em class="mn">https://dev . to</em></a><em class="mn">。</em></p></div></div>    
</body>
</html>