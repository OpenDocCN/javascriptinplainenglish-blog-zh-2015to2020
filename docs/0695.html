<html>
<head>
<title>Creating a Singleton in JavaScript with Angular</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Angular在JavaScript中创建单例</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/singleton-design-patterns-meet-the-frontend-d06bdcf1ee14?source=collection_archive---------2-----------------------#2019-11-27">https://javascript.plainenglish.io/singleton-design-patterns-meet-the-frontend-d06bdcf1ee14?source=collection_archive---------2-----------------------#2019-11-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="23e5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">设计模式符合前端</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1ad663c82cb4777459b0eebf4286324e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eg8egGDRuNIahap_.jpg"/></div></div></figure><p id="e866" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">作为一名棱角分明的开发者，我每天都在处理单个的<code class="fe ln lo lp lq b">Injectables</code>形状。然而，当我坐下来写关于单身族的文章时，我又看了一眼。</p><p id="c740" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lr">注意:本文中的代码示例将使用</em><a class="ae ls" href="http://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"><em class="lr">TypeScript(3.7)</em></a><em class="lr">，最后两个示例将使用Java。</em></p><p id="101c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们把它分成几个问题:</p><ul class=""><li id="81bc" class="lt lu iq kt b ku kv kx ky la lv le lw li lx lm ly lz ma mb bi translated">🤔什么构成了独生子女？</li><li id="4fe3" class="lt lu iq kt b ku mc kx md la me le mf li mg lm ly lz ma mb bi translated">❓:为什么它们用在有棱角的地方？</li><li id="778a" class="lt lu iq kt b ku mc kx md la me le mf li mg lm ly lz ma mb bi translated">😍我们从单身族身上得到了什么优势？</li><li id="e349" class="lt lu iq kt b ku mc kx md la me le mf li mg lm ly lz ma mb bi translated">📣为什么会有关于它们是否是反模式的争论？</li></ul><p id="90cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这篇文章中，我将试图阐明其中的一些问题。</p><h1 id="495f" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">🤔什么构成了独生子女？</h1><p id="f623" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">我们将从单体的定义开始:</p><blockquote class="ne nf ng"><p id="5e7c" class="kr ks lr kt b ku kv jr kw kx ky ju kz nh lb lc ld ni lf lg lh nj lj lk ll lm ij bi translated"><em class="iq">类的实例化对单个实例的限制。</em></p></blockquote><p id="778b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">换句话说，任何时候我们实例化一个类，我们都只能得到该类的第一个实例。这些单件可以实现接口，作为参数传递给方法，并且可以是多态的T21。</p><p id="35ef" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，每次我们使用该类时，它将是我们第一次创建的同一个对象。下面的代码示例可能更能说明这种情况:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="586e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就是这样！创建单例就是这么简单！🔥🔥🔥</p><p id="24e7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是这到底是什么意思呢？这将如何影响我们的程序设计，我们在其中找到了价值？</p><p id="ca53" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">好吧，单例可以用来存储共享状态。你可以在你的应用中实例化你的Singleton，改变其中的一些数据，它会在你的应用中得到反映。</p><p id="ed96" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你不仔细考虑，⚠️这样做可能会有危险！</p><p id="176d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们修改上面的示例来说明这一点:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="7e29" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上述示例的结果是:</p><pre class="kg kh ki kj gt nm lq nn no aw np bi"><span id="5aa9" class="nq mi iq lq b gy nr ns l nt nu">Hi, my name is John <br/>Hi, my name is John</span></pre><p id="115e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">🤔🤔但是我们不是把<code class="fe ln lo lp lq b">myService.user</code>设置成了一个<code class="fe ln lo lp lq b">Colum</code>的名字吗？</p><p id="b017" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是的，但那是在我们将<code class="fe ln lo lp lq b">differentService.user</code>命名为<code class="fe ln lo lp lq b">John</code>之前。</p><p id="9ff4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这样做，由于<code class="fe ln lo lp lq b">UserService</code>只能有一个实例，我们实际上将<em class="lr">单个</em> <code class="fe ln lo lp lq b">user</code>对象的名称从<code class="fe ln lo lp lq b">Colum</code>改为<code class="fe ln lo lp lq b">John</code>。</p><p id="5f20" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种能够共享状态的想法有时非常有用，例如，如果您想要跟踪当前登录的用户。</p><p id="fa18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单例可以延迟加载，这可能会提高应用程序的启动性能，但是，在多线程语言中，延迟加载单例的实现可能会导致跨多线程的多个实例化问题，如果没有声明跨线程同步，则会破坏模式。</p><h1 id="2998" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">❓:那么，它们为什么用在有棱角的地方呢？</h1><p id="174c" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">Angular的<a class="ae ls" href="https://angular.io/guide/dependency-injection" rel="noopener ugc nofollow" target="_blank">依赖注入</a>依赖<code class="fe ln lo lp lq b">Injectables</code>。依赖注入本身也是一种设计模式，但是它在这里是相关的，因为在这个上下文中，它使用了单例模式。</p><p id="4cca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Angular应用程序通常包含多个模块(<code class="fe ln lo lp lq b">NgModules</code>)，但至少有一个根模块，其中包含应用程序所需的列表。然后将它们注入到需要它们的类中。</p><p id="0bc4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们来看一个寻找一个<code class="fe ln lo lp lq b">LogService</code>注入其中的角形组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="6ff2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">首先，我们组件的<code class="fe ln lo lp lq b">constructor</code>接受了一个<code class="fe ln lo lp lq b">LogService</code>类型的参数。<br/>其次，在没有创建这个类的实例的情况下，我们在我们的<code class="fe ln lo lp lq b">ngOnInit()</code>方法中使用它。这是因为Angular将实例化这个类，将它保存在内存中，并将其传递给任何需要它的类。</p><p id="5050" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过这样做，Angular也利用了Singleton模式，因为它只实例化一个模块的提供者一次，并将对这个实例的引用传递给依赖它的任何类。</p><h1 id="eea3" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">😍我们从单身族身上得到了什么优势？</h1><p id="384d" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">如前所述，我们可以通过使用Singleton模式与应用程序中的不同区域共享状态，在Angular中，由于依赖注入系统，这变得更加简单。</p><p id="0631" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有些用例涉及对数据存储的单一访问、跟踪购物车中的活动商品、单一真实来源等。</p><p id="27fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">⚠️ <em class="lr">请注意，单身族并不打算取代你正在使用的任何国家管理系统。</em></p><p id="d344" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，它还允许我们创建逻辑服务，这是一类可以在多种情况下重用以提供相同逻辑的方法，可以只实例化一次，有助于提高代码的可重用性和可维护性，而不会对内存使用或应用程序的性能产生很大影响。</p><p id="e28b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这些用例是调用API端点的数据服务，这些服务将基于传递给它们的方法的参数做出并返回决策。</p><h1 id="6cbf" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">📣为什么会有关于它们是否是反模式的争论？</h1><p id="dba0" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">有一种观点认为，通过积极地违反依赖倒置(DI)原则，单例在代码中促进了糟糕的设计。在构造函数中接受接口作为参数的类，可以简单地接受一个常量/最终实例化对象作为参数。</p><p id="d5b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这种争论通常来自使用强类型语言的开发人员，或者当他们完全控制他们的DI系统时。请参见下面的Java示例，以了解更多信息:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="1180" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们从上面所看到的，开发人员完全控制着应用程序的结构，可以自己决定他们想要使用的接口的实现，可以在应用程序启动时初始化它们，并将它们传递给相关的类。</p><p id="c102" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果这里要使用Singleton模式，那么只能使用数据服务的一种可能的实现。请参见下面代码中的变化:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk nl l"/></div></figure><p id="a09b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">虽然上面的代码可能更小，但它确实打破了依赖倒置原则，并在依赖单例的类和单例本身之间创建了更紧密的耦合。</p><h1 id="6a95" class="mh mi iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">然而❗❗❗</h1><p id="3bb3" class="pw-post-body-paragraph kr ks iq kt b ku mz jr kw kx na ju kz la nb lc ld le nc lg lh li nd lk ll lm ij bi translated">值得注意的是，Angular通过使用<a class="ae ls" href="https://angular.io/guide/dependency-injection-in-action#supply-a-custom-provider-with-inject" rel="noopener ugc nofollow" target="_blank">注入令牌</a>解决了这个问题，这是一个稍微高级一点的话题。它允许您在NgModule级别提供具体的实现，而不是将您的组件和服务耦合到您的Singletons。<br/>🚀🚀🚀</p><p id="d07e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">希望你多学了一点(<em class="lr">？</em>)关于本文中的单件，它们的一些用例以及它们在Angular中的实现。</p><p id="1630" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如有任何问题，欢迎在下方提问或在Twitter上联系我:<a class="ae ls" href="https://twitter.com/FerryColum" rel="noopener ugc nofollow" target="_blank"> @FerryColum </a>。</p></div><div class="ab cl nv nw hu nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ij ik il im in"><p id="b004" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lr">原发布于2019年11月27日</em><a class="ae ls" href="https://dev.to/coly010/singleton-design-patterns-meet-the-frontend-12m1" rel="noopener ugc nofollow" target="_blank"><em class="lr">https://dev . to</em></a><em class="lr">。</em></p></div></div>    
</body>
</html>