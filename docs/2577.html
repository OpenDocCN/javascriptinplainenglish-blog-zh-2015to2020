<html>
<head>
<title>Inside PixiJS’s Projection System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">PixiJS的投影系统内部</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/inside-pixijs-projection-system-897872a3dc17?source=collection_archive---------6-----------------------#2020-07-06">https://javascript.plainenglish.io/inside-pixijs-projection-system-897872a3dc17?source=collection_archive---------6-----------------------#2020-07-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6eee" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">以及如何优化你的场景图！</h2></div><p id="93f8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">投影矩阵允许你定义从你的“世界”到“画布”的一部分的转换。是的，你的场景图形生活在它自己的“世界”中，你可以移动它在画布上呈现的位置，而与你的世界中的对象是否移动无关。</p><p id="5acd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，为显示对象设置的位置与画布坐标相关。换句话说，“世界”和“画布”是相同的。然而，更灵活的模式是两者独立。</p><p id="62d7" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">想象一个无限的平面，用一个点设定“原点”，用一个网格以像素为单位测量物体。你的场景图存在于这个2D“世界平面”上，你从这个世界(源帧)渲染一个矩形，投影到画布上的一个矩形(目的帧)。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/ce9669484e80875f88d3f9954c0e8c31.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oIjxJazEEZo6Cjp1OY1zVg.png"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Projecting a world with blocks of text upscaled onto the user’s screen</figcaption></figure><blockquote class="lr ls lt"><p id="9548" class="kf kg lu kh b ki kj jr kk kl km ju kn lv kp kq kr lw kt ku kv lx kx ky kz la ij bi translated">你正在阅读PixiJS: WebGL渲染器中的<a class="ae ly" href="/@sukantk3.4/inside-pixijs-webgl-renderer-eca3357ad7f5" rel="noopener ugc nofollow" target="_blank">一章。</a></p><p id="a823" class="kf kg lu kh b ki kj jr kk kl km ju kn lv kp kq kr lw kt ku kv lx kx ky kz la ij bi translated">注意:本文包含的内容对于5.3.1之前的PixiJS版本可能不稳定！将投影变换与修改渲染纹理绑定但不支持源帧和目标帧的插件一起使用可能会有问题。</p></blockquote><h1 id="c00a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">源帧→目标帧</h1><p id="e388" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">渲染纹理系统提供了基本的源帧到目标帧的转换。渲染纹理的绑定设置两个帧。如果没有提供，两个框架都默认为画布的尺寸。</p><blockquote class="lr ls lt"><p id="6fa8" class="kf kg lu kh b ki kj jr kk kl km ju kn lv kp kq kr lw kt ku kv lx kx ky kz la ij bi translated">屏幕上的画布本身就是一个<code class="fe mw mx my mz b">null</code>渲染纹理。</p></blockquote><p id="367f" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用<code class="fe mw mx my mz b">bind</code>方法传递您的帧:</p><pre class="lc ld le lf gt na mz nb nc aw nd bi"><span id="bd9d" class="ne ma iq mz b gy nf ng l nh ni">renderer.renderTexture.bind(null, sourceFrame, destinationFrame);</span></pre><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">WorldContainer demo</figcaption></figure><p id="cfbe" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的例子通过将画布渲染纹理绑定到矩形<code class="fe mw mx my mz b">(0,0,200,200)</code>中的渲染内容到矩形<code class="fe mw mx my mz b">(200,150,400,300)</code>来渲染画布中间的<code class="fe mw mx my mz b">WorldContainer</code>内容。</p><p id="70ea" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通过设置源帧和目标帧，可以实现两种类型的变换:</p><ul class=""><li id="c10d" class="nl nm iq kh b ki kj kl km ko nn ks no kw np la nq nr ns nt bi translated">平移:矩形的(<em class="lu"> x，y </em>)坐标之间的差异决定了移动或平移。这里,( 0，0)处的内容被转换为(200，150)</li><li id="da2a" class="nl nm iq kh b ki nu kl nv ko nw ks nx kw ny la nq nr ns nt bi translated">比例:宽度<em class="lu"> w </em>和高度<em class="lu"> h </em>的比值决定了水平和垂直比例。内容在两个方向上都升级了2倍。</li></ul><h2 id="f355" class="ne ma iq bd mb nz oa dn mf ob oc dp mj ko od oe ml ks of og mn kw oh oi mp oj bi translated">sourceFrame和destinationFrame提供的剪辑</h2><p id="cdfd" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">设置源帧确保<em class="lu">源帧之外的任何内容都不会被绘制到画布</em>。类似地，设置目标帧确保<em class="lu">画布上目标帧之外的任何内容都不会被修改</em>。</p><p id="76d9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用这些保证在画布的不同部分(甚至是渲染纹理)分别渲染多个窗格。</p><h1 id="8954" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">投影变换</h1><p id="8f31" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">您可以提供一个附加的变换来应用于“世界”中的顶点。这是使用投影系统的<code class="fe mw mx my mz b">transform</code>属性设置的，当您提供添加旋转或倾斜效果时非常方便。</p><p id="e3f9" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此变换在源帧到目标帧变换之前应用于顶点。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="88b2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的例子通过计算一个每帧旋转增加的投影变换来旋转场景图形。</p><h1 id="5365" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">摄影机</h1><p id="dd12" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">投影技术是对基于动态摄像机或侧滚场景图形的优化。想法是显示对象本身不移动，因此，它们的世界变换/边界不在每一帧重新计算。</p><p id="7a6c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的是，投影场景和<code class="fe mw mx my mz b">app.stage</code>场景是分开的。在前面显示的例子中，<code class="fe mw mx my mz b">WorldContainer</code>没有将其内容添加到子容器中——这是为了使世界的变换不会影响内容的变换，而是希望投影内容，使它们出现在与世界容器相同的位置。然而，这有效地在世界容器边界将显示对象树分成两个场景图。</p><p id="95c8" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的笔是一个简单的例子，它展示了你可以投影一个显示对象的子树，使它们出现在摄像机的边界内。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><p id="3f5a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">蓝色背景不会投影，而白色背景中的“hello world”文本会投影。请注意旋转后白色矩形是如何裁剪到源帧(或相机的边界)的。</p><p id="c50c" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">本例中实际上有两个独立的运动:</p><ol class=""><li id="dd0d" class="nl nm iq kh b ki kj kl km ko nn ks no kw np la ok nr ns nt bi translated">世界摄像机本身在做圆周运动</li><li id="91e9" class="nl nm iq kh b ki nu kl nv ko nw ks nx kw ny la ok nr ns nt bi translated">世界的内容和背景围绕着它们的中心旋转。但是，由于投影的原因，只有内容被剪切到相机的边界。</li></ol><h1 id="e662" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">有什么好处？</h1><p id="7a15" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">量化优化的好处并将其与其他成本进行平衡总是一个好主意。当使用投影矩阵渲染一个相当简单的大约50K矩形的场景图形时，下面的笔展示了大约10 FPS (+30%)的改进。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="nj nk l"/></div></figure><h1 id="dd0e" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">插件支持</h1><p id="0fc4" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated"><a class="ae ly" href="https://github.com/davidfig/pixi-viewport" rel="noopener ugc nofollow" target="_blank"> pixi-viewport </a>是PixiJS应用程序事实上的相机插件。我和维护者David Figatner正致力于在下一个主要版本中实现这一优化！</p><h1 id="57a0" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">陷阱</h1><p id="a88c" class="pw-post-body-paragraph kf kg iq kh b ki mr jr kk kl ms ju kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">投影系统在以前的版本中一直不稳定，我正在修补所有的错误。以下是我之前发现并修复的错误列表:</p><ul class=""><li id="739f" class="nl nm iq kh b ki kj kl km ko nn ks no kw np la nq nr ns nt bi translated"><a class="ae ly" href="https://github.com/pixijs/pixi.js/pull/6683" rel="noopener ugc nofollow" target="_blank">https://github.com/pixijs/pixi.js/pull/6683</a></li><li id="20c7" class="nl nm iq kh b ki nu kl nv ko nw ks nx kw ny la nq nr ns nt bi translated"><a class="ae ly" href="https://github.com/pixijs/pixi.js/pull/6739" rel="noopener ugc nofollow" target="_blank">https://github.com/pixijs/pixi.js/pull/6739</a></li><li id="80e5" class="nl nm iq kh b ki nu kl nv ko nw ks nx kw ny la nq nr ns nt bi translated"><a class="ae ly" href="https://github.com/pixijs/pixi.js/issues/6461" rel="noopener ugc nofollow" target="_blank">https://github.com/pixijs/pixi.js/issues/6461</a></li><li id="1f67" class="nl nm iq kh b ki nu kl nv ko nw ks nx kw ny la nq nr ns nt bi translated">【https://github.com/pixijs/pixi.js/issues/6461 T2】号</li><li id="e43c" class="nl nm iq kh b ki nu kl nv ko nw ks nx kw ny la nq nr ns nt bi translated">交互-系统没有对投影矩阵进行正确调整</li></ul><blockquote class="lr ls lt"><p id="74f9" class="kf kg lu kh b ki kj jr kk kl km ju kn lv kp kq kr lw kt ku kv lx kx ky kz la ij bi translated">注意:在5.3.1版本中，过滤器和交互管理器没有打补丁以与投影兼容！</p></blockquote><p id="cc69" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着我们越来越接近让投影成为一个一流的特性，这个帖子将会更新。</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><p id="9392" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lu">大家好，我是Shu Kant Pal——pix ijs的维护人员和WebGL开发人员。在Twitter上关注我以获取更多我的内容:</em><a class="ae ly" href="https://twitter.com/ShukantP" rel="noopener ugc nofollow" target="_blank"><em class="lu">https://twitter.com/ShukantP</em></a></p></div></div>    
</body>
</html>