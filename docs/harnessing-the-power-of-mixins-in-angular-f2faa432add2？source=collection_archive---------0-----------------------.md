# 利用混音的力量

> 原文：<https://javascript.plainenglish.io/harnessing-the-power-of-mixins-in-angular-f2faa432add2?source=collection_archive---------0----------------------->

![](img/67b18253ab08ad974adfc17aea2b4bc8.png)

什么是 mixin？根据版本 [2.2](https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript#support-for-mix-in-classes) ，TypeScript 现在支持 mixin 的概念——这个函数可以接受一个类，用一些功能扩展它，然后返回新的类，允许其他类从中扩展——允许类混合和共享功能！

# 它是如何工作的？

这个概念相当简单——如果我们熟悉继承、高阶类/函数及其语法，我们就可以直接进入它们。下面是 TypeScript 文档本身的示例:

正如我们看到的，我们在这里使用一个函数来创建另一个类的丰富版本，它既可以用来实例化新对象，也可以用来扩展其他类。在某种意义上，这现在允许多重继承—如果我们的一些类只需要共享功能( *abstract* class)，那么我们可以将它写在一个函数内，这样它就可以与其他类混合，以便进一步组合。

# 这个怎么用？

假设一个普通的 Angular 应用程序有不同的页面，其中一些页面有表单。一切都很好，然后有一天我们决定，从现在开始，如果用户触摸一个表单，但试图离开页面而不保存它，应该显示一个窗口，要求用户确认他们是否真的想离开页面(一个非常标准的功能)。

当然，首先想到的是一个`Guard`。因为我们的应用程序设计得很时尚，*大部分*(但**不是**全部！)包含表单的组件有一个通用的`form`字段，它是`AbstractFormControl`的一个实例。当然，从那时起我们可以检查`form`属性的`touched`字段，如果有必要显示提示的话。守卫可以是这样的:

当然，这在纸面上看起来不错，但实际上，正如上面简要提到的，并不是每个页面都是这样的——有些页面有多个表单，有些页面的子组件中有表单，有些页面两者都有。当然，我们希望防护装置以相同的方式为每个组件工作，我们也希望非常精确和一致。所以这里有一个想法:从现在开始，每个应该有这个保护的组件都应该实现一个叫做`isFormTouched`的特殊方法，这个方法将返回一个`boolean`来告诉这个保护是否必须显示提示。下面是一个更复杂的组件的例子，它的表单*不在它自身*中，而是在它的子组件中，以及它如何实现这个方法:

当然，这很好，但是对于大多数组件(比如 90%)来说,`isFormTouched`方法可以归结为:

当然，我们可以将这个方法复制并粘贴到我们需要它的每个组件中，但是这个操作本身就有问题，对吗？我们不想要这个解决方案的一个原因是，有一天，它可能还需要检查表单是否已经被提交(在同一个类上使用一个`isSubmitted`属性)。那将需要我们重写**许多**代码。如果我们遗漏了一个实例，可能要过很久才会有人发现这样一个小错误。因此，自然地，我们想要一个解决方案，让我们只写一次特定的方法*，但是仍然在我们所有需要它的组件之间共享它。很自然地，我们想到了继承——但是这里有三个基本的缺点:*

1.  *惯用的:继承意味着表示一种*是-一种*关系(如“马是一种动物”)，而不是共享功能。依赖注入或对象组合被用于此。*
2.  *范例:这个类应该代表什么？在一些面向对象的语言中有一个叫做`trait`的概念，它允许这样的事情，但是在 JS 中我们没有这样的特性，所以我们的类应该代表一些东西，而不仅仅是包含一个简单的方法。*
3.  *实用:如果将来我们需要从另一个基类扩展我们的组件怎么办？在那种情况下，我们会束手无策。*

# *混血儿来拯救*

*看看这个函数:*

*正如您所看到的，这个函数接受一个简单的类(也可以是一个角度组件)并返回另一个组件，该组件从它扩展而来，并在其上实现了`isFormTouched`方法。我们可以做这个简单的事情:*

*下面是这个函数如何解决上述三个问题:*

1.  *因为它被命名为`WithFormTouchedCheck`，所以它现在代表了一个类(它可以作为一个参数获得——或者没有它，请注意`Base: Constructor<T> = (class {} as any)`行，这基本上意味着如果没有给定类，将会扩展一个空的类),该类被增强了一些额外的特性。*
2.  *这个函数本身并不是一个类，它只代表了一个添加到现有函数中的功能——假设它实现了某个接口——这就是为什么它被声明为抽象的原因。*
3.  *因为它接受另一个类作为参数，所以现在它也允许我们从其他类扩展我们的组件。事实上，只要我们保持这种形式，我们就可以想上多少课就上多少课！*

# *混合东西*

*我相信你们很多人都听说过关于[僵尸订阅](https://gist.github.com/ThomasBurleson/df0d9554b5d30d365cd8737a36d69fe3)的可怕故事，以及我们如何通过使用`takeUntil`操作符来避免它们。当然，我们还需要为此创建一个特定的`Subject`，并在我们的`ngOnDestroy`方法中发送一个`next`通知。事实上，代码如下:*

*我们的许多组件内部可能都有订阅，并且所有的组件都应该实现相同的功能，所以将其转换为 mixin 是有意义的:*

*当然，使用我们以前的 mixin 的组件可能也需要这个新的，但是将它们组合起来是极其容易的:*

***小心**:我们在 mixin 中实现了`ngOnDestroy`方法:如果你要在一个类中使用它，这个类本身也会实现`ngOnDestroy`方法，一定要在里面调用`super.ngOnDestroy()`！*

# *骗局*

*当然，编程中的每一种方法都可能有一些缺点。在我们的例子中，大多数错误都与一些特定于 Typescript 编译器的问题或者角度构建问题有关。这里我呈现其中的两个，可能是最让人沮丧的。*

*1.`Decorators are not valid here`问题:*

*如果我们尝试在 mixin 中使用这样的装饰器:*

*我们将得到一个显示`Decorators are not valid here`的错误。这实际上是 Typescript 编译器的一个问题。以下是一种解决方法:*

*Somehow Typescript is only okay when we put decorators on a named class*

*2.角度输入问题:*

*如果我们在一个 mixin 类中包含一个 decorator，例如，在类上定义一个`Input`属性，那么当我们`ng serve`我们的应用程序时，它将按预期工作，但是在产品构建期间将抛出一个错误。这与这个[问题](https://github.com/angular/angular/issues/25249)有关。这个问题的解决方法有点混乱:*

*这当然需要在子组件上做更多的工作，Angular 自己的风格指南不允许在 decorators 中使用`inputs`数组，但这仍然是一种变通方法。我个人并不介意，直到 Angular 团队给我们提供了解决方案。*

# *结论*

*Typescript mixins 是一种很好的方式，可以在不中断任何流程的情况下，通过共享功能来增强我们的 Angular 应用程序。虽然这项技术仍然有一些小的缺点，但我个人认为它的好处远远大于它们。*

**关注我关于* [*中型*](https://medium.com/@Armandotrue) *和*[*Twitter*](https://twitter.com/Armandotrue)*了解更多关于 Angular、Rxjs、React 和 Javascript 的一般信息*。*