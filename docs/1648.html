<html>
<head>
<title>3 Pretty Cool Built-In Node.js Modules</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3个非常酷的内置Node.js模块</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/3-pretty-cool-built-in-node-js-modules-c2c3283276e6?source=collection_archive---------4-----------------------#2020-04-10">https://javascript.plainenglish.io/3-pretty-cool-built-in-node-js-modules-c2c3283276e6?source=collection_archive---------4-----------------------#2020-04-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="02d8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">让我们使用Node.js读取用户输入，执行终端命令并运行一个JS虚拟机！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e69e704babc1c03a6ef48de5741a805c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Rj8eEWlUM1ZaFskLcE3uUQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: The Author</figcaption></figure><p id="6dd0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">在我们开始之前:</strong>这是第二部分，对于4个更实用的内置模块你可以看看这里:</p><div class="lr ls gp gr lt lu"><a href="https://medium.com/better-programming/4-very-useful-built-in-node-js-modules-b734e140174c" rel="noopener follow" target="_blank"><div class="lv ab fo"><div class="lw ab lx cl cj ly"><h2 class="bd ir gy z fp lz fr fs ma fu fw ip bi translated">4个非常有用的内置Node.js模块</h2><div class="mb l"><h3 class="bd b gy z fp lz fr fs ma fu fw dk translated">深入了解perf_hooks、fs、os和URL</h3></div><div class="mc l"><p class="bd b dl z fp lz fr fs ma fu fw dk translated">medium.com</p></div></div><div class="md l"><div class="me l mf mg mh md mi kp lu"/></div></div></a></div><h1 id="1d50" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">Node.js中有哪些内置模块？</h1><p id="f230" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">Node.js有一些所谓的<em class="ng">内置模块</em>。这意味着，尽管这些模块像我们可以安装的其他模块一样工作，例如，通过NPM，然后包括使用<code class="fe nh ni nj nk b">require</code>或<code class="fe nh ni nj nk b">import</code>语法，顾名思义，内置模块已经安装，因此总是可用的。</p><p id="9371" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，它们是由Node.js背后的开发团队维护的，所以一切都是最新的，我们可以放心地使用这些模块。</p><p id="5d7f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不推荐使用的模块特性可以在官方文档中找到。</p><p id="7fce" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以，有充分的理由来看看这些模块，并在我们的下一个项目中使用它们。</p><h1 id="92d6" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">1.从键盘等输入流中读取数据(readline)</h1><p id="8115" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">诚然，有许多库提供了从控制台读取和处理输入的能力。但是<strong class="kx ir"> readline </strong>模块也有一些非常酷的特性，我们现在就可以看看。</p><h2 id="14a4" class="nl mk iq bd ml nm nn dn mp no np dp mt le nq nr mv li ns nt mx lm nu nv mz nw bi translated">在控制台中提示和处理输入</h2><pre class="kg kh ki kj gt nx nk ny nz aw oa bi"><span id="bbea" class="nl mk iq nk b gy ob oc l od oe">const readline = require('readline')</span><span id="f217" class="nl mk iq nk b gy of oc l od oe">const rl = readline.createInterface({<br/>  input: process.stdin,<br/>  output: process.stdout,<br/>})</span><span id="b605" class="nl mk iq nk b gy of oc l od oe"><em class="ng">console.log('Enter a number, Node will double it for you')</em></span><span id="b486" class="nl mk iq nk b gy of oc l od oe"><em class="ng">rl.question('Your Number: ', (number) =&gt; {<br/>  console.log(parseInt(number) * 2)<br/>  rl.close()<br/>})</em></span></pre><p id="c3a2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">重要提示:</strong>控制台中的输入总是被这个模块<br/>捕获为字符串，此外，我们总是必须首先使用<strong class="kx ir"> createInterface </strong>函数创建<strong class="kx ir"> rl </strong>，如上所述。在下面的代码中，我将省略这一点。</p><h2 id="d154" class="nl mk iq bd ml nm nn dn mp no np dp mt le nq nr mv li ns nt mx lm nu nv mz nw bi translated">输出用户用Enter确认的任何输入</h2><pre class="kg kh ki kj gt nx nk ny nz aw oa bi"><span id="c5bf" class="nl mk iq nk b gy ob oc l od oe">rl.on('line', (input) =&gt; {<br/>  console.log('You entered: ${input}')<br/>})</span></pre><p id="703a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它的工作方式类似于<strong class="kx ir"> rl.question </strong>，但是没有问题。<br/>如果我们愿意，我们当然可以在这里用<strong class="kx ir"> rl.close() </strong>和<strong class="kx ir"> readline </strong>的所有其他函数随时停止读取用户输入。</p><h2 id="a471" class="nl mk iq bd ml nm nn dn mp no np dp mt le nq nr mv li ns nt mx lm nu nv mz nw bi translated">如果用户想用ctrl-C终止程序，请注册</h2><pre class="kg kh ki kj gt nx nk ny nz aw oa bi"><span id="7c2b" class="nl mk iq nk b gy ob oc l od oe">rl.on('SIGINT', (input) =&gt; {<br/>  console.log('you exited')<br/>  process.exit()<br/>})</span></pre><p id="0fd6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">注意:</strong>这只是一个监听器，所以程序必须由例如process.exit()终止，否则用户不能用ctrl-C自己终止程序。</p><p id="3a28" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，我们实际上可以将此与<strong class="kx ir"> rs.question </strong>结合起来，要求用户输入。这样，如果用户输入“<em class="ng">是</em>或者“<em class="ng"> y </em>”，我们就可以按照他们的要求终止程序。</p><pre class="kg kh ki kj gt nx nk ny nz aw oa bi"><span id="a74e" class="nl mk iq nk b gy ob oc l od oe">rl.on(‘SIGINT’, (input) =&gt; {<br/>  rl.question(‘Are you sure you want to exit? ‘, (answer) =&gt; {<br/>    <em class="ng">if</em> (answer.match(/<em class="ng">^</em>y(es)?<em class="ng">$</em>/i)) process.exit()<br/>    <em class="ng">else</em> console.log(‘glad you stay’)<br/>  })<br/>})</span></pre><p id="a661" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这样，您可以双重确保用户没有无意中按下ctrl-c。</p><h1 id="712c" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">2.使用Node (child_process)运行shell命令</h1><p id="73bb" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated"><strong class="kx ir"> child_process </strong>模块可以用于许多不同的事情，但是本质上它是关于它的名字所说的。或多或少在后台运行的进程。</p><p id="79b7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我现在将向您展示如何使用它来执行不会中断Node.js应用程序的shell命令。</p><h2 id="476d" class="nl mk iq bd ml nm nn dn mp no np dp mt le nq nr mv li ns nt mx lm nu nv mz nw bi translated">使用ls列出更高级目录的内容</h2><pre class="kg kh ki kj gt nx nk ny nz aw oa bi"><span id="9f51" class="nl mk iq nk b gy ob oc l od oe">const { exec } = require(‘child_process’)</span><span id="f811" class="nl mk iq nk b gy of oc l od oe">exec('cd .. &amp;&amp; ls', (error, output) =&gt; {<br/>  <em class="ng">if</em> (error) <em class="ng">throw</em> error<br/>  console.log(output)<br/>})</span></pre><p id="5327" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">理论上没有限制，在Windows和Linux上都可以用“<strong class="kx ir"> &amp; &amp; </strong>”将终端命令串在一起，从而可以一个接一个地执行各种命令。</p><p id="0a98" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">您可以非常流畅地将exec集成到Node应用程序的流程中，从而也可以将Express.js文件中的内容作为HTTP响应发送给用户。当然这只是为了说明。</p><pre class="kg kh ki kj gt nx nk ny nz aw oa bi"><span id="4f6a" class="nl mk iq nk b gy ob oc l od oe">app.get(‘/’, (req, res) =&gt; {<br/>  exec(‘cat test.txt‘, (error, output) =&gt; {<br/>    res.send(output)<br/>  })<br/>})</span></pre><h1 id="eb43" class="mj mk iq bd ml mm mn mo mp mq mr ms mt jw mu jx mv jz mw ka mx kc my kd mz na bi translated">3.在虚拟机的Node.js (vm)中运行JavaScript代码</h1><p id="8000" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">我个人认为vm是最有趣的模块之一，因为有太多东西可以尝试。<br/>让我们从一小段代码开始。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="og oh l"/></div></figure><ol class=""><li id="a990" class="oi oj iq kx b ky kz lb lc le ok li ol lm om lq on oo op oq bi translated">我们将“x”定义为一个全局变量。没什么特别的，但是记住这一点。</li><li id="f14c" class="oi oj iq kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated">然后，我们将变量x放入虚拟机的上下文中，我们用<strong class="kx ir"> createContext </strong>来完成。</li><li id="9296" class="oi oj iq kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated">我们的代码变量就是我们想要在虚拟机中执行的JavaScript代码。这里我们访问了<strong class="kx ir"> x </strong>，而没有在代码中创建它。<strong class="kx ir"> x </strong>之所以可用，是因为我们将它传递给了<strong class="kx ir">上下文</strong>。</li><li id="0119" class="oi oj iq kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated">我们还创建了另外两个变量。重要提示:如果我们以后想在VM之外访问VM上下文中的变量，它们显然不能作为<strong class="kx ir"> let </strong>或<strong class="kx ir"> const </strong>使用，我们必须使用<strong class="kx ir"> var </strong>关键字。</li><li id="9006" class="oi oj iq kx b ky or lb os le ot li ou lm ov lq on oo op oq bi translated">最后，使用<strong class="kx ir"> runInContext </strong>我们可以将从全局范围借用的变量<strong class="kx ir"> x </strong>和要在VM中执行的代码集合在一起并执行我们的上下文。</li></ol><h2 id="ada9" class="nl mk iq bd ml nm nn dn mp no np dp mt le nq nr mv li ns nt mx lm nu nv mz nw bi translated">好了，让我们来看看虚拟机:</h2><p id="7103" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">每当我们想要访问我们的VM上下文中的变量，也就是说，<strong class="kx ir">代码</strong>，我们可以使用<strong class="kx ir">上下文</strong>对象:</p><pre class="kg kh ki kj gt nx nk ny nz aw oa bi"><span id="07ae" class="nl mk iq nk b gy ob oc l od oe">console.log(context.x) <em class="ng">// 41<br/></em>console.log(context.y) <em class="ng">// 17</em></span></pre><p id="61f1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们看到一切都在意料之中。由于<strong class="kx ir"> x </strong>是全局1，我们在VM中加了40，所以它现在在VM 41中。<br/>但是如果我们想在全局范围内访问变量<strong class="kx ir"> x </strong>，它是不变的:</p><pre class="kg kh ki kj gt nx nk ny nz aw oa bi"><span id="3296" class="nl mk iq nk b gy ob oc l od oe">console.log(x) <em class="ng">// 1</em></span></pre><p id="567a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">当然，我们可以从虚拟机内部执行该功能:</p><pre class="kg kh ki kj gt nx nk ny nz aw oa bi"><span id="8f64" class="nl mk iq nk b gy ob oc l od oe">console.log(context.hello()) <em class="ng">// “from the VM”</em></span></pre><h2 id="5140" class="nl mk iq bd ml nm nn dn mp no np dp mt le nq nr mv li ns nt mx lm nu nv mz nw bi translated">JavaScript用简单的英语写的一个注释:</h2><p id="ce08" class="pw-post-body-paragraph kv kw iq kx b ky nb jr la lb nc ju ld le nd lg lh li ne lk ll lm nf lo lp lq ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物，表达对它们的爱:<a class="ae ow" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kx ir">AI in Plain English</strong></a><a class="ae ow" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kx ir">UX in Plain English</strong></a><a class="ae ow" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kx ir">Python in Plain English</strong></a><strong class="kx ir"/>—谢谢，继续学习！</p></div></div>    
</body>
</html>