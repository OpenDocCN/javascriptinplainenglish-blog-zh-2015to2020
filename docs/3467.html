<html>
<head>
<title>Jotai — Simple State Management for React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">jotai——React的简单状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/jotai-simple-state-management-for-react-b9318b0f7616?source=collection_archive---------1-----------------------#2020-10-01">https://javascript.plainenglish.io/jotai-simple-state-management-for-react-b9318b0f7616?source=collection_archive---------1-----------------------#2020-10-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d4e9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">快速设置，小巧灵活</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/bb527bfdfb708f2462332e0d2c63acdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Zz7k1EivM38fBhbwIVkI7w.png"/></div></div></figure><p id="8ae9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Jotai是React.js中一个简单的无状态管理库，它的工作方式类似于useState Hook，这使得它非常容易使用。它也是打字稿友好的，可以在几秒钟内设置好。</p><p id="88a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">先开始安装Jotai吧。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="a186" class="lt lu iq lp b gy lv lw l lx ly"><em class="lz">yarn add jotai </em></span></pre><p id="61b0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了能够在整个应用程序中使用状态，我们需要提供者。只需将其添加到index.js中，如下所示:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="8fa3" class="lt lu iq lp b gy lv lw l lx ly"><em class="lz">import</em> { Provider } <em class="lz">from</em> "jotai"</span><span id="29ab" class="lt lu iq lp b gy ma lw l lx ly">ReactDOM.render(<br/>  &lt;Provider&gt;<br/>    &lt;App /&gt;<br/>  &lt;/Provider&gt;,<br/>  document.getElementById(‘root’)<br/>);</span></pre><p id="0576" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是我们目前所需要的。我们可以通过创建一个atom来直接开始使用Jotai。恰当选择的名称是库中最小的单元——每个状态都有自己的原子。对于原子，我们也直接传递状态的默认值。让我们建立一个国家。</p><h1 id="4c9a" class="mb lu iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">基础——原子</h1><p id="885a" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">在Jotai中，一个<em class="lz">原子</em>是一个单一独立的状态。</p><p id="0c95" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它应该在组件函数之外定义。此外，还有<em class="lz"> useAtom </em>函数，其工作原理类似于钩子。这个函数也依赖于一个原子——它将原子作为参数获取。</p><p id="06be" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是与<em class="lz">使用状态</em>挂钩的区别。使用<em class="lz"> useState </em>我们直接传递默认值，在Jotai中，我们将一个原子传递给<em class="lz"> useAtom </em>。</p><p id="5607" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们应该在构件之外创造原子；从内部，我们可以用类似于使用状态的<em class="lz"> useAtom </em>来访问它。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="6dc4" class="lt lu iq lp b gy lv lw l lx ly"><em class="lz">import</em> { useAtom, atom } <em class="lz">from</em> “jotai”</span><span id="2b21" class="lt lu iq lp b gy ma lw l lx ly">const inputAtom = atom(“”)</span><span id="810d" class="lt lu iq lp b gy ma lw l lx ly">function App() {<br/>  const [input, setInput] = useAtom(inputAtom)<br/>  <em class="lz">return</em> (<br/>    &lt;&gt;<br/>      &lt;p&gt;{input}&lt;/p&gt;<br/>      &lt;input type=”text” placeholder=”enter something” /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="69ab" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="lz">使用状态</em>强烈提醒<em class="lz">使用状态</em>。和<em class="lz"> useState </em>一样，第一个元素是状态本身，因为我们可以在DOM中输出，它返回的第二个元素是一个函数，它获取新的状态作为参数。</p><p id="1ade" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以现在我们可以写一个函数来改变每个输入的状态。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="668c" class="lt lu iq lp b gy lv lw l lx ly">const inputAtom = atom(“”)</span><span id="3b01" class="lt lu iq lp b gy ma lw l lx ly">function App() {<br/>  const [input, setInput] = useAtom(inputAtom)</span><span id="feb7" class="lt lu iq lp b gy ma lw l lx ly">  function handleChange(event) {<br/>    setInput(event.target.value)<br/>  }</span><span id="11a1" class="lt lu iq lp b gy ma lw l lx ly"><em class="lz">  return</em> (<br/>    &lt;&gt;<br/>      &lt;p&gt;{input}&lt;/p&gt;<br/>      &lt;input type=”text” onChange={handleChange} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="3f07" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于有了<em class="lz"> onChange </em>属性，每次更改输入字段的内容时都会调用<em class="lz"> handleChange </em>函数。用户输入总是存储在事件对象中。最后，我们只需用<em class="lz"> useState </em>覆盖状态。</p><p id="57ae" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因为我们为输入状态定义了atom，即组件函数外部的<em class="lz"> inputAtom </em>，所以我们可以创建其他基于函数的组件并访问其中的状态。<br/>每个函数都有自己的<em class="lz"> useAtom </em>，它从atom <em class="lz"> inputAtom获取状态。</em></p><p id="fdf1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以现在，我们构建一个组件来显示状态。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="2b0e" class="lt lu iq lp b gy lv lw l lx ly">const inputAtom = atom(“”)</span><span id="73e8" class="lt lu iq lp b gy ma lw l lx ly">function DisplayInput() {<br/>  const [input, setInput] = useAtom(inputAtom)<br/>  <em class="lz">return</em> &lt;p&gt;User input: {input}&lt;/p&gt;<br/>}</span></pre><p id="f84d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们现在可以在我们的应用程序组件中呈现<em class="lz">显示输入</em>；它显示当前状态。</p><h1 id="6875" class="mb lu iq bd mc md me mf mg mh mi mj mk jw ml jx mm jz mn ka mo kc mp kd mq mr bi translated">移出状态—单个文件中的多个组件</h1><p id="34af" class="pw-post-body-paragraph kr ks iq kt b ku ms jr kw kx mt ju kz la mu lc ld le mv lg lh li mw lk ll lm ij bi translated">到目前为止，一切都很好——但是在现实中，我们很难在一个文件中拥有很多自己的组件。<br/>通常，我们会为每个组件创建一个单独的文件，但仍然希望随时随地访问应用程序的状态。</p><p id="9d40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们可以通过将原子本身存储在一个文件中来实现这一点。我把这个文件叫做state.js，它有以下内容:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="f365" class="lt lu iq lp b gy lv lw l lx ly"><em class="lz">import</em> { atom } <em class="lz">from</em> “jotai”</span><span id="479a" class="lt lu iq lp b gy ma lw l lx ly">const inputAtom = atom(“”)</span><span id="7fc7" class="lt lu iq lp b gy ma lw l lx ly"><em class="lz">export</em> <em class="lz">default</em> inputAtom</span></pre><p id="eaee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">剩下的就简单了。从state.js导入atom，并像以前一样使用它:</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="3fec" class="lt lu iq lp b gy lv lw l lx ly"><em class="lz">import</em> inputAtom <em class="lz">from</em> “./state”</span><span id="2e42" class="lt lu iq lp b gy ma lw l lx ly">function App() {<br/>  const [input, setInput] = useAtom(inputAtom)</span><span id="b45e" class="lt lu iq lp b gy ma lw l lx ly">  function saveUserinput(event) {<br/>    setInput(event.target.value)<br/>  }</span></pre><p id="4a84" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">由于我们无法获得应用程序组件中原子的状态，我们也可以将其设置为只写。为此，我们只需拿出输入:<br/> <code class="fe mx my mz lp b">const [, setInput] = useAtom(inputAtom)</code></p><p id="1885" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们也可以在应用程序组件中使用状态。当然，在我们的<em class="lz">显示输入</em>组件中，我为其创建了一个<strong class="kt ir">。js </strong>文件同名。</p><pre class="kg kh ki kj gt lo lp lq lr aw ls bi"><span id="a699" class="lt lu iq lp b gy lv lw l lx ly"><em class="lz">import</em> { useAtom } <em class="lz">from</em> “jotai”<br/><em class="lz">import</em> inputAtom <em class="lz">from</em> “./state”</span><span id="d6d6" class="lt lu iq lp b gy ma lw l lx ly">const DisplayInput = () =&gt; {<br/>  const [input] = useAtom(inputAtom)<br/>  <em class="lz">return</em> &lt;p&gt;User Input: {input}&lt;/p&gt;<br/>}</span></pre><p id="ddff" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，如上所示，我们还可以在App.js中包含<em class="lz"> DisplayInput </em>组件，并在那里呈现它。</p><p id="d248" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">几个组件现在引用同一个状态；一切都很顺利——我们已经实现了一个可以在整个应用程序中访问和更改的状态。超级酷简单吧？而且没有Redux。</p><p id="ec6d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果您对发现React.js的更多库感兴趣:</p><div class="na nb gp gr nc nd"><a href="https://medium.com/javascript-in-plain-english/5-awesome-react-packages-you-need-to-try-out-20a156d3d73e" rel="noopener follow" target="_blank"><div class="ne ab fo"><div class="nf ab ng cl cj nh"><h2 class="bd ir gy z fp ni fr fs nj fu fw ip bi translated">你需要尝试的5个很棒的React包</h2><div class="nk l"><h3 class="bd b gy z fp ni fr fs nj fu fw dk translated">预渲染，有用的钩子，加载动画，颜色选择器&amp;访问头部区域。由5位伟大的…</h3></div><div class="nl l"><p class="bd b dl z fp ni fr fs nj fu fw dk translated">medium.com</p></div></div><div class="nm l"><div class="nn l no np nq nm nr kp nd"/></div></div></a></div><p id="f512" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="http://eepurl.com/hacY0v" rel="noopener ugc nofollow" target="_blank">加入我的邮件列表，保持联系</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/787be6c671be8d345dc786dad8729ce5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s-sOyyG8NoRbKpCG_y4Cmw@2x.png"/></div></div><figcaption class="nt nu gj gh gi nv nw bd b be z dk"><a class="ae ln" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank">Subscribe to Decoded, our official YouTube channel!</a></figcaption></figure></div></div>    
</body>
</html>