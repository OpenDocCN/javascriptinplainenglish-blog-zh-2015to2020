<html>
<head>
<title>A Simple Task &amp; Queue Solution via Firebase Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Firebase函数实现简单的任务和队列解决方案</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/simple-queue-via-firebase-functions-4a69ca6e33a9?source=collection_archive---------1-----------------------#2019-03-06">https://javascript.plainenglish.io/simple-queue-via-firebase-functions-4a69ca6e33a9?source=collection_archive---------1-----------------------#2019-03-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6bd779e805e800f1cf982f9978ec54b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*R0pJlapmWnJVdtJQiiU7Vw.png"/></div></div></figure><p id="b763" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用具有简单模式模式的Firebase函数可以使常见任务的排队解决方案对于大量常见应用程序任务来说非常容易；S3存储、图像大小调整、Slack &amp; Twilio消息和Hubspot联系人同步。</p><p id="e75b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">根据最近的统计，在我们的生产<a class="ae kw" href="https://meenta.io" rel="noopener ugc nofollow" target="_blank">meen ta . io</a><a class="ae kw" href="https://firebase.google.com" rel="noopener ugc nofollow" target="_blank">firebase</a>应用程序中运行着超过120个不同的Firebase函数。这些功能可以完成各种任务，从调整图像大小、跨路径更新数据、向HubSpot和Slack发送电子邮件和推送消息。</p><p id="c9d7" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">管理这种不断增长的功能让我们学到了许多关于如何思考和扩展微服务使用的经验教训。首先，我们的每个功能都是一个微服务，有自己的范围、依赖关系和工作。第二，我们希望将任务从UI中分离出来，并相互分离。发送电子邮件、消息传递松弛以及为给定订单设置S3存储桶不需要有任何相互依赖性。</p><h1 id="9f8b" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">服务和共享资源</h1><p id="7e73" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们确实有一套共享服务，允许我们集中访问配置变量；SendGrid、S3、Hubspot等。</p><p id="2a90" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们(目前)没有使用任何ODM来允许我们跨函数共享类或方法。Mongoose for MongoDB是这种ODM特性如何帮助模式管理、钩子、模式和方法的一个很好的例子。但是在firebase functions环境中，这种方法对于我们的需求来说太沉重了，并且会导致复杂和交织的代码库。</p><p id="f677" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们开发的模式之一是“行动”的概念。当firebase中的给定路径被创建时，我们发现触发器需要是离散的和可重用的。例如，当一个新订单被创建时，我们需要做许多工作；<em class="ma">将用户账户链接到订单，通过SendGrid发送收据电子邮件，通知Slack频道我们有订单，更新用户的订单计数，并向Twilio的可编程聊天推送欢迎消息。</em></p><p id="5d72" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在单个代码块中完成所有这些工作会导致问题。如果这些外部服务中的一个没有响应，那么我们就会被需要重新运行的任务所困扰。发送重复的电子邮件或消息不是一个好的用户体验。而且firebase日志很复杂，难以阅读，回调路径也很复杂。</p><h1 id="5a0a" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">我们的解决方案</h1><p id="cb14" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们的解决方案是使用firebase函数和数据库触发器构建一个简单的任务系统。所以现在我们用一个<code class="fe mb mc md me b">actions</code>元素来设置我们的firebase路径。该元素包含键值，键值作为动作，值作为状态。</p><figure class="mf mg mh mi gt jr"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="b454" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">使用这种方法，我们创建函数来观察<code class="fe mb mc md me b">actions</code>元素中的特定值。键名告诉我们所需的操作(时差、电子邮件、短信等)，值告诉我们该操作的状态(挂起、失败或已完成)。当一个功能运行时，它只需要执行它的特定任务(电子邮件、时差、s3等)，然后它需要设置它的状态消息；已完成”、“失败”或“挂起”。当<code class="fe mb mc md me b">failed</code>或<code class="fe mb mc md me b">completed.</code>时，该代码将停止执行</p><ul class=""><li id="95eb" class="ml mm iq ka b kb kc kf kg kj mn kn mo kr mp kv mq mr ms mt bi translated">/invite/{ id }/actions/<strong class="ka ir">twi lio</strong>/待定</li><li id="3ffe" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">/invite/{ id }/actions/<strong class="ka ir">电子邮件</strong>/待定</li><li id="93d5" class="ml mm iq ka b kb mu kf mv kj mw kn mx kr my kv mq mr ms mt bi translated">/invite/{ id }/actions/<strong class="ka ir">hub spot</strong>/待定</li></ul><h1 id="5bb8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">赞成的意见</h1><p id="47c6" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><strong class="ka ir">独立</strong> —任务状态、数据库触发、任务数据都位于同一位置/路径。使用“parent.parent”允许函数的代码沿着参考线向上走，得到它需要的数据。这意味着该函数不需要从其他路径获取数据，这使得代码更容易管理，回调更少。</p><p id="e4d1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">较小的工作块</strong> —这种模式有助于我们的团队理解给定特征或数据块的状态变化。它使单个代码块更小，更易于代码检查和重用。</p><p id="3b2e" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">可扩展</strong> —该功能如预期使用firebases函数和数据库触发器。谷歌提供了一系列监控任务、报告和跟踪执行时间的工具。</p><blockquote class="mz na nb"><p id="5bba" class="jy jz ma ka b kb kc kd ke kf kg kh ki nc kk kl km nd ko kp kq ne ks kt ku kv ij bi translated">我们系统中没有任何任务是相互依赖的。每一个都是独立的工作块，有自己的报告系统、内存和逻辑。</p></blockquote><h1 id="5660" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">缺点</strong></h1><p id="9a48" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated"><strong class="ka ir">动作在路径中</strong>——动作对象位于路径中，这意味着它与所有请求一起被发送下去。所以用户界面会看到这些数据。由于操作位于路径内，并且我们知道它是可见的，所以我们不存储任何历史或堆栈跟踪信息。我们必须深入研究日志，了解特定任务失败的原因。</p><p id="d8db" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir">调度</strong>——当我们需要在一天中的给定时间或在给定的时间间隔触发给定的动作时，这种方法不是很好。有一些项目引入了CRON特性，但是我们避免使用它们，因为这意味着我们将函数用于长期运行的活动。</p><h1 id="cce1" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">操作的管理用户界面</h1><p id="7de9" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">我们已经围绕这个模式构建了我们的管理用户界面。由于<code class="fe mb mc md me b">actions</code>是人类可读的，并且是实体数据本身的一部分，我们的用户界面能够在上下文中显示动作。当我们进入管理用户界面来管理一个新的订单或用户帐户时，用户界面代码具有显示每个操作的状态和提供CRUD特性所需的信息。这种方法意味着管理员用户不需要监控或管理单独的系统，并且系统管理变得自我记录。</p><p id="e600" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经设置了UI (Angularjs ),允许我们放入UI元素来列出和管理在<code class="fe mb mc md me b">ref/actions. </code>中发现的任何内容。如果其中一个任务失败，我们会通过Google monitoring services得到通知，我们可以提取firebase日志并调试问题，或者通过将值设置为<code class="fe mb mc md me b">pending</code>来简单地触发操作再次运行。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/595fd8158d9d97ebd1bf1b73469d34af.png" data-original-src="https://miro.medium.com/v2/resize:fit:922/format:webp/1*_2ftAGQIto-mbTsrTINn2w.png"/></div><figcaption class="ng nh gj gh gi ni nj bd b be z dk">Screenshot for our invite admin UI.</figcaption></figure><p id="7f06" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们考虑过添加错误消息等，但随着时间的推移，我们发现我们监视我们的功能，所以真的不需要在数据库中存档失败状态。</p><p id="c9a1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，由于我们将<code class="fe mb mc md me b">actions</code>元素绑定到一个<a class="ae kw" href="https://github.com/firebase/angularfire/blob/master/docs/reference.md#firebasearray" rel="noopener ugc nofollow" target="_blank"> Angularfire数组</a>，UI会随着任务的执行而更新。</p><p id="2187" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在特性开发过程中，我们发现从Firebase数据库控制台触发单独的操作很有帮助。</p><figure class="mf mg mh mi gt jr gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/f5118e4db51c4f3261fd1f64bc3ed552.png" data-original-src="https://miro.medium.com/v2/resize:fit:826/format:webp/1*9pMBEoanQoLJTAObIxKduA.png"/></div></figure><h1 id="7498" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated"><strong class="ak">安全顾虑</strong></h1><p id="52bc" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">值得注意的是，数据库规则需要配置为强制用户权限，因此只有选定的用户可以编辑键/值和触发功能。我们还将所有堆栈信息保留在UI之外，因为日志消息和堆栈信息可能会造成问题。</p><h1 id="6f97" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">总结</h1><p id="6625" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">基本上，这只是任务/排队解决方案，它使用数据库触发器的能力，不需要设置和管理CRON作业、工作进程和重试参数。是可怜的芒<a class="ae kw" href="https://aws.amazon.com/sqs/" rel="noopener ugc nofollow" target="_blank"> AWS SQS服务</a>。我们所有的代码都在git repo中管理。每个功能都是轻量级的，我们可以在本地测试这些功能，在功能的基础上部署到不同的firebase应用程序。</p><h1 id="30a8" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">下一个:函数组</h1><p id="4d12" class="pw-post-body-paragraph jy jz iq ka b kb lv kd ke kf lw kh ki kj lx kl km kn ly kp kq kr lz kt ku kv ij bi translated">Google和firebase团队已经为管理功能添加了越来越多的CLI选项。我们已经开始将我们的功能分组，这样我们就可以部署更小的代码块。此外，我们发现我们喜欢将函数组织到文件夹中，文件夹名反映了数据库路径的根。</p><p id="3a40" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">例如:<code class="fe mb mc md me b">/userInvites/{uid}/{id}/actions/email =&gt; {…}</code>存储在/functions/user invites/onWrite . js中，它告诉我们<code class="fe mb mc md me b">ref</code>和数据库事件(on write、onDelete等)。当数据库触发器被更深地绑定到对象中时，我们添加文件名的路径；这有助于我们从文件夹或文件名中读取映射。</p></div></div>    
</body>
</html>