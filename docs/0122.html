<html>
<head>
<title>Introduction to Functors in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的函子介绍</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-definite-guide-to-functors-in-js-6f5e82bd1dac?source=collection_archive---------0-----------------------#2019-04-06">https://javascript.plainenglish.io/the-definite-guide-to-functors-in-js-6f5e82bd1dac?source=collection_archive---------0-----------------------#2019-04-06</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/0920437f8b7b75114ee03a4e7240459c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6sHRG_sKftbF1sZUxI4jNA.png"/></div></div></figure><div class=""/><div class=""><h2 id="a9d0" class="pw-subtitle-paragraph jv ix iy bd b jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dk translated">让我告诉你什么是面向对象编程的函子:它是一个<strong class="ak"> <em class="kn">容器、</em>和一个映射函数</strong>。</h2></div><p id="1258" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">函子是<a class="ae lk" href="https://en.wikipedia.org/wiki/Category_theory" rel="noopener ugc nofollow" target="_blank">范畴理论</a>的基础，范畴理论已经成为函数式编程范例中最有价值的工具之一。</p><p id="1938" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在数学中，<strong class="kq iz">函子</strong>是<a class="ae lk" href="https://en.wikipedia.org/wiki/Category_(mathematics)" rel="noopener ugc nofollow" target="_blank">类别</a>之间的映射。一个类别只是一个对象和对象之间的箭头的集合，如下图所示。类别C有物体x，y和一个从x到y的箭头f，这就是它的基本内容。算是吧。</p><figure class="lm ln lo lp gt ip gh gi paragraph-image"><div class="gh gi ll"><img src="../Images/88235121a9c873cde5d9b4edca6fe17c.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*kruUtN4SxXqcon1R5gQ41A.png"/></div></figure><p id="9b0c" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在编程中，一个主要的<strong class="kq iz">类别是这种类型</strong> int，bool…类型之间的箭头是函数/方法f:<em class="lq">a</em>T14】→T16】b。但是因为这个概念非常广泛，所以在编程的各个领域都会出现类别。例如，如果我们得到对象是程序的类别，那么它们之间的箭头可能是<strong class="kq iz">编译器</strong>，它得到一个输入程序并给出一个不同的程序<em class="lq">Comp:program 1</em>→assembly program。]</p><p id="1f2b" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">让我们开门见山，看看JavaScript中的一个例子。该数组是用<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank"> <strong class="kq iz">映射</strong> </a> <strong class="kq iz"> </strong>的方法将 与<strong class="kq iz"> <em class="lq">联系在一起。<a class="ae lk" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" rel="noopener ugc nofollow" target="_blank"> <strong class="kq iz">映射</strong> </a> <strong class="kq iz"> </strong>是从初始范畴映射或者我们说提升一个函数f的方法。但是我们可以看看最简单的函子贝娄:</em></strong></p><figure class="lm ln lo lp gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><figure class="lm ln lo lp gt ip gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/0ed35445b36813d6c8e733dd1cc7adb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*7Mpev9c5jVNkMi7agKFu8w.png"/></div></figure><p id="244d" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在下面的例子中，我们有整数2和4(为了简单起见，我们称之为这个例子中的整数类别)，在这个类别中还有函数<em class="lq"> f =x= &gt; x*x </em>将2映射到4。如果我们应用新的函子()构造函数，我们可以将每个整数映射到函子对象类别，例如2将被映射到<strong class="kq iz">新的函子(2) </strong>和4在<strong class="kq iz">新的函子(4) </strong>唯一缺少的部分是函数f <strong class="kq iz">函子【f】</strong>到这个新类别的正确提升。很容易看出正确的映射是:</p><pre class="lm ln lo lp gt lu lv lw lx aw ly bi"><span id="a3ab" class="lz ma iy lv b gy mb mc l md me">this.map =  (f) =&gt; Functor(f(value));</span></pre><h1 id="dd8e" class="mf ma iy bd mg mh mi mj mk ml mm mn mo ke mp kf mq kh mr ki ms kk mt kl mu mv bi translated">交换图</h1><p id="130a" class="pw-post-body-paragraph ko kp iy kq b kr mw jz kt ku mx kc kw kx my kz la lb mz ld le lf na lh li lj ig bi translated">关于<strong class="kq iz">映射函数有一点很重要。</strong></p><p id="9403" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq iz"> <em class="lq">如果我们选择两条可能的路线中的任何一条到达那里，映射应该得到与[4]相同的结果。</em> </strong> <em class="lq">这个意思是:</em></p><blockquote class="nb nc nd"><p id="6cd7" class="ko kp lq kq b kr ks jz kt ku kv kc kw ne ky kz la nf lc ld le ng lg lh li lj ig bi translated"><strong class="kq iz"> <em class="iy">映射</em> </strong> <em class="iy">(又名从C到D的函数提升)</em> <strong class="kq iz">应该保留结构</strong></p></blockquote><figure class="lm ln lo lp gt ip gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/0ed35445b36813d6c8e733dd1cc7adb2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1008/format:webp/1*7Mpev9c5jVNkMi7agKFu8w.png"/></div></figure><ol class=""><li id="1d73" class="nh ni iy kq b kr ks ku kv kx nj lb nk lf nl lj nm nn no np bi translated">我们可以先得到函子，然后映射它。这是图上的红色路径。</li></ol><pre class="lm ln lo lp gt lu lv lw lx aw ly bi"><span id="7737" class="lz ma iy lv b gy mb mc l md me">Functor(4) = Functor(2).map(f);</span></pre><p id="52cd" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2.或者先用f提升2再得到函子。</p><pre class="lm ln lo lp gt lu lv lw lx aw ly bi"><span id="97c6" class="lz ma iy lv b gy mb mc l md me">Functor(4) = Functor(f(2));</span></pre><figure class="lm ln lo lp gt ip"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="2d6e" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们说图<strong class="kq iz"> <em class="lq">往返于</em> </strong>时就是这种情况。这意味着态射的提升(编程中的箭头或函数)保留了c中对象的结构。</p><h1 id="34d8" class="mf ma iy bd mg mh mi mj mk ml mm mn mo ke mp kf mq kh mr ki ms kk mt kl mu mv bi translated">将自定义承诺扩展到函子</h1><p id="28c3" class="pw-post-body-paragraph ko kp iy kq b kr mw jz kt ku mx kc kw kx my kz la lb mz ld le lf na lh li lj ig bi translated">让我们看看JavaScript中另一个最流行的函子。原住民的承诺。promises的本机实现(基于<a class="ae lk" href="https://promisesaplus.com/" rel="noopener ugc nofollow" target="_blank"> Promises/A+ </a>规范)有一个通过重载<code class="fe nq nr ns lv b">Promise.then()</code>方法实现的<strong class="kq iz">有效映射</strong>:</p><pre class="lm ln lo lp gt lu lv lw lx aw ly bi"><span id="794a" class="lz ma iy lv b gy mb mc l md me">var thenableMapResult = <br/>   new Promise((resolve,reject) =&gt; resolve(5))<br/>    .then(<strong class="lv iz">x=&gt;x+3</strong>)           <strong class="lv iz"> //</strong> <strong class="lv iz">Using then to map the x=&gt;x+3</strong><br/>    .then(console.log)       <strong class="lv iz">//8</strong></span></pre><p id="8c0d" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">运行这个:<a class="ae lk" href="https://jsfiddle.net/functionalCategories/2n5ug098/" rel="noopener ugc nofollow" target="_blank"> JS拨弄</a></p><p id="2a0d" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">很明显，这一部分只是为了提供一些对背后机制的理解。然后作为地图。</p><p id="3cea" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们已经说过，函子的通常隐喻是“容器”<strong class="kq iz">一个承诺可以被看作一个容器</strong>，它接受一个值并包装它，直到它被解析。为了将Promise提升为Functor，必须有一个<strong class="kq iz">映射</strong>函数，它能够提升任何函数，并使用提升的值给出一个新的Promise。</p><p id="92e5" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">下面是一个可能的保持结构的映射函数:</p><figure class="lm ln lo lp gt ip"><div class="bz fp l di"><div class="nt ls l"/></div></figure><p id="c16a" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">运行这个:<a class="ae lk" href="https://jsfiddle.net/functionalCategories/ab5xcpyt/" rel="noopener ugc nofollow" target="_blank"> JS拨弄</a></p><p id="190f" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">提升函数f的映射函数:int →int它遵循以下步骤:</p><figure class="lm ln lo lp gt ip gh gi paragraph-image"><div class="gh gi nu"><img src="../Images/5b5c2dec18a0bd027a691ae4f73e347c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1190/format:webp/1*wUiuLCijiETkb0zaZr8J7w.png"/></div></figure><p id="0fc3" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">1.等待承诺的结果(因此在某种程度上解开了包含的值)<code class="fe nq nr ns lv b">initialPromise.then()</code></p><p id="4d19" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">2.应用功能<code class="fe nq nr ns lv b"> f : result =&gt; resolve(f(result))</code></p><p id="3935" class="pw-post-body-paragraph ko kp iy kq b kr ks jz kt ku kv kc kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">3.将结果值再次包装到一个新的承诺:<code class="fe nq nr ns lv b">return new Promise() </code>中，因为当我们实现一个<strong class="kq iz">映射</strong>，<strong class="kq iz"> </strong>时，我们总是返回相同类型的东西，以便属于相同的类别(在本例中为类型)或承诺。</p></div></div>    
</body>
</html>