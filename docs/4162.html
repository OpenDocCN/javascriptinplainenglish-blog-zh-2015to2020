<html>
<head>
<title>What’s New in ES2021?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ES2021有什么新功能？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/whats-new-in-es2021-99921c01f220?source=collection_archive---------1-----------------------#2020-11-21">https://javascript.plainenglish.io/whats-new-in-es2021-99921c01f220?source=collection_archive---------1-----------------------#2020-11-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2d60" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">随时了解2021年JavaScript即将推出的新特性</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/073bc742d07e2e8ccf2e061c5aba53d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6NXBv0LELNYtzfFW"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@shekatherine?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ekaterina Shevchenko</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="fb57" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自2015年以来，JavaScript每年都会不断收到新功能的更新。虽然ES2021/ES12将于明年发布，但我们已经可以看到未来的发展，因为许多功能已经达到<a class="ae kv" href="https://tc39.es/process-document/#:~:text=Spec%20compliant-,4,in%20the%20formal%20ECMAScript%20standard" rel="noopener ugc nofollow" target="_blank">阶段4(完成)规范</a>，并将包含在规范中。在本文中，我将讨论已经达到第四阶段并添加到Google Chrome V8引擎中的功能。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="e467" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">字符串.原型. replaceAll</h1><p id="fa8a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">String.prototype.replace</code>是一个现有的方法，允许我们用其他东西替换字符串中的模式。在这个方法中需要记住的一点是，当我们替换一个模式时，只有该模式在字符串中的第一次出现才会被替换。为了替换所有的出现，我们使用<strong class="ky ir"> RegEx </strong>来达到同样的目的。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="6304" class="ne ma iq mz b gy nf ng l nh ni">const str = 'I love Javascript and Javascript is awesome!';<br/>str.replace('Javascript', 'coding');<br/>// "I love coding and Javascript is awesome!"</span><span id="c6f3" class="ne ma iq mz b gy nj ng l nh ni">// Alternate solution to replace all occurrences<br/>str.replace(/Javascript/g, 'coding');<br/>// "I love coding and coding is awesome!"</span></pre><p id="ec6d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些年来，还没有像replaceAll这样的方法，不用正则表达式就能替换所有出现的内容。ES2021引入了这种新方法来克服这一障碍。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="da79" class="ne ma iq mz b gy nf ng l nh ni">const str = 'I love Javascript and Javascript is awesome!';<br/>str.replaceAll('Javascript', 'coding');<br/>// "I love coding and coding is awesome!"</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="cdeb" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">承诺。任何</h1><p id="8104" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><strong class="ky ir"> Promise.any() </strong>方法接受一个承诺列表，并在遇到列表中的第一个已解析承诺时立即返回值。如果所有的承诺都被拒绝，那么它将抛出一个<code class="fe mw mx my mz b">AggregatedError</code>消息。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="efbf" class="ne ma iq mz b gy nf ng l nh ni">Promise.any(promises).then(<br/>  (first) =&gt; {<br/>    // Any of the promises was fulfilled.<br/>  },<br/>  (error) =&gt; {<br/>    // All of the promises were rejected.<br/>  }<br/>);</span></pre><p id="ea70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种方法与<code class="fe mw mx my mz b">Promise.race</code>不同，因为在<code class="fe mw mx my mz b">race</code>中，当一个给定的承诺<strong class="ky ir">解决</strong>或<strong class="ky ir">拒绝</strong>时，承诺会短路一次，但在这里，如果任何一个承诺被履行，承诺就会被解决，只有当<strong class="ky ir">所有</strong>承诺都被拒绝时，承诺才会被拒绝。</p><p id="2238" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子可以证明这一点:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="8892" class="ne ma iq mz b gy nf ng l nh ni">Promise.any([</span><span id="d614" class="ne ma iq mz b gy nj ng l nh ni">new Promise((resolve, reject) =&gt; setTimeout(reject, 200, 'One')),</span><span id="c875" class="ne ma iq mz b gy nj ng l nh ni">new Promise((resolve, reject) =&gt; setTimeout(resolve, 1000, 'Two')),</span><span id="57c7" class="ne ma iq mz b gy nj ng l nh ni">new Promise((resolve, reject) =&gt; setTimeout(resolve, 2000, 'Three'))</span><span id="b89f" class="ne ma iq mz b gy nj ng l nh ni">])</span><span id="bb45" class="ne ma iq mz b gy nj ng l nh ni">.then((value) =&gt; console.log(`Result - ${value}`))</span><span id="8da2" class="ne ma iq mz b gy nj ng l nh ni">.catch((err) =&gt; console.log(err));</span><span id="af43" class="ne ma iq mz b gy nj ng l nh ni"><br/>// OUTPUT<br/>// Result - Two</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3d7d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">逻辑赋值运算符</h1><p id="c58a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">逻辑赋值运算符用赋值运算符组合逻辑运算(<code class="fe mw mx my mz b">&amp;&amp;</code>、<code class="fe mw mx my mz b">||</code>或<code class="fe mw mx my mz b">??</code>)。</p><h2 id="f711" class="ne ma iq bd mb nk nl dn mf nm nn dp mj lf no np ml lj nq nr mn ln ns nt mp nu bi translated">1.带&amp;&amp;运算符的逻辑赋值运算符</h2><p id="dd54" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果<code class="fe mw mx my mz b">a</code>和<code class="fe mw mx my mz b">b</code>都为真，则<code class="fe mw mx my mz b">a &amp;&amp;= b</code>将返回<code class="fe mw mx my mz b">b</code>，否则将返回<code class="fe mw mx my mz b">a</code>。换句话说，只有当LHS值为真时，它才会将RHS变量值赋给LHS变量。</p><p id="8f17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="2e30" class="ne ma iq mz b gy nf ng l nh ni">let a = 1;<br/>let b = 2;</span><span id="bb74" class="ne ma iq mz b gy nj ng l nh ni">a &amp;&amp;= b</span><span id="c485" class="ne ma iq mz b gy nj ng l nh ni">// Or</span><span id="9ae2" class="ne ma iq mz b gy nj ng l nh ni">a &amp;&amp; (a = b)</span><span id="e54e" class="ne ma iq mz b gy nj ng l nh ni">// Or </span><span id="ce93" class="ne ma iq mz b gy nj ng l nh ni">if(a) {<br/>  a = b<br/>}</span><span id="634f" class="ne ma iq mz b gy nj ng l nh ni">// OUTPUT<br/>// 2</span></pre><h2 id="be2c" class="ne ma iq bd mb nk nl dn mf nm nn dp mj lf no np ml lj nq nr mn ln ns nt mp nu bi translated">2.带有||运算符的逻辑赋值运算符</h2><p id="ad65" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">如果<code class="fe mw mx my mz b">a</code>为真，<code class="fe mw mx my mz b">a ||= b</code>将返回<code class="fe mw mx my mz b">a</code>，否则将返回<code class="fe mw mx my mz b">b</code>。换句话说，只有当LHS值为falsy时，它才会将RHS变量值赋给LHS变量。</p><p id="9f0a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="bca0" class="ne ma iq mz b gy nf ng l nh ni">let a;<br/>let b = 2;</span><span id="8307" class="ne ma iq mz b gy nj ng l nh ni">a ||= b</span><span id="db3f" class="ne ma iq mz b gy nj ng l nh ni">// Or</span><span id="bb72" class="ne ma iq mz b gy nj ng l nh ni">a || (a = b)</span><span id="3d22" class="ne ma iq mz b gy nj ng l nh ni">// Or</span><span id="ca2d" class="ne ma iq mz b gy nj ng l nh ni">if(!a) {<br/>  a = b<br/>}</span><span id="7f6d" class="ne ma iq mz b gy nj ng l nh ni">// OUTPUT<br/>// 2</span></pre><h2 id="3286" class="ne ma iq bd mb nk nl dn mf nm nn dp mj lf no np ml lj nq nr mn ln ns nt mp nu bi translated">3.逻辑赋值运算符。？操作员</h2><p id="67fd" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">??</code>也被称为<strong class="ky ir">无效</strong> <strong class="ky ir">合并</strong>运算符，它检查值是<code class="fe mw mx my mz b">null</code>还是<code class="fe mw mx my mz b">undefined</code>。如果<code class="fe mw mx my mz b">a</code>为<code class="fe mw mx my mz b">null</code>或<code class="fe mw mx my mz b">undefined</code>，则<code class="fe mw mx my mz b">a ??= b</code>将返回<code class="fe mw mx my mz b">b</code>，否则将返回<code class="fe mw mx my mz b">b</code>。换句话说，只有当LHS值为<code class="fe mw mx my mz b">null</code>或<code class="fe mw mx my mz b">undefined</code>时，它才会将RHS变量值赋给LHS变量。</p><p id="f56e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="247c" class="ne ma iq mz b gy nf ng l nh ni">let a;<br/>let b = 2;</span><span id="68b4" class="ne ma iq mz b gy nj ng l nh ni">a ??= b</span><span id="88ab" class="ne ma iq mz b gy nj ng l nh ni">// Or</span><span id="5b5a" class="ne ma iq mz b gy nj ng l nh ni">a ?? (a = b)</span><span id="8b04" class="ne ma iq mz b gy nj ng l nh ni">// Or</span><span id="0199" class="ne ma iq mz b gy nj ng l nh ni">if(!a) {<br/>  a = b<br/>}</span><span id="113e" class="ne ma iq mz b gy nj ng l nh ni">// OUTPUT<br/>// 2</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="0122" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">数字分隔符</h1><p id="c29b" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><strong class="ky ir">数字分隔符</strong>将通过使用<code class="fe mw mx my mz b">_</code>字符在各组数字之间提供分隔，使读取数值变得更容易。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="1905" class="ne ma iq mz b gy nf ng l nh ni">rs = 1_00_000;<br/>// 100000</span></pre><p id="9e4a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这只是作为一种表示，因为开发人员更容易通读代码。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="ed61" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">WeakRefs</h1><p id="027c" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">WeakRef</code>代表弱引用。弱引用的主要用途是实现<strong class="ky ir">缓存</strong>。</p><p id="9ef1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为JavaScript是一种垃圾收集语言，如果一个变量不再可达，GC会自动删除它。作为一个好的实践，我们不希望在很长一段时间内保留很多内容。我们可以允许内存被垃圾收集，以后如果我们再次需要它，我们可以生成一个新的缓存。</p><p id="4956" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="1a00" class="ne ma iq mz b gy nf ng l nh ni">// callback function<br/>const callback = () =&gt; {<br/>  const obj = {<br/>    name: "Harsha"<br/>  };<br/>  console.log(obj);<br/>}</span><span id="f20a" class="ne ma iq mz b gy nj ng l nh ni">// IIFE function to print the object after 3 secs<br/>(async function(){<br/>  await new Promise((resolve) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      callback(); // {name: "Harsha"}<br/>      resolve();<br/>    }, 3000);<br/>  });<br/>})();</span></pre><p id="ccff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的例子可能看起来很复杂。但是，这其实很简单。这段代码基本上在3秒钟后调用一个回调函数，该函数打印一个对象。每当我们调用回调函数时，<code class="fe mw mx my mz b">obj</code>仍然存在于内存中。为了有效地管理<strong class="ky ir">缓存</strong>，我们可以使用<code class="fe mw mx my mz b">WeakRef</code>。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="c4ef" class="ne ma iq mz b gy nf ng l nh ni">// callback function<br/>const callback = () =&gt; {<br/>  const obj = new WeakRef({    <br/>    name: "Harsha"  <br/>  });  <br/>  console.log(obj.deref().name);<br/>}</span><span id="6321" class="ne ma iq mz b gy nj ng l nh ni">// IIFE function to print the object after 2 and 5 secs<br/>(async function(){<br/>  await new Promise((resolve) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      callback(); // Guaranteed to print "Harsha"<br/>      resolve();<br/>    }, 2000);<br/>  });<br/><br/>  await new Promise((resolve) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      callback(); // No Gaurantee that "Harsha" is printed<br/>      resolve();<br/>    }, 5000);<br/>  });<br/>})();</span></pre><p id="dbce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe mw mx my mz b">WeakRef</code>中，使用<code class="fe mw mx my mz b">deref()</code>方法读取参考值。第一次将打印该值，第二次不保证会打印出来，因为它可能已经被GC清除了。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="54f7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">终结注册表</h1><p id="84e8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">FinalizationRegistry</code>允许程序员注册对象被垃圾收集后调用的回调函数。据说是<code class="fe mw mx my mz b">WeakRef</code>的配套功能。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="2088" class="ne ma iq mz b gy nf ng l nh ni">const registry = new FinalizationRegistry((value) =&gt; {<br/>  console.log(value);<br/>});</span></pre><p id="baa7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里<code class="fe mw mx my mz b">registry</code>是<code class="fe mw mx my mz b">FinalizationRegistry</code>的一个实例。传递给<code class="fe mw mx my mz b">FinalizationRegistry</code>的回调函数在对象被垃圾收集时被触发。</p><p id="b357" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="23b6" class="ne ma iq mz b gy nf ng l nh ni">(function () {<br/>  const obj = {};<br/>  registry.register(obj, "Harsha");<br/>})();</span></pre><p id="1073" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe mw mx my mz b">obj</code>被垃圾收集时，<code class="fe mw mx my mz b">"Harsha"</code>被传递给回调函数并打印在控制台中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nv"><img src="../Images/28338d2596243305d464ad68499a143b.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*dcOqm5Twd27AadpurjCncA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">When the garbage is collected Harsha is printed out</figcaption></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="c33d" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">国际号码。列表格式</h1><p id="246d" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated"><code class="fe mw mx my mz b">Intl.ListFormat</code>对象是支持语言敏感列表格式的对象的构造函数。它接受两个参数——第一个参数是区域设置，第二个参数是具有两个属性(样式和类型)的options对象。看一个例子比用语言解释要容易得多:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="7038" class="ne ma iq mz b gy nf ng l nh ni">const list = ['King', 'Queen', 'Jack'];<br/><br/>new Intl.ListFormat('en', { style: 'long', type: 'conjunction' }).format(list);<br/>// King, Queen and Jack<br/><br/>new Intl.ListFormat('en', { style: 'short', type: 'disjunction' }).format(list);<br/>// King, Queen or Jack</span></pre><p id="e3d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您也可以尝试其他语言。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="7b19" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">Intl的日期样式和时间样式选项。日期时间格式</h1><p id="1696" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">现在，我们可以使用<code class="fe mw mx my mz b">dateStyle</code>和<code class="fe mw mx my mz b">timeStyle</code>来请求给定长度的特定于地区的日期和时间。我们只需要将它们作为选项传递，其余的就可以处理了。</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="c0d3" class="ne ma iq mz b gy nf ng l nh ni">// short<br/>new Intl.DateTimeFormat("en" , {<br/>  timeStyle: "short"<br/>}).format(Date.now())<br/>// "6:35 PM"<br/><br/>// medium<br/>new Intl.DateTimeFormat("en" , {<br/>  timeStyle: "medium"<br/>}).format(Date.now())<br/>// "6:35:13 PM"<br/><br/>// long<br/>new Intl.DateTimeFormat("en" , {<br/>  timeStyle: "long"<br/>}).format(Date.now())<br/>// "6:35:55 PM GMT+5:30"</span></pre><p id="7d40" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于<code class="fe mw mx my mz b">dateStyle</code>，这里有几个例子:</p><pre class="kg kh ki kj gt na mz nb nc aw nd bi"><span id="55bc" class="ne ma iq mz b gy nf ng l nh ni">// short<br/>new Intl.DateTimeFormat("en" , {<br/>  dateStyle: "short"<br/>}).format(Date.now())<br/>// "11/19/20"<br/><br/>// medium<br/>new Intl.DateTimeFormat("en" , {<br/>  dateStyle: "medium"<br/>}).format(Date.now())<br/>// "Nov 19, 2020"<br/><br/>// long<br/>new Intl.DateTimeFormat("en" , {<br/>  dateStyle: "long"<br/>}).format(Date.now())<br/>// "November 19, 2020"</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="464a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">结论</strong></h1><p id="83b3" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">作为一名开发人员，了解任何编程语言的新特性是很重要的。我希望，我已经给了你一个简短的想法，什么都还没有到来。</p><p id="b3bf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢您阅读并在评论中删除您最喜欢的功能！</p></div></div>    
</body>
</html>