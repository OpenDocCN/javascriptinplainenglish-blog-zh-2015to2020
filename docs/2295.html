<html>
<head>
<title>Skeleton Loading State as a System</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">骨架加载状态作为一个系统</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/skeleton-loading-state-as-a-system-286e828ddf75?source=collection_archive---------1-----------------------#2020-06-09">https://javascript.plainenglish.io/skeleton-loading-state-as-a-system-286e828ddf75?source=collection_archive---------1-----------------------#2020-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="e588" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个关于如何在前端应用程序中实现框架加载基础结构的演练。该方法将框架状态构建为一个<em class="kl">系统</em>，因此您的前端可以在保持加载状态一致性的同时进行扩展。对于这个例子，我将使用React、React上下文和钩子。</p><h1 id="cd86" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">基本想法</h1><p id="0efc" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">为用户界面中最底层的组件实现一个“框架状态”。然后使用您选择的框架的状态管理特性，在必要时打开和关闭框架状态。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/fbe3c9331a4d630881a1320df70f59c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*7Y7VUlLLpTfu0XGggv47aA.gif"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Text component changes from regular state to skeleton state</figcaption></figure><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/5bceadf0c3f75010d04a9c0cc488430c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*y-7dVNnUE3kxHYzyUvHxWg.gif"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Icon component changes from regular state to skeleton state</figcaption></figure><p id="187f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于较高级别的组件是由较低级别的组件组成的，每个向前(或向上)移动的新组件都可以免费获得一个框架状态视图。正是这一概念允许应用程序向上扩展，而无需在应用程序增长时为每个新组件构建唯一的框架状态的技术开销。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi lp"><img src="../Images/93935a83d59d2ff277c60090f8a2acb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*ksXJk7nWQ7lgYwh2nE9tqQ.gif"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">DetailsCard component changes from regular state to skeleton state</figcaption></figure><h1 id="457c" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">低级组件</h1><p id="e06a" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">良好的低电平元件包括<code class="fe mf mg mh mi b">&lt;Text/&gt;</code>、<code class="fe mf mg mh mi b">&lt;Image/&gt;</code>和<code class="fe mf mg mh mi b">&lt;Icon/&gt;</code>。这些常见组件的行为符合预期，即文本呈现文本，图像呈现图像，等等。但是在这种方法中，它们都将构建有自己的后续“加载”视图，可以打开和关闭。</p><h2 id="0180" class="mj kn iq bd ko mk ml dn ks mm mn dp kw jy mo mp la kc mq mr le kg ms mt li mu bi translated">文本组件</h2><p id="3e8d" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">默认情况下，文本组件将呈现传入的任何文本和样式。如果道具<code class="fe mf mg mh mi b">skeleton</code>作为<code class="fe mf mg mh mi b">true</code>传入，它将呈现一个带有灰色背景和圆形边缘的条，就像上面的图片示例一样。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Text component with a skeleton state</figcaption></figure><h2 id="9b5e" class="mj kn iq bd ko mk ml dn ks mm mn dp kw jy mo mp la kc mq mr le kg ms mt li mu bi translated">图像组件</h2><p id="6ad9" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">图像组件遵循相同的原理。它将使用传入的任何源来呈现图像。但是如果<code class="fe mf mg mh mi b">skeleton</code>道具是<code class="fe mf mg mh mi b">true</code>，它会呈现一个灰色的方框表示“正在加载”。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Image component with a skeleton state</figcaption></figure><h1 id="5753" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">高级组件</h1><p id="8f6b" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">正如我之前提到的，较高级别的组件是由较低级别的组件组成的，因此与后续的框架视图打包在一起。例如，一个<code class="fe mf mg mh mi b">&lt;DetailsCard/&gt;</code>可能看起来像这样。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="a94b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，这个组件不需要框架状态的代码，但是框架视图立即可用。由于代码中没有提到，所以骨架状态是否可用并不十分明显，但这是部分原因。该组件由“支持框架”的组件组成，因此它本身也是“支持框架”的。随着应用程序的发展而构建的任何新组件都可以免费获得按需加载状态。</p><p id="ed95" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">由于管理应用程序框架状态的外观和感觉发生在应用程序的一个完全不同的区域(低级组件)，因此可伸缩性也得到显著实现。为了说明这一点，设想在应用程序的所有框架状态上引入动画效果。通过将其应用于低级组件，动画效果立即应用于每个组件的<em class="kl">。</em></p><p id="0ec1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是这种方法的核心。下一部分将介绍骨架状态是如何打开和关闭的。</p><h1 id="cd50" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">通信状态</h1><p id="f5d5" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">考虑一个应用程序，它有一个搜索字段来查找github repos。在搜索框中输入一个词会启动一个对github的API请求。响应以列表的形式返回，填充在搜索字段下方。当请求发出和返回时，UI显示一个框架状态来帮助用户理解发生了什么。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mx"><img src="../Images/5e8052432d265597197f56d609cf1b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GSDg_u0eNVS-Gh7wcw3jCg.gif"/></div></div></figure><p id="536a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">React中的一个简单实现可能有一个用于标题区域的<code class="fe mf mg mh mi b">&lt;Header/&gt;</code>组件、一个用于搜索框的<code class="fe mf mg mh mi b">&lt;Search/&gt;</code>组件和一个用于呈现搜索结果的<code class="fe mf mg mh mi b">&lt;RepoList/&gt;</code>组件。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Example fetch request for git repositories on submit</figcaption></figure><p id="2e9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">注意，第25行的<code class="fe mf mg mh mi b">onSubmit</code>回调触发了<code class="fe mf mg mh mi b">handleSearchSubmit</code>函数来发出API请求。当请求开始时，第7行将本地<code class="fe mf mg mh mi b">isLoading</code>状态设置为<code class="fe mf mg mh mi b">true</code>，当请求完成时，返回到第19行的<code class="fe mf mg mh mi b">false</code>。在第18行，来自API请求的响应存储在<code class="fe mf mg mh mi b">gitRepos</code>本地状态中。最后，<code class="fe mf mg mh mi b">gitRepos</code>和<code class="fe mf mg mh mi b">isLoading</code>状态被传递给<code class="fe mf mg mh mi b">&lt;RepoList/&gt;</code>组件。</p><p id="0d27" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">呈现搜索查询结果的<code class="fe mf mg mh mi b">&lt;RepoList/&gt;</code>组件接受一个数据数组，并呈现一个<code class="fe mf mg mh mi b">&lt;DetailsCard/&gt;</code>组件列表。它还需要一个<code class="fe mf mg mh mi b">isLoading</code> prop来理解何时获取数据。在下面的例子中，当<code class="fe mf mg mh mi b">isLoading</code>设置为true时，它将真实数据交换为一列假占位符数据(第11行)。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="5c9f" class="mj kn iq bd ko mk ml dn ks mm mn dp kw jy mo mp la kc mq mr le kg ms mt li mu bi translated">向下传递数据</h2><p id="088d" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">当API请求正在进行时，您需要告诉底层组件进入它们的框架状态。在React中，您可以向下传递道具，但这需要<a class="ae my" href="https://medium.com/@jeromefranco/how-to-avoid-prop-drilling-in-react-7e3a9f3c8674" rel="noopener">道具钻孔</a>才能够到低级组件。随着越来越多的组件被嵌套，跟踪道具是非常麻烦的，这就是为什么一般不建议使用道具钻孔。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mz"><img src="../Images/552b2a260dc1bad4a2d0e44a361fcc98.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_QzpnK47mQHNDIDAD05Kdw.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Diagram of prop drilling</figcaption></figure><p id="a430" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">相反，我们将使用<a class="ae my" href="https://reactjs.org/docs/context.html" rel="noopener ugc nofollow" target="_blank">反应上下文</a>。使用React上下文，您可以与任何子组件共享状态，而不管有多少层。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mz"><img src="../Images/4fe5c0c0dd2bf5823930ccc1dd133b9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*81xS1kOh13C2yHJ7WGFidg.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Diagram of React Context</figcaption></figure><p id="fdf2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们将创建一个名为<code class="fe mf mg mh mi b">skeleton.js</code>的新文件。它有一个<code class="fe mf mg mh mi b">SkeletonContext</code>变量来存储用于打开和关闭骨架状态的布尔值。和一个共享状态的<code class="fe mf mg mh mi b">&lt;SkeletonArea/&gt;</code>提供者组件。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Skeleton context and provider</figcaption></figure><p id="c0cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将用新的<code class="fe mf mg mh mi b">&lt;SkeletonArea/&gt;</code>组件将整个应用程序包装在<code class="fe mf mg mh mi b">app.js</code>中(下面的第22和28行),并传入<code class="fe mf mg mh mi b">isLoading</code>属性。通过将<code class="fe mf mg mh mi b">isLoading</code>属性传递给提供者，您可以有效地将该值作为其所有子组件的全局状态进行共享。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk">App.js wrapped with a context provider</figcaption></figure><p id="b1cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们将使用新的上下文提供者更新所有底层组件，以便它们知道何时进入“框架”状态。下面的每个文件都有一个由上下文提供者设置的名为<code class="fe mf mg mh mi b">isLoading</code>的新布尔变量。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Level components consuming the context provider</figcaption></figure><h1 id="e97a" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">孤立的骨架区域</h1><p id="c74f" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">这个解决方案有一个问题。由于所有的组件都使用相同的状态，您可能会得到一个不应该与“加载”相关联的页面区域的框架视图。例如，当获取搜索响应(“加载”)时，这里的头不应进入骨架状态。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mx"><img src="../Images/562a73295269e729fa7b45e54379606c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*A03edc-lRx0qHLgSfftdjA.gif"/></div></div></figure><p id="3426" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了解决这个问题，您可以在一组组件的边界应该共享相同框架状态的每个点上嵌套React上下文提供程序。在下图中，提供者只包装了结果列表，为特定的组件树创建了一个隔离的全局状态区域。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mz"><img src="../Images/5fcc13ecb570d83e8a1d87e242d55d10.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ULLV2VnSCgg_nMs-RFZe7Q.png"/></div></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Diagram of isolated React Context</figcaption></figure><p id="1ef5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们更新代码来隔离列表结果，如上图所示。因为我们只希望骨架状态出现在结果列表中，所以我们将它从<code class="fe mf mg mh mi b">app.js</code>中移除，并将其添加到<code class="fe mf mg mh mi b">&lt;RepoList/&gt;</code>组件中。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Moves the context provider to the RepoList component</figcaption></figure><p id="0bfd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了想要的行为。只有列表区域显示一个框架状态。</p><figure class="lq lr ls lt gt lu gh gi paragraph-image"><div role="button" tabindex="0" class="lv lw di lx bf ly"><div class="gh gi mx"><img src="../Images/5e8052432d265597197f56d609cf1b3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*GSDg_u0eNVS-Gh7wcw3jCg.gif"/></div></div></figure><h1 id="35c4" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">使用骨架挂钩</h1><p id="4c39" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">现在一切正常，但是代码需要打包以便重用。为此，我将在React钩子中捕获模式细节，并公开一个小API以供重用。我将调用钩子<code class="fe mf mg mh mi b">useSkeletonData</code>，钩子的API将接受3个参数。</p><ul class=""><li id="1461" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated"><code class="fe mf mg mh mi b"><strong class="jp ir">fakeData</strong></code>:这是组件在骨架状态下使用的数据。把它想象成占位符数据。</li><li id="e965" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated"><code class="fe mf mg mh mi b"><strong class="jp ir">realData</strong></code>:这是组件在不处于框架状态时使用的数据。</li><li id="a436" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated"><code class="fe mf mg mh mi b"><strong class="jp ir">isLoadingPredicate</strong></code>:这个函数返回一个布尔值。它的目的是远程控制任何低级子组件何时应该进入它们的框架状态。</li></ul><p id="495f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">钩子(第18行)将返回一个数据对象，或者是实数，或者是占位符，这取决于上面描述的谓词函数，以及一个“<code class="fe mf mg mh mi b">connector</code>”对象。(连接器是允许钩子控制低级组件的骨架状态的必要部件)。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Adds two hooks for toggling data and consuming data</figcaption></figure><p id="7c26" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了新的钩子，我将把它应用到<code class="fe mf mg mh mi b">&lt;RepoList/&gt;</code>组件上。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk">RepoList component updated with the useSkeletonData hook</figcaption></figure><p id="d7bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第16行获取真实数据，第17行获取虚假数据，第18行获取谓词函数。在这种情况下，它返回<code class="fe mf mg mh mi b">isLoading</code>道具来控制骨骼状态。最后，第10行在上下文组件中传递了<code class="fe mf mg mh mi b">connector</code>对象。</p><p id="015e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">回到<code class="fe mf mg mh mi b">skeleton.js</code>文件，我将为底层组件再创建一个钩子(下面的第16行)，<code class="fe mf mg mh mi b">useIsSkeletonLoading</code>。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="b8b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">任何低级别的组件都将能够使用这个钩子，而不是直接导入React上下文来打开和关闭它们的框架视图。下面是如何更新<code class="fe mf mg mh mi b">&lt;Text/&gt;</code>组件。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="3523" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所有其他低级组件也将被更新。</p><h1 id="316f" class="km kn iq bd ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj bi translated">沙箱</h1><p id="5968" class="pw-post-body-paragraph jn jo iq jp b jq lk js jt ju ll jw jx jy lm ka kb kc ln ke kf kg lo ki kj kk ij bi translated">我们已经解决了许多复杂的问题:</p><ul class=""><li id="f38b" class="na nb iq jp b jq jr ju jv jy nc kc nd kg ne kk nf ng nh ni bi translated">按需骨架组件</li><li id="9e64" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">孤立的骨架区域</li><li id="8ec2" class="na nb iq jp b jq nj ju nk jy nl kc nm kg nn kk nf ng nh ni bi translated">可重用API</li></ul><p id="cd3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这个沙盒有一个运行的例子。</p><figure class="lq lr ls lt gt lu"><div class="bz fp l di"><div class="no mw l"/></div><figcaption class="mb mc gj gh gi md me bd b be z dk">Sandbox</figcaption></figure><p id="dada" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">感谢你阅读❤</p><p id="944c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">- —— - <br/> Nathaniel是<a class="ae my" href="http://rangle.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jp ir"> Rangle.io </strong> </a>的解决方案架构师</p></div></div>    
</body>
</html>