<html>
<head>
<title>Async &amp; Defer — How to Load JavaScript Properly</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">异步和延迟——如何正确加载JavaScript</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/async-and-defer-the-complete-guide-to-loading-javascript-properly-ce6edce1e6b5?source=collection_archive---------1-----------------------#2020-05-25">https://javascript.plainenglish.io/async-and-defer-the-complete-guide-to-loading-javascript-properly-ce6edce1e6b5?source=collection_archive---------1-----------------------#2020-05-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7470" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解决错误并提高性能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/99273ef0ce744b4b7b9e7d8f0443dbca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DYrc880yiPsigIIaLzrFNg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Async and defer in a HTML script tag</figcaption></figure><p id="5855" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用script标签将外部脚本加载到HTML中可能是必不可少的。虽然它实际上是如此重要，但还是会出现问题。</p><p id="bbc8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> async </strong>和<strong class="kx ir"> defer </strong>都是HTML中经典脚本标签的属性，它允许我们指定外部JavaScript应该如何加载。</p><p id="4d7e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，在本文中，我们将讨论如何同时优化我们的脚本标签。</p><h1 id="40bc" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">为什么应该使用异步和延迟？</h1><p id="30a6" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">因为加载和执行外部脚本可能会导致错误，这可能是每个开发人员都经历过的。通常只是顺序不对，因为浏览器从上到下读取和执行HTML文档——至少这是我们的脚本标签的标准，它可以包含JavaScript代码本身，或者引用外部文件。让我们看一个经常出现的问题的例子:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="ab6f" class="mt ls iq mp b gy mu mv l mw mx">&lt;head&gt;<br/>  &lt;script&gt;<br/>    console.log(document.querySelector('h1'))<br/>  &lt;/script&gt;<br/>&lt;/head&gt;</span><span id="30cf" class="mt ls iq mp b gy my mv l mw mx">&lt;body&gt;<br/>  &lt;h1&gt;our headline&lt;/h1&gt;<br/>&lt;/body&gt;</span></pre><p id="e438" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们的console.log现在将输出<strong class="kx ir"><em class="mz">【null】</em></strong>，因为我们在H1在DOM中可用之前执行了JavaScript。因此<strong class="kx ir"> querySelector </strong>不能访问该元素，因为它实际上还不存在。</p><p id="7868" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">不管我们是在脚本标记中包含代码，还是在相同的位置用包含相同代码的脚本标记加载外部脚本，我们的console.log都会返回“null”，因为我们的h1标记还不存在。</p><p id="3257" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">理解这一点很重要，因为JavaScript也<strong class="kx ir">阻止了我们的DOM构造</strong>——只要浏览器遇到一个脚本，它就会立即被加载和执行，即使它实际上应该访问DOM，而那时DOM还不存在——而且它还阻止了DOM的构造，因为浏览器在那个时刻优先考虑脚本。</p><h2 id="58ee" class="mt ls iq bd lt na nb dn lx nc nd dp mb le ne nf md li ng nh mf lm ni nj mh nk bi translated">这不是唯一的问题</h2><p id="3d69" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">实际上，关于刚才描述的问题，你可以简单地说，我们需要访问DOM的脚本应该总是包含在页面的末尾——换句话说，以这样的方式，当DOM准备好时，它们只被<strong class="kx ir">加载</strong>和<strong class="kx ir">执行</strong>，即页面已经对用户可见。</p><p id="4fed" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是如果浏览器现在遇到一个脚本，哪怕只是在页面的最后，也要先完整加载执行。</p><p id="1944" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在当今世界，JavaScript在现代网站的动态中扮演着关键角色，这意味着页面在这个时间点已经可见，但用户不一定能与之交互，因为处理事件或输入所需的脚本尚未加载和执行。</p><p id="f247" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，用户坐在一个表面上已经完成的网站前面，但是如果它实际上需要在后台运行JavaScript，它就不能对任何事情做出反应。这是一种非常令人沮丧的体验，尤其是在网速很慢、网络连接很差的移动设备上。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="ea79" class="lr ls iq bd lt lu ns lw lx ly nt ma mb jw nu jx md jz nv ka mf kc nw kd mh mi bi translated">解决方案1:异步</h1><p id="5f0e" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">就像defer一样，当我们使用async来包含外部脚本时，它是经典脚本标签的一个属性。正确使用它很容易，如下所示:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="e130" class="mt ls iq mp b gy mu mv l mw mx">&lt;script src="jquery.js" async&gt;&lt;/script&gt;</span></pre><p id="c620" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">因此，我们只需包含async as属性，就像它与defer一起工作一样，但稍后会详细介绍。</p><p id="b7aa" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> async </strong>意味着我们的脚本与所有其他资源并行加载，浏览器可以构建DOM并同时加载脚本。Async保证加载脚本不再阻塞DOM。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/4bb302083c62f6004c88932af3904100.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*SOnsEgF-mT8XCLFiANGPfw.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">How async works</figcaption></figure><h2 id="db5a" class="mt ls iq bd lt na nb dn lx nc nd dp mb le ne nf md li ng nh mf lm ni nj mh nk bi translated"><strong class="ak">重要的</strong></h2><p id="fcc2" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">只有<strong class="kx ir">加载</strong>不再阻塞——一旦脚本完成加载，它将立即执行<strong class="kx ir"/>，从而阻塞浏览器正在做的任何事情。</p><p id="23f5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">而这正是我们用<strong class="kx ir"> async </strong> : <br/> <strong class="kx ir">要注意的，不清楚脚本什么时候加载完，什么时候执行。</strong></p><h2 id="9a69" class="mt ls iq bd lt na nb dn lx nc nd dp mb le ne nf md li ng nh mf lm ni nj mh nk bi translated">何时不使用异步属性加载脚本</h2><ul class=""><li id="bc47" class="ny nz iq kx b ky mj lb mk le oa li ob lm oc lq od oe of og bi translated">因此，要小心使用加载脚本来访问带有异步<strong class="kx ir">的DOM。</strong></li><li id="2ed5" class="ny nz iq kx b ky oh lb oi le oj li ok lm ol lq od oe of og bi translated">同样危险的是用<strong class="kx ir"> async </strong>加载几个脚本，但是它们实际上是相互依赖的——所以它们的执行顺序很重要，因为例如<strong class="kx ir">两个脚本中的一个是第二个脚本想要访问的库。</strong></li></ul><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="e846" class="mt ls iq mp b gy mu mv l mw mx">&lt;script <em class="mz">src</em>="library.js"&gt;&lt;/script&gt;</span><span id="50c4" class="mt ls iq mp b gy my mv l mw mx">&lt;script <em class="mz">src</em>="app.js"&gt;&lt;/script&gt;</span></pre><p id="e5fe" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们包含如上所示的两个没有任何异步或延迟的脚本，库将总是<strong class="kx ir">首先执行或可用</strong>。因为浏览器是从上到下的，并且为它们中的每一个提供了一个加载和执行的暂停。</p><p id="4c5a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们现在用<strong class="kx ir"> async </strong>包含两者，关键的一点是这个库当然比我们的app.js大得多，因此加载时间也相应地长。然而，使用async，两个脚本将并行加载，但是由于大小不同，它们将在不同的时间完成。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/1de7812d81866ec773f744c323508e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EPmrlR9lMNMI23FWtkJOiw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Chrome network tag showing the async loading-behavior</figcaption></figure><p id="c790" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您在这个网络选项卡中看到的，<strong class="kx ir"> app.js </strong>准备得更早，因此运行得更早。这也可以用两个文件中的<strong class="kx ir"> console.log </strong>相对容易地证明:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/35aa3e8d662a4539c12d1d458cb9e9e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:808/format:webp/1*010b-fZQbsK9t-skfI9aSA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Console logs of both files</figcaption></figure><p id="34d2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">对于这两个测试，我在开发者工具中设置了“快速3G”以使其更加真实。</p><p id="de57" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">关于这一点的结论:</strong>用async加载依赖脚本也是有风险的，因为我们想要的顺序不一定被保持。</p><h2 id="9cb5" class="mt ls iq bd lt na nb dn lx nc nd dp mb le ne nf md li ng nh mf lm ni nj mh nk bi translated">何时使用异步属性加载脚本</h2><p id="f60f" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">特别是当我们从另一个服务器加载外部JavaScripts时，当然总是会出现短暂的延迟甚至失败。如果没有<strong class="kx ir"> async </strong>属性，这个脚本会在很长一段时间内阻止我们整个网站的加载。<br/>特别是如果脚本只是一个像谷歌分析这样的分析工具，因此对用户没有附加值，出于性能和安全原因，我们应该将其与<strong class="kx ir"> async </strong>集成。</p><p id="53da" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">否则，这也适用于所有其他不能直接访问DOM的脚本。例外证实了这一规则，因为在有些情况下，如果在第一次访问DOM时因为元素尚不存在而返回“null ”,这一点也不可悲——例如，如果整个事情出于某种原因在某个时间间隔内发生。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="d030" class="lr ls iq bd lt lu ns lw lx ly nt ma mb jw nu jx md jz nv ka mf kc nw kd mh mi bi translated">解决方案2:推迟</h1><p id="2d7c" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">除了<strong class="kx ir"> async </strong>之外，还有<strong class="kx ir"> defer </strong>，用它我们可以影响脚本的加载行为。</p><p id="3016" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">就像<strong class="kx ir"> async </strong>一样，<strong class="kx ir"> defer </strong>在加载脚本时不会阻塞浏览器。<br/>对于<strong class="kx ir">异步</strong>，决定性的一点是<strong class="kx ir">异步</strong>可能会在执行过程中阻塞浏览器——而<strong class="kx ir">延迟</strong>则不会。</p><p id="e669" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">包含在<strong class="kx ir"> defer </strong>中的脚本只在DOM准备好的时候执行——因此defer对于保证访问DOM的脚本来说是理想的。</p><p id="191c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> async </strong>和<strong class="kx ir"> defer </strong>的共同点是脚本是与DOM的构造并行加载的——只是两者的脚本执行时间不同。使用<strong class="kx ir"> defer </strong>可以保证它们只有在DOM准备好的时候才会被执行。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nx"><img src="../Images/de6ca5f267c3bf6e47e88b09d1b71fa9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*zt7aoPZV2lI3muL1Oyhr7A.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">How defer works</figcaption></figure><h2 id="f33d" class="mt ls iq bd lt na nb dn lx nc nd dp mb le ne nf md li ng nh mf lm ni nj mh nk bi translated">让我们再看一下我们的库和app.js的例子</h2><p id="50f1" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">我们只需用defer替换async属性，就完成了:</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="4cbc" class="mt ls iq mp b gy mu mv l mw mx">&lt;script <em class="mz">src</em>="library.js" <em class="mz">defer</em>&gt;&lt;/script&gt;</span><span id="d2c7" class="mt ls iq mp b gy my mv l mw mx">&lt;script <em class="mz">src</em>="app.js" <em class="mz">defer</em>&gt;&lt;/script&gt;</span></pre><p id="caf3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在控制台中，首先输出来自library.js的console.log，然后输出来自app.js的console.log尽管库当然更大，因此加载时间更长。</p><p id="cb34" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是因为defer完全遵循我们用脚本标签的顺序指定的执行顺序。因此，如果我们现在交换两个脚本标签的位置，使app.js在上面，那么它将首先执行——但是像往常一样，只有当DOM准备好了，才会执行<strong class="kx ir"> defer </strong>。</p><p id="abf9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们现在查看network选项卡的部分，我们会看到几乎与我们使用async实现整个项目时相同的内容。这是因为async和defer加载脚本与DOM构造并行。<br/>但是你当然不能从网络记录中看出两人在不同的时间执行脚本。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/7bd70a688bf9919367572846993493dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h0FGvoYXdE0BjUM22pO5Mw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Almost identical as if we had used async</figcaption></figure><h2 id="b3ae" class="mt ls iq bd lt na nb dn lx nc nd dp mb le ne nf md li ng nh mf lm ni nj mh nk bi translated">何时使用defer属性加载脚本</h2><p id="5775" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">基本上，这个属性对于所有保证访问DOM的脚本都是理想的，并且必须不惜一切代价成功访问。</p><p id="e682" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们有几个相互访问的脚本也是理想的，这意味着它们必须按照我们希望的顺序执行。</p><p id="92b3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> Defer </strong>非常适合这种情况，因为执行顺序总是与我们在DOM中从上到下包含脚本的顺序相同——不管脚本的大小如何。</p></div><div class="ab cl nl nm hu nn" role="separator"><span class="no bw bk np nq nr"/><span class="no bw bk np nq nr"/><span class="no bw bk np nq"/></div><div class="ij ik il im in"><h1 id="7a22" class="lr ls iq bd lt lu ns lw lx ly nt ma mb jw nu jx md jz nv ka mf kc nw kd mh mi bi translated">最后一个例子</h1><p id="aa13" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">最后，我想把我们学到的所有知识放到一个更大的例子中，在这个例子中，你可以清楚地看到包含我们脚本的所有可能性的属性。</p><p id="dc19" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我用下面的文件结构创建了一个小例子。每个脚本都包含一个console.log来明确它是哪个脚本&amp;一个querySelector来访问DOM中的h1标签，正如它在我们的index.html中一样，如下所示。</p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="16bb" class="mt ls iq mp b gy mu mv l mw mx">├── async.js<br/>├── default.js<br/>├── defer.js<br/>└── index.html</span></pre><p id="07a8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> index.html: </strong></p><pre class="kg kh ki kj gt mo mp mq mr aw ms bi"><span id="d3f3" class="mt ls iq mp b gy mu mv l mw mx">&lt;html <em class="mz">lang</em>=”en”&gt;<br/>&lt;head&gt;<br/>  &lt;script <em class="mz">src</em>=”async.js” <em class="mz">async</em>&gt;&lt;/script&gt;<br/>  &lt;script <em class="mz">src</em>=”defer.js” <em class="mz">defer</em>&gt;&lt;/script&gt;<br/>  &lt;script <em class="mz">src</em>=”default.js”&gt;&lt;/script&gt;<br/>&lt;/head&gt;</span><span id="27f9" class="mt ls iq mp b gy my mv l mw mx">&lt;body&gt;<br/>  &lt;h1&gt;our headline&lt;/h1&gt;<br/>&lt;/body&gt;</span><span id="92ca" class="mt ls iq mp b gy my mv l mw mx">&lt;script&gt;<br/>  console.log(‘embedded:’, document.querySelector(‘h1’))<br/>&lt;/script&gt;<br/>&lt;/html&gt;</span></pre><p id="24cc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">再次强调:</strong>所有的脚本实际上都是一样的，只有它们的console.log不同，但这没问题。我这样命名default.js，因为它是“正常”包含的，没有<strong class="kx ir">延迟</strong>或<strong class="kx ir">异步</strong>。</p><p id="74f5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是Chrome和Firefox中浏览器控制台的输出。<br/>(就加载和执行行为而言，由于浏览器、任何扩展或互联网连接，总是会有偏差。)</p><div class="kg kh ki kj gt ab cb"><figure class="op kk oq or os ot ou paragraph-image"><img src="../Images/52e7307d1c269a4d19beef916717bc1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:920/format:webp/1*5UaNJlOu6m5m1Ao7KjX_5Q.png"/></figure><figure class="op kk ov or os ot ou paragraph-image"><img src="../Images/629f1a20e8d54b9e224272e492f1a0e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:620/format:webp/1*5vYQvNIuBF4XF6A2jV8cdQ.png"/><figcaption class="kr ks gj gh gi kt ku bd b be z dk ow di ox oy">On the left: Chrome, on the right side: Firefox</figcaption></figure></div><ul class=""><li id="641b" class="ny nz iq kx b ky kz lb lc le oz li pa lm pb lq od oe of og bi translated">到目前为止，结果应该是清楚的。<strong class="kx ir"> async.js </strong>是如此之小，以至于它的加载速度极快，当然，和<strong class="kx ir"> async </strong>一样，它是直接执行的。此时，它还不能访问我们的h1，因为它还不存在。</li><li id="3b6f" class="ny nz iq kx b ky oh lb oi le oj li ok lm ol lq od oe of og bi translated"><strong class="kx ir"> default.js </strong>正常加载，即加载时阻塞，执行时阻塞。因为它包含在我们的h1标记之前，并且浏览器从上到下读取所有内容，所以default.js不能访问该元素</li><li id="fcdd" class="ny nz iq kx b ky oh lb oi le oj li ok lm ol lq od oe of og bi translated">脚本<strong class="kx ir">直接嵌入</strong>在index.html中，定义在h1标签下，仅在h1标签已经进入DOM时执行。因此它可以成功地访问标签。</li><li id="f2a1" class="ny nz iq kx b ky oh lb oi le oj li ok lm ol lq od oe of og bi translated"><strong class="kx ir"> defer.js </strong>和我们的<strong class="kx ir"> async.js </strong>几乎同时被下载，但是和<strong class="kx ir"> defer </strong>一样，它会一直等到DOM准备好。因此，它当然可以成功地访问h1标签。</li></ul><h1 id="8869" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">临终遗言</h1><p id="028c" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">如果加载脚本时有延迟，并且浏览器已经在DOM中显示了h1标签，那么<strong class="kx ir"> async.js </strong>最终还是可以访问元素，因此当async在延迟加载后执行时，脚本可以成功访问DOM。</p><p id="4203" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">与我们预期的偏差总是会发生，尤其是在加载脚本时，即使没有使用<strong class="kx ir">异步</strong>或<strong class="kx ir">延迟</strong>。</p><p id="5765" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我认为提到这一点特别重要:当一个真实世界的应用程序用<strong class="kx ir">延迟</strong>和<strong class="kx ir">异步</strong>实现时，它就是测试、测试、测试。并且当然在具有不同连接的不同设备上，以避免可能的错误。</p><p id="1f56" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是通常总是有一种理想的方法来包含任何脚本，在这种情况下，您可以使用async或defer，我们已经讨论过了。但是你不一定要和他们中的一个合作。</p><h1 id="f31a" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated"><strong class="ak">用简单英语写的便条</strong></h1><p id="a9a4" class="pw-post-body-paragraph kv kw iq kx b ky mj jr la lb mk ju ld le ml lg lh li mm lk ll lm mn lo lp lq ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae pc" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kx ir">plain English . io</strong></a>找到所有这些内容——关注我们的出版物并<a class="ae pc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">订阅我们的YouTube频道</strong> </a> <strong class="kx ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>