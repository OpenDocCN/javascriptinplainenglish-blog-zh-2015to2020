<html>
<head>
<title>Introducing the JavaScript Window Object — Image and Workers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript窗口对象简介—图像和工人</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introducing-the-javascript-window-object-image-and-workers-60133f3231f9?source=collection_archive---------5-----------------------#2020-01-28">https://javascript.plainenglish.io/introducing-the-javascript-window-object-image-and-workers-60133f3231f9?source=collection_archive---------5-----------------------#2020-01-28</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2266ed23e99b05b74470989633dba315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*3tp0ziby-WVjhdLC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nathanfertig?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nathan Fertig</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4474" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">window</code>对象是一个全局对象，具有与当前DOM文档相关的属性，即浏览器选项卡中的内容。<code class="fe lb lc ld le b">window</code>对象的<code class="fe lb lc ld le b">document</code>属性拥有DOM文档以及相关的节点和方法，我们可以用它们来操作DOM节点并监听每个节点的事件。因为<code class="fe lb lc ld le b">window</code>对象是全局的，所以它在应用程序的每个部分都是可用的。当一个变量在没有<code class="fe lb lc ld le b">var</code>、<code class="fe lb lc ld le b">let</code>或<code class="fe lb lc ld le b">const</code>关键字的情况下被声明时，它们会被自动附加到<code class="fe lb lc ld le b">window</code>对象上，使它们在你的web应用程序的每个部分都可用。这仅适用于禁用严格模式的情况。如果它被启用，那么声明没有<code class="fe lb lc ld le b">var</code>、<code class="fe lb lc ld le b">let</code>或<code class="fe lb lc ld le b">const</code>的变量将被停止，因为让我们意外地声明全局变量不是一个好主意。<code class="fe lb lc ld le b">window</code>对象有许多属性。它们包括构造函数、值属性和方法。有一些方法可以操作当前的浏览器标签，比如打开和关闭新的弹出窗口等。</p><p id="d8ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在选项卡式浏览器中，每个选项卡都有自己的<code class="fe lb lc ld le b">window</code>对象，因此<code class="fe lb lc ld le b">window</code>对象总是代表代码运行时当前打开的选项卡的状态。但是，有些属性仍然适用于浏览器的所有选项卡，如<code class="fe lb lc ld le b">resizeTo</code>方法以及<code class="fe lb lc ld le b">innerHeight</code>和<code class="fe lb lc ld le b">innerWidth</code>属性。</p><p id="faad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，我们不需要直接引用<code class="fe lb lc ld le b">window</code>对象来调用方法和对象属性。例如，如果我们想使用<code class="fe lb lc ld le b">window.Image</code>构造函数，我们可以只写<code class="fe lb lc ld le b">new Image()</code>。</p><h1 id="3de0" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">构造器</h1><p id="d270" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">对象有一些构造器属性。它们包括将XML和HTML字符串解析成DOM元素、创建新的HTML DOM元素的对象，以及创建新的Web workers的对象。</p><h2 id="7452" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">DOMParser</h2><p id="ea37" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">DOMParser</code>构造函数让我们创建一个DOM解析器对象，将XML或HTML字符串解析成DOM树对象。对于HTML，我们还可以设置从DOM解析器返回的DOM节点对象的<code class="fe lb lc ld le b">innerHTML</code>或<code class="fe lb lc ld le b">outerHTML</code>元素，以添加到DOM树中。这些属性也可以用来获取对应于DOM子树的HTML片段。构造函数不接受任何参数。创建的对象有<code class="fe lb lc ld le b">parseFroMString</code>方法，根据给定的字符串将HTML或XML字符串解析成DOM树对象。它需要两个参数。第一个参数是包含我们想要解析的XML或HTML代码的字符串。该字符串必须是HTML、XML、XHTML+XML或SVG文档。第二个参数是一个字符串，它具有我们作为第一个参数传入的代码字符串的MIME类型。MIME类型可以是下列类型之一:</p><ul class=""><li id="44bb" class="mu mv iq kf b kg kh kk kl ko mw ks mx kw my la mz na nb nc bi translated"><code class="fe lb lc ld le b">text/html</code></li><li id="5b74" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><code class="fe lb lc ld le b">text/xml</code></li><li id="2d07" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><code class="fe lb lc ld le b">application/xml</code></li><li id="450c" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><code class="fe lb lc ld le b">application/xhtml+xml</code></li><li id="eb42" class="mu mv iq kf b kg nd kk ne ko nf ks ng kw nh la mz na nb nc bi translated"><code class="fe lb lc ld le b">image/svg+xml</code></li></ul><p id="fc08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以在下面的代码中使用它:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="633a" class="mi lg iq le b gy nq nr l ns nt">const xmlString = `<br/>&lt;note&gt;<br/> &lt;to&gt;John&lt;/to&gt;<br/> &lt;from&gt;Jane&lt;/from&gt;<br/> &lt;heading&gt;Greeting&lt;/heading&gt;<br/> &lt;body&gt;How are you?&lt;/body&gt;<br/>&lt;/note&gt;<br/>`;<br/>const parser = new DOMParser();<br/>const xmlDoc = parser.parseFromString(xmlString, "application/xml");<br/>console.log(xmlDoc);</span></pre><p id="6a65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们运行上面的代码时，我们获得了带有DOM节点的DOM对象。我们也可以在HTML中使用<code class="fe lb lc ld le b">parseFromString</code>方法，如下面的代码所示:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="7213" class="mi lg iq le b gy nq nr l ns nt">const htmlString = `<br/>&lt;div&gt;<br/> &lt;p&gt;From: John&lt;/p&gt;<br/> &lt;p&gt;To: Jane&lt;/p&gt;<br/> &lt;p&gt;Greeting&lt;/p&gt;<br/> &lt;p&gt;How are you?&lt;/p&gt;<br/>&lt;/div&gt;<br/>`;<br/>const parser = new DOMParser();<br/>const htmlDoc = parser.parseFromString(htmlString, "text/html");<br/>console.log(htmlDoc);<br/>for (const p of htmlDoc.body.children[0].children) {<br/>  console.log(p.innerHTML);<br/>}</span></pre><p id="2297" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们运行上面的代码时，我们用第一个<code class="fe lb lc ld le b">console.log</code>语句获得带有DOM节点的DOM对象，这使我们:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="dd3a" class="mi lg iq le b gy nq nr l ns nt">&lt;html&gt;<br/>  &lt;head&gt;&lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div&gt;<br/>      &lt;p&gt;From: John&lt;/p&gt;<br/>      &lt;p&gt;To: Jane&lt;/p&gt;<br/>      &lt;p&gt;Greeting&lt;/p&gt;<br/>      &lt;p&gt;How are you?&lt;/p&gt;<br/>    &lt;/div&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="a22a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们在上面示例代码的底部循环时，我们得到:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="13a7" class="mi lg iq le b gy nq nr l ns nt">From: John<br/>To: Jane<br/>Greeting<br/>How are you?</span></pre><p id="1018" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为<code class="fe lb lc ld le b">htmlDoc.body.children[0].children</code>为我们获取了DOM树对象，该对象有一个<code class="fe lb lc ld le b">body</code>属性来为我们获取<code class="fe lb lc ld le b">body</code>元素和其中的所有内容。该元素有一个<code class="fe lb lc ld le b">children</code>对象，该对象将<code class="fe lb lc ld le b">div</code>元素作为类似DOM树数组的对象的第一个元素，然后我们获得该对象的<code class="fe lb lc ld le b">children</code>属性，该对象有<code class="fe lb lc ld le b">p</code>元素。有了它，我们可以遍历它们并得到元素。在上面的例子中，我们使用<code class="fe lb lc ld le b">innerHTML</code>属性访问了<code class="fe lb lc ld le b">p</code>标签中的内容。</p><p id="ada4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以将<code class="fe lb lc ld le b">parseFromString</code>与SVG元素一起使用，因为SVG图形是从XML文件生成的矢量图形。因此，我们可以使用相同的方法来解析SVG字符串。</p><h2 id="c161" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">图像</h2><p id="83f3" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">Image</code>构造函数创建一个新的HTML <code class="fe lb lc ld le b">image</code>元素。这和使用<code class="fe lb lc ld le b">document.createElement('img')</code>完全一样，它也创建了一个HTML元素。<code class="fe lb lc ld le b">Image</code>构造函数有两个参数。第一个参数是以像素为单位的<code class="fe lb lc ld le b">img</code>元素的宽度，第二个参数是以像素为单位的图像元素的高度。例如，我们可以这样使用它:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="e3c5" class="mi lg iq le b gy nq nr l ns nt">const image = new Image(100, 200);<br/>image.src = '<a class="ae kc" href="https://images.unsplash.com/photo-1572315831029-5d6f20e0035d?ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=750&amp;q=80'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1572315831029-5d6f20e0035d?ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=750&amp;q=80'</a>;<br/>document.body.appendChild(image);</span></pre><p id="2c6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将创建一个100像素宽、200像素高的<code class="fe lb lc ld le b">img</code>元素。然后，创建的图像元素将被附加到HTML文档的<code class="fe lb lc ld le b">body</code>元素中。如果我们运行上面的代码，我们应该会看到一个图像，其尺寸由构造函数的参数给出。这相当于:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="be81" class="mi lg iq le b gy nq nr l ns nt">&lt;img width="100" height="200" src="<a class="ae kc" href="https://images.unsplash.com/photo-1572315831029-5d6f20e0035d?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=750&amp;amp;q=80" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1572315831029-5d6f20e0035d?ixlib=rb-1.2.1&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=750&amp;amp;q=80</a>"&gt;</span></pre><p id="20d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也是<code class="fe lb lc ld le b">Image</code>构造函数输出的内容。</p><h2 id="46cf" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">[计]选项</h2><p id="23a2" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">Option</code>构造函数创建一个<code class="fe lb lc ld le b">HTMLOptionElement</code>，它是一个带有<code class="fe lb lc ld le b">option</code>标签的HTML元素。构造函数有4个参数。第一个参数是选项的文本。这是一个可选的字符串参数。如果未指定，则使用空字符串作为默认值。第二个参数是<code class="fe lb lc ld le b">option</code>元素的值，它对应于HTML <code class="fe lb lc ld le b">option</code>元素的<code class="fe lb lc ld le b">value</code>属性的值。如果没有指定，那么文本的值将被用作<code class="fe lb lc ld le b">value</code>属性的值。第三个参数是boolean，当第一次加载这个元素时，它设置<code class="fe lb lc ld le b">selected</code>属性值。如果没有指定，那么<code class="fe lb lc ld le b">false</code>就是使用的值。设置<code class="fe lb lc ld le b">true</code>的值不会将选项设置为选中(如果它尚未被选中)。第四个参数是一个布尔值，它设置了<code class="fe lb lc ld le b">selected</code>属性的值。默认为<code class="fe lb lc ld le b">false</code>，这意味着默认情况下它不被选中。如果省略该参数，即使第三个参数是<code class="fe lb lc ld le b">true</code>，也不会选择该选项。这个构造函数的所有参数都是可选的。</p><p id="420f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过为<code class="fe lb lc ld le b">select</code>元素添加HTML代码来使用它:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="5735" class="mi lg iq le b gy nq nr l ns nt">&lt;select id='select'&gt;&lt;/select&gt;</span></pre><p id="2236" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以添加获取<code class="fe lb lc ld le b">select</code>元素的JavaScript代码，然后用<code class="fe lb lc ld le b">Option</code>构造函数创建<code class="fe lb lc ld le b">option</code>元素，然后将它们追加到<code class="fe lb lc ld le b">select</code>元素，如下面的代码所示:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="86e9" class="mi lg iq le b gy nq nr l ns nt">const select = document.getElementById('select');<br/>const options = ['one', 'two', 'three'];</span><span id="174d" class="mi lg iq le b gy nu nr l ns nt">for (const o of options) {<br/>  select.append(new Option(o, o, o === 'one', o === 'one'));<br/>}</span></pre><p id="1e79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的例子中，如果<code class="fe lb lc ld le b">option</code>的值和文本是<code class="fe lb lc ld le b">'one'</code>，我们将构造函数的第三和第四个参数设置为<code class="fe lb lc ld le b">true</code>，因此第一个选项将是默认选择的选项。如果我们运行上面的代码，我们应该得到一个下拉框，默认情况下第一个选项被选中。</p><p id="ad7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以将<code class="fe lb lc ld le b">option</code>元素的不同值设置为不同的属性。例如，我们可以写:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="7082" class="mi lg iq le b gy nq nr l ns nt">const select = document.getElementById('select');<br/>const options = ['one', 'two', 'three'];</span><span id="24df" class="mi lg iq le b gy nu nr l ns nt">for (const o of options) {<br/>  if (o === 'one') {<br/>    select.append(new Option(o, o, true, false));<br/>  } else if (o === 'two') {<br/>    select.append(new Option(o, o, false, true));<br/>  } else {<br/>    select.append(new Option(o, o, false, false));<br/>  }<br/>}</span></pre><p id="bb50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们运行上面的代码，我们会发现在页面加载时默认选择第二个选项，而不是第一个。</p><figure class="ni nj nk nl gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/4db568cdce33fb418016c6a72f4bba6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gUCIRl3uJL2fRt9Z"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rpnickson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Roberto Nickson</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="097a" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">工人</h2><p id="deea" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">Worker</code>构造函数让我们创建一个Web Worker，让我们在Web应用程序中后台处理任务。它可以很容易地被创建，并且可以用来向它的创建者发送消息。创建一个worker就像调用<code class="fe lb lc ld le b">Worker</code>构造函数并指定一个脚本来运行Worker线程一样简单。只要新工人与原始工人具有相同的起源，工人就可以产生新工人。只要<code class="fe lb lc ld le b">XMLHttpRequest</code>上的<code class="fe lb lc ld le b">responseXML</code>和<code class="fe lb lc ld le b">channel</code>属性总是返回<code class="fe lb lc ld le b">null</code>，工人就可以使用<code class="fe lb lc ld le b">XMLHttpRequest</code>进行HTTP请求。</p><p id="cb18" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了创建一个worker，我们使用了接受2个参数的<code class="fe lb lc ld le b">Worker</code>构造函数。第一个是一个字符串，其中包含worker将运行的脚本的URL。它必须与产生该工作线程的脚本位于相同的源或域中。第二个参数是可选参数，它是一个具有下列属性的对象。<code class="fe lb lc ld le b">type</code>属性是一个字符串，它指定了要创建的worker的类型。这些值可以是<code class="fe lb lc ld le b">classic</code>或<code class="fe lb lc ld le b">module</code>。默认值为<code class="fe lb lc ld le b">classic</code>。<code class="fe lb lc ld le b">credentials</code>属性是一个字符串，它指定使用worker的凭证的类型。可能的值有<code class="fe lb lc ld le b">omit</code>、<code class="fe lb lc ld le b">same-origin</code>或<code class="fe lb lc ld le b">include</code>。如果没有指定或者类型是<code class="fe lb lc ld le b">classic</code>，那么默认值是<code class="fe lb lc ld le b">omit</code>，这意味着不需要凭证。最后，<code class="fe lb lc ld le b">name</code>属性是一个字符串属性，它让我们指定代表工作者范围的<code class="fe lb lc ld le b">DedicatedWorkerGlobalScope</code>的标识名。这主要用于调试目的。</p><p id="dadb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个<code class="fe lb lc ld le b">Worker</code>对象抛出异常。如果文档不允许启动workers，它会抛出一个<code class="fe lb lc ld le b">SecurityError</code>。如果URL无效或没有遵循同源策略，就会发生这种情况。如果工作脚本的MIME类型不正确，就会引发<code class="fe lb lc ld le b">NetworkError</code>。应该一直是<code class="fe lb lc ld le b">text/javasceipr</code>。当无法解析Worker的URL时，会引发一个<code class="fe lb lc ld le b">SyntaxError</code>。</p><p id="10d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过从一个脚本向一个工作者脚本发送消息来构造一个工作者对象。然后工作脚本可以向主脚本发回消息。在下面的例子中，我们将通过编写一些代码与工人一起制作一个简单的计算器。首先，我们为输入创建HTML代码，如下所示:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="9201" class="mi lg iq le b gy nq nr l ns nt">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;Add Worker&lt;/title&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;form&gt;<br/>      &lt;div&gt;<br/>        &lt;label for="number1"&gt;First Number&lt;/label&gt;<br/>        &lt;input type="text" id="number1" value="0" /&gt;<br/>      &lt;/div&gt;<br/>      &lt;div&gt;<br/>        &lt;label for="number2"&gt;Second Number&lt;/label&gt;<br/>        &lt;input type="text" id="number2" value="0" /&gt;<br/>      &lt;/div&gt;<br/>    &lt;/form&gt;<br/>    &lt;p id="result"&gt;Result&lt;/p&gt;<br/>    &lt;script src="main.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="10c3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个文件夹，并将上面的代码保存到一个HTML文件中。然后在同一个文件夹中，创建一个<code class="fe lb lc ld le b">main.js</code>文件，并放入以下代码:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="9326" class="mi lg iq le b gy nq nr l ns nt">const worker = new Worker("worker.js");<br/>const first = document.getElementById("number1");<br/>const second = document.getElementById("number2");<br/>const result = document.getElementById("result");<br/>first.onkeyup = () =&gt; {<br/>  worker.postMessage([first.value, second.value]);<br/>};</span><span id="bedc" class="mi lg iq le b gy nu nr l ns nt">second.onkeyup = () =&gt; {<br/>  worker.postMessage([first.value, second.value]);<br/>};</span><span id="3ca5" class="mi lg iq le b gy nu nr l ns nt">worker.onmessage = e =&gt; {<br/>  result.textContent = e.data;<br/>};</span></pre><p id="a2f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将从HTML文件中获取输入的值，然后每当第一个或第二个输入有内容输入时就发送消息。监听每个输入的<code class="fe lb lc ld le b">keyup</code>事件让我们实现这个目标。然后在同一个文件夹中，创建一个<code class="fe lb lc ld le b">worker.js</code>文件，然后放入以下代码:</p><pre class="ni nj nk nl gt nm le nn no aw np bi"><span id="6674" class="mi lg iq le b gy nq nr l ns nt">onmessage = e =&gt; {<br/>  console.log("Worker received message");<br/>  const [first, second] = e.data;<br/>  let sum = +first + +second;<br/>  if (isNaN(sum)) {<br/>    postMessage("Both inputs should be numbers");<br/>  } else {<br/>    let workerResult = `Result: ${sum} `;<br/>    console.log("Send message back to main scriot");<br/>    postMessage(workerResult);<br/>  }<br/>};</span></pre><p id="5113" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，<code class="fe lb lc ld le b">worker.js</code>文件有一个<code class="fe lb lc ld le b">onmessage</code>处理程序。该函数是必需的，并且应该具有该名称。参数<code class="fe lb lc ld le b">e</code>具有从<code class="fe lb lc ld le b">main.js</code>文件发送的消息。我们可以像收到信息一样收到它。所以<code class="fe lb lc ld le b">e</code>参数应该有从<code class="fe lb lc ld le b">main.js</code>发送的数组。然后我们可以计算这个函数中的和，然后将计算的结果发送回<code class="fe lb lc ld le b">main.js</code>，它用<code class="fe lb lc ld le b">postMessage</code>函数生成了这个worker。在<code class="fe lb lc ld le b">main.js</code>文件中，我们有<code class="fe lb lc ld le b">worker.onmessage</code>处理程序来监听从这个文件发回的消息。在这个文件中，我们发回了结果，这就是我们得到的结果，我们用它来设置ID为<code class="fe lb lc ld le b">result</code>的元素的结果。</p><p id="c965" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们仅仅触及了<code class="fe lb lc ld le b">window</code>对象的表面。我们只讨论了在各种情况下可能会派上用场的几个构造函数。我们使用DOMParser将HTML和XML字符串解析成DOM树对象。同样，我们使用Image构造函数创建一个<code class="fe lb lc ld le b">img</code>元素，使用<code class="fe lb lc ld le b">Option</code>构造函数创建一个<code class="fe lb lc ld le b">option</code>元素。最后，我们使用Worker构造函数创建一个Web Worker，让我们在后台运行代码，并在一个脚本和Worker脚本之间发送消息，反之亦然。产生worker的脚本和worker脚本必须托管在同一个域中，这样外部脚本就不能在我们的应用程序中产生worker并向我们的应用程序发送包含恶意数据的消息。<code class="fe lb lc ld le b">window</code>对象比一些构造函数有更多的属性，我们将在本系列的后面部分研究这些属性。</p></div></div>    
</body>
</html>