<html>
<head>
<title>Algorithms 101: Reverse a string in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:在JavaScript中反转字符串</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-101-reverse-a-string-in-javascript-de453d5ce77e?source=collection_archive---------5-----------------------#2019-09-10">https://javascript.plainenglish.io/algorithms-101-reverse-a-string-in-javascript-de453d5ce77e?source=collection_archive---------5-----------------------#2019-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fd54" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated"><em class="kf"> Noob诉LeetCode，第二集</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/bc1040230fd0f860e996937e15f5f2d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rmJM7xdAA1uzN3wjNtrCFA.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">noob, not a bad thing.</figcaption></figure><p id="1d2f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">显然，这是科技面试中的一个经典挑战:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ls"><img src="../Images/aa99ce6b33c60e5ecdb23bde0f52ec83.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xkKj76wcx3aKCro3a4Q3ng.png"/></div></div></figure><p id="d52e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个问题的强力解决方案很容易找到。要在js中反转一个字符串，你要做的就是</p><ul class=""><li id="7450" class="lt lu iq ky b kz la lc ld lf lv lj lw ln lx lr ly lz ma mb bi translated">把它分成一个数组</li><li id="bab8" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">反转数组中元素的顺序</li><li id="6da6" class="lt lu iq ky b kz mc lc md lf me lj mf ln mg lr ly lz ma mb bi translated">然后把它变回字符串</li></ul><p id="83a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对一个数字做同样的事情，首先你把它变成一个字符串，然后<em class="mh">然后</em>你运行上面的步骤。(不能直接把一个数拆分成一个数组)。</p><pre class="kh ki kj kk gt mi mj mk ml aw mm bi"><span id="3e03" class="mn mo iq mj b gy mp mq l mr ms">let x = 121</span><span id="23fa" class="mn mo iq mj b gy mt mq l mr ms">let string = x.toString()<br/>// =&gt; "121"</span><span id="a558" class="mn mo iq mj b gy mt mq l mr ms">let array = string.split('')<br/>// =&gt; ["1", "2", "1"]<br/>//note: string.split() =&gt; ["121"]</span><span id="f88a" class="mn mo iq mj b gy mt mq l mr ms">let reversedArray = array.reverse()<br/>// =&gt; ["1", "2", "1"]</span><span id="22dc" class="mn mo iq mj b gy mt mq l mr ms">let reversedString = reversedArray.join('')<br/>// =&gt; "121"</span><span id="48cf" class="mn mo iq mj b gy mt mq l mr ms">return x.toString() === reversedString ? true : false <br/>// =&gt; true<br/></span></pre><p id="906a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有加在一起，用一个<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" rel="noopener ugc nofollow" target="_blank">三元运算符</a>:</p><pre class="kh ki kj kk gt mi mj mk ml aw mm bi"><span id="f568" class="mn mo iq mj b gy mp mq l mr ms">let x = 141</span><span id="5c24" class="mn mo iq mj b gy mt mq l mr ms">const isPalindrome = function(x) { <br/>   <br/>   return x.toString() === x.toString().split(‘’).reverse().join(‘’) ? true : false </span><span id="36f1" class="mn mo iq mj b gy mt mq l mr ms"> };</span><span id="ebe6" class="mn mo iq mj b gy mt mq l mr ms">//=&gt; true</span></pre><p id="5c3c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不幸的是，像往常一样，粗暴的方法很慢。</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mv"><img src="../Images/43674540484a76ed5a5afe09558f1059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3D0HzFttZrlWkZetE__D9A.png"/></div></div></figure><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="251e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们没有使用太多的内存，但是我们的运行时间排在最后16%。</p><h1 id="2125" class="my mo iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">更好、更聪明、更快</h1><p id="842a" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated"><em class="mh">顺便说一句，这是我以前供职的报纸《华尔街日报》的座右铭</em></p><p id="0ba9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一种方法很慢，因为在它对照反转数组中的每个字符检查数组中的每个字符之前，它不能返回true或false。我们怎样才能加快速度呢？</p><p id="f296" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我尝试添加一个初始屏幕:检查数组的第一个元素是否等于数组的最后一个元素，如果不等于，则返回false。如果这是真的，那么继续最初的方法。</p><p id="c5af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这有点像让求职者或室友申请者在电子邮件的主题行中包含某个代码字；并忽略所有不包含它的应用程序。如果申请人提供了代码，筛选时间和以前一样长；但是你要筛选的就少多了。对了，这个很好用！在现实生活中。</p><p id="235d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是在代码中效果不好。</p><pre class="kh ki kj kk gt mi mj mk ml aw mm bi"><span id="3583" class="mn mo iq mj b gy mp mq l mr ms">const isPalindrome = function(x) {  <br/>    <br/>    let array = x.toString().split('') <br/>    if (array[0] === array[array.length - 1]) {        <br/>        return array.join('')  === array.reverse().join('')? true : false  <br/>        } else {<br/>        <br/>            return false<br/>        }<br/>      return false                 <br/>};</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nu"><img src="../Images/3993b87579e4b4d7c097f2bb1dfb1b9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y3TmSRICRDat6KTY6WlC5w.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">runTime is only slightly better, now we’re in the bottom 18%</figcaption></figure><p id="ffd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我的下一个直觉是错误的:放弃这种方法，去别处看看。我这样做了，并最终找到了一个伟大的解决方案，使用…相同的概念，但发挥它的所有方式。</p><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="nv mx l"/></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">obligatory d’oh giphy</figcaption></figure><p id="fb70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以使用迭代来检查第二个元素、倒数第二个元素、第三个元素和倒数第三个元素，等等，而不是只检查数组的第一个和最后一个元素作为初始屏幕。</p><p id="c1db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你像我一样是个新手，你知道如何从数组的开始迭代，但是你不知道如何同时从数组的结尾迭代。</p><p id="bf03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">从一开始，你可以用这个:</p><p id="e702" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nw nx ny mj b">for let(i = 0; i &lt; array.length; i++)</code></p><p id="7399" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，从最后，你可以用这个:</p><p id="d24d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nw nx ny mj b">for (let j = array.length — 1; j &gt; 0; j--)</code></p><p id="dd43" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你想两者一起做，你可以只使用一个for循环。每次你用<code class="fe nw nx ny mj b">i++</code>增加<code class="fe nw nx ny mj b">i</code>，你用同样的循环用<code class="fe nw nx ny mj b">j--</code>减少<code class="fe nw nx ny mj b">j</code>。</p><p id="8f78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:我们在这里不必使用reverse，这意味着我们不需要将我们的字符串转换为数组(reverse适用于数组，不适用于字符串)。相反，我们可以用<a class="ae mu" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charAt" rel="noopener ugc nofollow" target="_blank"> charAt()检查字符串的每个元素。</a></p><pre class="kh ki kj kk gt mi mj mk ml aw mm bi"><span id="897d" class="mn mo iq mj b gy mp mq l mr ms">let string = String(x)<br/>// turn number x into a string</span><span id="8c3f" class="mn mo iq mj b gy mt mq l mr ms">let j = string.length - 1 </span><span id="17df" class="mn mo iq mj b gy mt mq l mr ms">for (i = 0; i &lt; string.length; i ++ )<br/>    if (string.charAt(i) === string.charAt(j)){<br/>         j --<br/>     } else {<br/>         return false<br/>     }<br/>}</span><span id="bf82" class="mn mo iq mj b gy mt mq l mr ms">return true</span></pre><p id="2937" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">变得更快:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nz"><img src="../Images/acbc6145573c7fd2e0e5c5d1e20d2bba.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q7MwYXSiFd9TrL-yJFbLQA.png"/></div></div></figure><p id="664b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果我们在上面的代码中添加一个初始屏幕，立即为负数返回false:</p><pre class="kh ki kj kk gt mi mj mk ml aw mm bi"><span id="d45f" class="mn mo iq mj b gy mp mq l mr ms">const isPalindrome = function(x)  {</span><span id="f43a" class="mn mo iq mj b gy mt mq l mr ms">x &lt; 0 ? false : null<br/>    <br/> let string = String(x)<br/> let j = string.length - 1<br/> <br/> for (i = 0; i &lt; string.length; i ++ )<br/>     if (string.charAt(i) === string.charAt(j)){<br/>         j --<br/>     } else {<br/>         return false<br/>     }<br/>    return true   <br/>            <br/>};<br/></span></pre><p id="627e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的速度更快:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi oa"><img src="../Images/fb543fa0a735fe7380dac35a0829280a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7GoQHGCMN7PkznyVGQsbXA.png"/></div></div></figure><p id="e4d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意:如果用箭头函数运行相同的代码，运行时间会稍微长一点:</p><pre class="kh ki kj kk gt mi mj mk ml aw mm bi"><span id="48a8" class="mn mo iq mj b gy mp mq l mr ms">const isPalindrome = (x) =&gt;  {</span><span id="59c6" class="mn mo iq mj b gy mt mq l mr ms">      x &lt; 0 ? false : null<br/>    <br/>      let string = String(x)<br/>      let j = string.length - 1<br/> <br/>      for (i = 0; i &lt; string.length; i ++ ){<br/>          if (string.charAt(i) === string.charAt(j)){<br/>               j --<br/>          } else {<br/>               return false<br/>          }<br/>      }</span><span id="b798" class="mn mo iq mj b gy mt mq l mr ms">    return true   <br/>            <br/>};</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ob"><img src="../Images/fff6885d5a87a8bcaa7cf1f9e03d4f04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UF-BhEwefe_AWiuVrvuGPw.png"/></div></div></figure><h1 id="f6f4" class="my mo iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">但是如果……</h1><figure class="kh ki kj kk gt kl"><div class="bz fp l di"><div class="oc mx l"/></div></figure><p id="0c04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在最后一种方法中，我们迭代通过<code class="fe nw nx ny mj b">i</code>到数组的末尾，即使我们只需要到数组的中点+ 1(如果array.length是4，我们只需要迭代字符串开头的元素0和1；最后是3和2。我们不需要从头到尾遍历字符串。</p><p id="6668" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果array.length为5，或者任意奇数，我们只需要遍历元素<code class="fe nw nx ny mj b">array.length/2 + 1</code>(元素0，1，2，其中元素2在中心)。</p><p id="1a2a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于好奇，我们试试这个怎么样:</p><pre class="kh ki kj kk gt mi mj mk ml aw mm bi"><span id="b86e" class="mn mo iq mj b gy mp mq l mr ms">const isPalindrome = function(x)  {</span><span id="493d" class="mn mo iq mj b gy mt mq l mr ms">     x &lt; 0 ? false : null<br/>    <br/>     let string = String(x)<br/>     let j = string.length - 1<br/> <br/>     for (i = 0; i &lt; (string.length/2 + 1); i ++ ){<br/>          if (string.charAt(i) === string.charAt(j)){<br/>              j --<br/>          } else {<br/>              return false<br/>          }<br/>     }</span><span id="e4fa" class="mn mo iq mj b gy mt mq l mr ms">    return true   <br/>            <br/>};</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi ob"><img src="../Images/844220810e1de9d3d6f40d91ff4a96c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QthBIHyJ8zxFOHSRt5hmPw.png"/></div></div></figure><p id="c461" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好吧，稍微慢了一点，但是这一点点内存使用的改进让我们在内存效率方面排在前41%!</p><h1 id="b3f1" class="my mo iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">速度更快:</h1><p id="01ed" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">还有一个改进，这要感谢DaleHurtt。正如他指出的，我们不必在每次迭代中定义的中点。相反，我们可以在循环之前定义它。</p><pre class="kh ki kj kk gt mi mj mk ml aw mm bi"><span id="8882" class="mn mo iq mj b gy mp mq l mr ms">const isPalindrome = (x) =&gt;  {</span><span id="15b3" class="mn mo iq mj b gy mt mq l mr ms">x &lt; 0 ? false : null</span><span id="adc0" class="mn mo iq mj b gy mt mq l mr ms">let string = String(x)<br/>     let j = string.length - 1<br/>     let midpoint = string.length / 2 + 1</span><span id="3719" class="mn mo iq mj b gy mt mq l mr ms">for (i = 0; i &lt; midpoint; i ++ ){<br/>         if (string.charAt(i) === string.charAt(j)){<br/>             j --<br/>         } else {<br/>             return false<br/>         }<br/>     }<br/>    return true   <br/>            <br/>};</span></pre><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi od"><img src="../Images/4f39766fce971bda0ff19cbecab2aea6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LFgShtKeQ_fYw2HXTn3dwA.png"/></div></div></figure><h1 id="eadb" class="my mo iq bd mz na nb nc nd ne nf ng nh jw ni jx nj jz nk ka nl kc nm kd nn no bi translated">感谢…</h1><p id="aa5e" class="pw-post-body-paragraph kw kx iq ky b kz np jr lb lc nq ju le lf nr lh li lj ns ll lm ln nt lp lq lr ij bi translated">chavarriacarlos，用<a class="ae mu" href="https://leetcode.com/problems/palindrome-number/discuss/371714/JavaScript-Easy-to-Understand.-O(n)-solution.-Faster-than-70" rel="noopener ugc nofollow" target="_blank">照亮了他在LeetCode </a>和<a class="ae mu" href="https://medium.com/@dalehurtt" rel="noopener"> DaleHurtt </a>上的讨论帖子(见他的优雅解决方案的评论)。</p><p id="2f23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mh">下一个:</em> <a class="ae mu" href="https://medium.com/javascript-in-plain-english/algorithms-101-next-greatest-element-493e224f82b5" rel="noopener"> <em class="mh">算法101:Javascript中的下一个最大元素</em> </a></p><p id="8089" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><a class="ae mu" href="https://medium.com/javascript-in-plain-english/algorithms-101-twosum-in-javascript-b493c8d64014" rel="noopener"> <em class="mh">以防你错过:算法101:Javascript中的二和</em> </a></p><p id="9004" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">版权所有琼·印第安纳·琳斯2019</p></div></div>    
</body>
</html>