<html>
<head>
<title>Best of Modern JavaScript — __proto__ and Descriptors</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript的精华— __proto__和描述符</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-proto-and-descriptors-1c5eda001226?source=collection_archive---------15-----------------------#2020-10-10">https://javascript.plainenglish.io/best-of-modern-javascript-proto-and-descriptors-1c5eda001226?source=collection_archive---------15-----------------------#2020-10-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/07dc7a69365d0f3f7c5ec3c4de8968dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ITGZcJMWOqjDhQyd"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@freetousesoundscom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Free To Use Sounds</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="388d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript中新的OOP特性。</p><h1 id="9285" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">__proto__</code>属性</h1><p id="a240" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用<code class="fe lz ma mb mc b">__proto__</code>属性轻松地获取和设置对象的原型。</p><p id="e586" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3471" class="mq lc iq mc b gy mr ms l mt mu">Object.getPrototypeOf({ __proto__: null })</span></pre><p id="e58a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后它将返回<code class="fe lz ma mb mc b">null</code>，因为我们将<code class="fe lz ma mb mc b">__proto__</code>属性设置为<code class="fe lz ma mb mc b">null</code>。</p><p id="fc89" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这不适用于密钥的字符串版本，因为它会创建自己的属性:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="d7fd" class="mq lc iq mc b gy mr ms l mt mu">Object.getPrototypeOf({ ['__proto__']: null })</span></pre><p id="d9c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它会返回<code class="fe lz ma mb mc b">Object.prototype</code>。</p><p id="0708" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且<code class="fe lz ma mb mc b">Object.keys({ [‘__proto__’]: null })</code>返回数组<code class="fe lz ma mb mc b">[ ‘__proto__’ ]</code>。</p><p id="5cad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，如果我们定义自己的属性名为<code class="fe lz ma mb mc b">__proto__</code>，它也不会工作。</p><p id="5fd0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="3abe" class="mq lc iq mc b gy mr ms l mt mu">const<!-- --> <!-- -->obj<!-- --> <!-- -->=<!-- --> <!-- -->{};<br/>Object.defineProperty(obj,<!-- --> <!-- -->'__proto__',<!-- --> <!-- -->{<!-- --> <!-- -->value:<!-- --> 'bar' <!-- -->})</span></pre><h1 id="1ced" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有<code class="fe lz ma mb mc b">Object.prototype</code>作为原型的对象</h1><p id="0794" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用带有参数<code class="fe lz ma mb mc b">null</code>的<code class="fe lz ma mb mc b">Object.create</code>方法来创建一个没有原型的对象。</p><p id="b499" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="fbf8" class="mq lc iq mc b gy mr ms l mt mu">const<!-- --> <!-- -->obj<!-- --> <!-- -->=<!-- --> <!-- -->Object.create(null);</span></pre><p id="1bf1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe lz ma mb mc b">obj</code>就没有<code class="fe lz ma mb mc b">__proto__</code>属性。</p><p id="98a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个方法使得创建dictionary对象变得容易，我们不希望从它那里继承任何属性。</p><h1 id="97de" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">__proto__</code>和JSON</h1><p id="c083" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">__proto__</code>可以用<code class="fe lz ma mb mc b">JSON.stringify</code>字符串化。</p><p id="4927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5e5d" class="mq lc iq mc b gy mr ms l mt mu">JSON.stringify({['__proto__']: 'foo' })</span></pre><p id="b131" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后返回:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="f700" class="mq lc iq mc b gy mr ms l mt mu">"{"__proto__":"foo"}"</span></pre><h1 id="3187" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检测对ES6风格的支持<code class="fe lz ma mb mc b">__proto__</code></h1><p id="5fcc" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">有几种方法可以检测ES6 style <code class="fe lz ma mb mc b">__proto__</code>属性。</p><p id="6927" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用对象文字中的<code class="fe lz ma mb mc b">Object.prototype.__proto__</code>属性和<code class="fe lz ma mb mc b">__proto__</code>来检查它。</p><p id="b18c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c09a" class="mq lc iq mc b gy mr ms l mt mu">const supported = ({}).hasOwnProperty.call(Object.prototype, '__proto__');</span></pre><p id="bbaf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们检查<code class="fe lz ma mb mc b">Object.prototype.__proto__</code>属性是否存在。</p><p id="13a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以检查<code class="fe lz ma mb mc b">__proto__</code>的getter和setter是函数，以确保我们可以获取和设置该属性的值。</p><p id="5154" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ef32" class="mq lc iq mc b gy mr ms l mt mu">const desc = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');<br/>const supported = (<br/>  typeof desc.get === 'function' &amp;&amp; typeof desc.set === 'function'<br/>);</span></pre><p id="d46f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以使用<code class="fe lz ma mb mc b">Object.getPrototypeOf</code>方法通过传入一个属性设置为<code class="fe lz ma mb mc b">null</code>的对象来进行检查。</p><p id="df4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用它来检查返回的原型是否是<code class="fe lz ma mb mc b">null</code>。</p><p id="bba4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="07ff" class="mq lc iq mc b gy mr ms l mt mu">const supported = Object.getPrototypeOf({__proto__: null}) === null;</span></pre><h1 id="e148" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">ES6中的可枚举性</h1><p id="8a97" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">在JavaScript中，每个对象可以有零个或多个属性。</p><p id="6a67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个属性都有一个键和3个或更多的描述符。</p><p id="1d09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有属性都有<code class="fe lz ma mb mc b">enumerable</code>和<code class="fe lz ma mb mc b">configurable </code>属性</p><p id="42a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">enumerable</code>意味着我们是否到处展示财产。</p><p id="4c0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">configurable</code>设置为<code class="fe lz ma mb mc b">false</code>禁用属性值更改并防止删除。</p><p id="6777" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性有<code class="fe lz ma mb mc b">value</code>和<code class="fe lz ma mb mc b">writable</code>属性。</p><p id="c38d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">value</code>有属性值。</p><p id="1e96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe lz ma mb mc b">writable</code>控制我们是否可以改变属性的值。</p><p id="2967" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性也有getter <code class="fe lz ma mb mc b">get</code>访问器和setter <code class="fe lz ma mb mc b">set</code>访问器。</p><p id="b191" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe lz ma mb mc b">Object.getOwnPropertyDescriptor</code>方法来获取属性描述符。</p><p id="f5b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="0765" class="mq lc iq mc b gy mr ms l mt mu">const obj = { foo: 'bar' };<br/>consr desc = Object.getOwnPropertyDescriptor(obj, 'foo')</span></pre><p id="426a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe lz ma mb mc b">desc</code>就是:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="fb63" class="mq lc iq mc b gy mr ms l mt mu">{<br/>  value: "bar",<br/>  writable: true,<br/>  enumerable: true,<br/>  configurable: true<br/>}</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/54faba8511f8c7458fbc12b77329f3de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*QYSG2PsupAOZw9bD"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@5tep5?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Alexander Popov</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3d08" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="7d93" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">对象属性有属性描述符。</p><p id="b955" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，<code class="fe lz ma mb mc b">__proto__</code>属性在不同的上下文中有不同的行为。</p><p id="103c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过不同的方式来检查该属性是否可用。</p><p id="8268" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>