<html>
<head>
<title>Webpack-dev-server, React, Fetch, and Cookies</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Webpack-dev-server、React、Fetch和Cookies</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/webpack-dev-server-react-fetch-and-cookies-2d4e89840ea2?source=collection_archive---------2-----------------------#2020-08-19">https://javascript.plainenglish.io/webpack-dev-server-react-fetch-and-cookies-2d4e89840ea2?source=collection_archive---------2-----------------------#2020-08-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/ab0495dc5e2c308fa6e2f2668db0e943.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Mf18JUID7UXPDM-t"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@gui_vasconcelos?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Guilherme Vasconcelos</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="321c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天很有趣。在开发React应用程序时，我使用webpack-dev-server来提供服务。我正在实现JavaScript Web令牌，通过一个httpOnly cookie通过一个<code class="fe lb lc ld le b">fetch()</code>请求在域之间刷新令牌。当我在fetch响应中收到httpOnly cookie时，该cookie不会被转换到devtools中的Application选项卡上，这意味着它不会在我的下一个API请求中自动传递。</p><p id="21f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我花了一段时间试图找到这个问题，并在这篇文章中提出我的解决方案(许多可能性之一)。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><p id="5f19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">问题在于信任。如果您提供来自单个域的内容，就不会有什么问题。然而，如果您的API服务器运行在<a class="ae kc" href="http://localhost:3000," rel="noopener ugc nofollow" target="_blank"> http://localhost:3000，</a>上，而您的React应用程序通过webpack-dev-server运行在<a class="ae kc" href="http://localhost:8081" rel="noopener ugc nofollow" target="_blank"> http://localhost:8081 </a>上(例如)，那么就浏览器而言，这些是不同的域，并且安全规则开始生效。这些规则需要更多的设置和理解来告诉浏览器我们真的信任另一个域。由于webpack-dev-server的工作方式，这些额外的步骤可能仍然不起作用。</p><p id="65cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你使用Fetch()请求一个API资源，你必须包含<code class="fe lb lc ld le b">mode: 'cors'</code>和<code class="fe lb lc ld le b">credentials: 'same-origin'</code>。但即使是这些也可能不够。</p><p id="37a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">“简单”的解决方法是将您的API请求转移到一个代理后面，这样看起来就像是来自您的主域。例如，导航到<code class="fe lb lc ld le b"><a class="ae kc" href="http://localhost:8081/api/login" rel="noopener ugc nofollow" target="_blank">http://localhost:8081/api/login</a></code>会导致在浏览器不知道的情况下调用<code class="fe lb lc ld le b"><a class="ae kc" href="http://localhost:3000/api/login" rel="noopener ugc nofollow" target="_blank">http://localhost:<strong class="kf ir">3000</strong>/api/login</a></code>。这在Nginx/Apache中相对容易设置:</p><pre class="lm ln lo lp gt lq le lr ls aw lt bi"><span id="febc" class="lu lv iq le b gy lw lx l ly lz">// nginx<br/>location '/api' {<br/>  proxy_set_header   X-Forwarded-For $remote_addr;<br/>  proxy_set_header   Host $http_host;<br/>  proxy_pass         <a class="ae kc" href="http://192.168.43.31:5000" rel="noopener ugc nofollow" target="_blank">http://l</a>ocalhost:3000;<br/>}</span></pre><p id="475a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是当我们开发时，我们可能只使用webpack-dev-server。</p><p id="cdbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Webpack-dev-server也可以做代理。只需要一点小小的设置。</p><p id="1e21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在您的<code class="fe lb lc ld le b">webpack.config.js</code>文件中，您可以像这样设置一个代理:</p><pre class="lm ln lo lp gt lq le lr ls aw lt bi"><span id="bdcd" class="lu lv iq le b gy lw lx l ly lz">module.exports = merge(common, {<br/>  ...<br/>  devServer: {<br/>    contentBase: './dist',<br/>    // the historyAPIFallback allows react-router to work<br/>    historyApiFallback: true,<br/>    proxy: {<br/>      // when a requst to /api is done, we want to apply a proxy<br/>      '/api': {<br/>        changeOrigin: true,<br/>        cookieDomainRewrite: 'localhost',<br/>        target: 'http://localhost:3000',<br/>        onProxyReq: (proxyReq) =&gt; {<br/>        if (proxyReq.getHeader('origin')) {<br/>          proxyReq.setHeader('origin', 'http://localhost:3000')<br/>        }<br/>    },<br/>  },<br/>  ...</span><span id="ee00" class="lu lv iq le b gy ma lx l ly lz">// derived from code found at <a class="ae kc" href="https://sdk.gooddata.com/gooddata-ui/docs/4.1.1/ht_configure_webpack_proxy.html" rel="noopener ugc nofollow" target="_blank">https://sdk.gooddata.com/gooddata-ui/docs/4.1.1/ht_configure_webpack_proxy.html</a></span></pre><p id="99e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当你重启你的开发服务器时，你可以向<code class="fe lb lc ld le b">/api</code>发出请求，它们将被传递到你的API服务器。就浏览器而言，你已经从同一个域请求了一个资源，所以那些讨厌的安全规则不适用。</p><p id="55ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最重要的是，httpOnly cookies是在浏览器的devtools中的Application选项卡上正确设置的。(您可能仍然需要弄乱fetch()的头和/或模式/凭证设置。)这意味着您发出的下一个请求也会传递这个cookie。viola——我们可以使用JWT令牌，而无需将它存储在浏览器中，也不会将其暴露给恶意的JS攻击。</p><p id="5e4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">额外的好处是，我们的React应用程序不再需要跟踪API服务器的位置。所有API资源都可以指向<code class="fe lb lc ld le b">/api</code>，底层服务器负责正确的代理调用。</p><p id="41b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从长远来看，正确的答案是让它适合生产环境。这通常意味着Nginx、Apache、IIS或其他常见的web服务器。只要这些服务器能够配置目录代理，这就很容易。</p><p id="2462" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使这不是一个永久的解决方案，它也允许我们继续开发应用程序的其余部分。</p></div></div>    
</body>
</html>