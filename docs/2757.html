<html>
<head>
<title>JavaScript Best Practices — Complex and Duplicate Code and Functional Programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践——复杂重复的代码和函数式编程</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-complex-and-duplicate-code-and-functional-programming-cc509db6d0ed?source=collection_archive---------2-----------------------#2020-07-21">https://javascript.plainenglish.io/javascript-best-practices-complex-and-duplicate-code-and-functional-programming-cc509db6d0ed?source=collection_archive---------2-----------------------#2020-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/05a89dcd6deecad5d101efe53c5af4da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*AbD85pBzklxYUgCV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">CFPhoto by <a class="ae kc" href="https://unsplash.com/@yirage?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andriyko Podilnyk</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c6cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了使代码易于阅读和维护，我们应该遵循一些最佳实践。</p><p id="0f90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在这篇文章中，我们将看看我们应该遵循的一些最佳实践，以使每个人的生活更轻松。</p><h1 id="68bb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">删除重复代码</h1><p id="1cd2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">重复代码是错误的。</p><p id="f203" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们必须改变它们，我们必须在多个地方改变它们。</p><p id="23d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">很容易错过他们。</p><p id="4e0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该清除它们。</p><p id="5e5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0126" class="mn lc iq mj b gy mo mp l mq mr">function showEmployeeList(employees) {<br/>  employees.forEach(employee =&gt; {<br/>    const salaries = employees.salaries();<br/>    const tasks = employees.tasks();<br/>    const data = {<br/>      salaries,<br/>      tasks<br/>    };</span><span id="7800" class="mn lc iq mj b gy ms mp l mq mr">    display(data);<br/>  });<br/>}</span><span id="e7b3" class="mn lc iq mj b gy ms mp l mq mr">function showManagerList(managers) {<br/>  managers.forEach(manager =&gt; {<br/>    const salaries = manager.salaries();<br/>    const tasks = manager.tasks();<br/>    const data = {<br/>      salaries,<br/>      tasks<br/>    };</span><span id="8896" class="mn lc iq mj b gy ms mp l mq mr">    display(data);<br/>  });<br/>}</span></pre><p id="d350" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c30d" class="mn lc iq mj b gy mo mp l mq mr">function showWorkersList(workers) {<br/>  workers.forEach(worker =&gt; {<br/>    const salaries = worker.salaries();<br/>    const tasks = worker.tasks();<br/><br/>    const data = {<br/>      salaries,<br/>      tasks<br/>    };<br/><br/>    switch (worker.type) {<br/>      case "manager":<br/>        render(data);<br/>      case "employee":<br/>        render(data);<br/>    }<br/>  });<br/>}</span></pre><h1 id="3dd3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Object.assign设置默认对象</h1><p id="9f4d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">将一个非空对象设置为<code class="fe mt mu mv mj b">Object.assign</code>的第一个参数将返回一个对象，该对象在第一个参数中的所有属性与其他参数的属性合并。</p><p id="9f6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="686b" class="mn lc iq mj b gy mo mp l mq mr">const obj = Object.assign({<br/>    title: "Foo"<br/>  },<br/>  config<br/>);</span></pre><p id="495c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">obj</code>是一个带有<code class="fe mt mu mv mj b">title</code>的对象，其后带有<code class="fe mt mu mv mj b">config</code>中的属性。</p><h1 id="c57b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要使用标志作为函数参数</h1><p id="bb12" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该使用标志作为函数参数。</p><p id="11c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d556" class="mn lc iq mj b gy mo mp l mq mr">function getData(name, isManager) {<br/>  if (isManager) {<br/>    return findManagerData(name);<br/>  } else {<br/>    return findWorkerData(name);<br/>  }<br/>}</span></pre><p id="05da" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8361" class="mn lc iq mj b gy mo mp l mq mr">function getManagerData(name) {<br/>  return findtManagerData(name);<br/>}</span><span id="44bf" class="mn lc iq mj b gy ms mp l mq mr">function getWorkerData(name) {<br/>  return findtWorkerData(name);<br/>}</span></pre><h1 id="4476" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有副作用</h1><p id="5ce5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">副作用是对函数之外的东西产生的影响</p><p id="408b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有些副作用是不可避免的，比如操纵文件和改变其他外部资源。</p><p id="e0c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">剩下的大部分都可以避免。</p><p id="c141" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们不应该写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="12db" class="mn lc iq mj b gy mo mp l mq mr">let name = "foo bar";</span><span id="0dc0" class="mn lc iq mj b gy ms mp l mq mr">function splitName() {<br/>  name = name.split(" ");<br/>}</span></pre><p id="a99e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们可以用函数返回结果。</p><p id="2c91" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以改为写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="2885" class="mn lc iq mj b gy mo mp l mq mr">function splitName(name) {<br/>  return name.split(" ");<br/>}</span></pre><h1 id="8317" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如果对象是从函数参数传递来的，就不要在原地操作它</h1><p id="ab97" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">所有非原始值，包括对象和数组，都通过引用传递给函数。</p><p id="65f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，如果我们修改这些参数，那么我们将改变原始对象。</p><p id="49fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3e76" class="mn lc iq mj b gy mo mp l mq mr">const addTask = (tasks, task) =&gt; {<br/>  tasks.push(task);<br/>};</span></pre><p id="9362" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe mt mu mv mj b">tasks</code>数组和传入的<code class="fe mt mu mv mj b">task object </code>将被修改。</p><p id="78b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们应该返回一个新的数组:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="880f" class="mn lc iq mj b gy mo mp l mq mr">const addTask = (tasks, task) =&gt; {<br/>  return [...tasks, tasks];<br/>};</span></pre><p id="10ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们可能没有想到的更隐蔽的副作用。</p><h1 id="b05c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不要写全局函数</h1><p id="b3c1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">永远不要修改内置原型。</p><p id="f56f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反，我们可以扩展它们。</p><p id="8a19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">扩展内置原型会产生意想不到的结果。</p><p id="1450" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们使测试更容易，并防止错误改变数据。</p><p id="5aa9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8b51" class="mn lc iq mj b gy mo mp l mq mr">Array.prototype.itemsInOtherArray = function(arr) {<br/>  return this.filter(element =&gt; !arr.includes(element));<br/>};</span></pre><p id="71c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e290" class="mn lc iq mj b gy mo mp l mq mr">class DiffArray extends Array {<br/>  itemsInOtherArray(arr) {<br/>    return this.filter(element =&gt; !arr.includes(element));<br/>  }<br/>}</span></pre><h1 id="c73b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用函数式编程</h1><p id="68dd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该使用函数式编程原则，比如不产生副作用。</p><p id="2983" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们使对象不可变。</p><p id="3d51" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">高阶函数也是我们可以使用的。</p><p id="9d3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些数组方法是展示所有这些特征的完美例子。</p><p id="0633" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不使用循环计算总和:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0446" class="mn lc iq mj b gy mo mp l mq mr">let totalPrice = 0;<br/><br/>for (const item of items) {<br/>  totalPrice += item.price;<br/>}</span></pre><p id="b372" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4136" class="mn lc iq mj b gy mo mp l mq mr">const totalPrice = items.reduce(<br/>  (totalPrice, output) =&gt; totalPrice + item.price,<br/>  0<br/>);</span></pre><p id="387f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript数组使用了<code class="fe mt mu mv mj b">reduce</code>方法将数组条目中的总价相加。</p><h1 id="4152" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">封装条件</h1><p id="605c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们在条件中有很长的布尔表达式，我们可以把它们放在一个函数中。</p><p id="5060" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9c25" class="mn lc iq mj b gy mo mp l mq mr">if (item.price &gt; 100 &amp;&amp; isLarge(item) &amp;&amp; isSmart(item)) {<br/>  // ...<br/>}</span></pre><p id="5eda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="88c9" class="mn lc iq mj b gy mo mp l mq mr">const isBigAndSmart = (item) =&gt; {<br/>  return item.price &gt; 100 &amp;&amp; isLarge(item) &amp;&amp; isSmart(item)<br/>}</span><span id="4275" class="mn lc iq mj b gy ms mp l mq mr">if (isBigAndSmart(item)) {<br/>  // ...<br/>}</span></pre><h1 id="5131" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">没有否定条件句</h1><p id="99b7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们的代码中不应该有负条件。</p><p id="8434" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们很难读懂。</p><p id="07c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不要写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d67f" class="mn lc iq mj b gy mo mp l mq mr">if (!isPresent(node)) {<br/>  // ...<br/>}</span></pre><p id="d857" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7cd9" class="mn lc iq mj b gy mo mp l mq mr">if (isPresent(node)) {<br/>  // ...<br/>}</span></pre><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/beaede76deffdecdfbb15bf70f0bd9fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bvlzEglHHVcbKQU_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@maudslaats?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Maud Slaats</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3fc6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="6084" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该利用JavaScript中的函数式编程特性。</p><p id="1989" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们应该删除重复的代码，并将复杂的代码移到它们自己的功能中。</p><h1 id="e541" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单英语的JavaScript</h1><p id="acf2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>