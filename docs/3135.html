<html>
<head>
<title>Experiments with Time Complexity in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript时间复杂度实验</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/experiments-with-time-complexity-in-javascript-56643e20ca12?source=collection_archive---------6-----------------------#2020-09-01">https://javascript.plainenglish.io/experiments-with-time-complexity-in-javascript-56643e20ca12?source=collection_archive---------6-----------------------#2020-09-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/8e933ec624609b933617a3b338138423.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dQWYfinE8FzLp0glHZb7hw.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@icons8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Icons8 Team</a> on <a class="ae jz" href="https://unsplash.com/s/photos/timer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8a7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你像我一样，在通过非传统途径找到这个领域后，正在面试你的第一个软件工程角色，你很快就会达到需要对大O符号和性能有坚实理解的地步。使用大O符号，理解会深入许多层。有对“哦，是的，就是那个有很多O和n的”的表层理解，更深层次的学术理解，以及对Big O中提出的概念如何影响你的代码的更具体的理解。</p><p id="9f71" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你正在寻找对大O和时间复杂性的更深入的学术理解，这不是你想要的文章。有很多精彩的资源可以涵盖这个主题。在本文中，我将提供一个简单的DIY实验，帮助我更具体地理解如何使用performance.now()对不同输入大小的代码进行计时来测量性能。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="1fec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://www.interviewcake.com/article/java/big-o-notation-time-and-space-complexity" rel="noopener ugc nofollow" target="_blank">面试蛋糕</a>给出了大O批注的伟大定义:</p><p id="5466" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“使用大O表示法，我们将运行时表示为，当输入变得任意大时，它相对于输入增长得有多快。”</p><p id="fa88" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我喜欢面试蛋糕对大O的解释的原因是，它也告诫我们在分析业绩时不要只看大O。</p><p id="3528" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“大O忽略常数，但有时常数很重要。如果我们有一个运行时间为5小时的脚本，将运行时间除以5的优化可能不会影响big O，但它仍然会为您节省4小时的等待时间……一个伟大的工程师(启动或其他)知道如何在运行时间、空间、实现时间、可维护性和可读性之间取得正确的平衡。”</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="b527" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">既然您已经有了定义并链接到一个很棒的资源来了解更多，我们如何在实际代码上运行实验来测试这些概念呢？这就是performance.now()在使用JavaScript时发挥作用的地方。使用performance.now()，我们可以创建一个简单的计时器来测量代码执行需要多少毫秒。</p><p id="8aaf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，让我们看看基本设置:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="0330" class="lo lp in lk b gy lq lr l ls lt">//make sure you're able to access performance.now()<br/>const {performance} = require('perf_hooks');</span><span id="fe25" class="lo lp in lk b gy lu lr l ls lt">//write out your function<br/>const functionName = () =&gt; {<br/>   //code goes here</span><span id="4de2" class="lo lp in lk b gy lu lr l ls lt">}</span><span id="90e8" class="lo lp in lk b gy lu lr l ls lt">//time your function<br/>const startTimer = performance.now();<br/>functionName();<br/>const endTimer = performance.now();</span><span id="a255" class="lo lp in lk b gy lu lr l ls lt">//log how many milliseconds it took your function to execute<br/>console.log(`This function took ${endTimer - startTimer} milliseconds`);</span></pre><p id="5237" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以把你的计时器的开始和结束放在任何地方，所以这也是测试你的函数的一个方便的方法，看看是什么拖了你的后腿。</p><p id="2326" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们用一个实际的例子来实践这一点，使用两种不同的方法解决HackerRank的“中等”<a class="ae jz" href="https://www.hackerrank.com/challenges/sparse-arrays/problem?h_r=profile" rel="noopener ugc nofollow" target="_blank">级匹配字符串</a>问题。</p><p id="7a50" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">HackerRank的匹配字符串问题要求我们创建一个带有两个参数的函数:“Strings”，一个要搜索的字符串数组，和“queries”，一个查询数组。有了这两个参数，我们需要创建一个函数，返回一个整数数组，表示每个查询在strings数组中出现的频率。</p><p id="aa3d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以使用嵌套循环来解决这个问题。嵌套循环可以(但不总是)在O(n)时间或二次时间内运行。如果一个函数在二次时间内运行，传入1个输入，它将运行10次。如果传入10个输入，它将运行100次。你可以看到时间复杂度会变得非常快。</p><p id="5a38" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我使用嵌套循环解决了匹配字符串问题，我的解决方案可能如下所示:</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="c38d" class="lo lp in lk b gy lq lr l ls lt">const matchingStrings = (strings, queries) =&gt; {<br/>  const results = new Array(queries.length).fill(0);<br/>  for (let i = 0; i &lt; strings.length; i++) {<br/>    for (let j = 0; j &lt; queries.length; j++) {<br/>      if (strings[i] === queries[j]) {<br/>        results.splice(j, 1, results[j] + 1)<br/>      }<br/>    }<br/>  }<br/>  return results;<br/>};</span></pre><p id="f46c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们稍微优化一下这个解决方案，将可能的字符串匹配存储在一个对象中，而不是使用嵌套循环，然后将我们的查询与对象键进行比较，并将值(表示查询在字符串数组中出现的次数)推入结果数组。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="6eaa" class="lo lp in lk b gy lq lr l ls lt">const fasterMatchingStrings = (strings, queries) =&gt; { <br/>  const condensedStrings = {};<br/>  const results = [];<br/>  for (let string of strings) {<br/>    condensedStrings[string] = condensedStrings[string] + 1 || 1;<br/>  }<br/>  for (let query of queries) {<br/>    if (condensedStrings.hasOwnProperty(query)) {<br/>      results.push(condensedStrings[query]);<br/>    } else {<br/>      results.push(0);<br/>    }<br/>  }<br/>  return results;<br/>};</span></pre><p id="c595" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，使用我们计时器的时候到了。首先，让我们来看看HackerRank使用的一个较小的测试。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="63a4" class="lo lp in lk b gy lq lr l ls lt">//First attempt at Matching Strings<br/>const startTime = performance.now();<br/>matchingStrings(['def', 'de', 'fgh'], ['de', 'lmn', 'fgh']);<br/>const endTime = performance.now();</span><span id="afb3" class="lo lp in lk b gy lu lr l ls lt">console.log(`Time to run was ${ endTime - startTime} milliseconds`);</span><span id="5922" class="lo lp in lk b gy lu lr l ls lt">//Second attempt at Matching Strings<br/>const fasterStartTime = performance.now();<br/>fasterMatchingStrings(['def', 'de', 'fgh'], ['de', 'lmn', 'fgh']);<br/>const fasterEndTime = performance.now();</span><span id="f8d8" class="lo lp in lk b gy lu lr l ls lt">console.log(`Time to run was ${ fasterEndTime - fasterStartTime} milliseconds`);</span></pre><p id="76da" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我运行三次(在使用performance.now()时，您不应该只依赖一个结果)，我会得到以下(四舍五入)结果。</p><p id="63d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第一个匹配字符串解(ms): </strong> 7.326，7.846，7.870</p><p id="57a1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第二匹配字符串解(ms): </strong> 0.158，0.152，0.160</p><p id="0242" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">哇，差别真大！但是请记住，Big O中的时间复杂度不是关于一个输入大小如何执行，而是关于当它变得任意大时，运行时相对于输入增长得有多快。让我们尝试一个稍微大一点的输入，看看这在实际代码中意味着什么。</p><pre class="lf lg lh li gt lj lk ll lm aw ln bi"><span id="420f" class="lo lp in lk b gy lq lr l ls lt">//First attempt at Matching Strings<br/>const startTime = performance.now();<br/>matchingStrings(['def', 'de', 'fgh', 'aba', 'bb', 'tig', 'app', 'ghe', 'igh', 'ii'], ['de', 'lmn', 'fgh', 'ii', 'bbb', 'ba', 'tig', 'pa', 'pap']);<br/>const endTime = performance.now();</span><span id="a8e7" class="lo lp in lk b gy lu lr l ls lt">console.log(`Time to run was ${ endTime - startTime} milliseconds`);</span><span id="e622" class="lo lp in lk b gy lu lr l ls lt">//Second attempt at Matching Strings<br/>const fasterStartTime = performance.now();<br/>fasterMatchingStrings(['def', 'de', 'fgh', 'aba', 'bb', 'tig', 'app', 'ghe', 'igh', 'ii'], ['de', 'lmn', 'fgh', 'ii', 'bbb', 'ba', 'tig', 'pa', 'pap']);<br/>const fasterEndTime = performance.now();</span><span id="b9cb" class="lo lp in lk b gy lu lr l ls lt">console.log(`Time to run was ${ fasterEndTime - fasterStartTime} milliseconds`);</span></pre><p id="eac0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果我运行三次，我会得到:</p><p id="d9b0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第一个匹配字符串解(ms): </strong> 9.412，8.194，8.102</p><p id="c92c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">第二个匹配字符串解(ms): </strong> 0.271，0.256，0.232</p><p id="ad8d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一个解决方案只增加了几个输入，就增加了大约0.3毫秒到1毫秒以上，而我们的第二个解决方案增加了大约0.1毫秒。想象一下，随着输入任意增大，这种增长差异会如何继续下去！</p><p id="18ee" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">随着您进一步优化这个解决方案，并随着输入大小的增加继续计时您的函数，您将会看到“最慢”和“最快”函数之间的差异越来越大。这可能是一种有趣且令人满意的方式，有助于具体理解代码中的不同选择如何影响性能！</p></div></div>    
</body>
</html>