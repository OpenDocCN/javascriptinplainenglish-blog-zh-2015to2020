<html>
<head>
<title>Let’s Create a React app with Firebase Auth, Express Backend and MongoDB Database</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们用Firebase Auth、Express Backend和MongoDB数据库创建一个React应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-create-react-app-with-firebase-auth-express-backend-and-mongodb-database-805c83e4dadd?source=collection_archive---------1-----------------------#2020-11-03">https://javascript.plainenglish.io/lets-create-react-app-with-firebase-auth-express-backend-and-mongodb-database-805c83e4dadd?source=collection_archive---------1-----------------------#2020-11-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/64cf9c0de63940049592f82b18223ae4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jbeaWtLN1I7gzH2hKjZH-w.png"/></div></div></figure><div class=""/><p id="ebae" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Firebase是一个非常好的软件开发平台，它可以让你访问身份验证、noSQL数据库、存储等等。这是一个真正的发电站，我喜欢使用Firebase和database Firestore的便利性。</p><p id="c5f1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们都知道在工作中使用正确工具的重要性。如果你用Firebase开发一个应用程序，你可能会遇到云功能不够用的情况，你需要一个单独的后端服务器来完成一些任务。您甚至可以使用Firebase作为您的主枢纽，并让其他微服务连接到它。</p><p id="6f54" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不管怎样，如果您要离开Firebase，您需要进行身份验证。在Firebase和你单独的后端服务器上有不同的认证系统会很奇怪。</p><p id="4131" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，Google允许我们在Firebase之外使用Firebase身份验证。这是通过将Firebase身份验证令牌和有效负载一起发送到后端服务器，并在那里进行验证来实现的。让我们看看如何解决这个问题。</p><p id="5263" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这将是一个循序渐进的教程，我们建立一个简单的例子应用程序。我们将详细介绍每个步骤，您不需要任何Firebase、React或Express方面的经验。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="9df6" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">目录</h1><ul class=""><li id="6881" class="mb mc jb ka b kb md kf me kj mf kn mg kr mh kv mi mj mk ml bi translated"><a class="ae mm" href="#9da3" rel="noopener ugc nofollow">我们正在建造的东西</a></li><li id="0286" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated"><a class="ae mm" href="#f790" rel="noopener ugc nofollow">搭建消防基地</a></li><li id="8c22" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated"><a class="ae mm" href="#28e4" rel="noopener ugc nofollow">始反应前端</a></li><li id="9511" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated"><a class="ae mm" href="#1209" rel="noopener ugc nofollow">开始快递后端</a></li><li id="07a4" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated"><a class="ae mm" href="#fa67" rel="noopener ugc nofollow">与后端通信</a></li><li id="2455" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated"><a class="ae mm" href="#a97b" rel="noopener ugc nofollow">从后端到前端</a></li><li id="a768" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated"><a class="ae mm" href="#c101" rel="noopener ugc nofollow">在前端显示数据</a></li><li id="bbde" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated"><a class="ae mm" href="#f8b9" rel="noopener ugc nofollow">收尾思路</a></li></ul></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="9da3" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">我们正在建造的东西</h1><p id="052d" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们将建立一个简单的电话簿。用户将能够添加电话号码，并看到所有电话号码的列表。我们不会在这个项目中使用任何css样式。让我们看看我们将使用的技术。</p><p id="29d4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> Firebase <br/> </strong>我们将只使用Firebase作为其认证平台。<br/><a class="ae mm" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank">https://firebase.google.com/</a></p><p id="e5ae" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将使用现代的钩子和基于箭头的React作为我们的前端。<br/><a class="ae mm" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/</a></p><p id="1e04" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc"> Express <br/> </strong>我们将在NodeJS中编写我们的后端，使用Express作为我们的后端框架<br/><a class="ae mm" href="https://expressjs.com/" rel="noopener ugc nofollow" target="_blank">https://expressjs.com/</a></p><p id="6eb0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka jc">MongoDB(MongoDB Atlas)<br/></strong>我们将使用MongoDB Atlas作为我们的数据库——一个基于云的MongoDB版本，由MongoDB团队自己托管。对于这个应用程序的功能，常规的SQL数据库是最自然的选择。然而，在npm模块Mongoose的帮助下，MongoDB将充当关系数据库，并为我们的数据提供模式。沿着这条路走下去的好处是，我们可以对结构化数据使用Mongoose，对非结构化数据使用纯MongoDB。在这个应用程序中，我们将只通过Mongoose使用MongoDB。https://www.mongodb.com/<br/><a class="ae mm" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"/></p><h2 id="15d0" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated">Github的完整代码</h2><p id="c810" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">这个项目的完整源代码可以在https://github . com/Devalo/Firebase-auth-react-express-MongoDB找到</p><p id="babf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">对于这样一个简单的应用程序来说，这是一个很大的变动。我们会玩得很开心的！</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="f790" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">设置Firebase</h1><p id="aeb2" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">让我们从创建一个新的Firebase应用程序开始。移至<a class="ae mm" href="http://www.firebase.com" rel="noopener ugc nofollow" target="_blank">www.firebase.com</a>点击“开始”，用你的谷歌账户登录。</p><p id="d32a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，我们必须单击添加项目</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/353439f09a4f12ce78e053885ebc6870.png" data-original-src="https://miro.medium.com/v2/resize:fit:730/format:webp/1*64IRIwCEVALAdjkqUP-xdA.png"/></div></figure><p id="2be9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将为该应用程序命名</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nm"><img src="../Images/22446ad5aeb078fb10beae55360ec411.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TLBFSrwvYDVs1w8a62mu7Q.png"/></div></div></figure><p id="cb08" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们不需要这个项目的谷歌分析</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nn"><img src="../Images/e1989d76522ccd25b7838767d285800d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i0Db5CIMYnBqTKmbqqqxVw.png"/></div></div></figure><p id="7c17" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然后我们按“创建项目”。过一会儿，我们的项目就准备好了。准备好后，点击“继续”。</p><p id="a53d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你看一下左边的菜单，你会发现认证标签。我们将选中它，然后单击“设置登录方法”。</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi no"><img src="../Images/42ac74771d79dce4135c6454385782ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y-FP5wC4Ems2pB6TqKnmIA.png"/></div></div></figure><p id="97a7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将显示不同登录提供商的列表。我们只需要电子邮件/密码。我们悬停在它上面，点击铅笔并打开它。</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi np"><img src="../Images/6bd2825ca710a827f52277145156cdfc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dkW4CDi6xdgV5Qk0jZkxOQ.png"/></div></div></figure><p id="70ba" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们不会在这个项目中创建新用户。我们将只允许用户登录。因此，我们将把新用户直接添加到Firebase身份验证中。点击“用户”</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/aabf0b817c03edc7e78db800ca9159bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:816/format:webp/1*YEji3OI0Z3QBEA_irRW6SQ.png"/></div></figure><p id="54b6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并添加新用户。</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nr"><img src="../Images/4bef9049d85e659a01e51674a97ce441.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fGxcNrBpwUrkdiWrKo2n5w.png"/></div></div></figure><p id="799e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Firebase会自动正确散列密码。您将无法从该面板对用户进行任何更改。所有其他更改必须以编程方式完成。然而，我们的第一个用户被创建:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ns"><img src="../Images/a5881af74898024014f85bdfb2bcf08f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*diXscZGOlWQV6dbuoejxkA.png"/></div></div></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="28e4" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">开始反应前端</h1><h2 id="3d07" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated">设置React</h2><p id="0d5d" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">有了Firebase，我们将开始设置我们的前端。我们将使用create-react-app来引导我们的前端</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="dc6e" class="mv le jb nu b gy ny nz l oa ob">$ npx create-react-app phone-frontend<br/>...<br/>Happy hacking!<br/>$ cd phone-frontend<br/>/phone-frontend $ npm start</span></pre><p id="cd12" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果一切按计划进行，我们应该在<a class="ae mm" href="http://localhost:3000" rel="noopener ugc nofollow" target="_blank"> http://localhost:3000 </a>看到这个</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/d0f1f92315f6e0f4d2550c9929d2fb49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1384/format:webp/1*kVUWIrd3bNSbiP39knR5aQ.png"/></div></figure><p id="5bca" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了。现在，我们的大部分工作将在src文件夹中完成。我们在src文件夹中的文件夹结构如下:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="f7db" class="mv le jb nu b gy ny nz l oa ob">/components<br/>  - /sessions<br/>      Login.jsx<br/>  - /phonebook<br/>      AddNumber.jsx<br/>      ListAllNumbers.jsx<br/>/services<br/>  - phonebookServices.js<br/>App.js<br/>index.js</span></pre><p id="b5cf" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将index.js更改为:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="e703" class="mv le jb nu b gy ny nz l oa ob">// index.js </span><span id="c975" class="mv le jb nu b gy od nz l oa ob">import React from 'react';<br/>import ReactDOM from 'react-dom';<br/>import App from './App';</span><span id="5ec6" class="mv le jb nu b gy od nz l oa ob">ReactDOM.render(<br/>  &lt;React.StrictMode&gt;<br/>    &lt;App /&gt;<br/>  &lt;/React.StrictMode&gt;,<br/>  document.getElementById('root')<br/>);</span></pre><p id="ae4f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">和我们的App.js:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="4b6e" class="mv le jb nu b gy ny nz l oa ob">// App.js</span><span id="1371" class="mv le jb nu b gy od nz l oa ob">function App() {<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      Hello World!<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="32e2" class="mv le jb nu b gy od nz l oa ob">export default App;</span></pre><p id="d762" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们已经准备好开始我们的React前端工作。注意—此时您可能需要重新启动react服务器，以使更改生效。</p><p id="339d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们知道我们将有多个视图。我们需要一种方法来改变登录页面，列出所有电话号码，并添加号码。为此，我们将使用一个名为react-router-dom的npm模块。让我们安装它:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="65f5" class="mv le jb nu b gy ny nz l oa ob">npm install react-router-dom</span></pre><p id="0c86" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要安装firebase包:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="2d04" class="mv le jb nu b gy ny nz l oa ob">npm install firebase</span></pre><p id="6417" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们创建我们的登录路径，并使它在我们没有登录时总是登陆到我们的登录页面。</p><h2 id="89ea" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated">将firebase添加到我们的前端</h2><p id="05c6" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">在之前的步骤中，我们创建了一个新的Firebase应用程序。我们需要从firebase网站上获取一些配置。</p><p id="c623" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">回到firebase网站，单击左侧导航栏中最上面的链接——项目概述。我们需要添加一个新的web应用程序:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi oe"><img src="../Images/e8845860b870c6216f6df448f70cfa95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*CEH-Yicck1GaT3fnS5XT1A.png"/></div></figure><p id="7f41" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们给它起了个名字:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi of"><img src="../Images/3fe2ac6db82cb08e146c2967220fed82.png" data-original-src="https://miro.medium.com/v2/resize:fit:1312/format:webp/1*fctmBvkt--9_PjNXdZ3phA.png"/></div></figure><p id="7593" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们复制firebaseConfig对象，然后单击“继续到控制台”</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi og"><img src="../Images/18d06df2f1045d64e145a779ee8c5766.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HwLBRI_DyZfjl_FV3m7Kkg.png"/></div></div></figure><p id="d382" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在一个生产应用中，你可以把这些配置放在环境变量中，但是Google声明这不是绝对必要的。这是因为Firebase安全性基于多个规则，这些规则限制和开放了应用程序。依我拙见，隐藏这些类型的设置总是更好。不过，我可能错了。</p><p id="6703" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的src文件夹中，我们将创建一个新文件——fire . js，并将我们的配置添加到其中。该文件应该如下所示:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="3137" class="mv le jb nu b gy ny nz l oa ob">// fire.js</span><span id="1e5b" class="mv le jb nu b gy od nz l oa ob"><br/>import firebase from 'firebase';</span><span id="7aa4" class="mv le jb nu b gy od nz l oa ob">const firebaseConfig = {<br/>    apiKey: "AIzaSyAHDUwcM0zO4yMCoyazo4w-HOeKfGsQL2g",<br/>    authDomain: "phone-book-fe436.firebaseapp.com",<br/>    databaseURL: "<a class="ae mm" href="https://phone-book-fe436.firebaseio.com" rel="noopener ugc nofollow" target="_blank">https://phone-book-fe436.firebaseio.com</a>",<br/>    projectId: "phone-book-fe436",<br/>    storageBucket: "phone-book-fe436.appspot.com",<br/>    messagingSenderId: "410083027161",<br/>    appId: "1:410083027161:web:e69ec743153a72d48df6c8"<br/>};</span><span id="c2f0" class="mv le jb nu b gy od nz l oa ob">try {<br/>  firebase.initializeApp(firebaseConfig);<br/>} catch (err) {<br/>  if (!/already exists/.test(err.message)) {<br/>    console.error('Firebase initialization error', err.stack);<br/>  }<br/>}</span><span id="5afc" class="mv le jb nu b gy od nz l oa ob">const fire = firebase;<br/>export default fire;</span></pre><p id="33fd" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将在这个文件中使用firebase。我们现在准备开始认证用户。</p><h2 id="ad29" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated"><strong class="ak">设置认证</strong></h2><p id="4efc" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">Firebase为我们提供了一种非常简单的方法来检查我们是否通过了身份验证。我们将使用useState()钩子创建一个新的状态，并将结果存储在那里:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="d26d" class="mv le jb nu b gy ny nz l oa ob">// App.js<br/></span><span id="2a51" class="mv le jb nu b gy od nz l oa ob">import React, { useState } from 'react';</span><span id="9a5e" class="mv le jb nu b gy od nz l oa ob">import fire from './fire.js';</span><span id="639f" class="mv le jb nu b gy od nz l oa ob">function App() {<br/>  const [isLoggedIn, setIsLoggedIn] = useState(false);<br/>  <br/>    fire.auth().onAuthStateChanged((user) =&gt; {<br/>      return user ? setIsLoggedIn(true) : setIsLoggedIn(false);<br/>  });<br/>  <br/>  console.log('logged in?', isLoggedIn);<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      Hello World!<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="6b0f" class="mv le jb nu b gy od nz l oa ob">export default App;</span></pre><p id="72b7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从React库中导入useState，从firebase配置文件中导入firebase。我们使用。onAuthStateChanged()函数来检查用户是否登录。如果我们已经登录，我们将把isLoggedIn状态设置为true。</p><p id="e3ad" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们检查我们的控制台，它清楚地表明我们没有登录。</p><p id="edf3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将创建第一条路线。现在，对于每个请求，我们都希望在继续之前检查我们是否已登录。</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="dbfb" class="mv le jb nu b gy ny nz l oa ob">// App.js</span><span id="62e3" class="mv le jb nu b gy od nz l oa ob">import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';</span><span id="2d4e" class="mv le jb nu b gy od nz l oa ob">...</span><span id="b75c" class="mv le jb nu b gy od nz l oa ob">&lt;div className="App"&gt;<br/>      &lt;Router&gt;<br/>        <br/>        {!isLoggedIn<br/>          ? (<br/>            &lt;&gt;<br/>              &lt;Switch&gt;<br/>                &lt;Route path="/"&gt;<br/>                  &lt;Login /&gt;<br/>                &lt;/Route&gt;<br/>              &lt;/Switch&gt;<br/>            &lt;/&gt;<br/>          ) <br/>          : (<br/>            &lt;&gt;<br/>              Hello World!<br/>            &lt;/&gt;<br/>          )}<br/>      &lt;/Router&gt;<br/>    &lt;/div&gt;<br/>...</span></pre><p id="8fe0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所有路由都是交换机组件的子组件，而交换机组件是路由器组件的子组件。如果我们没有登录，除了登录组件，我们将看不到任何东西。我们可以通过查看空白页来验证这一点。</p><p id="310b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们转到登录组件，看看我们能否在页面上添加一些内容。</p><p id="3481" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将首先创建一个简单、可行的表单，记录电子邮件和密码输入:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="a431" class="mv le jb nu b gy ny nz l oa ob">// components/session/Login.jsx<br/></span><span id="a5ae" class="mv le jb nu b gy od nz l oa ob">import React, { useState } from 'react';<br/>import fire from '../../fire.js';</span><span id="ec00" class="mv le jb nu b gy od nz l oa ob">const Login = () =&gt; {<br/>    const [email, setEmail] = useState();<br/>    const [password, setPassword] = useState();<br/>    <br/>    const handleSubmit = (e) =&gt; {<br/>        e.preventDefault();<br/>        console.log(`submitted email: <br/>          ${email} password: ${password}`);<br/>    }<br/>    return (<br/>        &lt;div&gt;    <br/>        &lt;h2&gt;Login&lt;/h2&gt;<br/>            &lt;form onSubmit={handleSubmit}&gt;<br/>                &lt;input<br/>                    type="text"<br/>                    onChange={({ target }) =&gt;     <br/>                      setEmail(target.value)}<br/>                    placeholder="Email"<br/>                /&gt;<br/>                &lt;br /&gt;<br/>                &lt;input<br/>                    type="password"<br/>                    onChange={({ target}) =&gt; <br/>                      setPassword(target.value)}<br/>                    placeholder="Password"<br/>                /&gt;<br/>                &lt;br /&gt;<br/>                &lt;button type="submit"&gt;<br/>                    Sign in<br/>                &lt;/button&gt;<br/>            &lt;/form&gt;<br/>        &lt;/div&gt;<br/>    )<br/>};</span><span id="2614" class="mv le jb nu b gy od nz l oa ob">export default Login</span></pre><p id="998f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们设置了两个新的状态挂钩，它们将保存我们的电子邮件和密码状态。每个输入都有一个onChange属性，它直接记录每个状态钩子的输入。如果我们按下“登录”按钮，我们输入的数据将显示在我们的控制台上。相当整洁。登录将变得非常容易。我们只需向提交函数添加一行代码:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="e5c2" class="mv le jb nu b gy ny nz l oa ob">// components/session/Login.jsx</span><span id="66c7" class="mv le jb nu b gy od nz l oa ob">...</span><span id="fca3" class="mv le jb nu b gy od nz l oa ob">const handleSubmit = (e) =&gt; {<br/>  e.preventDefault();<br/>  fire.auth().signInWithEmailAndPassword(email, password)<br/>    .catch((error) =&gt; {<br/>      console.error('Incorrect username or password');<br/>    });<br/>  }</span><span id="282d" class="mv le jb nu b gy od nz l oa ob">...</span></pre><p id="5cb7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这条简单的线。如果您输入了错误的电子邮件和密码:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/de6acf042133637d5fe441d91243b6c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:544/format:webp/1*HuGeAGM8Y2ouBZ7xWHnpUg.png"/></div></figure><p id="b4e3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们使用正确的用户名和密码登录，我们将恢复我们的Hello World！文本，我们的控制台现在打印true(来自保存会话状态的状态钩子)。</p><p id="478d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">花点时间，让它深入人心。这是难以置信的简单认证。我不认为你能比这更容易得到它。</p><p id="3afb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可能也应该想出一个注销的方法。幸运的是，Firebase也让这变得非常简单。替换文本“Hello World！”在App.js中使用:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="bd83" class="mv le jb nu b gy ny nz l oa ob">// App.js</span><span id="8bdb" class="mv le jb nu b gy od nz l oa ob"><br/>&lt;span onClick={signOut}&gt;<br/>  &lt;a href="#"&gt;Sign out&lt;/a&gt;<br/>&lt;/span&gt;</span></pre><p id="ba74" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并向App组件添加一个新功能:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="efb2" class="mv le jb nu b gy ny nz l oa ob">const signOut = () =&gt; {<br/>    fire.auth().signOut()<br/>};</span></pre><p id="9429" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！单击“注销”后，我们会被重定向回登录表单。我们有了一个好的开始！</p><h2 id="611e" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated">为我们的电话号码创建视图</h2><p id="b9c6" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们之前为我们的电话号码创建了一个组件文件。现在是开始实现我们的数据显示方式的好时机。让我们从创建一条新路线开始。我们会将我们的路线放在“登出”链接的下方:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="df37" class="mv le jb nu b gy ny nz l oa ob">// App.js</span><span id="21fa" class="mv le jb nu b gy od nz l oa ob">import ListAllNumbers from './components/phonebook/ListAllNumbers';</span><span id="cf43" class="mv le jb nu b gy od nz l oa ob">...</span><span id="5b58" class="mv le jb nu b gy od nz l oa ob">&lt;span onClick={signOut}&gt;<br/>  &lt;a href="#"&gt;Sign out&lt;/a&gt;<br/>&lt;/span&gt;<br/>&lt;Switch&gt;<br/>  &lt;Route path="/"&gt;<br/>    &lt;ListAllNumbers /&gt;<br/>  &lt;/Route&gt;<br/>&lt;/Switch&gt;</span><span id="480f" class="mv le jb nu b gy od nz l oa ob">...</span></pre><p id="30b5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">你一保存文件，应用程序就会崩溃。没关系。我们还没有创建ListAllNumbers组件。让我们来看看组件文件。</p><p id="c37b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们将创建一个非常简单的表，我们将在其中显示我们的数据:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="6fcf" class="mv le jb nu b gy ny nz l oa ob">// components/phonebook/ListAllNumbers.jsx</span><span id="0e4b" class="mv le jb nu b gy od nz l oa ob">import React from 'react';<br/>import { Link } from 'react-router-dom';</span><span id="cc7e" class="mv le jb nu b gy od nz l oa ob">const ListAllNumbers = () =&gt; {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Link to="/add-number"&gt;Add number&lt;/Link&gt;<br/>      &lt;h2&gt;Phone numbers&lt;/h2&gt;<br/>    <br/>      &lt;table&gt;<br/>        &lt;thead&gt;<br/>          &lt;tr&gt;<br/>            &lt;th&gt;Name&lt;/th&gt;<br/>            &lt;th&gt;Number&lt;/th&gt;<br/>          &lt;/tr&gt;<br/>        &lt;/thead&gt;<br/>        &lt;tbody&gt;<br/>          &lt;tr&gt;<br/>            &lt;td&gt;Foo Bar&lt;/td&gt;<br/>            &lt;td&gt;999888777&lt;/td&gt;<br/>          &lt;/tr&gt;<br/>        &lt;/tbody&gt;<br/>      &lt;/table&gt;<br/>    &lt;/div&gt;<br/>  ) <br/>};</span><span id="498b" class="mv le jb nu b gy od nz l oa ob">export default ListAllNumbers;</span></pre><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/be7b82df5c2dba2a0547d81f29468c45.png" data-original-src="https://miro.medium.com/v2/resize:fit:416/format:webp/1*XJZvlpr6_FrsVrm4LBpPBw.png"/></div></figure><p id="8bcc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这是一个杰作..</p><h2 id="f29f" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated">创建添加电话号码的视图</h2><p id="03f3" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">在开始查看任何逻辑之前，我们将创建最后一个视图。我们将在原有路线的基础上建立一条新路线。</p><p id="776f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">整个App.js将看起来像这样:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="20d9" class="mv le jb nu b gy ny nz l oa ob">// App.js</span><span id="9961" class="mv le jb nu b gy od nz l oa ob"><br/>import React, { useState } from 'react';<br/>import { BrowserRouter as Router, Switch, Route} from 'react-router-dom';</span><span id="ad89" class="mv le jb nu b gy od nz l oa ob">import fire from './fire.js';<br/>import Login from './components/session/Login';<br/>import ListAllNumbers from './components/phonebook/ListAllNumbers';<br/>import AddNumber from './components/phonebook/AddNumber';<br/>function App() {<br/>  const [isLoggedIn, setIsLoggedIn] = useState(false);<br/>  <br/>    fire.auth().onAuthStateChanged((user) =&gt; {<br/>      return user ? setIsLoggedIn(true) : setIsLoggedIn(false);<br/>  });<br/>  <br/>  const signOut = () =&gt; {<br/>    fire.auth().signOut()<br/>  };<br/>  <br/>  console.log(isLoggedIn);<br/>  return (<br/>    &lt;div className="App"&gt;<br/>      &lt;Router&gt;<br/>        {!isLoggedIn<br/>          ? (<br/>            &lt;&gt;<br/>            &lt;Switch&gt;<br/>              &lt;Route path="/"&gt;<br/>                &lt;Login /&gt;<br/>              &lt;/Route&gt;<br/>            &lt;/Switch&gt;<br/>            &lt;/&gt;<br/>          ) <br/>          : (<br/>            &lt;&gt;<br/>            &lt;span onClick={signOut}&gt;<br/>              &lt;a href="#"&gt;Sign out&lt;/a&gt;<br/>            &lt;/span&gt;<br/>            &lt;Switch&gt;<br/>              &lt;Route path="/add-number"&gt;<br/>                &lt;AddNumber /&gt;<br/>              &lt;/Route&gt;<br/>              &lt;Route path="/"&gt;<br/>                &lt;ListAllNumbers /&gt;<br/>              &lt;/Route&gt;<br/>            &lt;/Switch&gt;<br/>            &lt;/&gt;<br/>          <br/>          )}<br/>      &lt;/Router&gt;<br/>    &lt;/div&gt;<br/>  );<br/>}</span><span id="8d72" class="mv le jb nu b gy od nz l oa ob">export default App;</span></pre><p id="b5f0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完美。我们的路线已经配置好了。让我们跳转到AddNumber组件并添加必要的代码:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="c2e5" class="mv le jb nu b gy ny nz l oa ob">// components/phonebook/AddNumber.js</span><span id="90fa" class="mv le jb nu b gy od nz l oa ob">import React, { useState } from 'react';<br/>import { Link } from 'react-router-dom';</span><span id="484d" class="mv le jb nu b gy od nz l oa ob">const AddNumber = () =&gt; {<br/>  const [name, setName] = useState();<br/>  const [phone, setPhone] = useState();<br/>  <br/>  const handleSubmit = (e) =&gt; {<br/>    e.preventDefault();<br/>    <br/>    console.log(`submitted: ${name} - ${phone}`);<br/>  };<br/>  <br/>  return (<br/>    &lt;div&gt;<br/>      &lt;Link to="/"&gt;View phonebook&lt;/Link&gt;<br/>    &lt;h2&gt;Add Number&lt;/h2&gt;<br/>    &lt;form onSubmit={handleSubmit}&gt;<br/>      &lt;input<br/>        type="text"<br/>        placeholder="Name"<br/>        onChange={({ target }) =&gt; setName(target.value)}<br/>      /&gt;&lt;br /&gt;<br/>      &lt;input<br/>        type="text"<br/>        placeholder="Number"<br/>        onChange={({ target }) =&gt; setPhone(target.value)}<br/>      /&gt;&lt;br /&gt;<br/>      <br/>      &lt;button type="submit"&gt;<br/>        Add number<br/>      &lt;/button&gt;<br/>    &lt;/form&gt;<br/>    &lt;/div&gt;<br/>  )<br/>};</span><span id="8de7" class="mv le jb nu b gy od nz l oa ob">export default AddNumber;</span></pre><p id="eeed" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">正如我们对登录字段所做的那样，我们将两个输入字段都存储在一个状态钩子中。在提交时，我们将输入数据打印到控制台。完美。这和我们的前端一样棒。我们现在已经完成了前端。我们应该创建后端，然后连接数据库。我们将很快返回前端。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="1209" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">开始快速后端</h1><p id="fb37" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们将在framework Express的帮助下构建后端。我们的后端将是一个独立的应用程序。让我们从前端光盘，并为我们的后端创建一个新的文件夹:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="649e" class="mv le jb nu b gy ny nz l oa ob">/phone-frontend $ cd ..<br/>$ mkdir phone-backend<br/>$ cd phone-backend<br/>/phone-backend $ npm init</span></pre><p id="67df" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们用“npm init”开始一个新的JS项目。这里的问题现在对我们来说都不重要，所以只需点击回车直到结束。完成后，我们将在手机后端文件夹中创建一个package.json文件。</p><p id="8bd9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">由于我们的后端将是一个JSON-API，我们不打算使用任何快速生成器来引导我们的应用程序。我们将从安装Express开始:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="f890" class="mv le jb nu b gy ny nz l oa ob">/phone-backend $ npm install express</span></pre><p id="1793" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并创建我们的端点索引. js文件:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="0544" class="mv le jb nu b gy ny nz l oa ob">/phone-backend $ touch index.js</span></pre><p id="6553" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们的索引文件中，我们将编写一个快速服务器:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="4235" class="mv le jb nu b gy ny nz l oa ob">// index.js</span><span id="4f73" class="mv le jb nu b gy od nz l oa ob"><br/>const express = require('express');</span><span id="7702" class="mv le jb nu b gy od nz l oa ob">const app = express();</span><span id="982f" class="mv le jb nu b gy od nz l oa ob">app.get('/', (req, res) =&gt; {<br/>    res.send('Hello World');<br/>});</span><span id="f59b" class="mv le jb nu b gy od nz l oa ob">const PORT = 3001;<br/>app.listen(PORT, () =&gt; {<br/>    console.log(`Server is running on port ${PORT}`);<br/>});</span></pre><p id="dd2b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是创建服务器端点的全部工作。我们可以用app.get()定义一条路由。如果你前往<a class="ae mm" href="http://localhost:3001" rel="noopener ugc nofollow" target="_blank"> http://localhost:3001 </a>网站，你会收到那条可爱的信息:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/f6e8a933145aae9244aa9e0cfe779345.png" data-original-src="https://miro.medium.com/v2/resize:fit:454/format:webp/1*gPkPBXRpVPqyx7yDDpBHgQ.png"/></div></figure><p id="a11e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们考虑一下应用程序的流程。</p><ul class=""><li id="b628" class="mb mc jb ka b kb kc kf kg kj ok kn ol kr om kv mi mj mk ml bi translated">前端将向我们的根路由发送一个GET请求，查询所有条目</li><li id="e427" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">后端将接收请求，并从数据库中提取</li><li id="64c8" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">前端将向我们的根路由发送一个POST请求，添加一个条目</li><li id="38c2" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">后端将接收请求，并添加到数据库</li></ul><p id="79de" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一个好的起点是路线框架。我们将这样构建我们的应用程序:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="1971" class="mv le jb nu b gy ny nz l oa ob">- controllers<br/>  phones.js<br/>- models<br/>  phone.js<br/>index.js</span></pre><h2 id="33fe" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated">写出我们的控制器，安装nodemon</h2><p id="aaa2" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们将从包含路线的控制器开始。只有两个，所以编码相当容易。我们将使用快速路由器，它是一种功能强大的内置路由器。</p><p id="33f7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的控制器文件将如下所示:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="3f76" class="mv le jb nu b gy ny nz l oa ob">// controllers/phones.js</span><span id="2512" class="mv le jb nu b gy od nz l oa ob"><br/>const phonesRouter = require('express').Router();</span><span id="c878" class="mv le jb nu b gy od nz l oa ob">phonesRouter.get('/', (req, res) =&gt; {<br/>  return res.send('Hi, from within the phones router GET'); <br/>});</span><span id="a88c" class="mv le jb nu b gy od nz l oa ob">phonesRouter.post('/', (req, res) =&gt; {<br/>  return res.send('Hi, from within the phones router POST');<br/>});</span><span id="1b69" class="mv le jb nu b gy od nz l oa ob">module.exports = phonesRouter;</span></pre><p id="a1bb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">两条路线。一个用于GET请求，一个用于POST请求。它们在被调用时会返回一条消息。现在，我们将它导入到index.js中，并用phoneRouter替换我们之前的路由。请注意，我们在url中添加了“/api”。我们查询API的url将是http://localhost:3001/api</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="ef2b" class="mv le jb nu b gy ny nz l oa ob">const express = require('express');</span><span id="2bed" class="mv le jb nu b gy od nz l oa ob">const phonesRouter = require('./controllers/phones');<br/>const app = express();</span><span id="823f" class="mv le jb nu b gy od nz l oa ob">app.use('/api', phonesRouter);</span><span id="ce73" class="mv le jb nu b gy od nz l oa ob">const PORT = 8080;<br/>app.listen(PORT, () =&gt; {<br/>    console.log(`Server is running on port ${PORT}`);<br/>});</span></pre><p id="3c44" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你尝试移动到我们的新网址，什么也不会发生。事实证明，当我们修改代码时，我们的应用程序不会自动重新加载。为了解决这个问题，我们将安装一个名为nodemon的npm包，它将做到这一点—代码更改时重新加载:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="a2bf" class="mv le jb nu b gy ny nz l oa ob">/phone-backend $ npm install nodemon</span></pre><p id="f9ab" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了使用nodemon，我们将在package.json文件中创建一个小脚本:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="44da" class="mv le jb nu b gy ny nz l oa ob">// package.json</span><span id="093f" class="mv le jb nu b gy od nz l oa ob">...</span><span id="820f" class="mv le jb nu b gy od nz l oa ob">"scripts": {<br/>    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",<br/>    "dev": "nodemon index.js"<br/>  },<br/>...</span></pre><p id="5a45" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">“开发”脚本将使用nodemon启动我们的应用程序。我们用npm run dev命令启动我们的应用程序:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="b03c" class="mv le jb nu b gy ny nz l oa ob">/phone-backend $ npm run dev<br/>&gt; nodemon index.js</span><span id="1d9f" class="mv le jb nu b gy od nz l oa ob">[nodemon] 2.0.6<br/>[nodemon] to restart at any time, enter `rs`<br/>[nodemon] watching path(s): *.*<br/>[nodemon] watching extensions: js,mjs,json<br/>[nodemon] starting `node index.js`<br/>Server is running on port 3001</span></pre><p id="8e50" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太棒了，如果你返回<a class="ae mm" href="http://localhost:3001/api," rel="noopener ugc nofollow" target="_blank"> http://localhost:3001/api，</a>你会收到一条直接来自路由的消息。我们即将从数据库中获取数据。关于这一点——让我们建立一个新的MongoDB Atlas数据库</p><h2 id="98b0" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated">设置MongoDB地图集</h2><p id="9d7a" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们需要做的第一件事，是前往MongoDB Atlas并创建我们的帐户:前往https://www.mongodb.com/cloud/atlas/signup<a class="ae mm" href="https://www.mongodb.com/cloud/atlas/signup" rel="noopener ugc nofollow" target="_blank">并创建一个新用户。</a></p><p id="9352" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">选择空闲群集:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi on"><img src="../Images/636e737081a9a331accb358808d36e95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*whDioD0kHkVQ_8cEMXVOPw.png"/></div></div></figure><p id="d28f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您将能够选择哪个提供商来托管您的数据库，以及该地区。我打算用谷歌托管的数据库。单击“创建集群”:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oo"><img src="../Images/f5d20e69d1a9a1b4fb1040f60d555edc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uw7qwPKtLSTYxj0kAFUx3g.png"/></div></div></figure><p id="db50" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将出现一个向导。一旦集群启动并运行，让我们按照它的步骤进行。这可能需要几分钟时间:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi op"><img src="../Images/bb1b2a3c7c3f307eda751465c2078829.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gJFMew33bfg9kR5t_AzlZg.png"/></div></div></figure><p id="5693" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将从创建第一个数据库用户开始。前往数据库访问:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oq"><img src="../Images/14bf3cf768fa513a78e9f53b76ab2e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HWerLuHPFX0Ogji7KLyCdw.png"/></div></div></figure><p id="631e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">创建新用户:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi or"><img src="../Images/f19346f0b5075da07dd7c057f76987ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1310/format:webp/1*wuvoxe1DAO_jIUK0KK881w.png"/></div></figure><p id="eab4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并添加用户。一旦完成，我们需要将我们的服务器列入白名单。我们将在这里使用标准IP 0.0.0.0:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi os"><img src="../Images/f0b6a91eb7082815b4bcc2413d682a85.png" data-original-src="https://miro.medium.com/v2/resize:fit:1398/format:webp/1*aIPLuvjMIxVgCgFRqEPFIQ.png"/></div></div></figure><p id="e87b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将IP地址列入白名单提供了额外的安全层。然而，我们的后端将登录到用户名和密码的数据库，所以它不是完全开放的。</p><p id="9c1e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦完成，下一步将是连接我们的数据库到我们的后端。</p><p id="7357" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将选择连接我们的应用程序:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ot"><img src="../Images/f6a9d92a39308e5f690fd78ae4eca230.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nzI7wU8PeQLzfs9Exdiwzw.png"/></div></div></figure><p id="d336" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">复制网址。这是我们将用来连接数据库的url。保存url以备后用:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/88dfda45806a8479d2369d633e6d9b00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*KjEk5bUO8wbmGZpzExiEqg.png"/></div></figure><p id="6ec2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">MongoDB Atlas已配置。让我们回到我们的后端，把它连接起来。</p><h2 id="4613" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated">将后端连接到MongoDB Atlas</h2><p id="45d2" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">如前所述，我们将使用Mongoose而不是纯MongoDB。这将为我们提供一些结构。(这有点违背了使用noSQL数据库的目的，但是有了Mongoose，您可以两者兼得)。让我们安装它:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="41f1" class="mv le jb nu b gy ny nz l oa ob">/phones-backend $ npm install mongoose</span></pre><p id="ebf6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了简单起见，我们将在index.js中添加连接到MongoDB的代码。当然，您可以将它存储在其他地方，并将其导入index.js:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="7dd5" class="mv le jb nu b gy ny nz l oa ob">// index.js</span><span id="f8e4" class="mv le jb nu b gy od nz l oa ob">const mongoose = require('mongoose');</span><span id="0877" class="mv le jb nu b gy od nz l oa ob">...</span><span id="d70e" class="mv le jb nu b gy od nz l oa ob">mongoose.connect(<br/> 'mongodb+srv://foobar:<a class="ae mm" href="mailto:foobar123@cluster0.ylunw.mongodb.net" rel="noopener ugc nofollow" target="_blank">foobar123@cluster0.ylunw.mongodb.net</a>/phonebook?retryWrites=true&amp;w=majority',<br/> { useNewUrlParser: true, useUnifiedTopology: true })<br/>  .then(() =&gt; {<br/>    console.log('Connected to database');<br/>  })<br/>  .catch((err) =&gt; {<br/>    console.log('Error connecting to DB', err.message);<br/>  });</span><span id="56d6" class="mv le jb nu b gy od nz l oa ob">...</span></pre><p id="e572" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将您之前复制的MongoDB URL粘贴到mongoose的connect函数中。用您自己的凭证替换<password>和<dbname>。当您保存时，服务器将重新启动，您会在控制台中收到可爱的消息，说明您已连接到数据库。如果由于某种原因出现错误，请确保您输入了正确的凭据。</dbname></password></p><p id="ce8b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的后端服务器和数据库之间的连接现在已经完成。这意味着我们可以开始从数据库中取出东西，并把东西放入其中。在此之前，让我们回到前端。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="fa67" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">与后端通信</h1><p id="3f60" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">如果我们回顾一下我们之前编写的应用程序的流程</p><ul class=""><li id="4c10" class="mb mc jb ka b kb kc kf kg kj ok kn ol kr om kv mi mj mk ml bi translated">前端将向我们的根路由发送一个GET请求，查询所有条目</li><li id="0fdb" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">后端将接收请求，并从数据库中提取</li><li id="cc40" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">前端将向我们的根路由发送一个POST请求，添加一个条目</li><li id="c427" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">后端将接收请求，并添加到数据库</li></ul><p id="0706" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以看到前端需要向后端发送一个get请求。我们希望在请求中包含一个firebase auth令牌。这样，后端可以在允许访问数据库之前验证用户。</p><p id="499b" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们希望将与后端通信的代码与视图组件本身分开。在我们的AddNumber.jsx文件中，我们将把表单数据发送给一个服务，该服务将处理后端通信。如果您还没有在服务文件夹中创建phonebookServices.js文件，这将是一个很好的时机。</p><h2 id="753f" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated">将数据传递给服务</h2><p id="a904" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">首先，让我们让前端和后端互相通信。在开始发送firebase令牌之前，我们将重点关注这一点。在AddNumber.jsx中，我们将向handleSubmit()函数添加一些代码:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="2786" class="mv le jb nu b gy ny nz l oa ob">// components/phonebook/AddNumber.jsx<br/></span><span id="4fec" class="mv le jb nu b gy od nz l oa ob">import { addToPhonebook } from '../../services/phonebookServices';</span><span id="6c99" class="mv le jb nu b gy od nz l oa ob">...</span><span id="c46b" class="mv le jb nu b gy od nz l oa ob">const handleSubmit = (e) =&gt; {<br/>    e.preventDefault();</span><span id="28eb" class="mv le jb nu b gy od nz l oa ob">  if (name &amp;&amp; phone) {<br/>      phonebookServices.addToPhonebook(name, phone);<br/>    }<br/>  console.log('You must enter a name and a number');<br/>  };</span><span id="60de" class="mv le jb nu b gy od nz l oa ob">...</span></pre><p id="9f92" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果两个字段都填写了，我们会将数据发送给我们的服务。如果没有，我们打印到控制台。如果你真的填了东西并提交了，这个应用就会爆炸。<br/>接下来让我们来修复服务吧！</p><h2 id="ba5c" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated">将数据从服务传递到数据库，然后再传递回来。</h2><p id="e985" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">该服务将负责与后端服务来回通信。我们可以使用内置的fetch库来做到这一点。我们将使用axios库，因为我发现它更容易使用。让我们安装它:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="c6fb" class="mv le jb nu b gy ny nz l oa ob">/phone-frontend $ npm install axios</span></pre><p id="72d8" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们知道我们的后端服务器运行在<a class="ae mm" href="http://localhost:3001/api," rel="noopener ugc nofollow" target="_blank"> http://localhost:3001/api，</a>，所以是时候将表单数据发送到那个url了。在我们的服务文件中:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="8c5b" class="mv le jb nu b gy ny nz l oa ob">// services/phonebookServices.js</span><span id="cef8" class="mv le jb nu b gy od nz l oa ob"><br/>import axios from 'axios';</span><span id="a88d" class="mv le jb nu b gy od nz l oa ob">const url = '<a class="ae mm" href="http://localhost:3001/api'" rel="noopener ugc nofollow" target="_blank">http://localhost:3001/api'</a>;</span><span id="e8cf" class="mv le jb nu b gy od nz l oa ob">export const addToPhonebook = (name, number) =&gt; {<br/>  const payload = {<br/>    name,<br/>    number,<br/>  }<br/>  axios.post(url, payload);<br/>};</span></pre><p id="5c1f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们创建一个新的JS对象，并用后端url将其传递给axios。前所未有的兴奋，我们填写并发送我们的表格:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/f128d085eea5d56c8720a8b544838888.png" data-original-src="https://miro.medium.com/v2/resize:fit:850/format:webp/1*7iQLR7Z9Yqmlgh6asm-sEg.png"/></div></figure><p id="59c0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">哇哦。这不起作用。嗯，这是因为跨产地资源共享，简称CORS。</p><blockquote class="ow ox oy"><p id="98f7" class="jy jz oz ka b kb kc kd ke kf kg kh ki pa kk kl km pb ko kp kq pc ks kt ku kv ij bi translated">来自mozilla开发者</p><p id="b01c" class="jy jz oz ka b kb kc kd ke kf kg kh ki pa kk kl km pb ko kp kq pc ks kt ku kv ij bi translated"><strong class="ka jc">跨源资源共享</strong> ( <a class="ae mm" href="https://developer.mozilla.org/en-US/docs/Glossary/CORS" rel="noopener ugc nofollow" target="_blank"> CORS </a>)是一种机制，它使用额外的<a class="ae mm" href="https://developer.mozilla.org/en-US/docs/Glossary/HTTP" rel="noopener ugc nofollow" target="_blank"> HTTP </a>头来告诉浏览器，让运行在一个<a class="ae mm" href="https://developer.mozilla.org/en-US/docs/Glossary/origin" rel="noopener ugc nofollow" target="_blank">源</a>的web应用程序访问来自不同源的选定资源。当web应用程序请求来源(域、协议或端口)与其自身不同的资源时，它会执行跨来源HTTP请求。</p></blockquote><p id="9b96" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将通过安装一个名为cors的模块来解决这个问题。转到后端，安装它:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="5203" class="mv le jb nu b gy ny nz l oa ob">/phone-backend $ npm install cors</span></pre><p id="16c4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">并将其应用到我们的后端:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="12d0" class="mv le jb nu b gy ny nz l oa ob">// index.js</span><span id="7691" class="mv le jb nu b gy od nz l oa ob">const cors = require('cors');</span><span id="aa37" class="mv le jb nu b gy od nz l oa ob">...</span><span id="31c7" class="mv le jb nu b gy od nz l oa ob">const app = express();</span><span id="90a8" class="mv le jb nu b gy od nz l oa ob">app.use(cors());</span><span id="f4cf" class="mv le jb nu b gy od nz l oa ob">...</span></pre><p id="1772" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">安装了cors后，我们再次尝试我们的前端，一切都如预期的那样工作:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi pd"><img src="../Images/296bcd849a0383847b1146b62257adfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*H8sPNVgo0YUOmL7KJqTWAg.png"/></div></figure><p id="7034" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这太完美了。前端和后端现在正在通信。我们需要做的下一件事，是弄清楚如何将Firebase令牌和有效负载一起从前端发送到后端。</p><h2 id="eb56" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated">前端Firebase令牌</h2><p id="2a6d" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">Firebase的伟大之处在于它非常易于使用。创建令牌也是如此。我们将在服务文件中创建一个新函数，它将为我们创建令牌。</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="a68e" class="mv le jb nu b gy ny nz l oa ob">// services/phonebookService.js</span><span id="857f" class="mv le jb nu b gy od nz l oa ob">import fire from '../fire';</span><span id="5835" class="mv le jb nu b gy od nz l oa ob">...</span><span id="030e" class="mv le jb nu b gy od nz l oa ob">const createToken = async () =&gt; {<br/>  const user = fire.auth().currentUser;<br/>  const token = user &amp;&amp; (await user.getIdToken());</span><span id="b398" class="mv le jb nu b gy od nz l oa ob">  const payloadHeader = {<br/>    headers: {<br/>      'Content-Type': 'application/json',<br/>      Authorization: `Bearer ${token}`,<br/>    },<br/>  };<br/>  return payloadHeader;<br/>}</span><span id="6112" class="mv le jb nu b gy od nz l oa ob">...</span></pre><p id="5107" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个函数从Firebase Auth库中获取当前用户。我们使用当前用户来获取id令牌。我们需要将这个令牌放在我们的请求头中。最简单的方法是创建并返回包含令牌的头。</p><p id="0dbc" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在addToPhonebook函数中，我们将使用一个异步try…catch块来增强代码，并将我们新生成的auth头包含在有效负载中:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="2b23" class="mv le jb nu b gy ny nz l oa ob">// services/phonebookServices.js</span><span id="4710" class="mv le jb nu b gy od nz l oa ob">...</span><span id="b28d" class="mv le jb nu b gy od nz l oa ob">export const addToPhonebook = async (name, number) =&gt; {<br/>  const header = await createToken();</span><span id="efba" class="mv le jb nu b gy od nz l oa ob">  const payload = {<br/>    name,<br/>    number,<br/>  }<br/>  try {<br/>    const res = await axios.post(url, payload, header);<br/>    return res.data;</span><span id="9972" class="mv le jb nu b gy od nz l oa ob">} catch (e) {<br/>    console.error(e);<br/>  }<br/>};</span></pre><p id="e0d0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们创建一个从数据库中获取所有电话号码的函数。我们在同一个文件中创建它:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="c7ca" class="mv le jb nu b gy ny nz l oa ob">// services/phonebookServices.js</span><span id="8006" class="mv le jb nu b gy od nz l oa ob">... </span><span id="9878" class="mv le jb nu b gy od nz l oa ob">export const getPhonebookEntries = async () =&gt; {<br/>  const header = await createToken();</span><span id="4d52" class="mv le jb nu b gy od nz l oa ob">try {<br/>    const res = await axios.get(url, header);<br/>    return res.data;<br/>  } catch (e) {<br/>    console.error(e);<br/>  }<br/>}</span></pre><p id="b171" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们再次使用axios。这一次，我们将向后端发送一个GET请求。这将查询所有电话簿条目的后端。让我们回到后端。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="a97b" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">从后端到前端</h1><p id="303b" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">回顾我们的申请流程</p><ul class=""><li id="11d4" class="mb mc jb ka b kb kc kf kg kj ok kn ol kr om kv mi mj mk ml bi translated">前端将向我们的根路由发送一个GET请求，查询所有条目</li><li id="6a02" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">后端将接收请求，并从数据库中提取</li><li id="31fc" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">前端将向我们的根路由发送一个POST请求，添加一个条目</li><li id="ddd1" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">后端将接收请求，并添加到数据库</li></ul><p id="04af" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以跨越两步，这样就把步骤缩小到:</p><ul class=""><li id="3cfc" class="mb mc jb ka b kb kc kf kg kj ok kn ol kr om kv mi mj mk ml bi translated">后端将接收请求，并从数据库中提取</li><li id="d8c8" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">后端将接收请求，并添加到数据库</li></ul><p id="51b0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在我们实际获取和发送到数据库之前，我们应该验证用户。认证令牌包含在请求中。这意味着我们可以创建一个中间件，它将通过管道进入请求并对其稍作修改。我们将修改它，以便一旦请求到达我们的控制器和路由，我们能够在请求中找到经过验证的用户。</p><h2 id="8cfe" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated">创建firebase中间件</h2><p id="8d0e" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">因为我们使用Firebase作为我们的身份验证提供者，所以我们需要安装Firebase后端模块。这将允许我们用Firebase验证身份验证令牌。让我们安装它:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="662c" class="mv le jb nu b gy ny nz l oa ob">/phonebook-backend $ npm install firebase-admin</span></pre><p id="bb0e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要生成一个谷歌服务帐户私钥文件。按照在<a class="ae mm" href="https://firebase.google.com/docs/admin/setup" rel="noopener ugc nofollow" target="_blank">https://firebase.google.com/docs/admin/setup</a>的指示</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi pe"><img src="../Images/5f0b5455d36f03aaca1f89767bd11d04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*80KAoPp0gycwM2_2BRCt5g.png"/></div></figure><p id="04a4" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们需要前往<a class="ae mm" href="https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk" rel="noopener ugc nofollow" target="_blank">https://console . firebase . Google . com/project/_/settings/service accounts/adminsdk</a>来创建它。也从Google的配置示例中复制url</p><p id="cef0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一旦你下载了JSON文件，把它添加到我们后端的根目录。你也应该把它的名字改成更简单的名字。我调用了mine serviceAccount.json，这是将配置放入它自己的环境变量的好时机。如果你愿意，请随意。</p><p id="a055" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们创建一个新文件— authenticateToken.js，并将其放在根目录中。我们将在这里编写中间件:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="5e25" class="mv le jb nu b gy ny nz l oa ob">// authenticateToken.js</span><span id="d1c5" class="mv le jb nu b gy od nz l oa ob">const admin = require('firebase-admin');<br/>const serviceAccount require('./serviceAccount.json');</span><span id="c746" class="mv le jb nu b gy od nz l oa ob">admin.initializeApp({<br/>  credential: admin.credential.cert(serviceAccount),<br/>  databaseURL: '<a class="ae mm" href="https://phone-book-fe436.firebaseio.com'" rel="noopener ugc nofollow" target="_blank">https://phone-book-fe436.firebaseio.com'</a>,<br/>});</span><span id="6302" class="mv le jb nu b gy od nz l oa ob">async function decodeIDToken(req, res, next) {<br/>  const header = req.headers?.authorization;<br/>  if (header !== 'Bearer null' &amp;&amp; req.headers?.authorization?.startsWith('Bearer ')) {</span><span id="077e" class="mv le jb nu b gy od nz l oa ob">const idToken = req.headers.authorization.split('Bearer ')[1];</span><span id="6adf" class="mv le jb nu b gy od nz l oa ob">try {<br/>      const decodedToken = await admin.auth().verifyIdToken(idToken);<br/>      req['currentUser'] = decodedToken;<br/>    } catch (err) {<br/>      console.log(err);<br/>    }<br/>  }</span><span id="0645" class="mv le jb nu b gy od nz l oa ob">next();<br/>}</span><span id="4426" class="mv le jb nu b gy od nz l oa ob">module.exports = decodeIDToken;</span></pre><p id="147c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们导入带有Firebase配置的JSON文件，并使用它在后端初始化Firebase。我们创建了一个函数——decodeIDToken，它检查传入的请求是否有承载令牌。如果令牌存在，我们将其发送到Firebase进行验证。如果被验证，我们把它放到请求中。这样，我们的航线就可以使用它了。</p><p id="5d6c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们还需要将它添加到我们的index.js中:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="2314" class="mv le jb nu b gy ny nz l oa ob">// index.js</span><span id="6c25" class="mv le jb nu b gy od nz l oa ob">... </span><span id="a185" class="mv le jb nu b gy od nz l oa ob">const decodeIDToken = require('./authenticateToken');</span><span id="4b7b" class="mv le jb nu b gy od nz l oa ob">...</span><span id="674d" class="mv le jb nu b gy od nz l oa ob">app.use(decodeIDToken);</span><span id="ded2" class="mv le jb nu b gy od nz l oa ob">...</span></pre><p id="38c6" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们现在能够对每个传入的请求进行身份验证:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="7536" class="mv le jb nu b gy ny nz l oa ob">// controllers/phones.js</span><span id="c718" class="mv le jb nu b gy od nz l oa ob">... </span><span id="7258" class="mv le jb nu b gy od nz l oa ob">phonesRouter.post('/', (req, res) =&gt; {<br/>  const auth = req.currentUser;<br/>  if (auth) {<br/>    console.log('authenticated!', auth);<br/>    return res.send('Hi, from within the phones router POST');<br/>  }<br/>  return res.status(403).send('Not authorized')<br/>});<br/></span></pre><p id="f6a2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们能够直接从请求中获取经过身份验证的用户。如果存在，我们将用户打印到控制台:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi pf"><img src="../Images/ffd3bb706aec254e24cbe994a2cbc166.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fn5OZAPKw7oMd5osZbAz6w.png"/></div></div></figure><h2 id="3010" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated"><strong class="ak">创建电话簿</strong></h2><p id="a469" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们终于可以真正开始使用猫鼬了。我们将使用mongoose创建一个新的电话簿模型。在我们空空的手机里:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="dc6d" class="mv le jb nu b gy ny nz l oa ob">// models/phone.js</span><span id="2caa" class="mv le jb nu b gy od nz l oa ob">const mongoose = require('mongoose');</span><span id="1511" class="mv le jb nu b gy od nz l oa ob">const phoneSchema = new mongoose.Schema({<br/>  name: String,<br/>  number: String,<br/>});</span><span id="e9f2" class="mv le jb nu b gy od nz l oa ob">phoneSchema.set('toJSON', {<br/>  transform: (doc, returnedObject) =&gt; {<br/>    returnedObject.id = returnedObject._id.toString();<br/>    delete returnedObject._id;<br/>    delete returnedObject.__v;<br/>  },<br/>});</span><span id="3c51" class="mv le jb nu b gy od nz l oa ob">module.exports = mongoose.model('Phone', phoneSchema);</span></pre><p id="f8d1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们创建数据库模式。这里，我们的两个字段都是字符串。就像我们前院的田地。接下来，我们确保从数据库返回的对象包含字符串形式的id。最初，它是作为一个对象出现的。</p><p id="1a07" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这就是我们的模型。我们现在能够发布到数据库。</p><h2 id="6944" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated">将条目过帐到数据库</h2><p id="1968" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">为了能够从前端正确管理有效负载，我们需要向我们的应用程序添加一个内置的中间件。添加到index.js:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="a3dd" class="mv le jb nu b gy ny nz l oa ob">app.use(express.json());</span></pre><p id="38fa" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将对我们的发布路线进行一些更改:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="29eb" class="mv le jb nu b gy ny nz l oa ob">// controllers/phones.js</span><span id="7b4f" class="mv le jb nu b gy od nz l oa ob">...</span><span id="0a47" class="mv le jb nu b gy od nz l oa ob">const Phone = require('../models/phone');</span><span id="f48b" class="mv le jb nu b gy od nz l oa ob">...</span><span id="92f2" class="mv le jb nu b gy od nz l oa ob">phonesRouter.post('/', (req, res) =&gt; {<br/>  const auth = req.currentUser;<br/>  if (auth) {<br/>    const phone = new Phone(req.body);<br/>    const savedPhone = phone.save();</span><span id="c67e" class="mv le jb nu b gy od nz l oa ob">return res.status(201).json(savedPhone);<br/>  }<br/>  return res.status(403).send('Not authorized');<br/>});</span></pre><p id="ec93" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们验证请求，从我们的模型创建一个新的电话对象并保存它。</p><p id="9447" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们看一下我们的MongoDB集合:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi pg"><img src="../Images/d1ac9b53a822dc80f15c857ac694b9ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*AsO-QrU4i5yiXd5A3LqdyQ.png"/></div></figure><p id="6695" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">有救了！</p><p id="192c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">趁我们进展顺利，我们来编一条路。</p><h2 id="ad3d" class="mv le jb bd lf mw mx dn lj my mz dp ln kj na nb lr kn nc nd lv kr ne nf lz ng bi translated">从数据库中获取条目</h2><p id="f0c0" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">我们编码了我们的获取路线:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="339f" class="mv le jb nu b gy ny nz l oa ob">// controllers/phones.js</span><span id="225d" class="mv le jb nu b gy od nz l oa ob">...</span><span id="ed48" class="mv le jb nu b gy od nz l oa ob">phonesRouter.get('/', async (req, res) =&gt; {<br/>  const auth = req.currentUser;<br/>  if (auth) {<br/>    const phones = await Phone.find({});<br/>    return res.json(phones.map((phone) =&gt; phone.toJSON()));<br/>  }<br/>  return res.status(403).send('Not authorized');<br/>});</span><span id="11cf" class="mv le jb nu b gy od nz l oa ob">...</span></pre><p id="17e1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">猫鼬让我们很容易。通过传入一个空对象，我们查询集合中的所有文档。然后，我们将对每个对象进行循环，应用我们在模型文件中所做的更改。这将删除__v字段，并修复id。之后我们将它返回前端。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="c101" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">在前端显示数据</h1><p id="13b4" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">如果我们再看一下我们的步骤:</p><ul class=""><li id="9043" class="mb mc jb ka b kb kc kf kg kj ok kn ol kr om kv mi mj mk ml bi translated">后端将接收请求，并从数据库中提取</li><li id="b2c6" class="mb mc jb ka b kb mn kf mo kj mp kn mq kr mr kv mi mj mk ml bi translated">后端将接收请求，并添加到数据库</li></ul><p id="2386" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们确实在从数据库中提取数据。我们也在增加数据库。这意味着我们正在接近我们的最终目标。现在，让我们弄清楚如何在前端列出所有条目</p><p id="c4b1" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们的服务文件正在返回接收到的数据。让我们从ListAllNumbers组件中调用getPhonebookEntries()。完整的ListAllNumbers组件将如下所示:</p><pre class="ni nj nk nl gt nt nu nv nw aw nx bi"><span id="c762" class="mv le jb nu b gy ny nz l oa ob">// components/phonebook/ListAllNumbers.jsx</span><span id="cce0" class="mv le jb nu b gy od nz l oa ob">import React, { useState, useEffect } from 'react';<br/>import { Link } from 'react-router-dom';<br/>import { getPhonebookEntries } from '../../services/phonebookServices';</span><span id="8cec" class="mv le jb nu b gy od nz l oa ob">const ListAllNumbers = () =&gt; {<br/>  const [entries, setEntries] = useState();</span><span id="47f6" class="mv le jb nu b gy od nz l oa ob">useEffect(() =&gt; {<br/>    const fetchEntries = async () =&gt; {<br/>      const fetchedEntries = await getPhonebookEntries();<br/>      setEntries(fetchedEntries);<br/>    }<br/>    fetchEntries();<br/>  }, [])</span><span id="335a" class="mv le jb nu b gy od nz l oa ob">if (entries === undefined) {<br/>    return null;<br/>  }</span><span id="e2a2" class="mv le jb nu b gy od nz l oa ob">return (<br/>    &lt;div&gt;<br/>      &lt;Link to="/add-number"&gt;Add number&lt;/Link&gt;<br/>      &lt;h2&gt;Phone numbers&lt;/h2&gt;<br/>      <br/>      &lt;table&gt;<br/>        &lt;thead&gt;<br/>          &lt;tr&gt;<br/>            &lt;th&gt;Name&lt;/th&gt;<br/>            &lt;th&gt;Number&lt;/th&gt;<br/>          &lt;/tr&gt;<br/>        &lt;/thead&gt;<br/>        &lt;tbody&gt;<br/>          {entries.map((entry) =&gt; (<br/>          &lt;tr&gt;<br/>            &lt;td&gt;{entry.name}&lt;/td&gt;<br/>            &lt;td&gt;{entry.number}&lt;/td&gt;<br/>          &lt;/tr&gt;<br/>          ))}<br/>        &lt;/tbody&gt;<br/>      &lt;/table&gt;<br/>    &lt;/div&gt;<br/>  ) <br/>};</span><span id="0e9b" class="mv le jb nu b gy od nz l oa ob">export default ListAllNumbers;</span></pre><p id="e0bb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们建立了一个州来保存我们的参赛作品。我们通过使用useEffect钩子中的服务来查询数据库。在模板内部，我们用一个map函数循环遍历条目，并显示每个条目。</p><blockquote class="ow ox oy"><p id="8dfe" class="jy jz oz ka b kb kc kd ke kf kg kh ki pa kk kl km pb ko kp kq pc ks kt ku kv ij bi translated">从React文档中:</p><p id="5e54" class="jy jz oz ka b kb kc kd ke kf kg kh ki pa kk kl km pb ko kp kq pc ks kt ku kv ij bi translated"><strong class="ka jc"/><code class="fe ph pi pj nu b"><strong class="ka jc">useEffect</strong></code><strong class="ka jc">是做什么的？</strong>通过使用这个钩子，你告诉React你的组件需要在渲染后做一些事情。React将记住您传递的函数(我们称之为“效果”)，并在执行DOM更新后调用它。在这种情况下，我们设置了文档标题，但是我们也可以执行数据获取或者调用其他一些命令式API。</p></blockquote><p id="7927" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们从后端接收数据，并将其设置为状态。因为查询数据库是异步操作，所以我们检查条目是否存在。如果没有，我们返回null。一旦数据从后端返回，条目将自动填充，我们的数据将会出现。</p><p id="4b70" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果我们尝试添加另一个条目，并返回到我们的电话簿:</p><figure class="ni nj nk nl gt is gh gi paragraph-image"><div class="gh gi pk"><img src="../Images/06f66656a00de6960532cb52bc20f0a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:394/format:webp/1*lFfCV0dQRJfIYmDyxWASNg.png"/></div></figure><p id="b395" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">一切都按照预期进行存储和提取。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="f8b9" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结束语</h1><p id="51c5" class="pw-post-body-paragraph jy jz jb ka b kb md kd ke kf me kh ki kj ms kl km kn mt kp kq kr mu kt ku kv ij bi translated">就像我之前说过的，Firebase并不总是适合这项工作的工具。然而，我们总是需要某种认证。Firebase为我们带来了一个真正的大礼包。</p><p id="8bac" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我希望你从这篇大文章中学到了一些东西。你可以在<a class="ae mm" href="https://github.com/Devalo/Firebase-auth-react-express-mongodb" rel="noopener ugc nofollow" target="_blank">https://github . com/Devalo/Firebase-auth-react-express-MongoDB</a>找到完整的源代码</p><p id="0df0" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">直到下次<br/>斯蒂芬·巴克伦德·瓦卢瓦</p></div></div>    
</body>
</html>