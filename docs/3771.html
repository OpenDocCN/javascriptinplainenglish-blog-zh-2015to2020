<html>
<head>
<title>9 Tips for Writing Scalable JavaScript Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写可伸缩JavaScript代码的9个技巧</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/9-tips-for-writing-scalable-javascript-code-e6bcfc791882?source=collection_archive---------1-----------------------#2020-10-24">https://javascript.plainenglish.io/9-tips-for-writing-scalable-javascript-code-e6bcfc791882?source=collection_archive---------1-----------------------#2020-10-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5a03" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">您应该从一开始就准备好扩展您的项目。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/02bd50108840b81689aef2e78d3a0bf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*h8WtWzROEHch8S0A"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="daec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在某个时候，你的项目会增长。我有一个好消息和一个坏消息告诉你。</p><p id="72d8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">坏消息是你的代码库可能会失去控制，所以你最终会把它扔进篮子里，然后从头开始。你希望这次你能做得更好。除非你保持同样的心态。</p><p id="7bff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">幸运的是，好消息是你可以通过使用我下面要分享的技巧来编写可伸缩的代码来避免坏消息。继续读。</p><h1 id="2a2e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">1.使用设计模式</h1><p id="a103" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">如果你想以可重用的方式解决编码问题，你需要在设计模式上花时间。</p><p id="ffb3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">设计模式就像是解决编码中常见问题的模板。这是一个行之有效的解决方案，你不需要浪费时间去重新发明轮子。</p><p id="8178" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">试着掌握它，你会发现作为一名开发人员，你的生活是多么容易。</p><div class="mp mq gp gr mr ms"><a href="https://medium.com/javascript-in-plain-english/7-javascript-design-patterns-every-developer-should-know-df9c40e7debf" rel="noopener follow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">每个开发人员都应该知道的7个JavaScript设计模式</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">如果你能把你的源代码组织成一个漂亮的模板，可以应用到相同的每个项目中，那会怎么样</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">medium.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng kp ms"/></div></div></a></div><h1 id="c276" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">2.分离您的代码</h1><p id="dc21" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">不要在一个地方混合所有类型的代码。例如，您应该将它们分为逻辑、视图和数据。你可以使用一些类似MVC的架构来装饰你的代码库。分开的代码总是比乱七八糟的更可控。</p><p id="b14b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你写函数的时候，同样的心态也应该适用。长话短说，不要把一堆东西放到一个函数里。永远记住一个功能一个使命。</p><h1 id="147a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">3.构建模块</h1><p id="bd5a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这类似于分离你的代码，但是在不同的层次上。</p><p id="2376" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">模块是将相关代码分组的地方。例如，所有旨在处理授权的功能都应该放在一个单独的模块中。我们称之为授权模块。</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="4d87" class="nm lt iq ni b gy nn no l np nq">function validate(username, password) {<br/>  // validate data<br/>}</span><span id="9839" class="nm lt iq ni b gy nr no l np nq">function login(username, password) {<br/>  // login<br/>}</span><span id="d77a" class="nm lt iq ni b gy nr no l np nq">function logout() {<br/>  // logout<br/>}</span><span id="fa81" class="nm lt iq ni b gy nr no l np nq">module.exports = {<br/>  validate,<br/>  login,<br/>  logout<br/>}</span></pre><p id="991f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当您需要在其他地方使用它们时:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="70e2" class="nm lt iq ni b gy nn no l np nq">const { validate, login, logout } = require(‘./AuthorizationModule’)</span><span id="07f3" class="nm lt iq ni b gy nr no l np nq">validate(‘amy’, 123);<br/>login(‘amy’, 123);<br/>logout();</span></pre><p id="357a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样你就可以保持你的代码有条理。</p><h1 id="bae9" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">4.保持你的文件小，甚至很小</h1><p id="8f25" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我喜欢小文件。当我在这些文件中查找内容时，可以更容易、更快地找到我需要的内容。</p><p id="4e4d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在大文件中，任务变得复杂。我有时会处理那些大文件。它们有一万行代码，你能想象吗？这里面有一堆逻辑。这是一种痛苦。</p><p id="45e3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我倾向于把我的文件保持在500行左右。这是我的规则。如果它要增长超过那个阈值，我就把它分解成新的文件。用模块组织相关逻辑就是其中一种方式。</p><p id="952c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你能写这些小文件并保持它们的良好结构，你会为自己感到骄傲。</p><h1 id="2289" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">5.相比回调，更倾向于承诺和异步/等待</h1><p id="9beb" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">技术上来说，回调是有帮助的。然而，当它在多个嵌套层次(也称为回调地狱)中增长时，会给你带来很多麻烦。而且，很丑。为了可读性，您应该尽可能避免使用它。</p><p id="5bd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">请改用async/await。</p><p id="0e4e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">嵌套回调将打破自然的思维流程，而async/await仍然是流程。简单地说，async/await让我们能够编写看起来同步的异步代码。这就是async/await如何让代码更漂亮、可读性更好。</p><p id="4c3b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用回调示例:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="f313" class="nm lt iq ni b gy nn no l np nq">function getBook(bookId, callback) {<br/>  setTimeout(() =&gt; {<br/>    let book = {<br/>      title: ‘JavaScript’,<br/>      authorId: ‘123’<br/>    }<br/>  <br/>    callback(book);<br/>  }, 500);<br/>}</span><span id="675a" class="nm lt iq ni b gy nr no l np nq">function getAuthor(authorId, callback) {<br/>  setTimeout(() =&gt; {<br/>    let author = {<br/>      name: ‘Amy’,<br/>      age: 28<br/>    }</span><span id="2c7e" class="nm lt iq ni b gy nr no l np nq">    callback(author);<br/>  }, 500);<br/>}</span><span id="d13c" class="nm lt iq ni b gy nr no l np nq">function fetchData() {<br/>  // This will reach the hell level if having more callbacks. I keep it simple for example<br/> <br/>  getBook(2020, book =&gt; {<br/>    getAuthor(book.authorId, author =&gt; {<br/>      console.log(author);<br/>    })<br/>  });<br/>}</span><span id="998e" class="nm lt iq ni b gy nr no l np nq">fetchData(); // { name: ‘Amy’, age: 28 }</span></pre><p id="816b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们将删除回调:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="1335" class="nm lt iq ni b gy nn no l np nq">function getBook(bookId) {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      let book = {<br/>        title: ‘JavaScript’,<br/>        authorId: ‘123’<br/>      }<br/>    <br/>      resolve(book);<br/>    }, 500);<br/>  });<br/>}</span><span id="ec89" class="nm lt iq ni b gy nr no l np nq">function getAuthor(authorId) {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(() =&gt; {<br/>      let author = {<br/>        name: ‘Amy’,<br/>        age: 28<br/>      }</span><span id="d059" class="nm lt iq ni b gy nr no l np nq">      resolve(author);<br/>    }, 500);<br/>  });<br/>}</span><span id="b210" class="nm lt iq ni b gy nr no l np nq">async function fetchData() {<br/>  let book = await getBook(2020);<br/>  let author = await getAuthor(book.authorId);</span><span id="eaad" class="nm lt iq ni b gy nr no l np nq">  console.log(author)<br/>}</span><span id="7c3e" class="nm lt iq ni b gy nr no l np nq">fetchData(); // { name: ‘Amy’, age: 28 }</span></pre><p id="1198" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，看看函数<strong class="ky ir"> fetchData </strong>有多令人满意。</p><h1 id="4cc1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">6.解构</h1><p id="4ac7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">ES6配备了许多令人惊叹的功能。解构就是其中之一。</p><p id="c8b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该特性使您能够从对象中提取特定的字段，并根据需要将它们分配给变量。</p><p id="2fed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="e98f" class="nm lt iq ni b gy nn no l np nq">let person = {<br/>  name: ‘Amy’,<br/>  age: 28,<br/>  job: ‘Entrepreneur’<br/>};</span><span id="f2c3" class="nm lt iq ni b gy nr no l np nq">let { name, age, job } = person;<br/>console.log(name, age, job); // Amy 28 Entrepreneur</span></pre><p id="23b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当你使用析构时，你的代码可读性更好。你不必总是写一些像<strong class="ky ir">这样的东西。相反，你写一个简单的变量<strong class="ky ir">名</strong>。没有更多嵌套属性。你的同事会清楚地知道你在使用什么变量。</strong></p><div class="mp mq gp gr mr ms"><a href="https://medium.com/better-programming/5-ways-to-make-the-most-of-destructuring-in-javascript-to-write-cleaner-code-d674c00da9c7" rel="noopener follow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">充分利用JavaScript中析构的5种方法来编写更简洁的代码</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">析构是ES6最激动人心的特性之一</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">medium.com</p></div></div><div class="nb l"><div class="ns l nd ne nf nb ng kp ms"/></div></div></a></div><h1 id="dd68" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">7.初始化默认值</h1><p id="d900" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">当缺省值伴随着函数参数的析构时，这是一笔大买卖。</p><p id="1ee8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JavaScript中，很难看到一个参数就知道可以传递什么类型的数据。默认值会有所帮助，因为它们给出了可以传递给函数的数据示例。</p><p id="d537" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们经常检查一个论点是否被定义。如果您为它初始化了一个默认值，您就不需要再做那个任务了。</p><h1 id="93e4" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">8.使用更漂亮和ESLint来修饰你的代码</h1><p id="7d3f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">团队的每个成员都有自己的编码风格。为了保持项目的一致性并易于扩展，您和您的同事必须遵循一种风格。</p><p id="3273" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是埃斯林特和漂亮地跳进游戏的时候。</p><p id="95ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ESLint附带了限制编码风格的默认规则。然而，您也可以根据自己的需要编辑或定义您的规则。</p><p id="da1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">更漂亮地自动修饰你的代码，使之一致。您只需专注于编写高质量的代码，将格式化部分留给更漂亮的代码。</p><p id="ba52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当事情可以用工具自动完成时，就去做吧。把你有意义的时间花在更重要的任务上。</p><div class="mp mq gp gr mr ms"><a href="https://medium.com/javascript-in-plain-english/9-great-javascript-extensions-for-visual-studio-code-to-speed-up-your-development-8b3275248718" rel="noopener follow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">Visual Studio代码的9大JavaScript扩展加速您的开发</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">谁想更快更容易地编码？</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">medium.com</p></div></div><div class="nb l"><div class="nt l nd ne nf nb ng kp ms"/></div></div></a></div><h1 id="f74d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">9.定义多个参数，而不是一个对象参数</h1><p id="c5ff" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">说到编写函数，有两种类型的开发人员。</p><p id="f79b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="50a2" class="nm lt iq ni b gy nn no l np nq">function showProduct(name, price, description) {<br/>  console.log(name, price, description);<br/>}</span></pre><p id="7362" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第二个:</p><pre class="kg kh ki kj gt nh ni nj nk aw nl bi"><span id="5360" class="nm lt iq ni b gy nn no l np nq">function showProduct(product) {<br/>  console.log(product.name, product.price, product.description);<br/>}</span></pre><p id="27df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你是什么类型的？</p><p id="e2c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">乍一看，第二个似乎很方便，因为我们不需要写一长串参数。</p><p id="8952" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但事情是这样的:</p><p id="d99f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">第一个很简单。无需猜测，您就能准确地知道向函数传递什么。</p><p id="ae1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您将参数作为单个对象传递，有时您不知道对象内部的必要属性是否可用。</p><p id="0383" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，这一规则并不总是合适的。如果你定义了一个超过四个参数的函数，那么使用对象参数。运用你的常识。</p><h1 id="fdd1" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="dd18" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">编写可伸缩代码的话题永远不会过时。我们写的代码越多，我们的编码技能就提高得越多。</p><p id="abf1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">到目前为止，以上是我每天使用的保持代码库可伸缩性的技巧。希望你觉得有用。</p><p id="a8be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你有自己的建议吗？如果你能在下面的评论中分享它们，那就太好了。</p><p id="8ece" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kv" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir">订阅解码获得更多类似内容，我们的YouTube频道</strong> </a> <strong class="ky ir">！</strong></p></div><div class="ab cl nu nv hu nw" role="separator"><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz oa"/><span class="nx bw bk ny nz"/></div><div class="ij ik il im in"><h1 id="1f84" class="ls lt iq bd lu lv ob lx ly lz oc mb mc jw od jx me jz oe ka mg kc of kd mi mj bi translated">进一步阅读</h1><div class="mp mq gp gr mr ms"><a href="https://medium.com/javascript-in-plain-english/how-to-write-effective-javascript-code-that-every-programmer-loves-to-maintain-a490b42b9b9f" rel="noopener follow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd ir gy z fp mx fr fs my fu fw ip bi translated">如何编写每个程序员都喜欢维护的有效JavaScript代码</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">要不要写更易维护的代码？运用坚实的原则</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">medium.com</p></div></div><div class="nb l"><div class="og l nd ne nf nb ng kp ms"/></div></div></a></div></div></div>    
</body>
</html>