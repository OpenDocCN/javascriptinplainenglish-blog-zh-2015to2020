<html>
<head>
<title>Let’s Build a MongoDB + Express + React + GraphQL + Relay Modern Full Stack Web App (From Scratch!) — Back End Part</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">让我们构建一个MongoDB+Express+React+graph QL+Relay Modern全栈Web App(从零开始！)—后端部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lets-build-a-mongodb-express-react-graphql-relay-modern-full-stack-web-app-from-scratch-a4ae3aaf212?source=collection_archive---------1-----------------------#2020-01-23">https://javascript.plainenglish.io/lets-build-a-mongodb-express-react-graphql-relay-modern-full-stack-web-app-from-scratch-a4ae3aaf212?source=collection_archive---------1-----------------------#2020-01-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div class="gh gi jn"><img src="../Images/f9a0b8a0894f4922c372d7e490ecccb3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*RG2n787iuQVANYUwQrp3qw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">React x Relay x GraphQL</figcaption></figure><blockquote class="jy jz ka"><p id="57e6" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">嗨！你可以在下面的链接中找到本文的第二部分。</p><p id="771d" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><a class="ae la" href="https://medium.com/@jelorivera08/lets-build-a-mongodb-express-react-graphql-relay-modern-full-stack-web-app-from-scratch-d41b5091d41d" rel="noopener">本文第二部分。使用React和Relay配置前端。</a></p></blockquote><p id="b78d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">自从我上一篇关于web应用堆栈的文章以来，我收集了一些有趣的东西，我想与你们分享。我们将创建一个包含上述所有技术的基本notes web应用程序。CRUD，cloud mongoDB，React前端，中继现代状态管理(奖金更新教程)，graphQL查询和突变。</p><p id="e76c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">作为一名软件工程师，我一直在努力寻找将这些技术的基本应用融入到一个真实应用中的文章。这就是我发表这篇文章的原因。我们将从头开始构建这个应用程序，所以准备好你的编码手指。(给你一个建议，我会在文章的最后发布这个web应用程序的最终git repo，这样你就可以一步一步地跟着我了。这将有助于你牢牢掌握这些技术提出的理论/想法。</p><p id="d2d8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在本文中，我们将使用大型科技公司目前正在使用的最新、最顶尖的技术。本文要求您至少具备React、Javascript、Relay和graphQL的基础知识。如果你有这些基本技能，让我们开始构建并开始编码吧！<a class="ae la" href="https://emojipedia.org/man-technologist/" rel="noopener ugc nofollow" target="_blank">👨‍💻</a> <a class="ae la" href="https://emojipedia.org/woman-technologist/" rel="noopener ugc nofollow" target="_blank">👩‍💻</a></p><blockquote class="jy jz ka"><p id="f548" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我使用Heroku部署了web应用程序的最终版本。加载web app时请耐心等待。当网站闲置一段时间后，Heroku会启动服务器。和平！:-)</p></blockquote><h1 id="4a33" class="le lf iq bd lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb bi translated">加快我们的后端</h1><p id="5b61" class="pw-post-body-paragraph kb kc iq ke b kf mc kh ki kj md kl km lb me kp kq lc mf kt ku ld mg kx ky kz ij bi translated">先说我们的GraphQL + Express + MongoDB服务器栈。打开终端，让我们为我们的项目创建一个目录。让我们将其命名为full-stack-app，并创建我们的服务器目录。让我们初始化我们的服务器目录并安装下面的库。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="7d11" class="mq lf iq mm b gy mr ms l mt mu">mkdir full-stack-app<br/>cd full-stack-app<br/>mkdir server<br/>cd server<br/>mkdir src<br/>touch src/index.js<br/>npm init -y <br/>npm install express express-graphql cors graphql mongodb</span></pre><p id="fb5d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">请注意，我们已经创建了src根目录和index.js。在那里，我们将初始化我们的服务器，因此继续在src/index.js中键入下面的代码</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">backend — src/index.js</figcaption></figure><p id="6e68" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">当您运行<code class="fe mx my mz mm b">node <em class="kd">./src/index.js</em></code> <em class="kd"> </em>时，服务器应该启动并运行。</p><p id="7de8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在，让我们配置我们的MongoDB数据库。我们将使用MongoDB在云中存储我们的数据。登陆他们的<a class="ae la" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank">网站</a>，创建你自己的账户。别担心，这是免费的。注册并登录后。遵循这些步骤。我们将创建自己的空闲集群，并将其链接到我们刚刚创建的节点服务器。</p><ol class=""><li id="634d" class="na nb iq ke b kf kg kj kk lb nc lc nd ld ne kz nf ng nh ni bi translated">从选项中选择<em class="kd">创建自由集群</em>。</li><li id="1981" class="na nb iq ke b kf nj kj nk lb nl lc nm ld nn kz nf ng nh ni bi translated">通过选择您喜欢的数据库区域等来设置您的空闲集群。</li><li id="e305" class="na nb iq ke b kf nj kj nk lb nl lc nm ld nn kz nf ng nh ni bi translated">MongoDB Atlas将指导您遵循他们的教程，之后我们将把我们的集群连接到我们的节点服务器。</li></ol><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="91bd" class="mq lf iq mm b gy mr ms l mt mu">Atlas tutorial will tell you to:</span><span id="cf45" class="mq lf iq mm b gy no ms l mt mu">    3.a. Build your own cluster  - done :-)<br/>    3.b. Create your own database user<br/>    3.c. Whitelist your own IP address<br/>    3.d. Load Sample Data (optional)<br/>    3.e. Connect to your cluster</span></pre><p id="58ab" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在集群的连接选项中，选择“连接您的应用程序”选项，并复制显示的连接字符串。我们将在下一步中需要它。</p><p id="ae22" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在，让我们回到节点服务器代码，在src目录中创建一个名为config的目录。在我们的配置目录中，创建一个名为databaseConnection.js的文件，并在其中编写下面的代码。将我们之前复制的字符串粘贴到uri变量中，并将db用户凭证更改为您的凭证。</p><figure class="mh mi mj mk gt jr"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="8dbb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在我们必须在index.js内部调用它。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="9ed9" class="mq lf iq mm b gy mr ms l mt mu">src/index.js<br/>...</span><span id="9419" class="mq lf iq mm b gy no ms l mt mu">const graphqlHTTP = require('express-graphql');<br/>const { setupDB } = require('./config/databaseConnection')</span><span id="fc3a" class="mq lf iq mm b gy no ms l mt mu">setupDB(<em class="kd">v</em> =&gt; console.log(v));</span><span id="d3bb" class="mq lf iq mm b gy no ms l mt mu">const schema = {<br/><em class="kd">// we will add this later<br/></em>};</span><span id="0e13" class="mq lf iq mm b gy no ms l mt mu">...</span></pre><p id="c501" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">再次运行<code class="fe mx my mz mm b">node .src/index.js </code>，我们应该看到我们的数据库成功连接。</p><p id="9604" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在，关于GraphQL部分的事情。在我们的src目录中创建一个graphql目录，并按照下面的文件夹结构对其进行造型。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi np"><img src="../Images/829605dde2d4310d78ccaa50651734bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*3d68uWQIcnW09MOJz8NCDg.png"/></div></figure><p id="7ef9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">将下面的要点编码到它们各自的文件中，我将在下面讨论重要的部分。</p><ul class=""><li id="d958" class="na nb iq ke b kf kg kj kk lb nc lc nd ld ne kz nq ng nh ni bi translated"><a class="ae la" href="https://gist.github.com/jelorivera08/0becf53746a93aedb612a1c3309d9539" rel="noopener ugc nofollow" target="_blank"> NotesMutation.js </a></li><li id="f380" class="na nb iq ke b kf nj kj nk lb nl lc nm ld nn kz nq ng nh ni bi translated"><a class="ae la" href="https://gist.github.com/jelorivera08/cdef9b47a2cc9c06cf43be305135f62b" rel="noopener ugc nofollow" target="_blank"> nodeTypes.js </a></li><li id="9f13" class="na nb iq ke b kf nj kj nk lb nl lc nm ld nn kz nq ng nh ni bi translated"><a class="ae la" href="https://gist.github.com/jelorivera08/6a9931e02fefce907a577785f70a7d42" rel="noopener ugc nofollow" target="_blank"> NotesQuery.js </a></li><li id="c897" class="na nb iq ke b kf nj kj nk lb nl lc nm ld nn kz nq ng nh ni bi translated"><a class="ae la" href="https://gist.github.com/jelorivera08/f2688be46c68e4e6e8162427fe79879e" rel="noopener ugc nofollow" target="_blank"> schema.js </a></li></ul><p id="713e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">从<em class="kd"> schema.js开始，然后是nodeTypes.js，然后是NotesQuery.js，最后是notesumtation . js</em></p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nr"><img src="../Images/a103329a242b17503cd51d7452068fef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5cV8P_DjKeQ2K54AzJAGDw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">schema.js</figcaption></figure><p id="1787" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这里我们定义了我们的graphql根模式、查询和变异。这些就像解析数据库查询和其他服务器相关任务的api路由。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi nw"><img src="../Images/28a325acb336b2aabe9206789998a613.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/1*m21N3j83ataQZcb9kYBbjA.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">nodeTypes.js</figcaption></figure><p id="e0d1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这里我们创建了自己的graphql对象数据类型。我们有一个注释类型，它有自己的_id和内容字段。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi nx"><img src="../Images/9149e36fcca6df733847a0c23dd05ccf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oVDe-Vz17gnSadnnRDMmXw.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">NotesQuery.js</figcaption></figure><p id="766c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这是我们的账单。一旦我们开始创建它们，这将返回存储在我们数据库中的所有“注释”。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi ny"><img src="../Images/c66934ab2d1db1173ae56dc5a1b7e115.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8y8-6jq3k-Ui8yEhxcacqg.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">NotesMutation.js</figcaption></figure><p id="ef4d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这是我们notes变异的一个例子。一旦我们调用这个突变查询，这将使我们能够创建一个注释。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="f201" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在这些都是一口气要做的很多，所以慢慢来，阅读并理解背后的代码和想法。您可能想知道NoteService的东西是从哪里来的。它只是我创建的一个服务类，用来抽象我们的mongodb存储库查询。我们一会儿就会谈到这一点。</p><p id="120b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们现在处于服务器设置的最后阶段。我们只需将我们的mongodb存储库与我们的graphql查询链接起来。为此，创建一个如下所示的文件夹结构。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div class="gh gi og"><img src="../Images/df457db4dcc4d73976074c8e186c9598.png" data-original-src="https://miro.medium.com/v2/resize:fit:848/format:webp/1*VYmedDVyhbQZCYkP_2sJGw.png"/></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">services and repository</figcaption></figure><p id="6e8c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">就像我们不久前所做的那样，将下面的要点编码到它们各自的js文件中，我会边走边解释它们。</p><ul class=""><li id="5ba4" class="na nb iq ke b kf kg kj kk lb nc lc nd ld ne kz nq ng nh ni bi translated"><a class="ae la" href="https://gist.github.com/jelorivera08/0676b10a9de26ce137c5ee2e93746ec8" rel="noopener ugc nofollow" target="_blank"> mongoDbRepository.js </a></li><li id="f405" class="na nb iq ke b kf nj kj nk lb nl lc nm ld nn kz nq ng nh ni bi translated"><a class="ae la" href="https://gist.github.com/jelorivera08/90b88184430f4a9ee781b56906b39426" rel="noopener ugc nofollow" target="_blank">notes service . js</a></li></ul><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oh"><img src="../Images/7cd701eb7f71674b8993b17f4b0ac196.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*icEZRWyagUfnqui3R4ioUQ.png"/></div></div><figcaption class="ju jv gj gh gi jw jx bd b be z dk">MongoDbRepo class</figcaption></figure><p id="1fab" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在这个MongoDbRepo类中，我们只是连接到我们的MongoDB数据库，我们公开了一些API，让我们可以对我们的数据库条目进行CRUD操作。</p><figure class="mh mi mj mk gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="ns nt di nu bf nv"><div class="gh gi oi"><img src="../Images/6f3349dafb2db372273b89398ab810fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xjphks5iNl0cuyw1LQoaWw.png"/></div></div></figure><p id="ada3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这里，我们使用MongoDbRepo类来实例化一个链接到“notes”数据库的存储库，我们在其中保存所有的“Notes”条目。请注意，这只是为了更好地扩展我们的代码，以及更好地抽象我们的数据。</p></div><div class="ab cl nz oa hu ob" role="separator"><span class="oc bw bk od oe of"/><span class="oc bw bk od oe of"/><span class="oc bw bk od oe"/></div><div class="ij ik il im in"><p id="64e7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">唷！快好了！</p><p id="1d0a" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在让我们修改src/index.js代码，以便将graphql模式链接到我们的express服务器。将src/index.js代码更改如下。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="b4ff" class="mq lf iq mm b gy mr ms l mt mu">const express = require('express');<br/>const graphqlHTTP = require('express-graphql');<br/>const schema = require('./graphql/schema');<br/>const { setupDB } = require('./config/databaseConnection');<br/>const cors = require('cors');</span><span id="8d03" class="mq lf iq mm b gy no ms l mt mu">const app = express();<br/>setupDB(<em class="kd">v</em> =&gt; console.log(v));</span><span id="526d" class="mq lf iq mm b gy no ms l mt mu">app.use(cors());<br/>app.use(<br/>    '/graphql',<br/>    graphqlHTTP({<br/>        schema,<br/>        graphiql: true,<br/>        pretty: true<br/>    })<br/>);</span><span id="a675" class="mq lf iq mm b gy no ms l mt mu">app.listen(4000);<br/>console.log('SERVER OK');</span></pre><p id="8864" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">搞定了。现在，让我们在浏览器中尝试我们的graphql服务器，看看这个宝贝是如何骑行的！将下面的url粘贴到浏览器中，查看我们新构建的graphql服务器。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="2700" class="mq lf iq mm b gy mr ms l mt mu"><a class="ae la" href="http://localhost:4000/graphql" rel="noopener ugc nofollow" target="_blank">http://localhost:4000/graphql</a></span></pre><p id="bd2e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">尝试用这个突变查询创建一个注释。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="e019" class="mq lf iq mm b gy mr ms l mt mu">mutation {<br/> createNote(content:"test") {<br/>    content<br/>    _id<br/>  }<br/>}</span></pre><p id="d1cd" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">然后，为了查看我们的查询是否有效，让我们使用下面的查询来查询服务器中所有可用的notes。</p><pre class="mh mi mj mk gt ml mm mn mo aw mp bi"><span id="6a2f" class="mq lf iq mm b gy mr ms l mt mu">query {<br/>  notes {<br/>    _id<br/>    content<br/>  }<br/>}</span></pre><p id="b24b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">耶！现在我们已经设置好了我们的后端，我们现在应该继续使用React+Relay modem创建我们的前端。我将在本文的第二部分解决这个问题。我想把它放在这篇文章里，但我认为它会使这篇文章过于饱和，所以我认为最好把它放在单独的一篇文章里。</p><p id="3cd7" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">如果你能走到这一步，恭喜你！给自己一个鼓励，花点时间吸收这些新图书馆试图传达的思想。这些技术赋予开发人员的思维定势才是真正让我们能够为最终用户和开发人员构建使人类生活更轻松的东西。</p><blockquote class="oj"><p id="fc45" class="ok ol iq bd om on oo op oq or os kz dk translated"><a class="ae la" href="https://github.com/jelorivera08/MERG-BE" rel="noopener ugc nofollow" target="_blank">如约而至。</a></p></blockquote></div></div>    
</body>
</html>