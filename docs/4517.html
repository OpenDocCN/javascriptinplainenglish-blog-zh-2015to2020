<html>
<head>
<title>How To Set Up Mongoose With Express.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Express.js设置Mongoose</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-set-up-mongoose-with-expressjs-da2cc34c9219?source=collection_archive---------7-----------------------#2020-12-17">https://javascript.plainenglish.io/how-to-set-up-mongoose-with-expressjs-da2cc34c9219?source=collection_archive---------7-----------------------#2020-12-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/9851619ae2d4a3ab11a0761b028343c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ETD8F28vnid0ngvd.jpg"/></div></div></figure><p id="19ca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在上一篇文章中，我演示了如何在您的express项目中设置Nunjucks模板引擎。我决定通过逐步构建示例应用程序，使这成为一个成熟的web应用程序开发系列文章。在本文中，我们将使用Mongoose将应用程序连接到MongoDB数据库。</p><p id="f13a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Mongoose是一个ODM(对象文档映射器),允许使用JavaScript对象与MongoDB数据库进行交互。</p><p id="8896" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">它提供了额外的功能(比如模式上的静态方法),允许我们增强数据库交互并编写更简洁的代码。</p><p id="0e63" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在撰写本文时，Mongoose的最新稳定版本是v5.11.8。虽然这里的大部分信息应该仍然是相关的，但在阅读时很可能会有所不同。</p><p id="e716" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在继续之前，确保您的系统上已经安装并运行了MongoDB服务器。如果没有，你可以<a class="ae kt" href="https://www.mongodb.com/cloud/atlas" rel="noopener ugc nofollow" target="_blank">在MongoDB Atlas注册一个免费集群</a>并连接到那里。</p><h1 id="d495" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">猫鼬装置</h1><p id="dca8" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">首先使用以下命令安装Mongoose和dotenv:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2e4d" class="mg kv in mc b gy mh mi l mj mk">npm install mongoose dotenv</span></pre><p id="5918" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">Dotenv允许我们将环境变量加载到应用程序中。我们将把MongoDB URI放在一个环境变量文件中，而不是硬编码它。</p><p id="2190" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这样做允许我们通过只改变环境变量中的URI而不改变代码本身来连接到不同环境中的不同MongoDB实例。</p><p id="f9b8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">创建一个名为。env”放在项目的根目录下。文件的内容应该如下:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ac8b" class="mg kv in mc b gy mh mi l mj mk">PORT=8000 MONGO_URI=mongodb://localhost:27017/app</span></pre><p id="f331" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们在这里定义了端口和MongoDB URI。确保根据您的设置更改这些值。</p><p id="beae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在回到index.js文件(或者初始化应用程序实例的文件),在文件的开头添加下面一行:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="8e35" class="mg kv in mc b gy mh mi l mj mk">if (process.env.ENV === 'dev') require('dotenv').config()</span></pre><p id="b927" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这将加载。如果我们在开发环境中，请在我们的项目中使用env文件。我们可以使用“process.env. <variable_name>”来访问每个环境变量。</variable_name></p><p id="71fa" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">dotenv包将查找。调用config方法时项目中的env文件。</p><p id="b710" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将它放在入口点文件的顶部，可以确保当我们决定采用模块化方法来组织路由时，环境变量对于整个应用程序都是可用的。</p><p id="6659" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在导入猫鼬:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="bd75" class="mg kv in mc b gy mh mi l mj mk">const mongoose = require('mongoose')</span></pre><p id="6021" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过在路由定义前插入以下代码来创建一个mongoose连接:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="968e" class="mg kv in mc b gy mh mi l mj mk">const connection = mongoose.connect(process.env.MONGO_URI, {<br/>  useNewUrlParser: true,<br/>  useUnifiedTopology: true<br/>})</span><span id="af99" class="mg kv in mc b gy ml mi l mj mk">/* Display message in the console if the connection is successful. */<br/>mongoose.connection.once('open', () =&gt; {<br/>  console.log('connected!')<br/>})</span></pre><h1 id="1286" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">模型</h1><p id="5f1b" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">我们的猫鼬连接已经建立。下一步是定义我们的模型。模型是将驻留在我们数据库中的文档的对象表示。</p><p id="81d9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">mongoose中的模型需要一个模式。模式指定了文档的结构。</p><p id="6e1f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果您熟悉NoSQL数据库，尤其是MongoDB，您可能会意识到其中一个好处是模式是动态的。这意味着您可以在创建/更新时动态地向文档添加新字段。</p><p id="a8f4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">根据您的用例，这可能是一个好主意，但是mongoose需要模式来定义集合中文档的形状。这确保了集合的一致性以及每个文档中包含哪些属性的参考点。</p><p id="a371" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们通过在项目的根目录下创建一个名为“model”的文件夹来开始设置我们的模型。接下来，在这个文件夹中创建一个名为“User.js”的文件。将模型分离到它们自己的文件中是一个好主意。</p><p id="900e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在User.js中，添加以下代码:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="43e3" class="mg kv in mc b gy mh mi l mj mk">const { Schema, model } = require('mongoose')</span><span id="3a49" class="mg kv in mc b gy ml mi l mj mk">var userSchema = new Schema({<br/>  name: {<br/>    type: Schema.Types.String,<br/>    required: [true, 'You must provide a name']<br/>  },<br/>  email: {<br/>    type: Schema.Types.String,<br/>    required: [true, 'Email address is required']<br/>  },<br/>  username: {<br/>    type: Schema.Types.String,<br/>    required: [true, 'Username is required']<br/>  },<br/>  password: {<br/>    type: Schema.Types.String,<br/>    required: [true, 'You must provide a password']<br/>  }<br/>})</span><span id="6d43" class="mg kv in mc b gy ml mi l mj mk">const User = model('User', userSchema)</span></pre><p id="06ff" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">让我们浏览一下这个文件的内容:</p><ul class=""><li id="080a" class="mm mn in jx b jy jz kc kd kg mo kk mp ko mq ks mr ms mt mu bi translated">从mongoose导入模式和模型。</li><li id="b843" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">创建一个架构实例，该实例定义用户集合中用户文档的结构。</li><li id="8568" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">创建一个模型实例，并将集合名称和模式传递给它。</li><li id="3ed9" class="mm mn in jx b jy mv kc mw kg mx kk my ko mz ks mr ms mt mu bi translated">导出用户模型以在路线中使用。</li></ul><p id="fbcd" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">现在在models目录中创建一个索引文件。这个文件将从它的兄弟文件中导入所有的模型，并将它们导出到一个对象中。我们这样做是为了在导入模型时减少其他文件中require语句的数量。</p><p id="dec5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您当然可以直接从它们各自的文件中导入模型，但是这绝对是一种更干净的方式。</p><p id="c39b" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个index.js文件的内容现在应该是这样的:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="848e" class="mg kv in mc b gy mh mi l mj mk">const User = require('./User') module.exports = { User }</span></pre><h1 id="7de2" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">使用模型</h1><p id="007a" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">是时候检验这是否行得通了。如果集合为空，我们将向集合中插入一个用户，否则在集合中检索用户。</p><p id="5f2e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在应用程序条目文件中，从模型索引文件中导入用户模型，如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="1ac4" class="mg kv in mc b gy mh mi l mj mk">// Import models <br/>const { User } = require('./models')</span></pre><p id="a00e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">将归属路由更新为以下内容:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="2860" class="mg kv in mc b gy mh mi l mj mk">app.get('/', async (req, res) =&gt; {<br/>  const users = await User.find({})<br/>  if (users.length) {<br/>    /* Log users if users exists. */<br/>    console.log(users)<br/>  } else {<br/>    /* If no users exist, save new user and log saved user on the console. */<br/>    let newUser = new User({<br/>      name: 'Kelvin Mwinuka',<br/>      email: '<a class="ae kt" href="mailto:email@kelvinmwinuka.com" rel="noopener ugc nofollow" target="_blank">email@kelvinmwinuka.com</a>',<br/>      username: 'kelvin',<br/>      password: 'password'<br/>    })<br/>    let savedUser = await newUser.save()<br/>    console.log(savedUser)<br/>  }<br/>  res.render('home.html')<br/>})</span></pre><p id="127c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在浏览器中导航到这条路线，您应该会注意到，第一次有一个对象被打印到控制台:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="50cb" class="mg kv in mc b gy mh mi l mj mk">{<br/>  _id: 5fdab492561efb3e9a2c56c7,<br/>  name: 'Kelvin Mwinuka',<br/>  email: '<a class="ae kt" href="mailto:email@kelvinmwinuka.com" rel="noopener ugc nofollow" target="_blank">email@kelvinmwinuka.com</a>',<br/>  username: 'kelvin',<br/>  password: 'password',<br/>  __v: 0<br/>}</span></pre><p id="988e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">当您刷新页面时，结果应该如下所示:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="bd12" class="mg kv in mc b gy mh mi l mj mk">[<br/>  {<br/>    _id: 5fdab492561efb3e9a2c56c7,<br/>    name: 'Kelvin Mwinuka',<br/>    email: '<a class="ae kt" href="mailto:email@kelvinmwinuka.com" rel="noopener ugc nofollow" target="_blank">email@kelvinmwinuka.com</a>',<br/>    username: 'kelvin',<br/>    password: 'password',<br/>    __v: 0<br/>  }<br/>]</span></pre><p id="50e1" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">请注意，这是当前文档的数组，没有创建/保存新用户。</p><p id="3555" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">就是这样。我们已经成功地设置了mongoose，并准备开始在我们的MongoDB数据库中持久化数据！</p><h1 id="f1f4" class="ku kv in bd kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr bi translated">结论</h1><p id="b0b4" class="pw-post-body-paragraph jv jw in jx b jy ls ka kb kc lt ke kf kg lu ki kj kk lv km kn ko lw kq kr ks ig bi translated">在本文中，我们将express应用程序连接到一个MongoDB数据库，创建mongoose模型，并使用这些模型将数据保存到我们的数据库中。</p><p id="3c58" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在下一篇文章中，我将介绍使用Passport JS的用户注册和认证。</p><p id="9e5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在<a class="ae kt" href="https://github.com/kelvinmwinuka/express-tutorial" rel="noopener ugc nofollow" target="_blank"> Github </a>上追踪这个项目的进展。</p><p id="eec4" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="na">如果你喜欢这篇文章，可以考虑关注我的</em> <a class="ae kt" href="https://kelvinmwinuka.com/" rel="noopener ugc nofollow" target="_blank"> <em class="na">个人网站</em> </a> <em class="na">，以便在我的内容在媒体上发布之前提前获得(别担心，它仍然是免费的，没有烦人的弹出广告！).另外，请随意评论这篇文章。我很想听听你们的想法！</em></p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><p id="4d6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><em class="na">原载于2020年12月17日https://kelvinmwinuka.com</em><em class="na">的</em> <a class="ae kt" href="https://kelvinmwinuka.com/how-to-set-up-mongoose-with-expressjs/" rel="noopener ugc nofollow" target="_blank"> <em class="na">。</em></a></p></div></div>    
</body>
</html>