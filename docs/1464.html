<html>
<head>
<title>Creating Accessible React Apps — Focus and Semantics</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">创建可访问的React应用程序——焦点和语义</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-accessible-react-apps-focus-and-semantics-27ee5798c5e?source=collection_archive---------6-----------------------#2020-03-18">https://javascript.plainenglish.io/creating-accessible-react-apps-focus-and-semantics-27ee5798c5e?source=collection_archive---------6-----------------------#2020-03-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/21d456bf5a793e318459e0d1396ca5de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9uwX1NcaiL1MaXtB"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@brigittetohm?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brigitte Tohm</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5025" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是一个用于创建前端视图的库。它有一个庞大的图书馆生态系统与之合作。此外，我们可以用它来增强现有的应用程序。</p><p id="01b0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何创建可访问的React应用程序。</p><h1 id="fec1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么是可访问性？</h1><p id="a09b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该创建可访问的应用程序，以便每个人都可以使用它们。</p><h1 id="41bb" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">标准和指南</h1><p id="611f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><a class="ae kc" href="https://www.w3.org/WAI/intro/wcag" rel="noopener ugc nofollow" target="_blank">网站内容可访问性指南</a>提供了创建可访问网站的指南。</p><p id="ef0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们还有<a class="ae kc" href="https://www.w3.org/WAI/intro/aria" rel="noopener ugc nofollow" target="_blank">Web Accessibility Initiative——Accessible Rich Internet Applications</a>文档包含构建完全可访问的JavaScript小部件的指南。</p><p id="db02" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JSX完全支持HTML属性。这些属性以烤肉串的形式保存在HTML中。</p><h1 id="780e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">语义HTML</h1><p id="9941" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">HTML标签因其含义而得名。这意味着它们对屏幕阅读器和其他解析web内容的辅助程序有意义。</p><p id="fb2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们不应该使用<code class="fe me mf mg mh b">div</code>来分组元素，而是应该使用片段，这样我们的应用程序就不会有额外的<code class="fe me mf mg mh b">div</code>元素妨碍屏幕阅读器。</p><p id="42a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以向组件添加片段，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7007" class="mq lc iq mh b gy mr ms l mt mu">function ListItem({ item }) {<br/>  return (<br/>    &lt;Fragment&gt;<br/>      &lt;dt&gt;{item.term}&lt;/dt&gt;<br/>      &lt;dd&gt;{item.meaning}&lt;/dd&gt;<br/>    &lt;/Fragment&gt;<br/>  );<br/>}</span><span id="c1f5" class="mq lc iq mh b gy mv ms l mt mu">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = {<br/>      items: [<br/>        { term: "coffee", meaning: "black drink" },<br/>        { term: "milk", meaning: "white drink" }<br/>      ]<br/>    };<br/>  }</span><span id="4b9e" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;dl&gt;<br/>        {this.state.items.map(item =&gt; (<br/>          &lt;ListItem item={item} key={item.id} /&gt;<br/>        ))}<br/>      &lt;/dl&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="585c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们得到以下呈现的HTML:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5677" class="mq lc iq mh b gy mr ms l mt mu">&lt;dl&gt;<br/>  &lt;dt&gt;coffee&lt;/dt&gt;<br/>  &lt;dd&gt;black drink&lt;/dd&gt;<br/>  &lt;dt&gt;milk&lt;/dt&gt;<br/>  &lt;dd&gt;white drink&lt;/dd&gt;<br/>&lt;/dl&gt;</span></pre><p id="9d24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，片段不会产生任何额外的HTML，而是让我们将元素组合在一起。</p><p id="b918" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个简写或片段是<code class="fe me mf mg mh b">&lt;&gt;</code>和<code class="fe me mf mg mh b">&lt;/&gt;</code>。因此，我们可以将上面的代码重写如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="594b" class="mq lc iq mh b gy mr ms l mt mu">function ListItem({ item }) {<br/>  return (<br/>    &lt;&gt;<br/>      &lt;dt&gt;{item.term}&lt;/dt&gt;<br/>      &lt;dd&gt;{item.meaning}&lt;/dd&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="9a5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们保持代码的其余部分不变。</p><p id="c369" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到相同的HTML渲染。</p><h1 id="8846" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">可访问的表单</h1><p id="6221" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该给表单贴上标签，为所有用户提供可访问性。</p><p id="82b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们向<code class="fe me mf mg mh b">label</code>元素添加一个<code class="fe me mf mg mh b">for</code>属性。在React中，由<code class="fe me mf mg mh b">htmlFor</code>属性表示的<code class="fe me mf mg mh b">for</code>元素。</p><p id="e9ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这适用于所有表单控件。</p><p id="0e13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以做以下操作来添加一个<code class="fe me mf mg mh b">htmlFor</code>道具:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dc85" class="mq lc iq mh b gy mr ms l mt mu">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { name: "" };<br/>  }</span><span id="24c3" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;&gt;<br/>        &lt;label htmlFor="name"&gt;Name:&lt;/label&gt;<br/>        &lt;input type="text" name="name" value={this.state.name} /&gt;<br/>      &lt;/&gt;<br/>    );<br/>  }<br/>}</span></pre><p id="c0e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="5d23" class="mq lc iq mh b gy mr ms l mt mu">htmlFor="name"</span></pre><p id="d013" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将标签与表单域相关联。<code class="fe me mf mg mh b">htmlFor</code>值应该与表单控件元素的<code class="fe me mf mg mh b">name</code>值相同。</p><p id="27a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">完整的可访问性指南位于:</p><ul class=""><li id="795b" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><a class="ae kc" href="https://www.w3.org/WAI/tutorials/forms/labels/" rel="noopener ugc nofollow" target="_blank">W3C向我们展示了如何标记元素</a></li><li id="34ce" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae kc" href="https://webaim.org/techniques/forms/controls" rel="noopener ugc nofollow" target="_blank"> WebAIM向我们展示了如何标记元素</a></li><li id="c107" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae kc" href="https://www.paciellogroup.com/blog/2017/04/what-is-an-accessible-name/" rel="noopener ugc nofollow" target="_blank">paci ello集团解释了可访问名称</a></li></ul><h1 id="51ef" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">向用户通知错误</h1><p id="0f3c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">用户需要理解错误。以下指南告诉我们如何向屏幕阅读器显示错误文本:</p><ul class=""><li id="9652" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated"><a class="ae kc" href="https://www.w3.org/WAI/tutorials/forms/notifications/" rel="noopener ugc nofollow" target="_blank">W3C演示用户通知</a></li><li id="f38d" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated"><a class="ae kc" href="https://webaim.org/techniques/formvalidation/" rel="noopener ugc nofollow" target="_blank"> WebAIM查看表单验证</a></li></ul><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nk"><img src="../Images/8dd3da13170308e5eef6812cd526e3f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*aPso-Cv41z7YLjfe"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@brett_jordan?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brett Jordan</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="502e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">聚焦控制</h1><p id="2a67" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该只通过使用CSS来改变或删除轮廓，这样用户即使看不到轮廓也可以获得聚焦的元素。</p><h1 id="4951" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">跳到所需内容的方法</h1><p id="5421" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">此外，我们应该为用户提供跳转到他们想看或想用的内容的方法。</p><p id="0996" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用内部页面锚和一些样式来实现。</p><p id="af8a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以将重要的内容放在像<code class="fe me mf mg mh b">main</code>和<code class="fe me mf mg mh b">aside</code>这样的元素中，这样它们就可以与其他内容区分开来。</p><h1 id="96e0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">以编程方式管理焦点</h1><p id="6adc" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在React中，我们可以通过使用refs来访问DOM元素。这意味着我们可以通过调用DOM方法来控制元素何时获得焦点。</p><p id="5fb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们想在组件安装在DOM树中时聚焦一个元素，我们可以如下调用<code class="fe me mf mg mh b">focus</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="89e2" class="mq lc iq mh b gy mr ms l mt mu">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.textInput = React.createRef();<br/>  }</span><span id="8579" class="mq lc iq mh b gy mv ms l mt mu">  componentDidMount() {<br/>    this.textInput.current.focus();<br/>  }</span><span id="de3a" class="mq lc iq mh b gy mv ms l mt mu">  render() {<br/>    return &lt;input type="text" ref={this.textInput} /&gt;;<br/>  }<br/>}</span></pre><p id="a7b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们通过编写以下代码创建了一个<code class="fe me mf mg mh b">ref</code>来访问DOM元素:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fed0" class="mq lc iq mh b gy mr ms l mt mu">this.textInput = React.createRef();</span></pre><p id="1553" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">input</code>元素中，我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3a67" class="mq lc iq mh b gy mr ms l mt mu">ref={this.textInput}</span></pre><p id="5f8b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将<code class="fe me mf mg mh b">input</code>元素与我们创建的<code class="fe me mf mg mh b">ref</code>元素关联起来。</p><p id="e466" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在<code class="fe me mf mg mh b">componentDidMount</code>钩子中，我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b01e" class="mq lc iq mh b gy mr ms l mt mu">this.textInput.current.focus();</span></pre><p id="23c9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在组件安装时聚焦输入。<code class="fe me mf mg mh b">this.textInput.current</code>返回input元素，这样我们就可以在上面调用原生的<code class="fe me mf mg mh b">focus</code>方法。</p><h1 id="e42b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="d387" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在创建React应用时，我们应该考虑可访问性。</p><p id="e56f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着我们应该使用语义HTML标签，以便所有用户都能理解一个页面的内容。</p><p id="2990" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们应该为用户提供跳转到他们想看的内容的方法。</p><p id="ceb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以通过编程来聚焦元素，这样当焦点丢失时，用户可以通过重新获得焦点来立即使用输入。</p></div></div>    
</body>
</html>