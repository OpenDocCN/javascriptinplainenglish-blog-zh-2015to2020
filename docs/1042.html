<html>
<head>
<title>JavaScript can do that? (shorthand techniques)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript能做到吗？(速记技巧)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-can-do-that-ca59c00738cd?source=collection_archive---------1-----------------------#2020-01-20">https://javascript.plainenglish.io/javascript-can-do-that-ca59c00738cd?source=collection_archive---------1-----------------------#2020-01-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1239" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用JavaScript速记技术做更多的事情。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/fb558bf7daaaeefbf629d00fee2cbd84.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VJckS0eA8GJ_R_MJoBm-XA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image by <a class="ae kv" href="https://pixabay.com/users/Alltechbuzz-13671689/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4523100" rel="noopener ugc nofollow" target="_blank">Alltechbuzz</a> from <a class="ae kv" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=4523100" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="d9a9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript是最流行的编程语言之一，有时了解JavaScript中的速记技术可以改进您的代码，做到事半功倍。在这篇文章中，我将谈论一些速记技巧。</p><p id="80be" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="ls">这些技术可能会让你的代码看起来整洁，但它可能会损害一些用户的可读性，特别是初级开发人员可能很难理解发生了什么，所以明智地使用它们</em>，<a class="ae kv" href="https://en.wikipedia.org/wiki/KISS_principle" rel="noopener ugc nofollow" target="_blank">亲亲</a>。</p><p id="f47b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以让我们开始吧。</p><h1 id="8c78" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">将值转换为布尔值</h1><h2 id="13bb" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">双非(！！)</h2><p id="eb1c" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">这种转换是基于值的“<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/truthy" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"/></a>”或“<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Glossary/falsy" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"/></a>”的真值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="24cb" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">布尔函数</h2><p id="5c6c" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">这很像上面显示的<strong class="ky ir"> DoubleNot </strong>操作符。但是我觉得更干净，更容易理解。跟<strong class="ky ir">一样快(！！)</strong>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="e961" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">将数字字符串和null转换为数字</h1><p id="f6ad" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">最简单的方法是在字符串前面添加<strong class="ky ir">一元运算符</strong> <code class="fe ne nf ng nh b">+</code>。如果格式正确，<code class="fe ne nf ng nh b">string</code>将被转换成<code class="fe ne nf ng nh b">integer</code>。这不是一个广为人知的技巧，也许是因为它会让读者感到困惑。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c397" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">数字()👍🏽</strong>可读性最强，更容易理解。也可以用(<strong class="ky ir"> *1) </strong>但是，我感觉就是有点乱。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="6e4d" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">将值转换为字符串</h1><p id="9024" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">进行字符串转换最流行的方法是使用<code class="fe ne nf ng nh b">toString()</code>，但是现在我们可以使用模板文字。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="0f5e" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">串联</h1><p id="6866" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我们可以使用模板文字进行连接。它使您能够创建多行字符串和表达式插值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="42f2" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">使用Spread运算符的数组和对象</h1><h2 id="5d31" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">复制/克隆阵列</h2><p id="4c7b" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">当你想要复制一个数组或一个对象时，你可以使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax" rel="noopener ugc nofollow" target="_blank"> spread运算符</a> (…)。这创建了一个数组/对象的浅拷贝，就像<code class="fe ne nf ng nh b">Array.prototype.slice() / Object.assign()</code>。然而，当处理多维数组时，不推荐这样做。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="14a3" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">复制/克隆对象</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="3c3f" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">将数组连接在一起</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h2 id="c28b" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">删除数组中的重复项</h2><p id="c073" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated"><code class="fe ne nf ng nh b">Set</code>是ES6 中引入的<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set" rel="noopener ugc nofollow" target="_blank">新数据对象。set对象允许您存储任何类型的唯一值。我从</a><a class="ni nj ep" href="https://medium.com/u/829a804ea5da?source=post_page-----ca59c00738cd--------------------------------" rel="noopener" target="_blank">萨曼莎·明</a>的<a class="ae kv" href="https://www.samanthaming.com/tidbits/43-3-ways-to-remove-array-duplicates" rel="noopener ugc nofollow" target="_blank">博客</a>上读到了<code class="fe ne nf ng nh b">Set</code>。我觉得它真的很棒😀。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="f7c0" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">IndexOf()或includes()</h1><p id="ad2a" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">当在一个数组中寻找一个项目时，我们使用<code class="fe ne nf ng nh b">indexOf()</code>来获得我们所寻找的那个项目的位置。如果该值是一个数字(+或-)，而不是一个<code class="fe ne nf ng nh b">0</code>，那么它被认为是<strong class="ky ir">真值。</strong>我们也可以使用<strong class="ky ir"> includes()，</strong>来适当地返回一个布尔值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="c293" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还有<code class="fe ne nf ng nh b">~</code> ( <strong class="ky ir">波浪号</strong>[<strong class="ky ir">til</strong>-<em class="ls">duh</em>)可以和<code class="fe ne nf ng nh b">indexOf()</code>一起使用的按位运算符，不过为了简单起见我宁愿用<code class="fe ne nf ng nh b">includes()</code>。除了<code class="fe ne nf ng nh b">-1</code>之外，按位运算符将返回任何值的真值。</p><h1 id="8989" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">如果(👽)条件</h1><h2 id="b718" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">真实性检查</h2><p id="d046" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">我在代码中多次看到下面的truthy check。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><p id="1cf9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JavaScript中，如果值不是<code class="fe ne nf ng nh b">undefined, null, false, 0, "", NaN</code> <a class="ae kv" href="https://www.ecma-international.org/ecma-262/5.1/#sec-9.2" rel="noopener ugc nofollow" target="_blank">，那么它将计算为the。</a> <strong class="ky ir"> </strong>因此，你可以<strong class="ky ir"> </strong>简单地使用变量本身作为条件，而不是像上面的例子那样。</p><p id="7899" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">进行真实性检查的一种简便方法:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nc nd l"/></div></figure><h1 id="cf20" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">实验性和有限的可用性</h1><p id="f283" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">在工作中，我几乎一直都在使用TypeScript，关于TypeScript的最好的事情之一是你现在就可以使用ECMAScript即将到来的特性。最近发布的<a class="ae kv" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html" rel="noopener ugc nofollow" target="_blank"> TypeScript v3.7 </a>允许您使用<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank">可选链接</a>和<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining" rel="noopener ugc nofollow" target="_blank">无效合并</a>。</p><h2 id="2c99" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">可选链接</h2><p id="961b" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">这允许我们安全地读取一个属性的值，这个值在一个对象的深处。我们不再需要明确检查对象链的每个属性是否有效。这使得我们的代码更短、更简单、更容易理解。</p><pre class="kg kh ki kj gt nk nh nl nm aw nn bi"><span id="7b34" class="ml lu iq nh b gy no np l nq nr">// What we current use:<br/>let y = (foo === null || foo === undefined) ? undefined : foo.bar;</span></pre><p id="90c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不用做上面的，你可以简单的做这个:<code class="fe ne nf ng nh b">let y = foo?.bar;</code>，看看有多简单优雅🙂。</p><p id="51c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于可选的链接，表达式将只返回<code class="fe ne nf ng nh b">undefined</code>。而不是我们都熟悉的例外<code class="fe ne nf ng nh b">TypeError: Cannot read property 'bar' of undefined</code>。</p><h2 id="29e4" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">无效合并</h2><p id="f5ee" class="pw-post-body-paragraph kw kx iq ky b kz mx jr lb lc my ju le lf mz lh li lj na ll lm ln nb lp lq lr ij bi translated">在JavaScript中，对于nullish合并，我们使用逻辑<strong class="ky ir">或|| </strong>操作符。但是这伴随着一些意想不到的行为。</p><pre class="kg kh ki kj gt nk nh nl nm aw nn bi"><span id="8db7" class="ml lu iq nh b gy no np l nq nr">const foo = bar.baz || "qux";</span></pre><p id="e421" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">或(||) </strong>是一个布尔运算符，如果<code class="fe ne nf ng nh b">bar.baz</code>定义了一个值并且是<code class="fe ne nf ng nh b">0</code>，那么<code class="fe ne nf ng nh b">foo</code>将是<code class="fe ne nf ng nh b">"qux",</code>，因为<code class="fe ne nf ng nh b">0</code>是一个伪值。这是因为左边的值被强制转换为布尔值进行评估，并且<em class="ls">任何假值都不会返回</em>。这就是nullish合并运算符派上用场的地方。</p><pre class="kg kh ki kj gt nk nh nl nm aw nn bi"><span id="5649" class="ml lu iq nh b gy no np l nq nr">const foo = bar.baz ?? "qux";</span></pre><p id="1011" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果<code class="fe ne nf ng nh b">bar.baz</code>的值是<code class="fe ne nf ng nh b">0</code>，那么<code class="fe ne nf ng nh b">foo</code>将是<code class="fe ne nf ng nh b">0</code>。如果<code class="fe ne nf ng nh b">bar.baz</code>是<code class="fe ne nf ng nh b">undefined</code>或<code class="fe ne nf ng nh b">null</code>，那么<code class="fe ne nf ng nh b">foo</code>将是<code class="fe ne nf ng nh b">"qux"</code>。无效合并运算符和可选链接运算符都将<code class="fe ne nf ng nh b">undefined</code>和<code class="fe ne nf ng nh b">null</code>视为特定值。</p></div><div class="ab cl ns nt hu nu" role="separator"><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx ny"/><span class="nv bw bk nw nx"/></div><div class="ij ik il im in"><p id="6ed6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些是我认为值得分享的一些技巧，还有很多；我们改天再看。</p><h2 id="67e6" class="ml lu iq bd lv mm mn dn lz mo mp dp md lf mq mr mf lj ms mt mh ln mu mv mj mw bi translated">感谢阅读😀</h2></div></div>    
</body>
</html>