<html>
<head>
<title>How to Integrate Stand-Alone React Components on a Static Page</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在静态页面上集成独立的React组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/integrating-stand-alone-react-components-on-a-static-page-21dd4fd3074?source=collection_archive---------3-----------------------#2020-05-12">https://javascript.plainenglish.io/integrating-stand-alone-react-components-on-a-static-page-21dd4fd3074?source=collection_archive---------3-----------------------#2020-05-12</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b4a4" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">仅对您需要的东西使用React</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/d4bb42659aa1548e7fc9a78347bbe791.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MMnhdL0IjHR1sEqLr2r81Q.jpeg"/></div></div></figure><p id="9552" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如今，速度才是王道。众所周知，普通的HTML站点比JavaScript驱动的站点表现更好。但是对于我们提供给用户的所有交互内容，几乎无法想象一个没有JavaScript的网站。那么，中间立场是什么？</p><h1 id="52c5" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">你不喜欢反应？</h1><p id="5b14" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">不要误解我的意思，我是前端框架的忠实支持者，但有时我们在实现中会受到限制。这意味着，在某些情况下，我们无法在普通的React应用程序中工作。例如:</p><ul class=""><li id="5c13" class="mh mi in kq b kr ks ku kv kx mj lb mk lf ml lj mm mn mo mp bi translated">你的网站是由内容管理系统驱动的</li><li id="90b5" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">多个团队控制着网站的不同部分</li><li id="0a55" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">技术决定已经做出，这不是你说了算的</li><li id="ad84" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">性能和搜索引擎优化是非常重要的</li><li id="831c" class="mh mi in kq b kr mq ku mr kx ms lb mt lf mu lj mm mn mo mp bi translated">您没有对您的应用程序进行SSR的基础设施</li></ul><p id="9fb8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个清单还可以继续，但关键是，<strong class="kq io">你并不总是处于控制中</strong>。</p><h1 id="0636" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">使用案例</h1><p id="d75c" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">我们有一个静态网站，我们想在那里注入动态内容的微小片段。我们不想要一个完全动态的页面，因为动态的内容比静态的内容要少。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/16b414205b06aa7d391a966693687b53.png" data-original-src="https://miro.medium.com/v2/resize:fit:676/format:webp/1*KrfUCFBZoKvPZ8r0V9PC3Q.png"/></div></figure><p id="4edd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这些动态内容可以是传送带、价格显示、通知、CTA等等</p><p id="999c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这些由我们的React组件表示。这些组件通常依赖API来执行操作或显示数据。</p><p id="55d1" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在的问题是，我们如何以结构化和可维护的方式将它们显示在页面上。我们希望避免每次集成新组件时都必须手动编写代码。</p><h1 id="1044" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">整合组件</h1><p id="1ef3" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">如果我们看看如何启动一个普通的React应用程序，它看起来像这样。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="23f7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">其中<em class="my"> &lt; App/ &gt; </em>是入口组件，而<em class="my"> root </em>是我们将在DOM中放置该组件的位置。如果你这样说，你可能会问，<strong class="kq io">我们能对多重根这样做吗？答案是肯定的。了解了这一点，我们就可以建立一些基本框架，在特定的根上呈现特定的组件。</strong></p><h2 id="c89c" class="mz ll in bd lm na nb dn lq nc nd dp lu kx ne nf lw lb ng nh ly lf ni nj ma nk bi translated">根</h2><p id="d08a" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">让我们从定义组件根在DOM中的外观开始。我们需要识别哪个React组件将呈现，以及将什么数据传递给该组件。数据属性将定义我们的组件将如何呈现。<em class="my"> data-react-component </em>将引用react组件映射到的键。<em class="my"> data-react-props </em>是我们可以传递给组件的数据的JSON表示。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h2 id="7128" class="mz ll in bd lm na nb dn lq nc nd dp lu kx ne nf lw lb ng nh ly lf ni nj ma nk bi translated">映射</h2><p id="e83e" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">映射是自动匹配HTML根和React组件的关键。为了提高可维护性，可以利用一些助手方法来注册和获取组件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5a1a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">当获取一个组件时，在失败的情况下返回空值<em class="my">是很重要的，因为与呈现未定义的</em>相反，呈现空值<em class="my">不会导致反应错误。</em></p><h1 id="f01a" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">渲染</h1><p id="34c0" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">现在，我们将结合React渲染方法应用前面的示例。我们将通过在DOM中查询一个<em class="my"> data-react-component </em>属性来获得所有的根。然后我们遍历每个根，从HTML元素的数据集中获取组件id和JSON属性。</p><p id="6d59" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了在组件中插入道具，我们<a class="ae nl" href="https://medium.com/javascript-in-plain-english/destructuring-demystified-76884866ba30" rel="noopener">析构</a>组件中被解析的JSON道具作为单独的道具。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><h1 id="3fa9" class="lk ll in bd lm ln lo lp lq lr ls lt lu jt lv ju lw jw lx jx ly jz lz ka ma mb bi translated">我们能让这些组件交流吗？</h1><p id="0bbd" class="pw-post-body-paragraph ko kp in kq b kr mc jo kt ku md jr kw kx me kz la lb mf ld le lf mg lh li lj ig bi translated">如果我们不能，我会问吗？当然可以！组件交互最常见的方式之一是通过传递道具。然而，有了我们的独立组件，就没有父母可以从中获取道具，也没有孩子可以向其传递道具。</p><p id="78e7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">作为一个例子，我们可以使用Redux来解决这个问题。可以使用许多其他的状态管理库，但是这个例子展示了将共享状态与独立组件集成的概念。</p><p id="af1f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Redux利用了一个提供者，它向连接的组件公开存储。由于这个提供者是你的应用程序的包装器，许多人认为如果你想让你的组件使用同一个存储，它们需要在同一个应用程序中。不对！</p><p id="f75a" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过用提供者包装我们想要呈现的每个组件，并将相同的存储引用传递给该提供者，我们实际上向所有这些单独的组件公开了同一个存储。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="4fdb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">请注意，当您使用一个函数来设置您的商店时，请确保您总是返回相同的商店实例来传递给您的提供者。否则，每个组件都有一个单独的存储。</p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><p id="360e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">好了，你可以随意使用React，但是请记住，当渲染更多单独的组件时，性能会降低。然而，当需要呈现那么多组件时，您应该真正尝试改变为单个应用程序的方法。</p></div><div class="ab cl nm nn hr no" role="separator"><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr ns"/><span class="np bw bk nq nr"/></div><div class="ig ih ii ij ik"><h2 id="8346" class="mz ll in bd lm na nb dn lq nc nd dp lu kx ne nf lw lb ng nh ly lf ni nj ma nk bi translated">进一步阅读</h2><div class="nt nu gp gr nv nw"><a href="https://bit.cloud/blog/design-tokens-in-components-with-react-and-bit-l28qlxq6" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd io gy z fp ob fr fs oc fu fw im bi translated">用React和Bit设计组件中的令牌</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">现场演示更好。在我们深入细节之前，让我们看一下使用Bit设计令牌如何帮助我们构建…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">比特云</p></div></div><div class="of l"><div class="og l oh oi oj of ok km nw"/></div></div></a></div><p id="a4fa" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="my">更多内容请看</em><a class="ae nl" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="my">plain English . io</em></strong></a><em class="my">。报名参加我们的</em> <a class="ae nl" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="my">免费周报</em> </strong> </a> <em class="my">。关注我们关于</em><a class="ae nl" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="my">Twitter</em></strong></a><a class="ae nl" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="my">LinkedIn</em></strong></a><strong class="kq io"><em class="my"/></strong><a class="ae nl" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="my">YouTube</em></strong></a><strong class="kq io"><em class="my">，以及</em></strong><em class="my"/><a class="ae nl" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kq io"><em class="my">不和</em> </strong> </a>  <em class="my">对成长黑客感兴趣？检查</em> <a class="ae nl" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="kq io"> <em class="my">电路</em> </strong> </a> <strong class="kq io"> <em class="my">。</em> </strong></p></div></div>    
</body>
</html>