<html>
<head>
<title>The JavaScript Event Loop explained</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript事件循环解释</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-event-loop-explained-dd9520a58544?source=collection_archive---------3-----------------------#2020-02-13">https://javascript.plainenglish.io/javascript-event-loop-explained-dd9520a58544?source=collection_archive---------3-----------------------#2020-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/84f1ee7c4465164da08f7df064ca8266.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3oi7faLaWR7VSYJ8Tovdiw.jpeg"/></div></div></figure><p id="cc1a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在前两篇文章中，我们学习了JavaScript的调用堆栈、单线程和非阻塞行为。为了理解JavaScript如何在chrome的V8引擎上运行。这是我们讨论事件循环、Web APIs和任务队列的最后一篇文章。所有这些东西是如何一起工作并形成JavaScript运行时环境的。我们开始吧。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><div class="ld le lf lg gt lh"><a href="https://medium.com/javascript-in-plain-english/js-single-thread-non-blocking-explained-d5de012a33cf" rel="noopener follow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd ir gy z fp lm fr fs ln fu fw ip bi translated">JavaScript中的单线程和非阻塞是什么意思？</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">一次性理解JavaScript可能会很困难，也很忙乱。我读了很多教程，但没有得到…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">medium.com</p></div></div><div class="lq l"><div class="lr l ls lt lu lq lv jw lh"/></div></div></a></div></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="33ce" class="lw lx iq bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">调用栈</h1><p id="cc9d" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">调用堆栈是一个后进先出(先执行最新的任务)的数据结构，包含执行将恢复的地址。调用栈是JavaScript运行的整个系统的一部分。如果你想更好地理解JavaScript，你可以阅读我在调用栈上的文章。</p><div class="mz na gp gr nb lh"><a href="https://medium.com/javascript-in-plain-english/node-call-stack-explained-fd9df1c49d2e" rel="noopener follow" target="_blank"><div class="li ab fo"><div class="lj ab lk cl cj ll"><h2 class="bd ir gy z fp lm fr fs ln fu fw ip bi translated">节点:调用堆栈解释</h2><div class="lo l"><h3 class="bd b gy z fp lm fr fs ln fu fw dk translated">大约一年前，正如我的投资组合所说，我是一名高级JavaScript开发人员。但是在孤独的时候，当我问自己…</h3></div><div class="lp l"><p class="bd b dl z fp lm fr fs ln fu fw dk translated">medium.com</p></div></div><div class="lq l"><div class="nc l ls lt lu lq lv jw lh"/></div></div></a></div><h1 id="2df5" class="lw lx iq bd ly lz nd mb mc md ne mf mg mh nf mj mk ml ng mn mo mp nh mr ms mt bi translated">Web APIs</h1><p id="f3ae" class="pw-post-body-paragraph jy jz iq ka b kb mu kd ke kf mv kh ki kj mw kl km kn mx kp kq kr my kt ku kv ij bi translated">Web APIs不是JS引擎的一部分，但是它们是浏览器提供的JavaScript运行时环境的一部分。JavaScript只是为我们提供了一种访问这些API的机制。由于Web APIs是特定于浏览器的，因此它们可能因浏览器而异。有些情况下，一些Web APIs可能出现在一个浏览器中，但在另一个浏览器中却没有。</p><h2 id="bcee" class="ni lx iq bd ly nj nk dn mc nl nm dp mg kj nn no mk kn np nq mo kr nr ns ms nt bi translated">例子</h2><ol class=""><li id="01ff" class="nu nv iq ka b kb mu kf mv kj nw kn nx kr ny kv nz oa ob oc bi translated">操作DOM的DOM API。<code class="fe od oe of og b">document.getElementById</code>、<code class="fe od oe of og b">addEventListerner</code>、<code class="fe od oe of og b">document.querySelectorAll</code>等。是浏览器提供的DOM API的一部分，我们可以使用JavaScript访问它。</li><li id="c47b" class="nu nv iq ka b kb oh kf oi kj oj kn ok kr ol kv nz oa ob oc bi translated">AJAX调用或XMLHttpRequest。由于Web API是特定于浏览器的，而XMLHttpRequest是一个Web API，所以在JQuery拯救我们之前，我们必须以不同的方式为IE实现XMLHttpRequest(还记得吗？).</li><li id="b63f" class="nu nv iq ka b kb oh kf oi kj oj kn ok kr ol kv nz oa ob oc bi translated">像<code class="fe od oe of og b">setTimeout</code>、<code class="fe od oe of og b">setInterval</code>这样的定时器功能也是浏览器提供的。</li></ol><p id="ff38" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">为了更好地理解事件循环和任务队列，我们将举一个例子来理解我们一直在做的事情:)。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/27823355562359727fcfd89f269e8de3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dHbds6T9Lh24v5B8Pv9Nfg.png"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk">Credits: JS Conference</figcaption></figure><p id="dc33" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在这里，我们将执行这段代码，并了解事件循环、任务队列、web APIs和调用堆栈如何协同工作。正如我们所知，JavaScript是一种异步语言，这意味着如果一些代码需要时间来执行，它将移动到下一行，然后当合适的时间到来时，这些代码就会执行。但是JavaScript是如何做到这些的，我们来看看。像网络请求、图像处理等一般需要时间的代码。我们使用<code class="fe od oe of og b">setTimeout</code>5秒来创建一个延迟。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/53991f6a4738e4a832e81a1058295c27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6DBFtzjvgy4B0Ef8AXQvBw.png"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk">Image 1</figcaption></figure><p id="e62c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">代码开始时，一切都很顺利。正如我们所知，JavaScript一次运行一段代码，这段代码存在于调用堆栈中。这里的<code class="fe od oe of og b">log("Hi")</code>是要执行的第一行。由于<code class="fe od oe of og b">log("Hi")</code>不需要花费时间来执行，它只是从调用堆栈中在控制台弹出窗口中打印结果。简单！</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/f6d5127a2a7876e7cf38edc25f587058.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h3DtCFPM52CvCHBGB5VO2A.png"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk">Image 2</figcaption></figure><p id="9632" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在让我们去下一行，<code class="fe od oe of og b">setTimeout()</code>它在等着我们。当<code class="fe od oe of og b">setTimeout()</code>被推入堆栈时，JavaScript智能运行时已经知道执行需要时间。那怎么办呢？在这种情况下，每当某段代码需要时间来执行时，JS会将它移入浏览器的web API，因为<code class="fe od oe of og b">setTimeout()</code>是浏览器Web API模块的一部分，而&amp;是Web API模块的5秒处理计时器。现在，我们的堆栈又可以自由执行其他代码了。见下图。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/d48978956679d32fe12dc404121f358b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Psh-JhRAIp7dvGjqQvKwtg.png"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk">Image 3</figcaption></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="156c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，让我们进入下一行。<code class="fe od oe of og b">log("JSConfEU")</code>也是一行简单的代码，首先被推入调用堆栈，然后成功执行。请参见下图中的控制台。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/a69e0d797cd03aa857df9191524019bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7yiuSfKhI1HCygcy6SvJBA.png"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk">Image 4</figcaption></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="7001" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">与此同时，我们的<code class="fe od oe of og b">setTimeout()</code>正在等待5秒钟完成计时器。定时器结束后，它被移动到任务队列。在这里，任务队列发挥了作用。见下图。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/e9c193f9830d680c107d31b9eb61be73.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BkbYLiLYDnyzdY4T4xDcXw.png"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk">Image 5</figcaption></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="3bf1" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，我们的事件循环出现了。事件循环的工作是查看任务队列和调用堆栈。如果任务队列中的一些代码准备好执行，事件循环等待调用堆栈变空，当调用堆栈空闲来执行任务时，事件循环从任务队列中取出代码，推送到调用堆栈。见下图。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/b949421ef7f9c118c60275697cbd3e97.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x5fkvXWrwyBgc81Ux4PPlg.png"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk">Image 6</figcaption></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="ca58" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在最后<code class="fe od oe of og b">setTimeout()</code>的回调函数将执行并在控制台显示结果。</p><figure class="ld le lf lg gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi om"><img src="../Images/6c59ad8506505eab6a2f5ba5a7379a42.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hWIhEsce17tX1xWkwLfYug.png"/></div></div><figcaption class="on oo gj gh gi op oq bd b be z dk">Image 7</figcaption></figure></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><p id="8024" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，毕竟，XYZ运营的所有实体都成功地协调执行了这3行代码。简单总结一下。</p><p id="692a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 1: </strong>调用栈在LIFO的基础上执行代码，但一次只能执行一个代码。<br/> <strong class="ka ir"> 2: </strong>浏览器的Web APIs提供其他需要的功能，如setTimeout、网络请求等。</p><blockquote class="or os ot"><p id="39b5" class="jy jz ou ka b kb kc kd ke kf kg kh ki ov kk kl km ow ko kp kq ox ks kt ku kv ij bi translated"><code class="fe od oe of og b">console.log("HI");</code>也是Web APIs的一部分，但不是JavaScript的一部分。</p></blockquote><p id="8c29" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><strong class="ka ir"> 3: </strong>任务队列存储先前花费时间但现在等待执行的代码。<br/><strong class="ka ir">4:</strong><strong class="ka ir"/>事件循环管理任务队列和调用栈。当调用堆栈为空并且任务队列有任务要执行时。事件循环从任务队列中取出任务，并推入调用堆栈。</p><p id="d2e3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以，我认为现在关于事件循环和任务队列的疑问已经很清楚了&amp;您对JavaScript的基本工作有了更好的理解。如果你喜欢这篇文章，请“鼓掌”，关注我更多有趣的文章。</p><p id="8c6b" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">鸣谢:本文内容参考自飞利浦罗伯特<a class="ae oy" href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener ugc nofollow" target="_blank">视频讲解</a>。为了更好地理解，你也可以观看视频。</p><blockquote class="oz"><p id="b77c" class="pa pb iq bd pc pd pe pf pg ph pi kv dk translated">感谢阅读</p><p id="f893" class="pa pb iq bd pc pd pe pf pg ph pi kv dk translated">快乐编码||写2学</p></blockquote></div></div>    
</body>
</html>