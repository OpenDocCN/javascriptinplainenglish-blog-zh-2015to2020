<html>
<head>
<title>Constructors vs Literals in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的构造函数与文字</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-constructors-vs-literals-2d19e8b5f2d9?source=collection_archive---------5-----------------------#2020-06-21">https://javascript.plainenglish.io/javascript-constructors-vs-literals-2d19e8b5f2d9?source=collection_archive---------5-----------------------#2020-06-21</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="e355" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在JavaScript中，我们确实有以不同方式获得相同结果的自由。我们可以创建字符串、数字、对象、数组等。同时使用构造函数和文本方法的值。使用这些方法中的任何一种都可以获得相同的值。然而，仍然有一些差异需要知道，哪些可能有助于避免运行时错误。</p><blockquote class="ki kj kk"><p id="8b3e" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">对于那些只阅读这段引文的人来说，长话短说，用<br/> <strong class="jm io">文字值创建值比内置构造函数要好。</strong></p></blockquote><p id="2df3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">首先，如果你想知道这些是什么。</p><figure class="kq kr ks kt gt ku gh gi paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="gh gi kp"><img src="../Images/d0c794e740575f48ae6d55c6905a212b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NkBJh2g_db1RRVt6dotgyw.png"/></div></div></figure><p id="431d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你可以继续使用字面量而不知道它们的区别，没有人会对你说什么。我知道，如果你有一颗好奇的心，你会继续阅读。但是特别是对于那些来自基于类的编程语言的人来说，您可能会倾向于使用构造函数方法。如果你是，那么你必须在继续编码之前阅读以下内容。</p><p id="ced7" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通常情况下，你应该<strong class="jm io">更喜欢文字</strong> <strong class="jm io">和原语</strong>和<strong class="jm io">避免内置构造函数</strong>。</p><h2 id="a684" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated">为什么更喜欢文字和原语？</h2><p id="c246" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">1.文字较短，易于读写。</p><pre class="kq kr ks kt gt lz ma mb mc aw md bi"><span id="97b7" class="lb lc in ma b gy me mf l mg mh">let o = new Object();</span><span id="c4c3" class="lb lc in ma b gy mi mf l mg mh">let o = {}; // easier and actual representation</span></pre><p id="7a06" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.文本仍然可以受益于由构造函数创建的对象所提供的属性和方法。</p><pre class="kq kr ks kt gt lz ma mb mc aw md bi"><span id="660d" class="lb lc in ma b gy me mf l mg mh">let a = [1, 2, 3];<br/>a.length // 3<br/>a.slice(2) // [3]</span></pre><p id="dd09" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.当您在原语上调用一个方法时，它被隐式地转换为场景后面的一个临时对象。</p><pre class="kq kr ks kt gt lz ma mb mc aw md bi"><span id="876e" class="lb lc in ma b gy me mf l mg mh">let a = "Hello world";<br/>a.toLowerCase() // hello world<br/>a.length // 11</span></pre><h2 id="e249" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated"><strong class="ak">为什么要避免内置构造函数？</strong></h2><p id="4fa7" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">1.当与动态参数一起使用时，new Object()会导致意外的结果，从而造成混乱。</p><pre class="kq kr ks kt gt lz ma mb mc aw md bi"><span id="e312" class="lb lc in ma b gy me mf l mg mh">let n = new Object(1) // Number {1}<br/>typeof n // "object"<br/>n.constructor === Number // true</span><span id="4036" class="lb lc in ma b gy mi mf l mg mh">let b = new Object(true) // Boolean {true}<br/>typeof b // "boolean"<br/>b.constructor === Boolean // true</span></pre><p id="92e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">2.new Array()使用不同数量的参数给出不同的结果。</p><pre class="kq kr ks kt gt lz ma mb mc aw md bi"><span id="dd58" class="lb lc in ma b gy me mf l mg mh">let a = new Array(3) // [undefined, undefined, undefined]<br/>a.length // 3</span><span id="7abc" class="lb lc in ma b gy mi mf l mg mh">let a = new Array(1, 2, 3) // [1, 2, 3]<br/>a.length // 3</span><span id="6e98" class="lb lc in ma b gy mi mf l mg mh">let a = new Array(3.14) // Uncaught RangeError</span></pre><p id="c600" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">3.新的RegExp()，像反斜杠和引号这样的转义字符很无聊，降低了可读性。</p><pre class="kq kr ks kt gt lz ma mb mc aw md bi"><span id="997a" class="lb lc in ma b gy me mf l mg mh">let reg = /\\/g; // /\\/g<br/>let reg = new RegExp("\\\\", "g") // /\\/g</span></pre><p id="3833" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">4.在JavaScript中，您可以调用内置的构造函数，如数组、字符串等。没有使用“new”操作符，这有时可能会使您忘记使用使用“this”的“new”操作符调用自定义构造函数。</p><pre class="kq kr ks kt gt lz ma mb mc aw md bi"><span id="af23" class="lb lc in ma b gy me mf l mg mh">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="39c1" class="lb lc in ma b gy mi mf l mg mh">let p = Person("Kelina");<br/>p.name // undefined</span></pre><p id="28ab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当然，前面的语句不是错误，也不会降低任何性能，但是如果不小心的话，可能会导致意想不到的结果，从而引入错误。您仍然可以使用构造函数或文字，这实际上取决于您的偏好和必要性。</p><h2 id="7d10" class="lb lc in bd ld le lf dn lg lh li dp lj jv lk ll lm jz ln lo lp kd lq lr ls lt bi translated"><strong class="ak">总结</strong></h2><pre class="kq kr ks kt gt lz ma mb mc aw md bi"><span id="3907" class="lb lc in ma b gy me mf l mg mh">Literals and primitives   |  Built-in constructors</span><span id="72bd" class="lb lc in ma b gy mi mf l mg mh">let o = {};               |  let o = new Object();</span><span id="d802" class="lb lc in ma b gy mi mf l mg mh">let a = [];               |  let a = new Array();</span><span id="7225" class="lb lc in ma b gy mi mf l mg mh">let s = “”;               |  let s = new String();</span><span id="f1c9" class="lb lc in ma b gy mi mf l mg mh">let n = 0;                |  let n = new Number();</span><span id="f230" class="lb lc in ma b gy mi mf l mg mh">let b = false;            |  let b = new Boolean();</span><span id="ae37" class="lb lc in ma b gy mi mf l mg mh">let reg = /[a-z]/g;       |  let reg = new RegExp( "[a-z]", "g" );</span><span id="0e37" class="lb lc in ma b gy mi mf l mg mh">throw {                   |  throw new Error(“oops... error”);<br/>  name: “Error”, <br/>  message: “oops... error” <br/>};<br/>throw Error(“oops... error”);</span></pre><p id="52e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">虽然每种方法都有自己的好处，但一般来说，在大多数情况下使用文字就足够了。一如既往，感谢阅读。</p></div></div>    
</body>
</html>