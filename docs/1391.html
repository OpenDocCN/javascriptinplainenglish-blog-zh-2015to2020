<html>
<head>
<title>JavaScript Job Technical Interview Questions in 2020</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2020年JavaScript工作技术面试题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-job-technical-interview-questions-in-2020-7470d8763732?source=collection_archive---------1-----------------------#2020-03-10">https://javascript.plainenglish.io/javascript-job-technical-interview-questions-in-2020-7470d8763732?source=collection_archive---------1-----------------------#2020-03-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="9392" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Java Script语言</h2><div class=""/><div class=""><h2 id="20fa" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">你能回答几个？</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/63dafae9de8a1028fac373ef888a7085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*juD4cFvI6ndSv702"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@jonathanborba?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jonathan Borba</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="af7c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">最近几个月，我一直在努力找一份新工作。嗯，我不确定这是否是正确的表达方式，我想在另一家公司工作。我更新了我的简历，参加了一些工作面试——实际上不止几次。</p><p id="6627" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这篇文章中，我将与你分享最常见的5个JavaScript技术问题。我就写一下我是怎么回答的。如果有什么我应该知道的或者我错了，请随意比较你和我的答案并评论我！</p><h1 id="7f27" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">什么是终结？</h1><p id="4902" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">简而言之——闭包是一种现象或概念，它给你一个到已经完成执行的函数的访问链接。</p><p id="4949" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">详细回答—当在当前活动/运行的执行上下文的执行阶段执行一个函数时，会创建一个新的执行上下文，并将其置于先前活动的执行上下文之上。内部函数在外部函数中声明。当一个函数诞生时，它被赋予了一个外部变量的访问链接，我们称之为作用域链。因为内部函数作为外部函数的输出返回，所以您仍然可以使用返回的内部函数访问变量。即使外部函数的执行上下文已经消失或从执行堆栈中删除，从内部到外部的访问链接仍然有效。这被称为结束。闭包在我们的代码中无处不在，如果你以错误的方式使用或滥用它们，它可能会导致内存泄漏。</p><ul class=""><li id="8b37" class="my mz iq lh b li lj ll lm lo na ls nb lw nc ma nd ne nf ng bi translated"><a class="ae le" href="https://medium.com/better-programming/execution-context-lexical-environment-and-closures-in-javascript-b57c979341a5" rel="noopener">关于这个话题的相关帖子</a>——JavaScript中的执行上下文、词法环境和闭包</li></ul><h1 id="f26b" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">箭头函数和普通函数有什么不同？</h1><p id="fdc2" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">简而言之——箭头函数没有关键字<code class="fe nh ni nj nk b">this</code>,而普通函数有。此外，<code class="fe nh ni nj nk b">Function.prototype.bind</code>对箭头函数不起作用，箭头函数不能是构造函数。</p><p id="eb71" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">详细回答——当声明一个函数时，JavaScript引擎会计算出该函数的类型。如果函数是箭头函数，引擎会将其引用类型分类为“词法”。当声明一个函数时，引擎将引用链接设置为<code class="fe nh ni nj nk b">this</code>。但是，如果函数的引用类型是“词法”，那么引擎不会创建<code class="fe nh ni nj nk b">this</code>。相反，当您调用它的<code class="fe nh ni nj nk b">this</code>时，该函数试图在外部执行中寻找<code class="fe nh ni nj nk b">this</code>。结果，<code class="fe nh ni nj nk b">Function.prototype.bind</code>也不起作用，因为<code class="fe nh ni nj nk b">bind</code>所做的是改变<code class="fe nh ni nj nk b">this</code>引用——反正箭头函数的<code class="fe nh ni nj nk b">this</code>不存在，所以毫无意义！当引擎创建一个函数时，只有当函数类型是普通函数时，它才创建函数的原型。</p><ul class=""><li id="edc4" class="my mz iq lh b li lj ll lm lo na ls nb lw nc ma nd ne nf ng bi translated"><a class="ae le" href="https://medium.com/better-programming/javascript-whats-the-difference-between-normal-and-arrow-functions-74c367324ae1" rel="noopener">关于这个话题的相关帖子</a> — JavaScript:普通函数和箭头函数有什么区别？</li></ul><h1 id="84d9" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">什么是承诺？</h1><p id="9714" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">简而言之——promise是一个异步代理，它允许您异步运行代码。它通常被比作<code class="fe nh ni nj nk b">async-await</code>，主要区别在于<code class="fe nh ni nj nk b">async-await</code>是你可以同步执行代码的方式。</p><p id="383c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">详细回答——要理解什么是承诺，你应该知道JavaScript中事件的基本历史。当一些代码运行时间过长时，它们会停止整个程序。所以许多开发人员应该非常小心不要挂起进程。您可以使用稍后运行代码的<code class="fe nh ni nj nk b">setTimeout</code>或<code class="fe nh ni nj nk b">setInterval</code>。JavaScript将这些称为宏任务，而将其他普通任务称为任务，比如<code class="fe nh ni nj nk b">console.log(1)</code>。宏任务总是在所有正常任务执行后执行。但是他们不能向你保证他们不会打扰或扰乱渲染步骤。因此，有时或有时以上，他们把渲染步骤推到当前节拍或下一节拍的末尾，因为它们需要很长时间。<code class="fe nh ni nj nk b">requestAnimationFrame</code>是解决这个问题的下一代异步函数。这也是一个宏任务，在正常任务之后执行。但它肯定会在Chrome渲染步骤之前执行。在Safari中，它在渲染步骤之后执行。</p><p id="0fec" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是你不能控制回调何时必须使用<code class="fe nh ni nj nk b">requestAnimatinoFrame</code>运行，尽管在渲染步骤上它比<code class="fe nh ni nj nk b">setTimeout</code>更好。相反，ES6中发布了一个新功能，叫做Promise。这也是一个异步函数，但是它并没有真正完成任何渲染步骤。无极、<code class="fe nh ni nj nk b">setTimeout</code>和<code class="fe nh ni nj nk b">requestAnimationFrame</code>之间有一个主要的区别。您可以通过拨打<code class="fe nh ni nj nk b">res(), rej() or then()</code>来控制您的承诺何时生效。这些方法返回了一个新的承诺。承诺被称为微观任务，而不是宏观任务——不要混淆！它们必须在每个正常任务完成后才能执行。</p><p id="7e95" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是，你也应该向面试官解释的一个重要事实是，无论如何，JavaScript都是一种单线程语言。<code class="fe nh ni nj nk b">setTimeout</code>、<code class="fe nh ni nj nk b">requestAnimationFrame</code>、<code class="fe nh ni nj nk b">Promise</code>……一切都好，但他们无法逃离一个单线程国家。也就是说,<code class="fe nh ni nj nk b">asynchronous</code>这个词听起来似乎不受代码块挂起的影响，但事实并非如此。</p><pre class="kp kq kr ks gt nl nk nm nn aw no bi"><span id="d943" class="np mc iq nk b gy nq nr l ns nt">setTimeout(() =&gt; {<br/>  console.log('setTimeout-1')<br/>  for (let i = 0; i &lt; 10e9; i +=1) {}<br/>})<br/>setTimeout(() =&gt; {<br/>  console.log('setTimeout-2')<br/>})</span></pre><p id="167b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">打印<code class="fe nh ni nj nk b">setTimeout-2</code>需要很长时间。</p><ul class=""><li id="03ec" class="my mz iq lh b li lj ll lm lo na ls nb lw nc ma nd ne nf ng bi translated"><a class="ae le" href="https://medium.com/better-programming/be-the-master-of-the-event-loop-in-javascript-part-1-6804cdf6608f" rel="noopener">关于此主题的相关帖子</a>——掌握JavaScript中的事件循环(第1部分)</li></ul><h1 id="a846" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">什么是HOF？</h1><p id="ede4" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">简短回答HOF是一个函数，它以一个函数作为输入，并返回一个函数作为输出。</p><p id="2df7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">详细答案——HOF不仅仅是一个接受并返回函数的函数，它还可以是一个闭包(您应该知道闭包是什么意思)。HOF返回一个函数，该函数使用声明返回函数的执行环境，换句话说，是一个外部函数。</p><pre class="kp kq kr ks gt nl nk nm nn aw no bi"><span id="b90d" class="np mc iq nk b gy nq nr l ns nt">const hof = (ctx) =&gt; <br/>  (props) =&gt; ctx.props = props;</span></pre><p id="daf1" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">此示例显示了HOF可以成为闭包的原因。此外，HOF应该是一个纯函数，因为如果有可能导致副作用，那么它总是不好的，尤其是当它可能是一个闭包时。在反应中，存在来自HOF的ad HOC。唯一的区别在于，HOC返回的是一个组件，而不是一个函数。</p><ul class=""><li id="b5f6" class="my mz iq lh b li lj ll lm lo na ls nb lw nc ma nd ne nf ng bi translated"><a class="ae le" href="https://medium.com/javascript-in-plain-english/functional-programming-higher-order-function-hof-aaa46bb444bb" rel="noopener">关于本主题的相关帖子</a>——函数式编程::高阶函数，HOF</li></ul><h1 id="d7de" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">常量和字母与var有什么不同？</h1><p id="e057" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">简答— <code class="fe nh ni nj nk b">const</code>和<code class="fe nh ni nj nk b">let</code>是变量声明的阻塞范围关键字。并且<code class="fe nh ni nj nk b">const</code>不允许值一旦被设置就被改变，不像<code class="fe nh ni nj nk b">let</code>那样是可能的。在现代web编程中，为了更加稳定，你通常需要使用<code class="fe nh ni nj nk b">const</code>和<code class="fe nh ni nj nk b">let</code>。</p><p id="38b5" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">详细回答——<code class="fe nh ni nj nk b">const/let</code>和<code class="fe nh ni nj nk b">var</code>的主要区别在于它们的范围。<code class="fe nh ni nj nk b">var</code>位于其周围最近的函数内，而<code class="fe nh ni nj nk b">const</code>和<code class="fe nh ni nj nk b">let</code>仅位于最近的块内(<code class="fe nh ni nj nk b">{}</code>)。对<code class="fe nh ni nj nk b">cosnt</code>和<code class="fe nh ni nj nk b">let</code>的误解之一是它们没有被吊起，这实际上并不正确。当JavaScript引擎收集变量并检查它们的变量关键字时，它将<code class="fe nh ni nj nk b">const</code>和<code class="fe nh ni nj nk b">let</code>推到上下文的一边，等待变量被赋值。这个被引擎推开关键词的区域叫做TDZ，时间死区。当你试图访问用<code class="fe nh ni nj nk b">var</code>声明的变量时，如果你没有给它赋值，它将返回<code class="fe nh ni nj nk b">undefined</code>。然而，用<code class="fe nh ni nj nk b">const</code>或<code class="fe nh ni nj nk b">let</code>声明的变量会出错。看起来好像是因为它们没有被升起，但这不是真的。这仅仅是TDZ的一个特色。更有趣的是，你不能访问在全局上下文中声明的变量，比如用<code class="fe nh ni nj nk b">const</code>声明的<code class="fe nh ni nj nk b">window.x</code>。它总会回报你的(如果你不相信我，你自己试试吧！)</p><pre class="kp kq kr ks gt nl nk nm nn aw no bi"><span id="3f4f" class="np mc iq nk b gy nq nr l ns nt">// on the global context<br/>var a = 1;<br/>let b = 2;<br/>const c = 3;</span><span id="360d" class="np mc iq nk b gy nu nr l ns nt">window.a // 1<br/>window.b // undefined<br/>window.c // undefined</span></pre><p id="8267" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是因为当JavaScript引擎初始化变量时，它不会将<code class="fe nh ni nj nk b">const</code>或<code class="fe nh ni nj nk b">let</code>变量添加到最顶层的上下文中，即<code class="fe nh ni nj nk b">window</code>。</p><ul class=""><li id="c9aa" class="my mz iq lh b li lj ll lm lo na ls nb lw nc ma nd ne nf ng bi translated"><a class="ae le" href="https://medium.com/javascript-in-plain-english/do-you-know-why-this-x-is-undefined-when-x-is-declared-with-const-or-let-8f6e00dcd490" rel="noopener">关于这个话题的相关帖子</a> —知道为什么用Const或Let声明x时this.x是未定义的吗？</li></ul><h1 id="ade3" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">结论</h1><p id="68ba" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">当然，对于JavaScript开发人员来说，还有很多面试问题——如果有机会的话，我会尽量稍后与您分享更多。但是，重要的是，至少我认为是重要的，你应该能够解释相关的故事，而不仅仅是主要概念本身，因为JavaScript有这么多不同的概念，它们都结合在一起，构成了语言的坚实结构。</p><p id="4bcd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">感谢你阅读这篇文章！</p><h1 id="2f5b" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">资源</h1><ul class=""><li id="5fc7" class="my mz iq lh b li mt ll mu lo nv ls nw lw nx ma nd ne nf ng bi translated">我在面试中的个人经历</li></ul><p id="cf3f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们总是有兴趣帮助推广高质量的内容。如果你有一篇想用简单英语提交给JavaScript的文章，用你的中级用户名发邮件到submissions@javascriptinplainenglish.com<a class="ae le" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank"><strong class="lh ja"/></a><strong class="lh ja">给我们，我们会把你添加为作者。</strong></p></div></div>    
</body>
</html>