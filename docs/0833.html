<html>
<head>
<title>How-to form submissions with Flask and AJAX</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Flask和AJAX形成提交</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-form-submissions-with-flask-and-ajax-dfde9891c620?source=collection_archive---------0-----------------------#2019-12-19">https://javascript.plainenglish.io/how-to-form-submissions-with-flask-and-ajax-dfde9891c620?source=collection_archive---------0-----------------------#2019-12-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/644b6378073d069576c5f67e2216527d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RUf5zEfBFpP5KvuFVtBatg.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Contact form with HTML5 and JS form validation and an AJAX post request.</figcaption></figure><div class=""/><div class=""><h2 id="8288" class="pw-subtitle-paragraph kc je jf bd b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dk translated">根据最新的HTML5标准和安全措施提交和验证表单，无需重新加载网页</h2></div><p id="c709" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在某种程度上，你会希望让你的web应用程序动态化，允许用户提供输入，并以安全和正确的方式进行处理。这意味着您将处理表单和表单提交，同时保持信息传输的安全性。</p><p id="361c" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在这个故事中，我将尝试向你展示如何使用异步javascript执行(AJAX)将用户输入从前端(HTML)发送到后端(Flask)，即无需重新加载网页。使用CSRF令牌可以保护这种信息传输免受恶意攻击。我还加入了一些噱头，比如HTML5表单验证和用户反馈。</p><blockquote class="lq"><p id="3bb3" class="lr ls jf bd lt lu lv lw lx ly lz lp dk translated">AJAX非常适合在同一网页上动态加载内容，而不需要重新加载，以此为指导，您可以使其安全可靠，并在整个过程中提供用户反馈。</p></blockquote><p id="5988" class="pw-post-body-paragraph ku kv jf kw b kx ma kg kz la mb kj lc ld mc lf lg lh md lj lk ll me ln lo lp ij bi translated">我们将讨论的技术堆栈是:</p><ul class=""><li id="e923" class="mf mg jf kw b kx ky la lb ld mh lh mi ll mj lp mk ml mm mn bi translated">带有引导(HTML)和物化(CSS)框架的表单</li><li id="ba4a" class="mf mg jf kw b kx mo la mp ld mq lh mr ll ms lp mk ml mm mn bi translated">Javascript和jQuery:用FormData对象提交AJAX表单</li><li id="55f1" class="mf mg jf kw b kx mo la mp ld mq lh mr ll ms lp mk ml mm mn bi translated">HTML5和JS表单验证</li><li id="5f9b" class="mf mg jf kw b kx mo la mp ld mq lh mr ll ms lp mk ml mm mn bi translated">在Flask路由上发送请求:捕捉响应并返回</li><li id="ae40" class="mf mg jf kw b kx mo la mp ld mq lh mr ll ms lp mk ml mm mn bi translated">用烧瓶保护CSRF-WTF</li></ul><p id="8865" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在这个故事中，我们将构建一个简单的联系表单，但这个架构可以扩展为更复杂的表单、文件上传或任何其他可以想象的HTTP请求。让我们开始吧，从前面(HTML)到后面(Flask)。</p><h2 id="6697" class="mt mu jf bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">前端HTML</h2><figure class="nm nn no np gt is"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Simple contact form in Flask’s jinja2 HTML template.</figcaption></figure><p id="5e7d" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这是一个简单的HTML表单，通过POST请求指向Flask后端的/contact路径。您可能还注意到在<code class="fe ns nt nu nv b">line 2</code>上有一个隐藏的输入类型，包含我们的<strong class="kw jg"> CSRF令牌</strong>，它被证明对于保护表单提交免受恶意攻击是不可或缺的。</p><p id="af2b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">众所周知的<a class="ae nw" href="https://getbootstrap.com/" rel="noopener ugc nofollow" target="_blank"> Bootstrap </a>框架用于水平划分网页上的内容，并实现了一个附加的<a class="ae nw" href="https://materializecss.com/" rel="noopener ugc nofollow" target="_blank">物化</a>框架用于样式化。这意味着不同类名的所有样式都有意义，比如<code class="fe ns nt nu nv b">input-field col s6</code>、<code class="fe ns nt nu nv b">validate</code>、<code class="fe ns nt nu nv b">helper-text</code>、<code class="fe ns nt nu nv b">waves-effect</code>和<code class="fe ns nt nu nv b">waves-light</code>，因为它们是在引导和物化框架中定义的。注意，<code class="fe ns nt nu nv b">class="&lt;element1&gt; &lt;element2&gt;"</code>之间的空格表示正在调用多个类。最后，值得注意的是<code class="fe ns nt nu nv b">line 31</code>上的提交按钮有一个<code class="fe ns nt nu nv b">id="contact-form-button"</code>，这就是我们如何<strong class="kw jg">将jQuery中的一个事件绑定到这个表单。当从前端向后端来回发送请求时，带有<code class="fe ns nt nu nv b">id="form-response"</code>的最后一个<code class="fe ns nt nu nv b">div</code>元素将显示一个预加载器，反之亦然。</strong></p><figure class="nm nn no np gt is"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Loading necessary scripts for format and styling.</figcaption></figure><p id="46f0" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">依赖关系的链接在<code class="fe ns nt nu nv b">&lt;head&gt;&lt;/head&gt;</code>标签中，脚本在<code class="fe ns nt nu nv b">{%block scripts %}{% endblock %}</code>之间，这是Flask中划分内容位置的一种很好的方式。一个通用的启发是有一个<code class="fe ns nt nu nv b">base.html</code>，它包含每一个其他HTML页面所必需的HTML代码，比如<code class="fe ns nt nu nv b">header</code>、<code class="fe ns nt nu nv b">navbar</code>和<code class="fe ns nt nu nv b">footer</code>，但也包括链接和脚本。然后，通过在HTML页面前面加上<code class="fe ns nt nu nv b">{% extends "base.html" %}</code>,您可以在每个其他HTML页面上扩展这个<code class="fe ns nt nu nv b">base.html</code>,在我们的示例联系人页面中也是这样做的。</p><blockquote class="lq"><p id="de6b" class="lr ls jf bd lt lu lv lw lx ly lz lp dk translated">一个通用的启发是有一个<code class="fe ns nt nu nv b">base.html</code>，它包含每一个其他HTML页面所必需的HTML代码。</p></blockquote><p id="791c" class="pw-post-body-paragraph ku kv jf kw b kx ma kg kz la mb kj lc ld mc lf lg lh md lj lk ll me ln lo lp ij bi translated">同样重要的是要注意，这些脚本有一个特定的<strong class="kw jg">顺序</strong>，必须按照这个顺序加载才能正常工作。我相信顺序是<code class="fe ns nt nu nv b">(1) jQuery (2) Popper (3) Bootstrap</code>。</p><figure class="nm nn no np gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nx"><img src="../Images/38117239fd11883fb2ef55df9c644acf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gsyJeHX-UAnyJ3C7daKPgw.png"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">The form’s formatting is provided by Bootstrap and Materialize.</figcaption></figure><h2 id="c6d4" class="mt mu jf bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">Javascript文件和jQuery方法</h2><p id="be64" class="pw-post-body-paragraph ku kv jf kw b kx ny kg kz la nz kj lc ld oa lf lg lh ob lj lk ll oc ln lo lp ij bi translated">我们使用Javascript文件来使用jQuery的AJAX方法。AJAX使得向我们的Flask route <code class="fe ns nt nu nv b">/contact</code>发送POST请求成为可能，而不必重新加载整个HTTP网页。这将是这个故事的核心，也是最难解释的部分。首先，我们需要在用户点击表单上的提交按钮时进行捕捉，这将通过使用它的<code class="fe ns nt nu nv b">id</code>属性和一些jQuery来实现。</p><p id="9922" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">jQuery是Javascript的包装器，本质上使它更加用户友好，可以用在。js文件与Javascript代码交织在一起。jQuery选择器<code class="fe ns nt nu nv b">$('#theID')</code>和JS选择器<code class="fe ns nt nu nv b">document.getElementById('theID')</code>之间的一个相关区别是，对于jQuery来说，普通的属性和方法是不可用的，但是jQuery特有的一组不同的方法是:<code class="fe ns nt nu nv b">$('#theID').get(0)</code>或<code class="fe ns nt nu nv b">$('#theID')[0]</code>。这种差异很重要，在这里会有更详细的解释。</p><figure class="nm nn no np gt is"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Catching user event and setting variables for AJAX form submission.</figcaption></figure><p id="46c3" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe ns nt nu nv b">$('#contact-form-button').click()</code>每当用户点击表单的提交按钮时捕捉。然后，我们设置一些变量并创建我们的FormData对象。FormData对象编译一组键/值对，通过提议的<code class="fe ns nt nu nv b">method</code>发送到<code class="fe ns nt nu nv b">url</code>。这些来自HTML表单，在表单的<code class="fe ns nt nu nv b">action</code> ( <code class="fe ns nt nu nv b">/user</code>)和<code class="fe ns nt nu nv b">method</code> ( <code class="fe ns nt nu nv b">POST</code>)属性中的<code class="fe ns nt nu nv b">contact.html</code>的<code class="fe ns nt nu nv b">line 1</code>上定义。</p><p id="c098" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">如您所见，click事件还调用了函数<code class="fe ns nt nu nv b">getContactFormData</code>，该函数在它下面定义，并使用JS DOM选择器<code class="fe ns nt nu nv b">getElementById</code>，因为我们需要内部属性:键<code class="fe ns nt nu nv b">input fields id's</code>和值<code class="fe ns nt nu nv b">text that the user typed</code>来填充我们的FormData对象，并将该信息发送到Flask route <code class="fe ns nt nu nv b">/contact</code>。使用FormData对象是自动封装用户在表单中填写的所有信息的简单方法。</p><figure class="nm nn no np gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi od"><img src="../Images/63741a4c816d406e88d62c77455a9c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6w0ASsWp1-x6XVCExJWuWg.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">AJAX form submission and HTML5 validation in action.</figcaption></figure><h2 id="9873" class="mt mu jf bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">表单验证</h2><p id="992c" class="pw-post-body-paragraph ku kv jf kw b kx ny kg kz la nz kj lc ld oa lf lg lh ob lj lk ll oc ln lo lp ij bi translated">在我们实际发送AJAX请求之前，我们将通过HTML5和JS进行一些表单验证。以黄色感叹号开头的指示<code class="fe ns nt nu nv b">Please fill out this field.</code>的消息是HTML5表单验证的一个例子，右边的消息(祝酒词)是JS表单验证。</p><figure class="nm nn no np gt is"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">HTML5 and JS form validation!</figcaption></figure><p id="10f7" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe ns nt nu nv b">form[0].checkValidity()</code>检查是否所有的<code class="fe ns nt nu nv b">required</code>表单域都已填写完毕，我们自己的函数<code class="fe ns nt nu nv b">isFormDataEmpty</code>检查FormData对象是否为非空。因为我们使用的是CSRF令牌，它包含在FormData中，所以在<code class="fe ns nt nu nv b">line 44</code>中我们跳过了FormData的<code class="fe ns nt nu nv b">csrf_token</code>键。如果所有键值对都为空，则<code class="fe ns nt nu nv b">isFormDataEmpty</code>返回<code class="fe ns nt nu nv b">true</code>，如果至少有一个非空，则<code class="fe ns nt nu nv b">false</code>返回。如果不满足<code class="fe ns nt nu nv b">line 4</code>中的任一条件，我们将不得不显示一些错误。</p><p id="468e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">HTML5表单验证是在表单的默认<code class="fe ns nt nu nv b">submit event</code>下只<strong class="kw jg"/>启用，这也会重新加载整个网页。我们想通过使用<code class="fe ns nt nu nv b">preventDefault(), line 5</code>来防止这种情况，但我们确实希望表单通过HTML5验证。这就是为什么只有在<code class="fe ns nt nu nv b">line 4</code>中确认了表单的有效性后才调用<code class="fe ns nt nu nv b">preventDefault()</code>。这样，如果表单无效，就不会阻止默认的<code class="fe ns nt nu nv b">submit event</code>，并且可以向用户显示HTML5表单验证。</p><blockquote class="lq"><p id="1afd" class="lr ls jf bd lt lu lv lw lx ly lz lp dk translated">HTML5表单验证是在表单的默认<code class="fe ns nt nu nv b">submit event</code>下只<strong class="ak">启用</strong>，这也会重新加载整个网页。</p></blockquote><p id="0598" class="pw-post-body-paragraph ku kv jf kw b kx ma kg kz la mb kj lc ld mc lf lg lh md lj lk ll me ln lo lp ij bi translated"><code class="fe ns nt nu nv b">lines 12 until 20</code>将为每个有标签的表单域创建一个方法<code class="fe ns nt nu nv b">.label</code>，例如<code class="fe ns nt nu nv b">line 6</code>为名字，<code class="fe ns nt nu nv b">line 11</code>为姓氏。然后，这个方法可以在所有具有<code class="fe ns nt nu nv b">invalid</code>类的项目上调用。该<code class="fe ns nt nu nv b">invalid</code>类被附加到用户在调用<code class="fe ns nt nu nv b">form[0].checkValidity() in line 4</code>时无效填写的每个表单字段中(例如，是<code class="fe ns nt nu nv b">required</code>但未填写或有<code class="fe ns nt nu nv b">pattern</code>要求未满足)。</p><p id="e54f" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">然后我们可以显示一条错误消息，一条<a class="ae nw" href="https://materializecss.com/toasts.html" rel="noopener ugc nofollow" target="_blank"> toast </a>，通过物化框架显示哪个表单字段无效，要求用户<code class="fe ns nt nu nv b">please fill out the &lt;label of class invalid input field&gt;</code>。在我们的联系表单中，所有的表单字段都是必填的，但是没有一个字段被填写，这就是为什么会出现四条错误消息的原因。如果出现其他问题，我们可以显示一般的错误消息:</p><pre class="nm nn no np gt oe nv of og aw oh bi"><span id="fe3b" class="mt mu jf nv b gy oi oj l ok ol">M.toast({html: "Another error occured, please try again.", classes: 'bg-danger text-white'});</span></pre><p id="1b9c" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe ns nt nu nv b">M.toast()</code>接受多个参数，包括<code class="fe ns nt nu nv b">html</code>，它是要返回的文本，还有<code class="fe ns nt nu nv b">classes</code>，它们在Materialize和Bootstrap中再次定义:类<code class="fe ns nt nu nv b">bg-danger</code>给出红色背景，类<code class="fe ns nt nu nv b">text-white</code>，使(呃)文本变成白色。</p><h2 id="e134" class="mt mu jf bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">AJAX请求</h2><p id="c93b" class="pw-post-body-paragraph ku kv jf kw b kx ny kg kz la nz kj lc ld oa lf lg lh ob lj lk ll oc ln lo lp ij bi translated">这就是神奇的地方:通过表单提交发送用户输入，而无需重新加载网页，也不会丢失所有已填写的信息！在这一点上，注意到目前为止我们通过不同JS函数的流程是:</p><p id="42a5" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe ns nt nu nv b">(1) catching the click event -&gt; (2) send_form() with modular_ajax (a function) as an argument -&gt; (3) calling inner_ajax()</code></p><p id="465b" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">本例中的<code class="fe ns nt nu nv b">inner_ajax()</code>是在<code class="fe ns nt nu nv b">send_form()</code>中作为参数发送的<code class="fe ns nt nu nv b">modular_ajax()</code>作为<code class="fe ns nt nu nv b">4th argument</code>。</p><figure class="nm nn no np gt is"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">23AJAX function.</figcaption></figure><p id="9207" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe ns nt nu nv b">url</code>是<code class="fe ns nt nu nv b">/contact</code>，信息要去的Flask route，数据是<code class="fe ns nt nu nv b">type</code> <code class="fe ns nt nu nv b">POST</code>和formData对象。表单数据对象不应被处理(<code class="fe ns nt nu nv b">processData</code>)并且已经被转换，因此不需要<code class="fe ns nt nu nv b">contentType</code>。AJAX函数的流程如下:</p><ol class=""><li id="c7c2" class="mf mg jf kw b kx ky la lb ld mh lh mi ll mj lp om ml mm mn bi translated"><code class="fe ns nt nu nv b">beforeSend:</code>在发送AJAX请求之前执行。在这种情况下，我们希望显示一个<a class="ae nw" href="https://materializecss.com/preloader.html" rel="noopener ugc nofollow" target="_blank">物化</a>不确定预加载器，表明我们正在处理请求。</li><li id="5058" class="mf mg jf kw b kx mo la mp ld mq lh mr ll ms lp om ml mm mn bi translated">一旦AJAX函数完成了它的动作:我们想要删除预加载程序。</li><li id="50e4" class="mf mg jf kw b kx mo la mp ld mq lh mr ll ms lp om ml mm mn bi translated"><code class="fe ns nt nu nv b">success:</code>如果有响应，将<code class="fe ns nt nu nv b">data</code>作为参数。在这种情况下，我们想用<code class="fe ns nt nu nv b">!$.trim(data.feedback)</code>检查响应是否为空(例如<code class="fe ns nt nu nv b">''</code>)。</li><li id="ee22" class="mf mg jf kw b kx mo la mp ld mq lh mr ll ms lp om ml mm mn bi translated"><code class="fe ns nt nu nv b">error:</code>如果没有响应，将<code class="fe ns nt nu nv b">xhr</code> (XMLHttpRequest)作为参数，该对象包含请求的所有元数据(例如错误，我们在<a class="ae nw" href="https://developers.google.com/web/tools/chrome-devtools/console" rel="noopener ugc nofollow" target="_blank">浏览器控制台</a>中显示)。</li><li id="766f" class="mf mg jf kw b kx mo la mp ld mq lh mr ll ms lp om ml mm mn bi translated"><code class="fe ns nt nu nv b">.done()</code>当整个<code class="fe ns nt nu nv b">.ajax({})</code>功能执行完毕。我们总是给用户反馈，用<code class="fe ns nt nu nv b">toast_error_msg</code>和<code class="fe ns nt nu nv b">toast_category</code>中消息的颜色来指示AJAX请求是否成功。</li></ol><p id="3445" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><code class="fe ns nt nu nv b">success:</code>函数将<code class="fe ns nt nu nv b">data</code>作为一个参数，它包含<code class="fe ns nt nu nv b">feedback</code>和<code class="fe ns nt nu nv b">category</code>，但是它也可以包含另一个元素<code class="fe ns nt nu nv b">&lt;results&gt;</code>，该元素包含您想要在HTML表单中显示的数据。例如在<code class="fe ns nt nu nv b">&lt;div id="form-response"&gt;&lt;/div&gt;, html.form line 35</code>中，下面的代码<code class="fe ns nt nu nv b">$('#form-response').html(data.results)</code>在<code class="fe ns nt nu nv b">line 22–24, ajax.js</code>之间。名称<code class="fe ns nt nu nv b">feedback</code>和<code class="fe ns nt nu nv b">category</code>在我们的Flask后端中定义，我们也在这里用内容填充这些键。</p><p id="6403" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们现在来看看接收AJAX请求的Flask route，在那里我们可以对用户填写的元素做些什么，比如将它保存在数据库中或发送电子邮件。</p><h2 id="037b" class="mt mu jf bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">烧瓶路线</h2><figure class="nm nn no np gt is"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Flask backend code.</figcaption></figure><p id="18d4" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在我们的Flask应用程序中，有一个路由<code class="fe ns nt nu nv b">/contact</code>接受<code class="fe ns nt nu nv b">GET</code>请求(用于查看联系表单)和用户填写联系表单时的<code class="fe ns nt nu nv b">POST</code>请求。请求通过<code class="fe ns nt nu nv b">request.form</code>传入，它的键是表单<code class="fe ns nt nu nv b">contact.html</code>的<code class="fe ns nt nu nv b">input</code>元素的<code class="fe ns nt nu nv b">id=""</code>。因此，我们的联系人表单的名字输入字段request.form的键是<code class="fe ns nt nu nv b">id="first-name", contact.html line 7</code>，并通过<code class="fe ns nt nu nv b">request.form['first-name'], app.py line 18</code>访问。</p><p id="c743" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在这种情况下，我们发送一封电子邮件，内容是用户使用<a class="ae nw" href="https://pythonhosted.org/Flask-Mail/" rel="noopener ugc nofollow" target="_blank"> flask-mail </a>在我们的联系表单中填写的。无论邮件是否发送，我们总是向用户返回反馈。<code class="fe ns nt nu nv b">resp, line 30</code>是包含在<code class="fe ns nt nu nv b">ajax.js, line 23-24</code>中提取的<code class="fe ns nt nu nv b">feedback</code>(文本)和<code class="fe ns nt nu nv b">category</code>(颜色)键的字典。我们需要用<code class="fe ns nt nu nv b">jsonify()</code>将这个字典转换成JSON数组，然后使用Flask的<code class="fe ns nt nu nv b">make_response</code>发送那个响应对象。就是这样！我们使用AJAX请求将用户输入从前端发送到后端，并在Flask route <code class="fe ns nt nu nv b">/contact</code>中捕获该请求。</p><p id="3c39" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">接下来，我们将研究<strong class="kw jg">保护</strong>前端到后端的信息传输免受恶意攻击。</p><h2 id="16e1" class="mt mu jf bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">使用烧瓶保护CSRF-WTF</h2><p id="b708" class="pw-post-body-paragraph ku kv jf kw b kx ny kg kz la nz kj lc ld oa lf lg lh ob lj lk ll oc ln lo lp ij bi translated"><a class="ae nw" href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html" rel="noopener ugc nofollow" target="_blank">跨站点请求伪造</a>是一种攻击，当用户通过身份验证后，恶意网站、电子邮件、博客、即时消息或程序会导致用户的web浏览器在受信任的站点上执行不必要的操作。对于大多数提交表单，用户需要登录或验证(比如更新数据库值或更改密码)。但是，如果用户通过了站点的身份验证，站点就无法再区分合法请求或伪造请求。这是因为所有的身份验证凭证(如会话变量)都已经包含在请求中。因此，需要另一个标识符，它由后端应用程序设置，随每个请求一起发送，并由后端应用程序再次验证:所谓的<code class="fe ns nt nu nv b">X-CRSFToken</code>头。</p><p id="f3bd" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">为了防止跨站点请求伪造的信息传输，我们在我们的<code class="fe ns nt nu nv b">form.html, line 2</code>中添加了一个<code class="fe ns nt nu nv b">&lt;input type="hidden" name="csrf_token" value="{{ csrf_token() }}"/&gt;</code>。<code class="fe ns nt nu nv b">{{ csrf_token() }}</code>是一个被<code class="fe ns nt nu nv b">render_template(), app.py line 35</code>理解的Jinja2语法表达式。这个字符串令牌是在<code class="fe ns nt nu nv b">csrf_token()</code>中生成的，Flask-WTF的一个方法。Flask-WTF是流行的<a class="ae nw" href="https://wtforms.readthedocs.io/en/stable/" rel="noopener ugc nofollow" target="_blank"> WTForms </a>的包装器。他们有一份非常好的CSRF保护流程文档<a class="ae nw" href="https://flask-wtf.readthedocs.io/en/stable/csrf.html" rel="noopener ugc nofollow" target="_blank">在这里</a>。</p><figure class="nm nn no np gt is"><div class="bz fp l di"><div class="nq nr l"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Using CSRF protection for our AJAX requests.</figcaption></figure><p id="b6ae" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们需要使用<code class="fe ns nt nu nv b">$.ajaxSetup({})</code>将上面的代码添加到每个AJAX请求的设置中。我们只需要使用<code class="fe ns nt nu nv b">$.ajaxSetup({})</code>一次，因为它会为每个AJAX请求初始化并运行这段代码。在<code class="fe ns nt nu nv b">$.ajaxSetup({})</code>中，我们将<code class="fe ns nt nu nv b">csrf_token</code>附加到XMLHttpRequest头<code class="fe ns nt nu nv b">"X-CSRFToken"</code>中的每个请求。这就是浏览器如何理解请求来自我们的应用程序，而不是任何其他网站。然后在我们的应用程序中使用Flask-WTF验证这一点，并在我们的<code class="fe ns nt nu nv b">app.py</code>中使用以下代码。</p><pre class="nm nn no np gt oe nv of og aw oh bi"><span id="4afd" class="mt mu jf nv b gy oi oj l ok ol"><strong class="nv jg">from</strong> flask_wtf.csrf <strong class="nv jg">import</strong> CSRFProtect<br/><br/>csrf = CSRFProtect<strong class="nv jg">(</strong>app<strong class="nv jg">)</strong></span></pre><h2 id="36fb" class="mt mu jf bd mv mw mx dn my mz na dp nb ld nc nd ne lh nf ng nh ll ni nj nk nl bi translated">结论</h2><figure class="nm nn no np gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi od"><img src="../Images/63741a4c816d406e88d62c77455a9c4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*6w0ASsWp1-x6XVCExJWuWg.gif"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">AJAX form submission and HTML5 validation in action.</figcaption></figure><p id="305e" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在这个故事中，我向您展示了如何使用Bootstrap HTML和Materialize CSS框架构建一个简单的联系人表单，如何将jQuery事件绑定到submit按钮，如何用HTML5和JS验证表单，如何用FormData对象发送AJAX请求，如何在Flask route中捕获请求并向AJAX返回响应，同时保护它不受CSRF攻击。</p><p id="a764" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">AJAX非常适合在同一网页上动态加载内容，而不需要重新加载。有了它，你就可以让它变得安全可靠，并随时向用户提供反馈。不要犹豫，问我一个问题或评论这个故事。</p><p id="24ef" class="pw-post-body-paragraph ku kv jf kw b kx ky kg kz la lb kj lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated"><strong class="kw jg">免责声明</strong>:正如<a class="ae nw" href="https://www.reddit.com/r/flask/comments/edqpvx/howto_form_submissions_with_flask_and_ajax/" rel="noopener ugc nofollow" target="_blank"> Redditors </a>指出的，这个故事使用了jQuery选择器<code class="fe ns nt nu nv b">$('#theID').get(0)</code>或<code class="fe ns nt nu nv b">$('#theID')[0]</code>和JS选择器<code class="fe ns nt nu nv b">document.getElementById('theID')</code>的杂波，它们返回相同的结果。虽然我没有意识到，可以通过简单的<code class="fe ns nt nu nv b">XMLHttpRequest</code>或<code class="fe ns nt nu nv b">fetch() API</code>动态加载内容，消除jQuery的依赖性。即将到来的Bootstrap5可能会用原生(普通)JS替换jQuery，这是一个好的开始。无论哪种方式，最好始终坚持一种方法:jQuery或vanilla JS。</p></div></div>    
</body>
</html>