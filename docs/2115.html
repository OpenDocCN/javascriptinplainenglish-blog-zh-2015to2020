<html>
<head>
<title>When and why you should use a Map instead of an Object in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中何时以及为什么应该使用地图而不是对象</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/when-and-why-you-should-use-a-map-instead-of-an-object-in-javascript-6c345028b3ca?source=collection_archive---------0-----------------------#2020-05-21">https://javascript.plainenglish.io/when-and-why-you-should-use-a-map-instead-of-an-object-in-javascript-6c345028b3ca?source=collection_archive---------0-----------------------#2020-05-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/2567a93e72e5356ea041342620f3c6a4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*46jxRgyk9Alw53LeeQX53g.jpeg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@zekedrone?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Martin Sanchez</a> on <a class="ae kc" href="https://unsplash.com/s/photos/parking-spots?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="dbbe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">映射是一种经典的数据结构，其中数据以键/值对的形式存储:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="6a4f" class="lk ll iq lg b gy lm ln l lo lp">const map = new Map();<br/>map.set('key', 'value'); // Map(1) {"key" =&gt; "value"}<br/>map.get('key'); // 'value'</span></pre><p id="33f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript对象是属性的集合，属性是一个键/值对:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="58bd" class="lk ll iq lg b gy lm ln l lo lp">const someObject = {};<br/>someObject.key = 'value';<br/>someObject.key; // 'value'</span></pre><p id="862d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">定义和行为非常接近，以至于令人困惑。更令人困惑的是，地图是ES6的附加功能，所以很长时间以来，除了使用对象来实现类似地图的行为之外，没有其他解决方案。那么为什么现在要费心使用地图，而不是坚持使用传统的JavaScript对象呢？</p><h1 id="b93b" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">键的类型</h1><p id="5160" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">JavaScript对象只接受两种类型的键:字符串和符号。您可以使用anothe类型的键，但是JavaScript会隐式地将其转换为字符串:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8562" class="lk ll iq lg b gy lm ln l lo lp">const object = { };<br/>object[true] = 'value';<br/>object[1] = 'value';<br/>object[{'key': 'value'}] = 'value';</span><span id="32ec" class="lk ll iq lg b gy ms ln l lo lp">Object.keys(object); // ["1", "true", "[object Object]"]</span></pre><p id="a808" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，map将接受任何类型的键，并将保留键类型。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2cc4" class="lk ll iq lg b gy lm ln l lo lp">const map = new Map();<br/>map.set(1, 'value');<br/>map.set(true, 'value');<br/>map.set({'key': 'value'}, 'value');</span><span id="f813" class="lk ll iq lg b gy ms ln l lo lp">for (const key of map.keys()) {<br/>  console.log(key);<br/>}<br/>// 1<br/>// true<br/>// {key: "value"}</span></pre><h1 id="d869" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">原型字段</h1><p id="b61b" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">与地图不同，物体不仅仅是你所看到的。虽然映射只包含您定义的键/值对，但对象带有一些来自其原型的内置属性:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="9704" class="lk ll iq lg b gy lm ln l lo lp">const newObject = {};<br/>newObject.constructor; // ƒ Object() { [native code] }</span></pre><p id="ce78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当你没有正确地迭代你的对象属性时，它会导致问题。它还会产生有趣的错误:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="eacf" class="lk ll iq lg b gy lm ln l lo lp">const countWords = (words) =&gt; {<br/>  const counts = { };<br/>  for (const word of words) {<br/>    counts[word] = (counts[word] || 0) + 1;<br/>  }<br/>  return counts;<br/>};</span><span id="4e4c" class="lk ll iq lg b gy ms ln l lo lp">const counts = countWords(['constructor', 'creates', 'a', 'bug']);</span><span id="6d85" class="lk ll iq lg b gy ms ln l lo lp">/* {constructor: "function Object() { [native code] }1", creates: 1, a: 1, bug: 1} */</span></pre><p id="0e62" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">(这个例子的灵感来自丹·范德卡姆的《有效打字稿》一书)</p><h1 id="fcd9" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">循环</h1><p id="8376" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">地图是可迭代的，可以直接迭代。例如，您可以在地图上使用<code class="fe mt mu mv lg b">forEach</code>循环:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b502" class="lk ll iq lg b gy lm ln l lo lp">const map = new Map();<br/>map.set('key1', 'value1');<br/>map.set('key2', 'value2');<br/>map.set('key3', 'value3');</span><span id="fd82" class="lk ll iq lg b gy ms ln l lo lp">map.forEach((value, key) =&gt; {<br/>  console.log(key, value);<br/>});</span><span id="21ac" class="lk ll iq lg b gy ms ln l lo lp">// key1 value1<br/>// key2 value2<br/>// key3 value3</span></pre><p id="4789" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者直接进入<code class="fe mt mu mv lg b">for ... of ...</code>循环:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="2035" class="lk ll iq lg b gy lm ln l lo lp">for(const entry of map) {<br/>  console.log(entry);<br/>}</span><span id="144c" class="lk ll iq lg b gy ms ln l lo lp">// ["key1", "value1"]<br/>// ["key2", "value2"]<br/>// ["key3", "value3"]</span></pre><p id="9669" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，对象不是直接可迭代的。尝试迭代一个会导致错误:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="bfb4" class="lk ll iq lg b gy lm ln l lo lp">const object = {<br/>  key1: 'value1',<br/>  key2: 'value2',<br/>  key3: 'value3',<br/>};</span><span id="cf0c" class="lk ll iq lg b gy ms ln l lo lp">for(const entry of object) {<br/>  console.log(entry);<br/>}</span><span id="0a6a" class="lk ll iq lg b gy ms ln l lo lp">// Uncaught TypeError: object is not iterable</span></pre><p id="b775" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您需要一个额外的步骤来检索它的键、值或条目:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="e292" class="lk ll iq lg b gy lm ln l lo lp">for(const key of Object.keys(object)) {<br/>  console.log(key);<br/>}</span><span id="fab8" class="lk ll iq lg b gy ms ln l lo lp">// key1<br/>// key2<br/>// key3</span><span id="ac7c" class="lk ll iq lg b gy ms ln l lo lp"><br/>for(const value of Object.values(object)) {<br/>  console.log(value);<br/>}</span><span id="078b" class="lk ll iq lg b gy ms ln l lo lp">// value1<br/>// value2<br/>// value3</span><span id="814a" class="lk ll iq lg b gy ms ln l lo lp"><br/>for(const entry of Object.entries(object)) {<br/>  console.log(entry);<br/>}</span><span id="0bd0" class="lk ll iq lg b gy ms ln l lo lp">// ["key1", "value1"]<br/>// ["key2", "value2"]<br/>// ["key3", "value3"]</span></pre><p id="8dcd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你也可以在一个对象上使用<code class="fe mt mu mv lg b">for ... in ...</code>循环来迭代它的键:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="0341" class="lk ll iq lg b gy lm ln l lo lp">for(const key in object) {<br/>  console.log(key);<br/>}</span><span id="46b4" class="lk ll iq lg b gy ms ln l lo lp">// key1<br/>// key2<br/>// key3</span></pre><h1 id="e755" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">元素顺序和大小</h1><p id="1dd7" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">一个地图保持跟踪它的大小，使它在O(1)中可访问。</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="a1a4" class="lk ll iq lg b gy lm ln l lo lp">const map = new Map();<br/>map.set('key1', 'value1');<br/>map.set('key2', 'value2');<br/>map.set('key3', 'value3');</span><span id="65a9" class="lk ll iq lg b gy ms ln l lo lp">map.size; // 3</span></pre><p id="c131" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要得到一个对象的属性数，你需要手工迭代它，使它为O(n ), n是属性数。</p><p id="7ae9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">地图也保持键的顺序。正如您在前面的例子中所看到的，遍历一个map会按照插入的顺序返回键。对于对象来说，情况并非如此。从ES6开始，字符串和符号键以正确的顺序保留，但JavaScript转换为字符串的其他类型的键则不是这样:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="132b" class="lk ll iq lg b gy lm ln l lo lp">const object = { };<br/>object['key1'] = 'value1';<br/>object['key0'] = 'value0';<br/>object; // {key1: "value1", key0: "value0"}</span><span id="1155" class="lk ll iq lg b gy ms ln l lo lp">object[20] = 'value20';<br/>object; // {20: "value20", key1: "value1", key0: "value0"}</span></pre></div><div class="ab cl mw mx hu my" role="separator"><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb nc"/><span class="mz bw bk na nb"/></div><div class="ij ik il im in"><p id="8261" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们是对象和贴图之间的基本区别，在决定使用什么来解决您的问题时，您需要考虑这些区别。如果您需要使用字符串和符号以外的其他类型的键，那么映射就是解决方案。</p><p id="b0d9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您需要迭代条目，尤其是如果顺序很重要，那么映射也是需要认真考虑的。地图在大集合和频繁的添加和删除上通常也更有性能，所以如果没有什么违背它的话，最好选择地图。</p><p id="d6a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，如果您正在处理少量的属性，一个对象可能就足够了，尤其是当您需要在JSON之间进行转换时。因为映射键可以是任何类型，所以没有将它们转换成JSON的本地方法。如果你需要给它添加逻辑(方法)，那么一个对象是最好的选择。</p><h1 id="ef2c" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">简明英语团队的一份说明</strong></h1><p id="2b22" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个关注来表达爱意:<a class="ae kc" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kf ir">JavaScript in Plain English</strong></a><a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！</p><p id="205f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还推出了一个YouTube，希望你能通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的简明英语频道</strong> </a>来支持我们</p><p id="8a95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往,“简明英语”希望帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>