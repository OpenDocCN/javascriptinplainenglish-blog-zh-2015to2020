<html>
<head>
<title>Cluster Location-based Data Using K-Means Algorithm in Node.js + React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js + React中使用K-Means算法对基于位置的数据进行聚类</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/cluster-location-based-data-using-k-means-algorithm-in-node-js-and-react-d92fc425dc55?source=collection_archive---------2-----------------------#2020-05-29">https://javascript.plainenglish.io/cluster-location-based-data-using-k-means-algorithm-in-node-js-and-react-d92fc425dc55?source=collection_archive---------2-----------------------#2020-05-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="110c" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">地面运输管理实例实用指南</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/0759a82bda9f265ccb29c71588f72e1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yw3pOG7dhjud5dQDjmR-ZQ.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture by <a class="ae ks" href="https://www.pexels.com/id-id/@aksonsat-uanthoeng-393797?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Aksonsat Uanthoeng </a>from <a class="ae ks" href="https://www.pexels.com/id-id/foto/bayangan-berbayang-berfokus-berkonsentrasi-1078850/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><h1 id="fcde" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">订单分配问题</h1><p id="9cb4" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我的客户经营一家地面运输公司，该公司从客户的仓库接收货运订单，用卡车将货物运送到目的地。每天，调度员必须给司机分配装运订单。首先，他必须仔细地将订单分组到相邻的目的地。然后，他将分组后的订单分配给司机，以便司机只交付彼此距离较近的订单。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mh"><img src="../Images/19c18322247661c865c79ac01d2f967c.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*Oas2e-Fn6-apNseW6R2Rlg.jpeg"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Dispatcher assigns orders to drivers</figcaption></figure><p id="18b1" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">当调度员必须处理大量的装运订单时，这就成了一个问题。手动将订单分组并逐个分配给司机会非常复杂。</p></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="ea5d" class="kt ku in bd kv kw mu ky kz la mv lc ld jt mw ju lf jw mx jx lh jz my ka lj lk bi translated">k-均值算法</h1><p id="24b1" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">K-Means算法是一种聚类算法，用于将大量观察值划分为聚类，其中每个观察值属于具有最近均值的聚类。这个算法如何工作的细节是<a class="ae ks" href="https://en.wikipedia.org/wiki/K-means_clustering" rel="noopener ugc nofollow" target="_blank">这里是</a>。</p><p id="49fb" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">K-means以<strong class="ln io">两个变量</strong>作为输入。第一个变量是我们想要聚集的观察值。第二个变量是集群的大小，也就是我们想要创建的集群的数量。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mz"><img src="../Images/d99b6e165c57c9558dbef49e2688c3a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rG1Sqm7PYVsIH32AcM6-Zw.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Inputs for K-Means Algorithm</figcaption></figure></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="f61d" class="kt ku in bd kv kw mu ky kz la mv lc ld jt mw ju lf jw mx jx lh jz my ka lj lk bi translated">k-表示使用node-kmeans在Node.js中实现</h1><p id="e765" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我们将使用Node.js构建一个API REST服务器，并使用K-Means算法创建一个函数来对我们的观察值进行聚类。我们可以使用一个名为<strong class="ln io"> node-kmeans </strong>的库。你可以在这里了解更多关于库<a class="ae ks" href="https://www.npmjs.com/package/node-kmeans" rel="noopener ugc nofollow" target="_blank">的信息。</a></p><p id="3e17" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">在我们的例子中，调度员必须安排的装运订单包含目的地的经度<strong class="ln io">和纬度<strong class="ln io">信息。我们将把这一信息视为第一个变量。调度员必须将装运订单分配给的司机数量是我们的第二个变量。</strong></strong></p><p id="dda3" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">因此，如果有八个有三个司机的装运订单，那么订单中的<strong class="ln io">经度和纬度将是观察值<strong class="ln io">(第一个变量)</strong>，而<strong class="ln io">司机的数量</strong>将是聚类的大小<strong class="ln io">(第二个变量)</strong>。</strong></p><p id="2023" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">K-Means将订单分为三组。每个组可能包含不同数量的订单，但我们可以确定同一组中订单的目的地位置彼此接近。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi na"><img src="../Images/369bbbac22dc02d1f3be0c05f2b7767b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bPQfMjrKr0GCUYxq4G_m3g.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Illustration of clustering orders using K-Means Algorithm. <strong class="bd nb">Step 1 </strong>: Dispatcher selects orders that he wants to ship. <strong class="bd nb">Step 2 </strong>: K-Means Algorithm clusters the orders based on longitude and latitude of destination of the orders. <strong class="bd nb">Step 3</strong> : Orders are assigned to the drivers. The orders assigned to a driver are close to each other.</figcaption></figure></div><div class="ab cl mn mo hr mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="ig ih ii ij ik"><h1 id="d7f9" class="kt ku in bd kv kw mu ky kz la mv lc ld jt mw ju lf jw mx jx lh jz my ka lj lk bi translated">我们要建造什么</h1><p id="39fe" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我们将创建两个应用程序:</p><ul class=""><li id="37c8" class="nc nd in ln b lo mi lr mj lu ne ly nf mc ng mg nh ni nj nk bi translated"><strong class="ln io"> Node.js API服务器</strong>。这个API服务器将包含实现K-Means算法<strong class="ln io">的函数。</strong></li><li id="f476" class="nc nd in ln b lo nl lr nm lu nn ly no mc np mg nh ni nj nk bi translated"><strong class="ln io"> React web应用</strong>。这将是我们发送装运订单和驱动程序的用户界面</li></ul><h2 id="06a4" class="nq ku in bd kv nr ns dn kz nt nu dp ld lu nv nw lf ly nx ny lh mc nz oa lj ob bi translated">我们开始吧</h2><p id="3797" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">首先，为我们的Node.js <em class="og"> </em> API服务器创建一个名为<code class="fe oc od oe of b">api</code>的空文件夹。在<code class="fe oc od oe of b">api</code>文件夹中，创建一个<code class="fe oc od oe of b">package.json</code>文件，如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">File: package.json</figcaption></figure><p id="f5aa" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">在<code class="fe oc od oe of b">api</code>文件夹中，使用<strong class="ln io">命令提示符</strong> <em class="og"> </em>或<strong class="ln io">终端</strong>键入以下内容:</p><pre class="kd ke kf kg gt oj of ok ol aw om bi"><span id="1bbe" class="nq ku in of b gy on oo l op oq">npm install</span></pre><p id="9fd7" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">它会将所有需要的依赖项安装到<code class="fe oc od oe of b">node_modules</code>文件夹中。在<code class="fe oc od oe of b">api</code>文件夹中，创建如下三个文件<code class="fe oc od oe of b">server.js, index.js,</code>和<code class="fe oc od oe of b">apis.js</code> <em class="og"> </em>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">File: server.js</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">File: index.js</figcaption></figure><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">File: apis.js</figcaption></figure><p id="587e" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated"><code class="fe oc od oe of b">Server.js</code>是我们的基础文件，<code class="fe oc od oe of b">index.js</code>和<code class="fe oc od oe of b">apis.js</code>分别是我们注册函数和函数实现的文件。</p><h2 id="b639" class="nq ku in bd kv nr ns dn kz nt nu dp ld lu nv nw lf ly nx ny lh mc nz oa lj ob bi translated">创建一个测试函数</h2><p id="dc4b" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我们在<code class="fe oc od oe of b">apis.js</code> <em class="og"> </em>中创建一个测试函数叫做<em class="og"> </em> <code class="fe oc od oe of b">groupOrders</code> <em class="og">。</em>这是一个简单的函数，用于测试我们的K-Means算法，以了解<strong class="ln io">节点kmeans </strong>如何工作以及输出会是什么样子。它将<code class="fe oc od oe of b">orders</code>变量(<strong class="ln io">作为我们的观测值</strong>)和<code class="fe oc od oe of b">size</code>变量(<strong class="ln io">作为聚类的大小</strong>)作为输入。这些变量采用JSON格式，如下例所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">File: orders_and_size.json</figcaption></figure><p id="d1ef" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated"><code class="fe oc od oe of b">order_id, order_date, sender_name, sender_full_address, recipient_name, recipient_full_address</code>是订单发送方和接收方的基本信息。包含要发送的项目的数组。<code class="fe oc od oe of b">Longitude_from</code>和<code class="fe oc od oe of b">latitude_from</code>是起点仓库的坐标，而<code class="fe oc od oe of b">longitude_to</code> <em class="og"> </em>和<code class="fe oc od oe of b">latitude_to</code>是订单目的地的坐标。</p><p id="1c6c" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">为了测试我们的功能，我们可以使用像<strong class="ln io"> Postman </strong>这样的工具作为我们API服务器的客户端。你可以在这里免费下载<strong class="ln io">邮差</strong><a class="ae ks" href="https://www.postman.com/downloads/" rel="noopener ugc nofollow" target="_blank">。接下来，我们需要运行Node.js API服务器。在<code class="fe oc od oe of b">api</code>文件夹中，在<strong class="ln io">命令提示符</strong>或<strong class="ln io">终端中，键入</strong>如下<strong class="ln io"> : </strong></a></p><pre class="kd ke kf kg gt oj of ok ol aw om bi"><span id="2886" class="nq ku in of b gy on oo l op oq">node server.js</span></pre><p id="c7f6" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">我们的API服务器现在运行在端口1338上。使用<strong class="ln io"> Postman </strong>，创建一个新的API调用<code class="fe oc od oe of b">groupOrders</code>函数，如下图:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi or"><img src="../Images/292289499f9be004efbabf097caae793.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-4WDPjaDi2NhmEFNA7Eheg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Call the <em class="os">groupOrders</em> function using Postman</figcaption></figure><p id="d8b2" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">使用<strong class="ln io"> Postman </strong>调用函数的步骤如下:</p><ol class=""><li id="481a" class="nc nd in ln b lo mi lr mj lu ne ly nf mc ng mg ot ni nj nk bi translated">创建新请求。</li><li id="2778" class="nc nd in ln b lo nl lr nm lu nn ly no mc np mg ot ni nj nk bi translated">选择<strong class="ln io">发布</strong>作为方法。</li><li id="57cb" class="nc nd in ln b lo nl lr nm lu nn ly no mc np mg ot ni nj nk bi translated">在地址字段中，键入<a class="ae ks" href="http://localhost:3000/grouporders" rel="noopener ugc nofollow" target="_blank">http://localhost:1338/group orders</a></li><li id="7b75" class="nc nd in ln b lo nl lr nm lu nn ly no mc np mg ot ni nj nk bi translated">选择<strong class="ln io">正文</strong>并选择<strong class="ln io"> raw </strong>开始创建正文消息。</li><li id="6070" class="nc nd in ln b lo nl lr nm lu nn ly no mc np mg ot ni nj nk bi translated">选择<strong class="ln io"> JSON </strong>作为正文消息的格式。</li><li id="9ba3" class="nc nd in ln b lo nl lr nm lu nn ly no mc np mg ot ni nj nk bi translated">将<strong class="ln io"> orders_and_size.json </strong>复制粘贴到正文内容中。</li><li id="35ad" class="nc nd in ln b lo nl lr nm lu nn ly no mc np mg ot ni nj nk bi translated">点击<strong class="ln io">发送</strong>按钮，向<code class="fe oc od oe of b">groupOrders</code>功能发送请求。</li></ol><p id="35a9" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">我们的API调用的输出如下所示:</p><pre class="kd ke kf kg gt oj of ok ol aw om bi"><span id="e69e" class="nq ku in of b gy on oo l op oq">[ <br/> {<br/>   “centroid”: [<br/>        106.924981,<br/>        -6.3214015<br/>   ],<br/>   “cluster”: [<br/>        [<br/>          106.92533,<br/>          -6.321741<br/>        ],<br/>        [<br/>          106.924632,<br/>          -6.321062<br/>        ]<br/>   ],<br/>   “clusterInd”: [<br/>          1,<br/>          2<br/>   ]<br/> },<br/> {<br/>   “centroid”: [<br/>        106.931853,<br/>        -6.322157<br/>   ],<br/>   “cluster”: [<br/>        [<br/>          106.931853,<br/>          -6.322157<br/>        ]<br/>   ],<br/>   “clusterInd”: [<br/>        0<br/>   ]<br/> }<br/>]</span></pre><p id="1dae" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">如果我们查看上面的输出，我们会看到<strong class="ln io">节点——k means</strong>创建了两个集群——由两个<strong class="ln io">质心值——T33表示，因为我们的<code class="fe oc od oe of b">size</code>输入是2。质心是位于聚类中心的数据点。第一个群包含由“clusterInd 1和2”指示的订单“002”和订单“003”。第二个群集仅包含单个订单“001”。</strong></p><p id="3107" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">在接下来的部分中，我们将创建我们的主函数和用户界面应用程序来访问我们的API服务器。</p><h2 id="c06d" class="nq ku in bd kv nr ns dn kz nt nu dp ld lu nv nw lf ly nx ny lh mc nz oa lj ob bi translated">创建主要功能</h2><p id="48fc" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">让我们通过添加一个名为<code class="fe oc od oe of b">assignDrivers</code>的新函数来修改<code class="fe oc od oe of b">apis.js</code>文件，如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">File: modified_apis.js</figcaption></figure><p id="f56e" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated"><code class="fe oc od oe of b">assignDrivers</code>函数是我们的主要函数，它将使用K-Means算法对订单进行聚类，然后将订单自动分配给司机。</p><p id="dafd" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">该函数将两个变量作为输入。第一个变量是<code class="fe oc od oe of b">orders</code> <em class="og"> </em>，与<code class="fe oc od oe of b">groupOrders</code>函数中的格式相同。第二个变量是<code class="fe oc od oe of b">drivers</code>，它包含来自所有驱动程序的信息。以下是以JSON格式发送给<code class="fe oc od oe of b">assignDrivers</code>函数的数据示例:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">File: orders_and_drivers.json</figcaption></figure><p id="d77f" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">不要忘记修改<code class="fe oc od oe of b">index.js</code>以注册<code class="fe oc od oe of b">assignDrivers</code>功能，如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">File: modified_index.js</figcaption></figure><p id="39dd" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">添加函数后，让我们重启Node.js服务器。</p><h2 id="8c5c" class="nq ku in bd kv nr ns dn kz nt nu dp ld lu nv nw lf ly nx ny lh mc nz oa lj ob bi translated">创建用户界面应用程序</h2><p id="51ac" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我们将创建一个简单的web应用程序，使用React作为用户界面来访问Node.js服务器。</p><p id="07c1" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">使用<strong class="ln io">命令提示符</strong>或<strong class="ln io">终端</strong>，键入如下内容:</p><pre class="kd ke kf kg gt oj of ok ol aw om bi"><span id="e92b" class="nq ku in of b gy on oo l op oq">npx create-react-app ui</span></pre><p id="ae76" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">它将在<code class="fe oc od oe of b">ui</code>文件夹中创建一个新的React应用程序。现在，让我们创建一个简单的用户界面来输入订单和司机的名字。将<em class="og"> </em> <code class="fe oc od oe of b">ui</code> <em class="og"> </em>文件夹<em class="og"> </em>中的<code class="fe oc od oe of b">App.js</code> <em class="og">修改如下:</em></p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oh oi l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">File: App.js</figcaption></figure><p id="fa1a" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">使用<code class="fe oc od oe of b">ui</code>文件夹中的<strong class="ln io">命令提示符</strong>或<strong class="ln io">终端</strong>，如下运行应用程序:</p><pre class="kd ke kf kg gt oj of ok ol aw om bi"><span id="11da" class="nq ku in of b gy on oo l op oq">npm start</span></pre><p id="66e0" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">浏览器中的应用程序现在将如下所示:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/54d1c355b2e449dddebbac71e5bb8555.png" data-original-src="https://miro.medium.com/v2/resize:fit:1242/format:webp/1*graibE8GWoAltTFA3PZIjQ.png"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">K-Means User Interface Application using React</figcaption></figure><p id="c518" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">作为我们的示例，我们创建了五个装运订单，并将订单分配给三个司机:<strong class="ln io">安德鲁</strong>、<strong class="ln io">布鲁斯</strong>和<strong class="ln io">查理</strong>。首先，我们从下拉列表中选择驱动程序和订单。接下来，我们单击<code class="fe oc od oe of b">Assign Orders using K-Means</code>按钮，该按钮将调用Node.js服务器中的<code class="fe oc od oe of b">assignDrivers</code>函数。我们将得到如下输出:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ov"><img src="../Images/6331472e73434c629cf18d6a79ce3c79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*K4Hx3BYduS5CR8UJEq_FYw.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">K-Means output with all orders assigned to drivers</figcaption></figure><blockquote class="ow ox oy"><p id="5424" class="ll lm og ln b lo mi jo lq lr mj jr lt oz mk lw lx pa ml ma mb pb mm me mf mg ig bi translated"><strong class="ln io">注</strong>:五个出货订单位于<strong class="ln io">洛杉矶</strong>，其中三个订单前往<strong class="ln io">西林区</strong>，另外两个订单前往<strong class="ln io">好莱坞区</strong>。我们假设所有订单都来自同一个来源；洛杉矶国际机场。</p></blockquote><p id="d6db" class="pw-post-body-paragraph ll lm in ln b lo mi jo lq lr mj jr lt lu mk lw lx ly ml ma mb mc mm me mf mg ig bi translated">您可以看到，现在所有订单都根据相邻的目的地进行分组，并分配给我们的三个司机。您可以随时更改订单和驱动程序，以查看它如何更改驱动程序的分配。</p><h1 id="6940" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">结论</h1><p id="1a9f" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">作为一个结论，K-Means是一个基于质心的聚类算法，使我们能够解决司机分配问题，因为我们有以上。该算法简化了调度员的工作，尤其是在处理大量装运订单时。应用程序的源代码可在<a class="ae ks" href="https://github.com/nadinugraha/k-means" rel="noopener ugc nofollow" target="_blank">这里</a>获得。欢迎大家修改。</p><h1 id="3114" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated"><strong class="ak">用简单英语写的便条</strong></h1><p id="d364" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae ks" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="ln io">plain English . io</strong></a>找到所有这些——关注我们的出版物并<a class="ae ks" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="ln io">订阅我们的YouTube频道</strong> </a> <strong class="ln io">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>