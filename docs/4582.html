<html>
<head>
<title>A First Look at React’s New Server Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React的新服务器组件初探</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-server-components-2cf9f8e82c1f?source=collection_archive---------0-----------------------#2020-12-22">https://javascript.plainenglish.io/react-server-components-2cf9f8e82c1f?source=collection_archive---------0-----------------------#2020-12-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1758" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">解释在React.js中获取数据的新方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae kv" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank">reactjs.org</a></figcaption></figure><p id="153b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">昨天，React团队宣布了一个新特性:服务器组件。</p><p id="2f01" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">该功能仍处于试验阶段；还没有真正的文档。<br/>关于什么简单说就是:React.js中的数据&amp;组件取数。</p><p id="3e23" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器组件允许我们从后端加载组件。组件已经在后端呈现，可以无缝集成到正在运行的应用程序中。</p><p id="6495" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以这有点像服务器端渲染，但工作方式不同。</p><p id="bfe5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">类似于你从Next.js的<strong class="ky ir"> getInitialProps </strong>中了解到的，服务器组件可以获取数据并将其传递给前端组件。</p><p id="28c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然而，与经典的SSR不同，服务器组件更具动态性。我们可以在应用程序执行期间获取一个服务器树；客户端状态不会丢失。</p><p id="60c1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">他们在技术上也有所不同。使用SSR，我们的JavaScript代码在服务器上被呈现为HTML。这就创建了一个HTML模板，它是我们网页的可见部分。</p><p id="543b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这被发送到客户端，加上用于交互的JavaScript代码。由于SSR，我们可以更早地看到一些东西，但交互性可能会延迟。</p><p id="9a2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器组件动态包含在应用程序中，并以特殊形式传递，如下图所示。</p><p id="ed8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所有的JavaScript指令都被执行。1 + 1变成2，也以格式传递。组件是静态的，<strong class="ky ir">不能交互。</strong>与SSR相比，只有可见的部分被通过——交互性缺失。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ls"><img src="../Images/94771f5fdb15ac8c494a04786e66b3be.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MK4oKEaCe0695GCCP2oOTA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae kv" href="https://twitter.com/swyx/status/1341136473546899459" rel="noopener ugc nofollow" target="_blank">twitter.com</a></figcaption></figure><p id="ef49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器组件的大优势在哪里？</p><h1 id="c53f" class="lt lu iq bd lv lw lx ly lz ma mb mc md jw me jx mf jz mg ka mh kc mi kd mj mk bi translated">零束尺寸组件</h1><p id="fb75" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">JavaScript世界充满了巨大的库。想想像Moment.js这样的包，它的大小有几千字节，但是我们只使用了其中的几个函数。</p><p id="6481" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于应用程序的性能，因此对于用户来说，这当然是非常糟糕的——所有的代码都被传送到前端。</p><p id="fbfc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">摇树可以用来保存我们不需要的代码。剩下的还是很多代码，往往只执行一次。例如，格式化日期。</p><p id="c46b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">感谢服务器组件，我们也可以节省我们的前端代码。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/c8979dfbe7b0768eb68cb11ebda8a3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pS0W9igQLFN2sOGzgRK2lA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae kv" href="https://github.com/reactjs/rfcs/blob/bf51f8755ddb38d92e23ad415fc4e3c02b95b331/text/0000-server-components.md" rel="noopener ugc nofollow" target="_blank">Github</a></figcaption></figure><p id="8e07" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，React团队展示了导入渲染Markdown库的代码——如您所见，这个库非常大。</p><p id="352e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，我们不想把那么多代码发送给用户——这会耗费时间和带宽。此外，该组件根本没有交互性——它只是呈现Markdown。</p><p id="b29d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解决方案:服务器组件。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mr"><img src="../Images/b7818785fc4d8657dae2e4d914f2e281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iYQUMaBL-WkwNji3w341iQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae kv" href="https://github.com/reactjs/rfcs/blob/bf51f8755ddb38d92e23ad415fc4e3c02b95b331/text/0000-server-components.md" rel="noopener ugc nofollow" target="_blank">Github</a></figcaption></figure><p id="2e1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里值得注意的是，文件扩展名是“server.js”，但代码基础是相同的——只是现在一切都发生在服务器上。</p><p id="eefb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，客户机只获得呈现的结果，而不是将Markdown库的全部代码发送给客户机。</p><p id="7d89" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">总之，服务器组件不会影响我们前端应用的捆绑包大小。代码只在后端运行，对用户不可见。</p><h2 id="a8d6" class="ms lu iq bd lv mt mu dn lz mv mw dp md lf mx my mf lj mz na mh ln nb nc mj nd bi translated">服务器组件具有完全后端访问权限</h2><p id="a687" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">在所有这些React代码都在我们的后端运行之后，这一点现在应该很清楚了。因此，类似于Next.js，我们可以访问后端，尽管在Next中只能绕道数据库、文件系统等。</p><p id="4c1f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">服务器组件使得这种访问相当容易。React生态系统通过几个库进行了适当的访问。</p><p id="a2cf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">除了<strong class="ky ir"> react-pg </strong>和<strong class="ky ir"> react-fetch </strong>，<strong class="ky ir"> react-fs </strong>就是其中之一。<br/>没错，“fs”，代表文件系统。</p><p id="8ab8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">是的，我们可以用React.js访问我们后端的文件系统。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ne"><img src="../Images/94aadb2f1c367dd18d350122d4108891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J-_xGac1pYFTvJfKGuCWag.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Source: <a class="ae kv" href="https://github.com/reactjs/rfcs/blob/bf51f8755ddb38d92e23ad415fc4e3c02b95b331/text/0000-server-components.md" rel="noopener ugc nofollow" target="_blank">Github</a></figcaption></figure><p id="02d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">还支持访问数据库和其他服务。</p><p id="f618" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">感谢您的阅读！</strong></p><h2 id="8883" class="ms lu iq bd lv mt mu dn lz mv mw dp md lf mx my mf lj mz na mh ln nb nc mj nd bi translated"><a class="ae kv" href="http://eepurl.com/hacY0v" rel="noopener ugc nofollow" target="_blank">加入我的简讯，了解更多有趣的内容</a></h2><p id="daf1" class="pw-post-body-paragraph kw kx iq ky b kz ml jr lb lc mm ju le lf mn lh li lj mo ll lm ln mp lp lq lr ij bi translated">有关React.js的更多信息，请查看:</p><div class="nf ng gp gr nh ni"><a href="https://medium.com/javascript-in-plain-english/i-built-the-same-app-with-react-and-preact-here-are-the-differences-b0da382a6f72" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">我用React和Preact构建了相同的应用程序。以下是不同之处</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">以及测量的大小、性能和实现</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="ns l nt nu nv nr nw kp ni"/></div></div></a></div><div class="nf ng gp gr nh ni"><a href="https://medium.com/better-programming/next-js-for-react-why-you-should-give-it-a-try-right-now-e3b1886e4f20" rel="noopener follow" target="_blank"><div class="nj ab fo"><div class="nk ab nl cl cj nm"><h2 class="bd ir gy z fp nn fr fs no fu fw ip bi translated">Next.js for React:为什么你现在应该尝试一下</h2><div class="np l"><h3 class="bd b gy z fp nn fr fs no fu fw dk translated">我们生活在服务器端渲染的时代。Next.js在这方面很棒。这里有几个你应该检查它的理由…</h3></div><div class="nq l"><p class="bd b dl z fp nn fr fs no fu fw dk translated">medium.com</p></div></div><div class="nr l"><div class="nx l nt nu nv nr nw kp ni"/></div></div></a></div></div></div>    
</body>
</html>