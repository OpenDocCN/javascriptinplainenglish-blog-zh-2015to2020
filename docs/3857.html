<html>
<head>
<title>Avoid The Pyramid Of Doom</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避开末日金字塔</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/avoiding-the-pyramid-of-doom-f27176b9bb98?source=collection_archive---------6-----------------------#2020-10-29">https://javascript.plainenglish.io/avoiding-the-pyramid-of-doom-f27176b9bb98?source=collection_archive---------6-----------------------#2020-10-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7ad1" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">因为嵌套代码不利于心理健康</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/e3b9b99a268eae2196ea24adad83688c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CAJlkmwCRy_HTHpV_TJ0MQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Picture courtesy of <a class="ae kv" href="https://unsplash.com/@thaiscord" rel="noopener ugc nofollow" target="_blank">Thais Cordeiro</a></figcaption></figure><p id="de8c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我经常在看大三写的代码时，看到很多嵌套的代码。在这篇文章中，我将试图阐明为什么它是有问题的，以及应该怎么做。</p><h1 id="d73c" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">对这个问题的简单说明</h1><p id="40c7" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">让我们一起来看一个微不足道的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="70d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个函数足够简单；它要么接收输入，要么不接收。目前，这个函数的几乎所有代码都受到一个<code class="fe mr ms mt mu b">if</code>语句的“保护”。也就是说，如果不满足条件，几乎不会执行任何代码。如果不是，那么只需要执行一个日志语句。</p><p id="2f1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于这样一个简单的函数，这不是一个<em class="mv">大</em>问题，但它仍然是一个问题。为什么？</p><h1 id="bea5" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">根本问题</h1><p id="88ef" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">像前面这样的函数是有问题的，因为它们嵌套了不需要嵌套的代码。嵌套代码更难阅读/理解。</p><p id="9da2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">只要有机会，就删除不必要的嵌套，这样做可以降低代码的复杂性。</p><p id="aa03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个有趣的代码质量指标叫做<a class="ae kv" href="https://en.wikipedia.org/wiki/Cyclomatic_complexity" rel="noopener ugc nofollow" target="_blank">圈复杂度</a>，它基于控制流图来评估程序的复杂度。如果没有条件语句/决策点，那么复杂度为“1”，因为代码中只有一条路径。</p><p id="9723" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有一个<code class="fe mr ms mt mu b">if</code>，那么现在有两条不同的路径，复杂度上升到“2”。如果在那个<code class="fe mr ms mt mu b">if</code>中有一个条件语句或决策点，那么复杂度上升到“3”，等等。</p><p id="21e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，从根本上来说，这个想法是“嵌套”越少，代码就越不复杂。而且，对我来说，不太复杂的代码几乎总是赢，不管功能是否小/简单。</p><p id="9be8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我举的例子可能微不足道，但这个原则已经适用了。代码库更复杂的部分肯定会有两层或更多的嵌套，导致臭名昭著的<a class="ae kv" href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)" rel="noopener ugc nofollow" target="_blank">末日金字塔</a>。例如，当您链接回调时，也会发生同样的情况，因此相同的基本问题会出现不同的情况:随着嵌套层次的增加，复杂性也会增加。</p><p id="a8e1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们能做些什么来降低这些代码的复杂性呢？</p><blockquote class="mw mx my"><p id="7937" class="kw kx mv ky b kz la jr lb lc ld ju le mz lg lh li na lk ll lm nb lo lp lq lr ij bi translated">提示:<a class="ae kv" href="https://palantir.github.io/tslint/rules/cyclomatic-complexity/" rel="noopener ugc nofollow" target="_blank"> TSLint </a>和<a class="ae kv" href="https://eslint.org/docs/rules/complexity" rel="noopener ugc nofollow" target="_blank"> ESLint </a>都有内置的规则，可以检查你的代码的圈复杂度，所以要确保这些都被启用了。</p></blockquote><h1 id="8be0" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">使用guard语句的简单代码</h1><p id="800c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">这是我们玩具例子的一个稍微好一点的版本:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="8294" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，我删除了大部分代码的一层嵌套，并完全删除了<code class="fe mr ms mt mu b">else</code>分支。</p><p id="8643" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mr ms mt mu b">if (!noteContent) { ... return; }</code>检查就是<a class="ae kv" href="https://martinfowler.com/" rel="noopener ugc nofollow" target="_blank">马丁·福勒</a>在他的<em class="mv"> </em> <a class="ae kv" href="https://martinfowler.com/books/refactoring.html" rel="noopener ugc nofollow" target="_blank">重构</a>一书中所说的<em class="mv">守卫语句</em>。顾名思义，保护语句是用来保护代码的其余部分的。</p><p id="b40d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这种情况下，如果没有输入(<code class="fe mr ms mt mu b">null</code>论证)，那么继续下去就没有意义；于是有了<code class="fe mr ms mt mu b">return</code>。因为如果没有达到最小期望值，我们就简单地离开函数，那么代码的其余部分就不需要保持嵌套。</p><h1 id="f13e" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">但是应该有单一的退货单吧？！</h1><p id="2ca2" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><a class="ae kv" href="https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670" rel="noopener ugc nofollow" target="_blank">代码完成</a>其他来源有时不建议在一个函数中有多个return语句。一般来说，我同意并坚持这样做，因为它通常会简化调试，但在像这样的简单情况下，我坚信最好的方法是立即返回并简化代码的其余部分。</p><p id="200c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正如在几个<a class="ae kv" href="https://stackoverflow.com/questions/36707/should-a-function-have-only-one-return-statement" rel="noopener ugc nofollow" target="_blank"> StackOverflow问题</a>中解释的那样，单次返回有时会导致如下噩梦般的代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="1582" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不知道你怎么想，但是如果我偶然发现了这样的代码，我会收拾好自己的东西，飞得越远越好，再也不回头；-)</p><h1 id="7474" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="2c26" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">在这篇小文章中，我解释了为什么嵌套是有问题的，即使对于简单的函数。圈复杂度是一个需要控制的重要的代码质量指标，像这样的简单技巧确实有助于简化代码。</p><p id="8e0f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我还给出了一个例子，说明如何提高代码质量，从而提高代码的可维护性。</p><p id="027b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每当你想引入嵌套时，考虑一下这一点，并尝试其他策略(比如引入适合目的的函数)来避免不必要的复杂性；这个世界已经够复杂了；-)</p><p id="5725" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">今天到此为止！</p><p id="5684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">PS:如果你想学习大量关于软件/Web开发、TypeScript、Angular、React、Vue、Kotlin、Java、Docker/Kubernetes和其他很酷的主题的其他很酷的东西，那么不要犹豫<a class="ae kv" href="https://www.amazon.com/Learn-TypeScript-Building-Applications-understanding-ebook/dp/B081FB89BL" rel="noopener ugc nofollow" target="_blank">去拿一本我的书</a>并订阅<a class="ae kv" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">我的简讯</a>！</p></div></div>    
</body>
</html>