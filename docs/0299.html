<html>
<head>
<title>JavaScript. Event Loop and Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript。事件循环和承诺</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-event-loop-y-promises-951ba6845899?source=collection_archive---------0-----------------------#2019-09-15">https://javascript.plainenglish.io/javascript-event-loop-y-promises-951ba6845899?source=collection_archive---------0-----------------------#2019-09-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="3082" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">执行异步代码时JavaScript事件循环如何工作</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/0a442c6eb41f4b1ad760a33895e0d8ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lbjEo3zEUN9ERLOXb3Ax6w.jpeg"/></div></div></figure><p id="e9d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天，我准备了其中一篇文章，我认为它有助于强化我们经常忽略的某些<strong class="kt ir"> Javascript </strong>概念，因为<em class="ln">日复一日的</em>迫使我们将更多的注意力放在解决问题上，而不是理解下面事情的工作方式。</p><p id="e9b4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">具体来说，今天我想谈谈<strong class="kt ir">承诺</strong>，随着ES6的到来，这种新类型的对象(最终)出现了，它允许我们异步执行任务，一旦完成，就获得它们的结果(或者如果出现错误的话)并执行我们需要的代码。不过话说回来…<strong class="kt ir">Javascript是异步的</strong>？为了回答这个问题，我们还将深入研究被称为事件循环的“<em class="ln">工具</em>，它经常出现在选拔技术人员在面试中提出的问题中(去年在我参加的每次面试中，我都必须解释它)。</p><p id="1e34" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所以，我们开始吧！</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="a4bf" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">是的，Javascript是同步的</h1><p id="047a" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">让我们从Javascript是同步的开始<strong class="kt ir">并且只有一个执行线程。也就是说，它一次只能执行一个任务，这将阻止任务的执行，直到任务完成，然后才能继续执行下一个任务。</strong></p><p id="5750" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，当我们必须执行繁重的查询时，会发生什么呢？例如，获取一个包含10，000条记录的列表，我们稍后将使用这些记录。有没有办法防止执行被阻塞，以便<em class="ln">在</em>时我们可以继续做其他任务？这就是开发人员社区提出的解决方案出现的地方，以便为Javascript提供异步的某个方面:著名的<strong class="kt ir">事件循环</strong>。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="cad1" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">Javascript事件循环</h1><p id="05bb" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">为了理解Javascript事件循环，我们先来看看同步执行堆栈是如何工作的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ms"><img src="../Images/91db69ac34b65af7e0a5462c42fb78e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*53CwFZLTAge9VZrTY-rL0g.png"/></div></div></figure><p id="19d8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，当<code class="fe mt mu mv mw b">a()</code>函数开始执行时，对其余函数的连续调用被添加到堆栈中，这些调用被执行并在结束时从堆栈中移除。</p><p id="f737" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，假设我们有以下代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mx"><img src="../Images/c5f7b0eb9454b4f696432c66d5ad7654.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r5V2p9SUGhGqJRxFUMMghA.png"/></div></div></figure><p id="26a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，如果我们在一个同步执行堆栈上工作，<code class="fe mt mu mv mw b">setTimeout</code>函数将导致执行停止10秒钟(从而阻塞程序),因此在我们等待计数器结束时，没有办法做任何其他事情。</p><p id="19b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了解决这些类型的情况，实施了众所周知的<strong class="kt ir">事件循环</strong>，它允许以同步方式执行这些类型的任务，以便:</p><ul class=""><li id="939b" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">执行没有被阻止</li><li id="ddc8" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">一旦异步任务完成，只要有可能就执行你的<em class="ln">回调</em><strong class="kt ir"/>(记住后者非常重要)</li></ul><p id="89b7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们看看它是如何工作的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/643d02cc822d7ed46955ae50024ba5b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TNYKaDRtR3jRlEfbJLE9iQ.png"/></div></div></figure><ul class=""><li id="eb07" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated">在步骤2中，当<code class="fe mt mu mv mw b">setTimeout(callback, 10000)</code>函数被放入堆栈时，这个调用被传递给浏览器的Web API<strong class="kt ir">o它不再属于Javascript引擎</strong>，而是属于浏览器(或运行它的系统)提供的附加功能。</li><li id="6c7e" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">因此，在步骤3中，您可以看到是<strong class="kt ir"> Web API负责</strong>执行<code class="fe mt mu mv mw b">callback</code>功能。</li><li id="6c80" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">在第4步中，我们可以看到另一个<code class="fe mt mu mv mw b">console.log</code>是如何执行的，因此在第5步中堆栈已经是空的。</li><li id="4e57" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">一旦在Web API中找到的<code class="fe mt mu mv mw b">setTimeout</code>的10秒过去(并且JavaScript摩托车的执行堆栈为空)，就发生步骤6。由于Web API不能直接向堆栈添加任何东西(这可能会导致当前正在运行的代码中断)，它所做的是将<code class="fe mt mu mv mw b">callback</code>添加到<strong class="kt ir">回调队列</strong>(步骤7)。</li><li id="349d" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">在步骤8中，<strong class="kt ir">事件循环</strong>开始起作用。在Javascript引擎栈为空的时刻<strong class="kt ir">，事件循环获取队列回调中的内容并将其添加到执行栈中。</strong></li><li id="ab9d" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated">从那里开始，<code class="fe mt mu mv mw b">callback</code>执行遵循正常的执行过程(步骤10到13 ),直到堆栈为空。</li></ul><p id="c21b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，尽管Javascript不是异步的，但是包含WebAPI以及<em class="ln">事件循环和队列回调</em>允许它提供某种程度的灵活性，以便较重的任务不会阻塞执行线程。</p><p id="aff0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，<strong class="kt ir">有一个“但是”</strong>。由于不知道函数的<em class="ln">回调</em>将在何时被执行(正如我们所见，有必要将堆栈留空，以便<em class="ln">事件循环</em>可以从队列回调中向其添加内容)，可能有必要在我们的函数回调中嵌套连续的调用，这被称为“<strong class="kt ir">地狱回调”</strong>。</p><p id="1925" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如我们将在下面看到的那样，这是为了解决所产生的承诺。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/4cc32b4b3d7907b702961e59424b8ce4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*koznNL-ZLBN0doF17PEl_w.png"/></div></figure></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="1063" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">承诺</h1><p id="bd1f" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">为了避免这种“<em class="ln">回调地狱”</em>，开发了一系列库，如<a class="ae no" href="http://bluebirdjs.com/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank"> Bluebird </a>或Q，允许稍微清理嵌套函数的所有混乱，并编写异步操作但看起来像是同步编写的代码:<strong class="kt ir">承诺</strong>诞生了。</p><p id="3bcc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">随后，随着ES6的到来，将承诺带入Javascript的提议被接受，留下了如下语法:</p><pre class="kg kh ki kj gt np mw nq nr aw ns bi"><span id="d747" class="nt lw iq mw b gy nu nv l nw nx">const p = new Promise(function(resolve, reject) {<br/>    return setTimeout(function() { <br/>        resolve(1); <br/>    }, 10000);<br/>});</span><span id="c7d2" class="nt lw iq mw b gy ny nv l nw nx">p.then(function(value) { <br/>     console.log(value) <br/>});</span><span id="f9c2" class="nt lw iq mw b gy ny nv l nw nx">// 1</span></pre><blockquote class="nz"><p id="333a" class="oa ob iq bd oc od oe of og oh oi lm dk translated">我们可以将<strong class="ak">承诺</strong>定义为一个可以在未来某个时间产生单个值的对象，可以是一个值，也可以是无法解决的原因。</p></blockquote><p id="2d6a" class="pw-post-body-paragraph kr ks iq kt b ku oj jr kw kx ok ju kz la ol lc ld le om lg lh li on lk ll lm ij bi translated">承诺可以有三种状态:待定、履行或拒绝。对于这些<code class="fe mt mu mv mw b">Promise</code>对象，开发人员可以通过<code class="fe mt mu mv mw b">then</code>指令附加<em class="ln">回调</em>，这样一旦承诺解析的值可用(或无法解析的原因)，我们就可以执行代码。</p><p id="5fdf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">另外，<strong class="kt ir">承诺</strong>的另一个特点是<strong class="kt ir">热切</strong>，也就是说，一调用构造函数，承诺就会开始做驻留在你体内的任务。你可以在这个例子中看到:</p><p id="644a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae no" href="http://latentflip.com/loupe/?code=Y29uc3QgY2FsbGJhY2tQcm9taXNlID0gZnVuY3Rpb24odmFsdWUpIHsKICAgIGNvbnNvbGUubG9nKCdjYWxsYmFjayBwcm9taXNlJyk7Cn0KY29uc3QgcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHsKICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDAwKTsKfSk7CmNvbnNvbGUubG9nKCdDb21pZW56bycpOwpwLnRoZW4oY2FsbGJhY2tQcm9taXNlKTsKY29uc29sZS5sb2coJ0ZpbicpOw%3D%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D" rel="noopener ugc nofollow" target="_blank">http://latentflip.com/loupe/?code = y 29 UC 3 qgy 2 fsbgjhy 2 TQ cm 9 taxnlid 0 gznvuy 3 rpb 24 odmfsdupihskicaginvbnvbguubg 9 nkcdjywxsymfjaybwcm 9 taxnljyk 7 cn 0 ky 29 UC 3 qg CCA 9 ig 5 ldybqcm 9 taxnlkgz 1 BmN 0 aw 9 ukhjlc 29 sdmupihskicagihjldybibzzxruaw 1 lb 3 v0k hjlc 29 sdmusidewmdawktskfsk 7 cmnvbnnvbguu！！pgj 1 dhrvbj 5 dbgljaybtzse 8 L2 j 1 dhrvbj 4% 3D</a></p><p id="0b33" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你已经执行了代码，你会看到如何调用<code class="fe mt mu mv mw b">setTimeout</code>是第一件被执行的事情，在Web Apis中托管这个指令。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="3006" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">承诺和事件循环</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/e0682137a67075ae068f997ed0d11a35.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qGmbkU8-PaG4C8Y1"/></div></div><figcaption class="op oq gj gh gi or os bd b be z dk">Photo by <a class="ae no" href="https://unsplash.com/@daisybisley?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Claire Satera</a> on <a class="ae no" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="f758" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，承诺及其"<em class="ln">回调</em>的执行与我们在上一点中看到的异步回调有所不同，因为承诺回调被添加到一个我们之前没有提到的新队列:<strong class="kt ir">微任务队列。</strong></p><p id="bf1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">从现在开始，我们将区分两种类型的异步任务:</p><ul class=""><li id="0ef5" class="my mz iq kt b ku kv kx ky la na le nb li nc lm nd ne nf ng bi translated"><strong class="kt ir">宏任务</strong>，这些宏任务被编程，以便浏览器可以确保它们在从内部引擎访问Javascript时按顺序执行。例如，浏览器事件的回调(一个<code class="fe mt mu mv mw b">onClick</code>)或者我们之前看到的<code class="fe mt mu mv mw b">setTimeout</code>之类的函数的回调被认为是宏任务。</li><li id="6565" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm nd ne nf ng bi translated"><strong class="kt ir">微任务</strong>，它们被编程为应该在当前运行的脚本之后立即发生的事情，例如执行一些异步的事情，而不支持创建新的<em class="ln">宏任务</em>的惩罚。这些微任务被粘在<strong class="kt ir">微任务队列</strong>中，微任务队列在<em class="ln">宏任务</em>之后被处理，并且在每个宏任务执行结束时，假设没有Javascript运行。如我之前所说，微任务中有<code class="fe mt mu mv mw b">Promise</code>对象的回调。</li></ul><p id="6dde" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，在<strong class="kt ir">事件循环</strong>的迭代中，我们将拥有:</p><ol class=""><li id="f0df" class="my mz iq kt b ku kv kx ky la na le nb li nc lm ot ne nf ng bi translated">检查<strong class="kt ir">宏任务</strong>队列中是否有任务。</li><li id="7aa2" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm ot ne nf ng bi translated">如果是这样，并且该任务正在运行，请等到它完成后再进行下一步。如果没有，直接转到步骤3。</li><li id="0287" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm ot ne nf ng bi translated">然后运行微任务队列中的所有<strong class="kt ir">微任务</strong>。</li><li id="54f2" class="my mz iq kt b ku nh kx ni la nj le nk li nl lm ot ne nf ng bi translated"><strong class="kt ir">如果我们在微任务</strong>执行期间添加新的微任务，它们也会被执行。</li></ol><blockquote class="ou ov ow"><p id="7ebf" class="kr ks ln kt b ku kv jr kw kx ky ju kz ox lb lc ld oy lf lg lh oz lj lk ll lm ij bi translated">作为这个序列的推论，我们可以说，如果在两个宏任务之间，微任务的尾部有元素，那么这两个宏任务就不能一个接一个地执行。</p></blockquote><p id="b66b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，在我们定义承诺的解析(通过指令<code class="fe mt mu mv mw b">then</code>的方式)的时刻，一个新的微任务被表示，该微任务代表所述回调。</p><p id="1504" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这允许我们确保这样的回调是异步的，即使承诺已经被解决。也就是说，如果我们有以下代码:</p><pre class="kg kh ki kj gt np mw nq nr aw ns bi"><span id="5c14" class="nt lw iq mw b gy nu nv l nw nx">console.log('start');  <br/>Promise.resolve()<br/>  .then(function() {   <br/>    console.log('promise 1'); <br/>  })<br/>  .then(function() {   <br/>    console.log('promise 2'); <br/>  });  <br/>console.log('end');</span><span id="be82" class="nt lw iq mw b gy ny nv l nw nx">// start<br/>// end<br/>// promise 1<br/>// promise 2</span></pre><p id="fa49" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">属于已定义承诺的回调的<code class="fe mt mu mv mw b">console.log</code>被画在了最后，因为它们被粘在了一起，即使我们正在异步解析承诺。</p><p id="8afb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在另一个例子中:</p><pre class="kg kh ki kj gt np mw nq nr aw ns bi"><span id="0543" class="nt lw iq mw b gy nu nv l nw nx">console.log('start');</span><span id="2466" class="nt lw iq mw b gy ny nv l nw nx">setTimeout(function() {   <br/>  console.log('timeout finished'); <br/>}, 0);</span><span id="7277" class="nt lw iq mw b gy ny nv l nw nx">Promise.resolve()<br/>  .then(function() {   <br/>    console.log('promise 1'); <br/>  })<br/>  .then(function() {   <br/>    console.log('promise 2'); <br/>  });  <br/>console.log('end');</span><span id="7cbc" class="nt lw iq mw b gy ny nv l nw nx">// start<br/>// end<br/>// promise 1<br/>// promise 2<br/>// timeout finished</span></pre><p id="fa24" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">你可以看到<code class="fe mt mu mv mw b">timeout finished</code>是如何写在最后的，因为<strong class="kt ir">脚本本身被当作一个宏任务，所以在最后排队的微任务被执行</strong>，也就是引用承诺回调的两个console.log。</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="be68" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="b21b" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">如您所见，尽管我们经常使用<strong class="kt ir">承诺</strong>背后有许多概念，并且它们在当前的Javascript代码中已经无处不在。</p><p id="9444" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我希望这篇文章能帮助你回顾或发现所有这些类型的概念。一如既往，如果你有任何问题或想对本文有所贡献，请在评论中留下，我将很高兴收到你的来信！</p></div><div class="ab cl lo lp hu lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="ij ik il im in"><h1 id="2d13" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">你想看更多这样的文章吗？</h1><p id="7367" class="pw-post-body-paragraph kr ks iq kt b ku mn jr kw kx mo ju kz la mp lc ld le mq lg lh li mr lk ll lm ij bi translated">如果你喜欢这篇文章，我鼓励你订阅我每周日发送的时事通讯，里面有类似的出版物和更多的推荐内容:👇👇👇</p><div class="pa pb gp gr pc pd"><a href="https://eepurl.us20.list-manage.com/subscribe?u=c14cad2102bcf33bf216cc69e&amp;id=2790da9378" rel="noopener  ugc nofollow" target="_blank"><div class="pe ab fo"><div class="pf ab pg cl cj ph"><h2 class="bd ir gy z fp pi fr fs pj fu fw ip bi translated">拿铁和代码</h2><div class="pk l"><h3 class="bd b gy z fp pi fr fs pj fu fw dk translated">您即将订阅每周日收到的 Latte and Code 通讯。最后两篇文章...</h3></div><div class="pl l"><p class="bd b dl z fp pi fr fs pj fu fw dk translated">eepurl.us20.list-manage.com</p></div></div><div class="pm l"><div class="pn l po pp pq pm pr kp pd"/></div></div></a></div></div></div>    
</body>
</html>