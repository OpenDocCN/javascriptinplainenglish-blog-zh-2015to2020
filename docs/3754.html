<html>
<head>
<title>Spice Up React with Composition and Currying</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">香料与成分和Currying反应</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/spice-up-react-with-curry-356d346ff188?source=collection_archive---------7-----------------------#2020-10-22">https://javascript.plainenglish.io/spice-up-react-with-curry-356d346ff188?source=collection_archive---------7-----------------------#2020-10-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="92ac" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">避免函数匹配和组合的属性冲突</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/0cf406d64ffec3486d0fbb7bc848e218.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hUhHJUGu-LFe-nUJXdhr0w.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@grimnoire?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">emy</a> on <a class="ae ks" href="https://unsplash.com/s/photos/spicy-curry?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5223" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">反应高阶组件(HOC)没有失效；事实上，如果使用得当，它们是一个方便的工具。Eric Elliot 有关于何时使用HOCs vs. Hooks的<a class="ae ks" href="https://medium.com/javascript-scene/do-react-hooks-replace-higher-order-components-hocs-7ae4a08b7b58" rel="noopener">权威指南</a>。然而，一个经常被忽视的情况是如何在您的HOC中使用钩子的结果。仅仅为了在组件属性中传递钩子调用的结果而添加一个HOC是一种反模式。通过属性传递可能会迅速膨胀，导致命名冲突以及其他负面影响。为了避免这种情况，可以使用函数currying。</p><blockquote class="lp lq lr"><p id="dd24" class="kt ku ls kv b kw kx jo ky kz la jr lb lt ld le lf lu lh li lj lv ll lm ln lo ig bi translated">注意:这些例子使用了<a class="ae ks" href="https://flow.org/" rel="noopener ugc nofollow" target="_blank">流</a>类型，但是同样适用于<a class="ae ks" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank">类型脚本</a>，且在语法上几乎相同。如果您不理解<a class="ae ks" href="https://flow.org/en/docs/types/generics/" rel="noopener ugc nofollow" target="_blank">泛型</a>，请仔细阅读它们，因为它们在本文中被广泛使用。</p></blockquote><h2 id="acdb" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">反模式:用HOCs作曲</h2><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="1dd8" class="lw lx in mq b gy mu mv l mw mx">export const <strong class="mq io">withQuestionDataPreload</strong> = compose(<br/>  <strong class="mq io">withDataPreload</strong>&lt;ServiceCallParamsType&gt;(<br/>    ({apolloClient, routeParams}: ServiceCallParamsType) =&gt; {<br/>      return apolloClient.query({<br/>        query: QUESTIONS_QUERY,<br/>        variables: {<br/>          questionId: parseInt(routeParams.questionId, 10),<br/>        },<br/>      });<br/>    }<br/>  ),<br/>  <strong class="mq io">withRouteParams</strong>,<br/>  <strong class="mq io">withApolloClient</strong>,<br/>);</span></pre><p id="bfea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在本例中，<a class="ae ks" href="https://ramdajs.com/docs/#compose" rel="noopener ugc nofollow" target="_blank"> ramda compose </a>用于创建一个包含数据预加载的HOC。数据预加载是通过调用<code class="fe my mz na mq b">withDataPreload</code>返回的服务并与<code class="fe my mz na mq b">React.lazy</code>并行调用来实现的</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="1de8" class="lw lx in mq b gy mu mv l mw mx">export const <strong class="mq io">withDataPreload</strong> = &lt;Config&gt;(<br/>  <strong class="mq io">serviceCall: (params: Config) =&gt; mixed</strong><br/>): ((component: ComponentPromiseType&lt;Config&gt;) =&gt; AbstractComponent&lt;Config&gt;) =&gt; (<br/>  component: ComponentPromiseType&lt;Config&gt;<br/>): AbstractComponent&lt;Config&gt; =&gt; {<br/>  function ViewComponent(<strong class="mq io">props: Config</strong>) {<br/>    React.useEffect(() =&gt; {<br/>      <strong class="mq io">serviceCall(props);</strong><br/>    }, []);<br/>    <br/>    const ComponentPromise = <strong class="mq io">React.lazy(component)</strong>;<br/><br/>    return &lt;ComponentPromise {...props} /&gt;;<br/>  }<br/><br/>  ViewComponent.displayName = `withDataPreload(${getDisplayName(<br/>    ViewComponent<br/>  )})`;<br/><br/>  return ViewComponent;<br/>};</span></pre><p id="2d34" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里的问题是所有的<code class="fe my mz na mq b">serviceCall</code>依赖都必须作为<strong class="kv io">组件属性</strong>来传递。这可能导致属性的大量累积，并导致命名冲突。</p><h2 id="4fa5" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated">解决方法:<a class="ae ks" href="https://medium.com/javascript-scene/curry-and-function-composition-2c208d774983" rel="noopener">函数curry</a></h2><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="2112" class="lw lx in mq b gy mu mv l mw mx">export const hooks = function&lt;T&gt;(...hooks): () =&gt; T {<br/>  return (): T =&gt; {<br/>    return hooks.reduce((params, hook) =&gt; {<br/>      return {...params, ...hook()};<br/>    });<br/>  };<br/>};</span></pre><p id="5324" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了解决这个问题，我们创建了一个函数，它将通过使用一种形式化的<code class="fe my mz na mq b">reduce</code>执行钩子来创建我们的参数。我们定义了泛型<code class="fe my mz na mq b">T</code>来允许类型系统为调用者提供类型安全。</p><p id="72fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们现在可以在没有大量属性的情况下创建我们的HOC，并符合Eric Elliot对HOC使用的测试:</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="c816" class="lw lx in mq b gy mu mv l mw mx">export type ServiceCallParamsType = {<br/>  apolloClient: ApolloClient,<br/>  routeParams: {<br/>    questionId: string,<br/>  },<br/>};</span><span id="69ac" class="lw lx in mq b gy nb mv l mw mx">export const withQuestionDataPreload<strong class="mq io"><em class="ls"> </em></strong>= compose(<br/>  withDataPreload&lt;ServiceCallParamsType&gt;(<br/>    <strong class="mq io">hooks&lt;ServiceCallParamsType&gt;(useParams, useApolloClient, useConfig)</strong>,<br/>    ({params}: ServiceCallParamsType) =&gt; {<br/>      return <strong class="mq io">params.apolloClient.query</strong>({<br/>        query: QUESTIONS_QUERY,<br/>        variables: {<br/>          questionId: parseInt(<strong class="mq io">params.questionId</strong>, 10),<br/>        },<br/>      });<br/>    }<br/>  )<br/>);</span></pre><p id="363d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这里并不要求使用compose，但是我通常喜欢把它放在适当的位置，原因和我们使用尾随逗号的原因一样。如果已经有了组合管道，就更容易扩展它。</p><p id="224d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后<code class="fe my mz na mq b">withDataPreload</code>变成</p><pre class="kd ke kf kg gt mp mq mr ms aw mt bi"><span id="3d27" class="lw lx in mq b gy mu mv l mw mx">type ComponentPromiseType&lt;Config&gt; = () =&gt; Promise&lt;{<br/>  default: AbstractComponent&lt;Config&gt;,<br/>}&gt;;<br/><br/>export const withDataPreload = &lt;Config&gt;(<br/>  <strong class="mq io">getParams: () =&gt; Config</strong>,<br/>  <strong class="mq io">serviceCall: (params: Config) =&gt; mixed</strong><br/>): ((component: ComponentPromiseType&lt;Config&gt;) =&gt; AbstractComponent&lt;Config&gt;) =&gt; (<br/>  component: ComponentPromiseType&lt;Config&gt;<br/>): AbstractComponent&lt;Config&gt; =&gt; {<br/>  function ViewComponent(props: Config) {<br/>    <strong class="mq io">const params = getParams();</strong><br/><br/>    React.useEffect(() =&gt; {<br/>      <strong class="mq io">serviceCall(params);</strong><br/>    }, []);<br/><br/>    const ComponentPromise = <strong class="mq io">React.lazy(component)</strong>;<br/><br/>    return &lt;ComponentPromise {...props} /&gt;;<br/>  }<br/><br/>  ViewComponent.displayName = `withDataPreload(${getDisplayName(<br/>    ViewComponent<br/>  )})`;<br/><br/>  return ViewComponent;</span></pre><p id="3397" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">密切注意<code class="fe my mz na mq b">getParams</code>呼叫的位置。因为我们使用了<code class="fe my mz na mq b">hooks</code>来搜索结果，所以可以在正确的位置使用<code class="fe my mz na mq b">getParams</code>,以避免React产生无效的钩子调用异常。</p><p id="8545" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们现在有了一个非常可重用的方法来组装hoc的依赖项，而不需要创建大量的属性！</p></div></div>    
</body>
</html>