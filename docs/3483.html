<html>
<head>
<title>Build A Production Ready Node/Express API With Docker</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Docker构建生产就绪节点/Express API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/build-a-production-ready-node-express-api-with-docker-9a45443427a0?source=collection_archive---------0-----------------------#2020-10-03">https://javascript.plainenglish.io/build-a-production-ready-node-express-api-with-docker-9a45443427a0?source=collection_archive---------0-----------------------#2020-10-03</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/31ed3854e5d40dcad9f39a643e178c08.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_f186TrKOUrpvoYSQMSP6A.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">image courtesy of dev.to</figcaption></figure><p id="9bd5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">容器是运行在共享操作系统上的独立进程。要在容器中运行应用程序，您需要一个映像，它是源代码、运行时、库、配置文件和其他所需资产的“捆绑包”。这个“捆绑包”确保了标准化，并且只包含必需的资产。这使得容器化的应用程序变得轻量级和非常便携。</p><p id="d271" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Docker是一种允许我们将应用程序打包并作为容器运行的技术。随着最近对构建可伸缩的分布式系统的需求的增加，容器化已经成为主流，以至于“Dockerize”几乎成为一种事物。这也导致了围绕集装箱化构建的工具和框架的兴起，如<a class="ae kx" href="https://docs.docker.com/engine/swarm/" rel="noopener ugc nofollow" target="_blank"> Docker Swarm </a>和<a class="ae kx" href="https://kubernetes.io/" rel="noopener ugc nofollow" target="_blank"> Kubernetes </a>。</p><p id="4c35" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">欢迎阅读关于NodeJS和Express的三部分系列的第二部分。本系列的其他文章包括:</p><ul class=""><li id="9b89" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated"><a class="ae kx" href="https://medium.com/swlh/build-a-light-weight-rest-api-with-node-express-and-typescript-2e16b70691ad" rel="noopener">用Node、Express和TypeScript构建轻量级REST API</a></li><li id="18d2" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">在裸机服务器上部署节点和Express API</li></ul><h1 id="ce05" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">让我们对Express API进行分类</h1><p id="686b" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">事实证明，为Express应用程序创建Docker映像非常容易。你所需要的只是一个文档。这是一个文本文件，包含一组命令性的指令，告诉Docker如何构建映像。首先，让我们看看我们在上一篇文章中写的代码:</p><div class="mp mq gp gr mr ms"><a href="https://github.com/MwinyiMoha/express-typescript-api" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd io gy z fp mx fr fs my fu fw im bi translated">MwinyiMoha/express-typescript-API</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">Express和TypeScript入门。为MwinyiMoha/express-typescript-API开发做出贡献，创建一个…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">github.com</p></div></div><div class="nb l"><div class="nc l nd ne nf nb ng jt ms"/></div></div></a></div><p id="5919" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们创建一个名为<code class="fe nh ni nj nk b">Dockerfile</code>的文件—是的，没有扩展名。然后，增加以下内容:</p><figure class="nl nm nn no gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="77b5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们通过在包含我们代码的目录中打开一个终端并运行:</p><pre class="nl nm nn no gt nr nk ns nt aw nu bi"><span id="2289" class="nv ln in nk b gy nw nx l ny nz">docker build -t &lt;docker-username&gt;/expressapi:v1 .</span></pre><p id="e3ed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我假设你有码头工人账户。如果没有，请前往<a class="ae kx" href="https://hub.docker.com/" rel="noopener ugc nofollow" target="_blank"> Docker Hub </a>免费注册。用您的真实Docker用户名替换<code class="fe nh ni nj nk b">&lt;docker-username&gt;</code>。</p><h1 id="12ff" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">多么可怕的例子</h1><p id="eb87" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">上述Dockerfile文件生成的图像是:</p><ul class=""><li id="4c12" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">非常“重”，重量高达1GB。沉重的映像会导致部署缓慢，在某些情况下还会让您损失金钱</li><li id="3234" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">构建缓慢，因为它没有利用Docker的缓存机制</li><li id="8c69" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">充斥着开发依赖</li><li id="4f9c" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">不安全，离生产就绪还差得远</li></ul><p id="54c5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">虽然网上有概述上述步骤或类似内容的资料，但它们要么是针对绝对初学者的，要么是方便的简短示例，要么是彻头彻尾的糟糕指南。</p><h1 id="a55c" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">以正确的方式去做</h1><p id="8a9e" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">为了减轻前面提到的一些顾虑，如果我们的映像准备好投入生产，我们需要考虑几个问题。其中包括:</p><ul class=""><li id="a6c7" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated"><strong class="kb io"> Docker的构建上下文</strong></li></ul><p id="b8f1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">构建上下文基本上是docker文件所在的目录。在构建期间，文件和目录的所有递归内容都作为构建上下文发送到Docker。这包括臭名昭著的<code class="fe nh ni nj nk b">node_modules</code>目录的内容，我们不需要发送这些内容，因此需要忽略它们。我们为此使用了一个<code class="fe nh ni nj nk b">.dockerignore</code>文件:</p><pre class="nl nm nn no gt nr nk ns nt aw nu bi"><span id="1ba5" class="nv ln in nk b gy nw nx l ny nz">touch .dockerignore</span><span id="48da" class="nv ln in nk b gy oa nx l ny nz">echo "node_modules/" &gt;&gt; .dockerignore</span></pre><p id="c194" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">下一次我们运行构建时，我们的上下文将<strong class="kb io">在这个例子中</strong>小大约<strong class="kb io"> 60MB </strong>。</p><ul class=""><li id="1916" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated"><strong class="kb io">从轻量级基础映像开始</strong></li></ul><p id="e282" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在之前的构建中，我们从基于Debian(stretch) Linux的<code class="fe nh ni nj nk b">node:latest</code>基础映像开始，它的重量大约为<strong class="kb io"> 940MB </strong>。相比之下，基于Alpine Linux的<code class="fe nh ni nj nk b">node:14-alpine</code>有<strong class="kb io"> 117MB </strong>重，是一个可行的轻量级候选。让我们更新docker文件中的第一行，使用这个更亮的图像:</p><pre class="nl nm nn no gt nr nk ns nt aw nu bi"><span id="61c7" class="nv ln in nk b gy nw nx l ny nz">FROM node:14-alpine</span></pre><ul class=""><li id="9868" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated"><strong class="kb io">利用Docker的层缓存机制</strong></li></ul><p id="4a0e" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">Docker的缓存机制可能值得单独写一篇文章。总之，Docker使用分层的方法一层一层地“堆叠”来构建图像。如果特定层的指令与之前的构建相比没有变化，Docker将从缓存中提取该层，而不是重建它，从而加快构建过程。让我们用它来安装NPM库:</p><pre class="nl nm nn no gt nr nk ns nt aw nu bi"><span id="10ab" class="nv ln in nk b gy nw nx l ny nz">COPY package*.json ./</span><span id="1309" class="nv ln in nk b gy oa nx l ny nz">RUN npm i</span><span id="d0db" class="nv ln in nk b gy oa nx l ny nz">COPY . .</span></pre><p id="5ac2" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">在上面的设置中，我们在运行安装命令之前复制了<code class="fe nh ni nj nk b">package.json</code>和<code class="fe nh ni nj nk b">package-lock.json</code>文件。然后，在安装NPM库之后，我们复制其余的源代码。这确保了如果<code class="fe nh ni nj nk b">package.json</code>和<code class="fe nh ni nj nk b">package-lock.json</code>的内容没有改变，Docker将使用缓存层并跳过重新安装NPM库。</p><ul class=""><li id="64dd" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated"><strong class="kb io">使用多阶段构建管理依赖关系</strong></li></ul><p id="5a5d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果您还记得，在第一篇文章中，我们安装了几个开发依赖项，使用了:</p><pre class="nl nm nn no gt nr nk ns nt aw nu bi"><span id="2a1e" class="nv ln in nk b gy nw nx l ny nz">npm i -D typescript ts-node-dev @types/express</span></pre><p id="3214" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">代码从TypeScript转换成JavaScript后，这些库就不再需要了，这意味着它们只是增加了我们的图像。我们将采用多阶段构建来移除这些。现在，多阶段构建是另一个可能需要单独文章的概念。点击此处阅读更多内容:</p><div class="mp mq gp gr mr ms"><a href="https://docs.docker.com/develop/develop-images/multistage-build/" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd io gy z fp mx fr fs my fu fw im bi translated">使用多阶段构建</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">多阶段构建是一项新功能，要求守护程序和客户端上的Docker 17.05或更高版本。多阶段构建是…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">docs.docker.com</p></div></div><div class="nb l"><div class="ob l nd ne nf nb ng jt ms"/></div></div></a></div><p id="f38d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们的多阶段战略将有两个命名阶段:构建阶段和最终阶段。构建阶段将:</p><ul class=""><li id="e90e" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">安装所有依赖项，包括TypeScript</li><li id="a906" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">将代码转换成JavaScript并保存在一个<code class="fe nh ni nj nk b">dist</code>目录中</li></ul><p id="d80d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后阶段将:</p><ul class=""><li id="62f8" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">从构建器阶段复制<code class="fe nh ni nj nk b">dist</code>目录</li><li id="eeaf" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">仅安装<strong class="kb io">生产中所需的</strong>依赖项</li><li id="8fd7" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">使用复制的JavaScript代码运行应用程序</li></ul><p id="9535" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们的docker文件现在看起来像这样:</p><figure class="nl nm nn no gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1b9b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">嗯，这是一些docker文件！</p><ul class=""><li id="4560" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated"><strong class="kb io">以非根用户身份运行应用</strong></li></ul><p id="99ed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">默认情况下，Docker映像以root用户身份运行。这带来了安全问题，因为根用户拥有升级的权限。经验法则:以非根用户的身份运行docker映像。幸运的是，<code class="fe nh ni nj nk b">node:14-alpine</code>映像附带了一个名为<code class="fe nh ni nj nk b">node</code>的非根用户，其主目录在<code class="fe nh ni nj nk b">/home/node/</code>。在确保该用户拥有必要文件的所有权后，我们将使用该用户来运行应用程序。</p><p id="010c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们更新我们的最后阶段:</p><figure class="nl nm nn no gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><ul class=""><li id="c1ee" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated"><strong class="kb io">使用生产级流程经理</strong></li></ul><p id="46ed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">虽然Node二进制文件在开发环境中可能已经足够了，但是在生产环境中运行Node应用程序的最佳方式是使用进程管理器，比如PM2。它提供了方便启动、管理和管理节点应用程序的特性。点击此处了解更多信息:</p><div class="mp mq gp gr mr ms"><a href="https://pm2.keymetrics.io/" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd io gy z fp mx fr fs my fu fw im bi translated">PM2 -家</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">伙计们刚刚在我的实时服务器上安装了pm2，并连接到Keymetrics。印象深刻。这一切天衣无缝，棒极了…</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">pm2.keymetrics.io</p></div></div><div class="nb l"><div class="oc l nd ne nf nb ng jt ms"/></div></div></a></div><p id="33ed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">PM2的一个优点是，我们可以使用配置文件来声明应用程序的期望状态。让我们在项目的根目录下创建一个<code class="fe nh ni nj nk b">process.yml</code>文件，内容如下:</p><figure class="nl nm nn no gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="1bf9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">文件告诉PM2:</p><ul class=""><li id="5806" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated">我们有一个名为<code class="fe nh ni nj nk b">express-typescript-api</code>的应用</li><li id="1a1a" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">入口点是<code class="fe nh ni nj nk b">./dist/index.js</code></li><li id="7312" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">应用程序应该以集群模式运行，并且</li><li id="5287" class="ky kz in kb b kc lh kg li kk lj ko lk ks ll kw ld le lf lg bi translated">从系统中推断要运行的工作人员的最大数量</li></ul><p id="a243" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们还需要安装PM2，并使用适合容器化应用程序的<code class="fe nh ni nj nk b">pm2-runtime</code>来运行应用程序。让我们再次更新我们的最后阶段:</p><figure class="nl nm nn no gt jo"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="b2ca" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">既然说的是生产级流程经理，那也可以说一下<strong class="kb io"> NODE_ENV </strong>。如Dockerfile中的第6行所示，将此设置为“production ”,可以提高应用程序的性能，并减少错误消息的冗长性，这是典型的生产行为。</p><p id="3ef0" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">请注意，有时我们可能不想在构建步骤中直接设置环境，而是在运行容器时指定它。在这种情况下，您可以从Dockerfile中省略环境，并在运行时指定它，如下所示:</p><pre class="nl nm nn no gt nr nk ns nt aw nu bi"><span id="3f19" class="nv ln in nk b gy nw nx l ny nz">docker run -e NODE_ENV=production &lt;image-name&gt;</span></pre><p id="5767" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">上面的命令为我们提供了灵活性，以便我们可以在开发或生产设置下确定应用程序的行为</p><ul class=""><li id="dffb" class="ky kz in kb b kc kd kg kh kk la ko lb ks lc kw ld le lf lg bi translated"><strong class="kb io">安装安全更新</strong></li></ul><p id="0d2c" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最新的平台和安全补丁对生产中运行的任何应用程序都至关重要。我们将通过使用Alpine Linux的<code class="fe nh ni nj nk b">apk</code>包管理器安装更新来确保我们的应用程序基础层是最新的:</p><pre class="nl nm nn no gt nr nk ns nt aw nu bi"><span id="5da0" class="nv ln in nk b gy nw nx l ny nz">RUN apk --no-cache -U upgrade</span></pre><p id="9c6d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该命令更新基本映像的包索引，升级已安装的包，并使用<code class="fe nh ni nj nk b">--no-cache</code>标志确保包索引文件不会下载到我们的映像中，从而保持它的简洁。</p><h1 id="09ae" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">让我们建立图像</h1><p id="d0d6" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">我们最终的docker文件现在看起来像这样:</p><figure class="nl nm nn no gt jo"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Build a light-weight REST API with Node, Express and TypeScript</figcaption></figure><p id="4a48" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">让我们使用以下方式构建图像:</p><pre class="nl nm nn no gt nr nk ns nt aw nu bi"><span id="3986" class="nv ln in nk b gy nw nx l ny nz">docker build -t &lt;docker-username&gt;/expressapi:latest .</span></pre><p id="30d1" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们的新图像重达令人印象深刻的155 MB。并且，请记住<strong class="kb io"> 117MB </strong>是我们的基本映像，这意味着我们的源代码、节点包、操作系统更新和配置只给我们的总映像大小增加了<strong class="kb io"> 38 MB </strong>，这是相当公平的。</p><p id="7dbd" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">由于我们使用的是多阶段策略，我们可以瞄准并构建一个特定的阶段。这允许我们为检查目的构建图像的开发版本。例如，我们可以针对<code class="fe nh ni nj nk b">builder</code>阶段使用:</p><pre class="nl nm nn no gt nr nk ns nt aw nu bi"><span id="33c4" class="nv ln in nk b gy nw nx l ny nz">docker build --target builder -t &lt;docker-username&gt;/expressapi:dev .</span></pre><h1 id="acb7" class="lm ln in bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated"><strong class="ak">总结</strong></h1><p id="d96f" class="pw-post-body-paragraph jz ka in kb b kc mk ke kf kg ml ki kj kk mm km kn ko mn kq kr ks mo ku kv kw ig bi translated">总而言之，我们做了大量工作来确保我们的映像符合在生产中运行容器化应用程序的既定标准。进一步的调整和优化可以使我们的形象“更好”。</p><p id="9fdc" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">例如，如果我们选择将我们的应用基于Node版本10——该版本将于2021年4月在LTS发布——而不是版本14，我们可以减少额外的33MB。但是，考虑与使用旧版本相关的权衡是很重要的。</p><p id="c1b9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">一个叫做<code class="fe nh ni nj nk b">FromLatest</code>的有趣工具帮助检测和解决Dockerfiles中的问题。请点击这里查看:</p><div class="mp mq gp gr mr ms"><a href="https://www.fromlatest.io/#/" rel="noopener  ugc nofollow" target="_blank"><div class="mt ab fo"><div class="mu ab mv cl cj mw"><h2 class="bd io gy z fp mx fr fs my fu fw im bi translated">来自:最新的，一个固执己见的码头工人。</h2><div class="mz l"><h3 class="bd b gy z fp mx fr fs my fu fw dk translated">查看您的docker文件，看看您是否实现了最佳实践。</h3></div><div class="na l"><p class="bd b dl z fp mx fr fs my fu fw dk translated">www.fromlatest.io</p></div></div><div class="nb l"><div class="od l nd ne nf nb ng jt ms"/></div></div></a></div><p id="d87a" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">快乐大厦！</p></div></div>    
</body>
</html>