<html>
<head>
<title>Functional Programming — Higher Order Function, HOF</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">函数式编程——高阶函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/functional-programming-higher-order-function-hof-aaa46bb444bb?source=collection_archive---------0-----------------------#2019-12-29">https://javascript.plainenglish.io/functional-programming-higher-order-function-hof-aaa46bb444bb?source=collection_archive---------0-----------------------#2019-12-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9f51" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">什么是HOF，如何使用它？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/92cfec0c47bc1de77e1c57022b05c752.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wDGAD008hM8pzMtO"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@cgower?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Christopher Gower</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5ae5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在函数式程序设计中，HOF使用非常广泛，被认为是一个重要的因素。但是你可能没有意识到这个概念，尽管你可能每天都在使用它。在这篇文章中，我将谈谈HOF是什么以及如何使用它。</p><h1 id="aeca" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">在JavaScript中，函数是一级对象</h1><p id="419a" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">看看这个例子。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="138d" class="mu lt iq mq b gy mv mw l mx my">function fruit(sweetness) {<br/>  return sweetness * 3;<br/>}</span><span id="bb99" class="mu lt iq mq b gy mz mw l mx my">const pear = fruit(1);<br/>const strawberry = fruit(5);<br/>const watermelon = fruit(3);</span></pre><p id="a0df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数<code class="fe na nb nc mq b">fruit</code>能够被分配给变量。这是可能的，因为函数在JavaScript中是一个值。如果你不熟悉函数没有价值的语言，你会很困惑，但是不要担心。在JavaScript中，它们是一个值。</p><p id="0519" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这意味着函数也可以分配给一个数组或一个对象。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="44b4" class="mu lt iq mq b gy mv mw l mx my">const fruitsArr = [fruit(1), fruit(3), fruit(5)];<br/>const fruitsObj = {<br/>  pear: fruit(1),<br/>  strawberry: fruit(5),<br/>  watermelon: fruit(3)<br/>};</span></pre><p id="a0b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者可以将它们传递给另一个函数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3d8b" class="mu lt iq mq b gy mv mw l mx my">function strawberry(fruit) {<br/>  return fruit(5); <br/>}</span><span id="809e" class="mu lt iq mq b gy mz mw l mx my">strawberry(fruit);</span></pre><p id="2c81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为JavaScript函数被认为是一个变量，所以它被称为一级对象。一级对象最强大的特性之一是一个函数也可以返回另一个函数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c1b7" class="mu lt iq mq b gy mv mw l mx my">function f(x) {<br/>  return function(y) { ... }<br/>}</span></pre><h1 id="4149" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">那HOF是什么？</h1><p id="2e1c" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">尽管HOF听起来像是一种新技术，但它不是。HOF，高阶函数，是以函数为自变量，返回函数的函数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="bc23" class="mu lt iq mq b gy mv mw l mx my">// HOF<br/>function f(x) {<br/>  // HOF<br/>  return function(y) {<br/>    return function(x) {}<br/>  }<br/>}</span></pre><p id="1c1b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看起来很简单，不是吗？是的，确实如此。但这会带你去一个你一生中从未见过的魔法世界。在实际情况中，使用HOF最常见的情况可能是一些数组。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="3388" class="mu lt iq mq b gy mv mw l mx my">const numbers = [1, 2, 3, 4, 5, 6, 7];<br/>const isGreaterThan = x =&gt; x &gt; 4;</span><span id="33d2" class="mu lt iq mq b gy mz mw l mx my">numbers.filter(isGreaterThan); // [5, 6, 7]</span></pre><p id="9e33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc mq b">Array.prototype.filter</code>采用一个函数，该函数选取一些满足过滤条件的值。如果没有霍夫，你不得不这样做。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="c493" class="mu lt iq mq b gy mv mw l mx my">const filtered = [];<br/>for (let i = 0; i &lt; numbers.length; i += 1) {<br/>  if (numbers[i] &gt; 4) {<br/>    filtered.push(numbers[i]);<br/>  }<br/>}</span></pre><p id="e33d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用HOF看起来更好更干净！</p><h1 id="af79" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">HOF的真正力量——函数合成</h1><p id="92da" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为什么HOF在函数式编程中很重要，因为它允许你将函数组合在一起。既然HOF返回一个函数，这个函数可以返回一个函数，这个函数可以返回一个函数…，那么你可以做一个管道。</p><p id="201f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在很多函数式JavaScript库中，有一个函数叫做“compose”。名称可能与您使用的库不同，但核心概念是相同的。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="dd69" class="mu lt iq mq b gy mv mw l mx my">f: ((w → x), (x → y), (y → z), …)</span></pre><p id="5887" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">组合函数采用一个或多个函数。这个compose函数执行从左到右的函数合成。最左边的函数可以采用任何arity。一旦最左边的函数返回值，下一个最左边的函数就获取结果并返回它的返回值，这个过程一直持续到最右边的函数返回结果。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="6744" class="mu lt iq mq b gy mv mw l mx my">const compose = (fn, ...fns) =&gt; (...v) =&gt; <br/>  fns.reduce((r, f) =&gt; f(r), fn.apply(this, v));</span></pre><p id="36a5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当然，真正的compose函数可能看起来更加复杂和困难，而且组织得也很好。我在代码块中附加的<code class="fe na nb nc mq b">compose</code>来自<a class="ae kv" href="https://ramdajs.com/" rel="noopener ugc nofollow" target="_blank"> ramda.js </a>，这是一个很棒的函数式编程库。我已经写了一些硬代码。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="ee55" class="mu lt iq mq b gy mv mw l mx my">const classyGreeting = (firstName, lastName) =&gt; <br/>  `The name's ${lastName}, ${firstName} ${lastName}`;<br/>const toUpper = name =&gt; name.toUpperCase();</span><span id="c38f" class="mu lt iq mq b gy mz mw l mx my">const yellGreeting = compose(classyGreeting, toUpper);<br/>yellGreeting('james', 'bond');<br/>// THE NAMW'S BOND, JAMES BOND</span></pre><p id="2cab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Compose需要两个函数，<code class="fe na nb nc mq b">classyGreeting</code>和<code class="fe na nb nc mq b">toUpper</code>。<code class="fe na nb nc mq b">classyGreeting</code>将两个参数组合成一个字符串，<code class="fe na nb nc mq b">toUpper</code>将所有字母转换成大写字母。</p><p id="11c8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦函数被传递给compose，第一个函数将被绑定到<code class="fe na nb nc mq b">fn</code>，其他函数将被绑定到<code class="fe na nb nc mq b">...fns</code>。如果只有一个函数被传递给compose like <code class="fe na nb nc mq b">compose(toUpper)</code>，那么<code class="fe na nb nc mq b">fn</code>将是<code class="fe na nb nc mq b">toUpper</code>而<code class="fe na nb nc mq b">fns</code>将是一个空数组(<code class="fe na nb nc mq b">[]</code>)。一旦用空数组调用reduce，就会抛出一个错误。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="d6b3" class="mu lt iq mq b gy mv mw l mx my">Uncaught TypeError: Reduce of empty array with no initial value</span></pre><p id="896f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果您按如下方式设置初始值，它不会抛出错误。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9eb2" class="mu lt iq mq b gy mv mw l mx my">fns.reduce(..., fn.apply(this, v));</span></pre><p id="b02d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么，这个reduce函数的初始值就是fn的结果。如果你不明白<code class="fe na nb nc mq b">reduce</code>是如何工作的，请查阅<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank">文档</a>。</p><p id="511d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是这个看起来不是很像管子吗？函数式编程中的管道函数也接受函数和返回值，它像示例中的compose一样执行从左到右的合成。在函数式编程中，通常管道执行从左到右的函数组合，而compose执行从右到左的函数组合，这基本上是相同的。</p><h1 id="0760" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">咖喱和部分应用也是一种形式</h1><p id="5228" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">FP里还有一个概念叫库里。curry函数是一个只接受一个参数的函数，它返回一个只接受一个参数的函数，并且返回一个只接受一个参数的函数…</p><p id="bd44" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设你想把一个学生的分数加起来。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="9da9" class="mu lt iq mq b gy mv mw l mx my">function sum(math, eng, geo) {<br/>  return math + eng + geo;<br/>}</span></pre><p id="38d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，你可以这样写这个函数。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="420c" class="mu lt iq mq b gy mv mw l mx my">// ES5<br/>function curriedSum(math) {<br/>  return function(eng) {<br/>    return function(geo) {<br/>      return math + eng + geo;<br/>    }<br/>  }<br/>}</span><span id="1152" class="mu lt iq mq b gy mz mw l mx my">// ES6<br/>const curriedSum = math =&gt; eng =&gt; geo =&gt; math + eng + geo;</span></pre><p id="06fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是部分应用。</p><pre class="kg kh ki kj gt mp mq mr ms aw mt bi"><span id="b17e" class="mu lt iq mq b gy mv mw l mx my">// ES5<br/>function partialSum(math) {<br/>  return function(eng, geo) {<br/>    return math + eng + geo;<br/>  }<br/>}</span><span id="0cc9" class="mu lt iq mq b gy mz mw l mx my">// ES6<br/>const partialSum = math =&gt; (eng, geo) =&gt; math + eng + geo;</span></pre><p id="70df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这些函数给了你懒惰的优势——使用闭包计算值。</p><h1 id="3ded" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="41de" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">HOF是JavaScript中一个非常特殊的特性，它支持函数式编程，允许你在以后需要的时候计算值。在React中，这个概念被广泛用作一个组件返回一个新组件的更高阶组件的名称。</p><p id="edce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">好了，伙计们，现在你们需要做的是在你们的项目中找到HOF，并思考它为什么是HOF。这将是一个很好的练习！</p><h1 id="5c43" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">你可能想看看我在FP的其他帖子</h1><ul class=""><li id="1eca" class="nd ne iq ky b kz mk lc ml lf nf lj ng ln nh lr ni nj nk nl bi translated"><a class="ae kv" href="https://medium.com/better-programming/functional-programming-and-the-pipe-function-in-javascript-c92833052057" rel="noopener">JavaScript中的函数式编程和管道函数</a></li><li id="6ee9" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://medium.com/better-programming/functional-programming-currying-vs-partial-application-53b8b05c73e3?source=your_stories_page---------------------------" rel="noopener">函数式编程:curry vs . Partial Application</a></li></ul><h1 id="7a7d" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">资源</h1><ul class=""><li id="2b78" class="nd ne iq ky b kz mk lc ml lf nf lj ng ln nh lr ni nj nk nl bi translated"><a class="ae kv" href="https://ramdajs.com/docs/#compose" rel="noopener ugc nofollow" target="_blank">撰写— Ramda.js </a></li><li id="3a38" class="nd ne iq ky b kz nm lc nn lf no lj np ln nq lr ni nj nk nl bi translated"><a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank">array . prototype . reduce—MDN</a></li></ul></div></div>    
</body>
</html>