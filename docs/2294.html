<html>
<head>
<title>JavaScript Best Practices — Arrow Functions and Classes</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript最佳实践—箭头函数和类</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-arrow-functions-and-classes-87d7563d9481?source=collection_archive---------0-----------------------#2020-06-09">https://javascript.plainenglish.io/javascript-best-practices-arrow-functions-and-classes-87d7563d9481?source=collection_archive---------0-----------------------#2020-06-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/25e0a6eca3343c6a47fd01ef7e766f68.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mYtKF_GCaC5k88-R"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Paweł Czerwiński</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="19f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="1b5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将探讨使用arrow函数和类的最佳方式。</p><h1 id="d6db" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对匿名函数使用箭头函数</h1><p id="f813" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">匿名函数应该使用箭头函数。</p><p id="50cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样就不用处理<code class="fe me mf mg mh b">this</code>的不同值，而且更短。</p><p id="5c47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ce18" class="mq lc iq mh b gy mr ms l mt mu">[1, 2, 3].map(function (x) {<br/>  return x + 1;<br/>});</span></pre><p id="af67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e469" class="mq lc iq mh b gy mr ms l mt mu">[1, 2, 3].map((x) =&gt; x + 1);</span></pre><p id="501f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它要短得多而且<code class="fe me mf mg mh b">this</code>的值和外面的一样。</p><h1 id="c3bf" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">删除一个语句长的箭头函数的花括号</h1><p id="2f94" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">对于只有一条语句的箭头函数，我们不需要花括号。</p><p id="a0b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="e06e" class="mq lc iq mh b gy mr ms l mt mu">[1, 2, 3].map((x) =&gt; x ** 2);</span></pre><p id="a889" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">返回是隐式的，所以我们也不需要写<code class="fe me mf mg mh b">return</code>。</p><h1 id="3095" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如果表达式跨越多行，请用括号将它括起来</h1><p id="c6d9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们有一个一个语句长的arrow函数，那么我们必须把它放在括号里，这样我们就可以返回整个表达式。</p><p id="e7ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f2b9" class="mq lc iq mh b gy mr ms l mt mu">[1, 2, 3].map((x) =&gt; ({<br/>  [x]: x<br/>}));</span></pre><p id="f424" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们将每个数组条目的键和值设置为数组条目的值。</p><p id="2a09" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以对任何长表达式这样做。</p><h1 id="d844" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为清晰和一致起见，在参数两边加上括号</h1><p id="5de7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在参数周围添加括号使我们的箭头函数签名更清晰。</p><p id="799a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这也符合没有参数或有多个参数的箭头函数。</p><p id="cf55" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8bcc" class="mq lc iq mh b gy mr ms l mt mu">[1, 2, 3].map((x) =&gt; x ** x);</span></pre><p id="5394" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="af24" class="mq lc iq mh b gy mr ms l mt mu">[1, 2, 3].map(x =&gt; x ** x);</span></pre><h1 id="1770" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">避免将箭头函数语法与比较运算符混淆</h1><p id="d108" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该给比较表达式加上括号，这样我们就知道它们是比较表达式。</p><p id="6005" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f222" class="mq lc iq mh b gy mr ms l mt mu">[1, 2, 3].map((x) =&gt; x &lt;= 2);</span></pre><p id="feb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="14d4" class="mq lc iq mh b gy mr ms l mt mu">[1, 2, 3].map((x) =&gt; (x &lt;= 2));</span></pre><p id="36f6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，省略括号使得我们的箭头函数更难阅读。</p><h1 id="631f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">类和构造函数</h1><p id="3ef2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该接受现代句法，而不是使用旧句法。</p><h1 id="138a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用类语法而不是原型</h1><p id="3b87" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">使用类语法比操纵原型属性更清楚。</p><p id="594d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原型是很多人都很困惑的东西。</p><p id="2754" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向构造函数添加实例方法，而不是编写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="90e9" class="mq lc iq mh b gy mr ms l mt mu">function Person(name) {<br/>  this.name = name;<br/>}</span><span id="8bfe" class="mq lc iq mh b gy mv ms l mt mu">Person.prototype.getName = function() {<br/>  return this.name;<br/>}</span></pre><p id="be0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9214" class="mq lc iq mh b gy mr ms l mt mu">class Person {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="1ad8" class="mq lc iq mh b gy mv ms l mt mu">  getName() {<br/>    return this.name;<br/>  }<br/>}</span></pre><p id="b4b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该将方法放入类中，而不是将方法添加到<code class="fe me mf mg mh b">prototype</code>属性中。</p><p id="ead7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">实例变量应该在<code class="fe me mf mg mh b">constructor</code>方法中初始化，而不是在构造函数中。</p><p id="21f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在用给定的声明一个类之后，我们不能用相同的名字声明另一个类。</p><p id="b34d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造函数就不是这样了。</p><h1 id="ff6e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用继承扩展</h1><p id="0bef" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有了类语法，继承变得容易多了。</p><p id="bef6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，<code class="fe me mf mg mh b">instanceof</code>也会正常工作。</p><p id="dbaa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，不写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6248" class="mq lc iq mh b gy mr ms l mt mu">function Animal(name) {<br/>  this.name = name;<br/>}<br/>Animal.prototype.getName = function() {<br/>  return this.name;<br/>}</span><span id="f8ed" class="mq lc iq mh b gy mv ms l mt mu">function Dog(name) {<br/>  Animal.call(this, name);<br/>}<br/>Dog.prototype = Object.create(Animal.prototype);<br/>Dog.prototype.constructor = Animal;</span></pre><p id="9156" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c892" class="mq lc iq mh b gy mr ms l mt mu">class Animal {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }<br/>  getName() {<br/>    return this.name;<br/>  }<br/>}</span><span id="5c77" class="mq lc iq mh b gy mv ms l mt mu">class Dog extends Animal {<br/>  constructor(name) {<br/>    super(name);<br/>  }<br/>}</span></pre><p id="8b96" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们创建一个<code class="fe me mf mg mh b">Dog</code>实例时，我们可以使用<code class="fe me mf mg mh b">instanceof</code>来检查它是否是<code class="fe me mf mg mh b">Animal</code>的实例。</p><p id="ba47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="de0d" class="mq lc iq mh b gy mr ms l mt mu">const dog = new Dog();<br/>console.log(dog instanceof Animal)</span></pre><p id="213c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">查看控制台日志显示<code class="fe me mf mg mh b">true</code>，以便正确完成继承。</p><p id="8f5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构造函数语法给出了相同的结果，但是这个过程更加复杂并且容易出错。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/fecaa8c31627c37b5588a6b0ef5f3fc7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*mQCmDnC_FPk7gOjd"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@anniespratt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Annie Spratt</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e914" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">方法可以返回<code class="fe me mf mg mh b">this</code>来帮助方法链接</h1><p id="519c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在类中，我们可以有返回<code class="fe me mf mg mh b">this</code>的方法来让我们链接它们。</p><p id="4a2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="da3d" class="mq lc iq mh b gy mr ms l mt mu">class Cube {<br/>  setLength(val) {<br/>    this.length = val;<br/>    return this;<br/>  }</span><span id="229e" class="mq lc iq mh b gy mv ms l mt mu">  setWidth(val) {<br/>    this.width = val;<br/>    return this;<br/>  }</span><span id="9353" class="mq lc iq mh b gy mv ms l mt mu">  setHeight(val) {<br/>    this.height = val;<br/>    return this;<br/>  }<br/>}</span></pre><p id="ff50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过编写以下代码来链接<code class="fe me mf mg mh b">Cube</code>实例的方法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="2f9a" class="mq lc iq mh b gy mr ms l mt mu">const cube = new Cube()<br/>  .setHeight(10)<br/>  .setWidth(20)<br/>  .setLength(30)</span></pre><p id="cdff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而<code class="fe me mf mg mh b">cube</code>就是<code class="fe me mf mg mh b">{height: 10, width: 20, length: 30}</code></p><h1 id="8a16" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="8bb7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类语法和箭头函数是JavaScript的两个最好的特性，所以我们应该尽可能多地使用它们。</p><h2 id="4a9d" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">用简单英语写的JavaScript</strong></h2><p id="cea3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>