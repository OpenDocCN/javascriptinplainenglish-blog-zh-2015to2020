<html>
<head>
<title>Elm vs Svelte from 8 perspectives</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从8个角度看榆树vs苗条</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/elm-vs-svelte-d8e6f0abf667?source=collection_archive---------1-----------------------#2020-01-01">https://javascript.plainenglish.io/elm-vs-svelte-d8e6f0abf667?source=collection_archive---------1-----------------------#2020-01-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="82c6" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">两个编译成JavaScript的框架之间有偏见和肤浅的比较</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/8200df4e79ee5c7d686c36e4546530c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-KQlU0ib4_2sLRLrlHfAqA.png"/></div></div></figure><p id="2d17" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">写这篇关于榆树和苗条的文章(可能不是决定性的)让我很开心。Rich Harris，在<a class="ae ln" href="https://svelte.dev/blog/write-less-code" rel="noopener ugc nofollow" target="_blank"> <em class="lo">写更少的代码</em> </a> <em class="lo">，</em>展示了一个短小精悍的代码片段，作为写少量代码就能完成工作的例子。</p><p id="d61e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我在Elm中写了同样的东西，并使用以下标准与Svelte进行了比较:</p><ol class=""><li id="2f06" class="lp lq iq kt b ku kv kx ky la lr le ls li lt lm lu lv lw lx bi translated">代码大小</li><li id="fbe9" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">演出</li><li id="2c63" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">建筑</li><li id="65cb" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">声明式编程与命令式编程</li><li id="dfdf" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">静态与动态类型</li><li id="4106" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">数据绑定</li><li id="c881" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">真实的单一来源</li><li id="9548" class="lp lq iq kt b ku ly kx lz la ma le mb li mc lm lu lv lw lx bi translated">编译程序</li></ol><h1 id="fc11" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">1.代码大小</h1><p id="28e4" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">可以预见，Elm有更多的代码。</p><h2 id="72e0" class="na me iq bd mf nb nc dn mj nd ne dp mn la nf ng mp le nh ni mr li nj nk mt nl bi translated">苗条的版本</h2><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="c4df" class="na me iq nn b gy nr ns l nt nu">&lt;script&gt;<br/>    let a = 1;<br/>    let b = 2;<br/>&lt;/script&gt;</span><span id="000b" class="na me iq nn b gy nv ns l nt nu">&lt;input type="number" bind:value={a}&gt;<br/>&lt;input type="number" bind:value={b}&gt;</span><span id="259f" class="na me iq nn b gy nv ns l nt nu">&lt;p&gt;{a} + {b} = {a + b}&lt;/p&gt;</span></pre><p id="cd60" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://svelte.dev/repl/b18710774e8e45d3a1237e3837ce5f47?version=3.16.7" rel="noopener ugc nofollow" target="_blank">工作演示</a></p><h2 id="489e" class="na me iq bd mf nb nc dn mj nd ne dp mn la nf ng mp le nh ni mr li nj nk mt nl bi translated">榆树版本</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div></figure><h2 id="1751" class="na me iq bd mf nb nc dn mj nd ne dp mn la nf ng mp le nh ni mr li nj nk mt nl bi translated">代码字符(不包括空格):</h2><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="2684" class="na me iq nn b gy nr ns l nt nu">Elm.....: 630 characters <br/>Svelte..: 127 characters</span></pre><p id="fa4c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">(*)我计算字符移除所有制表符/空格，复制到剪贴板，然后运行<code class="fe ny nz oa nn b">pbpaste | wc -c</code></p><h2 id="7fad" class="na me iq bd mf nb nc dn mj nd ne dp mn la nf ng mp le nh ni mr li nj nk mt nl bi translated">缩小并拉上拉链</h2><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="e56f" class="na me iq nn b gy nr ns l nt nu">Elm.....:  ~27 KB<br/>Svelte..:   ~3 KB</span></pre><p id="ff27" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">哇！这几乎大了一个数量级。</p><p id="73bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是，等等，如果Elm从630个字符的代码中产生了27 KB，我想它会添加额外的东西，这些东西以后会变得很方便。</p><p id="4f57" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们分析一下现实世界中的示例应用程序(<a class="ae ln" href="https://elm-spa-example.netlify.com/" rel="noopener ugc nofollow" target="_blank"> Elm </a>和<a class="ae ln" href="https://realworld.svelte.dev/" rel="noopener ugc nofollow" target="_blank"> Svelte </a>)的足迹:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="6390" class="na me iq nn b gy nr ns l nt nu">Elm.....:  ~29 KB (  +2 KB)<br/>Svelte..:  ~15 KB ( +12 KB)</span></pre><p id="0abc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是的，榆树的增量小于苗条的增量。这些数字会互换吗？我的意思是，有没有哪个应用的Svelte build比Elm build大(不使用代码拆分)？这是一个有趣的问题，我没有答案。</p><p id="8fa8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果你想看其他更酷的代码更少的例子，你可以查看官方列表。特别喜欢todo app 里的<a class="ae ln" href="https://svelte.dev/examples#animate" rel="noopener ugc nofollow" target="_blank">动画。</a></p><h1 id="12c5" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">2.演出</h1><p id="90e3" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">除非您创建的页面包含复杂的动画、视频游戏或显示大量数据，否则在现代硬件/浏览器中，性能不是问题。</p><p id="11e4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">但是对于上面提到的情况，斯维特和榆树的表现是一个档次的(<a class="ae ln" href="https://twitter.com/sveltejs/status/1138094066867089408" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae ln" href="https://krausest.github.io/js-framework-benchmark/current.html" rel="noopener ugc nofollow" target="_blank">这里</a>和<a class="ae ln" href="https://www.freecodecamp.org/news/a-realworld-comparison-of-front-end-frameworks-with-benchmarks-2019-update-4be0d3c78075/" rel="noopener ugc nofollow" target="_blank">这里</a>)。Svelte直接与DOM交互，而Elm使用一个经过优化的虚拟DOM，充分利用其纯度。你可以在这里和这里<a class="ae ln" href="https://discourse.elm-lang.org/t/could-updating-the-dom-directly-instead-of-the-virtual-dom-get-any-advantage-for-elm-the-way-it-does-for-svelte/3995/10" rel="noopener ugc nofollow" target="_blank">找到关于这两种方法的有趣对话。</a></p><p id="2c1b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">理论上，直接修改DOM的完美脚本可能具有最佳性能。基于虚拟DOM的系统需要做同样的事情，此外，它还需要管理虚拟DOM。</p><p id="2440" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在现实中，生成一个完美的脚本，可以在过多的情况下工作是不可能的，所以这就是为什么在榆树和苗条的情况下，性能是<a class="ae ln" href="https://twitter.com/sveltejs/status/1138094066867089408" rel="noopener ugc nofollow" target="_blank">并驾齐驱</a>。</p><p id="4e03" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是vanilla JavaScript、Svelte、Imba、Elm、Vue、React和Angular的性能对比。越绿越好。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ob"><img src="../Images/d4d88113e6311645ca82b64a360513f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ltOH7UI-Yc_8RljaahG8RA.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk">Comprehensive stats of performances, keyed version. The greener, the better. Elm and Svelte are neck and neck. From <a class="ae ln" href="https://krausest.github.io/js-framework-benchmark/current.html" rel="noopener ugc nofollow" target="_blank">https://krausest.github.io/js-framework-benchmark/current.html</a></figcaption></figure><h1 id="2a87" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">3.建筑</h1><p id="e9fd" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">Elm自带了内置的Elm架构。这是一种矫枉过正的做法，但是使用Elm(或任何其他框架，就此而言)来开发这个小应用程序也是矫枉过正。Elm解决方案是一个可以扩展的框架。有了Elm，你就拥有了一种具有不变性、模式匹配、类型推理、静态类型等的声明式纯函数语言。有利有弊。</p><p id="5d42" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果不熟悉纯函数的概念，就是“同输入，同输出”，没有副作用的函数。</p><p id="d813" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所有的Elm函数都是这样的。这是Elm可靠且易于测试的部分原因。</p><p id="70b1" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我猜Svelte可以用类似于Elm架构的东西来写(Svelte有“on:input”吗？).</p><h1 id="f2c8" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">4.声明式编程与命令式编程</h1><p id="ec81" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">比较这两个片段，Elm版本似乎有更多的样板文件，Elm更倾向于“如何做”,而不是简单明了的苗条版本，后者倾向于“做什么”。</p><p id="e10c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我完全赞成声明性方法(“什么”而不是“如何”)，但是我们需要在两者之间保持良好的平衡，否则它就变成了魔术和混淆。</p><p id="4dcd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个小例子中，双向数据绑定隐藏了某种类型的强制，这种强制可能会产生意外的行为。</p><h1 id="74a7" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">5.静态与动态类型</h1><p id="5e12" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">处理类型为<code class="fe ny nz oa nn b">number</code>的输入字段相当困难。我之前在使用Vue  <a class="ae ln" href="https://medium.com/@l.mugnaini/things-that-can-go-wrong-without-a-strictly-typed-language-part-ii-8b239a85f35a" rel="noopener">和React </a>时遇到过几个<a class="ae ln" href="https://itnext.io/things-that-can-go-wrong-without-a-strictly-typed-language-d91d418a53a1" rel="noopener ugc nofollow" target="_blank">问题。与他们相比，Svelte在返回“未定义”方面做得非常好。要理解这个问题，请尝试在number类型的type字段中键入“ee”或任何非数字的内容。浏览器将返回一个空字符串。Svelte使用了一些魔法来处理这个对开发者隐藏的问题。</a></p><p id="4f40" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我猜神奇之处在于编译器生成的这个函数:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="848a" class="na me iq nn b gy nr ns l nt nu">function to_number(value) {<br/>    return value === '' ? undefined : +value;<br/>}</span></pre><p id="237e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在Elm示例中，在将结果打印到屏幕之前处理了同样的问题，代码如下:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="a8c0" class="na me iq nn b gy nr ns l nt nu">Maybe.map2 (+) (String.toFloat model.a) (String.toFloat model.b)</span></pre><p id="b665" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于不熟悉Elm的人来说，这一行类似于:</p><p id="3fd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“我需要存储为字符串的两个浮点数的数学和(字符串是HTML输入字段的自然输出，当它们是类型<code class="fe ny nz oa nn b">number</code>时也是如此)。所以首先我需要将这两个字符串转换成数字，但是转换可能会失败。如果两次转换中有任何一次失败，我也希望sum操作失败。”</p><p id="7395" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">那行代码的结果是一个<code class="fe ny nz oa nn b"><a class="ae ln" href="https://package.elm-lang.org/packages/elm/core/latest/Maybe#Maybe" rel="noopener ugc nofollow" target="_blank">Maybe Float</a></code>，其中<code class="fe ny nz oa nn b">Maybe</code>是Elm中可能失败的东西的表示。一个<code class="fe ny nz oa nn b">Maybe Float</code>类型的两个可能值是<code class="fe ny nz oa nn b">Just Float</code>(耶！一切顺利，这里是你漂亮的浮点数)或者<code class="fe ny nz oa nn b">Nothing</code>(呜呜，发生了不好的事情，不好意思，没有你的号)。</p><p id="eb18" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在没有数字的情况下，我们在屏幕上打印<code class="fe ny nz oa nn b">undefined</code>,只是为了模仿这个简单的例子，因为实际上Elm中的<code class="fe ny nz oa nn b">undefined</code>并不存在。而<code class="fe ny nz oa nn b">null</code>也没有。</p><h2 id="c946" class="na me iq bd mf nb nc dn mj nd ne dp mn la nf ng mp le nh ni mr li nj nk mt nl bi translated">JavaScript咬</h2><p id="d089" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">是的，bites，而不是bytes，就像JavaScript类型系统在咬你的时候。</p><p id="a0d6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">仍然与类型有关，如果您将<code class="fe ny nz oa nn b">a</code>和<code class="fe ny nz oa nn b">b</code>的类型更改为字符串，如</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="df48" class="na me iq nn b gy nr ns l nt nu">&lt;script&gt;<br/>    let a = "1";<br/>    let b = "2";<br/>&lt;/script&gt;</span><span id="0ecb" class="na me iq nn b gy nv ns l nt nu">&lt;input type="number" bind:value={a}&gt;<br/>&lt;input type="number" bind:value={b}&gt;</span><span id="98a5" class="na me iq nn b gy nv ns l nt nu">&lt;p&gt;{a} + {b} = {a + b}&lt;/p&gt;</span></pre><p id="eba7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://svelte.dev/repl/b18710774e8e45d3a1237e3837ce5f47?version=3.16.7" rel="noopener ugc nofollow" target="_blank">工作演示</a></p><p id="a274" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">浏览器会将其呈现为:“1 + 2 = 12”，因为JavaScript中的“+”可以处理任何东西，包括string(它将它们串联起来)。Svelte正在后台进行一些类型转换，但是在这种情况下，函数<code class="fe ny nz oa nn b">to_number</code>在初始化期间没有运行。</p><p id="91bc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在严格类型化的语言中不会出现这种情况。如果你将<code class="fe ny nz oa nn b">a</code>或<code class="fe ny nz oa nn b">b</code>初始化为字符串，编译器会报错，因为<a class="ae ln" href="https://package.elm-lang.org/packages/elm/core/latest/Basics#+" rel="noopener ugc nofollow" target="_blank">“+”只接受数字</a>。</p><p id="fdf0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦Svelte支持Typescript，这些问题可能会得到解决。</p><h2 id="f2a4" class="na me iq bd mf nb nc dn mj nd ne dp mn la nf ng mp le nh ni mr li nj nk mt nl bi translated">类型灵活性</h2><p id="7ece" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">作为后续说明，虽然精简版将<code class="fe ny nz oa nn b">a</code>和<code class="fe ny nz oa nn b">b</code>定义为类型<code class="fe ny nz oa nn b">number</code>，但在Elm中我们将它们定义为字符串:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="2959" class="na me iq nn b gy nr ns l nt nu">init = { a = "1", b = "2" }</span></pre><p id="7c73" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我决定使用字符串，因为这是HTML的自然产物。然后在添加它们之前，我把它们转换成浮点型。</p><p id="eeb7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们想将它们存储为数字，我们应该使用</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="af7f" class="na me iq nn b gy nr ns l nt nu">init = { a = Just 1, b = Just 2 }</span></pre><p id="a02a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑到字符串到数字转换过程中可能出现的故障。</p><h1 id="75f6" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">6.数据绑定</h1><p id="6a0a" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">Elm没有自动双向数据绑定。在这个意义上，Elm更类似于原始的HTML。榆树代码是</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="8ad8" class="na me iq nn b gy nr ns l nt nu">input [ onInput ChangeA, value model.a, type_ "number" ] []</span></pre><p id="af0e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这在HTML中是类似的</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="7a0b" class="na me iq nn b gy nr ns l nt nu">&lt;input oninput="...", value=model.a, type="number"&gt;</span></pre><p id="240f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">绑定是用<code class="fe ny nz oa nn b">onInput</code>和值属性完成的，其中<code class="fe ny nz oa nn b">"..."</code>是用消息<code class="fe ny nz oa nn b">ChangeA</code>和模型调用<code class="fe ny nz oa nn b">update</code>函数的东西，用伪代码:<code class="fe ny nz oa nn b">update( [ "ChangeA", this.value ], model )</code>。</p><p id="80c5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">苗条地:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="8aa1" class="na me iq nn b gy nr ns l nt nu">&lt;input type="number" bind:value={a}&gt;</span></pre><p id="bfd7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与原<code class="fe ny nz oa nn b">bind:</code>条款绑定。</p><p id="4b85" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这两种方法都有优点和缺点。Elm方式需要更多的布线，并允许您在必要时修改流程。苗条的方法更简单，对你隐藏了心流。</p><h1 id="8ae3" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">7.真实的单一来源</h1><p id="9859" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">在Elm中，按照设计，在应用程序的生命周期中只有一个“东西”(即<code class="fe ny nz oa nn b">model</code>)可以修改。在这种情况下，我们选择了包含两个值a和b的记录。</p><p id="adfb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个简单的例子中，有两个值被修改，它们是组件级别的状态。保持状态苗条有几种方法:<code class="fe ny nz oa nn b">Stores</code>、<code class="fe ny nz oa nn b">Context</code>、<code class="fe ny nz oa nn b">Props</code>。<code class="fe ny nz oa nn b">Stores</code>是保持组件外部状态的方式，可以是<code class="fe ny nz oa nn b">writable</code>、<code class="fe ny nz oa nn b">readable</code>、<code class="fe ny nz oa nn b">derived</code>和<code class="fe ny nz oa nn b">custom</code>类型。</p><p id="6729" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">同样，在Elm中，状态在应用程序级别只有一个。其他任何东西都不能有独立的国家。<br/>事件Elm中的所有事件都被转换成消息，在这个简单的例子中我们使用了两条消息:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="3d15" class="na me iq nn b gy nr ns l nt nu">type Msg = ChangeA String | ChangeB String</span></pre><p id="db6e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一个用于更新输入字段<code class="fe ny nz oa nn b">a</code>，一个用于更新输入字段<code class="fe ny nz oa nn b">b</code>。我们可以只使用一条消息:</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="cc09" class="na me iq nn b gy nr ns l nt nu">type Msg = Change InputField String</span></pre><p id="e840" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">其中<code class="fe ny nz oa nn b">InputField</code>是一个定制类型，或者更一般一点(但不是Elm中的最佳实践):</p><pre class="kg kh ki kj gt nm nn no np aw nq bi"><span id="2aea" class="na me iq nn b gy nr ns l nt nu">type Msg = Change String String</span></pre><p id="957a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这不是一个好的做法，因为在Elm中，您希望编译器尽可能严格，以便在编译时而不是在执行时拦截bug。有了String，编译器就不会给你一个错误，例如，如果你传递一个既不是<code class="fe ny nz oa nn b">a</code>也不是<code class="fe ny nz oa nn b">b</code>的字符串。</p><h1 id="ddc6" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">8.编译程序</h1><p id="234f" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">Elm和Svelte都有编译器，并且都编译成JavaScript。</p><p id="48b3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae ln" href="https://github.com/elm/compiler/tree/master/compiler/src" rel="noopener ugc nofollow" target="_blank"> Elm编译器</a>是26K行的Haskell，而<a class="ae ln" href="https://github.com/sveltejs/svelte/tree/master/src/compiler" rel="noopener ugc nofollow" target="_blank"> Svelte编译器</a>是15K行的Typescript。</p><p id="9712" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Elm编译器生成一个大型JavaScript文件，该文件已经与Elm运行时捆绑在一起，随时可以使用。它有3种模式:正常、调试(打开时间旅行调试器)和优化(打开优化使代码更小更快)。</p><p id="f333" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Svelte编译器生成一个小的JavaScript文件，在第二步中，该文件与<a class="ae ln" href="https://github.com/sveltejs/svelte/tree/master/src/runtime" rel="noopener ugc nofollow" target="_blank"> Svelte运行时</a>捆绑在一起。你可以在这里找到编译文件<a class="ae ln" href="https://dev.to/zev/how-does-svelte-actually-work-part-1-j9m" rel="noopener ugc nofollow" target="_blank">的分析，在这里</a>找到<a class="ae ln" href="https://dev.to/zev/how-does-svelte-actually-work-part-2-3gbp" rel="noopener ugc nofollow" target="_blank">的分析。</a></p><p id="7907" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Svelte编译器有几种模式，最重要的是:服务器端渲染、开发、CSS(将CSS包含在JavaScript中并在运行时注入)、Hydratable、不可变(告诉编译器你承诺不改变任何对象)、Legacy(在IE9和IE10中工作)。</p><h1 id="6dfb" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">关于真实世界例子和性能的更多信息</h1><p id="5541" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">现实世界中的例子可能已经过时或者没有很好的实现，所以对这些观察要有所保留。</p><p id="4074" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我对现实世界的例子进行了一些简单的测试，但是我没有注意到任何相关的差异。在慢速网络连接上，苗条版本给出了更快的数字(它也使用了Elm 中没有的<a class="ae ln" href="https://elm-lang.org/news/small-assets-without-the-headache" rel="noopener ugc nofollow" target="_blank">代码分割),但是视觉上Elm版本渲染得更快。细长版本显示文本“加载…”很长一段时间，这可能是由一些实现问题引起的。在苗条版本中，浏览器在4个槽中下载7个JavaScript块，页面的主要部分仅在第四个槽后下载。</a></p><p id="e5aa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">所有测试都是在“慢3G”网络的MacBook Pro上使用Chrome 79.0.3945.88进行的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/2017f5a6e3462b14034d1c268a35c36b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FfRn9fdMWmHL-deqZBUkhw.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk">Elm on the left, Svelte on the right. Performances are similar</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/e3b4fc353c6c80304c4e95f1b511ed4a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wL0H1OYlonqeZmsYMVUgSg.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk">Svelte — Assets are served as four slots for a total of seven chunks. While the fourth chunk is coming the page is still “Loading…”. An implementation issue?</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/f39361c53d0b1d456215d9ae4f72d467.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*a1VUz4q5O_vOycdzRS3jqg.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk">Svelte — The last chunk</figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi og"><img src="../Images/18ab491a09ed17ce8768a5a96d57c774.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4ccDkMjl0E-G0jePfIXlHQ.png"/></div></div><figcaption class="oc od gj gh gi oe of bd b be z dk">Elm —The first (and last) chunk</figcaption></figure><h1 id="7857" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">那么，谁是赢家？🏆</h1><p id="6b3c" class="pw-post-body-paragraph kr ks iq kt b ku mv jr kw kx mw ju kz la mx lc ld le my lg lh li mz lk ll lm ij bi translated">我们只是触及了这两项技术的表面，但我们能宣布赢家吗？</p><p id="32b6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">是的，谁为正确的任务选择正确的工具，谁就是赢家。</p><p id="a2df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这篇文章强调了这两个框架之间的主要客观权衡之一。</p><blockquote class="oh"><p id="bb5d" class="oi oj iq bd ok ol om on oo op oq lm dk translated">S <!-- --> velte让你<a class="ae ln" href="https://gist.github.com/Rich-Harris/0f910048478c2a6505d1c32185b61934" rel="noopener ugc nofollow" target="_blank">接近HTML/CSS/JavaScript </a>，而<a class="ae ln" href="https://medium.com/@l.mugnaini/is-the-future-of-front-end-development-without-html-css-and-javascript-e7bb0877980e?" rel="noopener"> Elm和elm-ui让你离开它们</a>以换取一些好处，例如<a class="ae ln" href="https://twitter.com/rtfeldman/status/961051166783213570" rel="noopener ugc nofollow" target="_blank">无运行时异常</a>。</p></blockquote><p id="fa41" class="pw-post-body-paragraph kr ks iq kt b ku or jr kw kx os ju kz la ot lc ld le ou lg lh li ov lk ll lm ij bi translated">其他概念如学习曲线、逐步采用、性能、足迹大小都有待讨论。</p><p id="169d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我称赞Svelte为前端工程界带来了有趣的新想法，我将继续尝试它。污染是一件好事，我们应该永远学习(复制？)相互脱离。</p><p id="8042" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">与此同时，我将继续使用Elm，因为我相信它最适合我正在构建的应用程序。我也是elm-ui 的快乐用户，重新编写CSS的想法并不吸引人。</p><p id="a293" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">带有严格类型和类型推断的纯函数式编程的整个概念感觉像是一种更高形式的编程，它引起了我的共鸣。</p></div></div>    
</body>
</html>