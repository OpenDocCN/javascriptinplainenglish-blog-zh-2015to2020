<html>
<head>
<title>Tail Calls in JavaScript — Will there be a comeback?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的尾调用——会卷土重来吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/tail-calls-in-javascript-will-there-be-a-comeback-63ac3a0523a5?source=collection_archive---------3-----------------------#2020-12-24">https://javascript.plainenglish.io/tail-calls-in-javascript-will-there-be-a-comeback-63ac3a0523a5?source=collection_archive---------3-----------------------#2020-12-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="00d5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript从Node开始得到尾部调用。JS 6.17.1但是它们还会被支持吗？</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ba1abf67075b692a7699eb6cb92410b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ok_mF-5iFAsZNk7PODSx_g.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk"><a class="ae kv" href="https://www.pexels.com/de-de/@pixabay" rel="noopener ugc nofollow" target="_blank">Pixabay</a> via <a class="ae kv" href="https://www.pexels.com/de-de/foto/abgeschlossen-barb-drahte-barriere-baustelle-209717/" rel="noopener ugc nofollow" target="_blank">pexels</a> (CC0)</figcaption></figure><p id="5775" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下一个级别可能不会出现在JavaScript中，但是其他语言支持它。</p><p id="ab38" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决周期性任务，您有两种选择。迭代或递归。当您决定进行迭代时，可以使用循环结构，如for循环、forEach循环等等。如果你选择递归，你将采用一种允许函数调用自身的机制。迭代的部分在于函数本身的反复调用。</p><p id="07b0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用一个数学例子来说明这一点。函数是一个数学函数，它定义了从1到n的所有自然数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="1eb2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种数学运算很快就会得出相当大的数字。10的教职员工已经超过300万。映射成数学术语就会造成这个定义。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/b3ef61f5a77f847f71f49c203d8f1739.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*nhdwRwC7-NJIRxRZtUEyRg.png"/></div></figure><p id="3684" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是也可以声明数学递归:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/35af98302e849c2f82c70f7aa298c6b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:400/format:webp/1*6HcMRgqqIIK_bHNh9EOg8w.png"/></div></figure><p id="d5c0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">主要的关键方面是澄清两种表示是平等的。可能会出现一个比另一个更适合的情况，但这取决于具体情况和你的任务说明。在代码中使用函数通常会导致递归的出现。这就更容易理解计算4！还包括3的计算！。</p><h1 id="2c28" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">选哪个？递归还是迭代？</h1><p id="f932" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">对于编码的部分，我们必须选择一个，尽管两种方法基本上是一样的，我们一次只能实现一个。两者都有优点和缺点需要注意。</p><h2 id="b8b9" class="ms lw iq bd lx mt mu dn mb mv mw dp mf lf mx my mh lj mz na mj ln nb nc ml nd bi translated">递归</h2><p id="11ae" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">这是在JavaScript中使用递归实现数字功能的方法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="864c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里明显的优点是可读性，因为我们用一个已经递归格式化的解决方案来处理这个问题。选择递归时要小心。同一函数的每个新调用都需要随机存取存储器。一些环境具有有限的RAM，或者如果您主要使用递归，您很容易陷入堆栈溢出的困境。这种情况通常发生在你没有正确定义你的分类检查的时候。</p><h2 id="d2b5" class="ms lw iq bd lx mt mu dn mb mv mw dp mf lf mx my mh lj mz na mj ln nb nc ml nd bi translated">循环</h2><p id="645e" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">这是循环的方式。只要因子低于初始输入值，简单的for循环迭代。例如，输入4将迭代3次，结果为4 * 3 * 2 * 1 = 24；</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="0c94" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们没有开销，也不用担心堆栈溢出。反对这种解决方案的是源代码的可读性。原因不在于循环结构，而在于这样一个事实，即函数是一个递归场合，我们必须在读取代码时将这个递归移植到迭代结构中。这种转换需要时间，并且会减慢阅读过程。</p><p id="585b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑两种方法的相等性将会得出这样的结论:如果两种方法相等，那么每一次递归都可以转化为一次迭代，反之亦然。这意味着编译器可以将我们的代码编译成编码/读取最差的部分。然后，我们可以为递归问题递归地编写代码，并让编译器将代码编译成迭代语句。我们不用再读书了。我们不会看到编译后的代码。这只是为了运行应用程序。</p><p id="da90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于JavaScript将这一原则用于其他几个代码部分，如async &amp; await或yield，它们被映射到一个状态机中，所以这并不困难。</p><h1 id="0506" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">使用尾部调用进行转换</h1><p id="5ef7" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">当我们使用<em class="ne">结束递归</em>，更好地被称为尾调用[1]时，我们可以实现我们的理论。这个名字来源于这个函数的最后一次调用是递归调用。仔细检查<em class="ne">X2 _ 1 _递归. js </em>的最后一行可以清楚地看到，这个函数不能处理尾部调用。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="caa0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果忽略return语句，那么正在发生的最后一个动作是与n相乘。递归调用已经发生并被求值。为了将此转换为尾调用，我们必须在两者之间实现一个参数。然后，该参数将保存一个临时结果，并将该值传递给该函数的下一次调用。一个流行的名称是“累加器”，我们可以用acc来缩短它。一旦我们完成了所有这些步骤，最后一行将会像这样。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="ed47" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将新的参数acc传递到函数中，并且必须改变整个函数的递归函数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="1a63" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样做，我们就可以满足我们的需求，编写递归，在编译后转换成迭代。</p><p id="d4fb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解释这一点:我们必须在堆栈中覆盖函数的参数，并从函数的开始处继续执行代码。这给人一种函数递归调用自身的印象，但实际上，有一个<em class="ne">跳转到</em>的跳转指令。</p><h1 id="7a1d" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">JavaScript中对尾部调用的支持</h1><p id="406a" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">我在这里解释的听起来很容易理解，也很容易实现。现实世界看起来完全不同。</p><p id="229e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">节点中的编码。JS，你会很快找到不同版本的支持。[2]</p><ul class=""><li id="2275" class="nf ng iq ky b kz la lc ld lf nh lj ni ln nj lr nk nl nm nn bi translated">直到6.4.0才完全支持尾部调用</li><li id="85b6" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">6.17.1和7.5.0 &amp; 7.10.1也获得了支持</li><li id="7af9" class="nf ng iq ky b kz no lc np lf nq lj nr ln ns lr nk nl nm nn bi translated">从8.2.1开始，他们又开始踢尾巴了</li></ul><p id="48d1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这不是唯一的节点。JS故障但更多的是谷歌chrome的V8引擎。它们与Node.JS有着相似的支持历史。它被淘汰的主要原因是缺乏调试支持。调用函数在源代码中，但不再在堆栈中，这导致了混乱，因为看起来函数只被调用了一次。在错误查找和调试过程中会产生更多的问题。</p><p id="539f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">safari浏览器是一款支持尾部调用的浏览器！【6】，【7】</p><p id="e121" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">自2016年以来，TC39提案[3]中对此进行了公开讨论。一些开发人员强烈希望JavaScript支持尾部调用优化。目前有一个通过使用预定义的关键字显式选择加入的尾部调用的活动提案。该提案称之为句法尾调用。他们将尾调用优化称为适当尾调用(PTC)。</p><p id="7c21" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用类似于<em class="ne"> return continue </em>的语句来声明尾部调用，开发人员可以选择是否利用这种调用堆栈优化。在我看来，这可能是一个好的解决办法。它允许争论双方的开发者得到他们想要的。开发人员必须有意识地得到他想要的东西，因为利用尾部调用是显而易见的。因此，这种解决方案假定编码者知道他或她在做什么。</p><p id="29f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有些人可能会抱怨说，他们希望以含蓄的方式来完成。不幸的是，不管将来会有什么样的解决方案。不会让所有人都满意。虽然，我觉得这是一个合适的妥协。语法尾调用仍然处于提议状态，这个主题也是很久以前提出来的，并且有许多不同的意见，在我们看到它在浏览器中实际实现之前，可能还需要几年时间。</p><p id="7798" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是最重要的是，如果你看了我的第一个<a class="ae kv" href="https://www.geeksforgeeks.org/tail-recursion/" rel="noopener ugc nofollow" target="_blank">链接</a>，你会发现其他语言也支持它，你可以带着在这里学到的知识回去！[1]</p><h1 id="4fc7" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">结论</h1><p id="f2e7" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">甚至因为最后一部分和长时间的讨论，我认为负责人正在使用一种策略，把一切都掩盖起来。讨论从2016年开始，当我研究TC39的计划时，我认为这不再是一个相关的话题。有价值的是以这里提到的优化方式编写代码，知道递归和迭代结构之间的区别。</p><p id="761c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您在特定节点中工作。6.17.1到7.10的JS版本，坚持ES2015/ES6的ES版本，只坚持safari或使用另一种语言你会节省自己很多学习这种编码方式的时间。节点使用的V8引擎。JS没有进一步追求这种特性。[5]</p><p id="826a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">关于TCO的不确定未来，参见堆栈溢出中的这个回答:<a class="ae kv" href="https://stackoverflow.com/questions/42788139/es6-tail-recursion-optimisation-stack-overflow" rel="noopener ugc nofollow" target="_blank"> ES6尾部递归优化</a>。</p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><p id="dfea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为你自己节省大量的时间，专注于重要的主题。  </p></div><div class="ab cl nt nu hu nv" role="separator"><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny nz"/><span class="nw bw bk nx ny"/></div><div class="ij ik il im in"><h1 id="3447" class="lv lw iq bd lx ly oa ma mb mc ob me mf jw oc jx mh jz od ka mj kc oe kd ml mm bi translated">继续读</h1><div class="of og gp gr oh oi"><a href="https://towardsdatascience.com/javascript-ecmascript-history-the-hidden-features-acb38af57be8" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">JavaScript ECMAScript历史-隐藏的特性</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">关于ECMAScript版本中不流行的技巧的JavaScript历史指南</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">towardsdatascience.com</p></div></div><div class="or l"><div class="os l ot ou ov or ow kp oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/javascript-in-plain-english/javascript-async-await-promisify-the-future-to-callback-never-again-6762707e18e5" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">JavaScript Async Await:承诺未来不再回调！</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">对承诺的回调直到异步等待</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="ox l ot ou ov or ow kp oi"/></div></div></a></div><div class="of og gp gr oh oi"><a href="https://medium.com/javascript-in-plain-english/javascript-es6-modules-import-export-129a90e83ad6" rel="noopener follow" target="_blank"><div class="oj ab fo"><div class="ok ab ol cl cj om"><h2 class="bd ir gy z fp on fr fs oo fu fw ip bi translated">JavaScript ES6模块导入导出</h2><div class="op l"><h3 class="bd b gy z fp on fr fs oo fu fw dk translated">ES6模块导入导出业务用JavaScript和JS遗留代码</h3></div><div class="oq l"><p class="bd b dl z fp on fr fs oo fu fw dk translated">medium.com</p></div></div><div class="or l"><div class="oy l ot ou ov or ow kp oi"/></div></div></a></div><h1 id="b5fd" class="lv lw iq bd lx ly lz ma mb mc md me mf jw mg jx mh jz mi ka mj kc mk kd ml mm bi translated">链接</h1><p id="5aca" class="pw-post-body-paragraph kw kx iq ky b kz mn jr lb lc mo ju le lf mp lh li lj mq ll lm ln mr lp lq lr ij bi translated">【1】尾叫<a class="ae kv" href="https://www.geeksforgeeks.org/tail-recursion/" rel="noopener ugc nofollow" target="_blank">https://www.geeksforgeeks.org/tail-recursion/</a></p><p id="3a7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[2]尾音优化节点js es 2015【https://github.com/nodejs/CTC/issues/3 T2】</p><p id="7c9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[3]讨论TC39【https://github.com/tc39/proposal-ptc-syntax T4】号</p><p id="df46" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[4]堆栈溢出post到TCO <a class="ae kv" href="https://stackoverflow.com/questions/42788139/es6-tail-recursion-optimisation-stack-overflow" rel="noopener ugc nofollow" target="_blank"> ES6尾部递归优化</a></p><p id="87e7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[5] Chrome平台状态<a class="ae kv" href="https://www.chromestatus.com/feature/5516876633341952" rel="noopener ugc nofollow" target="_blank">https://www.chromestatus.com/feature/5516876633341952</a></p><p id="0104" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[6] Safari支持Tail calls<a class="ae kv" href="https://medium.com/indigoag-eng/tail-call-optimization-in-the-wild-26a10e450c73#:~:text=Safari%20does!,that%20supports%20tail%2Dcall%20optimization" rel="noopener">https://medium . com/indigoag-eng/Tail-call-optimization-in-the-wild-26 a10e 450 c 73 #:~:text = Safari % 20 does！，即% 20支持% 20tail % 2Dcall %优化</a>。</p><p id="5a2d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">[7] Safari支持尾部调用<a class="ae kv" href="https://iryl.info/2020/09/19/improve-your-recursions-performance-with-tail-call-optimizations/" rel="noopener ugc nofollow" target="_blank">https://iryl . info/2020/09/19/improve-your-recursion-performance-with-Tail-call-optimizations/</a></p></div></div>    
</body>
</html>