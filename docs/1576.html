<html>
<head>
<title>Creating and Using Interface Types with Express Apollo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Express Apollo创建和使用接口类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/creating-and-using-interface-types-with-express-apollo-5b79e51ce394?source=collection_archive---------4-----------------------#2020-04-02">https://javascript.plainenglish.io/creating-and-using-interface-types-with-express-apollo-5b79e51ce394?source=collection_archive---------4-----------------------#2020-04-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/6551ca09c5051855097af580888b082f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gIC59evn1Hs9oF3K"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@florinnicu?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">niculcea florin</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d458" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Apollo服务器作为节点包提供。我们可以用它来创建一个接受GraphQL请求的服务器。</p><p id="8084" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何在Apollo Server和Express应用程序中创建和使用接口类型。</p><h1 id="c329" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">接口类型</h1><p id="81b6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">接口类型让我们通过使用抽象类型来构建模式。抽象类型不能直接在模式中使用，但是它可以用作创建其他类型的构建块。</p><p id="8e4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用它来创建共享相同属性的多种类型。</p><p id="664b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以创建接口并按如下方式使用它们:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a43c" class="mn lc iq mj b gy mo mp l mq mr">const express = require('express');<br/>const { ApolloServer, gql } = require('apollo-server-express');</span><span id="e97e" class="mn lc iq mj b gy ms mp l mq mr">const data = {<br/>  '1': { title: 'Math Textbook', author: 'Jane Smith', classes: ['Math'] },<br/>  '2': { title: 'Coloring Book', author: 'Joe Smith', colors: ['red'] },<br/>}</span><span id="73b0" class="mn lc iq mj b gy ms mp l mq mr">const typeDefs = gql`<br/>  interface Book {<br/>    title: String<br/>    author: String<br/>  }</span><span id="8b35" class="mn lc iq mj b gy ms mp l mq mr">  type TextBook implements Book {<br/>    title: String<br/>    author: String<br/>    classes: [String]<br/>  }</span><span id="413c" class="mn lc iq mj b gy ms mp l mq mr">  type ColoringBook implements Book {<br/>    title: String<br/>    author: String<br/>    colors: [String]<br/>  }</span><span id="6e0d" class="mn lc iq mj b gy ms mp l mq mr">  type Query {<br/>    schoolBooks(id: Int!): Book<br/>  }<br/>`;</span><span id="aa10" class="mn lc iq mj b gy ms mp l mq mr">const resolvers = {<br/>  Book: {<br/>    __resolveType(obj, context, info) {<br/>      if (obj.classes) {<br/>        return 'TextBook';<br/>      }</span><span id="33bb" class="mn lc iq mj b gy ms mp l mq mr">      if (obj.colors) {<br/>        return 'ColoringBook';<br/>      }</span><span id="e499" class="mn lc iq mj b gy ms mp l mq mr">      return null;<br/>    },<br/>  },<br/>  Query: {<br/>    schoolBooks: (_, { id }) =&gt; data[id]<br/>  },<br/>};</span><span id="051a" class="mn lc iq mj b gy ms mp l mq mr">const app = express();<br/>const server = new ApolloServer({ typeDefs, resolvers });<br/>server.applyMiddleware({ app });</span><span id="28e1" class="mn lc iq mj b gy ms mp l mq mr">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="660f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们首先创建了带有对象的<code class="fe mt mu mv mj b">data</code>对象，这些对象具有与我们稍后将创建的类型相对应的各种字段:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5038" class="mn lc iq mj b gy mo mp l mq mr">const data = {<br/>  '1': { title: 'Math Textbook', author: 'Jane Smith', classes: ['Math'] },<br/>  '2': { title: 'Coloring Book', author: 'Joe Smith', colors: ['red'] },<br/>}</span></pre><p id="27e0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们通过书写来创建我们的类型:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e916" class="mn lc iq mj b gy mo mp l mq mr">const typeDefs = gql`<br/>  interface Book {<br/>    title: String<br/>    author: String<br/>  }</span><span id="38b9" class="mn lc iq mj b gy ms mp l mq mr">  type TextBook implements Book {<br/>    title: String<br/>    author: String<br/>    classes: [String]<br/>  }</span><span id="9370" class="mn lc iq mj b gy ms mp l mq mr">  type ColoringBook implements Book {<br/>    title: String<br/>    author: String<br/>    colors: [String]<br/>  }</span><span id="d1b2" class="mn lc iq mj b gy ms mp l mq mr">  type Query {<br/>    schoolBooks(id: Int!): Book<br/>  }<br/>`;</span></pre><p id="6d71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有包含<code class="fe mt mu mv mj b">title</code>和<code class="fe mt mu mv mj b">author</code>字段的<code class="fe mt mu mv mj b">Book</code>接口类型，这意味着实现<code class="fe mt mu mv mj b">Book</code>接口的其他类型也必须包含相同类型的字段。</p><p id="151a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，我们有了带有<code class="fe mt mu mv mj b">title</code>和<code class="fe mt mu mv mj b">author</code>字符串字段的<code class="fe mt mu mv mj b">TextBook</code>和<code class="fe mt mu mv mj b">ColoringBook</code>字段。<code class="fe mt mu mv mj b">TextBook</code>也有字符串数组<code class="fe mt mu mv mj b">classes</code>字段，<code class="fe mt mu mv mj b">ColoringBook</code>有<code class="fe mt mu mv mj b">colors</code>字符串数组字段。</p><p id="7f43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">关键字<code class="fe mt mu mv mj b">implements</code>表示一个类型正在实现一个接口。</p><p id="79dc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在我们的<code class="fe mt mu mv mj b">Query</code>类型中，我们添加了接受Int <code class="fe mt mu mv mj b">id</code>参数并返回一个<code class="fe mt mu mv mj b">Book</code>的<code class="fe mt mu mv mj b">schoolBooks</code>字段。</p><p id="2bf7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我们的<code class="fe mt mu mv mj b">resolvers</code>对象中，我们在带有接口名称的属性中使用带有<code class="fe mt mu mv mj b">__resolveType</code>方法的<code class="fe mt mu mv mj b">Book</code>类型来检查<code class="fe mt mu mv mj b">obj</code>参数的结构，并相应地返回类型名称。</p><p id="6e1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe mt mu mv mj b">Query</code>对象有一个<code class="fe mt mu mv mj b">schoolBooks</code>解析器，它接受一个<code class="fe mt mu mv mj b">id</code>参数并返回给定<code class="fe mt mu mv mj b">id</code>的数据。</p><p id="d849" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，在GraphQL Playground页面中，我们通过转到<code class="fe mt mu mv mj b">/graphql</code>页面打开该页面，我们使用内联片段运行一个查询，就像我们使用联合类型一样，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="81da" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  schoolBooks(id: 1) {<br/>    __typename<br/>    ...on ColoringBook {<br/>      title<br/>      author<br/>      colors<br/>    }<br/>    ...on TextBook {<br/>      title<br/>      author<br/>      classes<br/>    }<br/>  }<br/>}</span></pre><p id="db67" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3ac1" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "data": {<br/>    "schoolBooks": {<br/>      "__typename": "TextBook",<br/>      "title": "Math Textbook",<br/>      "author": "Jane Smith",<br/>      "classes": [<br/>        "Math"<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="f5cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为回应。</p><p id="312d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将<code class="fe mt mu mv mj b">id</code>改为2，我们得到:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="c7a8" class="mn lc iq mj b gy mo mp l mq mr">{<br/>  "data": {<br/>    "schoolBooks": {<br/>      "__typename": "ColoringBook",<br/>      "title": "Coloring Book",<br/>      "author": "Joe Smith",<br/>      "colors": [<br/>        "red"<br/>      ]<br/>    }<br/>  }<br/>}</span></pre><p id="04fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/58fa296f5c6ec21922cb2c2d96e53a16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xoYBVXTsw_ta4PzI"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@dmey503?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dan Meyers</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e99c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="0711" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们创建可以作为其他具体类型的抽象类型的接口。</p><p id="d1a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个类型实现一个接口时，这意味着接口中的字段和类型都必须包含在内。这减少了出错的机会，并鼓励代码重用。</p><p id="1a27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像往常一样，我们将接口添加到类型定义中，然后我们可以用关键字<code class="fe mt mu mv mj b">implements</code>创建实现接口的类型。</p><p id="3bbd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在我们的解析器中，我们将<code class="fe mt mu mv mj b">__resolveType</code>方法添加到具有我们的接口类型名称的对象中，以根据传递到方法中的对象的结构返回类型名称。</p><p id="197a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe mt mu mv mj b">Query</code>属性中，我们添加带有我们想要添加的参数的字段，并返回我们想要返回的、与我们指定的类型结构相匹配的对象。</p><p id="0938" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">【JavaScript简单英语提示:我们总是乐于帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，请用你的Medium用户名在<a class="ae kc" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">submissions@javascriptinplainenglish.com</a>给我们发电子邮件，我们会将你添加为作者。</p></div></div>    
</body>
</html>