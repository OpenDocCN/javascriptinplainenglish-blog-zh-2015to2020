<html>
<head>
<title>Save your analytics data with the Beacon and PageVisibility APIs</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用信标和页面可见性API保存您的分析数据</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/save-your-analytics-data-with-the-beacon-and-pagevisibility-apis-f7d6a01087c4?source=collection_archive---------13-----------------------#2020-10-28">https://javascript.plainenglish.io/save-your-analytics-data-with-the-beacon-and-pagevisibility-apis-f7d6a01087c4?source=collection_archive---------13-----------------------#2020-10-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ba737dcb3acd2ee23ba1d2f57148b5e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UFonPbLGXmYqL_2lCp0MdA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@matthaeus123?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">matthaeus</a> on <a class="ae jz" href="https://unsplash.com/s/photos/beacon?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="387a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您想确保在用户离开您的网站或web应用程序的特定部分之前捕获他们的一些信息，您可以使用Beacon和PageVisivibility web APIs来确保数据被成功发送到您自己的后端服务。</p><h1 id="bc5d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">发送请求的问题</h1><p id="dfef" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">发送分析或日志信息的一种方法是捕获在web浏览器中的用户导航离开页面或关闭浏览器之前发生的事件。我们可以向后端服务发送一个网络请求，其中包含以下信息:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="3f46" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这有几个问题:</p><ul class=""><li id="c201" class="mh mi in kc b kd ke kh ki kl mj kp mk kt ml kx mm mn mo mp bi translated">浏览器不会等待请求完成，所以它可能会被取消</li><li id="f14b" class="mh mi in kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp bi translated">使用一种技术来等待请求完成，即同步完成，可能会影响下一页的加载时间(如果适用)</li><li id="e565" class="mh mi in kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp bi translated">一些浏览器会忽略<code class="fe mv mw mx my b">unload</code>处理程序中的请求，而其他浏览器根本不会触发<code class="fe mv mw mx my b">unload</code>事件(稍后会有更多内容)</li></ul><p id="ab1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是为什么使用Beacon API是一个更好的选择，如果您想确保对后端服务的最终请求完成，即使用户完全关闭了他们的浏览器。</p><h1 id="81cf" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">信标应用编程接口有什么不同？</h1><p id="64d8" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">使用Beacon API，页面发送的那些最终请求肯定会被发送。它们也是异步发送的，所以对下一页的加载时间没有副作用。</p><p id="e545" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">由于这些原因，没有必要编写任何额外的代码来确保那些最终请求被发送到您的后端服务，从而使您的代码更简单。</p><p id="dcf9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">简而言之，信标API将</p><ul class=""><li id="c5e4" class="mh mi in kc b kd ke kh ki kl mj kp mk kt ml kx mm mn mo mp bi translated">可靠地确保传递给<code class="fe mv mw mx my b">sendBeacon</code>功能的数据被发送到指定的URL</li><li id="9aa6" class="mh mi in kc b kd mq kh mr kl ms kp mt kt mu kx mm mn mo mp bi translated">异步发送请求，因此不会影响后续页面的加载时间</li></ul><h1 id="179b" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用信标应用编程接口</h1><p id="34af" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">那么，Beacon API是如何工作的呢？</p><p id="fa9d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嗯，就像在<code class="fe mv mw mx my b">window.navigator</code>对象上调用一个函数一样简单。我们可以重写前面的例子，改用Beacon API。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="b473" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然<a class="ae jz" href="https://caniuse.com/?search=beacon" rel="noopener ugc nofollow" target="_blank">浏览器支持非常好</a>，但是在尝试调用<code class="fe mv mw mx my b">navigator</code>对象之前，您可能需要检查该对象上是否存在<code class="fe mv mw mx my b">sendBeacon</code>函数。</p><p id="0a7f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mv mw mx my b">sendBeacon</code>功能将向指定为第一个参数的URL发送<strong class="kc io"> POST </strong>请求。第二个参数是要发送的数据。</p><p id="70e6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">数据的格式可以是<code class="fe mv mw mx my b">ArrayBuffer</code>、<code class="fe mv mw mx my b">ArrayBufferView</code>、<code class="fe mv mw mx my b">Blob</code>、<code class="fe mv mw mx my b">DOMString</code>、<code class="fe mv mw mx my b">FormData</code>或<code class="fe mv mw mx my b">URLSearchParams</code>。</p><h1 id="8874" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">不要使用卸载事件</h1><p id="68e7" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我之前提到过，当标签页关闭或者用户导航到另一个页面时，一些浏览器不会触发<code class="fe mv mw mx my b">unload</code>事件。手机浏览器尤其如此。</p><p id="e343" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从<a class="ae jz" href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api#legacy-lifecycle-apis-to-avoid" rel="noopener ugc nofollow" target="_blank">谷歌开发者网站的这个页面</a>:</p><blockquote class="mz na nb"><p id="5524" class="ka kb nc kc b kd ke kf kg kh ki kj kk nd km kn ko ne kq kr ks nf ku kv kw kx ig bi translated">许多开发人员将<code class="fe mv mw mx my b">unload</code>事件视为有保证的回调，并将其用作会话结束信号来保存状态和发送分析数据，但这样做是<strong class="kc io">极其不可靠的</strong>，尤其是在移动设备上！<code class="fe mv mw mx my b">unload</code>事件在许多典型的卸载情况下不会触发，包括从移动标签切换器关闭标签或者从应用切换器关闭浏览器应用。</p></blockquote><p id="26c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，当寻呼会话结束时，发送信标请求的最佳方法是什么呢？嗯，我们可以使用PageVisibility API来确定用户是否已经离开了当前选项卡。</p><h1 id="4712" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">使用页面可见性API</h1><p id="ae19" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">顾名思义，PageVisibility API可以用来确定一个文档在用户的显示器上是否可见，也就是说，用户的选项卡是否在焦点上。</p><p id="f056" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以从<code class="fe mv mw mx my b">document.visibilityState</code>中访问当前状态，它将返回<code class="fe mv mw mx my b">prerender</code>、<code class="fe mv mw mx my b">hidden</code>中的一个，或者如果您正在开发工具<code class="fe mv mw mx my b">visible</code>中运行它，则最有可能返回一个。您可以使用此属性在代码中的任何特定点检查选项卡当前是否对用户可见。</p><p id="9e5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这对于我们的情况来说没什么用，但是您可以通过一个事件来了解<code class="fe mv mw mx my b">visibilityState</code>的变化。因此，当这种情况发生变化时，您可以发送信标请求。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="36f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，现在当用户导航离开页面时，将触发<code class="fe mv mw mx my b">visibilityChange</code>事件，我们可以安全地将我们的分析或日志信息发送到我们的后端服务。</p><h1 id="96f8" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">一个完整的例子</h1><p id="fbc3" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">让我们来看一个完整的例子，您可以在本地运行并进行实验。</p><p id="6fac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，使用Express的依赖项设置一个项目:</p><pre class="mb mc md me gt ng my nh ni aw nj bi"><span id="6c54" class="nk kz in my b gy nl nm l nn no">mkdir beacon-example<br/>cd beacon-example<br/>npm init -y<br/>npm install express body-parser<br/>mkdir public<br/>touch public/index.html<br/>touch app.js</span></pre><p id="8825" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，在<code class="fe mv mw mx my b">app.js</code>文件中，设置一个Express服务器来接收我们的信标请求</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="3c6d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将Express服务器设置为运行:</p><pre class="mb mc md me gt ng my nh ni aw nj bi"><span id="4ea5" class="nk kz in my b gy nl nm l nn no">node app.js</span></pre><p id="dd7a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，在包含在<code class="fe mv mw mx my b">public</code>文件夹中的<code class="fe mv mw mx my b">index.html</code>文件中，我们可以添加一些JavaScript代码来发送信标请求。</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="0424" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">虽然这有点粗糙，但希望你能理解如何收集关于用户如何与你的页面或web应用程序交互的信息，并使用<code class="fe mv mw mx my b">sendBeacon</code>请求将这些信息传回你的后端服务。</p><p id="c670" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以通过用关于其他事件的信息更新<code class="fe mv mw mx my b">events</code>数组来扩展这个例子。例如，当用户单击页面上的任意位置时:</p><figure class="mb mc md me gt jo"><div class="bz fp l di"><div class="mf mg l"/></div></figure><p id="d65d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您前往运行后端Express服务的终端，您会看到如下所示的输出:</p><pre class="mb mc md me gt ng my nh ni aw nj bi"><span id="9bb8" class="nk kz in my b gy nl nm l nn no">Received Beacon:  [<br/>  { type: 'Session Start', time: 1603812976748 },<br/>  { type: 'Click', x: 122, y: 151 },<br/>  { type: 'Session End', time: 1603812979156 }<br/>]</span></pre><h1 id="4164" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="e6ad" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在本教程中，我们已经了解了通过简单的HTTP调用向后端服务发送分析和日志信息的问题，以及为什么不应该使用<code class="fe mv mw mx my b">unload</code>事件来侦听会话的结束。</p><p id="b6de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在知道，Beacon API提供了一种安全可靠的方式来将这种数据传递回我们自己的后端服务，而不会影响后续的页面加载时间。</p><p id="8ad5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">此外，我们还看到了PageVisibility API如何提供一个安全事件，可以告诉我们用户何时离开了某个页面，即使是在移动设备上。</p><p id="0b1e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读。如果你觉得这很有用，请<a class="ae jz" href="https://twitter.com/codebubb" rel="noopener ugc nofollow" target="_blank">在Twitter上关注我(@codebubb) </a>获取更多教程。</p></div></div>    
</body>
</html>