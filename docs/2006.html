<html>
<head>
<title>React Tips — Async and setState</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应提示—异步和设置状态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-tips-async-and-setstate-cb539ad62135?source=collection_archive---------0-----------------------#2020-05-12">https://javascript.plainenglish.io/react-tips-async-and-setstate-cb539ad62135?source=collection_archive---------0-----------------------#2020-05-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9daedda805eeeba7ddb4f6c399d9b320.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*henmzw7KjMWnlz5V"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@theotherkev?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kev Kindred</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="814d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">React是构建现代交互式前端web应用最常用的前端库。它还可以用来构建移动应用程序。</p><p id="75b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看<code class="fe lb lc ld le b">setState</code>的异步特性，以及我们应该如何编写代码来顺序运行多个<code class="fe lb lc ld le b">setState</code>调用。</p><h1 id="bb32" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">setState的异步特性</h1><p id="fd7b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">setState</code>方法是更新组件内部状态的方法。这是一个异步的批处理方法。这意味着在用新状态重新呈现组件之前，多个<code class="fe lb lc ld le b">setState</code>调用被批处理。</p><p id="ce68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">setState</code>不会立即改变状态，而是创建一个挂起的状态事务。这意味着在调用<code class="fe lb lc ld le b">setState</code>之后立即访问<code class="fe lb lc ld le b">state</code>可能会返回旧值。</p><p id="2df4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">setState</code>方法最多接受2个参数。我们通常只传入一个。第一个参数可以是用于更新状态的对象或回调。</p><p id="61ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是一个函数，它总是在<code class="fe lb lc ld le b">setState</code>运行后运行。例如，我们可以在第二个参数中传递一个回调，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="aaaf" class="mq lg iq le b gy mr ms l mt mu">import React from "react";</span><span id="4ff8" class="mq lg iq le b gy mv ms l mt mu">class App extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { count: 0 };<br/>  }</span><span id="9dff" class="mq lg iq le b gy mv ms l mt mu">  update() {<br/>    this.setState(<br/>      ({ count }) =&gt; ({<br/>        count: count + 1<br/>      }),<br/>      () =&gt; {<br/>        this.setState(({ count }) =&gt; ({<br/>          count: count + 2<br/>        }));<br/>      }<br/>    );<br/>  }</span><span id="2892" class="mq lg iq le b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;&gt;<br/>        &lt;button onClick={this.update.bind(this)}&gt;Increment&lt;/button&gt;<br/>        &lt;p&gt;{this.state.count}&lt;/p&gt;<br/>      &lt;/&gt;<br/>    );<br/>  }<br/>}</span><span id="b562" class="mq lg iq le b gy mv ms l mt mu">export default App;</span></pre><p id="fa80" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ef57" class="mq lg iq le b gy mr ms l mt mu">update() {<br/>  this.setState(<br/>    ({ count }) =&gt; ({<br/>      count: count + 1<br/>    }),<br/>    () =&gt; {<br/>      this.setState(({ count }) =&gt; ({<br/>        count: count + 2<br/>      }));<br/>    }<br/>  );<br/>}</span></pre><p id="4f28" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它调用<code class="fe lb lc ld le b">setState</code>一次，然后在回调中再次调用<code class="fe lb lc ld le b">setState</code>。这将确保一个在另一个之后运行。</p><p id="32a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当我们点击增量时，<code class="fe lb lc ld le b">count</code>状态每次都会增加3。</p><h1 id="1156" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">setState接受一个对象或函数</h1><p id="158e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">从上面的代码中我们可以看到，<code class="fe lb lc ld le b">setState</code>可以接受一个回调，该回调基于先前的状态返回新的状态。这对于更新基于先前状态的状态很有用。</p><p id="6334" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，新的<code class="fe lb lc ld le b">count</code>基于旧的<code class="fe lb lc ld le b">count</code>，所以传入回调比传入对象更合适，因为我们可以保证当原始状态作为回调参数传入时，它是最新的。</p><p id="7478" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还将一个<code class="fe lb lc ld le b">props</code>参数作为具有属性的第二个参数。例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4e60" class="mq lg iq le b gy mr ms l mt mu">import React from "react";</span><span id="e0c0" class="mq lg iq le b gy mv ms l mt mu">class Counter extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { count: 0 };<br/>  }</span><span id="b5a7" class="mq lg iq le b gy mv ms l mt mu">  update() {<br/>    this.setState(({ count }, { incrementVal }) =&gt; ({<br/>      count: incrementVal + count<br/>    }));<br/>  }</span><span id="37bf" class="mq lg iq le b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;&gt;<br/>        &lt;button onClick={this.update.bind(this)}&gt;Increment&lt;/button&gt;<br/>        &lt;p&gt;{this.state.count}&lt;/p&gt;<br/>      &lt;/&gt;<br/>    );<br/>  }<br/>}</span><span id="83cc" class="mq lg iq le b gy mv ms l mt mu">export default function App() {<br/>  return &lt;Counter incrementVal={5} /&gt;;<br/>}</span></pre><p id="0c66" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有一个<code class="fe lb lc ld le b">Counter</code>组件，它有一个<code class="fe lb lc ld le b">update</code>方法，就像我们在前面的例子中一样。但是这个ti，e，<code class="fe lb lc ld le b">setState</code>方法接受一个有第二个参数的回调。它有道具对象。</p><p id="97d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以像上面一样通过析构赋值语法来获取属性的值。此外，我们可以像访问任何其他JavaScript对象属性一样，使用点或括号符号来访问prop对象的属性。</p><p id="5daf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，既然我们已经:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="c41f" class="mq lg iq le b gy mr ms l mt mu">&lt;Counter incrementVal={5} /&gt;</span></pre><p id="4c50" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe lb lc ld le b">App</code>中，当我们点击增量按钮时，<code class="fe lb lc ld le b">Counter</code>中的<code class="fe lb lc ld le b">count</code>状态将更新5，因为这是我们指定的。</p><p id="4c47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传递给<code class="fe lb lc ld le b">setState</code>的最常见的实体可能是一个对象。我们只是传入一个对象，它有我们想要改变的状态属性。没有包括的将保持不变。</p><p id="22fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d925" class="mq lg iq le b gy mr ms l mt mu">import React from "react";</span><span id="b6e5" class="mq lg iq le b gy mv ms l mt mu">class Counter extends React.Component {<br/>  constructor(props) {<br/>    super(props);<br/>    this.state = { count: 0, foo: "foo" };<br/>  }</span><span id="763e" class="mq lg iq le b gy mv ms l mt mu">  update() {<br/>    this.setState({ count: this.state.count + 1 });<br/>  }</span><span id="32ed" class="mq lg iq le b gy mv ms l mt mu">  render() {<br/>    return (<br/>      &lt;&gt;<br/>        &lt;button onClick={this.update.bind(this)}&gt;Increment&lt;/button&gt;<br/>        &lt;p&gt;{this.state.count}&lt;/p&gt;<br/>        &lt;p&gt;{this.state.foo}&lt;/p&gt;<br/>      &lt;/&gt;<br/>    );<br/>  }<br/>}</span><span id="baa9" class="mq lg iq le b gy mv ms l mt mu">export default function App() {<br/>  return &lt;Counter /&gt;;<br/>}</span></pre><p id="128c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么即使在运行<code class="fe lb lc ld le b">update</code>中的<code class="fe lb lc ld le b">this.setstate</code>之后，<code class="fe lb lc ld le b">this.state.foo</code>也具有值<code class="fe lb lc ld le b">'foo'</code>。</p><p id="9ed6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当我们单击增量按钮时，无论我们单击多少次，都会看到“foo”显示。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/c1e5edbbab015389d139a71a2933ce78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RZlrE9IApdjDC4H8"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@ankushsehgal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ankush Nath Sehgal</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="8a9c" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="4622" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">setState</code>通话可能不总是连续的。配料有时可能不受React控制。因此，如果我们想确保多个<code class="fe lb lc ld le b">setState</code>调用始终按顺序运行，我们应该运行回调中的第二个<code class="fe lb lc ld le b">setState</code>，它作为<code class="fe lb lc ld le b">setState</code>的第二个参数传入。</p><p id="055c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另外，<code class="fe lb lc ld le b">setState</code>可以把一个具有前一状态的对象或函数以及props对象分别作为第一和第二参数。</p><h2 id="c4c6" class="mq lg iq bd lh mx my dn ll mz na dp lp ko nb nc lt ks nd ne lx kw nf ng mb nh bi translated"><strong class="ak">简明英语团队的笔记</strong></h2><p id="af9d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae kc" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kf ir">JavaScript in Plain English</strong></a><a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>—谢谢，继续学习！</p><p id="46ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们总是有兴趣帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>