<html>
<head>
<title>JavaScript ES2021 (ES12) New Features</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript ES2021 (ES12)新功能</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-es2021-es12-new-features-7aa5f411d81f?source=collection_archive---------3-----------------------#2020-10-03">https://javascript.plainenglish.io/javascript-es2021-es12-new-features-7aa5f411d81f?source=collection_archive---------3-----------------------#2020-10-03</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="969b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">准备纳入的功能</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4d41c5b45a5eec4931572497fb5a03ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QRyy7n9T0sYPTa4XMkmJvQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">JS 2021 (es12) picture</figcaption></figure><p id="8e4d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">ECMAScript 2021版本预计将在明年发布，现在我们正在敲定这个反主题2020，这是一个绝佳的时间来回顾将带来ES12版本的新功能。</p><p id="d24e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个列表基于ECMAScript提案四，这意味着这些特性将出现在下一个版本中。</p><h1 id="a0c7" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">索引</h1><ul class=""><li id="bd46" class="mj mk iq kx b ky ml lb mm le mn li mo lm mp lq mq mr ms mt bi translated">String.prototype.replaceAll()</li><li id="f846" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated">Promise.any()</li><li id="e694" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated">WeakRefs</li><li id="1f18" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated">逻辑赋值运算符</li><li id="ed04" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated">数字分隔符</li></ul><h1 id="2f41" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">String.prototype.replaceAll()</h1><p id="710e" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">String.prototype.replaceAll()用另一个字符串值替换字符串中某个子字符串的所有实例，而不使用全局regexp。</p><p id="fac5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到目前为止，最常见的方法是使用全局regexp。</p><p id="fb64" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">考虑下面的代码，其中我们使用正则表达式将“+”字符替换为空字符:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="198c" class="nh ls iq nd b gy ni nj l nk nl">const fullname= 'fullname=Jhon+Hannibal+Smith';<br/>const fullnameFormated = fullname.replace(/\+/g, ' ');</span><span id="8169" class="nh ls iq nd b gy nm nj l nk nl">//Jhon Hannibal Smith</span></pre><p id="8557" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这种方法的缺点是需要使用特殊字符的正则表达式来实现这一点。但是正则表达式的使用并不容易，而且容易出错，是常见的错误来源。</p><p id="298e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">实现这一点的更直接的解决方法是将String#split与Array#join结合起来:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="6e60" class="nh ls iq nd b gy ni nj l nk nl">const fullname= 'fullname=Jhon+Hannibal+Smith';<br/>const fullnameFormated= fullname.split('+').join(' ');</span><span id="43eb" class="nh ls iq nd b gy nm nj l nk nl">//Jhon Hannibal Smith</span></pre><p id="7e04" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个过程避免了正则表达式，但代价是将字符串分割成一组部分，然后再将它们粘在一起。</p><p id="adb9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">Mathias bynens的提议解决了这些问题，并给出了一种执行全局子串替换的简单方法:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="7c9c" class="nh ls iq nd b gy ni nj l nk nl">const fullname = 'fullname=Jhon+Hannibal+Smith';<br/>const fullnameFormated = fullname.replaceAll('+',' ');</span><span id="a4aa" class="nh ls iq nd b gy nm nj l nk nl">//Jhon Hannibal Smith</span></pre><p id="9df5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">📌请注意，为了与语言中预先存在的API保持一致，string . prototype . replace all(search value，newvalue)的行为类似于string . prototype . replace(search value，newvalue ),但有两个主要例外:</p><ul class=""><li id="3247" class="mj mk iq kx b ky kz lb lc le no li np lm nq lq mq mr ms mt bi translated">如果searchvalue是一个字符串，那么String#replaceAll将替换所有匹配项，而String#replace仅替换子字符串的第一个匹配项。</li><li id="8156" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated">如果searchValue是非全局正则表达式，String.prototype.replace仅替换单个匹配项。另一方面，String.prototype.replaceAll在这种情况下抛出一个异常，以避免在缺少全局标志(这意味着“不要全部替换”)和被调用方法的名称(这意味着“全部替换”)之间产生混淆。</li></ul><h1 id="f305" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">Promise.any()</h1><p id="f486" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">Promise.any()是任何承诺一兑现就结算，或者全部拒绝。在这种情况下，它被AggregateError拒绝。</p><p id="b2a4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">考虑下面的例子:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="82a9" class="nh ls iq nd b gy ni nj l nk nl">const promise1 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve("P1"), Math.floor(Math.random() * 100));<br/>});</span><span id="b0a7" class="nh ls iq nd b gy nm nj l nk nl">const promise2 = new Promise((resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; resolve("P2"), Math.floor(Math.random() * 100));<br/>});</span><span id="479b" class="nh ls iq nd b gy nm nj l nk nl">(async function() {<br/>  const result = await Promise.any([promise1, promise2]);<br/>  console.log(result); // P1 or P2<br/>})();</span></pre><p id="af88" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">结果是Promise.any()的第一个解析结果。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/64f4ec6dcb945495ebe459e35c6f207d.png" data-original-src="https://miro.medium.com/v2/resize:fit:950/format:webp/1*XnHW8J2eezUfl4blTIqqkA.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Example in Google Chrome dev tools.</figcaption></figure><p id="d8ee" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在没有一个承诺被解析的情况下，Promise.any()抛出AggregateError异常。</p><p id="2c03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">📌请记住与Promise.race()的不同之处，其中任何一个承诺一经确定，无论它们是被实现还是被拒绝，都将被确定。</p><h1 id="0586" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">WeakRefs</h1><p id="bb8f" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">武器在很多情况下都很有用。例如，我们可以使用一个Map对象来实现一个包含许多键值的缓存，这些键值需要大量的内存。在这种情况下，对我们来说方便的是尽快释放键值对占用的内存，WeakRefs允许我们这样做。</p><p id="788e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">WeakRef对象包含对对象的弱引用。对对象的弱引用是指不阻止垃圾收集器恢复该对象的引用。另一方面，标准引用将对象保存在内存中。</p><p id="46a5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">JavaScript中对对象的引用被保存。也就是说，只要你有一个对象的引用，它就不会被垃圾收集。</p><p id="78f4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">示例:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="0c6c" class="nh ls iq nd b gy ni nj l nk nl">const obj1= { a: 10, b: 20};</span></pre><p id="f65b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">目前，我们有WeakMap()和WeakSet()使用WeakRefs:</p><p id="a695" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">WeakMap对象是键-值对的集合，其中的键被弱引用。</p><p id="c379" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们考虑下面的例子:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="ec2a" class="nh ls iq nd b gy ni nj l nk nl">const myObj = {...};</span></pre><p id="0d5d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用前一个对象的函数:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="e62f" class="nh ls iq nd b gy ni nj l nk nl">function useTheObj(obj){<br/>   doSomethingWith(obj);<br/>}</span></pre><p id="fc5f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我想记录某个特定对象调用该方法的次数，并在超过1000次时进行报告:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="2154" class="nh ls iq nd b gy ni nj l nk nl">var map = new Map();</span><span id="ca49" class="nh ls iq nd b gy nm nj l nk nl">function useTheObj(obj){</span><span id="fa7f" class="nh ls iq nd b gy nm nj l nk nl"> doSomethingWith(obj);</span><span id="3c8c" class="nh ls iq nd b gy nm nj l nk nl"> //get the number of called times <br/> //or initialize to 0 is null.       <br/> var called = map.get(obj) || 0;</span><span id="69f5" class="nh ls iq nd b gy nm nj l nk nl"> //Increase the counter in one<br/> called++;</span><span id="c9c1" class="nh ls iq nd b gy nm nj l nk nl"> if(called &gt; 1000) {<br/>   console.log(’called more than 1000 times’);<br/> };</span><span id="c1fb" class="nh ls iq nd b gy nm nj l nk nl"> map.set(obj, called);<br/>}</span></pre><p id="26f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这个解决方案是可行的，但是它存在内存泄漏，因为传递给函数的每个对象都永远保留在映射上，并且没有被垃圾收集。解决方案是使用WeakMap:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="1cde" class="nh ls iq nd b gy ni nj l nk nl">var wmap = new WeakMap();</span><span id="b40e" class="nh ls iq nd b gy nm nj l nk nl">function useTheObj(obj){</span><span id="1beb" class="nh ls iq nd b gy nm nj l nk nl"> doSomethingWith(obj);</span><span id="bb6d" class="nh ls iq nd b gy nm nj l nk nl"> //get the number of called times<br/> //or initialize to 0 is null.<br/> var called = wmap.get(obj) || 0;</span><span id="a9ba" class="nh ls iq nd b gy nm nj l nk nl"> //Increase the counter in one<br/> called++;</span><span id="13fa" class="nh ls iq nd b gy nm nj l nk nl"> if(called &gt; 1000) {<br/>   console.log(’called more than 1000 times’);<br/> };</span><span id="129f" class="nh ls iq nd b gy nm nj l nk nl"> wmap.set(obj, called);<br/>}</span></pre><p id="ccc3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">📌因为引用是弱的，所以WeakMap键是不可枚举的。</p><p id="7861" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">📌WeakSet类似于WeakMap，但是就像集合一样，WeakSet中的每个对象只能出现一次。WeakSet集合中的所有对象都是唯一的。</p><h1 id="eb6f" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">逻辑赋值运算符</h1><p id="8511" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">逻辑赋值操作符(由Justin Ridgewell和Hemanth HM提出)结合了逻辑操作符(&amp;&amp;，||，？？)和赋值表达式:</p><p id="6096" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">到目前为止，JavaScript有以下赋值操作符:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="25e4" class="nh ls iq nd b gy ni nj l nk nl">=<br/>Assignment operator.</span><span id="790e" class="nh ls iq nd b gy nm nj l nk nl">/=<br/>Division assignment.</span><span id="00fa" class="nh ls iq nd b gy nm nj l nk nl">*=<br/>Multiplication assignment.</span><span id="940a" class="nh ls iq nd b gy nm nj l nk nl">&amp;&amp;=<br/>Logical AND assignment.</span><span id="3545" class="nh ls iq nd b gy nm nj l nk nl">||=<br/>Logical OR assignment.</span><span id="3234" class="nh ls iq nd b gy nm nj l nk nl">??=<br/>Logical nullish assignment.</span><span id="05b7" class="nh ls iq nd b gy nm nj l nk nl">**=<br/>Exponentiation assignment.</span><span id="4a5a" class="nh ls iq nd b gy nm nj l nk nl">%=<br/>Remainder assignment.</span><span id="8fe9" class="nh ls iq nd b gy nm nj l nk nl">+=<br/>Addition assignment.</span><span id="0dc3" class="nh ls iq nd b gy nm nj l nk nl">-=<br/>Subtraction assignment.</span><span id="ddef" class="nh ls iq nd b gy nm nj l nk nl">&lt;&lt;=<br/>Left shift assignment.</span><span id="7933" class="nh ls iq nd b gy nm nj l nk nl">&gt;&gt;=<br/>Right shift assignment.</span><span id="8d2e" class="nh ls iq nd b gy nm nj l nk nl">&gt;&gt;&gt;=<br/>Unsigned right shift assignment.</span><span id="67b3" class="nh ls iq nd b gy nm nj l nk nl">&amp;=<br/>Bitwise AND assignment.</span><span id="792b" class="nh ls iq nd b gy nm nj l nk nl">^=<br/>Bitwise XOR assignment.</span><span id="ca3e" class="nh ls iq nd b gy nm nj l nk nl">|=<br/>Bitwise OR assignment.</span><span id="8419" class="nh ls iq nd b gy nm nj l nk nl">Destructuring assignment operators:</span><span id="f0a5" class="nh ls iq nd b gy nm nj l nk nl">[a, b] = [10, 20]<br/>{a, b} = {a:10, b:20}</span></pre><p id="ba63" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了这个建议，我们可以将逻辑运算符和赋值表达式结合起来:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="1e7d" class="nh ls iq nd b gy ni nj l nk nl">a ||= b<br/>//Equivalent to : a || (a = b), only assigns if a is Falsy.</span><span id="e916" class="nh ls iq nd b gy nm nj l nk nl">a &amp;&amp;= b<br/>//Equivalent to: a &amp;&amp; (a = b), only assigns if a is Truthy.</span><span id="ce3d" class="nh ls iq nd b gy nm nj l nk nl">a ??= b<br/>//Equivalent to: a ?? (a = b), only assigns if a is Nullish.</span></pre><h1 id="d667" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">数字分隔符</h1><p id="760a" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">数字分隔符(Christophe Porteneuve)扩展了现有的<a class="ae nn" href="https://tc39.github.io/ecma262/#prod-NumericLiteral" rel="noopener ugc nofollow" target="_blank"> <em class="ns"> NumericLiteral </em> </a>以允许数字之间的分隔符。</p><p id="cf04" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">由于这个特性，通过在数字组之间创建一个可视的分隔，可以很容易地使数字更具可读性。</p><p id="a028" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">例如:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="8e22" class="nh ls iq nd b gy ni nj l nk nl">const money = 1000000000000;</span></pre><p id="64c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">上面的数字文字很难阅读，但是我们可以使用下划线作为分隔符使其更容易阅读:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="5fab" class="nh ls iq nd b gy ni nj l nk nl">const money = 1_000_000_000_000;</span></pre><p id="e2f3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">好了，现在更容易读懂“钱”这个变量了。</p><p id="f0f7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">数字分隔符可以用在不同的位置:</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="cd6f" class="nh ls iq nd b gy ni nj l nk nl">const money = 1_000_000.123_456;</span></pre><p id="22dd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">另外，数字分隔符在八进制整数文本中也是可用的。</p><pre class="kg kh ki kj gt nc nd ne nf aw ng bi"><span id="de47" class="nh ls iq nd b gy ni nj l nk nl">const octal = 0o123_123;</span></pre><h1 id="12b8" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">结论</h1><p id="edb7" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mz lg lh li na lk ll lm nb lo lp lq ij bi translated">JavaScript不断地加入新的特性。在本文中，我们回顾了JavaScript ES2021 (ES12)中最有可能包含的一些特性。</p><p id="56b4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">谢谢你阅读我。保重！</p><h1 id="5f26" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">更多信息:</h1><ul class=""><li id="12d2" class="mj mk iq kx b ky ml lb mm le mn li mo lm mp lq mq mr ms mt bi translated"><a class="ae nn" href="https://medium.com/javascript-in-plain-english/new-javascript-features-in-es2020-c2d76acf9c5a" rel="noopener">es 2020(es 11)中的JavaScript新特性</a></li><li id="895b" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated"><a class="ae nn" href="https://medium.com/javascript-in-plain-english/javascript-module-namespace-exports-71dc7d1a75c0" rel="noopener">es 2020(ES11)中的JavaScript模块名称空间导出</a></li><li id="cceb" class="mj mk iq kx b ky mu lb mv le mw li mx lm my lq mq mr ms mt bi translated"><a class="ae nn" href="https://medium.com/javascript-in-plain-english/javascript-es2019-es10-in-a-nutshell-cae6f7524519" rel="noopener"> JavaScript在ES2019(ES10)中的新功能</a></li></ul><h1 id="18dc" class="lr ls iq bd lt lu lv lw lx ly lz ma mb jw mc jx md jz me ka mf kc mg kd mh mi bi translated">参考</h1><div class="nt nu gp gr nv nw"><a href="https://tc39.es/ecma262/" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">ECMAScript 2021语言规范</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">编辑描述</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">tc39.es</p></div></div></div></a></div><div class="nt nu gp gr nv nw"><a href="https://stackoverflow.com/" rel="noopener  ugc nofollow" target="_blank"><div class="nx ab fo"><div class="ny ab nz cl cj oa"><h2 class="bd ir gy z fp ob fr fs oc fu fw ip bi translated">堆栈溢出-开发人员学习、共享和构建职业生涯的地方</h2><div class="od l"><h3 class="bd b gy z fp ob fr fs oc fu fw dk translated">德诺怎么了？我们与一位主要撰稿人交谈以了解情况。现在听着。我们生产的产品能够增强…</h3></div><div class="oe l"><p class="bd b dl z fp ob fr fs oc fu fw dk translated">stackoverflow.com</p></div></div><div class="of l"><div class="og l oh oi oj of ok kp nw"/></div></div></a></div></div></div>    
</body>
</html>