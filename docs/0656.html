<html>
<head>
<title>Nuxt Automated Testing: The Tricky Parts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nuxt自动化测试:棘手的部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/nuxt-automated-testing-the-tricky-parts-773f04481dd0?source=collection_archive---------4-----------------------#2019-11-22">https://javascript.plainenglish.io/nuxt-automated-testing-the-tricky-parts-773f04481dd0?source=collection_archive---------4-----------------------#2019-11-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="7ea1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TL；DR——如果您点击了这篇文章，很可能您已经有点不知所措，试图对您的Nuxt应用程序的某些部分进行自动化测试。全面覆盖测试是另一个挑战，但值得努力。因为已经有很多很好的文章非常详细地描述了一般的自动化测试，所以本文将关注细节:主要是插件、模块和端到端测试的一些方面。</p><p id="48e4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">TL；DR2(2021年11月29日更新)——随着Nuxt3的推出和Nuxt 2.x的最新稳定版本，这篇文章的大部分内容可能会过时。该框架已经更新，使得传递插件选项变得更加容易，因此自本文最初撰写以来，测试已经大大简化。</p><p id="dfa0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">知识渊博和/或缺乏耐心的人可能希望跳过介绍，直接从下面的“测试Nuxt插件”部分开始。</p></div><div class="ab cl ki kj hr kk" role="separator"><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn ko"/><span class="kl bw bk km kn"/></div><div class="ig ih ii ij ik"><p id="3545" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">先决条件:</strong></p><ul class=""><li id="1cb3" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated">讨论的软件利用了<a class="ae ky" href="https://github.com/avajs/ava" rel="noopener ugc nofollow" target="_blank"> ava </a>测试框架(只是个人偏好)。不管选择了什么样的特定框架，测试框架通常是如何构造的知识应该有助于读者理解所示的代码。在ava中，<code class="fe kz la lb lc b">test</code>代表测试步骤，<code class="fe kz la lb lc b">t.is</code>、<code class="fe kz la lb lc b">t.true, t.pass, t.fail</code>用于执行断言，<code class="fe kz la lb lc b">t.timeout</code>用于控制给定测试步骤的超时。</li><li id="6a42" class="kp kq in jm b jn ld jr le jv lf jz lg kd lh kh ku kv kw kx bi translated">这个讨论的软件利用<a class="ae ky" href="https://github.com/istanbuljs/nyc" rel="noopener ugc nofollow" target="_blank">NYC/伊斯坦布尔</a>命令行工具来获得测试覆盖。</li></ul><p id="2f27" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">设置:</strong></p><ul class=""><li id="9e14" class="kp kq in jm b jn jo jr js jv kr jz ks kd kt kh ku kv kw kx bi translated">在<code class="fe kz la lb lc b">npx create-nuxt-app</code>期间指定一个测试框架应该已经成功地设置好了一切。如果没有，请咨询我的<a class="ae ky" href="https://github.com/richardeschloss/nuxt-socket-io" rel="noopener ugc nofollow" target="_blank"> Github repo </a>，它已经设置了测试、覆盖和CI/CD。(很大程度上归功于<a class="li lj ep" href="https://medium.com/u/2853bf3e5a26?source=post_page-----773f04481dd0--------------------------------" rel="noopener" target="_blank"> Vinayak Kulkarni </a>，因为他的<a class="ae ky" href="https://github.com/vinayakkulkarni/nuxt-ava-e2e-unit-testing" rel="noopener ugc nofollow" target="_blank">回购</a>是我测试工作的基础)。复制并运行已知的工作代码应该是最简单的开始方式。</li><li id="151d" class="kp kq in jm b jn ld jr le jv lf jz lg kd lh kh ku kv kw kx bi translated">也已经有很多很棒的文章详细描述了正确的测试设置。这种详细程度是值得的，但超出了本文的范围。</li></ul><p id="2977" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">简介:</strong></p><p id="4413" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我喜欢成为某种程度上的极简主义者:我只想编写需要的代码。同样，说到测试，我只想测试我需要做的事情<em class="lk">。尽管很痛苦，我还是选择测试覆盖率，因为这样做总是会挤出两样东西:1)死代码和2)诚实。当我说代码没有膨胀，100%的覆盖率就是证明。例如，任何人都可以在他们的测试中像这样撒谎:</em></p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="3781" class="lt lu in lc b gy lv lw l lx ly">test('all my code', (t) =&gt; t.pass())</span></pre><p id="31b9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个测试总是会通过，并且测试报告会说“通过”，但是如果眼睛也看到0%的覆盖率，他们会知道没有代码被实际测试。</p><p id="43fc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">作为前面提到的目标的必然结果，我也只想模仿<em class="lk">我需要</em>做的事情。我不想嘲笑这个星球，只是最基本的东西。</p><p id="6099" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">测试Nuxt插件:</strong></p><p id="58d8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于Nuxt插件，可以说一件至关重要的事情:插件并不完全是JavaScript。它们看起来和感觉上都像JavaScript，但是…这有点像幻觉。Nuxt插件实际上是一个<em class="lk">预编译的JS模板</em>，Nuxt <a class="ae ky" href="https://github.com/nuxt/nuxt.js/blob/92c7f4ed249466870a477798f910c84eb1fdd18d/packages/builder/src/builder.js#L574" rel="noopener ugc nofollow" target="_blank">在构建你的应用时会编译这个模板</a>。具体来说，就是Nuxt用<a class="ae ky" href="https://lodash.com/docs/4.17.15#template" rel="noopener ugc nofollow" target="_blank"> lodash </a>编译的嵌入式Ruby ( <a class="ae ky" href="https://ruby-doc.org/stdlib-2.6.5/libdoc/erb/rdoc/ERB.html" rel="noopener ugc nofollow" target="_blank"> ERB </a>)模板。使用这些模板是为了让Nuxt可以用您在nuxt.config中指定的插件选项来编译您的插件:</p><p id="e365" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">nuxt.config:</p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="9655" class="lt lu in lc b gy lv lw l lx ly">{<br/>  ...<br/>  plugins: [ './Plugin.js', { options: { userId: 123 } } ]<br/>  ...<br/>}</span></pre><p id="2669" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">插件. js:</p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="57a3" class="lt lu in lc b gy lv lw l lx ly">const myPluginOptions = &lt;%= JSON.stringify(options) =&gt;</span></pre><p id="deec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当Nuxt构建您的应用程序时，编译后的插件将如下所示:</p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="2325" class="lt lu in lc b gy lv lw l lx ly">const myPluginOptions = { userId: 123 }</span></pre><p id="2efe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这看起来很简单，然而，当测试<code class="fe kz la lb lc b">‘./Plugin.js’</code>时，很可能需要用不同的选项进行测试。乍一看，似乎每个选项集都需要一个单独的编译步骤，写入<code class="fe kz la lb lc b">plugin.compiled.js</code>，然后将编译后的插件导入到测试中。然而，再次导入插件将要求我们记得清除先前持有的require缓存，否则，我们将总是用第一个选项集进行测试。此外，如果我们一次又一次地覆盖已编译的插件，我们在技术上改变了覆盖工具使用的源地图，从而使100%的覆盖捕获无法实现。相反，如果我们选择编写多个编译后的文件，我们将得到这些文件的单独覆盖率，并且总覆盖率不会显示为100%，即使一个文件有10%，而另一个文件有90%。但是，我们的目标仍然是报告100%的总数，因为CI系统通常使用这个数字。</p><p id="d921" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过对插件处理选项的方式进行一些调整，测试可以变得更加容易:</p><figure class="ll lm ln lo gt ma gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/9ce82475a8a55d72dbafdf5683d6db65.png" data-original-src="https://miro.medium.com/v2/resize:fit:882/format:webp/1*EjYhwelWvci5YDVnacTa-Q.jpeg"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Plugin Options: Another Approach</figcaption></figure><p id="b761" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的想法是仅在测试模式下将getters和setters包装在插件选项周围。在任何其他模式下，插件选项将被限制在插件的范围内，setters被禁用，插件选项仅来自<code class="fe kz la lb lc b">nuxt.config</code>。这样，插件只需要在所有测试运行之前编译一次，测试可以根据需要提供任意多的选项。</p><p id="9540" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">要编译上面的插件，人们可能认为用<code class="fe kz la lb lc b">lodash/template</code>就可以了，使用默认设置:</p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="e884" class="lt lu in lc b gy lv lw l lx ly">const content = (read plugin.js)<br/>const compiled = template(content) // Problems await...</span></pre><p id="aa99" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，这段代码忽略了一个关键的警告。在撰写本文时，<code class="fe kz la lb lc b">lodash</code>默认情况下不仅编译ERB模板，还编译ES6模板文字字符串。如果插件的代码编写如下:</p><p id="17bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kz la lb lc b">const errMsg = `${err} do something`</code></p><p id="10f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe kz la lb lc b">lodash</code>的<code class="fe kz la lb lc b">compiled </code>函数将期望被提供一个已定义的<code class="fe kz la lb lc b">err</code>，以便它可以相应地替换<code class="fe kz la lb lc b">err</code>令牌:</p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="9db0" class="lt lu in lc b gy lv lw l lx ly">let pluginJS = compiled({options}) <br/>// --&gt; lodash throws error: "err undefined!"</span><span id="d11c" class="lt lu in lc b gy mh lw l lx ly">const pluginJS = compiled({options, err: 'Umm'})<br/>// --&gt; lodash will create:<br/>// const errMsg = 'Umm do something'<br/>//(Probably not what you want)</span></pre><p id="7af3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，最有可能的是，当在你的插件中使用ES6模板文字时，你可能期望<em class="lk">你的代码</em>，而不是<code class="fe kz la lb lc b">lodash</code>来替换令牌。如果确实如此，<code class="fe kz la lb lc b">lodash</code>只需要一个插值覆盖，它只指定ERB模板，而不指定<em class="lk">ES6模板文字(仅供参考，这正是Nuxt构建器所做的):</em></p><figure class="ll lm ln lo gt ma gh gi paragraph-image"><div class="gh gi mi"><img src="../Images/910b55eae0644a947bc85bec32f490e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1294/format:webp/1*F0Q21T05YgYe2k5ITpJ2dw.jpeg"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Compile Plugin Example (with interpolate override)</figcaption></figure><p id="ca20" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上述示例将编译一个包含以下内容的插件:</p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="b600" class="lt lu in lc b gy lv lw l lx ly">// Using JSON.stringify (preferred)<br/>const pluginOptions = &lt;%= JSON.stringify(options) %&gt;</span><span id="65d4" class="lt lu in lc b gy mh lw l lx ly">/* Using serialize (discouraged, but required if options contains functions)*/<br/>const pluginOptions = &lt;%= serialize(options) %&gt; </span><span id="3fd5" class="lt lu in lc b gy mh lw l lx ly">let err = 'Real error this time'<br/>let errMsg = `${err} occurred`<br/>// --&gt; errMsg = 'Real error this time occurred'<br/>// --&gt; Your code replaced "err", lodash did not, as expected.</span></pre><p id="1427" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然已经讨论了编译插件的方法，我们就来讨论插件测试和嘲讽。Nuxt中的许多插件都有一个类似如下的结构:</p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="9cca" class="lt lu in lc b gy lv lw l lx ly">function someFn(args) {</span><span id="49c2" class="lt lu in lc b gy mh lw l lx ly">  const out = [do something with args]<br/>  this.$store.commit('someData', 'correctData')<br/>  this.$store.commit('someData', 'incorrectData')<br/>  return out<br/>}</span><span id="b058" class="lt lu in lc b gy mh lw l lx ly">export default function(context, inject) {</span><span id="d4de" class="lt lu in lc b gy mh lw l lx ly">  inject('someFn', someFn)<br/>}</span></pre><p id="b545" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">可以，Nuxt插件可以和Vuex商店交互(<code class="fe kz la lb lc b">$store</code>附属于<code class="fe kz la lb lc b">this</code>)。但是，为了测试这个示例插件，我们不需要重新创建所有的Vuex，只需要重新创建提交方法。所以，假设上面的插件被编译成一个临时文件<code class="fe kz la lb lc b">plugin.compiled.js</code>，我们可以这样测试它:</p><p id="6e65" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在所有测试之前，通过动态导入来加载编译后的插件<code class="fe kz la lb lc b">plugin.compiled.js</code>。然后，对于实际的插件测试，模拟上下文和注入函数。当插件运行时，在某些方法运行之后运行断言，在本例中是在调用<code class="fe kz la lb lc b">$store.commit</code>之后。这里需要注意的一个关键点是<code class="fe kz la lb lc b">$store</code>和<code class="fe kz la lb lc b">someFn</code>被封装在同一个对象中，这样当<code class="fe kz la lb lc b">someFn</code>点击它时<code class="fe kz la lb lc b">this</code>和<code class="fe kz la lb lc b">this.$store</code>被定义。</p><figure class="ll lm ln lo gt ma gh gi paragraph-image"><div class="gh gi mj"><img src="../Images/f40bf05a315afe64e0a1881e5dd8e042.png" data-original-src="https://miro.medium.com/v2/resize:fit:1164/format:webp/1*c61PWs0ZPCdWrdhcLN4jEg.jpeg"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Loading Plugin with Mocks in Place</figcaption></figure><p id="c0d5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于这个特殊的例子，有了这些检查，当插件提交不正确的数据时，测试应该会失败。即使测试将获得几乎100%的覆盖率，它仍然会有一部分失败(这对我们的测试来说是一件好事！).</p><p id="3cc6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">测试Nuxt模块:</strong></p><p id="9e25" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">Nuxt中的许多模块具有以下结构:</p><figure class="ll lm ln lo gt ma gh gi paragraph-image"><div class="gh gi mk"><img src="../Images/a48ca9126925852f89817762e811a2ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1248/format:webp/1*cIhXB2qZJ_Yqo6Wj5mXjZA.jpeg"/></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Example Module</figcaption></figure><p id="7b7f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中，分配了模块选项，注册了一个nuxt挂钩，并添加了一个插件。幸运的是，为了测试这个模块，我们不需要模仿所有的Nuxt，只需要模仿我们需要的部分。下图显示了这一点:</p><figure class="ll lm ln lo gt ma gh gi paragraph-image"><div role="button" tabindex="0" class="mm mn di mo bf mp"><div class="gh gi ml"><img src="../Images/a2ed4d156e5a50c7234e5a8381aba9bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1396/format:webp/1*2p11G1XgukYK0C0le66tQw.jpeg"/></div></div><figcaption class="md me gj gh gi mf mg bd b be z dk">Example: Mocking to Test Nuxt Module</figcaption></figure><p id="7190" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如上图所示，当<code class="fe kz la lb lc b">SomeModule</code>运行，遇到<code class="fe kz la lb lc b">this.nuxt</code>和<code class="fe kz la lb lc b">this.addPlugin</code>时，没有真正的Nuxt运行，也没有真正的插件添加正在进行。为了测试这个模块，这就有点过分了。编写测试是为了验证对于我们提供的选项，模块是否按照我们想要的方式响应。</p><p id="6394" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">并且，像在插件测试示例中一样，将模块封装在一个也包含模拟的对象中，在使用时为“<code class="fe kz la lb lc b">this</code>”提供了适当的上下文。</p><p id="7a59" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> Nuxt端到端测试:</strong></p><p id="09e5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">关于端到端(e2e)测试(不仅仅是针对Nuxt)需要知道的一件重要事情是，它通常需要更长的时间来运行，并且可靠地运行<em class="lk"/>可能更具挑战性。当运行e2e测试时，通常会有更多的事情超出测试人员的控制。例如，一些e2e测试需要在Nuxt上等待构建应用程序的所有<em class="lk">和</em>，这个时间不是恒定的，但通常会相对较长。必须为设置超时设置任意值。此外，当运行测试时，无法控制路由呈现时间，因此也需要指定任意的测试超时。因此，当希望只知道<em class="lk">增量代码变更的效果时，将e2e测试推迟到</em>单元测试通过后的<em class="lk">可能是个好主意。</em></p><p id="b436" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，e2e测试仍然提供了应用程序性能或退化的良好指示，并且在适当的情况下可能值得执行。幸运的是，Nuxt有一些方法可以帮助我们对此进行量化:<code class="fe kz la lb lc b">renderRoute</code>和<code class="fe kz la lb lc b">renderAndGetWindow</code>。前者只给出html(如果需要，需要传递给JSDOM)，后者给出窗口(已经附加了DOM)。可以通过以下方式检查性能:</p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="2807" class="lt lu in lc b gy lv lw l lx ly">test('Render time', async (t) =&gt; {</span><span id="f281" class="lt lu in lc b gy mh lw l lx ly">  const t.timeout(3000) // Rendering should take &lt;= 3 sec</span><span id="a7a8" class="lt lu in lc b gy mh lw l lx ly">  console.time('renderTime')<br/>  const window = await nuxt.renderAndGetWindow('localhost:3000')</span><span id="4022" class="lt lu in lc b gy mh lw l lx ly">  console.timeEnd('renderTime')<br/>  // --&gt; renderTime: 2500 ms</span><span id="7088" class="lt lu in lc b gy mh lw l lx ly">  t.pass() // Test passes if we get here in &lt;= 3 sec<br/>})</span></pre><p id="2fb5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记录时间不是必要的，但仍然是有用的。分析呈现时间的CI / CD系统可以发现web应用程序的某些方面何时变得更糟，并抢先提供警告。也就是说，测试可能会连续通过，但可能会报告:“renderTime: 2500 ms，2600 ms，2700 ms…[接近失败，警告某人]”</p><p id="c868" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的代码中可能不太明显的是，隐藏在呈现方法中的是这些方法在内部使用的全局加载超时。设置<code class="fe kz la lb lc b">t.timeout(3000)</code>不会覆盖那些内部超时。相反，为了覆盖那些，<code class="fe kz la lb lc b">globals</code>属性只需要在<code class="fe kz la lb lc b">nuxt.config</code>中更新:</p><pre class="ll lm ln lo gt lp lc lq lr aw ls bi"><span id="cfa3" class="lt lu in lc b gy lv lw l lx ly">globals: {<br/>  loadingTimeout: 5000<br/>}</span></pre><p id="9bb2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，需要注意的一件重要事情是:<code class="fe kz la lb lc b">nuxt.renderRoute</code>和<code class="fe kz la lb lc b">nuxt.renderAndGetWindow</code>将只在你构建并启动的Nuxt实例上工作，这一点可能很明显，也可能不明显，尤其是如果你来自Selenium Webdriver思维模式的话。Nuxt不能神奇地与您已经在机器上启动的所有单独的Nuxt实例进行交互。因此，如果您计划运行两个单独的Nuxt实例，一个用于实际的应用程序(<code class="fe kz la lb lc b">npm run dev</code>)，另一个用于检测UI ( <code class="fe kz la lb lc b">npm run test:e2e</code>)，那么单独实例中的测试将无法呈现应用程序的路径。对于这种工具，像Selenium、Nightwatch、Cypress这样的工具可能更适合本文。</p><p id="761a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">其他棘手的部分(非Nuxt特有):</strong></p><p id="9dcd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输入验证。在这方面我不会涉及太多细节，因为输入验证是一个更广泛的话题，不仅仅适用于Nuxt测试。我要说的是:代码仍然有可能通过测试并达到100%的覆盖率，并且<em class="lk">仍然</em>引起用户的关注。测试可能不总是以用户可能的所有方式提供输入，并且对于验证具有嵌套复杂性的混合数据类型将花费多少计算成本，这是一个工程决策。</p><p id="a41f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">结论:</strong></p><p id="2a57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">本文涵盖了自动化Nuxt测试时可能面临的一些不太明显的挑战。本文探讨了专门测试Nuxt插件、模块以及使用Nuxt API进行e2e测试的问题。关键的一点是，当你迭代时，只测试你所需要的，把全面的测试委托给你云中的CI系统。获得对测试的完全控制可以让这个过程变得更加愉快、可行和不那么令人畏惧。尽管乍一看可能不是这样，但在许多情况下，正确完成的自动化测试可以比热模块重载更快地给你带来满足感，尽管这听起来很疯狂。热模块重载是web开发中最整洁的事情之一，我觉得，然而我仍然认为自动测试的热重载更酷。只是我的看法。</p><p id="1b54" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">测试愉快。我希望我在您的测试工作中为您节省了大量时间。</p><p id="aea9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">还在迷茫？受挫？在<a class="ae ky" href="https://www.linkedin.com/in/richardeschloss/" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上找到我，让我知道我能帮上什么忙！</p></div></div>    
</body>
</html>