<html>
<head>
<title>Algorithms 101: Pascal’s Triangle in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:JavaScript中的帕斯卡三角</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-101-pascals-triangle-in-javascript-9fbd9032871?source=collection_archive---------0-----------------------#2019-10-15">https://javascript.plainenglish.io/algorithms-101-pascals-triangle-in-javascript-9fbd9032871?source=collection_archive---------0-----------------------#2019-10-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="bd0a" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Noob诉算法# 13——一次解决一行问题</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/d0df474071d9089cc818dcb46ac3cb2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:952/format:webp/1*uq3wh8RtvgYLOWoCqqW0ig.png"/></div></figure><p id="ca60" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在我不断练习算法的过程中，我遇到了今天来自LeetCode的挑战【T0:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi lk"><img src="../Images/21e946bad14a32d8a32a8aa8c2fa7b05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JbSP-i4gx-YBNMDUO-fd2A.png"/></div></div></figure><p id="ae05" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了构建这个三角形，我们需要注意一些事情。</p><ol class=""><li id="791c" class="lp lq iq kp b kq kr kt ku kw lr la ls le lt li lu lv lw lx bi translated">每一行都以1开始和结束。</li><li id="1a68" class="lp lq iq kp b kq ly kt lz kw ma la mb le mc li lu lv lw lx bi translated">在每一行中，在1之间，每一个数字是紧接在它上面的两个数字的和。</li><li id="4fb3" class="lp lq iq kp b kq ly kt lz kw ma la mb le mc li lu lv lw lx bi translated">我们可以使用这个模式从第3行开始构建新的行。但是我们不能用它来构建第一行或第二行。</li><li id="6b6a" class="lp lq iq kp b kq ly kt lz kw ma la mb le mc li lu lv lw lx bi translated">每一行都表示为一个数组；我们需要将整个三角形输出为这些行的数组(即数组的数组)。</li></ol><h1 id="ba2a" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">一寸一寸，一排一排…</h1><p id="5c5d" class="pw-post-body-paragraph kn ko iq kp b kq mv jr ks kt mw ju kv kw mx ky kz la my lc ld le mz lg lh li ij bi translated">每当我在研究算法时，我都试图把问题分解成更小的问题。在这种情况下，不要担心构建整个三角形，让我们关注一个更简单的任务:如果我们知道前一行是什么样子，我们如何构建下一行？</p><p id="80ed" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们稍后将处理边缘情况。现在，让我们假设我们应该建立至少3行这个三角形。因为我们的模式从第3行开始，所以让我们用前两行作为三角形的种子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi na"><img src="../Images/77dd9efc1db35202aa8a1f8eb8e040c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qvknmgcjhuUAalHovuA-Pg.png"/></div></div></figure><p id="0a20" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在让我们来看看如何构建第3行:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nb"><img src="../Images/c27a3b8c10c8f8126d9f4439c14f5b57.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Xxadx8fRuronFXqOgkR_Ng.png"/></div></div></figure><p id="8add" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了计算第3行中间的金额，我们需要访问第2行。具体来说，我们需要将第2行的两位数字相加，以计算第3行中间的数字。</p><p id="920e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">从第3行生成第4行:同样，我们以1开始和结束。为了计算第一个“3”，我们将前一行的第一个和第二个数字相加。为了计算第二个“3”，我们将前一行的第二位和第三位数字相加。</p><p id="a4d5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以对于每一行，不管它有多长，我们都需要从一个1开始，循环遍历前一行来计算中间的数字，然后在末尾添加另一个1。</p><h1 id="1475" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">我们需要循环多少次？</h1><p id="5170" class="pw-post-body-paragraph kn ko iq kp b kq mv jr ks kt mw ju kv kw mx ky kz la my lc ld le mz lg lh li ij bi translated">我们需要计算的每个数字一次。对于第4行，它有四个数字，因为我们知道第一个和最后一个数字是1，我们只需要计算两个数字。对于第5行，我们需要计算3位数。</p><p id="269b" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">因为我们循环第3行来计算第4行的两个中间数字，我们可以说我们需要循环第3行两次，这比第3行的长度少一个。所以循环次数，<em class="nc"> i </em>，应该小于<em class="nc">前一个</em>的长度。</p><p id="8945" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">循环结束后，我们将在行尾再加1。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nd"><img src="../Images/e953818c847c2d233130f850f7004389.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3wnoeVrAXe0rPag32s605g.png"/></div></div></figure><p id="18cb" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在我们有了从以前的行创建新行的逻辑，我们把它放在哪里呢？我决定把它放在自己的函数里，这个函数以一个三角形作为参数，定义<em class="nc"> previous </em>为三角形的最后一行:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ne"><img src="../Images/c7969c6db57b3cb26f79b3f0fed289d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_T3i1d-xJPlxLJK9JUu0bA.png"/></div></div></figure><p id="e2e8" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然后我决定从我的主函数中调用这个函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nf"><img src="../Images/e50b9fddf3867917e1eac2714cb917c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aMeQeZrOIoj8V2WEgyWP6Q.png"/></div></div></figure><h1 id="fd58" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">重复x次…</h1><p id="6142" class="pw-post-body-paragraph kn ko iq kp b kq mv jr ks kt mw ju kv kw mx ky kz la my lc ld le mz lg lh li ij bi translated">下一个挑战:我们需要运行<em class="nc"> addRow(triangle) </em>多少次，我们该怎么做？</p><p id="356a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">第一个问题很简单。假设numRows是10。我们从两排开始。所以我们需要再生成8个，也就是numRows减2。</p><p id="0e4c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">下一个问题在Ruby中更容易解决。如果你像我一样喜欢Ruby，你会知道它有这个很棒的重复动作的方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi ng"><img src="../Images/4ea1e4c9f9d25225c9cf3ab7713ad5e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPCqGw_-Gj99T8ulmErPqQ.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Ruby is so intuitive … but we’re working JavaScript</figcaption></figure><p id="582e" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在JavaScript中，您可以通过for循环来实现这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nl"><img src="../Images/7d19eeacca544cd228589d2a39370570.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*30Rz6N8tZuNixdVMsgSPMQ.png"/></div></div></figure><p id="5d23" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这给了我们这个:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nm"><img src="../Images/bf228fa5f40343e777ef001411e6a471.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FPSo5f1sQcIITVLYam3szw.png"/></div></div></figure><h1 id="2b9f" class="md me iq bd mf mg mh mi mj mk ml mm mn jw mo jx mp jz mq ka mr kc ms kd mt mu bi translated">不要忘记边缘案例</h1><p id="b279" class="pw-post-body-paragraph kn ko iq kp b kq mv jr ks kt mw ju kv kw mx ky kz la my lc ld le mz lg lh li ij bi translated">现在，我们只需要处理边缘案件。我们的函数假设我们必须构建至少三行。但是如果<em class="nc"> numRows </em>小于3呢？</p><p id="a093" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果是0，我们不想返回三角形，这是一个空数组:<code class="fe nn no np nq b">[]</code>如果是1，我们只想返回第一行<code class="fe nn no np nq b">[[1]]</code>等等:</p><p id="91a1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">现在一起:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nr"><img src="../Images/764d8a9fbf576dbf5560cb37b278cb81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*P8DvYngjug8Le_huuLLrLg.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">You can play with this code <a class="ae lj" href="https://repl.it/@Joan_IndianaInd/Pascals-Triangle" rel="noopener ugc nofollow" target="_blank">on repl.it.</a></figcaption></figure><p id="be9c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这不是最短的解决方案，但很容易理解。而且表现也很好！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="ll lm di ln bf lo"><div class="gh gi nm"><img src="../Images/d2dc39aacc47f0c0fe5988ab5b9f9f72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HAPNSl6gpq_oVzBBCh2oaQ.png"/></div></div></figure><p id="3707" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">版权所有琼·印第安纳·琳斯2019</p><p id="ecb5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">接下来:<em class="nc">算法101 # 14:</em><a class="ae lj" href="https://medium.com/@joanrigdon/algorithms-101-happy-number-in-javascript-bddeb3d17035" rel="noopener"><em class="nc">JavaScript中的快乐数字</em> </a></p><p id="0d5f" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><em class="nc">以防你错过:算法101 #12: </em> <a class="ae lj" href="https://medium.com/javascript-in-plain-english/algorithms-101-learn-recursion-with-nesting-dolls-javascript-a8c334fe65f6" rel="noopener"> <em class="nc">用嵌套玩偶</em> </a>学习JavaScript中的递归</p></div></div>    
</body>
</html>