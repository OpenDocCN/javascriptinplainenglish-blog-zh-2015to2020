<html>
<head>
<title>JavaScript Drag and Drop With Backend Interactivity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript拖放和后端交互</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-drag-and-drop-with-backend-interactivity-90f5ed68e576?source=collection_archive---------2-----------------------#2019-10-08">https://javascript.plainenglish.io/javascript-drag-and-drop-with-backend-interactivity-90f5ed68e576?source=collection_archive---------2-----------------------#2019-10-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="7a16" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">增加拖放功能的功能和实用性</h2></div><p id="e00f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我将介绍一个JavaScript拖放特性，它可以与后端API进行交互和更新。我将从呈现的API数据中添加DOM元素，使这些元素可拖放，并更新API以响应拖放。我将解释一些基本的拖放组件，但是如果您需要进一步的指导，可以查看本文末尾的参考资料。</p><p id="2b19" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是我将构建的功能:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/892d3ed728ce281b01e41bd7f9b68a0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cI_HuSTN1qkylWOB.gif"/></div></div></figure><p id="59cd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您想测试应用程序，<a class="ae lk" href="https://github.com/mrwerner392/drag-and-drop-tasks" rel="noopener ugc nofollow" target="_blank">这里是存储库</a>。</p><p id="a5b9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了，让我们开始吧。</p><h1 id="3e97" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">步骤0:将HTML元素保存为变量</h1><p id="fb54" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我们的任务有两个“容器”,我们将在几个地方需要它们，所以在开始之前，让我们将它们保存到JavaScript文件顶部的全局变量中。这些容器只是HTML文件中的<code class="fe mi mj mk ml b">&lt;div&gt;</code>元素:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="09da" class="mq lm in ml b gy mr ms l mt mu">const unfinishedTasks = document.querySelector('#unfinished-tasks');<br/>const finishedTasks = document.querySelector('#finished-tasks');</span></pre><h1 id="732a" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">步骤1:从后端获取数据</h1><p id="8d2a" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我有一个Rails API后端，里面有一些关于任务的数据。每个任务有两个属性:“内容”(类型string)和“完成”(类型boolean)。我们可以使用<code class="fe mi mj mk ml b">fetch()</code>来获取这个任务数据:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="9deb" class="mq lm in ml b gy mr ms l mt mu">fetch('http://localhost:3000/tasks')<br/>.then(res =&gt; res.json())<br/>.then(tasksArr =&gt; {<br/>  tasksArr.forEach(task =&gt; handleTask(task))<br/>});</span></pre><p id="7f8c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">解析完数据后，我们有了一个任务对象数组，我们遍历这个数组，对每个任务对象调用(待定)<code class="fe mi mj mk ml b">handleTask()</code>函数。</p><h1 id="6502" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">步骤2:将数据转换成可拖动的DOM元素</h1><p id="2044" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">让我们定义上面调用的<code class="fe mi mj mk ml b">handleTask()</code>方法:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="9fa4" class="mq lm in ml b gy mr ms l mt mu">function handleTask(task) {</span><span id="fa52" class="mq lm in ml b gy mv ms l mt mu">  let taskPTag = document.createElement('p');<br/>  taskPTag.innerText = task.content;<br/>  taskPTag.id = `task ${task.id}`;<br/>  taskPTag.classList.add('task');<br/>  taskPTag.dataset.databaseId = task.id;</span><span id="d390" class="mq lm in ml b gy mv ms l mt mu">  if (task.finished === true) {<br/>    taskPTag.dataset.id = 'finished';<br/>    finishedTasks.append(taskPTag);<br/>  } else {<br/>    taskPTag.dataset.id = 'unfinished'<br/>    unfinishedTasks.append(taskPTag);<br/>  };</span><span id="332b" class="mq lm in ml b gy mv ms l mt mu">  taskPTag.setAttribute('draggable', 'true');<br/>  addDragEventListeners(task, taskPTag);</span><span id="da9f" class="mq lm in ml b gy mv ms l mt mu">};</span></pre><p id="8f71" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个功能的大部分只是为每个任务创建一个<code class="fe mi mj mk ml b">&lt;p&gt;</code>元素，给它文本和一堆属性，并把它放在适当的任务容器中。除了类——它是用来设计样式的——在我们的JavaScript中，每个属性都有特定的用途。</p><p id="cc03" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个函数的最后两行是拖放功能真正开始的地方。第一个给了我们的新<code class="fe mi mj mk ml b">&lt;p&gt;</code>另一个名为“draggable”的属性，并将其值设置为“true”这个恰当命名的属性使得每个新的<code class="fe mi mj mk ml b">&lt;p&gt;</code>可以拖动。第二个调用了一个名为<code class="fe mi mj mk ml b">addDragEventListeners()</code>的方法，并将我们的<code class="fe mi mj mk ml b">task</code>对象和我们新创建的<code class="fe mi mj mk ml b">&lt;p&gt;</code>作为参数传入。我们将在下一步中定义和分析这个方法。</p><h1 id="cd5a" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">步骤3:向可拖动元素添加拖动事件侦听器</h1><p id="fa7b" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">如果我们从上一步中注释掉<code class="fe mi mj mk ml b">addDragEventListeners()</code>的方法调用，我们的功能将如下所示:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/417c18df1771745b524da01717364c60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eDGgIwVQOl4Eullv.gif"/></div></div></figure><p id="ef8b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以拖动我们的任务，但是当我们放下它们时什么也不会发生。为了解决这个问题，我们首先需要向我们的<code class="fe mi mj mk ml b">&lt;p&gt;</code>添加一些事件监听器，这是我们用<code class="fe mi mj mk ml b">addDragEventListeners()</code>函数完成的。我们在上一步中调用了这个函数——现在让我们看看它的定义:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="9e34" class="mq lm in ml b gy mr ms l mt mu">function addDragEventListeners(task, taskPTag) {</span><span id="c6d3" class="mq lm in ml b gy mv ms l mt mu">  taskPTag.addEventListener('dragstart', evt =&gt; {<br/>    evt.dataTransfer.setData('text', evt.target.id);<br/>  }, false);</span><span id="0449" class="mq lm in ml b gy mv ms l mt mu">  taskPTag.addEventListener('dragend', evt =&gt; {<br/>    evt.dataTransfer.clearData();<br/>    if (document.querySelector('.over')) {<br/>      document.querySelector('.over').classList.remove('over');<br/>    };<br/>  });</span><span id="0158" class="mq lm in ml b gy mv ms l mt mu">};</span></pre><p id="7dca" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于我们的每个<code class="fe mi mj mk ml b">&lt;p&gt;</code>,我们添加两个事件监听器:一个用于“dragstart ”,一个用于“dragend”。在“dragstart”上，我们获取被拖动的<code class="fe mi mj mk ml b">&lt;p&gt;</code>的id，并将其传递给一个名为<code class="fe mi mj mk ml b">dataTransfer</code>的拖动事件属性。这允许我们从不同的事件侦听器中访问该id，稍后我们将使用它来访问被拖动的元素本身。在“dragend”中，我们从<code class="fe mi mj mk ml b">dataTransfer</code>中清除这个信息，然后if语句用于样式目的(类名“over”是给容器绿色阴影的原因，我们不希望当拖动循环结束时这个阴影还在。)</p><p id="427f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将拖动事件侦听器添加到可拖动元素中只是解决了一半问题。现在我们需要建立我们的空投区。</p><h1 id="b1ed" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">步骤4:设置拖放区</h1><p id="d30c" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">除非我们告诉他们，否则元素不会成为可接受的拖放区。我们通过给它们一些拖动事件监听器来做到这一点。我们有两个拖放区，每个拖放区需要相同的事件侦听器。我们将定义一个函数<code class="fe mi mj mk ml b">addDropzoneEventListeners()</code>,并为每个拖放区调用该函数。这是事情变得有点忙乱的地方，所以让我们分块来做。</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="3b8d" class="mq lm in ml b gy mr ms l mt mu">addDropzoneEventListeners(unfinishedTasks);<br/>addDropzoneEventListeners(finishedTasks);</span><span id="fcbb" class="mq lm in ml b gy mv ms l mt mu">function addDropzoneEventListeners(dropzone) {</span><span id="9b1b" class="mq lm in ml b gy mv ms l mt mu">  dropzone.addEventListener('dragover', evt =&gt; {<br/>    evt.preventDefault();<br/>    evt.currentTarget.classList.add('over');<br/>  }, false);</span><span id="190a" class="mq lm in ml b gy mv ms l mt mu">  dropzone.addEventListener('dragleave', evt =&gt; {<br/>    evt.currentTarget.classList.remove('over');<br/>  }, false);</span><span id="03dd" class="mq lm in ml b gy mv ms l mt mu">  ...</span><span id="67df" class="mq lm in ml b gy mv ms l mt mu">};</span></pre><p id="b0e3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们的<code class="fe mi mj mk ml b">addDropzoneEventListeners()</code>函数将为每个拖放区添加三个事件监听器，其中两个如上所示。这两个“dragover”和“dragleave”服务于双重目的。首先是防止实际“拖动”事件的默认行为。默认行为不允许发生丢弃，所以我们需要防止这种情况发生。这些事件侦听器的另一个目的是用于样式化，因为我们在被拖动的拖放区上添加和移除一个“over”类。如前所述，这就是绿框阴影的来源(对功能来说并不重要，但对用户来说是一个很好的特性)。</p><p id="7c49" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好了，现在是最后一部分——处理实际的下落。这是更新我们的DOM并与我们的后端交互的部分。让我们添加最后一个事件监听器:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="5797" class="mq lm in ml b gy mr ms l mt mu">addDropzoneEventListeners(unfinishedTasks);<br/>addDropzoneEventListeners(finishedTasks);</span><span id="b1b9" class="mq lm in ml b gy mv ms l mt mu">function addDropzoneEventListeners(dropzone) {</span><span id="50a2" class="mq lm in ml b gy mv ms l mt mu">  ...</span><span id="0b87" class="mq lm in ml b gy mv ms l mt mu">  dropzone.addEventListener('drop', evt =&gt; {<br/>        <br/>    let elemId = evt.dataTransfer.getData('text');<br/>    let droppedElem = document.getElementById(elemId);</span><span id="ccd4" class="mq lm in ml b gy mv ms l mt mu">    if (droppedElem.dataset.id !== evt.currentTarget.dataset.id) {</span><span id="d4d3" class="mq lm in ml b gy mv ms l mt mu">      evt.currentTarget.append(droppedElem);<br/>      evt.dataTransfer.clearData();</span><span id="ba23" class="mq lm in ml b gy mv ms l mt mu">      const dataIdToggle = {<br/>        'finished': 'unfinished',<br/>        'unfinished': 'finished'<br/>      };<br/>      droppedElem.dataset.id = dataIdToggle[droppedElem.dataset.id];</span><span id="c63d" class="mq lm in ml b gy mv ms l mt mu">      const databaseAttributeMap = {<br/>        'finished': true,<br/>        'unfinished': false<br/>      };<br/>      let isFinished = databaseAttributeMap[droppedElem.dataset.id];<br/>      let id = droppedElem.dataset.databaseId;<br/>      <br/>      fetch(`http://localhost:3000/tasks/${id}`, {<br/>        method: 'PATCH',<br/>        headers: {<br/>          'Content-Type': 'application/json',<br/>          Accept: 'application/json'<br/>        },<br/>        body: JSON.stringify({<br/>          'finished': isFinished<br/>        })<br/>      })<br/>      .then(res =&gt; res.json())<br/>      .then(task =&gt; {<br/>        task.finished === true ? alert('Way to Go!!!') : alert('Darn<br/>        😕')<br/>      });</span><span id="a9a6" class="mq lm in ml b gy mv ms l mt mu">    };</span><span id="27d3" class="mq lm in ml b gy mv ms l mt mu">  }, false);</span><span id="dd01" class="mq lm in ml b gy mv ms l mt mu">};</span></pre><p id="bcb7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们来分析一下。首先，我们使用<code class="fe mi mj mk ml b">evt.dataTransfer.getData()</code>来访问被拖放的元素的id，然后找到实际的元素。然后我们有一个<code class="fe mi mj mk ml b">if</code>语句，它的目的是确定一个“已完成”的任务是否被放到了“未完成”的任务容器中，反之亦然。如果是，我们继续。否则，拖动循环结束，被拖动的元素返回到原来的位置。如果一个任务被放在它开始的同一个容器中，什么都不需要发生。</p><p id="bd16" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果<code class="fe mi mj mk ml b">if</code>语句返回true，我们就实现了我们的功能。让我们放大一些代码。前两行将被拖动的元素移动到拖放区，并从<code class="fe mi mj mk ml b">dataTransfer</code>对象中清除数据:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="852e" class="mq lm in ml b gy mr ms l mt mu">evt.currentTarget.append(droppedElem);<br/>evt.dataTransfer.clearData();</span></pre><p id="3917" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意，我们乐观地呈现这个更新，这对于我们简单的任务跟踪器来说似乎是合理的。然后，我们切换被移动元素的数据集id属性，使其与新位置相匹配:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="a5ae" class="mq lm in ml b gy mr ms l mt mu">const dataIdToggle = {<br/>  'finished': 'unfinished',<br/>  'unfinished': 'finished'<br/>};<br/>droppedElem.dataset.id = dataIdToggle[droppedElem.dataset.id];</span></pre><p id="1d01" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这允许我们在前端的“已完成”和“未完成”任务容器之间来回移动元素，也帮助我们在后端适当地更新我们的任务数据。在我们向后端发出更新API的请求之前，我们收集了一些东西:用来更新我们的任务的新信息，以及我们正在更新的特定任务的id:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="6154" class="mq lm in ml b gy mr ms l mt mu">const databaseAttributeMap = {<br/>  'finished': true,<br/>  'unfinished': false<br/>};<br/>let isFinished = databaseAttributeMap[droppedElem.dataset.id];<br/>let id = droppedElem.dataset.databaseId;</span></pre><p id="e780" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最后，我们向<code class="fe mi mj mk ml b">fetch()</code>提出请求:</p><pre class="kz la lb lc gt mm ml mn mo aw mp bi"><span id="a75c" class="mq lm in ml b gy mr ms l mt mu">fetch(`http://localhost:3000/tasks/${id}`, {<br/>  method: 'PATCH',<br/>  headers: {<br/>    'Content-Type': 'application/json',<br/>    Accept: 'application/json'<br/>  },<br/>  body: JSON.stringify({<br/>    'finished': isFinished<br/>  })<br/>})<br/>.then(res =&gt; res.json())<br/>.then(task =&gt; {<br/>  task.finished === true ? alert('Way to Go!!!') : alert('Darn 😕')<br/>});</span></pre><p id="bdcc" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样，我们的任务已经在后端更新了，这样，如果用户刷新页面，任务就会留在它的新家。(注意:容器中任务的顺序可能会在刷新时改变，因为这取决于它们在API中的顺序。在前端维护订单超出了本文的范围。)我们还以定制警告的形式给用户一些额外的反馈。最后，我们有了我们想要的功能:</p><figure class="kz la lb lc gt ld gh gi paragraph-image"><div role="button" tabindex="0" class="le lf di lg bf lh"><div class="gh gi ky"><img src="../Images/a887690170be5c72362bd5a688ca49fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*p4o2JG4acQw1xTtr.gif"/></div></div></figure><h1 id="a2ac" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">最后的想法</h1><p id="2443" class="pw-post-body-paragraph kc kd in ke b kf md jo kh ki me jr kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在我看来，拖放功能是非常用户友好的。它们的功能很直观，给用户一些很好的视觉反馈。而且实现起来也不是很难！一个非常简单的拖放功能只需几个步骤就可以完成，通过添加一些后端交互性，我们可以大大增加该功能的功能和实用性。</p><p id="1c9c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢阅读！！</p><p id="dd09" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">资源</strong> <br/> <a class="ae lk" href="https://medium.com/quick-code/simple-javascript-drag-drop-d044d8c5bed5" rel="noopener">简单JavaScript拖拽&amp;Drop(<em class="mw">Medium</em>post)</a><br/><a class="ae lk" href="https://alligator.io/js/drag-and-drop-vanilla-js/" rel="noopener ugc nofollow" target="_blank">拖拽&amp; Drop元素带香草Javascript和HTML(有帮助的教程)</a> <br/> <a class="ae lk" href="https://www.w3schools.com/html/html5_draganddrop.asp" rel="noopener ugc nofollow" target="_blank"> HTML5拖拽(W3Schools docs) </a></p></div></div>    
</body>
</html>