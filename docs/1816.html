<html>
<head>
<title>The Practical Problems with Callbacks in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中回调的实际问题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-practical-problems-with-callbacks-in-javascript-5dd4209c20d?source=collection_archive---------2-----------------------#2020-04-26">https://javascript.plainenglish.io/the-practical-problems-with-callbacks-in-javascript-5dd4209c20d?source=collection_archive---------2-----------------------#2020-04-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="261b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">嵌套回调有什么问题，为什么大家都讨厌它？</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b79ccfd59f5687c96fe22f682d429d44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IVTBhiH3FhYGfOwt"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@clemono2?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clem Onojeghuo</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a931" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">由于您可能是JavaScript新手或使用多年，所以您不可能从未听说过“<strong class="kv io">回调地狱</strong>”以及对它的厌恶。不知何故，无论你走到哪里，都会有一些人说<em class="lp">嵌套回调</em>是邪恶的，并展示了如下图像，其他人通常也会说，“回调见鬼，恶心！”</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lq"><img src="../Images/8533467f96ca5612d801d04dd505056b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*58vcVucp3Jn6HCnLalYlwQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Callback Hell — actually I think it looks cool :)</figcaption></figure><p id="bc93" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是作为一个新手(或者有经验的人)，你可能想知道嵌套回调到底有什么问题，为什么每个人都讨厌它。</p><p id="b4e1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">也许你已经听到了一些模糊的争论，但是让我试着澄清这个主题并展示一些问题，这可以帮助你逻辑地推理回调，并使你理解为什么你可能需要一些其他的模式(例如，承诺、异步/等待、观察者、CSP等)。)</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="8760" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">回调本身有什么问题？</h1><p id="2377" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">首先，让我们看看当你使用回调时会发生什么。</p><p id="a68a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">让我告诉你一个真实的故事。</p><p id="d264" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">几个月前，我只想使用一个库中的函数，该函数接受回调并将结果作为参数传递给回调(这是异步函数的一种规范)，然后我说，“好的，酷！”</p><p id="62b2" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是当我运行程序时，我注意到我的回调是同步执行的(Whaaat？？为什么？)</p><p id="dcf5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你写了一个应该同步工作的函数，为什么要把结果传递给一个回调函数呢？为什么不直接返回值呢？</p><p id="c9d6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">实际上，以这种方式使用回调并不是一个好主意，也没有理由这样做(当然你可以，但你不应该这样做)，因为<strong class="kv io">习惯上回调应该用在异步函数</strong>或<strong class="kv io">中，至少异步调用</strong>。</p><p id="058f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我告诉你这个故事是为了让你明白，当你向第三方发出回电时，你必须依赖第三方，这可能会导致一些混乱，比如回电时的情况:</p><ul class=""><li id="5a96" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo na nb nc nd bi translated"><strong class="kv io">会被同步调用</strong>(像我的)</li><li id="481c" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated"><strong class="kv io">会被多次调用</strong></li><li id="fb1a" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo na nb nc nd bi translated"><strong class="kv io">永远不会被称为</strong></li></ul><h1 id="cecc" class="ly lz in bd ma mb nj md me mf nk mh mi jt nl ju mk jw nm jx mm jz nn ka mo mp bi translated">嵌套回调有什么问题？</h1><p id="1f04" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">在开始之前，让我们看看为什么我们把函数放在异步函数的回调中(如果put函数是异步的，这个过程可以递归地继续)。</p><p id="2da3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果你想在一个异步函数执行后调用其他函数，并且因为回调是你在一个异步函数执行完成后被注意到的唯一方式，你别无选择，只能把下一个函数放入异步函数的回调中。(如上图。)</p><p id="17ba" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">换句话说，当我们想要按顺序运行一些异步函数时，我们必须将它们放入前一个函数的回调中，这使得嵌套回调发生。</p><p id="190c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我希望这里的解释对你来说足够清楚(如果不是，在评论区问你的问题，我会回答你。)</p><p id="0329" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在我们了解了嵌套回调的原因，让我们研究一下它的后果。</p><h2 id="6f46" class="no lz in bd ma np nq dn me nr ns dp mi lc nt nu mk lg nv nw mm lk nx ny mo nz bi translated">嵌套回调中的错误处理</h2><p id="eea6" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">你可能听说过这个论点，但是我们应该一起仔细研究在嵌套回调中处理错误的问题。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oa"><img src="../Images/bbb0f4f31bbae216b2dc55bbdbf57281.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OVqGAIx11Mmz6JLKXmU2IQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Error handing in nested callbacks</figcaption></figure><p id="f4cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如你所见，<strong class="kv io">我们必须在每个回调</strong>中处理错误，这实际上是处理错误的样板文件的重复。所以<strong class="kv io">这段代码并不枯燥</strong>(作为程序员，我们不喜欢一遍又一遍地重复相同的代码)，重用错误处理程序有点困难。</p><h2 id="a83f" class="no lz in bd ma np nq dn me nr ns dp mi lc nt nu mk lg nv nw mm lk nx ny mo nz bi translated">平行</h2><p id="81c7" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">当我们打算使用嵌套回调时，异步函数之间可能有两种关系:</p><ol class=""><li id="8e27" class="mv mw in kv b kw kx kz la lc mx lg my lk mz lo ob nb nc nd bi translated">异步功能执行必须在<strong class="kv io">序列</strong>中进行</li><li id="4e8a" class="mv mw in kv b kw ne kz nf lc ng lg nh lk ni lo ob nb nc nd bi translated">异步功能的执行应该在<strong class="kv io">并行</strong></li></ol><p id="47ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以让我们调查他们两个。</p><p id="9ceb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">异步功能执行必须按顺序进行</strong></p><p id="6094" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，想象一下当我们想读取<code class="fe oc od oe of b">file-1</code>然后将内容写入<code class="fe oc od oe of b">file-2</code>时的情况。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/1e0fb7f8aa10c21c4eed9e597c5ea359.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OzF4RHLGLNnjbIIRLpvlnw.png"/></div></div></figure><p id="1000" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在这种情况下，它们必须串行运行，使用这种模式，可以简单地完成。</p><p id="90ed" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv io">异步功能的执行应该是并行的</strong></p><p id="55bd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，想象一下当我们想阅读<code class="fe oc od oe of b">file-1</code>和<code class="fe oc od oe of b">file-2</code>时的情况，但是要确保<code class="fe oc od oe of b">file-1</code>的内容在<code class="fe oc od oe of b">file-2</code>之前显示</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi og"><img src="../Images/a27ed4f1daf63ab7dbeaf6157b7df9ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UIcCoZsTr11PUzNtdN-Ytg.png"/></div></div></figure><p id="0452" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">事实上，我们这里有一个问题。正确的做法是，解析的内容必须按顺序显示，但是读取过程应该同时运行(即并发、并行)。</p><p id="d1e7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以这意味着我们不能使用嵌套模式，因为它阻止我们平行。换句话说，<strong class="kv io">嵌套回调模式被限制在序列</strong>中运行。</p><p id="3e15" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">为了并行运行这些功能，我们可以使用一些技巧来实现:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi oh"><img src="../Images/d2eb03b3cfe3aa5544608264808d9e34.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdJW21qDggmvVoOe5johnA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Callbacks run concurrently, but the result of them would be displayed in sequence</figcaption></figure><p id="a07b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在<code class="fe oc od oe of b">displayHandler </code>功能中，我们必须控制<strong class="kv io">竞争条件</strong>。</p><blockquote class="oi oj ok"><p id="f00f" class="kt ku lp kv b kw kx jo ky kz la jr lb ol ld le lf om lh li lj on ll lm ln lo ig bi translated">注意:竞争条件仅仅意味着当一些异步函数以不正确的顺序被解析时(例如，<code class="fe oc od oe of b">file-2</code>在<code class="fe oc od oe of b">file-1</code>之前被读取)</p></blockquote><p id="299e" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是这种技巧不应该用在生产中，因为它们既不可伸缩，也不可维护，也不灵活。</p><h2 id="f68a" class="no lz in bd ma np nq dn me nr ns dp mi lc nt nu mk lg nv nw mm lk nx ny mo nz bi translated">对未来价值的参考</h2><p id="92ce" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">最后但同样重要的是，我要提到一个回调模式无法实现的特性(在我看来，我们不应该称之为问题)。</p><p id="685c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们不能用回调模式传递对异步函数未来值的引用(不像promise)，我们只能传递对异步函数执行的控制。</p></div><div class="ab cl lr ls hr lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ig ih ii ij ik"><h1 id="bcf8" class="ly lz in bd ma mb mc md me mf mg mh mi jt mj ju mk jw ml jx mm jz mn ka mo mp bi translated">包扎</h1><p id="35bb" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">这篇文章的主要目的是以实际和切实的方式向您展示这些问题。</p><p id="9125" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我的想法是，可能有一些像我一样的人无法被一些关于回调问题的模糊论点所说服，例如"<em class="lp">回调地狱是坏的"、"很难推理嵌套"、"错误处理是困难的"、" T1 "以及这些我过去不清楚的东西。</em></p><p id="10b9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以我试着用简单的方式，从我的个人经历和我遇到的问题的角度来解释它们。</p><p id="d3c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我希望这篇文章对你有用(尤其是新手)</p><p id="cc94" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果这里有什么不清楚的地方，欢迎在评论区提出你的问题，我会回应的。</p><h2 id="cd51" class="no lz in bd ma np nq dn me nr ns dp mi lc nt nu mk lg nv nw mm lk nx ny mo nz bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="b49d" class="pw-post-body-paragraph kt ku in kv b kw mq jo ky kz mr jr lb lc ms le lf lg mt li lj lk mu lm ln lo ig bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae ks" href="https://medium.com/ai-in-plain-english" rel="noopener"> <strong class="kv io"> AI in Plain English </strong> </a>，<a class="ae ks" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kv io">UX in Plain English</strong></a>，<a class="ae ks" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kv io">Python in Plain English</strong></a><strong class="kv io"/>——谢谢，继续学习！</p><p id="f375" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae ks" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">submissions @ plain English . io</strong></a><strong class="kv io"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>