<html>
<head>
<title>Dead Lettering in Nest.js &amp; RabbitMQ — Is it even possible?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Nest.js &amp; RabbitMQ中的死字——这可能吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/dead-lettering-in-nest-js-rabbitmq-is-it-even-possible-a6aa5732ef1d?source=collection_archive---------2-----------------------#2020-09-05">https://javascript.plainenglish.io/dead-lettering-in-nest-js-rabbitmq-is-it-even-possible-a6aa5732ef1d?source=collection_archive---------2-----------------------#2020-09-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="13f9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">上周，我发现自己在努力寻找一些关于与Nest.js &amp; RabbitMQ的死信交换的文档。有些GitHub问题推荐使用外部包，但是你实际上可以用普通的Nest.js来实现！</p><p id="ff8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们需要一些关于RabbitMQ和Nest.js的基础知识。</p><blockquote class="kj kk kl"><p id="0be3" class="jk jl km jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">完整的源代码可在<a class="ae ki" href="https://github.com/NiklasPor/nestjs-rmq-dead-lettering" rel="noopener ugc nofollow" target="_blank">这里</a>获得。如果你想直接跳到前面。</p></blockquote><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi kq"><img src="../Images/89e90bba62d244ee987d7195ece31df1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*4CVq_6DQ7UbvHQZH"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">Photo by <a class="ae ki" href="https://unsplash.com/@joannakosinska?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joanna Kosinska</a> on <a class="ae ki" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="39e5" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">你说的这个死字是什么？</h1><p id="1e94" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">RabbitMQ死信消息，以下<a class="ae ki" href="https://www.rabbitmq.com/dlx.html" rel="noopener ugc nofollow" target="_blank">点中至少有一点适用于该消息</a>:</p><ul class=""><li id="5680" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh mo mp mq mr bi translated">消息被拒绝或未用<code class="fe ms mt mu mv b">requeue: false</code>确认。</li><li id="f522" class="mj mk in jm b jn mw jr mx jv my jz mz kd na kh mo mp mq mr bi translated">消息的TTL(生存时间)已过期。</li><li id="8a19" class="mj mk in jm b jn mw jr mx jv my jz mz kd na kh mo mp mq mr bi translated">该消息已被丢弃，因为它超过了队列的最大长度。</li></ul><p id="6ce2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果指定了死信交换，则死信消息将被转发到死信交换。在我们的例子中，我们只是将它们转发到另一个RabbitMQ队列，并在那里进行处理。这种模式非常适合实现容错工作者！</p><h1 id="bc4b" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">我们将建造什么？</h1><p id="f483" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">很高兴你问了！我们将构建两个模拟汉堡制作的微服务。可悲的是，我们的厨师放弃了三分之一的汉堡肉饼。我们将引入一些错误处理来解决这个问题。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi nb"><img src="../Images/4fec789c57087f4ce1b887af492114e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rBI3iUAwzhBCZHU_RReDug.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">Sequence Diagram of our Burger Ordering</figcaption></figure><p id="4985" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如我们所见，制作一个汉堡有4个组成部分:</p><ol class=""><li id="a61d" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh nc mp mq mr bi translated">汉堡队列:接收关于汉堡制作的所有信息，并与顾客沟通。</li><li id="1c50" class="mj mk in jm b jn mw jr mx jv my jz mz kd na kh nc mp mq mr bi translated">Burger Worker:获取来自<code class="fe ms mt mu mv b">Burger Queue</code>的消息并处理它们。</li><li id="0227" class="mj mk in jm b jn mw jr mx jv my jz mz kd na kh nc mp mq mr bi translated">恢复队列:接收所有死信。</li><li id="8dd7" class="mj mk in jm b jn mw jr mx jv my jz mz kd na kh nc mp mq mr bi translated">恢复工作者:从<code class="fe ms mt mu mv b">Recovery Queue</code>获取消息，并将它们重定向到<code class="fe ms mt mu mv b">Burger Queue</code>。还将重试次数增加1。如果重试次数超过4，则发出失败。</li></ol></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="489d" class="lg lh in bd li lj nk ll lm ln nl lp lq lr nm lt lu lv nn lx ly lz no mb mc md bi translated">设置RabbitMQ</h1><p id="333d" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">设置RabbitMQ最简单的方法是使用<a class="ae ki" href="https://docs.docker.com/get-docker/" rel="noopener ugc nofollow" target="_blank"> Docker </a>:</p><pre class="kr ks kt ku gt np mv nq nr aw ns bi"><span id="be20" class="nt lh in mv b gy nu nv l nw nx">docker run -d -p 15672:15672 -p 5672:5672 rabbitmq:3-management</span></pre><p id="cf5f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">执行这个命令后，您的Docker守护进程中将运行一个RabbitMQ。在<code class="fe ms mt mu mv b">amqp://guest:guest@localhost:5672</code>有，在<code class="fe ms mt mu mv b"><a class="ae ki" href="http://localhost:15672." rel="noopener ugc nofollow" target="_blank">http://localhost:15672</a></code> <a class="ae ki" href="http://localhost:15672." rel="noopener ugc nofollow" target="_blank">可以进入管理界面。</a></p><blockquote class="kj kk kl"><p id="64c5" class="jk jl km jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">注意:密码和用户名都是<code class="fe ms mt mu mv b"><em class="in">guest</em></code>。您可以使用它们来访问RabbitMQ本身和管理界面。</p></blockquote><h1 id="b850" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">设置Nest.js</h1><p id="568a" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">首先，我们将通过npm在全球范围内安装Nest CLI:</p><pre class="kr ks kt ku gt np mv nq nr aw ns bi"><span id="ad1e" class="nt lh in mv b gy nu nv l nw nx">npm i -g @nestjs/cli</span></pre><p id="fa13" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然后我们必须创建一个名为<code class="fe ms mt mu mv b">burger-worker</code>的新项目:</p><pre class="kr ks kt ku gt np mv nq nr aw ns bi"><span id="b980" class="nt lh in mv b gy nu nv l nw nx">nest new burger-worker</span></pre><p id="fbff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在向项目添加第二个名为<code class="fe ms mt mu mv b">recovery-worker</code>的应用程序:</p><pre class="kr ks kt ku gt np mv nq nr aw ns bi"><span id="ecbe" class="nt lh in mv b gy nu nv l nw nx">cd burger-worker<br/>nest g app recovery-worker</span></pre><p id="d725" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">接下来，将名为<code class="fe ms mt mu mv b">shared</code>的库添加到项目中。我们将使用它来共享连接和消息信息:</p><pre class="kr ks kt ku gt np mv nq nr aw ns bi"><span id="04f4" class="nt lh in mv b gy nu nv l nw nx">nest generate lib shared</span></pre><p id="66bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当询问前缀时，只需保留默认的<code class="fe ms mt mu mv b">@app</code>并按回车键。</p><p id="edf0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们必须添加一些用于连接RabbitMQ和创建微服务的包:</p><pre class="kr ks kt ku gt np mv nq nr aw ns bi"><span id="c7a6" class="nt lh in mv b gy nu nv l nw nx">npm i @nestjs/microservices amqplib amqp-connection-manager</span></pre></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="0d4c" class="lg lh in bd li lj nk ll lm ln nl lp lq lr nm lt lu lv nn lx ly lz no mb mc md bi translated">创建RabbitMQ和死字连接参数</h1><p id="7858" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">为了给两个项目提供选项，我们将在共享库中创建一个<code class="fe ms mt mu mv b">queue-options.ts</code>文件。这包括死信交换的设置:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">libs/shared/src/queue-options.ts</figcaption></figure><h1 id="0a7c" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">创建消息</h1><p id="6dc8" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">我们还将添加一个<code class="fe ms mt mu mv b">messages.ts</code>文件到我们的共享库中。这将包括所有消息。每条消息由两个主要部分组成:</p><ol class=""><li id="b1b1" class="mj mk in jm b jn jo jr js jv ml jz mm kd mn kh nc mp mq mr bi translated">模式:模式是一个<code class="fe ms mt mu mv b">string</code>或<code class="fe ms mt mu mv b">symbol</code>，用于标识消息的类型。</li><li id="f1a0" class="mj mk in jm b jn mw jr mx jv my jz mz kd na kh nc mp mq mr bi translated">有效负载/数据:有效负载是消息中提供的实际数据。在我们的例子中，主要是与汉堡相关的东西和重试次数。</li></ol><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">libs/shared/src/messages.ts</figcaption></figure><p id="29b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住导出“index.ts”文件中的消息和队列选项:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">libs/shared/src/index.ts</figcaption></figure></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="8ea6" class="lg lh in bd li lj nk ll lm ln nl lp lq lr nm lt lu lv nn lx ly lz no mb mc md bi translated">将汉堡工人与兔子连接起来</h1><p id="6b84" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">首先:由于我们不会实现任何复杂的业务逻辑，我们可以安全地移除<code class="fe ms mt mu mv b">app.service.ts</code>及其所有引用。</p><h2 id="7c3c" class="nt lh in bd li oa ob dn lm oc od dp lq jv oe of lu jz og oh ly kd oi oj mc ok bi translated">主页面</h2><p id="99be" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">我们需要替换<code class="fe ms mt mu mv b">apps/burger-worker/src/main.ts</code>的内容。这创建了一个完整的应用程序，但我们只需要一个微服务，它将使用<code class="fe ms mt mu mv b">index.ts</code>。</p><p id="30b5" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以用这个简单的设置代码完全替换<code class="fe ms mt mu mv b">main.ts</code>:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">apps/burger-worker/src/main.ts</figcaption></figure><h2 id="a23d" class="nt lh in bd li oa ob dn lm oc od dp lq jv oe of lu jz og oh ly kd oi oj mc ok bi translated">应用程序模块</h2><p id="8a78" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">此外，我们需要更新汉堡工人的<code class="fe ms mt mu mv b">app.module.ts</code>。我们想要向<code class="fe ms mt mu mv b">burger-queue</code>发送消息。Nest.js的<code class="fe ms mt mu mv b">ClientModule</code>会给我们提供这个功能:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">apps/burger-worker/src/app.module.ts</figcaption></figure><h2 id="c040" class="nt lh in bd li oa ob dn lm oc od dp lq jv oe of lu jz og oh ly kd oi oj mc ok bi translated">首次启动</h2><p id="47f8" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">如果您已经完成了上述所有步骤，并且还清理了您的<code class="fe ms mt mu mv b">app.controller.ts</code>，那么您现在就可以启动<code class="fe ms mt mu mv b">burger-worker</code>！</p><pre class="kr ks kt ku gt np mv nq nr aw ns bi"><span id="650a" class="nt lh in mv b gy nu nv l nw nx">nest start -w burger-worker</span></pre><p id="5466" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您的CLI应该看起来像这样:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi ol"><img src="../Images/f139e282a879495e96b6bb6d517e1d18.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*krhUaqE_8PBPHXE2ie5hDA.png"/></div></div></figure><p id="3629" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这也将在我们的RabbitMQ实例中创建<code class="fe ms mt mu mv b">burger-queue</code>。您可以通过查看队列选项卡来检查是否一切正常:</p><p id="00bc" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ki" href="http://localhost:15672/#/queues" rel="noopener ugc nofollow" target="_blank">http://localhost:15672/#/queues</a>。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi om"><img src="../Images/755488dc10492dd6b89fb1e4b629a87f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*negll54Wa1a4xwILeNYWfA.png"/></div></div></figure><blockquote class="kj kk kl"><p id="f91e" class="jk jl km jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">登录管理界面的密码和用户名均为<code class="fe ms mt mu mv b"><em class="in">guest</em></code>。以防你忘了👌</p></blockquote><h1 id="92a4" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">实现汉堡工人</h1><p id="4d08" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">最后，我们可以着手实际的实现。我们将使用<code class="fe ms mt mu mv b">@EventPattern</code>装饰器从我们的<code class="fe ms mt mu mv b">Burger Queue</code>接收事件(消息)。<code class="fe ms mt mu mv b">@Payload</code>和<code class="fe ms mt mu mv b">@Ctx</code>装饰器可以用来接收消息上下文。我们需要消息上下文来确认或拒绝消息。</p><p id="b965" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了处理make burger消息，我们现在可以使用我们定义的模式和<code class="fe ms mt mu mv b">@EventPattern</code>装饰器:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">apps/burger-worker/src/app.controller.ts</figcaption></figure><p id="2986" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果汉堡可以毫无问题地准备好，我们发出成功<strong class="jm io">和</strong>确认我们处理了消息。RabbitMQ将知道它可以从队列中删除消息。</p><h2 id="d341" class="nt lh in bd li oa ob dn lm oc od dp lq jv oe of lu jz og oh ly kd oi oj mc ok bi translated">添加对失败和成功的处理</h2><p id="8b92" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">我们将添加一些简单的日志，记录我们在制作汉堡时是否成功。另外，将这些处理程序添加到您的<code class="fe ms mt mu mv b">app.controller.ts</code>中。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">apps/burger-worker/src/app.controller.ts</figcaption></figure><blockquote class="kj kk kl"><p id="9576" class="jk jl km jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">你总是可以在这里比较你的库和完成的库。或者看一下<code class="fe ms mt mu mv b"><em class="in">Burger Worker</em></code>的成品<a class="ae ki" href="https://github.com/NiklasPor/nestjs-rmq-dead-lettering/blob/master/apps/burger-worker/src/app.controller.ts" rel="noopener ugc nofollow" target="_blank"> app.controller.ts </a>。</p></blockquote><h2 id="dcd7" class="nt lh in bd li oa ob dn lm oc od dp lq jv oe of lu jz og oh ly kd oi oj mc ok bi translated">试试吧！</h2><p id="418c" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">启动burger worker并通过RabbitMQ接口提交一些消息。要向队列发送消息，只需单击它并提供消息正文:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi on"><img src="../Images/fd499a2599c650f823ad42f4f4d69059.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*kt9zXkzBehXqj1fRHX-vRw.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk"><a class="ae ki" href="http://localhost:15672/#/queues/%2F/burger" rel="noopener ugc nofollow" target="_blank">http://localhost:15672/#/queues/%2F/burger</a></figcaption></figure><p id="7119" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在发布消息<strong class="jm io"> 2 </strong>次后，CLI应该显示第一次成功，然后显示一次失败(因为厨师掉了第三个汉堡肉饼)。失败后，这条信息被废弃了。</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi oo"><img src="../Images/812981811f9140d9cfdb76c43a3f99e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Gp5QBo0gpcmEN9qmVv_eQ.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">output after publishing the message <strong class="bd op">2</strong> times</figcaption></figure><blockquote class="kj kk kl"><p id="7c1a" class="jk jl km jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">但是等等！我们没有实现恢复工人，它处理我们的死信消息！</p></blockquote><h1 id="f34f" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">将恢复工作程序连接到RabbitMQ</h1><p id="4e9d" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">这和汉堡工人的情况基本相同。除了我们必须将<code class="fe ms mt mu mv b">recovery-queue</code>而不是<code class="fe ms mt mu mv b">burger-queue</code>添加到<code class="fe ms mt mu mv b">main.ts</code>中。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">apps/recovery-worker/src/main.ts</figcaption></figure><p id="408e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ms mt mu mv b">app.module.ts</code>完全相同，因为我们仍然只向<code class="fe ms mt mu mv b">Burger Queue</code>和<strong class="jm io">发送消息，而不是向<code class="fe ms mt mu mv b">Recovery Queue</code>发送</strong>:</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">apps/recovery-worker/src/app.module.ts</figcaption></figure><h1 id="8bb7" class="lg lh in bd li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md bi translated">实施恢复逻辑</h1><p id="0e8b" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">恢复逻辑非常简单。我们正在增加消息的重试计数有效负载，并再次将其发送到<code class="fe ms mt mu mv b">Burger Queue</code>。如果超过了重试阈值，我们会发送一条失败消息。</p><figure class="kr ks kt ku gt kv"><div class="bz fp l di"><div class="ny nz l"/></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">apps/recovery-worker/src/app.controller.ts</figcaption></figure></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="6e4b" class="lg lh in bd li lj nk ll lm ln nl lp lq lr nm lt lu lv nn lx ly lz no mb mc md bi translated">运行您的可扩展和容错应用🎉</h1><p id="2628" class="pw-post-body-paragraph jk jl in jm b jn me jp jq jr mf jt ju jv mg jx jy jz mh kb kc kd mi kf kg kh ig bi translated">打开两个终端标签，运行<code class="fe ms mt mu mv b">nest start -w burger-worker</code>和<code class="fe ms mt mu mv b">nest start -w recovery-worker</code>。现在发布和以前一样的消息，并对其进行处理！</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi oq"><img src="../Images/f3b7ef9e51026b35297b027b129303d7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E9ld6U5YR2P_L3dWOJrYeA.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">Output for: {patties: 2, customer: “John”}</figcaption></figure><p id="0fd1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们现在点了3个以上的汉堡(记住我们的厨师每3个就失败一个)，这个订单总是会失败。但是首先，我们将执行最多4次重试。如我们<code class="fe ms mt mu mv b">Recovery Worker</code>中所述:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi or"><img src="../Images/f8bf069bda9449a82d829ee5373ccb13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HDwpArFUyTsyiYc3y0rI9A.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">Output for: {patties: 4, customer: “Someone Hungry”}</figcaption></figure><p id="62dd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果没有<code class="fe ms mt mu mv b">Burger Worker</code>可用，消息将在4秒后超时。然后消息被我们的<code class="fe ms mt mu mv b">Recovery Worker</code>处理。重试4次后，工人将发出失败消息:</p><figure class="kr ks kt ku gt kv gh gi paragraph-image"><div role="button" tabindex="0" class="kw kx di ky bf kz"><div class="gh gi os"><img src="../Images/66d2c647fad2a74f32e08b5f5289b906.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4mel47s-ovD2c2bAsoUk0w.png"/></div></div><figcaption class="lc ld gj gh gi le lf bd b be z dk">Output for no burger worker &amp; {patties: 2, customer: “Emilia”}</figcaption></figure><blockquote class="ot"><p id="9508" class="ou ov in bd ow ox oy oz pa pb pc kh dk translated">这个汉堡实验到此结束。如果你想进一步试验，你可以试着启动每个worker的多个实例。看一看，看看是否一切顺利！</p></blockquote></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><p id="2969" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">恭喜你！你现在是少数几个知道如何在Nest.js中使用死字体的人之一👌非常感谢您花时间阅读这篇文章。如果你有任何公开的问题，请在Twitter <a class="ae ki" href="https://twitter.com/niklaspor" rel="noopener ugc nofollow" target="_blank"> @niklaspor </a>上给我打电话，或者发表评论。</p><blockquote class="kj kk kl"><p id="e575" class="jk jl km jm b jn jo jp jq jr js jt ju kn jw jx jy ko ka kb kc kp ke kf kg kh ig bi translated">完成项目的源代码可在<a class="ae ki" href="https://github.com/NiklasPor/nestjs-rmq-dead-lettering" rel="noopener ugc nofollow" target="_blank">这里</a>获得。</p></blockquote><p id="def4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">祝您愉快！</p><p id="88fb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">尼克拉斯</p></div></div>    
</body>
</html>