<html>
<head>
<title>JavaScript Module Definitions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript模块定义</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-module-definitions-a5a467a7f202?source=collection_archive---------4-----------------------#2019-10-16">https://javascript.plainenglish.io/javascript-module-definitions-a5a467a7f202?source=collection_archive---------4-----------------------#2019-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c448215d7ff6b2934199ed9e1ff5f1b2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pjXQpdB3ms3BKNxO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@egnaro?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Rick Mason</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7cb4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个JavaScript模块可以被视为一个乐高积木，它在底部有一些<em class="lb">管</em>和在顶部有一些<em class="lb">钉</em>，这个简单的契约可以很容易地将一些模块连接在一起。模块内部可能有任何东西，模块内部不影响其他模块内部。</p><p id="5e06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种使模块可以连接到其他模块的契约被称为<strong class="kf ir">模块定义</strong>。目前我们有很多不同的模块定义(IIFE，commonJS，ESM，AMD，UMD，esnext…)，所以如果我们想发布我们的代码，我们需要特别理解它们。</p><h1 id="2060" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">史前史</strong></h1><p id="d556" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">当JavaScript出现在浏览器上时，它被添加了<em class="lb"> &lt;脚本&gt; </em>标签，并且每个函数或变量都是全局的。这对于较小的项目来说很容易，但是重用不同团队创建的代码却很困难，因为一些函数或变量可能会在不同的库之间被无意地共享或覆盖。</p><h1 id="dc6d" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">生活</strong></h1><p id="dd4c" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">没有像标准模块定义这样的东西，所以一些聪明的开发者开始使用<strong class="kf ir">life</strong>(立即调用函数表达式)</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="67ac" class="mo ld iq mk b gy mp mq l mr ms">(function () {</span><span id="f65d" class="mo ld iq mk b gy mt mq l mr ms">…</span><span id="0336" class="mo ld iq mk b gy mt mq l mr ms">})();</span></pre><p id="dc01" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为函数体的作用域是局部的，所以函数内部的变量和函数不再是全局的。</p><p id="1485" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当代码必须对应用程序的其他部分可用时，我们仍然被迫添加至少一个全局变量。类似于:</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="d9b3" class="mo ld iq mk b gy mp mq l mr ms"><em class="lb">window.myLibrary = {…}</em> </span></pre><p id="6775" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但至少是故意的，更有控制力。</p><h1 id="8aac" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak">常见的</strong></h1><p id="08f1" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">2009年一些开发者开始在服务器中使用JS，需要一个真正的模块系统。于是<strong class="kf ir"> CJS </strong>模块诞生了</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="a64d" class="mo ld iq mk b gy mp mq l mr ms">var path = require(‘path’);</span><span id="43cf" class="mo ld iq mk b gy mt mq l mr ms">module.exports = …</span><span id="6169" class="mo ld iq mk b gy mt mq l mr ms">module.exports.NAMED = …</span></pre><p id="b5e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">答。js文件在默认情况下是一个模块，所以没有函数或变量是全局的。它们可以通过<em class="lb"> module.exports </em>暴露给其他模块，模块可以通过<em class="lb"> require() </em>使用其他模块。</p><p id="f922" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">CommonJS仍然是节点应用程序的标准模块定义，但是浏览器不支持它。</p><p id="a22a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了在浏览器上使用CJS，出现了bundler概念。Browserify是一个命令行工具，用于分析中的<em class="lb"> require() </em>。js文件，并将所有相关模块连接成一个单独的。js文件。</p><p id="79e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这有助于网络开发者使用模块。捆绑的js还有额外的优势:例如，它更快，因为浏览器中需要下载的文件更少。</p><h1 id="0a63" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak"> AMD </strong></h1><p id="7096" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">异步模块定义是一种不同的方法</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="2815" class="mo ld iq mk b gy mp mq l mr ms">define(name, [dependencies], function(dependencies) {</span><span id="a2ba" class="mo ld iq mk b gy mt mq l mr ms">  …</span><span id="7fc8" class="mo ld iq mk b gy mt mq l mr ms">})</span></pre><p id="db27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">模块是通过调用定义函数来定义的，其中模块指定了它的依赖项。当模块加载器加载了所有的依赖项后，它开始执行模块。</p><p id="8323" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb"> RequireJS </em>是实现AMD的加载器。它是一个浏览器库，有一些优点，比如不需要命令行界面，因为一切都在浏览器中完成。</p><h1 id="a250" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak"> UMD </strong></h1><p id="7c72" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">模块的爆炸式增长给库开发者带来了额外的工作，因此<strong class="kf ir"> UMD </strong>被发明出来。通用模块定义基本上是一个<em class="lb"> if </em>语句，根据谁在使用库，它使模块作为CJS模块、AMD模块或IIFE global可用。</p><h1 id="2fa3" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak"> ESM </strong></h1><p id="d7b1" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">但是这些模块定义都不是EcmaScript标准，所以在2015年ES6附带了<strong class="kf ir"> ESM </strong> (EcmaScript模块)</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6a4c" class="mo ld iq mk b gy mp mq l mr ms">import { format } from “date-utils”;</span><span id="d615" class="mo ld iq mk b gy mt mq l mr ms">export …</span><span id="4336" class="mo ld iq mk b gy mt mq l mr ms">export default …</span></pre><p id="2f72" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有一个主要的优点，你可以从一个库中导入一个函数，所以捆绑器可以删除不需要的代码。</p><blockquote class="mu mv mw"><p id="5707" class="kd ke lb kf b kg kh ki kj kk kl km kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated">在这一点上，重要的是要注意到，如果你想创建一个包含一组模块的库，你必须让项目容易地使用你的一个或一些模块，而不强迫他们加载你的所有包。这是主要原因，因为momentjs正在被date-fns取代。</p></blockquote><h1 id="9624" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated"><strong class="ak"> System.register </strong></h1><p id="5749" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">现在大多数现代浏览器都支持ES模块。SystemJS是一个运行在浏览器中的模块加载器，它支持额外的特性，如编译或加载非标准模块。它有自己的模块定义<strong class="kf ir"> System.register </strong>和一套附加的相关工具，包括一个捆绑器。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="2324" class="mo ld iq mk b gy mp mq l mr ms">System.register([dependencies], function(export) {</span><span id="6394" class="mo ld iq mk b gy mt mq l mr ms">  export(‘parseDate’, function () { … });</span><span id="44b3" class="mo ld iq mk b gy mt mq l mr ms">});</span></pre><h1 id="233c" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">浏览器中的捆绑器与模块加载器</h1><p id="1277" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">目前，在web应用程序中使用模块有两种方法:</p><ul class=""><li id="02ed" class="na nb iq kf b kg kh kk kl ko nc ks nd kw ne la nf ng nh ni bi translated">使用捆扎机(Browserify、Webpack、Rollup、package…)</li><li id="08bd" class="na nb iq kf b kg nj kk nk ko nl ks nm kw nn la nf ng nh ni bi translated">使用浏览器加载程序(RequireJS、SystemJS或简单浏览器本机ESM)。</li></ul><p id="61ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现代浏览器可以原生使用ESM，但没有IE版本支持它。</p><p id="18df" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现代捆绑器可以读取大多数模块定义，也可以生成它们。</p><p id="9367" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像<a class="ae kc" href="https://unpkg.com/" rel="noopener ugc nofollow" target="_blank"> unpkg </a>或<a class="ae kc" href="https://www.pika.dev/" rel="noopener ugc nofollow" target="_blank"> pika </a>这样的一些倡议正在推动直接在浏览器中使用ESM。此外,<a class="ae kc" href="https://github.com/WICG/webpackage" rel="noopener ugc nofollow" target="_blank">网络包装标准</a>正在定义中。</p><p id="1a17" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://v8.dev/features/modules" rel="noopener ugc nofollow" target="_blank">如今，使用捆绑器可以产生最佳性能，但是浏览器(以及HTTP/2)正在发展，可以更快更好地加载ESM</a>。所以在不久的将来可能会有所不同。</p><h1 id="f007" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="a751" class="pw-post-body-paragraph kd ke iq kf b kg ma ki kj kk mb km kn ko mc kq kr ks md ku kv kw me ky kz la ij bi translated">有这么多模块定义的原因是历史原因，现在我们有了ESM，就没有理由再出现更多的模块定义了(请)。</p><p id="81cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">NodeJS本机支持CJS，从节点12开始，它还支持带有实验标志的ESM。</p><p id="27b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你正在编写一个JavaScript库，你应该支持:</p><ul class=""><li id="89ad" class="na nb iq kf b kg kh kk kl ko nc ks nd kw ne la nf ng nh ni bi translated">CJS如果代码可以在节点运行</li><li id="73d9" class="na nb iq kf b kg nj kk nk ko nl ks nm kw nn la nf ng nh ni bi translated">ESM，永远</li><li id="c253" class="na nb iq kf b kg nj kk nk ko nl ks nm kw nn la nf ng nh ni bi translated">AMD和global IIFE支持没有捆绑器的旧应用程序</li></ul><blockquote class="mu mv mw"><p id="1597" class="kd ke lb kf b kg kh ki kj kk kl km kn mx kp kq kr my kt ku kv mz kx ky kz la ij bi translated">如果您想要支持节点应用程序、新的web应用程序和旧的web应用程序，我会考虑生成UMD + ESM格式</p></blockquote></div></div>    
</body>
</html>