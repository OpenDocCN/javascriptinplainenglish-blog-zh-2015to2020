<html>
<head>
<title>Getting started with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React挂钩入门</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/getting-started-with-react-hooks-3d98c2ba886d?source=collection_archive---------4-----------------------#2020-01-05">https://javascript.plainenglish.io/getting-started-with-react-hooks-3d98c2ba886d?source=collection_archive---------4-----------------------#2020-01-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="13c8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React中使用钩子的终极指南</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/45540cf1c9346cef0905100487cb8ba9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*aNViZ86x6E7Kzq1r7sjGkQ.jpeg"/></div></div></figure><p id="0c8f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React hooks是在<em class="ln"> v16.8 </em>中引入的伟大特性，React hooks增加了<strong class="kt ir">在React功能组件</strong>中管理状态和与生命周期事件交互的能力。它有助于更简单地开发react应用程序，减少冗长和复杂性。It <em class="ln">加强清晰的结构(容器和功能组件)和严格的数据流现在比以前更容易在我们的组件中创建合理的UI逻辑。</em></p><p id="3cfc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果我们想使用状态或生命周期方法，我们通常必须使用<em class="ln"> React进行更改。组件</em>和类。相反，hooks允许我们在功能组件中使用这些组件。</p><h1 id="7936" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">为什么挂钩:</h1><p id="7abe" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">React挂钩是在我们的功能组件中访问状态和生命周期方法的方式，而无需编写类。使用React挂钩我们所知的功能，如道具钻取、渲染道具和高阶组件(HOC ),甚至减少不必要的冗余，所有这些都会导致代码难以编写、阅读和维护。少说两句，让我们深入代码示例。</p><h1 id="0d28" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">挂钩类型:</h1><p id="f567" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">这里我们将讨论常见的钩子类型</p><h2 id="6736" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">使用状态()</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk"><a class="ae nd" href="https://gist.github.com/ishan-me/65d9ebb35e34ca1d95cd092099572717" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ishan-me</a></figcaption></figure><p id="8f9b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第一个也是最重要的react钩子:<a class="ae nd" href="https://reactjs.org/docs/hooks-state.html" rel="noopener ugc nofollow" target="_blank"> <em class="ln"> useState </em> </a>由要在顶部导入的React包公开。在代码中，我们可以注意到功能组件使用起来有多简单。导入useState后，我们将从useState中挑选一个包含两个变量的数组。传递给useState的参数是起始状态，即DOM中将要改变的数据。所以它返回两个绑定状态的实际值和更新值。</p><p id="16c8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">使用状态<a class="ae nd" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="noopener ugc nofollow" target="_blank"> <em class="ln">对数组使用析构</em> </a>赋值，就像我们用<em class="ln">对象析构</em>拉道具一样。我们也可以在同一个函数中使用多个useState钩子。</p><h2 id="1750" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">useRef()</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk"><a class="ae nd" href="https://gist.github.com/ishan-me/bea73a0bb6eeebc7fa4b0a2dc1bec6fc" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ishan-me</a></figcaption></figure><p id="bbee" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个钩子将帮助我们允许直接访问DOM中的元素。<code class="fe ne nf ng nh b">useRef</code>钩子让我们在功能组件内部创建可变变量。只有当组件在整个生命周期中被安装和保存时，才会创建这个挂钩。</p><p id="e07e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">注意:更新ref是一个副作用，所以应该只在</em> <code class="fe ne nf ng nh b"><em class="ln">useEffect</em></code> <em class="ln"> / </em> <code class="fe ne nf ng nh b"><em class="ln">useLayoutEffect</em></code> <em class="ln">或者事件处理函数内部完成。</em></p><h2 id="7ca7" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated"><strong class="ak"> useEffect() </strong></h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk"><a class="ae nd" href="https://gist.github.com/ishan-me/201007d6fec5e3351b4c4f9f30f8dcd5" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ishan-me</a></figcaption></figure><p id="5160" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个钩子是添加和删除DOM侦听器的最佳位置。如果我们有一些高性能的数据获取、订阅或从react组件手动更改DOM。我们将这些操作称为<em class="ln">“副作用”</em>，因为它们会影响其他组件，并且在渲染过程中无法完成。效果挂钩<code class="fe ne nf ng nh b">useEffect</code>，增加了从功能组件执行副作用的能力。它的作用与React类中的<code class="fe ne nf ng nh b">componentDidMount</code>、<code class="fe ne nf ng nh b">componentDidUpdate</code>和<code class="fe ne nf ng nh b">componentWillUnmount</code>相同，但是统一到一个API中。</p><h2 id="0e9e" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">一起使用useState和useEffect:</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk"><a class="ae nd" href="https://gist.github.com/ishan-me/0c2082793cdb2cca55d7417a37fbf26c" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ishan-me</a></figcaption></figure><p id="2b22" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在代码中，我们同时使用了两个钩子。使用它们从open API端点获取数据没有问题。</p><h2 id="a96a" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">useReducer()</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk"><a class="ae nd" href="https://gist.github.com/ishan-me/983d934949a6258991811b0d7d7a0d90" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ishan-me</a></figcaption></figure><p id="8e69" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个钩子用于管理应用程序的状态。这类似于reducer在幕后的工作方式。reducer是一个纯粹的函数，它根据前一个状态和已经分派的动作计算下一个状态。同样，Reducer in <a class="ae nd" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>它根据传递给它的动作返回下一个状态。</p><h2 id="e266" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">使用备忘录()</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk"><a class="ae nd" href="https://gist.github.com/ishan-me/611ed97be24619925ce7b1d97d52afbb" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ishan-me</a></figcaption></figure><p id="253d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们理解使用记忆挂钩之前，我们需要理解术语<em class="ln">记忆</em>。这是计算机科学中的一个行话，意思是缓存昂贵的函数调用的结果，并在参数相同时返回缓存的版本。</p><p id="977d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">useMemo帮助我们优化应用程序的性能。它有两个参数:一个内联函数和一个依赖数组。</p><blockquote class="ni"><p id="6f07" class="nj nk iq bd nl nm nn no np nq nr lm dk translated"><code class="fe ne nf ng nh b">React.useMemo(() =&gt; fn, deps)</code></p></blockquote><p id="ae40" class="pw-post-body-paragraph kr ks iq kt b ku ns jr kw kx nt ju kz la nu lc ld le nv lg lh li nw lk ll lm ij bi translated">第一个参数Inline function从开销很大的计算中返回值- <code class="fe ne nf ng nh b">() =&gt; doHeavyComputation(a, b)</code>。</p><p id="606d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">第二个参数是一个依赖关系数组<code class="fe ne nf ng nh b">[a, b]</code>，当其中一个依赖关系发生变化时，<code class="fe ne nf ng nh b">useMemo()</code>会重新计算值，如果没有发生变化，则返回上一次存储的值。如果我们忘记传递依赖关系数组，那么每次组件渲染时都会计算新值。我们可以使用这些钩子进行昂贵计算，例如:过滤大型数组，递归函数，如阶乘、斐波那契等，避免不必要的子组件渲染。简单地说，它返回一个<em class="ln">记忆的</em>值。</p><p id="fadf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该示例使用将在第一次渲染时运行的<em class="ln"> useMemo </em>函数。它会阻塞线程，直到昂贵的函数完成，因为<code class="fe ne nf ng nh b">useMemo</code>在渲染中运行。如果<code class="fe ne nf ng nh b">listOfItems</code>没有改变，那么这些昂贵的函数就不会再次启动，我们仍然可以从它们那里得到返回值。它会让这些昂贵的功能看起来瞬间完成。</p><h2 id="70b1" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">useCallback()</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk"><a class="ae nd" href="https://gist.github.com/ishan-me/679b4e3e0fdb2b4cc2d4c9ff86562c3f" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ishan-me</a></figcaption></figure><p id="3f27" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">它返回一个记忆化的回调。当我们有一个子组件经常重新呈现，并且我们向它传递一个回调时，这个钩子也很有用。<code class="fe ne nf ng nh b">useCallback()</code>常与<code class="fe ne nf ng nh b">useEffect()</code>连用，因为它可以防止函数的重新创建。</p><p id="6a3e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们传递给<code class="fe ne nf ng nh b">useCallback</code>钩子的函数只有在它的一个依赖项改变时才被重新创建。</p><h2 id="4bed" class="ml lp iq bd lq mm mn dn lu mo mp dp ly la mq mr ma le ms mt mc li mu mv me mw bi translated">使用上下文()或上下文应用编程接口</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mx my l"/></div><figcaption class="mz na gj gh gi nb nc bd b be z dk"><a class="ae nd" href="https://gist.github.com/ishan-me/258f53bcaf53d6544d888195b8683646" rel="noopener ugc nofollow" target="_blank">https://gist.github.com/ishan-me</a></figcaption></figure><p id="6ba8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个钩子与上下文API结合使用。这样我们就可以得到当前的上下文值，它引用了最近的<em class="ln"> &lt; MyContext。&gt;供应商</em>组件。</p><p id="c43d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">React Context API的主要目标是管理状态，而不使用道具在整个应用程序中传递数据。它还使我们能够避免使用Redux，并简化代码结构。</p><h1 id="669e" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">结论</h1><p id="8bbc" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我希望本文在理解钩子的基础知识方面有所澄清。请找到Github的要点，并创造新的惊人的东西。关于钩子还有很多要学的。</p><p id="1eed" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了了解更多关于hooks的信息，我建议您观看一年前由<a class="ae nd" href="https://www.youtube.com/watch?v=V-QO-KO90iQ" rel="noopener ugc nofollow" target="_blank"> Sophie Alpert在React Conf 2018 </a>上所做的演讲。</p><p id="8635" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="ln">———————————————快乐编码！—————————————————————</em></p></div></div>    
</body>
</html>