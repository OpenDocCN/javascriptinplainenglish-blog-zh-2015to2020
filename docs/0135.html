<html>
<head>
<title>Drag and Drop dashboard builder with Angular and Gridster</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Angular和Gridster拖放仪表板生成器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/drag-and-drop-dashboard-builder-with-angular-and-gridster-a07592e54ce2?source=collection_archive---------0-----------------------#2019-04-30">https://javascript.plainenglish.io/drag-and-drop-dashboard-builder-with-angular-and-gridster-a07592e54ce2?source=collection_archive---------0-----------------------#2019-04-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="f3fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果你想在Angular中使用<em class="kl">拖拽</em>来构建仪表盘，那就别再找了。在这篇文章中，我们将介绍如何使用Angular从头开始创建一个<em class="kl">拖放仪表板生成器</em>项目！</p><p id="f24c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您以前从未使用过Angular，请不要担心，事实上这是一个很好的起点，因为我们将用可靠的工作示例涵盖大多数基础知识，这将比另一个<em class="kl"> ToDo </em>或<em class="kl"> Hello world </em>有趣得多！</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/d4549a23243e18189a1a3a086612457a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3SVbDS0IVJtkOeK2M9RSxw.jpeg"/></div></div></figure><h1 id="771f" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">最终目标是什么？</h1><p id="68eb" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我想创建一个<em class="kl">拖放仪表板生成器</em>，使<em class="kl">用户</em>能够配置仪表板布局，然后将组件拖放到上面。</p><p id="11f2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">这种功能对于任何与数据分析相关的事情来说都是非常酷的，可以作为一种非常酷的方式，使您的用户(例如分析师)能够创建完全定制的仪表板。</em></p><h1 id="4602" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">我们将使用什么工具？</h1><ol class=""><li id="b57d" class="mb mc iq jp b jq lw ju lx jy md kc me kg mf kk mg mh mi mj bi translated"><strong class="jp ir">有角度(v7) </strong></li><li id="554a" class="mb mc iq jp b jq mk ju ml jy mm kc mn kg mo kk mg mh mi mj bi translated">格里斯特</li></ol><h1 id="8c25" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">有角的</h1><p id="9d9b" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Angular是一个JavaScript框架(<em class="kl">由Google团队</em>开发)，它非常固执地描述了应该“如何”构建JavaScript代码。通过遵循Angular的模式和惯例，你可以节省很多时间和精力；允许框架处理困难的部分，如数据绑定和组件组合。在这篇文章中，我们将介绍Angular的基础知识，但是如果你想了解更多，Angular上有很多资源。注意区分AngularJS ( <em class="kl">老版本与本帖</em>无关)和Angular ( <em class="kl">最新版本是7有8在地平线上</em>)。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><h1 id="a7fc" class="ky kz iq bd la lb mw ld le lf mx lh li lj my ll lm ln mz lp lq lr na lt lu lv bi translated">格里斯特</h1><p id="4d76" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">Gridster是一个拖放式多列网格，使用户能够从跨越多列的元素构建直观的可拖动布局。它还支持在网格中动态添加和删除元素。我最近在工作中经常使用它，感觉棒极了。</p><p id="f5ae" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">具体来说，我们将使用<a class="ae nb" href="https://github.com/tiberiuzuld/angular-gridster2" rel="noopener ugc nofollow" target="_blank"> angular-gridster2 </a>，它是该库的纯角度实现:</p><div class="nc nd gp gr ne nf"><a href="https://github.com/tiberiuzuld/angular-gridster2" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">tiberiuzuld/angular-gridster2</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">角磨机2。在GitHub上创建一个帐户，为tiberiuzuld/angular-gridster2的开发做出贡献。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="np l nq nr ns no nt kw nf"/></div></div></a></div></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="2239" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在事不宜迟，让我们卷起袖子大干一场吧！</p><h1 id="c105" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">1.创建新的角度项目</h1><p id="39bf" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">如果您以前从未使用过Angular，那么在我们开始之前，您需要在您的计算机上全局安装它:</p><p id="1897" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nu nv nw nx b">npm install -g @angular/cli</code></p><p id="fe98" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第一步是创建和配置Angular工作空间，让我们使用Angular的神奇CLI创建一个工作空间:</p><p id="02a4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nu nv nw nx b">ng new ng-dashboard-builder</code></p><p id="2463" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们不需要这个项目的路由，所以可以不包含它，并选择<code class="fe nu nv nw nx b">SCSS</code>作为样式表格式:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="2917" class="oc kz iq nx b gy od oe l of og">Would you like to add Angular routing? <strong class="nx ir">No</strong><br/>Which stylesheet format would you like to use? <strong class="nx ir">SCSS</strong> [ <a class="ae nb" href="http://sass-lang.com" rel="noopener ugc nofollow" target="_blank">http://sass-lang.com</a> ]</span></pre><p id="9f42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，让我们转到项目目录并安装我们的依赖项:</p><p id="5cb9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nu nv nw nx b">cd ng-dashboard-builder<br/>npm i angular-gridster2 angular2-uuid --save</code></p><p id="4387" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个阶段，你可以启动Angular的开发服务器，通过运行<code class="fe nu nv nw nx b">ng serve</code>预览你的项目，并在<code class="fe nu nv nw nx b">http://localhost:4200</code>打开你的浏览器。</p><h1 id="1976" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">2.创建布局服务和组件</h1><p id="f32f" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">接下来，让我们为布局<strong class="jp ir">服务</strong>和布局<strong class="jp ir">组件</strong>创建占位符。</p><p id="206c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">在我们创建它们之前，让我区分一下这两者:</em></p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="f106" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一个<strong class="jp ir">服务</strong>通常是一些共享的业务逻辑、数据模型或功能，它们可以通过依赖注入在一个Angular应用程序中的不同组件之间共享(<em class="kl">我们将在后面讨论依赖注入——这真的很酷！</em>)。</p><p id="f760" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于我们的dashboard builder，我们可能需要一个服务来保存与我们的布局相关的数据(<em class="kl">数据</em> <em class="kl">模型</em>)和另一个服务来对附加到我们的拖放事件的数据进行转换。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="b103" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">组件以其最简单的形式用于在我们的应用程序中显示数据，所以在我们的例子中呈现布局。组件构成了任何角度应用的主要构件。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="ce79" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过区分这两者，我们有了关注点的分离，数据和逻辑(<em class="kl">作为无状态对象的服务</em>)从它们的上下文用例中分离出来。这有助于将我们的应用程序划分成逻辑块，促进良好的实践，如可重用性和可伸缩性。</p><p id="c208" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我喜欢将组件和服务分离到不同的文件夹中，所以让我们在新工作区的<code class="fe nu nv nw nx b">src/app/</code>根目录下创建两个文件夹:</p><p id="c491" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nu nv nw nx b">cd src/app/<br/>mkdir components services</code></p><p id="cbf3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们将很快更详细地了解这些，但是让我们使用CLI创建一个<strong class="jp ir">布局服务</strong>和<strong class="jp ir">布局组件</strong>:</p><p id="ecb0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nu nv nw nx b">cd components/<br/>ng generate component layout</code></p><p id="71c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nu nv nw nx b">cd ../services/<br/>ng generate service layout</code></p><p id="db19" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦你完成了上面的步骤，你的项目应该如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oh"><img src="../Images/c1225b7ec0e7258afd56510d523bb4fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NGm1gkxwvU7PZP-CmphFPw.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk">Angular project with layout component and layout service</figcaption></figure><p id="ab62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们继续之前，我们应该让我们的应用程序默认呈现我们的<strong class="jp ir">布局组件</strong>。通常，这可以通过应用程序路由来实现，但由于我们在本文中没有涉及这一点，我们可以简单地将引用硬编码到我们的<code class="fe nu nv nw nx b">app.component.html</code>文件中，将其内容替换为以下内容:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="0722" class="oc kz iq nx b gy od oe l of og">&lt;app-layout&gt;&lt;/app-layout&gt;</span></pre><p id="9443" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">注意:</em></strong><em class="kl">Angular编译器巧妙地识别出这个自定义元素名，并将其映射到我们的布局组件。自定义元素名称定义为</em><strong class="jp ir"><em class="kl">layout . component . ts</em></strong><em class="kl">文件中的</em> <strong class="jp ir"> <em class="kl">选择器</em> </strong> <em class="kl">。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi om"><img src="../Images/7961c079626cd09c8cd7902203a26d60.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/0*4fKiM8qxwootz0EP.jpg"/></div></div></figure><h1 id="b49e" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">3.带有Gridster的布局组件</h1><p id="bd42" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">现在有趣的是——让我们引入Gridster，使我们能够开始构建一些布局。</p><p id="7e41" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经在<strong class="jp ir"> angular-gridster2、<em class="kl"> </em> </strong>上安装了我们的依赖项，但是我们需要让它在我们的angular项目中可用，为此我们必须将它导入到我们的app模块的<code class="fe nu nv nw nx b">app.module.ts </code>文件中。</p><p id="3015" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">继续打开<code class="fe nu nv nw nx b">src/app/app.module.ts</code>:</p><p id="ed40" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从文件顶部的<strong class="jp ir"> angular-gridster2 </strong>导入<strong class="jp ir"> GridsterModule </strong>，并将其添加到模块的导入定义中，如下所示:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="95ad" class="oc kz iq nx b gy od oe l of og">import { BrowserModule } from '@angular/platform-browser';<br/>import { NgModule } from '@angular/core';<br/><strong class="nx ir">import { GridsterModule } from 'angular-gridster2';</strong></span><span id="e57c" class="oc kz iq nx b gy on oe l of og">import { AppComponent } from './app.component';</span><span id="9f2f" class="oc kz iq nx b gy on oe l of og">import { LayoutComponent } from './components/layout/layout.component';</span><span id="98c6" class="oc kz iq nx b gy on oe l of og">@NgModule({<br/>  declarations: [<br/>    AppComponent,<br/>    LayoutComponent<br/>  ],<br/>  <strong class="nx ir">imports</strong>: [<br/>    BrowserModule,<br/><strong class="nx ir">    GridsterModule</strong><br/>  ],<br/>  providers: [],<br/>  bootstrap: [AppComponent]<br/>})</span><span id="a2d6" class="oc kz iq nx b gy on oe l of og">export class AppModule { }</span></pre></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="0689" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们要求Angular CLI创建我们的布局组件时，它生成了如下所示的4个文件:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="b29f" class="oc kz iq nx b gy od oe l of og">src/app/components/layout/layout.component.html</span><span id="1d20" class="oc kz iq nx b gy on oe l of og"># Template used for rendering HTML</span><span id="93d6" class="oc kz iq nx b gy on oe l of og">src/app/components/layout/layout.component.scss</span><span id="b7a5" class="oc kz iq nx b gy on oe l of og"># Styling i.e. how the component looks</span><span id="aec3" class="oc kz iq nx b gy on oe l of og">src/app/components/layout/layout.component.spec.ts</span><span id="5049" class="oc kz iq nx b gy on oe l of og"># Unit test spec</span><span id="b065" class="oc kz iq nx b gy on oe l of og">src/app/components/layout/layout.component.ts</span><span id="992b" class="oc kz iq nx b gy on oe l of og"># TypeScript file with logic, methods available to the component</span></pre><p id="afa9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Gridster需要一些默认选项来运行，所以让我们把它们添加到<code class="fe nu nv nw nx b">src/app/components/layout/layout.component.ts</code>中。</p><p id="f7b3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将此导入行添加到文件的开头，然后在类定义中添加选项和布局值，如下所示:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="be5f" class="oc kz iq nx b gy od oe l of og">import { Component, OnInit } from '@angular/core';<br/><strong class="nx ir">import { GridsterConfig, GridsterItem } from 'angular-gridster2';</strong></span><span id="df6b" class="oc kz iq nx b gy on oe l of og">@Component({<br/>  selector: 'app-layout',<br/>  templateUrl: './layout.component.html',<br/>  styleUrls: ['./layout.component.scss']<br/>})</span><span id="f001" class="oc kz iq nx b gy on oe l of og">export class LayoutComponent implements OnInit {</span><span id="d85d" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">  options: GridsterConfig = {<br/>    draggable: {<br/>      enabled: true<br/>    },<br/>    pushItems: true,<br/>    resizable: {<br/>      enabled: true<br/>    }<br/>  };</strong></span><span id="9b43" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">  layout: GridsterItem[] = [];</strong></span><span id="24d6" class="oc kz iq nx b gy on oe l of og">  constructor() { }</span><span id="acad" class="oc kz iq nx b gy on oe l of og">  ngOnInit() {<br/>  }</span><span id="579d" class="oc kz iq nx b gy on oe l of og">}</span></pre><blockquote class="oo op oq"><p id="d132" class="jn jo kl jp b jq jr js jt ju jv jw jx or jz ka kb os kd ke kf ot kh ki kj kk ij bi translated">如果您以前没有见过JavaScript中的<code class="fe nu nv nw nx b">&lt;name&gt;: &lt;type&gt;</code>符号，欢迎来到TypeScript。TypeScript与Angular捆绑在一起，为JavaScript带来了静态类型。</p></blockquote><p id="7d81" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们只是将一些<strong class="jp ir"> GridsterConfig </strong>设置为<strong class="jp ir">选项</strong>，将一个<strong class="jp ir"> GridsterItem </strong> ( <em class="kl">暂时为空</em>)数组设置为<strong class="jp ir">布局</strong>。</p><p id="26ba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> GridsterConfig </strong>和<strong class="jp ir"> GridsterItem </strong>是指我们在本文件开头从<strong class="jp ir"> angular-gridster2 </strong>导入的类型。</p><p id="6301" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">注意:</em> </strong> <em class="kl">因为我们使用的是TypeScript，编译器知道哪些值是预期值，所以如果我们输入一个无效值，项目将不会编译。</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/9d58236391ca3e73a4b768569dde2507.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*rfwGOWoVkd1Oy6cd.jpg"/></div></figure><p id="8019" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在打开<code class="fe nu nv nw nx b">src/app/components/layout/layout.component.html</code>，用以下内容替换它的内容:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="902b" class="oc kz iq nx b gy od oe l of og">&lt;div class="toolbar"&gt;&lt;/div&gt;</span><span id="57cb" class="oc kz iq nx b gy on oe l of og">&lt;gridster [options]="options"&gt;<br/>  &lt;gridster-item *ngFor="let item of layout" [item]="item"&gt;<br/>  &lt;/gridster-item&gt;<br/>&lt;/gridster&gt;</span></pre><p id="d97d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">暂时忽略<strong class="jp ir">工具栏</strong> div，我们稍后会用到它…</p><p id="0452" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们通过引用<code class="fe nu nv nw nx b">&lt;gridster&gt;</code>标签在组件模板中创建了一个新的Gridster实例。</p><p id="6a09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们将一个属性放在方括号中时(例如<code class="fe nu nv nw nx b">[options]="options"</code>)，我们使用一个表达式来绑定这个值。</p><p id="8105" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">另外,<code class="fe nu nv nw nx b">*ngFor="let item of layout"</code>是一个在数据集合上迭代的指令。</p><p id="4b31" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你已经学习了表达式和指令，你很快就会爱上Angular的强大模板引擎！</p><p id="15c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要为Gridster添加一些CSS来正确渲染，因为它需要一个高度，这样它就可以计算尺寸，所以让我们将以下内容添加到<code class="fe nu nv nw nx b">layout.component.scss</code>:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="65e5" class="oc kz iq nx b gy od oe l of og">:host {</span><span id="9db9" class="oc kz iq nx b gy on oe l of og">  .toolbar {<br/>    height: 100px;<br/>    display: flex;<br/>  }</span><span id="aa6e" class="oc kz iq nx b gy on oe l of og">  gridster {<br/>    display: flex;<br/>    height: calc(100vh - 115px);<br/>    flex-direction: column;<br/>  }</span><span id="4c29" class="oc kz iq nx b gy on oe l of og">}</span></pre></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="6805" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们继续之前，快速回顾一下…T12】</p><blockquote class="oo op oq"><p id="3485" class="jn jo kl jp b jq jr js jt ju jv jw jx or jz ka kb os kd ke kf ot kh ki kj kk ij bi translated">我们已经创建了项目，并添加了布局组件和布局服务。我们将布局组件设置为默认呈现，然后在布局组件中配置gridster之前，在应用程序模块中包含angular-gridster2。</p></blockquote></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="dff3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，组件不呈现任何东西，因为我们在<code class="fe nu nv nw nx b">layout.component.ts</code>中将GridsterItem值的数组设置为空…</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="149c" class="oc kz iq nx b gy od oe l of og">layout: GridsterItem[] = [];</span></pre><p id="e6a5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们将创建一个服务来帮助我们管理我们的布局。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ov"><img src="../Images/06a09edb9407da0ffc7ca5023c8008f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/0*YR4fpyEn_G6ijqgO.jpg"/></div></figure><h1 id="65fb" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">4.布局服务</h1><p id="9815" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">我将有目的地保持我们的服务简单，这样您就可以看到组件如何与它交互，而没有不必要的复杂性。</p><p id="0ad2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">不过要注意，我们会在布局组件和布局服务之间频繁切换。</em> </strong></p><p id="380d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">首先，向我们的服务添加两个方法，一个是添加名为<code class="fe nu nv nw nx b">addItem()</code>的<strong class="jp ir"> GridsterItem </strong>，另一个是删除名为<code class="fe nu nv nw nx b">removeItem()</code>的GridsterItem。</p><p id="dd70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">打开<code class="fe nu nv nw nx b">src/app/services/layout.service.ts</code>并添加以下内容:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="649f" class="oc kz iq nx b gy od oe l of og">import { Injectable } from '@angular/core';<br/><strong class="nx ir">import { GridsterConfig, GridsterItem } from 'angular-gridster2';<br/>import { UUID } from 'angular2-uuid';</strong></span><span id="c78a" class="oc kz iq nx b gy on oe l of og">@Injectable({<br/>  providedIn: 'root'<br/>})</span><span id="00f5" class="oc kz iq nx b gy on oe l of og">export class LayoutService {</span><span id="f935" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">  public options: GridsterConfig = {<br/>    draggable: {<br/>      enabled: true<br/>    },<br/>    pushItems: true,<br/>    resizable: {<br/>      enabled: true<br/>    }<br/>  };</strong></span><span id="cb79" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">  public layout: GridsterItem[] = [];</strong></span><span id="d869" class="oc kz iq nx b gy on oe l of og">  constructor() { }</span><span id="f181" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">  addItem(): void {<br/>    this.layout.push({<br/>      cols: 5,<br/>      id: UUID.UUID(),<br/>      rows: 5,<br/>      x: 0,<br/>      y: 0<br/>    });<br/>  }</strong></span><span id="65ed" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">  deleteItem(id: string): void {<br/>    const item = this.layout.find(d =&gt; d.id === id);<br/>    this.layout.splice(this.layout.indexOf(item), 1);<br/>  }</strong></span><span id="655a" class="oc kz iq nx b gy on oe l of og">}</span></pre><p id="59f9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们中更精明的人会注意到在组件和服务中定义的<strong class="jp ir">布局</strong>和<strong class="jp ir">选项</strong>变量的严重重复。</p><p id="86bd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我这样做是为了说明服务是多么有用。如果属性是在服务中定义的，那么这些值可以很容易地与其他组件共享。在组件中定义它们没有这个优势。</p><p id="9a0d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在是时候重新审视我们的组件，让这些新方法对我们有用，并删除重复的属性。</p><p id="391d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">切换回<code class="fe nu nv nw nx b">src/app/components/layout/layout.component.ts</code>并更新到以下内容:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="e007" class="oc kz iq nx b gy od oe l of og">import { Component, OnInit } from '@angular/core';<br/>import { GridsterConfig, GridsterItem } from 'angular-gridster2';<br/><strong class="nx ir">import { LayoutService } from '../../services/layout.service';</strong></span><span id="3888" class="oc kz iq nx b gy on oe l of og">@Component({<br/>selector: 'app-layout',<br/>templateUrl: './layout.component.html',<br/>styleUrls: ['./layout.component.scss']<br/>})</span><span id="05bf" class="oc kz iq nx b gy on oe l of og">export class LayoutComponent implements OnInit {</span><span id="4262" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">  get options(): GridsterConfig {<br/>    return this.layoutService.options;<br/>  }</strong></span><span id="40a2" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">  get layout(): GridsterItem[] {<br/>    return this.layoutService.layout;<br/>  }</strong></span><span id="549a" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">  constructor(<br/>    private layoutService: LayoutService<br/>  ) { }</strong></span><span id="9fd4" class="oc kz iq nx b gy on oe l of og">  ngOnInit() {}</span><span id="cc51" class="oc kz iq nx b gy on oe l of og">}</span></pre><p id="067c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里的主要区别是<strong class="jp ir">选项</strong>和<strong class="jp ir">布局</strong>的值现在来自我们的布局服务(使用getters)。我们的服务是通过依赖注入实现的。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="67a1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">依赖注入是有角度的，这比你理解它是如何工作的要重要得多。其实很聪明。</p><p id="8092" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过在组件顶部导入我们的服务(<em class="kl">作为普通的</em>)，我们可以在构造函数中声明一个类型为我们的服务的变量。现在，它将神奇地创建一个新的应用程序范围的服务实例，或者使用一个已经存在的实例。很酷，对吧？</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="81c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经在我们的布局服务中创建了一些新方法，并将我们的布局服务注入到我们的布局组件中，所以让我们利用组件模板中的方法，打开<code class="fe nu nv nw nx b">src/app/components/layout/layout.component.html</code>并更新如下:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="3f66" class="oc kz iq nx b gy od oe l of og">&lt;div class="toolbar"&gt;<br/>  <strong class="nx ir">&lt;button (click)="layoutService.addItem()"&gt;Add Item&lt;/button&gt;<br/></strong>&lt;/div&gt;</span><span id="0a93" class="oc kz iq nx b gy on oe l of og">&lt;gridster [options]="options"&gt;<br/>  &lt;gridster-item *ngFor="let item of layout" [item]="item"&gt;<br/><strong class="nx ir">    &lt;button<br/>      (click)="layoutService.deleteItem(item)"<br/>    &gt;<br/>      Delete Item<br/>    &lt;/button&gt;</strong><br/>  &lt;/gridster-item&gt;<br/>&lt;/gridster&gt;</span></pre><p id="0376" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们所做的唯一改变是引入了两个新按钮；一个调用<code class="fe nu nv nw nx b">addItem()</code>服务方法，另一个调用<code class="fe nu nv nw nx b">deleteItem()</code>服务方法(<em class="kl">传递一个布局作为参数</em>)。</p><p id="6a86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我还会推荐按钮的样式。我只打算在<code class="fe nu nv nw nx b">layout.component.scss</code>中添加一个固定高度，如下所示:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="07dc" class="oc kz iq nx b gy od oe l of og">button {<br/>  height: 30px;<br/>}</span></pre><p id="566e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">现在你终于可以玩Gridster了…在浏览器中加载你的项目，点击“添加项目”按钮，添加任意多的面板，然后调整大小，拖动和删除，直到你满意为止！</em></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ow"><img src="../Images/2106b39585dc2ab46e684993532f5755.png" data-original-src="https://miro.medium.com/v2/resize:fit:906/format:webp/0*34ZATTGONlpquS8r.jpg"/></div></figure><h1 id="79a5" class="ky kz iq bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">5.拖放组件</h1><p id="0994" class="pw-post-body-paragraph jn jo iq jp b jq lw js jt ju lx jw jx jy ly ka kb kc lz ke kf kg ma ki kj kk ij bi translated">在我将这个小项目交给您并让您尽情发挥之前，我想添加一些功能，使用户能够将组件拖放到布局上，从而创建完全定制的仪表板。</p><p id="22b9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这将是本演练中最紧张的部分，但请耐心等待，我们就快完成了。</p><p id="f187" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将让您决定组件的外观。我们公司一直使用这种方法来创建分析仪表板，所以对我们来说，组件主要是数据可视化，如图表、数据表等。</p><p id="933a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于本文的目的，让我们创建一些示例组件:</p><p id="682c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您还没有在组件目录中，那么<code class="fe nu nv nw nx b">cd</code>您自己在那里，并使用Angular CLI生成一些示例组件:</p><p id="731c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nu nv nw nx b">cd src/app/components/<br/>ng generate component example1<br/>ng generate component example2</code></p><p id="cd3a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你现在应该在<code class="fe nu nv nw nx b">src/app/components/</code>文件夹下有<strong class="jp ir">两个</strong>附加文件夹，如下所示:</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div class="gh gi ox"><img src="../Images/81c87807acb41da67702898dab07fc12.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*lRg_ZIhUNRNSUgXLTMGgqA.png"/></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk">example 1 and example 2 components</figcaption></figure><p id="ca37" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要这些组件作为<strong class="jp ir">入口组件</strong>可用，这样我们就可以将它们放在我们的布局项目中。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="d8cf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="kl">入口组件</em> </strong> <em class="kl">是引导组件，Angular将作为应用程序启动过程的一部分加载到DOM中。</em></p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="67b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为此，我们必须向<code class="fe nu nv nw nx b">src/app/app.module.ts</code>添加一个<code class="fe nu nv nw nx b">entryComponents</code>定义，如下所示:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="e25c" class="oc kz iq nx b gy od oe l of og">...</span><span id="751e" class="oc kz iq nx b gy on oe l of og">entryComponents: [<br/>  Example1Component,<br/>  Example2Component<br/>]</span></pre></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="a5b2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的目标是有一个非常酷的用户体验，用户可以将组件拖放到布局项目上。为此，我们需要通过创建一些HTML元素来创建应用程序中组件的可视化表示，这些元素可以使用HTML5的拖放事件来拖动。</p><p id="59fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在此之前，我们希望在我们的布局服务中保存<code class="fe nu nv nw nx b">components</code>,这样当用户将一个组件放到布局项目中时，我们会将更改存储在应用程序状态中。</p><p id="7922" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们需要对我们的布局服务进行一些更改来支持这一点，打开<code class="fe nu nv nw nx b">src/app/services/layout.service.ts</code>并添加以下内容:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="4655" class="oc kz iq nx b gy od oe l of og"><strong class="nx ir">export interface IComponent {<br/>  id: string;<br/>  componentRef: string;<br/>}</strong></span><span id="def5" class="oc kz iq nx b gy on oe l of og">@Injectable({<br/>  providedIn: 'root'<br/>})<br/>...</span></pre><p id="b462" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是一个自定义的<strong class="jp ir">接口</strong>定义，它应该在我们的布局服务定义之上。这里我们定义了<code class="fe nu nv nw nx b">id</code>和<code class="fe nu nv nw nx b">componentRef</code>，前者应该匹配封闭布局项的id，后者将是对示例组件<em class="kl">的字符串引用，即哪个组件应该放在匹配该id的布局项内。</em></p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="c691" class="oc kz iq nx b gy od oe l of og">public layout: GridsterItem[] = [];</span><span id="f416" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">public components: IComponent[] = [];</strong></span><span id="66a4" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">dropId: string;</strong></span></pre><p id="7364" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">我们需要定义一些额外的参数，如上所示:</em></p><p id="fbd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nu nv nw nx b">components</code>是一个组件数组(<em class="kl">我们定义为</em>之上的接口)，它将通过id与布局项目匹配。</p><p id="393f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nu nv nw nx b">dropId</code>是用户当前悬停的布局项目的id(<em class="kl">我们将很快看到这是如何工作的</em>)。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="69f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">接下来，我们需要向我们的服务添加一些新方法，这些方法将附加到Gridster和HTML5提供的拖放<em class="kl"> </em>事件处理程序:</p><p id="7d47" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nu nv nw nx b">setDropId()</code>将被附加到Gridster items <code class="fe nu nv nw nx b">drag-over </code>事件，该事件将在用户将鼠标移动到布局项目上时被触发。</p><p id="d2a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nu nv nw nx b">dropItem()</code>将由组件上的HTML5 <code class="fe nu nv nw nx b">dragend</code>事件触发，该事件将在用户完成组件拖动时触发。</p><p id="ea1b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nu nv nw nx b">getComponentRef()</code>是一个方便的实用方法，它允许我们通过传递一个布局项目id来查询componentRef。</p><p id="92d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还对我们的<code class="fe nu nv nw nx b">deleteItem()</code>方法进行了修改，如果布局项目被删除，它将从我们的<code class="fe nu nv nw nx b">components</code>数组中删除组件。</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="47cc" class="oc kz iq nx b gy od oe l of og">deleteItem(id: string): void {<br/>  const item = this.layout.find(d =&gt; d.id === id);<br/>  this.layout.splice(this.layout.indexOf(item), 1);<br/><strong class="nx ir">  const comp = this.components.find(c =&gt; c.id === id);<br/>  this.components.splice(this.components.indexOf(comp), 1);</strong><br/>}</span><span id="1fcf" class="oc kz iq nx b gy on oe l of og"><br/><strong class="nx ir">setDropId(dropId: string): void {<br/>  this.dropId = dropId;<br/>}</strong></span><span id="814e" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">dropItem(dragId: string): void {</strong></span><span id="8cfa" class="oc kz iq nx b gy on oe l of og">  <strong class="nx ir">const { components } = this;</strong></span><span id="a5f3" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">  const comp: IComponent = components.find(c =&gt; c.id === this.dropId);<br/>  <br/>  const updateIdx: number = comp ? components.indexOf(comp) : components.length;</strong></span><span id="6d73" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">  const componentItem: IComponent = {<br/>    id: this.dropId,<br/>    componentRef: dragId<br/>  };</strong></span><span id="e596" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">  this.components = Object.assign([], components, { [updateIdx]: componentItem });</strong></span><span id="bb28" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">}</strong></span><span id="f3af" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">getComponentRef(id: string): string {<br/>  const comp = this.components.find(c =&gt; c.id === id);<br/>  return comp ? comp.componentRef : null;<br/>}</strong></span></pre><p id="bb9f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的布局服务现在已经具备了让我们能够在布局项目上拖放组件的所有必要条件。</p></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="edcb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们跳回到布局组件，并将这些新的布局服务方法连接到我们的布局组件。</p><p id="b337" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">从在<code class="fe nu nv nw nx b">src/app/components/layout/layout.component.ts</code>中公开服务的新<code class="fe nu nv nw nx b">components</code>属性开始。您还需要导入我们在布局服务中定义的<code class="fe nu nv nw nx b">IComponent</code>接口:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="0491" class="oc kz iq nx b gy od oe l of og">...<br/>import { LayoutService<strong class="nx ir">, IComponent</strong> } from '../../services/layout.service';</span><span id="57e1" class="oc kz iq nx b gy on oe l of og">...</span><span id="a454" class="oc kz iq nx b gy on oe l of og"><strong class="nx ir">get components(): IComponent[] {<br/>  return this.layoutService.components;<br/>}</strong></span></pre><p id="bed2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们准备在组件模板中附加服务方法，打开<code class="fe nu nv nw nx b">src/app/components/layout/layout.component.html</code>并进行以下更改:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="e3b0" class="oc kz iq nx b gy od oe l of og">&lt;div class="toolbar"&gt;<br/>  &lt;button (click)="layoutService.addItem()"&gt;Add Item&lt;/button&gt;<br/> <strong class="nx ir"> &lt;div<br/>    class="draggable"<br/>    draggable="true"<br/>    (dragend)="layoutService.dropItem('example1')"</strong><br/>  <strong class="nx ir">&gt;<br/>    Example 1<br/>  &lt;/div&gt;<br/>  &lt;div<br/>    class="draggable"<br/>    draggable="true"<br/>    (dragend)="layoutService.dropItem('example2')"<br/>  &gt;<br/>    Example 2<br/>  &lt;/div&gt;</strong><br/>&lt;/div&gt;<br/>&lt;gridster [options]="options"&gt;<br/>  &lt;gridster-item<br/>    *ngFor="let item of layout"<br/>    [item]="item"<br/>    <strong class="nx ir">(dragover)="layoutService.setDropId(item.id)"</strong><br/>  &gt;<br/>    &lt;button<br/>    (click)="layoutService.deleteItem(item)"<br/>    &gt;<br/>      Delete Item<br/>    &lt;/button&gt;<br/>  &lt;/gridster-item&gt;<br/>&lt;/gridster&gt;</span></pre><p id="f4d5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们现在添加了几个新的HTML <code class="fe nu nv nw nx b">div</code>元素来表示我们的组件。</p><p id="3533" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我鼓励你在这里发挥一点创造力。我只是以一种基本的方式来说明功能…这里的重点是它如何工作，而不是它看起来如何。</p><p id="ce9d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里要注意的重要属性是:</p><p id="decc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nu nv nw nx b">draggable="true"</code>，这是挂钩到HTML5的拖放事件。这将使这个元素在浏览器中可拖动，并将触发一些我们现在可以使用的事件。</p><p id="b6fb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当用户拖动完HTML元素后，将触发<code class="fe nu nv nw nx b">(dragend)="layoutService.onDragEnd('example1')"</code>。</p><p id="2d33" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当用户将鼠标移动到布局项目上时，将触发<code class="fe nu nv nw nx b">(dragover)="layoutService.setDropId(item.id)"</code>。</p><p id="9aec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们还需要在<code class="fe nu nv nw nx b">layout.component.scss</code>中添加一些基本的样式:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="bc41" class="oc kz iq nx b gy od oe l of og">.draggable {<br/>  padding: 10px;<br/>  width: 200px;<br/>  border: solid 2px #000;<br/>  margin-left: 20px;<br/>  text-align: center;<br/>  font-family: Arial, Helvetica, sans-serif;<br/>}</span></pre></div><div class="ab cl mp mq hu mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="ij ik il im in"><p id="0bcd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到这个阶段，一切都应该在幕后很好地运转。我们应该能够添加布局项目，并从顶部拖动组件到它们上面，但等待…什么都没发生？</p><p id="27fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，我们需要创建一个定制的Angular指令来呈现布局项目中的组件。</p><p id="0981" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了保持整洁，让我们在<code class="fe nu nv nw nx b">src/app/</code>文件夹中创建一个<code class="fe nu nv nw nx b">directives</code>文件夹，并使用CLI生成一个名为<code class="fe nu nv nw nx b">layout-item</code>的指令:</p><p id="b4e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe nu nv nw nx b">cd src/app/<br/>mkdir directives<br/>cd directives/<br/>ng generate directive layout-item</code></p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oy"><img src="../Images/77333ba3e76eb7d9ddea665b5d6844fa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eBa9hqoaRStwzHnBJw8UWA.png"/></div></div><figcaption class="oi oj gj gh gi ok ol bd b be z dk">layout-item directive</figcaption></figure><p id="4a74" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们在<code class="fe nu nv nw nx b">src/app/directives/layout-item.directive.ts</code>中添加一些代码来呈现我们的组件:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="33cf" class="oc kz iq nx b gy od oe l of og">import {<br/>  Directive,<br/>  Input,<br/>  OnChanges,<br/>  ViewContainerRef,<br/>  ComponentFactoryResolver,<br/>  ComponentRef<br/>} from '@angular/core';</span><span id="7267" class="oc kz iq nx b gy on oe l of og">import { Example1Component } from '../components/example1/example1.component';</span><span id="6fab" class="oc kz iq nx b gy on oe l of og">import { Example2Component } from '../components/example2/example2.component';</span><span id="56cd" class="oc kz iq nx b gy on oe l of og">const components = {<br/>  example1: Example1Component,<br/>  example2: Example2Component<br/>};</span><span id="58c6" class="oc kz iq nx b gy on oe l of og">@Directive({<br/>  selector: '[appLayoutItem]'<br/>})</span><span id="0bff" class="oc kz iq nx b gy on oe l of og">export class LayoutItemDirective implements OnChanges {<br/>  @Input() componentRef: string;<br/>  component: ComponentRef&lt;any&gt;;<br/>  <br/>  constructor(<br/>    private container: ViewContainerRef,<br/>    private resolver: ComponentFactoryResolver<br/>  ) { }</span><span id="0ad7" class="oc kz iq nx b gy on oe l of og">  ngOnChanges(): void {<br/>    const component = components[this.componentRef];<br/>    <br/>    if (component) {<br/>      const factory = this.resolver.resolveComponentFactory&lt;any&gt;(component);<br/>      this.component = this.container.createComponent(factory);<br/>    }<br/>  }<br/>}</span></pre><p id="5789" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在上面的指令中，我们为我们的<code class="fe nu nv nw nx b">componentRef</code>属性存储了一个映射。然后我们将这个<code class="fe nu nv nw nx b">componentRef</code>值作为<code class="fe nu nv nw nx b">Input()</code>传递给指令，并使用Angular的组件工厂生成一个新组件。该组件是在一个容器内生成的，该容器在指令构造函数中使用Angular的<code class="fe nu nv nw nx b">ViewContainerRef</code>引用。</p><p id="36cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">将指令添加到我们的模板中，工作方式与组件相同，我们只需要在下面的文件<code class="fe nu nv nw nx b">src/app/components/layout/layout.component.html</code>中的每个布局项目中添加一个引用:</p><pre class="kn ko kp kq gt ny nx nz oa aw ob bi"><span id="a8ce" class="oc kz iq nx b gy od oe l of og">&lt;gridster-item<br/>    *ngFor="let item of layout"<br/>    [item]="item"<br/>    (dragover)="setDropId(item.id)"<br/>  &gt;<br/><strong class="nx ir">    &lt;ng-container<br/>      appLayoutItem<br/>      [componentRef]="layoutService.getComponentRef(item.id)"<br/>    &gt;<br/>    &lt;/ng-container&gt;</strong><br/>    &lt;button<br/>      (click)="layoutService.deleteItem(item)"<br/>    &gt;<br/>      Delete Item<br/>    &lt;/button&gt;<br/>  &lt;/gridster-item&gt;</span></pre><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi oz"><img src="../Images/2a8cf2c8ae14a4b4601fbbfb6eba27bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*4KY3W6vF2Grnt2RdCu_YQg.png"/></div></div></figure><p id="ff64" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="kl">现在，我们完成了！！！我希望你觉得这个小项目有用…一如既往，我已经把它放在我的GitHub上了，享受吧！！</em></p><div class="nc nd gp gr ne nf"><a href="https://github.com/chriskitson/ng-dashboard-builder" rel="noopener  ugc nofollow" target="_blank"><div class="ng ab fo"><div class="nh ab ni cl cj nj"><h2 class="bd ir gy z fp nk fr fs nl fu fw ip bi translated">chriskitson/ng-仪表板生成器</h2><div class="nm l"><h3 class="bd b gy z fp nk fr fs nl fu fw dk translated">在GitHub上创建一个帐户，为chriskitson/ng-dashboard-builder的开发做出贡献。</h3></div><div class="nn l"><p class="bd b dl z fp nk fr fs nl fu fw dk translated">github.com</p></div></div><div class="no l"><div class="pa l nq nr ns no nt kw nf"/></div></div></a></div><blockquote class="oo op oq"><p id="ee5f" class="jn jo kl jp b jq jr js jt ju jv jw jx or jz ka kb os kd ke kf ot kh ki kj kk ij bi translated">感谢您花时间阅读我的文章。</p></blockquote></div></div>    
</body>
</html>