<html>
<head>
<title>JavaScript Events Handlers — LoadStart and Mouse Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript事件处理程序— LoadStart和鼠标事件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-events-handlers-loadstart-and-mouse-events-ed7a693dfbbb?source=collection_archive---------4-----------------------#2020-01-25">https://javascript.plainenglish.io/javascript-events-handlers-loadstart-and-mouse-events-ed7a693dfbbb?source=collection_archive---------4-----------------------#2020-01-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d8341e84a6f702c874df0a4dcf3a01bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kSWqmZG1PR85NJq2"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rstone_design?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ryan Stone</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="62af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，事件是应用程序中发生的动作。它们是由各种事情触发的，比如输入、提交表单、调整大小等元素变化，或者应用程序运行时发生的错误等。我们可以分配一个事件处理器来处理这些事件。发生在DOM元素上的事件可以通过为相应事件的DOM对象的属性分配一个事件处理程序来处理。在本文中，我们将看看如何使用<code class="fe lb lc ld le b">onloadstart</code>、<code class="fe lb lc ld le b">onlostpointercapture</code>和<code class="fe lb lc ld le b">onmouseup</code>事件处理程序。</p><h1 id="c68e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated"><code class="fe lb lc ld le b"><strong class="ak">onloadstart</strong></code></h1><p id="03ff" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">onloadstart</code>属性是XmlHttpRequest对象的一部分。它允许我们给它分配一个事件处理函数来处理数据刚开始加载时触发的<code class="fe lb lc ld le b">loadstart</code>事件。</p><p id="9e2b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以为<code class="fe lb lc ld le b">onloadstart</code>事件分配一个事件处理程序，就像我们在下面的代码中所做的那样:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6679" class="mq lg iq le b gy mr ms l mt mu">const loadButtonSuccess = document.querySelector('.load.success');<br/>const loadButtonError = document.querySelector('.load.error');<br/>const loadButtonAbort = document.querySelector('.load.abort');<br/>const log = document.querySelector('.event-log');</span><span id="d67c" class="mq lg iq le b gy mv ms l mt mu">function handleLoadStart(e) {<br/>  console.log(e);<br/>  log.textContent = log.textContent + `${e.type}: ${e.loaded} bytes transferred\n`;<br/>}</span><span id="06d6" class="mq lg iq le b gy mv ms l mt mu">function addListeners(xhr) {<br/>  xhr.onloadstart = handleLoadStart;<br/>}</span><span id="a7c1" class="mq lg iq le b gy mv ms l mt mu">function get(url) {<br/>  log.textContent = '';<br/>  const xhr = new XMLHttpRequest();<br/>  addListeners(xhr);<br/>  xhr.open("GET", url);<br/>  xhr.send();<br/>  return xhr;<br/>}<br/>loadButtonSuccess.addEventListener('click', () =&gt; {<br/>  get('<a class="ae kc" href="https://jsonplaceholder.typicode.com/todos/1'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1'</a>);<br/>});<br/>loadButtonError.addEventListener('click', () =&gt; {<br/>  get('<a class="ae kc" href="https://somewhere.org/i-dont-exist'" rel="noopener ugc nofollow" target="_blank">https://somewhere.org/i-dont-exist'</a>);<br/>});<br/>loadButtonAbort.addEventListener('click', () =&gt; {<br/>  get('<a class="ae kc" href="https://jsonplaceholder.typicode.com/todos/1').abort();" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1').abort();</a><br/>});</span></pre><p id="346d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有3个按钮，每当每个按钮被点击时都会运行<code class="fe lb lc ld le b">click</code>事件处理程序。点击“加载(成功)”按钮将运行<code class="fe lb lc ld le b">get </code>功能。我们将在对<code class="fe lb lc ld le b">get</code>函数的调用中传递一个有效的URL。“加载(成功)”按钮的点击处理由以下模块完成:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="b712" class="mq lg iq le b gy mr ms l mt mu">loadButtonSuccess.addEventListener('click', () =&gt; {<br/>    get('<a class="ae kc" href="https://jsonplaceholder.typicode.com/todos/1'" rel="noopener ugc nofollow" target="_blank">https://jsonplaceholder.typicode.com/todos/1'</a>);<br/>});</span></pre><p id="091c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JSONPlaceholder有一个可以为任何URL服务的测试API，因为它托管了一个假API，所以我们可以加载它而不会得到任何错误。同样，我们有按钮加载一个会给出错误的URL，还有另一个按钮加载一个有效的URL，但是我们中止请求。一旦XmlHttpRequest完成，我们分配给<code class="fe lb lc ld le b">onloadstart</code>事件处理程序的函数，也就是<code class="fe lb lc ld le b">handleLoadStart</code>函数，将会运行。</p><p id="8f86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">handleLoadStart</code>函数有一个参数，它是一个<code class="fe lb lc ld le b">Event</code>对象，包含一些关于已完成请求的数据。在该函数中，我们获得了<code class="fe lb lc ld le b">type</code>属性的值，该属性具有被触发的事件类型，应该是<code class="fe lb lc ld le b">loadstart</code>。此外，我们还获得了属性<code class="fe lb lc ld le b">loaded</code>的值，它包含了已经加载的数据的字节数。它应该总是0，因为当<code class="fe lb lc ld le b">loadstart</code>事件被触发时，还没有加载任何东西。</p><p id="7867" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在HTML代码中，我们添加上面的<code class="fe lb lc ld le b">querySelector</code>调用中列出的元素:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4c3f" class="mq lg iq le b gy mr ms l mt mu">&lt;div class="controls"&gt;<br/>  &lt;input class="load success" type="button" name="xhr" value="Load Start (success)" /&gt;<br/>  &lt;br&gt;<br/>  &lt;input class="load error" type="button" name="xhr" value="Load Start (error)" /&gt;<br/>  &lt;br&gt;<br/>  &lt;input class="load abort" type="button" name="xhr" value="Load Start (abort)" /&gt;<br/>&lt;/div&gt;<br/>&lt;textarea readonly class="event-log"&gt;&lt;/textarea&gt;</span></pre><p id="7b3e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有3个按钮可以点击来加载成功的HTTP请求，一个带有不存在的URL的HTTP请求，和一个中止的HTTP请求。然后我们显示触发的事件和加载的字节数。</p><h1 id="73ef" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">onlostpointercapture</h1><p id="0afc" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">DOM元素的<code class="fe lb lc ld le b">onlostpointercapture</code>属性让我们分配一个事件处理函数来处理<code class="fe lb lc ld le b">lostpointercapture</code>事件。当释放被捕获的指针时，触发<code class="fe lb lc ld le b">lostpointercapture</code>事件。捕获指针意味着特定的指针事件将被重新定向到特定的元素，而不是响应指针事件的普通元素。它用于确保一个元素继续接收指针事件，即使指针设备离开了该元素。</p><p id="1350" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以使用它来记录<code class="fe lb lc ld le b">lostpointercapture</code>事件，就像我们在下面的代码中所做的那样:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="e00a" class="mq lg iq le b gy mr ms l mt mu">const para = document.querySelector('p');</span><span id="ce38" class="mq lg iq le b gy mv ms l mt mu">para.onlostpointercapture = () =&gt; {<br/>  console.log('Pointer been released!')<br/>};</span><span id="81fc" class="mq lg iq le b gy mv ms l mt mu">para.onpointerdown = (event) =&gt; {<br/>  para.setPointerCapture(event.pointerId);<br/>};</span></pre><p id="3d7e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在相应的HTML代码中，我们放入:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="77f7" class="mq lg iq le b gy mr ms l mt mu">&lt;p&gt;Touch and Release&lt;/p&gt;</span></pre><p id="e10c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，当我们单击<code class="fe lb lc ld le b">p</code>元素时，首先触发<code class="fe lb lc ld le b">pointerdown</code>事件，因此我们分配给<code class="fe lb lc ld le b">para</code>对象的<code class="fe lb lc ld le b">onpointerdown</code>属性的事件处理程序运行，该对象是<code class="fe lb lc ld le b">p</code>元素的DOM对象。在事件处理函数中，我们在<code class="fe lb lc ld le b">para</code>对象上运行<code class="fe lb lc ld le b">setPointerCapture</code>方法，该方法将鼠标指针事件指向<code class="fe lb lc ld le b">p</code>元素。</p><p id="6bd1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当鼠标按钮被释放时，被捕获的指针被释放，因此触发了<code class="fe lb lc ld le b">lostpointercapture</code>方法。然后，我们分配给<code class="fe lb lc ld le b">onlostpointercapture</code>事件的事件处理程序运行，记录“指针被释放！”我们添加的消息。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/19d2950cd40ebffa0f676dea80e117ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_AdXXCxA2xJL--JA"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@sweetmangostudios?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ricky Kharawala</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="f7d5" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">onmousedown</h1><p id="3196" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们分配给DOM元素的<code class="fe lb lc ld le b">onmousedown</code>属性的事件处理函数在<code class="fe lb lc ld le b">mousedown</code>事件被触发时运行。当指针在元素内部时按下指点设备按钮，触发<code class="fe lb lc ld le b">mousedown</code>事件。这与<code class="fe lb lc ld le b">click</code>事件不同，因为<code class="fe lb lc ld le b">click</code>是在完全点击动作发生后触发的。这意味着当指针停留在同一元素内时，鼠标按钮既被按下又被释放。最初按下鼠标按钮时触发<code class="fe lb lc ld le b">mousedown</code>。</p><p id="db06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以使用<code class="fe lb lc ld le b">onmousedown</code>事件处理程序来创建一个偷窥效果，当我们点击屏幕的一部分时，图像中被点击的部分就会显示出来。</p><p id="1888" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">首先，我们为图像添加HTML代码，并添加一个黑色的<code class="fe lb lc ld le b">div</code>元素来隐藏图像，如下面的代码所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f3da" class="mq lg iq le b gy mr ms l mt mu">&lt;div class='container'&gt;<br/>  &lt;div class="view" hidden&gt;&lt;/div&gt;<br/>  &lt;img src='<a class="ae kc" href="https://images.unsplash.com/photo-1503066211613-c17ebc9daef0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1500&amp;q=80'" rel="noopener ugc nofollow" target="_blank">https://images.unsplash.com/photo-1503066211613-c17ebc9daef0?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1500&amp;q=80'</a>&gt;</span><span id="fbdb" class="mq lg iq le b gy mv ms l mt mu">&lt;/div&gt;</span></pre><p id="e65f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们为HTML元素添加CSS代码，使<code class="fe lb lc ld le b">.view</code> <code class="fe lb lc ld le b">div</code>元素具有黑色背景:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7424" class="mq lg iq le b gy mr ms l mt mu">.container {<br/>  background: black;<br/>  width: 500px;<br/>}</span><span id="5d40" class="mq lg iq le b gy mv ms l mt mu">.view {<br/>  position: absolute;<br/>  width: 200px;<br/>  height: 200px;<br/>  background: white;<br/>  border-radius: 50%;<br/>}</span><span id="1ccb" class="mq lg iq le b gy mv ms l mt mu">img {<br/>  mix-blend-mode: darken;<br/>  width: 500px;<br/>}</span></pre><p id="1a94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在JavaScript代码中，我们添加了<code class="fe lb lc ld le b">onmousedown</code>事件处理程序，让我们显示鼠标指针点击过的图像部分:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1474" class="mq lg iq le b gy mr ms l mt mu">const img = document.querySelector('img');<br/>const view = document.querySelector('.view');<br/>const container = document.querySelector('.container');</span><span id="204c" class="mq lg iq le b gy mv ms l mt mu">const showView = (event) =&gt; {<br/>  view.removeAttribute('hidden');<br/>  view.style.left = event.clientX - 50 + 'px';<br/>  view.style.top = event.clientY - 50 + 'px';<br/>  event.preventDefault();<br/>}</span><span id="c6ad" class="mq lg iq le b gy mv ms l mt mu">const moveView = (event) =&gt; {<br/>  view.style.left = event.clientX - 50 + 'px';<br/>  view.style.top = event.clientY - 50 + 'px';<br/>}</span><span id="ccb2" class="mq lg iq le b gy mv ms l mt mu">const hideView = (event) =&gt; {<br/>  view.setAttribute('hidden', '');<br/>}</span><span id="2084" class="mq lg iq le b gy mv ms l mt mu">container.onmousedown = showView;<br/>container.onmousemove = moveView;<br/>document.onmouseup = hideView;</span></pre><p id="571c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">.container</code> <code class="fe lb lc ld le b">div</code>元素的<code class="fe lb lc ld le b">onmousedown</code>属性被设置为<code class="fe lb lc ld le b">showView</code>函数，该函数在鼠标按钮按下时运行。在函数内部，我们从<code class="fe lb lc ld le b">.view</code> <code class="fe lb lc ld le b">div</code>元素中移除了<code class="fe lb lc ld le b">hidden</code>属性，以显示<code class="fe lb lc ld le b">div</code>下面的图像。从拥有<code class="fe lb lc ld le b">Event</code>对象的<code class="fe lb lc ld le b">event</code>参数中，我们获得了<code class="fe lb lc ld le b">clientX</code>和<code class="fe lb lc ld le b">clientY</code>属性，它们拥有点击位置的鼠标坐标。我们将其设置为代表<code class="fe lb lc ld le b">.view</code>元素的<code class="fe lb lc ld le b">view</code> DOM对象的位置。然后我们调用<code class="fe lb lc ld le b">event.preventDefault()</code>来停止默认动作，因为我们已经用它之前的代码进行了揭示。</p><p id="dfdd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">onmousemove</code>事件处理程序被设置为<code class="fe lb lc ld le b">moveView</code>函数，该函数处理<code class="fe lb lc ld le b">mousemove</code>事件。当鼠标移动时触发该事件。在函数中，我们将<code class="fe lb lc ld le b">.view</code>元素设置为鼠标指针当前所在的位置，同样使用<code class="fe lb lc ld le b">event</code>参数的<code class="fe lb lc ld le b">clientX</code>和<code class="fe lb lc ld le b">clientY</code>属性，该参数是<code class="fe lb lc ld le b">MouseEvent</code>对象。</p><p id="5c7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当鼠标按钮被释放时，<code class="fe lb lc ld le b">mouseup</code> is事件被触发，我们分配给<code class="fe lb lc ld le b">document</code>对象的<code class="fe lb lc ld le b">onmouseup</code>属性的<code class="fe lb lc ld le b">hideView</code>函数被调用。我们设置了<code class="fe lb lc ld le b">.view</code>元素的<code class="fe lb lc ld le b">hidden</code>属性来隐藏<code class="fe lb lc ld le b">.view</code>元素。</p><p id="ed2a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">onloadstart</code>属性是XmlHttpRequest对象的一部分。它允许我们给它分配一个事件处理函数来处理数据刚开始加载时触发的<code class="fe lb lc ld le b">loadstart</code>事件。</p><p id="775b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">DOM元素的<code class="fe lb lc ld le b">onlostpointercapture</code>属性让我们分配一个事件处理函数来处理<code class="fe lb lc ld le b">lostpointercapture</code>事件。当释放被捕获的指针时，触发<code class="fe lb lc ld le b">lostpointercapture</code>事件。</p><p id="a8f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们分配给DOM元素的<code class="fe lb lc ld le b">onmousedown</code>属性的事件处理函数在<code class="fe lb lc ld le b">mousedown</code>事件被触发时运行。当指针在元素内部时按下指点设备按钮，触发<code class="fe lb lc ld le b">mousedown</code>事件。这与<code class="fe lb lc ld le b">click</code>事件不同，因为<code class="fe lb lc ld le b">click</code>是在完全点击动作发生后触发的。这意味着当指针停留在同一元素内时，鼠标按钮既被按下又被释放。最初按下鼠标按钮时触发<code class="fe lb lc ld le b">mousedown</code>。</p></div></div>    
</body>
</html>