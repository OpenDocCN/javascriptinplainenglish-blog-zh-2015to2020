<html>
<head>
<title>Best of Modern JavaScript — Property Keys and Comparisons</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">现代JavaScript精华—属性键和比较</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/best-of-modern-javascript-property-keys-and-comparisons-d5b6634d273a?source=collection_archive---------10-----------------------#2020-10-16">https://javascript.plainenglish.io/best-of-modern-javascript-property-keys-and-comparisons-d5b6634d273a?source=collection_archive---------10-----------------------#2020-10-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/d6b09849ec8b84050472bf32dbcadca3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qu2iPAj2-xc69EcB"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@freetousesoundscom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Free To Use Sounds</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="80f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">自2015年以来，JavaScript有了巨大的进步。</p><p id="c894" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在用起来比以前舒服多了。</p><p id="193a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究JavaScript中新的OOP特性。</p><h1 id="bf86" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用<code class="fe lz ma mb mc b">Object.is()</code>查找数组元素</h1><p id="a2a7" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用<code class="fe lz ma mb mc b">Object.is</code>来寻找数组元素。</p><p id="f4b4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有助于在我阵中找到<code class="fe lz ma mb mc b">NaN</code>。</p><p id="4574" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="a5fe" class="mq lc iq mc b gy mr ms l mt mu">const arr = [0, NaN, 2];<br/>const index = arr.findIndex(x =&gt; Object.is(x, NaN));</span></pre><p id="b7e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用<code class="fe lz ma mb mc b">findIndex</code>方法找到<code class="fe lz ma mb mc b">NaN</code>的指数。</p><p id="ae3b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用<code class="fe lz ma mb mc b">findIndex</code>回调函数返回<code class="fe lz ma mb mc b">Object.is</code>的结果。</p><h1 id="1ac2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">Object.setPrototypeOf(obj, proto)</code></h1><p id="6542" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">Object.setPrototyeOf</code>方法让我们将对象的原型设置为我们想要的对象。</p><p id="59a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5ed1" class="mq lc iq mc b gy mr ms l mt mu">const proto = {<br/>  foo: 'bar'<br/>}<br/>const obj = {<br/>  baz: 'qux'<br/>};<br/>Object.setPrototypeOf(obj, proto);</span></pre><p id="ad31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用了<code class="fe lz ma mb mc b">Object.setPrototype</code>，将我们想要设置原型的对象作为第一个参数。</p><p id="0d3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是我们想要为<code class="fe lz ma mb mc b">obj</code>设置的原型。</p><p id="1a95" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，当我们记录<code class="fe lz ma mb mc b">__proto__</code>属性时:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5e56" class="mq lc iq mc b gy mr ms l mt mu">console.log(obj.__proto__)</span></pre><p id="3ea2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到了<code class="fe lz ma mb mc b">proto</code>物体。</p><h1 id="45d4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">ES6中的遍历属性</h1><p id="a94a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">有几种方法可以用ES6遍历对象。</p><p id="b734" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有几种方法可以做到这一点。</p><p id="3cd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Object.keys</code>方法接受一个对象并返回一个可枚举的字符串键数组。</p><p id="a21a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Object.getOwnPropertyNames</code>方法接受一个对象并返回一个对象所有自己的字符串键的数组。</p><p id="d845" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Object.getOwnPropertySymbols</code>方法接受一个对象并返回一个符号自身键的数组。</p><p id="8afc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">Reflect.ownKeys</code>是一个方法，它接受一个对象并返回一个包含所有字符串和符号自身键的数组。</p><p id="19cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">for-in循环在ES6之前是可用的，它让我们遍历对象拥有的和继承的键。</p><h1 id="bb0b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">属性的遍历顺序</h1><p id="e50c" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">对于自己的属性键和可枚举的自己的名称，属性的移动顺序是分开的。</p><p id="719b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">own属性键检索对象中所有own属性的键。</p><p id="bc48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">字符串kets是整数，按数字升序遍历。</p><p id="1b7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后遍历其他字符串键。</p><p id="baa2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，遍历符号键。</p><p id="ea38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是由<code class="fe lz ma mb mc b">Object.assign()</code>、<code class="fe lz ma mb mc b">Object.defineProperties()</code>、<code class="fe lz ma mb mc b">Object.getOwnPropertyNames()</code>、<code class="fe lz ma mb mc b">Object.getOwnPropertySymbols()</code>、<code class="fe lz ma mb mc b">Reflect.ownKeys()</code>方法使用的。</p><p id="7441" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可枚举所有者名称是从对象的所有可枚举所有者属性的字符串关键字中检索的。</p><p id="36bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">ES6没有定义它，但是它与for-in循环遍历属性的顺序相同。</p><p id="801b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种方式被<code class="fe lz ma mb mc b">JSON.parse()</code>、<code class="fe lz ma mb mc b">JSON.stringify()</code>、<code class="fe lz ma mb mc b">Object.keys()</code>方法所采用。</p><h1 id="0144" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">整数索引</h1><p id="d05e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">数组元素有整数索引，但它们被视为普通的字符串属性键。</p><p id="3c94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="65d3" class="mq lc iq mc b gy mr ms l mt mu">const arr = ['a', 'b', 'c'];</span></pre><p id="e038" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="7584" class="mq lc iq mc b gy mr ms l mt mu">console.log(arr['0'])</span></pre><p id="6c3d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">日志<code class="fe lz ma mb mc b">'a'</code>。</p><p id="5e44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">整数索引是特殊的，因为它们影响数组的<code class="fe lz ma mb mc b">length</code>，并且在遍历属性键时排在第一位。</p><p id="f823" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何以<code class="fe lz ma mb mc b">‘0’</code>开头的都不是整数索引。</p><h1 id="3883" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">分配与定义属性</h1><p id="52d9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">向对象添加属性有两种方式。</p><p id="e5f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一种方法是分配它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="033b" class="mq lc iq mc b gy mr ms l mt mu">obj.prop = 'foo';</span></pre><p id="7029" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一种方法是用<code class="fe lz ma mb mc b">Object.defineProperty</code>方法定义它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="7603" class="mq lc iq mc b gy mr ms l mt mu">Object.defineProperty(obj, 'prop', { value: 'foo' });</span></pre><p id="bc43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第一个参数是要添加属性的对象。</p><p id="bb13" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个是属性名。</p><p id="84e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第三个包含属性描述符，其中包含值。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/de21f1567586560f83bca1ef1e5b210e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*l0QxUG6P9OffoD8N"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@chiklad?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ochir-Erdene Oyunmedeg</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="1a6d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="1fb4" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以使用<code class="fe lz ma mb mc b">Object</code>方法来获取键并比较值和对象。</p><p id="5bac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一种遍历属性的固定方式。</p><p id="843c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">向对象添加属性的方法不止一种。</p><p id="2799" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>