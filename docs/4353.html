<html>
<head>
<title>How to Create a Modal in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在React中创建模态</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-create-a-modal-in-react-14b1cb84cf09?source=collection_archive---------6-----------------------#2020-12-05">https://javascript.plainenglish.io/how-to-create-a-modal-in-react-14b1cb84cf09?source=collection_archive---------6-----------------------#2020-12-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="84fe" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">React中创建风格不可知模型的快速、实用指南。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/ff304224560a20451091818b143ad159.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*15_P2qDJjZFP7QY4"/></div></div></figure><p id="771e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">模态是一个弹出框，它的出现是为了响应用户的一些操作。模态通常比阻止其他事件发生的动作更受欢迎，比如<code class="fe ln lo lp lq b">window.confirm</code>和<code class="fe ln lo lp lq b">window.alert</code>。</p><p id="b4a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">幸运的是，在React中创建模态很容易。在本文中，我们将为React组件创建一个简单的、基本的模型。不需要特定的CSS框架，因此读者可以采用这种方式创建模态，并以他们想要的任何方式使用它。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="1249" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">创建示例应用程序</h1><p id="ca55" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">在命令行上，运行<code class="fe ln lo lp lq b">npx create-react-app modal</code>。<code class="fe ln lo lp lq b">modal</code>是由<code class="fe ln lo lp lq b">create-react-app</code>创建的目录。</p><p id="d507" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一旦命令完成，<code class="fe ln lo lp lq b">cd</code>进入<code class="fe ln lo lp lq b">modal</code>。</p><p id="a072" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">接下来，在文本编辑器中打开整个<code class="fe ln lo lp lq b">modal</code>目录。</p><p id="bbe4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">最后，从根目录<code class="fe ln lo lp lq b">modal</code>运行<code class="fe ln lo lp lq b">yarn start</code>。我们准备好做模型了。</p><h1 id="6010" class="ly lz iq bd ma mb mv md me mf mw mh mi jw mx jx mk jz my ka mm kc mz kd mo mp bi translated">最低款式</h1><p id="c23a" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">在<code class="fe ln lo lp lq b">src</code>中，打开<code class="fe ln lo lp lq b">App.css</code>。在此，将以下样式<strong class="kt ir">粘贴到文件</strong>中包含的样式下面:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="6183" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><code class="fe ln lo lp lq b">.modal-background</code>是该文件中需要注意的重要类。这个类中使用的属性和值将在模态之后创建背景<strong class="kt ir">，阻止用户与模态</strong>之外的任何事物<strong class="kt ir">交互。</strong></p><blockquote class="nc nd ne"><p id="ebfd" class="kr ks nf kt b ku kv jr kw kx ky ju kz ng lb lc ld nh lf lg lh ni lj lk ll lm ij bi translated">注意:这款modal会<strong class="kt ir">不好看</strong>。由读者来决定组件的样式。</p></blockquote><h1 id="1111" class="ly lz iq bd ma mb mv md me mf mw mh mi jw mx jx mk jz my ka mm kc mz kd mo mp bi translated">创建模型</h1><p id="8b27" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">打开<code class="fe ln lo lp lq b">App.js</code>。用一个<code class="fe ln lo lp lq b">const</code>声明替换<code class="fe ln lo lp lq b">function App</code>，并对其进行适当的修改，使其作为一个React组件工作，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b475" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">为了创建一个模态，我们需要一些<strong class="kt ir">状态</strong>来告诉我们是否<strong class="kt ir">显示模态</strong>。让我们从<code class="fe ln lo lp lq b">react</code>导入<code class="fe ln lo lp lq b">useState</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e7fd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，让我们使用一个<strong class="kt ir">钩子</strong>来存储一些关于<strong class="kt ir">显示</strong>模态的状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d598" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们给了函数调用<code class="fe ln lo lp lq b">useState</code>一个参数<code class="fe ln lo lp lq b">false</code>，因为通常我们不希望页面在用户没有做一些动作的情况下显示一个模态。当我们用参数<code class="fe ln lo lp lq b">true</code>调用<code class="fe ln lo lp lq b">setShow</code>时，我们告诉React to <strong class="kt ir"> show </strong>模态。有了<code class="fe ln lo lp lq b">false</code>，我们就有了<strong class="kt ir">隐藏</strong>的情态。</p><p id="3f2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们也创建一些事件处理函数来处理设置<strong class="kt ir">显示</strong>的状态:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="7e71" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">读者应该注意到我们将参数<code class="fe ln lo lp lq b">e</code>、<code class="fe ln lo lp lq b">event</code>传递给了<code class="fe ln lo lp lq b">handleModalClose</code>。这有一个很好的理由，将在本文后面解释。</p><p id="319f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们需要创建这些处理函数来避免组件的无限重渲染。当组件挂载时，如果组件上有某种事件处理程序，并且它是一个钩子，它将无限次调用该函数，并进入一个重新渲染组件的<a class="ae nj" href="https://community.airtable.com/t/too-many-re-renders/31671" rel="noopener ugc nofollow" target="_blank">无限循环</a>。</p><p id="647e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">让我们创建一个保存<strong class="kt ir">模态</strong>的<code class="fe ln lo lp lq b">div</code>，并创建一个可以点击打开模态的<code class="fe ln lo lp lq b">button</code>。向<code class="fe ln lo lp lq b">button</code>和<code class="fe ln lo lp lq b">div</code>传递适当的事件处理程序:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="dc14" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">太好了！我们现在可以点击<code class="fe ln lo lp lq b">button</code>并实际打开模态。当点击<code class="fe ln lo lp lq b">button</code>时，它应该是这样的:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nk"><img src="../Images/805e75e816088a035861dc7c94e47ee9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AEhrkaPIMQp6HhilVWbADw.png"/></div></div><figcaption class="nl nm gj gh gi nn no bd b be z dk">I am ugly and I am proud!</figcaption></figure><p id="ecf5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">单击深灰色背景应该会创建以下视图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi np"><img src="../Images/e4efe28ba012fbd654965eda80626597.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PrnbL8VB2CvVjnF6Tl0WFg.png"/></div></div></figure><p id="8a2e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">然而，目前的实现存在一个主要问题。当我们点击<code class="fe ln lo lp lq b">modal-card</code> <code class="fe ln lo lp lq b">div</code>时，它也会关闭模态。我们不希望发生这种情况，因为我们只想在单击背景时关闭模态，而不是模态的实际内容。</p><p id="fc65" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这是因为<code class="fe ln lo lp lq b">modal-card</code> <code class="fe ln lo lp lq b">div</code>是<code class="fe ln lo lp lq b">modal-background</code> <code class="fe ln lo lp lq b">div</code>的子节点。任何对<code class="fe ln lo lp lq b">modal-card</code>的点击都会导致对<code class="fe ln lo lp lq b">modal-background</code>的点击。</p><p id="92a8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">因此，我们需要更新<code class="fe ln lo lp lq b">handleModalClose</code>来检查触发事件的<code class="fe ln lo lp lq b">className</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ad7f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通过检查<code class="fe ln lo lp lq b">className</code>，我们确保只有当被触发的事件是<code class="fe ln lo lp lq b">modal-background</code> <code class="fe ln lo lp lq b">div</code>，而不是<code class="fe ln lo lp lq b">modal-card</code>子事件<code class="fe ln lo lp lq b">div</code>时，模态才被关闭。</p><p id="f655" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">就这样，我们有了一个全功能的模型！</p><h1 id="0fca" class="ly lz iq bd ma mb mv md me mf mw mh mi jw mx jx mk jz my ka mm kc mz kd mo mp bi translated">后续步骤</h1><p id="b0cd" class="pw-post-body-paragraph kr ks iq kt b ku mq jr kw kx mr ju kz la ms lc ld le mt lg lh li mu lk ll lm ij bi translated">对于希望将他们的<strong class="kt ir">模态</strong>游戏提升到下一个级别的读者，我建议将模态提取到它自己的的<strong class="kt ir">组件中，该组件可以用作任何<strong class="kt ir">组件</strong>的子组件。这将包括将<strong class="kt ir"> props </strong>从父组件传递到模态子组件。</strong></p><p id="10f8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如果读者很容易理解这一点，可以在模态中添加某种类型的<strong class="kt ir">加载通知</strong>。这增加了相当多的复杂性，尤其是在加载通知是动画的情况下。</p><p id="18f6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">感谢您花时间阅读本文。编码快乐！如果你觉得这很有用，可以通过<a class="ae nj" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir">订阅我们的YouTube频道</strong> </a> <strong class="kt ir">获取更多类似的内容！</strong></p></div></div>    
</body>
</html>