<html>
<head>
<title>Manipulating AST with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript操作AST</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/manipulating-ast-with-javascript-baac3b92f1ed?source=collection_archive---------2-----------------------#2020-01-12">https://javascript.plainenglish.io/manipulating-ast-with-javascript-baac3b92f1ed?source=collection_archive---------2-----------------------#2020-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="863c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">之前，我已经谈到了如何编写巴别塔转换(T1)，我更深入地探讨了T2巴别塔(T3)，通过T4展示如何创建定制的JavaScript语法(T5)，我展示了巴别塔如何将你的代码解析成AST，转换它并生成代码。</p><figure class="kn ko kp kq gt kr gh gi paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="gh gi km"><img src="../Images/c05ba58a78c41a16c0e3b8922811b70e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sf9ucs4SgonwO9dw.png"/></div></div></figure><p id="066c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了用Babel运行JavaScript AST的知识和经验，让我们看看如何将这些知识推广到其他语言中。</p><blockquote class="ky kz la"><p id="ca02" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated"><em class="iq">当我提到“其他语言”时，我实际上指的是流行的前端语言，例如:</em><a class="ae kl" href="https://www.ecma-international.org/publications/standards/Ecma-262.htm" rel="noopener ugc nofollow" target="_blank"><em class="iq">JavaScript</em></a><em class="iq">，</em><a class="ae kl" href="http://typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"><em class="iq">TypeScript</em></a><em class="iq">，</em><a class="ae kl" href="https://sass-lang.com/" rel="noopener ugc nofollow" target="_blank"><em class="iq">Sass</em></a><em class="iq">，</em><a class="ae kl" href="https://www.w3.org/Style/CSS/" rel="noopener ugc nofollow" target="_blank"><em class="iq">CSS</em></a><em class="iq">，</em> <a class="ae kl" href="https://www.w3.org/html/" rel="noopener ugc nofollow" target="_blank"> <em class="iq"/></a></p><p id="56c7" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated"><em class="iq">当然，不仅限于前端语言。只是用JavaScript写的这些语言比其他语言，比如C++或者Java，更容易找到解析器。</em></p></blockquote><h1 id="6548" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">解析器</h1><p id="6186" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">就像我们如何使用Babel来解析和生成JavaScript一样，还有其他库可以帮助我们解析和生成我们的语言。</p><p id="76bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">找到这些库的一个简单方法是通过https://astexplorer.net/。</p><p id="ee0e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">选择一种语言后，您会看到一个解析器列表，您可以用它来解析您的语言。例如，如果您选择<strong class="jp ir"> HTML </strong>，有<a class="ae kl" href="https://github.com/fb55/htmlparser2" rel="noopener ugc nofollow" target="_blank"> htmlparser2 </a>，<a class="ae kl" href="https://github.com/nik-garmash/hyntax" rel="noopener ugc nofollow" target="_blank"> hyntax </a>，<a class="ae kl" href="https://github.com/inikulin/parse5" rel="noopener ugc nofollow" target="_blank"> parse5 </a> …当您选择其中一个解析器时，您可以立即在右侧面板上看到AST的样子，而Github链接到右上角的解析器。</p><p id="b9c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个不完整的解析器列表，它是<code class="fe mi mj mk ml b">parse</code>和<code class="fe mi mj mk ml b">generate</code>方法:</p><ul class=""><li id="c442" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">HTML(解析:<a class="ae kl" href="https://github.com/inikulin/parse5/tree/master/packages/parse5" rel="noopener ugc nofollow" target="_blank">解析5 </a>，解析:<code class="fe mi mj mk ml b"><a class="ae kl" href="https://github.com/inikulin/parse5/blob/master/packages/parse5/docs/index.md#parse" rel="noopener ugc nofollow" target="_blank">parse5.parse(str)</a></code>，生成:<a class="ae kl" href="https://github.com/inikulin/parse5/blob/master/packages/parse5/docs/index.md#serialize" rel="noopener ugc nofollow" target="_blank"> </a> <code class="fe mi mj mk ml b"><a class="ae kl" href="https://github.com/inikulin/parse5/blob/master/packages/parse5/docs/index.md#serialize" rel="noopener ugc nofollow" target="_blank">parse5.serialize(ast)</a></code>)</li><li id="d3b9" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">Markdown(解析:<a class="ae kl" href="https://github.com/remarkjs/remark" rel="noopener ugc nofollow" target="_blank">备注</a>，解析:<code class="fe mi mj mk ml b"><a class="ae kl" href="https://github.com/remarkjs/remark/tree/master/packages/remark-parse" rel="noopener ugc nofollow" target="_blank">unified().use(remarkParse)</a></code>，生成:<code class="fe mi mj mk ml b"><a class="ae kl" href="https://github.com/remarkjs/remark/tree/master/packages/remark-stringify" rel="noopener ugc nofollow" target="_blank">unified().use(remarkStringify)</a></code>)</li><li id="990c" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">CSS(解析器:<a class="ae kl" href="https://github.com/csstree/csstree" rel="noopener ugc nofollow" target="_blank"> css树</a>，解析:<code class="fe mi mj mk ml b"><a class="ae kl" href="https://github.com/csstree/csstree/blob/master/docs/parsing.md" rel="noopener ugc nofollow" target="_blank">csstree.parse(str)</a></code>，生成:<code class="fe mi mj mk ml b"><a class="ae kl" href="https://github.com/csstree/csstree/blob/master/docs/generate.md" rel="noopener ugc nofollow" target="_blank">csstree.generate(ast)</a></code>)</li><li id="3a7e" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">JavaScript(解析器:<a class="ae kl" href="https://babeljs.io" rel="noopener ugc nofollow" target="_blank">巴别塔</a>、解析:<code class="fe mi mj mk ml b"><a class="ae kl" href="https://babeljs.io/docs/en/babel-parser#babelparserparsecode-options" rel="noopener ugc nofollow" target="_blank">babel.parse(str)</a></code>、生成:<code class="fe mi mj mk ml b"><a class="ae kl" href="https://babeljs.io/docs/en/babel-generator" rel="noopener ugc nofollow" target="_blank">babel.generate(ast)</a></code>)</li></ul><p id="c5d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如您所看到的，大多数解析器同时提供解析和生成方法。</p><p id="27dc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，一般来说，您可以使用以下内容作为模板来编写代码转换代码:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="37a3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，您可以将一种语言的AST转换成另一种语言的AST，例如:Sass ➡️ CSS，标记➡️ HTML，并使用另一种语言的生成器来生成代码。</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="2a03" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在有了这个模板，让我们来谈谈更神奇的<em class="lb"/>东西，即<em class="lb">变换函数</em>。</p><h1 id="b4eb" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">遍历AST</h1><p id="9453" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">顾名思义，AST采用树形数据结构。为了磨练操纵AST的技能，我们需要回忆起我们对<em class="lb">【算法101】</em><strong class="jp ir">深度优先搜索(DFS) </strong>树遍历算法的远距离记忆。</p><p id="55fd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://twitter.com/vaidehijoshi" rel="noopener ugc nofollow" target="_blank">vaide hai Joshi</a>在<a class="ae kl" href="https://medium.com/basecs/demystifying-depth-first-search-a7c14cccf056" rel="noopener">上写了一篇令人惊叹的文章，揭开了深度优先搜索</a>的神秘面纱，我想我没有更好的解释了，所以如果你想回顾一下深度优先搜索，请在我们继续之前去阅读<a class="ae kl" href="https://medium.com/basecs/demystifying-depth-first-search-a7c14cccf056" rel="noopener">她的文章</a>。</p><p id="dd6a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在您对深度优先搜索的工作原理有了更清楚的了解，AST上的深度优先搜索应该是这样的:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="cc36" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们可以用我们的操纵代码填充<code class="fe mi mj mk ml b">TODO</code>。</p><p id="b48a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果我们发现自己需要用不同的AST操作进行多次遍历，我们会很快意识到将AST操作代码和遍历代码混合在一起是<em class="lb">不够干净的</em>。当然，您会意识到<em class="lb">传递一个回调函数会更干净</em>，这个函数在我们每次访问一个节点时都会被调用:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8145" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe mi mj mk ml b">visit</code>功能现在足够通用，您可以将其用于任何AST:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="86e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，您会认为在回调函数中拥有父节点的信息和当前节点的键/索引会很有用:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="56ec" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，我们可能会想，我不想为每个被访问的节点得到回调，我只需要为某个节点回调。您可能会想在<code class="fe mi mj mk ml b">visit</code>函数中添加一个条件:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9b1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是你要三思:<em class="lb">如果别人想用</em> <code class="fe mi mj mk ml b"><em class="lb">visit</em></code> <em class="lb">但是用不同的条件进行回调怎么办？</em></p><p id="9866" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">大多数情况下，您只希望回调到特定类型的节点。在这种情况下，您可以将节点类型的映射传入各自的回调函数，而不是传入回调函数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="dd25" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这一点上，你可能意识到，<em class="lb">嘿，这看起来很像AST遍历库！</em>是的，这就是它们的实现方式。</p><p id="5e9a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们可以遍历AST，找到我们感兴趣的节点，所以下一步是操作它们。</p><p id="48f7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">操纵AST可以分为3种不同的操作:</p><ul class=""><li id="00bf" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">添加节点</li><li id="d9b5" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">替换节点</li><li id="fc4f" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">删除节点</li></ul><h1 id="4f46" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">添加节点</h1><p id="ecba" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">要添加节点，可以将其分配给节点的键控属性:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ba86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">或者如果键控属性是数组，则推送新节点:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b2bb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要将节点添加为同级节点，您可能需要访问该节点的父节点:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="abba" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">替换节点</h1><p id="dab0" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">要将当前节点替换为另一个节点，请更新当前节点的父节点的key属性:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="27f4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果父项的键属性是数组:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="9e69" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">删除节点</h1><p id="f928" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">要删除当前节点，请删除当前节点的父节点的key属性:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9993" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果父项的键属性是数组:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><blockquote class="ky kz la"><p id="0e2e" class="jn jo lb jp b jq jr js jt ju jv jw jx lc jz ka kb ld kd ke kf le kh ki kj kk ij bi translated"><em class="iq"/><strong class="jp ir"><em class="iq">添加</em> </strong> <em class="iq">、</em> <strong class="jp ir"> <em class="iq">替换</em> </strong> <em class="iq">、</em> <strong class="jp ir"> <em class="iq">删除</em> </strong> <em class="iq">节点的操作非常常见，通常作为一个实用函数来实现。</em></p></blockquote><p id="2736" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然而，有一个重要的步骤<strong class="jp ir">我没有提到:在你改变节点之后，你需要确保遍历仍然正常工作。</strong></p><p id="a5da" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于作为其父节点的键的属性的节点，添加、替换和删除它们通常是可以的。除了替换操作，您可能需要重新访问<em class="lb">“当前节点”</em>，这是<em class="lb">新的替换节点</em>。</p><p id="25fe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，对于数组中的节点，需要特别注意更新循环的数组索引:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="38ee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是你怎么知道当前节点被删除了呢？</p><p id="609b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，知道一个节点何时被删除有时是一个秘密，它存在于树遍历库中的<code class="fe mi mj mk ml b">remove</code> util函数中。</p><p id="cb42" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当你打电话给<code class="fe mi mj mk ml b">remove</code>的时候，它可以像设置一面旗帜一样简单:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="a64d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是有时，不需要从树遍历库中导入<code class="fe mi mj mk ml b">remove</code> util，<code class="fe mi mj mk ml b">remove</code>函数在<code class="fe mi mj mk ml b">visitCallback</code>的<code class="fe mi mj mk ml b">this</code>中可用:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="f397" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你已经学习了操纵AST的3个基本操作，你可能想知道如何使用这些基本操作来编写一个codemod或AST转换插件？</p><p id="a608" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">嗯，在我的<a class="ae kl" href="https://lihautan.com/step-by-step-guide-for-writing-a-babel-transformation" rel="noopener ugc nofollow" target="_blank">分步指南</a>中，我已经解释过，你可以使用像<a class="ae kl" href="http://astexplorer.net/" rel="noopener ugc nofollow" target="_blank">http://astexplorer.net/</a>或<a class="ae kl" href="https://lihautan.com/babel-ast-explorer" rel="noopener ugc nofollow" target="_blank">巴别AST浏览器</a>这样的AST浏览器来帮助你。</p><p id="5651" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要:</p><ul class=""><li id="fc3f" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated"><strong class="jp ir">了解您想要更改的代码部分在AST中的样子</strong>，这样您就可以针对特定类型的节点，并且</li><li id="2efb" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><strong class="jp ir">知道您希望在AST </strong>中看到的最终输出是什么样子，这样您就知道要创建、更新或删除哪些节点。</li></ul><p id="7974" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因此，我们将详细阐述这两个步骤。</p><h1 id="f499" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">瞄准一个节点</h1><p id="c364" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">节点定位，大多数时候，只是一大堆<code class="fe mi mj mk ml b">===</code>。</p><p id="bf2c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">例如，如果您想要将一个包含一个<code class="fe mi mj mk ml b">&lt;img&gt;</code>和一个<a class="ae kl" href="https://github.com/fb55/htmlparser2" rel="noopener ugc nofollow" target="_blank"> htmlparser2 </a>中的<code class="fe mi mj mk ml b">&lt;figcaption&gt;</code>的类<code class="fe mi mj mk ml b">foo</code>作为目标:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="41c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">您需要检查:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5d1f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了使它不那么冗长，我们可以将每个检查重构为可重用的函数:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><h1 id="6c74" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">创建节点</h1><p id="97cb" class="pw-post-body-paragraph jn jo iq jp b jq md js jt ju me jw jx jy mf ka kb kc mg ke kf kg mh ki kj kk ij bi translated">有几种方法可以创建AST节点。</p><p id="a2fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最简单粗暴的方法是<strong class="jp ir">手动创建节点对象</strong>。大多数时候，节点对象是一个JavaScript对象。所以您可以手动创建它们:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="282d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当创建大型复杂的AST节点时，它可能会变得笨拙，所以有时库决定提供构建器函数，如<a class="ae kl" href="https://babeljs.io/docs/en/babel-types" rel="noopener ugc nofollow" target="_blank"> @babel/types </a>来简化节点创建并提供默认值:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="af78" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">它看起来更加简洁和整洁，但很难理解和掌握它是在创建什么节点。</p><p id="07b0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">所以，创建复杂AST节点的更好方法，是使用<code class="fe mi mj mk ml b">parse</code>函数+ <code class="fe mi mj mk ml b">string</code>:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d19f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于Babel，有一个神奇的util叫做<a class="ae kl" href="https://babeljs.io/docs/en/babel-template" rel="noopener ugc nofollow" target="_blank"> @babel/template </a>，在这里您可以使用<a class="ae kl" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank">模板文字</a>来创建AST节点:</p><figure class="kn ko kp kq gt kr"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e7d2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经经历了:</p><ul class=""><li id="de59" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated">如何使用深度优先搜索算法遍历AST，</li><li id="86ec" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">3个基本的AST操作，添加、替换和删除，</li><li id="c8ea" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">如何在AST中定位一个节点，以及</li><li id="b06c" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated">如何创建AST节点</li></ul><p id="0e06" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kl" href="https://twitter.com/flexdinesh" rel="noopener ugc nofollow" target="_blank"> Dinesh (@flexdinesh) </a> <a class="ae kl" href="https://twitter.com/flexdinesh/status/1196680010343432192" rel="noopener ugc nofollow" target="_blank">发推文</a>他口袋里收藏的AST资源:</p><ul class=""><li id="cdfd" class="mm mn iq jp b jq jr ju jv jy mo kc mp kg mq kk mr ms mt mu bi translated"><a class="ae kl" href="https://frontendmasters.com/courses/linting-asts/" rel="noopener ugc nofollow" target="_blank">代码转换和带有ASTs的林挺</a></li><li id="9228" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><a class="ae kl" href="https://kentcdodds.com/blog/write-your-own-code-transform/" rel="noopener ugc nofollow" target="_blank">编写你自己的代码转换以获得乐趣和利润</a></li><li id="a05d" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><a class="ae kl" href="https://www.sitepoint.com/understanding-asts-building-babel-plugin/" rel="noopener ugc nofollow" target="_blank">通过构建自己的Babel插件来理解ASTs</a></li><li id="253b" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><a class="ae kl" href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/en/plugin-handbook.md#toc-writing-your-first-babel-plugin" rel="noopener ugc nofollow" target="_blank">编写你的第一个巴别塔插件</a></li><li id="8313" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><a class="ae kl" href="https://medium.com/the-guild/this-is-how-i-build-babel-plug-ins-b0a13dcd0352" rel="noopener">这就是我如何构建巴别塔插件</a></li><li id="9385" class="mm mn iq jp b jq mv ju mw jy mx kc my kg mz kk mr ms mt mu bi translated"><a class="ae kl" href="https://varunzxzx.github.io/blog/writing-babel-plugin" rel="noopener ugc nofollow" target="_blank">编写我的第一个巴别塔插件</a></li></ul><p id="971b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir"> <em class="lb">原载于</em></strong><a class="ae kl" href="https://lihautan.com/manipulating-ast-with-javascript/" rel="noopener ugc nofollow" target="_blank">【https://lihautan.com/】T21</a></p></div></div>    
</body>
</html>