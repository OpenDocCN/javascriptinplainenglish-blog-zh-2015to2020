<html>
<head>
<title>Hash Tables Explained and Implemented in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript解释和实现哈希表</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/hash-tables-explained-and-implemented-in-javascript-9f173a0cd76b?source=collection_archive---------10-----------------------#2020-12-10">https://javascript.plainenglish.io/hash-tables-explained-and-implemented-in-javascript-9f173a0cd76b?source=collection_archive---------10-----------------------#2020-12-10</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="cb1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">编码面试最常用的概念之一，哈希表。许多现代编程语言都有内置的哈希表，这使得使用起来非常简单；例如在Python中，它是Python字典，在JavaScript中，它是JavaScript对象。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/da5f79a792aee3b1cdf462203bad505f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0H8a7bItjRiK_sHJ5P6wfw.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Photo by <a class="ae ky" href="https://www.pexels.com/@tomfisk?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Tom Fisk</a> from <a class="ae ky" href="https://www.pexels.com/photo/aerial-photography-of-container-van-lot-3063470/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><h2 id="c871" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">什么是哈希表？</h2><p id="551b" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">哈希表是一种数据结构，它允许我们存储成对的键和值，其中每个键都映射到一个值。在哈希表中，给定一个键就可以访问一个值。这些是非常强大和常见的数据结构，它经常在实践和编码面试中使用。</p><p id="32c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从根本上说，散列表是相当复杂的，但是为了编写面试代码，我们可以只关注简单的概念。</p><p id="f237" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们看一个例子，</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="7954" class="kz la in ly b gy mc md l me mf">"act" =&gt; 1  <br/>"sun" =&gt; 2            <br/>"fly" =&gt; 3</span></pre><p id="458f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里，键“foo”、“bar”、“baz”映射到值1、2和3。给定键“foo ”,我可以访问值1，但是我们不能使用键“foo”来查找值1。</p><p id="7857" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哈希表中键值对的插入、搜索和删除平均都在常数时间O(1)内运行。</p><p id="cab6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们使用一个散列函数<em class="mg">将一个键变成一个索引</em>以适合一个数组。当您搜索一个给定键的值时，您将使用这个散列函数将该键转换成一个索引，它映射到。如果你找到了索引，你就可以获取数组中的值，这就是常数时间索引。</p><h2 id="204f" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated"><strong class="ak">将字符串转换成索引</strong></h2><p id="9791" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">要将字符串转换成索引，我们可以将字符串中的每个元素映射到它的ASCII字符编码。每个元素有一个整数，计算所有整数的和来得到数字。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="5460" class="kz la in ly b gy mc md l me mf">                      ASCII         ASCII % length of the array - 1<br/>"key1" =&gt; 1            134           139 % 3 = 1(1 is the reminder)<br/>"key2" =&gt; 2            353           353 % 3 = 2<br/>"key3" =&gt; 3            639           639 % 3 = 0</span><span id="5439" class="kz la in ly b gy mh md l me mf">indecies   0  1  2<br/>let arr = [3, 1, 2]</span></pre><p id="1a2d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我们将字符串<code class="fe mi mj mk ly b">'key1'</code>中的每个字符映射到它的ASCII编码值，将所有整数相加得到134。接下来，我们将使用模操作符<code class="fe mi mj mk ly b">%</code>来获取数组位置。所以，它会看起来像这样，<code class="fe mi mj mk ly b">134 % length of the array</code>答案会在0和数组的长度减1之间。假设数组的长度为3，134个模块的长度为3就等于1。此时，我们可以在索引1处存储1。对字符串“sun”和“fly”重复相同的公式，并将值2和0存储在数组中。最后，这给了我们每个键的相关指数。</p><h2 id="f626" class="kz la in bd lb lc ld dn le lf lg dp lh jv li lj lk jz ll lm ln kd lo lp lq lr bi translated">碰撞</h2><p id="008e" class="pw-post-body-paragraph jk jl in jm b jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd lw kf kg kh ig bi translated">现在让我们假设我们的第二个字符串<code class="fe mi mj mk ly b">'key2'</code>也映射到1，这意味着我们现在有两个键映射到同一个值1。这表明哈希表不仅仅是一个数组；这是一个数组，其中每个索引映射到一个潜在值的链表。这主要处理两个键被散列到同一个索引中并发生冲突的情况，这在哈希表中被称为<em class="mg">冲突</em>。</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="3a3b" class="kz la in ly b gy mc md l me mf">ASCII               <br/>"key1" =&gt; 1            139 % 3 = 1 \<br/>                                     &gt; Collision<br/>"key2" =&gt; 2            352 % 3 = 1 /<br/>"key3" =&gt; 3            639 % 3 = 0</span></pre><p id="2fb0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了<strong class="jm io">解决冲突</strong>，我们简单地将所有具有相同哈希值的键放在一个单独的链表中。在这种情况下，数组将有三个链表，索引0处的值3，索引1处的值1 &amp; 2，<code class="fe mi mj mk ly b">1 -&gt; 2</code>。现在，您可能想知道如何知道indices，3中的两个值中的哪一个与“key1”和“key2”相关。要查找键，每个值还需要指向它们的键。所以，值3将指向“key3”，值2将指向“key2”，值1将同时指向值2和“key1”。这个过程清楚地表明了哪个键与哪个值相关。</p><p id="6049" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哈希表支持常数时间、<strong class="jm io"> O(1) </strong> <em class="mg">插入</em>、<em class="mg">删除</em>，以及<em class="mg">平均搜索</em>。最坏情况下，时间复杂度为<strong class="jm io"> O(n) </strong>，线性时间。如果你在一个场景中结束，你有一个长链表，或者说你有15个值，其中12个相互冲突，其余的是独立的，这个长度为15的链表，将是一个长度为n的链表；<strong class="jm io"> O(n) </strong>最坏情况下。我们使用散列函数<em class="mg">来最小化冲突的数量</em>。事实上，这些散列函数是如此强大，以至于在行业中，我们经常忘记线性时间最坏情况。我们几乎总是认为散列表平均支持常量时间的插入、删除和搜索。</p><p id="d4da" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">所以，它需要<strong class="jm io"> O(n) </strong>运行时间来初始化一个哈希表，其中有n个元素。空间复杂度取决于你存储的值，因为我们只存储值，不存储键；我们只指向内存中的键。因此，存储的空间复杂度为<strong class="jm io"> O(n) </strong>。</p><p id="c2f1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">最后，我们来过一个简单的哈希表面试问题。</p><p id="512f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">问题:</strong>给定一个字符串<code class="fe mi mj mk ly b">str</code>，判断它是否拥有所有唯一字符。</p><p id="90e8" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输入1:“XYZ”</p><p id="296e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出1:真</p><p id="ab55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输入2:“xyzz”</p><p id="25f0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">输出2:错误</p><pre class="kj kk kl km gt lx ly lz ma aw mb bi"><span id="f172" class="kz la in ly b gy mc md l me mf">function uniqueString(string){</span><span id="0364" class="kz la in ly b gy mh md l me mf">        // create a hash table by assiging it to storage<br/>        let storage = {}</span><span id="823d" class="kz la in ly b gy mh md l me mf">        //start iteration at index 0<br/>        let i = 0<br/>        <br/>        //enter the while loop<br/>        while(i &lt; string.length){<br/>            //assign char to the value of the index<br/>            let char = string[i]<br/>            <br/>            //check if the char is not in the storage hash<br/>           if(!storage[char]){</span><span id="ade8" class="kz la in ly b gy mh md l me mf">                // add it in the hash table and increment<br/>                storage[char] = true<br/>                i++<br/>            }else{</span><span id="be9e" class="kz la in ly b gy mh md l me mf">               //if char is already in storage return false<br/>               return false<br/>            }<br/>        }<br/>        //true, if you make your way out of the loop without any duplicate value   <br/>     <br/>        return true<br/>    }</span></pre><p id="911d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个程序运行<strong class="jm io"> O(n) </strong>次，其中n是字符串的长度。空间复杂度是<strong class="jm io"> O(n) </strong>，n是存储在存储中的值，我们的哈希表。</p></div><div class="ab cl ml mm hr mn" role="separator"><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq mr"/><span class="mo bw bk mp mq"/></div><div class="ig ih ii ij ik"><p id="a8ce" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">以前的帖子:</strong></p><p id="776f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ky" href="https://medium.com/javascript-in-plain-english/type-checking-using-proptypes-in-react-be8c46e7e704?source=your_stories_page-------------------------------------" rel="noopener">在React中使用PropTypes进行类型检查</a></p><p id="b862" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ky" href="https://medium.com/swlh/12-most-common-javascript-number-methods-4dfeedb7f2af?source=your_stories_page-------------------------------------" rel="noopener"> 12种最常见的JavaScript数字方法</a></p><p id="f439" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">12人必须知道下一次面试的数组方法——JavaScript</p><p id="7fa1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ky" href="https://medium.com/@tanuka.das12/arrays-left-rotation-javascript-2befa87c4c87?source=your_stories_page-------------------------------------" rel="noopener">数组:左旋转(JavaScript) </a></p></div></div>    
</body>
</html>