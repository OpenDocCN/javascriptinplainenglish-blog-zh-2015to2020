<html>
<head>
<title>The right way to check if an object has a property in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在JavaScript中检查对象是否有属性的正确方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-right-way-to-check-if-an-object-has-a-property-in-javascript-10da3160a1e4?source=collection_archive---------5-----------------------#2019-09-30">https://javascript.plainenglish.io/the-right-way-to-check-if-an-object-has-a-property-in-javascript-10da3160a1e4?source=collection_archive---------5-----------------------#2019-09-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/bbbab6fc99628470add15052bb51d73c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*H-25KB7EbSHjv70HXrdl6w.png"/></div></div></figure><p id="e006" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">您可能认为这可以通过使用<code class="fe kw kx ky kz b">in</code>操作符很容易地完成。</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="8125" class="li lj iq kz b gy lk ll l lm ln">const user = {<br/>  name: 'Olivier',<br/>}</span><span id="25c3" class="li lj iq kz b gy lo ll l lm ln">'name' in user // true</span></pre><p id="fb7a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><code class="fe kw kx ky kz b">in</code>操作符的问题在于它检查属性是在指定的对象<strong class="ka ir">中还是在它的原型链</strong>中。这意味着:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="4e28" class="li lj iq kz b gy lk ll l lm ln">const user = {<br/>  name: 'Olivier',<br/>}</span><span id="3999" class="li lj iq kz b gy lo ll l lm ln">'name' in user // true<br/>'age' in user // false<br/>'constructor' in user // true</span></pre><p id="3712" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">因为<code class="fe kw kx ky kz b">constructor</code>实际上是<code class="fe kw kx ky kz b">object</code>原型的一个属性。</p></div><div class="ab cl lp lq hu lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ij ik il im in"><p id="06ea" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">幸运的是，有一个<code class="fe kw kx ky kz b">hasOwnProperty</code>方法可以指示对象<strong class="ka ir">是否将指定的属性作为自己的属性</strong>。</p><p id="2ff6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">所以你认为你可以这样使用它:<code class="fe kw kx ky kz b">myObject.hasOwnProperty('id')</code>但是你猜怎么着？<br/>建议用:<code class="fe kw kx ky kz b">Object.prototype.hasOwnProperty.call(myObject, 'id')</code>代替。这两种语法有什么区别？</p><p id="c5c8" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">第一个调用对象<code class="fe kw kx ky kz b">hasOwnProperty</code>方法，而第二个调用对象原型<code class="fe kw kx ky kz b">hasOwnProperty</code>方法。</p><p id="4230" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">区别是什么，为什么要使用第二种语法？</p><ol class=""><li id="6eda" class="lw lx iq ka b kb kc kf kg kj ly kn lz kr ma kv mb mc md me bi translated">你可以这样用javascript创建没有任何原型的对象:<br/> <code class="fe kw kx ky kz b">const myObject = Object.create(null)</code>。为什么你会这样做而不是<code class="fe kw kx ky kz b">const myObject = {}</code>？因为这显然是在引入地图数据结构之前模拟地图数据结构的一种方式(你仍然会得到一个对象，但是没有从原型继承的任何属性或方法)。</li><li id="719a" class="lw lx iq ka b kb mf kf mg kj mh kn mi kr mj kv mb mc md me bi translated">您可以覆盖<code class="fe kw kx ky kz b">hasOwnProperty</code>方法(或任何其他方法),因此:</li></ol><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="72ab" class="li lj iq kz b gy lk ll l lm ln">const user = { name: 'Olivier' }<br/>user.hasOwnProperty = null<br/>user.hasOwnProperty('name') // Uncaught TypeError<br/>Object.prototype.hasOwnProperty.call(user, 'name') // true</span></pre><p id="18fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后一句话。请注意，可以覆盖原型方法:</p><pre class="la lb lc ld gt le kz lf lg aw lh bi"><span id="be6d" class="li lj iq kz b gy lk ll l lm ln">Object.prototype.hasOwnProperty = null<br/>const user = { name: 'Olivier' }<br/>Object.prototype.hasOwnProperty.call(user, 'name') // Uncaught TypeError</span></pre><p id="8255" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是你不应该心甘情愿的这么做，除非你真的知道自己在做什么！</p></div></div>    
</body>
</html>