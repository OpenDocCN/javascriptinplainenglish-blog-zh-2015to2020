<html>
<head>
<title>How to Make a Simple Custom useDrag React Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何制作一个简单的自定义的Drag React钩子</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-make-a-simple-custom-usedrag-react-hook-6b606d45d353?source=collection_archive---------6-----------------------#2020-12-31">https://javascript.plainenglish.io/how-to-make-a-simple-custom-usedrag-react-hook-6b606d45d353?source=collection_archive---------6-----------------------#2020-12-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="9679" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">使用自定义的可重用React挂钩处理元素拖动行为</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9b6c4782ae62c07c0227b8f0d99cd954.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H_UYW2dxhfJynBRN"/></div></div></figure><p id="74f7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">大约有10亿个库在Reactiverse中处理React浮动的移动和拖动，其中许多库实际上非常棒。但是，有时你可能不想要一个完全成熟的库，或者你找到的库不能完成你需要的，<em class="lk">或者</em>你只是喜欢学习东西，想写你自己的代码！🤓</p><p id="ceb3" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">另外需要指出的是，我们将要构建的钩子是用来在页面上拖动一个元素，并通过一个<code class="fe ll lm ln lo b">CSS</code>属性改变它的位置。因此，我们将使用<code class="fe ll lm ln lo b">pointer</code>事件处理程序(<code class="fe ll lm ln lo b">onpointermove</code>、<code class="fe ll lm ln lo b">onpointerdown</code>等)。)来移动我们的元素。如果我们构建钩子来移动<em class="lk">数据，</em>而不是实际的元素，我们可能想要使用<code class="fe ll lm ln lo b">drag</code>事件处理程序(<code class="fe ll lm ln lo b">ondrag</code>、<code class="fe ll lm ln lo b">ondragstart</code>等)。).</p><p id="9e48" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">事不宜迟，这里有一个超级简单的自定义React钩子，您可以用它来完成所有基本的元素拖动任务。</p><h1 id="9727" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">使用抹布</h1><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="08bb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">酷毙了。这个钩子真的很简单，但是让我们来看看到底发生了什么。</p><p id="8607" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一个参数是一个必需的React <code class="fe ll lm ln lo b">ref</code>对象，它保存对一个<strong class="kq io"> HTML元素</strong>的引用。接下来是<code class="fe ll lm ln lo b">deps</code>，一个<strong class="kq io">依赖关系列表</strong>(重要)，最后是一个<strong class="kq io"> options </strong>对象，带有几个可选的回调:<code class="fe ll lm ln lo b">onPointerDown</code>、<code class="fe ll lm ln lo b">onPointerUp</code>、<code class="fe ll lm ln lo b">onPointerMove</code>和<code class="fe ll lm ln lo b">onDrag</code>。</p><h2 id="f734" class="mj lq in bd lr mk ml dn lv mm mn dp lz kx mo mp mb lb mq mr md lf ms mt mf mu bi translated">状态和处理程序</h2><p id="49e6" class="pw-post-body-paragraph ko kp in kq b kr mv jo kt ku mw jr kw kx mx kz la lb my ld le lf mz lh li lj ig bi translated">我们将拖动状态存储在<code class="fe ll lm ln lo b">isDragging</code>中，然后声明处理程序<code class="fe ll lm ln lo b">handlePointerDown</code>、<code class="fe ll lm ln lo b">handlePointerUp</code>和<code class="fe ll lm ln lo b">handlePointerMove</code>。</p><p id="69f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe ll lm ln lo b">isDragging</code>简单地跟踪元素当前是否在拖动。注意，它也被从<code class="fe ll lm ln lo b">useDrag</code>返回用于其他地方。</p><p id="9af6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于<code class="fe ll lm ln lo b">handlePointerDown</code>，每当用户按下他们的设备时，我们将<code class="fe ll lm ln lo b">isDragging</code>设置为<code class="fe ll lm ln lo b">true</code>，然后通过我们的<code class="fe ll lm ln lo b">onPointerDown</code>回调将事件传回。类似地，使用<code class="fe ll lm ln lo b">handlePointerUp</code>，每当用户的设备上升时，将<code class="fe ll lm ln lo b">isDragging</code>设置为<code class="fe ll lm ln lo b">false</code>，并将拖动事件传回<code class="fe ll lm ln lo b">onPointerUp</code>。最后，使用<code class="fe ll lm ln lo b">handlePointerMove</code>，每当用户移动鼠标时，将事件传递回<code class="fe ll lm ln lo b">onPointerMove</code>，如果我们当前正在拖动，也将事件传递回<code class="fe ll lm ln lo b">onDrag</code>。</p><h2 id="3c37" class="mj lq in bd lr mk ml dn lv mm mn dp lz kx mo mp mb lb mq mr md lf ms mt mf mu bi translated">使用效果</h2><p id="35a1" class="pw-post-body-paragraph ko kp in kq b kr mv jo kt ku mw jr kw kx mx kz la lb my ld le lf mz lh li lj ig bi translated">之后，我们添加了负责注册和注销事件处理程序的<code class="fe ll lm ln lo b">useEffect</code>钩子。我们首先检查以确保我们的元素<code class="fe ll lm ln lo b">ref</code>已经初始化，然后我们用<code class="fe ll lm ln lo b">addEventListener</code>和上面的处理函数注册每个事件。为了清理，我们返回一个函数，在每个处理程序上调用<code class="fe ll lm ln lo b">removeEventListener</code>。<a class="ae na" href="https://www.osmosis.org/learn/Remember" rel="noopener ugc nofollow" target="_blank">记住</a>钩子中返回的函数将在下一次更新之前运行。如果我们不这样做，每次效果挂钩运行的时候就会有新的事件监听器被注册<em class="lk">，这很快就会堆积起来。您可以通过注释掉<code class="fe ll lm ln lo b">removeEventListener</code>调用并在<code class="fe ll lm ln lo b">handlePointerDown</code>中添加一个<code class="fe ll lm ln lo b">console.log</code>来亲自看到这一点。你会发现每次点击都会产生越来越多的日志。</em></p><p id="8dec" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后一位是我们的依赖数组，我们将<code class="fe ll lm ln lo b">isDragging</code>与<code class="fe ll lm ln lo b">deps</code>数组结合起来，这意味着只要这些变量中的任何一个发生变化，<code class="fe ll lm ln lo b">useEffect</code>钩子就会运行。这里的依赖数组很重要！每次<code class="fe ll lm ln lo b">useEffect</code>钩子运行时，它都会得到更新的函数处理程序向<code class="fe ll lm ln lo b">addEventHandler</code>注册。如果那个<em class="lk">没有</em>发生，我们会以<em class="lk">过期的</em>函数注册到事件中结束。例如，如果我们有一个空数组——这意味着<code class="fe ll lm ln lo b">useEffect</code>钩子只在组件被挂载时运行一次——那么<code class="fe ll lm ln lo b">handlePointerMove</code>中的<code class="fe ll lm ln lo b">isDragging</code>变量将始终是它被初始化时的样子— <code class="fe ll lm ln lo b">false</code>!</p><p id="8750" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，如上所述，我们返回一个带有<code class="fe ll lm ln lo b">isDragging</code>的对象用于其他地方。</p><h1 id="a829" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">例子</h1><p id="2215" class="pw-post-body-paragraph ko kp in kq b kr mv jo kt ku mw jr kw kx mx kz la lb my ld le lf mz lh li lj ig bi translated">不错！现在让我们继续演示这只小狗。</p><p id="07f7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我用<code class="fe ll lm ln lo b">create-react-app</code>搞出一个React app，用大家最喜欢的spinny React logo作为拖动的目标。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="a743" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了实现拖动，首先我们将我们的<code class="fe ll lm ln lo b">ref</code>容器声明为<code class="fe ll lm ln lo b">divRef</code>，然后声明一个状态变量来保存div的当前<code class="fe ll lm ln lo b">translate</code>位置。接下来，我们在<code class="fe ll lm ln lo b">useDraggable</code>中声明从<code class="fe ll lm ln lo b">onDrag</code>调用的<code class="fe ll lm ln lo b">handleDrag</code>函数。最后，我们调用我们闪亮的新钩子，传递<code class="fe ll lm ln lo b">divRef</code>、带有<code class="fe ll lm ln lo b">translate</code>状态变量(重要)的依赖数组和<code class="fe ll lm ln lo b">handleDrag</code>函数。现在，在下面，将我们的<code class="fe ll lm ln lo b">divRef</code>连接到logo容器，并添加转换样式。</p><p id="93f8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">她就写了这么多！检查一下:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="nb mi l"/></div></figure><h1 id="75f4" class="lp lq in bd lr ls lt lu lv lw lx ly lz jt ma ju mb jw mc jx md jz me ka mf mg bi translated">结束语</h1><p id="948d" class="pw-post-body-paragraph ko kp in kq b kr mv jo kt ku mw jr kw kx mx kz la lb my ld le lf mz lh li lj ig bi translated">当然，和往常一样，还有很多其他方法可以实现上述目标。实际上，对于所用的示例，直接在容器<code class="fe ll lm ln lo b">div</code>上使用React的<code class="fe ll lm ln lo b">onPointerMove</code>、<code class="fe ll lm ln lo b">onPointerUp</code>和<code class="fe ll lm ln lo b">onPointerDown</code>处理程序会更快，并且在App.js. <em class="lk">或</em>中处理拖动状态。您可以创建一个自定义组件来包装容器<code class="fe ll lm ln lo b">div</code>并以这种方式处理拖动。</p><p id="4749" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，我发现使用<code class="fe ll lm ln lo b">useDraggable</code>钩子的一个好处是，你可以在同一个<code class="fe ll lm ln lo b">ref</code>容器<code class="fe ll lm ln lo b">div</code>上定义多个拖动处理程序，甚至可以通过传递<code class="fe ll lm ln lo b">ref</code>在不同的组件中定义。</p><p id="e0c9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">例如，您可能有一个定义了<code class="fe ll lm ln lo b">ref</code>的父组件。然后将那个<code class="fe ll lm ln lo b">ref</code>传递给包含目标元素的子组件。现在，您还可以将它传递给处理不同拖动行为的兄弟组件。</p><p id="dca7" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">大概是这样的:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nc"><img src="../Images/9d54e85709e1eac6b6b1a4f86ac54c4e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*T2mSXIHfDdhgEV9h5on6lg.jpeg"/></div></div></figure><p id="7dab" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">同样，在拖动元素的时候，有很多方法可以让你变得更加可爱，但是使用你自己的可重复使用的React钩子是一种快速简单的方法。</p><p id="8000" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">感谢阅读，希望你能学到一两件事！现在前进吧，带上你的元素！</p></div><div class="ab cl nd ne hr nf" role="separator"><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni nj"/><span class="ng bw bk nh ni"/></div><div class="ig ih ii ij ik"><h1 id="2be5" class="lp lq in bd lr ls nk lu lv lw nl ly lz jt nm ju mb jw nn jx md jz no ka mf mg bi translated">资源</h1><ul class=""><li id="49ea" class="np nq in kq b kr mv ku mw kx nr lb ns lf nt lj nu nv nw nx bi translated"><a class="ae na" href="https://codesandbox.io/s/late-lake-t1byk?file=/src/App.js" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/late-lake-t1byk?file=/src/App.js</a></li><li id="b119" class="np nq in kq b kr ny ku nz kx oa lb ob lf oc lj nu nv nw nx bi translated"><a class="ae na" href="https://github.com/tmarshall07/use-draggable-hook" rel="noopener ugc nofollow" target="_blank">https://github.com/tmarshall07/use-draggable-hook</a></li></ul></div></div>    
</body>
</html>