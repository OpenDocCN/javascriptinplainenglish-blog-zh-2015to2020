<html>
<head>
<title>Render dynamically a .docx file with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript动态呈现. docx文件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/render-dynamically-a-docx-file-with-javascript-daaed816fcb8?source=collection_archive---------1-----------------------#2019-12-20">https://javascript.plainenglish.io/render-dynamically-a-docx-file-with-javascript-daaed816fcb8?source=collection_archive---------1-----------------------#2019-12-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2340406a5795a6e231ada048711d1e28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gbvASll85Qf3PnzY"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@mr_vero?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Irvan Smith</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="042d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">大家好，我是斯特凡诺，这是我的第一篇文章！请随意给我一些关于写作或与这篇文章相关的建议🙌🏻<br/>原文<a class="ae jz" href="https://dev.to/sintj_/render-dynamically-a-docx-file-with-javascript-3mef" rel="noopener ugc nofollow" target="_blank">此处</a> (dev.to)。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="f15e" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">需求</h1><p id="840a" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">我正在用Vue构建一个webapp。JS + Nuxt。我的一个客户的JS:这个应用程序的目的是基于他们制造的产品创建提案，计算价格和一堆其他事情。<br/>最终，完成的提案需要转换成可打印的格式。</p><h1 id="1a4c" class="lf lg in bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">问题是</h1><p id="13c4" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">每个提案都有不同的基本信息(标题、创建日期等..)和里面不同的产品。每个产品也是不同的，它可能有一些其他产品没有的键/值对。<br/>事实是<strong class="kc io">我想导出一个看起来总是一样的文件(一个模板)，但用我的提案中的数据渲染</strong>。</p><h1 id="4955" class="lf lg in bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">工具</h1><p id="3264" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">在网上搜索时，我发现了一个名为<strong class="kc io"> docxtemplater </strong>的非常棒的工具，它完全可以完成这项工作。<em class="mn">让我们看看它的作用:</em></p><p id="a01e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想象一个. docx (Word，Google Doc等..)像这样:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4bf9" class="mx lg in mt b gy my mz l na nb">Hello {name}!<br/>You have all these games: {#gameList}{.} {/gameList}<br/>{#hasXbox}And you have also an XBOX!{/}</span></pre><p id="29a0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用<strong class="kc io"> docxtemplater </strong>你可以传入一个对象，例如，像这样:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="9064" class="mx lg in mt b gy my mz l na nb">let obj = {<br/> name: `Sam`,<br/> gameList: [`Metal Gear Solid`, `Crash Bandicoot`, `Final Fantasy 7`],<br/> hasXbox: false<br/>}</span></pre><p id="9266" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">渲染后，您将能够下载文档，在这种情况下，将如下所示:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b72d" class="mx lg in mt b gy my mz l na nb">Hello Sam!<br/>You have all these games: Metal Gear Solid Crash Bandicoot Final Fantasy 7</span></pre><p id="70a6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你注意到了吗？<br/> <strong class="kc io">数组上的条件和循环是可能的</strong>给你自由构建一个符合你需求的模板。<br/>由于布尔值<em class="mn"> hasxbox </em>，整个Xbox句子被省略。你也可以在一组对象上循环，这给了你更多的能力。关于整个文档，我建议看一看<a class="ae jz" href="https://docxtemplater.readthedocs.io/en/latest/tag_types.html" rel="noopener ugc nofollow" target="_blank">的官方网站</a>。</p><h1 id="809a" class="lf lg in bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">设置</h1><p id="b116" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">正如我之前所说的，我使用的是Vue，但是下面的方法很容易适应其他环境。</p><p id="9e6b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您需要<em class="mn"> npm安装</em>一些依赖项:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="b499" class="mx lg in mt b gy my mz l na nb">npm install --save docxtemplater jszip@2 jszip-utils file-saver</span></pre><p id="3ed5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mn"> docxtemplater </em>接受zip，因此<em class="mn"> jszip </em>和<em class="mn"> jszip-utils </em>对此很有用，<em class="mn"> file-saver </em>对于保存渲染的文件很有用。设备上的docx。<br/> <em class="mn">注意:jszip@2为了防止安装在我的环境中似乎不工作的版本3+:请随意尝试两者。</em></p><p id="521d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">也就是说我像这样把它们导入到组件中:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="439a" class="mx lg in mt b gy my mz l na nb">import docxtemplater from ‘docxtemplater’<br/>import JSzip from ‘jszip’<br/>import JSzipUtils from ‘jszip-utils’<br/>import { saveAs } from ‘file-saver’</span></pre><p id="2238" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在html模板中，我有这个按钮:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="4e34" class="mx lg in mt b gy my mz l na nb">&lt;button @click=”createDOC()”&gt;Export DOCX&lt;/button&gt;</span></pre><p id="5331" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后是方法:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="5167" class="mx lg in mt b gy my mz l na nb">methods:{<br/>    loadFile(url,callback){<br/>        JSzipUtils.getBinaryContent(url,callback);<br/>    },<br/><br/>    createDOC(){<br/>        let prev = this.getLoadedPrev<br/>        this.loadFile('/template.docx',function(error,content){<br/>            if (error) { throw error };<br/>            let zip = new JSzip(content);<br/>            let doc = new docxtemplater().loadZip(zip)<br/>            doc.setData(prev)<br/><br/>            try {<br/>                doc.render()<br/>            }<br/><br/>            catch (error) {<br/>                let e = {<br/>                    message: error.message,<br/>                    name: error.name,<br/>                    stack: error.stack,<br/>                    properties: error.properties,<br/>                }<br/>                console.log(JSON.stringify({error: e}));<br/>                // The error thrown here contains additional information when logged with JSON.stringify (it contains a property object).<br/>                throw error;<br/>            }<br/><br/>            let out = doc.getZip().generate({<br/>                type:"blob",<br/>                mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",<br/>                })<br/>            saveAs(out,`${prev.titolo}.docx`)<br/>        })<br/>    }<br/>}</span></pre><p id="05c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的例子中，方法<em class="mn"> loadFile </em>将检索。应用程序的静态文件夹中的docx模板(所有这一切都发生在客户端，有可能设置所有这一切与节点服务器端)。<br/>jszip实用程序将压缩。为了实例化一个新的<em class="mn"> docxtemplate </em>文档而传递的docx。</p><p id="4f92" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<em class="mn"> doc.setData(prev) </em>中，我用<strong class="kc io">传递一个对象，该对象包含关于建议书的所有信息(标题、创建日期、产品列表、作者等..)</strong>然后它会尝试渲染doc。</p><p id="0fcd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">错误处理后的代码块:</p><pre class="mo mp mq mr gt ms mt mu mv aw mw bi"><span id="a3f2" class="mx lg in mt b gy my mz l na nb">let out = doc.getZip().generate({<br/>                type:"blob",<br/>                mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",<br/>                })<br/>            saveAs(out,`${prev.titolo}.docx`)<br/>        })</span></pre><p id="2024" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">负责呈现文档的输出。</p><h1 id="c003" class="lf lg in bd lh li mi lk ll lm mj lo lp lq mk ls lt lu ml lw lx ly mm ma mb mc bi translated">结论</h1><p id="de56" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">请注意，如果您需要生成一个PDF文件，<strong class="kc io">可以通过</strong>到<a class="ae jz" href="https://www.npmjs.com/package/@nativedocuments/docx-wasm" rel="noopener ugc nofollow" target="_blank">这个包</a>。对于对Lambda函数有信心的人来说，这将是轻而易举的事情。现在我没有这样做的需求，所以我不能用真实的例子来帮助你。</p><p id="c7cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就这些，<br/>干杯！👋🏻</p></div></div>    
</body>
</html>