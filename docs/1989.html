<html>
<head>
<title>JavaScript Best Practices for Writing More Robust Code — Checking Object Types</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">编写更健壮代码的JavaScript最佳实践—检查对象类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-best-practices-for-writing-more-robust-code-checking-object-types-3d5d1a5a36c2?source=collection_archive---------16-----------------------#2020-05-09">https://javascript.plainenglish.io/javascript-best-practices-for-writing-more-robust-code-checking-object-types-3d5d1a5a36c2?source=collection_archive---------16-----------------------#2020-05-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/9530ddfbbe3e58a26aca013a457499fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dEFSJUX37I3vWj5Q"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@pawel_czerwinski?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Paweł Czerwiński</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bdcd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是一种简单易学的编程语言。编写运行并执行某些操作的程序很容易。然而，很难考虑所有的用例并编写健壮的JavaScript代码。</p><p id="632a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何检查对象的类型，以便我们只处理我们正在寻找的对象类型。</p><h1 id="78a5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">运算符的实例</h1><p id="65fd" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript <code class="fe me mf mg mh b">instanceof</code>操作符让我们获得用于创建对象的构造函数。</p><p id="3197" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">instanceof</code>操作符的语法如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="07a2" class="mq lc iq mh b gy mr ms l mt mu">x instanceof Ctor</span></pre><p id="197a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">其中<code class="fe me mf mg mh b">x</code>是我们正在检查的对象，<code class="fe me mf mg mh b">Ctor</code>是我们想要检查它是否是从它创建的构造函数。</p><p id="fe0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ddf4" class="mq lc iq mh b gy mr ms l mt mu">function C() {}<br/>const c = new C();<br/>console.log(c instanceof C);</span></pre><p id="93db" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码有一个新的构造函数<code class="fe me mf mg mh b">C</code>，我们通过用<code class="fe me mf mg mh b">new</code>操作符调用<code class="fe me mf mg mh b">C</code>构造函数创建了<code class="fe me mf mg mh b">c</code>对象。</p><p id="9067" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当我们记录<code class="fe me mf mg mh b">c instanceof C</code>时，我们应该会看到<code class="fe me mf mg mh b">true</code>，因为<code class="fe me mf mg mh b">c</code>是从<code class="fe me mf mg mh b">C</code>构造函数创建的。</p><p id="ba73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">注意，大多数对象也是<code class="fe me mf mg mh b">Object</code>的实例，除非我们专门创建了一个没有原型的对象。</p><p id="e04f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<code class="fe me mf mg mh b">console.log(c instanceof Object);</code>也应该是<code class="fe me mf mg mh b">true</code>，因为我们在创建<code class="fe me mf mg mh b">c</code>时并没有特意移除原型。</p><p id="2acc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">instanceof</code>操作符沿着原型链一直向上检查，所以如果它在原型链的任何地方找到构造函数，它将返回<code class="fe me mf mg mh b">true</code>。</p><p id="5ef9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于<code class="fe me mf mg mh b">Object</code>是<code class="fe me mf mg mh b">C</code>的原型，<code class="fe me mf mg mh b">c</code>是<code class="fe me mf mg mh b">C</code>的实例，<code class="fe me mf mg mh b">instanceof</code>返回<code class="fe me mf mg mh b">true</code>。</p><p id="aca1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们想检查某个东西，而不是某个东西的实例时，我们必须小心。</p><p id="c2f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想检查<code class="fe me mf mg mh b">c</code>是否不是<code class="fe me mf mg mh b">C</code>的实例，我们应该写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="cfd4" class="mq lc iq mh b gy mr ms l mt mu">if (!(c instanceof C)) {<br/>  //...<br/>}</span></pre><p id="337a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">而不是:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="852c" class="mq lc iq mh b gy mr ms l mt mu">if (!c instanceof C) {<br/>  //...<br/>}</span></pre><p id="9a14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为在第二个例子中,<code class="fe me mf mg mh b">!</code>操作符只应用于<code class="fe me mf mg mh b">c</code>,而不是<code class="fe me mf mg mh b">c instanceof C</code>。因此，我们得到了<code class="fe me mf mg mh b">false instanceof C</code>而不是<code class="fe me mf mg mh b">!(c instanceof C)</code>，因为<code class="fe me mf mg mh b">c</code>是真的，我们否定了它。</p><h1 id="8369" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">构造函数名称检查</h1><p id="9502" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">instanceof</code>的另一种方法是用对象的<code class="fe me mf mg mh b">constructor.name</code>属性检查创建对象的构造函数的名称。</p><p id="937f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="93b2" class="mq lc iq mh b gy mr ms l mt mu">function C() {}<br/>const c = new C();<br/>console.log(c.constructor.name);</span></pre><p id="eac3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么<code class="fe me mf mg mh b">c.constructor.name</code>就是<code class="fe me mf mg mh b">'C'</code>，因为我们从<code class="fe me mf mg mh b">C</code>构造函数创建了<code class="fe me mf mg mh b">c</code>。</p><p id="f0bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这只返回创建它的构造函数的名字，所以我们不会得到原型链上的任何信息。</p><h1 id="e49c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结构检查</h1><p id="849d" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了检查对象是否是我们想要处理的，我们还应该检查给定的属性和值是否存在。</p><p id="7123" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用对象实例的<code class="fe me mf mg mh b">hasOwnProperty</code>方法来完成，或者我们可以检查属性的类型是否是<code class="fe me mf mg mh b">'undefined'</code>。</p><p id="df2f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它只检查属性是否是自己的属性，这意味着它不是从原型链上的对象继承的属性。</p><p id="6faf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以编写以下代码来检查:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6ec8" class="mq lc iq mh b gy mr ms l mt mu">const obj = {};<br/>obj.foo = 42;<br/>console.log(obj.hasOwnProperty('foo'));</span></pre><p id="d739" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有<code class="fe me mf mg mh b">obj.hasOwnProperty(‘foo’)</code>。由于<code class="fe me mf mg mh b">obj</code>具有属性<code class="fe me mf mg mh b">foo</code>，因此<code class="fe me mf mg mh b">obj.hasOwnProperty(‘foo’)</code>返回<code class="fe me mf mg mh b">true</code>。</p><p id="b070" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">hasOwnProperty</code>将返回<code class="fe me mf mg mh b">true</code>，即使属性值为<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">undefined</code>。只要它被添加到对象中，它就会返回<code class="fe me mf mg mh b">true</code>。</p><p id="41b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同样，我们可以使用JavaScript <code class="fe me mf mg mh b">in</code>操作符来检查一个属性是否在一个对象中。</p><p id="7a0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性用于检查给定对象中是否包含继承的或自己的属性。</p><p id="f119" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="75d8" class="mq lc iq mh b gy mr ms l mt mu">const obj = {};<br/>obj.foo = 42;<br/>console.log('foo' in obj);<br/>console.log('constructor' in obj);</span></pre><p id="2c39" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后两个控制台日志都显示<code class="fe me mf mg mh b">true</code>，因为<code class="fe me mf mg mh b">'foo'</code>是<code class="fe me mf mg mh b">obj</code>自己的属性，而<code class="fe me mf mg mh b">'constructor'</code>是从<code class="fe me mf mg mh b">Object</code>继承的属性，而<code class="fe me mf mg mh b">Object</code>是<code class="fe me mf mg mh b">obj</code>的原型。</p><p id="63b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">和<code class="fe me mf mg mh b">hasOwnProperty</code>一样，如果属性值为<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">undefined</code>，那么<code class="fe me mf mg mh b">in</code>操作符也会返回<code class="fe me mf mg mh b">true</code>。</p><p id="d91f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想检查一个属性是否不是<code class="fe me mf mg mh b">null</code>或<code class="fe me mf mg mh b">undefined</code>，我们可以写如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="0dfd" class="mq lc iq mh b gy mr ms l mt mu">const obj = {};<br/>obj.foo = 42;<br/>console.log(typeof obj.foo !== 'undefined' &amp;&amp; obj.foo !== null);</span></pre><p id="81f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="52f8" class="mq lc iq mh b gy mr ms l mt mu">typeof obj.foo !== 'undefined' &amp;&amp; obj.foo !== null</span></pre><p id="160d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">用<code class="fe me mf mg mh b">typoef</code>操作器检查<code class="fe me mf mg mh b">obj.foo</code>是否与<code class="fe me mf mg mh b">undefined</code>不在一起，用<code class="fe me mf mg mh b">!==</code>操作器检查<code class="fe me mf mg mh b">obj.foo</code>是否与<code class="fe me mf mg mh b">null</code>不在一起。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/a8ca08e0dc4d641258ed25c001cf45f1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*iVZG2SNe10yXhKYF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@zmachacek?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zdeněk Macháček</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="08c6" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="17e5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">instanceof</code>操作符或使用对象的<code class="fe me mf mg mh b">constructor.name</code>属性来检查对象是否是构造函数的实例。</p><p id="750c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们必须检查一个属性是否是我们正在寻找的，这样我们就知道我们正在处理正确的对象。为此，我们可以使用<code class="fe me mf mg mh b">hasOwnProperty</code>、<code class="fe me mf mg mh b">in</code>或<code class="fe me mf mg mh b">typeof</code>操作符。</p><h2 id="4ad0" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated"><strong class="ak">简明英语团队的笔记</strong></h2><p id="132b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae kc" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kf ir">JavaScript in Plain English</strong></a><a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong><strong class="kf ir"/>—谢谢，继续学习！</a></p><p id="1f5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们总是有兴趣帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，附上您的中型用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>