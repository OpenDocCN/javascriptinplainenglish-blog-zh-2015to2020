<html>
<head>
<title>What is the JavaScript NodeIterator API?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是JavaScript NodeIterator API？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-the-javascript-nodeiterator-api-c4443b79b492?source=collection_archive---------4-----------------------#2020-02-20">https://javascript.plainenglish.io/what-is-the-javascript-nodeiterator-api-c4443b79b492?source=collection_archive---------4-----------------------#2020-02-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="610b" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">遍历DOM树节点</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3afda67844c2c2e4b030c9d8586ce51b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*diJl1Xngm2jUsSWp0uEsfw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@toddquackenbush?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Todd Quackenbush</a> on <a class="ae kv" href="https://unsplash.com/s/photos/tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="74f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi ls translated">这里有两个遍历DOM的JavaScript API。他们是<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/NodeIterator" rel="noopener ugc nofollow" target="_blank">节点迭代器</a>和<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker" rel="noopener ugc nofollow" target="_blank">树行者</a>。两者都可以<strong class="ky ir">返回给定根节点下的节点列表</strong>。他们很相似，但也有一些不同。</p><blockquote class="mb"><p id="2f8f" class="mc md iq bd me mf mg mh mi mj mk lr dk translated">两者的核心目的都是过滤和查找所需的节点</p></blockquote><blockquote class="ml mm mn"><p id="5653" class="kw kx mo ky b kz mp jr lb lc mq ju le mr ms lh li mt mu ll lm mv mw lp lq lr ij bi translated"><code class="fe mx my mz na b"><strong class="ky ir">NodeIterator</strong></code>接口表示DOM子树中节点的<strong class="ky ir">列表</strong>成员的迭代器。节点将按文档顺序返回。</p><p id="5ed6" class="kw kx mo ky b kz la jr lb lc ld ju le mr lg lh li mt lk ll lm mv lo lp lq lr ij bi translated"><code class="fe mx my mz na b"><strong class="ky ir">TreeWalker</strong></code>对象表示文档<strong class="ky ir">子树</strong>的节点以及它们内部的位置。</p></blockquote></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><p id="c64b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">为了使本文简短，我们将把重点放在NodeIterator API上。</strong></p></div><div class="ab cl nb nc hu nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ij ik il im in"><h1 id="d3fd" class="ni nj iq bd nk nl nm nn no np nq nr ns jw nt jx nu jz nv ka nw kc nx kd ny nz bi translated">节点迭代器API</h1><p id="501f" class="pw-post-body-paragraph kw kx iq ky b kz oa jr lb lc ob ju le lf oc lh li lj od ll lm ln oe lp lq lr ij bi translated">使用文档接口的<strong class="ky ir"> createNodeIterator() </strong>方法创建<strong class="ky ir"> NodeIterator </strong>对象。</p><p id="0cc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">语法是，</p><pre class="kg kh ki kj gt of na og oh aw oi bi"><span id="29df" class="oj nj iq na b gy ok ol l om on">const nodeIterator = document.createNodeIterator(root, whatToShow, filter);</span></pre><p id="f5c3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如图所示，这个方法有三个参数。</p><ul class=""><li id="0ea2" class="oo op iq ky b kz la lc ld lf oq lj or ln os lr ot ou ov ow bi translated"><em class="mo">根节点</em>，它保存了我们想要过滤的所有节点。</li><li id="a3d6" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated">第二个参数，<em class="mo">whatoshow</em>，是一个<strong class="ky ir"> </strong> <em class="mo">构建的</em> <strong class="ky ir"> <em class="mo"> - </em> </strong> <em class="mo">，在filter </em>中使用了<strong class="ky ir"> NodeFilter </strong>对象的常量。</li><li id="f95b" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated">第三个参数，<em class="mo"> filter </em>，是一个返回<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> NodeFilter </strong> </a>对象<strong class="ky ir"> </strong>的函数，用于<strong class="ky ir">选择</strong>相关节点。在这里，您可以指定自定义标准来帮助决定<strong class="ky ir">接受</strong>、<strong class="ky ir">拒绝</strong>或<strong class="ky ir">跳过</strong>节点。</li></ul><p id="abdb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的第二个参数指的是<em class="mo">常量</em>。这些是<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/NodeFilter" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> NodeFilter </strong> </a>对象的常量，格式为NodeFilter.CONSTANT。</p><ul class=""><li id="cff3" class="oo op iq ky b kz la lc ld lf oq lj or ln os lr ot ou ov ow bi translated">节点过滤器。SHOW_TEXT(显示文本节点)</li><li id="332f" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated">节点过滤器。SHOW_ELEMENT(显示元素节点)</li></ul><p id="178f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当使用这些时，不匹配的节点被跳过<em class="mo">、</em>第一级过滤<em class="mo">。</em> <strong class="ky ir"> <em class="mo">常数</em> </strong> <em class="mo">的完整列表可以在</em> <a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/NodeIterator" rel="noopener ugc nofollow" target="_blank"> <em class="mo">这里</em> </a> <em class="mo">找到。</em></p><p id="04fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于NodeIterator是一个<strong class="ky ir">迭代器</strong>，它为我们提供了一个循环遍历节点的方法。nextNode()。</p><blockquote class="mb"><p id="0468" class="mc md iq bd me mf mg mh mi mj mk lr dk translated">简单地说，我们在DOM中指定一个起点，遍历DOM，寻找符合内置过滤器和定制过滤器标准的节点。</p></blockquote><h2 id="b79a" class="oj nj iq bd nk pc pd dn no pe pf dp ns lf pg ph nu lj pi pj nw ln pk pl ny pm bi translated">示例-显示元素</h2><p id="87e8" class="pw-post-body-paragraph kw kx iq ky b kz oa jr lb lc ob ju le lf oc lh li lj od ll lm ln oe lp lq lr ij bi translated">创造出下面的<strong class="ky ir">index.html</strong></p><pre class="kg kh ki kj gt of na og oh aw oi bi"><span id="4fcd" class="oj nj iq na b gy ok ol l om on">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;</span><span id="c973" class="oj nj iq na b gy pn ol l om on">&lt;head&gt;<br/>    &lt;meta charset="UTF-8"&gt;<br/>    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;<br/>    &lt;title&gt;Document.createNodeIterator&lt;/title&gt;<br/>&lt;/head&gt;</span><span id="64d8" class="oj nj iq na b gy pn ol l om on">&lt;body&gt;<br/>    &lt;div id='main'&gt;<br/>    &lt;h1&gt;Traversing The DOM&lt;/h1&gt;</span><span id="e7d3" class="oj nj iq na b gy pn ol l om on">    &lt;div&gt;<br/>       First Name:&lt;input type='text'&gt;&lt;br/&gt;<br/>       Last Name:&lt;input type='text'&gt;&lt;br/&gt;<br/>    &lt;/div&gt;<br/>    &lt;br/&gt;<br/>    &lt;div&gt;<br/>        To Do:<br/>        &lt;ul&gt;<br/>            &lt;li&gt;Wash Clothes&lt;/li&gt;<br/>            &lt;li&gt;Do Dishes&lt;/li&gt;<br/>            &lt;li&gt;Write Code&lt;/li&gt;<br/>        &lt;/ul&gt;<br/>    &lt;/div&gt;</span><span id="6ff5" class="oj nj iq na b gy pn ol l om on">&lt;/div&gt;<br/>    &lt;script src="index.js"&gt; &lt;/script&gt;</span><span id="be28" class="oj nj iq na b gy pn ol l om on">&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="15b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来创建下面的<strong class="ky ir"> index.js </strong></p><pre class="kg kh ki kj gt of na og oh aw oi bi"><span id="9f13" class="oj nj iq na b gy ok ol l om on">window.onload = ()=&gt; {<br/>    // The starting node<br/>    getNodesStartingAt(document.querySelector('#main'));<br/>}</span><span id="be6e" class="oj nj iq na b gy pn ol l om on">function getNodesStartingAt(myRoot) {</span><span id="f189" class="oj nj iq na b gy pn ol l om on">const nodeIterator = document.createNodeIterator(<br/>        myRoot,<br/>        NodeFilter.SHOW_ELEMENT,<br/>        (node) =&gt; {<br/>            // ACCEPT, REJECT OR SKIP based on<br/>            // custom criteria<br/>            return NodeFilter.FILTER_ACCEPT;<br/>        }<br/>    );</span><span id="d1c1" class="oj nj iq na b gy pn ol l om on">let currentnode;</span><span id="2c3b" class="oj nj iq na b gy pn ol l om on">while (currentnode = nodeIterator.nextNode()) {<br/>        console.log(currentnode.tagName);<br/>    }<br/>}</span></pre><p id="4dd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">试运行</strong></p><p id="6449" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开index.html。</p><p id="f7b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">打开浏览器的控制台窗口，观察输出。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi po"><img src="../Images/b69e7e727351a7e32e1a038a3f8e8ac3.png" data-original-src="https://miro.medium.com/v2/resize:fit:170/format:webp/1*CbRmhBefJF7b6TsxEbT2Kw.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Output for NodeFilter<strong class="bd pp">.SHOW_ELEMENT</strong></figcaption></figure><p id="3567" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">尝试通过修改函数调用来改变</strong>起始根，如下所示:</p><pre class="kg kh ki kj gt of na og oh aw oi bi"><span id="76c0" class="oj nj iq na b gy ok ol l om on">getNodesStartingAt(document.body);</span></pre><p id="705e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">尝试通过改变如下循环来改变</strong>console . log()的输出，</p><pre class="kg kh ki kj gt of na og oh aw oi bi"><span id="c5a7" class="oj nj iq na b gy ok ol l om on">while (currentnode = nodeIterator.nextNode()) {<br/>        <strong class="na ir">console.log(currentnode.innerHTML);</strong><br/>    }</span></pre><p id="f980" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">尝试更改</strong>节点过滤器。NodeFilter的常数。SHOW_TEXT和console.log()输出到nodeValue。请参见下面的粗体项目。</p><pre class="kg kh ki kj gt of na og oh aw oi bi"><span id="24cc" class="oj nj iq na b gy ok ol l om on">window.onload = ()=&gt; {<br/>    // The starting node<br/>    getNodesStartingAt(document.body);<br/>}</span><span id="0c5a" class="oj nj iq na b gy pn ol l om on">function getNodesStartingAt(myRoot) {</span><span id="beb7" class="oj nj iq na b gy pn ol l om on">const nodeIterator = document.createNodeIterator(<br/>        myRoot,<br/>       <strong class="na ir"> NodeFilter.SHOW_TEXT,</strong><br/>        (node) =&gt; {<br/>            // ACCEPT, REJECT OR SKIP based on<br/>            // custom criteria<br/>            return NodeFilter.FILTER_ACCEPT;<br/>        }<br/>    );</span><span id="9d85" class="oj nj iq na b gy pn ol l om on">let currentnode;</span><span id="83a6" class="oj nj iq na b gy pn ol l om on">while (currentnode = nodeIterator.nextNode()) {<br/>      <strong class="na ir">  console.log(currentnode.nodeValue);</strong><br/>    }<br/>}</span></pre><p id="40c6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这产生了，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi pq"><img src="../Images/0fb175b2af7975a314b8e829e8e05b75.png" data-original-src="https://miro.medium.com/v2/resize:fit:268/format:webp/1*2OG7bDyiNTli6ATrBsytnA.jpeg"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Output for NodeFilter.<strong class="bd pp">SHOW_TEXT</strong></figcaption></figure><p id="2691" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将在另一篇文章中讨论树行者，但这里是一个快速浏览。</p><h1 id="e6cc" class="ni nj iq bd nk nl pr nn no np ps nr ns jw pt jx nu jz pu ka nw kc pv kd ny nz bi translated">TreeWalker API</h1><blockquote class="ml mm mn"><p id="809b" class="kw kx mo ky b kz la jr lb lc ld ju le mr lg lh li mt lk ll lm mv lo lp lq lr ij bi translated">这两个接口的主要区别在于，树遍历器呈现的是子树中节点<strong class="ky ir"> </strong>的<strong class="ky ir">面向树的视图</strong>，而不是迭代器的<strong class="ky ir">面向列表的视图。</strong></p></blockquote><p id="1dea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TreeWalker还有一些额外的方法。</p><ul class=""><li id="64eb" class="oo op iq ky b kz la lc ld lf oq lj or ln os lr ot ou ov ow bi translated"><strong class="ky ir">前一个节点</strong> -(也在节点迭代器中。)移动到并返回当前节点的前一个节点。</li><li id="ec08" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated"><strong class="ky ir"> nextNode </strong> -(也在NodeIterator中。)移动到经过筛选的节点集合中的下一个节点并返回。</li><li id="992c" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated"><strong class="ky ir"> parentNode </strong> -移动并返回当前节点的父节点。</li><li id="ff9d" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated"><strong class="ky ir"> firstChild </strong> -移动并返回当前节点的第一个子节点。</li><li id="de4d" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated"><strong class="ky ir"> lastChild </strong> -移动并返回当前节点的第一个子节点。</li><li id="acee" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated"><strong class="ky ir"> previousSibling </strong> -移动并返回当前节点的前一个兄弟节点。</li><li id="16b7" class="oo op iq ky b kz ox lc oy lf oz lj pa ln pb lr ot ou ov ow bi translated"><strong class="ky ir"> nextSibling </strong> -移动到当前节点的下一个兄弟节点并返回。</li></ul><p id="f793" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">TreeWalker有四个论点。前三个与NodeIterator相同。语法是，</p><pre class="kg kh ki kj gt of na og oh aw oi bi"><span id="3f88" class="oj nj iq na b gy ok ol l om on">document.createTreeWalker(root, whatToShow, filter, <strong class="na ir">entityExpandBol</strong>)</span></pre><p id="acb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后一个参数是一个布尔参数，指定是否应该扩展实体引用。</p><p id="18d3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">示例</strong></p><p id="bf5e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用相同的index.html，但将index.js更改如下。</p><pre class="kg kh ki kj gt of na og oh aw oi bi"><span id="b2b9" class="oj nj iq na b gy ok ol l om on">window.onload = ()=&gt; {<br/>    // The starting node<br/>    getNodesStartingAt(document.querySelector('#main'));<br/>}</span><span id="6346" class="oj nj iq na b gy pn ol l om on">function getNodesStartingAt(myRoot) {</span><span id="306f" class="oj nj iq na b gy pn ol l om on">const treeWalker = document.createTreeWalker(<br/>        myRoot,<br/>       NodeFilter.SHOW_ELEMENT,<br/>        (node) =&gt; {<br/>            // ACCEPT, REJECT OR SKIP based on<br/>            // custom criteria<br/>            return NodeFilter.FILTER_ACCEPT;<br/>        }<br/>    );</span><span id="eeb0" class="oj nj iq na b gy pn ol l om on">let currentnode;<br/>    while (currentnode = treeWalker.nextNode()) {<br/>        console.log(currentnode.tagName);<br/>    }<br/> </span></pre><h1 id="1400" class="ni nj iq bd nk nl pr nn no np ps nr ns jw pt jx nu jz pu ka nw kc pv kd ny nz bi translated">结论:</h1><p id="eac8" class="pw-post-body-paragraph kw kx iq ky b kz oa jr lb lc ob ju le lf oc lh li lj od ll lm ln oe lp lq lr ij bi translated">定位全部或部分DOM树的能力对于底层检查和潜在的DOM操作非常有用。简单地说，这就是现代应用程序一直在做的事情，例如SPA。</p><p id="fe28" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">大部分功能将来自于第三个参数<strong class="ky ir">、<strong class="ky ir">定制过滤器</strong>。正是在这里，我们可以根据我们选择的任何标准来接受、拒绝或跳过。</strong></p><p id="2671" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我鼓励您尝试使用<strong class="ky ir">常量</strong>过滤器(第二个参数)、<strong class="ky ir">自定义</strong>过滤器(第三个参数)以及更复杂的HTML文档。</p><p id="d7e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">感谢您的阅读和快乐编码！</strong></p><p id="ba1a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在Medium上阅读所有你想要的文章，并通过成为Medium会员来帮助我继续写作，每月只需5美元。</p><div class="pw px gp gr py pz"><a href="https://bobtomlin-70659.medium.com/membership" rel="noopener follow" target="_blank"><div class="qa ab fo"><div class="qb ab qc cl cj qd"><h2 class="bd ir gy z fp qe fr fs qf fu fw ip bi translated">通过我的推荐链接加入灵媒——重力井(罗伯·汤姆林)</h2><div class="qg l"><h3 class="bd b gy z fp qe fr fs qf fu fw dk translated">作为一个媒体会员，你的会员费的一部分会给你阅读的作家，你可以完全接触到每一个故事…</h3></div><div class="qh l"><p class="bd b dl z fp qe fr fs qf fu fw dk translated">bobtomlin-70659.medium.com</p></div></div><div class="qi l"><div class="qj l qk ql qm qi qn kp pz"/></div></div></a></div></div></div>    
</body>
</html>