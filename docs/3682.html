<html>
<head>
<title>JavaScript Promises as a poor person’s Either Type</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript承诺穷人的两种类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-promises-as-a-poor-persons-either-type-87381d0e6a76?source=collection_archive---------6-----------------------#2020-10-17">https://javascript.plainenglish.io/javascript-promises-as-a-poor-persons-either-type-87381d0e6a76?source=collection_archive---------6-----------------------#2020-10-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0c37d19c063d15edf19cc196cbce9d47.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*aus6x9mIQ5PaFEla.png"/></div></div></figure><p id="2847" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我一直在思考如何优雅地处理同步Javascript代码中的异常。</p><p id="18ba" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我是<a class="ae kw" href="https://gcanti.github.io/fp-ts/modules/Either.ts.html" rel="noopener ugc nofollow" target="_blank">或者</a>类型和<a class="ae kw" href="https://github.com/fluture-js/Fluture" rel="noopener ugc nofollow" target="_blank">未来</a>类型的粉丝。我对什么是“正确”的看法受到在生产代码库中使用它们的严重影响。</p><h1 id="5a08" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">问题是</h1><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="d061" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我不喜欢这段代码有两个原因。</p><ol class=""><li id="7954" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated"><code class="fe mk ml mm mn b">let</code>:暗示<code class="fe mk ml mm mn b">validBreed</code>的值会随时间发生突变。本质上，它在函数上下文中创建了一些状态，并为其他人通过进一步更改<code class="fe mk ml mm mn b">let</code>来扩展它创造了空间。</li><li id="aece" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated"><code class="fe mk ml mm mn b">try-catch</code>:本质上是创建分支逻辑。也降低了代码的可读性，因为函数存在于<code class="fe mk ml mm mn b">catch</code>。</li></ol><h1 id="97ed" class="kx ky iq bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu bi translated">极端的例子</h1><p id="dc28" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">在极端情况下，这两种方法可以使代码看起来像这样:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="b2bf" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可能最终用<code class="fe mk ml mm mn b">n</code>变量来保持状态，并有多条退出路径。</p><p id="5aa3" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们可以把这些尝试捆绑在一起，但是我们能做得更好吗？</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="534e" class="kx ky iq bd kz la nf lc ld le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu bi translated">输入承诺</h1><p id="4d64" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我知道承诺是不同步的，但请迁就我一下:</p><figure class="lv lw lx ly gt jr"><div class="bz fp l di"><div class="lz ma l"/></div></figure><p id="caf0" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不可否认，从事件循环中不断推迟会使运行速度变慢。(异步代码中的上下文切换成本更高)。有多慢？非常。下面是您可以自己进行的<a class="ae kw" href="https://jsbench.me/ybkg9y1kdq/1" rel="noopener ugc nofollow" target="_blank">基准测试</a>。你会注意到它几乎慢了一倍。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="af84" class="kx ky iq bd kz la nf lc ld le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu bi translated">我觉得有些事情是对的</h1><p id="d10a" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">我第一个承认:故意给同步代码增加上下文切换开销听起来很糟糕。</p><p id="483a" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但我也认为这种方法也有一些优点:</p><ol class=""><li id="f9a2" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">使用链式承诺语法可以避免共享可变状态。(从我的代码中消除状态是我的一个成功之处)</li><li id="64ed" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">它提高了代码的可读性。很容易推断出没有<code class="fe mk ml mm mn b">let</code>的代码。</li><li id="ed4d" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">不管是同步代码还是异步代码，代码都是一样的。</li><li id="9b37" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">代码写起来更简单。(如果您需要引入额外的错误处理，只需在承诺链中插入一个额外的<code class="fe mk ml mm mn b">catch</code></li></ol><p id="40f5" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">此外，上下文切换开销在实际应用中可能不是问题:</p><ol class=""><li id="e9a9" class="mb mc iq ka b kb kc kf kg kj md kn me kr mf kv mg mh mi mj bi translated">如果您使用JavaScript执行计算密集型任务，那么您可能做错了。(阅读:不要阻塞事件循环)</li><li id="0e77" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">JavaScript程序的主线程大部分时间都处于空闲状态。</li><li id="90c7" class="mb mc iq ka b kb mo kf mp kj mq kn mr kr ms kv mg mh mi mj bi translated">无论是每秒50，000，000次操作还是每秒25，000，000次操作，对于IO密集型使用情形来说都没有什么区别。</li></ol></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><h1 id="1bea" class="kx ky iq bd kz la nf lc ld le ng lg lh li nh lk ll lm ni lo lp lq nj ls lt lu bi translated">你应该这样写代码吗？</h1><p id="e247" class="pw-post-body-paragraph jy jz iq ka b kb mt kd ke kf mu kh ki kj mv kl km kn mw kp kq kr mx kt ku kv ij bi translated">这绝对感觉像是效率和可读性之间的权衡。所以，我不确定。</p><p id="599d" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">理想情况下，如果一个函数返回non-T0，那么拥有一个不会延迟的本机promise构造就更好了。</p></div><div class="ab cl my mz hu na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ij ik il im in"><p id="9c7c" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><em class="nk">原载于</em><a class="ae kw" href="https://nadeeshacabral.com/projects/blogging/promises-poor-mans-either-type/" rel="noopener ugc nofollow" target="_blank"><em class="nk">【nadeeshacabral.com】</em></a></p></div></div>    
</body>
</html>