<html>
<head>
<title>.setState() Not Working? Shallow Copy vs Deep Copy &amp; Lodash</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">。setState()不起作用？浅层拷贝与深层拷贝&amp; Lodash</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/setstate-not-working-shallow-copy-vs-deep-copy-lodash-55a015db80ff?source=collection_archive---------2-----------------------#2019-09-10">https://javascript.plainenglish.io/setstate-not-working-shallow-copy-vs-deep-copy-lodash-55a015db80ff?source=collection_archive---------2-----------------------#2019-09-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="7e3b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在React和Redux中，当你试图更新状态时，有时它就是不起作用。也许它已经在其他案例中发挥了作用。当你通过[…预操作符]、Object.assign()和任何其他你能在互联网上找到的复制方法时，你开始质疑你的理智。不幸的是，问题不在于你的复制方法，而在于你的复制类型——你可能需要深层复制而不是浅层复制。</p><blockquote class="kl km kn"><p id="20ef" class="jn jo ko jp b jq jr js jt ju jv jw jx kp jz ka kb kq kd ke kf kr kh ki kj kk ij bi translated">这里的例子具体到React和Redux，但是理解浅层和深层副本是有价值的计算机科学知识，Lodash可以用于任何JavaScript项目。</p></blockquote><h1 id="11df" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">浅层拷贝与深层拷贝</h1><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi lq"><img src="../Images/f4194ceda93180c8e40c231e6cbf2b01.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*n5NA8Op9izHrHHgIVs6Cmg.jpeg"/></div></figure><p id="ada6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如上图所示，浅层拷贝(或“克隆”)只引用原始对象内部的对象，但深层克隆也会克隆内部对象。换句话说，浅层克隆只复制对象的顶层。让我们将其与现实生活中的例子进行比较。</p><h2 id="52c6" class="ly kt iq bd ku lz ma dn ky mb mc dp lc jy md me lg kc mf mg lk kg mh mi lo mj bi translated">浅拷贝</h2><p id="fcbf" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">假设你第一次有了自己的网飞账户，所以你没有喜欢的节目或电影。你向你最好的朋友寻求建议，你喜欢你朋友列表上的每一个网飞项目。(这比制作浅层克隆要多得多，所以忽略这部分。)现在你和你的朋友在网飞有了相同的“我的清单”。</p><p id="84e6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你复制了你朋友的名单。它们是独立的，您可以在自己的列表中添加或删除节目，而不会影响其他人的列表。然而，它们是肤浅的，因为它们引用相同的对象——也就是说，如果网飞出于某种原因改变了列表中的某个对象，该对象也会在您的列表和您朋友的列表中被改变。你没有自己制作电影和电视剧的拷贝。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mp"><img src="../Images/2ecfb8cdda4b05788defcd3b9a65b520.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XDtpJslHgTWwWbsmcG5Y9g.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">If you copy my Netflix, it is a shallow copy, because you are not making copies of each program. Changes to the shows and programs will also change your list.</figcaption></figure><h2 id="5e1e" class="ly kt iq bd ku lz ma dn ky mb mc dp lc jy md me lg kc mf mg lk kg mh mi lo mj bi translated">深层拷贝</h2><p id="ed5c" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">另一方面，大多数技术以外的例子都是深度拷贝。如果你复制了一份家庭食谱，你可以像上面的浅层副本一样添加和删除配料，但你也可以改变预先存在的配料而不影响食谱的其他副本。如果我决定我的胡萝卜蛋糕需要的葡萄干比我妈妈的少，改变我食谱上的葡萄干数量不会改变我妈妈的食谱上的数量。这是一份深度拷贝。</p><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div class="gh gi my"><img src="../Images/63b6048b9f92d8335bfd8d7bc04b6576.png" data-original-src="https://miro.medium.com/v2/resize:fit:998/format:webp/1*mJ6ny11ZHLVpDGidoTmdCg.jpeg"/></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">This recipe is a deep copy — changing the objects inside this recipe will not change the original recipe.</figcaption></figure><h2 id="fa88" class="ly kt iq bd ku lz ma dn ky mb mc dp lc jy md me lg kc mf mg lk kg mh mi lo mj bi translated">摘要</h2><p id="0aff" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">浅层副本包含引用，深层副本包含这些引用的自身副本。</p><h1 id="dd63" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">为什么它很重要</h1><p id="370f" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">在React和Redux中，您的应用程序只有在通过检测到状态变化时才会更新。setState()或reducer。浅层拷贝可以在调用这两个状态之前改变状态<em class="ko">，所以当它们被调用时，旧的状态看起来等于新的状态，并且你的元素不会被更新。</em></p><p id="69fa" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这就是为什么(您可能已经注意到了)，当您在更新状态时遇到问题时，在应该更新的状态<em class="ko">之前使用console.log()会显示状态已经更改为您想要的更新。但是因为这发生在错误的时间，React和Redux不会注意到它，您也不会在页面上看到结果。</em></p><h1 id="6b2e" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">修复方法——洛达什</h1><figure class="lr ls lt lu gt lv gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mz"><img src="../Images/9c4079060accac5ba644d34a2ca9e80d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*sYsvMuoRbScpLd-LvZaJJw.png"/></div></div><figcaption class="mu mv gj gh gi mw mx bd b be z dk">The Lodash Logo</figcaption></figure><p id="249c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Lodash附带React，但是如果它不在您的包lock.json中，您可以使用NPM轻松地添加它。</p><pre class="lr ls lt lu gt na nb nc nd aw ne bi"><span id="971e" class="ly kt iq nb b gy nf ng l nh ni">npm i -g npm</span><span id="9710" class="ly kt iq nb b gy nj ng l nh ni">npm i --save lodash</span></pre><p id="1312" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果这不起作用，试试Lodash.com的<a class="ae nk" href="https://lodash.com/" rel="noopener ugc nofollow" target="_blank">或搜索互联网。接下来，定义</a></p><pre class="lr ls lt lu gt na nb nc nd aw ne bi"><span id="0a7f" class="ly kt iq nb b gy nf ng l nh ni"><em class="ko">var</em> _ = require('lodash');</span></pre><p id="badc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我的类组件中，我必须在类之外定义它。是的，变量名是“_”明白了吗？洛达什？这是一个低破折号！</p><p id="a3cc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">最后，如果需要深度克隆，只需使用</p><pre class="lr ls lt lu gt na nb nc nd aw ne bi"><span id="71a8" class="ly kt iq nb b gy nf ng l nh ni">_.cloneDeep(theObjectThatNeedsCloningHere)</span></pre><h1 id="7a12" class="ks kt iq bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp bi translated">结论</h1><p id="f19f" class="pw-post-body-paragraph jn jo iq jp b jq mk js jt ju ml jw jx jy mm ka kb kc mn ke kf kg mo ki kj kk ij bi translated">尝试一下这个函数，感受一下它是如何工作的。持续关注对象内部的对象在深层和浅层拷贝中的反应。总的来说，这种方法帮助我更快地写出成功的代码，并使我的代码更容易阅读。</p><p id="c319" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">编码快乐！</p></div></div>    
</body>
</html>