<html>
<head>
<title>How to handle and design the startup of a React application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何处理和设计React应用程序的启动</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-handle-and-design-the-startup-of-a-react-application-da779f3727e5?source=collection_archive---------1-----------------------#2019-10-25">https://javascript.plainenglish.io/how-to-handle-and-design-the-startup-of-a-react-application-da779f3727e5?source=collection_archive---------1-----------------------#2019-10-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="50c5" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">这也适用于React Native！</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/7a6f8b0473c46f461dde1004a0e7c842.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I3ZCjvTAtEkUbIekz-S7IA.png"/></div></div></figure><p id="ddf2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在构建基于react的应用程序时，一旦用户到达，您可能希望在显示界面之前做一些事情:</p><ul class=""><li id="b0db" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm ls lt lu lv bi translated">加载/预加载远程内容或资源。</li><li id="c122" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">确保用户身份验证。</li><li id="5668" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">初始化上下文。</li><li id="3fa3" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm ls lt lu lv bi translated">无论如何…</li></ul><p id="502b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这很常见！有时候异步完成这个任务没有问题，但是通常你想阻止用户界面，并且在完成之前显示一个闪屏。</p><p id="504c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一些应用程序所有者还希望在显示应用程序内容之前，在同一个闪屏上显示公司徽标几秒钟。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><p id="e9fb" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">今天，我想根据我在各种基于移动/独立PWA的应用程序中的经验，与您分享一种处理此类需求的方法。</p><p id="f08d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">大部分是在我在<a class="mi mj ep" href="https://medium.com/u/bc4d66204c48?source=post_page-----da779f3727e5--------------------------------" rel="noopener" target="_blank"> Kaliop </a>的技术领导角色范围内实现的。</p><h1 id="514e" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">为什么我应该在应用程序启动时显示加载屏幕而不是静态屏幕？</h1><p id="f600" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated"><strong class="kt ir">静态加载屏幕经常会让用户误以为应用程序在启动时冻结了</strong>。这真的不是你想要的！这就是为什么建议展示装载机。</p><p id="872b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">加载屏幕应该在视觉上有趣，贯穿品牌元素，并向用户提供足够的加载进度反馈。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nh"><img src="../Images/0cceeae3f3555086096080b8012f6eaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*SimNAN6cDmXdXWfa.gif"/></div></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">8tracks application</figcaption></figure><h1 id="adbd" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">如何显示一个加载动画，并在长时间强制进程没有加载时阻止UI显示？</h1><h2 id="640d" class="nm ml iq bd mm nn no dn mq np nq dp mu la nr ns mw le nt nu my li nv nw na nx bi translated">我们可以使用加载组件和重定向？</h2><p id="842a" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">很长一段时间以来，我一直在做一个特定的加载组件，它单独安装，并在加载完成后使用导航界面重定向，虽然这在react native和<code class="fe ny nz oa ob b">react-navigation</code>上工作得很好，但对于web应用程序来说，它变得复杂了，因为入口点是多个的，并且取决于URL。</p><p id="06df" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这就是为什么我强烈推荐下面的方法，它适用于任何情况。</p><h2 id="880b" class="nm ml iq bd mm nn no dn mq np nq dp mu la nr ns mw le nt nu my li nv nw na nx bi translated">我们应该构建一个包装组件，并使用状态管理策略。</h2><p id="bde0" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">该模式将使用一个包装组件，当一些进程在后台加载时，该组件将阻止UI并显示另一个加载组件。这是你的动画和标志将被使用的地方。</p><p id="2742" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们将把这个实现分成三个独立的部分:</p><ol class=""><li id="dd52" class="ln lo iq kt b ku kv kx ky la lp le lq li lr lm oc lt lu lv bi translated">逻辑发生的<code class="fe ny nz oa ob b">Apploader</code>组件。</li><li id="fcaf" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm oc lt lu lv bi translated">流程提供者组件，通常是主要的应用程序组件，我们称之为<strong class="kt ir"> AppStartupOrchestrator。</strong></li><li id="31d4" class="ln lo iq kt b ku lw kx lx la ly le lz li ma lm oc lt lu lv bi translated">并且加载组件显示您的动画，为了清楚起见，在那篇文章中将不处理这一部分。</li></ol><p id="e73f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">💡<em class="od">下面所有的组件都是使用</em> <code class="fe ny nz oa ob b"><em class="od">typescript</em></code> <em class="od">编写的，这是一个由</em> <strong class="kt ir"> <em class="od">微软</em> </strong> <em class="od">提供的Javascript超集，它允许静态类型。在Javascript中，这非常类似，所以可以随意使用这样的工具将以下代码片段转换为JS ES2015代码:</em><a class="ae oe" href="http://www.typescriptlang.org/play/" rel="noopener ugc nofollow" target="_blank"><em class="od">http://www.typescriptlang.org/play/</em></a><em class="od">。</em></p><p id="1608" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="od">另外，在你的编辑器中随意复制代码片段来突出语法。</em></p><h1 id="f8a7" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">我们的应用程序加载过程的实现</h1><h2 id="d445" class="nm ml iq bd mm nn no dn mq np nq dp mu la nr ns mw le nt nu my li nv nw na nx bi translated">主加载程序组件(Apploader.tsx)</h2><p id="c58a" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">该组件将接受一系列强制进程，并且只要每个进程没有准备好，就会显示我们的加载器动画。</p><p id="2e26" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们的应用程序组件是该视图的子视图，在我们的示例中，我们将看到App router是第一个子视图。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">AppLoader.tsx</figcaption></figure><p id="2941" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在一切都在加载，同时，您可以看到，只要每个进程没有处于就绪状态，应用程序就会显示我们的加载器闪屏。一旦发生变化，组件的子组件将被填充，应用程序将运行，从这一刻开始，可以肯定地说，每个强制流程数据都已定义并可访问。</p><p id="78dc" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">📦奖励:最短持续时间拦截器</strong></p><p id="acfd" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">上面的代码片段附带了一个小功能，它将确保加载程序至少显示XXXX毫秒，有时你的应用程序加载太快，你会错过你可能想看到的加载状态。</p><h2 id="c871" class="nm ml iq bd mm nn no dn mq np nq dp mu la nr ns mw le nt nu my li nv nw na nx bi translated">流程编排器及其加载挂钩(<strong class="ak">appstartuporchestrator . tsx+</strong>usefavoritecountry . tsx<strong class="ak">)</strong></h2><p id="9bb2" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">对于加载任务，我建议使用一些钩子来返回某种空值和一个最终值，一旦动作加载被处理，这个最终值就不为空。</p><p id="c661" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">🔗装载钩示例</strong></p><p id="c717" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">正如你在下面的例子中看到的，<code class="fe ny nz oa ob b">favoriteCountry</code>将返回是否是<code class="fe ny nz oa ob b">CountrySelectionStatus.NotChosen</code>、<code class="fe ny nz oa ob b">CountrySelectionStatus.Loading</code>或者一个代表国家代码的字符串。</p><p id="c879" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们有3种状态可以用来定义我们的装载状态。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">useFavoriteCountry.tsx</figcaption></figure><p id="cce3" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这个例子中，我们使用了<code class="fe ny nz oa ob b">to</code>库中的一个函数<a class="ae oe" href="https://www.npmjs.com/package/await-to-js" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> await-to-js </strong> </a>用来以一种更简单的方式处理来自Promise的错误。</p><p id="b998" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">🎼管弦乐队(App.tsx) </strong></p><p id="d977" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在我们的应用程序根级组件中，我们可以有这样的内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="of og l"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">App.tsx</figcaption></figure><p id="8cba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">如您所见，我们正在使用上面刚刚创建的钩子，只要状态为正在加载，就绪就是<code class="fe ny nz oa ob b">false</code>，就将其添加到加载进程列表中，但是一旦发生这种变化，<code class="fe ny nz oa ob b">ready</code>就是<code class="fe ny nz oa ob b">true</code>，这将触发显示我们的<code class="fe ny nz oa ob b">AppLoader</code>子进程。此外，我们在生产中增加了2秒的最短持续时间，以防我们最喜欢的国家流程比这少。</p><h2 id="5069" class="nm ml iq bd mm nn no dn mq np nq dp mu la nr ns mw le nt nu my li nv nw na nx bi translated">🚀如何提高装载任务的性能？</h2><p id="e8f2" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">考虑离线支持和加载性能优化的缓存策略。依靠缓存优先策略可以显著缩短应用程序加载最新数据的时间，同时从网络中收集新数据。</p></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><h1 id="93eb" class="mk ml iq bd mm mn oh mp mq mr oi mt mu jw oj jx mw jz ok ka my kc ol kd na nb bi translated">更进一步:</h1><p id="f42a" class="pw-post-body-paragraph kr ks iq kt b ku nc jr kw kx nd ju kz la ne lc ld le nf lg lh li ng lk ll lm ij bi translated">上面的模型非常简单但是有效，你可以通过添加可选的进程来在你的加载屏幕上显示一些指示器，你也可以处理错误消息显示，甚至是一个完成进度条。</p><p id="10a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">想深入动画设计？让我们在react官方<a class="ae oe" href="https://facebook.github.io/react-native/blog/2018/01/18/implementing-twitters-app-loading-animation-in-react-native" rel="noopener ugc nofollow" target="_blank">博客查看一个不错的样本:https://Facebook . github . io/react-native/blog/2018/01/18/implementing-twitters-app-loading-animation-in-react-native</a></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi om"><img src="../Images/2ccfa64d5a52af1e862347967c6fbaa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:600/0*FRzNP65-MOLsm7-K.gif"/></div><figcaption class="ni nj gj gh gi nk nl bd b be z dk">Twitter loading animation in react-native</figcaption></figure></div><div class="ab cl mb mc hu md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="on og l"/></div></figure><p id="cf1d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae oe" href="https://codingspark.io" rel="noopener ugc nofollow" target="_blank"> <strong class="kt ir"> 🇫🇷STOP！你是法国人吗🥖？您也可以访问ici网站，接收法国的私人通讯🙂</strong></a></p></div></div>    
</body>
</html>