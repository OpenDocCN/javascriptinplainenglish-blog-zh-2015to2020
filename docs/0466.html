<html>
<head>
<title>How to make an image uploading app with Vue, Quasar, Firebase Storage and Cordova — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Vue、Quasar、Firebase Storage和Cordova制作一个图片上传应用程序——第二部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-make-an-image-uploading-app-with-vue-quasar-firebase-storage-and-cordova-part-2-88bb719cea5a?source=collection_archive---------2-----------------------#2019-10-20">https://javascript.plainenglish.io/how-to-make-an-image-uploading-app-with-vue-quasar-firebase-storage-and-cordova-part-2-88bb719cea5a?source=collection_archive---------2-----------------------#2019-10-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="1253" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">我们正在建造的东西</h1><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div></figure><p id="3613" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们将构建一个跨平台的移动应用程序，用于拍摄照片并上传到firebase。</p><p id="2079" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在<a class="ae lq" href="https://medium.com/javascript-in-plain-english/how-to-make-an-image-uploading-app-with-vue-quasar-firebase-storage-and-cordova-part-1-232b68755d0c" rel="noopener"> Part 1 </a>中，我们看到了如何拍摄照片并保存到Firebase云存储中。在这篇文章中，我们将通过web worker将上传转移到一个单独的线程，并使用blueimp库在本地生成一个缩略图，并在上传时显示它。</p><h1 id="2cd5" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">网络工作者</h1><h2 id="e11d" class="lr jo iq bd jp ls lt dn jt lu lv dp jx ld lw lx kb lh ly lz kf ll ma mb kj mc bi translated">什么是网络工作者</h2><blockquote class="md me mf"><p id="c58d" class="ks kt mg ku b kv kw kx ky kz la lb lc mh le lf lg mi li lj lk mj lm ln lo lp ij bi translated">Web Workers是Web内容在后台线程中运行脚本的一种简单方式。工作线程可以在不干扰用户界面的情况下执行任务。(<a class="ae lq" href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" rel="noopener ugc nofollow" target="_blank">mozilla.org</a>)</p></blockquote><p id="152b" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">因此，我们将使用一个web worker将可能阻塞我们的UI线程的代码(在我们的例子中是Firebase存储代码)卸载到另一个线程。</p><h2 id="0afb" class="lr jo iq bd jp ls lt dn jt lu lv dp jx ld lw lx kb lh ly lz kf ll ma mb kj mc bi translated">配置工作化加载程序</h2><p id="0675" class="pw-post-body-paragraph ks kt iq ku b kv mk kx ky kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp ij bi translated">我们将使用<a class="ae lq" href="https://github.com/developit/workerize-loader" rel="noopener ugc nofollow" target="_blank"> workerize-loader </a>来使使用web workers变得更容易一些(web workers接口有点奇怪)。</p><pre class="kl km kn ko gt mp mq mr ms aw mt bi"><span id="f98f" class="lr jo iq mq b gy mu mv l mw mx">yarn add workerize-loader</span></pre><p id="0eee" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们需要添加一些webpack配置来告诉webpack使用<code class="fe my mz na mq b">workerize-loader</code>。在<code class="fe my mz na mq b">quasar.conf.js</code>的<code class="fe my mz na mq b">build</code>部分添加:</p><pre class="kl km kn ko gt mp mq mr ms aw mt bi"><span id="daa1" class="lr jo iq mq b gy mu mv l mw mx">extendWebpack(cfg) {<br/>    cfg.module.rules.push({<br/>        test: /\.worker\.js$/,<br/>        loader: 'workerize-loader',<br/>    })<br/>},<br/><br/>chainWebpack (chain, { isServer, isClient }) {<br/>    chain.output.globalObject('self')<br/>}</span></pre><p id="c1a4" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这告诉webpack使用<code class="fe my mz na mq b">workerize-loader</code>加载文件<code class="fe my mz na mq b">worker.js</code>。</p><h2 id="6d7b" class="lr jo iq bd jp ls lt dn jt lu lv dp jx ld lw lx kb lh ly lz kf ll ma mb kj mc bi translated">将代码转移到工作线程</h2><p id="a628" class="pw-post-body-paragraph ks kt iq ku b kv mk kx ky kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp ij bi translated">让我们添加文件<code class="fe my mz na mq b">src/services/worker.js</code>，并将我们的上传代码移入其中:</p><pre class="kl km kn ko gt mp mq mr ms aw mt bi"><span id="250f" class="lr jo iq mq b gy mu mv l mw mx">import cloudStorage from './cloud-storage'<br/><br/>export async function uploadPicture(imageData) {<br/>    let storageId = new Date().getTime().toString();<br/><br/>    let downloadURL = await cloudStorage.uploadBase64(<br/>        imageData,<br/>        storageId<br/>    );<br/><br/>    return {<br/>        storageId,<br/>        downloadURL,<br/>    }<br/>}<br/><br/>export function initFB() {<br/>    cloudStorage.initialize();<br/>}<br/><br/>export async function deletePic(storageId) {<br/>    await cloudStorage.deleteFromStorage(storageId)<br/>}</span></pre><p id="d6bc" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们还添加了一个<code class="fe my mz na mq b">deletePic</code>调用，稍后我们将在<code class="fe my mz na mq b">cloudStorage.js</code>中看到。</p><h1 id="54fd" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">添加简单的状态管理</h1><p id="722a" class="pw-post-body-paragraph ks kt iq ku b kv mk kx ky kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp ij bi translated">我们希望创建一个worker实例，并将其保存在应用程序的状态中。我们还没有状态管理，所以让我们使用一个<code class="fe my mz na mq b">store.js</code>文件添加一个简单的状态管理模式:</p><pre class="kl km kn ko gt mp mq mr ms aw mt bi"><span id="309d" class="lr jo iq mq b gy mu mv l mw mx">import worker from "workerize-loader!./worker.js";<br/><br/>var store = {<br/>    debug: true,<br/>    state: {<br/>        pics: [],<br/>        uploading: false<br/>    },<br/>    initWorker() {<br/>        this.state.workerInstance = worker();<br/>        this.state.workerInstance.initFB();<br/>    },<br/>    async loadPictures() {<br/>        if (this.debug) console.log("loadPictures triggered")<br/>        let picsJson = await localStorage.getItem("pics");<br/>        if (!picsJson) this.state.pics = [];<br/>        else this.state.pics = JSON.parse(picsJson);<br/>        this.state.pics = this.state.pics.filter(pic =&gt; !pic.uploading)<br/>    },<br/>    async addPic(pic) {<br/>        if (this.debug) console.log("addPic triggered with", pic)<br/><br/>        pic.failed = false;<br/>        this.state.pics.splice(0, 0, pic);<br/>        localStorage.setItem("pics", JSON.stringify(this.state.pics));<br/>    },<br/>    async deletePic(idx) {<br/>        if (this.debug) console.log("deletePic triggered with", idx)<br/><br/>        this.state.pics[idx].uploading = true;<br/><br/>        if (this.state.pics[idx].storageId) {<br/>            await this.state.workerInstance.deletePic(this.state.pics[idx].storageId)<br/>        }<br/>        this.state.pics.splice(idx, 1);<br/>        localStorage.setItem("pics", JSON.stringify(this.state.pics));<br/>    },<br/>    async updatePicUploaded(oldPic, newPic) {<br/>        if (this.debug) console.log("updatePicUploaded triggered with", oldPic, newPic)<br/><br/>        oldPic.uploading = false<br/>        oldPic.url = newPic.downloadURL<br/>        oldPic.storageId = newPic.storageId<br/>        oldPic.width = newPic.width<br/>        oldPic.height = newPic.height<br/><br/>        localStorage.setItem("pics", JSON.stringify(this.state.pics));<br/>    },<br/>    async updatePicFailed(pic) {<br/>        if (this.debug) console.log("updatePicFailed triggered with", pic)<br/><br/>        pic.failed = true<br/>    },<br/>}<br/><br/>export default {<br/>    ...store<br/>}</span></pre><p id="5d3d" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这里发生了一些事情:</p><ul class=""><li id="07ed" class="nb nc iq ku b kv kw kz la ld nd lh ne ll nf lp ng nh ni nj bi translated">我们使用前缀<code class="fe my mz na mq b">workerize-loader!</code>导入我们的worker，它告诉webpack使用我们之前配置的加载器。</li><li id="9ddc" class="nb nc iq ku b kv nk kz nl ld nm lh nn ll no lp ng nh ni nj bi translated">我们将<code class="fe my mz na mq b">pics</code>集合从<code class="fe my mz na mq b">Index.vue</code>移动到了<code class="fe my mz na mq b">state</code>对象。</li><li id="62d2" class="nb nc iq ku b kv nk kz nl ld nm lh nn ll no lp ng nh ni nj bi translated">我们公开了初始化worker实例的方法<code class="fe my mz na mq b">initWorker</code>。</li><li id="47ef" class="nb nc iq ku b kv nk kz nl ld nm lh nn ll no lp ng nh ni nj bi translated">我们在<code class="fe my mz na mq b">localStorage</code> : <code class="fe my mz na mq b">addPic</code>、<code class="fe my mz na mq b">loadPictures</code>和<code class="fe my mz na mq b">delete</code>中添加了一些CRUD方法来持久化<code class="fe my mz na mq b">pics</code>集合。</li><li id="a84b" class="nb nc iq ku b kv nk kz nl ld nm lh nn ll no lp ng nh ni nj bi translated"><code class="fe my mz na mq b">updatePicUploaded</code>和<code class="fe my mz na mq b">updatePicFailed</code>改变图片的<code class="fe my mz na mq b">loading</code>属性。我们将使用它来显示微调器。</li></ul><h1 id="b689" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">生成缩略图</h1><p id="744f" class="pw-post-body-paragraph ks kt iq ku b kv mk kx ky kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp ij bi translated">我们将生成一个缩略图(在客户端上)在图像上传时显示。为此，我们将使用<a class="ae lq" href="https://www.npmjs.com/package/blueimp-load-image" rel="noopener ugc nofollow" target="_blank"> blueimp </a>库:</p><pre class="kl km kn ko gt mp mq mr ms aw mt bi"><span id="cda7" class="lr jo iq mq b gy mu mv l mw mx">yarn add blueimp-load-image</span></pre><p id="fc78" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">让我们添加另一个操作图像的服务:<code class="fe my mz na mq b">src/services/image-ops.js</code>:</p><pre class="kl km kn ko gt mp mq mr ms aw mt bi"><span id="4095" class="lr jo iq mq b gy mu mv l mw mx">import loadImage from 'blueimp-load-image'<br/><br/>const base64JpegPrefix = "data:image/jpeg;base64,";<br/><br/>function removeBase64Prefix(base64Str) {<br/>    return base64Str.substr(base64Str.indexOf(",") + 1);<br/>}<br/><br/>function addBase64Prefix(imageData) {<br/>    return base64JpegPrefix + imageData<br/>}<br/><br/>async function generateThumbnail(imageData, maxWidth) {<br/>    return new Promise(async resolve =&gt; {<br/>        let url = base64JpegPrefix + imageData<br/>        let res = await fetch(url)<br/>        let blob = await res.blob()<br/><br/>        loadImage(<br/>            blob,<br/>            (canvas) =&gt; {<br/>                let dataURL = canvas.toDataURL('image/jpeg');<br/>                resolve(removeBase64Prefix(dataURL));<br/>            }, {<br/>                maxWidth: maxWidth,<br/>                canvas: true<br/>            }<br/>        );<br/>    });<br/>}<br/><br/><br/>export default {<br/>    removeBase64Prefix,<br/>    generateThumbnail,<br/>    addBase64Prefix,<br/>};</span></pre><p id="04f7" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">注意，我们在这里移动了<code class="fe my mz na mq b">removeBase64Prefix</code>和<code class="fe my mz na mq b">addBase64Prefix</code>方法。<code class="fe my mz na mq b">generateThumbnail</code>函数获取imageData -一个base64字符串，使用<code class="fe my mz na mq b">fetch</code> API，将其转换为<code class="fe my mz na mq b">blob</code>，然后使用blueimp的<code class="fe my mz na mq b">loadImage</code>将其大小更改为<code class="fe my mz na mq b">maxWidth</code>。我们正在从一个新的配置文件中加载<code class="fe my mz na mq b">maxWidth</code>，为了使事情变得整洁，我们已经添加了这个文件- <code class="fe my mz na mq b">src/services/config.js</code>:</p><pre class="kl km kn ko gt mp mq mr ms aw mt bi"><span id="f86f" class="lr jo iq mq b gy mu mv l mw mx">export default {<br/>    photos: {<br/>        maxWidth: 1000,<br/>        thumbnailMaxWidth: 30<br/>    }<br/>}</span></pre><h1 id="24b4" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">添加图像上传服务</h1><p id="276b" class="pw-post-body-paragraph ks kt iq ku b kv mk kx ky kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp ij bi translated">我们将把所有的图片上传流提取到一个服务中，以保持UI组件的整洁。添加文件<code class="fe my mz na mq b">src/services/image-uploader.js</code>:</p><pre class="kl km kn ko gt mp mq mr ms aw mt bi"><span id="cb23" class="lr jo iq mq b gy mu mv l mw mx">import store from "./store";<br/>import cordovaCamera from "./cordova-camera";<br/>import imageOps from "./image-ops";<br/>import config from "./config";<br/><br/><br/>async function uploadImageFromCamera() {<br/>    let base64 = await cordovaCamera.getBase64FromCamera();<br/><br/>    let imageData = imageOps.removeBase64Prefix(base64);<br/><br/>    let thumbnailImageData = await imageOps.generateThumbnail(<br/>        imageData,<br/>        config.photos.thumbnailMaxWidth<br/>    );<br/><br/>    let localPic = {<br/>        url: imageOps.addBase64Prefix(thumbnailImageData),<br/>        uploading: true<br/>    };<br/>    store.addPic(localPic);<br/><br/>    let uploadedPic = await store.state.workerInstance.uploadPicture(<br/>        imageData<br/>    );<br/>    store.updatePicUploaded(localPic, uploadedPic);<br/>}<br/><br/>export default {<br/>    uploadImageFromCamera<br/>}</span></pre><p id="e0da" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">我们在<code class="fe my mz na mq b">uploadImageFromCamera</code>方法中所做的是:从cordova相机中获取base64-&gt;使用我们的<code class="fe my mz na mq b">imageOps</code> - &gt;生成缩略图，使用<code class="fe my mz na mq b">uploading=true</code> - &gt;在<code class="fe my mz na mq b">state</code>中生成一个新的<code class="fe my mz na mq b">pic</code>对象，使用web worker - &gt;将图片上传到Firebase，当上传完成时更新pic的<code class="fe my mz na mq b">uploading</code>状态属性。</p><h1 id="ea7b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">把它放在一起</h1><p id="f55d" class="pw-post-body-paragraph ks kt iq ku b kv mk kx ky kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp ij bi translated">现在我们已经添加了所有这些服务，我们需要从我们的组件中调用它们。</p><p id="4e39" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">在<code class="fe my mz na mq b">App.vue</code>中，我们将使用<code class="fe my mz na mq b">mounted</code>生命周期钩子来初始化worker，并从保存状态加载保存的图片URL:</p><pre class="kl km kn ko gt mp mq mr ms aw mt bi"><span id="f9b3" class="lr jo iq mq b gy mu mv l mw mx">&lt;template&gt;<br/>  &lt;div id="q-app"&gt;<br/>    &lt;router-view /&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>import store from "./services/store.js";<br/><br/>export default {<br/>  name: "App",<br/>  async mounted() {<br/>    store.initWorker();<br/>    store.loadPictures();<br/>  }<br/>};<br/>&lt;/script&gt;<br/><br/>&lt;style&gt;<br/>&lt;/style&gt;</span></pre><p id="32a0" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">最后，我们将在<code class="fe my mz na mq b">Index.vue</code>中添加查看这一切的界面:</p><pre class="kl km kn ko gt mp mq mr ms aw mt bi"><span id="9f42" class="lr jo iq mq b gy mu mv l mw mx">&lt;template&gt;<br/>  &lt;q-page class&gt;<br/>    &lt;div class="q-pa-md"&gt;<br/>      &lt;div class="row justify-center q-ma-md" v-for="(pic, idx) in pics" :key="idx"&gt;<br/>        &lt;div class="col"&gt;<br/>          &lt;q-card v-if="pic"&gt;<br/>            &lt;q-img spinner-color="white" :src="pic.url"&gt;<br/>              &lt;div class="spinner-container" v-if="pic.uploading &amp;&amp; !pic.failed"&gt;<br/>                &lt;q-spinner color="white" size="4em" /&gt;<br/>              &lt;/div&gt;<br/>              &lt;div class="spinner-container" v-if="pic.failed"&gt;<br/>                &lt;q-icon name="cloud_off" style="font-size: 48px;"&gt;&lt;/q-icon&gt;<br/>              &lt;/div&gt;<br/>            &lt;/q-img&gt;<br/>            &lt;q-card-actions align="around"&gt;<br/>              &lt;q-btn flat round color="red" icon="favorite" @click="notifyNotImplemented()" /&gt;<br/>              &lt;q-btn flat round color="teal" icon="bookmark" @click="notifyNotImplemented()" /&gt;<br/>              &lt;q-btn<br/>                flat<br/>                round<br/>                color="primary"<br/>                icon="delete"<br/>                @click="deletePic(idx)"<br/>                :disable="pic.uploading"<br/>              /&gt;<br/>            &lt;/q-card-actions&gt;<br/>          &lt;/q-card&gt;<br/>        &lt;/div&gt;<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  &lt;/q-page&gt;<br/>&lt;/template&gt;<br/><br/>&lt;style scoped&gt;<br/>.spinner-container {<br/>  display: flex;<br/>  align-items: center;<br/>  justify-content: center;<br/>  width: 100%;<br/>  height: 100%;<br/>}<br/><br/>&lt;/style&gt;<br/><br/>&lt;script&gt;<br/>import store from "../services/store";<br/>import { EventBus } from "../services/event-bus";<br/>import imageUploader from "../services/image-uploader";<br/><br/>export default {<br/>  name: "PageIndex",<br/>  data() {<br/>    return {<br/>      state: store.state<br/>    };<br/>  },<br/>  mounted() {<br/>    EventBus.$off("takePicture");<br/>    EventBus.$on("takePicture", this.uploadImageFromCamera);<br/>  },<br/>  computed: {<br/>    pics() {<br/>      return this.state.pics;<br/>    }<br/>  },<br/>  methods: {<br/>    notifyNotImplemented() {<br/>      this.$q.notify({ message: "Not implemented yet :/" });<br/>    },<br/>    async deletePic(idx) {<br/>      try {<br/>        await store.deletePic(idx);<br/>        this.$q.notify({ message: "Picture deleted." });<br/>      } catch (err) {<br/>        console.error(err);<br/>        this.$q.notify({ message: "Delete failed. Check log." });<br/>      }<br/>    },<br/>    async uploadImageFromCamera() {<br/>      try {<br/>        imageUploader.uploadImageFromCamera();<br/>      } catch (err) {<br/>        console.error("Uploading failed");<br/>        console.dir(err);<br/>        store.updatePicFailed(localPic);<br/>        this.$q.notify({ message: "Uploading failed. Check log." });<br/>      }<br/>    }<br/>  }<br/>};<br/>&lt;/script&gt;</span></pre><p id="e618" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">这是怎么回事:</p><ul class=""><li id="ba96" class="nb nc iq ku b kv kw kz la ld nd lh ne ll nf lp ng nh ni nj bi translated">我们添加了一个<code class="fe my mz na mq b">q-spinner</code>来显示图片的<code class="fe my mz na mq b">uploading</code>属性何时为真。</li><li id="b4ab" class="nb nc iq ku b kv nk kz nl ld nm lh nn ll no lp ng nh ni nj bi translated">我们在点击照片按钮时调用<code class="fe my mz na mq b">imageUploader.uploadImageFromCamera</code>，它处理我们的上传。</li><li id="a893" class="nb nc iq ku b kv nk kz nl ld nm lh nn ll no lp ng nh ni nj bi translated">我们在图片的<code class="fe my mz na mq b">q-card</code>中添加了一些动作(目前只实现了删除)</li></ul><h1 id="7898" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">最终应用</h1><p id="2e47" class="pw-post-body-paragraph ks kt iq ku b kv mk kx ky kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp ij bi translated">就是这样！我们有一个图像上传应用程序，用微调器显示模糊的缩略图，有点像WhatsApp的图像上传。使用<code class="fe my mz na mq b">quasar dev -m android/ios</code>运行这一切将显示最终结果:</p><figure class="kl km kn ko gt kp"><div class="bz fp l di"><div class="kq kr l"/></div></figure><h1 id="8f44" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">进一步的改进</h1><p id="bf4f" class="pw-post-body-paragraph ks kt iq ku b kv mk kx ky kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp ij bi translated">进一步改进该应用程序的一些想法如下:</p><ul class=""><li id="7636" class="nb nc iq ku b kv kw kz la ld nd lh ne ll nf lp ng nh ni nj bi translated">将缩略图创建工作交给另一个网络工作者</li><li id="21a9" class="nb nc iq ku b kv nk kz nl ld nm lh nn ll no lp ng nh ni nj bi translated">用一个虚拟列表组件处理长长的图像列表，比如这个</li><li id="b190" class="nb nc iq ku b kv nk kz nl ld nm lh nn ll no lp ng nh ni nj bi translated">添加一个旋转木马/画廊组件来查看完整尺寸的图像</li><li id="8000" class="nb nc iq ku b kv nk kz nl ld nm lh nn ll no lp ng nh ni nj bi translated">为失败的上传添加重试机制</li><li id="6ea7" class="nb nc iq ku b kv nk kz nl ld nm lh nn ll no lp ng nh ni nj bi translated">使用<a class="ae lq" href="https://firebase.google.com/docs/auth" rel="noopener ugc nofollow" target="_blank">firebase auth</a>——这样用户只能删除自己的照片</li></ul><h1 id="d6f2" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">源代码</h1><p id="7504" class="pw-post-body-paragraph ks kt iq ku b kv mk kx ky kz ml lb lc ld mm lf lg lh mn lj lk ll mo ln lo lp ij bi translated">完整代码在GitHub这里:<a class="ae lq" href="https://github.com/syonip/vue-firebase-image-upload" rel="noopener ugc nofollow" target="_blank">vue-firebase-image-upload</a>。</p><p id="9475" class="pw-post-body-paragraph ks kt iq ku b kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp ij bi translated">享受:)</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="nq nr di ns bf nt"><div class="gh gi np"><img src="../Images/7534688196b6b786997bb7313ee442b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d0faUEns5j9EceUCx-ULhg.png"/></div></div></figure></div></div>    
</body>
</html>