<html>
<head>
<title>How To Avoid Prop Drilling in React Using Component Composition</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在使用组件组合反应中避免正确的钻取</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-avoid-prop-drilling-in-react-using-component-composition-c42adfcdde1b?source=collection_archive---------0-----------------------#2020-07-29">https://javascript.plainenglish.io/how-to-avoid-prop-drilling-in-react-using-component-composition-c42adfcdde1b?source=collection_archive---------0-----------------------#2020-07-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="6505" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">没有Redux或上下文API</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/da959d490f7f4ec445eaab7bf9c84fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zd8xNfpnLt5nHEpNmXPMQw.jpeg"/></div></div></figure><p id="615b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">Prop Drilling是将数据从React组件树的一个部分传递到另一个部分的过程，方法是遍历不需要数据但只是帮助传递数据的其他部分。</p><p id="055c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">想象一下，住在尼日利亚拉各斯的某人在亚马逊上订购了一个包裹。包裹必须经过许多人的手——它必须空运到尼日利亚，运输到拉各斯，从一个地方搬到另一个地方，直到到达买家手中。在每一个阶段，亚马逊都雇佣不“关心”产品的人提供服务，他们只是帮助将产品“传递”给关心产品的人——买家。</p><p id="69bd" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">道具钻取类似:你把数据(道具)从某个<code class="fe lk ll lm ln b">FirstComponent</code>传递到另一个<code class="fe lk ll lm ln b">SecondComponent</code>——它不需要数据渲染，只把它传递给另一个<code class="fe lk ll lm ln b">ThirdComponent</code>，后者也不需要它，可能传递给另一个<code class="fe lk ll lm ln b">FourthComponent</code>。这可能会持续到数据到达<code class="fe lk ll lm ln b">ComponentNeedingProps</code>。</p><p id="1d3e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">考虑下面的代码片段:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lo lp l"/></div></figure><p id="cca2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">content</code>属性被传递给根组件<code class="fe lk ll lm ln b">App</code>中的<code class="fe lk ll lm ln b">FirstComponent</code>。但是<code class="fe lk ll lm ln b">FirstComponent</code>不需要道具渲染，它只把它传给<code class="fe lk ll lm ln b">SecondComponent</code>，T9把它传给<code class="fe lk ll lm ln b">ThirdComponent</code>，T10把它传给<code class="fe lk ll lm ln b">ComponentNeedingProps</code>。正是这个组件使用<code class="fe lk ll lm ln b">content</code>属性来呈现<code class="fe lk ll lm ln b">&lt;h3&gt;{content}&lt;/h3&gt;</code>中的内容。</p><h1 id="194b" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">为什么道具钻探是一个问题？</h1><p id="429d" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">道具钻井不一定是个问题。如果我们只在2或3层之间传递数据，那就没问题。追踪数据的流动将会很容易。但是想象一下，我们正在钻5层，或者10层，或者15层。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mn"><img src="../Images/20e21fa04d1fd9f59bdfd3f4af94efb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1014/format:webp/1*R4csNpIyGu4cHg54n2P7xA.jpeg"/></div></figure><h1 id="987e" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">如何解决问题</h1><p id="9e4d" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">正确钻探在React中并不是一个新问题(相当明显)，已经有许多解决方案让我们将数据向下传递到深层嵌套的组件。</p><p id="da9f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">其中一个是Redux:你创建一个数据<code class="fe lk ll lm ln b">store</code>和<code class="fe lk ll lm ln b">connect</code>到<code class="fe lk ll lm ln b">store</code>的任何组件，瞧，不管组件在组件树中的位置在哪里，它都可以访问存储。</p><p id="93a5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">React也有<code class="fe lk ll lm ln b">Context</code>的概念，它允许你创建类似于全局<code class="fe lk ll lm ln b">data store</code>的东西，并且“上下文”中的任何组件都可以访问数据存储。</p><p id="db97" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然而，如果您想在不使用上下文的情况下解决这个问题<strong class="kq io">，您可以使用<a class="ae mo" href="https://reactjs.org/docs/context.html#when-to-use-context" rel="noopener ugc nofollow" target="_blank"> React文档所建议的组件组合:</a></strong></p><p id="f53d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mp">如果你只想避免一些道具通过许多关卡，组件组合通常是比上下文更简单的解决方案</em></p><p id="adac" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在使用Context 之前，你可以在这里<a class="ae mo" href="https://reactjs.org/docs/context.html#before-you-use-context" rel="noopener ugc nofollow" target="_blank">了解更多信息，并且查看</a><a class="mq mr ep" href="https://medium.com/u/7f9567e0d71c?source=post_page-----c42adfcdde1b--------------------------------" rel="noopener" target="_blank"> Michael Jackson </a>的帖子，了解为什么你应该避免使用Context API。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="ms lp l"/></div></figure><h1 id="0dab" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">如何避免使用组件组合进行正确钻探</h1><p id="0fce" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">组件组合是指将不同的组件(通常很简单)组合在一起，以创建更复杂的功能。如果你曾经编写过React应用程序，我敢打赌你一直在编写组件。举个例子:</p><pre class="kd ke kf kg gt mt ln mu mv aw mw bi"><span id="e8c6" class="mx lr in ln b gy my mz l na nb">function LoginForm(props){<br/>  return (<br/>    &lt;Input name="fname" /&gt;<br/>    &lt;Button onClick={props.handleClick} /&gt;)<br/>}</span></pre><p id="b3ca" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这里，通过使用组合，我们创建了一个“复杂”的功能，<code class="fe lk ll lm ln b">LoginForm </code>通过组合两个简单的功能，<code class="fe lk ll lm ln b">Button </code>和<code class="fe lk ll lm ln b">Input </code>组件。你可以在React <a class="ae mo" href="https://reactjs.org/docs/composition-vs-inheritance.html" rel="noopener ugc nofollow" target="_blank">文档页面</a>上阅读更多关于合成的内容。</p><h1 id="a9f1" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">我们试图解决的实际问题是什么？</h1><p id="4663" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">实际的问题是，我们希望在<code class="fe lk ll lm ln b">ThirdComponent</code>中呈现<code class="fe lk ll lm ln b">ComponentNeedingProps</code>，但是它需要来自根组件<code class="fe lk ll lm ln b">App</code>的数据来实现。换句话说，<code class="fe lk ll lm ln b">ComponentNeedingProps</code>需要来自组件树中更高位置的数据(<code class="fe lk ll lm ln b">App</code>)，从那里它被渲染(<code class="fe lk ll lm ln b">ThirdComponent</code>)。</p><p id="dab9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">解决办法？</p><h1 id="1459" class="lq lr in bd ls lt lu lv lw lx ly lz ma jt mb ju mc jw md jx me jz mf ka mg mh bi translated">儿童道具的野性力量</h1><p id="595d" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">您可以通过使一个组件成为另一个组件的子组件来组合组件，例如:</p><pre class="kd ke kf kg gt mt ln mu mv aw mw bi"><span id="fb33" class="mx lr in ln b gy my mz l na nb">&lt;ReactComponent1&gt;<br/>  &lt;ReactComponent2 /&gt;<br/>&lt;/ReactCompoent1&gt;</span></pre><p id="0d0d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">ReactComponent2</code>在<code class="fe lk ll lm ln b">ReactComponent1</code>内部被调用，因此它是它的子节点。每个组件都有一个名为<code class="fe lk ll lm ln b">children</code>的“自动”属性，用于保存组件的子组件。所以在<code class="fe lk ll lm ln b">ReactComponent1</code>中我们可以写:</p><pre class="kd ke kf kg gt mt ln mu mv aw mw bi"><span id="1bf5" class="mx lr in ln b gy my mz l na nb">function ReactComponent1({ children }) {<br/>  return <br/>   (&lt;div&gt; I render my children<br/>      {children} <br/>   &lt;/div&gt;)<br/>}</span></pre><p id="7d1b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">在这种情况下我们如何使用它？请记住，我们希望<code class="fe lk ll lm ln b">ComponentNeedingProps</code>呈现在组件树中的另一个组件中，如果我们可以将<code class="fe lk ll lm ln b">ComponentNeedingProps</code>作为子组件传递给它所需要的数据，然后在它的父组件中呈现它，那么我们就成功地避免了属性钻取。</p><p id="47be" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，我们将拥有:</p><pre class="kd ke kf kg gt mt ln mu mv aw mw bi"><span id="f8e4" class="mx lr in ln b gy my mz l na nb">&lt;ThirdComponent&gt;<br/> &lt;h3&gt;I am the third component&lt;/h3&gt;<br/>     &lt;ComponentNeedingProps content={content}  /&gt;<br/>&lt;/ThirdCompoent&gt;</span></pre><p id="ff1d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">而在<code class="fe lk ll lm ln b">ThirdComponent </code>的宣言中我们有:</p><pre class="kd ke kf kg gt mt ln mu mv aw mw bi"><span id="4346" class="mx lr in ln b gy my mz l na nb">function ThirdComponent({ children }) {<br/> return (<br/> &lt;div&gt;<br/>    &lt;h3&gt;I am the third component&lt;/h3&gt;<br/>     {children}<br/>   &lt;/div&gt;<br/> );<br/>}</span></pre><p id="db26" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这看起来和我们之前的没有太大的不同，但是等待奇迹吧。</p><p id="4a93" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">通过使用这种呈现孩子的技术，我们可以将<code class="fe lk ll lm ln b">App</code>重构为:</p><pre class="kd ke kf kg gt mt ln mu mv aw mw bi"><span id="662e" class="mx lr in ln b gy my mz l na nb">function App() {<br/>const content = "Who needs me?";<br/>return (<br/>&lt;div className="App"&gt;<br/>  &lt;FirstComponent&gt;<br/>    &lt;SecondComponent&gt;<br/>      &lt;ThirdComponent&gt;<br/>        &lt;ComponentNeedingProps content={content}  /&gt;<br/>      &lt;ThirdComponent&gt;<br/>    &lt;/SecondComponent&gt;<br/>  &lt;/FirstComponent&gt;<br/>&lt;/div&gt;<br/>);<br/>}</span></pre><p id="64c2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">然后我们重构其他组件来呈现它们的<code class="fe lk ll lm ln b">children</code></p><p id="49e5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第一组件:</p><pre class="kd ke kf kg gt mt ln mu mv aw mw bi"><span id="2575" class="mx lr in ln b gy my mz l na nb">function FirstComponent({ children }) {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h3&gt;I am the first component&lt;/h3&gt;;<br/>     { children }<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="da8c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第二组件:</p><pre class="kd ke kf kg gt mt ln mu mv aw mw bi"><span id="2bc5" class="mx lr in ln b gy my mz l na nb">function SecondComponent({ children }) {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h3&gt;I am the second component&lt;/h3&gt;;<br/>     {children}<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="5d5b" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">第三组件:</p><pre class="kd ke kf kg gt mt ln mu mv aw mw bi"><span id="3ef2" class="mx lr in ln b gy my mz l na nb">function ThirdComponent({ children }) {<br/>  return (<br/>    &lt;div&gt;<br/>      &lt;h3&gt;I am the third component&lt;/h3&gt;<br/>        {children}<br/>    &lt;/div&gt;<br/>  );<br/>}</span></pre><p id="b24f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><code class="fe lk ll lm ln b">ComponentNeedingProps</code>保持原样:</p><pre class="kd ke kf kg gt mt ln mu mv aw mw bi"><span id="2a79" class="mx lr in ln b gy my mz l na nb">function ComponentNeedingProps({ content }) {<br/>  return &lt;h3&gt;{content}&lt;/h3&gt;<br/>}</span></pre><p id="5350" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">你看到了吗？我们通过从数据源<code class="fe lk ll lm ln b">App </code>直接给<code class="fe lk ll lm ln b">ComponentNeedingProps</code>它需要的数据，然后通过使用子道具，我们将它传递到它应该被渲染的地方<code class="fe lk ll lm ln b">ThirdComponent</code>，从而避免了道具钻取。</p><p id="1e22" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">太棒了。查看完整代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lo lp l"/></div></figure><h2 id="786c" class="mx lr in bd ls nc nd dn lw ne nf dp ma kx ng nh mc lb ni nj me lf nk nl mg nm bi translated">什么时候应该使用上下文API？</h2><p id="6b98" class="pw-post-body-paragraph ko kp in kq b kr mi jo kt ku mj jr kw kx mk kz la lb ml ld le lf mm lh li lj ig bi translated">您还可以使用上下文API来避免适当的钻探，我可能会在不久的将来就此写另一篇文章。</p><p id="962f" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果您需要让不同嵌套层次的许多组件可以访问某些数据，那么您应该使用上下文API。React docs建议我们“谨慎使用它，因为它使组件重用更加困难。”换句话说，您可能无法“脱离上下文”重用您的组件。</p><p id="a592" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是这篇文章的全部内容，谢谢你的阅读。你可以在<a class="ae mo" href="https://codesandbox.io/s/propdrilling-vs-composition-updated-qe8nm?file=/src/App.js:0-878" rel="noopener ugc nofollow" target="_blank"> CodeSandbox </a>上玩代码</p><p id="58cb" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">快乐编码。</p><p id="8b77" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><strong class="kq io"> <em class="mp">注</em> </strong> <em class="mp">:根据评论中提供的反馈，这篇文章已经进行了重大修改。我感谢所有提供有用反馈的人。下面的一些评论不适用于这次修订。</em></p></div></div>    
</body>
</html>