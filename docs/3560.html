<html>
<head>
<title>Using MutationObserver to stop a flaky plugin wrecking your beautiful site</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用MutationObserver阻止一个片状插件破坏你美丽的网站</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-mutationobserver-to-stop-a-flaky-plugin-wrecking-your-beautiful-site-cf97bf981441?source=collection_archive---------10-----------------------#2020-10-08">https://javascript.plainenglish.io/using-mutationobserver-to-stop-a-flaky-plugin-wrecking-your-beautiful-site-cf97bf981441?source=collection_archive---------10-----------------------#2020-10-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/2be32d183652456ee69a87375e298955.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eFs_rndNcVexxdGAFRqVjg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">On the lookout for mutations in Lake DOM</figcaption></figure><p id="766b" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">当客户要求你“把这个脚本贴在网站上”时，你难道不喜欢吗？很少有什么“只是”，因为这些事情总是有连锁反应，最近当一个客户在他们的网站上安装了一个实时聊天插件时，我就遇到了这种情况。它看起来很糟糕，我对此无能为力，但它也重叠了移动设备上的一些关键功能，使它们无法使用。</p><p id="7c04" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我可以通过在body中添加一个类并相应地更新各种样式来解决这个问题，但是这只有在实时聊天就绪的情况下才有效，这是无法保证的。</p><p id="5b18" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">该插件有时被启用，有时被禁用。有时会加载，有时不会。当它加载时，需要15-20秒。最糟糕的是，没有发出“嘿，我成功加载了”事件。所以我需要一些方法来判断实时聊天怪物是否存在。</p><p id="b0e9" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我开始查看某种轮询脚本，每隔一段时间检查一下DOM，看看它是否已经加载了(我甚至讨厌自己考虑这个问题)，但是我突然想到——我们现在不是有一个很好的API来处理这类事情吗？</p><p id="7849" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">事实证明，是的，我们有！它被称为MutationObserver，从2012年开始在Chrome和Firefox中得到支持，甚至可以在IE11中工作。非常漂亮。您告诉浏览器注意DOM中的某些特定变化，它会在发现变化时通知您。就像你在尝试联系客服的时候，轮到你的时候可以按1得到回拨而不是坐等(旁白:为什么不是所有公司都这么做？！).</p><p id="66c5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">观察有三个主要部分:</p><ol class=""><li id="8872" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw lc ld le lf bi translated">目标元素——您将关注DOM的哪一部分？</li><li id="bb5e" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">配置—您希望什么样的变化？</li><li id="e249" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw lc ld le lf bi translated">回调——当变化发生时，你会怎么做？</li></ol><p id="8984" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">实时聊天窗口被附加到主体上，所以我的目标元素必须是主体。这听起来很昂贵(从计算角度来说)，但是在配置中，我们将确保我们没有看到整个DOM。</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="2f35" class="lv lw in lr b gy lx ly l lz ma">const targetElement = document.body;</span></pre><p id="f738" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们正在寻找的是新的子元素。有一个选项，叫做孩子列表。其他主要选项包括:</p><ul class=""><li id="f574" class="kx ky in kb b kc kd kg kh kk kz ko la ks lb kw mb ld le lf bi translated">属性，它监视元素本身属性的变化</li><li id="bd12" class="kx ky in kb b kc lg kg lh kk li ko lj ks lk kw mb ld le lf bi translated">subtree，它监视从目标元素开始的整个DOM树</li></ul><p id="47ae" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">您可以混合和匹配这些选项，但是您只需要指定您想要启用的选项，因为默认情况下其他选项都是假的。所以我们的配置非常简单:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="e57c" class="lv lw in lr b gy lx ly l lz ma">const config = { childList: true }</span></pre><p id="2b4d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">最后，回调，这是比较棘手的部分。我们传递了两个对象——一个突变列表和实际的观察者。</p><p id="8da6" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我们将循环遍历这些突变，对于那些类型为childList的突变，我们将查看是否有任何添加的节点。您还可以查看从目标中删除的节点，以及目标本身。对于每个节点，您可以访问完整的元素及其所有属性——就像使用getElementById或querySelector一样。一旦我们找到了我们正在寻找的节点，我们就可以将类添加到主体中，并断开与观察者的连接，这样我们就不会耗尽宝贵的CPU周期。</p><p id="1957" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">我的回调看起来是这样的:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="850e" class="lv lw in lr b gy lx ly l lz ma">const callback = function (mutationsList, observer) {<br/>  for (const mutation of mutationsList) {<br/>    if (mutation.type === 'childList') {<br/>      for (const addedNode of mutation.addedNodes) {<br/>        if (addedNode.id === 'live-chat-window') {<br/>          document.documentElement.classList.add('live-chat-loaded');<br/>          observer.disconnect();<br/>        }<br/>      }<br/>    }<br/>  }<br/>}</span></pre><p id="9e7d" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">现在剩下的就是激发观察者:</p><pre class="lm ln lo lp gt lq lr ls lt aw lu bi"><span id="56f2" class="lv lw in lr b gy lx ly l lz ma">const observer = new MutationObserver(callback);<br/>observer.observe(target, config);</span></pre><p id="1bed" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">极少量的代码，而且看不到setTimeout！</p><p id="a776" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">这是一个简单的例子。现在我们可以做一些改进。</p><p id="0c40" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">健壮性:</strong>为了防止竞态条件，我们应该在设置任何观察器之前检查节点是否存在。</p><p id="b317" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">性能:</strong>遍历突变<a class="ae mc" href="https://stackoverflow.com/questions/31659567/performance-of-mutationobserver-to-detect-nodes-in-entire-dom#39332340" rel="noopener ugc nofollow" target="_blank">可能不是性能最好的</a>。执行getElementById可能会快得多(尽管在我的实际问题中，我没有可预测的Id来检查)。</p><p id="80f5" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated"><strong class="kb io">兼容性:</strong>有些浏览器不支持MutationObserver，所以在尝试使用它之前检查它是否存在是个好习惯(<code class="fe md me mf lr b">if (window.MutationObserver)</code>)。Polyfills是存在的，但我不知道它们是否有用。如果你想要IE支持，你还需要把for…of循环改成简单的for(或者让你的transpiler替你做)。</p><p id="0567" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">如果你想了解更多关于变异观察者的信息，请查看MDN页面和粉碎杂志指南。</p><p id="b8d3" class="pw-post-body-paragraph jz ka in kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw ig bi translated">喜欢这篇文章吗？如果有，通过<a class="ae mc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kb io">订阅解码，我们的YouTube频道</strong> </a> <strong class="kb io">获取更多类似内容！</strong></p></div></div>    
</body>
</html>