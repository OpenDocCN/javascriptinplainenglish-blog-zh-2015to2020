<html>
<head>
<title>Introduction to TypeScript Data Types — Tuple, Enum, and Any</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript数据类型简介—元组、枚举和任意</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/introduction-to-typescript-data-types-tuple-enum-and-any-7b2ce12b5f20?source=collection_archive---------2-----------------------#2019-12-10">https://javascript.plainenglish.io/introduction-to-typescript-data-types-tuple-enum-and-any-7b2ce12b5f20?source=collection_archive---------2-----------------------#2019-12-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn js jt ju jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi jr"><img src="../Images/da41df33d0adb9e3775975a022541760.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qCWinLBUwe-xQr-x"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk">Photo by <a class="ae kg" href="https://unsplash.com/@mnelson?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Matt Nelson</a> on <a class="ae kg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="43cf" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">JavaScript和其他编程语言一样，有自己的数据结构和类型。为了用JavaScript构建程序，我们必须了解一些数据类型。不同的数据可以放在一起构建更复杂的数据结构。</p><p id="9d12" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">JavaScript是一种松散类型或动态类型的语言。这意味着用一种类型声明的变量可以转换成另一种类型，而不用显式地将数据转换成另一种类型。</p><p id="d823" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">变量也可以在任何时候包含任何类型，这取决于赋值的内容。在动态类型语言中，如果不记录就很难确定变量的类型，我们可能会在变量中分配我们不想要的数据。</p><p id="e228" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">TypeScript纠正了这些问题，让我们为变量设置固定的类型，这样我们就可以确定类型。在本文中，我们将研究TypeScript独有的TypeScript数据类型。在本文中，我们将研究tuple、enum和<code class="fe jn jo jp jq b">any</code>数据类型。</p><h1 id="5999" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">元组</h1><p id="6127" class="pw-post-body-paragraph kh ki iq kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le ij bi translated">元组是逗号分隔的对象列表。我们可以有尽可能多的逗号分隔的项目。然而，在现实中，我们可能不应该在一个类型中有超过10个逗号分隔的项。在TypeScript中，我们可以使用括号声明类型为的变量，括号内的类型名称用逗号分隔。这意味着元组中的每个条目都将具有我们声明元组变量时设置的类型。例如，我们可以写:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="1eff" class="mq lg iq jq b gy mr ms l mt mu">let x: [string, number, boolean] = ['hello', 1, true];<br/>console.log(x);</span></pre><p id="e3a1" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="bdd7" class="mq lg iq jq b gy mr ms l mt mu">["hello", 1, true]</span></pre><p id="e77b" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">元组只是一个数组，每个条目都有固定的类型。如果我们在声明它的时候，把不同于我们指定的类型放在位置上，那么我们会得到一个错误。例如，如果我们有:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="86bf" class="mq lg iq jq b gy mr ms l mt mu">let x: [string, number, boolean] = [2, 1, true];<br/>console.log(x);</span></pre><p id="d7db" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后我们得到“类型‘数字’不能赋给类型‘字符串’。”错误，程序将不会运行。我们可以像访问数组一样访问元组中的一个条目，因为它们只是每个条目都有固定类型的数组。例如，我们可以编写以下代码:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="369c" class="mq lg iq jq b gy mr ms l mt mu">let x: [string, number, boolean] = ['hello', 1, true];<br/>console.log(x);<br/>console.log(x[0]);<br/>console.log(x[1]);<br/>console.log(x[2]);</span></pre><p id="645c" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="96f1" class="mq lg iq jq b gy mr ms l mt mu">hello<br/>1<br/>true</span></pre><p id="b958" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">同样，析构赋值操作符也像其他数组一样正常工作。例如，我们可以写:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="10dc" class="mq lg iq jq b gy mr ms l mt mu">const x: [string, number, boolean] = ['hello', 1, true];<br/>const [str, num, bool] = x;<br/>console.log(x);<br/>console.log(str);<br/>console.log(num);<br/>console.log(bool);</span></pre><p id="ca43" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后我们得到和以前一样的输出。我们也可以将非原语对象放在元组对象中。例如，我们可以有一个类的实例，如下面的代码所示:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="62a9" class="mq lg iq jq b gy mr ms l mt mu">class Person{<br/>  name: string;<br/>  constructor(name: string){<br/>    this.name = name;<br/>  }<br/>}<br/>const x: [string, number, boolean, Person] = ['hello', 1, true, new Person('Jane')];<br/>const [str, num, bool, person] = x;<br/>console.log(x);<br/>console.log(str);<br/>console.log(num);<br/>console.log(bool);<br/>console.log(person);</span></pre><p id="58c6" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后我们得到以下结果:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="5455" class="mq lg iq jq b gy mr ms l mt mu">hello<br/>1<br/>true<br/>Person {name: "Jane"}</span></pre><p id="29bb" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">从<code class="fe jn jo jp jq b">console.log</code>输出。</p><h1 id="c5fd" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">列举型别</h1><p id="3f22" class="pw-post-body-paragraph kh ki iq kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le ij bi translated">TypeScript具有JavaScript中不可用的枚举类型。枚举类型是一种数据类型，它有一组命名值，称为该类型的元素、成员、枚举数或枚举数。它们是标识符，就像语言中的常量一样。在TypeScript中，枚举有一个与之关联的相应索引。默认情况下，成员从索引0开始，但可以更改为从我们喜欢的任何索引开始，后续成员的索引将从该起始编号开始递增。例如，我们可以编写以下代码，在TypeScript中定义一个简单的枚举:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="8de4" class="mq lg iq jq b gy mr ms l mt mu">enum Fruit { Orange, Apple, Grape };</span></pre><p id="6a76" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后我们可以用下面的代码访问一个枚举的成员:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="ecaf" class="mq lg iq jq b gy mr ms l mt mu">enum Fruit { Orange, Apple, Grape };<br/>console.log(Fruit.Orange);</span></pre><p id="43d8" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">那么上面代码中的<code class="fe jn jo jp jq b">console.log</code>应该得到0，因为我们没有为枚举指定起始索引。我们可以用类似下面的代码指定枚举的起始索引:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="1967" class="mq lg iq jq b gy mr ms l mt mu">enum Fruit { Orange = 1, Apple, Grape };<br/>console.log(Fruit.Orange);<br/>console.log(Fruit.Apple);<br/>console.log(Fruit.Grape);</span></pre><p id="0186" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后，我们从每个<code class="fe jn jo jp jq b">console.log</code>语句中按顺序记录以下内容:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="a127" class="mq lg iq jq b gy mr ms l mt mu">1<br/>2<br/>3</span></pre><p id="e045" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我们可以为每个成员指定相同的索引，但这不是很有用:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="f363" class="mq lg iq jq b gy mr ms l mt mu">enum Fruit { Orange = 1, Apple = 1, Grape };<br/>console.log(Fruit.Orange);<br/>console.log(Fruit.Apple);<br/>console.log(Fruit.Grape);</span></pre><p id="f1f4" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="ee44" class="mq lg iq jq b gy mr ms l mt mu">1<br/>1<br/>2</span></pre><p id="67f7" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">来自<code class="fe jn jo jp jq b">console.log</code>。正如我们所看到的，我们指定了索引，但是我们想改变它。我们甚至可以有负指数:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="c28f" class="mq lg iq jq b gy mr ms l mt mu">enum Fruit { Orange = -1, Apple, Grape };<br/>console.log(Fruit.Orange);<br/>console.log(Fruit.Apple);<br/>console.log(Fruit.Grape);</span></pre><p id="47af" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="15d3" class="mq lg iq jq b gy mr ms l mt mu">-1<br/>0<br/>1</span></pre><p id="d9f8" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">从<code class="fe jn jo jp jq b">console.log</code>开始。要通过索引获取枚举成员，我们可以像通过索引访问数组条目一样使用括号符号。例如，我们可以编写以下代码:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="5acf" class="mq lg iq jq b gy mr ms l mt mu">enum Fruit { Orange, Apple, Grape };<br/>console.log(Fruit[0]);<br/>console.log(Fruit[1]);<br/>console.log(Fruit[2]);</span></pre><p id="591a" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="db72" class="mq lg iq jq b gy mr ms l mt mu">Orange<br/>Apple<br/>Grape</span></pre><figure class="mi mj mk ml gt jv gh gi paragraph-image"><div role="button" tabindex="0" class="jw jx di jy bf jz"><div class="gh gi mv"><img src="../Images/5e7c76dab708952c4e9ca9c5bfab1116.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OrifkAgkcLnGO84k"/></div></div><figcaption class="kc kd gj gh gi ke kf bd b be z dk">Photo by <a class="ae kg" href="https://unsplash.com/@anoirchafik?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Anoir Chafik</a> on <a class="ae kg" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c132" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">任何的</h1><p id="8ed4" class="pw-post-body-paragraph kh ki iq kj b kk md km kn ko me kq kr ks mf ku kv kw mg ky kz la mh lc ld le ij bi translated">在TypeScript中，<code class="fe jn jo jp jq b">any</code>类型意味着我们可以将任何东西赋给用类型<code class="fe jn jo jp jq b">any</code>声明的变量。这和我们在JavaScript中给变量赋值没有什么不同。这让我们可以慢慢地采用JavaScript来打字稿，也让我们可以像字典一样使用动态对象。它还允许我们使用我们不知道来自第三方库模块的like成员类型的变量。我们可以将任何东西赋给一个<code class="fe jn jo jp jq b">any</code>类型的变量，而不会出现任何错误。例如，我们可以像下面的代码一样声明并使用一个类型为<code class="fe jn jo jp jq b">any</code>的变量:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="bf26" class="mq lg iq jq b gy mr ms l mt mu">let x: any = 1;<br/>console.log(x);<br/>x = 'string';<br/>console.log(x);</span></pre><p id="e40c" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">如果我们运行上面的代码，那么我们得到下面的<code class="fe jn jo jp jq b">console.log</code>值:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="5cfc" class="mq lg iq jq b gy mr ms l mt mu">1<br/>string</span></pre><p id="9975" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">类型对于声明其他数据类型也很方便，比如数组。如果我们用<code class="fe jn jo jp jq b">any</code>类型声明一个数组，那么我们可以将任何类型的数据作为条目放入我们声明的数组中。我们可以用下面的代码声明一个类型为<code class="fe jn jo jp jq b">any</code>的数组:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="153a" class="mq lg iq jq b gy mr ms l mt mu">let anyList: any[] = [1, true, "abc"];<br/>console.log(anyList);</span></pre><p id="bd7a" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="9b72" class="mq lg iq jq b gy mr ms l mt mu">[1, true, "abc"]</span></pre><p id="19f8" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">从<code class="fe jn jo jp jq b">console.log</code>开始。TypeScript有一个与JavaScript中的<code class="fe jn jo jp jq b">Object</code>对象相对应的<code class="fe jn jo jp jq b">Object</code>类型。所以不能像<code class="fe jn jo jp jq b">any</code>型那样使用。<code class="fe jn jo jp jq b">Object</code>式有自己的方法，如<code class="fe jn jo jp jq b">toString</code>、<code class="fe jn jo jp jq b">hasOwnProperty</code>等。，它与<code class="fe jn jo jp jq b">any</code>类型完全不同，后者实际上意味着变量可以被赋予任何值。例如，如果我们编写以下内容:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="797b" class="mq lg iq jq b gy mr ms l mt mu">let x: Object = 2;<br/>x.toFixed();</span></pre><p id="d75a" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我们将得到错误“类型“Object”上不存在属性“toFixed”。但是，我们可以编写以下代码:</p><pre class="mi mj mk ml gt mm jq mn mo aw mp bi"><span id="f95f" class="mq lg iq jq b gy mr ms l mt mu">let x: Object = 2;<br/>console.log(x.hasOwnProperty('foo'));</span></pre><p id="a5c4" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">我们可以看到，<code class="fe jn jo jp jq b">Object</code>类型有一个<code class="fe jn jo jp jq b">hasOwnProperty</code>属性方法，这就是JavaScript中的<code class="fe jn jo jp jq b">Object</code>对象所具有的。</p><p id="a359" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">元组是逗号分隔的对象列表。我们可以有尽可能多的逗号分隔的项目。它只是一个JavaScript数组，每个条目都有固定的类型。TypeScript具有JavaScript中不可用的枚举类型。枚举类型是一种数据类型，它有一组命名值，称为该类型的元素、成员、枚举数或枚举数。</p><p id="2f2a" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated">它们是标识符，就像语言中的常量一样。每个枚举成员都有一个索引，可以任意设置。我们也可以用括号符号从成员的索引中获取成员名，就像我们如何通过索引获取数组条目一样。</p><p id="36f2" class="pw-post-body-paragraph kh ki iq kj b kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le ij bi translated"><code class="fe jn jo jp jq b">any</code>类型允许我们给用类型<code class="fe jn jo jp jq b">any</code>声明的变量赋值。这和我们在JavaScript中给变量赋值没有什么不同。</p></div></div>    
</body>
</html>