<html>
<head>
<title>Writing reusable code in React with {render.props}</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用{render.props}在React中编写可重用的代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/write-reusable-code-by-render-props-8ddb4f85cfa5?source=collection_archive---------0-----------------------#2019-03-23">https://javascript.plainenglish.io/write-reusable-code-by-render-props-8ddb4f85cfa5?source=collection_archive---------0-----------------------#2019-03-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="ba0d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在<a class="ae ki" href="https://medium.com/@hellonehha/reactjs-reusable-components-by-props-children-df6d77d69a98" rel="noopener">的上一篇文章</a>中，我们看到了如何通过使用<em class="kj">儿童道具</em>来重用React中的组件。在这篇文章中，我们将学习在React中创建可重用组件的另一种重用模式—<strong class="jm io"><em class="kj">render . props</em></strong><em class="kj">。</em></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi kk"><img src="../Images/fc2f02813f16b02634116ed9c28ac04e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XXvvIfkt7MpNWOl82MAQrw.png"/></div></div></figure><h1 id="d5b5" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">什么是render.props</h1><p id="295c" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated"><em class="kj"> render.props </em>是一种编写可重用组件的方式。根据React文档——"<em class="kj">render . props是一种</em> <em class="kj">在React组件之间共享代码的方式，使用一个值为函数的prop。</em>“不断有人将<em class="kj"> render.props </em>与<em class="kj"> children.props </em>混淆比较。然而，两者都有自己的用例，但render.props比<em class="kj"> children.props </em>更强大，我们将在一段时间内看到。</p><h1 id="93be" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated"><strong class="ak">问题陈述</strong></h1><p id="a0db" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">假设，我们想要创建一个3列布局，布局中的每个列都可以通过传递道具来独立处理，并且我们可以访问它们。</p><p id="d2bf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">简而言之，我们希望实现两件事:</p><ol class=""><li id="0142" class="lz ma in jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh bi translated">三列布局，其中所有三列组件都应该有一个独立的包装</li><li id="4f1a" class="lz ma in jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh bi translated">每个col-component应该能够从父包装器访问props</li></ol><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi mn"><img src="../Images/9641f34058f806d804e161c01f277179.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9ntDWAKCUAdJ9maOVN7HIg.png"/></div></div></figure><h1 id="24d5" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">解决方案:</h1><p id="1540" class="pw-post-body-paragraph jk jl in jm b jn lu jp jq jr lv jt ju jv lw jx jy jz lx kb kc kd ly kf kg kh ig bi translated">让我们先试着通过<em class="kj">儿童道具</em>来解决这个问题，然后我们将移动到<em class="kj">渲染道具</em></p><p id="2c1d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">步骤1:为包装器创建四个组件——left . js、Right.js、Mid.js和Content.js。</em></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi mo"><img src="../Images/507e167c63f238fa689f9601404c1dd0.png" data-original-src="https://miro.medium.com/v2/resize:fit:342/format:webp/1*PzahM6UUxm_Dh-rvXVG7Yw.png"/></div></figure><p id="d177" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">步骤2:将下面的代码放入Left.js、Mid.js和Right.js中，不要忘记更改第3、#4和#7行的组件名称</em></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/0a64a2d899f50b1368da4497eb0b9c42.png" data-original-src="https://miro.medium.com/v2/resize:fit:942/format:webp/1*grfDIK0olY_Xy8n1CzKvmw.png"/></div></figure><p id="2263" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">第三步:让我们组装到index.js中的应用程序</em></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi mq"><img src="../Images/ed3c40dabfd75d2879523264c345ba5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:772/format:webp/1*Ad6WQzLvTThGRtMRHp6eow.png"/></div></figure><p id="df86" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">第四步:通过children.props我们将渲染Content.js中的组件</em></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi mr"><img src="../Images/c3447197a9c67686ffb90c351a9845d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:936/format:webp/1*WmR_IqpnhwVgNi6DlpHc6A.png"/></div></figure><p id="52bd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">耶！！我们得到了内容中带有<em class="kj"> children.props </em>的所有三个组件。现在，继续尝试Content.js中的以下代码来分别访问每个组件。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ms"><img src="../Images/cfd79a7d173425883c3b8ab2a606b3a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*6og3KorAhI7Xt8e3VRNnLQ.png"/></div></figure><p id="8239" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你会看到这是行不通的。这是<em class="kj">儿童道具</em>范围结束和<em class="kj">渲染道具</em>开始的地方。所以，现在我们将重构代码来实现<em class="kj"> render.props </em></p><p id="5a11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码链接:<a class="ae ki" href="https://codesandbox.io/s/y848622v9" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/y848622v9</a></p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><blockquote class="na nb nc"><p id="92fa" class="jk jl kj jm b jn jo jp jq jr js jt ju nd jw jx jy ne ka kb kc nf ke kf kg kh ig bi translated">我们将使用相同的代码，只在需要的地方重构文件。</p></blockquote><p id="bf4f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">第一步:按照下面的截图重构Index.js。</em></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/0f57e235b1c7a1fc7b3b22065c4e1cc0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1036/format:webp/1*XzNXZsvdKyKPbl8n0k2pqw.png"/></div></figure><p id="8912" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">第二步:在Content.js中，用section或div标签包装每个组件。(根据下面的截图)。</em></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nh"><img src="../Images/27a3fb01edb5de580541a51e8f5d890f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*MQz1JZQbfCl2adQYzzw4cw.png"/></div></figure><p id="6a3a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">哇。！所以，现在我们能够独立地得到每个组件，并且它有自己的包装。满足了第一个要求，我们也看到了如何在缺少<em class="kj">儿童道具</em>的地方使用<em class="kj">渲染道具</em>。</p><p id="093c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">第二个要求是将<em class="kj">道具</em>传递给组件。为此，我们将转到<em class="kj"> Content.js </em>并将<em class="kj">道具</em>添加到渲染组件(<em class="kj">第6和第7行)。(参见下图截图)</em></p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div role="button" tabindex="0" class="kq kr di ks bf kt"><div class="gh gi ni"><img src="../Images/bdec965460154c965239aaab4db6b2e3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EyF1WZ_gFjHTEtrI0-76zw.png"/></div></div></figure><blockquote class="na nb nc"><p id="13b5" class="jk jl kj jm b jn jo jp jq jr js jt ju nd jw jx jy ne ka kb kc nf ke kf kg kh ig bi translated">如果你注意到上面的截图，我们正在传递圆括号中的道具，代表一个函数。是的，我们称之为道具。这里的功能是传递道具，但是等待我们的Content.js持有简单的Component，然后它将如何处理它。现在，我们将最后一次重新访问Content.js。</p></blockquote><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nj"><img src="../Images/adab0be8cc1c0c9c7470f284c7d42572.png" data-original-src="https://miro.medium.com/v2/resize:fit:1370/format:webp/1*68gyBdrZi4xpV4S2SSdgcQ.png"/></div></figure><p id="bf74" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在15号线上方，我们正在传递一个函数作为道具，以访问从6号线传递的道具并返回组件。</p><figure class="kl km kn ko gt kp gh gi paragraph-image"><div class="gh gi nk"><img src="../Images/bef52335a1a2e1ca5028bf859e255d01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1176/format:webp/1*s6Y7D08RVNxLZBUZ_I_OYg.png"/></div></figure><p id="2ceb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，现在您可以访问<em class="kj"> Left.js </em>中的标题作为<em class="kj">道具</em>。有了这个，我们也能够成功地满足第二个要求。</p><p id="2a5e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">代码链接:<a class="ae ki" href="https://codesandbox.io/s/9y6zpj4jjy" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/9y6zpj4jjy</a></p><blockquote class="na nb nc"><p id="dadd" class="jk jl kj jm b jn jo jp jq jr js jt ju nd jw jx jy ne ka kb kc nf ke kf kg kh ig bi translated">Summary，render.props让我们将组件作为道具传递，您也可以将组件作为函数传递，返回组件并从包装器组件访问道具。当您想要独立访问render.props中传递的每个组件时，这是很重要的，这在children.props中是不可能的。</p></blockquote></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><p id="6f33" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你喜欢它，请分享并为它鼓掌。你可以在推特上关注我——twitter.com/hellonehha</p></div><div class="ab cl mt mu hr mv" role="separator"><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my mz"/><span class="mw bw bk mx my"/></div><div class="ig ih ii ij ik"><h2 id="07b1" class="nl kx in bd ky nm nn dn lc no np dp lg jv nq nr lk jz ns nt lo kd nu nv ls nw bi translated">进一步阅读</h2><div class="nx ny gp gr nz oa"><a href="https://bit.cloud/blog/how-to-reuse-react-components-across-your-projects-l4pz83f4" rel="noopener  ugc nofollow" target="_blank"><div class="ob ab fo"><div class="oc ab od cl cj oe"><h2 class="bd io gy z fp of fr fs og fu fw im bi translated">如何在项目中重用反应组件</h2><div class="oh l"><h3 class="bd b gy z fp of fr fs og fu fw dk translated">最后，您完成了在应用程序中为表单创建一个奇妙的输入字段的任务。你对…很满意</h3></div><div class="oi l"><p class="bd b dl z fp of fr fs og fu fw dk translated">bit.cloud</p></div></div><div class="oj l"><div class="ok l ol om on oj oo ku oa"/></div></div></a></div><p id="696a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="kj">更多内容请看</em><a class="ae ki" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="kj">plain English . io</em></strong></a><em class="kj">。报名参加我们的</em> <a class="ae ki" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kj">免费周报</em> </strong> </a> <em class="kj">。关注我们关于</em><a class="ae ki" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="kj">Twitter</em></strong></a><a class="ae ki" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="kj">LinkedIn</em></strong></a><strong class="jm io"><em class="kj"/></strong><a class="ae ki" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="kj">YouTube</em></strong></a><strong class="jm io"><em class="kj">，以及</em></strong><em class="kj"/><a class="ae ki" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="jm io"><em class="kj">不和</em> </strong> </a>  <em class="kj">对成长黑客感兴趣？检查</em> <a class="ae ki" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="jm io"> <em class="kj">电路</em> </strong> </a> <strong class="jm io"> <em class="kj">。</em> </strong></p></div></div>    
</body>
</html>