<html>
<head>
<title>React Native Notifications with Server-Sent Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用服务器发送的事件对本机通知做出反应</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-native-local-notifications-with-server-sent-events-e1df2d2e3ffa?source=collection_archive---------1-----------------------#2019-11-29">https://javascript.plainenglish.io/react-native-local-notifications-with-server-sent-events-e1df2d2e3ffa?source=collection_archive---------1-----------------------#2019-11-29</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/b25584777acf274b9d5c7609b19e9561.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dM95nEifsdQjKfVbQSrI0A.png"/></div></div></figure><div class=""/><ol class=""><li id="4b7f" class="jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp bi translated"><em class="kq">为什么？什么？等待..你在说什么？为什么呢？</em></li><li id="531c" class="jy jz jb ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated"><em class="kq">在Express Node.js服务器上设置服务器发送的事件</em></li><li id="9435" class="jy jz jb ka b kb kr kd ks kf kt kh ku kj kv kl km kn ko kp bi translated"><em class="kq">在React本地应用中监听服务器发送的事件</em></li></ol></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="23b7" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><em class="mb"> 1。为什么？什么？等待..你在说什么？为什么呢？</em></h1><p id="642c" class="pw-post-body-paragraph mc md jb ka b kb me mf mg kd mh mi mj kf mk ml mm kh mn mo mp kj mq mr ms kl ij bi translated">我想为我的React本机应用程序提供一些通知，但我认为推送通知看起来非常复杂，没有明确的方法来解释如何做，不赞成使用的库等。<em class="kq">(现在我更清楚了，因为</em> <a class="ae mt" href="https://medium.com/swlh/rn-push-notifications-a-complete-guide-front-back-8c238fc81d28" rel="noopener"> <em class="kq">我花了很多时间挖掘这个主题</em> </a> <em class="kq"> ) </em></p><p id="7ea9" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">所以我挺郁闷的，因为我在app里建了聊天，没有推送通知的聊天不算聊天。</p><p id="47c9" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">没有推送通知的聊天不算聊天？真的吗？</p><p id="710a" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">然后我意识到:我真的需要推送通知吗？我个人一点都不喜欢他们。对我自己来说，我把我所有的聊天软件(Messenger，WhatsApp，等等)和邮件都关掉了。我只为我的短信保留它们，因为我只接收我妻子的短信，为了我的婚姻，最好为我妻子保留推送通知…</p><p id="0aea" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">所以我改变了我的应用程序的规格:严格来说，我想要的不是推送通知。我想要的是:</p><ul class=""><li id="a761" class="jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl mx kn ko kp bi translated">当我的应用程序在后台时，什么都不会发生——因为这是推送通知的区域，我现在没有能力设置它们。我不想要他们，更重要的是。是的，就是这样:不是我<em class="kq">不能</em>实现它们，而是我<em class="kq">不想</em>实现它们。甚至更好。</li><li id="0a01" class="jy jz jb ka b kb kr kd ks kf kt kh ku kj kv kl mx kn ko kp bi translated">当我的应用程序从后台转到前台时，或者当它从头开始打开时，以某种通知的形式显示新消息。这很简单，只需从我的服务器上获取:问题甚至在拥有它之前就已经解决了。</li><li id="472a" class="jy jz jb ka b kb kr kd ks kf kt kh ku kj kv kl mx kn ko kp bi translated">当我的应用程序在前台时，如果有其他用户的新消息，就从他们那里获取。从技术上来说，这意味着:<strong class="ka jc">我需要应用程序监听服务器，这个服务器在需要时发送数据</strong>。</li></ul><p id="4b42" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">那是我在朋友Google上挖的，我发现了神奇的东西:<strong class="ka jc">服务器发送事件</strong>，也叫<strong class="ka jc"> SSE。</strong>我叫他们太多SSE了，我都忘了单词的意思了，我也经常叫技术服务器- <em class="kq">端</em>事件，不过反正。</p><p id="53e1" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">你猜怎么着:我花了2到3个小时在我的应用程序中设置这个，时间包括谷歌搜索、编码部分、编码部分的失败和最后的成功，其中推送通知花了我至少15个小时。</p><p id="f720" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">所以让我们开始吧。</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="1bdb" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><em class="mb"> 2。在Express Node.js服务器上设置服务器发送的事件</em></h1><p id="7f64" class="pw-post-body-paragraph mc md jb ka b kb me mf mg kd mh mi mj kf mk ml mm kh mn mo mp kj mq mr ms kl ij bi translated">嗯，没有比在那里放一段代码，加上注释更好的解释了。</p><p id="3aeb" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">只是给你个背景:我的Node.js app是用Express 4.16.4构建的。</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="9942" class="nh le jb nd b gy ni nj l nk nl">const { getUserId } = require('../handlers/getUserId');</span><span id="847f" class="nh le jb nd b gy nm nj l nk nl">const SSE_RESPONSE_HEADER = {<br/>  'Connection': 'keep-alive',<br/>  'Content-Type': 'text/event-stream',<br/>  'Cache-Control': 'no-cache',<br/>  'X-Accel-Buffering': 'no'<br/>};</span><span id="a4ee" class="nh le jb nd b gy nm nj l nk nl"><em class="kq">// We can't store our streams in database as they are response objects with javascript functions included</em></span><span id="b522" class="nh le jb nd b gy nm nj l nk nl">global.usersStreams = {}</span><span id="2796" class="nh le jb nd b gy nm nj l nk nl"><br/>exports.setupStream = (req, res, next) =&gt; {</span><span id="0d2c" class="nh le jb nd b gy nm nj l nk nl">  let userId = getUserId(req);<br/>  if (!userId) {<br/>    next({ message: 'stream.no-user' })<br/>    return;<br/>  }</span><span id="f071" class="nh le jb nd b gy nm nj l nk nl">  <em class="kq">// Store this connection</em><br/>  global.usersStreams[userId] = {<br/>    res,<br/>    lastInteraction: null,<br/>  }</span><span id="87da" class="nh le jb nd b gy nm nj l nk nl"><em class="kq">  // Writes response header</em><br/>  res.writeHead(200, SSE_RESPONSE_HEADER);<br/></span><span id="4192" class="nh le jb nd b gy nm nj l nk nl"><em class="kq">  // Note: Heatbeat for avoidance of client's request timeout of first time (30 sec, can be fine tuned)</em><br/>  res.write(`data: ${JSON.stringify({type: 'heartbeat' })}\n\n`);<br/>  global.usersStreams[userId].lastInteraction = Date.now()<br/></span><span id="0788" class="nh le jb nd b gy nm nj l nk nl"><em class="kq">// Interval loop</em><br/>  const maxInterval = 55000;<br/>  const interval = 3000;<br/>  let intervalId = setInterval(function() {<br/>    if (!global.usersStreams[userId]) return;<br/>    if (Date.now() - global.usersStreams[userId].lastInteraction &lt; maxInterval) return;<br/>    res.write(`data: ${JSON.stringify({type: 'heartbeat'})}\n\n`);<br/>    global.usersStreams[userId].lastInteraction = Date.now()<br/>  }, interval);</span><span id="277c" class="nh le jb nd b gy nm nj l nk nl">function cleanConnection() {<br/>  let userId = getUserId(req);<br/>  clearInterval(intervalId);<br/>  delete global.usersStreams[userId];<br/>}</span><span id="833a" class="nh le jb nd b gy nm nj l nk nl">req.on("close", cleanConnection);</span><span id="de52" class="nh le jb nd b gy nm nj l nk nl">req.on("end", cleanConnection);</span><span id="ffe5" class="nh le jb nd b gy nm nj l nk nl">};</span><span id="8fa8" class="nh le jb nd b gy nm nj l nk nl">exports.sendStream = async (userId, data) =&gt; {</span><span id="a98b" class="nh le jb nd b gy nm nj l nk nl">if (!userId) return;<br/>  if (!global.usersStreams[userId]) return;<br/>  if (!data) return;</span><span id="aee3" class="nh le jb nd b gy nm nj l nk nl">const { res } = global.usersStreams[userId];</span><span id="03bd" class="nh le jb nd b gy nm nj l nk nl">res.write(`data: ${JSON.stringify(data)}\n\n`);<br/>  global.usersStreams[userId].lastInteraction = Date.now();</span><span id="b4d8" class="nh le jb nd b gy nm nj l nk nl">};</span></pre><p id="4702" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">上面的代码运行良好，如果我参考一些专家的话<a class="ae mt" href="https://stackoverflow.com/a/58823176/5225096" rel="noopener ugc nofollow" target="_blank">还不错，但我确信它应该得到改进，我很好奇你对此有什么看法。</a></p><p id="0df1" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">所以让我们总结一下重要的事情:</p><ul class=""><li id="de87" class="jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl mx kn ko kp bi translated">一个<code class="fe nn no np nd b">keep-alive</code>连接需要被刺激以保持活跃。可以在主题上找到一些<a class="ae mt" href="https://contourline.wordpress.com/2011/03/30/preventing-server-timeout-in-node-js/" rel="noopener ugc nofollow" target="_blank">博客帖子</a>以了解应该多长时间刺激一次，并且似乎对于Node.js，连接在2分钟超时后关闭。我没有发现任何精确的东西，但是我设置了一个55秒的超时(代码中的<code class="fe nn no np nd b">maxInterval</code>),它工作了。</li><li id="17bf" class="jy jz jb ka b kb kr kd ks kf kt kh ku kj kv kl mx kn ko kp bi translated">注意你需要储存的是<code class="fe nn no np nd b">response</code>，而不是<code class="fe nn no np nd b">request</code>。这样你就可以使用<code class="fe nn no np nd b">response.write</code>。不是<code class="fe nn no np nd b">request.write</code>。</li><li id="5590" class="jy jz jb ka b kb kr kd ks kf kt kh ku kj kv kl mx kn ko kp bi translated">响应对象不能存储在数据库中，因为它不能序列化和重新膨胀，所以它需要存储在变量中。不需要<code class="fe nn no np nd b">global</code>变量是因为你不在其他文件中使用它。</li></ul><p id="5b28" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">现在要写的内容流(<code class="fe nn no np nd b">===</code>你发送的)，我花了一些时间来理解如何组织它。这就是为什么你只看到<code class="fe nn no np nd b"><strong class="ka jc">res.write('data:</strong> some bullshit<strong class="ka jc">\n\n')</strong></code>的原因，因为我在一个月前写了代码，我还没有想出如何使事情正常进行。现在我写这篇文章，我想解开这个谜，我做到了！以下是我了解到的情况，以及规格说明中提到的内容:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="6bc5" class="nh le jb nd b gy ni nj l nk nl">res.write('id: 12345\n')<br/>res.write(':lines starting with : are comments and will be ignored')<br/>res.write('event: message\n')<br/>res.write('retry: 5000\n')<br/>res.write(`data: ${JSON.stringify(anyDataObject)}\n\n`) </span></pre><ul class=""><li id="e99c" class="jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl mx kn ko kp bi translated">正如<code class="fe nn no np nd b">Content-Type: text/event-stream</code>告诉我们的，我们的流只有文本。这也意味着它可以是一个字符串化JSON。所以让我们把我们正在发送的文本称为:<strong class="ka jc">文本</strong>，这样我们实际上就做了<code class="fe nn no np nd b">res.write(TEXT)</code></li><li id="1064" class="jy jz jb ka b kb kr kd ks kf kt kh ku kj kv kl mx kn ko kp bi translated">a <code class="fe nn no np nd b">response</code>等看了<code class="fe nn no np nd b">\n\n</code>才知道内容已经写完了，可以发送了。</li><li id="f589" class="jy jz jb ka b kb kr kd ks kf kt kh ku kj kv kl mx kn ko kp bi translated">一次可以发送多条文本:需要用<code class="fe nn no np nd b">\n</code>将它们分开</li><li id="8e3a" class="jy jz jb ka b kb kr kd ks kf kt kh ku kj kv kl mx kn ko kp bi translated">以<code class="fe nn no np nd b">:</code>开头的行将被视为注释，将被省略。</li><li id="0326" class="jy jz jb ka b kb kr kd ks kf kt kh ku kj kv kl mx kn ko kp bi translated">如果一行不是以<code class="fe nn no np nd b">:</code>开始，而是包含在中间，那么它应该被解释为一个字段/值行，只有四个可用字段</li></ul><p id="d909" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated"><strong class="ka jc">事件:</strong>事件的类型。它将允许您对不同的内容使用相同的流。<strong class="ka jc">客户可以决定只“听”一种类型的事件</strong>，或者对每种事件类型做出不同的解释。</p><p id="99ec" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated"><strong class="ka jc">数据:</strong>消息的数据字段。你可以把连续的“数据”线。</p><p id="506a" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated"><strong class="ka jc"> ID </strong>:每个事件流的ID。有助于跟踪丢失的邮件。</p><p id="2e8e" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated"><strong class="ka jc">重试:</strong>这是一个我还不会使用的字段，因为我不明白为什么我会需要它，但是为了您的信息<a class="ae mt" href="https://apifriends.com/api-streaming/server-sent-events/" rel="noopener ugc nofollow" target="_blank">我找到了这个解释</a>:</p><blockquote class="nq nr ns"><p id="9b8e" class="mc md kq ka b kb kc mf mg kd ke mi mj nt mu ml mm nu mv mo mp nv mw mr ms kl ij bi translated">所有连接丢失后，浏览器尝试新连接之前所用的时间(毫秒)。重新连接过程是自动的，默认设置为3秒。在这个重新连接的过程中，最后收到的ID将自动发送到服务器… …这需要你自己用Websockets或长轮询来编码。</p></blockquote><p id="5e5e" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">后端就是这样。很简单，对吧？</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="1aff" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated"><em class="mb"> 3。在React本地应用中监听服务器发送的事件</em></h1><p id="03d4" class="pw-post-body-paragraph mc md jb ka b kb me mf mg kd mh mi mj kf mk ml mm kh mn mo mp kj mq mr ms kl ij bi translated">这一部分也很简单:我们需要设置一个<a class="ae mt" href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource" rel="noopener ugc nofollow" target="_blank">事件源</a>。我<a class="ae mt" href="https://github.com/jordanbyron/react-native-event-source" rel="noopener ugc nofollow" target="_blank">看到</a> <code class="fe nn no np nd b"><a class="ae mt" href="https://github.com/jordanbyron/react-native-event-source" rel="noopener ugc nofollow" target="_blank">react-native-event-source </a></code> <a class="ae mt" href="https://github.com/jordanbyron/react-native-event-source" rel="noopener ugc nofollow" target="_blank"> lib </a>在为React Native做这个工作(其实只是JS，所以也可以在React Native之外使用)，但是在我的代码里没有用，不知道为什么。所以我所做的是在我的代码中残酷地复制粘贴<code class="fe nn no np nd b"><a class="ae mt" href="https://github.com/jordanbyron/react-native-event-source/blob/master/index.js" rel="noopener ugc nofollow" target="_blank">RNEventSource</a></code> <a class="ae mt" href="https://github.com/jordanbyron/react-native-event-source/blob/master/index.js" rel="noopener ugc nofollow" target="_blank">类代码</a>，以及<code class="fe nn no np nd b"><a class="ae mt" href="https://github.com/jordanbyron/react-native-event-source/blob/master/EventSource.js" rel="noopener ugc nofollow" target="_blank">EventSource polyfill</a></code> <a class="ae mt" href="https://github.com/jordanbyron/react-native-event-source/blob/master/EventSource.js" rel="noopener ugc nofollow" target="_blank">和</a>:然后它在我的代码中工作得非常好。</p><p id="486d" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">这就是了！</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="a05a" class="nh le jb nd b gy ni nj l nk nl">import React from 'react';<br/>import { AppState } from 'react-native';<br/>import { BACKEND } from '../api';<br/>import RNEventSource from '../event-source';</span><span id="6970" class="nh le jb nd b gy nm nj l nk nl">class Notifications extends React.Component {<br/>  state = {<br/>    appState: AppState.currentState,<br/>  };</span><span id="0ee1" class="nh le jb nd b gy nm nj l nk nl">  componentDidMount() {<br/>    AppState.addEventListener('change', this._handleAppStateChange);<br/>    this.startStream();<br/>  }</span><span id="bf1a" class="nh le jb nd b gy nm nj l nk nl">  _handleAppStateChange = async nextAppState =&gt; {<br/>    const { appState } = this.state;<br/>    const inactive = /inactive|background/;<br/>    const active = /active/;<br/>    if (appState.match(inactive) &amp;&amp; nextAppState.match(active)) {<br/>      this.startStream();<br/>    }<br/>    if (appState.match(active) &amp;&amp; nextAppState.match(inactive)) {<br/>      this.endStream();<br/>    }<br/>    this.setState({ appState: nextAppState });<br/>  };</span><span id="4a74" class="nh le jb nd b gy nm nj l nk nl">  requestStreamWithBackend = userId =&gt; {<br/>    return new RNEventSource(`${BACKEND}/stream/${userId}`);<br/>  }<br/>  <br/>  startStream = () =&gt; {<br/>    if (this.streamStarted) return;<br/>    try {<br/>      const { userId, catchServerSideEventRequested } = this.props;<br/>      this.eventSource = this.requestStreamWithBackend(userId);<br/>      this.eventSource.addEventListener('message', message =&gt; {<br/>        catchServerSideEventRequested(message);<br/>      });<br/>      this.streamStarted = true;<br/>    } catch (e) {<br/>      console.log('startstream error', e);<br/>    }<br/>  };</span><span id="a20d" class="nh le jb nd b gy nm nj l nk nl">  endStream = () =&gt; {<br/>    if (!this.eventSource) return;<br/>    this.eventSource.removeAllListeners();<br/>    this.eventSource.close();<br/>    this.streamStarted = false;<br/>  };</span><span id="2078" class="nh le jb nd b gy nm nj l nk nl">  componentWillUnmount() {<br/>    this.endStream();<br/>  }</span><span id="b20c" class="nh le jb nd b gy nm nj l nk nl">  render() {<br/>    return null;<br/>  }<br/>}</span><span id="5eb5" class="nh le jb nd b gy nm nj l nk nl">export default Notifications;</span></pre><p id="a60b" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">看着这段代码，您可能会想:如果我一直在渲染<code class="fe nn no np nd b">null</code>，为什么我要使用React组件？首先，我在我的应用程序中设置了<code class="fe nn no np nd b">redux</code>和<code class="fe nn no np nd b">redux-saga</code>，但是我对<code class="fe nn no np nd b">redux-saga</code>的<code class="fe nn no np nd b">channel</code>设置不太适应，这是我完成这项工作所需要的。第二是<code class="fe nn no np nd b">React.Component</code>生命周期实际上非常适合处理流的打开/重启/关闭循环:易于编写，易于理解……对我来说非常完美。第三:我实际上最终在我的应用程序中显示了通知，这是我在最终代码中呈现的…</p><p id="bf41" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">反正那里没什么难懂的。</p><p id="f84b" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">但是有一件事我花了太多时间才明白:<code class="fe nn no np nd b">res.write('event: an-event-type\n')</code>和<code class="fe nn no np nd b">this.eventSource.addEventListener('message', ...)</code>之间的关系。每次我在我的后端设置一个事件——比如<code class="fe nn no np nd b">chat-message</code>或<code class="fe nn no np nd b">test</code>或<code class="fe nn no np nd b">prout</code>(这是我在测试时经常使用的一个词)——我在我的前端看不到任何东西。直到<a class="ae mt" href="https://github.com/jordanbyron/react-native-event-source/blob/98b8730621f4ffeca865354ed7d2d22a8795a6bd/EventSource.js#L108" rel="noopener ugc nofollow" target="_blank">我在</a> <code class="fe nn no np nd b"><a class="ae mt" href="https://github.com/jordanbyron/react-native-event-source/blob/98b8730621f4ffeca865354ed7d2d22a8795a6bd/EventSource.js#L108" rel="noopener ugc nofollow" target="_blank">EventSource</a></code> <a class="ae mt" href="https://github.com/jordanbyron/react-native-event-source/blob/98b8730621f4ffeca865354ed7d2d22a8795a6bd/EventSource.js#L108" rel="noopener ugc nofollow" target="_blank"> polyfill </a>中挖掘发现:</p><pre class="my mz na nb gt nc nd ne nf aw ng bi"><span id="bbe7" class="nh le jb nd b gy ni nj l nk nl">eventsource.dispatchEvent(eventType || 'message', event);</span></pre><p id="08dd" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">这意味着要用<code class="fe nn no np nd b">res.write('event: chat-message\n')</code>接收流，需要设置<code class="fe nn no np nd b">this.eventSource.addEventListener('chat-message', ...)</code>。</p><p id="2f79" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">当你知道时，这听起来可能很愚蠢——对我来说确实如此，但我可以告诉你:我花了几个小时试图了解错误是来自后端，还是来自前端，或者其他什么…</p></div><div class="ab cl kw kx hu ky" role="separator"><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb lc"/><span class="kz bw bk la lb"/></div><div class="ij ik il im in"><h1 id="a2e0" class="ld le jb bd lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma bi translated">结论</h1><p id="9237" class="pw-post-body-paragraph mc md jb ka b kb me mf mg kd mh mi mj kf mk ml mm kh mn mo mp kj mq mr ms kl ij bi translated">这篇文章到此为止，我认为它相当直截了当，但请告诉我是否可以修改它以使它变得更好。</p><p id="3182" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">最后一件事，回到与推送通知的比较:我们刚刚在我们的应用程序<strong class="ka jc">中设置的是</strong>推送通知系统，但只有当应用程序在前台时。而Apple for iOS或Google for Android处理的推送通知系统可能并没有严格使用SSE，但我猜它是一种遵循相同原理的技术:<strong class="ka jc">任何推送通知都需要服务器发送一个流给正在监听服务器的软件。</strong>对于苹果/谷歌推送通知，是苹果/谷歌服务器通过某种<em class="kq">(我不知道)</em>方法<em class="kq"> </em>发送通知到iOS/Android软件，监听他们的服务器。对于我们的本地通知，是我们通过服务器发送的事件向我们的应用软件发送通知。</p><p id="c1ae" class="pw-post-body-paragraph mc md jb ka b kb kc mf mg kd ke mi mj kf mu ml mm kh mv mo mp kj mw mr ms kl ij bi translated">女士们，先生们，女士们，先生们，干杯</p><h1 id="9199" class="ld le jb bd lf lg nw li lj lk nx lm ln lo ny lq lr ls nz lu lv lw oa ly lz ma bi">🍻</h1><h1 id="da0d" class="ld le jb bd lf lg nw li lj lk nx lm ln lo ny lq lr ls nz lu lv lw oa ly lz ma bi translated">参考</h1><figure class="my mz na nb gt is"><div class="bz fp l di"><div class="ob oc l"/></div></figure><div class="ip iq gp gr ir od"><a href="https://www.html5rocks.com/en/tutorials/eventsource/basics/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jc gy z fp oi fr fs oj fu fw ja bi translated">使用服务器发送的事件流更新- HTML5 Rocks</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">如果您无意中看到这篇文章，并对“服务器发送事件(SSEs)到底是什么”感到疑惑，我不会感到惊讶…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">www.html5rocks.com</p></div></div><div class="om l"><div class="on l oo op oq om or ix od"/></div></div></a></div><div class="ip iq gp gr ir od"><a href="https://apifriends.com/api-streaming/server-sent-events/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jc gy z fp oi fr fs oj fu fw ja bi translated">用用例解释服务器发送的事件</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">在过去几个月与许多开发人员讨论后，我意识到他们中的很大一部分…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">apifriends.com</p></div></div><div class="om l"><div class="os l oo op oq om or ix od"/></div></div></a></div><div class="ip iq gp gr ir od"><a href="https://jasonbutz.info/2018/08/server-sent-events-with-node/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jc gy z fp oi fr fs oj fu fw ja bi translated">服务器发送的带有节点的事件</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">服务器发送事件(SSEs)允许从服务器到客户端的单向通信。他们可以非常有用的东西…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">jasonbutz.info</p></div></div><div class="om l"><div class="ot l oo op oq om or ix od"/></div></div></a></div><div class="ip iq gp gr ir od"><a href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jc gy z fp oi fr fs oj fu fw ja bi translated">事件源</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">EventSource接口是web内容与服务器发送的事件的接口。EventSource实例打开一个持久的…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">developer.mozilla.org</p></div></div><div class="om l"><div class="ou l oo op oq om or ix od"/></div></div></a></div><div class="ip iq gp gr ir od"><a href="https://github.com/jordanbyron/react-native-event-source" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jc gy z fp oi fr fs oj fu fw ja bi translated">约旦拜伦/反应-本地-事件-来源</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">React本机应用程序的服务器发送事件！基于@remy的EventSource polyfill。在您的…中运行以下命令</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">github.com</p></div></div><div class="om l"><div class="ov l oo op oq om or ix od"/></div></div></a></div><div class="ip iq gp gr ir od"><a href="https://www.w3.org/TR/2009/WD-eventsource-20090421/" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd jc gy z fp oi fr fs oj fu fw ja bi translated">服务器发送的事件</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">该规范定义了一个API，用于打开HTTP连接，以便从服务器接收推送通知…</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">www.w3.org</p></div></div></div></a></div></div></div>    
</body>
</html>