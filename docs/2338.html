<html>
<head>
<title>Using TypeScript — Never and Unknown Types, Removing null from Unions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用TypeScript-Never和未知类型，从联合中移除null</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-typescript-never-and-unknown-types-removing-null-from-unions-81aa77842725?source=collection_archive---------5-----------------------#2020-06-14">https://javascript.plainenglish.io/using-typescript-never-and-unknown-types-removing-null-from-unions-81aa77842725?source=collection_archive---------5-----------------------#2020-06-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a15625c246122411c5fed89921105806.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Vw0bGvQ5bL_UiOm1"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@the_roaming_platypus?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">timJ</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5347" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">TypeScript是JavaScript的自然扩展，在许多项目中取代了JavaScript。</p><p id="cc57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，并不是每个人都知道它实际上是如何工作的。</p><p id="02f8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看<code class="fe lb lc ld le b">never</code>类型、<code class="fe lb lc ld le b">unknown</code>类型的使用，以及从联合中移除<code class="fe lb lc ld le b">null</code>。</p><h1 id="cc81" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">从不打字</h1><p id="ec8e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">TypeScript为我们提供了<code class="fe lb lc ld le b">never</code>类型，用于类型保护已经处理了一个值的所有可能类型的情况。</p><p id="6508" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦处理完所有可能的类型，编译器将只允许给<code class="fe lb lc ld le b">never </code>类型赋值。</p><p id="4022" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有一个<code class="fe lb lc ld le b">switch</code>语句:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="9400" class="mq lg iq le b gy mr ms l mt mu">const getTax = (price: number, format: boolean): string | number =&gt; {<br/>  if (typeof price !== "number") {<br/>    return 0;<br/>  }</span><span id="4458" class="mq lg iq le b gy mv ms l mt mu">if (format) {<br/>    return (price * 0.2).toFixed(2) as string;<br/>  }<br/>  return (price * 0.2) as number;<br/>};</span><span id="3556" class="mq lg iq le b gy mv ms l mt mu">let tax = getTax(100, false);<br/>switch (typeof tax) {<br/>  case "number":<br/>    console.log(`Number: ${tax.toFixed(2)}`);<br/>    break;<br/>  case "string":<br/>    console.log(tax);<br/>    break;<br/>  default:<br/>    let value: never = tax;<br/>    console.log(`Unexpected type for value: ${value}`);<br/>}</span></pre><p id="76d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们将<code class="fe lb lc ld le b">default</code>案例的值赋给一个<code class="fe lb lc ld le b">never</code>类型的变量，因为我们在前面的案例中处理了字符串和数字。</p><h1 id="49d6" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">使用未知类型</h1><p id="759a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">unknown</code>型是<code class="fe lb lc ld le b">any</code>的更安全的替代品。</p><p id="395a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它表明我们不知道值的类型。</p><p id="232b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将事物分配给一个<code class="fe lb lc ld le b">unknown</code>类型。</p><p id="ce1b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2e93" class="mq lg iq le b gy mr ms l mt mu">let tax: unknown = getTax(100, false);</span></pre><p id="aeb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">tax</code>如果没有类型声明，不能将其赋给另一种类型的变量。</p><h1 id="f21e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">可空类型</h1><p id="c53e" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">null</code>和<code class="fe lb lc ld le b">undefined</code>类型不在TypeScript类型系统中。</p><p id="c60d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，我们可以通过使用可空类型来创建变量的可空版本。</p><p id="274e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="21d7" class="mq lg iq le b gy mr ms l mt mu">const getTax = (price: number, format: boolean): string | number | null =&gt; {<br/>  if (typeof price !== "number") {<br/>    return null;<br/>  }</span><span id="08c2" class="mq lg iq le b gy mv ms l mt mu">if (format) {<br/>    return (price * 0.2).toFixed(2) as string;<br/>  }<br/>  return (price * 0.2) as number;<br/>};</span></pre><p id="332e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在除了<code class="fe lb lc ld le b">number</code>或者<code class="fe lb lc ld le b">string</code>之外我们还可以返回<code class="fe lb lc ld le b">null</code>。</p><p id="acef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于参数，我们可以写成:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="7678" class="mq lg iq le b gy mr ms l mt mu">const getTax = (price?: number, format: boolean): string | number | null =&gt; {<br/>  if (typeof price !== "number") {<br/>    return null;<br/>  }</span><span id="9cea" class="mq lg iq le b gy mv ms l mt mu">  if (format) {<br/>    return (price * 0.2).toFixed(2) as string;<br/>  }<br/>  return (price * 0.2) as number;<br/>};</span></pre><p id="efa6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们在参数名旁边放了一个<code class="fe lb lc ld le b">?</code>，这样我们就可以表明它可能是<code class="fe lb lc ld le b">null</code>或<code class="fe lb lc ld le b">undefined</code>。</p><h1 id="9634" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">限制可空赋值</h1><p id="e7ee" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以通过启用<code class="fe lb lc ld le b">strictNullChecks</code>编译器设置来限制<code class="fe lb lc ld le b">null</code>或<code class="fe lb lc ld le b">undefined</code>的使用。</p><p id="8138" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们将它设置为<code class="fe lb lc ld le b">true</code>，那么我们就不能将<code class="fe lb lc ld le b">null</code>赋值给不是指定了其他数据类型的变量类型。</p><p id="f3c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们打开它，那么我们将得到'类型' null '不可赋给类型' string | number '。ts(2322)'。</p><p id="2d7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们必须像以前一样将<code class="fe lb lc ld le b">null</code>添加到类型联合中。</p><h1 id="3ce4" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">从联合中移除null</h1><p id="8331" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以用非空断言从联合类型中移除<code class="fe lb lc ld le b">null</code>。</p><p id="feff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="f903" class="mq lg iq le b gy mr ms l mt mu">let tax: string | number = getTax(100, false)!;</span></pre><p id="ad0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们确保没有将<code class="fe lb lc ld le b">null</code>返回并分配给<code class="fe lb lc ld le b">tax</code>。</p><p id="b80e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用类型守卫移除<code class="fe lb lc ld le b">null</code>。</p><p id="d54f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ab0d" class="mq lg iq le b gy mr ms l mt mu">if (tax !== null) {  <br/>  //..<br/>}</span></pre><p id="82de" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在继续之前进行空值检查。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/65ce6b949c1bf92274293f8a08c14e19.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Q7mnLWRESC4VDesO"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@miracletwentyone?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joseph Gonzalez</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="4ac1" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">明确赋值断言</h1><p id="a796" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">如果<code class="fe lb lc ld le b">strictNullChecks</code>选项被启用，如果变量在赋值前被使用，编译器将报告一个错误。</p><p id="756c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以将<code class="fe lb lc ld le b">null</code>添加到<code class="fe lb lc ld le b">tax</code>变量的联合类型中，然后在以后断言它。</p><p id="a7e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们写道:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6a02" class="mq lg iq le b gy mr ms l mt mu">let tax: string | number | null = getTax(100, false);</span></pre><p id="bda8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe lb lc ld le b">as</code>或者括号把它缩小到其他语句中我们想要的类型。</p><h1 id="14af" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="257d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">当我们在条件语句中处理所有其他类型时，会用到<code class="fe lb lc ld le b">never</code>类型。</p><p id="b520" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">unknown</code>比<code class="fe lb lc ld le b">any</code>更安全。<code class="fe lb lc ld le b">unknown</code>类型的变量不能赋给其他变量。</p><p id="9a4c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">从联合中移除类型有多种方法。</p><h2 id="8092" class="mq lg iq bd lh mx my dn ll mz na dp lp ko nb nc lt ks nd ne lx kw nf ng mb nh bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="c31b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>