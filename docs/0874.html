<html>
<head>
<title>Error Handling Using Error Boundaries in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中使用错误边界的错误处理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/error-handling-using-error-boundaries-in-react-e7c8f27d778e?source=collection_archive---------7-----------------------#2019-12-26">https://javascript.plainenglish.io/error-handling-using-error-boundaries-in-react-e7c8f27d778e?source=collection_archive---------7-----------------------#2019-12-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="f04f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">一种处理React组件内部错误而不使应用崩溃的方法</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/f7f96181d922d41e43326784309d67e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IaPhwvwogazpjAIT05qhAw.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@glenncarstenspeters?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Glenn Carstens-Peters</a> on <a class="ae kv" href="https://unsplash.com/s/photos/computer?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="49ac" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">使用试抓法</strong></h1><p id="4822" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">当你使用异步函数或者一个可能抛出错误的函数时，你如何处理这个错误？我们主要通过使用try-catch块来处理执行过程中的错误。try块是异常发生的地方，catch块是捕获错误并处理它的地方。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A simple try-catch block inside a function</figcaption></figure><p id="6bff" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">在React中，您可能会考虑编写类似如下的语法。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The implementation of try-catch block inside a React component</figcaption></figure><p id="1908" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">不幸的是，上面的代码将无法工作。Try-catch仅适用于命令式代码，而React组件是声明式的，并指定应该呈现什么样的。如果你对声明性代码和命令性代码有疑问，你可以在这里阅读伊恩·蒙迪的一篇文章。</p><div class="ms mt gp gr mu mv"><a href="https://codeburst.io/declarative-vs-imperative-programming-a8a7c93d9ad2" rel="noopener follow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">声明式编程与命令式编程</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">或者错误的反应方式</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">codeburst.io</p></div></div><div class="ne l"><div class="nf l ng nh ni ne nj kp mv"/></div></div></a></div><p id="9d2b" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">您可以使用下面的try-catch块来查看错误处理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk ml l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A example implementation of using try-catch inside render method</figcaption></figure><p id="226f" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">如上图所示，应该显示的<code class="fe nl nm nn no b">FailedComponent</code>没有正确显示(<strong class="lq ir"> <em class="mr">默认情况下，在开发模式下，React会显示错误堆栈的叠加。这在生产模式下不会显示。只需点击右上角</em> </strong>的‘x’按钮即可移除。这是试捕法所不能达到的。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="0bd9" class="kw kx iq bd ky kz nw lb lc ld nx lf lg jw ny jx li jz nz ka lk kc oa kd lm ln bi translated">使用误差边界</h1><blockquote class="ob oc od"><p id="a8b5" class="lo lp mr lq b lr mm jr lt lu mn ju lw oe mo lz ma of mp md me og mq mh mi mj ij bi translated">UI某个部分的JavaScript错误不应该破坏整个应用程序。</p></blockquote><p id="748f" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">有了上述概念，在React 16中，它引入了错误处理新概念，称为错误边界。基于React文档，下面是错误边界的定义。</p><blockquote class="ob oc od"><p id="7660" class="lo lp mr lq b lr mm jr lt lu mn ju lw oe mo lz ma of mp md me og mq mh mi mj ij bi translated">错误边界是React组件，<strong class="lq ir">捕捉子组件树中任何地方的JavaScript错误，记录这些错误，并显示回退UI </strong>而不是崩溃的组件树。错误边界在渲染期间、在生命周期方法中以及在它们下面的整个树的构造函数中捕捉错误。</p></blockquote><p id="bca8" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">下面是一个错误边界代码的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div></figure><p id="b23a" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">然后，该组件捕获所有由其子组件抛出的错误，而不会破坏应用程序。下面是我们如何使用误差边界的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk ml l"/></div></figure><p id="f6d6" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">上面的代码没有分解应用程序。错误边界捕捉由其子组件引发的错误，并显示回退组件。在上面的例子中，<code class="fe nl nm nn no b">WorkedComponent</code>抛出一个错误并被<code class="fe nl nm nn no b">ErrorBoundaries</code>捕获，然后显示一个带有<code class="fe nl nm nn no b">FailedComponent</code>的回退。这要好得多，因为我们的应用程序不会崩溃。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="f233" class="kw kx iq bd ky kz nw lb lc ld nx lf lg jw ny jx li jz nz ka lk kc oa kd lm ln bi translated">误差边界应该放在哪里</h1><p id="d9c5" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">正如文件所说，</p><blockquote class="ob oc od"><p id="4dd9" class="lo lp mr lq b lr mm jr lt lu mn ju lw oe mo lz ma of mp md me og mq mh mi mj ij bi translated">错误边界的粒度由您决定。您可以包装顶级路由组件以向用户显示“出错”消息，就像服务器端框架通常处理崩溃一样。您还可以将单个小部件封装在一个错误边界中，以防止它们破坏应用程序的其余部分。</p></blockquote><p id="8e94" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">有了这个想法，我们可以简单地创建一个错误边界，并将其作为所有组件的包装器，或者在每个组件上创建它。这带来了一个好处，我们可以让我们的应用程序仍然运行，即使应用程序的某些部分崩溃/抛出一个错误。我们可以看到下面的实现。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk ml l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">An example of placing Error Boundaries on each component</figcaption></figure><p id="19d6" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">太好了。我们的React应用程序现在仍然可以运行，即使有一个组件抛出错误。</p></div><div class="ab cl np nq hu nr" role="separator"><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu nv"/><span class="ns bw bk nt nu"/></div><div class="ij ik il im in"><h1 id="d1da" class="kw kx iq bd ky kz nw lb lc ld nx lf lg jw ny jx li jz nz ka lk kc oa kd lm ln bi translated">异步错误处理</h1><p id="837e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">好了，我们已经学习了如何使用错误边界来处理错误，那么我们完成了吗？还没有。React文档中的错误边界状态为:</p><blockquote class="ob oc od"><p id="4b2a" class="lo lp mr lq b lr mm jr lt lu mn ju lw oe mo lz ma of mp md me og mq mh mi mj ij bi translated">错误边界<strong class="lq ir">不</strong>捕捉错误:</p><p id="1182" class="lo lp mr lq b lr mm jr lt lu mn ju lw oe mo lz ma of mp md me og mq mh mi mj ij bi translated">事件处理程序(了解更多)</p><p id="cbf5" class="lo lp mr lq b lr mm jr lt lu mn ju lw oe mo lz ma of mp md me og mq mh mi mj ij bi translated"><strong class="lq ir">异步代码</strong>(如<code class="fe nl nm nn no b">setTimeout</code>或<code class="fe nl nm nn no b">requestAnimationFrame</code>回调)</p><p id="b3a5" class="lo lp mr lq b lr mm jr lt lu mn ju lw oe mo lz ma of mp md me og mq mh mi mj ij bi translated">服务器端渲染</p><p id="c760" class="lo lp mr lq b lr mm jr lt lu mn ju lw oe mo lz ma of mp md me og mq mh mi mj ij bi translated">在错误边界本身(而不是其子代)中引发的错误</p></blockquote><p id="b628" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">正如我们所见，异步代码是错误边界无法处理的代码。那么，我们还能使用那个组件来处理我们的错误吗？是的，的确如此。这里的问题是<strong class="lq ir">异步运行在渲染方法</strong>之外。如果你想知道这里的问题是什么，让我从错误边界文档中提醒你(它也在上面陈述)。</p><blockquote class="ob oc od"><p id="740b" class="lo lp mr lq b lr mm jr lt lu mn ju lw oe mo lz ma of mp md me og mq mh mi mj ij bi translated">错误边界在渲染期间、在生命周期方法中以及在它们下面的整个树的构造函数中捕捉错误。</p></blockquote><p id="1fb9" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">那么，当异步块在渲染之外运行时，我们如何在异步块中抛出错误，并且仍然被错误边界组件捕获呢？丹·阿布拉莫夫在这里提出了一个小技巧。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oh"><img src="../Images/a472b70346d20725461f47c768b6897f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dYfdPJSQPVCQEs2z3rRB-g.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">A trick that Dan Abramov suggest on “Throwing Error from hook not caught in error boundary” github issue <a class="ae kv" href="https://github.com/facebook/react/issues/14981" rel="noopener ugc nofollow" target="_blank">https://github.com/facebook/react/issues/14981</a></figcaption></figure><p id="31bd" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">这样，我们仍然可以在异步函数中抛出错误。这适用于类和函数组件。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mk ml l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">An example of the component that thrown an error inside an async function</figcaption></figure><p id="e20b" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">为了直接展示给你们看，这里是沙盒。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk ml l"/></div></figure><p id="6e91" class="pw-post-body-paragraph lo lp iq lq b lr mm jr lt lu mn ju lw lx mo lz ma mb mp md me mf mq mh mi mj ij bi translated">太好了。我们的误差边界现在同时支持同步和异步功能。我们可以使用这个组件将特定情况下的错误处理集中到一个组件中，如网络问题、失败的惰性导入和需要对所有组件进行相同行为捕捉的异步进程等等。</p><h1 id="7fdf" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">警告</h1><p id="78c2" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">虽然错误边界是强大的，但仍有一些方面需要记住。</p><ul class=""><li id="19f8" class="oi oj iq lq b lr mm lu mn lx ok mb ol mf om mj on oo op oq bi translated">未被错误边界捕获的错误仍然会导致组件反应树被卸载。(参见文档)</li><li id="f6ed" class="oi oj iq lq b lr or lu os lx ot mb ou mf ov mj on oo op oq bi translated">在撰写本文时，错误边界只能使用类组件来创建，因为<code class="fe nl nm nn no b">componentDidCatch</code>只能在类组件内部创建。</li><li id="563f" class="oi oj iq lq b lr or lu os lx ot mb ou mf ov mj on oo op oq bi translated">你应该记住所有边界不能捕捉的错误。</li></ul><div class="ms mt gp gr mu mv"><a href="https://reactjs.org/docs/error-boundaries.html" rel="noopener  ugc nofollow" target="_blank"><div class="mw ab fo"><div class="mx ab my cl cj mz"><h2 class="bd ir gy z fp na fr fs nb fu fw ip bi translated">错误边界-反应</h2><div class="nc l"><h3 class="bd b gy z fp na fr fs nb fu fw dk translated">过去，组件内部的JavaScript错误会破坏React的内部状态，导致它发出神秘的…</h3></div><div class="nd l"><p class="bd b dl z fp na fr fs nb fu fw dk translated">reactjs.org</p></div></div><div class="ne l"><div class="ow l ng nh ni ne nj kp mv"/></div></div></a></div></div></div>    
</body>
</html>