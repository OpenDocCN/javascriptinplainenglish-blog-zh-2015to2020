<html>
<head>
<title>JavaScript Coding Practice Challenges — Strings</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript编码实践挑战—字符串</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-coding-practice-challenges-strings-f2c9a98e8e5e?source=collection_archive---------0-----------------------#2020-04-06">https://javascript.plainenglish.io/javascript-coding-practice-challenges-strings-f2c9a98e8e5e?source=collection_archive---------0-----------------------#2020-04-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="2bc7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript中的问题及解决方案</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/3661604eb532f7b40d0b5bdcdce0ec2c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gzpPnQobvfW0Q0B8"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@d_mccullough?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daniel McCullough</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="3f15" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated"><strong class="ak">挑战1 —计算重复字符</strong></h1><p id="7440" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一个很常见的编程面试问题是，给定一个字符串，你需要找出字符串中的重复字符。</p><p id="948a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">输入</strong> : <code class="fe mp mq mr ms b">“adsjfdsfsfjsdjfhacabcsbajda”</code></p><p id="e848" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">输出</strong> : <code class="fe mp mq mr ms b">{ a: 5, b: 2, c: 2, d: 4, f: 4, j: 4, s: 5 }</code></p><p id="c773" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这个问题有两个解决方案。</p><h2 id="a63f" class="mt kx iq bd ky mu mv dn lc mw mx dp lg lx my mz li mb na nb lk mf nc nd lm ne bi translated">解决方案# 1</h2><p id="f06e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">第一种解决方案是迭代字符串字符，并使用一个<code class="fe mp mq mr ms b">dictionary &lt;key, value&gt;</code>将字符存储为键，将出现的次数存储为值。</p><ul class=""><li id="3fbb" class="nf ng iq lq b lr mk lu ml lx nh mb ni mf nj mj nk nl nm nn bi translated">如果当前角色从未被添加到<code class="fe mp mq mr ms b">dictionary</code>，那么将其添加为<code class="fe mp mq mr ms b">&lt;character, 1&gt;</code>。</li><li id="5cda" class="nf ng iq lq b lr no lu np lx nq mb nr mf ns mj nk nl nm nn bi translated">如果当前字符存在于<code class="fe mp mq mr ms b">dictionary</code>中，那么简单地将其<code class="fe mp mq mr ms b">occurrences</code>增加1。</li></ul><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h2 id="c481" class="mt kx iq bd ky mu mv dn lc mw mx dp lg lx my mz li mb na nb lk mf nc nd lm ne bi translated"><strong class="ak">解决方案2 </strong></h2><p id="2952" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们把字符串变成一个字符数组，然后对数组进行排序，把它们放在一起形成一个新的字符串。随着这个字符串被排序，我们可以使用一个正则表达式(这里是<code class="fe mp mq mr ms b"> /(.)\1+/g</code>)来匹配重复的字符。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="5ef8" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是两种情况下的输出。</p><pre class="kg kh ki kj gt nv ms nw nx aw ny bi"><span id="157b" class="mt kx iq ms b gy nz oa l ob oc">const str = “adsjfdsfsfjsdjfhacabcsbajda”</span><span id="4e37" class="mt kx iq ms b gy od oa l ob oc">count_duplicate_characters(str)</span><span id="8850" class="mt kx iq ms b gy od oa l ob oc">{ a: 5, b: 2, c: 2, d: 4, f: 4, j: 4, s: 5 }</span></pre><p id="f618" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你能用Unicode字符解决这个问题吗？在这里分享你的解决方案和你的评论。</p><h1 id="6d40" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">挑战2— <strong class="ak">找到第一个不重复的字符</strong></h1><p id="ce0d" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">编写一个JavaScript程序来查找字符串中第一个不重复的字符是编码挑战中的一个常见问题。我们可以在字符串的单次遍历或更完整/部分的遍历中解决这个问题。</p><p id="7024" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">输入</strong> : <code class="fe mp mq mr ms b">"cbcbdde"</code></p><p id="c897" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">输出</strong> : <code class="fe mp mq mr ms b">e</code></p><h2 id="ecdc" class="mt kx iq bd ky mu mv dn lc mw mx dp lg lx my mz li mb na nb lk mf nc nd lm ne bi translated">解决方法</h2><p id="9cec" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们将在单遍历方法中重新解决这个问题。这里，我们使用一个有256个条目的<code class="fe mp mq mr ms b">flag</code>数组来存储不重复的字符，然后我们找到包含一个不重复字符的最小索引。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="9d6a" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">尝试测试这种方法。</p><pre class="kg kh ki kj gt nv ms nw nx aw ny bi"><span id="24d7" class="mt kx iq ms b gy nz oa l ob oc">console.log(first_non_repeated_character("cbcbdde"))<br/>&lt;&lt; <strong class="ms ir">e</strong></span></pre><h1 id="2f68" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">挑战3 — <strong class="ak">颠倒字母和单词</strong></h1><p id="1e7a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">倒写字母意味着你把某些字母(或数字)倒着写。这有时被称为镜像写入。</p><p id="c29e" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">输入</strong> : <code class="fe mp mq mr ms b">"I evol uoy os !hcum"</code></p><p id="d573" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">输出</strong> : <code class="fe mp mq mr ms b">I love you so much!</code></p><h2 id="5342" class="mt kx iq bd ky mu mv dn lc mw mx dp lg lx my mz li mb na nb lk mf nc nd lm ne bi translated">解决方法</h2><p id="1791" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">使用内置函数很容易颠倒字母和单词。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="6a45" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这是输出。</p><pre class="kg kh ki kj gt nv ms nw nx aw ny bi"><span id="0fa9" class="mt kx iq ms b gy nz oa l ob oc">var test_string = "emocleW ot SJ ni nialP hsilgnE"<br/>reverse(test_string)</span><span id="f870" class="mt kx iq ms b gy od oa l ob oc">&lt;&lt; <strong class="ms ir">Welcome to JS in Plain English</strong></span></pre><h1 id="aa9e" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">挑战# 4 — <strong class="ak">生成所有排列</strong></h1><p id="ac53" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">涉及排列的问题通常也涉及<code class="fe mp mq mr ms b">recursivity</code>。基本上，递归被定义为一个给定初始状态的过程，每个<code class="fe mp mq mr ms b">successive state</code>根据<code class="fe mp mq mr ms b">preceding state</code>来定义。</p><p id="42cb" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">输入</strong> : <code class="fe mp mq mr ms b">ABC</code></p><p id="c4c0" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">输出</strong> : <code class="fe mp mq mr ms b">ABC, ACB, BCA, BAC, CAB, CBA</code></p><h2 id="2604" class="mt kx iq bd ky mu mv dn lc mw mx dp lg lx my mz li mb na nb lk mf nc nd lm ne bi translated">解决方法</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="1aee" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">你可以这样称呼它</p><pre class="kg kh ki kj gt nv ms nw nx aw ny bi"><span id="12bf" class="mt kx iq ms b gy nz oa l ob oc">permute_and_print(“ABC”)</span></pre><p id="1057" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">这将产生以下输出:</p><pre class="kg kh ki kj gt nv ms nw nx aw ny bi"><span id="6f66" class="mt kx iq ms b gy nz oa l ob oc">ABC ACB BCA BAC CAB CBA</span></pre><h1 id="3092" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">挑战5— <strong class="ak">检查一个字符串是否是回文</strong></h1><p id="f784" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">快速提醒一下，a <code class="fe mp mq mr ms b">palindrome</code>倒转时看起来没有变化。这意味着加工a <code class="fe mp mq mr ms b">palindrome</code>可以从两个方向进行，并将获得相同的结果</p><p id="12be" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">比如<code class="fe mp mq mr ms b">madam</code>这个词是回文，而<code class="fe mp mq mr ms b">madame</code>这个词不是。</p><h2 id="d27a" class="mt kx iq bd ky mu mv dn lc mw mx dp lg lx my mz li mb na nb lk mf nc nd lm ne bi translated">解决方法</h2><p id="805e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">实现依赖于while语句。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="f198" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们可以用一种更简洁的方法重写前面的解决方案，这种方法将依赖于一个<code class="fe mp mq mr ms b">for</code>语句而不是一个<code class="fe mp mq mr ms b">while</code>语句，如下所示。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="eaec" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我们能减少到一行代码吗？</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="3bb8" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">挑战# 6— <strong class="ak">按长度排序字符串数组</strong></h1><p id="8815" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">给我们一个字符串数组，我们需要按照字符串长度的递增顺序对数组进行排序</p><p id="edfe" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated"><strong class="lq ir">输入:</strong> <code class="fe mp mq mr ms b">["You", "are", "beautiful", "looking"]</code> <br/> <strong class="lq ir">输出:</strong> <code class="fe mp mq mr ms b">[“You", "are", "looking", "beautiful"]</code></p><h2 id="d2ef" class="mt kx iq bd ky mu mv dn lc mw mx dp lg lx my mz li mb na nb lk mf nc nd lm ne bi translated"><strong class="ak">解决方案</strong></h2><p id="8e5a" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">排序时首先想到的是使用比较器。在这种情况下，解决方案应该比较字符串的长度，因此通过为给定数组中的每个字符串调用<code class="fe mp mq mr ms b">.length</code>来返回整数。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><h1 id="2cac" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">挑战7— <strong class="ak">检查字符串是否包含子字符串</strong></h1><h2 id="94a6" class="mt kx iq bd ky mu mv dn lc mw mx dp lg lx my mz li mb na nb lk mf nc nd lm ne bi translated"><strong class="ak">解决方案</strong></h2><p id="7aa9" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一个非常简单的一行代码解决方案依赖于<code class="fe mp mq mr ms b">.includes()</code>函数。</p><pre class="kg kh ki kj gt nv ms nw nx aw ny bi"><span id="286b" class="mt kx iq ms b gy nz oa l ob oc">const string = “foo”<br/>const substring = “oo”</span><span id="0c0f" class="mt kx iq ms b gy od oa l ob oc">string.includes(substring)<br/>&lt;&lt; <strong class="ms ir">true</strong></span></pre><p id="f154" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">或者，可以依靠如下<code class="fe mp mq mr ms b">String.prototype.indexOf()</code>实施解决方案。</p><pre class="kg kh ki kj gt nv ms nw nx aw ny bi"><span id="45a2" class="mt kx iq ms b gy nz oa l ob oc">string.indexOf(substring) !== -1<br/>&lt;&lt; <strong class="ms ir">true</strong></span></pre><h1 id="bb57" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">挑战8 — <strong class="ak">检查两个字符串是否是字谜</strong></h1><p id="950e" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">一个字符串的变位词是包含相同字符的另一个字符串，只是字符的顺序不同。比如“<code class="fe mp mq mr ms b">abcd</code>”和“<code class="fe mp mq mr ms b">dabc</code>”是互为变位词。</p><h2 id="58d7" class="mt kx iq bd ky mu mv dn lc mw mx dp lg lx my mz li mb na nb lk mf nc nd lm ne bi translated">解决方法</h2><p id="9c86" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">我们创建一个计数数组，并将所有值初始化为0。对于输入字符串中的每个字符，递增相应计数数组中的计数。</p><pre class="kg kh ki kj gt nv ms nw nx aw ny bi"><span id="45d7" class="mt kx iq ms b gy nz oa l ob oc">for (i = 0; str1[i] &amp;&amp; str2[i]; i++) {<br/>    count[str1[i]]++<br/>    count[str2[I]]-— <br/>}</span></pre><p id="d7b3" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果两个字符串长度不同。去除这种情况将使程序对于类似“aaca”和“aca”的字符串失败</p><pre class="kg kh ki kj gt nv ms nw nx aw ny bi"><span id="40e7" class="mt kx iq ms b gy nz oa l ob oc">if<!-- --> <!-- -->(str1[i] || str2[i])<br/>    return<!-- --> <!-- -->false</span></pre><p id="a08f" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">查看count数组中是否有非零值。</p><pre class="kg kh ki kj gt nv ms nw nx aw ny bi"><span id="70ad" class="mt kx iq ms b gy nz oa l ob oc">for<!-- --> <!-- -->(i = 0; i &lt; NO_OF_CHARS; i++)<br/>    if<!-- --> <!-- -->(count[i])<br/>        return<!-- --> <!-- -->false</span></pre><p id="7b93" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">如果都不匹配，则返回一个<code class="fe mp mq mr ms b">true</code>值。这是我的完整解决方案。在这种情况下，时间复杂度为<code class="fe mp mq mr ms b">O(n)</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nt nu l"/></div></figure><p id="99ae" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">简单对吗？</p></div><div class="ab cl oe of hu og" role="separator"><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj ok"/><span class="oh bw bk oi oj"/></div><div class="ij ik il im in"><p id="30a7" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">我将在本文中更新与字符串相关的新挑战，请🔖它重新阅读并获得最新的问题和解决方案。</p><p id="ecc6" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">感谢阅读！😘</p><p id="d489" class="pw-post-body-paragraph lo lp iq lq b lr mk jr lt lu ml ju lw lx mm lz ma mb mn md me mf mo mh mi mj ij bi translated">【JavaScript用简单英语写的一句话:我们总是乐于帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的中级用户名发邮件到submissions@javascriptinplainenglish.com<a class="ae kv" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">给我们，我们会把你添加为作者。</a></p></div></div>    
</body>
</html>