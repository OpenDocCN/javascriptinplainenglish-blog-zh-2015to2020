<html>
<head>
<title>Looking to the future of JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">展望JavaScript的未来</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/looking-to-the-future-of-javascript-7792c57c79cc?source=collection_archive---------5-----------------------#2020-05-11">https://javascript.plainenglish.io/looking-to-the-future-of-javascript-7792c57c79cc?source=collection_archive---------5-----------------------#2020-05-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="351e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">ESNext:对不久的将来的建议</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/9e9349dc2d5dcf9d8697ee1df373a0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*6Cw93ZUSeMWlpq36.png"/></div></div></figure><p id="662c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">一、什么是ESNext？</p><p id="9216" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">通常，ECMAScript (JavaScript)的“下一个”版本指的是超出当前快照规范的持续移动的目标。</p><p id="a280" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我将在本文中谈论的三个特性是在TC39 <a class="ae ln" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank">流程</a>的第3和第4阶段。</p><p id="37d7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在以前的帖子中，我已经写了新规范(ES2019-ES2020)中已经集成或即将集成的新功能:</p><ul class=""><li id="ec98" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated"><a class="ae ln" href="https://medium.com/javascript-in-plain-english/javascript-es2019-es10-in-a-nutshell-cae6f7524519?source=your_stories_page---------------------------" rel="noopener">es 2019中新增的JavaScript特性</a>。</li><li id="bf8c" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><a class="ae ln" href="https://medium.com/javascript-in-plain-english/new-javascript-features-in-es2020-c2d76acf9c5a?source=your_stories_page---------------------------" rel="noopener">es 2020中的新JavaScript特性</a>。</li><li id="8370" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><a class="ae ln" href="https://medium.com/javascript-in-plain-english/nullish-coalescing-operator-for-javascript-8f502b970ba8?source=your_stories_page---------------------------" rel="noopener">如何在JavaScript中使用新的Nullish合并运算符</a>。</li><li id="e528" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><a class="ae ln" href="https://medium.com/javascript-in-plain-english/javascript-top-level-await-in-a-nutshell-4e352b3fc8c8?source=your_stories_page---------------------------" rel="noopener">JavaScript中新的“顶级等待”功能如何工作</a></li><li id="048c" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated"><a class="ae ln" href="https://medium.com/javascript-in-plain-english/subsume-json-and-well-formed-json-stringify-323f70c9dc36?source=your_stories_page---------------------------" rel="noopener">包含JSON和格式良好的JSON.stringify </a></li></ul><p id="59d5" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个新帖子是一个更新，我将包括该语言的三个新特性。前两个已经准备好包含在下一个规范中，最后一个必须遵循验收流程。</p><p id="f498" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">索引:</p><ul class=""><li id="8c3c" class="lo lp iq kt b ku kv kx ky la lq le lr li ls lm lt lu lv lw bi translated">import.meta(阶段4)</li><li id="2b0e" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">承诺.原型.最终(阶段4)</li><li id="68e3" class="lo lp iq kt b ku lx kx ly la lz le ma li mb lm lt lu lv lw bi translated">逻辑赋值||=，&amp;&amp;=，？？=.(第三阶段)</li></ul><h1 id="43df" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">import.meta</h1><p id="9ac5" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">作者:多米尼克·德尼科拉</p><p id="362e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">这个提议是为了给JavaScript添加一个导入元属性，用于保存关于当前模块的特定于主机的元数据，即关于该模块的信息。这个新属性是一个具有空原型的扩展对象，它的属性是可写的、可枚举的和可配置的。</p><p id="74a9" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">宿主环境返回一组属性(作为键/值对)，这些属性将被添加到对象中。</p><p id="d8cf" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在浏览器中我们可以使用这个属性，例如以如下方式:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="727f" class="ne md iq na b gy nf ng l nh ni">&lt;script type="module" src="one_module.mjs"&gt;&lt;/script&gt;</span></pre><p id="d4fa" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">现在，您可以使用import.meta对象来访问关于该模块的元信息，在本例中，该对象返回一个指示该模块的基本URL的对象:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="aeaf" class="ne md iq na b gy nf ng l nh ni">console.log(import.meta);<br/>//{url:"file:///home/one-module.mjs"}</span></pre><p id="a21b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">import.meta元属性在模块中语法上是有效的，因为它意味着关于当前运行的模块的元信息。</p><h1 id="ca78" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">承诺.原型.最终</h1><p id="4055" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">作者:乔丹·哈班德。</p><p id="a8f0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">许多promise库都有一个“finally”方法来注册一个回调函数，当一个promise被实现或拒绝时调用这个函数。例如，一个用例可以是记录操作已经完成，而不管它是否成功。</p><p id="3104" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“finally”方法不会收到任何争论，因为没有可靠的方法来确定承诺是被履行还是被拒绝。在这种情况下，您只想始终执行一个任务。</p><p id="df43" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在本例中，当我们执行Fetch操作时，我们希望在页面上显示一个loading微调器，但是当Fetch请求以“fulfilled”或“rejected”结束时，我们希望删除它:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="b6f1" class="ne md iq na b gy nf ng l nh ni">let loading = true;fetch(myRequest)<br/>.then( (response) =&gt; response.json))<br/>.then( json =&gt; { <br/>   //Do some stuff<br/> }.catch( (error) =&gt;{ console.error(error) }; <br/>.<strong class="na ir">finally</strong>(() =&gt; { loading = false; });</span></pre><h1 id="3c94" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">逻辑赋值</h1><p id="75f3" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">作者:贾斯汀·里奇威尔和赫曼思·HM</p><p id="6018" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">直到现在，JavaScript都不支持逻辑赋值，而现在，有了这个提议，我们可以组合逻辑运算符:“&amp;&amp;，”||，“and”？?"使用赋值表达式:" = "</p><p id="643e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请记住:</p><p id="38c7" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><em class="nj"/><a class="ae ln" href="https://medium.com/javascript-in-plain-english/nullish-coalescing-operator-for-javascript-8f502b970ba8" rel="noopener"><em class="nj"/></a><em class="nj">符？？“的行为与运算符“||”非常相似，只是它在计算运算符时不使用“truthy”。相反，它使用“nullish”的定义，这意味着该值严格等于null或未定义。</em></p><p id="c127" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">我们来看看逻辑运算的语义。</p><p id="e7c2" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">逻辑“与”的语义:</strong></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="1277" class="ne md iq na b gy nf ng l nh ni">a &amp;&amp; b;<br/>//b when a is truthy<br/>//a when a is not truthy</span></pre><p id="5995" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“还有还有。”逻辑与赋值。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="b1a1" class="ne md iq na b gy nf ng l nh ni">//These two lines are equivalent:<br/>a &amp;&amp;= b;<br/>a &amp;&amp; (a = b);</span></pre><p id="d089" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">逻辑或的语义:</strong></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="e9ac" class="ne md iq na b gy nf ng l nh ni">a || b;<br/>//a when a is truthy<br/>//b when a is not truthy</span></pre><p id="9d67" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">“或者或者。”逻辑或赋值</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="31da" class="ne md iq na b gy nf ng l nh ni">//The two lines are equivalent<br/>a || = b;<br/>a || (a = b);</span></pre><p id="f322" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><strong class="kt ir">无效合并赋值的语义:</strong></p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="8776" class="ne md iq na b gy nf ng l nh ni">a ?? b;<br/>//a when a is not nullish<br/>//b when  a is null or undefined.</span></pre><p id="5994" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">无效合并赋值:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="3899" class="ne md iq na b gy nf ng l nh ni">//The two lines are equivalent<br/>a ??= b;<br/>a ?? (a = b);</span></pre><p id="f26a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">用简单的英语说:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="e4dd" class="ne md iq na b gy nf ng l nh ni">let a = 'Hello world!';</span></pre><p id="069c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">没有逻辑赋值:a会不会<em class="nj">永远</em>是“Hello world！”即使a不是无效的:</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="001e" class="ne md iq na b gy nf ng l nh ni">a = a ?? 'Hello you!';<br/>//"Hello world!</span></pre><p id="a114" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">对于逻辑赋值:“a”也不会被重新赋值为“Hello you”，因为a不是无效的，并且“a”将保持不变。</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="f0e4" class="ne md iq na b gy nf ng l nh ni">a ??= 'Hello you!';<br/>//Hello world!</span></pre><p id="3e92" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">在这种情况下，“a”将是“你好！”</p><pre class="kg kh ki kj gt mz na nb nc aw nd bi"><span id="64f8" class="ne md iq na b gy nf ng l nh ni">let a;<br/>a ??= 'Hello you!';<br/>//Hello you!</span></pre><p id="585b" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">逻辑赋值遵循其相应操作的短路行为。如果逻辑运算将评估右侧，则它们<em class="nj">仅</em>执行赋值。</p><h1 id="337a" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">结论</h1><p id="2bc7" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">前两个提案处于第4阶段，我们将很快在规范中看到它们(ES2020？)，而最后一个提案在第3阶段，我期待它能被纳入ES2021。</p><p id="a390" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">非常感谢你阅读这篇文章！希望你觉得有用。</p><h1 id="6e5a" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">参考</h1><p id="afa0" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated"><a class="ae ln" href="https://www.ecma-international.org/memento/tc39.htm" rel="noopener ugc nofollow" target="_blank"> T39 </a>网站。</p><h2 id="e5c1" class="ne md iq bd me nk nl dn mi nm nn dp mm la no np mo le nq nr mq li ns nt ms nu bi translated">来自简明英语团队的一封信</h2><p id="99a3" class="pw-post-body-paragraph kr ks iq kt b ku mu jr kw kx mv ju kz la mw lc ld le mx lg lh li my lk ll lm ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae ln" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kt ir">JavaScript in Plain English</strong></a><a class="ae ln" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kt ir">AI in Plain English</strong></a><a class="ae ln" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kt ir">UX in Plain English</strong></a><a class="ae ln" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kt ir">Python in Plain English</strong></a><strong class="kt ir"/>—谢谢，继续学习！</p><p id="53ba" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">此外，我们总是有兴趣帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae ln" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kt ir">submissions @ plain English . io</strong></a><strong class="kt ir"/>，附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>