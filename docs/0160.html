<html>
<head>
<title>Code-splitting for efficient loading: How to use React Lazy Imports and Suspense with HOC</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">高效加载的代码分割:如何通过HOC使用React惰性导入和暂停</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/code-splitting-for-efficient-loading-how-to-use-react-lazy-imports-suspense-and-hoc-fabc8fb6525a?source=collection_archive---------0-----------------------#2019-05-30">https://javascript.plainenglish.io/code-splitting-for-efficient-loading-how-to-use-react-lazy-imports-suspense-and-hoc-fabc8fb6525a?source=collection_archive---------0-----------------------#2019-05-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/1b4091b1c90de850a1984bf640389b77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bhr-T__zANXFv4iqEx-uyg.jpeg"/></div></div></figure><p id="f28c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果只需要加载一半的代码就能获得完整的用户体验(例如，应用程序服务于不同类型的用户路径:租房者和贷款者)，那么React惰性加载可能会很有用。下面是如何让它工作。</p><figure class="kt ku kv kw gt jo"><div class="bz fp l di"><div class="kx ky l"/></div></figure><p id="5c96" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">首先，您需要通过安装依赖项将动态导入添加到React项目中:</p><p id="2f64" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">纱加</strong><a class="ae kz" href="http://twitter.com/babel/plugin-syntax-dynamic-imp" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">@ babel/plugin-syntax-dynamic-imp</strong></a><strong class="jx io">ort</strong></p><p id="dd7d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">或者</p><p id="3f85" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> npm安装</strong><a class="ae kz" href="http://twitter.com/babel/plugin-syntax-dynamic-imp" rel="noopener ugc nofollow" target="_blank"><strong class="jx io">@ babel/plugin-syntax-dynamic-imp</strong></a>T14】ort</p><p id="ca6a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后你会想要添加插件扩展到<strong class="jx io">。babelrc </strong>文件— babel插件设置数组:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi la"><img src="../Images/c37becb8f6c93146fcadf080c7a7251d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZeXP_ijTvhvFlicVn9EI7A.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><strong class="bd lf">in .babelrc:</strong> after installing dynamic imports, add the dynamic imports plugin to babel plugins array</figcaption></figure><p id="3bfb" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">接下来，让我们取消组件的标准导入的注释，只有当它们被显式“触发”时，我们才希望加载它们——例如，Route在我们更改到确切路径(url地址更改)时加载组件，而不是在整个应用程序加载时。</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/882dc19b8ed090aa81a201f0eb516007.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*zF3V0LRRGiRmwK6ZWF_S0Q.png"/></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><strong class="bd lf">in App.jsx: </strong>preparing to import the components using lazy loading</figcaption></figure><p id="21df" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用React.lazy导入组件，而不是stands import:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lh"><img src="../Images/d050f2a49a8fedff061cf7a6263f9d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkEf7dyBiVTIIwGfK9FftQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><strong class="bd lf">in App.jsx:</strong> import components using React.lazy</figcaption></figure><p id="37f6" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">以这种方式导入的组件需要使用React的<strong class="jx io">暂记组件</strong>进行渲染，并提供回退道具。当内容完全加载时，回退控制显示:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi li"><img src="../Images/45951b3bdcaccab622b0921c6faf2a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UyymA_4ClPxo_KCS6zcfZQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><strong class="bd lf">in HOC/LazyLoad.jsx: </strong>wrap your lazy loaded component with react Suspense component and fallback prop</figcaption></figure><p id="3562" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将创建一个更高阶的组件，这样该组件只有在被显式调用时才会被加载。将提供回退，以及传递给惰性导入组件的其余属性:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lj"><img src="../Images/1b086cf55585d35195ac65c8ad65bf5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CeCAYKIhufgjL_GkeHj3pg.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><strong class="bd lf">in HOC/LazyLoad.jsx:</strong> create the higher order comp. using the component prop pattern and pass all the props to the child (the lazy import component)</figcaption></figure><p id="761d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们将使用我们创建的LazyLoad HOC来包装lazy import组件，并将所有的道具传递给它们。这是为了在以后的布线中维护组件属性模式，您将在后面看到):</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lh"><img src="../Images/d050f2a49a8fedff061cf7a6263f9d1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mkEf7dyBiVTIIwGfK9FftQ.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">1. these components we imported earlier will need to be passed as component prop (see example below)</figcaption></figure><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lk"><img src="../Images/cbc6d986803d600daf4d9989118097cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q8yPEAu6rPRhv_WNaroyKA.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">2. then create pure functions for lazy imported components</figcaption></figure><p id="f6f9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们创建了纯组件，它将所有的道具传递给懒惰导入组件的暂停渲染。现在，它们已经准备好按照相同的组件属性模式在路由器中进行设置。因此，到最后，我们的惰性导入、特设悬念渲染和路由的设置应该如下所示:</p><figure class="kt ku kv kw gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi ll"><img src="../Images/b6780e966108a880a3a99111980f6bac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NySWb2RFGbZRhMagO4OINw.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk">How to be lazy in 4 steps</figcaption></figure><p id="7d60" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">希望你觉得这很有用。下次见！</p></div></div>    
</body>
</html>