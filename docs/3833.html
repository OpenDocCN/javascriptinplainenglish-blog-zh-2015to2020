<html>
<head>
<title>3 React concepts I wish I knew when I started</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">3个反应概念我希望在开始时就知道</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/some-react-concepts-i-wish-i-knew-when-i-started-6fd25c466f80?source=collection_archive---------1-----------------------#2020-10-28">https://javascript.plainenglish.io/some-react-concepts-i-wish-i-knew-when-i-started-6fd25c466f80?source=collection_archive---------1-----------------------#2020-10-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="b943" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我偶然发现<strong class="jm io">反应</strong>时，我几乎没有任何JS知识。当然，我的同行和互联网告诉我，开始使用React JS需要一些JavaScript知识，但是，我抓住了机会。属于那种“边做边学”的人，我继续探索JavaScript世界和React自带的JSX。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi ki"><img src="../Images/0ce381e4d8be7b9b39118ef561a8b417.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bdl0QENAzKWArsnQD7LxmQ.jpeg"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Cover image.</figcaption></figure><p id="c507" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这是给初学者和同类人的。</p><h2 id="a35b" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">1.严格模式</h2><p id="975f" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">我不熟悉这个概念，当我观察到这种奇怪的行为时，我花了一些时间才明白发生了什么</p><p id="ff23" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在App.js里面，我有一些非常简单的东西，</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="8d0a" class="ky kz in lx b gy mb mc l md me"><strong class="lx io">function</strong> App() {</span><span id="bd29" class="ky kz in lx b gy mf mc l md me">  console.log("app")</span><span id="0d6c" class="ky kz in lx b gy mf mc l md me"><strong class="lx io">  const</strong> [state, toggle] = useState(true);<br/></span><span id="ae3d" class="ky kz in lx b gy mf mc l md me">  return (</span><span id="0a5b" class="ky kz in lx b gy mf mc l md me">    &lt;div&gt;</span><span id="1501" class="ky kz in lx b gy mf mc l md me">    &lt;h2&gt;{`${state}`}&lt;/h2&gt;</span><span id="7ae6" class="ky kz in lx b gy mf mc l md me">    &lt;button onClick={() <strong class="lx io">=&gt;</strong> { toggle(!state) }}&gt;Toggle&lt;/button&gt;</span><span id="6287" class="ky kz in lx b gy mf mc l md me">    &lt;/div&gt;<br/> )</span><span id="fb7f" class="ky kz in lx b gy mf mc l md me">}</span></pre><p id="a2b3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我有一个标题和一个切换内容的按钮。我在函数中还有一个console.log来记录每次状态改变和重新渲染被触发时的消息。</p><p id="813a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我期望每个按钮点击都有一个日志。但是我注意到每次点击按钮，都会有两个日志。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi mg"><img src="../Images/2c38613e163ca75ba5453d2a631c1a27.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/1*6Qo5MR5yPoXcyNr9qT0Fqw.gif"/></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">Notice the logs.</figcaption></figure><p id="9217" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我继续前进，没有被这种行为所困扰。</p><p id="400c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">后来，当我在更复杂的事情中注意到同样的行为时，这让我很困扰。那时我意识到这种行为只在开发中可见，在生产中不可见。我在网上搜了一下发现，是因为<em class="mh">严格模式。</em>我注意到在index.js中，我的app被包裹在<strong class="jm io"> <em class="mh"> &lt; React内。StrictMode &gt; &lt; /React。严格模式&gt;。</em>T12】</strong></p><p id="41c9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">引用ReactJS文档本身:“<em class="mh">严格模式不能自动为您检测副作用，但它可以通过使副作用更具确定性来帮助您发现它们。这是通过有意地双重调用以下函数来实现的:类组件</em> <code class="fe mi mj mk lx b"><em class="mh">constructor</em></code> <em class="mh">、</em> <code class="fe mi mj mk lx b"><em class="mh">render</em></code> <em class="mh">和</em> <code class="fe mi mj mk lx b"><em class="mh">shouldComponentUpdate</em></code> <em class="mh">方法</em></p><p id="c992" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你正在使用create-react-app，你可能会注意到你的应用被包裹在<strong class="jm io"> <em class="mh"> &lt; React中。StrictMode &gt; &lt; /React。index.js中的StrictMode &gt; </em> </strong></p><p id="4447" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这就是问题所在。这就是为什么我每次渲染都有两个日志。我希望我知道这件事。点击阅读更多关于严格模式检查<a class="ae ml" href="https://reactjs.org/docs/strict-mode.html" rel="noopener ugc nofollow" target="_blank">的内容。</a></p><h2 id="f7a5" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">2.键</h2><p id="91da" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">当呈现多个组件时，我们通常映射列表，</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="d109" class="ky kz in lx b gy mb mc l md me">const numbers = [1, 2, 3, 4, 5];<br/>const listItems = numbers.map((number) =&gt;<br/>  &lt;li key={number.toString()}&gt;    {number}<br/>  &lt;/li&gt;<br/>);</span><span id="245d" class="ky kz in lx b gy mf mc l md me">ReactDOM.render(<br/>  &lt;ul&gt;{listItems}&lt;/ul&gt;,  document.getElementById('root')<br/>);</span></pre><p id="40d0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">React使用<em class="mh">键</em>来优化性能<em class="mh">。</em>在这里<a class="ae ml" href="https://reactjs.org/docs/reconciliation.html#component-elements-of-the-same-type" rel="noopener ugc nofollow" target="_blank"/>阅读更多关于为什么需要钥匙的信息。</p><p id="d997" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">从官方文档:<em class="mh">"关键字帮助React识别哪些项目已更改、添加或删除。应该给数组内部的元素赋予键，以给元素一个稳定的标识。</em></p><p id="489c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在一个显而易见的想法浮现在脑海中:我们可以使用数组索引作为键。但是等等，再想想，因为这不是推荐的方法。</p><p id="31b1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想想如果列表被预先考虑会发生什么，因为React只依赖键来决定DOM是否应该更新。在这里了解这个<a class="ae ml" href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318" rel="noopener">。本文使用一个非常好的文本输入例子来演示这个问题。</a></p><h2 id="ba1c" class="ky kz in bd la lb lc dn ld le lf dp lg jv lh li lj jz lk ll lm kd ln lo lp lq bi translated">3.陈旧状态</h2><p id="960c" class="pw-post-body-paragraph jk jl in jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh ig bi translated">问题是，在某些情况下，您无法掌握最新的状态。</p><p id="9199" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这一次，我费了很大的劲才明白过来。对于一个不知道闭包以及它们为什么在React环境中如此重要的人来说，我不得不阅读很多关于React“幕后”的东西。</p><p id="30af" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">考虑这段代码，</p><pre class="kj kk kl km gt lw lx ly lz aw ma bi"><span id="5db4" class="ky kz in lx b gy mb mc l md me">function App() {<br/>  <br/>    const [state, toggle] = useState(0);<br/>  <br/>    useEffect(()=&gt;{<br/>    <br/>    setInterval(()=&gt;{<br/>      console.log(`state ${state}`);<br/>    },3000)<br/>  <br/>},[])<br/>    return (</span><span id="ad3b" class="ky kz in lx b gy mf mc l md me">       &lt;div&gt;</span><span id="aa5b" class="ky kz in lx b gy mf mc l md me">       &lt;h2&gt;{`${state}`}&lt;/h2&gt;</span><span id="31f1" class="ky kz in lx b gy mf mc l md me">       &lt;button onClick={() =&gt; { toggle(state+1) }}&gt;Increase&lt;/button&gt;</span><span id="f731" class="ky kz in lx b gy mf mc l md me">       &lt;/div&gt;<br/>)<br/>}</span></pre><p id="a142" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">单击按钮并更新状态后，日志中没有变化。日志显示初始状态为0。看下面的GIF。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="ko kp di kq bf kr"><div class="gh gi mm"><img src="../Images/b8a1341847a3ddc5034dcb4e5c582a0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*eFpOioVyfUBSAtF3ZmeCoQ.gif"/></div></div><figcaption class="ku kv gj gh gi kw kx bd b be z dk">stale state in setInterval</figcaption></figure><p id="f813" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“为什么”的答案不在于React，而在于JavaScript本身。这与所谓的<em class="mh">关闭</em>有关。<em class="mh">在这里</em>  <em class="mh">阅读关于闭包的</em> <a class="ae ml" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures" rel="noopener ugc nofollow" target="_blank"> <em class="mh">。</em></a></p><p id="2c00" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这在这里不是一个大问题，但是想象一个事件监听器被附加到一个对象，在<em class="mh"> useEffect </em>中，并在其中获得陈旧状态。查看<a class="ae ml" href="https://stackoverflow.com/a/55156813/10996126" rel="noopener ugc nofollow" target="_blank">这个</a> SO答案，它显示了在<em class="mh"> useEffect </em>中使用事件监听器的正确方法。</p><p id="d8fe" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">重要的是要知道，拥有基本的JS知识应该比拥有框架或特定于库的知识更重要。因为，不管你用什么库，你还是要写JS代码，处理JS相关的顾虑。重要的是不要把自己局限于某个特定的框架/库，只有拥有强大的JS基础才有可能。</p><p id="be62" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">永远不要低估你仅仅通过看文档获得的知识，尤其是当它们和React的一样好的时候。</p><p id="d795" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">感谢您的阅读！</p></div></div>    
</body>
</html>