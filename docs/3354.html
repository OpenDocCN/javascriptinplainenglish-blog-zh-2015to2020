<html>
<head>
<title>How to Test Nest.js applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何测试Nest.js应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/testing-nestjs-applications-546ab3e9fa13?source=collection_archive---------0-----------------------#2020-09-22">https://javascript.plainenglish.io/testing-nestjs-applications-546ab3e9fa13?source=collection_archive---------0-----------------------#2020-09-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="6dd9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在之前的帖子中，我写了很多测试代码来验证我们的应用程序是否如预期的那样工作。</p><p id="374e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Nestjs提供了与<a class="ae kl" href="https://github.com/facebook/jest" rel="noopener ugc nofollow" target="_blank"> Jest </a>和<a class="ae kl" href="https://github.com/visionmedia/supertest" rel="noopener ugc nofollow" target="_blank"> Supertest </a>的集成，以及用于单元测试和端到端(e2e)测试的测试工具。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="a149" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">Nestjs测试线束</h1><p id="a817" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">像Angular的<code class="fe lw lx ly lz b">TestBed</code>一样，Nestjs提供了一个类似的<code class="fe lw lx ly lz b">Test</code>工具来为你的测试代码组装Nestjs组件。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="b972" class="mi ku iq lz b gy mj mk l ml mm">beforeEach(async () =&gt; {<br/>    const module: TestingModule = await Test.createTestingModule({<br/>      providers: [<br/>        ...<br/>      ],<br/>    }).compile();</span><span id="009c" class="mi ku iq lz b gy mn mk l ml mm">    service = module.get&lt;UserService&gt;(UserService);<br/>  });</span></pre><p id="bf09" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">类似于<code class="fe lw lx ly lz b">@Module</code>装饰器中的属性，<code class="fe lw lx ly lz b">creatTestingModule</code>定义了将在测试中使用的组件。</p><p id="7157" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们已经展示了在Nestjs应用程序中测试服务的方法，例如在<code class="fe lw lx ly lz b">post.service.spec.ts</code>中。</p><p id="41be" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要隔离服务中的依赖关系，有几种方法。</p><ul class=""><li id="ff02" class="mo mp iq jp b jq jr ju jv jy mq kc mr kg ms kk mt mu mv mw bi translated">创建一个假服务来替换真服务，在<code class="fe lw lx ly lz b">providers</code>中组装。</li><li id="d84a" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">提供者:[ { provide: UserService，useClass: FakeUserService } ]，</li><li id="d82b" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">请改用模拟实例。</li><li id="3c2b" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated"><code class="fe lw lx ly lz b">providers: [ provide: UserService, useValue: { send: jest.fn() } ],</code></li><li id="80dd" class="mo mp iq jp b jq mx ju my jy mz kc na kg nb kk mt mu mv mw bi translated">对于简单的服务提供者，您可以脱离Nestjs的束缚，创建一个简单的假依赖服务，并使用<code class="fe lw lx ly lz b">new</code>在<code class="fe lw lx ly lz b">setup</code>钩子中实例化您的服务。</li></ul><p id="426c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">也可以在<code class="fe lw lx ly lz b">Test.createTestingModule</code>中导入一个模块。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="0d9a" class="mi ku iq lz b gy mj mk l ml mm">Test.createTestingModule({<br/>        imports: []<br/>       })</span></pre><p id="b0b5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要替换导入模块中的某些服务，您可以<code class="fe lw lx ly lz b">override</code>它。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="9780" class="mi ku iq lz b gy mj mk l ml mm">Test.createTestingModule({<br/>        imports: []<br/>       })<br/>       .override(...)</span></pre></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="fe58" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">笑话技巧和窍门</h1><p id="418d" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Nestjs测试严重依赖Jest框架。我花了很多时间研究测试Nestjs应用程序中的所有组件。</p></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="42a1" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">模仿外部类或函数</h1><p id="23be" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">例如，<code class="fe lw lx ly lz b">mongoose.connect</code>将需要一个真正的mongo服务器来连接，以模仿<code class="fe lw lx ly lz b">mongoose</code>的<code class="fe lw lx ly lz b">createConnection</code>。</p><p id="ac30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在导入之前设置模拟。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="c536" class="mi ku iq lz b gy mj mk l ml mm">jest.mock('mongoose', () =&gt; ({<br/>    createConnection: jest.fn().mockImplementation(<br/>        (uri:any, options:any)=&gt;({} as any)<br/>    ),<br/>    Connection: jest.fn()<br/>}))</span><span id="d708" class="mi ku iq lz b gy mn mk l ml mm">//...<br/>import { Connection, createConnection } from 'mongoose';<br/>//</span></pre><p id="79db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当数据库提供者被实例化时，断言<code class="fe lw lx ly lz b">createConnection</code>被调用。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="10fb" class="mi ku iq lz b gy mj mk l ml mm">it('connect is called', () =&gt; {<br/>    //expect(conn).toBeDefined();<br/>    //expect(createConnection).toHaveBeenCalledTimes(1); // it is 2 here. why?<br/>    expect(createConnection).toHaveBeenCalledWith("mongodb://localhost/blog", {<br/>        useNewUrlParser: true,<br/>        useUnifiedTopology: true,<br/>        //see: <a class="ae kl" href="https://mongoosejs.com/docs/deprecations.html#findandmodify" rel="noopener ugc nofollow" target="_blank">https://mongoosejs.com/docs/deprecations.html#findandmodify</a><br/>        useFindAndModify: false<br/>    });<br/>})</span></pre></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="6198" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">通过原型模拟父类</h1><p id="3e04" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">看看本地的auth guard测试。</p><p id="a00a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模仿父原型中的方法<code class="fe lw lx ly lz b">canActivate</code>。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="3bc5" class="mi ku iq lz b gy mj mk l ml mm">describe('LocalAuthGuard', () =&gt; {<br/>  let guard: LocalAuthGuard;<br/>  beforeEach(() =&gt; {<br/>    guard = new LocalAuthGuard();<br/>  });<br/>  it('should be defined', () =&gt; {<br/>    expect(guard).toBeDefined();<br/>  });<br/>  it('should return true for `canActivate`', async () =&gt; {<br/>    AuthGuard('local').prototype.canActivate = jest.fn(() =&gt;<br/>      Promise.resolve(true),<br/>    );<br/>    AuthGuard('local').prototype.logIn = jest.fn(() =&gt; Promise.resolve());<br/>    expect(await guard.canActivate({} as ExecutionContext)).toBe(true);<br/>  });</span><span id="3cdf" class="mi ku iq lz b gy mn mk l ml mm">});</span></pre></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="59bc" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">尽可能将功能提取到函数中</h1><p id="23eb" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">让我们来看看<code class="fe lw lx ly lz b">user.model.ts</code>。将前置<code class="fe lw lx ly lz b">save</code>钩子方法和自定义<code class="fe lw lx ly lz b">comparePassword</code>方法提取到独立的函数中。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="e5df" class="mi ku iq lz b gy mj mk l ml mm">async function preSaveHook(next) {</span><span id="dc44" class="mi ku iq lz b gy mn mk l ml mm">  // Only run this function if password was modified<br/>  if (!this.isModified('password')) return next();</span><span id="9857" class="mi ku iq lz b gy mn mk l ml mm">  // Hash the password<br/>  const password = await hash(this.password, 12);<br/>  this.set('password', password);</span><span id="6a94" class="mi ku iq lz b gy mn mk l ml mm">  next();<br/>}</span><span id="8006" class="mi ku iq lz b gy mn mk l ml mm">UserSchema.pre&lt;User&gt;('save', preSaveHook);</span><span id="c832" class="mi ku iq lz b gy mn mk l ml mm">function comparePasswordMethod(password: string): Observable&lt;boolean&gt; {<br/>  return from(compare(password, this.password));<br/>}</span><span id="d3dd" class="mi ku iq lz b gy mn mk l ml mm">UserSchema.methods.comparePassword = comparePasswordMethod;</span></pre><p id="29db" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">测试它们就像测试简单的函数一样容易。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="76e8" class="mi ku iq lz b gy mj mk l ml mm">describe('preSaveHook', () =&gt; {<br/>    test('should execute next middleware when password is not modified', async () =&gt; {<br/>        const nextMock = jest.fn();<br/>        const contextMock = {<br/>            isModified: jest.fn()<br/>        };<br/>        contextMock.isModified.mockReturnValueOnce(false);<br/>        await preSaveHook.call(contextMock, nextMock);<br/>        expect(contextMock.isModified).toBeCalledWith('password');<br/>        expect(nextMock).toBeCalledTimes(1);<br/>    });</span><span id="2210" class="mi ku iq lz b gy mn mk l ml mm">    test('should set password when password is modified', async () =&gt; {<br/>        const nextMock = jest.fn();<br/>        const contextMock = {<br/>            isModified: jest.fn(),<br/>            set: jest.fn(),<br/>            password: '123456'<br/>        };<br/>        contextMock.isModified.mockReturnValueOnce(true);<br/>        await preSaveHook.call(contextMock, nextMock);<br/>        expect(contextMock.isModified).toBeCalledWith('password');<br/>        expect(nextMock).toBeCalledTimes(1);<br/>        expect(contextMock.set).toBeCalledTimes(1);<br/>    });<br/>});</span></pre></div><div class="ab cl km kn hu ko" role="separator"><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr ks"/><span class="kp bw bk kq kr"/></div><div class="ij ik il im in"><h1 id="e425" class="kt ku iq bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">端到端测试</h1><p id="a6fa" class="pw-post-body-paragraph jn jo iq jp b jq lr js jt ju ls jw jx jy lt ka kb kc lu ke kf kg lv ki kj kk ij bi translated">Nestjs集成supertest向服务器端发送请求。</p><p id="d0e3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用<code class="fe lw lx ly lz b">beforeAll</code>和<code class="fe lw lx ly lz b">afterAll</code>启动和停止应用程序，使用<code class="fe lw lx ly lz b">request</code>向服务器发送http请求并断言响应结果。</p><pre class="ma mb mc md gt me lz mf mg aw mh bi"><span id="9827" class="mi ku iq lz b gy mj mk l ml mm">import * as request from 'supertest';<br/>//...</span><span id="9cd3" class="mi ku iq lz b gy mn mk l ml mm">describe('API endpoints testing (e2e)', () =&gt; {<br/>    let app: INestApplication;<br/>    beforeAll(async () =&gt; {<br/>        const moduleFixture: TestingModule = await Test.createTestingModule({<br/>            imports: [AppModule],<br/>        }).compile();</span><span id="d671" class="mi ku iq lz b gy mn mk l ml mm">        app = moduleFixture.createNestApplication();<br/>        app.enableShutdownHooks();<br/>        app.useGlobalPipes(new ValidationPipe());<br/>        await app.init();<br/>    });</span><span id="5b01" class="mi ku iq lz b gy mn mk l ml mm">    afterAll(async () =&gt; {<br/>        await app.close();<br/>    });</span><span id="815a" class="mi ku iq lz b gy mn mk l ml mm">    // an example of using supertest request.<br/>    it('/posts (GET)', async () =&gt; {<br/>        const res = await request(app.getHttpServer()).get('/posts').send();<br/>        expect(res.status).toBe(200);<br/>        expect(res.body.length).toEqual(3);<br/>    });<br/>}</span></pre><p id="dba8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">关于完整的e2e测试的更多细节，查看Nestjs的<a class="ae kl" href="https://github.com/hantsy/nestjs-sample/tree/master/test" rel="noopener ugc nofollow" target="_blank">测试文件夹</a>。</p></div></div>    
</body>
</html>