<html>
<head>
<title>How to use Tail Call Optimizations in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中使用尾部调用优化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-optimizations-tail-call-optimization-tco-471b4f8e4f37?source=collection_archive---------1-----------------------#2020-02-10">https://javascript.plainenglish.io/javascript-optimizations-tail-call-optimization-tco-471b4f8e4f37?source=collection_archive---------1-----------------------#2020-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8fb7" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">简短、有用的JavaScript课程——让它变得简单。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi kf"><img src="../Images/0c04c40aa91023a24697f2765dad2bcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*Lh44XkK8lxwK201Q3SJDTQ.png"/></div></figure><p id="2dd5" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi lj translated">在应用任何优化之前，你必须了解你的代码是否运行在关键路径上。如果它不在关键路径上，那么你的优化就没有什么价值，过早的优化通常是个坏主意。</p><p id="e183" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">那么，什么是过早优化呢？这句话出自Donald Knuth的一句名言:“过早优化是万恶之源”。许多开发人员引用这句话来暗示大多数优化是“不成熟的”,因此是浪费精力。事实更加微妙。</p><p id="0fd2" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果你的代码在一个关键的路径上，这种优化会让你感兴趣，否则，最好花时间让代码更可读。</p><h2 id="6331" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kw mb mc md la me mf mg le mh mi mj mk bi translated">什么是TCO优化？</h2><p id="4809" class="pw-post-body-paragraph kn ko iq kp b kq ml jr ks kt mm ju kv kw mn ky kz la mo lc ld le mp lg lh li ij bi translated">尾部调用优化与函数调用可能发生的特定类型的优化相关。根据Kyle Simpson的说法，尾调用是出现在另一个函数尾部的函数调用，这样在调用结束后，就没有什么可做的了。</p><p id="096c" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">尾代码优化采用一个递归函数，并在内部使用“goto”生成一个迭代函数，然后执行它。它不限制堆栈调用，因为没有堆栈调用，而且函数也不是递归函数。这种迭代函数的性能与其递归函数相当。</p><p id="8c23" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">换句话说，尾部调用优化意味着可以从另一个函数调用一个函数，而不会增加调用堆栈。</p><p id="9806" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">例如，这里有一个尾部调用:</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="028c" class="ls lt iq mr b gy mv mw l mx my">function doA(a) {<br/>    return a;<br/>}</span><span id="98b1" class="ls lt iq mr b gy mz mw l mx my">function doB(b) {<br/>    return doA( b + 1 ); //tail call<br/>}</span><span id="f954" class="ls lt iq mr b gy mz mw l mx my">function foo() {<br/>    return 20 + doB(10); //not tail call<br/>}</span><span id="0fb8" class="ls lt iq mr b gy mz mw l mx my">foo(); // 31</span></pre><p id="54cc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">doA(b+1)是doB(b)中的尾调用。在doA(b+1)完成之后，doB(..)也结束了，只需要返回doA(b+1)调用的结果。然而，doB(10)不是一个尾调用，因为在它完成之后，它的结果必须加到20，foo()才能返回它。</p><p id="37c4" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated"><strong class="kp ir">调用一个新函数需要额外数量的保留内存</strong>来管理，称为堆栈帧。所以前面的代码片段通常需要一个堆栈框架来处理每个调用。</p><p id="8f1a" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">然而，如果具有TCO能力的引擎可以意识到doA(b+1)调用处于尾部位置，这意味着doB(b)基本上是完整的，那么当调用doA(b+1)时，它不需要创建新的堆栈帧，而是可以重用来自doB(b)的现有堆栈帧。速度更快，占用内存更少。</p><p id="5413" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">在处理递归时，这种优化变得至关重要，尤其是当递归可能导致数千个堆栈帧时。有了TCO，引擎可以在单个堆栈帧中执行所有这些调用。</p><p id="1161" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">考虑这个递归函数<strong class="kp ir">没有TCO优化</strong></p><p id="3ccc" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">此函数不可优化，因为最后一条指令不是对另一个函数的调用，而是将n乘以阶乘(n-1)返回的值的表达式。这可以防止引擎通过强制创建一个存储初始值的新堆栈来删除堆栈。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="164e" class="ls lt iq mr b gy mv mw l mx my">function factorial(n) {<br/>    console.trace();<br/>    <br/>    if (n === 0) {<br/>        return 1;<br/>    }</span><span id="af80" class="ls lt iq mr b gy mz mw l mx my">    // no proper tail call<br/>    return<strong class="mr ir"> n * factorial(n - 1);</strong><br/>}<br/>factorial(2);</span><span id="6c9a" class="ls lt iq mr b gy mz mw l mx my">VM31:4 console.trace<br/><strong class="mr ir">factorial</strong> @ VM31:4</span><span id="6202" class="ls lt iq mr b gy mz mw l mx my">VM31:4 console.trace<br/><strong class="mr ir">factorial</strong> @ VM31:4<br/><strong class="mr ir">factorial</strong> @ VM31:10</span><span id="ee87" class="ls lt iq mr b gy mz mw l mx my">VM31:4 console.trace<br/><strong class="mr ir">factorial</strong> @ VM31:4<br/><strong class="mr ir">factorial</strong> @ VM31:10<br/><strong class="mr ir">factorial</strong> @ VM31:10<br/></span></pre><p id="c4c9" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了使前面的函数可以被引擎优化，我们只需删除表达式n * factorial(n-1 ),并修改函数以不同的方式做同样的事情。</p><pre class="kg kh ki kj gt mq mr ms mt aw mu bi"><span id="3a63" class="ls lt iq mr b gy mv mw l mx my">'use strict'; </span><span id="d1c1" class="ls lt iq mr b gy mz mw l mx my">function factorial(n, total = 1) {<br/>    console.trace();<br/>    if (n === 0) {<br/>        return total;<br/>    }</span><span id="cbcf" class="ls lt iq mr b gy mz mw l mx my">    // proper tail call<br/><strong class="mr ir">    return factorial(n - 1, n * total);</strong><br/>}<br/>factorial(2);</span><span id="560a" class="ls lt iq mr b gy mz mw l mx my">Trace<br/>    at <strong class="mr ir">factorial</strong><br/>Trace<br/>    at <strong class="mr ir">factorial</strong><br/>Trace<br/>    at <strong class="mr ir">factorial</strong><br/></span></pre><p id="cad1" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">这里没有增加调用堆栈的大小。这意味着这样您就不会遇到超出最大调用堆栈大小的错误。</p><h2 id="99a0" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kw mb mc md la me mf mg le mh mi mj mk bi translated">最后的笔记</h2><p id="52a7" class="pw-post-body-paragraph kn ko iq kp b kq ml jr ks kt mm ju kv kw mn ky kz la mo lc ld le mp lg lh li ij bi translated">尾调用优化是ES2015-ES6规范的一部分。支持它不是NodeJS的事情，而是NodeJS使用的V8引擎需要支持的事情。从7.10到6.5.0的节点仅在严格模式下支持这一点，并带有标志“<strong class="kp ir"> -和谐</strong>”。</p><p id="dc79" class="pw-post-body-paragraph kn ko iq kp b kq kr jr ks kt ku ju kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">关于TCO的不确定未来，参见stackoverflow中的这个回答:<a class="ae na" href="https://stackoverflow.com/questions/42788139/es6-tail-recursion-optimisation-stack-overflow" rel="noopener ugc nofollow" target="_blank"> ES6尾部递归优化</a>。</p><h2 id="b73a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma kw mb mc md la me mf mg le mh mi mj mk bi translated">如果这对你有帮助，请点击下面的拍手按钮。非常感谢！</h2></div></div>    
</body>
</html>