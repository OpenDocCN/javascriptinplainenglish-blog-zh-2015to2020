<html>
<head>
<title>Themes within themes with React, TypeScript and Styled Components ✨</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">包含React、TypeScript和Styled组件的主题中的主题✨</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/themes-within-themes-with-react-typescript-and-styled-components-e65491e45f5e?source=collection_archive---------2-----------------------#2020-08-27">https://javascript.plainenglish.io/themes-within-themes-with-react-typescript-and-styled-components-e65491e45f5e?source=collection_archive---------2-----------------------#2020-08-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="b38d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">你如何构建一个多主题的应用程序？如果这些主题是内的<em class="kf">另一个主题呢？</em></h2></div><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi kg"><img src="../Images/bba4bb4992d94d15cf5727077cf458c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GOhd36zGnR7Navh4XP7AQA.jpeg"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Pencils by Jess Bailey</figcaption></figure><p id="2560" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最近的一个项目带来了一些巨大的挑战。客户想要一个演示体验，在一个品牌“容器”中显示一系列不同的网站。这些演示网站将在一个模拟的桌面或移动设备中进行交互，每个都有自己的主题。在本文中，我将深入探讨:</p><ol class=""><li id="5ef3" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">我们如何建立项目文件</li><li id="31cf" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">使用样式化组件进行主题化</li></ol><p id="ae65" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这已经足够具有挑战性了，但是最重要的是，我们需要给用户在模拟的“桌面”显示和“移动”显示模式之间切换的能力，所有这些都在这个静态容器中，<em class="mg">不使用</em>媒体查询。我将在后续文章中解决这一挑战。</p><p id="8529" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是我们制作的两张插图:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mh"><img src="../Images/7cdc5b28bbadebaf5a9138167481c05f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IgBcQ34PJbpzrSMCN-MTqg.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Mobile view</figcaption></figure><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mh"><img src="../Images/fc3f415ab6a1fa90bc32dbc22d107565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CDUcwGgRBpuqt5F6qLjv0g.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Desktop View</figcaption></figure><h1 id="80f5" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">我们需要多少主题？💭</h1><p id="ad76" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">这里的第一步是弄清楚我们需要多少主题，其次是如何设置这些主题。从一开始我们就正确地设置这一点是至关重要的，从长远来看，这可以让我们避免很多痛苦。</p><ol class=""><li id="ced3" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">这里我们需要一个静态容器的主题，不管活动的演示是什么，它都将保持不变。这将有一个品牌的黑色主题，以配合客户的风格指南。</li><li id="eac8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">我们还需要每个“演示”一个主题，这将取决于哪个演示是活跃的变化。所以三个演示意味着三个以上的主题，等等。</li></ol><p id="ed2b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">似乎很简单。以下是这种“网站中的网站”应该如何运行的一些基本说明:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi nf"><img src="../Images/c1608aade9ee216750e82aabc7ade991.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D-m76HZHBPCQGA-7sgmPPQ.png"/></div></div><figcaption class="ks kt gj gh gi ku kv bd b be z dk">Selecting a demo from the left will display a unique styled theme within the mobile frame. The outer container will keep its theme throughout.</figcaption></figure><h1 id="38f8" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">设置文件📚</h1><p id="4a9e" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">我们需要创建的第一个组件是我们的静态演示容器，它将包装模拟设备和所有其他主题。</p><p id="d47b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们将其创建为名为“DemoContainer”的React组件。就个人而言，当创建使用样式化组件的组件时，我喜欢使用下面的文件结构(这里我们使用的是TypeScript):</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="e794" class="nl mj iq nh b gy nm nn l no np">src<br/>├── components<br/>│   ├── atoms<br/>│   ├── molecules<br/>│   └── organisms<br/>│       └── DemoContainer<br/>│           ├── DemoContainer.tsx<br/>│           ├── Demo.props.ts<br/>│           └── Demo.style.ts</span></pre><h1 id="eee9" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">添加第一个主题</h1><p id="ecb9" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">现在我们有了基本的组件，我们需要用样式化的组件' T0 '来设置它的主题。在这种情况下，我们创建了一个<code class="fe nq nr ns nh b">styles/themes</code>文件夹来存放所有不同的主题。</p><p id="deb1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是我们采用的结构:</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="543e" class="nl mj iq nh b gy nm nn l no np">src<br/>├── styles<br/>│   └── themes<br/>│       ├── demoContainer<br/>│       │   ├── colors.ts<br/>│       │   ├── text.ts<br/>│       │   ├── typography.ts<br/>│       │   └── index.ts<br/>│       └── index.ts</span></pre><h2 id="e37d" class="nl mj iq bd mk nt nu dn mo nv nw dp ms lf nx ny mu lj nz oa mw ln ob oc my od bi translated">/colors.ts🎨</h2><p id="b88f" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">这个文件将包含主题的颜色变量。关于设置颜色的正确方法有很多争论，在我看来，这应该和设计师一起完成。然而，因为我们不在这里讨论这个，这里有一些虚拟变量名称让大家高兴😎</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="2584" class="nl mj iq nh b gy nm nn l no np"><strong class="nh ir"><em class="mg">//colors.ts</em></strong></span><span id="4015" class="nl mj iq nh b gy oe nn l no np">const colors = {<br/>  primary: {<br/>    primary1: '#172121',<br/>    primary2: '#444554',<br/>    primary3: '#7F7B82',<br/>  },<br/>  secondary: {<br/>    secondary1: '#BFACB5',<br/>    secondary2: '#E5D0CC',<br/>  },<br/>  ...<br/>}</span><span id="c4ca" class="nl mj iq nh b gy oe nn l no np">export default colors;</span></pre><h2 id="c224" class="nl mj iq bd mk nt nu dn mo nv nw dp ms lf nx ny mu lj nz oa mw ln ob oc my od bi translated">/text.ts🔠</h2><p id="d5d8" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">这是我们将要为主题存储所有文本变量的地方。这包括:</p><ul class=""><li id="67f7" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr of ly lz ma bi translated">字体系列</li><li id="447c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr of ly lz ma bi translated">大小</li><li id="37ad" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr of ly lz ma bi translated">字母间距</li><li id="fe9c" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr of ly lz ma bi translated">字体粗细</li><li id="e55f" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr of ly lz ma bi translated">行高</li></ul><p id="efb5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以及你想为你的文本存储的任何其他变量。以下是您可以存储的内容示例:</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="1587" class="nl mj iq nh b gy nm nn l no np"><strong class="nh ir"><em class="mg">// text.ts</em></strong></span><span id="6d35" class="nl mj iq nh b gy oe nn l no np">const text = {<br/>  font: {<br/>    heading: '"Merriweather", Georgia, serif',<br/>    body: '"Open Sans", Helvetica, Arial, sans-serif',<br/>  }<br/>  size: {<br/>    heading: {<br/>      mobile: {<br/>        h1: 40,<br/>        h2: 28,<br/>        ...<br/>      },<br/>      desktop: {...},<br/>    },<br/>    body: {<br/>      mobile: {<br/>        regular: 16,<br/>        ...<br/>      },<br/>      desktop: {<br/>        regular: 24,<br/>        ...<br/>      }<br/>    }<br/>  },<br/>  weight: {<br/>    light: 200,<br/>    regular: 400,<br/>    bold: 700,<br/>  }<br/>}</span><span id="ad35" class="nl mj iq nh b gy oe nn l no np">export default text;</span></pre><h2 id="0862" class="nl mj iq bd mk nt nu dn mo nv nw dp ms lf nx ny mu lj nz oa mw ln ob oc my od bi translated">/印刷术. ts📝</h2><p id="1097" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">最后，排版是我们为这个主题设置全局排版规则的地方。我们可以使用Styled Components ' T0 '来导出一些我们希望在整个主题中使用的集合样式。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="57dd" class="nl mj iq nh b gy nm nn l no np"><strong class="nh ir"><em class="mg">// typography.ts</em></strong></span><span id="fbee" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> { css } <em class="mg">from</em> 'styled-components';<br/><em class="mg">import </em>text <em class="mg">from </em>'./text';</span><span id="8651" class="nl mj iq nh b gy oe nn l no np">const { font, size, weight, lineHeight, letterSpacing } = text;</span><span id="e049" class="nl mj iq nh b gy oe nn l no np">const typography = css`<br/>  font-family: ${font.body};<br/>  font-weight: ${weight.regular};</span><span id="3f10" class="nl mj iq nh b gy oe nn l no np">  h1 {<br/>    font-size: ${size.heading.mobile.h1}px;<br/>  }<br/>  ...<br/>`;</span><span id="3615" class="nl mj iq nh b gy oe nn l no np">export default typography;</span></pre><p id="3d93" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我认为用这种方式导入你的文本样式比把它们添加到父样式组件更简洁。它有效地为主题设置了“全局”文本样式，因此它整理了样式组件，只为特定样式留出了空间。</p><h2 id="609d" class="nl mj iq bd mk nt nu dn mo nv nw dp ms lf nx ny mu lj nz oa mw ln ob oc my od bi translated">/index.ts</h2><p id="dae0" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">现在我们已经为这个主题设置了所有的样式变量，我们可以将它们放在一起，并从索引文件中导出它们，就像这样:</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="ae55" class="nl mj iq nh b gy nm nn l no np"><strong class="nh ir">// <em class="mg">index.ts</em></strong></span><span id="0956" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> colors <em class="mg">from</em> './colors';<br/><em class="mg">import</em> text <em class="mg">from</em> './text';<br/><em class="mg">import</em> typography <em class="mg">from</em> './typography';</span><span id="7452" class="nl mj iq nh b gy oe nn l no np">export default {<br/>  name: 'demoContainer',<br/>  colors,<br/>  text,<br/>  typography,<br/>};</span></pre><p id="2313" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里还可以包含许多其他样式变量，比如间距和动画。主要的一点是，我们希望任何特定于每个主题的可重用变量都包含在主题导出中。</p><h2 id="7d8c" class="nl mj iq bd mk nt nu dn mo nv nw dp ms lf nx ny mu lj nz oa mw ln ob oc my od bi translated">导出主题</h2><p id="c0ea" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">我们知道这里需要不止一个主题，所以让我们提前考虑从<code class="fe nq nr ns nh b">themes/index.ts</code>文件中导出这些主题:</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="ab8b" class="nl mj iq nh b gy nm nn l no np"><strong class="nh ir"><em class="mg">// index.ts</em></strong></span><span id="3235" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> demoContainer <em class="mg">from</em> './demoContainer';</span><span id="3792" class="nl mj iq nh b gy oe nn l no np">const theme = {<br/>  default: demoContainer,<br/>  demoContainer,<br/>};</span><span id="b2bd" class="nl mj iq nh b gy oe nn l no np">export default theme;</span></pre><p id="4e82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们还在这里添加了一个“默认”主题，并将其设置为demoContainer主题，以防万一我们需要一个后备。</p><h1 id="7cf6" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">使用主题变量🖼</h1><p id="b11c" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">现在有趣的部分来了，看看我们的主题是什么。第一步是将我们的<code class="fe nq nr ns nh b">DemoContainer</code>组件包装在来自样式化组件的<code class="fe nq nr ns nh b">ThemeProvider</code>中。</p><h2 id="3b51" class="nl mj iq bd mk nt nu dn mo nv nw dp ms lf nx ny mu lj nz oa mw ln ob oc my od bi translated">添加ThemeProvider</h2><p id="f3c7" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">我们的<code class="fe nq nr ns nh b">DemoContainer.tsx</code>文件看起来会像这样:</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="4b7b" class="nl mj iq nh b gy nm nn l no np"><strong class="nh ir"><em class="mg">// DemoContainer.tsx</em></strong></span><span id="df5f" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> React, { FunctionComponent } <em class="mg">from</em> 'react';<br/><em class="mg">import</em> { ThemeProvider } <em class="mg">from</em> 'styled-components';</span><span id="57ca" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> { DemoContainerProps } <em class="mg">from</em> './DemoContainer.props';<br/><em class="mg">import</em> theme <em class="mg">from</em> '../../../styles/global/theme';</span><span id="588a" class="nl mj iq nh b gy oe nn l no np">const <em class="mg">DemoContainer:</em> FunctionComponent&lt;DemoContainerProps&gt; = ({ children }) =&gt; {<br/>  return (<br/>    &lt;ThemeProvider <strong class="nh ir">theme={theme.demoContainer}</strong>&gt;<br/>      Demo Container content here!<br/>    &lt;/ThemeProvider&gt;<br/>  )<br/>}</span></pre><p id="b58a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们现在成功地将<em class="mg"> demoContainer </em>主题传递给我们的<code class="fe nq nr ns nh b">DemoContainer</code>组件。为了使用主题变量，让我们创建第一个样式化的组件，它将包装容器中的所有内容。</p><p id="2be9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将创建一个包装器组件，它将位于我们的<code class="fe nq nr ns nh b">ThemeProvider</code>中。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="becd" class="nl mj iq nh b gy nm nn l no np"><strong class="nh ir"><em class="mg">// DemoContainer.style.ts</em></strong></span><span id="a88f" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> styled <em class="mg">from</em> 'styled-components';</span><span id="fb56" class="nl mj iq nh b gy oe nn l no np">export const Wrapper = styled.main``;</span></pre><p id="1ccb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi">⚡️</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="a957" class="nl mj iq nh b gy nm nn l no np"><strong class="nh ir"><em class="mg">// DemoContainer.tsx</em></strong></span><span id="8059" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> React, { FunctionComponent } <em class="mg">from</em> 'react';<br/><em class="mg">import</em> { ThemeProvider } <em class="mg">from</em> 'styled-components';</span><span id="f24f" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> { DemoContainerProps } <em class="mg">from</em> './DemoContainer.props';<br/><em class="mg">import</em> theme <em class="mg">from</em> '../../../styles/global/theme';<br/><strong class="nh ir"><em class="mg">import</em> Wrapper <em class="mg">from</em> './DemoContainer.style.ts';</strong></span><span id="eeb3" class="nl mj iq nh b gy oe nn l no np">const <em class="mg">DemoContainer:</em> FunctionComponent&lt;DemoContainerProps&gt; = () =&gt; {<br/>  return (<br/>    &lt;ThemeProvider theme={theme.demoContainer}&gt;<br/>      &lt;<strong class="nh ir">Wrapper</strong>&gt;Demo Container content here!&lt;/<strong class="nh ir">Wrapper</strong>&gt;<br/>    &lt;/ThemeProvider&gt;<br/>  )<br/>}</span></pre><h2 id="1f10" class="nl mj iq bd mk nt nu dn mo nv nw dp ms lf nx ny mu lj nz oa mw ln ob oc my od bi translated">在我们的样式组件中使用主题变量</h2><p id="6f2a" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">现在，因为我们的包装器位于<code class="fe nq nr ns nh b">ThemeProvider</code>中，它也可以自动访问“主题”道具。因此，我们现在可以使用我们在<code class="fe nq nr ns nh b">/themes</code>文件夹中设置的变量，使用“主题”道具的对象分解:</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="9771" class="nl mj iq nh b gy nm nn l no np"><strong class="nh ir"><em class="mg">// DemoContainer.style.ts</em></strong></span><span id="5ef2" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> styled <em class="mg">from</em> 'styled-components';</span><span id="f538" class="nl mj iq nh b gy oe nn l no np">export const Wrapper = styled.main`<br/>  <em class="mg">// let's put all our global typography at the top</em><br/>  <strong class="nh ir">${({theme}) =&gt; theme.typography};</strong></span><span id="c36c" class="nl mj iq nh b gy oe nn l no np">  height: 100vh;<br/>  width: 100%;<br/>  padding: 60px;<br/>  background-color: <strong class="nh ir">${({theme}) =&gt; theme.colors.primary.primary1}</strong>;<br/>  color: <strong class="nh ir">${({theme}) =&gt; theme.colors.secondary.secondary2}</strong>;</span><span id="365f" class="nl mj iq nh b gy oe nn l no np">`;</span></pre><p id="910f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们已经使用变量对<code class="fe nq nr ns nh b">DemoContainer</code>进行了样式化。<code class="fe nq nr ns nh b">theme.typography</code>将确保我们的文本被样式化，所以不需要在我们的包装器中添加额外的文本样式。演示现在应该有一个很好的背景，我们的主要颜色1，文本将是次要颜色2。</p><h1 id="cd13" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">添加第二个主题(以及第三个、第四个……)👯‍♀️</h1><p id="54eb" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">我们的静态容器已经完成并设置了样式，剩下的就是设备内容的动态主题化，下面的箭头优雅地突出显示了这一点:</p><figure class="kh ki kj kk gt kl gh gi paragraph-image"><div role="button" tabindex="0" class="km kn di ko bf kp"><div class="gh gi mh"><img src="../Images/eb60e1eaca061c20633dbe1cd16c244b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oiZakuO5Ht3axfakaao2KA.png"/></div></div></figure><p id="f9f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当用户点击左侧的一个按钮(演示1、演示2等)时。)，我们需要改变模拟设备中的主题。</p><p id="d535" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">(我们碰巧使用Redux来进行这种状态管理，但是您也可以看看React的<code class="fe nq nr ns nh b">useContext</code>，如果我再做一次，我可能会使用它)</p><p id="4165" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">无论哪种方式，为了提供正确的主题，我们只需要从正在使用的提供者那里访问主题的名称或ID。</p><h2 id="aff6" class="nl mj iq bd mk nt nu dn mo nv nw dp ms lf nx ny mu lj nz oa mw ln ob oc my od bi translated">创建一个新组件来包装动态主题</h2><p id="1253" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">让我们创建我们的模拟设备组件，并将其命名为<code class="fe nq nr ns nh b">MockDevice</code>。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="7997" class="nl mj iq nh b gy nm nn l no np">src<br/>├── components<br/>│   ├── atoms<br/>│   ├── molecules<br/>│   └── organisms<br/>│       ├── DemoContainer<br/>│       └── MockDevice<br/>│           ├── MockDevice.tsx<br/>│           ├── MockDevice.props.ts<br/>│           └── MockDevice.style.ts</span></pre><p id="dfe1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nq nr ns nh b">MockDevice</code>将有一个与<code class="fe nq nr ns nh b">DemoContainer</code>非常相似的设置，它需要自己的<code class="fe nq nr ns nh b">ThemeProvider</code>。然而，我们将把<code class="fe nq nr ns nh b">ThemeProvider</code> <em class="mg">放在</em>两个其他样式组件之间:</p><ol class=""><li id="94e5" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated"><code class="fe nq nr ns nh b">Wrapper</code>，它将为我们的模拟设备提供“移动效果”样式</li><li id="533b" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated"><code class="fe nq nr ns nh b">DeviceContent</code>，它将包含我们希望为该网站提供的任何页面</li></ol><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="8c86" class="nl mj iq nh b gy nm nn l no np"><strong class="nh ir"><em class="mg">// </em></strong><strong class="nh ir"><em class="mg">MockDevice</em></strong><strong class="nh ir"><em class="mg">.tsx</em></strong></span><span id="2c18" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> React, { FunctionComponent } <em class="mg">from</em> 'react';<br/><em class="mg">import</em> { ThemeProvider } <em class="mg">from</em> 'styled-components';</span><span id="4c66" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> { <!-- -->MockDevice<!-- -->Props } <em class="mg">from</em> './MockDevice.props';<br/><em class="mg">import </em>{ Wrapper, DeviceContent } from './MockDevice.style.ts';</span><span id="afcc" class="nl mj iq nh b gy oe nn l no np">const <!-- -->MockDevice<em class="mg">:</em> FunctionComponent&lt;<!-- -->MockDevice<!-- -->Props&gt; = () =&gt; {<br/>  return (<br/>    &lt;Wrapper&gt;<br/>      &lt;ThemeProvider <strong class="nh ir">theme={???}</strong>&gt;<br/>        &lt;DeviceContent&gt;<br/>          <!-- -->Mock Device<!-- --> content here!<br/>        &lt;/DeviceContent&gt;<br/>      &lt;/ThemeProvider&gt;<br/>    &lt;/Wrapper&gt;<br/>  )<br/>}</span></pre><h2 id="23aa" class="nl mj iq bd mk nt nu dn mo nv nw dp ms lf nx ny mu lj nz oa mw ln ob oc my od bi translated">添加新的主题文件</h2><p id="5523" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">到目前为止，我们还不知道将什么主题传递到我们的新设备组件中，但是我们可以像设置<em class="mg"> demoContainer </em>主题一样开始设置这些主题。</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="b4ae" class="nl mj iq nh b gy nm nn l no np">src<br/>├── styles<br/>│   └── themes<br/>│       ├── demoContainer<br/>│       ├── demo1<br/>│       │   ├── colors.ts<br/>│       │   ├── text.ts<br/>│       │   ├── typography.ts<br/>│       │   └── index.ts<br/>│       ├── demo2<br/>│       │   ├── colors.ts<br/>│       │   ├── text.ts<br/>│       │   ├── typography.ts<br/>│       │   └── index.ts<br/>│       └── index.ts</span></pre><p id="2dbc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">不要忘记导出<code class="fe nq nr ns nh b">themes/index.ts</code>中的主题:</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="003a" class="nl mj iq nh b gy nm nn l no np"><strong class="nh ir"><em class="mg">// index.ts</em></strong></span><span id="fa95" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> demoContainer <em class="mg">from</em> './demoContainer';<br/><em class="mg">import</em> demo1 <em class="mg">from</em> './demo1';<br/><em class="mg">import</em> demo2 <em class="mg">from</em> './demo2';</span><span id="b27a" class="nl mj iq nh b gy oe nn l no np">const theme = {<br/>  default: demoContainer,<br/>  demoContainer,<br/>  demo1,<br/>  demo2,<br/>};</span><span id="7a9a" class="nl mj iq nh b gy oe nn l no np">export default theme;</span></pre><h2 id="1e40" class="nl mj iq bd mk nt nu dn mo nv nw dp ms lf nx ny mu lj nz oa mw ln ob oc my od bi translated">使用动态主题🧙‍♀️</h2><p id="7a39" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">我们现在可以从我们的提供商那里获得活动主题，并获取正确的样式。根据您使用的是<code class="fe nq nr ns nh b">useContext</code>还是<code class="fe nq nr ns nh b">Redux</code>，或者其他状态管理系统，这个位可能会略有不同。这是用Redux和hooks*:</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="ef70" class="nl mj iq nh b gy nm nn l no np"><strong class="nh ir"><em class="mg">// </em></strong><strong class="nh ir"><em class="mg">MockDevice</em></strong><strong class="nh ir"><em class="mg">.tsx</em></strong></span><span id="3dfd" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> React, { FunctionComponent } <em class="mg">from</em> 'react';<br/><em class="mg">import</em> { ThemeProvider } <em class="mg">from</em> 'styled-components';<br/><strong class="nh ir"><em class="mg">import</em> { useSelector } <em class="mg">from</em> 'react-redux';</strong></span><span id="4ffc" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> { <!-- -->MockDevice<!-- -->Props } <em class="mg">from</em> './MockDevice.props';<br/><em class="mg">import </em>{ Wrapper, DeviceContent } from './MockDevice.style.ts';<br/><strong class="nh ir"><em class="mg">import</em> themes <em class="mg">from</em> '../../../styles/global/theme';</strong></span><span id="b188" class="nl mj iq nh b gy oe nn l no np">const <!-- -->MockDevice<em class="mg">:</em> FunctionComponent&lt;<!-- -->MockDevice<!-- -->Props&gt; = ({children}) =&gt; {<br/>  <strong class="nh ir">const themeName = <em class="mg">useSelector</em>(<br/>    (state<em class="mg">:</em> RootState) =&gt; state.theme,<br/>  );</strong></span><span id="9d50" class="nl mj iq nh b gy oe nn l no np"><strong class="nh ir">const theme = themes[themeName] || themes.default;</strong></span><span id="7783" class="nl mj iq nh b gy oe nn l no np">return (<br/>    &lt;Wrapper&gt;<br/>      &lt;ThemeProvider <strong class="nh ir">theme={theme}</strong>&gt;<br/>        &lt;DeviceContent&gt;<br/>          {children}<br/>        &lt;/DeviceContent&gt;<br/>      &lt;/ThemeProvider&gt;<br/>    &lt;/Wrapper&gt;<br/>  )<br/>}</span></pre><p id="1ac0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">*以前没用过钩子或者不想包含它们？然后在连接的组件中用经典的</em><a class="ae og" href="https://react-redux.js.org/using-react-redux/connect-mapstate" rel="noopener ugc nofollow" target="_blank"><em class="mg">mapStateToProps</em></a><em class="mg">替换“useSelector”。</em></p><h1 id="c11b" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">整合应用程序💅</h1><p id="bda4" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">我们知道我们的<code class="fe nq nr ns nh b">DemoContainer</code>组件将包装整个应用程序。这个主题不会改变，应该保持不变。我们还知道<code class="fe nq nr ns nh b">MockDevice</code>需要在演示容器中。所以让我们补充一下:</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="de7a" class="nl mj iq nh b gy nm nn l no np"><strong class="nh ir"><em class="mg">// DemoContainer.tsx</em></strong></span><span id="dec3" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> React, { FunctionComponent } <em class="mg">from</em> 'react';<br/><em class="mg">import</em> { ThemeProvider } <em class="mg">from</em> 'styled-components';</span><span id="d5b0" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import</em> { DemoContainerProps } <em class="mg">from</em> './DemoContainer.props';<br/><em class="mg">import</em> theme <em class="mg">from</em> '../../../styles/global/theme';<br/><em class="mg">import</em> Wrapper <em class="mg">from</em> './DemoContainer.style.ts';<br/><strong class="nh ir">import MockDevice from '../MockDevice';</strong></span><span id="c637" class="nl mj iq nh b gy oe nn l no np">const <em class="mg">DemoContainer:</em> FunctionComponent&lt;DemoContainerProps&gt; = ({ <strong class="nh ir">children</strong> }) =&gt; {<br/>  return (<br/>    &lt;ThemeProvider theme={theme.demoContainer}&gt;<br/>      &lt;Wrapper&gt;<br/>        &lt;<strong class="nh ir">MockDevice</strong>&gt;<br/>          <strong class="nh ir">{children}</strong><br/>        &lt;/<strong class="nh ir">MockDevice</strong>&gt;<br/>      &lt;/Wrapper&gt;<br/>    &lt;/ThemeProvider&gt;<br/>  )<br/>}</span></pre><p id="0093" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为<code class="fe nq nr ns nh b">DemoContainer</code>将保持完全静态，所以我们可以在<code class="fe nq nr ns nh b">MockDevice</code>中渲染任何React子元素。</p><p id="ac6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">出于这个原因，我们决定让<code class="fe nq nr ns nh b">DemoContainer</code>包装我们的<code class="fe nq nr ns nh b">Router</code>，这样当用户导航到一个新页面时，这个页面将显示在我们的MockDevice中，并根据选择的主题进行样式化。</p><h1 id="1499" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">结论</h1><p id="2895" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">我们现在有了主题中的主题！一旦你建立了这个结构，你就可以添加任意多的主题。</p><ul class=""><li id="5c23" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr of ly lz ma bi translated"><code class="fe nq nr ns nh b">DemoContainer</code>样式将保持不变，并取决于<em class="mg">演示容器</em>主题变量。这些样式变量都可以在DemoContainer的<code class="fe nq nr ns nh b">Wrapper</code>中访问。</li><li id="f7e7" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr of ly lz ma bi translated">在应用程序状态下，<code class="fe nq nr ns nh b">MockDevice</code>将会用活动主题覆盖<em class="mg">演示容器</em>样式。任何在<code class="fe nq nr ns nh b">MockDevice</code>里的孩子都只能访问这个主题。</li><li id="a945" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr of ly lz ma bi translated">我们可以在任何子样式的组件中使用适当的分解结构来访问活动的主题变量。</li></ul><h1 id="8b38" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">打字笔记</h1><p id="67f3" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">重要的是，文件结构在所有新主题中保持一致，以避免主题寻找不存在的样式所导致的任何错误。</p><p id="f231" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里使用TypeScript确实很有帮助，因为您可以定义必须包含在每个文件中的属性:</p><pre class="kh ki kj kk gt ng nh ni nj aw nk bi"><span id="be9e" class="nl mj iq nh b gy nm nn l no np"><strong class="nh ir"><em class="mg">// themeTypes.ts</em></strong></span><span id="d545" class="nl mj iq nh b gy oe nn l no np">export interface Text {<br/>  font: {<br/>    heading: string;<br/>    body: string;<br/>  };<br/>  size: {<br/>    heading: {<br/>      mobile: {<br/>        h1: number;<br/>        h2: number;<br/>      };<br/>    };<br/>  };<br/>};</span><span id="ea53" class="nl mj iq nh b gy oe nn l no np"><strong class="nh ir">// <em class="mg">text.ts</em></strong></span><span id="606a" class="nl mj iq nh b gy oe nn l no np"><em class="mg">import </em>{ <strong class="nh ir">Text</strong> } <em class="mg">from </em>'./themeTypes.ts';</span><span id="c264" class="nl mj iq nh b gy oe nn l no np">const text: <strong class="nh ir">Text</strong> = {...}</span><span id="782e" class="nl mj iq nh b gy oe nn l no np">export default text;</span></pre><p id="9365" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您没有键入，请确保您始终遵循相同的结构。</p><h1 id="ad18" class="mi mj iq bd mk ml mm mn mo mp mq mr ms jw mt jx mu jz mv ka mw kc mx kd my mz bi translated">谢谢大家！🤗</h1><p id="682c" class="pw-post-body-paragraph kw kx iq ky b kz na jr lb lc nb ju le lf nc lh li lj nd ll lm ln ne lp lq lr ij bi translated">我希望你喜欢这篇文章，它在某种程度上帮助了你。你以前遇到过类似的挑战吗？我很想在下面的评论中听到你是如何处理的。</p><h2 id="2e1e" class="nl mj iq bd mk nt nu dn mo nv nw dp ms lf nx ny mu lj nz oa mw ln ob oc my od bi translated">进一步阅读</h2><div class="oh oi gp gr oj ok"><a href="https://bit.cloud/blog/theming-in-components-with-react-and-bit-l386casw" rel="noopener  ugc nofollow" target="_blank"><div class="ol ab fo"><div class="om ab on cl cj oo"><h2 class="bd ir gy z fp op fr fs oq fu fw ip bi translated">使用React和Bit在组件中进行主题化</h2><div class="or l"><h3 class="bd b gy z fp op fr fs oq fu fw dk translated">工程和设计团队面临的一个大的组织问题是分离外观和感觉…</h3></div><div class="os l"><p class="bd b dl z fp op fr fs oq fu fw dk translated">比特云</p></div></div><div class="ot l"><div class="ou l ov ow ox ot oy kq ok"/></div></div></a></div><p id="3d33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="mg">更多内容看</em> <a class="ae og" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mg">说白了。报名参加我们的</em> <a class="ae og" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mg">免费周报</em> </strong> </a> <em class="mg">。关注我们上</em> <a class="ae og" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mg">推特</em> </strong> </a>，<a class="ae og" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mg">领英</em> </strong> </a> <strong class="ky ir"> <em class="mg">，</em></strong><a class="ae og" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mg">YouTube</em></strong></a><strong class="ky ir"><em class="mg">，以及</em></strong><em class="mg"><a class="ae og" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir"><em class="mg">不和</em> </strong> </a></em> </strong> <em class="mg">对成长黑客感兴趣？检查出</em> </a><a class="ae og" href="https://circuit.ooo/" rel="noopener ugc nofollow" target="_blank"> <strong class="ky ir"> <em class="mg">电路</em> </strong> </a> <strong class="ky ir"> <em class="mg">。</em>T77】</strong></p></div></div>    
</body>
</html>