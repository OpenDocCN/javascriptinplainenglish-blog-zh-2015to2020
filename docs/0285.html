<html>
<head>
<title>The State of REST in 2019</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">2019年的休息状况</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-state-of-rest-in-2019-75005eaf05b9?source=collection_archive---------8-----------------------#2019-09-11">https://javascript.plainenglish.io/the-state-of-rest-in-2019-75005eaf05b9?source=collection_archive---------8-----------------------#2019-09-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/f7d61e94d263a7d56e2a44086803067e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BVudGfXSkBuJjWcX"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@anynieel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Angelina Kichukova</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="093a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">今天，每一个现代应用程序都为外部世界(互联网)提供了一种连接和交互的方式。它是必不可少的，以便应用程序可以通过互联网在客户端之间轻松发送和接收数据。它也可以被称为服务消费者的一种方式。应用程序中实现这一点的部分被称为<strong class="kc io"> API </strong>。API代表<strong class="kc io"> A </strong>应用<strong class="kc io"> P </strong>编程<strong class="kc io"> I </strong>界面。所有主要应用程序都使用某种API来促进通信，API可能是内部的或公共的，也可能是商业化的。销售对应用程序API的访问是一项大生意，特别是如果您的应用程序提供了其他服务或应用程序没有提供的数据。这只是对API的一个介绍，对它们有很多了解，但这不是本文的目的。由于一个API可以很容易地有很多活动部分，所以在创建它之前必须遵循一种架构风格。相同的模式有很多，如对等(P2P)、REST、基于服务、以数据为中心、事件驱动等。其中最著名的是REST。REST表示代表状态转移。</p><p id="d5dc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">十多年来，REST一直是执政的统治者。REST是一种架构风格，所有现代软件和网络服务都建立在这种架构风格之上。很可能您在手机、电脑或任何有互联网连接的设备上使用基于REST API构建的服务或应用数百次。也许您甚至已经开发了一个REST API或者自己编写了一个！尽管REST很受欢迎，但是，它也有一些明显的缺陷，需要修正。你可能会问，即使过了10多年，为什么它们还没有被淘汰？随着您对REST的进一步阅读和了解，您将会知道这些缺陷实际上并不是缺陷，是它们阻碍了REST的修复。</p><h1 id="690f" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">什么是休息？</h1><p id="afec" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">在REST中，装载API的服务器定义了一组客户机可以请求的特定资源，这些资源是使用惟一的URL定义和定位的。例如，考虑一下www.fossa.com的网站。当你访问这个链接时，它指向了FOSSA的主页。如果您将鼠标悬停在资源上并转到文档，您会看到链接URL附加了一个/docs后缀。这些后缀称为路由。它告诉API请求什么资源以及API提供什么资源。/docs为FOSSA提供了文档。这是一种非常干净、简单和抽象的方式来隔离网站或服务的不同部分。客户端接收的数据由服务器定义和构造，不能更改。考虑到前面的例子，您可以看到，根据请求，您可以获得完整的文档。如果只想看文档的介绍呢？你可以明白我的意思。解决此问题的基本方法是为不同的路段创建不同的路线。因此，对于简介，我们可以使用/docs/introduction，这当然很好，但如果有成千上万个部分，那么实际上会有一千条路线。可怜开发商。需要说明的是，大多数应用程序都有许多路径，并且所有的路径对于应用程序的运行都是必要的，但是上面的一千个路径是对可能已经在使用的一百个路径的补充。对于每一项资源，您都达到了一个端点，如此有效地创建了一个移动到其他部分的请求。这是非常危险的，因为它产生了大量的带宽开销，也使应用程序看起来很慢，存在保真度方面的所有障碍。有些人可能认为太多的请求可能不是一个很大的问题，不能算作一个缺陷，但事实证明，所有的请求都是HTTP请求，HTTP请求已经充满了所有的头和安全协议，增加请求的数量会产生冗余，因为请求中唯一改变的是路由。否则所有的HTTP部分保持不变。随着服务的发展，将会创建更多的端点，问题将会恶化。由于显而易见的原因，HTTP请求是不可更改的，所以必须在所使用的架构中进行更改。了解了您所知道的之后，您可能会认为这个API看起来不再是RESTful了。但事实就是如此，而且由于缺乏更好的替代方案，REST得到了统治，更不用说它提供的许多优势了。</p><p id="8023" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">概括一下，REST的主要问题是-</p><ul class=""><li id="b26f" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated">无法控制我们收到的数据。</li><li id="7c8d" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">HTTP请求太多。</li></ul><h1 id="9073" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">GraphQL是什么？</h1><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/0e5334efd5513c4cc8bff2a0850efa43.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/0*ejRRXrmIA6nomH7B"/></div></figure><p id="67a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">顾名思义，GraphQL是一种查询语言。这是一项由脸书创造的内部使用的技术，后来被开源。脸书面临着前面提到的问题，正如你可能已经体验过的，脸书的网页在连接上已经很重了，使用REST使它们变得有点慢。它是REST for APIs的完美替代，因为它允许您使用类型系统定义数据，形成模式。用简单的英语来说，它让客户能够完全控制他们请求的数据。</p><h1 id="60ab" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">GraphQL如何工作并帮助克服REST带来的问题？</h1><p id="27fa" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">GraphQL的工作方式使得我们可以一步克服REST的缺陷。让我们开始吧。</p><p id="be1f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们考虑一个社交网站的例子。</p><p id="3f85" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该网站有<strong class="kc io"> n </strong>个用户简档，每个简档有<strong class="kc io"> x </strong>个帖子，反过来这些帖子有<strong class="kc io"> y </strong>个评论。现在，如果我们打开一个配置文件，所有与该配置文件相关的帖子都应该出现，对应于每个帖子的所有评论都应该出现。正如上面已经讨论过的，这种方法不好，一次调用所有数据。所以我们采用另一种方法，只调用所需的数据，增加了请求的数量。</p><p id="c7cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">典型的REST请求如下</p><p id="fa7e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">/{ id }/2010年25日</p><p id="a172" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上述路由调用id为<em class="mu"> id </em>的概要文件，并且<em class="mu"> 25 </em>声明需要前25个帖子，25后面的<em class="mu"> 10 </em>告诉API需要对应于概要文件和帖子的10个注释。这种方式很方便，但仍然不是模块化的。我们这里有3个移动部件，即使其中一个发生变化，也必须提出新的请求。这是一个非常非常非常基本的例子，单个请求中有更多的部分，因此它们更容易被更改。现在在GraphQL的帮助下，考虑同样的场景。</p><p id="edd0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一个从API调用特定数据的查询示例。</p><figure class="mq mr ms mt gt jo gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/b3e8d382e639300f3f9743a4abcd97de.png" data-original-src="https://miro.medium.com/v2/resize:fit:480/0*1yE86MyoUQDCqAUJ"/></div></figure><p id="6337" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一次看起来可能有点难以理解，但是很容易理解。</p><p id="c1aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该查询主要由用户、帖子和评论字段组成。在user字段中，我们给了一个值为1的属性id，这意味着我们需要id为1的用户。在用户内部，有更多的属性被提及，如用户名全名等。可能会有10个以上，但我们只要求我们需要的领域，这与GraphQL的魔力开始。同样，我们呼吁张贴和评论。如果我们将这个部分与其余部分进行比较，即使我们想这样做，我们也无法分解请求中所需的子部分。如果在REST调用中，我们调用post，与之相关的所有数据都将发送给我们，这根本不是必需的，会使应用程序变慢，而在GraphQL中，我们可以具体指定我们对API的要求。为了清楚起见，这只是一个简单的例子，实际上你必须为连接创建一个<strong class="kc io">解析器</strong>和一个<strong class="kc io">模式</strong>来定义数据的完整结构。在实际的查询中，您可以从模式的特定字段中进行选择。</p><p id="5fc1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你得到的最大收获是你从n个请求变成了1个。</p><p id="d361" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">通常，GraphQL被视为思考和使用API的革命性产品。您不是在服务器上处理严格的端点，而是发送确切需求的查询。如果被一个组织采用，GraphQL对这个组织和他们的产品都有很好的反应。但是如果你深入研究，你会发现GraphQL和REST在某些方面是相似的。一些相似之处如下</p><ul class=""><li id="8cb3" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated">它们都使用HTTP来发送请求。</li><li id="7129" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">两者都可以使用特定的标识(如id)来请求资源。</li><li id="6ce3" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">两者都可以通过URL中的GET请求获取。</li><li id="3ae9" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">两者都可以在请求中返回行业标准的JSON数据。</li></ul><p id="1afd" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它们的一些不同之处是</p><ul class=""><li id="01ee" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated">在REST中，被调用的端点是对象的标识，而GraphQL将标识与获取该对象的方法分开。</li><li id="f187" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">在REST中，数据的形状和大小由服务器设置，而在GraphQL中，服务器只声明可用于调度的资源，客户端询问它需要什么。</li></ul><h1 id="454d" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">路由处理程序与解析程序</h1><p id="b993" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">那么当你实际调用一个API时会发生什么呢？通常它会在收到请求的服务器上执行一些代码。代码可以做任何事情，从调用另一个API到简单的数字加法，这取决于设计和需求。这里的整个想法是封装。你不需要知道关起门来会发生什么。但是REST和GraphQL都有非常标准的方法来实现API的内部，比较它们可以了解这些技术的不同之处。</p><p id="d78e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看express中的一个基本示例</p><p id="7bae" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">app.get('/hi '，function (req，res) { res.send('Hello World！')})</p><p id="90ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，您可以看到我们已经创建了一个/hi端点，它返回字符串“Hello World！”。从这个例子中，我们可以看到一个HTTP请求在REST API服务器中的生命周期:</p><ol class=""><li id="ea68" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mw mh mi mj bi translated">服务器从客户机接收请求，并检索HTTP动词(在本例中为GET)和URL路径。</li><li id="3863" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mw mh mi mj bi translated">API库将动词和路径匹配到在服务器中注册的函数。</li><li id="d29a" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mw mh mi mj bi translated">该函数执行并返回结果</li><li id="14ab" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mw mh mi mj bi translated">结果由API序列化，添加头，然后发送回客户端</li></ol><p id="f9e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">GraphQL提供了类似的实现</p><p id="e5b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">const resolvers = { query:{ hi:()= &gt; { return ' Hello world！'；} } };</p><p id="f152" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如您所见，我们没有为特定的URL提供函数，而是提供了匹配特定字段的函数，在本例中，字段是hi。在GraphQL中，这个函数被称为<strong class="kc io">解析器</strong>。</p><p id="3d1c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">发出请求的查询:</p><p id="fd7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">查询{嗨}</p><p id="d7d0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，当服务器收到GraphQL请求时，会发生以下情况:</p><ol class=""><li id="2788" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mw mh mi mj bi translated">服务器接收请求，并检索GraphQL查询。</li><li id="3700" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mw mh mi mj bi translated">遍历查询，并为每个字段调用适当的解析器。在本例中，只有一个字段，hi，它在查询类型中</li><li id="1191" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mw mh mi mj bi translated">调用该函数，它返回一个结果</li><li id="b3a4" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mw mh mi mj bi translated">GraphQL库和服务器将结果附加到与查询形状匹配的响应中</li></ol><p id="7dd9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以你会回到:</p><p id="9230" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">{“嗨”:“你好，世界！”}</p><p id="92f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于更复杂的查询，解析器也可以在单个查询中相互嵌套。</p><h1 id="4808" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">为什么选择GraphQL？:摘要</h1><p id="5982" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">GraphQL完美地解决了3个最重要的问题:</p><ul class=""><li id="d30f" class="mb mc in kc b kd ke kh ki kl md kp me kt mf kx mg mh mi mj bi translated"><strong class="kc io">需要多次往返以获取视图所需的数据</strong>:使用GraphQL，您总是可以通过与服务器的<em class="mu">单次</em>往返来获取视图所需的所有初始数据。为了用REST API做同样的事情，我们需要引入难以管理和扩展的非结构化参数和条件。</li><li id="be3a" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><strong class="kc io">客户端对服务器的依赖</strong>:使用GraphQL，客户端使用请求语言，无需服务器硬编码数据的形状或大小，并将客户端与服务器分离。这意味着客户机可以独立于服务器进行维护和改进。</li></ul><h1 id="96cb" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">结论</h1><p id="835c" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">GraphQL是一个游戏改变者。它非常优雅地解决了REST带来的问题，但即使在2019年，REST也不会去任何地方。这个场景可以与XML和JSON之争相比较。在JSON之前，XML是数据传输标准，当JSON出现时，它对XML构成了巨大的威胁，因为与XML相比，JSON非常简单和轻量级。毫无疑问，JSON到处都在使用，但是XML直到今天还活着，并且还在使用。同样的道理，不管有多少竞争者出现并威胁到它的存在，REST将永远盛行。这幅作品中的GraphQL并不是一幅完整的图画，而是一幅更大图画的一部分。您可以参考GraphQL的官方文档，以获得关于该技术的更多知识。</p></div></div>    
</body>
</html>