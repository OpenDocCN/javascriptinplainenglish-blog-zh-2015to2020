<html>
<head>
<title>Get started with Feathers &amp; React — Part 2</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">从羽毛和反应开始—第2部分</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/get-started-with-feathers-react-part-2-d071e29cb6a9?source=collection_archive---------3-----------------------#2020-10-31">https://javascript.plainenglish.io/get-started-with-feathers-react-part-2-d071e29cb6a9?source=collection_archive---------3-----------------------#2020-10-31</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3668cf7c30fc5efb4a2175c3caf88a77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q2J4l6Q1t5u1tgv_7YlHgg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Illustration by <a class="ae jz" href="https://undraw.co/" rel="noopener ugc nofollow" target="_blank">Undraw</a></figcaption></figure><p id="960f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我的<a class="ae jz" href="https://ingeniousambivert.medium.com/get-started-with-feathers-react-part-1-6b2b35a398c3" rel="noopener"> <strong class="kc io">上一篇文章</strong> </a>中，我简要解释了为什么选择<strong class="kc io">反应</strong>和<strong class="kc io">羽毛</strong>来创建一个网络应用。现在，在本文中，我们将设置一个基本的<strong class="kc io"> Web </strong> - <strong class="kc io"> App </strong>，带有配置了<em class="ky"> REST API </em>和<em class="ky">认证</em>的<strong class="kc io"> React客户端</strong>和<strong class="kc io"> Feathers </strong> <strong class="kc io">服务器</strong>。</p><h1 id="3263" class="kz la in bd lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw bi translated">所以让我们开始吧。</h1><p id="6f62" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">首先，我们将创建/设置<strong class="kc io"> React应用程序/客户端</strong>，然后是<strong class="kc io"> Feathers应用程序/服务器。</strong></p><p id="add3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以基本上有很多<a class="ae jz" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank">的方式</a>来设置一个<strong class="kc io"> React App </strong>，但是我们会用最常见最直接的方式<strong class="kc io">——</strong>使用<strong class="kc io"> </strong> <a class="ae jz" href="https://create-react-app.dev/docs/getting-started/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">创建——React——App</em></strong></a>。</p><blockquote class="mc md me"><p id="e58f" class="ka kb ky kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated">先决条件:你需要有<a class="ae jz" href="https://nodejs.org/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="in">节点</em> </strong> </a>和<a class="ae jz" href="https://www.npmjs.com/package/qs" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="in">NPM</em></strong></a><strong class="kc io"><em class="in"/></strong>(或者你也可以用<a class="ae jz" href="https://yarnpkg.com/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="in">纱线</em></strong></a><strong class="kc io"><em class="in"/></strong>代替<strong class="kc io"> <em class="in"> npm </em></strong></p></blockquote><p id="f280" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么我们用<a class="ae jz" href="https://nodejs.dev/learn/the-npx-nodejs-package-runner" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">npx</em></strong></a><strong class="kc io"><em class="ky"/></strong>(node . js包runner)在终端中运行<strong class="kc io"> create-react-app </strong>来生成我们的<strong class="kc io">客户端</strong> <em class="ky">。</em></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="617b" class="mr la in mn b gy ms mt l mu mv">// cd to the directory</span><span id="a33e" class="mr la in mn b gy mw mt l mu mv">npx create-react-app client</span></pre><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/0fcbae4cbe615545e532dfcf5f3e1cf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*1_F8c-1NENu0zQC9hn19fQ.gif"/></div></div></figure><p id="0a30" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这将需要几分钟的时间来完成。</p><p id="9844" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同时让我们生成<strong class="kc io">服务器，</strong>类似于<strong class="kc io"> React </strong>有不止一种<a class="ae jz" href="https://docs.feathersjs.com/guides/basics/starting.html#our-first-app" rel="noopener ugc nofollow" target="_blank">方式</a>来创建<strong class="kc io"> Feathers App </strong>但是我们还是会使用最常见的方式——<a class="ae jz" href="https://docs.feathersjs.com/guides/basics/generator.html" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">Feathers-CLI</em></strong></a><em class="ky">。</em>在终端中打开另一个标签，输入以下命令。</p><blockquote class="mc md me"><p id="7192" class="ka kb ky kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated">先决条件:你需要在你的系统中全局安装<em class="in"/><strong class="kc io"><em class="in">feathers-CLI</em></strong>。</p></blockquote><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e886" class="mr la in mn b gy ms mt l mu mv">// cd to the directory</span><span id="1b1d" class="mr la in mn b gy mw mt l mu mv">feathers generate app</span></pre><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mx"><img src="../Images/27ec796d36576fff244e17e58a411c1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*l36DnwqTtnooz_NpfgSoPw.gif"/></div></div></figure><p id="da19" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> feathers-cli </strong>将<strong class="kc io"> </strong>开始一系列提示，根据您的需要配置服务器。重要的有:</p><ol class=""><li id="b6b9" class="my mz in kc b kd ke kh ki kl na kp nb kt nc kx nd ne nf ng bi translated">语言偏好(<strong class="kc io">JavaScript</strong>/<strong class="kc io">TypeScript</strong>)—<em class="ky">JavaScript</em></li><li id="aa1e" class="my mz in kc b kd nh kh ni kl nj kp nk kt nl kx nd ne nf ng bi translated">包管理器的选择(<strong class="kc io">NPM</strong>/<strong class="kc io">yarn</strong>)—<em class="ky">NPM</em></li><li id="e41f" class="my mz in kc b kd nh kh ni kl nj kp nk kt nl kx nd ne nf ng bi translated">API类型(<strong class="kc io"> RESTful </strong>和/或<strong class="kc io">实时</strong> ) — <em class="ky"> REST </em></li><li id="f420" class="my mz in kc b kd nh kh ni kl nj kp nk kt nl kx nd ne nf ng bi translated">测试库的选择(<strong class="kc io">Jest</strong>/<strong class="kc io">Mocha+assert</strong>)—<em class="ky">Jest</em></li><li id="de5f" class="my mz in kc b kd nh kh ni kl nj kp nk kt nl kx nd ne nf ng bi translated">选择我们是否需要认证(创建认证<em class="ky">服务</em> ) — <em class="ky">是</em></li><li id="a643" class="my mz in kc b kd nh kh ni kl nj kp nk kt nl kx nd ne nf ng bi translated">林挺图书馆的选择(<strong class="kc io">ESLint</strong>/<strong class="kc io">standards js</strong>)——<em class="ky">ESLint</em></li><li id="8662" class="my mz in kc b kd nh kh ni kl nj kp nk kt nl kx nd ne nf ng bi translated">认证策略的选择(<strong class="kc io">本地</strong>/<strong class="kc io">OAuth</strong>)——<em class="ky">本地</em></li><li id="0cbb" class="my mz in kc b kd nh kh ni kl nj kp nk kt nl kx nd ne nf ng bi translated">用于认证的<em class="ky">服务</em>的种类— <em class="ky">用户</em>(可以根据使用情况而变化)</li><li id="2596" class="my mz in kc b kd nh kh ni kl nj kp nk kt nl kx nd ne nf ng bi translated">选择一个<a class="ae jz" href="https://docs.feathersjs.com/api/databases/adapters.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">数据库适配器</em> </strong> </a>用于认证<em class="ky">服务—mongose</em></li><li id="4a9f" class="my mz in kc b kd nh kh ni kl nj kp nk kt nl kx nd ne nf ng bi translated">根据选择的<em class="ky">适配器指定<em class="ky">数据库连接</em>—MongoDB://localhost:27017/server</em>(也可以选择使用远程连接)</li></ol><p id="aefe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样。我们已经成功地为我们的Web-App创建了一个<strong class="kc io">客户端</strong> ( <em class="ky">反应</em>)和一个<strong class="kc io">服务器</strong> ( <em class="ky">羽毛</em>)(当它们组合在一起时，就构成了Web-App btw)。</p><p id="684d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，继续在不同的终端中运行<strong class="kc io">客户端</strong>和<strong class="kc io">服务器</strong>。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="847f" class="mr la in mn b gy ms mt l mu mv">// cd to the respective directories</span><span id="d654" class="mr la in mn b gy mw mt l mu mv">npm start (or yarn start)</span></pre><p id="e87c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您应该会看到类似这样的内容。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nm"><img src="../Images/51cee716d5479fd8f1d81316cc41d86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S-Fqxwc27JPy5WC1gKagUA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Images created by <a class="ae jz" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">Carbon</a></figcaption></figure><p id="9683" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，两个项目(<strong class="kc io">客户机</strong> &amp; <strong class="kc io">服务器</strong>)都已经启动并运行。让我们浏览项目目录，看看<em class="ky">生成器/CLI</em>创建了什么，并浏览其中的代码。</p><h2 id="851f" class="mr la in bd lb nn no dn lf np nq dp lj kl nr ns ln kp nt nu lr kt nv nw lv nx bi translated">项目目录— ( src/)</h2><ul class=""><li id="7cbb" class="my mz in kc b kd lx kh ly kl ny kp nz kt oa kx ob ne nf ng bi translated"><strong class="kc io">客户端</strong></li></ul><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6461" class="mr la in mn b gy ms mt l mu mv">├── src</span><span id="d7b4" class="mr la in mn b gy mw mt l mu mv">├── App.css</span><span id="dc36" class="mr la in mn b gy mw mt l mu mv">├── App.js</span><span id="a668" class="mr la in mn b gy mw mt l mu mv">├── App.test.js</span><span id="2350" class="mr la in mn b gy mw mt l mu mv">├── index.css</span><span id="21b6" class="mr la in mn b gy mw mt l mu mv">├── index.js</span><span id="fb0f" class="mr la in mn b gy mw mt l mu mv">├── logo.svg</span><span id="abe3" class="mr la in mn b gy mw mt l mu mv">├── reportWebVitals.js</span><span id="6df2" class="mr la in mn b gy mw mt l mu mv">└── setupTests.js</span></pre><p id="00d9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里的<strong class="kc io"> <em class="ky"> index.js </em> </strong>是app的根，它保存了主要的<strong class="kc io"> App </strong>组件，这就把我们带到了<strong class="kc io"> <em class="ky"> App.js </em> </strong>。app所有不同的<em class="ky">组件</em>都配置到<strong class="kc io"> <em class="ky"> App.js. </em> </strong>中</p><p id="35c8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">app的内部路由也在<strong class="kc io"> <em class="ky"> App.js </em> </strong>中配置。我不会深入研究路由是如何工作的，但是路由是在一个<strong class="kc io"> React </strong>应用程序的不同组件视图之间的导航。如果你想了解更多，请看这里的。</p><p id="b164" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后将<strong class="kc io"> <em class="ky"> App.js </em> </strong>作为依赖项插入到<strong class="kc io"> <em class="ky"> index.js </em> </strong>中，呈现所有<em class="ky">组件</em>并生成一个<a class="ae jz" href="https://en.wikipedia.org/wiki/Single-page_application" rel="noopener ugc nofollow" target="_blank"> <em class="ky">单页面应用。</em>T45】</a></p><p id="32ea" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky"> CSS </em>文件由应用程序的样式组成。</p><blockquote class="mc md me"><p id="3b37" class="ka kb ky kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated">现在可以忽略<em class="in"> reportWebVitals.js </em>和<em class="in"> setupTests.js </em>。</p></blockquote><ul class=""><li id="12fb" class="my mz in kc b kd ke kh ki kl na kp nb kt nc kx ob ne nf ng bi translated"><strong class="kc io">服务器</strong></li></ul><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="144a" class="mr la in mn b gy ms mt l mu mv">├── app.hooks.js</span><span id="f263" class="mr la in mn b gy mw mt l mu mv">├── app.js</span><span id="066c" class="mr la in mn b gy mw mt l mu mv">├── authentication.js</span><span id="ebfe" class="mr la in mn b gy mw mt l mu mv">├── channels.js</span><span id="f84a" class="mr la in mn b gy mw mt l mu mv">├── index.js</span><span id="6fd7" class="mr la in mn b gy mw mt l mu mv">├── logger.js</span><span id="5afb" class="mr la in mn b gy mw mt l mu mv">├── middleware</span><span id="c0d8" class="mr la in mn b gy mw mt l mu mv">│   └── index.js</span><span id="593a" class="mr la in mn b gy mw mt l mu mv">├── models</span><span id="8b02" class="mr la in mn b gy mw mt l mu mv">│   └── users.model.js</span><span id="f440" class="mr la in mn b gy mw mt l mu mv">├── mongoose.js</span><span id="026d" class="mr la in mn b gy mw mt l mu mv">├── services</span><span id="0541" class="mr la in mn b gy mw mt l mu mv">├── index.js</span><span id="9d0f" class="mr la in mn b gy mw mt l mu mv">└── users</span><span id="fc5d" class="mr la in mn b gy mw mt l mu mv">├── users.class.js</span><span id="3254" class="mr la in mn b gy mw mt l mu mv">├── users.hooks.js</span><span id="aa38" class="mr la in mn b gy mw mt l mu mv">└── users.service.js</span></pre><p id="918d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这里，类似于<em class="ky">的客户端</em> <strong class="kc io"> <em class="ky"> index.js </em> </strong>是服务器的根。它包含执行应用程序和启动服务器的代码。<strong class="kc io"> <em class="ky"> app.js </em> </strong>保存了三个关键实例——<strong class="kc io"><em class="ky">羽毛</em> </strong>，<strong class="kc io"> <em class="ky">快递</em> </strong> (RESTful部分)，以及<strong class="kc io"> <em class="ky">猫鼬</em> </strong>(数据建模为<a class="ae jz" href="https://www.mongodb.com/" rel="noopener ugc nofollow" target="_blank"> <em class="ky">猫鼬</em> </a> ) <strong class="kc io"> <em class="ky"> </em> </strong>包括<strong class="kc io"> <em class="ky"> </em> </strong>所有配置)<strong class="kc io"> <em class="ky"> app.hooks.js </em> </strong>包含了<strong class="kc io"> <em class="ky"> before、</em> </strong>和<strong class="kc io"> <em class="ky">错误钩子、</em> </strong>这些钩子运行在每个<strong class="kc io"> <em class="ky"> HTTP调用<strong class="kc io"> <em class="ky"> app </em> </strong>的</em> </strong>上也就是说这些<strong class="kc io"> <em class="ky">钩子</em> </strong>将运行在每个上</p><p id="62f7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来，<strong class="kc io"><em class="ky">authentic ation . js</em></strong>实现<em class="ky">本地</em>&amp;<em class="ky">JWT</em><a class="ae jz" href="https://docs.feathersjs.com/api/authentication/strategy.html" rel="noopener ugc nofollow" target="_blank"><em class="ky">策略</em> </a>。它注册这些<em class="ky">策略</em>，并在我们的<strong class="kc io"> Feathers应用</strong>中配置<em class="ky"> expressOauth </em>。<strong class="kc io"> </strong>服务注册在<strong class="kc io"><em class="ky">'/认证'</em> </strong>路径上。</p><p id="26b8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">继续，<strong class="kc io"> <em class="ky"> channels.js </em> </strong>具有事件通道，这些事件通道由<strong class="kc io"> <em class="ky"> </em> </strong>决定将<a class="ae jz" href="https://docs.feathersjs.com/api/events.html" rel="noopener ugc nofollow" target="_blank">实时事件</a>发送给哪些连接的客户端，以及发送的数据应该是什么样子。它在一个<strong class="kc io">服务器</strong>上使用，带有<em class="ky">实时</em>传输(<a class="ae jz" href="https://docs.feathersjs.com/api/socketio.html" rel="noopener ugc nofollow" target="_blank"><em class="ky">socket . io</em></a><em class="ky"/>或<a class="ae jz" href="https://docs.feathersjs.com/api/primus.html" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> Primus </em> </a>)设置。但是因为我们没有，我们可以选择忽略它。</p><p id="f871" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">接下来是<strong class="kc io"> <em class="ky"> logger.js </em> </strong>，其中<strong class="kc io"> </strong>是用<a class="ae jz" href="https://www.npmjs.com/package/winston" rel="noopener ugc nofollow" target="_blank"> winston </a>创建的一个简单的可插拔函数，用来记录应用程序的事件和动作。以及<strong class="kc io"> </strong>中的<strong class="kc io">中间件/ </strong>用于注册<strong class="kc io"> Feathers App中的任意一个<a class="ae jz" href="https://expressjs.com/en/guide/using-middleware.html" rel="noopener ugc nofollow" target="_blank"> express中间件</a>。</strong></p><p id="5ea9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky">服务</em>的所有<em class="ky">数据模型(</em>用于<em class="ky"> MongoDB) </em>存储在<strong class="kc io"> models/中。</strong>它们是自动生成的(您可以稍后修改)。<strong class="kc io"><em class="ky">mongose . js</em></strong>由客户端为<strong class="kc io"> <em class="ky"> </em> </strong> <em class="ky">的MongoDB </em>数据库驱动—<strong class="kc io"><em class="ky">mongose</em></strong>组成。</p><p id="906e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">继续介绍<strong class="kc io">服务—</strong>T42羽毛<strong class="kc io">的</strong>心脏。<strong class="kc io"> <em class="ky">服务</em> </strong>包含了我们<strong class="kc io">羽毛</strong> <strong class="kc io"> App </strong>的所有业务逻辑。<strong class="kc io"> <em class="ky"> class.js </em> </strong>是我们写业务逻辑的地方。<strong class="kc io"> <em class="ky"> service.js </em> </strong>配置服务路径，实例化类，创建模型。<strong class="kc io"> <em class="ky"> hooks.js </em> </strong>与<strong class="kc io"> <em class="ky"> app.hooks.js </em> </strong>包含<strong class="kc io"> <em class="ky">之前、</em> </strong>和<strong class="kc io"> <em class="ky">错误挂钩</em> </strong>为特定的<strong class="kc io"> <em class="ky">服务</em> </strong>。而<strong class="kc io"> <em class="ky"> index.js </em> </strong>是所有服务注册到<strong class="kc io"> Feathers App </strong>的地方。</p><p id="aff9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是项目目录和其中代码的概述。</p><p id="73ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以进入下一步了。将<strong class="kc io"> <em class="ky">客户端</em> </strong>连接到<strong class="kc io"> <em class="ky">服务器。</em> </strong></p><p id="be7d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但在此之前，让我们测试一下我们的<strong class="kc io"> <em class="ky">认证</em></strong><em class="ky">API</em>real quick<em class="ky">。</em>我通常使用<a class="ae jz" href="https://www.postman.com/" rel="noopener ugc nofollow" target="_blank"><em class="ky">Postman</em></a><em class="ky">，</em>来测试我的API<em class="ky"/>，但是你可以使用任何你喜欢的<em class="ky"> REST客户端</em><em class="ky">。</em></p><p id="4da5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，启动<em class="ky"> REST客户端</em>，用凭证对象(电子邮件和密码)向<strong class="kc io"><em class="ky">"/用户"</em> </strong>发出一个<em class="ky"> POST </em>请求。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="24eb" class="mr la in mn b gy ms mt l mu mv"><strong class="mn io"><em class="ky">url : </em></strong><em class="ky">http:localhost:3030/users</em></span><span id="18f7" class="mr la in mn b gy mw mt l mu mv">// body type - JSON</span><span id="b45c" class="mr la in mn b gy mw mt l mu mv"><strong class="mn io">body :</strong></span><span id="adcc" class="mr la in mn b gy mw mt l mu mv">{</span><span id="084f" class="mr la in mn b gy mw mt l mu mv">"email":"monarch@maisuriya.com", // your email</span><span id="cd8e" class="mr la in mn b gy mw mt l mu mv">"password":"maisuriya" // your password</span><span id="9049" class="mr la in mn b gy mw mt l mu mv">}</span></pre><p id="40ed" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">点击发送后，您应该会收到类似以下内容的响应</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="763f" class="mr la in mn b gy ms mt l mu mv">{</span><span id="4a73" class="mr la in mn b gy mw mt l mu mv">"_id": "5f98effe9958b369f665215d",</span><span id="fddc" class="mr la in mn b gy mw mt l mu mv">"email": "monarch@maisuriya.com",</span><span id="a55a" class="mr la in mn b gy mw mt l mu mv">"createdAt": "2020-10-28T04:13:50.397Z",</span><span id="1e88" class="mr la in mn b gy mw mt l mu mv">"updatedAt": "2020-10-28T04:13:50.397Z",</span><span id="5820" class="mr la in mn b gy mw mt l mu mv">"__v": 0</span><span id="6a25" class="mr la in mn b gy mw mt l mu mv">}</span></pre><p id="5bb5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">瞧啊。这意味着我们已经成功地用我们的<em class="ky"> API </em>在我们的系统中创建了一个用户。并且用户具有上述属性。</p><p id="cc0a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在让我们尝试对创建的用户进行身份验证。</p><p id="8943" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<em class="ky"> REST客户端</em>中打开另一个标签页，向<strong class="kc io"><em class="ky"/></strong>发出<em class="ky"> POST </em>请求。但是这一次我们需要给我们的凭证对象添加一个额外的属性—策略<strong class="kc io"><em class="ky"/></strong><em class="ky"/>，在我们的例子中是本地<strong class="kc io"><em class="ky"/></strong><em class="ky">。</em></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ec97" class="mr la in mn b gy ms mt l mu mv"><strong class="mn io"><em class="ky">url : </em></strong><em class="ky">http:localhost:3030/authentication</em></span><span id="fcc9" class="mr la in mn b gy mw mt l mu mv">// body type - JSON</span><span id="dde0" class="mr la in mn b gy mw mt l mu mv"><strong class="mn io">body :</strong></span><span id="70b2" class="mr la in mn b gy mw mt l mu mv">{</span><span id="a6be" class="mr la in mn b gy mw mt l mu mv">"strategy":"local", // the auth strategy we chose earlier</span><span id="a60e" class="mr la in mn b gy mw mt l mu mv">"email":"monarch@maisuriya.com", // email used to create the user</span><span id="41ef" class="mr la in mn b gy mw mt l mu mv">"password":"maisuriya" // password used to create the user</span><span id="5f08" class="mr la in mn b gy mw mt l mu mv">}</span></pre><p id="3b5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">点击send，您应该会收到一个类似如下的响应对象。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="c493" class="mr la in mn b gy ms mt l mu mv">{</span><span id="fed7" class="mr la in mn b gy mw mt l mu mv">"accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6ImFjY2VzcyJ9.eyJpYXQiOjE2MDM4NTg5NTEsImV4cCI6MTYwMzk0NTM1MSwiYXVkIjoiaHR0cHM6Ly95b3VyZG9tYWluLmNvbSIsImlzcyI6ImZlYXRoZXJzIiwic3ViIjoiNWY5OGVmZmU5OTU4YjM2OWY2NjUyMTVkIiwianRpIjoiZDUyNzAzZjYtYTZhZS00NDgyLTg2MDYtODdlYTNmMzBjNzBlIn0.OMTAJO_cb9erx4SqHIfFUplQCy5a2CIS2-OfrATNqw4",</span><span id="a68a" class="mr la in mn b gy mw mt l mu mv">"authentication": {</span><span id="a06a" class="mr la in mn b gy mw mt l mu mv">"strategy": "local"</span><span id="b83a" class="mr la in mn b gy mw mt l mu mv">},</span><span id="e258" class="mr la in mn b gy mw mt l mu mv">"user": {</span><span id="a00e" class="mr la in mn b gy mw mt l mu mv">"_id": "5f98effe9958b369f665215d",</span><span id="590b" class="mr la in mn b gy mw mt l mu mv">"email": "monarch@maisuriya.com",</span><span id="6b01" class="mr la in mn b gy mw mt l mu mv">"createdAt": "2020-10-28T04:13:50.397Z",</span><span id="cd73" class="mr la in mn b gy mw mt l mu mv">"updatedAt": "2020-10-28T04:13:50.397Z",</span><span id="69ac" class="mr la in mn b gy mw mt l mu mv">"__v": 0</span><span id="bee5" class="mr la in mn b gy mw mt l mu mv">}</span><span id="bc33" class="mr la in mn b gy mw mt l mu mv">}</span></pre><p id="b9aa" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它有访问令牌(JWT)、用户详细信息和认证策略。</p><p id="4f5d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">现在你已经有了一个全功能的<em class="ky">认证</em>基础<em class="ky"> REST API。</em> </strong></p><p id="81c6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你看到设置这个有多简单了吗？没有手动设置Passport和JWT以及本地策略或会话和cookies，或者用任何ORM或ODM配置数据库的麻烦。羽毛为我们做了这一切。这不是很神奇吗？</p><h2 id="9a84" class="mr la in bd lb nn no dn lf np nq dp lj kl nr ns ln kp nt nu lr kt nv nw lv nx bi translated">现在下一步。将我们的React客户端连接到我们的Feathers服务器。</h2><p id="0630" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">要做到这一点<a class="ae jz" href="https://docs.feathersjs.com/api/client.html#feathersjs-client" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> </em> <strong class="kc io"> <em class="ky">羽毛方式</em> </strong> </a> <strong class="kc io"> </strong>(这在我看来是相当容易的方式)我们将需要在<strong class="kc io"> </strong>中安装几个依赖<strong class="kc io"><em class="ky"/></strong>。所以打开<strong class="kc io"> React App </strong>目录<strong class="kc io"> </strong>中的终端，用<em class="ky"> yarn </em>(或者<em class="ky"> npm </em>)安装下面的依赖项。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="ab9d" class="mr la in mn b gy ms mt l mu mv">yarn add @feathersjs/authentication-client @feathersjs/client @feathersjs/feathers @feathersjs/rest-client</span></pre><p id="5a51" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为我们已经添加了所需的依赖项。让我们来编写实际的代码，将<strong class="kc io"> <em class="ky">客户端</em> </strong>连接到<strong class="kc io"> <em class="ky">服务器</em> </strong>。</p><p id="939b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<strong class="kc io"> src </strong>中创建一个名为<strong class="kc io">‘client’</strong>的新目录。并在这个目录中创建一个<strong class="kc io"> index.js </strong>。并键入以下代码。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oc"><img src="../Images/0aeb8dc8335f0ac2823c347d65512fe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nK2W_P4u06mr2OhYZU6xLQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image created by <a class="ae jz" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">Carbon</a></figcaption></figure><blockquote class="mc md me"><p id="8253" class="ka kb ky kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated">我使用<a class="ae jz" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="in"> axios </em> </strong> </a>作为<em class="in"> HTTP客户端。但是你可以使用任何你想要的其他客户端，只要把它作为一个依赖项添加进来。点击了解更多信息<a class="ae jz" href="https://docs.feathersjs.com/api/client/rest.html#feathersjs-rest-client" rel="noopener ugc nofollow" target="_blank">。</a></em></p></blockquote><p id="89ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这段代码是做什么的呢？</p><p id="b652" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这相当简单。我们从<strong class="kc io">客户端</strong>导入<strong class="kc io">羽毛</strong>实例，从<strong class="kc io">认证客户端</strong>导入<strong class="kc io">认证</strong>实例，从<strong class="kc io"> rest客户端</strong>导入<strong class="kc io"> rest </strong>实例。</p><p id="14e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们实例化<strong class="kc io"> feathers() </strong>，然后实例化<strong class="kc io"> rest() — </strong>传递<em class="ky"> API_URL </em>(在我们的例子中— <em class="ky"> http:localhost:3030 </em>)作为参数。</p><p id="24a4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意——我使用<a class="ae jz" href="https://create-react-app.dev/docs/adding-custom-environment-variables/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">环境</strong> </a> <strong class="kc io"> </strong>变量来存储默认信息，比如在<strong class="kc io">中的API_URL。<strong class="kc io">客户端/ </strong>的<strong class="kc io">根</strong>处的环境</strong></p><p id="cdb9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">其次，我们在<em class="ky"> feathersClient </em>中配置<em class="ky"> restClient </em>以及我们选择的<em class="ky"> HTTP Client </em>。然后我们用<em class="ky"> feathers-authentication配置<em class="ky"> feathersClient </em>。</em></p><p id="13a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第三，我们在<strong class="kc io"> </strong> <em class="ky">中设置了<strong class="kc io"> auth() </strong>羽毛状</em> <strong class="kc io"> </strong>与<em class="ky"> </em>的一些典型选项。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="abce" class="mr la in mn b gy ms mt l mu mv">// stores the jwt in the browser's local storage<br/>storage: window.localStorage,</span><span id="1fdf" class="mr la in mn b gy mw mt l mu mv">// storage key for the jwt<br/>storageKey: "feathers-react-jwt"</span></pre><p id="44b4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就是这样，我们已经成功地将我们的<strong class="kc io"> React应用</strong>连接到我们的<strong class="kc io"> Feathers服务器</strong>。现在，我们可以使用这个<em class="ky"> feathersClient </em>让<em class="ky"> API调用</em>到我们的<em class="ky"> </em> <strong class="kc io"> <em class="ky">服务器</em> </strong> <em class="ky">。</em></p><h2 id="ba67" class="mr la in bd lb nn no dn lf np nq dp lj kl nr ns ln kp nt nu lr kt nv nw lv nx bi translated">现在是本文的最后一步。</h2><p id="bc9e" class="pw-post-body-paragraph ka kb in kc b kd lx kf kg kh ly kj kk kl lz kn ko kp ma kr ks kt mb kv kw kx ig bi translated">让我们创建一些简单的<em class="ky"> React组件</em>来组成一个S <strong class="kc io"> <em class="ky"> ignUp </em> </strong>和一个S <strong class="kc io"> <em class="ky"> ignIn </em> </strong>页面，这将允许我们与<strong class="kc io">服务器</strong>进行通信，以便通过一个简单的用户界面<em class="ky">来创建和验证用户。</em></p><p id="2206" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我不想从头开始创建这些组件。所以我使用Chris Bakley的<a class="ae jz" href="https://github.com/chrisblakely01/basic-react-forms" rel="noopener ugc nofollow" target="_blank"> React Forms Starter模板</a>，它有几个风格得体的React表单。</p><p id="5704" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我还在我们的app中使用了<a class="ae jz" href="https://www.npmjs.com/package/react-router-dom" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">react-router-DOM</em></strong></a><strong class="kc io"><em class="ky"/></strong>作为内部路由的依赖<strong class="kc io"> <em class="ky"> </em> </strong>。</p><p id="1949" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以在将模板中的代码添加到我们的<strong class="kc io"> <em class="ky">客户端</em></strong>之后，最终的<strong class="kc io"> App </strong>看起来是这样的。</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi od"><img src="../Images/22aa916d5b31cacaf749c6b93a5b3f48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*DSImdGP9uezm-pzxlp9wkA.gif"/></div></div></figure><p id="e3b3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里发生了什么？</p><p id="654d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这相当简单。我们有一个带有两个CTA按钮的登录页面— <strong class="kc io">注册</strong>和<strong class="kc io">登录。</strong>点击任意一个按钮，应用程序会将我们导航到不同的视图。</p><ul class=""><li id="2fd2" class="my mz in kc b kd ke kh ki kl na kp nb kt nc kx ob ne nf ng bi translated"><strong class="kc io">注册表单</strong>:这是一个简单的<em class="ky">反应组件</em>，有两个输入和一个提交按钮。所以让我们来看看代码。</li></ul><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oe"><img src="../Images/6db65380dcbdf0ddc5cb037358346d76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lGZGI_SjuN0kBiGRp4N8tA.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Images created by <a class="ae jz" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">Carbon</a></figcaption></figure><p id="4d34" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里到底发生了什么？让我们一步一步来。</p><p id="3381" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们导入必要的依赖项，如<em class="ky">使用状态</em>挂钩和<em class="ky">T33】羽毛客户端</em>。</p><blockquote class="mc md me"><p id="880c" class="ka kb ky kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated">如果你不熟悉<em class="in"> React Hooks，</em>我建议你在继续前进之前先看看这里的<a class="ae jz" href="https://reactjs.org/docs/hooks-overview.html" rel="noopener ugc nofollow" target="_blank"/>。</p></blockquote><p id="3362" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以正如我在我的<a class="ae jz" href="https://ingeniousambivert.medium.com/get-started-with-feathers-react-part-1-6b2b35a398c3" rel="noopener"> <strong class="kc io">上一篇文章</strong> </a>中提到的，<a class="ae jz" href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">状态</em> </strong> </a>对象是你存储属于组件的属性值的地方。由于我们使用<strong class="kc io"> React的功能组件</strong>，我们将需要使用<em class="ky">钩子</em>来执行与基于<strong class="kc io">类的组件</strong>相同的操作。</p><blockquote class="mc md me"><p id="c9f8" class="ka kb ky kc b kd ke kf kg kh ki kj kk mf km kn ko mg kq kr ks mh ku kv kw kx ig bi translated">为什么我选择了<strong class="kc io">功能组件</strong>而不是<strong class="kc io">基于类的</strong>？它<strong class="kc io"> </strong>完全是另外一个故事。如果你想了解它，你可以阅读这篇文章。</p></blockquote><p id="8b01" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们正在制作一个简单的<strong class="kc io">注册组件</strong>。<strong class="kc io"> </strong>现在，因为我们将使用来自用户的凭证(电子邮件、密码)来创建用户，所以在将它们发送到<strong class="kc io">服务器</strong>之前，我们需要将它们存储在组件中的临时<strong class="kc io">本地</strong> <strong class="kc io">状态</strong>中，这就是<em class="ky">使用状态</em>挂钩的作用。它允许我们创建一个组件的<strong class="kc io">局部</strong> <strong class="kc io">状态</strong>。因此，我正在创建一个具有电子邮件和密码属性的<strong class="kc io">状态</strong>对象(称之为<em class="ky">凭证</em>)。我还创建了另一个<strong class="kc io">状态</strong>对象- <em class="ky">结果</em>来存储我们从服务器得到的响应。</p><p id="542b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们跳到组件的JSX部分。我们将与它同时理解方法(<em class="ky">handleemailputchange，handlePasswordInputChange，handleSubmit </em>)。</p><p id="10fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，我们创建了一个基本表单，有两个输入(电子邮件和密码)和一个提交按钮。看起来相当简单，但是这里我们需要关注的是输入的两个属性——<em class="ky">value</em>和<em class="ky"> onChange </em>。<em class="ky"> </em>这里的<em class="ky"> value </em>属性保存输入的值，我们从<em class="ky"> credentials </em>对象中获取该值，这将我们带到下一个属性<em class="ky"> onChange </em>。</p><p id="f140" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ky"> onChange </em>属性根据输入调用方法<em class="ky">handleemailputchange</em>或<em class="ky">handlePasswordInputChange</em>，并将输入的值更改为凭证对象的值。现在我们来看看这两种方法背后的大致思路。</p><p id="856c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这些方法接受一个参数<code class="fe of og oh mn b">event</code>，这是一个<em class="ky"> javascript事件。</em></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="96a8" class="mr la in mn b gy ms mt l mu mv">// passing the credentials object<br/>setCredentials((credentials) =&gt; ({</span><span id="2561" class="mr la in mn b gy mw mt l mu mv">// spreading the credentials object<br/>...credentials,</span><span id="7932" class="mr la in mn b gy mw mt l mu mv">// changing the input (email/password) value<br/>input: event.target.value,</span><span id="50f0" class="mr la in mn b gy mw mt l mu mv">}));</span></pre><p id="7a7b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，让我们转到submit按钮，单击该按钮将提交表单。现在让我们回到创建表单的最开始，表单有一个属性<em class="ky"> onSubmit </em>，它在表单提交时调用一个方法。所以我们来看看提交表单时被调用的方法——<em class="ky">handle submit。</em></p><p id="009c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，这个方法接受一个参数<code class="fe of og oh mn b">event</code>，这是一个<em class="ky"> javascript事件。</em></p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="0c4e" class="mr la in mn b gy ms mt l mu mv">// e = event</span><span id="8aaf" class="mr la in mn b gy mw mt l mu mv">// prevent the default behaviour of the form on submit<br/><strong class="mn io">e.preventDefault();</strong></span><span id="c3eb" class="mr la in mn b gy mw mt l mu mv">// A simple Try-Catch Block</span><span id="45d4" class="mr la in mn b gy mw mt l mu mv"><strong class="mn io">try {</strong></span><span id="bd20" class="mr la in mn b gy mw mt l mu mv">/* since this is an async method we are awaiting and then storing the response from the server in result */<br/><strong class="mn io">const result = await feathersClient<br/>.service('users').create(credentials);</strong></span><span id="bf6c" class="mr la in mn b gy mw mt l mu mv">/* The main reason why we used the feathersClient - it allows us to call the API in this simple manner : <br/><em class="ky">clientInstance.service('service name/route').HTTPMethod({params})</em> */</span><span id="bea6" class="mr la in mn b gy mw mt l mu mv">/* using the set method to store the result from server in the result object we created earlier */<br/><strong class="mn io">setResult(result);</strong></span><span id="2956" class="mr la in mn b gy mw mt l mu mv"><strong class="mn io">} catch (error) {<br/></strong>/*<br/>Throwing the error in a catch statement defeats its purpose. I did it for testing purposes only. <br/>*/<strong class="mn io"><br/>throw Error(error);<br/>}</strong></span></pre><p id="1f3f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在Try-Catch中，<em class="ky"> feathersClient </em>请求服务器在<em class="ky"> users </em>服务中创建一个新用户。如果成功，服务器将返回一个响应对象，该对象将存储在<em class="ky">结果</em>对象中。我使用了<a class="ae jz" href="https://reactjs.org/docs/conditional-rendering.html" rel="noopener ugc nofollow" target="_blank"> <em class="ky">条件呈现</em> </a> <em class="ky"> </em>的概念，并且仅当<em class="ky">结果</em>对象不为空或者用户已经注册时，才呈现<em class="ky">链接</em>到<em class="ky"> </em>的<em class="ky">登录表单</em>。看，那很容易！</p><ul class=""><li id="e00f" class="my mz in kc b kd ke kh ki kl na kp nb kt nc kx ob ne nf ng bi translated"><strong class="kc io">签到表</strong>:和<em class="ky">签到表</em>一样，是一个简单的<em class="ky">反应组件</em>，有两个输入和一个提交按钮。但是让我们看一下代码。</li></ul><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi oe"><img src="../Images/8b5eaed39bed57d99ecdb6c7f18b1758.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xce84MdOWbmys99hJ-67Hg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Images created by <a class="ae jz" href="https://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">Carbon</a></figcaption></figure><p id="42a7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，如您所见，<em class="ky">签到表</em>与<em class="ky">签到表</em>非常相似。只有一些变化。让我们检查一下这些变化。</p><p id="a3bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，<em class="ky"> handleSubmit </em>方法中的逻辑被改变。但它仍然采用相同的参数。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="e2ec" class="mr la in mn b gy ms mt l mu mv">// e = event</span><span id="f2c8" class="mr la in mn b gy mw mt l mu mv">// prevent the default behaviour of the form on submit<br/><strong class="mn io">e.preventDefault();</strong></span><span id="9667" class="mr la in mn b gy mw mt l mu mv">// A simple Try-Catch Block</span><span id="a08e" class="mr la in mn b gy mw mt l mu mv"><strong class="mn io">try {</strong></span><span id="e4df" class="mr la in mn b gy mw mt l mu mv">/* Feathers Client provides an authenticate() strategy for authentication. Using that you can just call that method with the appropriate params and Feathers will authenticate the user, and return a JWT with other details. But you can also make a request with the default syntax, like the one we discussed above in the SignUp Form */<br/><strong class="mn io">await feathersClient.authenticate({strategy: 'local', ...credentials});</strong></span><span id="b781" class="mr la in mn b gy mw mt l mu mv">/* Now as I said, calling the authenticate() returns an object with JWT, so why are we calling the service again? Because I want the result object to work as a <a class="ae jz" href="https://daveceddia.com/computed-properties-in-react/" rel="noopener ugc nofollow" target="_blank">computed property</a>, for our conditional render later, so I will let Feathers authenticate first and then request the response later */<br/><strong class="mn io">const result = await feathersClient.get('authentication');</strong></span><span id="408a" class="mr la in mn b gy mw mt l mu mv">// Store the result<br/><strong class="mn io">result ? setResult(result) : setResult(null);</strong></span><span id="d149" class="mr la in mn b gy mw mt l mu mv"><strong class="mn io">} catch (error) {<br/></strong>/*<br/>Throwing the error in a catch statement defeats its purpose. I did it for testing purposes only. <br/>*/<br/><strong class="mn io">throw Error(error);<br/>}</strong></span></pre><p id="6dfb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">其次，表单末尾的条件呈现发生了变化，不再是一个<em class="ky">链接，</em>变成了一个<em class="ky">登出</em>按钮，并带有一个<em class="ky"> handleSignOut w </em>的回调，该回调请求登出。</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="0d97" class="mr la in mn b gy ms mt l mu mv"><strong class="mn io">feathersClient.logout()</strong><br/>/* This method removes the access token from storage on the client. It also calls the <!-- -->remove<!-- --> method of the authentication service */</span></pre><p id="e302" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">就这样，我们结束了。</p><h2 id="961a" class="mr la in bd lb nn no dn lf np nq dp lj kl nr ns ln kp nt nu lr kt nv nw lv nx bi translated">我们已经用<a class="ae jz" href="https://ingeniousambivert.medium.com/get-started-with-feathers-react-part-1-6b2b35a398c3" rel="noopener">的基本设置和配置</a> <a class="ae jz" href="https://ingeniousambivert.medium.com/get-started-with-feathers-react-part-1-6b2b35a398c3" rel="noopener">创建了一个功能完整的web应用程序。</a>真了不起！！！</h2></div><div class="ab cl oi oj hr ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ig ih ii ij ik"><p id="28f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就是<strong class="kc io"> <em class="ky">【羽毛&amp;反应</em> </strong>的<strong class="kc io"> Part 2 </strong>。感谢阅读:)</p><p id="81ef" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> Part 3 </strong>:自定义<strong class="kc io"> React App </strong>与<a class="ae jz" href="https://ant.design/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky"> Ant设计</em> </strong> </a> UI库，实现<a class="ae jz" href="https://medium.com/better-programming/react-state-management-in-2020-719d10c816bf" rel="noopener"> <strong class="kc io"> <em class="ky">状态管理</em></strong></a><strong class="kc io"><em class="ky"/></strong>与<strong class="kc io"><em class="ky"/></strong><a class="ae jz" href="https://redux-toolkit.js.org/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ky">Redux-Toolkit</em></strong></a>，并添加其他<em class="ky">必备安全特性</em><strong class="kc io"> <em class="ky"> </em> </strong>添加<a class="ae jz" href="https://github.com/feathersjs-ecosystem/feathers-authentication-management" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="ky">认证管理</em> </strong> </a>到<strong class="kc io">羽毛服务器。</strong></p><p id="5f54" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">即将推出。敬请关注。</p></div></div>    
</body>
</html>