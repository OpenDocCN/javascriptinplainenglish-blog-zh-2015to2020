# 我能完全理解 JavaScript 强制吗？

> 原文：<https://javascript.plainenglish.io/can-i-ever-fully-understand-javascript-coercion-a39a341a2b3a?source=collection_archive---------5----------------------->

## 你声称可以无缘无故避免强制！

![](img/396affbb456da5ff2fb4e4dec478b03f.png)

Photo by [Markus Spiske](https://unsplash.com/@markusspiske?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/programming?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

> 你永远无法理解一切。但是，你应该努力去理解这个系统。
> 
> ——Ryan Dahl， [**Node.js**](https://medium.com/u/96cd9a1fb56?source=post_page-----a39a341a2b3a--------------------------------) 和 **Deno** 的创作者

# 旧，但金！

> JavaScript 是世界上最容易被误解的编程语言。

**抽象操作是基础**，但这不是 JavaScript 机制的全部能力。如果你想了解这个系统是如何工作的，你应该看看另一组概念。深呼吸，不要被压力吓到。

我们从简单的开始。我举几个例子，你能猜到(或者猜不到)JS 强制。我们要回到 2015 年(ES6)-**JS 重生的一年！ES6** 爆出一些与强制有关的突出特点。

你听说过模板字符串吗？当然，你是。我在任何地方都用它。这是一个非常方便的工具，尤其是当我们把字符串和变量连接起来的时候:

你会承认这是一个乏味的过程。如今，我们试着变酷，做下一件事:

我一直都这样！当我使用 React.js 时，这是一种巨大的解脱。你有没有想过在引擎盖下发生了什么？**发生胁迫。如果你讨厌隐式强制并使用模板字符串，那就停止吧！我只是开玩笑。看，缺乏对**隐式强制**的理解，你不可能成为一个熟练的开发者。**

**不要仅仅依靠含蓄的强制试着去理解它。**你必须考虑正确的心理模型，以及当我们获取字符串 *str1* 并将其添加到数字*时会发生什么。*

发生了什么事？它引发了另一个操作，也称为**操作符过载**。如果你阅读[规格](https://www.ecma-international.org/ecma-262/#sec-addition-operator-plus)，你可以看到如果我们对字符串使用加号运算符， [*ToString* 操作将发生](https://www.ecma-international.org/ecma-262/#sec-addition-operator-plus-runtime-semantics-evaluation)。因此，它将对其调用 *ToString* 操作，并将其转换为字符串。我们可以变得超级酷，战胜胁迫，然后做下一件事:

那是意想不到的行为。它最终会变得纤细。如果我们检查一下[规格](https://www.ecma-international.org/ecma-262/#sec-array.prototype.join)，我们会看到 *join()* 首先把它变成一个字符串。这是一个很酷的功能，但我不建议使用它。如果你想更明确的使用 *toString* 方法:

这里可以通过使用 *toString()* 显式。这个方法将把一个数字转换成一个字符串。记住 *toString()* 方法不属于原始类型。在幕后有一些强大的操作**使我们能够在原始类型**上使用那些方法(后面会有更多)。但是，在这种特殊情况下，有一种方法可以避免强制- **使用基本对象**。让我们看一个例子:

我吓到你了，我知道。我们稍后会解释强制，不要担心。下面这个例子大家都很熟悉:

所以我们在这里模拟一个输入，它总是以字符串表示。哦不，我们有一根绳子。你预料到了吗？两个字符串连接起来，结果是*“34”*。因此，**不是一个数字运算，而是字符串连接**。在这些情况下，我们可以进行显式强制，并将其强制为一个数字。

我将向您展示一个迫使明确强制的绝佳技巧:

在字符串前使用“+”号，并强制*到数字*的抽象操作发生。很简单，不是吗？抽象操作会先把它转换成数字，然后把它作为参数传递。最终，结果将是数字，而不是字符串。如果我们给一个空字符串，它将强制为零。

我们可以超显式地使用一个基本对象——*Number()*。使用 fundamentals 对象是大多数 JS 开发人员的首选方式。你可能已经想象过这种情况了，但我还是要写出来:

这些是我们节目中经常出现的几件事。在下一个例子中，我将展示 JavaScript 中最常见的实践:

我们必须非常小心布尔运算。这里有很多死角案例。如果我们掉进陷阱，就没有回头路了。继续之前，请检查字符串是否非空。最坏的情况出现了:字符串中有大量的空白。

另一种常见的做法是检查数组的长度:

人们被吸引去把一个数字强制转换成一个布尔值。我们知道这个故事。如果值为零，则返回 false，否则返回 true。我们在这里依赖一个非零值，它总是返回 true。

这听起来可能很疯狂，但是如果有一个男的呢？迫不及待地想通过一个例子来测试它:

系统什么也做不了。当然，这只是其中一个小案例。**不要以为我在劝你停止使用它。我只是在说优点和缺点。我鼓励你开始使用这些文档。**相信我，**你的程序会变得不那么容易出错**。

此外，腐蚀可能非常明显，但在使用时必须非常小心。你可以做这个把戏，温和的把戏来明确地说话:

双重谈判会拯救世界！我在这里告诉你首先要变成布尔型，然后是其他所有的东西。

您可以更明确地使用数组来:

**使用数组时，依赖强制有时会致命。**此外，这比检查值是否真实更具语义性。最重要的是**角箱保护**。最终，最有影响力的计划是使用基本对象。让我们看一个例子:

结论:**在与布尔人打交道时，要注意处理好拐角处的病例。请记住，空字符串的布尔值始终为假，非空字符串的布尔值始终为真。最后，尽可能明确地说出来。默默无闻不是一个选择！**

当我们考虑原始类型时，我们可以很容易地避免一些小问题。但是，对象和类似对象的类型呢？让我们通过例子来看看:

**我们有一个预期的情况。** *未定义*和*空*正如预期的一样是错误的，但是一个物体呢？物体会把事情弄得一团糟，所以我们必须非常小心。有一种方法可以避免不便。我将展示一种检查对象的常见方法:

结论:**使用布尔型隐性胁迫是一种较好的做法。有些角落的情况你必须牢记在心。有时常识不是最好的思维模式，尝试像 JavaScript 这样的东西，你就会成为熟练的 JS 开发人员。**

# 额外收获:拳击如何节省我们的日常时间？

你可能已经忘记了，我承诺解释原始值是如何访问方法的。好吧，现在是时候了。

让我们热身，从一个例子开始:

它是如何工作的？我们怎么能进入*。长度*属性上的一个原始值？正如你所猜测的，复杂的逻辑发生在场景背后。我们对这个过程有一个奇特的名字- **拳击**。

**一种隐性的强制。**可以说，它与抽象运算相似，但它们的唤起方式不同。JavaScript 决定提供帮助，让我们能够使用像对象类型这样的基本类型。JavaScript 将为我们制造一个物体，多么友好的手势。

这是一个很好的特性，最终， **JS 是一种动态语言**，不像 Java 或 C#那样，你必须先将一个原语转换成一个对象类型，然后再进行其他操作。

历史上的一件趣事。这就是 JS 中的一切都是对象这一概念的来源。一个大多数高级开发者失败的地方。**事物可以表现得像一个物体，但这并不使它们成为物体。**

我希望你找到了正确的心智模式。我试图拉近这个故事(以及之前的故事)并解释一些概念。从更大的意义上来说，**你不能‘逃离’胁迫**，你也不需要这么做。所有编程语言都有强制，这是很自然的事情。

结论:【JavaScript 有两种方式。当试图访问基元值的属性时，要么实现装箱(boxing ),要么抛出错误。

## **用简单英语写的便条**

你知道我们有四份出版物和一个 YouTube 频道吗？你可以在我们的主页[**plain English . io**](https://plainenglish.io/)找到所有这些内容——关注我们的出版物并 [**订阅我们的 YouTube 频道**](https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw) **来表达你的爱吧！**