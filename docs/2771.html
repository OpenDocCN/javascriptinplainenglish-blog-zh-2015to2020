<html>
<head>
<title>Node.js Tips — Related Documents, Unzipping Files and Parsing HTML</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—相关文档、解压缩文件和解析HTML</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-related-documents-unzipping-files-and-parsing-html-2194858c4eab?source=collection_archive---------7-----------------------#2020-07-22">https://javascript.plainenglish.io/node-js-tips-related-documents-unzipping-files-and-parsing-html-2194858c4eab?source=collection_archive---------7-----------------------#2020-07-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c847f734b6c54e153dd22e792bb6a459.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uKiDB4LLqj3hSRGe"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@zamax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gustavo Zambelli</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="65e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="da6a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Socket.io中创建房间</h1><p id="9b96" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">要在socket.io中创建房间，我们只需按名称加入房间。</p><p id="7512" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">不一定要创造出来。</p><p id="82be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0a21" class="mn lc iq mj b gy mo mp l mq mr">socket.on('create', (room) =&gt; {<br/>  socket.join(room);<br/>});</span></pre><p id="2bff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用房间名来听<code class="fe ms mt mu mj b">create</code>事件。</p><p id="2ffc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到我们想要加入的房间的参数<code class="fe ms mt mu mj b">room</code>。</p><p id="802a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以发出事件，这样<code class="fe ms mt mu mj b">join</code>就运行了:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="6a76" class="mn lc iq mj b gy mo mp l mq mr">socket.emit('create', 'room');</span></pre><p id="4959" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">'create'</code>是事件名称。</p><p id="d023" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">'room'</code>是房间名。</p><h1 id="c806" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在Mongoose中使用多模式填充</h1><p id="4714" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以链接<code class="fe ms mt mu mj b">populate</code>调用来选择多个相关的文档。</p><p id="d148" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="3bc8" class="mn lc iq mj b gy mo mp l mq mr">Person.find()<br/>  .populate('address')<br/>  .populate('phone')<br/>  .exec((err, results) =&gt; {<br/>    //...<br/>  });</span></pre><p id="95cd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获得带有<code class="fe ms mt mu mj b">address</code>和<code class="fe ms mt mu mj b">phone</code>型号的<code class="fe ms mt mu mj b">Person</code>。</p><p id="f6bf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在<code class="fe ms mt mu mj b">results</code>中得到所有相关的文档。</p><p id="d75c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以使用空格分隔的字符串调用<code class="fe ms mt mu mj b">populate</code>来指定多个模式，而无需多次调用<code class="fe ms mt mu mj b">populate</code>。</p><p id="500a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="cd96" class="mn lc iq mj b gy mo mp l mq mr">Person.find()<br/>  .populate('address phone')<br/>  .exec((err, results) =&gt; {<br/>    //...<br/>  });</span></pre><p id="2e48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是从mongose 3.6版本开始提供的。</p><h1 id="790b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在节点应用程序的内存中下载并解压缩一个zip文件</h1><p id="41f6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe ms mt mu mj b">adm-zip</code>包下载并在内存中解压一个zip文件。</p><p id="3f21" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要安装它，我们运行:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="db7c" class="mn lc iq mj b gy mo mp l mq mr">npm install adm-zip</span></pre><p id="116e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以下载并解压缩一个文件，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="75b9" class="mn lc iq mj b gy mo mp l mq mr">const fileUrl = 'https://github.com/notepad-plus-plus/notepad-plus-plus/releases/download/v7.8.6/npp.7.8.6.bin.zip'</span><span id="897a" class="mn lc iq mj b gy mv mp l mq mr">const AdmZip = require('adm-zip');<br/>const http = require('http');</span><span id="1e2b" class="mn lc iq mj b gy mv mp l mq mr">http.get(fileUrl, (res) =&gt; {<br/>  let data = [];<br/>  let dataLen = 0;</span><span id="4db7" class="mn lc iq mj b gy mv mp l mq mr">res.on('data', (chunk) =&gt; {<br/>  data.push(chunk);<br/>  dataLen += chunk.length;</span><span id="c14d" class="mn lc iq mj b gy mv mp l mq mr">})<br/>.on('end', () =&gt; {<br/>  const buf = Buffer.alloc(dataLen);</span><span id="337d" class="mn lc iq mj b gy mv mp l mq mr">  for (let i = 0, pos = 0; i &lt; data.length,; i++) { <br/>    data[i].copy(buf, pos); <br/>    pos += data[i].length; <br/>  }</span><span id="89d9" class="mn lc iq mj b gy mv mp l mq mr">  const zip = new AdmZip(buf);<br/>  const zipEntries = zip.getEntries();</span><span id="4191" class="mn lc iq mj b gy mv mp l mq mr">  for (const zipEntry of zipEntries) {<br/>    if (zipEntry.entryName.match(/readme/))<br/>      console.log(zip.readAsText(zipEntry));<br/>    }<br/>  };<br/>});</span></pre><p id="38ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe ms mt mu mj b">http</code>模块的<code class="fe ms mt mu mj b">get</code>方法发出GET请求来获取zip文件。</p><p id="72fc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们将响应数据块放入<code class="fe ms mt mu mj b">data</code>数组。</p><p id="0a78" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们这样做了，我们用<code class="fe ms mt mu mj b">Buffer.alloc</code>创建一个新的缓冲区。</p><p id="0c59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们根据位置将<code class="fe ms mt mu mj b">data</code>中的组块放入缓冲区。</p><p id="4ba4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们将所有内容复制到缓冲区中，我们就用缓冲区创建了一个新的<code class="fe ms mt mu mj b">AdmZip</code>实例。</p><p id="abe4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以从中获取条目。</p><p id="8d9b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们遍历了for-of循环中的条目。</p><h1 id="faad" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">对Node.js使用DOM解析器</h1><p id="1a29" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">有几个针对节点应用的DOM解析器库。</p><p id="c973" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一个是<code class="fe ms mt mu mj b">jsdom</code>库。</p><p id="608c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过书写来使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="d49a" class="mn lc iq mj b gy mo mp l mq mr">const jsdom = require("jsdom");<br/>const dom = new jsdom.JSDOM(`&lt;p&gt;Hello world&lt;/p&gt;`);<br/>dom.window.document.querySelector("p").textContent;</span></pre><p id="70ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将一个HTML字符串传入<code class="fe ms mt mu mj b">JSDOM</code>构造函数。</p><p id="24e5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe ms mt mu mj b">dom.window.document.querySelector</code>方法从解析后的DOM树中获取一个元素。</p><p id="aa08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有图书馆。</p><p id="c465" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它比<code class="fe ms mt mu mj b">jsdom</code>更快更灵活，但是API更复杂。</p><p id="81ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要使用它，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8b8e" class="mn lc iq mj b gy mo mp l mq mr">const htmlparser = require("htmlparser2");<br/>const parser = new htmlparser.Parser({<br/>  onopentag(name, attrib){<br/>    console.log(name, attrib);<br/>  }<br/>}, { decodeEntities: true });<br/>parser.write(`&lt;p&gt;Hello world&lt;/p&gt;`);<br/>parser.end();</span></pre><p id="a33c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe ms mt mu mj b">htmlparser.Parser</code>构造函数，它通过解析HTML字符串时运行的<code class="fe ms mt mu mj b">onopentag</code>处理程序获取一个对象。</p><p id="57ef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">name</code>有标签名，<code class="fe ms mt mu mj b">attrib</code>有属性。</p><p id="2f32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">decodeEntities</code>意味着我们解码文档内的实体。</p><p id="f1d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">cheerio</code>是另一个DOM解析器库。它有一个类似jQuery的API，所以应该很多人都很熟悉。</p><p id="e5ea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过书写来使用它:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="a6a4" class="mn lc iq mj b gy mo mp l mq mr">const cheerio = require('cheerio');<br/>const $ = cheerio.load(`&lt;p&gt;Hello world&lt;/p&gt;`);<br/>$('p').text('bye');<br/>$.html();</span></pre><p id="5977" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将HTML字符串加载到一个DOM树中。</p><p id="ce92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用返回的<code class="fe ms mt mu mj b">$</code>函数来选择元素并操作它。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/df181edfb308719ab4da850d003584c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vA7w1SiSAM7Z_E07"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@neonbrand?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">NeONBRAND</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="5e51" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="47fe" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不必明确地创建一个房间来加入它。</p><p id="b132" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用库压缩文件。</p><p id="68d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有许多库可以让我们将HTML字符串解析成DOM树。</p><p id="ae57" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用Mongoose的<code class="fe ms mt mu mj b">populate</code>来获取相关文档。</p><h1 id="1770" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">简单英语的JavaScript</h1><p id="33cf" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果是这样，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>