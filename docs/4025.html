<html>
<head>
<title>Lazy-load images with the Intersection Observer API and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用交叉点观察器API和React延迟加载图像</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/lazy-load-images-with-the-intersection-observer-api-and-react-4fd8ae19e195?source=collection_archive---------7-----------------------#2020-11-11">https://javascript.plainenglish.io/lazy-load-images-with-the-intersection-observer-api-and-react-4fd8ae19e195?source=collection_archive---------7-----------------------#2020-11-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="4f0b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">交叉点观察器API允许您观察元素进入视口或父元素时的变化并做出反应。它非常常用于延迟加载，但也可以用于动画或当您滚动到页面的不同部分时改变导航栏中链接的活动状态。延迟加载图像使用户不必在初始页面加载时下载资源，而是推迟到更合适的时候。</p><p id="58f2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我一直在玩不同的懒人加载图像的效果，我喜欢这一个，不是用真实的图像交换占位符图像，而是用CSS不透明过渡显示图像。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div class="gh gi ki"><img src="../Images/45523904244b75df3b768dc9d0e332fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:616/1*7pBrGBsizwtLsJSbKB-XAA.gif"/></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">What we’ll be building!</figcaption></figure><h2 id="2fc1" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">安装并导入包和样式</h2><p id="252a" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">为了做到这一点，让我们从一些导入开始，我们将使用React钩子、CSS模块和classnames包来完成这项工作。您可以使用<code class="fe ls lt lu lv b">create-react-app</code>在CodeSandbox中看到下面完整的代码。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h2 id="385b" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">创建组件</strong></h2><p id="b358" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">我们将创建一个函数组件，它返回一个div元素，我们将使用它作为占位符。我们还将使用<code class="fe ls lt lu lv b">useRef</code>钩子来获取对DOM中占位符的引用。稍后，我们可以使用这个引用来查看占位符是否进入了视口。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="1c8f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ls lt lu lv b">useRef</code>钩子为您提供了一种在返回的对象上使用<code class="fe ls lt lu lv b">.current</code>属性存储可变值的方法。我不会深入解释为什么这很有用，但是在我们的例子中，当我们对占位符元素执行<code class="fe ls lt lu lv b">ref={placeholder}</code> <em class="ly"> </em>操作时，React会将<code class="fe ls lt lu lv b">.current</code>属性设置为相应的DOM节点，并在该值发生变化时保持其最新。</p><h2 id="736c" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated">添加样式</h2><p id="451f" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">这种样式非常简单，包装图像和占位符的元素将其<code class="fe ls lt lu lv b">display</code>设置为<code class="fe ls lt lu lv b">relative</code>来约束绝对定位的占位符。本质上，占位符是一个黄色的框，底部填充设置为匹配我们使用的图像的纵横比。添加transition属性意味着当我们以编程方式添加<code class="fe ls lt lu lv b">hidePlaceholder</code>类时，我们可以使用CSS淡出占位符。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="9946" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在这一点上，除了页面上的一个黄色矩形，我们什么也没有…令人兴奋！</p><p id="9e58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">下一步是让那个框淡出，我们已经创建了CSS类，所以我们只需要将它添加到占位符<code class="fe ls lt lu lv b">div</code>中。首先，我们将使用<code class="fe ls lt lu lv b">useState</code>钩子创建一个新的状态，让我们知道是否应该显示我们的图像。默认情况下这是<code class="fe ls lt lu lv b">false</code>，我们不想在第一次渲染时显示我们的图像。然后，我们将使用我们的<code class="fe ls lt lu lv b">showImage</code>状态来决定何时添加我们的<code class="fe ls lt lu lv b">hidePlaceholder</code>类。为了做到这一点，我喜欢使用<code class="fe ls lt lu lv b"><a class="ae lz" href="https://www.npmjs.com/package/classnames" rel="noopener ugc nofollow" target="_blank">classnames</a></code>包，因为它比我自己编写的要干净一点，而且对于用类名进行条件逻辑也很方便。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6665" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">既然已经排序了，我们可以更新占位符元素来使用新的classes变量。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h2 id="a1bd" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">添加我们的图像</strong></h2><p id="5e8a" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">现在，当<code class="fe ls lt lu lv b">showImage</code>状态的值改变时，我们的盒子将消失。但是，我们仍然需要实际显示图像，所以让我们接下来这样做。我选择了一个图像，并在我的组件之外为它创建了一个名为<code class="fe ls lt lu lv b">IMAGE_URL</code>的变量。我们已经有了我们的<code class="fe ls lt lu lv b">showImage</code>状态，所以我们也可以用它来有条件地渲染我们的图像。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><h2 id="4d78" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">设置路口观察者</strong></h2><p id="021a" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">我们剩下要做的就是在占位符出现时改变我们状态的值。我们需要设置<a class="ae lz" href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API" rel="noopener ugc nofollow" target="_blank">路口观察器</a>。</p><p id="290c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">交叉点观察器有两个参数，第一个是回调。这是当你的元素进入视图时，在我们的例子中，当我们的占位符进入视图时，它将被调用。请注意，这个回调也将在观察者第一次试图观察你的元素时被执行。</p><p id="5688" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">回调将得到一个<a class="ae lz" href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry" rel="noopener ugc nofollow" target="_blank">intersectionobserventry</a>对象的列表作为它的第一个参数。列表中的每个项目代表被观察的每个项目，其相交状态已经改变。在我们的例子中，列表的长度总是为1，因为我们只关注一个元素(我们的占位符)。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="6f4a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以检查条目上的<em class="ly">is intersection</em>属性的值，看看我们的占位符是否在视口内，如果是，那么我们应该将我们的<code class="fe ls lt lu lv b">showImage</code>状态更新为true。</p><p id="d135" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">传递给交叉点观察器的第二个参数是options对象。我们可以设置几个不同的选项来配置观察器，但我们只关注<code class="fe ls lt lu lv b">threshold</code>。阈值决定了何时应该运行回调。它可以是一个数字，也可以是一组数字。默认情况下，这是0，所以如果我们正在观察的元素的1个像素进入了视窗，那么我们的回调就会被触发，我已经将它改为1.0，这意味着我们的<code class="fe ls lt lu lv b">showImage</code>状态不会改变，直到整个占位符都在视窗中。这也意味着我们可以看着它平滑地淡入。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="8ab6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在我们可以创建交叉点观察器的新实例，传入我们的<code class="fe ls lt lu lv b">callback</code>和<code class="fe ls lt lu lv b">options</code>，并使用它来观察我们的占位符。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="2058" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">你会注意到我已经把它全部放在了一个<code class="fe ls lt lu lv b">useEffect</code>里面。当我们的组件在屏幕上时，我们使用<code class="fe ls lt lu lv b">useEffect</code>钩子在渲染后运行代码(一种效果)。在我们观察占位符之前，我们需要等待这种情况发生。默认情况下，每次渲染后<code class="fe ls lt lu lv b">useEffect</code>都会在<em class="ly">之后运行，但是我们可以将其更改为在特定值发生变化时运行。</em></p><p id="5703" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们可以通过将一个数组作为第二个值传递给<code class="fe ls lt lu lv b">useEffect</code>钩子来做到这一点，这个数组应该包含你的效果使用的任何依赖关系，以确保它总是有最新的值。在我们的例子中，效果没有任何依赖关系，我们只想设置一次交叉点观察器，所以我将数组留空。这意味着效果只会在第一次渲染时运行一次。</p><figure class="kj kk kl km gt kn gh gi paragraph-image"><div role="button" tabindex="0" class="mb mc di md bf me"><div class="gh gi ma"><img src="../Images/63b9630d9b91996d8a5a934914ce07ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rPWYFaGV18sS6QBDKuMS4g.png"/></div></div><figcaption class="kq kr gj gh gi ks kt bd b be z dk">Image: UK Black Tech</figcaption></figure><h2 id="5633" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><code class="fe ls lt lu lv b">UseEffect</code>清理</h2><p id="4e5a" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">我们还应该确保在<code class="fe ls lt lu lv b">useEffect</code>中运行清理函数，我们可以通过在<code class="fe ls lt lu lv b">useEffect</code>中返回一个函数来做到这一点，这个函数将在组件被销毁时被调用。</p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7808" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里我们在观察者上使用了<code class="fe ls lt lu lv b">disconnect</code>方法来阻止它观察所有目标元素的可见性变化。这意味着它将停止观察我们的占位符。</p><h2 id="fabf" class="ku kv in bd kw kx ky dn kz la lb dp lc jv ld le lf jz lg lh li kd lj lk ll lm bi translated"><strong class="ak">我们完成了！</strong></h2><p id="e810" class="pw-post-body-paragraph jk jl in jm b jn ln jp jq jr lo jt ju jv lp jx jy jz lq kb kc kd lr kf kg kh ig bi translated">一旦你在你的图片上添加了足够的内容，当你向下滚动时，你会看到你的图片在占位符完全出现后平滑地淡入。请查看下面的CodeSandbox进行测试。🙂</p><p id="e5c0" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">谢谢你能走到这一步！在insta gram<a class="ae lz" href="https://www.instagram.com/taraojo/" rel="noopener ugc nofollow" target="_blank">上关注我，了解其他JavaScript技巧和教程👩🏾‍💻</a></p><figure class="kj kk kl km gt kn"><div class="bz fp l di"><div class="mf lx l"/></div></figure></div></div>    
</body>
</html>