<html>
<head>
<title>JavaScript Algorithms: The N-th Fibonacci Entry</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript算法:第N个斐波那契入口</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-algorithms-the-n-th-fibonacci-entry-417afa581182?source=collection_archive---------9-----------------------#2020-12-01">https://javascript.plainenglish.io/javascript-algorithms-the-n-th-fibonacci-entry-417afa581182?source=collection_archive---------9-----------------------#2020-12-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="0dff" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">什么是斐波那契数列，我们如何找到第N个条目的数字？我将在这篇博客中讨论三种不同的解决方案。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi kj"><img src="../Images/493703cd93027533107fa2c096fd65ad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*GLQazSAgt3EUqVyX"/></div></div><figcaption class="kv kw gj gh gi kx ky bd b be z dk">Photo by <a class="ae kz" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aaron Burden</a></figcaption></figure><p id="6265" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">对于那些不熟悉它的人来说，斐波纳契数列是一系列数字，其中前两个数字加起来是后一个数字。例如，前9个条目是:0，1，1，2，3，5，8，13，21。这种模式在世界各地不同的地方频繁出现，例如在花、动物和鹦鹉螺壳上。这也是一个常见的测试你递归知识的技术面试问题。在这篇文章中，我将介绍解决这个问题的两种方法，同时也讨论这两种方法的运行时和时空复杂度。</p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="d060" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">打印出斐波那契数列中的第n<em class="ki">个</em>条目。例如，fib(6)将导致8。如果您参考上面的示例列表，该数组中的第6个索引将是8，因为数组索引从0开始。</strong></p><p id="e59e" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从简单的迭代解决方案开始。这个解决方案的诀窍在于，前两个数字不能自己生成，因为它们没有一个开始的模式。我们可以通过声明一个包含0，1的数组来手动输入0和1。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi lh"><img src="../Images/9657e4ef843efae2d8cae7507264694a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BjIuUJBOxLj1jF_8Yt76uQ.png"/></div></div></figure><p id="86ec" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在声明了一个名为<em class="ki"> result </em>的数组(其中包含0和1)之后，我将继续手动执行<em class="ki">循环。记住从2开始启动<em class="ki"> i </em>，因为索引0和1已经声明了。我们希望<em class="ki"> i </em>增加到或等于<em class="ki"> n，</em>，因为我们需要知道第<em class="ki"> n个</em>条目是什么。在<em class="ki"> for </em>循环中，我们希望开始向结果数组中添加新的条目。为此，我们可以通过将前两个条目相加来获得下一个条目。我们可以将这些条目中的每一个设置为变量<em class="ki"> a </em>和<em class="ki">b</em>，然后，我们将<em class="ki"> a </em>和<em class="ki"> b </em>的和推送到结果数组中，该数组最终会添加下一个条目。</em></p><p id="25c2" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们为fib(5)看一遍这个例子。当我们开始时，结果将包含0和1。在通过循环的<em class="ki">的第一次迭代期间，<em class="ki"> a </em>将为1，<em class="ki"> b </em>将为0。然后，我们推送0和1的结果，为下一个结果条目提供1，并将<em class="ki"> i </em>增加到3。我们用新的数组[0，1，1]重复这个过程。在迭代这个循环的时候，<em class="ki"> a </em>现在会是1，<em class="ki"> b </em>也会是1。总的来说，我们为下一个条目得到2，并得到一个数组[0，1，1，2]。然后，将<em class="ki"> i </em>增加到4。我们再次迭代循环，这次<em class="ki"> a </em>将等于2，而<em class="ki"> b </em>将等于1。将这两者相加，并将其推到结果上将得到[0，1，1，2，3]的数组。最后将<em class="ki"> i </em>增加到5。由于我们的条件语句等于5，我们最后一次运行循环，其中<em class="ki"> a </em>等于3，而<em class="ki"> b </em>等于2。将它们相加，并将其推入我们的结果，将得到数组[0，1，1，2，3，5]。现在我们已经达到了计数器5，我们中断循环并返回索引为<em class="ki"> n的<em class="ki">结果</em>，结果【5】</em>将返回5，因此fib(5)将返回5。</em></p><p id="db2b" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个解决方案的运行时间复杂度是O(n)，或者说是线性的。随着n增加1，我们只需要再做一次循环。空间复杂度也将是O(n ),因为无论数组列表有多长，所需的空间量总是会随着数组的大小而增加。</p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="1a57" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">现在让我们来看一下递归解:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi lh"><img src="../Images/5b34c97700814276ac404b60d1d73830.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F8pv9Y296ApiRAuPtjM3ug.png"/></div></div></figure><p id="4774" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这个解决方案看起来很简单，但是如果你不熟悉递归，实际上非常复杂。本质上，我们对前两个值做了一些类似的事情，其中我们说如果<em class="ki"> n </em>等于1或0，我们只返回与它们相关的值。现在到了棘手的部分，我们开始递归。最简单的可视化方法是用一个返回值和函数调用的树形图。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi li"><img src="../Images/32d22798f64e588754a4c3b0cc027eec.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vnfUh5L0_bnjU2lu5qxwRw.png"/></div></div></figure><p id="d4e9" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们从树的最开始，或者第一个函数调用开始。当我们运行fib(5)时，我们必须通过调用fib(4)和fib(3)将它们的返回值相加。要得到fib(4)，我们必须得到fib(3)和fib(2)的返回值。要得到fib(3)，我们必须得到fib(2)和fib(1)的返回值。当我们到达fib(2)时，由于fib(1)和fib(0)不进行任何额外的函数调用，我们可以开始返回一些值。我们知道fib(0)返回0，fib(1)返回1。因此，fib(2)将返回1。本质上，我们一直进行函数调用，直到我们遇到(n)等于1或0的两个条件。只有这样，我们才能开始添加返回值，并沿着堆栈向上到达fib(5)。</p><p id="c216" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">正如您可能知道的，这个递归解决方案的运行时会很糟糕。事实上，这是我们使用O(2^n运行时的情况之一，也称为指数运行时。<em class="ki"> n </em>每增加一次，函数调用的次数就会呈指数级增加。空间复杂度为O(n)。</p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="0b21" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">那么，有什么方法可以改善递归解决方案的运行时间呢？为了实现这一点，我们可以使用一种叫做记忆的策略。记忆包括将函数调用的返回值存储为参数。如果再次调用该函数，我们将进行检查，以确保由于返回值已经存在，我们返回预计算结果，而不是再次调用该函数。这可以有效地降低运行时的复杂性。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="kp kq di kr bf ks"><div class="gh gi lh"><img src="../Images/1a85650923593b3d59aec7af52b52f95.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JWHwvLpDOvqGz-_3aLLzaA.png"/></div></div></figure><p id="85d1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">让我们继续使用fib(5)示例。使用这个解决方案，我们会从上面往下看返回值树，但是每当我们遇到新的返回值时，它就会被存储到memoize中。例如，当第一次到达fib(2)时，由于memoize中还不存在2，memoize[2]将创建新条目。完成该函数调用后，memoize将包含{0: 0，1: 1，2: 1}。下一次我们调用fib(2)时，由于2在memoize中，我们不再需要进行额外的函数调用，只需要返回1的预计算结果。通过记忆，我们可以将运行时间减少到只有O(n)。</p></div><div class="ab cl la lb hr lc" role="separator"><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf lg"/><span class="ld bw bk le lf"/></div><div class="ig ih ii ij ik"><p id="53cf" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">斐波那契序列是自然界中最迷人的模式之一。在代码中使用它也是一种非常有趣的模式。这个问题让我对递归的理解有了更深的理解，这在我第一次尝试学习递归时无疑是一场斗争。我希望这个博客的解释是有帮助的。请随时通过<a class="ae kz" href="https://www.linkedin.com/in/jiangmichael1/" rel="noopener ugc nofollow" target="_blank">领英</a>或<a class="ae kz" href="https://twitter.com/dev_jiams" rel="noopener ugc nofollow" target="_blank">推特</a>与我联系，寻求问题、评论或更正。谢谢你的阅读！</p></div></div>    
</body>
</html>