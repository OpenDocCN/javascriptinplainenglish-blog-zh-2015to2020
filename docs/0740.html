<html>
<head>
<title>Is it time to move on from Virtual DOM (React)?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">是时候离开虚拟DOM (React)了吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/is-it-time-to-move-on-from-virtual-dom-reactjs-2c01afbf81fb?source=collection_archive---------0-----------------------#2019-12-04">https://javascript.plainenglish.io/is-it-time-to-move-on-from-virtual-dom-reactjs-2c01afbf81fb?source=collection_archive---------0-----------------------#2019-12-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/642d048389dd1b89d3ecdc9078b14bb5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U3QnWwnlFX5c1tV-W4MU_w.jpeg"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Designed by vectorpocket / Freepik updated by <a class="ja jb ep" href="https://medium.com/u/14bb3e347adc?source=post_page-----2c01afbf81fb--------------------------------" rel="noopener" target="_blank">Shashank Sharma</a></figcaption></figure><div class=""/><div class=""><h2 id="d159" class="pw-subtitle-paragraph kb jd je bd b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks dk translated">理解框架的地狱模式并预测下一次范式转变。</h2></div><p id="b3b9" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">十多年来，我一直在开发web应用程序，见证了许多JavaScript库和框架的兴衰。在框架的地狱中，变化是不可避免的。作为一名开发人员，我想知道是否存在一种模式，更重要的是，我们能预测下一次转变吗？</p><blockquote class="lp"><p id="2edf" class="lq lr je bd ls lt lu lv lw lx ly lo dk translated">今天最受欢迎的继任者填补了前任留下的空白</p></blockquote><p id="0254" class="pw-post-body-paragraph kt ku je kv b kw lz kf ky kz ma ki lb lc mb le lf lg mc li lj lk md lm ln lo ig bi translated">为了理解框架的这种变化模式，让我们稍微回到<strong class="kv jf"> JQuery </strong>的时代。</p><figure class="mf mg mh mi gt ip gh gi paragraph-image"><div class="gh gi me"><img src="../Images/2853ce302615eb62bcb90b42d0e581f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*O-zFyLjHmJwD6F7zdbKWZg.png"/></div></figure><p id="ef74" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当时，维护对任何web应用程序的跨浏览器支持对开发人员来说都是一场噩梦。JQuery(和相关的库)是web开发的实际方法。然而，它有其局限性。为了支持不同的浏览器，代码变得臃肿，而且大部分的生命周期管理必须分开进行，这增加了更多的代码占用空间。此外，最大的问题是不同的<strong class="kv jf"> jQuery </strong>插件如何能够共存并互相通信而不互相干扰。</p><blockquote class="mj mk ml"><p id="5ac0" class="kt ku mm kv b kw kx kf ky kz la ki lb mn ld le lf mo lh li lj mp ll lm ln lo ig bi translated">任何新的框架在解决一些问题的同时也会产生新的需求</p></blockquote><figure class="mf mg mh mi gt ip gh gi paragraph-image"><div class="gh gi me"><img src="../Images/d37bbaa8420a36136e028c65236f8394.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*VxUDCiETsNslcYonX0aUDQ.png"/></div></figure><p id="fea6" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">最终，库开始演变成框架，并为整个web应用程序提供了框架。这是模块驱动开发(<strong class="kv jf">amd</strong>/<strong class="kv jf">requires</strong>/<strong class="kv jf">Dojo</strong>等)兴起的时候。).</p><p id="19ad" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">企业很快采用了这些模式。许多这些库很快被企业采用。很快，模块化JavaScript生态系统中出现了几个不兼容的标准。甚至HTML社区也注意到了这一点，并分享了Web组件的初稿</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><figure class="mf mg mh mi gt ip gh gi paragraph-image"><div class="gh gi me"><img src="../Images/dc8a2f7accc6000c5f4783e70b1df641.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*5rxkQ0lolA1s5mRheFE71A.png"/></div></figure><p id="917e" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Web组件规范支持扩展现有HTML元素的能力。这就催生了HTML扩展模型(自定义HTML元素<strong class="kv jf"><em class="mm">&lt;【my-elements/&gt;</em></strong>)的兴起。</p><p id="f048" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，它还远未被浏览器所采用，但这激发了一个基于组件的JS框架的新时代，包括AngularJS(由Google开发)和React(由脸书开发)。他们提出了组件生命周期管理模型，剩下的就是历史了</p><figure class="mf mg mh mi gt ip gh gi paragraph-image"><div class="gh gi me"><img src="../Images/3985736d849b08b73da1b0e2ea3c2986.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*kVIBs8uu5vDS2OvPWD-GPw.png"/></div></figure><p id="0d03" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv jf"> Angular 1.x </strong>以创新的变更检测机制(Watchers)神奇地操纵HTML DOM，像风暴一样接管了web，成为web开发的新标准。</p><p id="e3fc" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，随着应用程序大小的增加，出现了许多问题，包括检测变化时的帧速率下降。当组件或观察器的数量增加时，性能和效率都不是很好。</p><figure class="mf mg mh mi gt ip gh gi paragraph-image"><div class="gh gi me"><img src="../Images/813d9621546d62cdce02363a43c86afd.png" data-original-src="https://miro.medium.com/v2/resize:fit:450/format:webp/1*vzmF2kwrtrvXJs_8knJJZA.png"/></div></figure><p id="79fe" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv jf"> ReactJS </strong>提出了改进的变化检测和更新机制，称为<strong class="kv jf"> Virtual-DOM </strong>，它优于angular的范围和监视技术</p><p id="3737" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Angular2.x 很快出现，试图修复Angular 1造成的混乱，但为时已晚，因为React已经超过了当时抛出的事实</p><p id="9429" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，市场上很少有像<strong class="kv jf"> VueJS </strong>这样的玩家在Angular或React缺乏的几个方面做得更好。</p><p id="8a19" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">此外，记住所有这些框架也在发展。他们发布了新版本，试图在每个后续版本中进行改进。然而，大多数时候他们通过保持核心架构相似来坚持向后兼容性。</p><h1 id="5632" class="mx my je bd mz na nb nc nd ne nf ng nh kk ni kl nj kn nk ko nl kq nm kr nn no bi translated">你能看出这里的模式吗？</h1><p id="76f3" class="pw-post-body-paragraph kt ku je kv b kw np kf ky kz nq ki lb lc nr le lf lg ns li lj lk nt lm ln lo ig bi translated">开发人员寻找更新的选项</p><ol class=""><li id="a6e3" class="nu nv je kv b kw kx kz la lc nw lg nx lk ny lo nz oa ob oc bi translated">现有框架中存在明显的缺陷，这些缺陷不能很快修复，或者必须进行重大更改(没有向后兼容性)</li><li id="c46e" class="nu nv je kv b kw od kz oe lc of lg og lk oh lo nz oa ob oc bi translated">存在解决上述问题的可选方案</li></ol><h1 id="25c4" class="mx my je bd mz na nb nc nd ne nf ng nh kk ni kl nj kn nk ko nl kq nm kr nn no bi translated">是时候离开虚拟DOM(ReactJS)了吗？</h1><p id="5f78" class="pw-post-body-paragraph kt ku je kv b kw np kf ky kz nq ki lb lc nr le lf lg ns li lj lk nt lm ln lo ig bi translated">要回答这个问题，我们需要两样东西</p><ol class=""><li id="05bb" class="nu nv je kv b kw kx kz la lc nw lg nx lk ny lo nz oa ob oc bi translated">不进行重大变更就无法修复的缺陷列表</li><li id="0d29" class="nu nv je kv b kw od kz oe lc of lg og lk oh lo nz oa ob oc bi translated">今天我们有其他选择吗？</li></ol><h1 id="4e7a" class="mx my je bd mz na nb nc nd ne nf ng nh kk ni kl nj kn nk ko nl kq nm kr nn no bi translated">缺陷👎🏻</h1><blockquote class="mj mk ml"><p id="1ae2" class="kt ku mm kv b kw kx kf ky kz la ki lb mn ld le lf mo lh li lj mp ll lm ln lo ig bi translated"><strong class="kv jf">Desclaimer</strong>——react js是一个很棒的合作生态系统。我使用react已经有一段时间了，它帮助我高效快速地运送网络应用程序。然而，这并不意味着它是完美的</p></blockquote><ol class=""><li id="e656" class="nu nv je kv b kw kx kz la lc nw lg nx lk ny lo nz oa ob oc bi translated">到目前为止讨论的所有这些框架都严重依赖于浏览器处理其算法的能力。示例变化检测/观察器/虚拟DOM操作等。不管差分算法的效率有多高，它总是会耗尽客户端的硬件资源。尽管很少有人尝试使用Web Workers、Web Assembly等各种概念来加速浏览器的处理能力，但潜在的挑战仍然是一样的。</li><li id="26f5" class="nu nv je kv b kw od kz oe lc of lg og lk oh lo nz oa ob oc bi translated">无论应用程序本身有多小或多大，应用程序都必须附带库和依赖项。现代网页的平均大小已经超过2MB，其中大部分时间包含大量的样板文件。</li></ol><h1 id="45bc" class="mx my je bd mz na nb nc nd ne nf ng nh kk ni kl nj kn nk ko nl kq nm kr nn no bi translated">当今的替代方案</h1><p id="3dac" class="pw-post-body-paragraph kt ku je kv b kw np kf ky kz nq ki lb lc nr le lf lg ns li lj lk nt lm ln lo ig bi translated">我们能继续享受这些框架的好处，避免捆绑包膨胀吗？优秀的开发者和用户体验？嗯<strong class="kv jf">是的！</strong></p><blockquote class="mj mk ml"><p id="7f56" class="kt ku mm kv b kw kx kf ky kz la ki lb mn ld le lf mo lh li lj mp ll lm ln lo ig bi translated">框架消失的时代</p></blockquote><p id="248f" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated"><strong class="kv jf">细长/模板/角形元素/聚合物/网状组件</strong>是这种新兴趋势的例子。</p><figure class="mf mg mh mi gt ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi oi"><img src="../Images/3d21dfb6393ad53a2225bc2bf7a0c371.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*g-SiMjVbaNLrTu9SOtlBIQ.png"/></div></div></figure><p id="6e00" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi oj translated">尤其是velte，最初引起了我的注意，因为它不是一个客户端框架；相反，它是一个编译时框架。它不再严重依赖浏览器进行处理，而是在编译时转移大量工作，最后，只提供渲染的HTML/CSS/JS。编译后的包不包含也不依赖于任何库代码。</p><h1 id="11f7" class="mx my je bd mz na nb nc nd ne nf ng nh kk ni kl nj kn nk ko nl kq nm kr nn no bi translated">结论</h1><p id="525b" class="pw-post-body-paragraph kt ku je kv b kw np kf ky kz nq ki lb lc nr le lf lg ns li lj lk nt lm ln lo ig bi translated">那么模式是什么呢？进步是典型的模式。大多数现有框架生态系统都存在一个共同的问题，即向客户端发送大量样板代码，并且严重依赖浏览器的资源进行状态管理、路由等。在框架的后续版本中，很难解决这些具有突破性变化的问题。与此同时，有一些替代方案可以继续提供当前开发人员社区所习惯的好处，而不会增加浏览器的工作量。</p><blockquote class="mj mk ml"><p id="adde" class="kt ku mm kv b kw kx kf ky kz la ki lb mn ld le lf mo lh li lj mp ll lm ln lo ig bi translated">消失的框架确实值得投资，值得一试。</p></blockquote></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><p id="7043" class="pw-post-body-paragraph kt ku je kv b kw kx kf ky kz la ki lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我希望这篇文章将有助于理解JS框架中不断变化的模式，并有助于在个人或企业项目开发中做出明智的决定。</p></div><div class="ab cl mq mr hr ms" role="separator"><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv mw"/><span class="mt bw bk mu mv"/></div><div class="ig ih ii ij ik"><h1 id="8cb4" class="mx my je bd mz na os nc nd ne ot ng nh kk ou kl nj kn ov ko nl kq ow kr nn no bi translated">资源</h1><p id="5c80" class="pw-post-body-paragraph kt ku je kv b kw np kf ky kz nq ki lb lc nr le lf lg ns li lj lk nt lm ln lo ig bi translated">特别感谢<a class="ja jb ep" href="https://medium.com/u/27616666fa21?source=post_page-----2c01afbf81fb--------------------------------" rel="noopener" target="_blank">彼得·奥肖内西</a>和里奇·哈里斯——重新思考反应能力，将所有观点汇集在一起。</p><figure class="mf mg mh mi gt ip"><div class="bz fp l di"><div class="ox oy l"/></div></figure><div class="im in gp gr io oz"><a href="https://medium.com/samsung-internet-dev/disappearing-frameworks-ed921f411c38" rel="noopener follow" target="_blank"><div class="pa ab fo"><div class="pb ab pc cl cj pd"><h2 class="bd jf gy z fp pe fr fs pf fu fw jd bi translated">消失的框架</h2><div class="pg l"><h3 class="bd b gy z fp pe fr fs pf fu fw dk translated">新的web平台特性和编译时框架如何建立web开发的下一个时代</h3></div><div class="ph l"><p class="bd b dl z fp pe fr fs pf fu fw dk translated">medium.com</p></div></div><div class="pi l"><div class="pj l pk pl pm pi pn iu oz"/></div></div></a></div></div></div>    
</body>
</html>