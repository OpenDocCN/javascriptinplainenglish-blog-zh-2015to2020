<html>
<head>
<title>Fully understanding React by creating an Automatic Update Feature</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过创建自动更新功能全面了解React</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/update-feature-while-double-checking-assumptions-8c42e30564d6?source=collection_archive---------3-----------------------#2019-10-28">https://javascript.plainenglish.io/update-feature-while-double-checking-assumptions-8c42e30564d6?source=collection_archive---------3-----------------------#2019-10-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e9f3" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">通过创建一个结合了setState()和componentDidUpdate()的自动更新特性，将您对React的理解提升到一个新的层次</h2></div><h1 id="f46a" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">背景</h1><p id="4a37" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">特定信息可能会在API的不同位置重复出现。一个简单而强大的特性是，当您更改特定信息时，该更改会反映在API的其他地方。虽然我确实说过这很简单，但实现起来并没有那么简单(至少对我来说是这样)。根据我学到的关于React的一些隐含假设，我可以一步一步地向您展示如何实现这个特性以及学到的经验。</p><p id="9a0f" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">我将使用的例子是一个有多部电影的剧院。其中两部电影将会重演。更新功能将做的是，当我更新一部电影的描述时，它将自动更新所有同名电影的更新描述。(如果同一部电影有两种不同的描述，那就太奇怪了！)</p><p id="4745" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">首先，请看看下面的要点。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Starting Point for App.js</figcaption></figure><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Starting Point for MovieCard.js</figcaption></figure><p id="73bb" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在第一个gist或App.js中，它的初始状态是一些影院细节和一系列当前正在上映的电影。为了显示更新特征的效果，重复播放两部电影。<code class="fe mg mh mi mj b">App</code>组件映射电影列表并呈现<code class="fe mg mh mi mj b">MovieCard</code>组件。</p><p id="abf7" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在第二个gist或MovieCard.js中，它的初始状态是基于其父组件App.js的状态的描述。<code class="fe mg mh mi mj b">MovieCard</code>的目的是呈现特定于电影本身的信息。这个组件需要有一个组件级的状态，因为我是专门为那部电影更新描述的。</p><p id="d00e" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">既然已经奠定了基础，接下来就是更新特性的逻辑/控制流。</p><h1 id="0528" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">更新功能的集体讨论</h1><p id="d39a" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在我开始编写代码来实现更新特性之前，我喜欢计划出实现这一点的步骤。</p><p id="6bf1" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">我的<strong class="kw io">第一个想法</strong>是我需要以某种方式更新App.js中的初始状态。通过更新App.js中的状态，所有从App.js状态接收其道具的子组件都应该自动重新呈现，因为在App.js级别有状态更改。我可以用<code class="fe mg mh mi mj b">this.setState()</code>改变状态。</p><p id="69d6" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">我的第二个想法是如何将子组件<code class="fe mg mh mi mj b">MovieCard</code>中的新描述传递给它的父组件<code class="fe mg mh mi mj b">App</code>。在React中，这将使用回调函数。为了实现这一点，我可以在<code class="fe mg mh mi mj b">App</code>组件中创建一个新的回调函数，并将其作为道具传递下去。</p><p id="4754" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">我的第三个想法是什么事件会触发我第二个想法的回调函数。我想到的两个选项是<code class="fe mg mh mi mj b">onChange</code>或者<code class="fe mg mh mi mj b">onSubmit</code>。剧透一下，如果你真的<strong class="kw io"><em class="mk"/></strong>看过我的要点，你会注意到第二个要点中的<code class="fe mg mh mi mj b">&lt;form&gt; </code>标签。经过一番修改后，<code class="fe mg mh mi mj b">onSubmit</code>是最好的选择。我已经需要组件级的<code class="fe mg mh mi mj b">onChange</code>事件来编辑它当前的描述。我考虑过使用<code class="fe mg mh mi mj b">onChange</code>作为对<code class="fe mg mh mi mj b">App</code>组件级别的回调函数，但是我建议自己不要这样做，因为每当输入一个字母，Redux就会不断地重新渲染。</p><h1 id="c8c1" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">更新功能的逻辑流程</h1><p id="2e55" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">现在我已经有了自己的想法，是时候一步一步地巩固它们，实现一个有凝聚力的实现了。我喜欢从触发更新特性的事件开始。我将把每一步与前一节中相应的思想进行比较。</p><ol class=""><li id="1877" class="ml mm in kw b kx lq la lr ld mn lh mo ll mp lp mq mr ms mt bi translated">在<code class="fe mg mh mi mj b">MovieCard</code>组件中为表单创建<code class="fe mg mh mi mj b">onSubmit</code>事件。(第三种想法)</li><li id="7f8d" class="ml mm in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated">在<code class="fe mg mh mi mj b">App</code>组件级别创建<code class="fe mg mh mi mj b">onSubmit</code>事件调用的回调函数。(第二个想法)</li><li id="beeb" class="ml mm in kw b kx mu la mv ld mw lh mx ll my lp mq mr ms mt bi translated">在回调函数中，更新<code class="fe mg mh mi mj b">App</code>组件状态以反映电影的更新描述。(第一个想法)</li></ol><p id="78c9" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">到目前为止，一切看起来都可行，所以让我们开始吧！</p><h1 id="ac2b" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">逻辑流程步骤#1</h1><p id="3b59" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">为表单创建<code class="fe mg mh mi mj b">onSubmit</code>事件。以下要点反映了这一点。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="761d" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在第22行，<code class="fe mg mh mi mj b">onSubmit</code>事件增加了三个参数:<code class="fe mg mh mi mj b">e</code>、<code class="fe mg mh mi mj b">title</code>和<code class="fe mg mh mi mj b">description</code>。我需要参数<code class="fe mg mh mi mj b">title</code>的原因将在后面的步骤3中解释。</p><h1 id="4597" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">逻辑流程步骤#2</h1><p id="e538" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">在<code class="fe mg mh mi mj b">App</code>组件中创建回调函数，表单提交时<code class="fe mg mh mi mj b">onSubmit</code>调用该函数。以下要点反映了这一点。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="face" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在第31–33行，我创建了有三个参数的<code class="fe mg mh mi mj b">handleSubmit</code>函数。注意，这三个参数是我从<code class="fe mg mh mi mj b">MovieCard</code>组件中使用的。</p><h1 id="f551" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">逻辑流程步骤#3</h1><p id="98a1" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">创建逻辑来更新具有相同电影标题的所有电影的描述。</p><p id="1aee" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">这比看起来要复杂一点。函数<code class="fe mg mh mi mj b">setState()</code>不适用于嵌套对象。为了更新一个嵌套对象，我需要使用spread操作符，直到到达需要更新的对象。我的set state函数可能是这样的:<code class="fe mg mh mi mj b">this.setState({theater: {...this.state.theater, movies: updatedMovies}})</code>。</p><p id="2275" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated"><code class="fe mg mh mi mj b">movies: updatedMovies</code>正在替换电影的当前状态，因此<code class="fe mg mh mi mj b">updatedMovies</code>应该是一个电影数组，它具有更新的描述<strong class="kw io"> <em class="mk">或</em> </strong>其各自电影的当前描述。让我们先把它写成代码。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">First crack at handleSubmit</figcaption></figure><p id="adea" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在这个要点中，我将变量<code class="fe mg mh mi mj b">updatedMovies</code>实例化为一个空数组，并写下了<code class="fe mg mh mi mj b">setState</code>函数的样子。由于<code class="fe mg mh mi mj b">updatedMovies</code>应该是一个反映其各自电影的更新描述或当前描述的电影数组，我可以使用<code class="fe mg mh mi mj b">push</code>函数来追加<code class="fe mg mh mi mj b">updatedMovies</code>数组。</p><p id="08e9" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">更新功能应该是用更新的描述来更新所有相同的电影。同样的电影会有同样的片名，这也是<code class="fe mg mh mi mj b">title</code>参数发挥作用的地方。我可以使用<code class="fe mg mh mi mj b">title</code>参数作为控制流的关键。让我们写下一些代码来表示这一点。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Second Crack at handleSubmit</figcaption></figure><p id="9c83" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">第5–15行是将当前/更新的电影推入<code class="fe mg mh mi mj b">updatedMovies</code>数组的控制流。if/else语句用作控制流，因为我们只关心在电影名称/标题匹配的情况下用新描述更新电影。</p><p id="7b69" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在第12行，我们可以在<code class="fe mg mh mi mj b">movie</code>本身中<code class="fe mg mh mi mj b">push</code>，因为它不满足我们的<code class="fe mg mh mi mj b">if</code>条件。这也有助于保持电影列表和以前一样的顺序。</p><p id="5db8" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在第8行，我们应该用更新的描述推进电影。然而，每个电影都是一个对象类型，这意味着为了更新对象，我们可以使用spread操作符来更新它，类似于我们为<code class="fe mg mh mi mj b">setState()</code>实现的方式。</p><p id="a315" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">以下要点反映了这些变化。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Third Crack at handleSubmit</figcaption></figure><p id="ce89" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">现在让我们把这个函数放入<code class="fe mg mh mi mj b">App</code>组件中，然后结束。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Final App Component</figcaption></figure><h1 id="8737" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">但是等等…还有更多！</h1><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="mz mb l"/></div></figure><p id="d412" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">如果你一直和这个博客一起写代码，你会注意到…这些都不起作用！每当“电影1”的描述发生变化，我们点击“提交更改”按钮时，另一个“电影1”描述的文本框不会发生变化。作为快速检查，我在更改描述之前和之后以及在点击“提交更改”按钮之后做了一个<code class="fe mg mh mi mj b">console.log</code>。</p><figure class="lv lw lx ly gt lz gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi na"><img src="../Images/a6070972995877593953ded7a2223869.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ra6LHoKqGYyVRLzXW-ORWA.png"/></div></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Discrepancy between the updated state and what is shown</figcaption></figure><p id="073a" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">让我们先看看控制台。控制台的上半部分显示了<code class="fe mg mh mi mj b">App</code>组件的初始状态。下半部分显示了 提交新描述后<code class="fe mg mh mi mj b">App</code>组件<strong class="kw io"> <em class="mk">的状态。下半部分显示了在提交基于逻辑流程的新描述后我所期望的。然而，在屏幕截图的左半部分，只有第一个“电影1”描述被更新，而第二个“电影1”描述保持不变。</em></strong></p><p id="2ff1" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">由于某种原因，<strong class="kw io"> <em class="mk">实际状态</em> </strong>(控制台后半部分)与<strong class="kw io"> <em class="mk">显示状态</em> </strong>(截图左半部分)有出入。</p><p id="7a24" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">在通读了<a class="ae nh" href="https://reactjs.org/docs/react-component.html#setstate" rel="noopener ugc nofollow" target="_blank"> setState()文档</a>之后，下面解释了一切。</p><blockquote class="ni nj nk"><p id="1bbb" class="ku kv mk kw b kx lq jo kz la lr jr lc nl ls lf lg nm lt lj lk nn lu ln lo lp ig bi translated">把<code class="fe mg mh mi mj b">setState()</code>看作是一个<em class="in">请求</em>，而不是一个立即更新组件的命令。为了获得更好的性能，React可能会延迟它，然后一次更新几个组件。<strong class="kw io"> React不保证状态更改会立即应用。</strong></p><p id="eb4b" class="ku kv mk kw b kx lq jo kz la lr jr lc nl ls lf lg nm lt lj lk nn lu ln lo lp ig bi translated"><code class="fe mg mh mi mj b"><strong class="kw io">setState()</strong></code> <strong class="kw io">并不总是立即更新组件。</strong>它可以批处理或推迟更新，直到以后。这使得在调用<code class="fe mg mh mi mj b">setState()</code>之后立即读取<code class="fe mg mh mi mj b">this.state</code>成为一个潜在的陷阱。<strong class="kw io">取而代之，使用</strong> <code class="fe mg mh mi mj b"><strong class="kw io">componentDidUpdate</strong></code> <strong class="kw io">或</strong> <code class="fe mg mh mi mj b"><strong class="kw io">setState</strong></code> <strong class="kw io">回调(</strong> <code class="fe mg mh mi mj b"><strong class="kw io">setState(updater, callback)</strong></code> <strong class="kw io">)，其中任何一个都保证在应用更新后触发。</strong>如果您需要根据之前的状态设置状态，请阅读下面的<code class="fe mg mh mi mj b">updater</code>参数。</p></blockquote><p id="afad" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">注意:加粗的句子是为了强调与本博客相关的某些要点。原始文档没有将这些句子加粗。</p><p id="f468" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">引用我之前的话:</p><blockquote class="ni nj nk"><p id="7dcb" class="ku kv mk kw b kx lq jo kz la lr jr lc nl ls lf lg nm lt lj lk nn lu ln lo lp ig bi translated">通过更新App.js中的状态，从App.js状态接收其属性的所有子组件都应该自动重新呈现，因为在App.js级别有状态更改。我可以使用<code class="fe mg mh mi mj b">this.setState()</code>来改变状态。</p></blockquote><p id="40f4" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">根据文档，新状态<strong class="kw io"> <em class="mk">不会自动应用或立即更新组件</em> </strong>，因此没有自动重新渲染。假设<code class="fe mg mh mi mj b">setState()</code>立即更新组件是所有后续逻辑和流程的关键。既然我的假设是不正确的，我就需要从零开始<strong class="kw io"> <em class="mk">但是</em> </strong>在这种情况下我很幸运。在应用更新后，我可以使用<code class="fe mg mh mi mj b">componentDidUpdate</code>来更新描述。</p><h1 id="b4cd" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">实现componentDidUpdate</h1><p id="18e0" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">我看了一下<a class="ae nh" href="https://reactjs.org/docs/react-component.html#componentdidupdate" rel="noopener ugc nofollow" target="_blank">组件更新文档</a>，发现了以下内容:</p><blockquote class="ni nj nk"><p id="b06a" class="ku kv mk kw b kx lq jo kz la lr jr lc nl ls lf lg nm lt lj lk nn lu ln lo lp ig bi translated">Y <!-- --> ou <strong class="kw io">可以在<code class="fe mg mh mi mj b">componentDidUpdate()</code>中立即调用</strong> <code class="fe mg mh mi mj b"><strong class="kw io">setState()</strong></code> <strong class="kw io">但是注意<strong class="kw io">必须像上面的例子一样用条件</strong>包裹，否则会导致无限循环。</strong></p></blockquote><p id="d5fb" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">对我来说幸运的是，当应用一个更新(即更新的描述)时，在<code class="fe mg mh mi mj b">MovieCard</code>组件上应用这个更新的唯一条件是如果先前的描述与更新的描述不同。我现在可以立即调用<code class="fe mg mh mi mj b">setState</code>，因为现在我有一个条件。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="dc41" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">由于<code class="fe mg mh mi mj b">componentDidUpdate</code>在应用更新后触发，<code class="fe mg mh mi mj b">this.props.movie.description</code>是更新的/当前的描述，而<code class="fe mg mh mi mj b">prevProps.movie.description</code>是先前的描述。如果这些不相等，则调用<code class="fe mg mh mi mj b">setState()</code>函数，用更新后的描述更新所有其他同名电影。<code class="fe mg mh mi mj b">componentDidUpdate</code>被放置在<code class="fe mg mh mi mj b">MovieCard</code>组件中，如下面的要点所示(第9-13行)。</p><figure class="lv lw lx ly gt lz"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="mc md gj gh gi me mf bd b be z dk">Final MovieCard Component</figcaption></figure><p id="a05b" class="pw-post-body-paragraph ku kv in kw b kx lq jo kz la lr jr lc ld ls lf lg lh lt lj lk ll lu ln lo lp ig bi translated">瞧，更新功能现在正在按预期工作！</p><h1 id="f442" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">关键外卖</h1><p id="6fd8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">如果你的假设或你对一个概念/主题/功能的理解没有达到预期的效果，一定要反复检查。理想情况下，我应该在继续之前仔细检查<code class="fe mg mh mi mj b">setState()</code>的功能，因为这是我更新特性的整个代码的基础。如果它不像我想的那样工作，我就需要从头开始，用不同的方法解决问题。我很幸运，因为我能够用<code class="fe mg mh mi mj b">componentDidUpdate</code>利用剩下的代码。如果不是这样，那么好的一面将是我对<code class="fe mg mh mi mj b">setState</code>有了更深入的了解并做出反应。</p></div></div>    
</body>
</html>