# 又来了:递归介绍以及如何在代码中使用递归

> 原文：<https://javascript.plainenglish.io/recursion-what-it-is-and-how-you-use-it-302d85e6577e?source=collection_archive---------4----------------------->

![](img/53c094ec0de876cc2f45206b38d774ab.png)

Photo by [Tine Ivanič](https://unsplash.com/@tine999?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/loop?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)

# 什么是递归？

用最简单的术语来说，**递归函数是一个自称为**的函数。递归是解决类似迭代解决的问题的工具，但是如果可能的话，迭代是更好的选择。但是在有些情况下，迭代并没有给我们所需要的东西，这就是递归的用武之地。

值得注意的是，递归函数需要一个**基础用例**，或者停止点，这样它们就不会永远继续调用自己。

# 我们什么时候使用递归函数？

当你遍历一个对象，你需要调用正在执行迭代的函数时，递归是必要的。

合并排序和快速排序都是递归函数。例如，Merge sort 通过将长度为 *n* 的数组分成 *n* 个不同的子数组来对数组进行排序。它将原始数组一分为二，然后将每个子数组一分为二，再将每个子数组一分为二，以此类推，直到子数组的长度为 1。

假设我们有以下长度为 8 的数组:

```
let array = [19, 42, 36, 11, 16, 91, 84, 2]
```

将数组传递到我们的合并排序函数中，我们希望将该数组一分为二，因此我们有以下子数组:

```
let firstSubArray = [19, 42, 36, 11]
let secondSubArray = [16, 91, 84, 2]
```

现在，我们真正想做的是将这些子数组中的每一个也传递到我们的合并排序函数中，这样每个子数组都被分成两半。这就是递归的用武之地，因为我们需要从合并排序函数中调用合并排序函数。

这篇文章是关于递归的，而不是具体的合并排序，但是对于那些不熟悉合并排序的人，我将用简单的英语很快地讲述接下来会发生什么。

一旦您的递归调用返回了长度都为 1 的 *n* 子数组，merge sort 就会一次比较 2 个数组，并按排序后的顺序连接它们。

```
[19] [42] [36] [11] [16] [91] [84] [2]
```

给定上面的子数组集，merge sort 将比较并连接 19 和 42、36 和 11、16 和 91 以及 84 和 2，返回如下结果:

```
[19, 42] [11, 36] [16, 91] [2, 84]
```

接下来的合并排序将会比较前两个数组和后两个数组。它将从比较第一个数组的第一个元素和第二个数组的第一个元素开始，所以 19 和 11。11 较小，所以添加 11 作为组合数组的第一个元素。然后将 19 与第二个数组中的第二项 36 进行比较，19 较小，因此将其添加到组合数组中。然后比较 42 和 36，36 比 36 小，所以加到组合数组中，然后加 42。

```
[11, 19, 36, 42] [16, 91] [2, 84]
```

对另外两个数组做同样的事情。2 小于 16 所以添加为它们组合数组的第一个元素，16 小于 84 所以添加，84 小于 91 所以添加，然后 91 添加。

```
[11, 19, 36, 42] [2, 16, 84, 91]
```

我们现在只剩下两个数组，它们都是已排序的，我们需要合并它们。2 小于 11，所以加 2。11 小于 16，所以加 11。16 小于 19，所以加 16。19 小于 84，所以加 19。36 小于 84，42 也小于 84，所以加 36 再加 42。最后添加 84 和 91。

```
[2, 11, 16, 19, 36, 42, 84, 91]
```

就这样，我们有了排序后的数组。

# JavaScript 中的递归是什么样子的？

一个合适的合并排序函数应该包括将原始数组减半为长度为 1 的子数组、子数组元素的比较以及子数组的连接，但是今天我们只想关注递归，所以我们将只构建 JavaScript 中的减半函数。

在这个例子中，我们将坚持使用我们的原始数组。我们从以下方面着手:

```
let array = [19, 42, 36, 11, 16, 91, 84, 2]
```

我们希望我们的功能产生:

```
[19] [42] [36] [11] [16] [91] [84] [2]
```

我们将从编写我们的函数开始，我们称之为减半，并将数组传递给它。因为我们将数组减半的能力依赖于知道长度，我们将从获得长度开始，将它一分为二，然后基于这个中点将数组一分为二。

```
function halving(array) {
     let length = array.length;
     let half = length / 2;
     let firstSubArray = array.slice(0, half;
     let secondSubArray = array.slice(half, length);
}
```

现在递归开始了。我们有第一个子数组和第二个子数组，正如我们之前说过的，我们真正想做的是将这些数组中的每一个传递给减半函数，*，我们想将它们的每个子数组传递给减半函数，直到子数组的长度为 1*。我们通过使用条件语句来确定长度，如果子数组的长度不等于 1，我们就从函数内部再次调用 halving 函数，并将子数组传入。这种从 halving(array)内部调用 halving(array)，就是递归。

```
function halving(array) {
     let length = array.length;
     let half = length / 2;
     let firstSubArray = array.slice(0, half;
     let secondSubArray = array.slice(half, length);
          if (firstSubArray.length === 1) {
          console.log(firstSubArray)
     } else {
          halving(firstSubArray);
     }
 if (secondSubArray.length === 1) {
         console.log(secondSubArray)
     } else {
          halving(secondSubArray);
     }
}
```

如果运行此代码，您将在控制台上看到以下输出:

```
[ 19 ]
[ 42 ]
[ 36 ]
[ 11 ]
[ 16 ]
[ 91 ]
[ 84 ]
[ 2 ]
```

这大概就是递归的内容了。下周回来学习堆背后的理论，以及如何使用 JavaScript 构建一个堆。