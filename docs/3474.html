<html>
<head>
<title>Write Integration Tests (and Mocks) with Jest and Supertest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest和Supertest编写集成测试(和模拟)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/write-integration-tests-and-mocks-with-jest-and-supertest-b65a7b9186ce?source=collection_archive---------1-----------------------#2020-10-02">https://javascript.plainenglish.io/write-integration-tests-and-mocks-with-jest-and-supertest-b65a7b9186ce?source=collection_archive---------1-----------------------#2020-10-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7a91" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">概述如何为集成测试设置应用程序</h2></div><p id="6433" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将讨论如何使用Jest、Supertest编写集成测试，在编写集成测试的过程中，我们经常需要模拟npm模块和依赖项，因此我们也将模拟这些npm模块和依赖项，以便顺利和完整地进行测试。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/a66f8ef8a984eb1682b1f5efae19ce5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XEgR0gQwr7ttkYovL4nFcw.jpeg"/></div></div><figcaption class="ln lo gj gh gi lp lq bd b be z dk">Photo by <a class="ae lr" href="https://www.pexels.com/@alxs?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Abet Llacer</a> from <a class="ae lr" href="https://www.pexels.com/photo/black-laptop-beside-audio-mixer-set-919734/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="df84" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们开始吧，Jest是一个优秀的库，可能是编写测试、检查测试覆盖率、模拟模块的最佳库之一，并且配备了许多其他有用的特性。首先，我们将创建一个Node.js应用程序，我们可以在其上编写测试。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="7629" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码片段中，我们创建了一个简单的应用程序来验证我们的访问令牌。我们将检查头中的访问令牌，并使用<strong class="kh ir"> jsonwebtoken </strong>库进行验证。由于我们还没有在应用程序中的任何地方实现<strong class="kh ir"> JWT </strong>，我们将使用<strong class="kh ir"> Jest Mock </strong>来模仿<strong class="kh ir"> JWT NPM模块</strong>。</p><p id="afcd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，让我们在应用程序中设置Jest。我们将从在应用程序中安装Jest开始。</p><ol class=""><li id="a736" class="lu lv iq kh b ki kj kl km ko lw ks lx kw ly la lz ma mb mc bi translated"><code class="fe md me mf mg b">npm install jest</code>。</li><li id="b58f" class="lu lv iq kh b ki mh kl mi ko mj ks mk kw ml la lz ma mb mc bi translated">在我们的<strong class="kh ir"> package.json </strong>中，用这个命令<br/> <code class="fe md me mf mg b">“test”: “npx jest — runInBand — coverage”</code>替换测试脚本。</li><li id="778c" class="lu lv iq kh b ki mh kl mi ko mj ks mk kw ml la lz ma mb mc bi translated">在根目录下创建一个<strong class="kh ir"> jest.config.json </strong>文件来指定要测试的文件。</li></ol><p id="3fc5" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kh ir"> jest.config.json </strong>文件的内容将是</p><pre class="lc ld le lf gt mm mg mn mo aw mp bi"><span id="11de" class="mq mr iq mg b gy ms mt l mu mv">{ <br/>  "testRegex": "((\\.|/*.)(spec))\\.js?$",<br/>  "clearMocks": true,<br/>  "testEnvironment": "node"<br/>}</span></pre><p id="e62b" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的文件在我们的项目目录中递归地搜索扩展名为<strong class="kh ir"> spec.js </strong>的文件，并将其包含在我们的测试中。</p><p id="96f2" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在，应该记住的是，如果我们正在编写集成测试，我们可能希望遵循测试的顺序，特别是当我们处理数据库和外键时。现在，假设我们有一些测试文件，比如说-</p><ol class=""><li id="59eb" class="lu lv iq kh b ki kj kl km ko lw ks lx kw ly la lz ma mb mc bi translated"><strong class="kh ir"> 001-dummy-test.spec.js </strong></li><li id="5275" class="lu lv iq kh b ki mh kl mi ko mj ks mk kw ml la lz ma mb mc bi translated"><strong class="kh ir"> 002-dummy-test.spec.js </strong></li><li id="02d9" class="lu lv iq kh b ki mh kl mi ko mj ks mk kw ml la lz ma mb mc bi translated"><strong class="kh ir"> 003-dummy-test.spec.js </strong></li></ol><p id="afdf" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且我们希望上面的文件按顺序运行，那么<strong class="kh ir">没有办法让这些文件按顺序运行，因为Jest异步运行它的测试用例</strong>。但是，这些文件中的测试套件以同步顺序运行。</p><p id="757a" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了避免这种情况，我们应该只有一个测试文件，里面有许多测试套件，在不同的函数中编写我们所有的测试用例，并要求它们在我们的测试套件中同步运行。我现在详细解释一下。</p><p id="9774" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">让我们在根目录下创建一个测试文件夹，在里面我们将编写我们的测试函数。</p><figure class="lc ld le lf gt lg"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="059d" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们的测试函数。让我们看看我们在这里做什么—</p><ol class=""><li id="0be6" class="lu lv iq kh b ki kj kl km ko lw ks lx kw ly la lz ma mb mc bi translated">为了运行集成测试，我们需要一个服务器，我们需要从我们的主<strong class="kh ir"> app.js </strong></li><li id="f963" class="lu lv iq kh b ki mh kl mi ko mj ks mk kw ml la lz ma mb mc bi translated">我们需要模块被jest嘲笑，jest在我们的例子中是<code class="fe md me mf mg b">jsonwebtoken</code>模块。</li><li id="e23e" class="lu lv iq kh b ki mh kl mi ko mj ks mk kw ml la lz ma mb mc bi translated">为了运行集成测试，我们需要<code class="fe md me mf mg b">supertest</code> ( <code class="fe md me mf mg b">npm install supertest</code>)。</li><li id="3a7c" class="lu lv iq kh b ki mh kl mi ko mj ks mk kw ml la lz ma mb mc bi translated">现在，我们开始在函数testApi中编写测试用例，我们将在我们唯一的测试文件中调用这个函数，以便它们按顺序运行。</li><li id="1103" class="lu lv iq kh b ki mh kl mi ko mj ks mk kw ml la lz ma mb mc bi translated">现在，要模仿一个模块，我们需要在它被调用时对它进行监视，这就是我们用Jest Spy所做的。我们在窥探jwt，jwt中的verify函数是什么时候调用的。</li><li id="3466" class="lu lv iq kh b ki mh kl mi ko mj ks mk kw ml la lz ma mb mc bi translated">现在，一旦在jwt内部调用了verify函数，我们就根据需要使用jest的mockReturnValue模拟jwt的返回值。因此，在我们的主<strong class="kh ir"> app.js </strong>中，jwt verify函数将返回这个值，而不是它自己的实现值。</li><li id="953d" class="lu lv iq kh b ki mh kl mi ko mj ks mk kw ml la lz ma mb mc bi translated">现在，使用supertest，我们达到了API端点，set用于设置头，在我们的例子中，我们设置了访问令牌。</li><li id="eb62" class="lu lv iq kh b ki mh kl mi ko mj ks mk kw ml la lz ma mb mc bi translated">因为我们已经模拟了测试用例将通过的值，并返回状态代码200。</li><li id="117f" class="lu lv iq kh b ki mh kl mi ko mj ks mk kw ml la lz ma mb mc bi translated">在第二个测试案例中，我们做了同样的事情，但是这次我们希望访问令牌无效。</li><li id="df7f" class="lu lv iq kh b ki mh kl mi ko mj ks mk kw ml la lz ma mb mc bi translated">为了抛出任何错误，我们使用jest的mockImplementationOnce来抛出错误。</li><li id="a562" class="lu lv iq kh b ki mh kl mi ko mj ks mk kw ml la lz ma mb mc bi translated">我们假设一旦它失败并抛出错误，我们将得到状态代码401。</li></ol><p id="1d26" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在运行这些测试用例，我们将导入我们唯一的测试文件。</p><pre class="lc ld le lf gt mm mg mn mo aw mp bi"><span id="3007" class="mq mr iq mg b gy ms mt l mu mv">const test1 = require('./test/001-test-api');</span><span id="9bc2" class="mq mr iq mg b gy mw mt l mu mv">describe('Test API and mock NPM Modules', test1);</span></pre><p id="4c61" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类似地，我们可以有更多的描述函数，所有这些都将按顺序运行，这样我们在运行集成测试时就不会遇到任何问题。</p><p id="ffad" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一件事，有许多方法来模仿NPM模块，但Jest SpyOn是最好的方法之一，因为它在每个it函数后清除模仿，所以我们不需要自己清除模仿，这样我们可能会错过一些时间，并可能导致我们的代码中的错误。我推荐的另一个图书馆是sinon，在那里我们可以使用存根来达到同样的目的。</p><p id="2f34" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在运行测试，简单运行<code class="fe md me mf mg b">npm run tests</code>和jest将在控制台中提供一个类似下图的详细报告。并在根目录中创建一个文件夹覆盖以获得更详细的信息。</p><figure class="lc ld le lf gt lg gh gi paragraph-image"><div role="button" tabindex="0" class="lh li di lj bf lk"><div class="gh gi lb"><img src="../Images/e5ca3ab68ecdf7d7ece1dc7b4afa2c1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LHj4YT7K0o8Lf-H0kLHd6Q.png"/></div></div></figure><p id="29dd" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您还可以查看项目结构。我们只有一个测试文件<strong class="kh ir"> test.spec.js </strong>，我们在其中运行所有的测试套件，以维持集成测试的顺序。</p><p id="d426" class="pw-post-body-paragraph kf kg iq kh b ki kj jr kk kl km ju kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">github repo—<a class="ae lr" href="https://github.com/ANUPAMCHAUDHARY1117/Integration-Tests-Jest-Supertest-And-Mocking-NPM-Module" rel="noopener ugc nofollow" target="_blank">https://github . com/anupamchaudhary 1117/Integration-Tests-Jest-Supertest-And-Mocking-NPM-Module</a></p></div></div>    
</body>
</html>