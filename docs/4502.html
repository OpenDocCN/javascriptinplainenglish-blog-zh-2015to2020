<html>
<head>
<title>Tree Traversal with JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JavaScript遍历树</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/tree-traversal-with-javascript-29b57d61d486?source=collection_archive---------7-----------------------#2020-12-16">https://javascript.plainenglish.io/tree-traversal-with-javascript-29b57d61d486?source=collection_archive---------7-----------------------#2020-12-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="889e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript数据结构系列的第6部分</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4b77b74e56be4ce81830e33fd580b06a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*eHmfeBIlCxnoMU-3"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@enioku?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Dmitry Schemelev</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0736" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将介绍树遍历。如果你错过了我们学习树、二叉树和二分搜索法树的系列文章的最后一部分，一定要先看看下面的文章。</p><div class="ls lt gp gr lu lv"><a href="https://medium.com/javascript-in-plain-english/binary-search-trees-with-javascript-715df954b33" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">使用JavaScript的二分搜索法树</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">JavaScript数据结构系列的第5部分</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="mf l mg mh mi me mj kp lv"/></div></div></a></div><h1 id="d1ab" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">什么是树遍历？</h1><p id="4ee8" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">树遍历是访问树中的每个节点一次。与只有一条线性路径来访问所有节点的列表、数组、堆栈或队列相比，树没有特定的顺序。对于树遍历，有两种方法:</p><ul class=""><li id="304b" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">深度优先搜索——在回溯之前尽可能向下搜索一个分支。在深度优先搜索中，有三个主要的顺序；前序、后序和无序。</li><li id="4710" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">广度优先搜索—在移动到下一个深度级别之前，探索当前深度的所有邻居节点。</li></ul><p id="78d5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图是我们将经历的快速总结。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nv"><img src="../Images/d2e081916f352060ea122e95d8ca22fd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pw23w4XKIlIKGvZkidoKnw.png"/></div></div></figure><p id="3788" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们将探索遍历我们的树的四种方法。对于本文，我们将使用二叉树作为例子。下面的代码是我们在上一篇文章中创建的二叉树。简单回顾一下，我们有一个节点类，用于在树中插入新节点，还有一个二叉树类，有两个方法，insert和find。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Binary Search Tree</figcaption></figure><h1 id="cefc" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">深度优先搜索</h1><p id="f97d" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">深度优先搜索意味着在访问任何兄弟节点之前垂直遍历树。在横向移动(广度优先)之前，我们将在树中向下移动(深度优先)。请注意，我们将在解决方案中使用递归。如果你不熟悉递归，你可以在这里阅读更多关于它的内容。</p><p id="7823" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在深度优先搜索中，我们需要采取三个步骤。我们执行这些步骤的顺序将决定输出和我们访问节点的顺序。</p><ul class=""><li id="9a7d" class="nh ni iq ky b kz la lc ld lf nj lj nk ln nl lr nm nn no np bi translated">访问节点</li><li id="dbb5" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">探索左侧</li><li id="2e21" class="nh ni iq ky b kz nq lc nr lf ns lj nt ln nu lr nm nn no np bi translated">探索右侧</li></ul><h2 id="ec15" class="ny ml iq bd mm nz oa dn mq ob oc dp mu lf od oe mw lj of og my ln oh oi na oj bi translated">预订</h2><p id="5dc5" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我们将首先看一看深度优先搜索前序。我们将从根开始，并将首先访问节点(这意味着我们将把它添加到我们的数据列表中，并且我们不会再访问它)。然后我们将遍历树的左侧，然后是右侧(我们将对每个节点都这样做)。下图显示了我们访问每个节点的顺序。我们将从1开始，并将其添加到列表中。然后检查1的左侧，这将我们移动到2，并将2添加到列表中。然后，检查2的左侧，这将我们移动到3，然后将3添加到列表中。由于3的左边没有，我们将返回到2，然后检查2的右边，这将我们移动到4，然后将4添加到列表中。然后，我们将沿着树向上移动到1，并检查1的右侧，这将我们移动到5，然后将5添加到列表中。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/ce5d5161d858316cc2f63e4e86bdb7f9.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*EZRkBS1AlMSHoQLR8v2qPw.png"/></div></figure><p id="e766" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在让我们写出我们的函数。我们将首先在tree类上创建一个新方法，并将其命名为DFSPreOrder。我们需要在方法中创建一个数组来存储我们访问过的节点，我们称之为数据。</p><p id="5f87" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们将使用递归并编写一个助手函数，称为traverse。这个函数将接受一个节点作为参数。请记住，我们需要采取三个步骤(访问节点，探索左侧，探索右侧)。让我们首先将节点的值推送到我们的数据数组中(访问节点)。然后，我们将检查节点是否有左属性。如果是这样，我们将使用左边的节点再次调用helper函数。然后，我们将检查节点是否有正确的属性。如果是这样，我们将使用正确的节点调用helper函数。</p><p id="06ff" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最后，我们将使用根节点调用helper函数，最后返回数据数组。</p><pre class="kg kh ki kj gt ol om on oo aw op bi"><span id="5235" class="ny ml iq om b gy oq or l os ot">DFSPreOrder() {<br/>  let data = [];<br/>  function traverse(node) {<br/>    data.push(node.value);<br/>    if(node.left) traverse(node.left);<br/>    if(node.right) traverse(node.right);<br/>  }<br/>  traverse(this.root);<br/>  return data;<br/>}</span></pre><h2 id="3e9d" class="ny ml iq bd mm nz oa dn mq ob oc dp mu lf od oe mw lj of og my ln oh oi na oj bi translated">后期订单</h2><p id="76b9" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">在后序中，我们将最后访问节点。这意味着在访问父节点之前，我们将首先访问所有子节点。</p><p id="a5ed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">下图显示了我们访问每个节点的顺序。我们再次从根节点开始，但是注意到根节点是我们访问的最后一个节点。我们首先遍历树的左侧，这将我们带到3，然后再到1。既然没有1的左或右，我们就访问1。然后，我们将遍历3的右侧，而不是访问3，这将我们带到2。由于2没有左右之分，我们访问2，然后移回3，访问3。在访问3之后，我们向上移动到5，但是在访问5之前，我们遍历5的右侧，这将我们移动到4。由于4没有左和右，我们访问4，然后最后回到5，访问5。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/ea743d045dd1176955dcee339fd1cf3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*e_Y_eQ6fBg4-7833IvXpMQ.png"/></div></div></figure><p id="0bde" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">postOrder的代码与preOrder的代码非常相似，除了我们在helper函数中采取的步骤有一个微小的变化。在helper函数中，我们不会在开始时推送节点值，而是在遍历了左右两边之后推送数据。就是这样！</p><pre class="kg kh ki kj gt ol om on oo aw op bi"><span id="d8f9" class="ny ml iq om b gy oq or l os ot">DFSPostOrder() {<br/>  let data = [];<br/>  function traverse(node) {<br/>    if(node.left) traverse(node.left);<br/>    if(node.right) traverse(node.right);<br/>    data.push(node.value);<br/>  }<br/>  traverse(this.root);<br/>  return data;<br/>}</span></pre><h2 id="15f9" class="ny ml iq bd mm nz oa dn mq ob oc dp mu lf od oe mw lj of og my ln oh oi na oj bi translated">中根次序</h2><p id="d84c" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">我们要看的最后一个深度优先搜索顺序是有序的。如果我们使用二叉查找树，这将给我们一个数组，数组中的值按升序排列，顾名思义。下图显示了我们访问每个节点的顺序。从根开始，我们将遍历树的左侧，移动到2，然后到1。因为1没有左或右，我们将访问1，然后返回到2。然后我们将参观2。然后遍历2的右侧，将我们移动到3，并访问3。接下来，我们将沿着树向上回到4，并访问4。最后，我们将遍历4的右侧，这将我们移动到5，我们将访问5。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/b8a0adf854cf306521efb8d5a331368a.png" data-original-src="https://miro.medium.com/v2/resize:fit:608/format:webp/1*gVn81p3YPcpG9mgbzSdKMg.png"/></div></div></figure><p id="a4df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，inOrder的代码类似于preOrder和postOrder，除了在helper函数中有一处变化。我们首先遍历左侧，然后通过将值推入数据数组来访问节点，然后遍历右侧。</p><pre class="kg kh ki kj gt ol om on oo aw op bi"><span id="4abe" class="ny ml iq om b gy oq or l os ot">DFSInOrder() {<br/>  let data = [];<br/>  function traverse(node) {<br/>    if(node.left) traverse(node.left);<br/>    data.push(node.value);<br/>    if(node.right) traverse(node.right);<br/>  }<br/>  traverse(this.root);<br/>  return data;<br/>}</span></pre><h1 id="2c03" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">广度优先搜索</h1><p id="9126" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">现在让我们进入广度优先搜索。与我们在深度优先搜索中所做的沿树向下移动不同，广度优先搜索在向下移动之前首先沿树水平移动。下图显示了我们访问每个节点的顺序。如您所见，我们从根开始，然后向下一层，访问2和3。然后向下移动到下一级，访问4和5。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ou"><img src="../Images/e6751c8273ffc3a62f3560112a7fc5ed.png" data-original-src="https://miro.medium.com/v2/resize:fit:650/format:webp/1*_Sr1OccEhNLNEd5ZtxovLw.png"/></div></figure><p id="16a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们将使用队列。如果您不熟悉队列，请查看下面的文章。</p><div class="ls lt gp gr lu lv"><a href="https://medium.com/javascript-in-plain-english/stacks-vs-queues-with-javascript-eeb33ae4c93c" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">使用JavaScript的堆栈与队列</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">JavaScript数据结构系列的第3部分</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="ov l mg mh mi me mj kp lv"/></div></div></a></div><p id="d6e4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们首先创建一个方法，并将其命名为BFS。为了以一种简单的方式重新创建我们的队列(先进先出)，我们将使用数组的push和shift方法。我们将创建两个空队列，分别称为队列和数据。我们还将创建一个节点变量来跟踪我们正在检查的当前节点。然后，我们将从将根节点放入队列开始。</p><pre class="kg kh ki kj gt ol om on oo aw op bi"><span id="fdfb" class="ny ml iq om b gy oq or l os ot">BFS() {<br/>  let queue = [];<br/>  let data = [];<br/>  let node = this.root;<br/>  queue.push(node);<br/>}</span></pre><p id="7f26" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">接下来，我们将创建一个while循环，在队列中有数据时运行。在这个while循环中，我们将使用shift获取队列中的第一个数据，并将该值存储为节点变量。然后，我们将把这个节点的值推入我们的数据数组。接下来，我们将检查节点是否有left和right属性。如果有，我们将把这些值推到队列中。当队列中有数据时，while循环将继续运行。一旦完成，我们将返回数据列表。</p><pre class="kg kh ki kj gt ol om on oo aw op bi"><span id="9546" class="ny ml iq om b gy oq or l os ot">BFS() {<br/>  let queue = [];<br/>  let data = [];<br/>  let node = this.root;<br/>  queue.push(node);<br/>  while(queue.length) {<br/>    node = queue.shift();<br/>    data.push(node.value);<br/>    if(node.left) queue.push(node.left);<br/>    if(node.right) queue.push(node.right);<br/>  }<br/>  return data;<br/>}</span></pre><p id="89cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终的代码将如下所示。您现在可以创建一个新的树，并测试我们添加的不同的树遍历方法。根据我们使用的搜索顺序，返回的数组应该以不同的顺序列出树的值。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nw nx l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Depth-First Search and Breadth-First Search</figcaption></figure><h1 id="3b7e" class="mk ml iq bd mm mn mo mp mq mr ms mt mu jw mv jx mw jz mx ka my kc mz kd na nb bi translated">包扎</h1><p id="3191" class="pw-post-body-paragraph kw kx iq ky b kz nc jr lb lc nd ju le lf ne lh li lj nf ll lm ln ng lp lq lr ij bi translated">现在，您应该对我们如何遍历树并访问每个节点有所了解了。如果您想知道何时应该使用一种方法而不是另一种方法，我推荐阅读关于<a class="ae kv" href="https://stackoverflow.com/questions/3332947/when-is-it-practical-to-use-depth-first-search-dfs-vs-breadth-first-search-bf" rel="noopener ugc nofollow" target="_blank">堆栈溢出</a>的一个线程来了解更多信息。</p></div><div class="ab cl ow ox hu oy" role="separator"><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb pc"/><span class="oz bw bk pa pb"/></div><div class="ij ik il im in"><p id="c560" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="pd">感谢阅读！如果您错过了本系列的第4部分，在那一部分中，我们用JavaScript研究了双向链表，请查看下面的文章。</em></p><div class="ls lt gp gr lu lv"><a href="https://medium.com/javascript-in-plain-english/doubly-linked-lists-with-javascript-9c20a9dc4fb3" rel="noopener follow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">使用JavaScript的双向链表</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">JavaScript数据结构系列的第4部分</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">medium.com</p></div></div><div class="me l"><div class="pe l mg mh mi me mj kp lv"/></div></div></a></div><p id="a276" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="pd">请关注本系列的第7部分，在那里我们将看到一种不同类型的树，二进制堆。</em></p></div></div>    
</body>
</html>