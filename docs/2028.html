<html>
<head>
<title>Learning JavaScript by Implementing Lodash Methods — Flattening and Mapping</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过实现Lodash方法学习JavaScript扁平化和映射</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/learning-javascript-by-implementing-lodash-methods-flattening-and-mapping-c644afce1cd0?source=collection_archive---------12-----------------------#2020-05-13">https://javascript.plainenglish.io/learning-javascript-by-implementing-lodash-methods-flattening-and-mapping-c644afce1cd0?source=collection_archive---------12-----------------------#2020-05-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/f2a28c21627d6e1fa20ed8f4b847d6da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*uhWdn9rIOMH7bzOV"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@brookelark?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Brooke Lark</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c598" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lodash是一个非常有用的工具库，让我们可以轻松地处理对象和数组。</p><p id="7fcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，现在JavaScript标准库正在赶上诸如Lodash之类的库，我们可以用简单的方法实现许多功能。</p><p id="65c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解如何创建自己的方法来展平集合。</p><h1 id="044d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">flatMap</code></h1><p id="4a28" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash <code class="fe lz ma mb mc b">flatMap</code>方法对原始数组的每个数组条目运行一个<code class="fe lz ma mb mc b">iteratee</code>函数，然后展平得到的数组并返回它。</p><p id="5db5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下实现它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c01f" class="mq lc iq mc b gy mr ms l mt mu">const flatMap = (arr, iteratee) =&gt; arr.map(iteratee).flat()</span></pre><p id="7cb0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们调用了<code class="fe lz ma mb mc b">arr</code>上的<code class="fe lz ma mb mc b">map</code>方法来将每个条目映射到<code class="fe lz ma mb mc b">iteratee</code>，然后调用<code class="fe lz ma mb mc b">flat</code>来展平结果数组。</p><p id="628d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们如下调用我们的<code class="fe lz ma mb mc b">flatMap</code>函数时:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="6852" class="mq lc iq mc b gy mr ms l mt mu">const result = flatMap([1, 2], a =&gt; [a, a]);</span></pre><p id="47ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到<code class="fe lz ma mb mc b">result</code>是<code class="fe lz ma mb mc b">[1, 1, 2, 2]</code>。</p><h1 id="8cd1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">flatMapDeep</code></h1><p id="6802" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash的<code class="fe lz ma mb mc b">flatMapDeep</code>方法类似于<code class="fe lz ma mb mc b">flatMap</code>，但是递归地展平结果数组。</p><p id="64d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以像对<code class="fe lz ma mb mc b">flatMap</code>方法那样实现它，如下所示:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="fdc3" class="mq lc iq mc b gy mr ms l mt mu">const flatMapDeep = (arr, iteratee) =&gt; arr.map(iteratee).flat(Infinity)</span></pre><p id="8143" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们的<code class="fe lz ma mb mc b">flatMapDeep</code>和<code class="fe lz ma mb mc b">flatMap</code>方法之间的唯一区别是，我们在通过调用<code class="fe lz ma mb mc b">iteratee</code>映射每个条目后，将<code class="fe lz ma mb mc b">Infinity</code>传递给<code class="fe lz ma mb mc b">flat</code>以递归展平我们的结果数组。</p><p id="0de7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们可以这样做时:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="5d9b" class="mq lc iq mc b gy mr ms l mt mu">const result = flatMapDeep([1, 2], a =&gt; [[a, a]]);</span></pre><p id="6514" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">result</code>应该是<code class="fe lz ma mb mc b">[1, 1, 2, 2]</code>。</p><h1 id="9a7b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">flatMapDepth</code></h1><p id="70c8" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">flatMapDepth</code>类似于<code class="fe lz ma mb mc b">flatMap</code>，但是我们可以指定结果数组的展平深度。</p><p id="15d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">普通的JS <code class="fe lz ma mb mc b">flat</code>方法也接受展平的深度作为参数，所以我们可以再次使用它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8ba8" class="mq lc iq mc b gy mr ms l mt mu">const flatMapDepth = (arr, iteratee, depth) =&gt; arr.map(iteratee).flat(depth)</span></pre><p id="e33f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们这样称呼它的时候:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="17bd" class="mq lc iq mc b gy mr ms l mt mu">const result = flatMapDepth([1, 2], a =&gt; [<br/>  [a, a]<br/>], 1);</span></pre><p id="1217" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="9606" class="mq lc iq mc b gy mr ms l mt mu">[<br/>  [<br/>    1,<br/>    1<br/>  ],<br/>  [<br/>    2,<br/>    2<br/>  ]<br/>]</span></pre><p id="7c19" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为<code class="fe lz ma mb mc b">result</code>的值，因为我们指定深度为1。</p><h1 id="f8a2" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">groupBy</code></h1><p id="7e4b" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">groupBy</code>方法返回一个对象，该对象接受一个数组中的项目，调用一个<code class="fe lz ma mb mc b">iteratee</code>函数并将其添加为返回对象的键】。</p><p id="e2e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后它创建一个数组作为每个键的值，然后当用它调用<code class="fe lz ma mb mc b">iteratee</code>时，将与键相同的项目推入数组。</p><p id="852f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以按如下方式实现:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="2e58" class="mq lc iq mc b gy mr ms l mt mu">const groupBy = (arr, iteratee) =&gt; {<br/>  let obj = {};<br/>  for (const a of arr) {<br/>    if (!Array.isArray(iteratee(a))) {<br/>      obj[iteratee(a)] = [];<br/>    }<br/>    obj[iteratee(a)].push(a);<br/>  }<br/>  return obj;<br/>}</span></pre><p id="6e08" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们用一个<code class="fe lz ma mb mc b">for...of</code>循环遍历条目，然后通过调用数组条目上的<code class="fe lz ma mb mc b">iteratee</code>来填充键，然后添加值为空数组的键。</p><p id="8b93" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后当把条目推入到相应的键的数组中时。</p><p id="656d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们这样称呼它的时候:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="1fb8" class="mq lc iq mc b gy mr ms l mt mu">const result = groupBy([6.1, 4.2, 6.3], Math.floor);</span></pre><p id="f479" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到的那个<code class="fe lz ma mb mc b">result</code>是:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="a71d" class="mq lc iq mc b gy mr ms l mt mu">{<br/>  "4": [<br/>    4.2<br/>  ],<br/>  "6": [<br/>    6.3<br/>  ]<br/>}</span></pre><h1 id="5988" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated"><code class="fe lz ma mb mc b">includes</code></h1><p id="42f2" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash <code class="fe lz ma mb mc b">includes</code>方法检查一个条目是否在集合中。它还需要一个起始索引来开始搜索。</p><p id="96cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以用如下的<code class="fe lz ma mb mc b">slice</code>和<code class="fe lz ma mb mc b">includes</code>方法实现这一点:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="8008" class="mq lc iq mc b gy mr ms l mt mu">const includes = (arr, value, start) =&gt; arr.slice(start).includes(value)</span></pre><p id="edf4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们调用了<code class="fe lz ma mb mc b">arr</code>上的<code class="fe lz ma mb mc b">slice</code>来从<code class="fe lz ma mb mc b">start</code>索引开始搜索。然后我们调用array实例的<code class="fe lz ma mb mc b">includes</code>方法来检查该项是否在切片数组中。</p><p id="c07a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们这样称呼它的时候:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="c78d" class="mq lc iq mc b gy mr ms l mt mu">const result = includes([6.1, 4.2, 6.3], 6.3, 1);</span></pre><p id="672e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lz ma mb mc b">result</code>应为<code class="fe lz ma mb mc b">true</code>，因为6.3位于索引大于或等于1的数组部分。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/fd9f8f58924e9b4c2327b4fcf32eb5e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*213anULxFh4E3XUP"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@thomaskinto?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Thomas Kinto</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c687" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">invokeMap</h1><p id="6099" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">Lodash <code class="fe lz ma mb mc b">invokeMap</code>方法映射一个数组的值，并根据我们作为参数传入的内容返回它。</p><p id="3323" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Lodash <code class="fe lz ma mb mc b">invokeMap</code>接受一个带有函数名的字符串或一个要在每个集合条目上调用的函数。这也需要一个论据来支持论据。</p><p id="8c7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下实现它:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="ac2d" class="mq lc iq mc b gy mr ms l mt mu">const invokeMap = (arr, fn, ...args) =&gt; arr.map(a =&gt; fn.apply(a, args))</span></pre><p id="261d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们使用rest操作符将<code class="fe lz ma mb mc b">args</code>扩展到一个数组中。然后我们调用<code class="fe lz ma mb mc b">arr</code>上的<code class="fe lz ma mb mc b">map</code>来映射每个条目，方法是调用<code class="fe lz ma mb mc b">fn</code>上的<code class="fe lz ma mb mc b">apply</code>来映射带有指定函数的值。</p><p id="00c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们保持简单，只假设<code class="fe lz ma mb mc b">fn</code>是一个函数，不像Lodash版本。</p><p id="3ed6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么当我们这样称呼<code class="fe lz ma mb mc b">invokeMap</code>时:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="4a33" class="mq lc iq mc b gy mr ms l mt mu">const result = invokeMap([123, 456], String.prototype.split, '')</span></pre><p id="891b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得出<code class="fe lz ma mb mc b">result</code>是:</p><pre class="mi mj mk ml gt mm mc mn mo aw mp bi"><span id="f794" class="mq lc iq mc b gy mr ms l mt mu">[<br/>  [<br/>    "1",<br/>    "2",<br/>    "3"<br/>  ],<br/>  [<br/>    "4",<br/>    "5",<br/>    "6"<br/>  ]<br/>]</span></pre><p id="434e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为我们把数字分成了子串。</p><h1 id="51c4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="89ed" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lz ma mb mc b">flatMap</code>系列方法可以用<code class="fe lz ma mb mc b">map</code>和<code class="fe lz ma mb mc b">flat</code>方法实现。</p><p id="0f06" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要实现<code class="fe lz ma mb mc b">groupBy</code>方法，我们只需通过在每个数组条目上调用<code class="fe lz ma mb mc b">iteratee</code>函数来填充一个对象，然后将它们作为键填充。这些值将是原始值，当我们对它调用<code class="fe lz ma mb mc b">iteratee</code>时，它们将返回与键相同的值。</p><p id="6da0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用普通JavaScript的<code class="fe lz ma mb mc b">includes</code>方法来实现我们自己的Lodash的<code class="fe lz ma mb mc b">includes</code>。</p><p id="97c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，<code class="fe lz ma mb mc b">invokeMap</code>可以通过使用rest操作符将参数分散到一个数组中，然后使用<code class="fe lz ma mb mc b">apply</code>在每个条目上调用传入的函数来实现。</p><h2 id="34b0" class="mq lc iq bd ld mw mx dn lh my mz dp ll ko na nb lp ks nc nd lt kw ne nf lx ng bi translated">来自简明英语团队的说明</h2><p id="140a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个follow来表达爱意:<a class="ae kc" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kf ir">JavaScript in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a>，<a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！我们还推出了一个YouTube，希望你能通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的英语频道</strong> </a>来支持我们</p><p id="dc87" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往,“简明英语”希望帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>