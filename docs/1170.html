<html>
<head>
<title>React, Vue, and Business Logic</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">反应、Vue和业务逻辑</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-vue-and-business-logic-19df105698a2?source=collection_archive---------1-----------------------#2020-02-07">https://javascript.plainenglish.io/react-vue-and-business-logic-19df105698a2?source=collection_archive---------1-----------------------#2020-02-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a2f0" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我的前端世界清洁建筑之路</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/3448211f46e9b24d1a42b7a8ca07e8e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*TheL5CNzq56DsyBr"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@williambout?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">William Bout</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9d2b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们热爱UI，不是吗？我是说UI开发。毕竟，我们中许多必须处理JavaScript和React.js和Vue.js等库的人都是UI开发人员。漂亮的、经过深思熟虑的UI提供了出色的用户体验，这让我们为自己的工作感到自豪。</p><p id="cb64" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我推测这是许多前端开发人员陷入React或Vue等标准库陷阱的主要原因之一。很容易陷入UI 占优势的<em class="lp">误区。</em></p><p id="7818" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">很多年前，在组件库在前端世界占据主导地位之前，使用<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes" rel="noopener ugc nofollow" target="_blank">“数据-”属性</a>在DOM元素中存储重要的业务数据是一个常见的错误。沿着这条滑坡很容易。毕竟，元素中就有一个属性，放入(以及稍后访问)产品的id甚至(上帝禁止！)用户的密码，只需调用:$()。数据()。简单错误。</p><p id="058f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">数据集属性从来不是用来存储业务数据的。它们是DOM API的一部分。而DOM一直在应用尺度上的那一部分，叫做“视图”、“展现”、“UI”。它与您的应用程序的业务逻辑无关。它的存在只是为了向用户展示这个逻辑的结果，并从他们那里收集反馈。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi lx"><img src="../Images/8933e4fa3854e49902a096a7f2866351.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*y6C4nSvy2Woe0m7bWEn4BA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae ks" href="https://et.wikipedia.org/wiki/Fail:React_Native_Logo.png" rel="noopener ugc nofollow" target="_blank">wikipedia.org</a></figcaption></figure><p id="b289" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">React和Vue没什么区别。它们的存在是为了帮助你构建<em class="lp"> UI </em>(或者相反，让它变得更困难——取决于你的前端宗教)。不多不少。<strong class="kv io">但是UI不重要</strong>。</p><p id="7d53" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">是的，可能是审美上的愉悦；它可能会大量销售你的产品。但是糟糕的UI会很快毁掉你的整个公司。这些从营销、美学、销售角度来看都是真的。</p><p id="2001" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是从软件架构的角度来看，UI是次要的。<strong class="kv io">数据和逻辑，</strong>另一方面<strong class="kv io">，是必不可少的</strong>。它们决定了软件的实用唯一性，是软件最有价值的部分。</p><p id="80db" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我想，作为一个理性的专业人士，你会尽可能地保护程序中最有价值的部分。有许多方法可以做到这一点。首先，你可以保护它免受<em class="lp">你的</em>bug。当然，最好的方法之一就是测试。没有什么比100%的测试覆盖率更能给我们带来美好明天的希望了。</p><p id="7b33" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">其次，您可以保护应用程序的核心免受其他人的错误。作为一名专业开发人员，在允许一个来自未知发行商的库v0.0.1触及您神圣的业务规则之前，您可能会三思而行。毕竟，如果我们想要健康，我们就要远离垃圾食品。出于同样的原因，我们应该远离我们不确定的外部库。</p><p id="1058" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第三，我会让你的注意力暂时集中在这一点上，我们应该保护我们有价值的应用核心免受不合理的改变。多年来，鲍勃大叔在书籍、文章、会议和聚会上一直在说这个简单却至关重要的真理。然而，我们仍然无视他的伟大建议。不相信我？试着回忆一下您在源代码中见过多少次这样的事情:</p><pre class="kd ke kf kg gt ly lz ma mb aw mc bi"><span id="e606" class="md me in lz b gy mf mg l mh mi">componentDidMount() {</span><span id="e258" class="md me in lz b gy mj mg l mh mi">   axios.get(‘/articles/’)</span><span id="78ef" class="md me in lz b gy mj mg l mh mi">}</span></pre><p id="130a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">或者</p><pre class="kd ke kf kg gt ly lz ma mb aw mc bi"><span id="23b0" class="md me in lz b gy mf mg l mh mi">methods: {</span><span id="cd87" class="md me in lz b gy mj mg l mh mi">  calculateDiscount(){</span><span id="675f" class="md me in lz b gy mj mg l mh mi">    // actual code that <br/>    // makes business-critical calculations <br/>    // for the price of the product</span><span id="a3e7" class="md me in lz b gy mj mg l mh mi">  }</span><span id="fe6b" class="md me in lz b gy mj mg l mh mi">}</span></pre><p id="0fff" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我见过很多。其中很多是我自己写的。这很容易落入这个陷阱，因为我们被告知我们的组件应该是<em class="lp">智能</em>。当然，不是所有的都是，还有“哑的”、“功能的”、“无状态的”、“表象的”成分。他们是不同的。它们仅用于UI目的。它们不包含任何业务逻辑。</p><p id="04c6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是有一群“智能的”、“有状态的”组件。为了在精神上将它们与“UI组件”分开，我们有时甚至称它们为“容器”。很容易得出结论，“哦，那么这意味着我们应该将我们的业务逻辑放在这些“智能”组件中！”。但是现在你至少有两个问题。</p><p id="903d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，您的业务逻辑现在是<em class="lp">加上UI </em>。我们可以随意称呼智能组件(甚至是“容器”或“高阶函数”)，但它们仍然是UI的一部分。</p><p id="5252" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">原因很简单，因为这些组件要么直接呈现DOM(例如React/Vue组件)，要么与这样做的组件紧密耦合(例如Redux容器)。</p><p id="d934" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">并且将业务逻辑与UI耦合是对单一责任原则的严重违反。每当您更改这些UI元素时，您都有潜在的业务逻辑更改的风险。换句话说，你的逻辑依赖于UI。</p><p id="c425" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">Bob Marting写了一整本书(“干净的代码”)解释为什么这是一个问题，如果你还没有读过，我强烈推荐你去读一读。但在这一点上，我想我们都知道。</p><p id="582a" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">第二个问题是你的应用程序的业务逻辑，软件中最有价值和最关键的部分，依赖于第三方的解决方案。用Bob叔叔的术语来说，你的应用程序已经“结合”了这个第三方库/框架。</p><p id="3f54" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">不要误解我的意思，我对框架和库本身并没有什么意见。它们可以在许多方面提供帮助:呈现一个坚实的结构，为来自不同团队的开发人员提供一种公共语言，帮助新团队成员入职，当然，还可以让您摆脱繁琐、重复的工作。但我投票支持合理使用如此强大的工具，因为它是有代价的。</p><p id="5caf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">假设我们做足了功课，没有挑最新鲜的，超辣的还没经过别人测试的(几年的生产使用！)框架。我们还非常仔细地进行了考虑，选择了对我们来说最好的解决方案，而不仅仅是最受欢迎的方案，仔细地比较了利弊。</p><p id="0d3c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">即便如此，我们现在“致力于”这个框架。这有什么不好？想象一下，新版本发布了。你知道，我们真的真的应该迁移到它，因为它修复了来自这个框架使用的npm依赖关系的25个以上的关键漏洞。或者更糟的是，团队/公司/CTO/PM/你决定从一个框架切换到另一个框架，因为…嗯，你知道… <em class="lp">原因</em>。</p><p id="14a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">现在，我们面临着<em class="lp">改变应用程序业务逻辑的风险，尽管业务的实际逻辑根本没有改变</em>。我们没有收到任何来自营销或商业分析团队的新备忘录。我们用和以前一样的方法计算折扣。我们获取相同的API。我们这边什么都没变，但我们必须做出改变。因此，我们再次违反单一责任原则，并为此付出代价。</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mk"><img src="../Images/c0de0bfa93be545753245bd42c2a11b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EdiFUfbTNmk_IxFDNqokqg.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae ks" href="https://commons.wikimedia.org/wiki/File:Ngrx-redux-pattern-diagram.png" rel="noopener ugc nofollow" target="_blank">wikimedia.org</a></figcaption></figure><p id="5dbb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">好吧，但是我们很多人都经历过这个阶段。我们确实意识到UI必须与业务规则相分离。也许我们甚至开始欣赏MV-*模式(又来了？).而且我们早就听说过<em class="lp">州管理</em>和<em class="lp">T7<em class="lp">全局的好处，于是决定</em>集中起来“啊！现在我知道该怎么做了！”。</em></p><p id="e5a1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们学习动作和突变/减少因子。我们知道全能的商店是真理的源泉。我们决定将我们的折扣计算，我们的API请求转移到动作和变化上。我们勇敢地回答面试问题，比如“我们应该从哪里获取请求:组件加载还是动作？”挑选最新的。这很有道理:Store不是UI，对吗？我们通过分离关注点来完成我们的工作！</p><p id="d252" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我们意识到显而易见但不知何故隐藏在真相之前时，问题就开始出现了。商店只有一个责任:<em class="lp">存储数据</em>。与商业逻辑无关。它不关心如何、从哪里以及为什么获取数据。它只负责存储并明确地提供给UI。这仅仅是数据库的一个特例。因此，通过混合逻辑和存储，我们违反了关注点分离原则，不符合它。</p><p id="598b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">还有另一个问题。和我们之前面对的一样。我们<em class="lp">将我们亲爱的业务逻辑与Flux/Redux/Vuex </em>或任何其他第三方解决方案结合起来。我们之前讨论的所有问题又潜伏在黑暗中。停下来，回答自己这个问题:“如果明天我必须更改Store solution(例如，将Redux改为Vuex)，我的应用程序的业务逻辑会受到多大的影响？我有多少宝贵的业务规则需要重写，而业务却一点也没有改变？”</p></div><div class="ab cl lq lr hr ls" role="separator"><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv lw"/><span class="lt bw bk lu lv"/></div><div class="ig ih ii ij ik"><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ml"><img src="../Images/6864efb950b0bc6ed5b9284170d6e402.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*6uOVpynWFSmMZvuP"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@olav_ahrens?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Olav Ahrens Røtne</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e6b5" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有什么解决办法？再一次，鲍伯·马丁<a class="ae ks" href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" rel="noopener ugc nofollow" target="_blank">在很久以前回答了</a>:<em class="lp">保持你的业务逻辑无依赖性</em>。将<em class="lp">很少甚至没有第三方库用于你的关键任务代码片段</em>。确保<em class="lp">除了业务规则</em>的改变之外，没有其他原因让他们改变。就这么简单。</p><p id="3c4c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">哦，顺便说一句，无依赖代码更容易测试。我们确实希望我们的重要代码得到尽可能多的测试，对吗？</p></div></div>    
</body>
</html>