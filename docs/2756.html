<html>
<head>
<title>useRef in React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React中的useRef</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/implementing-useref-in-react-732908aa1998?source=collection_archive---------1-----------------------#2020-07-21">https://javascript.plainenglish.io/implementing-useref-in-react-732908aa1998?source=collection_archive---------1-----------------------#2020-07-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="913e" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">用户参考文献简介</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/76a1b05f1c26511927b67e6db5ec0734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*8wctPggHf--3OCrH"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by Clement H. (Unsplash)</figcaption></figure><p id="8b13" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在做一个个人项目的时候，我实现了<code class="fe lr ls lt lu b">useRef</code>。它是React提供的一个钩子，相当于与类组件一起使用的<code class="fe lr ls lt lu b">createRef</code>。</p><blockquote class="lv lw lx"><p id="886c" class="kv kw ly kx b ky kz jr la lb lc ju ld lz lf lg lh ma lj lk ll mb ln lo lp lq ij bi translated"><code class="fe lr ls lt lu b">useRef</code>钩子是一个函数，它返回一个可变的<code class="fe lr ls lt lu b">ref</code>对象，该对象的<code class="fe lr ls lt lu b">.current</code>属性用一个参数初始化，(<code class="fe lr ls lt lu b">initialValue</code>)。返回的对象将在组件的整个生存期内保持不变。(<a class="ae mc" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank">挂钩参考</a>)</p></blockquote><pre class="kg kh ki kj gt md lu me mf aw mg bi"><span id="7e14" class="mh mi iq lu b gy mj mk l ml mm">const refContainer = useRef(initialValue);</span></pre><p id="45af" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我的项目中,<code class="fe lr ls lt lu b">useRef</code>钩子有两个主要用途:访问DOM节点/元素和存储可变信息。让我们探索如何在React应用程序中实现<code class="fe lr ls lt lu b">useRef</code>。</p><h1 id="27d5" class="mn mi iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">访问DOM节点/元素</h1><p id="4e92" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">在进一步潜水之前，我们先讨论一下<code class="fe lr ls lt lu b">ref</code>是什么。它是一个用在HTML元素或组件标签上的属性。它为我们提供了一种在React中引用DOM节点的方法。</p><p id="fbe3" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">下面是一个在<code class="fe lr ls lt lu b">div</code>元素中使用<code class="fe lr ls lt lu b">ref</code>的例子。</p><pre class="kg kh ki kj gt md lu me mf aw mg bi"><span id="d8c3" class="mh mi iq lu b gy mj mk l ml mm">&lt;div className="sample" ref={divRef}&gt;Sample Div&lt;/div&gt;</span></pre><p id="47c2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">还可以在React组件内部使用<code class="fe lr ls lt lu b">ref</code>,但是只能使用父组件的render方法。</p><pre class="kg kh ki kj gt md lu me mf aw mg bi"><span id="7d4c" class="mh mi iq lu b gy mj mk l ml mm">&lt;DivComponent ref={divComponentRef} /&gt;</span></pre><p id="5828" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在常规Javascript中，这相当于语法，</p><pre class="kg kh ki kj gt md lu me mf aw mg bi"><span id="4beb" class="mh mi iq lu b gy mj mk l ml mm">const divElement = document.querySelector(".sample")</span></pre><h2 id="03ef" class="mh mi iq bd mo nj nk dn ms nl nm dp mw le nn no my li np nq na lm nr ns nc nt bi translated">useRef和Ref的示例</h2><p id="9ec1" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">在React中，<code class="fe lr ls lt lu b">ref</code>属性将允许我们引用该元素，并为我们提供对其方法的访问。下面是功能组件中<code class="fe lr ls lt lu b">ref</code>和<code class="fe lr ls lt lu b">useRef</code>的示例。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="b484" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们有两个DOM元素，<code class="fe lr ls lt lu b">input</code>和<code class="fe lr ls lt lu b">button</code>。在按钮上，我们提供了一个带有回调函数<code class="fe lr ls lt lu b">buttonClick</code>的事件处理程序<code class="fe lr ls lt lu b">onClick</code>。当我们将一个ref对象传递给<code class="fe lr ls lt lu b">input</code>时，React会将<code class="fe lr ls lt lu b">.current</code>属性设置为相应的DOM节点。因此，当我们为<code class="fe lr ls lt lu b">textInputRef</code>创建<code class="fe lr ls lt lu b">useRef</code>时，我们可以传入<code class="fe lr ls lt lu b">null</code>或者什么都不传。</p><p id="6d8c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">像<code class="fe lr ls lt lu b">.focus()</code>方法一样，<code class="fe lr ls lt lu b">textInputRef.current</code>将可以访问<code class="fe lr ls lt lu b">input</code>元素的方法。当点击<code class="fe lr ls lt lu b">button</code>时，回调函数调用那个<code class="fe lr ls lt lu b">.focus()</code>方法，该方法聚焦在<code class="fe lr ls lt lu b">input</code>元素上。</p><h2 id="4ba7" class="mh mi iq bd mo nj nk dn ms nl nm dp mw le nn no my li np nq na lm nr ns nc nt bi translated">转发参考</h2><p id="3a6c" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">假设<code class="fe lr ls lt lu b">input</code>是组件内部的一个元素，但是<code class="fe lr ls lt lu b">textInputRef</code>仍然会在<code class="fe lr ls lt lu b">SampleComponent</code>中被引用。简单地传入一个<code class="fe lr ls lt lu b">textInputRef</code>作为组件的支撑本身是不行的。为了将它传递下去，我们必须利用React的另一个资源，<code class="fe lr ls lt lu b">forwardRef</code>。</p><blockquote class="lv lw lx"><p id="63c2" class="kv kw ly kx b ky kz jr la lb lc ju ld lz lf lg lh ma lj lk ll mb ln lo lp lq ij bi translated">React forwarding是一个选择性加入的特性，它允许一些组件接受它们接收到的ref，并将其进一步传递给子组件。(<a class="ae mc" href="https://reactjs.org/docs/forwarding-refs.html" rel="noopener ugc nofollow" target="_blank">反应参考转发文件</a>)</p></blockquote><p id="aa58" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们来看看这个会是什么样子。让我们重新构建我们之前的例子。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">SampleComponent.js</figcaption></figure><p id="01fb" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这个例子中，我们已经删除了<code class="fe lr ls lt lu b">input</code>元素，并用一个导入的组件<code class="fe lr ls lt lu b">AnotherComponent</code>替换了它。如前所述，我们可以利用组件上的<code class="fe lr ls lt lu b">ref</code>属性，并且我们正在传入<code class="fe lr ls lt lu b">textInputRef</code>。现在让我们探索一下<code class="fe lr ls lt lu b">AnotherComponent</code>由什么组成。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">AnotherComponent.js</figcaption></figure><p id="b892" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">该组件包含一个<code class="fe lr ls lt lu b">h1</code>元素和我们之前使用的原始<code class="fe lr ls lt lu b">input</code>元素。您可能会注意到函数所在的<code class="fe lr ls lt lu b">React.forwardRef()</code>。该函数接收从父组件传递来的参数<code class="fe lr ls lt lu b">props</code>和<code class="fe lr ls lt lu b">ref</code>。</p><p id="6979" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用<code class="fe lr ls lt lu b">ref</code>的第二个参数只在使用<code class="fe lr ls lt lu b">React.forwardRef()</code>调用定义组件时存在。常规函数或类组件不会收到<code class="fe lr ls lt lu b">ref</code>参数，也不会出现在<code class="fe lr ls lt lu b">props</code>中。<code class="fe lr ls lt lu b">ref</code>参数用于<code class="fe lr ls lt lu b">input</code> <code class="fe lr ls lt lu b">ref</code>属性，其作用与之前一样，即<code class="fe lr ls lt lu b">SampleComponent</code>中的<code class="fe lr ls lt lu b">textInputRef.current</code>引用了<code class="fe lr ls lt lu b">input</code>。</p><h1 id="b443" class="mn mi iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">存储可变信息</h1><p id="7e97" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">钩子不仅仅用于DOM引用。ref对象是一个通用容器，它的<code class="fe lr ls lt lu b">.current</code>属性是可变的，可以保存任何值，类似于类的实例属性(<a class="ae mc" href="https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables" rel="noopener ugc nofollow" target="_blank"> Hooks FAQ </a>)。</p><p id="6210" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在React组件中，有两种方法可以在重新渲染之间保存数据:</p><ul class=""><li id="2993" class="nw nx iq kx b ky kz lb lc le ny li nz lm oa lq ob oc od oe bi translated">在一个<code class="fe lr ls lt lu b">state</code>变量中，更新状态将导致组件的重新呈现，</li><li id="8292" class="nw nx iq kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated">在<code class="fe lr ls lt lu b">ref</code>中，改变<code class="fe lr ls lt lu b">.current</code>属性不会导致重新渲染。</li></ul><p id="3d91" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">它们的共同点是，在任何重新渲染之后，它们都能记住它们的数据。更好的问题是我们什么时候会真正使用<code class="fe lr ls lt lu b">useRef</code>而不是<code class="fe lr ls lt lu b">useState</code>？存储数据时，React应用程序可能不需要重新呈现所有内容。假设我们有以下的例子:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nu nv l"/></div></figure><p id="cab7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里，我们同时使用了<code class="fe lr ls lt lu b">useState</code>和<code class="fe lr ls lt lu b">useRef</code>。<code class="fe lr ls lt lu b">message</code>状态负责跟踪我们在<code class="fe lr ls lt lu b">input</code>标签中输入的内容，这需要重新呈现组件以更新显示在<code class="fe lr ls lt lu b">input</code>字段中的消息。<code class="fe lr ls lt lu b">sentMessage</code> ref跟踪发送的消息数量，这不一定需要触发重新呈现。</p><p id="9fdc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">注意<code class="fe lr ls lt lu b">useRef</code>值是如何改变的。它没有像<code class="fe lr ls lt lu b">useState</code>那样自带一套方法。要更改该值，我们将直接重新分配存储在<code class="fe lr ls lt lu b">useRef</code>的<code class="fe lr ls lt lu b">.current</code>属性中的值。重要的一点是，改变<code class="fe lr ls lt lu b">ref</code>是一种副作用，应该在使用React钩子时在<code class="fe lr ls lt lu b">useLayoutEffect</code>或<code class="fe lr ls lt lu b">useEffect</code>内部完成。</p><h1 id="3fc4" class="mn mi iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">摘要</h1><p id="1fc1" class="pw-post-body-paragraph kv kw iq kx b ky ne jr la lb nf ju ld le ng lg lh li nh lk ll lm ni lo lp lq ij bi translated">钩子允许我们在函数组件中创建可变变量。这对于访问DOM节点/React元素，以及存储可变变量而不触发重新呈现非常有用。<code class="fe lr ls lt lu b">useRef</code>更像是一个逃生出口，应该只在必要的时候使用，尤其是当它可以通过声明来完成的时候。</p><p id="c9db" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">本指南是对<code class="fe lr ls lt lu b">useRef</code>挂钩的快速介绍。钩子的其他实现和用例可以在React文档中引用。</p><p id="b7f8" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢您的阅读！</p><h1 id="de4c" class="mn mi iq bd mo mp mq mr ms mt mu mv mw jw mx jx my jz mz ka na kc nb kd nc nd bi translated">参考</h1><ul class=""><li id="e1ec" class="nw nx iq kx b ky ne lb nf le ok li ol lm om lq ob oc od oe bi translated"><a class="ae mc" href="https://reactjs.org/docs/refs-and-the-dom.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/refs-and-the-dom.html</a></li><li id="e221" class="nw nx iq kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated">https://reactjs.org/docs/hooks-reference.html#useref<a class="ae mc" href="https://reactjs.org/docs/hooks-reference.html#useref" rel="noopener ugc nofollow" target="_blank"/></li><li id="cc29" class="nw nx iq kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated"><a class="ae mc" href="https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables" rel="noopener ugc nofollow" target="_blank">https://react js . org/docs/hooks-FAQ . html # is-there-something-like-instance-variables</a></li><li id="299b" class="nw nx iq kx b ky of lb og le oh li oi lm oj lq ob oc od oe bi translated"><a class="ae mc" href="https://reactjs.org/docs/forwarding-refs.html" rel="noopener ugc nofollow" target="_blank">https://reactjs.org/docs/forwarding-refs.html</a></li></ul></div></div>    
</body>
</html>