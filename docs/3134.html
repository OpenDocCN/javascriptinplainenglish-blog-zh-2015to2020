<html>
<head>
<title>A Quick Vue3 Infinite Scrolling Component — Daily Vue Tips #4</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速Vue3无限滚动组件—每日Vue提示#4</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-quick-vue3-infinite-scrolling-component-daily-vue-tips-4-20c7052ccda4?source=collection_archive---------5-----------------------#2020-09-01">https://javascript.plainenglish.io/a-quick-vue3-infinite-scrolling-component-daily-vue-tips-4-20c7052ccda4?source=collection_archive---------5-----------------------#2020-09-01</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/17f66ddffba5fe92ca3d8969907f6750.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*d5XRV23El9GNI_gEthSekA.png"/></div></div></figure><div class=""/><p id="5b1f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你发现自己在社交媒体上呆的时间太长，那么你所在的网站很可能使用了一个无限滚动组件。</p><p id="7c6d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无限滚动组件是指当用户向下滚动页面时加载新内容，而不是将其分成多个页面。</p><p id="9636" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">它们对于特定类型的内容(如用户生成的内容)非常有效。</p><p id="2886" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这里有一个无限滚动的例子。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi kw"><img src="../Images/c03d1028c9ab29f41f41c9fdcf140fa3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*pMwWqMAnMoohFoTV.png"/></div></div><figcaption class="lb lc gj gh gi ld le bd b be z dk"><a class="ae lf" href="https://addyosmani.com" rel="noopener ugc nofollow" target="_blank">https://addyosmani.com</a></figcaption></figure><p id="8641" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">在本教程中，我们将使用<a class="ae lf" href="https://learnvue.co/2020/01/4-vue3-composition-api-tips-you-should-know/" rel="noopener ugc nofollow" target="_blank">组合API </a>创建一个Vue3无限滚动组件。这里先睹为快，看看我们最终会构建什么。如你所见，它无限滚动，屏幕右侧的滚动条反映了这一点。</p><figure class="kx ky kz la gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi lg"><img src="../Images/77a9ae53cbd67173ab72b6f64a2db8da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BeobLBv2WKd0x8Jx.gif"/></div></div></figure><p id="5639" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated"><a class="ae lf" href="https://matthewmaribojoc.github.io/learnvue-tutorials/tutorials/vue-infinite-scrolling" rel="noopener ugc nofollow" target="_blank">现场演示</a></p><p id="faea" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">好吧，让我们直接开始吧。</p><h2 id="f1fb" class="lh li jb bd lj lk ll dn lm ln lo dp lp kj lq lr ls kn lt lu lv kr lw lx ly lz bi translated">为什么还要使用无限滚动组件？</h2><p id="c0d8" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">我们都见过使用无限滚动来显示内容的网站的例子，但是什么时候这比使用典型的分页系统更好呢？</p><p id="2362" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">Nick Babich有一篇关于无限滚动/分页的利弊的文章。我绝对推荐读一读，不过我总结一下要点。</p><p id="845f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无限滚动的优点:</p><ul class=""><li id="0c8b" class="mf mg jb ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">用户参与和内容发现</li><li id="d502" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">滚动比点击更好(更好的可用性)</li><li id="6b40" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">滚动对移动设备有好处</li></ul><p id="db8e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">无限滚动的缺点:</p><ul class=""><li id="758d" class="mf mg jb ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">页面性能和设备资源</li><li id="03e0" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">项目搜索和定位——用户不能将页面加入书签并保留位置</li><li id="4bd5" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">无关滚动条</li></ul><p id="826d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">像所有web开发的事情一样，选择任何一个选项都有正当的理由。只是一定要考虑哪个最适合你的网站！</p><p id="c406" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">不管怎样，学习如何构建一个Vue3无限滚动组件是非常有趣的，而且将来可能会对你有用。</p><h2 id="6a69" class="lh li jb bd lj lk ll dn lm ln lo dp lp kj lq lr ls kn lt lu lv kr lw lx ly lz bi translated">好吧。让我们按时到达。</h2><p id="c862" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">首先，让我们从较高的层面来看一下这个系统是如何工作的。</p><p id="d9cb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">将有三个主要部分:</p><ol class=""><li id="038b" class="mf mg jb ka b kb kc kf kg kj mh kn mi kr mj kv mt ml mm mn bi translated">生成帖子的模拟API调用</li><li id="3c9d" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv mt ml mm mn bi translated">呈现单个帖子的后置组件</li><li id="773f" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv mt ml mm mn bi translated">ListComponent包含所有的post组件并处理从API加载post</li></ol><h2 id="50a6" class="lh li jb bd lj lk ll dn lm ln lo dp lp kj lq lr ls kn lt lu lv kr lw lx ly lz bi translated">模仿API调用</h2><p id="a951" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">对于本教程，我们将编写一个返回硬编码数据的伪API调用。如果你在一个真实的后台和数据库中实现它，重要的是你可以根据数据库的大小和位置来决定限制你的结果。</p><p id="9d05" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个API调用可以是任何东西，从简单应用程序中的简单数据库查询，一直到更高级应用程序中的复杂推荐算法。</p><p id="9443" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">以下是社交媒体网站常用的内容加载算法的一些不同想法:</p><ul class=""><li id="3bbc" class="mf mg jb ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">发布日期</li><li id="35e2" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">与当前用户的相关性</li><li id="ec40" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">帖子上的活动</li></ul><p id="0853" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">然而，为了简单起见，我们的算法将只生成随机的帖子数据，并根据给定的参数返回X个帖子。</p><pre class="kx ky kz la gt mu mv mw mx aw my bi"><span id="13bb" class="lh li jb mv b gy mz na l nb nc">var names = ['Matt Maribojoc', 'Lebron James', 'Bill Gates', 'Childish Gambino'] // used to generate posts for this tutorial<br/><br/>const getPosts = (number) =&gt; {<br/>	// generate a number of posts<br/>	// in a real setting, this would be a database call or algorithm<br/><br/>	let ret = []<br/><br/>	for (var i = 0; i &lt; number; i++) {<br/>		ret.push({<br/>			author: names[i % names.length],<br/>			content: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do.'<br/>		})<br/>	}	<br/><br/>	return ret<br/>}<br/><br/>export default getPosts</span></pre><h2 id="898e" class="lh li jb bd lj lk ll dn lm ln lo dp lp kj lq lr ls kn lt lu lv kr lw lx ly lz bi translated">制作我们的post组件</h2><p id="a1de" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">既然我们已经有了生成帖子的方法，让我们创建一个组件来呈现它们。</p><p id="0c26" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这段代码没有任何花哨的地方，我们只需通过组件的道具接收帖子，然后呈现作者和内容。这里也有一些风格来美化一些东西。</p><pre class="kx ky kz la gt mu mv mw mx aw my bi"><span id="3c0f" class="lh li jb mv b gy mz na l nb nc">&lt;template&gt;<br/>	&lt;div class='post'&gt;<br/>		&lt;h2&gt; {{ post.author }} &lt;/h2&gt;<br/>		&lt;p&gt; {{ post.content }} &lt;/p&gt;<br/>	&lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;<br/>export default {<br/>	props: {<br/>		post: Object<br/>	}<br/>}<br/>&lt;/script&gt;<br/>&lt;style scoped&gt;<br/>	.post {<br/>		background: #fff;<br/>		padding: 1.5em;<br/>	}<br/><br/>	.post:not(:last-child) {<br/>		border-bottom: 1px solid #ddd;<br/>	}<br/><br/>	.post h2 {<br/>		font-size: 1.3em;<br/>		padding-bottom: 0.25rem;<br/>	}<br/><br/>	.post p {<br/>		color: #888;<br/>	}<br/>&lt;/style&gt;</span></pre><h2 id="43d6" class="lh li jb bd lj lk ll dn lm ln lo dp lp kj lq lr ls kn lt lu lv kr lw lx ly lz bi translated">显示我们的帖子</h2><p id="ec86" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">接下来，让我们实际上弄清楚如何在屏幕上显示一些帖子。这就是<code class="fe nd ne nf mv b">ListComponent.vue</code>组件派上用场的地方。</p><p id="72d2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你没有任何Vue3的经验，这段代码可能会让你觉得有点奇怪。但是看看这个<a class="ae lf" href="https://learnvue.co/2020/01/a-first-look-at-vue3-alpha-release-example-app-in-15-minutes/" rel="noopener ugc nofollow" target="_blank">vue 3</a>入门指南。</p><p id="bba5" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">简而言之，Vue3用组合API替换了选项API，这意味着代码(<a class="ae lf" href="https://learnvue.co/2020/03/how-to-use-lifecycle-hooks-in-vue3/" rel="noopener ugc nofollow" target="_blank">生命周期挂钩</a>，数据等)都被组织在一个<code class="fe nd ne nf mv b">setup</code>方法中。</p><p id="4b0d" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，我们想导入一些东西:</p><ul class=""><li id="40ad" class="mf mg jb ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">我们的API调用</li><li id="c92a" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">我们的后组件</li><li id="d78f" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><code class="fe nd ne nf mv b">ref</code>用于创建反应数据</li><li id="f95c" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated"><code class="fe nd ne nf mv b">onMounted</code>和<code class="fe nd ne nf mv b">onUnmounted</code>来访问这些生命周期挂钩</li></ul><pre class="kx ky kz la gt mu mv mw mx aw my bi"><span id="135f" class="lh li jb mv b gy mz na l nb nc">import PostComponent from './PostComponent.vue'<br/>import { ref, onMounted, onUnmounted } from 'vue'<br/>import getPosts from '../scripts/post-loader'</span></pre><p id="c108" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">接下来，在我们的设置方法中——我们想要设置一个反应性的posts变量来调用我们的<code class="fe nd ne nf mv b">getPosts</code> API调用。不要忘记返回它，以便我们的模板可以访问它！</p><pre class="kx ky kz la gt mu mv mw mx aw my bi"><span id="7a7f" class="lh li jb mv b gy mz na l nb nc">setup () {<br/><br/>		const posts = ref(getPosts(10))<br/><br/>		return {<br/>			posts,<br/>		}<br/>}</span></pre><p id="abfb" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">最后，为了在模板中显示我们的数据，我们想运行一个<code class="fe nd ne nf mv b">v-for</code>循环来遍历我们的帖子，并为每个帖子呈现一个后置组件。我们的模板应该是这样的(注意<code class="fe nd ne nf mv b">.list-component</code>有一个引用，我们稍后会讲到)</p><pre class="kx ky kz la gt mu mv mw mx aw my bi"><span id="4fbd" class="lh li jb mv b gy mz na l nb nc">&lt;template&gt;<br/>	&lt;div class='scrolling-component' ref='scrollComponent'&gt;<br/>		&lt;post-component v-for='post in posts' :post="post" /&gt;<br/>	&lt;/div&gt;<br/>&lt;/template&gt;<br/>&lt;script&gt;</span></pre><p id="f628" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们当前的页面应该呈现10个帖子，看起来像这样。</p><p id="0348" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">但是如果我们滚动到底部，什么也不会发生。所以让我们进入激动人心的部分:无限滚动！</p><h2 id="e491" class="lh li jb bd lj lk ll dn lm ln lo dp lp kj lq lr ls kn lt lu lv kr lw lx ly lz bi translated">处理Vue3无限滚动</h2><p id="22c4" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">现在我们已经设置好了一切，当用户向下滚动到文章底部时，我们可以开始加载更多的数据。</p><p id="49b7" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">让我们首先创建一个方法，一次加载10篇文章，并将它们附加到我们的posts变量中。</p><pre class="kx ky kz la gt mu mv mw mx aw my bi"><span id="e411" class="lh li jb mv b gy mz na l nb nc">setup () {<br/><br/>		// ...<br/><br/>		const loadMorePosts = () =&gt; {<br/>			let newPosts = getPosts(10)<br/>			console.log(newPosts)<br/>			posts.value.push(...newPosts)<br/>		}<br/>  // ...<br/>}</span></pre><p id="f94a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">现在，我们只需要一个方法来触发这个方法。我们将通过添加一个事件侦听器来实现这一点，该侦听器侦听一个滚动事件并调用一个方法。我们将在安装组件时添加它，在卸载(销毁)组件时删除它。</p><pre class="kx ky kz la gt mu mv mw mx aw my bi"><span id="5d61" class="lh li jb mv b gy mz na l nb nc">setup () {<br/><br/>		// ... <br/><br/>		onMounted(() =&gt; {<br/>			window.addEventListener("scroll", handleScroll)<br/>		})<br/><br/>		onUnmounted(() =&gt; {<br/>			window.removeEventListener("scroll", handleScroll)<br/>		})<br/>const handleScroll = (e) =&gt; {<br/>			<br/>		}<br/>                // ...<br/>}</span></pre><p id="cb94" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">太好了。我们已经准备好开始加载更多的帖子。如果您还记得上一节，我们向<code class="fe nd ne nf mv b">.list-component </code>元素添加了一个refs属性。如果你以前在Vue中使用过refs，这是一个熟悉的概念，但是我们在Vue3中设置它们的方式有点不同。</p><p id="0209" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我们将再次使用<code class="fe nd ne nf mv b">refs</code>方法实例化我们的ref，然后从我们的setup方法返回它。</p><pre class="kx ky kz la gt mu mv mw mx aw my bi"><span id="a001" class="lh li jb mv b gy mz na l nb nc">setup () {<br/><br/>		const posts = ref(getPosts(10))<br/>		const scrollComponent = ref(null)<br/>return {<br/>			posts,<br/>			scrollComponent<br/>		}<br/>}</span></pre><p id="aa1f" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">通过使用<code class="fe nd ne nf mv b">refs</code>访问我们的元素，我们可以完成我们的方法来确定我们是否被滚动到我们内容的底部。</p><p id="1a7a" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">下面的代码检查内容的底部在屏幕上是否可见。如果是，我们调用我们的方法来加载更多的帖子！</p><pre class="kx ky kz la gt mu mv mw mx aw my bi"><span id="b456" class="lh li jb mv b gy mz na l nb nc">const handleScroll = (e) =&gt; {<br/>			let element = scrollComponent.value<br/>			if ( element.getBoundingClientRect().bottom &lt; window.innerHeight ) {<br/>				loadMorePosts()<br/>			}<br/>		}</span></pre><p id="1ba9" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">就是这样！当我们向下滚动到当前帖子的底部时，新帖子应该会自动加载进来。让我们看看我们有什么。</p><p id="01e2" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">完美！</p><h2 id="a575" class="lh li jb bd lj lk ll dn lm ln lo dp lp kj lq lr ls kn lt lu lv kr lw lx ly lz bi translated">无限滚动组件的可能扩展</h2><p id="a960" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">这只是对创建Vue3无限滚动组件的介绍。有很多不同的方向可以改进它。</p><p id="535e" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你在一个真实的系统中构建它，我会考虑添加一些想法。</p><ul class=""><li id="e963" class="mf mg jb ka b kb kc kf kg kj mh kn mi kr mj kv mk ml mm mn bi translated">因为API调用是异步的，所以创建一些在加载新数据时显示的<a class="ae lf" href="https://learnvue.co/2020/04/vue-skeleton-loading-screen-using-suspense-components-daily-vue-4/" rel="noopener ugc nofollow" target="_blank">加载微调器</a></li><li id="8a1b" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">创建一个更复杂的API算法，并将其连接到数据库</li><li id="45b8" class="mf mg jb ka b kb mo kf mp kj mq kn mr kr ms kv mk ml mm mn bi translated">给每篇文章添加更多的数据，并寻找新的方式来展示它</li></ul><h2 id="dcea" class="lh li jb bd lj lk ll dn lm ln lo dp lp kj lq lr ls kn lt lu lv kr lw lx ly lz bi translated">结论</h2><p id="a2e6" class="pw-post-body-paragraph jy jz jb ka b kb ma kd ke kf mb kh ki kj mc kl km kn md kp kq kr me kt ku kv ij bi translated">现在你知道了！我希望这篇教程既能帮助你适应Vue3，又能创建一个非常酷的组件。</p><p id="8468" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你想亲眼看看，这里有Github最终回购的链接。</p><p id="98f3" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你建立这个/添加任何扩展，我很想看看你做什么！炫耀你的项目或如果你有任何问题，只需留下一个答复。</p><p id="ad87" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">编码快乐！</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="8e7c" class="pw-post-body-paragraph jy jz jb ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">如果你有兴趣学习更多关于Vue 3的知识，下载我的免费的Vue 3备忘单，里面有一些基本的知识，比如组合API、Vue 3模板语法和事件处理。</p></div></div>    
</body>
</html>